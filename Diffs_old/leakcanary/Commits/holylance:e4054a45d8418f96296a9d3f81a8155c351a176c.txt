diff --git a/build.gradle b/build.gradle
index cd06185f..651eafbd 100644
--- a/build.gradle
+++ b/build.gradle
@@ -44,6 +44,7 @@ buildscript {
     classpath 'com.android.tools.build:gradle:3.4.0'
     classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.16'
     classpath 'com.github.ben-manes:gradle-versions-plugin:0.20.0'
+    classpath "org.jetbrains.dokka:dokka-gradle-plugin:0.9.18"
   }
 }
 
@@ -61,6 +62,18 @@ subprojects {
   }
 
   apply plugin: 'net.ltgt.errorprone'
+  apply plugin: 'org.jetbrains.dokka'
+
+  dokka {
+    reportUndocumented = false
+    // BuildConfig files
+    packageOptions {
+      prefix = "com.squareup.leakcanary"
+      suppress = true
+    }
+    outputFormat = 'gfm'
+    outputDirectory = "$rootDir/docs/api"
+  }
 
   tasks.withType(JavaCompile) {
     options.compilerArgs += [
diff --git a/docs/theme/main.html b/docs/theme/main.html
index 9843940b..c7a68575 100644
--- a/docs/theme/main.html
+++ b/docs/theme/main.html
@@ -2,7 +2,11 @@
 
 {% block content %}
                 {% if page.edit_url %}
-				<span style="float: right">🤔Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report</a> or <a href="{{ page.edit_url }}">edit</a> </span>
+				  {% if "/api/" in page.edit_url %}
+				<span style="float: right">🤔 Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report it</a></span>
+                  {% else %}
+				<span style="float: right">🤔 Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report</a> or <a href="{{ page.edit_url }}">edit</a></span>
+                  {% endif %}
                 {% endif %}
                 {% if not "\x3ch1" in page.content %}
                   <h1>{{ page.title | default(config.site_name, true)}}</h1>
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
index 52ca9f9c..709ad51e 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
@@ -1,24 +1,19 @@
 package leakcanary
 
+/**
+ * Used to report progress by the [HeapAnalyzer].
+ */
 interface AnalyzerProgressListener {
 
-  // These steps should be defined in the order in which they occur.
+  // These steps are defined in the order in which they occur.
   enum class Step {
-    READING_HEAP_DUMP_FILE,
     PARSING_HEAP_DUMP,
-    SCANNING_HEAP_DUMP,
-    FINDING_WATCHED_REFERENCES,
-    DEDUPLICATING_GC_ROOTS,
-    FINDING_LEAKING_REF,
-    FINDING_LEAKING_REFS,
-    FINDING_SHORTEST_PATH,
-    FINDING_SHORTEST_PATHS,
+    FINDING_LEAKING_INSTANCES,
+    FINDING_PATHS_TO_LEAKING_INSTANCES,
     FINDING_DOMINATORS,
     COMPUTING_NATIVE_RETAINED_SIZE,
     COMPUTING_RETAINED_SIZE,
-    BUILDING_LEAK_TRACE,
     BUILDING_LEAK_TRACES,
-    COMPUTING_DOMINATORS
   }
 
   fun onProgressUpdate(step: Step)
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt
new file mode 100644
index 00000000..9fb23b53
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+/**
+ * Caches values from the android.os.Build class in the heap dump.
+ */
+class AndroidBuildMirror(
+  /**
+   * Value of android.os.Build.MANUFACTURER
+   */
+  val manufacturer: String,
+  /**
+   * Value of android.os.Build.VERSION.SDK_INT
+   */
+  val sdkInt: Int
+)
+
+val HprofGraph.androidBuildMirror: AndroidBuildMirror
+  get() {
+    return context.getOrPut(AndroidBuildMirror::class.java.name) {
+      val buildClass = findClassByClassName("android.os.Build")!!
+      val versionClass = findClassByClassName("android.os.Build\$VERSION")!!
+      val manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
+      val sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
+      AndroidBuildMirror(manufacturer, sdkInt)
+    }
+  }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt
deleted file mode 100644
index 0e1eb917..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt
+++ /dev/null
@@ -1,1131 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import leakcanary.Exclusion.ExclusionType
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
-import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.Status
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import java.lang.ref.PhantomReference
-import java.lang.ref.SoftReference
-import java.lang.ref.WeakReference
-import java.util.EnumSet
-
-/**
- * The first parameter is the value of android.os.Build.MANUFACTURER and the second
- * parameter is the value of android.os.Build.VERSION.SDK_INT. Returns true if the known
- * reference should be applied on the provided manufacturer / sdk int.
- */
-typealias BuildFilter = (String, Int) -> Boolean
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- *
- * Most app developers should use [appDefaults]. However, you can also pick the
- * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
- * [buildKnownReferences]
- */
-class AndroidKnownReference private constructor(
-  val type: ExclusionType,
-  val reason: String?,
-  val status: Status,
-  val filter: BuildFilter
-) {
-
-  companion object {
-    private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
-    const val SAMSUNG = "samsung"
-    const val MOTOROLA = "motorola"
-    const val LENOVO = "LENOVO"
-    const val LG = "LGE"
-    const val NVIDIA = "NVIDIA"
-    const val MEIZU = "Meizu"
-    const val HUAWEI = "HUAWEI"
-    const val VIVO = "vivo"
-
-    /**
-     * This returns the references in the leak path that should be ignored by all on Android.
-     */
-    val androidDefaults: Set<AndroidKnownReference>
-      get() = buildKnownReferences(
-          EnumSet.of(
-              Defaults.REFERENCES,
-              Defaults.FINALIZER_WATCHDOG_DAEMON,
-              Defaults.MAIN,
-              Defaults.LEAK_CANARY_THREAD,
-              Defaults.EVENT_RECEIVER__MMESSAGE_QUEUE
-          )
-      )
-
-    /**
-     * This returns the references in the leak path that can be ignored for app developers. This
-     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-     */
-    val appDefaults: Set<AndroidKnownReference>
-      get() = buildKnownReferences(EnumSet.allOf(Defaults::class.java))
-
-    fun buildKnownReferences(defaults: Set<Defaults>): Set<AndroidKnownReference> {
-      val resultSet = mutableSetOf<AndroidKnownReference>()
-      defaults.forEach {
-        it.add(resultSet)
-      }
-      return resultSet
-    }
-
-    private val NO_FILTER: BuildFilter = { _, _ ->
-      true
-    }
-
-    fun staticField(
-      className: String,
-      fieldName: String,
-      reason: String? = null,
-      status: Status = WONT_FIX_LEAK,
-      filter: BuildFilter = NO_FILTER
-    ) = AndroidKnownReference(StaticFieldExclusion(className, fieldName), reason, status, filter)
-
-    fun instanceField(
-      className: String,
-      fieldName: String,
-      reason: String? = null,
-      status: Status = WONT_FIX_LEAK,
-      filter: BuildFilter = NO_FILTER
-    ) = AndroidKnownReference(InstanceFieldExclusion(className, fieldName), reason, status, filter)
-
-    fun javaLocal(
-      threadName: String,
-      reason: String? = null,
-      status: Status = WONT_FIX_LEAK,
-      filter: BuildFilter = NO_FILTER
-    ) = AndroidKnownReference(JavaLocalExclusion(threadName), reason, status, filter)
-
-    /**
-     * Used to transform [AndroidKnownReference] instances to [Exclusion] which is what
-     * the heap analyzer actually uses. The resulting set should only be used
-     * for exactly one analysis, it caches the Android version information.
-     */
-    fun mapToExclusions(knownReferences: Set<AndroidKnownReference>): List<Exclusion> {
-      val buildMirror = BuildMirror()
-      return knownReferences.map { knownReference ->
-        Exclusion(
-            knownReference.type, knownReference.reason, knownReference.status,
-            buildMirror.wrapFilter(knownReference.filter)
-        )
-      }
-    }
-  }
-
-  enum class Defaults {
-    // ######## Android Framework known leaks ########
-
-    ACTIVITY_CLIENT_RECORD__NEXT_IDLE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.app.ActivityThread\$ActivityClientRecord", "nextIdle",
-            reason = "Android AOSP sometimes keeps a reference to a destroyed activity as a"
-                + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-                + " Not sure what's going on there, input welcome."
-        ) { _, sdkInt ->
-          sdkInt in 19..27
-        }
-      }
-    },
-
-    SPAN_CONTROLLER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason =
-          ("Editor inserts a special span, which has a reference to the EditText. That span is a"
-              + " NoCopySpan, which makes sure it gets dropped when creating a new"
-              + " SpannableStringBuilder from a given CharSequence."
-              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-              + " reference to the textview and therefore the entire view hierarchy & activity"
-              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
-
-        references += instanceField(
-            "android.widget.Editor\$SpanController", "this$0", reason
-        ) { _, sdkInt ->
-          sdkInt <= 19
-        }
-
-        references += instanceField(
-            "android.widget.Editor\$EasyEditSpanController", "this$0", reason
-        ) { _, sdkInt ->
-          sdkInt <= 19
-        }
-      }
-    },
-
-    MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references +=
-          staticField(
-              "android.media.session.MediaSessionLegacyHelper", "sInstance",
-              reason = "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-                  + " keeps a reference to the context it's given the first time"
-                  + " MediaSessionLegacyHelper.getHelper() is called."
-                  + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-                  + " calling context.getApplicationContext()."
-                  + " Fix: https://github.com/android/platform_frameworks_base/commit"
-                  + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-                  + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-                  + " in Application.onCreate() and pass it the application context."
-          ) { _, sdkInt ->
-            sdkInt == 21
-          }
-      }
-    },
-
-    TEXT_LINE__SCACHED {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.text.TextLine", "sCached",
-            reason = "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-                + " at least two bugs that created memory leaks by not correctly clearing the"
-                + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-                + " https://github.com/android/platform_frameworks_base/commit"
-                + "/893d6fe48d37f71e683f722457bea646994a10"
-                + " The second was fixed, not released yet:"
-                + " https://github.com/android/platform_frameworks_base/commit"
-                + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-                + " To fix this, you could access TextLine.sCached and clear the pool every now"
-                + " and then (e.g. on activity destroy)."
-        ) { _, sdkInt ->
-          sdkInt <= 22
-        }
-      }
-    },
-
-    BLOCKING_QUEUE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason = ("A thread waiting on a blocking queue will leak the last"
-            + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-            + " keeps a local reference to the last message it received. That message then gets"
-            + " recycled and can be used again. As long as all messages are recycled after being"
-            + " used, this won't be a problem, because these references are cleared when being"
-            + " recycled. However, dialogs create template Message instances to be copied when a"
-            + " message needs to be sent. These Message templates holds references to the dialog"
-            + " listeners, which most likely leads to holding a reference onto the activity in some"
-            + " way. Dialogs never recycle their template Message, assuming these Message instances"
-            + " will get GCed when the dialog is GCed."
-            + " The combination of these two things creates a high potential for memory leaks as soon"
-            + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-            + " sleep for a long time."
-            + " To fix this, you could post empty messages to the idle handler threads from time to"
-            + " time. This won't be easy because you cannot access all handler threads, but a library"
-            + " that is widely used should consider doing this for its own handler threads. This leaks"
-            + " has been shown to happen in both Dalvik and ART.")
-
-        references += instanceField("android.os.Message", "obj", reason)
-        references += instanceField("android.os.Message", "next", reason)
-        references += instanceField("android.os.Message", "target", reason)
-      }
-    },
-
-    INPUT_METHOD_MANAGER_IS_TERRIBLE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
-            + " leaks a reference to it until a new view asks for keyboard input."
-            + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-            + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mNextServedView", reason
-        ) { _, sdkInt ->
-          sdkInt in 15..27
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mServedView", reason
-        ) { _, sdkInt ->
-          sdkInt in 15..27
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mServedInputConnection", reason
-        ) { _, sdkInt ->
-          sdkInt in 15..27
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mLastSrvView"
-            ,
-            reason =
-            "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
-        ) { manufacturer, sdkInt ->
-          manufacturer == HUAWEI && sdkInt in 23..27
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mCurRootView",
-            reason = "The singleton InputMethodManager is holding a reference to mCurRootView long"
-                + " after the activity has been destroyed."
-                + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-                + "#issuecomment-100579429"
-                + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
-        ) { _, sdkInt ->
-          sdkInt in 15..28
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mImeInsetsConsumer",
-            reason = """
-              Android Q Beta has a leak where InputMethodManager.mImeInsetsConsumer isn't set to
-              null when the activity is destroyed.
-            """.trimIndent()
-        ) { _, sdkInt ->
-          sdkInt == 28
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mCurrentInputConnection",
-            reason = """
-              In Android Q Beta InputMethodManager keeps its EditableInputConnection after the
-              activity has been destroyed.
-            """.trimIndent()
-        ) { _, sdkInt ->
-          sdkInt == 28
-        }
-      }
-    },
-
-    LAYOUT_TRANSITION {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.animation.LayoutTransition$1", "val\$parent",
-            reason = "LayoutTransition leaks parent ViewGroup through"
-                + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-                + " window is destroyed. Tracked here:"
-                + " https://code.google.com/p/android/issues/detail?id=171830"
-        ) { _, sdkInt ->
-          sdkInt in 14..22
-        }
-      }
-    },
-
-    SPELL_CHECKER_SESSION {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.view.textservice.SpellCheckerSession$1", "this$0",
-            reason = "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-                + " SpellCheckerSession is closed before the service is connected."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
-        ) { _, sdkInt ->
-          sdkInt in 16..24
-        }
-      }
-    },
-
-    SPELL_CHECKER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.widget.SpellChecker$1", "this$0",
-            reason = "SpellChecker holds on to a detached view that points to a destroyed activity."
-                + " mSpellRunnable is being enqueued, and that callback should be removed when "
-                + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
-                + " called after the view was detached."
-        ) { _, sdkInt ->
-          sdkInt == 22
-        }
-      }
-    },
-
-    ACTIVITY_CHOOSE_MODEL {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason = ("ActivityChooserModel holds a static reference to the last set"
-            + " ActivityChooserModelPolicy which can be an activity context."
-            + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-            + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
-
-
-        references += instanceField(
-            "android.support.v7.internal.widget.ActivityChooserModel",
-            "mActivityChoserModelPolicy",
-            reason = reason
-        ) { _, sdkInt ->
-          sdkInt in 15..22
-        }
-
-        references += instanceField(
-            "android.widget.ActivityChooserModel", "mActivityChoserModelPolicy",
-            reason = reason
-        )
-      }
-    },
-
-    MEDIA_PROJECTION_CALLBACK {
-      override fun add(references: MutableSet<AndroidKnownReference>) {
-        references += instanceField("android.media.projection.MediaProjection\$MediaProjectionCallback",
-            "this$0", reason = """
-              MediaProjectionCallback is held by another process, and holds on to MediaProjection
-              which has an activity as its context.
-            """.trimIndent()) { _, sdkInt ->
-          sdkInt in 22..28
-        }
-      }
-
-    },
-
-    SPEECH_RECOGNIZER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.speech.SpeechRecognizer\$InternalListener", "this$0"
-            ,
-            reason = "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-                + " class and leaked the SpeechRecognizer which leaked an activity context."
-                + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-                + " /b37866db469e81aca534ff6186bdafd44352329b"
-        ) { _, sdkInt ->
-          sdkInt < 21
-        }
-      }
-    },
-
-    ACCOUNT_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.accounts.AccountManager\$AmsTask\$Response", "this$1"
-            ,
-            reason =
-            "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
-                + " probably because the reference to the response in the other process hasn't been"
-                + " cleared."
-                + " AccountManager\$AmsTask is holding on to the activity reference to use for"
-                + " launching a new sub- Activity."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-                + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-                + " with the returned future to to get the result and correctly start an activity"
-                + " when it's available."
-        ) { _, sdkInt ->
-          sdkInt <= 27
-        }
-      }
-    },
-
-    MEDIA_SCANNER_CONNECTION {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.media.MediaScannerConnection", "mContext",
-
-            reason =
-            "The static method MediaScannerConnection.scanFile() takes an activity context"
-                + " but the service might not disconnect after the activity has been destroyed."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-                + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-                + " application context. Call connect() and disconnect() manually."
-        ) { _, sdkInt ->
-          sdkInt <= 22
-        }
-      }
-    },
-
-    USER_MANAGER__SINSTANCE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.os.UserManager", "mContext",
-            reason =
-            "UserManager has a static sInstance field that creates an instance and caches it"
-                + " the first time UserManager.get() is called. This instance is created with the"
-                + " outer context (which is an activity base context)."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-                + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-                + "/27db46850b708070452c0ce49daf5f79503fbde6"
-                + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-                + " UserManager instance gets cached with a reference to the application context."
-        ) { _, sdkInt ->
-          sdkInt in 18..25
-        }
-      }
-    },
-
-    APP_WIDGET_HOST_CALLBACKS {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.appwidget.AppWidgetHost\$Callbacks", "this$0"
-            ,
-            reason =
-            "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
-                + " code. The reference to the `mContext` was not being cleared, which caused the"
-                + " Callbacks instance to retain this reference"
-                + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-                + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
-        ) { _, sdkInt ->
-          sdkInt < 22
-        }
-      }
-    },
-
-    AUDIO_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.media.AudioManager$1", "this$0",
-            reason =
-            "Prior to Android M, VideoView required audio focus from AudioManager and"
-                + " never abandoned it, which leaks the Activity context through the AudioManager."
-                + " The root of the problem is that AudioManager uses whichever"
-                + " context it receives, which in the case of the VideoView example is an Activity,"
-                + " even though it only needs the application's context. The issue is fixed in"
-                + " Android M, and the AudioManager now uses the application's context."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-                + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
-        ) { _, sdkInt ->
-          sdkInt <= 22
-        }
-      }
-    },
-
-    EDITTEXT_BLINK_MESSAGEQUEUE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.widget.Editor\$Blink", "this$0",
-            reason =
-            "The EditText Blink of the Cursor is implemented using a callback and Messages,"
-                + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-                + " contains a blinking cursor is detached, a message is posted with a delay after the"
-                + " dialog has been closed and as a result leaks the Activity."
-                + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
-                + " dismiss() method of the dialog."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-                + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-                + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
-        ) { _, sdkInt ->
-          sdkInt <= 22
-        }
-      }
-    },
-
-    CONNECTIVITY_MANAGER__SINSTANCE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.net.ConnectivityManager", "sInstance",
-            reason =
-            "ConnectivityManager has a sInstance field that is set when the first"
-                + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
-                + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
-                + " ConnectivityManager instance is created with the activity context and stored in"
-                + " sInstance. That activity context then leaks forever."
-                + " Until this is fixed, app developers can prevent this leak by making sure the"
-                + " ConnectivityManager is first created with an App Context. E.g. in some static"
-                + " init do: context.getApplicationContext()"
-                + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
-                + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
-                + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
-        ) { _, sdkInt ->
-          sdkInt <= 23
-        }
-      }
-    },
-
-    ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.view.accessibility.AccessibilityNodeInfo", "mOriginalText"
-            ,
-            reason =
-            "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
-                + " AccessibilityNodeInfo instances are released back in the pool,"
-                + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
-                + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
-                + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
-                + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
-                + "android/view/accessibility/AccessibilityNodeInfo.java"
-        ) { _, sdkInt ->
-          sdkInt in 26..27
-        }
-      }
-    },
-
-    BACKDROP_FRAME_RENDERER__MDECORVIEW {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.android.internal.policy.BackdropFrameRenderer", "mDecorView"
-            ,
-            reason =
-            "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
-                + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
-                + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
-                + " activity"
-        ) { _, sdkInt ->
-          sdkInt in 24..26
-        }
-      }
-    },
-
-    VIEWLOCATIONHOLDER_ROOT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.view.ViewGroup\$ViewLocationHolder",
-            "mRoot"
-            ,
-            reason = "In Android P, ViewLocationHolder has an mRoot field that is not cleared " +
-                "in its clear() method. Introduced in https://github.com/aosp-mirror" +
-                "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
-                "report: https://issuetracker.google.com/issues/112792715"
-        ) { _, sdkInt ->
-          sdkInt == 28
-        }
-      }
-    },
-
-    ACCESSIBILITY_NODE_ID_MANAGER {
-      override fun add(references: MutableSet<AndroidKnownReference>) {
-        references += instanceField(
-            "android.view.accessibility.AccessibilityNodeIdManager", "mIdsToViews"
-            ,
-            reason = """
-              Android Q Beta added AccessibilityNodeIdManager which stores all views from their
-              onAttachedToWindow() call, until detached. Unfortunately it's possible to trigger
-              the view framework to call detach before attach (by having a view removing itself
-              from its parent in onAttach, which then causes AccessibilityNodeIdManager to keep
-              children view forever. Future releases of Q will hold weak references.
-            """.trimIndent()
-        ) { _, sdkInt ->
-          sdkInt == 28
-        }
-      }
-
-    },
-
-    TEXT_TO_SPEECH {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason =
-          ("TextToSpeech.shutdown() does not release its references to context objects." +
-              " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
-              " keeping the references, resulting the context objects leaked." +
-              " Developers might be able to mitigate the issue by passing application context" +
-              " to TextToSpeech constructor." +
-              " Tracked at: https://github.com/square/leakcanary/issues/1210 and" +
-              " https://issuetracker.google.com/issues/129250419")
-        references += instanceField(
-            "android.speech.tts.TextToSpeech", "mContext",
-            reason = reason
-        ) { _, sdkInt ->
-          sdkInt == 24
-        }
-
-        references += instanceField(
-            "android.speech.tts.TtsEngines", "mContext",
-            reason = reason
-        ) { _, sdkInt ->
-          sdkInt == 24
-        }
-      }
-    },
-
-    // ######## Manufacturer specific known leaks ########
-
-    // SAMSUNG
-
-    SPEN_GESTURE_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "com.samsung.android.smartclip.SpenGestureManager", "mContext"
-            ,
-            reason =
-            "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    CLIPBOARD_UI_MANAGER__SINSTANCE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.sec.clipboard.ClipboardUIManager", "mContext"
-            ,
-            reason =
-            "ClipboardUIManager is a static singleton that leaks an activity context."
-                + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-                + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-                + " application context. Example: https://gist.github.com/cypressious/"
-                + "91c4fb1455470d803a602838dfcd5774"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 19..21
-        }
-      }
-    },
-
-    SEM_CLIPBOARD_MANAGER__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.samsung.android.content.clipboard.SemClipboardManager",
-            "mContext"
-            ,
-            reason =
-            "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 19..24
-        }
-        references += instanceField(
-            "com.samsung.android.content.clipboard.SemClipboardManager$3",
-            "this$0"
-            ,
-            reason =
-            "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 22..28
-        }
-      }
-    },
-
-    SEM_EMERGENCY_MANAGER__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.samsung.android.emergencymode.SemEmergencyManager", "mContext"
-            ,
-            reason =
-            "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 19..24
-        }
-      }
-    },
-
-    SEM_PERSONA_MANAGER {
-      override fun add(references: MutableSet<AndroidKnownReference>) {
-        references += instanceField(
-            "com.samsung.android.knox.SemPersonaManager", "mContext"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 24
-        }
-      }
-    },
-
-    SEM_APP_ICON_SOLUTION {
-      override fun add(references: MutableSet<AndroidKnownReference>) {
-        references += instanceField(
-            "android.app.SemAppIconSolution", "mContext"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 28
-        }
-      }
-    },
-
-    AW_RESOURCE__SRESOURCES {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        // AwResource#setResources() is called with resources that hold a reference to the
-        // activity context (instead of the application context) and doesn't clear it.
-        // Not sure what's going on there, input welcome.
-        references += staticField(
-            "com.android.org.chromium.android_webview.AwResource", "sResources"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    TEXT_VIEW__MLAST_HOVERED_VIEW {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.widget.TextView", "mLastHoveredView",
-            reason =
-            "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 19..28
-        }
-      }
-    },
-
-    PERSONA_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.os.PersonaManager", "mContext",
-            reason =
-            "android.app.LoadedApk.mResources has a reference to"
-                + " android.content.res.Resources.mPersonaManager which has a reference to"
-                + " android.os.PersonaManager.mContext which is an activity."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    RESOURCES__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.content.res.Resources", "mContext",
-            reason =
-            "In AOSP the Resources class does not have a context."
-                + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-                + " instance that has a context that is the activity."
-                + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    VIEW_CONFIGURATION__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.view.ViewConfiguration", "mContext",
-            reason =
-            "In AOSP the ViewConfiguration class does not have a context."
-                + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-                + " ViewConfiguration instance that has a context that is the activity."
-                + " Observed here: https://github.com/square/leakcanary/issues"
-                + "/1#issuecomment-100324683"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    AUDIO_MANAGER__MCONTEXT_STATIC {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.media.AudioManager", "mContext_static",
-            reason =
-            "Samsung added a static mContext_static field to AudioManager, holds a reference"
-                + " to the activity."
-                + " Observed here: https://github.com/square/leakcanary/issues/32"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    ACTIVITY_MANAGER_MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.app.ActivityManager", "mContext",
-            reason =
-            "Samsung added a static mContext field to ActivityManager, holds a reference"
-                + " to the activity."
-                + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
-                + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 22..23
-        }
-      }
-    },
-
-    // OTHER MANUFACTURERS
-
-    GESTURE_BOOST_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.gestureboost.GestureBoostManager", "mContext"
-            ,
-            reason =
-            "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
-        ) { manufacturer, sdkInt ->
-          manufacturer == HUAWEI && sdkInt in 24..25
-        }
-      }
-    },
-
-    BUBBLE_POPUP_HELPER__SHELPER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.widget.BubblePopupHelper", "sHelper",
-            reason =
-            "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
-        ) { manufacturer, sdkInt ->
-          manufacturer == LG && sdkInt in 19..22
-        }
-      }
-    },
-
-    LGCONTEXT__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.lge.systemservice.core.LGContext", "mContext",
-            reason = "LGContext is a static singleton that leaks an activity context."
-        ) { manufacturer, sdkInt ->
-          manufacturer == LG && sdkInt == 21
-        }
-      }
-    },
-
-    MAPPER_CLIENT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0"
-            ,
-            reason =
-            "Not sure exactly what ControllerMapper is about, but there is an anonymous"
-                + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-                + " ControllerMapper.MapperClient which leaks the activity context."
-        ) { manufacturer, sdkInt ->
-          manufacturer == NVIDIA && sdkInt == 19
-        }
-      }
-    },
-
-    SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.hardware.SystemSensorManager", "mAppContextImpl"
-            ,
-            reason =
-            "SystemSensorManager stores a reference to context"
-                + " in a static field in its constructor."
-                + " Fix: use application context to get SensorManager"
-        ) { manufacturer, sdkInt ->
-          (manufacturer == LENOVO && sdkInt == 19) || (manufacturer == VIVO && sdkInt == 22)
-        }
-      }
-    },
-
-    INSTRUMENTATION_RECOMMEND_ACTIVITY {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.app.Instrumentation", "mRecommendActivity",
-            reason =
-            "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
-                + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
-                + " above"
-        ) { manufacturer, sdkInt ->
-          manufacturer == MEIZU && sdkInt in 21..22
-        }
-      }
-    },
-
-    DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0"
-            ,
-            reason =
-            "DevicePolicyManager keeps a reference to the context it has been created with"
-                + " instead of extracting the application context. In this Motorola build,"
-                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                + " observer, which is held into memory by a binder transport object."
-        ) { manufacturer, sdkInt ->
-          manufacturer == MOTOROLA && sdkInt in 19..22
-        }
-      }
-    },
-
-
-    // ######## General known references (not leaks) ########
-
-    REFERENCES {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            WeakReference::class.java.name, "referent",
-            status = WEAKLY_REACHABLE
-        )
-        references += instanceField(
-            KeyedWeakReference::class.java.name, "referent"
-            ,
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            SoftReference::class.java.name, "referent",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            PhantomReference::class.java.name, "referent",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.Finalizer", "prev",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.Finalizer", "element",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.Finalizer", "next",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.FinalizerReference", "prev",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.FinalizerReference", "element",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.FinalizerReference", "next",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "sun.misc.Cleaner", "prev", status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "sun.misc.Cleaner", "next", status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    FINALIZER_WATCHDOG_DAEMON {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-        // reference to the object and it was about to be GCed.
-        references += javaLocal(
-            "FinalizerWatchdogDaemon",
-            status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    MAIN {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        // The main thread stack is ever changing so local variables aren't likely to hold references
-        // for long. If this is on the shortest path, it's probably that there's a longer path with
-        // a real leak.
-        references += javaLocal(
-            "main",
-            status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    LEAK_CANARY_THREAD {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += javaLocal(
-            LEAK_CANARY_THREAD_NAME,
-            status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    EVENT_RECEIVER__MMESSAGE_QUEUE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-        // the native peer of the receiver is using them.
-        // The main thread message queue is held on by the main Looper, but that might be a longer
-        // path. Let's not confuse people with a shorter path that is less meaningful.
-        references += instanceField(
-            "android.view.Choreographer\$FrameDisplayEventReceiver",
-            "mMessageQueue"
-            ,
-            status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    ;
-
-    internal abstract fun add(references: MutableSet<AndroidKnownReference>)
-  }
-
-
-}
-
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
index 2e0efd9c..f8a24f40 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
@@ -30,6 +30,9 @@ import kotlin.reflect.KClass
  *
  * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
  * will not be influenced by those mistakes.
+ *
+ * Most developers should use the entire set of default [ObjectInspector] by calling [appDefaults],
+ * unless there's a bug and you temporarily want to remove an inspector.
  */
 enum class AndroidObjectInspectors : ObjectInspector {
 
@@ -38,38 +41,39 @@ enum class AndroidObjectInspectors : ObjectInspector {
       graph: HprofGraph,
       reporter: ObjectReporter
     ) {
-      val references: List<KeyedWeakReferenceMirror> = graph.context[KEYED_WEAK_REFERENCE.name] ?: {
-        val keyedWeakReferenceClass = graph.indexedClass("leakcanary.KeyedWeakReference")
+      val references: List<KeyedWeakReferenceMirror> =
+        graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
+          val keyedWeakReferenceClass = graph.findClassByClassName("leakcanary.KeyedWeakReference")
 
-        val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
-          null
-        } else {
-          keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
-        }
+          val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
+            null
+          } else {
+            keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+          }
 
-        if (heapDumpUptimeMillis == null) {
-          CanaryLog.d(
-              "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
-                  "this must be a heap dump from an older version of LeakCanary."
-          )
-        }
+          if (heapDumpUptimeMillis == null) {
+            CanaryLog.d(
+                "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
+                    "this must be a heap dump from an older version of LeakCanary."
+            )
+          }
 
-        val addedToContext: List<KeyedWeakReferenceMirror> = graph.instanceSequence()
-            .filter { instance ->
-              val className = instance.className
-              className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
-            }
-            .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
-            .filter { it.hasReferent }
-            .toList()
-        graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
-        addedToContext
-      }()
+          val addedToContext: List<KeyedWeakReferenceMirror> = graph.instances
+              .filter { instance ->
+                val className = instance.className
+                className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
+              }
+              .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
+              .filter { it.hasReferent }
+              .toList()
+          graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
+          addedToContext
+        }
 
       val objectId = reporter.objectRecord.objectId
       references.forEach { ref ->
         if (ref.referent.value == objectId) {
-          reporter.reportLeaking("RefWatcher was watching this")
+          reporter.reportLeaking("ObjectWatcher was watching this")
           reporter.addLabel("key = ${ref.key}")
           if (ref.name.isNotEmpty()) {
             reporter.addLabel("name = ${ref.name}")
@@ -474,9 +478,11 @@ enum class AndroidObjectInspectors : ObjectInspector {
   };
 
   companion object {
-    fun defaultInspectors(): List<ObjectInspector> {
-      return values().toList()
-    }
+    /** @see AndroidObjectInspectors */
+    val appDefaults: List<ObjectInspector>
+      get() {
+        return values().toList()
+      }
   }
 }
 
@@ -484,6 +490,9 @@ private infix fun GraphField.describedWithValue(valueDescription: String): Strin
   return "${classRecord.simpleName}#$name is $valueDescription"
 }
 
+/**
+ * Runs [block] if [ObjectReporter.objectRecord] is an instance of [expectedClass].
+ */
 inline fun ObjectReporter.whenInstanceOf(
   expectedClass: KClass<out Any>,
   action: ObjectReporter.(GraphInstanceRecord) -> Unit
@@ -491,15 +500,22 @@ inline fun ObjectReporter.whenInstanceOf(
   whenInstanceOf(expectedClass.java.name, action)
 }
 
+/**
+ * Runs [block] if [ObjectReporter.objectRecord] is an instance of [expectedClassName].
+ */
 inline fun ObjectReporter.whenInstanceOf(
-  className: String,
+  expectedClassName: String,
   block: ObjectReporter.(GraphInstanceRecord) -> Unit
 ) {
-  if (objectRecord is GraphInstanceRecord && objectRecord instanceOf className) {
+  if (objectRecord is GraphInstanceRecord && objectRecord instanceOf expectedClassName) {
     block(objectRecord)
   }
 }
 
+/**
+ * Recursively unwraps `this` [GraphInstanceRecord] as a ContextWrapper until an Activity is found in which case it is
+ * returned. Returns null if no activity was found.
+ */
 fun GraphInstanceRecord.unwrapActivityContext(): GraphInstanceRecord? {
   if (this instanceOf "android.app.Activity") {
     return this
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt
new file mode 100644
index 00000000..0da17501
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt
@@ -0,0 +1,1099 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.AndroidReferenceMatchers.Companion.appDefaults
+import leakcanary.AndroidReferenceMatchers.Companion.buildKnownReferences
+import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
+import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
+import leakcanary.ReferencePattern.InstanceFieldPattern
+import leakcanary.ReferencePattern.JavaLocalPattern
+import leakcanary.ReferencePattern.StaticFieldPattern
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import java.util.EnumSet
+
+/**
+ * [AndroidReferenceMatchers] values add [ReferenceMatcher] instances to a global list via their
+ * [add] method. A [ReferenceMatcher] is either a [IgnoredReferenceMatcher] or
+ * a [LibraryLeakReferenceMatcher].
+ *
+ * [AndroidReferenceMatchers] is used to build the list of known references that cannot ever create
+ * leaks (via [IgnoredReferenceMatcher]) as well as the list of known leaks in the Android Framework
+ * and in manufacturer specific Android implementations.
+ *
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use [appDefaults]. However, you can also use a subset of
+ * [AndroidReferenceMatchers] by creating an [EnumSet] that matches your needs and calling
+ * [buildKnownReferences].
+ */
+enum class AndroidReferenceMatchers {
+
+  // ######## Android Framework known leaks ########
+
+  ACTIVITY_CLIENT_RECORD__NEXT_IDLE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.app.ActivityThread\$ActivityClientRecord", "nextIdle",
+          description = "Android AOSP sometimes keeps a reference to a destroyed activity as a"
+              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+              + " Not sure what's going on there, input welcome."
+      ) {
+        sdkInt in 19..27
+      }
+    }
+  },
+
+  SPAN_CONTROLLER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("Editor inserts a special span, which has a reference to the EditText. That span is a"
+            + " NoCopySpan, which makes sure it gets dropped when creating a new"
+            + " SpannableStringBuilder from a given CharSequence."
+            + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+            + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+            + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+            + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+            + " reference to the textview and therefore the entire view hierarchy & activity"
+            + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+            + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+            + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+            + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
+
+      references += instanceFieldLeak(
+          "android.widget.Editor\$SpanController", "this$0", description
+      ) {
+        sdkInt <= 19
+      }
+
+      references += instanceFieldLeak(
+          "android.widget.Editor\$EasyEditSpanController", "this$0", description
+      ) {
+        sdkInt <= 19
+      }
+    }
+  },
+
+  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references +=
+        staticFieldLeak(
+            "android.media.session.MediaSessionLegacyHelper", "sInstance",
+            description = "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+                + " keeps a reference to the context it's given the first time"
+                + " MediaSessionLegacyHelper.getHelper() is called."
+                + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+                + " calling context.getApplicationContext()."
+                + " Fix: https://github.com/android/platform_frameworks_base/commit"
+                + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+                + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+                + " in Application.onCreate() and pass it the application context."
+        ) {
+          sdkInt == 21
+        }
+    }
+  },
+
+  TEXT_LINE__SCACHED {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.text.TextLine", "sCached",
+          description = "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+              + " at least two bugs that created memory leaks by not correctly clearing the"
+              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/893d6fe48d37f71e683f722457bea646994a10"
+              + " The second was fixed, not released yet:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+              + " To fix this, you could access TextLine.sCached and clear the pool every now"
+              + " and then (e.g. on activity destroy)."
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  BLOCKING_QUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description = ("A thread waiting on a blocking queue will leak the last"
+          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+          + " keeps a local reference to the last message it received. That message then gets"
+          + " recycled and can be used again. As long as all messages are recycled after being"
+          + " used, this won't be a problem, because these references are cleared when being"
+          + " recycled. However, dialogs create template Message instances to be copied when a"
+          + " message needs to be sent. These Message templates holds references to the dialog"
+          + " listeners, which most likely leads to holding a reference onto the activity in some"
+          + " way. Dialogs never recycle their template Message, assuming these Message instances"
+          + " will get GCed when the dialog is GCed."
+          + " The combination of these two things creates a high potential for memory leaks as soon"
+          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+          + " sleep for a long time."
+          + " To fix this, you could post empty messages to the idle handler threads from time to"
+          + " time. This won't be easy because you cannot access all handler threads, but a library"
+          + " that is widely used should consider doing this for its own handler threads. This leaks"
+          + " has been shown to happen in both Dalvik and ART.")
+
+      references += instanceFieldLeak("android.os.Message", "obj", description)
+      references += instanceFieldLeak("android.os.Message", "next", description)
+      references += instanceFieldLeak("android.os.Message", "target", description)
+    }
+  },
+
+  INPUT_METHOD_MANAGER_IS_TERRIBLE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("When we detach a view that receives keyboard input, the InputMethodManager"
+            + " leaks a reference to it until a new view asks for keyboard input."
+            + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+            + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mNextServedView", description
+      ) {
+        sdkInt in 15..27
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mServedView", description
+      ) {
+        sdkInt in 15..27
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mServedInputConnection", description
+      ) {
+        sdkInt in 15..27
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mLastSrvView"
+          ,
+          description =
+          "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
+      ) {
+        manufacturer == HUAWEI && sdkInt in 23..27
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mCurRootView",
+          description = "The singleton InputMethodManager is holding a reference to mCurRootView long"
+              + " after the activity has been destroyed."
+              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+              + "#issuecomment-100579429"
+              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
+      ) {
+        sdkInt in 15..28
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mImeInsetsConsumer",
+          description = """
+              Android Q Beta has a leak where InputMethodManager.mImeInsetsConsumer isn't set to
+              null when the activity is destroyed.
+            """.trimIndent()
+      ) {
+        sdkInt == 28
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mCurrentInputConnection",
+          description = """
+              In Android Q Beta InputMethodManager keeps its EditableInputConnection after the
+              activity has been destroyed.
+            """.trimIndent()
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  LAYOUT_TRANSITION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.animation.LayoutTransition$1", "val\$parent",
+          description = "LayoutTransition leaks parent ViewGroup through"
+              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+              + " window is destroyed. Tracked here:"
+              + " https://code.google.com/p/android/issues/detail?id=171830"
+      ) {
+        sdkInt in 14..22
+      }
+    }
+  },
+
+  SPELL_CHECKER_SESSION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.view.textservice.SpellCheckerSession$1", "this$0",
+          description = "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+              + " SpellCheckerSession is closed before the service is connected."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
+      ) {
+        sdkInt in 16..24
+      }
+    }
+  },
+
+  SPELL_CHECKER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.widget.SpellChecker$1", "this$0",
+          description = "SpellChecker holds on to a detached view that points to a destroyed activity."
+              + " mSpellRunnable is being enqueued, and that callback should be removed when "
+              + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+              + " called after the view was detached."
+      ) {
+        sdkInt == 22
+      }
+    }
+  },
+
+  ACTIVITY_CHOOSE_MODEL {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description = ("ActivityChooserModel holds a static reference to the last set"
+          + " ActivityChooserModelPolicy which can be an activity context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
+
+
+      references += instanceFieldLeak(
+          "android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy",
+          description = description
+      ) {
+        sdkInt in 15..22
+      }
+
+      references += instanceFieldLeak(
+          "android.widget.ActivityChooserModel", "mActivityChoserModelPolicy",
+          description = description
+      )
+    }
+  },
+
+  MEDIA_PROJECTION_CALLBACK {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.media.projection.MediaProjection\$MediaProjectionCallback",
+          "this$0", description = """
+              MediaProjectionCallback is held by another process, and holds on to MediaProjection
+              which has an activity as its context.
+            """.trimIndent()
+      ) {
+        sdkInt in 22..28
+      }
+    }
+
+  },
+
+  SPEECH_RECOGNIZER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.speech.SpeechRecognizer\$InternalListener", "this$0"
+          ,
+          description = "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+              + " class and leaked the SpeechRecognizer which leaked an activity context."
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + " /b37866db469e81aca534ff6186bdafd44352329b"
+      ) {
+        sdkInt < 21
+      }
+    }
+  },
+
+  ACCOUNT_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.accounts.AccountManager\$AmsTask\$Response", "this$1"
+          ,
+          description =
+          "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
+              + " probably because the reference to the response in the other process hasn't been"
+              + " cleared."
+              + " AccountManager\$AmsTask is holding on to the activity reference to use for"
+              + " launching a new sub- Activity."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+              + " with the returned future to to get the result and correctly start an activity"
+              + " when it's available."
+      ) {
+        sdkInt <= 27
+      }
+    }
+  },
+
+  MEDIA_SCANNER_CONNECTION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.media.MediaScannerConnection", "mContext",
+
+          description =
+          "The static method MediaScannerConnection.scanFile() takes an activity context"
+              + " but the service might not disconnect after the activity has been destroyed."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+              + " application context. Call connect() and disconnect() manually."
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  USER_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.os.UserManager", "mContext",
+          description =
+          "UserManager has a static sInstance field that creates an instance and caches it"
+              + " the first time UserManager.get() is called. This instance is created with the"
+              + " outer context (which is an activity base context)."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+              + "/27db46850b708070452c0ce49daf5f79503fbde6"
+              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+              + " UserManager instance gets cached with a reference to the application context."
+      ) {
+        sdkInt in 18..25
+      }
+    }
+  },
+
+  APP_WIDGET_HOST_CALLBACKS {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.appwidget.AppWidgetHost\$Callbacks", "this$0"
+          ,
+          description =
+          "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
+              + " code. The reference to the `mContext` was not being cleared, which caused the"
+              + " Callbacks instance to retain this reference"
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
+      ) {
+        sdkInt < 22
+      }
+    }
+  },
+
+  AUDIO_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.media.AudioManager$1", "this$0",
+          description =
+          "Prior to Android M, VideoView required audio focus from AudioManager and"
+              + " never abandoned it, which leaks the Activity context through the AudioManager."
+              + " The root of the problem is that AudioManager uses whichever"
+              + " context it receives, which in the case of the VideoView example is an Activity,"
+              + " even though it only needs the application's context. The issue is fixed in"
+              + " Android M, and the AudioManager now uses the application's context."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  EDITTEXT_BLINK_MESSAGEQUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.widget.Editor\$Blink", "this$0",
+          description =
+          "The EditText Blink of the Cursor is implemented using a callback and Messages,"
+              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+              + " contains a blinking cursor is detached, a message is posted with a delay after the"
+              + " dialog has been closed and as a result leaks the Activity."
+              + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+              + " dismiss() method of the dialog."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  CONNECTIVITY_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.net.ConnectivityManager", "sInstance",
+          description =
+          "ConnectivityManager has a sInstance field that is set when the first"
+              + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+              + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+              + " ConnectivityManager instance is created with the activity context and stored in"
+              + " sInstance. That activity context then leaks forever."
+              + " Until this is fixed, app developers can prevent this leak by making sure the"
+              + " ConnectivityManager is first created with an App Context. E.g. in some static"
+              + " init do: context.getApplicationContext()"
+              + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+              + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+              + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
+      ) {
+        sdkInt <= 23
+      }
+    }
+  },
+
+  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.view.accessibility.AccessibilityNodeInfo", "mOriginalText"
+          ,
+          description =
+          "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
+              + " AccessibilityNodeInfo instances are released back in the pool,"
+              + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
+              + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
+              + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+              + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+              + "android/view/accessibility/AccessibilityNodeInfo.java"
+      ) {
+        sdkInt in 26..27
+      }
+    }
+  },
+
+  BACKDROP_FRAME_RENDERER__MDECORVIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.android.internal.policy.BackdropFrameRenderer", "mDecorView"
+          ,
+          description =
+          "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
+              + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+              + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
+              + " activity"
+      ) {
+        sdkInt in 24..26
+      }
+    }
+  },
+
+  VIEWLOCATIONHOLDER_ROOT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.view.ViewGroup\$ViewLocationHolder",
+          "mRoot"
+          ,
+          description = "In Android P, ViewLocationHolder has an mRoot field that is not cleared " +
+              "in its clear() method. Introduced in https://github.com/aosp-mirror" +
+              "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
+              "report: https://issuetracker.google.com/issues/112792715"
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  ACCESSIBILITY_NODE_ID_MANAGER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.view.accessibility.AccessibilityNodeIdManager", "mIdsToViews"
+          ,
+          description = """
+              Android Q Beta added AccessibilityNodeIdManager which stores all views from their
+              onAttachedToWindow() call, until detached. Unfortunately it's possible to trigger
+              the view framework to call detach before attach (by having a view removing itself
+              from its parent in onAttach, which then causes AccessibilityNodeIdManager to keep
+              children view forever. Future releases of Q will hold weak references.
+            """.trimIndent()
+      ) {
+        sdkInt == 28
+      }
+    }
+
+  },
+
+  TEXT_TO_SPEECH {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("TextToSpeech.shutdown() does not release its references to context objects." +
+            " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
+            " keeping the references, resulting the context objects leaked." +
+            " Developers might be able to mitigate the issue by passing application context" +
+            " to TextToSpeech constructor." +
+            " Tracked at: https://github.com/square/leakcanary/issues/1210 and" +
+            " https://issuetracker.google.com/issues/129250419")
+      references += instanceFieldLeak(
+          "android.speech.tts.TextToSpeech", "mContext",
+          description = description
+      ) {
+        sdkInt == 24
+      }
+
+      references += instanceFieldLeak(
+          "android.speech.tts.TtsEngines", "mContext",
+          description = description
+      ) {
+        sdkInt == 24
+      }
+    }
+  },
+
+  // ######## Manufacturer specific known leaks ########
+
+  // SAMSUNG
+
+  SPEN_GESTURE_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "com.samsung.android.smartclip.SpenGestureManager", "mContext"
+          ,
+          description =
+          "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  CLIPBOARD_UI_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.sec.clipboard.ClipboardUIManager", "mContext"
+          ,
+          description =
+          "ClipboardUIManager is a static singleton that leaks an activity context."
+              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+              + " application context. Example: https://gist.github.com/cypressious/"
+              + "91c4fb1455470d803a602838dfcd5774"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..21
+      }
+    }
+  },
+
+  SEM_CLIPBOARD_MANAGER__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.samsung.android.content.clipboard.SemClipboardManager",
+          "mContext"
+          ,
+          description =
+          "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..24
+      }
+      references += instanceFieldLeak(
+          "com.samsung.android.content.clipboard.SemClipboardManager$3",
+          "this$0"
+          ,
+          description =
+          "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 22..28
+      }
+    }
+  },
+
+  SEM_EMERGENCY_MANAGER__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.samsung.android.emergencymode.SemEmergencyManager", "mContext"
+          ,
+          description =
+          "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..24
+      }
+    }
+  },
+
+  SEM_PERSONA_MANAGER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "com.samsung.android.knox.SemPersonaManager", "mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 24
+      }
+    }
+  },
+
+  SEM_APP_ICON_SOLUTION {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.app.SemAppIconSolution", "mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 28
+      }
+    }
+  },
+
+  AW_RESOURCE__SRESOURCES {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // AwResource#setResources() is called with resources that hold a reference to the
+      // activity context (instead of the application context) and doesn't clear it.
+      // Not sure what's going on there, input welcome.
+      references += staticFieldLeak(
+          "com.android.org.chromium.android_webview.AwResource", "sResources"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  TEXT_VIEW__MLAST_HOVERED_VIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.widget.TextView", "mLastHoveredView",
+          description =
+          "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..28
+      }
+    }
+  },
+
+  PERSONA_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.os.PersonaManager", "mContext",
+          description =
+          "android.app.LoadedApk.mResources has a reference to"
+              + " android.content.res.Resources.mPersonaManager which has a reference to"
+              + " android.os.PersonaManager.mContext which is an activity."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  RESOURCES__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.content.res.Resources", "mContext",
+          description =
+          "In AOSP the Resources class does not have a context."
+              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+              + " instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  VIEW_CONFIGURATION__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.view.ViewConfiguration", "mContext",
+          description =
+          "In AOSP the ViewConfiguration class does not have a context."
+              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+              + " ViewConfiguration instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues"
+              + "/1#issuecomment-100324683"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  AUDIO_MANAGER__MCONTEXT_STATIC {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.media.AudioManager", "mContext_static",
+          description =
+          "Samsung added a static mContext_static field to AudioManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/32"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  ACTIVITY_MANAGER_MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.app.ActivityManager", "mContext",
+          description =
+          "Samsung added a static mContext field to ActivityManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+              + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 22..23
+      }
+    }
+  },
+
+  // OTHER MANUFACTURERS
+
+  GESTURE_BOOST_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.gestureboost.GestureBoostManager", "mContext"
+          ,
+          description =
+          "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+      ) {
+        manufacturer == HUAWEI && sdkInt in 24..25
+      }
+    }
+  },
+
+  BUBBLE_POPUP_HELPER__SHELPER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.widget.BubblePopupHelper", "sHelper",
+          description =
+          "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
+      ) {
+        manufacturer == LG && sdkInt in 19..22
+      }
+    }
+  },
+
+  LGCONTEXT__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.lge.systemservice.core.LGContext", "mContext",
+          description = "LGContext is a static singleton that leaks an activity context."
+      ) {
+        manufacturer == LG && sdkInt == 21
+      }
+    }
+  },
+
+  MAPPER_CLIENT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0"
+          ,
+          description =
+          "Not sure exactly what ControllerMapper is about, but there is an anonymous"
+              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+              + " ControllerMapper.MapperClient which leaks the activity context."
+      ) {
+        manufacturer == NVIDIA && sdkInt == 19
+      }
+    }
+  },
+
+  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.hardware.SystemSensorManager", "mAppContextImpl"
+          ,
+          description =
+          "SystemSensorManager stores a reference to context"
+              + " in a static field in its constructor."
+              + " Fix: use application context to get SensorManager"
+      ) {
+        (manufacturer == LENOVO && sdkInt == 19) || (manufacturer == VIVO && sdkInt == 22)
+      }
+    }
+  },
+
+  INSTRUMENTATION_RECOMMEND_ACTIVITY {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.app.Instrumentation", "mRecommendActivity",
+          description =
+          "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
+              + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+              + " above"
+      ) {
+        manufacturer == MEIZU && sdkInt in 21..22
+      }
+    }
+  },
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0"
+          ,
+          description =
+          "DevicePolicyManager keeps a reference to the context it has been created with"
+              + " instead of extracting the application context. In this Motorola build,"
+              + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+              + " observer, which is held into memory by a binder transport object."
+      ) {
+        manufacturer == MOTOROLA && sdkInt in 19..22
+      }
+    }
+  },
+
+  // ######## Ignored references (not leaks) ########
+
+  REFERENCES {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += ignoredInstanceField(WeakReference::class.java.name, "referent")
+      references += ignoredInstanceField(KeyedWeakReference::class.java.name, "referent")
+      references += ignoredInstanceField(SoftReference::class.java.name, "referent")
+      references += ignoredInstanceField(PhantomReference::class.java.name, "referent")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "prev")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "element")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "next")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "prev")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "element")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "next")
+      references += ignoredInstanceField("sun.misc.Cleaner", "prev")
+      references += ignoredInstanceField("sun.misc.Cleaner", "next")
+    }
+  },
+
+  FINALIZER_WATCHDOG_DAEMON {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+      // reference to the object and it was about to be GCed.
+      references += ignoredJavaLocal("FinalizerWatchdogDaemon")
+    }
+  },
+
+  MAIN {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // The main thread stack is ever changing so local variables aren't likely to hold references
+      // for long. If this is on the shortest path, it's probably that there's a longer path with
+      // a real leak.
+      references += ignoredJavaLocal("main")
+    }
+  },
+
+  LEAK_CANARY_THREAD {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += ignoredJavaLocal(LEAK_CANARY_THREAD_NAME)
+    }
+  },
+
+  EVENT_RECEIVER__MMESSAGE_QUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+      // the native peer of the receiver is using them.
+      // The main thread message queue is held on by the main Looper, but that might be a longer
+      // path. Let's not confuse people with a shorter path that is less meaningful.
+      references += ignoredInstanceField(
+          "android.view.Choreographer\$FrameDisplayEventReceiver", "mMessageQueue"
+      )
+    }
+  },
+
+  ;
+
+  internal abstract fun add(references: MutableList<ReferenceMatcher>)
+
+  companion object {
+    private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+    const val SAMSUNG = "samsung"
+    const val MOTOROLA = "motorola"
+    const val LENOVO = "LENOVO"
+    const val LG = "LGE"
+    const val NVIDIA = "NVIDIA"
+    const val MEIZU = "Meizu"
+    const val HUAWEI = "HUAWEI"
+    const val VIVO = "vivo"
+
+    /**
+     * Returns a list of [ReferenceMatcher] that only contains [IgnoredReferenceMatcher] and no
+     * [LibraryLeakReferenceMatcher].
+     */
+    val ignoredReferencesOnly: List<ReferenceMatcher>
+      get() = buildKnownReferences(
+          EnumSet.of(
+              REFERENCES,
+              FINALIZER_WATCHDOG_DAEMON,
+              MAIN,
+              LEAK_CANARY_THREAD,
+              EVENT_RECEIVER__MMESSAGE_QUEUE
+          )
+      )
+
+    /**
+     * @see [AndroidReferenceMatchers]
+     */
+    val appDefaults: List<ReferenceMatcher>
+      get() = buildKnownReferences(EnumSet.allOf(AndroidReferenceMatchers::class.java))
+
+    /**
+     * Builds a list of [ReferenceMatcher] from the [referenceMatchers] set of
+     * [AndroidReferenceMatchers].
+     */
+    fun buildKnownReferences(referenceMatchers: Set<AndroidReferenceMatchers>): List<ReferenceMatcher> {
+      val resultSet = mutableListOf<ReferenceMatcher>()
+      referenceMatchers.forEach {
+        it.add(resultSet)
+      }
+      return resultSet
+    }
+
+    private val ALWAYS: AndroidBuildMirror.() -> Boolean = {
+      true
+    }
+
+    /**
+     * Creates a [LibraryLeakReferenceMatcher] that matches a [StaticFieldPattern].
+     */
+    fun staticFieldLeak(
+      className: String,
+      fieldName: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(StaticFieldPattern(className, fieldName), description, patternApplies)
+    }
+
+    /**
+     * Creates a [LibraryLeakReferenceMatcher] that matches a [InstanceFieldPattern].
+     */
+    fun instanceFieldLeak(
+      className: String,
+      fieldName: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(InstanceFieldPattern(className, fieldName), description, patternApplies)
+    }
+
+    private fun libraryLeak(
+      referencePattern: ReferencePattern,
+      description: String,
+      patternApplies: AndroidBuildMirror.() -> Boolean
+    ): LibraryLeakReferenceMatcher {
+      return LibraryLeakReferenceMatcher(
+          pattern = referencePattern,
+          description = description,
+          patternApplies = { graph ->
+            graph.androidBuildMirror.patternApplies()
+          }
+      )
+    }
+
+    /**
+     * Creates a [IgnoredReferenceMatcher] that matches a [InstanceFieldPattern].
+     */
+    fun ignoredInstanceField(
+      className: String,
+      fieldName: String
+    ): IgnoredReferenceMatcher {
+      return IgnoredReferenceMatcher(pattern = InstanceFieldPattern(className, fieldName))
+    }
+
+    /**
+     * Creates a [IgnoredReferenceMatcher] that matches a [JavaLocalPattern].
+     */
+    fun ignoredJavaLocal(
+      threadName: String
+    ): IgnoredReferenceMatcher {
+      return IgnoredReferenceMatcher(pattern = JavaLocalPattern(threadName))
+    }
+  }
+
+}
+
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
deleted file mode 100644
index 3cdfab9c..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-package leakcanary
-
-import kotlin.properties.Delegates.notNull
-
-/**
- * Turns BuildFilter into exclusion filters that HeapAnalyzer understand. Since retrieving from
- * the Hprof is not free, [BuildMirror] provides a caching mechanism. Make sure to use different
- * [BuildMirror] and set of filters for every hprof parsing.
- */
-class BuildMirror {
-
-  lateinit var manufacturer: String
-  var sdkInt: Int by notNull()
-
-  fun wrapFilter(filter: BuildFilter): (HprofGraph) -> Boolean = { graph ->
-    if (!::manufacturer.isInitialized) {
-      val buildClass = graph.indexedClass("android.os.Build")!!
-      val versionClass = graph.indexedClass("android.os.Build\$VERSION")!!
-      manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
-      sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
-    }
-    filter(manufacturer, sdkInt)
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
deleted file mode 100644
index d949e1b8..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
+++ /dev/null
@@ -1,89 +0,0 @@
-package leakcanary
-
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import java.io.Serializable
-
-/**
- * Deprioritizes specific references from being taken into account when computing the shortest strong
- * reference path from a suspected leaking instance to the GC roots.
- *
- * This class lets you ignore known memory leaks that you known about. If the shortest path
- * matches [Exclusion], than the heap analyzer should look for a longer path with nothing
- * matching in [Exclusion].
- *
- * Exclusions should be used to match patterns of known leaks that are beyond your control, for
- * examples leaks in the Android Framework or in 3rd party libraries. This won't fix the leaks,
- * and LeakCanary will still trigger, but at least it'll indicate that there's nothing you can do
- * about it.
- */
-data class Exclusion(
-  val type: ExclusionType,
-  val reason: String? = null,
-  val status: Status = WONT_FIX_LEAK,
-  val filter: (HprofGraph) -> Boolean = {true}
-) {
-  val description
-    get() = ExclusionDescription(type.matching, reason)
-
-  // Note: the enum order matters for shortest paths, do not reorder
-  enum class Status {
-    /**
-     * References matching this cannot create leaks.
-     * The shortest path finder will never go through references that match this exclusion.
-     */
-    NEVER_REACHABLE,
-    /**
-     * References matching this are known to create leaks, but those leaks will not be fixed.
-     * The shortest path finder will only go through references that match this exclusion after it
-     * has exhausted references that don't match any exclusion.
-     */
-    WONT_FIX_LEAK,
-    /**
-     * The shortest path finder will only go through references that match this exclusion after it
-     * has exhausted references that match known leak exclusions.
-     */
-    WEAKLY_REACHABLE
-  }
-
-  sealed class ExclusionType {
-    abstract val matching: String
-
-    /**
-     * Local references held in the stack of frames of a given thread.
-     */
-    class JavaLocalExclusion(
-      val threadName: String
-    ) : ExclusionType() {
-      override val matching: String
-        get() = "local variable on thread $threadName"
-    }
-
-    class StaticFieldExclusion(
-      val className: String,
-      val fieldName: String
-    ) : ExclusionType() {
-      override val matching: String
-        get() = "static field $className#$fieldName"
-    }
-
-    /**
-     * Excludes a member field of an instance of a class. [fieldName] can belong to a superclass
-     * and will still match for subclasses. This is to support overriding of rules for specific
-     * cases. If two exclusions for the same field name but different classname match in a class
-     * hierarchy, then the closest class in the hierarchy wins.
-     */
-    class InstanceFieldExclusion(
-      val className: String,
-      val fieldName: String
-    ) : ExclusionType() {
-      override val matching: String
-        get() = "field $className#$fieldName"
-    }
-  }
-
-}
-
-class ExclusionDescription(
-  val matching: String,
-  val reason: String? = null
-) : Serializable
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
index b4ba3a67..f9f25588 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
@@ -1,6 +1,8 @@
 package leakcanary
 
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import leakcanary.Leak.ApplicationLeak
+import leakcanary.Leak.LibraryLeak
+import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
 import leakcanary.internal.createSHA1Hash
 import java.io.File
 import java.io.Serializable
@@ -23,60 +25,63 @@ data class HeapAnalysisSuccess(
   override val heapDumpFile: File,
   override val createdAtTimeMillis: Long,
   override val analysisDurationMillis: Long,
-  val leakingInstances: List<LeakingInstance>
-) : HeapAnalysis()
+  val applicationLeaks: List<ApplicationLeak>,
+  val libraryLeaks: List<LibraryLeak>
+) : HeapAnalysis() {
+  val allLeaks: List<Leak>
+    get() = applicationLeaks + libraryLeaks
+}
 
-data class LeakingInstance(
+sealed class Leak : Serializable {
   /**
    * Class name of the leaking instance.
    * The class name format is the same as what would be returned by [Class.getName].
    */
-  val instanceClassName: String,
-  /**
-   * True if the only path to the leaking reference is through excluded references. Usually, that
-   * means you can safely ignore this report.
-   */
-  val exclusionStatus: Exclusion.Status?,
+  abstract val className: String
+
   /**
-   * Shortest path to GC roots for the leaking instance.
+   * Shortest path from GC roots to the leaking object.
    */
-  val leakTrace: LeakTrace,
+  abstract val leakTrace: LeakTrace
   /**
    * The number of bytes which would be freed if all references to the leaking object were
    * released. Null if the retained heap size was not computed.
    */
-  val retainedHeapSize: Int?
-
-) : Serializable {
+  abstract val retainedHeapSize: Int?
 
-  val groupHash = createGroupHash()
+  val groupHash
+    get() = createGroupHash()
 
-  val instanceClassSimpleName: String
+  val classSimpleName: String
     get() {
-      val separator = instanceClassName.lastIndexOf('.')
-      return if (separator == -1) instanceClassName else instanceClassName.substring(separator + 1)
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) className else className.substring(separator + 1)
     }
 
-  private fun createGroupHash(): String {
-    val uniqueString = if (exclusionStatus == WONT_FIX_LEAK) {
-      leakTrace.firstElementExclusion.matching
-    } else {
-      leakTrace.leakCauses
+  abstract fun createGroupHash(): String
+
+  data class LibraryLeak(
+    override val className: String,
+    override val leakTrace: LeakTrace,
+    override val retainedHeapSize: Int?,
+    val pattern: ReferencePattern,
+    val description: String
+  ) : Leak() {
+    override fun createGroupHash() = pattern.toString().createSHA1Hash()
+  }
+
+  data class ApplicationLeak(
+    override val className: String,
+    override val leakTrace: LeakTrace,
+    override val retainedHeapSize: Int?
+  ) : Leak() {
+    override fun createGroupHash(): String {
+      return leakTrace.leakCauses
           .joinToString(separator = "") { element ->
             val referenceName = element.reference!!.groupingName
             element.className + referenceName
           }
+          .createSHA1Hash()
     }
-    return uniqueString.createSHA1Hash()
   }
-}
-
-fun HeapAnalysis.leakingInstances(): List<LeakingInstance> {
-  return when (this) {
-    is HeapAnalysisFailure -> emptyList()
-    is HeapAnalysisSuccess -> leakingInstances
-  }
-}
-
-fun HeapAnalysis.applicationLeaks(): List<LeakingInstance> =
-  leakingInstances().filter { it.exclusionStatus == null }
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index 78a07fed..0f0cf088 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -18,9 +18,8 @@ package leakcanary
 import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
 import leakcanary.AnalyzerProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
 import leakcanary.AnalyzerProgressListener.Step.COMPUTING_RETAINED_SIZE
-import leakcanary.AnalyzerProgressListener.Step.FINDING_WATCHED_REFERENCES
-import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
-import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
+import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_INSTANCES
+import leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP
 import leakcanary.GcRoot.JavaFrame
 import leakcanary.GcRoot.JniGlobal
 import leakcanary.GcRoot.JniLocal
@@ -37,8 +36,8 @@ import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
 import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
 import leakcanary.HeapAnalyzer.TrieNode.LeafNode
 import leakcanary.HeapAnalyzer.TrieNode.ParentNode
-import leakcanary.LeakNode.ChildNode
-import leakcanary.LeakNode.RootNode
+import leakcanary.Leak.ApplicationLeak
+import leakcanary.Leak.LibraryLeak
 import leakcanary.LeakNodeStatus.LEAKING
 import leakcanary.LeakNodeStatus.NOT_LEAKING
 import leakcanary.LeakNodeStatus.UNKNOWN
@@ -46,9 +45,11 @@ import leakcanary.LeakTraceElement.Holder.ARRAY
 import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.internal.GcRootRecordListener
+import leakcanary.internal.ReferencePathNode
+import leakcanary.internal.ReferencePathNode.ChildNode
+import leakcanary.internal.ReferencePathNode.ChildNode.LibraryLeakNode
+import leakcanary.internal.ReferencePathNode.RootNode
 import leakcanary.internal.ShortestPathFinder
-import leakcanary.internal.ShortestPathFinder.Result
 import leakcanary.internal.ShortestPathFinder.Results
 import leakcanary.internal.hppc.LongLongScatterMap
 import leakcanary.internal.lastSegment
@@ -70,7 +71,7 @@ class HeapAnalyzer constructor(
    */
   fun checkForLeaks(
     heapDumpFile: File,
-    exclusions: List<Exclusion> = emptyList(),
+    referenceMatchers: List<ReferenceMatcher> = emptyList(),
     computeRetainedHeapSize: Boolean = false,
     objectInspectors: List<ObjectInspector> = emptyList(),
     leakFinders: List<ObjectInspector> = objectInspectors
@@ -85,37 +86,33 @@ class HeapAnalyzer constructor(
       )
     }
 
-    listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
-
     try {
-      listener.onProgressUpdate(SCANNING_HEAP_DUMP)
-
-      val gcRootRecordListener = GcRootRecordListener()
-      val (graph, hprofCloseable) = HprofGraph.readHprof(heapDumpFile, gcRootRecordListener)
+      listener.onProgressUpdate(PARSING_HEAP_DUMP)
+      val (graph, hprofCloseable) = HprofGraph.readHprof(heapDumpFile)
 
       hprofCloseable.use {
-        val analysisResults = mutableListOf<LeakingInstance>()
-        listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
+        listener.onProgressUpdate(FINDING_LEAKING_INSTANCES)
 
         val leakingInstanceObjectIds = findLeakingInstances(graph, leakFinders)
 
-        val (pathResults, dominatedInstances) =
+        val (shortestPathsToLeakingInstances, dominatedInstances) =
           findShortestPaths(
-              graph, exclusions, leakingInstanceObjectIds, gcRootRecordListener.gcRoots,
-              computeRetainedHeapSize
+              graph, referenceMatchers, leakingInstanceObjectIds, computeRetainedHeapSize
           )
 
         val retainedSizes = if (computeRetainedHeapSize) {
-          computeRetainedSizes(graph, pathResults, dominatedInstances)
+          computeRetainedSizes(graph, shortestPathsToLeakingInstances, dominatedInstances)
         } else {
           null
         }
 
-        buildLeakTraces(objectInspectors, pathResults, graph, analysisResults, retainedSizes)
+        val (applicationLeaks, libraryLeaks) = buildLeakTraces(
+            objectInspectors, shortestPathsToLeakingInstances, graph, retainedSizes
+        )
 
         return HeapAnalysisSuccess(
             heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-            analysisResults
+            applicationLeaks, libraryLeaks
         )
       }
     } catch (exception: Throwable) {
@@ -130,7 +127,7 @@ class HeapAnalyzer constructor(
     graph: HprofGraph,
     objectInspectors: List<ObjectInspector>
   ): Set<Long> {
-    return graph.objectSequence()
+    return graph.objects
         .filter { objectRecord ->
           val reporter = ObjectReporter(objectRecord)
           objectInspectors.forEach { inspector ->
@@ -144,14 +141,13 @@ class HeapAnalyzer constructor(
 
   private fun findShortestPaths(
     graph: HprofGraph,
-    exclusions: List<Exclusion>,
+    referenceMatchers: List<ReferenceMatcher>,
     leakingInstanceObjectIds: Set<Long>,
-    gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean
   ): Results {
     val pathFinder = ShortestPathFinder()
     return pathFinder.findPaths(
-        graph, exclusions, leakingInstanceObjectIds, gcRootIds, computeDominators, listener
+        graph, referenceMatchers, leakingInstanceObjectIds, computeDominators, listener
     )
   }
 
@@ -160,38 +156,41 @@ class HeapAnalyzer constructor(
 
     class ParentNode(override val objectId: Long) : TrieNode() {
       val children = mutableMapOf<Long, TrieNode>()
+      override fun toString(): String {
+        return "ParentNode(objectId=$objectId, children=$children)"
+      }
     }
 
     class LeafNode(
       override val objectId: Long,
-      val result: Result
+      val pathNode: ReferencePathNode
     ) : TrieNode()
 
   }
 
-  private fun deduplicateResults(inputPathResults: List<Result>): List<Result> {
+  private fun deduplicateShortestPaths(inputPathResults: List<ReferencePathNode>): List<ReferencePathNode> {
     val rootTrieNode = ParentNode(0)
 
-    for (result in inputPathResults) {
+    for (pathNode in inputPathResults) {
       // Go through the linked list of nodes and build the reverse list of instances from
       // root to leaking.
       val path = mutableListOf<Long>()
-      var leakNode: LeakNode = result.leakingNode
+      var leakNode: ReferencePathNode = pathNode
       while (leakNode is ChildNode) {
         path.add(0, leakNode.instance)
         leakNode = leakNode.parent
       }
       path.add(0, leakNode.instance)
-      updateTrie(result, path, 0, rootTrieNode)
+      updateTrie(pathNode, path, 0, rootTrieNode)
     }
 
-    val outputPathResults = mutableListOf<Result>()
+    val outputPathResults = mutableListOf<ReferencePathNode>()
     findResultsInTrie(rootTrieNode, outputPathResults)
     return outputPathResults
   }
 
   private fun updateTrie(
-    result: Result,
+    pathNode: ReferencePathNode,
     path: List<Long>,
     pathIndex: Int,
     parentNode: ParentNode
@@ -199,7 +198,7 @@ class HeapAnalyzer constructor(
     val objectId = path[pathIndex]
     if (pathIndex == path.lastIndex) {
       // Replace any preexisting children, this is shorter.
-      parentNode.children[objectId] = LeafNode(objectId, result)
+      parentNode.children[objectId] = LeafNode(objectId, pathNode)
     } else {
       val childNode = parentNode.children[objectId] ?: {
         val newChildNode = ParentNode(objectId)
@@ -207,14 +206,14 @@ class HeapAnalyzer constructor(
         newChildNode
       }()
       if (childNode is ParentNode) {
-        updateTrie(result, path, pathIndex + 1, childNode)
+        updateTrie(pathNode, path, pathIndex + 1, childNode)
       }
     }
   }
 
   private fun findResultsInTrie(
     parentNode: ParentNode,
-    outputPathResults: MutableList<Result>
+    outputPathResults: MutableList<ReferencePathNode>
   ) {
     parentNode.children.values.forEach { childNode ->
       when (childNode) {
@@ -222,7 +221,7 @@ class HeapAnalyzer constructor(
           findResultsInTrie(childNode, outputPathResults)
         }
         is LeafNode -> {
-          outputPathResults += childNode.result
+          outputPathResults += childNode.pathNode
         }
       }
     }
@@ -230,7 +229,7 @@ class HeapAnalyzer constructor(
 
   private fun computeRetainedSizes(
     graph: HprofGraph,
-    results: List<Result>,
+    results: List<ReferencePathNode>,
     dominatedInstances: LongLongScatterMap
   ): List<Int> {
     listener.onProgressUpdate(COMPUTING_NATIVE_RETAINED_SIZE)
@@ -247,13 +246,13 @@ class HeapAnalyzer constructor(
     // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
     // the CleanerThunk. The hprof does not include the native bytes pointed to.
 
-    graph.instanceSequence()
+    graph.instances
         .filter { it.className == "sun.misc.Cleaner" }
         .forEach { cleaner ->
           val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
-          val thunkId = thunkField?.value?.asNonNullObjectIdReference
+          val thunkId = thunkField?.value?.asNonNullObjectId
           val referentId =
-            cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectIdReference
+            cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectId
           if (thunkId != null && referentId != null) {
             val thunkRecord = thunkField.value.asObject
             if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
@@ -278,10 +277,10 @@ class HeapAnalyzer constructor(
 
     // Include self size for leaking instances
     val leakingInstanceIds = mutableSetOf<Long>()
-    results.forEach { result ->
-      val leakingInstanceObjectId = result.leakingNode.instance
+    results.forEach { pathNode ->
+      val leakingInstanceObjectId = pathNode.instance
       leakingInstanceIds.add(leakingInstanceObjectId)
-      val instanceRecord = graph.indexedObject(leakingInstanceObjectId).asInstance!!
+      val instanceRecord = graph.findObjectByObjectId(leakingInstanceObjectId).asInstance!!
       val classRecord = instanceRecord.instanceClass
       var retainedSize = sizeByDominator.getValue(leakingInstanceObjectId)
 
@@ -296,7 +295,14 @@ class HeapAnalyzer constructor(
       if (instanceId !in leakingInstanceIds) {
         val currentSize = sizeByDominator.getValue(dominatorId)
         val nativeSize = nativeSizes.getValue(instanceId)
-        val shallowSize = graph.computeShallowSize(graph.indexedObject(instanceId))
+        val shallowSize = when (val objectRecord = graph.findObjectByObjectId(instanceId)) {
+          is GraphInstanceRecord -> objectRecord.size
+          is GraphObjectArrayRecord -> objectRecord.readSize()
+          is GraphPrimitiveArrayRecord -> objectRecord.readSize()
+          is GraphClassRecord -> throw IllegalStateException(
+              "Unexpected class record $objectRecord"
+          )
+        }
         sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
       }
     }
@@ -306,7 +312,7 @@ class HeapAnalyzer constructor(
     var sizedMoved: Boolean
     do {
       sizedMoved = false
-      results.map { it.leakingNode.instance }
+      results.map { it.instance }
           .forEach { leakingInstanceId ->
             val dominator = dominatedInstances[leakingInstanceId]
             if (dominator != null) {
@@ -321,62 +327,67 @@ class HeapAnalyzer constructor(
           }
     } while (sizedMoved)
     dominatedInstances.release()
-    return results.map { result ->
-      sizeByDominator[result.leakingNode.instance]!!
+    return results.map { pathNode ->
+      sizeByDominator[pathNode.instance]!!
     }
   }
 
   private fun buildLeakTraces(
     objectInspectors: List<ObjectInspector>,
-    pathResults: List<Result>,
+    shortestPathsToLeakingInstances: List<ReferencePathNode>,
     graph: HprofGraph,
-    analysisResults: MutableList<LeakingInstance>,
     retainedSizes: List<Int>?
-  ) {
+  ): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
     listener.onProgressUpdate(BUILDING_LEAK_TRACES)
 
-    val deduplicatedResults = deduplicateResults(pathResults)
+    val applicationLeaks = mutableListOf<ApplicationLeak>()
+    val libraryLeaks = mutableListOf<LibraryLeak>()
+
+    val deduplicatedPaths = deduplicateShortestPaths(shortestPathsToLeakingInstances)
+
+    deduplicatedPaths.forEachIndexed { index, pathNode ->
+      val shortestChildPath = mutableListOf<ChildNode>()
+
+      var node: ReferencePathNode = pathNode
+      while (node is ChildNode) {
+        shortestChildPath.add(0, node)
+        node = node.parent
+      }
+      val rootNode = node as RootNode
 
-    deduplicatedResults.forEachIndexed { index, pathResult ->
       val leakTrace =
-        buildLeakTrace(graph, objectInspectors, pathResult.leakingNode)
+        buildLeakTrace(graph, objectInspectors, rootNode, shortestChildPath)
 
-      // We get the class name from the heap dump rather than the weak reference because primitive
-      // arrays are more readable that way, e.g. "[C" at runtime vs "char[]" in the heap dump.
-      val instanceClassName =
-        recordClassName(graph.indexedObject(pathResult.leakingNode.instance))
+      val className =
+        recordClassName(graph.findObjectByObjectId(pathNode.instance))
 
-      val leakDetected = LeakingInstance(
-          instanceClassName = instanceClassName,
-          exclusionStatus = pathResult.exclusionStatus, leakTrace = leakTrace,
-          retainedHeapSize = retainedSizes?.get(index)
-      )
-      analysisResults += leakDetected
+      val firstLibraryLeakNode =
+        shortestChildPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
+
+      if (firstLibraryLeakNode != null) {
+        val matcher = firstLibraryLeakNode.matcher
+        libraryLeaks += LibraryLeak(
+            className, leakTrace, retainedSizes?.get(index), matcher.pattern, matcher.description
+        )
+      } else {
+        applicationLeaks += ApplicationLeak(className, leakTrace, retainedSizes?.get(index))
+      }
     }
+    return applicationLeaks to libraryLeaks
   }
 
   private fun buildLeakTrace(
     graph: HprofGraph,
     objectInspectors: List<ObjectInspector>,
-    leakingNode: LeakNode
+    rootNode: RootNode,
+    shortestChildPath: List<ChildNode>
   ): LeakTrace {
-    val elements = ArrayList<LeakTraceElement>()
-    // We iterate from the leak to the GC root
-    val ignored = leakingNode.instance
-
-    val leafNode = ChildNode(ignored, Int.MAX_VALUE, null, leakingNode, null)
-
-    var node: LeakNode = leafNode
-    val nodes = mutableListOf<LeakNode>()
-    val leakReporters = mutableListOf<ObjectReporter>()
-    while (node is ChildNode) {
-      nodes.add(0, node.parent)
-      leakReporters.add(
-          0, ObjectReporter(graph.indexedObject(node.parent.instance))
-      )
-      node = node.parent
+    val shortestPath = shortestChildPath.toMutableList<ReferencePathNode>()
+    shortestPath.add(0, rootNode)
+
+    val leakReporters = shortestPath.map {
+      ObjectReporter(graph.findObjectByObjectId(it.instance))
     }
-    val rootNode = node as RootNode
 
     // Looping on inspectors first to get more cache hits.
     objectInspectors.forEach { inspector ->
@@ -387,13 +398,12 @@ class HeapAnalyzer constructor(
 
     val leakStatuses = computeLeakStatuses(rootNode, leakReporters)
 
-    node = leafNode
-    while (node is ChildNode) {
-      val index = (nodes.size - elements.size) - 1
+    val elements = shortestPath.mapIndexed { index, pathNode ->
       val leakReporter = leakReporters[index]
       val leakStatus = leakStatuses[index]
-      elements.add(0, buildLeakElement(graph, node, leakReporter.labels, leakStatus))
-      node = node.parent
+      val reference =
+        if (index < shortestPath.lastIndex) (shortestPath[index + 1] as ChildNode).referenceFromParent else null
+      buildLeakElement(graph, pathNode, reference, leakReporter.labels, leakStatus)
     }
     return LeakTrace(elements)
   }
@@ -508,13 +518,14 @@ class HeapAnalyzer constructor(
 
   private fun buildLeakElement(
     graph: HprofGraph,
-    node: ChildNode,
+    node: ReferencePathNode,
+    reference: LeakReference?,
     labels: List<String>,
     leakStatus: LeakNodeStatusAndReason
   ): LeakTraceElement {
-    val objectId = node.parent.instance
+    val objectId = node.instance
 
-    val graphRecord = graph.indexedObject(objectId)
+    val graphRecord = graph.findObjectByObjectId(objectId)
 
     val className = recordClassName(graphRecord)
 
@@ -530,9 +541,7 @@ class HeapAnalyzer constructor(
         OBJECT
       }
     }
-    return LeakTraceElement(
-        node.leakReference, holderType, className, node.exclusion, labels, leakStatus
-    )
+    return LeakTraceElement(reference, holderType, className, labels, leakStatus)
   }
 
   private fun recordClassName(
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
deleted file mode 100644
index 9ea3e5d2..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-package leakcanary
-
-sealed class LeakNode {
-  abstract val instance: Long
-  /** Used by the shortest path finder to create a segmented FIFO queue using a priority queue. */
-  abstract val visitOrder: Int
-
-  class RootNode(
-    val gcRoot: GcRoot,
-    override val instance: Long,
-    override val visitOrder: Int
-  ) : LeakNode()
-
-  class ChildNode(
-    override val instance: Long,
-    override val visitOrder: Int,
-    val exclusion: ExclusionDescription?,
-    val parent: LeakNode,
-    /**
-     * The reference from the parent to this node
-     */
-    val leakReference: LeakReference?
-  ) : LeakNode()
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
index c577e693..a12d5238 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
@@ -12,12 +12,6 @@ import java.io.Serializable
 data class LeakTrace(
   val elements: List<LeakTraceElement>
 ) : Serializable {
-
-  val firstElementExclusion
-    get() = elements.first { element ->
-      element.exclusion != null
-    }.exclusion!!
-
   val leakCauses = elements.filterIndexed { index, _ ->
     elementMayBeLeakCause(index)
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
index 940bf3fa..41dafe75 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
@@ -14,9 +14,6 @@ data class LeakTraceElement(
 
   val className: String,
 
-  /** If not null, there was no path that could exclude this element.  */
-  val exclusion: ExclusionDescription?,
-
   /**
    * Ordered labels that were computed during analysis. A label provides
    * extra information that helps understand the leak trace element.
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
index 3c0be75f..f2724880 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
@@ -1,8 +1,44 @@
 package leakcanary
 
+/**
+ * Provides LeakCanary with insights about objects (classes, instances and arrays) found in the
+ * heap. [inspect] will be called for each object that LeakCanary wants to know more about.
+ * The implementation can then use the provided [ObjectReporter] to provide insights for that
+ * object.
+ *
+ * You can create a [ObjectInspector] from a lambda by calling [invoke].
+ */
 interface ObjectInspector {
+
+  /**
+   * @see [ObjectInspector]
+   */
   fun inspect(
     graph: HprofGraph,
     reporter: ObjectReporter
   )
+
+  companion object {
+    /**
+     * Utility function to create a [ObjectInspector] from the passed in [block] lambda instead of
+     * using the anonymous `object : OnHeapAnalyzedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val inspector = ObjectInspector { graph, reporter ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HprofGraph, ObjectReporter) -> Unit): ObjectInspector =
+      object : ObjectInspector {
+        override fun inspect(
+          graph: HprofGraph,
+          reporter: ObjectReporter
+        ) {
+          block(graph, reporter)
+        }
+      }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt b/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
index 3f00f5c6..c98338ae 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
@@ -1,6 +1,13 @@
 package leakcanary
 
-class ObjectReporter(val objectRecord: GraphObjectRecord) {
+/**
+ * Enables [ObjectInspector] implementations to provide insights on [objectRecord], which is
+ * an object (class, instance or array) found in the heap.
+ *
+ * A given [ObjectReporter] only maps to one object in the heap, but is shared to many
+ * [ObjectInspector] implementations and accumulates insights.
+ */
+class ObjectReporter internal constructor(val objectRecord: GraphObjectRecord) {
 
   private val mutableLabels = mutableListOf<String>()
 
@@ -8,36 +15,54 @@ class ObjectReporter(val objectRecord: GraphObjectRecord) {
   private val mutableLikelyLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
   private val mutableNotLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
 
+  /**
+   * All labels added via [addLabel] for the [objectRecord] instance.
+   */
   val labels: List<String>
     get() = mutableLabels
 
+  /**
+   * All leaking insights added via [reportLikelyLeaking], [reportLeaking] and [reportNotLeaking]
+   * for the [objectRecord] instance.
+   */
   val leakNodeStatuses: List<LeakNodeStatusAndReason>
     get() = mutableLeakingStatuses + mutableLikelyLeakingStatuses + mutableNotLeakingStatuses
 
+  /**
+   * All leaking insights added via [reportLeaking] for the [objectRecord] instance.
+   */
   val leakingStatuses: List<LeakNodeStatusAndReason>
     get() = mutableLeakingStatuses
 
+  /**
+   * Adds a label that will be visible on the corresponding node in the leak trace.
+   */
   fun addLabel(label: String) {
     mutableLabels += label
   }
 
-
   /**
-   * The inspector is almost sure this instance is leaking, but not 100%. This information will
-   * be used for decorating leaktraces, but [HeapAnalyzer] will not look for these instances.
+   * @see [reportLeaking]
    */
   fun reportLikelyLeaking(reason: String) {
     mutableLikelyLeakingStatuses += LeakNodeStatus.leaking(reason)
   }
 
   /**
-   * The inspector is 100% sure this instance is leaking. [HeapAnalyzer] will look for these
-   * instances.
+   * Call this to let LeakCanary know that this instance was expected to be unreachable, ie that
+   * it's leaking.
+   *
+   * Only call this method if you're 100% sure this instance is leaking, otherwise call
+   * [reportLikelyLeaking]. The difference is that instances that are "likely leaking" are not
+   * considered to be leaking instances on which LeakCanary should compute the leak trace.
    */
   fun reportLeaking(reason: String) {
     mutableLeakingStatuses += LeakNodeStatus.leaking(reason)
   }
 
+  /**
+   * Call this to let LeakCanary know that this instance was expected to be reachable.
+   */
   fun reportNotLeaking(reason: String) {
     mutableNotLeakingStatuses += LeakNodeStatus.notLeaking(reason)
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt b/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt
new file mode 100644
index 00000000..8233c3c0
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt
@@ -0,0 +1,36 @@
+package leakcanary
+
+/**
+ * Used to pattern match known patterns of references in the heap, either to ignore them
+ * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+ */
+sealed class ReferenceMatcher {
+
+  /** The pattern that references will be matched against. */
+  abstract val pattern: ReferencePattern
+
+  /**
+   * [LibraryLeakReferenceMatcher] should be used to match references in library code that are
+   * known to create leaks and are beyond your control. The shortest path finder will only go
+   * through matching references after it has exhausted references that don't match, prioritizing
+   * finding an application leak over a known library leak. Library leaks will be reported as
+   * [Leak.LibraryLeak] instead of [Leak.ApplicationLeak].
+   */
+  data class LibraryLeakReferenceMatcher(
+    override val pattern: ReferencePattern,
+    val description: String = "",
+    /**
+     * Whether the identified leak may exist in the provided [HprofGraph]. Defaults to true. If
+     * the heap dump comes from a VM that runs a different version of the library that doesn't
+     * have the leak, then this should return false.
+     */
+    val patternApplies: (HprofGraph) -> Boolean = { true }
+  ) : ReferenceMatcher()
+
+  /**
+   * [IgnoredReferenceMatcher] should be used to match references that cannot ever create leaks. The
+   * shortest path finder will never go through matching references.
+   */
+  class IgnoredReferenceMatcher(override val pattern: ReferencePattern) : ReferenceMatcher()
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt b/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt
new file mode 100644
index 00000000..f80a3c8d
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt
@@ -0,0 +1,49 @@
+package leakcanary
+
+import java.io.Serializable
+
+/**
+ * A pattern that will match references for a given [ReferenceMatcher].
+ */
+sealed class ReferencePattern : Serializable {
+
+  /**
+   * Matches local references held in the stack of frames of a given thread, identified by its name.
+   */
+  data class JavaLocalPattern(
+    val threadName: String
+  ) : ReferencePattern() {
+    override fun toString(): String {
+      return "local variable on thread $threadName"
+    }
+  }
+
+  /**
+   * Matches static field references, identified by [className] and [fieldName].
+   */
+  data class StaticFieldPattern(
+    val className: String,
+    val fieldName: String
+  ) : ReferencePattern() {
+    override fun toString(): String {
+      return "static field $className#$fieldName"
+    }
+  }
+
+  /**
+   * Matches instances field references, identified by [className] and [fieldName].
+   *
+   * Note: If [fieldName] is declared in a superclass it will still match for subclasses.
+   * This is to support overriding of rules for specific cases. If two [ReferenceMatcher] match for
+   * the same [fieldName] but for different [className] in a class hierarchy, then the closest
+   * class in the hierarchy wins.
+   */
+  data class InstanceFieldPattern(
+    val className: String,
+    val fieldName: String
+  ) : ReferencePattern() {
+    override fun toString(): String {
+      return "instance field $className#$fieldName"
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/GcRootRecordListener.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/GcRootRecordListener.kt
deleted file mode 100644
index 2c3aacde..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/GcRootRecordListener.kt
+++ /dev/null
@@ -1,62 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.GcRoot
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.ReferenceCleanup
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.Record
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import kotlin.reflect.KClass
-
-internal class GcRootRecordListener : OnRecordListener {
-
-  val gcRoots = mutableListOf<GcRoot>()
-
-  override fun recordTypes(): Set<KClass<out Record>> = setOf(GcRootRecord::class)
-
-  override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
-  }
-
-  override fun onRecord(
-    position: Long,
-    record: Record
-  ) {
-    when (record) {
-      is GcRootRecord -> {
-        // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
-        // to do? What's VmInternal exactly? History does not go further than
-        // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
-        // We should log to figure out what objects VmInternal points to.
-        when (record.gcRoot) {
-          // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
-          // belongs to
-          is ThreadObject,
-          is JniGlobal,
-          is JniLocal,
-          is JavaFrame,
-          is NativeStack,
-          is StickyClass,
-          is ThreadBlock,
-          is MonitorUsed,
-            // TODO What is this and why do we care about it as a root?
-          is ReferenceCleanup,
-          is JniMonitor
-          -> {
-            gcRoots.add(record.gcRoot)
-          }
-        }
-      }
-      else -> {
-        throw IllegalArgumentException("Unexpected record $record")
-      }
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
index e47af626..93b5bd20 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -1,6 +1,7 @@
 package leakcanary.internal
 
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.HeapValue
 import leakcanary.HeapValue.ObjectReference
 
 internal class KeyedWeakReferenceMirror(
@@ -14,7 +15,7 @@ internal class KeyedWeakReferenceMirror(
   val retainedDurationMillis: Long?
 ) {
 
-  val hasReferent = referent.value != 0L
+  val hasReferent = referent.value != HeapValue.NULL_REFERENCE
 
   val isRetained = retainedDurationMillis == null || retainedDurationMillis != -1L
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
index 476a011f..b961d12c 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
@@ -11,7 +11,7 @@ import leakcanary.LeakTraceElement.Holder.THREAD
 import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import java.util.Locale
 
-fun LeakTrace.renderToString(): String {
+internal fun LeakTrace.renderToString(): String {
   var result = "┬"
 
   elements.forEachIndexed { index, element ->
@@ -32,10 +32,6 @@ fun LeakTrace.renderToString(): String {
     val currentReachability = elements[index].leakStatusAndReason
     result += "\n" + contentPrefix + "Leaking: " + currentReachability.renderToString()
 
-    if (element.exclusion != null) {
-      result += "\n" + contentPrefix + "Matches exclusion ${element.exclusion.matching}"
-    }
-
     for (label in element.labels) {
       result += "\n" + contentPrefix + label
     }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt
new file mode 100644
index 00000000..22a229c3
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt
@@ -0,0 +1,38 @@
+package leakcanary.internal
+
+import leakcanary.GcRoot
+import leakcanary.LeakReference
+import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
+
+internal sealed class ReferencePathNode {
+  abstract val instance: Long
+
+  class RootNode(
+    val gcRoot: GcRoot,
+    override val instance: Long
+  ) : ReferencePathNode()
+
+  sealed class ChildNode : ReferencePathNode() {
+
+    abstract val parent: ReferencePathNode
+
+    /**
+     * The reference from the parent to this node
+     */
+    abstract val referenceFromParent: LeakReference
+
+    class LibraryLeakNode(
+      override val instance: Long,
+      override val parent: ReferencePathNode,
+      override val referenceFromParent: LeakReference,
+      val matcher: LibraryLeakReferenceMatcher
+    ) : ChildNode()
+
+    class NormalNode(
+      override val instance: Long,
+      override val parent: ReferencePathNode,
+      override val referenceFromParent: LeakReference
+    ) : ChildNode()
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index 110001cf..8b1f4c5d 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -17,103 +17,91 @@ package leakcanary.internal
 
 import leakcanary.AnalyzerProgressListener
 import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
-import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
+import leakcanary.AnalyzerProgressListener.Step.FINDING_PATHS_TO_LEAKING_INSTANCES
 import leakcanary.CanaryLog
-import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.Status
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.GcRoot
 import leakcanary.GcRoot.JavaFrame
 import leakcanary.GcRoot.ThreadObject
+import leakcanary.GraphObjectRecord
 import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
 import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
+import leakcanary.HeapValue
 import leakcanary.HprofGraph
 import leakcanary.HprofReader
-import leakcanary.LeakNode
-import leakcanary.LeakNode.ChildNode
-import leakcanary.LeakNode.RootNode
 import leakcanary.LeakReference
 import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
 import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
 import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.ReferenceMatcher
+import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
+import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
+import leakcanary.internal.ReferencePathNode.ChildNode.LibraryLeakNode
+import leakcanary.internal.ReferencePathNode.ChildNode.NormalNode
+import leakcanary.internal.ReferencePathNode.RootNode
+import leakcanary.ReferencePattern
+import leakcanary.ReferencePattern.InstanceFieldPattern
+import leakcanary.ReferencePattern.StaticFieldPattern
 import leakcanary.internal.hppc.LongLongScatterMap
 import leakcanary.internal.hppc.LongScatterSet
+import java.util.ArrayDeque
+import java.util.Deque
 import java.util.LinkedHashMap
-import java.util.PriorityQueue
 
 /**
  * Not thread safe.
  *
- * Finds the shortest path from leaking references to a gc root, ignoring excluded
- * refs first and then including the ones that are not "always ignorable" as needed if no path is
+ * Finds the shortest path from leaking references to a gc root, first ignoring references
+ * identified as "to visit last" and then visiting them as needed if no path is
  * found.
- *
- * Skips enqueuing strings as an optimization, so if the leaking reference is a string then it will
- * never be found.
  */
 internal class ShortestPathFinder {
 
+  /** Set of instances to visit */
+  private val toVisitQueue: Deque<ReferencePathNode> = ArrayDeque()
+  private val toVisitLastQueue: Deque<LibraryLeakNode> = ArrayDeque()
   /**
-   * A segmented FIFO queue. The queue is segmented by [Status]. Within each segment the elements
-   * are ordered FIFO.
+   * Enables fast checking of whether a node is already in the queue.
    */
-  private val toVisitQueue = PriorityQueue<LeakNode>(1024, Comparator { node1, node2 ->
-    val priorityComparison = toVisitMap[node1.instance]!!.compareTo(toVisitMap[node2.instance]!!)
-    if (priorityComparison != 0) {
-      priorityComparison
-    } else {
-      node1.visitOrder.compareTo(node2.visitOrder)
-    }
-  })
-  /** Set of instances to visit */
-  private val toVisitMap = LinkedHashMap<Long, Status>()
+  private val toVisitSet = HashSet<Long>()
+  private val toVisitLastSet = HashSet<Long>()
+
   private val visitedSet = LongScatterSet()
   private lateinit var leakingInstanceObjectIds: Set<Long>
-  private var visitOrder = 0
 
   /**
    * Map of instances to their leaking dominator.
    * var because the instance will be returned by [findPaths] and replaced with a new empty map
    * here (copying it could be expensive).
    *
-   * If an instance has been added to [toVisitMap] or [visitedSet] and is missing from
+   * If an instance has been added to [toVisitSet] or [visitedSet] and is missing from
    * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
    * and cannot be dominated by a leaking instance.
    */
   private var dominatedInstances = LongLongScatterMap()
   private var sizeOfObjectInstances = 0
 
-  class Result(
-    val leakingNode: LeakNode,
-    val exclusionStatus: Status?
-  )
-
   data class Results(
-    val results: List<Result>,
+    val shortestPathsToLeakingInstances: List<ReferencePathNode>,
     val dominatedInstances: LongLongScatterMap
   )
 
   fun findPaths(
     graph: HprofGraph,
-    exclusions: List<Exclusion>,
+    referenceMatchers: List<ReferenceMatcher>,
     leakingInstanceObjectIds: Set<Long>,
-    gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean,
     listener: AnalyzerProgressListener
   ): Results {
-    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
+
+    listener.onProgressUpdate(FINDING_PATHS_TO_LEAKING_INSTANCES)
     clearState()
     this.leakingInstanceObjectIds = leakingInstanceObjectIds
 
-    val objectClass = graph.indexedClass("java.lang.Object")
+    val objectClass = graph.findClassByClassName("java.lang.Object")
     sizeOfObjectInstances = if (objectClass != null) {
       // In Android 16 ClassDumpRecord.instanceSize can be 8 yet there are 0 fields.
       // Better rely on our own computation of instance size.
@@ -135,61 +123,66 @@ internal class ShortestPathFinder {
       0
     }
 
-    val fieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
-    val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
-    val threadNames = mutableMapOf<String, Exclusion>()
+    val fieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
+    val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
+    val threadNames = mutableMapOf<String, ReferenceMatcher>()
 
-    exclusions.filter { it.filter(graph) }
-        .forEach { exclusion ->
-          when (exclusion.type) {
-            is ExclusionType.JavaLocalExclusion -> {
-              threadNames[exclusion.type.threadName] = exclusion
+    referenceMatchers.filter {
+      (it is IgnoredReferenceMatcher || (it is LibraryLeakReferenceMatcher && it.patternApplies(
+          graph
+      )))
+    }
+        .forEach { referenceMatcher ->
+          when (val pattern = referenceMatcher.pattern) {
+            is ReferencePattern.JavaLocalPattern -> {
+              threadNames[pattern.threadName] = referenceMatcher
             }
-            is StaticFieldExclusion -> {
-              val mapOrNull = staticFieldNameByClassName[exclusion.type.className]
+            is StaticFieldPattern -> {
+              val mapOrNull = staticFieldNameByClassName[pattern.className]
               val map = if (mapOrNull != null) mapOrNull else {
-                val newMap = mutableMapOf<String, Exclusion>()
-                staticFieldNameByClassName[exclusion.type.className] = newMap
+                val newMap = mutableMapOf<String, ReferenceMatcher>()
+                staticFieldNameByClassName[pattern.className] = newMap
                 newMap
               }
-              map[exclusion.type.fieldName] = exclusion
+              map[pattern.fieldName] = referenceMatcher
             }
-            is InstanceFieldExclusion -> {
-              val mapOrNull = fieldNameByClassName[exclusion.type.className]
+            is InstanceFieldPattern -> {
+              val mapOrNull = fieldNameByClassName[pattern.className]
               val map = if (mapOrNull != null) mapOrNull else {
-                val newMap = mutableMapOf<String, Exclusion>()
-                fieldNameByClassName[exclusion.type.className] = newMap
+                val newMap = mutableMapOf<String, ReferenceMatcher>()
+                fieldNameByClassName[pattern.className] = newMap
                 newMap
               }
-              map[exclusion.type.fieldName] = exclusion
+              map[pattern.fieldName] = referenceMatcher
             }
           }
         }
 
-    enqueueGcRoots(graph, gcRootIds, threadNames, computeDominators)
+    enqueueGcRoots(graph, threadNames, computeDominators)
 
-    var lowestPriority = ALWAYS_REACHABLE
-    val results = mutableListOf<Result>()
-    visitingQueue@ while (!toVisitQueue.isEmpty()) {
-      val node = toVisitQueue.poll()!!
-      val priority = toVisitMap[node.instance]!!
-      // Lowest priority has the highest value
-      if (priority > lowestPriority) {
-        lowestPriority = priority
+    val shortestPathsToLeakingInstances = mutableListOf<ReferencePathNode>()
+    visitingQueue@ while (!toVisitQueue.isEmpty() || !toVisitLastQueue.isEmpty()) {
+      val node = if (!toVisitQueue.isEmpty()) {
+        val removedNode = toVisitQueue.poll()
+        toVisitSet.remove(removedNode.instance)
+        removedNode
+      } else {
+        val removedNode = toVisitLastQueue.poll()
+        toVisitLastSet.remove(removedNode.instance)
+        removedNode
       }
 
-      toVisitMap.remove(node.instance)
-
       if (checkSeen(node)) {
-        continue
+        throw IllegalStateException(
+            "Node $node objectId=${node.instance} should not be enqueued when already visited or enqueued"
+        )
       }
 
       if (node.instance in leakingInstanceObjectIds) {
-        val exclusionPriority = if (lowestPriority == ALWAYS_REACHABLE) null else lowestPriority
-        results.add(Result(node, exclusionPriority))
+        shortestPathsToLeakingInstances.add(node)
         // Found all refs, stop searching (unless computing retained size which stops on weak reachables)
-        if (results.size == leakingInstanceObjectIds.size) {
-          if (computeDominators && lowestPriority < WEAKLY_REACHABLE) {
+        if (shortestPathsToLeakingInstances.size == leakingInstanceObjectIds.size) {
+          if (computeDominators) {
             listener.onProgressUpdate(FINDING_DOMINATORS)
           } else {
             break@visitingQueue
@@ -197,11 +190,7 @@ internal class ShortestPathFinder {
         }
       }
 
-      if (results.size == leakingInstanceObjectIds.size && computeDominators && lowestPriority >= WEAKLY_REACHABLE) {
-        break@visitingQueue
-      }
-
-      when (val graphRecord = graph.indexedObject(node.instance)) {
+      when (val graphRecord = graph.findObjectByObjectId(node.instance)) {
         is GraphClassRecord -> visitClassRecord(
             graph, graphRecord, node, staticFieldNameByClassName, computeDominators
         )
@@ -218,19 +207,20 @@ internal class ShortestPathFinder {
 
     clearState()
 
-    return Results(results, dominatedInstances)
+    return Results(shortestPathsToLeakingInstances, dominatedInstances)
   }
 
-  private fun checkSeen(node: LeakNode): Boolean {
+  private fun checkSeen(node: ReferencePathNode): Boolean {
     val neverSeen = visitedSet.add(node.instance)
     return !neverSeen
   }
 
   private fun clearState() {
     toVisitQueue.clear()
-    toVisitMap.clear()
+    toVisitLastQueue.clear()
+    toVisitSet.clear()
+    toVisitLastSet.clear()
     visitedSet.release()
-    visitOrder = 0
     dominatedInstances = LongLongScatterMap()
     leakingInstanceObjectIds = emptySet()
     sizeOfObjectInstances = 0
@@ -238,59 +228,59 @@ internal class ShortestPathFinder {
 
   private fun enqueueGcRoots(
     graph: HprofGraph,
-    gcRoots: MutableList<GcRoot>,
-    threadNameExclusions: Map<String, Exclusion>,
+    threadNameReferenceMatchers: Map<String, ReferenceMatcher>,
     computeDominators: Boolean
   ) {
-    gcRoots.removeAll { it.id == 0L }
-
-    // Sorting GC roots to get stable shortest path
-    // Once sorted all ThreadObject Gc Roots are located before JavaLocalExclusion Gc Roots.
-    // This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
-    // built before JavaFrames.
-    sortGcRoots(graph, gcRoots)
+    val gcRoots = sortedGcRoots(graph)
 
-    val threadsBySerialNumber = mutableMapOf<Int, ThreadObject>()
-    gcRoots.forEach { gcRoot ->
+    val threadsBySerialNumber = mutableMapOf<Int, Pair<GraphInstanceRecord, ThreadObject>>()
+    gcRoots.forEach { (objectRecord, gcRoot) ->
       if (computeDominators) {
         undominateWithSkips(graph, gcRoot.id)
       }
       when (gcRoot) {
         is ThreadObject -> {
-          threadsBySerialNumber[gcRoot.threadSerialNumber] = gcRoot
-          enqueue(graph, RootNode(gcRoot, gcRoot.id, visitOrder++), exclusionPriority = null)
+          threadsBySerialNumber[gcRoot.threadSerialNumber] = objectRecord.asInstance!! to gcRoot
+          enqueue(graph, RootNode(gcRoot, gcRoot.id))
         }
         is JavaFrame -> {
-          val threadRoot = threadsBySerialNumber.getValue(gcRoot.threadSerialNumber)
-          val threadInstance = graph.indexedObject(threadRoot.id).asInstance!!
+          val (threadInstance, threadRoot) = threadsBySerialNumber.getValue(
+              gcRoot.threadSerialNumber
+          )
           val threadName = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()
-          val exclusion = threadNameExclusions[threadName]
+          val referenceMatcher = threadNameReferenceMatchers[threadName]
 
-          if (exclusion == null || exclusion.status != NEVER_REACHABLE) {
+          if (referenceMatcher !is IgnoredReferenceMatcher) {
             // visitOrder is unused as this root node isn't enqueued.
-            val rootNode = RootNode(gcRoot, threadRoot.id, visitOrder = 0)
+            val rootNode = RootNode(gcRoot, threadRoot.id)
             // TODO #1352 Instead of <Java Local>, it should be <local variable in Foo.bar()>
             // We should also add the full stacktrace as a label of thread objects
             val leakReference = LeakReference(LOCAL, "")
-            enqueue(
-                graph,
-                ChildNode(gcRoot.id, visitOrder++, exclusion?.description, rootNode, leakReference),
-                exclusionPriority = exclusion?.status
-            )
+
+            val childNode = if (referenceMatcher is LibraryLeakReferenceMatcher) {
+              LibraryLeakNode(gcRoot.id, rootNode, leakReference, referenceMatcher)
+            } else {
+              NormalNode(gcRoot.id, rootNode, leakReference)
+            }
+            enqueue(graph, childNode)
           }
         }
-        else -> enqueue(graph, RootNode(gcRoot, gcRoot.id, visitOrder++), exclusionPriority = null)
+        else -> enqueue(graph, RootNode(gcRoot, gcRoot.id))
       }
     }
-    gcRoots.clear()
   }
 
-  private fun sortGcRoots(
-    graph: HprofGraph,
-    gcRoots: MutableList<GcRoot>
-  ) {
-    val rootClassName: (GcRoot) -> String = {
-      when (val graphObject = graph.indexedObject(it.id)) {
+  /**
+   * Sorting GC roots to get stable shortest path
+   * Once sorted all ThreadObject Gc Roots are located before JavaLocalPattern Gc Roots.
+   * This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
+   * built before JavaFrames.
+   */
+  private fun sortedGcRoots(
+    graph: HprofGraph
+  ): List<Pair<GraphObjectRecord, GcRoot>> {
+    val rootClassName: (GraphObjectRecord) -> String = { graphObject ->
+      when (graphObject) {
         is GraphClassRecord -> {
           graphObject.name
         }
@@ -305,22 +295,25 @@ internal class ShortestPathFinder {
         }
       }
     }
-    gcRoots.sortWith(Comparator { root1, root2 ->
-      // Sorting based on type name first. In reverse order so that ThreadObject is before JavaLocalExclusion
-      val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
-      if (gcRootTypeComparison != 0) {
-        gcRootTypeComparison
-      } else {
-        rootClassName(root1).compareTo(rootClassName(root2))
-      }
-    })
+
+    return graph.gcRoots
+        .map { graph.findObjectByObjectId(it.id) to it }
+        .sortedWith(Comparator { (graphObject1, root1), (graphObject2, root2) ->
+          // Sorting based on pattern name first. In reverse order so that ThreadObject is before JavaLocalPattern
+          val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
+          if (gcRootTypeComparison != 0) {
+            gcRootTypeComparison
+          } else {
+            rootClassName(graphObject1).compareTo(rootClassName(graphObject2))
+          }
+        })
   }
 
   private fun visitClassRecord(
     graph: HprofGraph,
     classRecord: GraphClassRecord,
-    node: LeakNode,
-    staticFieldNameByClassName: Map<String, Map<String, Exclusion>>,
+    parent: ReferencePathNode,
+    staticFieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>,
     computeRetainedHeapSize: Boolean
   ) {
     val ignoredStaticFields = staticFieldNameByClassName[classRecord.name] ?: emptyMap()
@@ -335,39 +328,46 @@ internal class ShortestPathFinder {
         continue
       }
 
-      val objectId = staticField.value.asObjectIdReference!!
+      val objectId = staticField.value.asObjectId!!
 
       if (computeRetainedHeapSize) {
         undominateWithSkips(graph, objectId)
       }
 
-      val leakReference = LeakReference(STATIC_FIELD, fieldName)
-
-      val exclusion = ignoredStaticFields[fieldName]
-
-      enqueue(
-          graph,
-          ChildNode(objectId, visitOrder++, exclusion?.description, node, leakReference),
-          exclusion?.status
-      )
+      when (val referenceMatcher = ignoredStaticFields[fieldName]) {
+        null -> {
+          enqueue(
+              graph,
+              NormalNode(objectId, parent, LeakReference(STATIC_FIELD, fieldName))
+          )
+        }
+        is LibraryLeakReferenceMatcher -> {
+          enqueue(
+              graph,
+              LibraryLeakNode(
+                  objectId, parent, LeakReference(STATIC_FIELD, fieldName), referenceMatcher
+              )
+          )
+        }
+      }
     }
   }
 
   private fun visitInstanceRecord(
     graph: HprofGraph,
     instanceRecord: GraphInstanceRecord,
-    parent: LeakNode,
-    fieldNameByClassName: Map<String, Map<String, Exclusion>>,
+    parent: ReferencePathNode,
+    fieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>,
     computeRetainedHeapSize: Boolean
   ) {
-    val ignoredFields = LinkedHashMap<String, Exclusion>()
+    val fieldReferenceMatchers = LinkedHashMap<String, ReferenceMatcher>()
 
     instanceRecord.instanceClass.classHierarchy.forEach {
-      val classExclusions = fieldNameByClassName[it.name]
-      if (classExclusions != null) {
-        for ((fieldName, exclusion) in classExclusions) {
-          if (!ignoredFields.containsKey(fieldName)) {
-            ignoredFields[fieldName] = exclusion
+      val referenceMatcherByField = fieldNameByClassName[it.name]
+      if (referenceMatcherByField != null) {
+        for ((fieldName, referenceMatcher) in referenceMatcherByField) {
+          if (!fieldReferenceMatchers.containsKey(fieldName)) {
+            fieldReferenceMatchers[fieldName] = referenceMatcher
           }
         }
       }
@@ -380,30 +380,37 @@ internal class ShortestPathFinder {
 
     fieldNamesAndValues.filter { it.value.isNonNullReference }
         .forEach { field ->
-          val objectId = field.value.asObjectIdReference!!
+          val objectId = field.value.asObjectId!!
           if (computeRetainedHeapSize) {
             updateDominatorWithSkips(graph, parent.instance, objectId)
           }
-
-          val exclusion = ignoredFields[field.name]
-          enqueue(
-              graph, ChildNode(
-              objectId,
-              visitOrder++, exclusion?.description, parent,
-              LeakReference(INSTANCE_FIELD, field.name)
-          ), exclusion?.status
-          )
+          when (val referenceMatcher = fieldReferenceMatchers[field.name]) {
+            null -> {
+              enqueue(
+                  graph,
+                  NormalNode(objectId, parent, LeakReference(INSTANCE_FIELD, field.name))
+              )
+            }
+            is LibraryLeakReferenceMatcher -> {
+              enqueue(
+                  graph,
+                  LibraryLeakNode(
+                      objectId, parent, LeakReference(INSTANCE_FIELD, field.name), referenceMatcher
+                  )
+              )
+            }
+          }
         }
   }
 
   private fun visitObjectArrayRecord(
     graph: HprofGraph,
     record: ObjectArrayDumpRecord,
-    parentNode: LeakNode,
+    parentNode: ReferencePathNode,
     computeRetainedHeapSize: Boolean
   ) {
-    record.elementIds.filter {objectId ->
-      objectId != 0L && graph.objectIdExists(objectId).apply {
+    record.elementIds.filter { objectId ->
+      objectId != HeapValue.NULL_REFERENCE && graph.objectExists(objectId).apply {
         if (!this) {
           // dalvik.system.PathClassLoader.runtimeInternalObjects references objects which don't
           // otherwise exist in the heap dump.
@@ -416,40 +423,46 @@ internal class ShortestPathFinder {
             updateDominatorWithSkips(graph, parentNode.instance, elementId)
           }
           val name = Integer.toString(index)
-          val reference = LeakReference(ARRAY_ENTRY, name)
-          enqueue(graph, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
+          enqueue(
+              graph,
+              NormalNode(elementId, parentNode, LeakReference(ARRAY_ENTRY, name))
+          )
         }
   }
 
   private fun enqueue(
     graph: HprofGraph,
-    node: LeakNode,
-    exclusionPriority: Status?
+    node: ReferencePathNode
   ) {
-    // 0L is null
-    if (node.instance == 0L) {
+    if (node.instance == HeapValue.NULL_REFERENCE) {
       return
     }
     if (visitedSet.contains(node.instance)) {
       return
     }
-    if (exclusionPriority == NEVER_REACHABLE) {
+    // Already enqueued => shorter or equal distance
+    if (toVisitSet.contains(node.instance)) {
       return
     }
-
-    val nodePriority = exclusionPriority ?: ALWAYS_REACHABLE
-
-    // Whether we want to visit now or later, we should skip if this is already to visit.
-    val existingPriority = toVisitMap[node.instance]
-
-    if (existingPriority != null && existingPriority <= nodePriority) {
-      return
+    //
+    if (toVisitLastSet.contains(node.instance)) {
+      // Already enqueued => shorter or equal distance amongst library leak ref patterns.
+      if (node is LibraryLeakNode) {
+        return
+      } else {
+        toVisitQueue.add(node)
+        toVisitSet.add(node.instance)
+        val nodeToRemove = toVisitLastQueue.first { it.instance == node.instance }
+        toVisitLastQueue.remove(nodeToRemove)
+        toVisitLastSet.remove(node.instance)
+        return
+      }
     }
 
     val isLeakingInstance = node.instance in leakingInstanceObjectIds
 
     if (!isLeakingInstance) {
-      val skip = when (val graphObject = graph.indexedObject(node.instance)) {
+      val skip = when (val graphObject = graph.findObjectByObjectId(node.instance)) {
         is GraphClassRecord -> false
         is GraphInstanceRecord ->
           when {
@@ -468,12 +481,13 @@ internal class ShortestPathFinder {
         return
       }
     }
-
-    if (existingPriority != null) {
-      toVisitQueue.removeAll { it.instance == node.instance }
+    if (node is LibraryLeakNode) {
+      toVisitLastQueue.add(node)
+      toVisitLastSet.add(node.instance)
+    } else {
+      toVisitQueue.add(node)
+      toVisitSet.add(node.instance)
     }
-    toVisitMap[node.instance] = nodePriority
-    toVisitQueue.add(node)
   }
 
   private fun updateDominatorWithSkips(
@@ -482,7 +496,7 @@ internal class ShortestPathFinder {
     objectId: Long
   ) {
 
-    when (val graphObject = graph.indexedObject(objectId)) {
+    when (val graphObject = graph.findObjectByObjectId(objectId)) {
       is GraphClassRecord -> {
         undominate(objectId, false)
       }
@@ -490,7 +504,7 @@ internal class ShortestPathFinder {
         // String internal array is never enqueued
         if (graphObject.className == "java.lang.String") {
           updateDominator(parentObjectId, objectId, true)
-          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
           if (valueId != null) {
             updateDominator(parentObjectId, valueId, true)
           }
@@ -521,7 +535,7 @@ internal class ShortestPathFinder {
     neverEnqueued: Boolean
   ) {
     val currentDominator = dominatedInstances[instance]
-    if (currentDominator == null && (instance in visitedSet || instance in toVisitMap)) {
+    if (currentDominator == null && (instance in visitedSet || instance in toVisitSet || instance in toVisitLastSet)) {
       return
     }
     val parentDominator = dominatedInstances[parent]
@@ -582,7 +596,7 @@ internal class ShortestPathFinder {
     graph: HprofGraph,
     objectId: Long
   ) {
-    when (val graphObject = graph.indexedObject(objectId)) {
+    when (val graphObject = graph.findObjectByObjectId(objectId)) {
       is GraphClassRecord -> {
         undominate(objectId, false)
       }
@@ -590,7 +604,7 @@ internal class ShortestPathFinder {
         // String internal array is never enqueued
         if (graphObject.className == "java.lang.String") {
           undominate(objectId, true)
-          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
           if (valueId != null) {
             undominate(valueId, true)
           }
@@ -624,10 +638,4 @@ internal class ShortestPathFinder {
       visitedSet.add(instance)
     }
   }
-
-  companion object {
-    // Since NEVER_REACHABLE never ends up in the queue, we use its value to mean "ALWAYS_REACHABLE"
-    // For this to work we need NEVER_REACHABLE to be declared as the first enum value.
-    private val ALWAYS_REACHABLE = NEVER_REACHABLE
-  }
 }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
deleted file mode 100644
index 926958fa..00000000
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
-import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.KeyedWeakReference
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Before
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.TemporaryFolder
-import java.io.File
-import java.lang.ref.WeakReference
-
-class ExclusionTest {
-
-  @get:Rule
-  var testFolder = TemporaryFolder()
-  private lateinit var hprofFile: File
-
-  @Before
-  fun setUp() {
-    hprofFile = testFolder.newFile("temp.hprof")
-  }
-
-  @Test fun shortestPathExcluded() {
-    hprofFile.writeTwoPathsToInstance()
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")))
-    )
-
-    val leak = analysis.leakingInstances[0]
-    assertThat(leak.leakTrace.elements).hasSize(3)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("HasLeaking")
-    assertThat(leak.leakTrace.elements[1].reference!!.name).isEqualTo("leaking")
-    assertThat(leak.leakTrace.elements[2].className).isEqualTo("Leaking")
-  }
-
-  @Test fun allPathsExcluded_ShortestWins() {
-    hprofFile.writeTwoPathsToInstance()
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(
-            Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")),
-            Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"))
-        )
-    )
-
-    val leak = analysis.leakingInstances[0]
-    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
-    assertThat(leak.leakTrace.elements).hasSize(2)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
-  }
-
-  @Test fun noPathToInstanceNeverReachable() {
-    hprofFile.writeTwoPathsToInstance()
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(
-            Exclusion(StaticFieldExclusion("GcRoot", "shortestPath"), status = NEVER_REACHABLE),
-            Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"), status = NEVER_REACHABLE)
-        )
-    )
-    assertThat(analysis.leakingInstances).isEmpty()
-  }
-
-  @Test fun excludedThread() {
-    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(Exclusion(JavaLocalExclusion("kroutine"), status = WONT_FIX_LEAK))
-    )
-
-    val leak = analysis.leakingInstances[0]
-    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
-  }
-
-  @Test fun weaklyReachableExclusion() {
-    hprofFile.dump {
-      "GcRoot" clazz {
-        staticField["ref"] =
-          keyedWeakReference(referentInstanceId = "Leaking" instance {})
-      }
-    }
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(
-            Exclusion(
-                type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-                status = WEAKLY_REACHABLE
-            )
-        )
-    )
-
-    val leak = analysis.leakingInstances[0]
-    assertThat(leak.exclusionStatus).isEqualTo(WEAKLY_REACHABLE)
-  }
-
-  @Test fun overrideSuperclassExclusion() {
-    hprofFile.dump {
-      "GcRoot" clazz {
-        staticField["ref"] =
-          keyedWeakReference(referentInstanceId = "Leaking" instance {})
-      }
-    }
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(
-            Exclusion(
-                type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-                status = WEAKLY_REACHABLE
-            ), Exclusion(
-            type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
-            status = NEVER_REACHABLE
-        )
-        )
-    )
-    assertThat(analysis.leakingInstances).isEmpty()
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
index 63b75b57..e67c39f9 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
@@ -5,7 +5,7 @@ import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.LeakTraceElement.Type.LOCAL
-import leakcanary.LeakingInstance
+import leakcanary.Leak
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -28,23 +28,23 @@ class HeapAnalyzerTest {
     hprofFile.writeSinglePathToInstance()
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis.leakingInstances[0]).isInstanceOf(LeakingInstance::class.java)
+    assertThat(analysis.applicationLeaks[0]).isInstanceOf(Leak::class.java)
   }
 
   @Test fun pathToString() {
     hprofFile.writeSinglePathToString()
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.instanceClassName).isEqualTo("java.lang.String")
+    assertThat(leak.className).isEqualTo("java.lang.String")
   }
 
   @Test fun pathToCharArray() {
     hprofFile.writeSinglePathsToCharArrays(listOf("Hello"))
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
-    val leak = analysis.leakingInstances[0]
-    assertThat(leak.instanceClassName).isEqualTo("char[]")
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("char[]")
   }
 
   // Two char arrays to ensure we keep going after finding the first one
@@ -59,7 +59,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
@@ -71,14 +71,14 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis.leakingInstances).isEmpty()
+    assertThat(analysis.applicationLeaks).isEmpty()
   }
 
   @Test fun weakRefCleared() {
     hprofFile.writeWeakReferenceCleared()
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
-    assertThat(analysis.leakingInstances).isEmpty()
+    assertThat(analysis.applicationLeaks).isEmpty()
   }
 
   @Test fun failsNoRetainedKeys() {
@@ -86,7 +86,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis.leakingInstances).isEmpty()
+    assertThat(analysis.applicationLeaks).isEmpty()
   }
 
   @Test fun findMultipleLeaks() {
@@ -94,8 +94,8 @@ class HeapAnalyzerTest {
 
     val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(leaks.leakingInstances).hasSize(5)
-        .hasOnlyElementsOfType(LeakingInstance::class.java)
+    assertThat(leaks.applicationLeaks).hasSize(5)
+        .hasOnlyElementsOfType(Leak::class.java)
   }
 
   @Test fun localVariableLeak() {
@@ -103,7 +103,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
     assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(LOCAL)
@@ -129,7 +129,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("leaking")
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt
new file mode 100644
index 00000000..07856ea4
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt
@@ -0,0 +1,42 @@
+package leakcanary.internal
+
+import leakcanary.HprofGraph
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import kotlin.reflect.KClass
+
+class JvmHprofParsingTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @Test fun dumpHeapAndReadString() {
+    val hprofFolder = testFolder.newFolder()
+    val hprofFile = File(hprofFolder, "jvm_heap.hprof")
+
+    JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
+
+    val (graph, closeable) = HprofGraph.readHprof(hprofFile)
+
+    closeable.use {
+      val testInstances = graph.instances
+          .filter { it.className == JvmHprofParsingTest::class.name }
+          .toList()
+
+      assertThat(testInstances).hasSize(1)
+      val test = testInstances[0]
+      val folderPath = test[JvmHprofParsingTest::class.name, "testFolder"]!!
+          .valueAsInstance!![TemporaryFolder::class.name, "folder"]!!
+          .valueAsInstance!![File::class.name, "path"]!!
+          .value.readAsJavaString()!!
+
+      assertThat(folderPath).isEqualTo(testFolder.root.path)
+    }
+  }
+}
+
+private val KClass<out Any>.name: String
+  get() = this.java.name
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmTestHeapDumper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmTestHeapDumper.kt
new file mode 100644
index 00000000..df505e71
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmTestHeapDumper.kt
@@ -0,0 +1,23 @@
+package leakcanary.internal
+
+import com.sun.management.HotSpotDiagnosticMXBean
+import java.lang.management.ManagementFactory
+
+object JvmTestHeapDumper {
+  private val hotspotMBean: HotSpotDiagnosticMXBean by lazy {
+    val mBeanServer = ManagementFactory.getPlatformMBeanServer()
+    ManagementFactory.newPlatformMXBeanProxy(
+        mBeanServer,
+        "com.sun.management:type=HotSpotDiagnostic",
+        HotSpotDiagnosticMXBean::class.java
+    )
+  }
+
+  fun dumpHeap(
+    fileName: String
+  ) {
+    val live = true
+    hotspotMBean.dumpHeap(fileName, live)
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
index 7a946696..5fe9984b 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
@@ -40,7 +40,7 @@ class LabelerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(labeler))
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
 
     assertThat(leak.leakTrace.elements.last().labels).contains("Hello World")
   }
@@ -51,7 +51,7 @@ class LabelerTest {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(AndroidObjectInspectors.THREAD))
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
 
     assertThat(leak.leakTrace.elements.first().labels).contains("Thread name: 'kroutine'")
   }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
index db291474..1b462ee8 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
@@ -35,7 +35,7 @@ class LeakStatusTest {
         objectInspectors = listOf(AndroidObjectInspectors.CLASS)
     )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
 
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
   }
@@ -45,7 +45,7 @@ class LeakStatusTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
 
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
   }
@@ -61,7 +61,7 @@ class LeakStatusTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
 
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(UNKNOWN)
   }
@@ -79,7 +79,7 @@ class LeakStatusTest {
         objectInspectors = listOf(notLeakingInstance("Class1"))
     )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
   }
 
@@ -97,7 +97,7 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
   }
 
@@ -115,7 +115,7 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
   }
 
@@ -137,7 +137,7 @@ class LeakStatusTest {
           objectInspectors = listOf(notLeakingInstance("Class3"))
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
   }
 
@@ -159,7 +159,7 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
   }
@@ -184,7 +184,7 @@ class LeakStatusTest {
           )
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements[2].leakStatusAndReason.status).isEqualTo(UNKNOWN)
   }
 
@@ -196,7 +196,7 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingClass("GcRoot"), AndroidObjectInspectors.CLASS)
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
 
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
@@ -214,7 +214,7 @@ class LeakStatusTest {
 
     println(analysis)
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
 
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
@@ -229,10 +229,10 @@ class LeakStatusTest {
           objectInspectors = listOf(notLeakingInstance("Leaking"))
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
-        "Leaking is not leaking. Conflicts with RefWatcher was watching this"
+        "Leaking is not leaking. Conflicts with ObjectWatcher was watching this"
     )
   }
 
@@ -243,10 +243,10 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Leaking"))
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
     assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
-        "Leaking is leaking and RefWatcher was watching this"
+        "Leaking is leaking and ObjectWatcher was watching this"
     )
   }
 
@@ -266,7 +266,7 @@ class LeakStatusTest {
           )
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
         "Class1 is not leaking. Conflicts with Class1 is leaking"
@@ -289,7 +289,7 @@ class LeakStatusTest {
           )
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
         "Class1 is not leaking and Class1 is not leaking"
@@ -310,7 +310,7 @@ class LeakStatusTest {
           objectInspectors = listOf(leakingInstance("Class1"), leakingInstance("Class1"))
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
     assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
         "Class1 is leaking and Class1 is leaking"
@@ -337,7 +337,7 @@ class LeakStatusTest {
           )
       )
 
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elementMayBeLeakCause(0)).isFalse()
     assertThat(leak.leakTrace.elementMayBeLeakCause(1)).isTrue()
     assertThat(leak.leakTrace.elementMayBeLeakCause(2)).isTrue()
@@ -493,10 +493,10 @@ class LeakStatusTest {
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
           objectInspectors = listOf(notLeakingInstance(notLeaking), leakingInstance(leaking))
       )
-    require(analysis.leakingInstances.size == 1) {
-      "Expecting 1 retained instance in ${analysis.leakingInstances}"
+    require(analysis.applicationLeaks.size == 1) {
+      "Expecting 1 retained instance in ${analysis.applicationLeaks}"
     }
-    val leak = analysis.leakingInstances[0]
+    val leak = analysis.applicationLeaks[0]
     return leak.groupHash
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
index 8de8eeec..7ae61f68 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
@@ -1,11 +1,11 @@
 package leakcanary.internal
 
-import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HprofGraph
 import leakcanary.ObjectInspector
 import leakcanary.ObjectReporter
+import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
+import leakcanary.ReferencePattern.InstanceFieldPattern
 import leakcanary.whenInstanceOf
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
@@ -42,7 +42,7 @@ class LeakTraceRendererTest {
     │    ↓ static GcRoot.leak
     │                    ~~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
     ​     retainedDurationMillis = 10000
@@ -118,7 +118,7 @@ class LeakTraceRendererTest {
     │    ↓ static GcRoot.leak
     │                    ~~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     ¯\_(ツ)_/¯
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
@@ -137,10 +137,12 @@ class LeakTraceRendererTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          exclusions = listOf(Exclusion(type = InstanceFieldExclusion("ClassA", "leak")))
+          referenceMatchers = listOf(
+              LibraryLeakReferenceMatcher(pattern = InstanceFieldPattern("ClassA", "leak"))
+          )
       )
 
-    analysis renders """
+    analysis rendersLibraryLeak """
     ┬
     ├─ GcRoot
     │    Leaking: UNKNOWN
@@ -149,11 +151,10 @@ class LeakTraceRendererTest {
     │                    ~~~~~~~~~
     ├─ ClassA
     │    Leaking: UNKNOWN
-    │    Matches exclusion field ClassA#leak
     │    ↓ ClassA.leak
     │             ~~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
     ​     retainedDurationMillis = 10000
@@ -182,7 +183,7 @@ class LeakTraceRendererTest {
     │    ↓ array Object[].[0]
     │                     ~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
     ​     retainedDurationMillis = 10000
@@ -203,7 +204,7 @@ class LeakTraceRendererTest {
     │    ↓ thread MyThread.<Java Local>
     │                      ~~~~~~~~~~~~
     ╰→ Leaking
-    ​     Leaking: YES (RefWatcher was watching this)
+    ​     Leaking: YES (ObjectWatcher was watching this)
     ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
     ​     watchDurationMillis = 25000
     ​     retainedDurationMillis = 10000
@@ -211,9 +212,12 @@ class LeakTraceRendererTest {
   }
 
   private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
-    val leak = leakingInstances[0]
-    assertThat(leak.leakTrace.renderToString()).isEqualTo(
-        expectedString.trimIndent()
+    assertThat(applicationLeaks[0].leakTrace.renderToString()).isEqualTo(expectedString.trimIndent()
+    )
+  }
+
+  private infix fun HeapAnalysisSuccess.rendersLibraryLeak(expectedString: String) {
+    assertThat(libraryLeaks[0].leakTrace.renderToString()).isEqualTo(expectedString.trimIndent()
     )
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
index c555300b..81d9cfc3 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
@@ -1,10 +1,10 @@
 package leakcanary.internal
 
-import leakcanary.AndroidKnownReference
+import leakcanary.AndroidReferenceMatchers
 import leakcanary.AndroidObjectInspectors
 import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
+import leakcanary.HprofPrimitiveArrayStripper
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
 import java.io.File
@@ -13,47 +13,67 @@ class LegacyHprofTest {
 
   @Test fun preM() {
     val analysis = analyzeHprof("leak_asynctask_pre_m.hprof")
-
-    assertThat(analysis.leakingInstances).hasSize(2)
-    val leak1 = analysis.leakingInstances[0]
-    val leak2 = analysis.leakingInstances[1]
-    assertThat(leak1.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak2.instanceClassName).isEqualTo("android.graphics.Bitmap")
+    assertThat(analysis.applicationLeaks).hasSize(2)
+    val leak1 = analysis.applicationLeaks[0]
+    val leak2 = analysis.applicationLeaks[1]
+    assertThat(leak1.className).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(leak2.className).isEqualTo("android.graphics.Bitmap")
   }
 
   @Test fun androidM() {
     val analysis = analyzeHprof("leak_asynctask_m.hprof")
 
-    assertThat(analysis.leakingInstances).hasSize(1)
-    val leak = analysis.leakingInstances[0]
-    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(leak.leakTrace.elements[0].labels).contains("Thread name: 'AsyncTask #1'")
+  }
+
+  @Test fun androidMStripped() {
+    val stripper = HprofPrimitiveArrayStripper()
+    val strippedHprof =
+      stripper.stripPrimitiveArrays(fileFromResources("leak_asynctask_m.hprof"))
+
+    val analysis = analyzeHprof(strippedHprof)
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(leak.leakTrace.elements[0].labels).contains("Thread name: ''")
   }
 
   @Test fun androidO() {
     val analysis = analyzeHprof("leak_asynctask_o.hprof")
 
-    assertThat(analysis.leakingInstances).hasSize(1)
-    val leak = analysis.leakingInstances[0]
-    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
   @Test fun gcRootInNonPrimaryHeap() {
     val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
 
-    assertThat(analysis.leakingInstances).hasSize(1)
-    val leak = analysis.leakingInstances[0]
-    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
   }
 
   private fun analyzeHprof(fileName: String): HeapAnalysisSuccess {
+    return analyzeHprof(fileFromResources(fileName))
+  }
+
+  private fun fileFromResources(fileName: String): File {
     val classLoader = Thread.currentThread()
         .contextClassLoader
     val url = classLoader.getResource(fileName)
     val hprofFile = File(url.path)
+    return hprofFile
+  }
 
+  private fun analyzeHprof(hprofFile: File): HeapAnalysisSuccess {
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
-        objectInspectors = AndroidObjectInspectors.defaultInspectors(),
-        exclusions = AndroidKnownReference.mapToExclusions(AndroidKnownReference.appDefaults)
+        objectInspectors = AndroidObjectInspectors.appDefaults,
+        referenceMatchers = AndroidReferenceMatchers.appDefaults
     )
     print(analysis)
     return analysis as HeapAnalysisSuccess
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ReferenceMatcherTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/ReferenceMatcherTest.kt
new file mode 100644
index 00000000..828e14ee
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/ReferenceMatcherTest.kt
@@ -0,0 +1,111 @@
+package leakcanary.internal
+
+import leakcanary.HeapAnalysisSuccess
+import leakcanary.KeyedWeakReference
+import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
+import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
+import leakcanary.ReferencePattern.InstanceFieldPattern
+import leakcanary.ReferencePattern.JavaLocalPattern
+import leakcanary.ReferencePattern.StaticFieldPattern
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import java.lang.ref.WeakReference
+
+class ReferenceMatcherTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun shortestPathExcluded() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+            LibraryLeakReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath"))
+        )
+    )
+
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements).hasSize(3)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("HasLeaking")
+    assertThat(leak.leakTrace.elements[1].reference!!.name).isEqualTo("leaking")
+    assertThat(leak.leakTrace.elements[2].className).isEqualTo("Leaking")
+  }
+
+  @Test fun allPathsExcluded_ShortestWins() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val expectedMatcher = LibraryLeakReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+            expectedMatcher,
+            LibraryLeakReferenceMatcher(InstanceFieldPattern("HasLeaking", "leaking"))
+        )
+    )
+
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(expectedMatcher.pattern)
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
+  @Test fun noPathToInstanceNeverReachable() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+            IgnoredReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath")),
+            IgnoredReferenceMatcher(InstanceFieldPattern("HasLeaking", "leaking"))
+        )
+    )
+    assertThat(analysis.libraryLeaks).isEmpty()
+  }
+
+  @Test fun excludedThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val matcher = LibraryLeakReferenceMatcher(JavaLocalPattern("kroutine"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(matcher)
+    )
+
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(matcher.pattern)
+  }
+
+  @Test fun overrideSuperclassExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+            LibraryLeakReferenceMatcher(
+                pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
+            ),
+            IgnoredReferenceMatcher(
+                pattern = InstanceFieldPattern(KeyedWeakReference::class.java.name, "referent")
+            )
+        )
+    )
+    assertThat(analysis.libraryLeaks).isEmpty()
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
index a503489f..5d2d4632 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
@@ -7,7 +7,7 @@ import leakcanary.HeapValue.IntValue
 import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
-import leakcanary.LeakingInstance
+import leakcanary.Leak
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -234,7 +234,7 @@ class RetainedSizeTest {
 
     val instance = retainedInstances[0]
 
-    assertThat(instance.instanceClassName).isEqualTo("GrandParentLeaking")
+    assertThat(instance.className).isEqualTo("GrandParentLeaking")
     // 4 bytes per ref * 2 + short + int + long
     assertThat(instance.retainedHeapSize).isEqualTo(22)
   }
@@ -304,11 +304,11 @@ class RetainedSizeTest {
     assertThat(retainedSize).isEqualTo(12 + nativeBitmapSize)
   }
 
-  private fun retainedInstances(): List<LeakingInstance> {
+  private fun retainedInstances(): List<Leak> {
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>(computeRetainedHeapSize = true)
     println(analysis.toString())
     analysis as HeapAnalysisSuccess
-    return analysis.leakingInstances.map { it }
+    return analysis.applicationLeaks.map { it }
   }
 
   private fun firstRetainedSize(): Int {
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
index 03f35c28..f25f6e3c 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -2,16 +2,15 @@ package leakcanary.internal
 
 import leakcanary.AnalyzerProgressListener
 import leakcanary.AndroidObjectInspectors
-import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalyzer
 import leakcanary.KeyedWeakReference
 import leakcanary.ObjectInspector
+import leakcanary.ReferenceMatcher
+import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
+import leakcanary.ReferencePattern.InstanceFieldPattern
+import leakcanary.ReferencePattern.JavaLocalPattern
 import java.io.File
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
@@ -21,7 +20,7 @@ import java.lang.ref.WeakReference
 fun <T : HeapAnalysis> File.checkForLeaks(
   objectInspectors: List<ObjectInspector> = emptyList(),
   computeRetainedHeapSize: Boolean = false,
-  exclusions: List<Exclusion> = defaultExclusionsFactory
+  referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers
 ): T {
   val inspectors = if (AndroidObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
     objectInspectors + AndroidObjectInspectors.KEYED_WEAK_REFERENCE
@@ -30,7 +29,7 @@ fun <T : HeapAnalysis> File.checkForLeaks(
   }
   val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
   val result = heapAnalyzer.checkForLeaks(
-      this, exclusions, computeRetainedHeapSize, inspectors
+      this, referenceMatchers, computeRetainedHeapSize, inspectors
   )
   if (result is HeapAnalysisFailure) {
     println(result)
@@ -38,73 +37,61 @@ fun <T : HeapAnalysis> File.checkForLeaks(
   return result as T
 }
 
-val defaultExclusionsFactory: List<Exclusion> =
+val defaultReferenceMatchers: List<ReferenceMatcher> =
   listOf(
-      Exclusion(
-          type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-          status = WEAKLY_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern(KeyedWeakReference::class.java.name, "referent")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion(SoftReference::class.java.name, "referent"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern(SoftReference::class.java.name, "referent")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion(PhantomReference::class.java.name, "referent"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern(PhantomReference::class.java.name, "referent")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "prev"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "prev")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "element"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "element")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "next"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "next")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "prev"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "prev")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "element"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "element")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "next"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "next")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion("sun.misc.Cleaner", "prev"), status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("sun.misc.Cleaner", "prev")
       )
       ,
-      Exclusion(
-          type = InstanceFieldExclusion("sun.misc.Cleaner", "next"), status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("sun.misc.Cleaner", "next")
       )
       ,
 
-      Exclusion(
-          type = JavaLocalExclusion("FinalizerWatchdogDaemon"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = JavaLocalPattern("FinalizerWatchdogDaemon")
       ),
-      Exclusion(
-          type = JavaLocalExclusion("main"),
-          status = NEVER_REACHABLE
+      IgnoredReferenceMatcher(
+          pattern = JavaLocalPattern("main")
       )
   )
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
similarity index 74%
rename from leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
rename to leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
index 8c24a7d1..f0fae9e4 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -2,8 +2,6 @@ package leakcanary
 
 import android.app.Application
 import com.squareup.leakcanary.core.R
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.internal.NotificationType.LEAKCANARY_RESULT
 import leakcanary.internal.Notifications
 import leakcanary.internal.activity.LeakActivity
@@ -15,12 +13,13 @@ import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
 import leakcanary.internal.activity.screen.HeapAnalysisListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisSuccessScreen
 
-object DefaultAnalysisResultListener : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
-  ) {
+/**
+ * Default [OnHeapAnalyzedListener] implementation, which will store the analysis to disk and
+ * show a notification summarizing the result.
+ */
+class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHeapAnalyzedListener {
 
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
     // TODO better log that include leakcanary version, exclusions, etc.
     CanaryLog.d("%s", heapAnalysis)
 
@@ -38,22 +37,20 @@ object DefaultAnalysisResultListener : AnalysisResultListener {
         var leakCount = 0
         var newLeakCount = 0
         var knownLeakCount = 0
-        var wontFixLeakCount = 0
+        var libraryLeakCount = 0
 
         for ((_, projection) in groupProjections) {
-          if (projection.exclusionStatus != WEAKLY_REACHABLE) {
-            leakCount += projection.leakCount
-            when {
-              projection.exclusionStatus == WONT_FIX_LEAK -> wontFixLeakCount += projection.leakCount
-              projection.isNew -> newLeakCount += projection.leakCount
-              else -> knownLeakCount += projection.leakCount
-            }
+          leakCount += projection.leakCount
+          when {
+            projection.isLibraryLeak -> libraryLeakCount += projection.leakCount
+            projection.isNew -> newLeakCount += projection.leakCount
+            else -> knownLeakCount += projection.leakCount
           }
         }
 
         application.getString(
             R.string.leak_canary_analysis_success_notification, leakCount, newLeakCount,
-            knownLeakCount, wontFixLeakCount
+            knownLeakCount, libraryLeakCount
         ) to HeapAnalysisSuccessScreen(id)
       }
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index e07e0601..732fff3b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -1,18 +1,39 @@
 package leakcanary
 
-import android.app.Application
 import android.content.Intent
+import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
+import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
 import leakcanary.internal.InternalLeakCanary
 
-typealias AnalysisResultListener = (Application, HeapAnalysis) -> Unit
-
+/**
+ * The entry point API for LeakCanary. LeakCanary builds on top of [LeakSentry]. LeakSentry
+ * notifies LeakCanary of retained instances, which in turns dumps the heap, analyses it and
+ * publishes the results.
+ *
+ * LeakCanary can be configured by updating [config].
+ */
 object LeakCanary {
 
+  /**
+   * LeakCanary configuration data class. Properties can be updated via [copy].
+   *
+   * @see [config]
+   */
   data class Config(
+    /**
+     * Whether LeakCanary should dump the heap when enough retained instances are found. This needs
+     * to be true for LeakCanary to work, but sometimes you may want to temporarily disable
+     * LeakCanary (e.g. for a product demo).
+     *
+     * Defaults to true.
+     */
     val dumpHeap: Boolean = true,
     /**
-     * The debugger can create temporary memory leaks (for instance if a thread is blocked on a
-     * breakpoint) so by default LeakCanary does not dump the heap when the debugger is attached.
+     * If [dumpHeapWhenDebugging] is false then LeakCanary will not dump the heap
+     * when the debugger is attached. The debugger can create temporary memory leaks (for instance
+     * if a thread is blocked on a breakpoint).
+     *
+     * Defaults to false.
      */
     val dumpHeapWhenDebugging: Boolean = false,
     /**
@@ -22,43 +43,81 @@ object LeakCanary {
      * especially frustrating as the Android Framework has a number of leaks that cannot easily
      * be fixed.
      *
-     * When the app becomes invisible, LeakCanary dumps the heap immediately.
+     * When the app becomes invisible, LeakCanary dumps the heap after
+     * [LeakSentry.Config.watchDurationMillis] ms.
+     *
+     * The app is considered visible if it has at least one activity in started state.
      *
      * A higher threshold means LeakCanary will dump the heap less often, therefore it won't be
      * bothering developers as much but it could miss some leaks.
+     *
+     * Defaults to 5.
      */
     val retainedVisibleThreshold: Int = 5,
 
-    val knownReferences: Set<AndroidKnownReference> = AndroidKnownReference.appDefaults,
+    /**
+     * Known patterns of references in the heap, lister here either to ignore them
+     * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+     *
+     * When adding your own custom [LibraryLeakReferenceMatcher] instances, you'll most
+     * likely want to set [LibraryLeakReferenceMatcher.patternApplies] with a filter that checks
+     * for the Android OS version and manufacturer. The build information can be obtained by calling
+     * [HprofGraph.androidBuildMirror].
+     *
+     * Defaults to [AndroidReferenceMatchers.appDefaults]
+     */
+    val referenceMatchers: List<ReferenceMatcher> = AndroidReferenceMatchers.appDefaults,
 
-    val objectInspectors: List<ObjectInspector> = AndroidObjectInspectors.defaultInspectors(),
+    /**
+     * List of [ObjectInspector] that provide LeakCanary with insights about objects found in the
+     * heap. You can create your own [ObjectInspector] implementations, and also add
+     * a [AppSingletonInspector] instance created with the list of internal singletons.
+     *
+     * Defaults to [AndroidObjectInspectors.appDefaults]
+     */
+    val objectInspectors: List<ObjectInspector> = AndroidObjectInspectors.appDefaults,
 
     /**
-     * Called with the heap analysis result from a background thread.
-     * The heap dump file will be removed immediately after this function is invoked.
+     * Called on a background thread when the heap analysis is complete.
      * If you want leaks to be added to the activity that lists leaks, make sure to delegate
-     * calls to [DefaultAnalysisResultListener].
+     * calls to a [DefaultOnHeapAnalyzedListener].
+     *
+     * Defaults to [DefaultOnHeapAnalyzedListener]
      */
-    val analysisResultListener: AnalysisResultListener = DefaultAnalysisResultListener,
+    val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener(
+        InternalLeakCanary.application
+    ),
+
     /**
-     * Whether to compute the total number of bytes in memory that would be reclaimed if the
-     * detected leaks didn't happen. This includes native memory associated to Java objects
-     * (e.g. bitmaps).
-     * Computing the retained heap size can slow down the leak analysis and is off by default.
+     * Whether to compute the retained heap size, which is the total number of bytes in memory that
+     * would be reclaimed if the detected leaks didn't happen. This includes native memory
+     * associated to Java objects (e.g. Android bitmaps).
+     *
+     * Computing the retained heap size can slow down the analysis because it requires navigating
+     * from GC roots through the entire object graph, whereas [HeapAnalyzer] would otherwise stop
+     * as soon as all leaking instances are found.
+     *
+     * Defaults to true.
      */
-    val computeRetainedHeapSize: Boolean = false,
+    val computeRetainedHeapSize: Boolean = true,
 
     /**
-     * How many heap dumps are kept locally. When this threshold is reached LeakCanary starts
-     * deleting the older heap dumps. As several heap dumps may be enqueued you should avoid
-     * going down to 1 or 2.
+     * How many heap dumps are kept on the Android device for this app package. When this threshold
+     * is reached LeakCanary deletes the older heap dumps. As several heap dumps may be enqueued
+     * you should avoid going down to 1 or 2.
+     *
+     * Defaults to 7.
      */
     val maxStoredHeapDumps: Int = 7,
 
     /**
-     * LeakCanary always attempts to store heap dumps on the external storage first. If the
-     * WRITE_EXTERNAL_STORAGE permission is not granted and [requestWriteExternalStoragePermission]
-     * is true, then LeakCanary will display a notification to ask for that permission.
+     * LeakCanary always attempts to store heap dumps on the external storage if the
+     * WRITE_EXTERNAL_STORAGE is already granted, and otherwise uses the app storage.
+     * If the WRITE_EXTERNAL_STORAGE permission is not granted and
+     * [requestWriteExternalStoragePermission] is true, then LeakCanary will display a notification
+     * to ask for that permission.
+     *
+     * Defaults to false because that permission notification can be annoying.
      */
     val requestWriteExternalStoragePermission: Boolean = false,
 
@@ -67,14 +126,32 @@ object LeakCanary {
      * tracked by [KeyedWeakReference]. This leads to finding more leaks and shorter leak traces.
      * However this also means the same leaking instances will be found in every heap dump for a
      * given process life.
+     *
+     * Defaults to false.
      */
     val useExperimentalLeakFinders: Boolean = false
   )
 
+  /**
+   * The current LeakCanary configuration. Can be updated at any time, usually by replacing it with
+   * a mutated copy, e.g.:
+   *
+   * ```
+   * LeakCanary.config = LeakCanary.config.copy(computeRetainedHeapSize = true)
+   * ```
+   */
   @Volatile
   var config: Config = if (LeakSentry.isInstalled) Config() else InternalLeakCanary.noInstallConfig
 
-  /** [Intent] that can be used to programmatically launch the leak display activity. */
-  val leakDisplayActivityIntent
-    get() = InternalLeakCanary.leakDisplayActivityIntent
+  /**
+   * Returns a new [Intent] that can be used to programmatically launch the leak display activity.
+   */
+  fun newLeakDisplayActivityIntent() = InternalLeakCanary.leakDisplayActivityIntent
+
+  /**
+   * Immediately triggers a heap dump and analysis, if there is at least one retained instance
+   * tracked by [LeakSentry.objectWatcher]. If there are no retained instances then the heap will not
+   * be dumped and a notification will be shown instead.
+   */
+  fun dumpHeap() = InternalLeakCanary.onDumpHeapReceived()
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
new file mode 100644
index 00000000..50d552cf
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
@@ -0,0 +1,39 @@
+package leakcanary
+
+import leakcanary.ObjectInspector.Companion.invoke
+import leakcanary.OnHeapAnalyzedListener.Companion.invoke
+
+/**
+ * Listener set in [LeakCanary.Config] and called by LeakCanary on a background thread when the
+ * heap analysis is complete.
+ *
+ * You can create a [OnHeapAnalyzedListener] from a lambda by calling [invoke].
+ */
+interface OnHeapAnalyzedListener {
+
+  /**
+   * @see OnHeapAnalyzedListener
+   */
+  fun onHeapAnalyzed(heapAnalysis: HeapAnalysis)
+
+  companion object {
+    /**
+     * Utility function to create a [OnHeapAnalyzedListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnHeapAnalyzedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnHeapAnalyzedListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HeapAnalysis) -> Unit): OnHeapAnalyzedListener =
+      object : OnHeapAnalyzedListener {
+        override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+          block(heapAnalysis)
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index 17655635..0c417b48 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -31,7 +31,7 @@ import android.view.View
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
 import leakcanary.CanaryLog
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.InternalLeakCanary.noOpDelegate
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import java.io.File
 import java.util.concurrent.TimeUnit.SECONDS
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 6da53dd2..239544b9 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -43,30 +43,20 @@ import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.START
 import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
-import leakcanary.internal.MoreDetailsView.Details.CLOSED
-import leakcanary.internal.MoreDetailsView.Details.NONE
-import leakcanary.internal.MoreDetailsView.Details.OPENED
 import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
-import leakcanary.internal.navigation.inflate
-import android.os.Build.VERSION.SDK_INT
 import leakcanary.internal.navigation.getColorCompat
+import leakcanary.internal.navigation.inflate
 
 @Suppress("DEPRECATION")
 internal class DisplayLeakAdapter constructor(
   context: Context,
   private val leakTrace: LeakTrace,
-  private val instanceProjections: List<InstanceProjection>
+  private val groupDescription: String = "",
+  private val instanceProjections: List<InstanceProjection> = emptyList()
 ) : BaseAdapter() {
 
   private val isLeakGroup = instanceProjections.isNotEmpty()
 
-  constructor(
-    context: Context,
-    leakTrace: LeakTrace
-  ) : this(context, leakTrace, emptyList())
-
-  private val opened = BooleanArray(TOP_ROW_COUNT + leakTrace.elements.size)
-
   private val classNameColorHexString: String
   private val leakColorHexString: String
   private val referenceColorHexString: String
@@ -107,7 +97,7 @@ internal class DisplayLeakAdapter constructor(
 
   private fun bindTopRow(view: View) {
     val textView = view.findViewById<TextView>(R.id.leak_canary_row_text)
-    textView.text = view.context.packageName
+    textView.text = groupDescription
   }
 
   private fun bindConnectorRow(
@@ -115,28 +105,10 @@ internal class DisplayLeakAdapter constructor(
     position: Int
   ) {
     val titleView = view.findViewById<TextView>(R.id.leak_canary_row_title)
-    val detailView = view.findViewById<TextView>(R.id.leak_canary_row_details)
     val connector = view.findViewById<DisplayLeakConnectorView>(R.id.leak_canary_row_connector)
-    val moreDetailsView = view.findViewById<MoreDetailsView>(R.id.leak_canary_row_more)
 
     connector.setType(getConnectorType(position))
 
-    moreDetailsView.setDetails(
-        when {
-          isLeakGroup -> NONE
-          // Learn more row
-          isFirstConnectorRow(position) -> NONE
-          opened[position] -> OPENED
-          else -> CLOSED
-        }
-    )
-
-    if (opened[position]) {
-      detailView.visibility = View.VISIBLE
-    } else {
-      detailView.visibility = View.GONE
-    }
-
     val resources = view.resources
     if (isFirstConnectorRow(position)) {
       titleView.text = if (isLeakGroup) {
@@ -167,11 +139,6 @@ internal class DisplayLeakAdapter constructor(
       val htmlTitle = htmlTitle(element, maybeLeakCause, view.context)
 
       titleView.text = htmlTitle
-
-      if (opened[position]) {
-        val htmlDetail = htmlDetails(element)
-        detailView.text = htmlDetail
-      }
     }
   }
 
@@ -241,11 +208,6 @@ internal class DisplayLeakAdapter constructor(
 
       htmlString += "$indentation$styledClassName.${if (maybeLeakCause) "<b>$referenceName</b>" else referenceName}"
     }
-
-    val exclusion = element.exclusion
-    if (exclusion != null) {
-      htmlString += " (excluded)"
-    }
     val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
     if (maybeLeakCause) {
       SquigglySpan.replaceUnderlineSpans(builder, context)
@@ -254,19 +216,6 @@ internal class DisplayLeakAdapter constructor(
     return builder
   }
 
-  private fun htmlDetails(element: LeakTraceElement): Spanned {
-    var htmlString = ""
-    val exclusion = element.exclusion
-    if (exclusion != null) {
-      htmlString += "<br/><br/>Excluded by rule"
-      htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>"
-      if (exclusion.reason != null) {
-        htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>"
-      }
-    }
-    return Html.fromHtml(htmlString)
-  }
-
   private fun getConnectorType(position: Int): Type {
     if (isFirstConnectorRow(position)) {
       return if (isLeakGroup) HELP_LEAK_GROUP else HELP
@@ -305,7 +254,9 @@ internal class DisplayLeakAdapter constructor(
               NODE_UNREACHABLE
             }
           }
-          else -> throw IllegalStateException("Unknown value: " + reachability.leakStatusAndReason.status)
+          else -> throw IllegalStateException(
+              "Unknown value: " + reachability.leakStatusAndReason.status
+          )
         }
       }
     }
@@ -315,11 +266,6 @@ internal class DisplayLeakAdapter constructor(
 
   fun isFirstConnectorRow(position: Int) = position == TOP_ROW_COUNT - 1
 
-  fun toggleRow(position: Int) {
-    opened[position] = !opened[position]
-    notifyDataSetChanged()
-  }
-
   override fun getCount() = TOP_ROW_COUNT + leakTrace.elements.size + instanceProjections.size
 
   override fun getItem(position: Int) = null
@@ -346,7 +292,10 @@ internal class DisplayLeakAdapter constructor(
     private const val TOP_ROW_COUNT = 2
 
     // https://stackoverflow.com/a/6540378/703646
-    private fun hexStringColor(context: Context, colorResId: Int): String {
+    private fun hexStringColor(
+      context: Context,
+      colorResId: Int
+    ): String {
       return String.format("#%06X", 0xFFFFFF and context.getColorCompat(colorResId))
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
index 9208e0d1..1f6eb5fd 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
@@ -22,7 +22,7 @@ import android.os.IBinder
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 
-abstract class ForegroundService(
+internal abstract class ForegroundService(
   name: String,
   private val notificationContentTitleResId: Int,
   private val notificationId: Int
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index f99a2da5..324c68dd 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -21,7 +21,6 @@ import android.os.Build.VERSION.SDK_INT
 import android.os.Process
 import com.squareup.leakcanary.core.R
 import leakcanary.AnalyzerProgressListener
-import leakcanary.AndroidKnownReference
 import leakcanary.AndroidObjectInspectors
 import leakcanary.CanaryLog
 import leakcanary.HeapAnalyzer
@@ -57,17 +56,16 @@ internal class HeapAnalyzerService : ForegroundService(
     val heapAnalyzer = HeapAnalyzer(this)
     val config = LeakCanary.config
 
-    val exclusions = AndroidKnownReference.mapToExclusions(config.knownReferences)
 
     val heapAnalysis =
       heapAnalyzer.checkForLeaks(
-          heapDumpFile, exclusions, config.computeRetainedHeapSize, config.objectInspectors,
+          heapDumpFile, config.referenceMatchers, config.computeRetainedHeapSize, config.objectInspectors,
           if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
               AndroidObjectInspectors.KEYED_WEAK_REFERENCE
           )
       )
 
-    config.analysisResultListener(application, heapAnalysis)
+    config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)
   }
 
   override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index c0110559..8183afbc 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -12,7 +12,7 @@ import leakcanary.GcTrigger
 import leakcanary.KeyedWeakReference
 import leakcanary.LeakCanary.Config
 import leakcanary.LeakSentry
-import leakcanary.RefWatcher
+import leakcanary.ObjectWatcher
 import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
 import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
@@ -20,7 +20,7 @@ import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 internal class HeapDumpTrigger(
   private val application: Application,
   private val backgroundHandler: Handler,
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val gcTrigger: GcTrigger,
   private val heapDumper: HeapDumper,
   private val configProvider: () -> Config
@@ -36,7 +36,7 @@ internal class HeapDumpTrigger(
   @Volatile
   private var checkScheduled: Boolean = false
 
-  private var lastDisplayedRetainedInstanceCount = 0
+  private var lastDisplayedRetainedObjectCount = 0
 
   private val scheduleDismissRetainedCountNotification = {
     dismissRetainedCountNotification()
@@ -65,35 +65,35 @@ internal class HeapDumpTrigger(
       applicationInvisibleAt = -1L
     } else {
       applicationInvisibleAt = SystemClock.uptimeMillis()
-      scheduleRetainedInstanceCheck("app became invisible", LeakSentry.config.watchDurationMillis)
+      scheduleRetainedObjectCheck("app became invisible", LeakSentry.config.watchDurationMillis)
     }
   }
 
-  fun onReferenceRetained() {
-    scheduleRetainedInstanceCheck("found new instance retained")
+  fun onObjectRetained() {
+    scheduleRetainedObjectCheck("found new object retained")
   }
 
-  private fun checkRetainedInstances(reason: String) {
+  private fun checkRetainedObjects(reason: String) {
     val config = configProvider()
     // A tick will be rescheduled when this is turned back on.
     if (!config.dumpHeap) {
-      CanaryLog.d("No checking for retained instance: LeakCanary.Config.dumpHeap is false")
+      CanaryLog.d("No checking for retained object: LeakCanary.Config.dumpHeap is false")
       return
     }
-    CanaryLog.d("Checking retained instances because %s", reason)
+    CanaryLog.d("Checking retained object because %s", reason)
 
-    var retainedReferenceCount = refWatcher.retainedInstanceCount
+    var retainedReferenceCount = objectWatcher.retainedObjectCount
 
     if (retainedReferenceCount > 0) {
       gcTrigger.runGc()
-      retainedReferenceCount = refWatcher.retainedInstanceCount
+      retainedReferenceCount = objectWatcher.retainedObjectCount
     }
 
     if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
     if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
       showRetainedCountWithDebuggerAttached(retainedReferenceCount)
-      scheduleRetainedInstanceCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
+      scheduleRetainedObjectCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
       CanaryLog.d(
           "Not checking for leaks while the debugger is attached, will retry in %d ms",
           WAIT_FOR_DEBUG_MILLIS
@@ -108,12 +108,12 @@ internal class HeapDumpTrigger(
     val heapDumpFile = heapDumper.dumpHeap()
     if (heapDumpFile == null) {
       CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
-      scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      scheduleRetainedObjectCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
       showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
       return
     }
-    lastDisplayedRetainedInstanceCount = 0
-    refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
+    lastDisplayedRetainedObjectCount = 0
+    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
 
     HeapAnalyzerService.runAnalysis(application, heapDumpFile)
   }
@@ -122,17 +122,17 @@ internal class HeapDumpTrigger(
     backgroundHandler.post {
       dismissNoRetainedOnTapNotification()
       gcTrigger.runGc()
-      val retainedReferenceCount = refWatcher.retainedInstanceCount
+      val retainedReferenceCount = objectWatcher.retainedObjectCount
       if (retainedReferenceCount == 0) {
-        CanaryLog.d("No retained instances after GC")
+        CanaryLog.d("No retained objects after GC")
         @Suppress("DEPRECATION")
         val builder = Notification.Builder(application)
             .setContentTitle(
-                application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+                application.getString(R.string.leak_canary_notification_no_retained_object_title)
             )
             .setContentText(
                 application.getString(
-                    R.string.leak_canary_notification_no_retained_instance_content
+                    R.string.leak_canary_notification_no_retained_object_content
                 )
             )
             .setAutoCancel(true)
@@ -140,13 +140,13 @@ internal class HeapDumpTrigger(
         val notification =
           Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
         notificationManager.notify(
-            R.id.leak_canary_notification_no_retained_instance_on_tap, notification
+            R.id.leak_canary_notification_no_retained_object_on_tap, notification
         )
         backgroundHandler.postDelayed(
             scheduleDismissNoRetainedOnTapNotification,
-            DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+            DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS
         )
-        lastDisplayedRetainedInstanceCount = 0
+        lastDisplayedRetainedObjectCount = 0
         return@post
       }
 
@@ -160,8 +160,8 @@ internal class HeapDumpTrigger(
         showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
         return@post
       }
-      lastDisplayedRetainedInstanceCount = 0
-      refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
+      lastDisplayedRetainedObjectCount = 0
+      objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
       HeapAnalyzerService.runAnalysis(application, heapDumpFile)
     }
   }
@@ -170,12 +170,12 @@ internal class HeapDumpTrigger(
     retainedKeysCount: Int,
     retainedVisibleThreshold: Int
   ): Boolean {
-    val countChanged = lastDisplayedRetainedInstanceCount != retainedKeysCount
-    lastDisplayedRetainedInstanceCount = retainedKeysCount
+    val countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount
+    lastDisplayedRetainedObjectCount = retainedKeysCount
     if (retainedKeysCount == 0) {
-      CanaryLog.d("No retained instances")
+      CanaryLog.d("No retained objects")
       if (countChanged) {
-        showNoMoreRetainedInstanceNotification()
+        showNoMoreRetainedObjectNotification()
       }
       return true
     }
@@ -183,13 +183,13 @@ internal class HeapDumpTrigger(
     if (retainedKeysCount < retainedVisibleThreshold) {
       if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
         CanaryLog.d(
-            "Found %d retained instances, which is less than the visible threshold of %d",
+            "Found %d retained objects, which is less than the visible threshold of %d",
             retainedKeysCount,
             retainedVisibleThreshold
         )
         showRetainedCountBelowThresholdNotification(retainedKeysCount, retainedVisibleThreshold)
-        scheduleRetainedInstanceCheck(
-            "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
+        scheduleRetainedObjectCheck(
+            "Showing retained objects notification", WAIT_FOR_OBJECT_THRESHOLD_MILLIS
         )
         return true
       }
@@ -197,7 +197,7 @@ internal class HeapDumpTrigger(
     return false
   }
 
-  private fun scheduleRetainedInstanceCheck(reason: String) {
+  private fun scheduleRetainedObjectCheck(reason: String) {
     if (checkScheduled) {
       CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
       return
@@ -205,11 +205,11 @@ internal class HeapDumpTrigger(
     checkScheduled = true
     backgroundHandler.post {
       checkScheduled = false
-      checkRetainedInstances(reason)
+      checkRetainedObjects(reason)
     }
   }
 
-  private fun scheduleRetainedInstanceCheck(
+  private fun scheduleRetainedObjectCheck(
     reason: String,
     delayMillis: Long
   ) {
@@ -220,60 +220,60 @@ internal class HeapDumpTrigger(
     checkScheduled = true
     backgroundHandler.postDelayed({
       checkScheduled = false
-      checkRetainedInstances(reason)
+      checkRetainedObjects(reason)
     }, delayMillis)
   }
 
   private fun showRetainedCountBelowThresholdNotification(
-    instanceCount: Int,
+    objectCount: Int,
     retainedVisibleThreshold: Int
   ) {
     showRetainedCountNotification(
-        instanceCount, application.getString(
+        objectCount, application.getString(
         R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold
     )
     )
   }
 
-  private fun showRetainedCountWithDebuggerAttached(instanceCount: Int) {
+  private fun showRetainedCountWithDebuggerAttached(objectCount: Int) {
     showRetainedCountNotification(
-        instanceCount,
+        objectCount,
         application.getString(R.string.leak_canary_notification_retained_debugger_attached)
     )
   }
 
-  private fun showRetainedCountWithHeapDumpFailed(instanceCount: Int) {
+  private fun showRetainedCountWithHeapDumpFailed(objectCount: Int) {
     showRetainedCountNotification(
-        instanceCount, application.getString(R.string.leak_canary_notification_retained_dump_failed)
+        objectCount, application.getString(R.string.leak_canary_notification_retained_dump_failed)
     )
   }
 
-  private fun showNoMoreRetainedInstanceNotification() {
+  private fun showNoMoreRetainedObjectNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
     if (!Notifications.canShowNotification) {
       return
     }
     val builder = Notification.Builder(application)
         .setContentTitle(
-            application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+            application.getString(R.string.leak_canary_notification_no_retained_object_title)
         )
         .setContentText(
             application.getString(
-                R.string.leak_canary_notification_no_retained_instance_content
+                R.string.leak_canary_notification_no_retained_object_content
             )
         )
         .setAutoCancel(true)
         .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
     val notification =
       Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
-    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+    notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
     backgroundHandler.postDelayed(
-        scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+        scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS
     )
   }
 
   private fun showRetainedCountNotification(
-    instanceCount: Int,
+    objectCount: Int,
     contentText: String
   ) {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
@@ -283,31 +283,31 @@ internal class HeapDumpTrigger(
     @Suppress("DEPRECATION")
     val builder = Notification.Builder(application)
         .setContentTitle(
-            application.getString(R.string.leak_canary_notification_retained_title, instanceCount)
+            application.getString(R.string.leak_canary_notification_retained_title, objectCount)
         )
         .setContentText(contentText)
         .setAutoCancel(true)
         .setContentIntent(NotificationReceiver.pendingIntent(application, DUMP_HEAP))
     val notification =
       Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
-    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+    notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
   }
 
   private fun dismissRetainedCountNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
-    notificationManager.cancel(R.id.leak_canary_notification_retained_instances)
+    notificationManager.cancel(R.id.leak_canary_notification_retained_objects)
   }
 
   private fun dismissNoRetainedOnTapNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissNoRetainedOnTapNotification)
-    notificationManager.cancel(R.id.leak_canary_notification_no_retained_instance_on_tap)
+    notificationManager.cancel(R.id.leak_canary_notification_no_retained_object_on_tap)
   }
 
   companion object {
     private const val WAIT_FOR_DEBUG_MILLIS = 20_000L
     private const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
-    private const val WAIT_FOR_INSTANCE_THRESHOLD_MILLIS = 2_000L
-    private const val DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS = 30_000L
+    private const val WAIT_FOR_OBJECT_THRESHOLD_MILLIS = 2_000L
+    private const val DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS = 30_000L
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 7da229c2..6c0470a8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -17,10 +17,13 @@ import leakcanary.GcTrigger
 import leakcanary.LeakCanary
 import leakcanary.LeakCanary.Config
 import leakcanary.LeakSentry
+import leakcanary.OnObjectRetainedListener
 import leakcanary.internal.activity.LeakActivity
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
 import java.util.concurrent.atomic.AtomicReference
 
-internal object InternalLeakCanary : LeakSentryListener {
+internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
 
   private const val DYNAMIC_SHORTCUT_ID = "com.squareup.leakcanary.dynamic_shortcut"
 
@@ -44,10 +47,10 @@ internal object InternalLeakCanary : LeakSentryListener {
 
   val noInstallConfig: Config
     get() = Config(
-        dumpHeap = false, knownReferences = emptySet(), objectInspectors = emptyList()
+        dumpHeap = false, referenceMatchers = emptyList(), objectInspectors = emptyList()
     )
 
-  override fun onLeakSentryInstalled(application: Application) {
+  override fun invoke(application: Application) {
     this.application = application
 
     val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
@@ -61,7 +64,7 @@ internal object InternalLeakCanary : LeakSentryListener {
     val backgroundHandler = Handler(handlerThread.looper)
 
     heapDumpTrigger = HeapDumpTrigger(
-        application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider
+        application, backgroundHandler, LeakSentry.objectWatcher, gcTrigger, heapDumper, configProvider
     )
     application.registerVisibilityListener { applicationVisible ->
       this.applicationVisible = applicationVisible
@@ -205,9 +208,9 @@ internal object InternalLeakCanary : LeakSentryListener {
     }
   }
 
-  override fun onReferenceRetained() {
+  override fun onObjectRetained() {
     if (this::heapDumpTrigger.isInitialized) {
-      heapDumpTrigger.onReferenceRetained()
+      heapDumpTrigger.onObjectRetained()
     }
   }
 
@@ -217,5 +220,15 @@ internal object InternalLeakCanary : LeakSentryListener {
     }
   }
 
+  inline fun <reified T : Any> noOpDelegate(): T {
+    val javaClass = T::class.java
+    val noOpHandler = InvocationHandler { _, _, _ ->
+      // no op
+    }
+    return Proxy.newProxyInstance(
+        javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    ) as T
+  }
+
   private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java
deleted file mode 100644
index a76fe7f4..00000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.java
+++ /dev/null
@@ -1,541 +0,0 @@
-package leakcanary.internal;
-
-import static org.xmlpull.v1.XmlPullParser.END_DOCUMENT;
-import static org.xmlpull.v1.XmlPullParser.START_TAG;
-
-import android.content.ContentProvider;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ProviderInfo;
-import android.content.res.XmlResourceParser;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Environment;
-import android.os.ParcelFileDescriptor;
-import android.provider.OpenableColumns;
-import android.text.TextUtils;
-import android.webkit.MimeTypeMap;
-
-import org.xmlpull.v1.XmlPullParserException;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-public class LeakCanaryFileProvider extends ContentProvider {
-    private static final String[] COLUMNS = {
-            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE };
-
-    private static final String
-            META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS";
-
-    private static final String TAG_ROOT_PATH = "root-path";
-    private static final String TAG_FILES_PATH = "files-path";
-    private static final String TAG_CACHE_PATH = "cache-path";
-    private static final String TAG_EXTERNAL = "external-path";
-    private static final String TAG_EXTERNAL_FILES = "external-files-path";
-    private static final String TAG_EXTERNAL_CACHE = "external-cache-path";
-    private static final String TAG_EXTERNAL_MEDIA = "external-media-path";
-
-    private static final String ATTR_NAME = "name";
-    private static final String ATTR_PATH = "path";
-
-    private static final File DEVICE_ROOT = new File("/");
-
-    private static HashMap<String, PathStrategy> sCache = new HashMap<String, PathStrategy>();
-
-    private PathStrategy mStrategy;
-
-    /**
-     * The default FileProvider implementation does not need to be initialized. If you want to
-     * override this method, you must provide your own subclass of FileProvider.
-     */
-    @Override
-    public boolean onCreate() {
-        return true;
-    }
-
-    /**
-     * After the FileProvider is instantiated, this method is called to provide the system with
-     * information about the provider.
-     *
-     * @param context A {@link Context} for the current component.
-     * @param info A {@link ProviderInfo} for the new provider.
-     */
-    @Override
-    public void attachInfo(Context context, ProviderInfo info) {
-        super.attachInfo(context, info);
-
-        // Sanity check our security
-        if (info.exported) {
-            throw new SecurityException("Provider must not be exported");
-        }
-        if (!info.grantUriPermissions) {
-            throw new SecurityException("Provider must grant uri permissions");
-        }
-
-        mStrategy = getPathStrategy(context, info.authority);
-    }
-
-    /**
-     * Return a content URI for a given {@link File}. Specific temporary
-     * permissions for the content URI can be set with
-     * {@link Context#grantUriPermission(String, Uri, int)}, or added
-     * to an {@link Intent} by calling {@link Intent#setData(Uri) setData()} and then
-     * {@link Intent#setFlags(int) setFlags()}; in both cases, the applicable flags are
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}. A FileProvider can only return a
-     * <code>content</code> {@link Uri} for file paths defined in their <code>&lt;paths&gt;</code>
-     * meta-data element. See the Class Overview for more information.
-     *
-     * @param context A {@link Context} for the current component.
-     * @param authority The authority of a {@link FileProvider} defined in a
-     *            {@code <provider>} element in your app's manifest.
-     * @param file A {@link File} pointing to the filename for which you want a
-     * <code>content</code> {@link Uri}.
-     * @return A content URI for the file.
-     * @throws IllegalArgumentException When the given {@link File} is outside
-     * the paths supported by the provider.
-     */
-    public static Uri getUriForFile(Context context, String authority,
-            File file) {
-        final PathStrategy strategy = getPathStrategy(context, authority);
-        return strategy.getUriForFile(file);
-    }
-
-    /**
-     * Use a content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()} to get information about a file
-     * managed by the FileProvider.
-     * FileProvider reports the column names defined in {@link android.provider.OpenableColumns}:
-     * <ul>
-     * <li>{@link android.provider.OpenableColumns#DISPLAY_NAME}</li>
-     * <li>{@link android.provider.OpenableColumns#SIZE}</li>
-     * </ul>
-     * For more information, see
-     * {@link ContentProvider#query(Uri, String[], String, String[], String)
-     * ContentProvider.query()}.
-     *
-     * @param uri A content URI returned by {@link #getUriForFile}.
-     * @param projection The list of columns to put into the {@link Cursor}. If null all columns are
-     * included.
-     * @param selection Selection criteria to apply. If null then all data that matches the content
-     * URI is returned.
-     * @param selectionArgs An array of {@link java.lang.String}, containing arguments to bind to
-     * the <i>selection</i> parameter. The <i>query</i> method scans <i>selection</i> from left to
-     * right and iterates through <i>selectionArgs</i>, replacing the current "?" character in
-     * <i>selection</i> with the value at the current position in <i>selectionArgs</i>. The
-     * values are bound to <i>selection</i> as {@link java.lang.String} values.
-     * @param sortOrder A {@link java.lang.String} containing the column name(s) on which to sort
-     * the resulting {@link Cursor}.
-     * @return A {@link Cursor} containing the results of the query.
-     *
-     */
-    @Override
-    public Cursor query(Uri uri, String[] projection, String selection,
-            String[] selectionArgs,
-            String sortOrder) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-
-        if (projection == null) {
-            projection = COLUMNS;
-        }
-
-        String[] cols = new String[projection.length];
-        Object[] values = new Object[projection.length];
-        int i = 0;
-        for (String col : projection) {
-            if (OpenableColumns.DISPLAY_NAME.equals(col)) {
-                cols[i] = OpenableColumns.DISPLAY_NAME;
-                values[i++] = file.getName();
-            } else if (OpenableColumns.SIZE.equals(col)) {
-                cols[i] = OpenableColumns.SIZE;
-                values[i++] = file.length();
-            }
-        }
-
-        cols = copyOf(cols, i);
-        values = copyOf(values, i);
-
-        final MatrixCursor cursor = new MatrixCursor(cols, 1);
-        cursor.addRow(values);
-        return cursor;
-    }
-
-    /**
-     * Returns the MIME type of a content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     *
-     * @param uri A content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @return If the associated file has an extension, the MIME type associated with that
-     * extension; otherwise <code>application/octet-stream</code>.
-     */
-    @Override
-    public String getType(Uri uri) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-
-        final int lastDot = file.getName().lastIndexOf('.');
-        if (lastDot >= 0) {
-            final String extension = file.getName().substring(lastDot + 1);
-            final String mime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
-            if (mime != null) {
-                return mime;
-            }
-        }
-
-        return "application/octet-stream";
-    }
-
-    /**
-     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
-     * subclass FileProvider if you want to provide different functionality.
-     */
-    @Override
-    public Uri insert(Uri uri, ContentValues values) {
-        throw new UnsupportedOperationException("No external inserts");
-    }
-
-    /**
-     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
-     * subclass FileProvider if you want to provide different functionality.
-     */
-    @Override
-    public int update(Uri uri, ContentValues values, String selection,
-            String[] selectionArgs) {
-        throw new UnsupportedOperationException("No external updates");
-    }
-
-    /**
-     * Deletes the file associated with the specified content URI, as
-     * returned by {@link #getUriForFile(Context, String, File) getUriForFile()}. Notice that this
-     * method does <b>not</b> throw an {@link java.io.IOException}; you must check its return value.
-     *
-     * @param uri A content URI for a file, as returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @param selection Ignored. Set to {@code null}.
-     * @param selectionArgs Ignored. Set to {@code null}.
-     * @return 1 if the delete succeeds; otherwise, 0.
-     */
-    @Override
-    public int delete(Uri uri, String selection,
-            String[] selectionArgs) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-        return file.delete() ? 1 : 0;
-    }
-
-    /**
-     * By default, FileProvider automatically returns the
-     * {@link ParcelFileDescriptor} for a file associated with a <code>content://</code>
-     * {@link Uri}. To get the {@link ParcelFileDescriptor}, call
-     * {@link android.content.ContentResolver#openFileDescriptor(Uri, String)
-     * ContentResolver.openFileDescriptor}.
-     *
-     * To override this method, you must provide your own subclass of FileProvider.
-     *
-     * @param uri A content URI associated with a file, as returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
-     * write access, or "rwt" for read and write access that truncates any existing file.
-     * @return A new {@link ParcelFileDescriptor} with which you can access the file.
-     */
-    @Override
-    public ParcelFileDescriptor openFile(Uri uri, String mode)
-            throws FileNotFoundException {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-        final int fileMode = modeToMode(mode);
-        return ParcelFileDescriptor.open(file, fileMode);
-    }
-
-    /**
-     * Return {@link PathStrategy} for given authority, either by parsing or
-     * returning from cache.
-     */
-    private static PathStrategy getPathStrategy(Context context, String authority) {
-        PathStrategy strat;
-        synchronized (sCache) {
-            strat = sCache.get(authority);
-            if (strat == null) {
-                try {
-                    strat = parsePathStrategy(context, authority);
-                } catch (IOException e) {
-                    throw new IllegalArgumentException(
-                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
-                } catch (XmlPullParserException e) {
-                    throw new IllegalArgumentException(
-                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
-                }
-                sCache.put(authority, strat);
-            }
-        }
-        return strat;
-    }
-
-    /**
-     * Parse and return {@link PathStrategy} for given authority as defined in
-     * {@link #META_DATA_FILE_PROVIDER_PATHS} {@code <meta-data>}.
-     *
-     * @see #getPathStrategy(Context, String)
-     */
-    private static PathStrategy parsePathStrategy(Context context, String authority)
-            throws IOException, XmlPullParserException {
-        final SimplePathStrategy strat = new SimplePathStrategy(authority);
-
-        final ProviderInfo info = context.getPackageManager()
-                .resolveContentProvider(authority, PackageManager.GET_META_DATA);
-        final XmlResourceParser in = info.loadXmlMetaData(
-                context.getPackageManager(), META_DATA_FILE_PROVIDER_PATHS);
-        if (in == null) {
-            throw new IllegalArgumentException(
-                    "Missing " + META_DATA_FILE_PROVIDER_PATHS + " meta-data");
-        }
-
-        int type;
-        while ((type = in.next()) != END_DOCUMENT) {
-            if (type == START_TAG) {
-                final String tag = in.getName();
-
-                final String name = in.getAttributeValue(null, ATTR_NAME);
-                String path = in.getAttributeValue(null, ATTR_PATH);
-
-                File target = null;
-                if (TAG_ROOT_PATH.equals(tag)) {
-                    target = DEVICE_ROOT;
-                } else if (TAG_FILES_PATH.equals(tag)) {
-                    target = context.getFilesDir();
-                } else if (TAG_CACHE_PATH.equals(tag)) {
-                    target = context.getCacheDir();
-                } else if (TAG_EXTERNAL.equals(tag)) {
-                    target = Environment.getExternalStorageDirectory();
-                } else if (TAG_EXTERNAL_FILES.equals(tag)) {
-                    File[] externalFilesDirs = getExternalFilesDirs(context, null);
-                    if (externalFilesDirs.length > 0) {
-                        target = externalFilesDirs[0];
-                    }
-                } else if (TAG_EXTERNAL_CACHE.equals(tag)) {
-                    File[] externalCacheDirs = getExternalCacheDirs(context);
-                    if (externalCacheDirs.length > 0) {
-                        target = externalCacheDirs[0];
-                    }
-                } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
-                        && TAG_EXTERNAL_MEDIA.equals(tag)) {
-                    File[] externalMediaDirs = context.getExternalMediaDirs();
-                    if (externalMediaDirs.length > 0) {
-                        target = externalMediaDirs[0];
-                    }
-                }
-
-                if (target != null) {
-                    strat.addRoot(name, buildPath(target, path));
-                }
-            }
-        }
-
-        return strat;
-    }
-
-    private static File[] getExternalFilesDirs(Context context, String type) {
-        if (Build.VERSION.SDK_INT >= 19) {
-            return context.getExternalFilesDirs(type);
-        } else {
-            return new File[] { context.getExternalFilesDir(type) };
-        }
-    }
-
-    private static File[] getExternalCacheDirs(Context context) {
-        if (Build.VERSION.SDK_INT >= 19) {
-            return context.getExternalCacheDirs();
-        } else {
-            return new File[] { context.getExternalCacheDir() };
-        }
-    }
-
-    /**
-     * Strategy for mapping between {@link File} and {@link Uri}.
-     * <p>
-     * Strategies must be symmetric so that mapping a {@link File} to a
-     * {@link Uri} and then back to a {@link File} points at the original
-     * target.
-     * <p>
-     * Strategies must remain consistent across app launches, and not rely on
-     * dynamic state. This ensures that any generated {@link Uri} can still be
-     * resolved if your process is killed and later restarted.
-     *
-     * @see SimplePathStrategy
-     */
-    interface PathStrategy {
-        /**
-         * Return a {@link Uri} that represents the given {@link File}.
-         */
-        Uri getUriForFile(File file);
-
-        /**
-         * Return a {@link File} that represents the given {@link Uri}.
-         */
-        File getFileForUri(Uri uri);
-    }
-
-    /**
-     * Strategy that provides access to files living under a narrow whitelist of
-     * filesystem roots. It will throw {@link SecurityException} if callers try
-     * accessing files outside the configured roots.
-     * <p>
-     * For example, if configured with
-     * {@code addRoot("myfiles", context.getFilesDir())}, then
-     * {@code context.getFileStreamPath("foo.txt")} would map to
-     * {@code content://myauthority/myfiles/foo.txt}.
-     */
-    static class SimplePathStrategy implements PathStrategy {
-        private final String mAuthority;
-        private final HashMap<String, File> mRoots = new HashMap<String, File>();
-
-        SimplePathStrategy(String authority) {
-            mAuthority = authority;
-        }
-
-        /**
-         * Add a mapping from a name to a filesystem root. The provider only offers
-         * access to files that live under configured roots.
-         */
-        void addRoot(String name, File root) {
-            if (TextUtils.isEmpty(name)) {
-                throw new IllegalArgumentException("Name must not be empty");
-            }
-
-            try {
-                // Resolve to canonical path to keep path checking fast
-                root = root.getCanonicalFile();
-            } catch (IOException e) {
-                throw new IllegalArgumentException(
-                        "Failed to resolve canonical path for " + root, e);
-            }
-
-            mRoots.put(name, root);
-        }
-
-        @Override
-        public Uri getUriForFile(File file) {
-            String path;
-            try {
-                path = file.getCanonicalPath();
-            } catch (IOException e) {
-                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
-            }
-
-            // Find the most-specific root path
-            Map.Entry<String, File> mostSpecific = null;
-            for (Map.Entry<String, File> root : mRoots.entrySet()) {
-                final String rootPath = root.getValue().getPath();
-                if (path.startsWith(rootPath) && (mostSpecific == null
-                        || rootPath.length() > mostSpecific.getValue().getPath().length())) {
-                    mostSpecific = root;
-                }
-            }
-
-            if (mostSpecific == null) {
-                throw new IllegalArgumentException(
-                        "Failed to find configured root that contains " + path);
-            }
-
-            // Start at first char of path under root
-            final String rootPath = mostSpecific.getValue().getPath();
-            if (rootPath.endsWith("/")) {
-                path = path.substring(rootPath.length());
-            } else {
-                path = path.substring(rootPath.length() + 1);
-            }
-
-            // Encode the tag and path separately
-            path = Uri.encode(mostSpecific.getKey()) + '/' + Uri.encode(path, "/");
-            return new Uri.Builder().scheme("content")
-                    .authority(mAuthority).encodedPath(path).build();
-        }
-
-        @Override
-        public File getFileForUri(Uri uri) {
-            String path = uri.getEncodedPath();
-
-            final int splitIndex = path.indexOf('/', 1);
-            final String tag = Uri.decode(path.substring(1, splitIndex));
-            path = Uri.decode(path.substring(splitIndex + 1));
-
-            final File root = mRoots.get(tag);
-            if (root == null) {
-                throw new IllegalArgumentException("Unable to find configured root for " + uri);
-            }
-
-            File file = new File(root, path);
-            try {
-                file = file.getCanonicalFile();
-            } catch (IOException e) {
-                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
-            }
-
-            if (!file.getPath().startsWith(root.getPath())) {
-                throw new SecurityException("Resolved path jumped beyond configured root");
-            }
-
-            return file;
-        }
-    }
-
-    /**
-     * Copied from ContentResolver.java
-     */
-    private static int modeToMode(String mode) {
-        int modeBits;
-        if ("r".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
-        } else if ("w".equals(mode) || "wt".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_TRUNCATE;
-        } else if ("wa".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_APPEND;
-        } else if ("rw".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
-                    | ParcelFileDescriptor.MODE_CREATE;
-        } else if ("rwt".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_TRUNCATE;
-        } else {
-            throw new IllegalArgumentException("Invalid mode: " + mode);
-        }
-        return modeBits;
-    }
-
-    private static File buildPath(File base, String... segments) {
-        File cur = base;
-        for (String segment : segments) {
-            if (segment != null) {
-                cur = new File(cur, segment);
-            }
-        }
-        return cur;
-    }
-
-    private static String[] copyOf(String[] original, int newLength) {
-        final String[] result = new String[newLength];
-        System.arraycopy(original, 0, result, 0, newLength);
-        return result;
-    }
-
-    private static Object[] copyOf(Object[] original, int newLength) {
-        final Object[] result = new Object[newLength];
-        System.arraycopy(original, 0, result, 0, newLength);
-        return result;
-    }
-}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
new file mode 100644
index 00000000..16d0c143
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
@@ -0,0 +1,583 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.content.ContentProvider
+import android.content.ContentValues
+import android.content.Context
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.content.pm.ProviderInfo
+import android.database.Cursor
+import android.database.MatrixCursor
+import android.net.Uri
+import android.os.Build
+import android.os.Environment
+import android.os.ParcelFileDescriptor
+import android.provider.OpenableColumns
+import android.text.TextUtils
+import android.webkit.MimeTypeMap
+import org.xmlpull.v1.XmlPullParser.END_DOCUMENT
+import org.xmlpull.v1.XmlPullParser.START_TAG
+import org.xmlpull.v1.XmlPullParserException
+import java.io.File
+import java.io.FileNotFoundException
+import java.io.IOException
+import java.util.HashMap
+
+/**
+ * Copy of androidx.core.content.FileProvider, converted to Kotlin.
+ */
+internal class LeakCanaryFileProvider : ContentProvider() {
+
+  private var mStrategy: PathStrategy? = null
+
+  /**
+   * The default FileProvider implementation does not need to be initialized. If you want to
+   * override this method, you must provide your own subclass of FileProvider.
+   */
+  override fun onCreate(): Boolean {
+    return true
+  }
+
+  /**
+   * After the FileProvider is instantiated, this method is called to provide the system with
+   * information about the provider.
+   *
+   * @param context A [Context] for the current component.
+   * @param info A [ProviderInfo] for the new provider.
+   */
+  override fun attachInfo(
+    context: Context,
+    info: ProviderInfo
+  ) {
+    super.attachInfo(context, info)
+
+    // Sanity check our security
+    if (info.exported) {
+      throw SecurityException("Provider must not be exported")
+    }
+    if (!info.grantUriPermissions) {
+      throw SecurityException("Provider must grant uri permissions")
+    }
+
+    mStrategy = getPathStrategy(context, info.authority)
+  }
+
+  /**
+   * Use a content URI returned by
+   * [getUriForFile()][.getUriForFile] to get information about a file
+   * managed by the FileProvider.
+   * FileProvider reports the column names defined in [android.provider.OpenableColumns]:
+   *
+   *  * [android.provider.OpenableColumns.DISPLAY_NAME]
+   *  * [android.provider.OpenableColumns.SIZE]
+   *
+   * For more information, see
+   * [ ContentProvider.query()][ContentProvider.query].
+   *
+   * @param uri A content URI returned by [.getUriForFile].
+   * @param projection The list of columns to put into the [Cursor]. If null all columns are
+   * included.
+   * @param selection Selection criteria to apply. If null then all data that matches the content
+   * URI is returned.
+   * @param selectionArgs An array of [java.lang.String], containing arguments to bind to
+   * the *selection* parameter. The *query* method scans *selection* from left to
+   * right and iterates through *selectionArgs*, replacing the current "?" character in
+   * *selection* with the value at the current position in *selectionArgs*. The
+   * values are bound to *selection* as [java.lang.String] values.
+   * @param sortOrder A [java.lang.String] containing the column name(s) on which to sort
+   * the resulting [Cursor].
+   * @return A [Cursor] containing the results of the query.
+   */
+  override fun query(
+    uri: Uri,
+    projectionArg: Array<String>?,
+    selection: String?,
+    selectionArgs: Array<String>?,
+    sortOrder: String?
+  ): Cursor? {
+    val projection = projectionArg ?: COLUMNS
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy!!.getFileForUri(uri)
+
+    var cols = arrayOfNulls<String>(projection.size)
+    var values = arrayOfNulls<Any>(projection.size)
+    var i = 0
+    for (col in projection) {
+      if (OpenableColumns.DISPLAY_NAME == col) {
+        cols[i] = OpenableColumns.DISPLAY_NAME
+        values[i++] = file.name
+      } else if (OpenableColumns.SIZE == col) {
+        cols[i] = OpenableColumns.SIZE
+        values[i++] = file.length()
+      }
+    }
+
+    cols = copyOfStringArray(cols, i)
+    values = copyOfAnyArray(values, i)
+
+    val cursor = MatrixCursor(cols, 1)
+    cursor.addRow(values)
+    return cursor
+  }
+
+  /**
+   * Returns the MIME type of a content URI returned by
+   * [getUriForFile()][.getUriForFile].
+   *
+   * @param uri A content URI returned by
+   * [getUriForFile()][.getUriForFile].
+   * @return If the associated file has an extension, the MIME type associated with that
+   * extension; otherwise `application/octet-stream`.
+   */
+  override fun getType(uri: Uri): String? {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy!!.getFileForUri(uri)
+
+    val lastDot = file.name.lastIndexOf('.')
+    if (lastDot >= 0) {
+      val extension = file.name.substring(lastDot + 1)
+      val mime = MimeTypeMap.getSingleton()
+          .getMimeTypeFromExtension(extension)
+      if (mime != null) {
+        return mime
+      }
+    }
+
+    return "application/octet-stream"
+  }
+
+  /**
+   * By default, this method throws an [java.lang.UnsupportedOperationException]. You must
+   * subclass FileProvider if you want to provide different functionality.
+   */
+  override fun insert(
+    uri: Uri,
+    values: ContentValues?
+  ): Uri? {
+    throw UnsupportedOperationException("No external inserts")
+  }
+
+  /**
+   * By default, this method throws an [java.lang.UnsupportedOperationException]. You must
+   * subclass FileProvider if you want to provide different functionality.
+   */
+  override fun update(
+    uri: Uri,
+    values: ContentValues?,
+    selection: String?,
+    selectionArgs: Array<String>?
+  ): Int {
+    throw UnsupportedOperationException("No external updates")
+  }
+
+  /**
+   * Deletes the file associated with the specified content URI, as
+   * returned by [getUriForFile()][.getUriForFile]. Notice that this
+   * method does **not** throw an [java.io.IOException]; you must check its return value.
+   *
+   * @param uri A content URI for a file, as returned by
+   * [getUriForFile()][.getUriForFile].
+   * @param selection Ignored. Set to `null`.
+   * @param selectionArgs Ignored. Set to `null`.
+   * @return 1 if the delete succeeds; otherwise, 0.
+   */
+  override fun delete(
+    uri: Uri,
+    selection: String?,
+    selectionArgs: Array<String>?
+  ): Int {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy!!.getFileForUri(uri)
+    return if (file.delete()) 1 else 0
+  }
+
+  /**
+   * By default, FileProvider automatically returns the
+   * [ParcelFileDescriptor] for a file associated with a `content://`
+   * [Uri]. To get the [ParcelFileDescriptor], call
+   * [ ContentResolver.openFileDescriptor][android.content.ContentResolver.openFileDescriptor].
+   *
+   * To override this method, you must provide your own subclass of FileProvider.
+   *
+   * @param uri A content URI associated with a file, as returned by
+   * [getUriForFile()][.getUriForFile].
+   * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
+   * write access, or "rwt" for read and write access that truncates any existing file.
+   * @return A new [ParcelFileDescriptor] with which you can access the file.
+   */
+  @Throws(FileNotFoundException::class)
+  override fun openFile(
+    uri: Uri,
+    mode: String
+  ): ParcelFileDescriptor? {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy!!.getFileForUri(uri)
+    val fileMode = modeToMode(mode)
+    return ParcelFileDescriptor.open(file, fileMode)
+  }
+
+  /**
+   * Strategy for mapping between [File] and [Uri].
+   *
+   *
+   * Strategies must be symmetric so that mapping a [File] to a
+   * [Uri] and then back to a [File] points at the original
+   * target.
+   *
+   *
+   * Strategies must remain consistent across app launches, and not rely on
+   * dynamic state. This ensures that any generated [Uri] can still be
+   * resolved if your process is killed and later restarted.
+   *
+   * @see SimplePathStrategy
+   */
+  internal interface PathStrategy {
+    /**
+     * Return a [Uri] that represents the given [File].
+     */
+    fun getUriForFile(file: File): Uri
+
+    /**
+     * Return a [File] that represents the given [Uri].
+     */
+    fun getFileForUri(uri: Uri): File
+  }
+
+  /**
+   * Strategy that provides access to files living under a narrow whitelist of
+   * filesystem roots. It will throw [SecurityException] if callers try
+   * accessing files outside the configured roots.
+   *
+   *
+   * For example, if configured with
+   * `addRoot("myfiles", context.getFilesDir())`, then
+   * `context.getFileStreamPath("foo.txt")` would map to
+   * `content://myauthority/myfiles/foo.txt`.
+   */
+  internal class SimplePathStrategy(private val mAuthority: String) : PathStrategy {
+    private val mRoots = HashMap<String, File>()
+
+    /**
+     * Add a mapping from a name to a filesystem root. The provider only offers
+     * access to files that live under configured roots.
+     */
+    fun addRoot(
+      name: String,
+      root: File
+    ) {
+
+      if (TextUtils.isEmpty(name)) {
+        throw IllegalArgumentException("Name must not be empty")
+      }
+
+      mRoots[name] = try {
+        // Resolve to canonical path to keep path checking fast
+        root.canonicalFile
+      } catch (e: IOException) {
+        throw IllegalArgumentException(
+            "Failed to resolve canonical path for $root", e
+        )
+      }
+    }
+
+    override fun getUriForFile(file: File): Uri {
+      var path: String
+      try {
+        path = file.canonicalPath
+      } catch (e: IOException) {
+        throw IllegalArgumentException("Failed to resolve canonical path for $file")
+      }
+
+      // Find the most-specific root path
+      var mostSpecific: MutableMap.MutableEntry<String, File>? = null
+      for (root in mRoots.entries) {
+        val rootPath = root.value.path
+        if (path.startsWith(
+                rootPath
+            ) && (mostSpecific == null || rootPath.length > mostSpecific.value.path.length)
+        ) {
+          mostSpecific = root
+        }
+      }
+
+      if (mostSpecific == null) {
+        throw IllegalArgumentException(
+            "Failed to find configured root that contains $path"
+        )
+      }
+
+      // Start at first char of path under root
+      val rootPath = mostSpecific.value.path
+      if (rootPath.endsWith("/")) {
+        path = path.substring(rootPath.length)
+      } else {
+        path = path.substring(rootPath.length + 1)
+      }
+
+      // Encode the tag and path separately
+      path = Uri.encode(mostSpecific.key) + '/'.toString() + Uri.encode(path, "/")
+      return Uri.Builder()
+          .scheme("content")
+          .authority(mAuthority)
+          .encodedPath(path)
+          .build()
+    }
+
+    override fun getFileForUri(uri: Uri): File {
+      var path = uri.encodedPath
+
+      val splitIndex = path!!.indexOf('/', 1)
+      val tag = Uri.decode(path.substring(1, splitIndex))
+      path = Uri.decode(path.substring(splitIndex + 1))
+
+      val root =
+        mRoots[tag] ?: throw IllegalArgumentException("Unable to find configured root for $uri")
+
+      var file = File(root, path!!)
+      try {
+        file = file.canonicalFile
+      } catch (e: IOException) {
+        throw IllegalArgumentException("Failed to resolve canonical path for $file")
+      }
+
+      if (!file.path.startsWith(root.path)) {
+        throw SecurityException("Resolved path jumped beyond configured root")
+      }
+
+      return file
+    }
+  }
+
+  companion object {
+    private val COLUMNS = arrayOf(OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE)
+
+    private val META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS"
+
+    private val TAG_ROOT_PATH = "root-path"
+    private val TAG_FILES_PATH = "files-path"
+    private val TAG_CACHE_PATH = "cache-path"
+    private val TAG_EXTERNAL = "external-path"
+    private val TAG_EXTERNAL_FILES = "external-files-path"
+    private val TAG_EXTERNAL_CACHE = "external-cache-path"
+    private val TAG_EXTERNAL_MEDIA = "external-media-path"
+
+    private val ATTR_NAME = "name"
+    private val ATTR_PATH = "path"
+
+    private val DEVICE_ROOT = File("/")
+
+    private val sCache = HashMap<String, PathStrategy>()
+
+    /**
+     * Return a content URI for a given [File]. Specific temporary
+     * permissions for the content URI can be set with
+     * [Context.grantUriPermission], or added
+     * to an [Intent] by calling [setData()][Intent.setData] and then
+     * [setFlags()][Intent.setFlags]; in both cases, the applicable flags are
+     * [Intent.FLAG_GRANT_READ_URI_PERMISSION] and
+     * [Intent.FLAG_GRANT_WRITE_URI_PERMISSION]. A FileProvider can only return a
+     * `content` [Uri] for file paths defined in their `<paths>`
+     * meta-data element. See the Class Overview for more information.
+     *
+     * @param context A [Context] for the current component.
+     * @param authority The authority of a [FileProvider] defined in a
+     * `<provider>` element in your app's manifest.
+     * @param file A [File] pointing to the filename for which you want a
+     * `content` [Uri].
+     * @return A content URI for the file.
+     * @throws IllegalArgumentException When the given [File] is outside
+     * the paths supported by the provider.
+     */
+    fun getUriForFile(
+      context: Context,
+      authority: String,
+      file: File
+    ): Uri {
+      val strategy = getPathStrategy(context, authority)
+      return strategy!!.getUriForFile(file)
+    }
+
+    /**
+     * Return [PathStrategy] for given authority, either by parsing or
+     * returning from cache.
+     */
+    private fun getPathStrategy(
+      context: Context,
+      authority: String
+    ): PathStrategy? {
+      var strat: PathStrategy?
+      synchronized(sCache) {
+        strat = sCache[authority]
+        if (strat == null) {
+          try {
+            strat = parsePathStrategy(context, authority)
+          } catch (e: IOException) {
+            throw IllegalArgumentException(
+                "Failed to parse $META_DATA_FILE_PROVIDER_PATHS meta-data", e
+            )
+          } catch (e: XmlPullParserException) {
+            throw IllegalArgumentException(
+                "Failed to parse $META_DATA_FILE_PROVIDER_PATHS meta-data", e
+            )
+          }
+          sCache[authority] = strat!!
+        }
+      }
+      return strat
+    }
+
+    /**
+     * Parse and return [PathStrategy] for given authority as defined in
+     * [.META_DATA_FILE_PROVIDER_PATHS] `<meta-data>`.
+     *
+     * @see .getPathStrategy
+     */
+    @Throws(IOException::class, XmlPullParserException::class)
+    private fun parsePathStrategy(
+      context: Context,
+      authority: String
+    ): PathStrategy {
+      val strat = SimplePathStrategy(authority)
+
+      val info = context.packageManager
+          .resolveContentProvider(authority, PackageManager.GET_META_DATA)!!
+      val resourceParser = info.loadXmlMetaData(
+          context.packageManager, META_DATA_FILE_PROVIDER_PATHS
+      ) ?: throw IllegalArgumentException(
+          "Missing $META_DATA_FILE_PROVIDER_PATHS meta-data"
+      )
+
+      var type = 0
+      while (({ type = resourceParser.next(); type }()) != END_DOCUMENT) {
+        if (type == START_TAG) {
+          val tag = resourceParser.name
+
+          val name = resourceParser.getAttributeValue(null, ATTR_NAME)
+          val path = resourceParser.getAttributeValue(null, ATTR_PATH)
+
+          var target: File? = null
+          if (TAG_ROOT_PATH == tag) {
+            target = DEVICE_ROOT
+          } else if (TAG_FILES_PATH == tag) {
+            target = context.filesDir
+          } else if (TAG_CACHE_PATH == tag) {
+            target = context.cacheDir
+          } else if (TAG_EXTERNAL == tag) {
+            target = Environment.getExternalStorageDirectory()
+          } else if (TAG_EXTERNAL_FILES == tag) {
+            val externalFilesDirs = getExternalFilesDirs(context, null)
+            if (externalFilesDirs.isNotEmpty()) {
+              target = externalFilesDirs[0]
+            }
+          } else if (TAG_EXTERNAL_CACHE == tag) {
+            val externalCacheDirs = getExternalCacheDirs(context)
+            if (externalCacheDirs.isNotEmpty()) {
+              target = externalCacheDirs[0]
+            }
+          } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && TAG_EXTERNAL_MEDIA == tag) {
+            val externalMediaDirs = context.externalMediaDirs
+            if (externalMediaDirs.isNotEmpty()) {
+              target = externalMediaDirs[0]
+            }
+          }
+
+          if (target != null) {
+            strat.addRoot(name, buildPath(target, path))
+          }
+        }
+      }
+
+      return strat
+    }
+
+    private fun getExternalFilesDirs(
+      context: Context,
+      type: String?
+    ): Array<File> {
+      return if (Build.VERSION.SDK_INT >= 19) {
+        context.getExternalFilesDirs(type)
+      } else {
+        arrayOf<File>(context.getExternalFilesDir(type)!!)
+      }
+    }
+
+    private fun getExternalCacheDirs(context: Context): Array<File> {
+      return if (Build.VERSION.SDK_INT >= 19) {
+        context.externalCacheDirs
+      } else {
+        arrayOf(context.externalCacheDir!!)
+      }
+    }
+
+    /**
+     * Copied from ContentResolver.java
+     */
+    private fun modeToMode(mode: String): Int {
+      val modeBits: Int
+      if ("r" == mode) {
+        modeBits = ParcelFileDescriptor.MODE_READ_ONLY
+      } else if ("w" == mode || "wt" == mode) {
+        modeBits = (ParcelFileDescriptor.MODE_WRITE_ONLY
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_TRUNCATE)
+      } else if ("wa" == mode) {
+        modeBits = (ParcelFileDescriptor.MODE_WRITE_ONLY
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_APPEND)
+      } else if ("rw" == mode) {
+        modeBits = ParcelFileDescriptor.MODE_READ_WRITE or ParcelFileDescriptor.MODE_CREATE
+      } else if ("rwt" == mode) {
+        modeBits = (ParcelFileDescriptor.MODE_READ_WRITE
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_TRUNCATE)
+      } else {
+        throw IllegalArgumentException("Invalid mode: $mode")
+      }
+      return modeBits
+    }
+
+    private fun buildPath(
+      base: File,
+      vararg segments: String
+    ): File {
+      var cur = base
+      for (segment in segments) {
+        cur = File(cur, segment)
+      }
+      return cur
+    }
+
+    private fun copyOfStringArray(
+      original: Array<String?>,
+      newLength: Int
+    ): Array<String?> {
+      val result = arrayOfNulls<String>(newLength)
+      System.arraycopy(original, 0, result, 0, newLength)
+      return result
+    }
+
+    private fun copyOfAnyArray(
+      original: Array<Any?>,
+      newLength: Int
+    ): Array<Any?> {
+      val result = arrayOfNulls<Any>(newLength)
+      System.arraycopy(original, 0, result, 0, newLength)
+      return result
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt
deleted file mode 100644
index ab13f6ea..00000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import android.annotation.SuppressLint
-import android.content.Context
-import android.graphics.Canvas
-import android.graphics.Color
-import android.graphics.Paint
-import android.util.AttributeSet
-import android.view.View
-import com.squareup.leakcanary.core.R
-import leakcanary.internal.MoreDetailsView.Details.CLOSED
-import leakcanary.internal.MoreDetailsView.Details.OPENED
-
-internal class MoreDetailsView(
-  context: Context,
-  attrs: AttributeSet
-) : View(context, attrs) {
-
-  enum class Details {
-    OPENED,
-    CLOSED,
-    NONE
-  }
-
-  private val iconPaint: Paint
-
-  private var details = Details.NONE
-
-  init {
-    val resources = resources
-    iconPaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    val strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_stroke_width)
-        .toFloat()
-    iconPaint.strokeWidth = strokeSize
-
-    // This lint check doesn't work for libraries which have a common prefix.
-    @SuppressLint("CustomViewStyleable") //
-    val a = context.obtainStyledAttributes(attrs, R.styleable.leak_canary_MoreDetailsView)
-    val plusColor =
-      a.getColor(R.styleable.leak_canary_MoreDetailsView_leak_canary_plus_color, Color.BLACK)
-    a.recycle()
-
-    iconPaint.color = plusColor
-  }
-
-  override fun onDraw(canvas: Canvas) {
-    val width = width
-    val height = height
-    val halfHeight = height / 2
-    val halfWidth = width / 2
-
-    if (details == OPENED) {
-      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
-    } else if (details == CLOSED) {
-      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
-      canvas.drawLine(halfWidth.toFloat(), 0f, halfWidth.toFloat(), height.toFloat(), iconPaint)
-    }
-  }
-
-  fun setDetails(details: Details) {
-    if (details != this.details) {
-      this.details = details
-      invalidate()
-    }
-  }
-}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
index b033e32d..d9f59cde 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
@@ -2,7 +2,7 @@ package leakcanary.internal
 
 import com.squareup.leakcanary.core.R
 
-enum class NotificationType(val nameResId: Int, val importance: Int) {
+internal enum class NotificationType(val nameResId: Int, val importance: Int) {
   LEAKCANARY_LOW(
       R.string.leak_canary_notification_channel_low, IMPORTANCE_LOW
   ),
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
index 5d470a4d..2710a5bc 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
@@ -34,9 +34,7 @@ internal class RowElementLayout(
   private val moreMarginTop: Int
 
   private var connector: View? = null
-  private var moreButton: View? = null
   private var title: View? = null
-  private var details: View? = null
 
   init {
     val resources = resources
@@ -51,9 +49,7 @@ internal class RowElementLayout(
   override fun onFinishInflate() {
     super.onFinishInflate()
     connector = findViewById(R.id.leak_canary_row_connector)
-    moreButton = findViewById(R.id.leak_canary_row_more)
     title = findViewById(R.id.leak_canary_row_title)
-    details = findViewById(R.id.leak_canary_row_details)
   }
 
   override fun onMeasure(
@@ -66,18 +62,7 @@ internal class RowElementLayout(
     val titleHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
     title!!.measure(titleWidthSpec, titleHeightSpec)
 
-    val moreSizeSpec = View.MeasureSpec.makeMeasureSpec(moreSize, View.MeasureSpec.EXACTLY)
-    moreButton!!.measure(moreSizeSpec, moreSizeSpec)
-
     var totalHeight = titleMarginTop + title!!.measuredHeight
-
-    val detailsWidth = availableWidth - connectorWidth - 3 * rowMargins
-    val detailsWidthSpec = View.MeasureSpec.makeMeasureSpec(detailsWidth, View.MeasureSpec.AT_MOST)
-    val detailsHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
-    details!!.measure(detailsWidthSpec, detailsHeightSpec)
-    if (details!!.visibility != View.GONE) {
-      totalHeight += details!!.measuredHeight
-    }
     totalHeight = Math.max(totalHeight, minHeight)
 
     val connectorWidthSpec =
@@ -96,24 +81,11 @@ internal class RowElementLayout(
     r: Int,
     b: Int
   ) {
-    val width = measuredWidth
     val connectorRight = rowMargins + connector!!.measuredWidth
     connector!!.layout(rowMargins, 0, connectorRight, connector!!.measuredHeight)
 
-    moreButton!!.layout(
-        width - rowMargins - moreSize, moreMarginTop, width - rowMargins,
-        moreMarginTop + moreSize
-    )
-
     val titleLeft = connectorRight + rowMargins
     val titleBottom = titleMarginTop + title!!.measuredHeight
     title!!.layout(titleLeft, titleMarginTop, titleLeft + title!!.measuredWidth, titleBottom)
-
-    if (details!!.visibility != View.GONE) {
-      details!!.layout(
-          titleLeft, titleBottom, width - rowMargins,
-          titleBottom + details!!.measuredHeight
-      )
-    }
   }
 }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
similarity index 85%
rename from leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt
rename to leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
index 786cb3aa..19800a17 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
@@ -1,4 +1,4 @@
-package leakcanary
+package leakcanary.internal
 
 import java.io.ByteArrayInputStream
 import java.io.ByteArrayOutputStream
@@ -6,13 +6,13 @@ import java.io.ObjectInputStream
 import java.io.ObjectOutputStream
 import java.io.Serializable
 
-fun Serializable.toByteArray(): ByteArray {
+internal fun Serializable.toByteArray(): ByteArray {
   val outputStream = ByteArrayOutputStream()
   ObjectOutputStream(outputStream).writeObject(this)
   return outputStream.toByteArray()
 }
 
-object Serializables {
+internal object Serializables {
 
   inline fun <reified T> fromByteArray(byteArray: ByteArray): T? {
     val inputStream = ByteArrayInputStream(byteArray)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
index ca214b51..72dca8a3 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
@@ -2,7 +2,7 @@ package leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.InternalLeakCanary.noOpDelegate
 
 internal class VisibilityTracker(
   private val listener: (Boolean) -> Unit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index f7a63fc9..4f4d02ab 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -8,11 +8,10 @@ import leakcanary.CanaryLog
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
-import leakcanary.Serializables
+import leakcanary.internal.Serializables
 import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.LeakDirectoryProvider
-import leakcanary.leakingInstances
-import leakcanary.toByteArray
+import leakcanary.internal.toByteArray
 import org.intellij.lang.annotations.Language
 import java.io.File
 
@@ -40,7 +39,7 @@ internal object HeapAnalysisTable {
     values.put("object", heapAnalysis.toByteArray())
     when (heapAnalysis) {
       is HeapAnalysisSuccess -> {
-        values.put("retained_instance_count", heapAnalysis.leakingInstances.size)
+        values.put("retained_instance_count", heapAnalysis.allLeaks.size)
       }
       is HeapAnalysisFailure -> {
         val cause = heapAnalysis.exception.cause!!
@@ -51,12 +50,14 @@ internal object HeapAnalysisTable {
 
     return db.inTransaction {
       val heapAnalysisId = db.insertOrThrow("heap_analysis", null, values)
-      heapAnalysis.leakingInstances()
-          .forEach { leakingInstance ->
-            LeakingInstanceTable.insert(
-                db, heapAnalysisId, leakingInstance
-            )
-          }
+      if (heapAnalysis is HeapAnalysisSuccess) {
+        heapAnalysis.allLeaks
+            .forEach { leakingInstance ->
+              LeakingInstanceTable.insert(
+                  db, heapAnalysisId, leakingInstance
+              )
+            }
+      }
       heapAnalysisId
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index 0803bb72..a557df8a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -2,15 +2,14 @@ package leakcanary.internal.activity.db
 
 import android.content.ContentValues
 import android.database.sqlite.SQLiteDatabase
-import leakcanary.Exclusion
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.LeakTrace
 import leakcanary.LeakTraceElement
 import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakingInstance
-import leakcanary.Serializables
+import leakcanary.Leak
+import leakcanary.Leak.LibraryLeak
+import leakcanary.internal.Serializables
 import leakcanary.internal.utils.to
-import leakcanary.toByteArray
+import leakcanary.internal.toByteArray
 import org.intellij.lang.annotations.Language
 
 internal object LeakingInstanceTable {
@@ -24,7 +23,7 @@ internal object LeakingInstanceTable {
         group_hash TEXT,
         group_description TEXT,
         class_simple_name TEXT,
-        exclusion_status INTEGER,
+        is_library_leak INTEGER,
         object BLOB
         )"""
 
@@ -40,22 +39,22 @@ internal object LeakingInstanceTable {
   fun insert(
     db: SQLiteDatabase,
     heapAnalysisId: Long,
-    leakingInstance: LeakingInstance
+    leak: Leak
   ): Long {
     val values = ContentValues()
     values.put("heap_analysis_id", heapAnalysisId)
-    values.put("group_hash", leakingInstance.groupHash)
-    values.put("group_description", leakingInstance.createGroupDescription())
-    values.put("class_simple_name", leakingInstance.instanceClassSimpleName)
-    values.put("object", leakingInstance.toByteArray())
-    values.put("exclusion_status", leakingInstance.exclusionStatus?.ordinal ?: -1)
+    values.put("group_hash", leak.groupHash)
+    values.put("group_description", leak.createGroupDescription())
+    values.put("class_simple_name", leak.classSimpleName)
+    values.put("object", leak.toByteArray())
+    values.put("is_library_leak", if (leak is LibraryLeak) 1 else 0)
     return db.insertOrThrow("leaking_instance", null, values)
   }
 
   fun retrieve(
     db: SQLiteDatabase,
     id: Long
-  ): Pair<Long, LeakingInstance>? {
+  ): Pair<Long, Leak>? {
     return db.rawQuery(
         """
           SELECT
@@ -68,7 +67,7 @@ internal object LeakingInstanceTable {
         .use { cursor ->
           if (cursor.moveToNext()) {
             val heapAnalysisId = cursor.getLong(0)
-            val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(1))
+            val leakingInstance = Serializables.fromByteArray<Leak>(cursor.getBlob(1))
             if (leakingInstance == null) {
               null
             } else {
@@ -86,7 +85,7 @@ internal object LeakingInstanceTable {
     val leakCount: Int,
     val totalLeakCount: Int,
     val isNew: Boolean,
-    val exclusionStatus: Exclusion.Status?
+    val isLibraryLeak: Boolean
   )
 
   fun retrieveAllByHeapAnalysisId(
@@ -108,7 +107,7 @@ internal object LeakingInstanceTable {
           , MAX(created_at_time_millis) as created_at_time_millis
           , SUM(CASE WHEN heap_analysis_id=$heapAnalysisId THEN 1 ELSE 0 END) as leak_count
           , COUNT(*) as total_leak_count
-          , MIN(exclusion_status) as exclusion_status
+          , MIN(is_library_leak) as is_library_leak
           FROM leaking_instance l
           LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
           GROUP BY 1, 2
@@ -125,12 +124,10 @@ internal object LeakingInstanceTable {
             val leakCount = cursor.getInt(3)
             val totalLeakCount = cursor.getInt(4)
             val isNew = isLatestHeapAnalysis && leakCount == totalLeakCount
-            val exclusionStatusOrdinal = cursor.getInt(5)
-            val exclusionStatus =
-              if (exclusionStatusOrdinal == -1) null else Exclusion.Status.values()[exclusionStatusOrdinal]
+            val isLibraryLeak = cursor.getInt(5) == 1
             val group = HeapAnalysisGroupProjection(
                 hash, description, createdAtTimeMillis, leakCount, totalLeakCount, isNew,
-                exclusionStatus
+                isLibraryLeak
             )
             projectionsByHash[hash] = group
           }
@@ -198,14 +195,11 @@ internal object LeakingInstanceTable {
     )
         .use { cursor ->
           if (cursor.moveToNext()) {
-            val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(0))!!
+            val leakingInstance = Serializables.fromByteArray<Leak>(cursor.getBlob(0))!!
             val leakTrace = leakingInstance.leakTrace
 
-            val groupLeakTrace = if (leakingInstance.exclusionStatus == WONT_FIX_LEAK) {
-              val index = leakTrace.elements.indexOfFirst { element -> element.exclusion != null }
-              LeakTrace(
-                  elements = listOf(leakTrace.elements[index].copy(labels = emptyList()))
-              )
+            val groupLeakTrace = if (leakingInstance is LibraryLeak) {
+              LeakTrace(elements = emptyList())
             } else {
               val elements = mutableListOf<LeakTraceElement>()
               for (index in 0 until leakTrace.elements.size) {
@@ -215,7 +209,8 @@ internal object LeakingInstanceTable {
                   val reference = element.reference!!
                   if (reference.type == ARRAY_ENTRY) {
                     // No array index in groups
-                    element = element.copy(reference = reference.copy(name = "x"), labels = emptyList())
+                    element =
+                      element.copy(reference = reference.copy(name = "x"), labels = emptyList())
                   } else {
                     element = element.copy(labels = emptyList())
                   }
@@ -271,14 +266,14 @@ internal object LeakingInstanceTable {
     db.delete("leaking_instance", null, null)
   }
 
-  private fun LeakingInstance.createGroupDescription(): String {
-    return if (exclusionStatus == WONT_FIX_LEAK) {
-      leakTrace.firstElementExclusion.matching
+  private fun Leak.createGroupDescription(): String {
+    return if (this is LibraryLeak) {
+      "Library Leak: " + pattern.toString()
     } else {
       val leakCauses = leakTrace.leakCauses
       if (leakCauses.isEmpty()) {
         // Should rarely happen, don't expect to see 0 unknown and 100% leaking or 100% not leaking
-        instanceClassName
+        className
       } else {
         val element = leakCauses.first()
         val referenceName = element.reference!!.groupingName
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 7e713797..4b1abaaa 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -26,6 +26,6 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
 
   companion object {
     // Last updated for next after 2.0-alpha-3
-    private const val VERSION = 12
+    private const val VERSION = 13
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
index 7c2d567a..3fb28ebb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
@@ -46,7 +46,7 @@ internal class GroupScreen(private val groupHash: String) : Screen() {
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val adapter = DisplayLeakAdapter(context, leakTrace, projections)
+    val adapter = DisplayLeakAdapter(context, leakTrace, groupDescription, projections)
     listView.adapter = adapter
 
     listView.setOnItemClickListener { _, _, position, _ ->
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
index 6eb7ab03..7225747a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
@@ -84,7 +84,7 @@ internal class HeapAnalysisListScreen : Screen() {
         )
 
         val title = projection.exceptionSummary ?: resources.getQuantityString(
-            R.plurals.leak_canary_heap_analysis_list_retained_instances,
+            R.plurals.leak_canary_heap_analysis_list_retained_objects,
             projection.retainedInstanceCount, projection.retainedInstanceCount
         )
         titleView.text = "$index. $title"
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
index c53b6511..058a4412 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -6,8 +6,6 @@ import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
 import com.squareup.leakcanary.core.R
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakingInstanceTable
@@ -52,7 +50,7 @@ internal class HeapAnalysisSuccessScreen(
   ) {
     activity.title = resources.getString(
         R.string.leak_canary_heap_analysis_success_screen_title,
-        heapAnalysis.leakingInstances.size
+        heapAnalysis.allLeaks.size
     )
 
     onCreateOptionsMenu { menu ->
@@ -87,7 +85,7 @@ internal class HeapAnalysisSuccessScreen(
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val retainedInstances = heapAnalysis.leakingInstances
+    val retainedInstances = heapAnalysis.allLeaks
 
     retainedInstances.forEach { retainedInstance ->
       if (leakGroupByHash[retainedInstance.groupHash] == null) {
@@ -102,19 +100,9 @@ internal class HeapAnalysisSuccessScreen(
     val leakGroups = leakGroupByHash.values.toList()
 
     rowList.addAll(leakGroups.map { projection ->
-      val description = when (projection.exclusionStatus) {
-        WONT_FIX_LEAK -> {
-          "[Won't Fix] ${projection.description}"
-        }
-        WEAKLY_REACHABLE -> {
-          "[Weakly Reachable] ${projection.description}"
-        }
-        else -> {
-          projection.description
-        }
-      }
+      val description = projection.description
 
-      val titleText = if (projection.isNew && projection.exclusionStatus == null) {
+      val titleText = if (projection.isNew && !projection.isLibraryLeak) {
         resources.getString(
             R.string.leak_canary_heap_analysis_success_screen_row_title_new, projection.leakCount,
             description
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index ddd3fbba..dfafa8f4 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -35,7 +35,7 @@ import leakcanary.internal.navigation.getColorCompat
 import java.io.File
 import kotlin.reflect.KClass
 
-object HeapDumpRenderer {
+internal object HeapDumpRenderer {
 
   private class HasDensity(resources: Resources) {
     val density = resources.displayMetrics.density
@@ -100,7 +100,8 @@ object HeapDumpRenderer {
     val stringColor = context.getColorCompat(R.color.leak_canary_heap_instance_string)
 
     val parser = HprofPushRecordsParser()
-    val reader = parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
+    var lastPosition = 0L
+    parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
       override fun recordTypes(): Set<KClass<out Record>> = setOf(Record::class)
 
       val hprofStringCache = mutableMapOf<Long, String>()
@@ -113,6 +114,7 @@ object HeapDumpRenderer {
         position: Long,
         record: Record
       ) {
+        lastPosition = position
         when (record) {
           is StringRecord -> {
             hprofStringCache[record.id] = record.string
@@ -158,9 +160,8 @@ object HeapDumpRenderer {
           }
         }
       }
-    }))
-    val heapLength = reader.position
-    reader.close()
+    })).close()
+    val heapLength = lastPosition
 
     val width = sourceWidth
     var height: Int
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
index 78addf1f..ef8fdb22 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -26,14 +26,6 @@ import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
 import leakcanary.HprofGraph
-import leakcanary.PrimitiveType.BOOLEAN
-import leakcanary.PrimitiveType.BYTE
-import leakcanary.PrimitiveType.CHAR
-import leakcanary.PrimitiveType.DOUBLE
-import leakcanary.PrimitiveType.FLOAT
-import leakcanary.PrimitiveType.INT
-import leakcanary.PrimitiveType.LONG
-import leakcanary.PrimitiveType.SHORT
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
@@ -93,7 +85,7 @@ internal class HprofExplorerScreen(
                 .setPositiveButton(android.R.string.ok) { _, _ ->
                   executeOnIo {
                     val partialClassName = input.text.toString()
-                    val matchingClasses = graph.classSequence()
+                    val matchingClasses = graph.classes
                         .filter { partialClassName in it.name }
                         .toList()
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
index 90d3f2f2..dd12dedb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -6,7 +6,8 @@ import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import com.squareup.leakcanary.core.R
-import leakcanary.LeakingInstance
+import leakcanary.Leak
+import leakcanary.Leak.LibraryLeak
 import leakcanary.internal.DisplayLeakAdapter
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.executeOnDb
@@ -30,7 +31,7 @@ internal class LeakingInstanceScreen private constructor(
   sealed class InstanceOrId : Serializable {
     class Instance(
       val heapAnalysisId: Long,
-      val instance: LeakingInstance
+      val instance: Leak
     ) : InstanceOrId()
 
     class Id(val id: Long) : InstanceOrId()
@@ -62,23 +63,22 @@ internal class LeakingInstanceScreen private constructor(
 
   private fun View.onInstanceRetrieved(
     heapAnalysisId: Long,
-    leakingInstance: LeakingInstance
+    leak: Leak
   ) {
-    val classSimpleName = leakingInstance.instanceClassSimpleName
+    val classSimpleName = leak.classSimpleName
     activity.title =
       resources.getString(R.string.leak_canary_class_has_leaked, classSimpleName)
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val adapter = DisplayLeakAdapter(context, leakingInstance.leakTrace)
+    val groupDescription = if (leak is LibraryLeak) "Library Leak: " +leak.pattern.toString() else ""
+    val adapter = DisplayLeakAdapter(context, leak.leakTrace, groupDescription)
     listView.adapter = adapter
 
     listView.setOnItemClickListener { _, _, position, _ ->
       if (adapter.isLearnMoreRow(position)) {
         val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(LEARN_MORE_URL))
         activity.startActivity(browserIntent)
-      } else {
-        adapter.toggleRow(position)
       }
     }
 
@@ -91,13 +91,13 @@ internal class LeakingInstanceScreen private constructor(
       menu.add(R.string.leak_canary_share_leak)
           .setOnMenuItemClickListener {
             // TODO Add version information
-            share(leakingInstance.toString())
+            share(leak.toString())
             true
           }
       menu.add(R.string.leak_canary_stackoverflow_share)
           .setOnMenuItemClickListener {
             // TODO Add version information
-            shareToStackOverflow(leakingInstance.toString())
+            shareToStackOverflow(leak.toString())
             true
           }
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
index 2c697900..43ce0128 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
@@ -5,7 +5,7 @@ import android.view.ViewGroup
 import android.widget.BaseAdapter
 import leakcanary.internal.navigation.inflate
 
-class SimpleListAdapter<T>(
+internal class SimpleListAdapter<T>(
   private val rowResId: Int,
   private val items: List<T>,
   private val bindView: SimpleListAdapter<T>.(View, Int) -> Unit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
index 6a3164d3..15dfaecb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
@@ -1,3 +1,3 @@
 package leakcanary.internal.utils
 
-infix fun <A, B, C> Pair<A, B>.to(that: C): Triple<A, B, C> = Triple(first, second, that)
+internal infix fun <A, B, C> Pair<A, B>.to(that: C): Triple<A, B, C> = Triple(first, second, that)
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
index 7a19621e..194e6f6a 100644
--- a/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
@@ -16,7 +16,6 @@
   -->
 <leakcanary.internal.RowElementLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:lib="http://schemas.android.com/apk/res-auto"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:clipChildren="false"
@@ -28,24 +27,9 @@
       android:layout_height="wrap_content"
       />
 
-  <leakcanary.internal.MoreDetailsView
-      android:id="@+id/leak_canary_row_more"
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      lib:leak_canary_plus_color="@color/leak_canary_class_name"
-      />
-
   <TextView
       android:id="@+id/leak_canary_row_title"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       />
-
-  <TextView
-      android:id="@+id/leak_canary_row_details"
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      android:visibility="gone"
-      />
-
 </leakcanary.internal.RowElementLayout>
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
index 0c625e36..ed47a273 100644
--- a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -48,7 +48,7 @@
   <string name="leak_canary_options_menu_permission_toast">Bitte erlaube zunächst die Speicher-Berechtigung, siehe Benachrichtigung…</string>
   <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendere HQ Bitmap, das könnte eine Weile dauern…</string>
   <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Rendere HQ Bitmap, das könnte eine Weile dauern…</string>
-  <plurals name="leak_canary_heap_analysis_list_retained_instances">
+  <plurals name="leak_canary_heap_analysis_list_retained_objects">
     <item quantity="one">%d erhaltene Instanz</item>
     <item quantity="other">%d erhaltene Instanzen</item>
   </plurals>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
index d352338b..c1074bd4 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
@@ -19,6 +19,6 @@
   <item type="id" name="leak_canary_notification_analysis_result" />
   <item type="id" name="leak_canary_notification_dumping_heap" />
   <item type="id" name="leak_canary_notification_analyzing_heap" />
-  <item type="id" name="leak_canary_notification_retained_instances" />
-  <item type="id" name="leak_canary_notification_no_retained_instance_on_tap" />
+  <item type="id" name="leak_canary_notification_retained_objects" />
+  <item type="id" name="leak_canary_notification_no_retained_object_on_tap" />
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index aa915031..523de211 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -23,7 +23,7 @@
   We welcome contributions from the community, please do not hesitate to
   <a href="https://github.com/square/leakcanary/issues">report an issue</a> or open a pull request!<br>]]></string>
   <string name="leak_canary_analysis_failed">Leak analysis failed</string>
-  <string name="leak_canary_analysis_success_notification">Analysis done: %1$d leaks (%2$d new, %3$d known, %4$d won\'t fix)</string>
+  <string name="leak_canary_analysis_success_notification">Analysis done: %1$d leaks (%2$d new, %3$d known, %4$d library)</string>
   <string name="leak_canary_class_has_leaked">%1$s Leaked</string>
   <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
   <string name="leak_canary_explorer_search_classes">Search classes</string>
@@ -34,12 +34,12 @@
   <string name="leak_canary_notification_dumping">Dumping Heap</string>
   <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
   <string name="leak_canary_notification_message">Click for more details</string>
-  <string name="leak_canary_notification_no_retained_instance_title">All retained instances were garbage collected</string>
-  <string name="leak_canary_notification_no_retained_instance_content">Tap to dismiss</string>
+  <string name="leak_canary_notification_no_retained_object_title">All retained objects were garbage collected</string>
+  <string name="leak_canary_notification_no_retained_object_content">Tap to dismiss</string>
   <string name="leak_canary_notification_retained_debugger_attached">Waiting for debugger to detach</string>
   <string name="leak_canary_notification_retained_dump_failed">Failed to dump heap</string>
-  <string name="leak_canary_notification_retained_title">%d retained instances, tap to dump heap</string>
-  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained instances</string>
+  <string name="leak_canary_notification_retained_title">%d retained objects, tap to dump heap</string>
+  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained objects</string>
   <string name="leak_canary_share_leak">Share Info</string>
   <string name="leak_canary_share_heap_dump">Share Heap Dump</string>
   <string name="leak_canary_share_with">Share with…</string>
@@ -61,15 +61,15 @@
   <string name="leak_canary_options_menu_permission_toast">Please grant the External Storage Permission first, see notification…</string>
   <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendering HQ Bitmap, this may take a while…</string>
   <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Rendering HQ Bitmap, this may take a while…</string>
-  <plurals name="leak_canary_heap_analysis_list_retained_instances">
-    <item quantity="one">%d Retained Instance</item>
-    <item quantity="other">%d Retained Instances</item>
+  <plurals name="leak_canary_heap_analysis_list_retained_objects">
+    <item quantity="one">%d Retained Objects</item>
+    <item quantity="other">%d Retained Objects</item>
   </plurals>
   <string name="leak_canary_share_heap_dump_bitmap_screen_title">Share Heap Dump Bitmap</string>
   <string name="leak_canary_heap_dump_screen_title">Heap Dump %s</string>
   <string name="leak_canary_analysis_deleted_title">Analysis Deleted</string>
   <string name="leak_canary_go_to_heap_analysis">Go to Heap Analysis</string>
-  <string name="leak_canary_heap_analysis_success_screen_title">Heap Analysis (%d Retained Instances)</string>
+  <string name="leak_canary_heap_analysis_success_screen_title">Heap Analysis (%d Retained Objects)</string>
   <string name="leak_canary_heap_analysis_success_screen_row_title">(%1$d / %2$d Total) %3$s</string>
   <string name="leak_canary_heap_analysis_success_screen_row_title_new">[NEW] (%1$d) %2$s</string>
   <string name="leak_canary_heap_analysis_success_screen_row_time_format">Latest: %s</string>
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
index f8513a60..f99e738e 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -9,11 +9,12 @@ import android.view.View
 import androidx.test.core.app.ApplicationProvider.getApplicationContext
 import androidx.test.rule.ActivityTestRule
 import leakcanary.TestUtils.assertLeak
-import leakcanary.internal.InternalHelper.noOpDelegate
 import org.junit.After
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
 import java.util.concurrent.CountDownLatch
 
 class FragmentLeakTest {
@@ -24,13 +25,13 @@ class FragmentLeakTest {
   )
 
   @Before fun setUp() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    LeakSentry.objectWatcher
+        .clearWatchedObjects()
   }
 
   @After fun tearDown() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    LeakSentry.objectWatcher
+        .clearWatchedObjects()
   }
 
   @Test
@@ -109,5 +110,15 @@ class FragmentLeakTest {
   companion object {
     private const val TOUCH_MODE = true
     private const val LAUNCH_ACTIVITY = true
+
+    inline fun <reified T : Any> noOpDelegate(): T {
+      val javaClass = T::class.java
+      val noOpHandler = InvocationHandler { _, _, _ ->
+        // no op
+      }
+      return Proxy.newProxyInstance(
+          javaClass.classLoader, arrayOf(javaClass), noOpHandler
+      ) as T
+    }
   }
 }
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
index 3f15083f..b168ee2a 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -13,18 +13,18 @@ import java.util.Date
 class InstrumentationLeakDetectorTest {
 
   @Before fun setUp() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    LeakSentry.objectWatcher
+        .clearWatchedObjects()
   }
 
   @After fun tearDown() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    LeakSentry.objectWatcher
+        .clearWatchedObjects()
   }
 
   @Test fun detectsLeak() {
     leaking = Date()
-    val refWatcher = LeakSentry.refWatcher
+    val refWatcher = LeakSentry.objectWatcher
     refWatcher.watch(leaking)
     assertLeak(Date::class.java)
   }
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
index 639e4d8d..f295e947 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
@@ -13,7 +13,13 @@ object TestUtils {
       is AnalysisPerformed -> result.heapAnalysis
     }
 
-    val applicationLeaks = heapAnalysis.applicationLeaks()
+    if (heapAnalysis !is HeapAnalysisSuccess) {
+      throw AssertionError(
+          "Expected analysis success not $heapAnalysis"
+      )
+    }
+
+    val applicationLeaks = heapAnalysis.applicationLeaks
     if (applicationLeaks.size != 1) {
       throw AssertionError(
           "Expected exactly one leak in $heapAnalysis"
@@ -22,9 +28,9 @@ object TestUtils {
 
     val leakInstance = applicationLeaks.first()
 
-    if (leakInstance.instanceClassName != expectedLeakClass.name) {
+    if (leakInstance.className != expectedLeakClass.name) {
       throw AssertionError(
-          "Expected a leak of $expectedLeakClass, not ${leakInstance.instanceClassName} in $heapAnalysis"
+          "Expected a leak of $expectedLeakClass, not ${leakInstance.className} in $heapAnalysis"
       )
     }
   }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
index 346cd239..2d49a655 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
@@ -4,8 +4,7 @@ import org.junit.runner.Description
 import org.junit.runner.notification.RunListener
 
 /**
- *
- * A JUnit [RunListener] subclassing [FailTestOnLeakRunListener] for detecting memory
+ * A JUnit [RunListener] extending [FailTestOnLeakRunListener] to detecting memory
  * leaks in Android instrumentation tests only when the [FailTestOnLeak] annotation
  * is used.
  *
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
index 1721e18c..024e3aa0 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
@@ -1,7 +1,6 @@
 package leakcanary
 
 /**
- *
  * An [Annotation] class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener]
  * for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener], the tests
  * should be annotated with this class in order for the listener to detect memory leaks.
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
index cd470232..b8d14966 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -17,6 +17,7 @@ package leakcanary
 
 import android.app.Instrumentation
 import android.os.Bundle
+import android.util.Log
 import androidx.test.internal.runner.listener.InstrumentationResultPrinter
 import androidx.test.internal.runner.listener.InstrumentationResultPrinter.REPORT_VALUE_RESULT_FAILURE
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
@@ -28,13 +29,12 @@ import org.junit.runner.notification.RunListener
 
 /**
  *
- * A JUnit [RunListener] for detecting memory leaks in Android instrumentation tests. It
- * waits for the end of a test, and if the test succeeds then it will look for leaking
- * references, trigger a heap dump if needed and perform an analysis.
+ * A JUnit [RunListener] that uses [InstrumentationLeakDetector] to detect memory leaks in Android
+ * instrumentation tests. It waits for the end of a test, and if the test succeeds then it will
+ * look for retained objects, trigger a heap dump if needed and perform an analysis.
  *
- *  [FailTestOnLeakRunListener] can be subclassed to override
- * [skipLeakDetectionReason], [reportLeaks]
- * or [buildLeakDetectedMessage]
+ *  [FailTestOnLeakRunListener] can be subclassed to override [skipLeakDetectionReason] and
+ *  [onAnalysisPerformed]
  *
  * @see InstrumentationLeakDetector
  */
@@ -60,7 +60,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   /**
    * Can be overridden to skip leak detection based on the description provided when a test
-   * is started. Returns null to continue leak detection, or a string describing the reason for
+   * is started. Return null to continue leak detection, or a string describing the reason for
    * skipping otherwise.
    */
   protected open fun skipLeakDetectionReason(description: Description): String? {
@@ -81,7 +81,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   override fun testFinished(description: Description) {
     detectLeaks()
-    LeakSentry.refWatcher.clearWatchedInstances()
+    LeakSentry.objectWatcher.clearWatchedObjects()
   }
 
   override fun testRunStarted(description: Description) {
@@ -101,46 +101,35 @@ open class FailTestOnLeakRunListener : RunListener() {
     val result = leakDetector.detectLeaks()
 
     if (result is AnalysisPerformed) {
-      val applicationLeaks = result.heapAnalysis.applicationLeaks()
-      if (applicationLeaks.isNotEmpty()) {
-        reportLeaks(result.heapAnalysis, applicationLeaks)
-      }
+      onAnalysisPerformed(heapAnalysis = result.heapAnalysis)
     }
   }
 
-  /** Can be overridden to report leaks in a different way or do additional reporting.  */
-  protected open fun reportLeaks(
-    heapAnalysis: HeapAnalysis,
-    applicationLeaks: List<LeakingInstance>
-  ) {
-    val message = buildLeakDetectedMessage(heapAnalysis, applicationLeaks)
-
-    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message)
-    getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle)
-  }
-
-  /** Can be overridden to customize the failure string message.  */
-  protected open fun buildLeakDetectedMessage(
-    heapAnalysis: HeapAnalysis,
-    applicationLeaks: List<LeakingInstance>
-  ): String {
-    val failureMessage = StringBuilder()
-    failureMessage.append(
-        "Test failed because memory leaks were detected, see leak traces below.\n"
-    )
-    failureMessage.append(SEPARATOR)
-
-    applicationLeaks.forEach { applicationLeak ->
-      // TODO Improve rendering
-      failureMessage.append(applicationLeak.toString())
-      failureMessage.append("\n ")
-      failureMessage.append(SEPARATOR)
+  /**
+   * Called when a heap analysis has been performed and a result is available.
+   *
+   * The default implementation call [failTest] if the [heapAnalysis] failed or if
+   * [HeapAnalysisSuccess.applicationLeaks] is not empty.
+   */
+  protected open fun onAnalysisPerformed(heapAnalysis: HeapAnalysis) {
+    when (heapAnalysis) {
+      is HeapAnalysisFailure -> {
+        failTest(Log.getStackTraceString(heapAnalysis.exception))
+      }
+      is HeapAnalysisSuccess -> {
+        val applicationLeaks = heapAnalysis.applicationLeaks
+        if (applicationLeaks.isNotEmpty()) {
+          failTest("Test failed because application memory leaks were detected:\n$heapAnalysis")
+        }
+      }
     }
-
-    return failureMessage.toString()
   }
 
-  companion object {
-    private const val SEPARATOR = "######################################\n"
+  /**
+   * Reports that the test has failed, with the provided [message].
+   */
+  protected fun failTest(message: String) {
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message)
+    getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle)
   }
 }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 09b4fbb4..276ac33f 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -25,40 +25,20 @@ import org.junit.runner.notification.RunListener
 import java.io.File
 
 /**
- * TODO Update this doc to match LeakCanary 2.0
- *
  * [InstrumentationLeakDetector] can be used to detect memory leaks in instrumentation tests.
  *
  * To use it, you need to:
  *
- *  * Install a custom RefWatcher that will not trigger heapdumps while the tests run.
- *  * Add an instrumentation test listener (a [RunListener]) that will invoke
- * [detectLeaks]
- *
- * ### Installing the instrumentation RefWatcher
- *
- * For [detectLeaks] to work correctly, the [RefWatcher] must keep track of
- * references but not trigger any heap dump until this [detectLeaks] runs, otherwise an
- * analysis in progress might prevent this listener from performing its own analysis.
- *
- * Create and install the [RefWatcher] instance using
- * [instrumentationRefWatcher] instead of
- * [LeakCanary.install] or [LeakCanary.refWatcher].
- *
- * ```
- * public class InstrumentationExampleApplication extends ExampleApplication {
- *  @Override protected void setupLeakCanary() {
- *    InstrumentationLeakDetector.instrumentationRefWatcher(this)
- *      .buildAndInstall();
- *  }
- * }
- * ```
+ *  - Call [updateConfig] so that [LeakSentry] will watch objects and [LeakCanary] will not dump
+ *  the heap on retained objects
+ *  - Add an instrumentation test listener (e.g. [FailTestOnLeakRunListener]) that will invoke
+ * [detectLeaks].
  *
  * ### Add an instrumentation test listener
  *
- * LeakCanary provides [FailTestOnLeakRunListener], but you should feel free to implement
- * your own [RunListener] and call [.detectLeaks] directly if you need a more custom
- * behavior (for instance running it only once per test suite, or reporting to a backend).
+ * LeakCanary provides [FailTestOnLeakRunListener], but you can also implement
+ * your own [RunListener] and call [detectLeaks] directly if you need a more custom
+ * behavior (for instance running it only once per test suite).
  *
  * All you need to do is add the following to the defaultConfig of your build.gradle:
  *
@@ -80,46 +60,52 @@ import java.io.File
  * ```
  *
  * ### Rationale
- * Instead of using the [FailTestOnLeakRunListener], one could simply enable LeakCanary in
+ * Instead of using the [InstrumentationLeakDetector], one could simply enable LeakCanary in
  * instrumentation tests.
  *
  * This approach would have two disadvantages:
  *
- *  * Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+ *  - Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
  * the test and introduce flakiness
- *  * The leak analysis is asynchronous by default, and happens in a separate process. This means
- * the tests could finish and the process die before the analysis is finished.
+ *  - The leak analysis is asynchronous by default. This means the tests could finish and the
+ *  process die before the analysis is finished.
  *
- * The approach taken here is to collect all references to watch as you run the test, but not
+ * The approach taken here is to collect all objects to watch as you run the test, but not
  * do any heap dump during the test. Then, at the end, if any of the watched objects is still in
  * memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
- * no matter the number of objects leaking.
+ * no matter the number of objects retained.
  */
 class InstrumentationLeakDetector {
 
+  /**
+   * The result of calling [detectLeaks], which is either [NoAnalysis] or [AnalysisPerformed].
+   */
   sealed class Result {
     object NoAnalysis : Result()
     class AnalysisPerformed(val heapAnalysis: HeapAnalysis) : Result()
   }
 
+  /**
+   * Looks for retained objects, triggers a heap dump if needed and performs an analysis.
+   */
   fun detectLeaks(): Result {
     val leakDetectionTime = SystemClock.uptimeMillis()
     val watchDurationMillis = LeakSentry.config.watchDurationMillis
     val instrumentation = getInstrumentation()
     val context = instrumentation.targetContext
-    val refWatcher = LeakSentry.refWatcher
+    val refWatcher = LeakSentry.objectWatcher
 
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
     instrumentation.waitForIdleSync()
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
     runGc()
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
@@ -127,7 +113,7 @@ class InstrumentationLeakDetector {
     // Android simply has way too many delayed posts that aren't canceled when views are detached.
     SystemClock.sleep(2000)
 
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
@@ -143,7 +129,7 @@ class InstrumentationLeakDetector {
 
     runGc()
 
-    if (!refWatcher.hasRetainedInstances) {
+    if (!refWatcher.hasRetainedObjects) {
       return NoAnalysis
     }
 
@@ -168,13 +154,13 @@ class InstrumentationLeakDetector {
       )
     }
 
-    refWatcher.removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis)
+    refWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
 
     val listener = AnalyzerProgressListener.NONE
 
     val heapAnalyzer = HeapAnalyzer(listener)
     val heapAnalysis = heapAnalyzer.checkForLeaks(
-        heapDumpFile, AndroidKnownReference.mapToExclusions(config.knownReferences),
+        heapDumpFile, config.referenceMatchers,
         config.computeRetainedHeapSize,
         config.objectInspectors,
         if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
@@ -190,12 +176,14 @@ class InstrumentationLeakDetector {
   companion object {
 
     /**
-     * Configures LeakCanary to not dump the heap so that instrumentation tests run smoothly,
-     * and we can look for leaks at the end of a test. This is automatically called by
-     * [FailTestOnLeakRunListener] when the tests start running.
+     * Configures [LeakSentry] to watch objects and [LeakCanary] to not dump the heap on retained
+     * objects so that instrumentation tests run smoothly, and we can look for leaks at the end of
+     * a test. This is automatically called by [FailTestOnLeakRunListener] when the tests start
+     * running.
      */
     fun updateConfig() {
       LeakSentry.config = LeakSentry.config.copy(enabled = true)
+      LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
     }
   }
 }
diff --git a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
index 39186f60..45610207 100644
--- a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
+++ b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
@@ -8,6 +8,14 @@ import android.content.pm.PackageInfo
 import android.content.pm.PackageManager
 import android.content.pm.ServiceInfo
 
+/**
+ * Used to determine whether the current process is the LeakCanary analyzer process. By depending
+ * on the `leakcanary-android-process` artifact instead of the `leakcanary-android`, LeakCanary
+ * will automatically run its analysis in a separate process.
+ *
+ * As such, you'll need to be careful to do any custom configuration of LeakCanary in both the main
+ * process and the analyzer process.
+ */
 object LeakCanaryProcess {
 
   @Volatile private var isInAnalyzerProcess: Boolean? = null
diff --git a/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt b/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
index ddfea9c9..59b328d4 100644
--- a/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
+++ b/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
@@ -19,17 +19,14 @@ class CLILogger : Logger {
   }
 
   override fun d(
-    throwable: Throwable?,
+    throwable: Throwable,
     message: String,
     vararg args: Any?
   ) {
     d(String.format(message, *args) + '\n' + getStackTraceString(throwable))
   }
 
-  private fun getStackTraceString(throwable: Throwable?): String {
-    if (throwable == null) {
-      return ""
-    }
+  private fun getStackTraceString(throwable: Throwable): String {
     val stringWriter = StringWriter()
     val printWriter = PrintWriter(stringWriter, false)
     throwable.printStackTrace(printWriter)
diff --git a/leakcanary-cli/src/main/java/leakcanary/Main.kt b/leakcanary-cli/src/main/java/leakcanary/Main.kt
index 4d91efb0..9d5569d2 100644
--- a/leakcanary-cli/src/main/java/leakcanary/Main.kt
+++ b/leakcanary-cli/src/main/java/leakcanary/Main.kt
@@ -15,7 +15,8 @@ fun main(args: Array<String>) {
       analyze(heapDumpFile)
     }
     args.size == 2 && args[0] == "dump-process" -> dumpHeap(args[1])
-    args.size == 2 && args[0] == "analyze-file" -> analyze(File(args[1]))
+    args.size == 2 && args[0] == "analyze-hprof" -> analyze(File(args[1]))
+    args.size == 2 && args[0] == "strip-hprof" -> stripHprof(File(args[1]))
     else -> printHelp()
   }
 }
@@ -23,11 +24,12 @@ fun main(args: Array<String>) {
 fun printHelp() {
   val workingDirectory = File(System.getProperty("user.dir"))
 
-  CanaryLog.d("""
+  CanaryLog.d(
+      """
     LeakCanary CLI
     Running in directory $workingDirectory
 
-    Commands: [analyze-process, dump-process, analyze-file]
+    Commands: [analyze-process, dump-process, analyze-hprof, strip-hprof]
 
     analyze-process: Dumps the heap for the provided process name, pulls the hprof file and analyzes it.
       USAGE: analyze-process PROCESS_PACKAGE_NAME
@@ -35,9 +37,13 @@ fun printHelp() {
     dump-process: Dumps the heap for the provided process name and pulls the hprof file.
       USAGE: dump-process PROCESS_PACKAGE_NAME
 
-    analyze-file: Analyzes the provided hprof file.
-      USAGE: analyze-file HPROF_FILE_PATH
-  """.trimIndent())
+    analyze-hprof: Analyzes the provided hprof file.
+      USAGE: analyze-hprof HPROF_FILE_PATH
+
+    strip-hprof: Removes all primitive arrays from the provided hprof file and generates a new "-stripped" hprof file.
+      USAGE: strip-hprof HPROF_FILE_PATH
+  """.trimIndent()
+  )
 }
 
 private fun dumpHeap(packageName: String): File {
@@ -127,9 +133,17 @@ private fun analyze(heapDumpFile: File) {
   val heapAnalyzer = HeapAnalyzer(listener)
   CanaryLog.d("Analyzing heap dump $heapDumpFile")
   val heapAnalysis = heapAnalyzer.checkForLeaks(
-      heapDumpFile, AndroidKnownReference.mapToExclusions(AndroidKnownReference.appDefaults), true,
-      AndroidObjectInspectors.defaultInspectors()
+      heapDumpFile, AndroidReferenceMatchers.appDefaults, true,
+      AndroidObjectInspectors.appDefaults
   )
 
   CanaryLog.d(heapAnalysis.toString())
 }
+
+private fun stripHprof(heapDumpFile: File) {
+  CanaryLog.d("Stripping primitive arrays in heap dump $heapDumpFile")
+  val stripper = HprofPrimitiveArrayStripper()
+  val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
+  CanaryLog.d("Stripped primitive arrays to $outputFile")
+}
+
diff --git a/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
index d12efa0c..a7bae01a 100644
--- a/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
+++ b/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -19,13 +19,13 @@ import android.app.Activity
 import androidx.fragment.app.Fragment
 import androidx.fragment.app.FragmentActivity
 import androidx.fragment.app.FragmentManager
-import leakcanary.RefWatcher
 import leakcanary.LeakSentry.Config
+import leakcanary.ObjectWatcher
 
 internal class AndroidXFragmentDestroyWatcher(
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
-) : FragmentDestroyWatcher {
+) : (Activity) -> Unit {
 
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
 
@@ -35,7 +35,7 @@ internal class AndroidXFragmentDestroyWatcher(
     ) {
       val view = fragment.view
       if (view != null && configProvider().watchFragmentViews) {
-        refWatcher.watch(view)
+        objectWatcher.watch(view)
       }
     }
 
@@ -44,12 +44,12 @@ internal class AndroidXFragmentDestroyWatcher(
       fragment: Fragment
     ) {
       if (configProvider().watchFragments) {
-        refWatcher.watch(fragment)
+        objectWatcher.watch(fragment)
       }
     }
   }
 
-  override fun watchFragments(activity: Activity) {
+  override fun invoke(activity: Activity) {
     if (activity is FragmentActivity) {
       val supportFragmentManager = activity.supportFragmentManager
       supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
diff --git a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt b/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
index fa7b3b9f..01f2e243 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
@@ -1,9 +1,18 @@
 package leakcanary
 
+/**
+ * A GcRoot as identified by [Record.HeapDumpRecord.GcRootRecord] in the heap dump.
+ */
 sealed class GcRoot {
 
+  /**
+   * The object id of the object that this gc root references.
+   */
   abstract val id: Long
 
+  /**
+   * An unknown gc root.
+   */
   class Unknown(override val id: Long) : GcRoot()
 
   /**
@@ -27,7 +36,7 @@ sealed class GcRoot {
   ) : GcRoot()
 
   /**
-   * Java local variable
+   * A java local variable
    */
   class JavaFrame(
     override val id: Long,
@@ -51,7 +60,7 @@ sealed class GcRoot {
   ) : GcRoot()
 
   /**
-   * System class
+   * A system class
    */
   class StickyClass(override val id: Long) : GcRoot()
 
@@ -67,6 +76,8 @@ sealed class GcRoot {
   class MonitorUsed(override val id: Long) : GcRoot()
 
   /**
+   * A thread.
+   *
    * Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
    */
   class ThreadObject(
@@ -75,16 +86,28 @@ sealed class GcRoot {
     val stackTraceSerialNumber: Int
   ) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class ReferenceCleanup(override val id: Long) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class VmInternal(override val id: Long) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class JniMonitor(
     override val id: Long,
     val stackTraceSerialNumber: Int,
     val stackDepth: Int
   ) : GcRoot()
 
+  /**
+   * An interned string, see [java.lang.String.intern].
+   */
   class InternedString(override val id: Long) : GcRoot()
 
   /**
@@ -92,6 +115,9 @@ sealed class GcRoot {
    */
   class Finalizing(override val id: Long) : GcRoot()
 
+  /**
+   * An object held by a connected debugger
+   */
   class Debugger(override val id: Long) : GcRoot()
 
   /**
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt b/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
index 2df3000e..3fed69d6 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
@@ -1,5 +1,9 @@
 package leakcanary
 
+/**
+ * In memory store that can be used to store objects in a given [HprofGraph] instance.
+ * This is a simple [MutableMap] of [String] to [Any], but with unsafe generics access.
+ */
 class GraphContext {
   private val store = mutableMapOf<String, Any>()
   operator fun <T> get(key: String): T? {
@@ -7,6 +11,22 @@ class GraphContext {
     return store[key] as T?
   }
 
+  /**
+   * @see MutableMap.getOrPut
+   */
+  fun <T> getOrPut(
+    key: String,
+    defaultValue: () -> T
+  ): T {
+    @Suppress("UNCHECKED_CAST")
+    return store.getOrPut(key, {
+      defaultValue() as Any
+    }) as T
+  }
+
+  /**
+   * @see MutableMap.set
+   */
   operator fun <T> set(
     key: String,
     value: T
@@ -14,10 +34,16 @@ class GraphContext {
     store[key] = (value as Any)
   }
 
+  /**
+   * @see MutableMap.containsKey
+   */
   operator fun contains(key: String): Boolean {
     return key in store
   }
 
+  /**
+   * @see MutableMap.remove
+   */
   operator fun minusAssign(key: String) {
     @Suppress("UNCHECKED_CAST")
     store -= key
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
index ce400a5b..882db9f2 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
@@ -1,9 +1,51 @@
 package leakcanary
 
 import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
 
+/**
+ * Represents a static field or an instance field.
+ */
 class GraphField(
+  /**
+   * The class this field was declared in.
+   */
   val classRecord: GraphClassRecord,
+  /**
+   * Name of the field
+   */
   val name: String,
+  /**
+   * Value of the field. Also see shorthands [valueAsClass], [valueAsInstance],
+   * [valueAsObjectArray], [valueAsPrimitiveArray].
+   */
   val value: GraphHeapValue
-)
\ No newline at end of file
+) {
+
+  /**
+   * Return a [GraphClassRecord] is [value] references a class, and null otherwise.
+   */
+  val valueAsClass: GraphClassRecord?
+    get() = value.asObject?.asClass
+
+  /**
+   * Return a [GraphInstanceRecord] is [value] references an instance, and null otherwise.
+   */
+  val valueAsInstance: GraphInstanceRecord?
+    get() = value.asObject?.asInstance
+
+  /**
+   * Return a [GraphObjectArrayRecord] is [value] references an object array, and null otherwise.
+   */
+  val valueAsObjectArray: GraphObjectArrayRecord?
+    get() = value.asObject?.asObjectArray
+
+  /**
+   * Return a [GraphPrimitiveArrayRecord] is [value] references a primitive array, and null
+   * otherwise.
+   */
+  val valueAsPrimitiveArray: GraphPrimitiveArrayRecord?
+    get() = value.asObject?.asPrimitiveArray
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
index a19c8de3..6cf1eb15 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
@@ -10,6 +10,10 @@ import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
 
+/**
+ * Represents a value in the heap dump, which can be an object reference or
+ * a primitive type. Provides navigation capabilities.
+ */
 class GraphHeapValue(
   private val graph: HprofGraph,
   val actual: HeapValue
@@ -38,10 +42,10 @@ class GraphHeapValue(
   val asLong: Long?
     get() = if (actual is LongValue) actual.value else null
 
-  val asObjectIdReference: Long?
+  val asObjectId: Long?
     get() = if (actual is ObjectReference) actual.value else null
 
-  val asNonNullObjectIdReference: Long?
+  val asNonNullObjectId: Long?
     get() = if (actual is ObjectReference && !actual.isNull) actual.value else null
 
   val isNullReference: Boolean
@@ -53,7 +57,7 @@ class GraphHeapValue(
   val asObject: GraphObjectRecord?
     get() {
       return if (actual is ObjectReference && !actual.isNull) {
-        return graph.indexedObject(actual.value)
+        return graph.findObjectByObjectId(actual.value)
       } else {
         null
       }
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
index 3638445f..43a7c540 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
@@ -14,8 +14,14 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
 import leakcanary.internal.IndexedObject.IndexedClass
 import leakcanary.internal.IndexedObject.IndexedInstance
 import leakcanary.internal.IndexedObject.IndexedObjectArray
@@ -23,8 +29,13 @@ import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
 import java.nio.charset.Charset
 import kotlin.reflect.KClass
 
+/**
+ * Represents an object in the heap dump and provides navigation capabilities.
+ */
 sealed class GraphObjectRecord {
 
+  abstract val graph: HprofGraph
+
   abstract val objectId: Long
 
   abstract fun readRecord(): ObjectRecord
@@ -41,11 +52,15 @@ sealed class GraphObjectRecord {
   val asPrimitiveArray: GraphPrimitiveArrayRecord?
     get() = if (this is GraphPrimitiveArrayRecord) this else null
 
+  /**
+   * Represents a class in the heap dump and provides navigation capabilities.
+   */
   class GraphClassRecord internal constructor(
-    private val graph: HprofGraph,
+    override val graph: HprofGraph,
     private val indexedObject: IndexedClass,
     override val objectId: Long
   ) : GraphObjectRecord() {
+
     override fun readRecord(): ClassDumpRecord {
       return graph.readClassDumpRecord(objectId, indexedObject)
     }
@@ -69,15 +84,15 @@ sealed class GraphObjectRecord {
 
     val superClass: GraphClassRecord?
       get() {
-        if (indexedObject.superClassId == 0L) return null
-        return graph.indexedObject(indexedObject.superClassId) as GraphClassRecord
+        if (indexedObject.superClassId == HeapValue.NULL_REFERENCE) return null
+        return graph.findObjectByObjectId(indexedObject.superClassId) as GraphClassRecord
       }
 
     val classHierarchy: Sequence<GraphClassRecord>
       get() = generateSequence(this) { it.superClass }
 
     val directInstances: Sequence<GraphInstanceRecord>
-      get() = graph.instanceSequence().filter { it.indexedObject.classId == objectId }
+      get() = graph.instances.filter { it.indexedObject.classId == objectId }
 
     fun readStaticFields(): Sequence<GraphField> {
       return readRecord().staticFields.asSequence()
@@ -104,19 +119,26 @@ sealed class GraphObjectRecord {
     }
   }
 
+  /**
+   * Represents an instance in the heap dump and provides navigation capabilities.
+   */
   class GraphInstanceRecord internal constructor(
-    private val graph: HprofGraph,
+    override val graph: HprofGraph,
     internal val indexedObject: IndexedInstance,
     override val objectId: Long,
     val isPrimitiveWrapper: Boolean
   ) : GraphObjectRecord() {
+
+    val size
+      get() = instanceClass.instanceSize
+
     override fun readRecord(): InstanceDumpRecord {
       return graph.readInstanceDumpRecord(objectId, indexedObject)
     }
 
     infix fun instanceOf(className: String): Boolean {
       var currentClassId = indexedObject.classId
-      while (currentClassId != 0L) {
+      while (currentClassId != HeapValue.NULL_REFERENCE) {
         if (graph.className(currentClassId) == className) {
           return true
         }
@@ -160,7 +182,7 @@ sealed class GraphObjectRecord {
 
     val instanceClass: GraphClassRecord
       get() {
-        return graph.indexedObject(indexedObject.classId) as GraphClassRecord
+        return graph.findObjectByObjectId(indexedObject.classId) as GraphClassRecord
       }
 
     fun readFields(): Sequence<GraphField> {
@@ -184,7 +206,9 @@ sealed class GraphObjectRecord {
       if (className != "java.lang.String") {
         return null
       }
-      val count = this["java.lang.String", "count"]!!.value.asInt!!
+
+      // JVM strings don't have a count field.
+      val count = this["java.lang.String", "count"]?.value?.asInt
       if (count == 0) {
         return ""
       }
@@ -199,9 +223,18 @@ sealed class GraphObjectRecord {
           // As of Marshmallow, substrings no longer share their parent strings' char arrays
           // eliminating the need for String.offset
           // https://android-review.googlesource.com/#/c/83611/
-          val offset = this["java.lang.String", "offset"]?.value?.asInt ?: 0
-
-          val chars = valueRecord.array.copyOfRange(offset, offset + count)
+          val offset = this["java.lang.String", "offset"]?.value?.asInt
+
+          val chars = if (count != null && offset != null) {
+            // Handle heap dumps where all primitive arrays have been replaced with empty arrays,
+            // e.g. with HprofPrimitiveArrayStripper
+            val toIndex = if (offset + count > valueRecord.array.size) {
+              valueRecord.array.size
+            } else offset + count
+            valueRecord.array.copyOfRange(offset, toIndex)
+          } else {
+            valueRecord.array
+          }
           return String(chars)
         }
         is ByteArrayDump -> {
@@ -219,8 +252,11 @@ sealed class GraphObjectRecord {
     }
   }
 
+  /**
+   * Represents an object array in the heap dump and provides navigation capabilities.
+   */
   class GraphObjectArrayRecord internal constructor(
-    private val graph: HprofGraph,
+    override val graph: HprofGraph,
     private val indexedObject: IndexedObjectArray,
     override val objectId: Long,
     val isPrimitiveWrapperArray: Boolean
@@ -229,6 +265,10 @@ sealed class GraphObjectRecord {
     val arrayClassName: String
       get() = graph.className(indexedObject.arrayClassId)
 
+    fun readSize(): Int {
+      return readRecord().elementIds.size * graph.idSize
+    }
+
     override fun readRecord(): ObjectArrayDumpRecord {
       return graph.readObjectArrayDumpRecord(objectId, indexedObject)
     }
@@ -243,11 +283,28 @@ sealed class GraphObjectRecord {
     }
   }
 
+  /**
+   * Represents a primitive array in the heap dump and provides navigation capabilities.
+   */
   class GraphPrimitiveArrayRecord internal constructor(
-    private val graph: HprofGraph,
+    override val graph: HprofGraph,
     private val indexedObject: IndexedPrimitiveArray,
     override val objectId: Long
   ) : GraphObjectRecord() {
+
+    fun readSize(): Int {
+      return when (val record = readRecord()) {
+        is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
+        is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
+        is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
+        is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
+        is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
+        is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
+        is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
+        is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
+      }
+    }
+
     val primitiveType: PrimitiveType
       get() = indexedObject.primitiveType
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
index 3178c479..bf7208dd 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
@@ -1,19 +1,15 @@
 package leakcanary
 
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
 
+/**
+ * A value in the heap dump, which can be an [ObjectReference] or
+ * a primitive type.
+ */
 sealed class HeapValue {
   data class ObjectReference(val value: Long) : HeapValue() {
     val isNull
-      get() = value == 0L
+      get() = value == NULL_REFERENCE
   }
 
   data class BooleanValue(val value: Boolean) : HeapValue()
@@ -24,61 +20,8 @@ sealed class HeapValue {
   data class ShortValue(val value: Short) : HeapValue()
   data class IntValue(val value: Int) : HeapValue()
   data class LongValue(val value: Long) : HeapValue()
-}
 
-val HeapValue?.isNullReference
-  get() = this is ObjectReference && isNull
-
-val HeapValue?.reference
-  get() = if (this is ObjectReference && !isNull) {
-    this.value
-  } else
-    null
-
-val HeapValue?.boolean
-  get() = if (this is BooleanValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.char
-  get() = if (this is CharValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.float
-  get() = if (this is FloatValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.double
-  get() = if (this is DoubleValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.byte
-  get() = if (this is ByteValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.short
-  get() = if (this is ShortValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.int
-  get() = if (this is IntValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.long
-  get() = if (this is LongValue) {
-    this.value
-  } else
-    null
\ No newline at end of file
+  companion object {
+    const val NULL_REFERENCE = 0L
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
index cac15530..fd8fe4f5 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -20,6 +20,7 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Fl
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import leakcanary.internal.FieldValuesReader
 import leakcanary.internal.HprofInMemoryIndex
 import leakcanary.internal.IndexedObject
 import leakcanary.internal.IndexedObject.IndexedClass
@@ -39,87 +40,102 @@ class HprofGraph internal constructor(
   private val index: HprofInMemoryIndex
 ) {
 
+  /**
+   * In memory store that can be used to store objects this [HprofGraph] instance.
+   */
   val context = GraphContext()
 
   /**
-   * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
-   * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
-   * Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+   * All GC roots which type matches the set passed to [HprofInMemoryIndex.createOnRecordListener].
    */
-  private val objectCache = LruCache<Long, ObjectRecord>(3000)
+  val gcRoots: List<GcRoot>
+    get() = index.gcRoots()
 
-  fun indexedClass(className: String): GraphClassRecord? {
-    val classId = index.classId(className)
-    return if (classId == null) {
-      null
-    } else {
-      return indexedObject(classId) as GraphClassRecord
+  /**
+   * Sequence of all objects in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val objects: Sequence<GraphObjectRecord>
+    get() {
+      return index.indexedObjectSequence()
+          .map {
+            wrapIndexedObject(it.second, it.first)
+          }
     }
-  }
 
-  fun readObjectRecord(objectId: Long): ObjectRecord {
-    return when (val indexedObject = index.indexedObject(objectId)) {
-      is IndexedInstance -> readInstanceDumpRecord(objectId, indexedObject)
-      is IndexedClass -> readClassDumpRecord(objectId, indexedObject)
-      is IndexedObjectArray -> readObjectArrayDumpRecord(objectId, indexedObject)
-      is IndexedPrimitiveArray -> readPrimitiveArrayDumpRecord(objectId, indexedObject)
+  /**
+   * Sequence of all classes in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val classes: Sequence<GraphClassRecord>
+    get() {
+      return index.indexedClassSequence()
+          .map {
+            val objectId = it.first
+            val indexedObject = it.second
+            GraphClassRecord(this, indexedObject, objectId)
+          }
     }
-  }
 
-  fun indexedObject(objectId: Long): GraphObjectRecord {
-    return wrapIndexedObject(index.indexedObject(objectId), objectId)
-  }
+  /**
+   * Sequence of all instances in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val instances: Sequence<GraphInstanceRecord>
+    get() {
+      return index.indexedInstanceSequence()
+          .map {
+            val objectId = it.first
+            val indexedObject = it.second
+            val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+            GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
+          }
+    }
 
-  fun objectIdExists(objectId: Long): Boolean {
-    return index.objectIdIsIndexed(objectId)
-  }
+  internal val idSize
+    get() = index.idSize
 
-  fun computeShallowSize(graphObject: GraphObjectRecord): Int {
-    return when (graphObject) {
-      is GraphInstanceRecord -> graphObject.instanceClass.instanceSize
-      is GraphObjectArrayRecord -> graphObject.readRecord().elementIds.size * index.idSize
-      is GraphPrimitiveArrayRecord -> when (val record = graphObject.readRecord()) {
-        is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
-        is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
-        is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
-        is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
-        is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
-        is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
-        is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
-        is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
-      }
-      is GraphClassRecord -> throw IllegalStateException(
-          "Unexpected record ${graphObject.readRecord()}"
-      )
-    }
-  }
+  // LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
+  // This is based on running InstrumentationLeakDetectorTest a bunch of time on a
+  // Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+  private val objectCache = LruCache<Long, ObjectRecord>(3000)
 
-  fun instanceSequence(): Sequence<GraphInstanceRecord> {
-    return index.indexedInstanceSequence()
-        .map {
-          val objectId = it.first
-          val indexedObject = it.second
-          val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
-          GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
-        }
+  /**
+   * Returns the [GraphObjectRecord] corresponding to the provided [objectId], and throws
+   * [IllegalArgumentException] otherwise.
+   */
+  fun findObjectByObjectId(objectId: Long): GraphObjectRecord {
+    return wrapIndexedObject(index.indexedObject(objectId), objectId)
   }
 
-  fun objectSequence(): Sequence<GraphObjectRecord> {
-    return index.indexedObjectSequence()
-        .map {
-          wrapIndexedObject(it.second, it.first)
-        }
+  /**
+   * Returns the [GraphClassRecord] corresponding to the provided [className], or null if the
+   * class cannot be found.
+   */
+  fun findClassByClassName(className: String): GraphClassRecord? {
+    val classId = index.classId(className)
+    return if (classId == null) {
+      null
+    } else {
+      return findObjectByObjectId(classId) as GraphClassRecord
+    }
   }
 
-  fun classSequence(): Sequence<GraphClassRecord> {
-    return index.indexedClassSequence()
-        .map {
-          val objectId = it.first
-          val indexedObject = it.second
-          GraphClassRecord(this, indexedObject, objectId)
-        }
+  /**
+   * Returns true if the provided [objectId] exists in the heap dump.
+   */
+  fun objectExists(objectId: Long): Boolean {
+    return index.objectIdIsIndexed(objectId)
   }
 
+  /**
+   * Returns the byte size of the provided [hprofType].
+   *
+   * Note: this API may be removed eventually.
+   */
   fun sizeOfFieldType(hprofType: Int) = index.sizeOfFieldType(hprofType)
 
   internal fun fieldName(fieldRecord: FieldRecord): String {
@@ -143,6 +159,15 @@ class HprofGraph internal constructor(
     }
   }
 
+  internal fun readObjectRecord(objectId: Long): ObjectRecord {
+    return when (val indexedObject = index.indexedObject(objectId)) {
+      is IndexedInstance -> readInstanceDumpRecord(objectId, indexedObject)
+      is IndexedClass -> readClassDumpRecord(objectId, indexedObject)
+      is IndexedObjectArray -> readObjectArrayDumpRecord(objectId, indexedObject)
+      is IndexedPrimitiveArray -> readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
+  }
+
   internal fun className(classId: Long): String {
     return index.className(classId)
   }
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt
new file mode 100644
index 00000000..2dd8758f
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt
@@ -0,0 +1,88 @@
+package leakcanary
+
+import leakcanary.HprofPushRecordsParser.OnRecordListener
+import leakcanary.Record.HeapDumpEndRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import java.io.File
+import kotlin.reflect.KClass
+
+/**
+ * Transforms a Hprof to all primitive arrays, which can be useful to remove PII.
+ */
+class HprofPrimitiveArrayStripper {
+
+  fun stripPrimitiveArrays(
+    inputHprofFile: File,
+    outputHprofFile: File = File(
+        inputHprofFile.parent, inputHprofFile.name.replace(
+        ".hprof", "-stripped.hprof"
+    ).let { if (it != inputHprofFile.name) it else inputHprofFile.name + "-stripped" })
+  ): File {
+    val parser = HprofPushRecordsParser()
+
+    lateinit var writer: HprofWriter
+
+    parser.readHprofRecords(inputHprofFile, setOf(object : OnRecordListener {
+
+      override fun recordTypes(): Set<KClass<out Record>> = setOf(Record::class)
+
+      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
+        writer =
+          HprofWriter.open(outputHprofFile, idSize = typeSizes.getValue(HprofReader.OBJECT_TYPE))
+      }
+
+      override fun onRecord(
+        position: Long,
+        record: Record
+      ) {
+
+        // HprofWriter automatically emits HeapDumpEndRecord, because it flushes
+        // all continuous heap dump sub records as one heap dump record.
+        if (record is HeapDumpEndRecord) {
+          return
+        }
+        writer.write(
+            when (record) {
+              is BooleanArrayDump -> BooleanArrayDump(
+                  record.id, record.stackTraceSerialNumber, booleanArrayOf()
+              )
+              is CharArrayDump -> CharArrayDump(
+                  record.id, record.stackTraceSerialNumber, charArrayOf()
+              )
+              is FloatArrayDump -> FloatArrayDump(
+                  record.id, record.stackTraceSerialNumber, floatArrayOf()
+              )
+              is DoubleArrayDump -> DoubleArrayDump(
+                  record.id, record.stackTraceSerialNumber, doubleArrayOf()
+              )
+              is ByteArrayDump -> ByteArrayDump(
+                  record.id, record.stackTraceSerialNumber, byteArrayOf()
+              )
+              is ShortArrayDump -> ShortArrayDump(
+                  record.id, record.stackTraceSerialNumber, shortArrayOf()
+              )
+              is IntArrayDump -> IntArrayDump(
+                  record.id, record.stackTraceSerialNumber, intArrayOf()
+              )
+              is LongArrayDump -> LongArrayDump(
+                  record.id, record.stackTraceSerialNumber, longArrayOf()
+              )
+              else -> {
+                record
+              }
+            }
+        )
+      }
+    })).close()
+    writer.close()
+    return outputHprofFile
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
index f0e60cbf..c6e1403a 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
@@ -40,7 +40,7 @@ import kotlin.reflect.KClass
  * A streaming push heap dump parser.
  *
  * Expected usage: call [readHprofRecords] once, which will go read through the entire heap dump
- * and notify the provided listener of records found.
+ * and notify the provided listeners of records found.
  *
  * This class is not thread safe, should be used from a single thread.
  *
@@ -75,7 +75,12 @@ class HprofPushRecordsParser {
         .buffer()
 
     val endOfVersionString = source.indexOf(0)
-    source.skip(endOfVersionString + 1)
+    val version = source.readUtf8(endOfVersionString)
+    require(version in supportedVersions) {
+      "Unsupported Hprof version [$version] not in supported list $supportedVersions"
+    }
+    // Skip the 0 at the end of the version string.
+    source.skip(1)
     val idSize = source.readInt()
     val startPosition = endOfVersionString + 1 + 4
 
@@ -602,7 +607,18 @@ class HprofPushRecordsParser {
     }
   }
 
+  enum class HprofVersion(val versionString: String) {
+    JDK1_2_BETA3("JAVA PROFILE 1.0"),
+    JDK1_2_BETA4("JAVA PROFILE 1.0.1"),
+    JDK_6("JAVA PROFILE 1.0.2"),
+    ANDROID("JAVA PROFILE 1.0.3")
+  }
+
   companion object {
+
+    private val supportedVersions = HprofVersion.values()
+        .map { it.versionString }
+
     internal const val STRING_IN_UTF8 = 0x01
     internal const val LOAD_CLASS = 0x02
     internal const val UNLOAD_CLASS = 0x03
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
index 596228ef..10946040 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
@@ -29,6 +29,8 @@ import java.io.Closeable
 import java.nio.charset.Charset
 
 /**
+ * Reads hprof content from an Okio [BufferedSource].
+ *
  * Not thread safe, should be used from a single thread.
  */
 open class HprofReader constructor(
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
index 421f922d..f9828f74 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
@@ -50,6 +50,11 @@ import okio.sink
 import java.io.Closeable
 import java.io.File
 
+/**
+ * Generates Hprof files.
+ *
+ * Call [open] to create an instance, [write] to add instances and [close] when you're done.
+ */
 class HprofWriter private constructor(
   private val sink: BufferedSink,
   val idSize: Int
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
deleted file mode 100644
index f3d730f9..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-package leakcanary
-
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-
-class HydratedClass(
-  val record: ClassDumpRecord,
-  val className: String,
-  val staticFieldNames: List<String>,
-  val fieldNames: List<String>
-) {
-  inline fun <reified T : HeapValue> staticFieldValue(name: String): T {
-    return staticFieldValueOrNull(name) ?: throw IllegalArgumentException(
-        "Could not find static field $name in class $className with id ${record.id} and static fields $staticFieldNames"
-    )
-  }
-
-  fun fieldType(name: String): Int {
-    fieldNames.forEachIndexed { index, fieldName ->
-      if (fieldName == name) {
-        return record.fields[index].type
-      }
-    }
-    throw IllegalArgumentException(
-        "Could not find field $name in class $className with id ${record.id} and fields $fieldNames"
-    )
-  }
-
-  inline fun <reified T : HeapValue> staticFieldValueOrNull(name: String): T? {
-    staticFieldNames.forEachIndexed { fieldIndex, fieldName ->
-      if (fieldName == name) {
-        val fieldValue = record.staticFields[fieldIndex].value
-        return if (fieldValue is T) {
-          fieldValue
-        } else null
-      }
-    }
-    return null
-  }
-
-  operator fun get(name: String): HeapValue? = staticFieldValueOrNull(name)
-
-  fun hasStaticField(name: String): Boolean {
-    staticFieldNames.forEach { fieldName ->
-      if (fieldName == name) {
-        return true
-      }
-    }
-    return false
-  }
-
-  val simpleClassName: String
-    get() {
-      val separator = className.lastIndexOf('.')
-      return if (separator == -1) {
-        className
-      } else {
-        className.substring(separator + 1)
-      }
-    }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
deleted file mode 100644
index 87affe41..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-package leakcanary
-
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-
-class HydratedInstance(
-  val record: InstanceDumpRecord,
-  val classHierarchy: List<HydratedClass>,
-  /**
-   * One list of field values per class
-   */
-  val fieldValues: List<List<HeapValue>>
-) {
-  inline fun <reified T : HeapValue> fieldValue(name: String): T {
-    return fieldValueOrNull(name) ?: throw IllegalArgumentException(
-        "Could not find field $name in instance with id ${record.id}"
-    )
-  }
-
-  inline fun <reified T : HeapValue> fieldValueOrNull(name: String): T? {
-    classHierarchy.forEachIndexed { classIndex, hydratedClass ->
-      hydratedClass.fieldNames.forEachIndexed { fieldIndex, fieldName ->
-        if (fieldName == name) {
-          val fieldValue = fieldValues[classIndex][fieldIndex]
-          return if (fieldValue is T) {
-            fieldValue
-          } else null
-        }
-      }
-    }
-    return null
-  }
-
-  operator fun get(name: String): HeapValue? = fieldValueOrNull(name)
-
-  fun hasField(name: String): Boolean {
-    classHierarchy.forEach { hydratedClass ->
-      hydratedClass.fieldNames.forEach { fieldName ->
-        if (fieldName == name) {
-          return true
-        }
-      }
-    }
-    return false
-  }
-
-  fun isInstanceOf(className: String): Boolean {
-    return classHierarchy.any { it.className == className }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/leakcanary-haha/src/main/java/leakcanary/Record.kt
index cd139855..85fa9a09 100644
--- a/leakcanary-haha/src/main/java/leakcanary/Record.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/Record.kt
@@ -1,5 +1,8 @@
 package leakcanary
 
+/**
+ * A Hprof record. These data structure map 1:1 with how records are written in hprof files.
+ */
 sealed class Record {
   class StringRecord(
     val id: Long,
diff --git a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
index d5ec5a22..ba68cd27 100644
--- a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
@@ -3,6 +3,9 @@ package leakcanary
 import okio.BufferedSource
 import java.nio.channels.FileChannel
 
+/**
+ * A [HprofReader] that can be moved ([moveTo]) to a new position.
+ */
 class SeekableHprofReader(
   private val channel: FileChannel,
   source: BufferedSource,
diff --git a/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt b/leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt
similarity index 57%
rename from leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
rename to leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt
index 9ab4dfe5..eb3ca46c 100644
--- a/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt
@@ -1,7 +1,8 @@
-package leakcanary
+package leakcanary.internal
 
+import leakcanary.HeapValue
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
 
-interface FieldValuesReader {
+internal interface FieldValuesReader {
   fun readValue(field: FieldRecord): HeapValue
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
index b347bf11..a4e915a4 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
@@ -1,6 +1,15 @@
 package leakcanary.internal
 
+import leakcanary.GcRoot
+import leakcanary.GcRoot.JavaFrame
 import leakcanary.GcRoot.JniGlobal
+import leakcanary.GcRoot.JniLocal
+import leakcanary.GcRoot.JniMonitor
+import leakcanary.GcRoot.MonitorUsed
+import leakcanary.GcRoot.NativeStack
+import leakcanary.GcRoot.StickyClass
+import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HprofPushRecordsParser.OnRecordListener
 import leakcanary.HprofReader
 import leakcanary.PrimitiveType
@@ -19,8 +28,6 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.In
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
 import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StackFrameRecord
-import leakcanary.Record.StackTraceRecord
 import leakcanary.Record.StringRecord
 import leakcanary.internal.IndexedObject.IndexedClass
 import leakcanary.internal.IndexedObject.IndexedInstance
@@ -35,6 +42,7 @@ internal class HprofInMemoryIndex private constructor(
   private val hprofStringCache: LongToStringSparseArray,
   private val classNames: LongToLongSparseArray,
   private val objectIndex: LongToObjectSparseArray<IndexedObject>,
+  private val gcRoots: List<GcRoot>,
   private val typeSizes: Map<Int, Int>,
   val primitiveWrapperTypes: Set<Long>
 ) {
@@ -74,15 +82,23 @@ internal class HprofInMemoryIndex private constructor(
     return objectIndex.entrySequence()
   }
 
+  fun gcRoots(): List<GcRoot> {
+    return gcRoots
+  }
+
   fun indexedObject(objectId: Long): IndexedObject {
-    return objectIndex[objectId]!!
+    return objectIndex[objectId] ?: throw IllegalArgumentException(
+        "Object id $objectId not found in heap dump."
+    )
   }
 
   fun objectIdIsIndexed(objectId: Long): Boolean {
     return objectIndex[objectId] != null
   }
 
-  class Builder : OnRecordListener {
+  class Builder(
+    private val indexedGcRootsTypes: Set<KClass<out GcRoot>>
+  ) : OnRecordListener {
     /**
      * Map of string id to string
      * This currently keeps all the hprof strings that we could care about: class names,
@@ -115,6 +131,8 @@ internal class HprofInMemoryIndex private constructor(
      */
     private val primitiveWrapperClassNames = mutableSetOf<Long>()
 
+    private val gcRoots = mutableListOf<GcRoot>()
+
     private lateinit var typeSizes: Map<Int, Int>
     private var consumed = false
 
@@ -124,7 +142,8 @@ internal class HprofInMemoryIndex private constructor(
         ClassDumpRecord::class,
         InstanceDumpRecord::class,
         ObjectArrayDumpRecord::class,
-        PrimitiveArrayDumpRecord::class
+        PrimitiveArrayDumpRecord::class,
+        GcRootRecord::class
     )
 
     override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
@@ -143,7 +162,8 @@ internal class HprofInMemoryIndex private constructor(
           if (PRIMITIVE_WRAPPER_TYPES.contains(record.string)) {
             primitiveWrapperClassNames.add(record.id)
           }
-          hprofStringCache[record.id] = record.string
+          // JVM heap dumps use "/" for package separators (vs "." for Android heap dumps)
+          hprofStringCache[record.id] = record.string.replace('/', '.')
         }
         is LoadClassRecord -> {
           classNames[record.id] = record.classNameStringId
@@ -151,12 +171,17 @@ internal class HprofInMemoryIndex private constructor(
             primitiveWrapperTypes.add(record.id)
           }
         }
+        is GcRootRecord -> {
+          val gcRoot = record.gcRoot
+          if (gcRoot.id != 0L && gcRoot::class in indexedGcRootsTypes) {
+            gcRoots += gcRoot
+          }
+        }
         is ClassDumpRecord -> {
           objectIndex[record.id] = IndexedClass(position, record.superClassId, record.instanceSize)
         }
         is InstanceDumpRecord -> {
-          objectIndex[record.id] =
-            IndexedInstance(position, record.classId)
+          objectIndex[record.id] = IndexedInstance(position, record.classId)
         }
         is ObjectArrayDumpRecord -> {
           objectIndex[record.id] = IndexedObjectArray(position, record.arrayClassId)
@@ -181,7 +206,7 @@ internal class HprofInMemoryIndex private constructor(
       consumed = true
       // Passing references to avoid copying the underlying data structures.
       return HprofInMemoryIndex(
-          hprofStringCache, classNames, objectIndex,
+          hprofStringCache, classNames, objectIndex, gcRoots,
           typeSizes,
           primitiveWrapperTypes
       )
@@ -197,8 +222,36 @@ internal class HprofInMemoryIndex private constructor(
         Int::class.java.name, Long::class.java.name
     )
 
-    fun createOnRecordListener(): Builder {
-      return Builder()
+    fun createOnRecordListener(
+      indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
+          JniGlobal::class,
+          JavaFrame::class,
+          JniLocal::class,
+          MonitorUsed::class,
+          NativeStack::class,
+          StickyClass::class,
+          ThreadBlock::class,
+          // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
+          // belongs to
+          ThreadObject::class,
+          JniMonitor::class
+          /*
+          Not included here:
+
+          VmInternal: Ignoring because we've got 150K of it, but is this the right thing
+          to do? What's VmInternal exactly? History does not go further than
+          https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+          We should log to figure out what objects VmInternal points to.
+
+          ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
+
+          Unknown: it's unknown, should we care?
+
+          We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
+           */
+      )
+    ): Builder {
+      return Builder(indexedGcRootTypes)
     }
 
   }
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt b/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt
new file mode 100644
index 00000000..bc5b33fa
--- /dev/null
+++ b/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt
@@ -0,0 +1,72 @@
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
+import leakcanary.PrimitiveType.BOOLEAN
+import leakcanary.PrimitiveType.CHAR
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class HprofPrimitiveArrayStripperTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  @Test
+  fun stripHprof() {
+    val hprofFile = testFolder.newFile("temp.hprof")
+
+    val booleanArray = BooleanArrayDump(id, 1, booleanArrayOf(true, false, true, true))
+    val charArray = CharArrayDump(id, 1, "Hello World!".toCharArray())
+    hprofFile.writeRecords(listOf(booleanArray, charArray))
+
+    val stripper = HprofPrimitiveArrayStripper()
+
+    val strippedFile = stripper.stripPrimitiveArrays(hprofFile)
+
+    strippedFile.readHprof { graph ->
+      val booleanArrays = graph.objects
+          .filter { it is GraphPrimitiveArrayRecord && it.primitiveType == BOOLEAN }
+          .map { it.readRecord() as BooleanArrayDump }
+          .toList()
+      assertThat(booleanArrays).hasSize(1)
+      assertThat(booleanArrays[0].id).isEqualTo(booleanArray.id)
+      assertThat(booleanArrays[0].array).isEmpty()
+
+      val charArrays = graph.objects
+          .filter { it is GraphPrimitiveArrayRecord && it.primitiveType == CHAR }
+          .map { it.readRecord() as CharArrayDump }
+          .toList()
+      assertThat(charArrays).hasSize(1)
+      assertThat(charArrays[0].id).isEqualTo(charArray.id)
+      assertThat(charArrays[0].array).isEmpty()
+    }
+  }
+
+  private fun File.writeRecords(
+    records: List<Record>
+  ) {
+    HprofWriter.open(this)
+        .use { writer ->
+          records.forEach { record ->
+            writer.write(record)
+          }
+        }
+  }
+
+  fun File.readHprof(block: (HprofGraph) -> Unit) {
+    val (graph, closeable) = HprofGraph.readHprof(this)
+    closeable.use {
+      block(graph)
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
index a3d0b26d..5544321f 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
+++ b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
@@ -30,7 +30,7 @@ class HprofWriterTest {
     hprofFile.writeRecords(records)
 
     hprofFile.readHprof { graph ->
-      val treasureChestClass = graph.indexedClass(TREASURE_CHEST_CLASS_NAME)!!
+      val treasureChestClass = graph.findClassByClassName(TREASURE_CHEST_CLASS_NAME)!!
       val baguetteInstance =
         treasureChestClass[CONTENT_FIELD_NAME]!!.value.asObject!!.asInstance!!
 
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
index c79c1d45..36507b5f 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
@@ -4,37 +4,67 @@ import android.app.Application
 import leakcanary.internal.InternalLeakSentry
 import java.util.concurrent.TimeUnit
 
+/**
+ * The entry point API for LeakSentry. LeakSentry is in charge of detecting retained objects.
+ *
+ * LeakSentry can be configured by updating [config]. You can ask LeakSentry to watch any object
+ * that you expect to be unreachable by calling [ObjectWatcher.watch] on [objectWatcher].
+ */
 object LeakSentry {
 
   data class Config(
     /**
-     * Whether LeakSentry should watch instances (by keeping weak references to them). Default is
-     * true in debuggable builds and false is non debuggable builds.
+     * Whether LeakSentry should watch objects (by keeping weak references to them).
+     *
+     * Default to true in debuggable builds and false is non debuggable builds.
      */
     val enabled: Boolean = InternalLeakSentry.isDebuggableBuild,
+
     /**
-     * Whether LeakCanary should automatically watch destroyed activities.
+     * Whether LeakSentry should automatically watch destroyed activity instances.
+     *
+     * Defaults to true.
      */
     val watchActivities: Boolean = true,
+
     /**
-     * Whether LeakCanary should automatically watch destroyed fragments.
+     * Whether LeakSentry should automatically watch destroyed fragment instances.
+     *
+     * Defaults to true.
      */
     val watchFragments: Boolean = true,
+
     /**
-     * Whether LeakCanary should automatically watch destroyed fragment views.
+     * Whether LeakSentry should automatically watch destroyed fragment view instances.
+     *
+     * Defaults to true.
      */
     val watchFragmentViews: Boolean = true,
+
     /**
-     * How long to wait before reporting a watched instance as retained. Default is 5 seconds.
+     * How long to wait before reporting a watched object as retained.
+     *
+     * Default to 5 seconds.
      */
     val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
   )
 
+  /**
+   * The current LeakSentry configuration. Can be updated at any time, usually by replacing it with
+   * a mutated copy, e.g.:
+   *
+   * ```
+   * LeakCanary.config = LeakCanary.config.copy(enabled = false)
+   * ```
+   */
   @Volatile
   var config: Config = if (isInstalled) Config() else Config(enabled = false)
 
-  val refWatcher
-    get() = InternalLeakSentry.refWatcher
+  /**
+   * The [ObjectWatcher] used by LeakSentry to detect retained objects.
+   */
+  val objectWatcher
+    get() = InternalLeakSentry.objectWatcher
 
   /** @see [manualInstall] */
   val isInstalled
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
index aec2cc7c..87b4fd97 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -18,11 +18,11 @@ package leakcanary.internal
 import android.app.Activity
 import android.app.Application
 import leakcanary.LeakSentry.Config
-import leakcanary.RefWatcher
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.ObjectWatcher
+import leakcanary.internal.InternalLeakSentry.noOpDelegate
 
 internal class ActivityDestroyWatcher private constructor(
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
 ) {
 
@@ -30,7 +30,7 @@ internal class ActivityDestroyWatcher private constructor(
     object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
       override fun onActivityDestroyed(activity: Activity) {
         if (configProvider().watchActivities) {
-          refWatcher.watch(activity)
+          objectWatcher.watch(activity)
         }
       }
     }
@@ -38,11 +38,11 @@ internal class ActivityDestroyWatcher private constructor(
   companion object {
     fun install(
       application: Application,
-      refWatcher: RefWatcher,
+      objectWatcher: ObjectWatcher,
       configProvider: () -> Config
     ) {
       val activityDestroyWatcher =
-        ActivityDestroyWatcher(refWatcher, configProvider)
+        ActivityDestroyWatcher(objectWatcher, configProvider)
       application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
     }
   }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
index dd2f7d4a..02e1bbc1 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -22,14 +22,13 @@ import android.app.Activity
 import android.app.Fragment
 import android.app.FragmentManager
 import leakcanary.LeakSentry.Config
-import leakcanary.RefWatcher
+import leakcanary.ObjectWatcher
 
 @SuppressLint("NewApi")
 internal class AndroidOFragmentDestroyWatcher(
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
-) : FragmentDestroyWatcher {
-
+) : (Activity) -> Unit {
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
 
     override fun onFragmentViewDestroyed(
@@ -38,7 +37,7 @@ internal class AndroidOFragmentDestroyWatcher(
     ) {
       val view = fragment.view
       if (view != null && configProvider().watchFragmentViews) {
-        refWatcher.watch(view)
+        objectWatcher.watch(view)
       }
     }
 
@@ -47,12 +46,12 @@ internal class AndroidOFragmentDestroyWatcher(
       fragment: Fragment
     ) {
       if (configProvider().watchFragments) {
-        refWatcher.watch(fragment)
+        objectWatcher.watch(fragment)
       }
     }
   }
 
-  override fun watchFragments(activity: Activity) {
+  override fun invoke(activity: Activity) {
     val fragmentManager = activity.fragmentManager
     fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
   }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
index 2b7e8e45..673fc587 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
@@ -26,7 +26,7 @@ internal class DefaultCanaryLog : Logger {
   }
 
   override fun d(
-    throwable: Throwable?,
+    throwable: Throwable,
     message: String,
     vararg args: Any?
   ) {
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
index 9cbe23e9..dee5d5ed 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -21,68 +21,64 @@ import android.os.Build.VERSION.SDK_INT
 import android.os.Build.VERSION_CODES.O
 import android.os.Bundle
 import leakcanary.LeakSentry
-import leakcanary.RefWatcher
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.ObjectWatcher
+import leakcanary.internal.InternalLeakSentry.noOpDelegate
 
 /**
  * Internal class used to watch for fragments leaks.
  */
-interface FragmentDestroyWatcher {
+internal object FragmentDestroyWatcher {
 
-  fun watchFragments(activity: Activity)
+  private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+  private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
+    "leakcanary.internal.AndroidXFragmentDestroyWatcher"
 
-  companion object {
+  fun install(
+    application: Application,
+    objectWatcher: ObjectWatcher,
+    configProvider: () -> LeakSentry.Config
+  ) {
+    val fragmentDestroyWatchers = mutableListOf<(Activity) -> Unit>()
 
-    private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
-    private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
-      "leakcanary.internal.AndroidXFragmentDestroyWatcher"
+    if (SDK_INT >= O) {
+      fragmentDestroyWatchers.add(
+          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)
+      )
+    }
 
-    fun install(
-      application: Application,
-      refWatcher: RefWatcher,
-      configProvider: () -> LeakSentry.Config
+    if (classAvailable(ANDROIDX_FRAGMENT_CLASS_NAME) &&
+        classAvailable(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
     ) {
-      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
+      val watcherConstructor = Class.forName(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
+          .getDeclaredConstructor(ObjectWatcher::class.java, Function0::class.java)
+      @kotlin.Suppress("UNCHECKED_CAST")
+      fragmentDestroyWatchers.add(
+          watcherConstructor.newInstance(objectWatcher, configProvider) as (Activity) -> Unit
+      )
+    }
 
-      if (SDK_INT >= O) {
-        fragmentDestroyWatchers.add(
-            AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
-        )
-      }
+    if (fragmentDestroyWatchers.size == 0) {
+      return
+    }
 
-      if (classAvailable(ANDROIDX_FRAGMENT_CLASS_NAME) &&
-          classAvailable(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
+    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
       ) {
-        val watcherConstructor = Class.forName(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
-            .getDeclaredConstructor(RefWatcher::class.java, Function0::class.java)
-        fragmentDestroyWatchers.add(
-            watcherConstructor.newInstance(refWatcher, configProvider) as FragmentDestroyWatcher
-        )
-      }
-
-      if (fragmentDestroyWatchers.size == 0) {
-        return
-      }
-
-      application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
-        override fun onActivityCreated(
-          activity: Activity,
-          savedInstanceState: Bundle?
-        ) {
-          for (watcher in fragmentDestroyWatchers) {
-            watcher.watchFragments(activity)
-          }
+        for (watcher in fragmentDestroyWatchers) {
+          watcher(activity)
         }
-      })
-    }
-
-    private fun classAvailable(className: String): Boolean {
-      return try {
-        Class.forName(className)
-        true
-      } catch (e: ClassNotFoundException) {
-        false
       }
+    })
+  }
+
+  private fun classAvailable(className: String): Boolean {
+    return try {
+      Class.forName(className)
+      true
+    } catch (e: ClassNotFoundException) {
+      false
     }
   }
 }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
deleted file mode 100644
index 64e05ead..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
+++ /dev/null
@@ -1,18 +0,0 @@
-package leakcanary.internal
-
-import java.lang.reflect.InvocationHandler
-import java.lang.reflect.Proxy
-
-/** Visible across several internal modules. */
-object InternalHelper {
-  inline fun <reified T : Any> noOpDelegate(): T {
-    val javaClass = T::class.java
-    val noOpHandler = InvocationHandler { _, _, _ ->
-      // no op
-    }
-    return Proxy.newProxyInstance(
-        javaClass.classLoader, arrayOf(javaClass), noOpHandler
-    ) as T
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
index d91fecaf..2578e825 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -8,7 +8,10 @@ import android.os.SystemClock
 import leakcanary.CanaryLog
 import leakcanary.Clock
 import leakcanary.LeakSentry
-import leakcanary.RefWatcher
+import leakcanary.OnObjectRetainedListener
+import leakcanary.ObjectWatcher
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
 import java.util.concurrent.Executor
 
 internal object InternalLeakSentry {
@@ -16,7 +19,8 @@ internal object InternalLeakSentry {
   val isInstalled
     get() = ::application.isInitialized
 
-  private val listener: LeakSentryListener
+  private val onLeakSentryInstalled: (Application) -> Unit
+  private val ON_OBJECT_RETAINED_LISTENER: OnObjectRetainedListener
 
   val isDebuggableBuild by lazy {
     (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
@@ -33,21 +37,25 @@ internal object InternalLeakSentry {
   private val mainHandler = Handler(Looper.getMainLooper())
 
   init {
-    listener = try {
+    val internalLeakCanary = try {
       val leakCanaryListener = Class.forName("leakcanary.internal.InternalLeakCanary")
-      leakCanaryListener.getDeclaredField("INSTANCE").get(null) as LeakSentryListener
+      leakCanaryListener.getDeclaredField("INSTANCE")
+          .get(null)
     } catch (ignored: Throwable) {
-      LeakSentryListener.None
+      NoLeakCanary
     }
+    @kotlin.Suppress("UNCHECKED_CAST")
+    onLeakSentryInstalled = internalLeakCanary as (Application) -> Unit
+    ON_OBJECT_RETAINED_LISTENER = internalLeakCanary as OnObjectRetainedListener
   }
 
   private val checkRetainedExecutor = Executor {
     mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
   }
-  val refWatcher = RefWatcher(
+  val objectWatcher = ObjectWatcher(
       clock = clock,
       checkRetainedExecutor = checkRetainedExecutor,
-      onInstanceRetained = { listener.onReferenceRetained() },
+      onObjectRetainedListener = ON_OBJECT_RETAINED_LISTENER,
       isEnabled = { LeakSentry.config.enabled }
   )
 
@@ -60,13 +68,19 @@ internal object InternalLeakSentry {
     InternalLeakSentry.application = application
 
     val configProvider = { LeakSentry.config }
-    ActivityDestroyWatcher.install(
-        application, refWatcher, configProvider
-    )
-    FragmentDestroyWatcher.install(
-        application, refWatcher, configProvider
-    )
-    listener.onLeakSentryInstalled(application)
+    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)
+    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)
+    onLeakSentryInstalled(application)
+  }
+
+  inline fun <reified T : Any> noOpDelegate(): T {
+    val javaClass = T::class.java
+    val noOpHandler = InvocationHandler { _, _, _ ->
+      // no op
+    }
+    return Proxy.newProxyInstance(
+        javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    ) as T
   }
 
   private fun checkMainThread() {
@@ -76,4 +90,12 @@ internal object InternalLeakSentry {
       )
     }
   }
+
+  object NoLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
+    override fun invoke(application: Application) {
+    }
+
+    override fun onObjectRetained() {
+    }
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
deleted file mode 100644
index 362550b1..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
+++ /dev/null
@@ -1,16 +0,0 @@
-package leakcanary.internal
-
-import android.app.Application
-
-interface LeakSentryListener {
-  fun onLeakSentryInstalled(application: Application)
-  fun onReferenceRetained()
-
-  object None : LeakSentryListener {
-    override fun onLeakSentryInstalled(application: Application) {
-    }
-
-    override fun onReferenceRetained() {
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
index a2eccf46..cb2ab6e7 100644
--- a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
+++ b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
@@ -1,15 +1,28 @@
 package leakcanary
 
+/**
+ * Central Logger for all LeakCanary artifacts. Set [logger] to change where these logs go.
+ */
 object CanaryLog {
 
+  /**
+   * @see CanaryLog
+   */
   interface Logger {
+
+    /**
+     * Logs a debug message formatted with the passed in arguments.
+     */
     fun d(
       message: String,
       vararg args: Any?
     )
 
+    /**
+     * Logs a [Throwable] and debug message formatted with the passed in arguments.
+     */
     fun d(
-      throwable: Throwable?,
+      throwable: Throwable,
       message: String,
       vararg args: Any?
     )
@@ -17,6 +30,9 @@ object CanaryLog {
 
   @Volatile var logger: Logger? = null
 
+  /**
+   * @see Logger.d
+   */
   fun d(
     message: String,
     vararg args: Any?
@@ -26,8 +42,11 @@ object CanaryLog {
     logger.d(message, *args)
   }
 
+  /**
+   * @see Logger.d
+   */
   fun d(
-    throwable: Throwable?,
+    throwable: Throwable,
     message: String,
     vararg args: Any?
   ) {
diff --git a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt b/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
index b07ec28f..8be7b1b0 100644
--- a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
+++ b/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
@@ -18,7 +18,7 @@ import org.junit.Test
  *
  * ./gradlew leakcanary-sample:connectedCheck
  *
- * To set this up, we installed a special RefWatcher dedicated to detecting leaks in
+ * To set this up, we installed a special ObjectWatcher dedicated to detecting leaks in
  * instrumentation tests in [InstrumentationExampleApplication], and then added the FailTestOnLeakRunListener
  * to the config of our build.gradle:
  *
diff --git a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
index bd3b146b..749e97f9 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
@@ -1,6 +1,11 @@
 package leakcanary
 
+/**
+ * An interface to abstract the SystemClock.uptimeMillis() Android API in non Android artifacts.
+ */
 interface Clock {
-  /** See Android SystemClock.uptimeMillis().  */
+  /**
+   * On Android VMs, this should return android.os.SystemClock.uptimeMillis().
+   */
   fun uptimeMillis(): Long
 }
diff --git a/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt b/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
index 023889b8..762432b7 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
@@ -16,13 +16,20 @@
 package leakcanary
 
 /**
- * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
- * in the reference queue yet. This gives the application a hook to run the GC before the [ ] checks the reference queue again, to avoid taking a heap dump if possible.
+ * [GcTrigger] is used to try triggering garbage collection and enqueuing [KeyedWeakReference] into
+ * the associated [java.lang.ref.ReferenceQueue]. The default implementation [Default] comes from
+ * AOSP.
  */
 interface GcTrigger {
 
+  /**
+   * Attempts to run garbage collection.
+   */
   fun runGc()
 
+  /**
+   * Default implementation of [GcTrigger].
+   */
   object Default : GcTrigger {
     override fun runGc() {
       // Code taken from AOSP FinalizationTest:
diff --git a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
index 7772ce2d..8a63e2b4 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -15,9 +15,18 @@
  */
 package leakcanary
 
+import leakcanary.KeyedWeakReference.Companion.heapDumpUptimeMillis
 import java.lang.ref.ReferenceQueue
 import java.lang.ref.WeakReference
 
+/**
+ * A weak reference used by [ObjectWatcher] to determine which objects become weakly reachable
+ * and which don't. [ObjectWatcher] uses [key] to keep track of [KeyedWeakReference] instances that
+ * haven't made it into the associated [ReferenceQueue] yet.
+ *
+ * [heapDumpUptimeMillis] should be set with the current time from [Clock.uptimeMillis] right
+ * before dumping the heap, so that we can later determine how long an object was retained.
+ */
 @Suppress("unused")
 class KeyedWeakReference(
   referent: Any,
@@ -29,9 +38,9 @@ class KeyedWeakReference(
     referent, referenceQueue
 ) {
   /**
-   * Compared against [heapDumpUptimeMillis] so that the Hprof Parser knows only to look at
-   * instances that were moved to retained, then used to remove weak references post heap dump.
-   **/
+   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn't
+   * been yet.
+   */
   @Volatile
   var retainedUptimeMillis = -1L
 
diff --git a/leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt
new file mode 100644
index 00000000..ffb469ca
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import java.lang.ref.ReferenceQueue
+import java.util.UUID
+import java.util.concurrent.Executor
+
+/**
+ * [ObjectWatcher] can be passed objects to [watch]. It will create [KeyedWeakReference] instances
+ * that reference watches objects, and check if those references have been cleared as expected on
+ * the [checkRetainedExecutor] executor. If not, these objects are considered retained and
+ * [ObjectWatcher] will then notify the [onObjectRetainedListener] on that executor thread.
+ *
+ * [checkRetainedExecutor] is expected to run its tasks on a background thread, with a significant
+ * to give the GC the opportunity to identify weakly reachable objects.
+ *
+ * [ObjectWatcher] is thread safe.
+ */
+// Thread safe by locking on all methods, which is reasonably efficient given how often
+// these methods are accessed.
+class ObjectWatcher constructor(
+  private val clock: Clock,
+  private val checkRetainedExecutor: Executor,
+  private val onObjectRetainedListener: OnObjectRetainedListener,
+  /**
+   * Calls to [watch] will be ignored when [isEnabled] returns false
+   */
+  private val isEnabled: () -> Boolean = { true }
+) {
+
+  /**
+   * References passed to [watch].
+   */
+  private val watchedObjects = mutableMapOf<String, KeyedWeakReference>()
+
+  private val queue = ReferenceQueue<Any>()
+
+  /**
+   * Returns true if there are watched objects that aren't weakly reachable, and
+   * have been watched for long enough to be considered retained.
+   */
+  val hasRetainedObjects: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.any { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns the number of retained objects, ie the number of watched objects that aren't weakly
+   * reachable, and have been watched for long enough to be considered retained.
+   */
+  val retainedObjectCount: Int
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.count { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns true if there are watched objects that aren't weakly reachable, even
+   * if they haven't been watched for long enough to be considered retained.
+   */
+  val hasWatchedObjects: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.isNotEmpty()
+    }
+
+  /**
+   * Returns the objects that are currently considered retained. Useful for logging purposes.
+   * Be careful with those objects and release them ASAP as you may creating longer lived leaks
+   * then the one that are already there.
+   */
+  val retainedObjects: List<Any>
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      val instances = mutableListOf<Any>()
+      for (weakReference in watchedObjects.values) {
+        if (weakReference.retainedUptimeMillis != -1L) {
+          val instance = weakReference.get()
+          if (instance != null) {
+            instances.add(instance)
+          }
+        }
+      }
+      return instances
+    }
+
+  /**
+   * Identical to [watch] with an empty string reference name.
+   */
+  @Synchronized fun watch(watchedObject: Any) {
+    watch(watchedObject, "")
+  }
+
+  /**
+   * Watches the provided [watchedObject].
+   *
+   * @param name A logical identifier for the watched object.
+   */
+  @Synchronized fun watch(
+    watchedObject: Any,
+    name: String
+  ) {
+    if (!isEnabled()) {
+      return
+    }
+    removeWeaklyReachableObjects()
+    val key = UUID.randomUUID()
+        .toString()
+    val watchUptimeMillis = clock.uptimeMillis()
+    val reference =
+      KeyedWeakReference(watchedObject, key, name, watchUptimeMillis, queue)
+    CanaryLog.d(
+        "Watching %s with key %s",
+        ((if (watchedObject is Class<*>) watchedObject.toString() else "instance of ${watchedObject.javaClass.name}") + if (name.isNotEmpty()) " named $name" else ""), key
+    )
+
+    watchedObjects[key] = reference
+    checkRetainedExecutor.execute {
+      moveToRetained(key)
+    }
+  }
+
+  /**
+   * Clears all [KeyedWeakReference] that were created before [heapDumpUptimeMillis] (based on
+   * [clock] [Clock.uptimeMillis])
+   */
+  @Synchronized fun clearObjectsWatchedBefore(heapDumpUptimeMillis: Long) {
+    val weakRefsToRemove = watchedObjects.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
+    weakRefsToRemove.values.forEach { it.clear() }
+    watchedObjects.keys.removeAll(weakRefsToRemove.keys)
+  }
+
+  /**
+   * Clears all [KeyedWeakReference]
+   */
+  @Synchronized fun clearWatchedObjects() {
+    watchedObjects.values.forEach { it.clear() }
+    watchedObjects.clear()
+  }
+
+  @Synchronized private fun moveToRetained(key: String) {
+    removeWeaklyReachableObjects()
+    val retainedRef = watchedObjects[key]
+    if (retainedRef != null) {
+      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
+      onObjectRetainedListener.onObjectRetained()
+    }
+  }
+
+  private fun removeWeaklyReachableObjects() {
+    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+    // reachable. This is before finalization or garbage collection has actually happened.
+    var ref: KeyedWeakReference?
+    do {
+      ref = queue.poll() as KeyedWeakReference?
+      if (ref != null) {
+        watchedObjects.remove(ref.key)
+      }
+    } while (ref != null)
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt b/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
new file mode 100644
index 00000000..17412172
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
@@ -0,0 +1,12 @@
+package leakcanary
+
+/**
+ * Listener used by [ObjectWatcher] to report retained objects.
+ */
+interface OnObjectRetainedListener {
+
+  /**
+   * A watched object became retained.
+   */
+  fun onObjectRetained()
+}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
deleted file mode 100644
index 0cd4e8f1..00000000
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import java.lang.ref.ReferenceQueue
-import java.util.UUID
-import java.util.concurrent.Executor
-
-/**
- * Thread safe by locking on all methods, which is reasonably efficient given how often
- * these methods are accessed.
- */
-class RefWatcher constructor(
-  private val clock: Clock,
-  private val checkRetainedExecutor: Executor,
-  private val onInstanceRetained: () -> Unit,
-  /**
-   * Calls to [watch] will be ignored when [isEnabled] returns false
-   */
-  private val isEnabled: () -> Boolean = { true }
-) {
-
-  /**
-   * References passed to [watch].
-   */
-  private val watchedInstances = mutableMapOf<String, KeyedWeakReference>()
-
-  private val queue = ReferenceQueue<Any>()
-
-  /**
-   * Returns true if there are watched instances that aren't weakly reachable, and
-   * have been watched for long enough to be considered retained.
-   */
-  val hasRetainedInstances: Boolean
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.any { it.value.retainedUptimeMillis != -1L }
-    }
-
-  val retainedInstanceCount: Int
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.count { it.value.retainedUptimeMillis != -1L }
-    }
-
-  /**
-   * Returns true if there are watched instances that aren't weakly reachable, even
-   * if they haven't been watched for long enough to be considered retained.
-   */
-  val hasWatchedInstances: Boolean
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.isNotEmpty()
-    }
-
-  /**
-   * Returns the instances that are currently considered retained. Useful for logging purposes.
-   * Be careful with those instances and release them ASAP as you may creating longer lived leaks
-   * then the one that are already there.
-   */
-  val retainedInstances: List<Any>
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      val instances = mutableListOf<Any>()
-      for (weakReference in watchedInstances.values) {
-        if (weakReference.retainedUptimeMillis != -1L) {
-          val instance = weakReference.get()
-          if (instance != null) {
-            instances.add(instance)
-          }
-        }
-      }
-      return instances
-    }
-
-  /**
-   * Identical to [.watch] with an empty string reference name.
-   */
-  @Synchronized fun watch(watchedInstance: Any) {
-    watch(watchedInstance, "")
-  }
-
-  /**
-   * Watches the provided instances.
-   *
-   * @param name A logical identifier for the watched object.
-   */
-  @Synchronized fun watch(
-    watchedInstance: Any,
-    name: String
-  ) {
-    if (!isEnabled()) {
-      return
-    }
-    removeWeaklyReachableInstances()
-    val key = UUID.randomUUID()
-        .toString()
-    val watchUptimeMillis = clock.uptimeMillis()
-    val reference =
-      KeyedWeakReference(watchedInstance, key, name, watchUptimeMillis, queue)
-    CanaryLog.d(
-        "Watching %s with key %s",
-        ((if (watchedInstance is Class<*>) watchedInstance.toString() else "instance of ${watchedInstance.javaClass.name}") + if (name.isNotEmpty()) " named $name" else ""), key
-    )
-
-    watchedInstances[key] = reference
-    checkRetainedExecutor.execute {
-      moveToRetained(key)
-    }
-  }
-
-  @Synchronized private fun moveToRetained(key: String) {
-    removeWeaklyReachableInstances()
-    val retainedRef = watchedInstances[key]
-    if (retainedRef != null) {
-      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
-      onInstanceRetained()
-    }
-  }
-
-  @Synchronized fun removeInstancesWatchedBeforeHeapDump(heapDumpUptimeMillis: Long) {
-    val weakRefsToRemove = watchedInstances.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
-    weakRefsToRemove.values.forEach { it.clear() }
-    watchedInstances.keys.removeAll(weakRefsToRemove.keys)
-  }
-
-  @Synchronized fun clearWatchedInstances() {
-    watchedInstances.clear()
-  }
-
-  private fun removeWeaklyReachableInstances() {
-    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
-    // reachable. This is before finalization or garbage collection has actually happened.
-    var ref: KeyedWeakReference?
-    do {
-      ref = queue.poll() as KeyedWeakReference?
-      if (ref != null) {
-        watchedInstances.remove(ref.key)
-      }
-    } while (ref != null)
-  }
-}
diff --git a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt b/leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
similarity index 54%
rename from leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
rename to leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
index 2d76440b..614122a3 100644
--- a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
+++ b/leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
@@ -5,35 +5,36 @@ import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
 import java.util.concurrent.Executor
 
-class RefWatcherTest {
+class ObjectWatcherTest {
 
-  private val onRefRetained: () -> Unit = {
+  private val onInstanceRetained = object: OnObjectRetainedListener {
+    override fun onObjectRetained() {}
   }
 
   private val checkRetainedExecutor: Executor = Executor {
     it.run()
   }
 
-  val refWatcher = RefWatcher(object : Clock {
+  private val objectWatcher = ObjectWatcher(object : Clock {
     override fun uptimeMillis(): Long {
       return time
     }
-  }, checkRetainedExecutor, onRefRetained)
+  }, checkRetainedExecutor, onInstanceRetained)
   var time: Long = 0
 
   var ref: Any? = Any()
 
   @Test fun `unreachable object not retained`() {
-    refWatcher.watch(ref!!)
+    objectWatcher.watch(ref!!)
     ref = null
     runGc()
-    assertThat(refWatcher.hasRetainedInstances).isFalse()
+    assertThat(objectWatcher.hasRetainedObjects).isFalse()
   }
 
   @Test fun `reachable object retained`() {
-    refWatcher.watch(ref!!)
+    objectWatcher.watch(ref!!)
     runGc()
-    assertThat(refWatcher.hasRetainedInstances).isTrue()
+    assertThat(objectWatcher.hasRetainedObjects).isTrue()
   }
 
 }
\ No newline at end of file
diff --git a/mkdocs.yml b/mkdocs.yml
index 2741caf1..9a8ca1dc 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -46,6 +46,15 @@ nav:
   - 'Code recipes': recipes.md
   - 'FAQ': faq.md
   - 'Stack Overflow ⏏': https://stackoverflow.com/questions/tagged/leakcanary?sort=active
+  - 'API reference':
+    - 'LeakCanary': api/leakcanary-android-core/leakcanary/index.md
+    - 'LeakSentry': api/leakcanary-leaksentry/leakcanary/index.md
+    - 'Extension: Instrumentation tests': api/leakcanary-android-instrumentation/leakcanary/index.md
+    - 'Extension: Separate process': api/leakcanary-android-process/leakcanary/index.md
+    - 'Core: RefWatcher': api/leakcanary-watcher/leakcanary/index.md
+    - 'Core: Heap Analyzer': api/leakcanary-analyzer/leakcanary/index.md
+    - 'Core: Hprof Parser': api/leakcanary-haha/leakcanary/index.md
+    - 'Core: Logs': api/leakcanary-log/leakcanary/index.md
   - 'Change Log': changelog.md
   - 'Support': support.md
   - 'Upgrading to LeakCanary 2': upgrading-to-leakcanary-2.0.md
