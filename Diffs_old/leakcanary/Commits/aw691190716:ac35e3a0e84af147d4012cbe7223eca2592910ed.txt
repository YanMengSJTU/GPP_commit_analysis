diff --git a/.github/workflows/greetings.yml b/.github/workflows/greetings.yml
new file mode 100644
index 00000000..4ed1a9a8
--- /dev/null
+++ b/.github/workflows/greetings.yml
@@ -0,0 +1,13 @@
+name: Greetings
+
+on: [pull_request, issues]
+
+jobs:
+  greeting:
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/first-interaction@v1
+      with:
+        repo-token: ${{ secrets.GITHUB_TOKEN }}
+        issue-message: 'üôèThank you for opening an issue! LeakCanary is maintained by @pyricau with help from the community. Please be kind and remember that LeakCanary isn''t anyone''s main job üòò.'
+        pr-message: 'üôèThank you for your contribution! @pyricau will take a look üîé. Depending on his availability that might take a while üò¥, but don''t worry, your pull request will not be ignored.'
diff --git a/.travis.yml b/.travis.yml
index ee5ea2c7..950dee62 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -16,7 +16,11 @@ before_install:
   - echo no | avdmanager create avd --force -n test -k "system-images;android-16;default;armeabi-v7a"
   - $ANDROID_HOME/emulator/emulator -avd test -no-audio -no-window &
 
-install: ./gradlew clean build assembleAndroidTest --stacktrace
+install:
+  #Run tasks in sequence so that Gradle doesn't run 'clean' in parallel with 'build'
+  - ./gradlew clean
+  - ./gradlew build --stacktrace
+  - ./gradlew assembleAndroidTest --stacktrace
 
 before_script:
   - android-wait-for-emulator
diff --git a/build.gradle b/build.gradle
index cd06185f..0f3efbb0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,7 +5,7 @@ buildscript {
       'minSdk'    : 14,
       'compileSdk': 29,
       'errorProne': '2.3.1',
-      'kotlin'    : '1.3.21',
+      'kotlin'    : '1.3.50',
   ]
   ext.deps = [
       assertj_core  : 'org.assertj:assertj-core:3.9.1',
@@ -29,6 +29,7 @@ buildscript {
           gradlePlugin: "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}",
           stdlib      : "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
       ],
+      detekt        : 'io.gitlab.arturbosch.detekt:detekt-gradle-plugin:1.0.0-RC16',
       mockito       : 'org.mockito:mockito-core:2.7.5',
       mockito_kotlin: 'com.nhaarman:mockito-kotlin-kt1.1:1.5.0',
       okio: 'com.squareup.okio:okio:2.2.2',
@@ -41,9 +42,11 @@ buildscript {
   }
   dependencies {
     classpath deps.kotlin.gradlePlugin
-    classpath 'com.android.tools.build:gradle:3.4.0'
+    classpath 'com.android.tools.build:gradle:3.5.0'
     classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.16'
     classpath 'com.github.ben-manes:gradle-versions-plugin:0.20.0'
+    classpath "org.jetbrains.dokka:dokka-gradle-plugin:0.9.18"
+    classpath deps.detekt
   }
 }
 
@@ -61,6 +64,27 @@ subprojects {
   }
 
   apply plugin: 'net.ltgt.errorprone'
+  apply plugin: 'org.jetbrains.dokka'
+  apply plugin: 'io.gitlab.arturbosch.detekt'
+
+  dokka {
+    reportUndocumented = false
+    // BuildConfig files
+    packageOptions {
+      prefix = "com.squareup.leakcanary"
+      suppress = true
+    }
+    packageOptions {
+      prefix = "shark.internal"
+      suppress = true
+    }
+    packageOptions {
+      prefix = "leakcanary.internal"
+      suppress = true
+    }
+    outputFormat = 'gfm'
+    outputDirectory = "$rootDir/docs/api"
+  }
 
   tasks.withType(JavaCompile) {
     options.compilerArgs += [
@@ -94,7 +118,29 @@ subprojects {
     }
   }
 
+  detekt {
+    config = rootProject.files('detekt-config.yml')
+    parallel = true
+    reports {
+      xml.enabled = false
+    }
+  }
+
+  afterEvaluate {
+    tasks.getByName('check').dependsOn 'detekt'
+    tasks.getByName('assemble').dependsOn installGitHooks
+    tasks.getByName('clean').dependsOn installGitHooks
+  }
+
   dependencies {
     errorprone "com.google.errorprone:error_prone_core:${versions.errorProne}"
   }
 }
+
+//Copies git hooks from /hooks folder into .git; currently used to run Detekt during push
+//Git hook installation
+task installGitHooks(type: Copy) {
+  from new File(rootProject.rootDir, 'hooks')
+  into { new File(rootProject.rootDir, '.git/hooks') }
+  fileMode 0777 //Make files executable
+}
\ No newline at end of file
diff --git a/checkstyle.xml b/checkstyle.xml
deleted file mode 100644
index ce09c3d1..00000000
--- a/checkstyle.xml
+++ /dev/null
@@ -1,150 +0,0 @@
-<?xml version="1.0"?>
-<!--
-  Copyright (C) 2014 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-  -->
-<!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
-
-<module name="Checker">
-  <!--module name="NewlineAtEndOfFile"/-->
-  <module name="FileLength"/>
-  <module name="FileTabCharacter"/>
-
-  <!-- Trailing spaces -->
-  <module name="RegexpSingleline">
-    <property name="format" value="\s+$"/>
-    <property name="message" value="Line has trailing spaces."/>
-  </module>
-
-  <!-- Space after 'for' and 'if' -->
-  <module name="RegexpSingleline">
-    <property name="format" value="^\s*(for|if)[^ ]"/>
-    <property name="message" value="Space needed before opening parenthesis."/>
-  </module>
-
-  <!-- For each spacing -->
-  <module name="RegexpSingleline">
-    <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
-    <property name="message" value="Space needed around ':' character."/>
-  </module>
-
-  <module name="TreeWalker">
-    <!-- Checks for Javadoc comments.                     -->
-    <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-    <!--module name="JavadocMethod"/-->
-    <!--module name="JavadocType"/-->
-    <!--module name="JavadocVariable"/-->
-    <!--module name="JavadocStyle"/-->
-
-
-    <!-- Checks for Naming Conventions.                  -->
-    <!-- See http://checkstyle.sf.net/config_naming.html -->
-    <!--<module name="ConstantName"/>-->
-    <module name="LocalFinalVariableName"/>
-    <module name="LocalVariableName"/>
-    <module name="MemberName"/>
-    <module name="MethodName">
-      <property name="format" value="^[a-z][a-zA-Z0-9_]*$"/>
-    </module>
-    <module name="PackageName"/>
-    <module name="ParameterName"/>
-    <module name="StaticVariableName"/>
-    <module name="TypeName">
-      <property name="format" value="^[A-Z][a-zA-Z0-9_]*$"/>
-    </module>
-
-
-    <!-- Checks for imports                              -->
-    <!-- See http://checkstyle.sf.net/config_import.html -->
-    <module name="AvoidStarImport"/>
-    <module name="IllegalImport"/>
-    <module name="RedundantImport"/>
-    <module name="UnusedImports">
-      <property name="processJavadoc" value="true"/>
-    </module>
-
-
-    <!-- Checks for Size Violations.                    -->
-    <!-- See http://checkstyle.sf.net/config_sizes.html -->
-    <!--module name="LineLength"-->
-      <!--property name="max" value="100"/-->
-    <!--/module-->
-    <!--module name="MethodLength"/-->
-    <!--<module name="ParameterNumber"/>-->
-
-
-    <!-- Checks for whitespace                               -->
-    <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-    <module name="GenericWhitespace"/>
-    <module name="EmptyForIteratorPad"/>
-    <module name="MethodParamPad"/>
-    <!--<module name="NoWhitespaceAfter"/>-->
-    <!--<module name="NoWhitespaceBefore"/>-->
-    <module name="OperatorWrap"/>
-    <module name="ParenPad"/>
-    <module name="TypecastParenPad"/>
-    <module name="WhitespaceAfter"/>
-    <module name="WhitespaceAround"/>
-
-
-    <!-- Modifier Checks                                    -->
-    <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-    <!--module name="ModifierOrder"/-->
-    <module name="RedundantModifier"/>
-
-
-    <!-- Checks for blocks. You know, those {}'s         -->
-    <!-- See http://checkstyle.sf.net/config_blocks.html -->
-    <!--module name="AvoidNestedBlocks"/-->
-    <!--module name="EmptyBlock"/-->
-    <module name="LeftCurly"/>
-    <module name="NeedBraces"/>
-    <module name="RightCurly"/>
-
-
-    <!-- Checks for common coding problems               -->
-    <!-- See http://checkstyle.sf.net/config_coding.html -->
-    <!--module name="AvoidInlineConditionals"/-->
-    <module name="CovariantEquals"/>
-    <module name="EmptyStatement"/>
-    <!--module name="EqualsAvoidNull"/-->
-    <module name="EqualsHashCode"/>
-    <!--module name="HiddenField"/-->
-    <module name="IllegalInstantiation"/>
-    <!--<module name="InnerAssignment"/>-->
-    <!--module name="MagicNumber"/-->
-    <module name="MissingSwitchDefault"/>
-    <!--module name="RedundantThrows"/-->
-    <module name="SimplifyBooleanExpression"/>
-    <module name="SimplifyBooleanReturn"/>
-
-    <!-- Checks for class design                         -->
-    <!-- See http://checkstyle.sf.net/config_design.html -->
-    <!--module name="DesignForExtension"/-->
-    <!--module name="FinalClass"/-->
-    <module name="HideUtilityClassConstructor"/>
-    <!--module name="InterfaceIsType"/-->
-    <!--module name="VisibilityModifier"/-->
-
-
-    <!-- Miscellaneous other checks.                   -->
-    <!-- See http://checkstyle.sf.net/config_misc.html -->
-    <module name="ArrayTypeStyle"/>
-    <!--module name="FinalParameters"/-->
-    <!--module name="TodoComment"/-->
-    <module name="UpperEll"/>
-  </module>
-</module>
diff --git a/detekt-config.yml b/detekt-config.yml
new file mode 100644
index 00000000..b55d3d68
--- /dev/null
+++ b/detekt-config.yml
@@ -0,0 +1,564 @@
+build:
+  maxIssues: 1
+  weights:
+    # complexity: 2
+    # LongParameterList: 1
+    # style: 1
+    # comments: 1
+
+processors:
+  active: true
+  exclude:
+  # - 'FunctionCountProcessor'
+  # - 'PropertyCountProcessor'
+  # - 'ClassCountProcessor'
+  # - 'PackageCountProcessor'
+  # - 'KtFileCountProcessor'
+
+console-reports:
+  active: true
+  exclude:
+  #  - 'ProjectStatisticsReport'
+  #  - 'ComplexityReport'
+  #  - 'NotificationReport'
+  #  - 'FindingsReport'
+  #  - 'BuildFailureReport'
+
+comments:
+  active: true
+  excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  CommentOverPrivateFunction:
+    active: false
+  CommentOverPrivateProperty:
+    active: false
+  EndOfSentenceFormat:
+    active: false
+    endOfSentenceFormat: ([.?!][ \t\n\r\f<])|([.?!:]$)
+  UndocumentedPublicClass:
+    active: false
+    searchInNestedClass: true
+    searchInInnerClass: true
+    searchInInnerObject: true
+    searchInInnerInterface: true
+  UndocumentedPublicFunction:
+    active: false
+
+complexity:
+  active: true
+  ComplexCondition:
+    active: true
+    threshold: 4
+  ComplexInterface:
+    active: false
+    threshold: 10
+    includeStaticDeclarations: false
+  ComplexMethod:
+    #LeakCanary - increased allowed complexity from 10 to 30; enabled ignores
+    active: true
+    threshold: 30
+    ignoreSingleWhenExpression: true
+    ignoreSimpleWhenEntries: true
+  LabeledExpression:
+    active: false
+    ignoredLabels: ""
+  LargeClass:
+    active: true
+    threshold: 600
+  LongMethod:
+    #LeakCanary - increased from 60 to 90
+    active: true
+    threshold: 90
+  LongParameterList:
+    #LeakCanary - enabled ignore
+    active: true
+    threshold: 6
+    ignoreDefaultParameters: true
+  MethodOverloading:
+    active: false
+    threshold: 6
+  NestedBlockDepth:
+    #LeakCanary - increased from 4 to 7
+    active: true
+    threshold: 7
+  StringLiteralDuplication:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    threshold: 3
+    ignoreAnnotation: true
+    excludeStringsWithLessThan5Characters: true
+    ignoreStringsRegex: '$^'
+  TooManyFunctions:
+    #LeakCanary - increased from 11 to 12
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    thresholdInFiles: 12
+    thresholdInClasses: 12
+    thresholdInInterfaces: 12
+    thresholdInObjects: 12
+    thresholdInEnums: 12
+    ignoreDeprecated: false
+    ignorePrivate: false
+    ignoreOverridden: false
+
+empty-blocks:
+  active: true
+  EmptyCatchBlock:
+    active: true
+    allowedExceptionNameRegex: "^(_|(ignore|expected).*)"
+  EmptyClassBlock:
+    active: true
+  EmptyDefaultConstructor:
+    active: true
+  EmptyDoWhileBlock:
+    active: true
+  EmptyElseBlock:
+    active: true
+  EmptyFinallyBlock:
+    active: true
+  EmptyForBlock:
+    active: true
+  EmptyFunctionBlock:
+    #LeakCanary - allow empty overridden functions
+    active: true
+    ignoreOverriddenFunctions: true
+  EmptyIfBlock:
+    active: true
+  EmptyInitBlock:
+    active: true
+  EmptyKtFile:
+    active: true
+  EmptySecondaryConstructor:
+    active: true
+  EmptyWhenBlock:
+    active: true
+  EmptyWhileBlock:
+    active: true
+
+exceptions:
+  active: true
+  ExceptionRaisedInUnexpectedLocation:
+    active: false
+    methodNames: 'toString,hashCode,equals,finalize'
+  InstanceOfCheckForException:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  NotImplementedDeclaration:
+    active: false
+  PrintStackTrace:
+    active: false
+  RethrowCaughtException:
+    active: false
+  ReturnFromFinally:
+    active: false
+  SwallowedException:
+    active: false
+    ignoredExceptionTypes: 'InterruptedException,NumberFormatException,ParseException,MalformedURLException'
+  ThrowingExceptionFromFinally:
+    active: false
+  ThrowingExceptionInMain:
+    active: false
+  ThrowingExceptionsWithoutMessageOrCause:
+    active: false
+    exceptions: 'IllegalArgumentException,IllegalStateException,IOException'
+  ThrowingNewInstanceOfSameException:
+    active: false
+  TooGenericExceptionCaught:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    exceptionNames:
+     - ArrayIndexOutOfBoundsException
+     - Error
+     - Exception
+     - IllegalMonitorStateException
+     - NullPointerException
+     - IndexOutOfBoundsException
+     - RuntimeException
+     - Throwable
+    allowedExceptionNameRegex: "^(_|(ignore|expected).*)"
+  TooGenericExceptionThrown:
+    #LeakCanary - disabled
+    active: false
+    exceptionNames:
+     - Error
+     - Exception
+     - Throwable
+     - RuntimeException
+
+formatting:
+  active: true
+  android: false
+  autoCorrect: true
+  AnnotationOnSeparateLine:
+    active: false
+  ChainWrapping:
+    active: true
+    autoCorrect: true
+  CommentSpacing:
+    active: true
+    autoCorrect: true
+  Filename:
+    active: true
+  FinalNewline:
+    active: true
+    autoCorrect: true
+  ImportOrdering:
+    active: false
+  Indentation:
+    active: false
+    indentSize: 4
+    continuationIndentSize: 4
+  MaximumLineLength:
+    active: true
+    maxLineLength: 120
+  ModifierOrdering:
+    active: true
+    autoCorrect: true
+  MultiLineIfElse:
+    active: true
+    autoCorrect: true
+  NoBlankLineBeforeRbrace:
+    active: true
+    autoCorrect: true
+  NoConsecutiveBlankLines:
+    active: true
+    autoCorrect: true
+  NoEmptyClassBody:
+    active: true
+    autoCorrect: true
+  NoItParamInMultilineLambda:
+    active: false
+  NoLineBreakAfterElse:
+    active: true
+    autoCorrect: true
+  NoLineBreakBeforeAssignment:
+    active: true
+    autoCorrect: true
+  NoMultipleSpaces:
+    active: true
+    autoCorrect: true
+  NoSemicolons:
+    active: true
+    autoCorrect: true
+  NoTrailingSpaces:
+    active: true
+    autoCorrect: true
+  NoUnitReturn:
+    active: true
+    autoCorrect: true
+  NoUnusedImports:
+    active: true
+    autoCorrect: true
+  NoWildcardImports:
+    active: true
+    autoCorrect: true
+  PackageName:
+    active: true
+    autoCorrect: true
+  ParameterListWrapping:
+    active: true
+    autoCorrect: true
+    indentSize: 4
+  SpacingAroundColon:
+    active: true
+    autoCorrect: true
+  SpacingAroundComma:
+    active: true
+    autoCorrect: true
+  SpacingAroundCurly:
+    active: true
+    autoCorrect: true
+  SpacingAroundDot:
+    active: true
+    autoCorrect: true
+  SpacingAroundKeyword:
+    active: true
+    autoCorrect: true
+  SpacingAroundOperators:
+    active: true
+    autoCorrect: true
+  SpacingAroundParens:
+    active: true
+    autoCorrect: true
+  SpacingAroundRangeOperator:
+    active: true
+    autoCorrect: true
+  SpacingAroundUnaryOperators:
+    active: true
+    autoCorrect: true
+  StringTemplate:
+    active: true
+    autoCorrect: true
+
+naming:
+  active: true
+  ClassNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    classPattern: '[A-Z$][a-zA-Z0-9$]*'
+  ConstructorParameterNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    parameterPattern: '[a-z][A-Za-z0-9]*'
+    privateParameterPattern: '[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+  EnumNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    enumEntryPattern: '^[A-Z][_a-zA-Z0-9]*'
+  ForbiddenClassName:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    forbiddenName: ''
+  FunctionMaxLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    maximumFunctionNameLength: 30
+  FunctionMinLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    minimumFunctionNameLength: 3
+  FunctionNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    functionPattern: '^([a-z$][a-zA-Z$0-9]*)|(`.*`)$'
+    excludeClassPattern: '$^'
+    ignoreOverridden: true
+  FunctionParameterNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    parameterPattern: '[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+    ignoreOverriddenFunctions: true
+  InvalidPackageDeclaration:
+    active: false
+    rootPackage: ''
+  MatchingDeclarationName:
+    active: true
+  MemberNameEqualsClassName:
+    active: false
+    ignoreOverriddenFunction: true
+  ObjectPropertyNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    constantPattern: '[A-Za-z][_A-Za-z0-9]*'
+    propertyPattern: '[A-Za-z][_A-Za-z0-9]*'
+    privatePropertyPattern: '(_)?[A-Za-z][_A-Za-z0-9]*'
+  PackageNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    packagePattern: '^[a-z]+(\.[a-z][A-Za-z0-9]*)*$'
+  TopLevelPropertyNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    constantPattern: '[A-Z][_A-Z0-9]*'
+    propertyPattern: '[A-Za-z][_A-Za-z0-9]*'
+    privatePropertyPattern: '_?[A-Za-z][_A-Za-z0-9]*'
+  VariableMaxLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    maximumVariableNameLength: 64
+  VariableMinLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    minimumVariableNameLength: 1
+  VariableNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    variablePattern: '[a-z][A-Za-z0-9]*'
+    privateVariablePattern: '(_)?[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+    ignoreOverridden: true
+
+performance:
+  active: true
+  ArrayPrimitive:
+    active: false
+  ForEachOnRange:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  SpreadOperator:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  UnnecessaryTemporaryInstantiation:
+    active: true
+
+potential-bugs:
+  active: true
+  DuplicateCaseInWhenExpression:
+    active: true
+  EqualsAlwaysReturnsTrueOrFalse:
+    active: false
+  EqualsWithHashCodeExist:
+    active: true
+  ExplicitGarbageCollectionCall:
+    #LeakCanary - we want to trigger GC manually
+    active: false
+  InvalidRange:
+    active: false
+  IteratorHasNextCallsNextMethod:
+    active: false
+  IteratorNotThrowingNoSuchElementException:
+    active: false
+  LateinitUsage:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    excludeAnnotatedProperties: ""
+    ignoreOnClassesPattern: ""
+  MissingWhenCase:
+    active: false
+  RedundantElseInWhen:
+    active: false
+  UnconditionalJumpStatementInLoop:
+    active: false
+  UnreachableCode:
+    active: true
+  UnsafeCallOnNullableType:
+    active: false
+  UnsafeCast:
+    active: false
+  UselessPostfixExpression:
+    active: false
+  WrongEqualsTypeParameter:
+    active: false
+
+style:
+  active: true
+  CollapsibleIfStatements:
+    active: false
+  DataClassContainsFunctions:
+    active: false
+    conversionFunctionPrefix: 'to'
+  DataClassShouldBeImmutable:
+    active: false
+  EqualsNullCall:
+    active: false
+  EqualsOnSignatureLine:
+    active: false
+  ExplicitItLambdaParameter:
+    active: false
+  ExpressionBodySyntax:
+    active: false
+    includeLineWrapping: false
+  ForbiddenComment:
+    active: true
+    values: 'TODO:,FIXME:,STOPSHIP:'
+  ForbiddenImport:
+    active: false
+    imports: ''
+  ForbiddenVoid:
+    active: false
+    ignoreOverridden: false
+  FunctionOnlyReturningConstant:
+    active: false
+    ignoreOverridableFunction: true
+    excludedFunctions: 'describeContents'
+  LibraryCodeMustSpecifyReturnType:
+    active: false
+  LoopWithTooManyJumpStatements:
+    active: false
+    maxJumpCount: 1
+  MagicNumber:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    ignoreNumbers: '-1,0,1,2'
+    ignoreHashCodeFunction: true
+    ignorePropertyDeclaration: false
+    ignoreConstantDeclaration: true
+    ignoreCompanionObjectPropertyDeclaration: true
+    ignoreAnnotation: false
+    ignoreNamedArgument: true
+    ignoreEnums: false
+    ignoreRanges: false
+  MandatoryBracesIfStatements:
+    active: false
+  MaxLineLength:
+    #LeakCanary - increased from 120 to 150
+    active: true
+    maxLineLength: 150
+    excludePackageStatements: true
+    excludeImportStatements: true
+    excludeCommentStatements: false
+  MayBeConst:
+    active: false
+  ModifierOrder:
+    active: true
+  NestedClassesVisibility:
+    active: false
+  NewLineAtEndOfFile:
+    #LeakCanary - disabled
+    active: false
+  NoTabs:
+    active: false
+  OptionalAbstractKeyword:
+    active: true
+  OptionalUnit:
+    active: false
+  OptionalWhenBraces:
+    active: false
+  PreferToOverPairSyntax:
+    active: false
+  ProtectedMemberInFinalClass:
+    active: false
+  RedundantVisibilityModifierRule:
+    active: false
+  ReturnCount:
+    #LeakCanary - increased from 2 to 4
+    active: true
+    max: 4
+    excludedFunctions: "equals"
+    excludeLabeled: false
+    excludeReturnFromLambda: true
+  SafeCast:
+    active: true
+  SerialVersionUIDInSerializableClass:
+    active: false
+  SpacingBetweenPackageAndImports:
+    active: false
+  ThrowsCount:
+    active: true
+    max: 2
+  TrailingWhitespace:
+    active: false
+  UnderscoresInNumericLiterals:
+    active: false
+    acceptableDecimalLength: 5
+  UnnecessaryAbstractClass:
+    active: false
+    excludeAnnotatedClasses: "dagger.Module"
+  UnnecessaryApply:
+    active: false
+  UnnecessaryInheritance:
+    active: false
+  UnnecessaryLet:
+    active: false
+  UnnecessaryParentheses:
+    active: false
+  UntilInsteadOfRangeTo:
+    active: false
+  UnusedImports:
+    active: false
+  UnusedPrivateClass:
+    active: false
+  UnusedPrivateMember:
+    active: false
+    allowedNames: "(_|ignored|expected|serialVersionUID)"
+  UseCheckOrError:
+    active: false
+  UseDataClass:
+    active: false
+    excludeAnnotatedClasses: ""
+  UseRequire:
+    active: false
+  UselessCallOnNotNull:
+    active: false
+  UtilityClassWithPublicConstructor:
+    active: false
+  VarCouldBeVal:
+    active: false
+  WildcardImport:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    excludeImports: 'java.util.*,kotlinx.android.synthetic.*'
diff --git a/docs/api/leakcanary-android-core/alltypes/index.md b/docs/api/leakcanary-android-core/alltypes/index.md
new file mode 100644
index 00000000..d8a17d88
--- /dev/null
+++ b/docs/api/leakcanary-android-core/alltypes/index.md
@@ -0,0 +1,9 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [leakcanary.DefaultOnHeapAnalyzedListener](../leakcanary/-default-on-heap-analyzed-listener/index.md) | Default [OnHeapAnalyzedListener](../leakcanary/-on-heap-analyzed-listener/index.md) implementation, which will store the analysis to disk and show a notification summarizing the result. |
+| [leakcanary.LeakCanary](../leakcanary/-leak-canary/index.md) | The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher](#). AppWatcher notifies LeakCanary of retained instances, which in turns dumps the heap, analyses it and publishes the results. |
+| [leakcanary.OnHeapAnalyzedListener](../leakcanary/-on-heap-analyzed-listener/index.md) | Listener set in [LeakCanary.Config](../leakcanary/-leak-canary/-config/index.md) and called by LeakCanary on a background thread when the heap analysis is complete. |
diff --git a/docs/api/leakcanary-android-core/index.md b/docs/api/leakcanary-android-core/index.md
new file mode 100644
index 00000000..d953c84f
--- /dev/null
+++ b/docs/api/leakcanary-android-core/index.md
@@ -0,0 +1,11 @@
+[leakcanary-android-core](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [leakcanary](leakcanary/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/-init-.md b/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/-init-.md
new file mode 100644
index 00000000..db18098c
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/-init-.md
@@ -0,0 +1,9 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [DefaultOnHeapAnalyzedListener](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`DefaultOnHeapAnalyzedListener(application: Application)`
+
+Default [OnHeapAnalyzedListener](../-on-heap-analyzed-listener/index.md) implementation, which will store the analysis to disk and
+show a notification summarizing the result.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/create.md b/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/create.md
new file mode 100644
index 00000000..e263a048
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/create.md
@@ -0,0 +1,5 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [DefaultOnHeapAnalyzedListener](index.md) / [create](./create.md)
+
+# create
+
+`fun create(): `[`OnHeapAnalyzedListener`](../-on-heap-analyzed-listener/index.md)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/index.md b/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/index.md
new file mode 100644
index 00000000..85ae5b0c
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/index.md
@@ -0,0 +1,26 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [DefaultOnHeapAnalyzedListener](./index.md)
+
+# DefaultOnHeapAnalyzedListener
+
+`class DefaultOnHeapAnalyzedListener : `[`OnHeapAnalyzedListener`](../-on-heap-analyzed-listener/index.md)
+
+Default [OnHeapAnalyzedListener](../-on-heap-analyzed-listener/index.md) implementation, which will store the analysis to disk and
+show a notification summarizing the result.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `DefaultOnHeapAnalyzedListener(application: Application)`<br>Default [OnHeapAnalyzedListener](../-on-heap-analyzed-listener/index.md) implementation, which will store the analysis to disk and show a notification summarizing the result. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [onHeapAnalyzed](on-heap-analyzed.md) | `fun onHeapAnalyzed(heapAnalysis: HeapAnalysis): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [create](create.md) | `fun create(): `[`OnHeapAnalyzedListener`](../-on-heap-analyzed-listener/index.md) |
diff --git a/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/on-heap-analyzed.md b/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/on-heap-analyzed.md
new file mode 100644
index 00000000..d899c0a0
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/on-heap-analyzed.md
@@ -0,0 +1,12 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [DefaultOnHeapAnalyzedListener](index.md) / [onHeapAnalyzed](./on-heap-analyzed.md)
+
+# onHeapAnalyzed
+
+`fun onHeapAnalyzed(heapAnalysis: HeapAnalysis): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Overrides [OnHeapAnalyzedListener.onHeapAnalyzed](../-on-heap-analyzed-listener/on-heap-analyzed.md)
+
+**See Also**
+
+[OnHeapAnalyzedListener](../-on-heap-analyzed-listener/index.md)
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/-init-.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/-init-.md
new file mode 100644
index 00000000..e5aad7fb
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/-init-.md
@@ -0,0 +1,12 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`Config(dumpHeap: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, dumpHeapWhenDebugging: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = false, retainedVisibleThreshold: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)` = 5, referenceMatchers: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher> = AndroidReferenceMatchers.appDefaults, objectInspectors: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ObjectInspector> = AndroidObjectInspectors.appDefaults, onHeapAnalyzedListener: `[`OnHeapAnalyzedListener`](../../-on-heap-analyzed-listener/index.md)` = DefaultOnHeapAnalyzedListener.create(), computeRetainedHeapSize: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, maxStoredHeapDumps: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)` = 7, requestWriteExternalStoragePermission: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = false, useExperimentalLeakFinders: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = false)`
+
+LeakCanary configuration data class. Properties can be updated via [copy](#).
+
+**See Also**
+
+[config](../config.md)
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/compute-retained-heap-size.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/compute-retained-heap-size.md
new file mode 100644
index 00000000..9bd08722
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/compute-retained-heap-size.md
@@ -0,0 +1,16 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [computeRetainedHeapSize](./compute-retained-heap-size.md)
+
+# computeRetainedHeapSize
+
+`val computeRetainedHeapSize: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether to compute the retained heap size, which is the total number of bytes in memory that
+would be reclaimed if the detected leaks didn't happen. This includes native memory
+associated to Java objects (e.g. Android bitmaps).
+
+Computing the retained heap size can slow down the analysis because it requires navigating
+from GC roots through the entire object graph, whereas [shark.HeapAnalyzer](#) would otherwise
+stop as soon as all leaking instances are found.
+
+Defaults to true.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/dump-heap-when-debugging.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/dump-heap-when-debugging.md
new file mode 100644
index 00000000..4ad3289f
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/dump-heap-when-debugging.md
@@ -0,0 +1,12 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [dumpHeapWhenDebugging](./dump-heap-when-debugging.md)
+
+# dumpHeapWhenDebugging
+
+`val dumpHeapWhenDebugging: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+If [dumpHeapWhenDebugging](./dump-heap-when-debugging.md) is false then LeakCanary will not dump the heap
+when the debugger is attached. The debugger can create temporary memory leaks (for instance
+if a thread is blocked on a breakpoint).
+
+Defaults to false.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/dump-heap.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/dump-heap.md
new file mode 100644
index 00000000..699e0a1e
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/dump-heap.md
@@ -0,0 +1,12 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [dumpHeap](./dump-heap.md)
+
+# dumpHeap
+
+`val dumpHeap: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether LeakCanary should dump the heap when enough retained instances are found. This needs
+to be true for LeakCanary to work, but sometimes you may want to temporarily disable
+LeakCanary (e.g. for a product demo).
+
+Defaults to true.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/index.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/index.md
new file mode 100644
index 00000000..e69d9f9f
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/index.md
@@ -0,0 +1,32 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](./index.md)
+
+# Config
+
+`data class Config`
+
+LeakCanary configuration data class. Properties can be updated via [copy](#).
+
+**See Also**
+
+[config](../config.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `Config(dumpHeap: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, dumpHeapWhenDebugging: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = false, retainedVisibleThreshold: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)` = 5, referenceMatchers: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher> = AndroidReferenceMatchers.appDefaults, objectInspectors: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ObjectInspector> = AndroidObjectInspectors.appDefaults, onHeapAnalyzedListener: `[`OnHeapAnalyzedListener`](../../-on-heap-analyzed-listener/index.md)` = DefaultOnHeapAnalyzedListener.create(), computeRetainedHeapSize: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, maxStoredHeapDumps: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)` = 7, requestWriteExternalStoragePermission: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = false, useExperimentalLeakFinders: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = false)`<br>LeakCanary configuration data class. Properties can be updated via [copy](#). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [computeRetainedHeapSize](compute-retained-heap-size.md) | `val computeRetainedHeapSize: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether to compute the retained heap size, which is the total number of bytes in memory that would be reclaimed if the detected leaks didn't happen. This includes native memory associated to Java objects (e.g. Android bitmaps). |
+| [dumpHeap](dump-heap.md) | `val dumpHeap: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether LeakCanary should dump the heap when enough retained instances are found. This needs to be true for LeakCanary to work, but sometimes you may want to temporarily disable LeakCanary (e.g. for a product demo). |
+| [dumpHeapWhenDebugging](dump-heap-when-debugging.md) | `val dumpHeapWhenDebugging: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>If [dumpHeapWhenDebugging](dump-heap-when-debugging.md) is false then LeakCanary will not dump the heap when the debugger is attached. The debugger can create temporary memory leaks (for instance if a thread is blocked on a breakpoint). |
+| [maxStoredHeapDumps](max-stored-heap-dumps.md) | `val maxStoredHeapDumps: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>How many heap dumps are kept on the Android device for this app package. When this threshold is reached LeakCanary deletes the older heap dumps. As several heap dumps may be enqueued you should avoid going down to 1 or 2. |
+| [objectInspectors](object-inspectors.md) | `val objectInspectors: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ObjectInspector>`<br>List of [ObjectInspector](#) that provide LeakCanary with insights about objects found in the heap. You can create your own [ObjectInspector](#) implementations, and also add a [shark.AppSingletonInspector](#) instance created with the list of internal singletons. |
+| [onHeapAnalyzedListener](on-heap-analyzed-listener.md) | `val onHeapAnalyzedListener: `[`OnHeapAnalyzedListener`](../../-on-heap-analyzed-listener/index.md)<br>Called on a background thread when the heap analysis is complete. If you want leaks to be added to the activity that lists leaks, make sure to delegate calls to a [DefaultOnHeapAnalyzedListener](../../-default-on-heap-analyzed-listener/index.md). |
+| [referenceMatchers](reference-matchers.md) | `val referenceMatchers: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher>`<br>Known patterns of references in the heap, lister here either to ignore them ([IgnoredReferenceMatcher](#)) or to mark them as library leaks ([LibraryLeakReferenceMatcher](#)). |
+| [requestWriteExternalStoragePermission](request-write-external-storage-permission.md) | `val requestWriteExternalStoragePermission: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>LeakCanary always attempts to store heap dumps on the external storage if the WRITE_EXTERNAL_STORAGE is already granted, and otherwise uses the app storage. If the WRITE_EXTERNAL_STORAGE permission is not granted and [requestWriteExternalStoragePermission](request-write-external-storage-permission.md) is true, then LeakCanary will display a notification to ask for that permission. |
+| [retainedVisibleThreshold](retained-visible-threshold.md) | `val retainedVisibleThreshold: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>When the app is visible, LeakCanary will wait for at least [retainedVisibleThreshold](retained-visible-threshold.md) retained instances before dumping the heap. Dumping the heap freezes the UI and can be frustrating for developers who are trying to work. This is especially frustrating as the Android Framework has a number of leaks that cannot easily be fixed. |
+| [useExperimentalLeakFinders](use-experimental-leak-finders.md) | `val useExperimentalLeakFinders: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>When true, [objectInspectors](object-inspectors.md) are used to find leaks instead of only checking instances tracked by [KeyedWeakReference](#). This leads to finding more leaks and shorter leak traces. However this also means the same leaking instances will be found in every heap dump for a given process life. |
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/max-stored-heap-dumps.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/max-stored-heap-dumps.md
new file mode 100644
index 00000000..932c8670
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/max-stored-heap-dumps.md
@@ -0,0 +1,12 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [maxStoredHeapDumps](./max-stored-heap-dumps.md)
+
+# maxStoredHeapDumps
+
+`val maxStoredHeapDumps: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+How many heap dumps are kept on the Android device for this app package. When this threshold
+is reached LeakCanary deletes the older heap dumps. As several heap dumps may be enqueued
+you should avoid going down to 1 or 2.
+
+Defaults to 7.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/object-inspectors.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/object-inspectors.md
new file mode 100644
index 00000000..fa9daa04
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/object-inspectors.md
@@ -0,0 +1,12 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [objectInspectors](./object-inspectors.md)
+
+# objectInspectors
+
+`val objectInspectors: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ObjectInspector>`
+
+List of [ObjectInspector](#) that provide LeakCanary with insights about objects found in the
+heap. You can create your own [ObjectInspector](#) implementations, and also add
+a [shark.AppSingletonInspector](#) instance created with the list of internal singletons.
+
+Defaults to [AndroidObjectInspectors.appDefaults](#)
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/on-heap-analyzed-listener.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/on-heap-analyzed-listener.md
new file mode 100644
index 00000000..7f9c0a00
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/on-heap-analyzed-listener.md
@@ -0,0 +1,12 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [onHeapAnalyzedListener](./on-heap-analyzed-listener.md)
+
+# onHeapAnalyzedListener
+
+`val onHeapAnalyzedListener: `[`OnHeapAnalyzedListener`](../../-on-heap-analyzed-listener/index.md)
+
+Called on a background thread when the heap analysis is complete.
+If you want leaks to be added to the activity that lists leaks, make sure to delegate
+calls to a [DefaultOnHeapAnalyzedListener](../../-default-on-heap-analyzed-listener/index.md).
+
+Defaults to [DefaultOnHeapAnalyzedListener](../../-default-on-heap-analyzed-listener/index.md)
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/reference-matchers.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/reference-matchers.md
new file mode 100644
index 00000000..cd915e79
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/reference-matchers.md
@@ -0,0 +1,16 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [referenceMatchers](./reference-matchers.md)
+
+# referenceMatchers
+
+`val referenceMatchers: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher>`
+
+Known patterns of references in the heap, lister here either to ignore them
+([IgnoredReferenceMatcher](#)) or to mark them as library leaks ([LibraryLeakReferenceMatcher](#)).
+
+When adding your own custom [LibraryLeakReferenceMatcher](#) instances, you'll most
+likely want to set [LibraryLeakReferenceMatcher.patternApplies](#) with a filter that checks
+for the Android OS version and manufacturer. The build information can be obtained by calling
+[shark.AndroidBuildMirror.fromHeapGraph](#).
+
+Defaults to [AndroidReferenceMatchers.appDefaults](#)
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/request-write-external-storage-permission.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/request-write-external-storage-permission.md
new file mode 100644
index 00000000..d5550495
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/request-write-external-storage-permission.md
@@ -0,0 +1,14 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [requestWriteExternalStoragePermission](./request-write-external-storage-permission.md)
+
+# requestWriteExternalStoragePermission
+
+`val requestWriteExternalStoragePermission: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+LeakCanary always attempts to store heap dumps on the external storage if the
+WRITE_EXTERNAL_STORAGE is already granted, and otherwise uses the app storage.
+If the WRITE_EXTERNAL_STORAGE permission is not granted and
+[requestWriteExternalStoragePermission](./request-write-external-storage-permission.md) is true, then LeakCanary will display a notification
+to ask for that permission.
+
+Defaults to false because that permission notification can be annoying.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/retained-visible-threshold.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/retained-visible-threshold.md
new file mode 100644
index 00000000..ab4b347b
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/retained-visible-threshold.md
@@ -0,0 +1,22 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [retainedVisibleThreshold](./retained-visible-threshold.md)
+
+# retainedVisibleThreshold
+
+`val retainedVisibleThreshold: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+When the app is visible, LeakCanary will wait for at least
+[retainedVisibleThreshold](./retained-visible-threshold.md) retained instances before dumping the heap. Dumping the heap
+freezes the UI and can be frustrating for developers who are trying to work. This is
+especially frustrating as the Android Framework has a number of leaks that cannot easily
+be fixed.
+
+When the app becomes invisible, LeakCanary dumps the heap after
+[AppWatcher.Config.watchDurationMillis](#) ms.
+
+The app is considered visible if it has at least one activity in started state.
+
+A higher threshold means LeakCanary will dump the heap less often, therefore it won't be
+bothering developers as much but it could miss some leaks.
+
+Defaults to 5.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/use-experimental-leak-finders.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/use-experimental-leak-finders.md
new file mode 100644
index 00000000..eaf321e0
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/-config/use-experimental-leak-finders.md
@@ -0,0 +1,13 @@
+[leakcanary-android-core](../../../index.md) / [leakcanary](../../index.md) / [LeakCanary](../index.md) / [Config](index.md) / [useExperimentalLeakFinders](./use-experimental-leak-finders.md)
+
+# useExperimentalLeakFinders
+
+`val useExperimentalLeakFinders: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+When true, [objectInspectors](object-inspectors.md) are used to find leaks instead of only checking instances
+tracked by [KeyedWeakReference](#). This leads to finding more leaks and shorter leak traces.
+However this also means the same leaking instances will be found in every heap dump for a
+given process life.
+
+Defaults to false.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/config.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/config.md
new file mode 100644
index 00000000..d7cf349f
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/config.md
@@ -0,0 +1,13 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [LeakCanary](index.md) / [config](./config.md)
+
+# config
+
+`var config: `[`LeakCanary.Config`](-config/index.md)
+
+The current LeakCanary configuration. Can be updated at any time, usually by replacing it with
+a mutated copy, e.g.:
+
+```
+LeakCanary.config = LeakCanary.config.copy(computeRetainedHeapSize = true)
+```
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/dump-heap.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/dump-heap.md
new file mode 100644
index 00000000..71c4ccc4
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/dump-heap.md
@@ -0,0 +1,10 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [LeakCanary](index.md) / [dumpHeap](./dump-heap.md)
+
+# dumpHeap
+
+`fun dumpHeap(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Immediately triggers a heap dump and analysis, if there is at least one retained instance
+tracked by [AppWatcher.objectWatcher](#). If there are no retained instances then the heap will not
+be dumped and a notification will be shown instead.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/index.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/index.md
new file mode 100644
index 00000000..c957571f
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/index.md
@@ -0,0 +1,31 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [LeakCanary](./index.md)
+
+# LeakCanary
+
+`object LeakCanary`
+
+The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher](#). AppWatcher
+notifies LeakCanary of retained instances, which in turns dumps the heap, analyses it and
+publishes the results.
+
+LeakCanary can be configured by updating [config](config.md).
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Config](-config/index.md) | `data class Config`<br>LeakCanary configuration data class. Properties can be updated via [copy](#). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [config](config.md) | `var config: `[`LeakCanary.Config`](-config/index.md)<br>The current LeakCanary configuration. Can be updated at any time, usually by replacing it with a mutated copy, e.g.: |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [dumpHeap](dump-heap.md) | `fun dumpHeap(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Immediately triggers a heap dump and analysis, if there is at least one retained instance tracked by [AppWatcher.objectWatcher](#). If there are no retained instances then the heap will not be dumped and a notification will be shown instead. |
+| [newLeakDisplayActivityIntent](new-leak-display-activity-intent.md) | `fun newLeakDisplayActivityIntent(): Intent`<br>Returns a new [Intent](#) that can be used to programmatically launch the leak display activity. |
+| [showLeakDisplayActivityLauncherIcon](show-leak-display-activity-launcher-icon.md) | `fun showLeakDisplayActivityLauncherIcon(showLauncherIcon: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Dynamically shows / hides the launcher icon for the leak display activity. Note: you can change the default value by overriding the leak_canary_add_launcher_icon boolean resource: |
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/new-leak-display-activity-intent.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/new-leak-display-activity-intent.md
new file mode 100644
index 00000000..e219909d
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/new-leak-display-activity-intent.md
@@ -0,0 +1,8 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [LeakCanary](index.md) / [newLeakDisplayActivityIntent](./new-leak-display-activity-intent.md)
+
+# newLeakDisplayActivityIntent
+
+`fun newLeakDisplayActivityIntent(): Intent`
+
+Returns a new [Intent](#) that can be used to programmatically launch the leak display activity.
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-leak-canary/show-leak-display-activity-launcher-icon.md b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/show-leak-display-activity-launcher-icon.md
new file mode 100644
index 00000000..05bd1d95
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-leak-canary/show-leak-display-activity-launcher-icon.md
@@ -0,0 +1,17 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [LeakCanary](index.md) / [showLeakDisplayActivityLauncherIcon](./show-leak-display-activity-launcher-icon.md)
+
+# showLeakDisplayActivityLauncherIcon
+
+`fun showLeakDisplayActivityLauncherIcon(showLauncherIcon: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Dynamically shows / hides the launcher icon for the leak display activity.
+Note: you can change the default value by overriding the leak_canary_add_launcher_icon
+boolean resource:
+
+```
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <bool name="leak_canary_add_launcher_icon">false</bool>
+</resources>
+```
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/index.md b/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/index.md
new file mode 100644
index 00000000..b9016e7c
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/index.md
@@ -0,0 +1,28 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [OnHeapAnalyzedListener](./index.md)
+
+# OnHeapAnalyzedListener
+
+`interface OnHeapAnalyzedListener`
+
+Listener set in [LeakCanary.Config](../-leak-canary/-config/index.md) and called by LeakCanary on a background thread when the
+heap analysis is complete.
+
+You can create a [OnHeapAnalyzedListener](./index.md) from a lambda by calling [invoke](invoke.md).
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [onHeapAnalyzed](on-heap-analyzed.md) | `abstract fun onHeapAnalyzed(heapAnalysis: HeapAnalysis): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [invoke](invoke.md) | `operator fun invoke(block: (HeapAnalysis) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`OnHeapAnalyzedListener`](./index.md)<br>Utility function to create a [OnHeapAnalyzedListener](./index.md) from the passed in [block](invoke.md#leakcanary.OnHeapAnalyzedListener.Companion$invoke(kotlin.Function1((shark.HeapAnalysis, kotlin.Unit)))/block) lambda instead of using the anonymous `object : OnHeapAnalyzedListener` syntax. |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [DefaultOnHeapAnalyzedListener](../-default-on-heap-analyzed-listener/index.md) | `class DefaultOnHeapAnalyzedListener : `[`OnHeapAnalyzedListener`](./index.md)<br>Default [OnHeapAnalyzedListener](./index.md) implementation, which will store the analysis to disk and show a notification summarizing the result. |
diff --git a/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/invoke.md b/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/invoke.md
new file mode 100644
index 00000000..b24934d0
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/invoke.md
@@ -0,0 +1,17 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [OnHeapAnalyzedListener](index.md) / [invoke](./invoke.md)
+
+# invoke
+
+`inline operator fun invoke(crossinline block: (HeapAnalysis) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`OnHeapAnalyzedListener`](index.md)
+
+Utility function to create a [OnHeapAnalyzedListener](index.md) from the passed in [block](invoke.md#leakcanary.OnHeapAnalyzedListener.Companion$invoke(kotlin.Function1((shark.HeapAnalysis, kotlin.Unit)))/block) lambda
+instead of using the anonymous `object : OnHeapAnalyzedListener` syntax.
+
+Usage:
+
+``` kotlin
+val listener = OnHeapAnalyzedListener {
+
+}
+```
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/on-heap-analyzed.md b/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/on-heap-analyzed.md
new file mode 100644
index 00000000..9c9ab3e0
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/on-heap-analyzed.md
@@ -0,0 +1,10 @@
+[leakcanary-android-core](../../index.md) / [leakcanary](../index.md) / [OnHeapAnalyzedListener](index.md) / [onHeapAnalyzed](./on-heap-analyzed.md)
+
+# onHeapAnalyzed
+
+`abstract fun onHeapAnalyzed(heapAnalysis: HeapAnalysis): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+**See Also**
+
+[OnHeapAnalyzedListener](index.md)
+
diff --git a/docs/api/leakcanary-android-core/leakcanary/index.md b/docs/api/leakcanary-android-core/leakcanary/index.md
new file mode 100644
index 00000000..ef6a0bad
--- /dev/null
+++ b/docs/api/leakcanary-android-core/leakcanary/index.md
@@ -0,0 +1,11 @@
+[leakcanary-android-core](../index.md) / [leakcanary](./index.md)
+
+## Package leakcanary
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [DefaultOnHeapAnalyzedListener](-default-on-heap-analyzed-listener/index.md) | `class DefaultOnHeapAnalyzedListener : `[`OnHeapAnalyzedListener`](-on-heap-analyzed-listener/index.md)<br>Default [OnHeapAnalyzedListener](-on-heap-analyzed-listener/index.md) implementation, which will store the analysis to disk and show a notification summarizing the result. |
+| [LeakCanary](-leak-canary/index.md) | `object LeakCanary`<br>The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher](#). AppWatcher notifies LeakCanary of retained instances, which in turns dumps the heap, analyses it and publishes the results. |
+| [OnHeapAnalyzedListener](-on-heap-analyzed-listener/index.md) | `interface OnHeapAnalyzedListener`<br>Listener set in [LeakCanary.Config](-leak-canary/-config/index.md) and called by LeakCanary on a background thread when the heap analysis is complete. |
diff --git a/docs/api/leakcanary-android-core/package-list b/docs/api/leakcanary-android-core/package-list
new file mode 100644
index 00000000..e886de54
--- /dev/null
+++ b/docs/api/leakcanary-android-core/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+leakcanary
diff --git a/docs/api/leakcanary-android-instrumentation/alltypes/index.md b/docs/api/leakcanary-android-instrumentation/alltypes/index.md
new file mode 100644
index 00000000..56d2bef1
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/alltypes/index.md
@@ -0,0 +1,10 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [leakcanary.FailAnnotatedTestOnLeakRunListener](../leakcanary/-fail-annotated-test-on-leak-run-listener/index.md) | A JUnit [RunListener](#) extending [FailTestOnLeakRunListener](../leakcanary/-fail-test-on-leak-run-listener/index.md) to detecting memory leaks in Android instrumentation tests only when the [FailTestOnLeak](../leakcanary/-fail-test-on-leak/index.md) annotation is used. |
+| [leakcanary.FailTestOnLeak](../leakcanary/-fail-test-on-leak/index.md) | An [Annotation](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-annotation/index.html) class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener](../leakcanary/-fail-annotated-test-on-leak-run-listener/index.md) for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener](../leakcanary/-fail-annotated-test-on-leak-run-listener/index.md), the tests should be annotated with this class in order for the listener to detect memory leaks. |
+| [leakcanary.FailTestOnLeakRunListener](../leakcanary/-fail-test-on-leak-run-listener/index.md) | A JUnit [RunListener](#) that uses [InstrumentationLeakDetector](../leakcanary/-instrumentation-leak-detector/index.md) to detect memory leaks in Android instrumentation tests. It waits for the end of a test, and if the test succeeds then it will look for retained objects, trigger a heap dump if needed and perform an analysis. |
+| [leakcanary.InstrumentationLeakDetector](../leakcanary/-instrumentation-leak-detector/index.md) | [InstrumentationLeakDetector](../leakcanary/-instrumentation-leak-detector/index.md) can be used to detect memory leaks in instrumentation tests. |
diff --git a/docs/api/leakcanary-android-instrumentation/index.md b/docs/api/leakcanary-android-instrumentation/index.md
new file mode 100644
index 00000000..d1e65775
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/index.md
@@ -0,0 +1,11 @@
+[leakcanary-android-instrumentation](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [leakcanary](leakcanary/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/-init-.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/-init-.md
new file mode 100644
index 00000000..d952730c
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/-init-.md
@@ -0,0 +1,14 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailAnnotatedTestOnLeakRunListener](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`FailAnnotatedTestOnLeakRunListener()`
+
+A JUnit [RunListener](#) extending [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md) to detecting memory
+leaks in Android instrumentation tests only when the [FailTestOnLeak](../-fail-test-on-leak/index.md) annotation
+is used.
+
+**See Also**
+
+[FailTestOnLeak](../-fail-test-on-leak/index.md)
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/index.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/index.md
new file mode 100644
index 00000000..c258126e
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/index.md
@@ -0,0 +1,39 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailAnnotatedTestOnLeakRunListener](./index.md)
+
+# FailAnnotatedTestOnLeakRunListener
+
+`class FailAnnotatedTestOnLeakRunListener : `[`FailTestOnLeakRunListener`](../-fail-test-on-leak-run-listener/index.md)
+
+A JUnit [RunListener](#) extending [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md) to detecting memory
+leaks in Android instrumentation tests only when the [FailTestOnLeak](../-fail-test-on-leak/index.md) annotation
+is used.
+
+**See Also**
+
+[FailTestOnLeak](../-fail-test-on-leak/index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `FailAnnotatedTestOnLeakRunListener()`<br>A JUnit [RunListener](#) extending [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md) to detecting memory leaks in Android instrumentation tests only when the [FailTestOnLeak](../-fail-test-on-leak/index.md) annotation is used. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [skipLeakDetectionReason](skip-leak-detection-reason.md) | `fun skipLeakDetectionReason(description: Description): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`?`<br>Can be overridden to skip leak detection based on the description provided when a test is started. Return null to continue leak detection, or a string describing the reason for skipping otherwise. |
+
+### Inherited Functions
+
+| Name | Summary |
+|---|---|
+| [failTest](../-fail-test-on-leak-run-listener/fail-test.md) | `fun failTest(message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Reports that the test has failed, with the provided [message](../-fail-test-on-leak-run-listener/fail-test.md#leakcanary.FailTestOnLeakRunListener$failTest(kotlin.String)/message). |
+| [onAnalysisPerformed](../-fail-test-on-leak-run-listener/on-analysis-performed.md) | `open fun onAnalysisPerformed(heapAnalysis: HeapAnalysis): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Called when a heap analysis has been performed and a result is available. |
+| [testAssumptionFailure](../-fail-test-on-leak-run-listener/test-assumption-failure.md) | `open fun testAssumptionFailure(failure: Failure): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testFailure](../-fail-test-on-leak-run-listener/test-failure.md) | `open fun testFailure(failure: Failure): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testFinished](../-fail-test-on-leak-run-listener/test-finished.md) | `open fun testFinished(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testIgnored](../-fail-test-on-leak-run-listener/test-ignored.md) | `open fun testIgnored(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testRunFinished](../-fail-test-on-leak-run-listener/test-run-finished.md) | `open fun testRunFinished(result: Result): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testRunStarted](../-fail-test-on-leak-run-listener/test-run-started.md) | `open fun testRunStarted(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testStarted](../-fail-test-on-leak-run-listener/test-started.md) | `open fun testStarted(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/skip-leak-detection-reason.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/skip-leak-detection-reason.md
new file mode 100644
index 00000000..d0cc4b5c
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-annotated-test-on-leak-run-listener/skip-leak-detection-reason.md
@@ -0,0 +1,12 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailAnnotatedTestOnLeakRunListener](index.md) / [skipLeakDetectionReason](./skip-leak-detection-reason.md)
+
+# skipLeakDetectionReason
+
+`protected fun skipLeakDetectionReason(description: Description): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`?`
+
+Overrides [FailTestOnLeakRunListener.skipLeakDetectionReason](../-fail-test-on-leak-run-listener/skip-leak-detection-reason.md)
+
+Can be overridden to skip leak detection based on the description provided when a test
+is started. Return null to continue leak detection, or a string describing the reason for
+skipping otherwise.
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/-init-.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/-init-.md
new file mode 100644
index 00000000..b69bae60
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/-init-.md
@@ -0,0 +1,17 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`FailTestOnLeakRunListener()`
+
+A JUnit [RunListener](#) that uses [InstrumentationLeakDetector](../-instrumentation-leak-detector/index.md) to detect memory leaks in Android
+instrumentation tests. It waits for the end of a test, and if the test succeeds then it will
+look for retained objects, trigger a heap dump if needed and perform an analysis.
+
+[FailTestOnLeakRunListener](index.md) can be subclassed to override [skipLeakDetectionReason](skip-leak-detection-reason.md) and
+[onAnalysisPerformed](on-analysis-performed.md)
+
+**See Also**
+
+[InstrumentationLeakDetector](../-instrumentation-leak-detector/index.md)
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/fail-test.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/fail-test.md
new file mode 100644
index 00000000..9c909fc4
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/fail-test.md
@@ -0,0 +1,8 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [failTest](./fail-test.md)
+
+# failTest
+
+`protected fun failTest(message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Reports that the test has failed, with the provided [message](fail-test.md#leakcanary.FailTestOnLeakRunListener$failTest(kotlin.String)/message).
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/index.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/index.md
new file mode 100644
index 00000000..bb3bafff
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/index.md
@@ -0,0 +1,43 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](./index.md)
+
+# FailTestOnLeakRunListener
+
+`open class FailTestOnLeakRunListener : RunListener`
+
+A JUnit [RunListener](#) that uses [InstrumentationLeakDetector](../-instrumentation-leak-detector/index.md) to detect memory leaks in Android
+instrumentation tests. It waits for the end of a test, and if the test succeeds then it will
+look for retained objects, trigger a heap dump if needed and perform an analysis.
+
+[FailTestOnLeakRunListener](./index.md) can be subclassed to override [skipLeakDetectionReason](skip-leak-detection-reason.md) and
+[onAnalysisPerformed](on-analysis-performed.md)
+
+**See Also**
+
+[InstrumentationLeakDetector](../-instrumentation-leak-detector/index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `FailTestOnLeakRunListener()`<br>A JUnit [RunListener](#) that uses [InstrumentationLeakDetector](../-instrumentation-leak-detector/index.md) to detect memory leaks in Android instrumentation tests. It waits for the end of a test, and if the test succeeds then it will look for retained objects, trigger a heap dump if needed and perform an analysis. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [failTest](fail-test.md) | `fun failTest(message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Reports that the test has failed, with the provided [message](fail-test.md#leakcanary.FailTestOnLeakRunListener$failTest(kotlin.String)/message). |
+| [onAnalysisPerformed](on-analysis-performed.md) | `open fun onAnalysisPerformed(heapAnalysis: HeapAnalysis): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Called when a heap analysis has been performed and a result is available. |
+| [skipLeakDetectionReason](skip-leak-detection-reason.md) | `open fun skipLeakDetectionReason(description: Description): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`?`<br>Can be overridden to skip leak detection based on the description provided when a test is started. Return null to continue leak detection, or a string describing the reason for skipping otherwise. |
+| [testAssumptionFailure](test-assumption-failure.md) | `open fun testAssumptionFailure(failure: Failure): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testFailure](test-failure.md) | `open fun testFailure(failure: Failure): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testFinished](test-finished.md) | `open fun testFinished(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testIgnored](test-ignored.md) | `open fun testIgnored(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testRunFinished](test-run-finished.md) | `open fun testRunFinished(result: Result): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testRunStarted](test-run-started.md) | `open fun testRunStarted(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [testStarted](test-started.md) | `open fun testStarted(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md) | `class FailAnnotatedTestOnLeakRunListener : `[`FailTestOnLeakRunListener`](./index.md)<br>A JUnit [RunListener](#) extending [FailTestOnLeakRunListener](./index.md) to detecting memory leaks in Android instrumentation tests only when the [FailTestOnLeak](../-fail-test-on-leak/index.md) annotation is used. |
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/on-analysis-performed.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/on-analysis-performed.md
new file mode 100644
index 00000000..337d7e09
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/on-analysis-performed.md
@@ -0,0 +1,11 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [onAnalysisPerformed](./on-analysis-performed.md)
+
+# onAnalysisPerformed
+
+`protected open fun onAnalysisPerformed(heapAnalysis: HeapAnalysis): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Called when a heap analysis has been performed and a result is available.
+
+The default implementation call [failTest](fail-test.md) if the [heapAnalysis](on-analysis-performed.md#leakcanary.FailTestOnLeakRunListener$onAnalysisPerformed(shark.HeapAnalysis)/heapAnalysis) failed or if
+[HeapAnalysisSuccess.applicationLeaks](#) is not empty.
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/skip-leak-detection-reason.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/skip-leak-detection-reason.md
new file mode 100644
index 00000000..702c5b65
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/skip-leak-detection-reason.md
@@ -0,0 +1,10 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [skipLeakDetectionReason](./skip-leak-detection-reason.md)
+
+# skipLeakDetectionReason
+
+`protected open fun skipLeakDetectionReason(description: Description): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`?`
+
+Can be overridden to skip leak detection based on the description provided when a test
+is started. Return null to continue leak detection, or a string describing the reason for
+skipping otherwise.
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-assumption-failure.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-assumption-failure.md
new file mode 100644
index 00000000..6de5595f
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-assumption-failure.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [testAssumptionFailure](./test-assumption-failure.md)
+
+# testAssumptionFailure
+
+`open fun testAssumptionFailure(failure: Failure): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-failure.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-failure.md
new file mode 100644
index 00000000..c3939a7e
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-failure.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [testFailure](./test-failure.md)
+
+# testFailure
+
+`open fun testFailure(failure: Failure): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-finished.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-finished.md
new file mode 100644
index 00000000..73724bfa
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-finished.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [testFinished](./test-finished.md)
+
+# testFinished
+
+`open fun testFinished(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-ignored.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-ignored.md
new file mode 100644
index 00000000..15679185
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-ignored.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [testIgnored](./test-ignored.md)
+
+# testIgnored
+
+`open fun testIgnored(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-run-finished.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-run-finished.md
new file mode 100644
index 00000000..097e8b41
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-run-finished.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [testRunFinished](./test-run-finished.md)
+
+# testRunFinished
+
+`open fun testRunFinished(result: Result): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-run-started.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-run-started.md
new file mode 100644
index 00000000..7d81fd51
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-run-started.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [testRunStarted](./test-run-started.md)
+
+# testRunStarted
+
+`open fun testRunStarted(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-started.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-started.md
new file mode 100644
index 00000000..bf0c758d
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak-run-listener/test-started.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeakRunListener](index.md) / [testStarted](./test-started.md)
+
+# testStarted
+
+`open fun testStarted(description: Description): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak/-init-.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak/-init-.md
new file mode 100644
index 00000000..7fcbee49
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak/-init-.md
@@ -0,0 +1,14 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeak](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`FailTestOnLeak()`
+
+An [Annotation](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-annotation/index.html) class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md)
+for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md), the tests
+should be annotated with this class in order for the listener to detect memory leaks.
+
+**See Also**
+
+[FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md)
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak/index.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak/index.md
new file mode 100644
index 00000000..ca8dbe00
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-fail-test-on-leak/index.md
@@ -0,0 +1,19 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [FailTestOnLeak](./index.md)
+
+# FailTestOnLeak
+
+`@Target([AnnotationTarget.FUNCTION]) annotation class FailTestOnLeak`
+
+An [Annotation](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-annotation/index.html) class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md)
+for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md), the tests
+should be annotated with this class in order for the listener to detect memory leaks.
+
+**See Also**
+
+[FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `FailTestOnLeak()`<br>An [Annotation](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-annotation/index.html) class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md) for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener](../-fail-annotated-test-on-leak-run-listener/index.md), the tests should be annotated with this class in order for the listener to detect memory leaks. |
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-init-.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-init-.md
new file mode 100644
index 00000000..1979ba32
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-init-.md
@@ -0,0 +1,58 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [InstrumentationLeakDetector](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`InstrumentationLeakDetector()`
+
+[InstrumentationLeakDetector](index.md) can be used to detect memory leaks in instrumentation tests.
+
+To use it, you need to:
+
+* Call [updateConfig](update-config.md) so that [AppWatcher](#) will watch objects and [LeakCanary](#) will not dump
+the heap on retained objects
+* Add an instrumentation test listener (e.g. [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md)) that will invoke
+[detectLeaks](detect-leaks.md).
+
+### Add an instrumentation test listener
+
+LeakCanary provides [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md), but you can also implement
+your own [RunListener](#) and call [detectLeaks](detect-leaks.md) directly if you need a more custom
+behavior (for instance running it only once per test suite).
+
+All you need to do is add the following to the defaultConfig of your build.gradle:
+
+`testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"`
+
+Then you can run your instrumentation tests via Gradle as usually, and they will fail when
+a memory leak is detected:
+
+`./gradlew leakcanary-sample:connectedCheck`
+
+If instead you want to run UI tests via adb, add a *listener* execution argument to
+your command line for running the UI tests:
+`-e listener leakcanary.FailTestOnLeakRunListener`. The full command line
+should look something like this:
+
+```
+adb shell am instrument \\
+-w com.android.foo/android.support.test.runner.AndroidJUnitRunner \\
+-e listener leakcanary.FailTestOnLeakRunListener
+```
+
+### Rationale
+
+Instead of using the [InstrumentationLeakDetector](index.md), one could simply enable LeakCanary in
+instrumentation tests.
+
+This approach would have two disadvantages:
+
+* Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+the test and introduce flakiness
+* The leak analysis is asynchronous by default. This means the tests could finish and the
+process die before the analysis is finished.
+
+The approach taken here is to collect all objects to watch as you run the test, but not
+do any heap dump during the test. Then, at the end, if any of the watched objects is still in
+memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
+no matter the number of objects retained.
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/-init-.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/-init-.md
new file mode 100644
index 00000000..dda08409
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/-init-.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../../../index.md) / [leakcanary](../../../index.md) / [InstrumentationLeakDetector](../../index.md) / [Result](../index.md) / [AnalysisPerformed](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`AnalysisPerformed(heapAnalysis: HeapAnalysis)`
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/heap-analysis.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/heap-analysis.md
new file mode 100644
index 00000000..ffa0b7eb
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/heap-analysis.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../../../index.md) / [leakcanary](../../../index.md) / [InstrumentationLeakDetector](../../index.md) / [Result](../index.md) / [AnalysisPerformed](index.md) / [heapAnalysis](./heap-analysis.md)
+
+# heapAnalysis
+
+`val heapAnalysis: HeapAnalysis`
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/index.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/index.md
new file mode 100644
index 00000000..732ba767
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-analysis-performed/index.md
@@ -0,0 +1,17 @@
+[leakcanary-android-instrumentation](../../../../index.md) / [leakcanary](../../../index.md) / [InstrumentationLeakDetector](../../index.md) / [Result](../index.md) / [AnalysisPerformed](./index.md)
+
+# AnalysisPerformed
+
+`class AnalysisPerformed : `[`InstrumentationLeakDetector.Result`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `AnalysisPerformed(heapAnalysis: HeapAnalysis)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [heapAnalysis](heap-analysis.md) | `val heapAnalysis: HeapAnalysis` |
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-no-analysis.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-no-analysis.md
new file mode 100644
index 00000000..e3da4941
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/-no-analysis.md
@@ -0,0 +1,5 @@
+[leakcanary-android-instrumentation](../../../index.md) / [leakcanary](../../index.md) / [InstrumentationLeakDetector](../index.md) / [Result](index.md) / [NoAnalysis](./-no-analysis.md)
+
+# NoAnalysis
+
+`object NoAnalysis : `[`InstrumentationLeakDetector.Result`](index.md)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/index.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/index.md
new file mode 100644
index 00000000..150b1073
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/-result/index.md
@@ -0,0 +1,21 @@
+[leakcanary-android-instrumentation](../../../index.md) / [leakcanary](../../index.md) / [InstrumentationLeakDetector](../index.md) / [Result](./index.md)
+
+# Result
+
+`sealed class Result`
+
+The result of calling [detectLeaks](../detect-leaks.md), which is either [NoAnalysis](-no-analysis.md) or [AnalysisPerformed](-analysis-performed/index.md).
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [AnalysisPerformed](-analysis-performed/index.md) | `class AnalysisPerformed : `[`InstrumentationLeakDetector.Result`](./index.md) |
+| [NoAnalysis](-no-analysis.md) | `object NoAnalysis : `[`InstrumentationLeakDetector.Result`](./index.md) |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [AnalysisPerformed](-analysis-performed/index.md) | `class AnalysisPerformed : `[`InstrumentationLeakDetector.Result`](./index.md) |
+| [NoAnalysis](-no-analysis.md) | `object NoAnalysis : `[`InstrumentationLeakDetector.Result`](./index.md) |
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/detect-leaks.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/detect-leaks.md
new file mode 100644
index 00000000..bf079652
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/detect-leaks.md
@@ -0,0 +1,8 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [InstrumentationLeakDetector](index.md) / [detectLeaks](./detect-leaks.md)
+
+# detectLeaks
+
+`fun detectLeaks(): `[`InstrumentationLeakDetector.Result`](-result/index.md)
+
+Looks for retained objects, triggers a heap dump if needed and performs an analysis.
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/index.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/index.md
new file mode 100644
index 00000000..62ec4168
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/index.md
@@ -0,0 +1,81 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [InstrumentationLeakDetector](./index.md)
+
+# InstrumentationLeakDetector
+
+`class InstrumentationLeakDetector`
+
+[InstrumentationLeakDetector](./index.md) can be used to detect memory leaks in instrumentation tests.
+
+To use it, you need to:
+
+* Call [updateConfig](update-config.md) so that [AppWatcher](#) will watch objects and [LeakCanary](#) will not dump
+the heap on retained objects
+* Add an instrumentation test listener (e.g. [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md)) that will invoke
+[detectLeaks](detect-leaks.md).
+
+### Add an instrumentation test listener
+
+LeakCanary provides [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md), but you can also implement
+your own [RunListener](#) and call [detectLeaks](detect-leaks.md) directly if you need a more custom
+behavior (for instance running it only once per test suite).
+
+All you need to do is add the following to the defaultConfig of your build.gradle:
+
+`testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"`
+
+Then you can run your instrumentation tests via Gradle as usually, and they will fail when
+a memory leak is detected:
+
+`./gradlew leakcanary-sample:connectedCheck`
+
+If instead you want to run UI tests via adb, add a *listener* execution argument to
+your command line for running the UI tests:
+`-e listener leakcanary.FailTestOnLeakRunListener`. The full command line
+should look something like this:
+
+```
+adb shell am instrument \\
+-w com.android.foo/android.support.test.runner.AndroidJUnitRunner \\
+-e listener leakcanary.FailTestOnLeakRunListener
+```
+
+### Rationale
+
+Instead of using the [InstrumentationLeakDetector](./index.md), one could simply enable LeakCanary in
+instrumentation tests.
+
+This approach would have two disadvantages:
+
+* Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+the test and introduce flakiness
+* The leak analysis is asynchronous by default. This means the tests could finish and the
+process die before the analysis is finished.
+
+The approach taken here is to collect all objects to watch as you run the test, but not
+do any heap dump during the test. Then, at the end, if any of the watched objects is still in
+memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
+no matter the number of objects retained.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Result](-result/index.md) | `sealed class Result`<br>The result of calling [detectLeaks](detect-leaks.md), which is either [NoAnalysis](-result/-no-analysis.md) or [AnalysisPerformed](-result/-analysis-performed/index.md). |
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `InstrumentationLeakDetector()`<br>[InstrumentationLeakDetector](./index.md) can be used to detect memory leaks in instrumentation tests. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [detectLeaks](detect-leaks.md) | `fun detectLeaks(): `[`InstrumentationLeakDetector.Result`](-result/index.md)<br>Looks for retained objects, triggers a heap dump if needed and performs an analysis. |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [updateConfig](update-config.md) | `fun updateConfig(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Configures [AppWatcher](#) to watch objects and [LeakCanary](#) to not dump the heap on retained objects so that instrumentation tests run smoothly, and we can look for leaks at the end of a test. This is automatically called by [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md) when the tests start running. |
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/update-config.md b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/update-config.md
new file mode 100644
index 00000000..da580060
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/-instrumentation-leak-detector/update-config.md
@@ -0,0 +1,11 @@
+[leakcanary-android-instrumentation](../../index.md) / [leakcanary](../index.md) / [InstrumentationLeakDetector](index.md) / [updateConfig](./update-config.md)
+
+# updateConfig
+
+`fun updateConfig(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Configures [AppWatcher](#) to watch objects and [LeakCanary](#) to not dump the heap on retained
+objects so that instrumentation tests run smoothly, and we can look for leaks at the end of
+a test. This is automatically called by [FailTestOnLeakRunListener](../-fail-test-on-leak-run-listener/index.md) when the tests start
+running.
+
diff --git a/docs/api/leakcanary-android-instrumentation/leakcanary/index.md b/docs/api/leakcanary-android-instrumentation/leakcanary/index.md
new file mode 100644
index 00000000..6872aa14
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/leakcanary/index.md
@@ -0,0 +1,17 @@
+[leakcanary-android-instrumentation](../index.md) / [leakcanary](./index.md)
+
+## Package leakcanary
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [FailAnnotatedTestOnLeakRunListener](-fail-annotated-test-on-leak-run-listener/index.md) | `class FailAnnotatedTestOnLeakRunListener : `[`FailTestOnLeakRunListener`](-fail-test-on-leak-run-listener/index.md)<br>A JUnit [RunListener](#) extending [FailTestOnLeakRunListener](-fail-test-on-leak-run-listener/index.md) to detecting memory leaks in Android instrumentation tests only when the [FailTestOnLeak](-fail-test-on-leak/index.md) annotation is used. |
+| [FailTestOnLeakRunListener](-fail-test-on-leak-run-listener/index.md) | `open class FailTestOnLeakRunListener : RunListener`<br>A JUnit [RunListener](#) that uses [InstrumentationLeakDetector](-instrumentation-leak-detector/index.md) to detect memory leaks in Android instrumentation tests. It waits for the end of a test, and if the test succeeds then it will look for retained objects, trigger a heap dump if needed and perform an analysis. |
+| [InstrumentationLeakDetector](-instrumentation-leak-detector/index.md) | `class InstrumentationLeakDetector`<br>[InstrumentationLeakDetector](-instrumentation-leak-detector/index.md) can be used to detect memory leaks in instrumentation tests. |
+
+### Annotations
+
+| Name | Summary |
+|---|---|
+| [FailTestOnLeak](-fail-test-on-leak/index.md) | `annotation class FailTestOnLeak`<br>An [Annotation](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-annotation/index.html) class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener](-fail-annotated-test-on-leak-run-listener/index.md) for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener](-fail-annotated-test-on-leak-run-listener/index.md), the tests should be annotated with this class in order for the listener to detect memory leaks. |
diff --git a/docs/api/leakcanary-android-instrumentation/package-list b/docs/api/leakcanary-android-instrumentation/package-list
new file mode 100644
index 00000000..e886de54
--- /dev/null
+++ b/docs/api/leakcanary-android-instrumentation/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+leakcanary
diff --git a/docs/api/leakcanary-android-process/alltypes/index.md b/docs/api/leakcanary-android-process/alltypes/index.md
new file mode 100644
index 00000000..0889db82
--- /dev/null
+++ b/docs/api/leakcanary-android-process/alltypes/index.md
@@ -0,0 +1,7 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [leakcanary.LeakCanaryProcess](../leakcanary/-leak-canary-process/index.md) | Used to determine whether the current process is the LeakCanary analyzer process. By depending on the `leakcanary-android-process` artifact instead of the `leakcanary-android`, LeakCanary will automatically run its analysis in a separate process. |
diff --git a/docs/api/leakcanary-android-process/index.md b/docs/api/leakcanary-android-process/index.md
new file mode 100644
index 00000000..a07c6db6
--- /dev/null
+++ b/docs/api/leakcanary-android-process/index.md
@@ -0,0 +1,11 @@
+[leakcanary-android-process](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [leakcanary](leakcanary/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/leakcanary-android-process/leakcanary/-leak-canary-process/index.md b/docs/api/leakcanary-android-process/leakcanary/-leak-canary-process/index.md
new file mode 100644
index 00000000..efbfeb7f
--- /dev/null
+++ b/docs/api/leakcanary-android-process/leakcanary/-leak-canary-process/index.md
@@ -0,0 +1,18 @@
+[leakcanary-android-process](../../index.md) / [leakcanary](../index.md) / [LeakCanaryProcess](./index.md)
+
+# LeakCanaryProcess
+
+`object LeakCanaryProcess`
+
+Used to determine whether the current process is the LeakCanary analyzer process. By depending
+on the `leakcanary-android-process` artifact instead of the `leakcanary-android`, LeakCanary
+will automatically run its analysis in a separate process.
+
+As such, you'll need to be careful to do any custom configuration of LeakCanary in both the main
+process and the analyzer process.
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [isInAnalyzerProcess](is-in-analyzer-process.md) | `fun isInAnalyzerProcess(context: Context): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether the current process is the process running the heap analyzer, which is a different process than the normal app process. |
diff --git a/docs/api/leakcanary-android-process/leakcanary/-leak-canary-process/is-in-analyzer-process.md b/docs/api/leakcanary-android-process/leakcanary/-leak-canary-process/is-in-analyzer-process.md
new file mode 100644
index 00000000..3322ae7d
--- /dev/null
+++ b/docs/api/leakcanary-android-process/leakcanary/-leak-canary-process/is-in-analyzer-process.md
@@ -0,0 +1,9 @@
+[leakcanary-android-process](../../index.md) / [leakcanary](../index.md) / [LeakCanaryProcess](index.md) / [isInAnalyzerProcess](./is-in-analyzer-process.md)
+
+# isInAnalyzerProcess
+
+`fun isInAnalyzerProcess(context: Context): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether the current process is the process running the heap analyzer, which is
+a different process than the normal app process.
+
diff --git a/docs/api/leakcanary-android-process/leakcanary/index.md b/docs/api/leakcanary-android-process/leakcanary/index.md
new file mode 100644
index 00000000..856aceca
--- /dev/null
+++ b/docs/api/leakcanary-android-process/leakcanary/index.md
@@ -0,0 +1,9 @@
+[leakcanary-android-process](../index.md) / [leakcanary](./index.md)
+
+## Package leakcanary
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [LeakCanaryProcess](-leak-canary-process/index.md) | `object LeakCanaryProcess`<br>Used to determine whether the current process is the LeakCanary analyzer process. By depending on the `leakcanary-android-process` artifact instead of the `leakcanary-android`, LeakCanary will automatically run its analysis in a separate process. |
diff --git a/docs/api/leakcanary-android-process/package-list b/docs/api/leakcanary-android-process/package-list
new file mode 100644
index 00000000..e886de54
--- /dev/null
+++ b/docs/api/leakcanary-android-process/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+leakcanary
diff --git a/docs/api/leakcanary-object-watcher-android/alltypes/index.md b/docs/api/leakcanary-object-watcher-android/alltypes/index.md
new file mode 100644
index 00000000..1dcce4a0
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/alltypes/index.md
@@ -0,0 +1,7 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [leakcanary.AppWatcher](../leakcanary/-app-watcher/index.md) | The entry point API for using [ObjectWatcher](#) in an Android app. [AppWatcher.objectWatcher](../leakcanary/-app-watcher/object-watcher.md) is in charge of detecting retained objects, and [AppWatcher](../leakcanary/-app-watcher/index.md) is auto configured on app start to pass it activity and fragment instances. Call [ObjectWatcher.watch](#) on [objectWatcher](../leakcanary/-app-watcher/object-watcher.md) to watch any other object that you expect to be unreachable. |
diff --git a/docs/api/leakcanary-object-watcher-android/index.md b/docs/api/leakcanary-object-watcher-android/index.md
new file mode 100644
index 00000000..bae5257b
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/index.md
@@ -0,0 +1,11 @@
+[leakcanary-object-watcher-android](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [leakcanary](leakcanary/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/-init-.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/-init-.md
new file mode 100644
index 00000000..aeb69e8d
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/-init-.md
@@ -0,0 +1,5 @@
+[leakcanary-object-watcher-android](../../../index.md) / [leakcanary](../../index.md) / [AppWatcher](../index.md) / [Config](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`Config(enabled: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = InternalAppWatcher.isDebuggableBuild, watchActivities: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, watchFragments: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, watchFragmentViews: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, watchDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = TimeUnit.SECONDS.toMillis(5))`
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/enabled.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/enabled.md
new file mode 100644
index 00000000..2f39941c
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/enabled.md
@@ -0,0 +1,10 @@
+[leakcanary-object-watcher-android](../../../index.md) / [leakcanary](../../index.md) / [AppWatcher](../index.md) / [Config](index.md) / [enabled](./enabled.md)
+
+# enabled
+
+`val enabled: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether AppWatcher should watch objects (by keeping weak references to them).
+
+Default to true in debuggable builds and false is non debuggable builds.
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/index.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/index.md
new file mode 100644
index 00000000..40313db9
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/index.md
@@ -0,0 +1,21 @@
+[leakcanary-object-watcher-android](../../../index.md) / [leakcanary](../../index.md) / [AppWatcher](../index.md) / [Config](./index.md)
+
+# Config
+
+`data class Config`
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `Config(enabled: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = InternalAppWatcher.isDebuggableBuild, watchActivities: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, watchFragments: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, watchFragmentViews: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = true, watchDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = TimeUnit.SECONDS.toMillis(5))` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [enabled](enabled.md) | `val enabled: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether AppWatcher should watch objects (by keeping weak references to them). |
+| [watchActivities](watch-activities.md) | `val watchActivities: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether AppWatcher should automatically watch destroyed activity instances. |
+| [watchDurationMillis](watch-duration-millis.md) | `val watchDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>How long to wait before reporting a watched object as retained. |
+| [watchFragments](watch-fragments.md) | `val watchFragments: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether AppWatcher should automatically watch destroyed fragment instances. |
+| [watchFragmentViews](watch-fragment-views.md) | `val watchFragmentViews: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether AppWatcher should automatically watch destroyed fragment view instances. |
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-activities.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-activities.md
new file mode 100644
index 00000000..4f6fa009
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-activities.md
@@ -0,0 +1,10 @@
+[leakcanary-object-watcher-android](../../../index.md) / [leakcanary](../../index.md) / [AppWatcher](../index.md) / [Config](index.md) / [watchActivities](./watch-activities.md)
+
+# watchActivities
+
+`val watchActivities: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether AppWatcher should automatically watch destroyed activity instances.
+
+Defaults to true.
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-duration-millis.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-duration-millis.md
new file mode 100644
index 00000000..d009c517
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-duration-millis.md
@@ -0,0 +1,10 @@
+[leakcanary-object-watcher-android](../../../index.md) / [leakcanary](../../index.md) / [AppWatcher](../index.md) / [Config](index.md) / [watchDurationMillis](./watch-duration-millis.md)
+
+# watchDurationMillis
+
+`val watchDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+How long to wait before reporting a watched object as retained.
+
+Default to 5 seconds.
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-fragment-views.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-fragment-views.md
new file mode 100644
index 00000000..e3269538
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-fragment-views.md
@@ -0,0 +1,10 @@
+[leakcanary-object-watcher-android](../../../index.md) / [leakcanary](../../index.md) / [AppWatcher](../index.md) / [Config](index.md) / [watchFragmentViews](./watch-fragment-views.md)
+
+# watchFragmentViews
+
+`val watchFragmentViews: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether AppWatcher should automatically watch destroyed fragment view instances.
+
+Defaults to true.
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-fragments.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-fragments.md
new file mode 100644
index 00000000..8520caa9
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/-config/watch-fragments.md
@@ -0,0 +1,10 @@
+[leakcanary-object-watcher-android](../../../index.md) / [leakcanary](../../index.md) / [AppWatcher](../index.md) / [Config](index.md) / [watchFragments](./watch-fragments.md)
+
+# watchFragments
+
+`val watchFragments: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether AppWatcher should automatically watch destroyed fragment instances.
+
+Defaults to true.
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config.md
new file mode 100644
index 00000000..897fb8af
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config.md
@@ -0,0 +1,13 @@
+[leakcanary-object-watcher-android](../../index.md) / [leakcanary](../index.md) / [AppWatcher](index.md) / [config](./config.md)
+
+# config
+
+`var config: `[`AppWatcher.Config`](-config/index.md)
+
+The current AppWatcher configuration. Can be updated at any time, usually by replacing it with
+a mutated copy, e.g.:
+
+```
+LeakCanary.config = LeakCanary.config.copy(enabled = false)
+```
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/index.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/index.md
new file mode 100644
index 00000000..40efc9f0
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/index.md
@@ -0,0 +1,30 @@
+[leakcanary-object-watcher-android](../../index.md) / [leakcanary](../index.md) / [AppWatcher](./index.md)
+
+# AppWatcher
+
+`object AppWatcher`
+
+The entry point API for using [ObjectWatcher](#) in an Android app. [AppWatcher.objectWatcher](object-watcher.md) is
+in charge of detecting retained objects, and [AppWatcher](./index.md) is auto configured on app start to
+pass it activity and fragment instances. Call [ObjectWatcher.watch](#) on [objectWatcher](object-watcher.md) to
+watch any other object that you expect to be unreachable.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Config](-config/index.md) | `data class Config` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [config](config.md) | `var config: `[`AppWatcher.Config`](-config/index.md)<br>The current AppWatcher configuration. Can be updated at any time, usually by replacing it with a mutated copy, e.g.: |
+| [isInstalled](is-installed.md) | `val isInstalled: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
+| [objectWatcher](object-watcher.md) | `val objectWatcher: ObjectWatcher`<br>The [ObjectWatcher](#) used by AppWatcher to detect retained objects. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [manualInstall](manual-install.md) | `fun manualInstall(application: Application): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>[AppWatcher](./index.md) is automatically installed on main process start by [leakcanary.internal.AppWatcherInstaller](#) which is registered in the AndroidManifest.xml of your app. If you disabled [leakcanary.internal.AppWatcherInstaller](#) or you need AppWatcher or LeakCanary to run outside of the main process then you can call this method to install [AppWatcher](./index.md). |
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/is-installed.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/is-installed.md
new file mode 100644
index 00000000..2a239f4c
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/is-installed.md
@@ -0,0 +1,10 @@
+[leakcanary-object-watcher-android](../../index.md) / [leakcanary](../index.md) / [AppWatcher](index.md) / [isInstalled](./is-installed.md)
+
+# isInstalled
+
+`val isInstalled: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+**See Also**
+
+[manualInstall](manual-install.md)
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/manual-install.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/manual-install.md
new file mode 100644
index 00000000..3ace9b31
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/manual-install.md
@@ -0,0 +1,12 @@
+[leakcanary-object-watcher-android](../../index.md) / [leakcanary](../index.md) / [AppWatcher](index.md) / [manualInstall](./manual-install.md)
+
+# manualInstall
+
+`fun manualInstall(application: Application): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+[AppWatcher](index.md) is automatically installed on main process start by
+[leakcanary.internal.AppWatcherInstaller](#) which is registered in the AndroidManifest.xml of
+your app. If you disabled [leakcanary.internal.AppWatcherInstaller](#) or you need AppWatcher
+or LeakCanary to run outside of the main process then you can call this method to install
+[AppWatcher](index.md).
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher.md b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher.md
new file mode 100644
index 00000000..47617835
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher.md
@@ -0,0 +1,8 @@
+[leakcanary-object-watcher-android](../../index.md) / [leakcanary](../index.md) / [AppWatcher](index.md) / [objectWatcher](./object-watcher.md)
+
+# objectWatcher
+
+`val objectWatcher: ObjectWatcher`
+
+The [ObjectWatcher](#) used by AppWatcher to detect retained objects.
+
diff --git a/docs/api/leakcanary-object-watcher-android/leakcanary/index.md b/docs/api/leakcanary-object-watcher-android/leakcanary/index.md
new file mode 100644
index 00000000..fe6223ab
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/leakcanary/index.md
@@ -0,0 +1,9 @@
+[leakcanary-object-watcher-android](../index.md) / [leakcanary](./index.md)
+
+## Package leakcanary
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [AppWatcher](-app-watcher/index.md) | `object AppWatcher`<br>The entry point API for using [ObjectWatcher](#) in an Android app. [AppWatcher.objectWatcher](-app-watcher/object-watcher.md) is in charge of detecting retained objects, and [AppWatcher](-app-watcher/index.md) is auto configured on app start to pass it activity and fragment instances. Call [ObjectWatcher.watch](#) on [objectWatcher](-app-watcher/object-watcher.md) to watch any other object that you expect to be unreachable. |
diff --git a/docs/api/leakcanary-object-watcher-android/package-list b/docs/api/leakcanary-object-watcher-android/package-list
new file mode 100644
index 00000000..e886de54
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher-android/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+leakcanary
diff --git a/docs/api/leakcanary-object-watcher/alltypes/index.md b/docs/api/leakcanary-object-watcher/alltypes/index.md
new file mode 100644
index 00000000..036a7050
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/alltypes/index.md
@@ -0,0 +1,11 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [leakcanary.Clock](../leakcanary/-clock/index.md) | An interface to abstract the SystemClock.uptimeMillis() Android API in non Android artifacts. |
+| [leakcanary.GcTrigger](../leakcanary/-gc-trigger/index.md) | [GcTrigger](../leakcanary/-gc-trigger/index.md) is used to try triggering garbage collection and enqueuing [KeyedWeakReference](../leakcanary/-keyed-weak-reference/index.md) into the associated [java.lang.ref.ReferenceQueue](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html). The default implementation [Default](../leakcanary/-gc-trigger/-default/index.md) comes from AOSP. |
+| [leakcanary.KeyedWeakReference](../leakcanary/-keyed-weak-reference/index.md) | A weak reference used by [ObjectWatcher](../leakcanary/-object-watcher/index.md) to determine which objects become weakly reachable and which don't. [ObjectWatcher](../leakcanary/-object-watcher/index.md) uses [key](../leakcanary/-keyed-weak-reference/key.md) to keep track of [KeyedWeakReference](../leakcanary/-keyed-weak-reference/index.md) instances that haven't made it into the associated [ReferenceQueue](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html) yet. |
+| [leakcanary.ObjectWatcher](../leakcanary/-object-watcher/index.md) | [ObjectWatcher](../leakcanary/-object-watcher/index.md) can be passed objects to [watch](../leakcanary/-object-watcher/watch.md). It will create [KeyedWeakReference](../leakcanary/-keyed-weak-reference/index.md) instances that reference watches objects, and check if those references have been cleared as expected on the [checkRetainedExecutor](#) executor. If not, these objects are considered retained and [ObjectWatcher](../leakcanary/-object-watcher/index.md) will then notify the [onObjectRetainedListener](#) on that executor thread. |
+| [leakcanary.OnObjectRetainedListener](../leakcanary/-on-object-retained-listener/index.md) | Listener used by [ObjectWatcher](../leakcanary/-object-watcher/index.md) to report retained objects. |
diff --git a/docs/api/leakcanary-object-watcher/index.md b/docs/api/leakcanary-object-watcher/index.md
new file mode 100644
index 00000000..4fad67a9
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/index.md
@@ -0,0 +1,11 @@
+[leakcanary-object-watcher](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [leakcanary](leakcanary/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-clock/index.md b/docs/api/leakcanary-object-watcher/leakcanary/-clock/index.md
new file mode 100644
index 00000000..d2ad10d2
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-clock/index.md
@@ -0,0 +1,13 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [Clock](./index.md)
+
+# Clock
+
+`interface Clock`
+
+An interface to abstract the SystemClock.uptimeMillis() Android API in non Android artifacts.
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [uptimeMillis](uptime-millis.md) | `abstract fun uptimeMillis(): `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>On Android VMs, this should return android.os.SystemClock.uptimeMillis(). |
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-clock/uptime-millis.md b/docs/api/leakcanary-object-watcher/leakcanary/-clock/uptime-millis.md
new file mode 100644
index 00000000..83c2d3e3
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-clock/uptime-millis.md
@@ -0,0 +1,8 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [Clock](index.md) / [uptimeMillis](./uptime-millis.md)
+
+# uptimeMillis
+
+`abstract fun uptimeMillis(): `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+On Android VMs, this should return android.os.SystemClock.uptimeMillis().
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/-default/index.md b/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/-default/index.md
new file mode 100644
index 00000000..a078848d
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/-default/index.md
@@ -0,0 +1,13 @@
+[leakcanary-object-watcher](../../../index.md) / [leakcanary](../../index.md) / [GcTrigger](../index.md) / [Default](./index.md)
+
+# Default
+
+`object Default : `[`GcTrigger`](../index.md)
+
+Default implementation of [GcTrigger](../index.md).
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [runGc](run-gc.md) | `fun runGc(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Attempts to run garbage collection. |
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/-default/run-gc.md b/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/-default/run-gc.md
new file mode 100644
index 00000000..d5110d23
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/-default/run-gc.md
@@ -0,0 +1,10 @@
+[leakcanary-object-watcher](../../../index.md) / [leakcanary](../../index.md) / [GcTrigger](../index.md) / [Default](index.md) / [runGc](./run-gc.md)
+
+# runGc
+
+`fun runGc(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Overrides [GcTrigger.runGc](../run-gc.md)
+
+Attempts to run garbage collection.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/index.md b/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/index.md
new file mode 100644
index 00000000..f9da4107
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/index.md
@@ -0,0 +1,27 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [GcTrigger](./index.md)
+
+# GcTrigger
+
+`interface GcTrigger`
+
+[GcTrigger](./index.md) is used to try triggering garbage collection and enqueuing [KeyedWeakReference](../-keyed-weak-reference/index.md) into
+the associated [java.lang.ref.ReferenceQueue](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html). The default implementation [Default](-default/index.md) comes from
+AOSP.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Default](-default/index.md) | `object Default : `[`GcTrigger`](./index.md)<br>Default implementation of [GcTrigger](./index.md). |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [runGc](run-gc.md) | `abstract fun runGc(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Attempts to run garbage collection. |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [Default](-default/index.md) | `object Default : `[`GcTrigger`](./index.md)<br>Default implementation of [GcTrigger](./index.md). |
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/run-gc.md b/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/run-gc.md
new file mode 100644
index 00000000..bde4366f
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-gc-trigger/run-gc.md
@@ -0,0 +1,8 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [GcTrigger](index.md) / [runGc](./run-gc.md)
+
+# runGc
+
+`abstract fun runGc(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Attempts to run garbage collection.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/-init-.md b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/-init-.md
new file mode 100644
index 00000000..66d519b6
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/-init-.md
@@ -0,0 +1,13 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [KeyedWeakReference](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`KeyedWeakReference(referent: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`, key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, watchUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, referenceQueue: `[`ReferenceQueue`](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html)`<`[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>)`
+
+A weak reference used by [ObjectWatcher](../-object-watcher/index.md) to determine which objects become weakly reachable
+and which don't. [ObjectWatcher](../-object-watcher/index.md) uses [key](key.md) to keep track of [KeyedWeakReference](index.md) instances that
+haven't made it into the associated [ReferenceQueue](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html) yet.
+
+[heapDumpUptimeMillis](heap-dump-uptime-millis.md) should be set with the current time from [Clock.uptimeMillis](../-clock/uptime-millis.md) right
+before dumping the heap, so that we can later determine how long an object was retained.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/heap-dump-uptime-millis.md b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/heap-dump-uptime-millis.md
new file mode 100644
index 00000000..50a3d274
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/heap-dump-uptime-millis.md
@@ -0,0 +1,5 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [KeyedWeakReference](index.md) / [heapDumpUptimeMillis](./heap-dump-uptime-millis.md)
+
+# heapDumpUptimeMillis
+
+`@JvmStatic var heapDumpUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/index.md b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/index.md
new file mode 100644
index 00000000..d88b86c8
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/index.md
@@ -0,0 +1,33 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [KeyedWeakReference](./index.md)
+
+# KeyedWeakReference
+
+`class KeyedWeakReference : `[`WeakReference`](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html)`<`[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>`
+
+A weak reference used by [ObjectWatcher](../-object-watcher/index.md) to determine which objects become weakly reachable
+and which don't. [ObjectWatcher](../-object-watcher/index.md) uses [key](key.md) to keep track of [KeyedWeakReference](./index.md) instances that
+haven't made it into the associated [ReferenceQueue](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html) yet.
+
+[heapDumpUptimeMillis](heap-dump-uptime-millis.md) should be set with the current time from [Clock.uptimeMillis](../-clock/uptime-millis.md) right
+before dumping the heap, so that we can later determine how long an object was retained.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `KeyedWeakReference(referent: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`, key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, watchUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, referenceQueue: `[`ReferenceQueue`](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html)`<`[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>)`<br>A weak reference used by [ObjectWatcher](../-object-watcher/index.md) to determine which objects become weakly reachable and which don't. [ObjectWatcher](../-object-watcher/index.md) uses [key](key.md) to keep track of [KeyedWeakReference](./index.md) instances that haven't made it into the associated [ReferenceQueue](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html) yet. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [key](key.md) | `val key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [name](name.md) | `val name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [retainedUptimeMillis](retained-uptime-millis.md) | `var retainedUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Time at which the associated object ([referent](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html#referent)) was considered retained, or -1 if it hasn't been yet. |
+| [watchUptimeMillis](watch-uptime-millis.md) | `val watchUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+
+### Companion Object Properties
+
+| Name | Summary |
+|---|---|
+| [heapDumpUptimeMillis](heap-dump-uptime-millis.md) | `var heapDumpUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/key.md b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/key.md
new file mode 100644
index 00000000..3757805a
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/key.md
@@ -0,0 +1,5 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [KeyedWeakReference](index.md) / [key](./key.md)
+
+# key
+
+`val key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/name.md b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/name.md
new file mode 100644
index 00000000..ce100a79
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/name.md
@@ -0,0 +1,5 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [KeyedWeakReference](index.md) / [name](./name.md)
+
+# name
+
+`val name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/retained-uptime-millis.md b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/retained-uptime-millis.md
new file mode 100644
index 00000000..6e25e85c
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/retained-uptime-millis.md
@@ -0,0 +1,9 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [KeyedWeakReference](index.md) / [retainedUptimeMillis](./retained-uptime-millis.md)
+
+# retainedUptimeMillis
+
+`var retainedUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Time at which the associated object ([referent](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html#referent)) was considered retained, or -1 if it hasn't
+been yet.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/watch-uptime-millis.md b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/watch-uptime-millis.md
new file mode 100644
index 00000000..7590a067
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-keyed-weak-reference/watch-uptime-millis.md
@@ -0,0 +1,5 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [KeyedWeakReference](index.md) / [watchUptimeMillis](./watch-uptime-millis.md)
+
+# watchUptimeMillis
+
+`val watchUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/-init-.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/-init-.md
new file mode 100644
index 00000000..ac9ace3b
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/-init-.md
@@ -0,0 +1,16 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ObjectWatcher(clock: `[`Clock`](../-clock/index.md)`, checkRetainedExecutor: `[`Executor`](https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html)`, isEnabled: () -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = { true })`
+
+[ObjectWatcher](index.md) can be passed objects to [watch](watch.md). It will create [KeyedWeakReference](../-keyed-weak-reference/index.md) instances
+that reference watches objects, and check if those references have been cleared as expected on
+the [checkRetainedExecutor](#) executor. If not, these objects are considered retained and
+[ObjectWatcher](index.md) will then notify the [onObjectRetainedListener](#) on that executor thread.
+
+[checkRetainedExecutor](#) is expected to run its tasks on a background thread, with a significant
+to give the GC the opportunity to identify weakly reachable objects.
+
+[ObjectWatcher](index.md) is thread safe.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/add-on-object-retained-listener.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/add-on-object-retained-listener.md
new file mode 100644
index 00000000..a0d9c5aa
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/add-on-object-retained-listener.md
@@ -0,0 +1,5 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [addOnObjectRetainedListener](./add-on-object-retained-listener.md)
+
+# addOnObjectRetainedListener
+
+`@Synchronized fun addOnObjectRetainedListener(listener: `[`OnObjectRetainedListener`](../-on-object-retained-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/clear-objects-watched-before.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/clear-objects-watched-before.md
new file mode 100644
index 00000000..de599fab
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/clear-objects-watched-before.md
@@ -0,0 +1,9 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [clearObjectsWatchedBefore](./clear-objects-watched-before.md)
+
+# clearObjectsWatchedBefore
+
+`@Synchronized fun clearObjectsWatchedBefore(heapDumpUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Clears all [KeyedWeakReference](../-keyed-weak-reference/index.md) that were created before [heapDumpUptimeMillis](clear-objects-watched-before.md#leakcanary.ObjectWatcher$clearObjectsWatchedBefore(kotlin.Long)/heapDumpUptimeMillis) (based on
+[clock](../-clock/uptime-millis.md))
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/clear-watched-objects.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/clear-watched-objects.md
new file mode 100644
index 00000000..08b7aa8f
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/clear-watched-objects.md
@@ -0,0 +1,8 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [clearWatchedObjects](./clear-watched-objects.md)
+
+# clearWatchedObjects
+
+`@Synchronized fun clearWatchedObjects(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Clears all [KeyedWeakReference](../-keyed-weak-reference/index.md)
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/has-retained-objects.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/has-retained-objects.md
new file mode 100644
index 00000000..aa973f51
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/has-retained-objects.md
@@ -0,0 +1,9 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [hasRetainedObjects](./has-retained-objects.md)
+
+# hasRetainedObjects
+
+`val hasRetainedObjects: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Returns true if there are watched objects that aren't weakly reachable, and
+have been watched for long enough to be considered retained.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/has-watched-objects.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/has-watched-objects.md
new file mode 100644
index 00000000..06401844
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/has-watched-objects.md
@@ -0,0 +1,9 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [hasWatchedObjects](./has-watched-objects.md)
+
+# hasWatchedObjects
+
+`val hasWatchedObjects: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Returns true if there are watched objects that aren't weakly reachable, even
+if they haven't been watched for long enough to be considered retained.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/index.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/index.md
new file mode 100644
index 00000000..fec9126d
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/index.md
@@ -0,0 +1,40 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](./index.md)
+
+# ObjectWatcher
+
+`class ObjectWatcher`
+
+[ObjectWatcher](./index.md) can be passed objects to [watch](watch.md). It will create [KeyedWeakReference](../-keyed-weak-reference/index.md) instances
+that reference watches objects, and check if those references have been cleared as expected on
+the [checkRetainedExecutor](#) executor. If not, these objects are considered retained and
+[ObjectWatcher](./index.md) will then notify the [onObjectRetainedListener](#) on that executor thread.
+
+[checkRetainedExecutor](#) is expected to run its tasks on a background thread, with a significant
+to give the GC the opportunity to identify weakly reachable objects.
+
+[ObjectWatcher](./index.md) is thread safe.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ObjectWatcher(clock: `[`Clock`](../-clock/index.md)`, checkRetainedExecutor: `[`Executor`](https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html)`, isEnabled: () -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = { true })`<br>[ObjectWatcher](./index.md) can be passed objects to [watch](watch.md). It will create [KeyedWeakReference](../-keyed-weak-reference/index.md) instances that reference watches objects, and check if those references have been cleared as expected on the [checkRetainedExecutor](#) executor. If not, these objects are considered retained and [ObjectWatcher](./index.md) will then notify the [onObjectRetainedListener](#) on that executor thread. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [hasRetainedObjects](has-retained-objects.md) | `val hasRetainedObjects: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if there are watched objects that aren't weakly reachable, and have been watched for long enough to be considered retained. |
+| [hasWatchedObjects](has-watched-objects.md) | `val hasWatchedObjects: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if there are watched objects that aren't weakly reachable, even if they haven't been watched for long enough to be considered retained. |
+| [retainedObjectCount](retained-object-count.md) | `val retainedObjectCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Returns the number of retained objects, ie the number of watched objects that aren't weakly reachable, and have been watched for long enough to be considered retained. |
+| [retainedObjects](retained-objects.md) | `val retainedObjects: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>`<br>Returns the objects that are currently considered retained. Useful for logging purposes. Be careful with those objects and release them ASAP as you may creating longer lived leaks then the one that are already there. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [addOnObjectRetainedListener](add-on-object-retained-listener.md) | `fun addOnObjectRetainedListener(listener: `[`OnObjectRetainedListener`](../-on-object-retained-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [clearObjectsWatchedBefore](clear-objects-watched-before.md) | `fun clearObjectsWatchedBefore(heapDumpUptimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Clears all [KeyedWeakReference](../-keyed-weak-reference/index.md) that were created before [heapDumpUptimeMillis](clear-objects-watched-before.md#leakcanary.ObjectWatcher$clearObjectsWatchedBefore(kotlin.Long)/heapDumpUptimeMillis) (based on [clock](../-clock/uptime-millis.md)) |
+| [clearWatchedObjects](clear-watched-objects.md) | `fun clearWatchedObjects(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Clears all [KeyedWeakReference](../-keyed-weak-reference/index.md) |
+| [removeOnObjectRetainedListener](remove-on-object-retained-listener.md) | `fun removeOnObjectRetainedListener(listener: `[`OnObjectRetainedListener`](../-on-object-retained-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [watch](watch.md) | `fun watch(watchedObject: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Identical to [watch](watch.md) with an empty string reference name.`fun watch(watchedObject: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`, name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Watches the provided [watchedObject](watch.md#leakcanary.ObjectWatcher$watch(kotlin.Any, kotlin.String)/watchedObject). |
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/remove-on-object-retained-listener.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/remove-on-object-retained-listener.md
new file mode 100644
index 00000000..f5e94007
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/remove-on-object-retained-listener.md
@@ -0,0 +1,5 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [removeOnObjectRetainedListener](./remove-on-object-retained-listener.md)
+
+# removeOnObjectRetainedListener
+
+`@Synchronized fun removeOnObjectRetainedListener(listener: `[`OnObjectRetainedListener`](../-on-object-retained-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/retained-object-count.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/retained-object-count.md
new file mode 100644
index 00000000..78cd8918
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/retained-object-count.md
@@ -0,0 +1,9 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [retainedObjectCount](./retained-object-count.md)
+
+# retainedObjectCount
+
+`val retainedObjectCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Returns the number of retained objects, ie the number of watched objects that aren't weakly
+reachable, and have been watched for long enough to be considered retained.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/retained-objects.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/retained-objects.md
new file mode 100644
index 00000000..5b3ad5bb
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/retained-objects.md
@@ -0,0 +1,10 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [retainedObjects](./retained-objects.md)
+
+# retainedObjects
+
+`val retainedObjects: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>`
+
+Returns the objects that are currently considered retained. Useful for logging purposes.
+Be careful with those objects and release them ASAP as you may creating longer lived leaks
+then the one that are already there.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/watch.md b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/watch.md
new file mode 100644
index 00000000..eb6aee84
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-object-watcher/watch.md
@@ -0,0 +1,15 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [ObjectWatcher](index.md) / [watch](./watch.md)
+
+# watch
+
+`@Synchronized fun watch(watchedObject: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Identical to [watch](./watch.md) with an empty string reference name.
+
+`@Synchronized fun watch(watchedObject: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`, name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Watches the provided [watchedObject](watch.md#leakcanary.ObjectWatcher$watch(kotlin.Any, kotlin.String)/watchedObject).
+
+### Parameters
+
+`name` - A logical identifier for the watched object.
\ No newline at end of file
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/index.md b/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/index.md
new file mode 100644
index 00000000..6f7d88a7
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/index.md
@@ -0,0 +1,19 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [OnObjectRetainedListener](./index.md)
+
+# OnObjectRetainedListener
+
+`interface OnObjectRetainedListener`
+
+Listener used by [ObjectWatcher](../-object-watcher/index.md) to report retained objects.
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [onObjectRetained](on-object-retained.md) | `abstract fun onObjectRetained(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>A watched object became retained. |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [invoke](invoke.md) | `operator fun invoke(block: () -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`OnObjectRetainedListener`](./index.md)<br>Utility function to create a [OnObjectRetainedListener](./index.md) from the passed in [block](invoke.md#leakcanary.OnObjectRetainedListener.Companion$invoke(kotlin.Function0((kotlin.Unit)))/block) lambda instead of using the anonymous `object : OnObjectRetainedListener` syntax. |
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/invoke.md b/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/invoke.md
new file mode 100644
index 00000000..7b8dd4f4
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/invoke.md
@@ -0,0 +1,17 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [OnObjectRetainedListener](index.md) / [invoke](./invoke.md)
+
+# invoke
+
+`inline operator fun invoke(crossinline block: () -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`OnObjectRetainedListener`](index.md)
+
+Utility function to create a [OnObjectRetainedListener](index.md) from the passed in [block](invoke.md#leakcanary.OnObjectRetainedListener.Companion$invoke(kotlin.Function0((kotlin.Unit)))/block) lambda
+instead of using the anonymous `object : OnObjectRetainedListener` syntax.
+
+Usage:
+
+``` kotlin
+val listener = OnObjectRetainedListener {
+
+}
+```
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/on-object-retained.md b/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/on-object-retained.md
new file mode 100644
index 00000000..552881ae
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/-on-object-retained-listener/on-object-retained.md
@@ -0,0 +1,8 @@
+[leakcanary-object-watcher](../../index.md) / [leakcanary](../index.md) / [OnObjectRetainedListener](index.md) / [onObjectRetained](./on-object-retained.md)
+
+# onObjectRetained
+
+`abstract fun onObjectRetained(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+A watched object became retained.
+
diff --git a/docs/api/leakcanary-object-watcher/leakcanary/index.md b/docs/api/leakcanary-object-watcher/leakcanary/index.md
new file mode 100644
index 00000000..04452fd5
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/leakcanary/index.md
@@ -0,0 +1,13 @@
+[leakcanary-object-watcher](../index.md) / [leakcanary](./index.md)
+
+## Package leakcanary
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Clock](-clock/index.md) | `interface Clock`<br>An interface to abstract the SystemClock.uptimeMillis() Android API in non Android artifacts. |
+| [GcTrigger](-gc-trigger/index.md) | `interface GcTrigger`<br>[GcTrigger](-gc-trigger/index.md) is used to try triggering garbage collection and enqueuing [KeyedWeakReference](-keyed-weak-reference/index.md) into the associated [java.lang.ref.ReferenceQueue](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html). The default implementation [Default](-gc-trigger/-default/index.md) comes from AOSP. |
+| [KeyedWeakReference](-keyed-weak-reference/index.md) | `class KeyedWeakReference : `[`WeakReference`](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/WeakReference.html)`<`[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>`<br>A weak reference used by [ObjectWatcher](-object-watcher/index.md) to determine which objects become weakly reachable and which don't. [ObjectWatcher](-object-watcher/index.md) uses [key](-keyed-weak-reference/key.md) to keep track of [KeyedWeakReference](-keyed-weak-reference/index.md) instances that haven't made it into the associated [ReferenceQueue](https://docs.oracle.com/javase/6/docs/api/java/lang/ref/ReferenceQueue.html) yet. |
+| [ObjectWatcher](-object-watcher/index.md) | `class ObjectWatcher`<br>[ObjectWatcher](-object-watcher/index.md) can be passed objects to [watch](-object-watcher/watch.md). It will create [KeyedWeakReference](-keyed-weak-reference/index.md) instances that reference watches objects, and check if those references have been cleared as expected on the [checkRetainedExecutor](#) executor. If not, these objects are considered retained and [ObjectWatcher](-object-watcher/index.md) will then notify the [onObjectRetainedListener](#) on that executor thread. |
+| [OnObjectRetainedListener](-on-object-retained-listener/index.md) | `interface OnObjectRetainedListener`<br>Listener used by [ObjectWatcher](-object-watcher/index.md) to report retained objects. |
diff --git a/docs/api/leakcanary-object-watcher/package-list b/docs/api/leakcanary-object-watcher/package-list
new file mode 100644
index 00000000..e886de54
--- /dev/null
+++ b/docs/api/leakcanary-object-watcher/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+leakcanary
diff --git a/docs/api/shark-android/alltypes/index.md b/docs/api/shark-android/alltypes/index.md
new file mode 100644
index 00000000..b64af2fb
--- /dev/null
+++ b/docs/api/shark-android/alltypes/index.md
@@ -0,0 +1,9 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [shark.AndroidBuildMirror](../shark/-android-build-mirror/index.md) | Caches values from the android.os.Build class in the heap dump. Retrieve a cached instances via [fromHeapGraph](../shark/-android-build-mirror/from-heap-graph.md). |
+| [shark.AndroidObjectInspectors](../shark/-android-object-inspectors/index.md) | A set of default [ObjectInspector](#)s that knows about common AOSP and library classes. |
+| [shark.AndroidReferenceMatchers](../shark/-android-reference-matchers/index.md) | [AndroidReferenceMatchers](../shark/-android-reference-matchers/index.md) values add [ReferenceMatcher](#) instances to a global list via their [add](#) method. A [ReferenceMatcher](#) is either a [IgnoredReferenceMatcher](#) or a [LibraryLeakReferenceMatcher](#). |
diff --git a/docs/api/shark-android/index.md b/docs/api/shark-android/index.md
new file mode 100644
index 00000000..7d6042a4
--- /dev/null
+++ b/docs/api/shark-android/index.md
@@ -0,0 +1,11 @@
+[shark-android](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [shark](shark/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-android/package-list b/docs/api/shark-android/package-list
new file mode 100644
index 00000000..415577c3
--- /dev/null
+++ b/docs/api/shark-android/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+shark
diff --git a/docs/api/shark-android/shark/-android-build-mirror/-init-.md b/docs/api/shark-android/shark/-android-build-mirror/-init-.md
new file mode 100644
index 00000000..4725bac3
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-build-mirror/-init-.md
@@ -0,0 +1,9 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidBuildMirror](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`AndroidBuildMirror(manufacturer: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, sdkInt: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+Caches values from the android.os.Build class in the heap dump.
+Retrieve a cached instances via [fromHeapGraph](from-heap-graph.md).
+
diff --git a/docs/api/shark-android/shark/-android-build-mirror/from-heap-graph.md b/docs/api/shark-android/shark/-android-build-mirror/from-heap-graph.md
new file mode 100644
index 00000000..ca98f4cb
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-build-mirror/from-heap-graph.md
@@ -0,0 +1,10 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidBuildMirror](index.md) / [fromHeapGraph](./from-heap-graph.md)
+
+# fromHeapGraph
+
+`fun fromHeapGraph(graph: HeapGraph): `[`AndroidBuildMirror`](index.md)
+
+**See Also**
+
+[AndroidBuildMirror](index.md)
+
diff --git a/docs/api/shark-android/shark/-android-build-mirror/index.md b/docs/api/shark-android/shark/-android-build-mirror/index.md
new file mode 100644
index 00000000..3db12553
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-build-mirror/index.md
@@ -0,0 +1,27 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidBuildMirror](./index.md)
+
+# AndroidBuildMirror
+
+`class AndroidBuildMirror`
+
+Caches values from the android.os.Build class in the heap dump.
+Retrieve a cached instances via [fromHeapGraph](from-heap-graph.md).
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `AndroidBuildMirror(manufacturer: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, sdkInt: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>Caches values from the android.os.Build class in the heap dump. Retrieve a cached instances via [fromHeapGraph](from-heap-graph.md). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [manufacturer](manufacturer.md) | `val manufacturer: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Value of android.os.Build.MANUFACTURER |
+| [sdkInt](sdk-int.md) | `val sdkInt: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Value of android.os.Build.VERSION.SDK_INT |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [fromHeapGraph](from-heap-graph.md) | `fun fromHeapGraph(graph: HeapGraph): `[`AndroidBuildMirror`](./index.md) |
diff --git a/docs/api/shark-android/shark/-android-build-mirror/manufacturer.md b/docs/api/shark-android/shark/-android-build-mirror/manufacturer.md
new file mode 100644
index 00000000..19a6ce74
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-build-mirror/manufacturer.md
@@ -0,0 +1,8 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidBuildMirror](index.md) / [manufacturer](./manufacturer.md)
+
+# manufacturer
+
+`val manufacturer: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Value of android.os.Build.MANUFACTURER
+
diff --git a/docs/api/shark-android/shark/-android-build-mirror/sdk-int.md b/docs/api/shark-android/shark/-android-build-mirror/sdk-int.md
new file mode 100644
index 00000000..8cec616c
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-build-mirror/sdk-int.md
@@ -0,0 +1,8 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidBuildMirror](index.md) / [sdkInt](./sdk-int.md)
+
+# sdkInt
+
+`val sdkInt: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Value of android.os.Build.VERSION.SDK_INT
+
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-a-c-t-i-v-i-t-y/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-a-c-t-i-v-i-t-y/index.md
new file mode 100644
index 00000000..d3521990
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-a-c-t-i-v-i-t-y/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [ACTIVITY](./index.md)
+
+# ACTIVITY
+
+`ACTIVITY`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-a-c-t-i-v-i-t-y/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-a-c-t-i-v-i-t-y/inspect.md
new file mode 100644
index 00000000..abcb5741
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-a-c-t-i-v-i-t-y/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [ACTIVITY](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-a-n-d-r-o-i-d-x_-f-r-a-g-m-e-n-t/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-a-n-d-r-o-i-d-x_-f-r-a-g-m-e-n-t/index.md
new file mode 100644
index 00000000..bb44c283
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-a-n-d-r-o-i-d-x_-f-r-a-g-m-e-n-t/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [ANDROIDX_FRAGMENT](./index.md)
+
+# ANDROIDX_FRAGMENT
+
+`ANDROIDX_FRAGMENT`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-a-n-d-r-o-i-d-x_-f-r-a-g-m-e-n-t/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-a-n-d-r-o-i-d-x_-f-r-a-g-m-e-n-t/inspect.md
new file mode 100644
index 00000000..51b592c9
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-a-n-d-r-o-i-d-x_-f-r-a-g-m-e-n-t/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [ANDROIDX_FRAGMENT](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-a-p-p-l-i-c-a-t-i-o-n/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-a-p-p-l-i-c-a-t-i-o-n/index.md
new file mode 100644
index 00000000..b9a7baff
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-a-p-p-l-i-c-a-t-i-o-n/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [APPLICATION](./index.md)
+
+# APPLICATION
+
+`APPLICATION`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-a-p-p-l-i-c-a-t-i-o-n/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-a-p-p-l-i-c-a-t-i-o-n/inspect.md
new file mode 100644
index 00000000..accac49c
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-a-p-p-l-i-c-a-t-i-o-n/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [APPLICATION](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-c-o-n-t-e-x-t_-w-r-a-p-p-e-r/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-c-o-n-t-e-x-t_-w-r-a-p-p-e-r/index.md
new file mode 100644
index 00000000..e40dfe6e
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-c-o-n-t-e-x-t_-w-r-a-p-p-e-r/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [CONTEXT_WRAPPER](./index.md)
+
+# CONTEXT_WRAPPER
+
+`CONTEXT_WRAPPER`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-c-o-n-t-e-x-t_-w-r-a-p-p-e-r/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-c-o-n-t-e-x-t_-w-r-a-p-p-e-r/inspect.md
new file mode 100644
index 00000000..47a67e17
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-c-o-n-t-e-x-t_-w-r-a-p-p-e-r/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [CONTEXT_WRAPPER](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-c-o-o-r-d-i-n-a-t-o-r/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-c-o-o-r-d-i-n-a-t-o-r/index.md
new file mode 100644
index 00000000..ffcffb82
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-c-o-o-r-d-i-n-a-t-o-r/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [COORDINATOR](./index.md)
+
+# COORDINATOR
+
+`COORDINATOR`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-c-o-o-r-d-i-n-a-t-o-r/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-c-o-o-r-d-i-n-a-t-o-r/inspect.md
new file mode 100644
index 00000000..d8e955b7
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-c-o-o-r-d-i-n-a-t-o-r/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [COORDINATOR](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-d-i-a-l-o-g/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-d-i-a-l-o-g/index.md
new file mode 100644
index 00000000..9dd5cdf7
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-d-i-a-l-o-g/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [DIALOG](./index.md)
+
+# DIALOG
+
+`DIALOG`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-d-i-a-l-o-g/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-d-i-a-l-o-g/inspect.md
new file mode 100644
index 00000000..1cc99533
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-d-i-a-l-o-g/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [DIALOG](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-e-d-i-t-o-r/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-e-d-i-t-o-r/index.md
new file mode 100644
index 00000000..444b5b13
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-e-d-i-t-o-r/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [EDITOR](./index.md)
+
+# EDITOR
+
+`EDITOR`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-e-d-i-t-o-r/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-e-d-i-t-o-r/inspect.md
new file mode 100644
index 00000000..786404fd
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-e-d-i-t-o-r/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [EDITOR](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-f-r-a-g-m-e-n-t/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-f-r-a-g-m-e-n-t/index.md
new file mode 100644
index 00000000..dda93fae
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-f-r-a-g-m-e-n-t/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [FRAGMENT](./index.md)
+
+# FRAGMENT
+
+`FRAGMENT`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-f-r-a-g-m-e-n-t/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-f-r-a-g-m-e-n-t/inspect.md
new file mode 100644
index 00000000..d39e5361
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-f-r-a-g-m-e-n-t/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [FRAGMENT](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r/index.md
new file mode 100644
index 00000000..9f212e2b
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [INPUT_METHOD_MANAGER](./index.md)
+
+# INPUT_METHOD_MANAGER
+
+`INPUT_METHOD_MANAGER`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r/inspect.md
new file mode 100644
index 00000000..e35fd12d
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [INPUT_METHOD_MANAGER](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-m-a-i-n_-t-h-r-e-a-d/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-m-a-i-n_-t-h-r-e-a-d/index.md
new file mode 100644
index 00000000..3ae50fc0
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-m-a-i-n_-t-h-r-e-a-d/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [MAIN_THREAD](./index.md)
+
+# MAIN_THREAD
+
+`MAIN_THREAD`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-m-a-i-n_-t-h-r-e-a-d/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-m-a-i-n_-t-h-r-e-a-d/inspect.md
new file mode 100644
index 00000000..bf2b1455
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-m-a-i-n_-t-h-r-e-a-d/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [MAIN_THREAD](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-m-e-s-s-a-g-e_-q-u-e-u-e/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-m-e-s-s-a-g-e_-q-u-e-u-e/index.md
new file mode 100644
index 00000000..af4479cf
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-m-e-s-s-a-g-e_-q-u-e-u-e/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [MESSAGE_QUEUE](./index.md)
+
+# MESSAGE_QUEUE
+
+`MESSAGE_QUEUE`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-m-e-s-s-a-g-e_-q-u-e-u-e/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-m-e-s-s-a-g-e_-q-u-e-u-e/inspect.md
new file mode 100644
index 00000000..05bfe09d
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-m-e-s-s-a-g-e_-q-u-e-u-e/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [MESSAGE_QUEUE](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-p-r-e-s-e-n-t-e-r/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-p-r-e-s-e-n-t-e-r/index.md
new file mode 100644
index 00000000..520d5746
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-p-r-e-s-e-n-t-e-r/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [MORTAR_PRESENTER](./index.md)
+
+# MORTAR_PRESENTER
+
+`MORTAR_PRESENTER`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-p-r-e-s-e-n-t-e-r/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-p-r-e-s-e-n-t-e-r/inspect.md
new file mode 100644
index 00000000..ed1d3517
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-p-r-e-s-e-n-t-e-r/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [MORTAR_PRESENTER](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-s-c-o-p-e/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-s-c-o-p-e/index.md
new file mode 100644
index 00000000..e6dc3b0a
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-s-c-o-p-e/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [MORTAR_SCOPE](./index.md)
+
+# MORTAR_SCOPE
+
+`MORTAR_SCOPE`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-s-c-o-p-e/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-s-c-o-p-e/inspect.md
new file mode 100644
index 00000000..4038066a
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-m-o-r-t-a-r_-s-c-o-p-e/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [MORTAR_SCOPE](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-s-u-p-p-o-r-t_-f-r-a-g-m-e-n-t/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-s-u-p-p-o-r-t_-f-r-a-g-m-e-n-t/index.md
new file mode 100644
index 00000000..43f2bfc1
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-s-u-p-p-o-r-t_-f-r-a-g-m-e-n-t/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [SUPPORT_FRAGMENT](./index.md)
+
+# SUPPORT_FRAGMENT
+
+`SUPPORT_FRAGMENT`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-s-u-p-p-o-r-t_-f-r-a-g-m-e-n-t/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-s-u-p-p-o-r-t_-f-r-a-g-m-e-n-t/inspect.md
new file mode 100644
index 00000000..8075d150
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-s-u-p-p-o-r-t_-f-r-a-g-m-e-n-t/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [SUPPORT_FRAGMENT](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-t-o-a-s-t/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-t-o-a-s-t/index.md
new file mode 100644
index 00000000..919584bc
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-t-o-a-s-t/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [TOAST](./index.md)
+
+# TOAST
+
+`TOAST`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-t-o-a-s-t/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-t-o-a-s-t/inspect.md
new file mode 100644
index 00000000..cc3b3075
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-t-o-a-s-t/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [TOAST](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w/index.md
new file mode 100644
index 00000000..e1e9a2d3
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [VIEW](./index.md)
+
+# VIEW
+
+`VIEW`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w/inspect.md
new file mode 100644
index 00000000..4dad68bd
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [VIEW](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w_-r-o-o-t_-i-m-p-l/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w_-r-o-o-t_-i-m-p-l/index.md
new file mode 100644
index 00000000..df91cfa0
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w_-r-o-o-t_-i-m-p-l/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [VIEW_ROOT_IMPL](./index.md)
+
+# VIEW_ROOT_IMPL
+
+`VIEW_ROOT_IMPL`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w_-r-o-o-t_-i-m-p-l/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w_-r-o-o-t_-i-m-p-l/inspect.md
new file mode 100644
index 00000000..6f782611
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-v-i-e-w_-r-o-o-t_-i-m-p-l/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [VIEW_ROOT_IMPL](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-w-i-n-d-o-w/index.md b/docs/api/shark-android/shark/-android-object-inspectors/-w-i-n-d-o-w/index.md
new file mode 100644
index 00000000..010fc8ff
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-w-i-n-d-o-w/index.md
@@ -0,0 +1,11 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [WINDOW](./index.md)
+
+# WINDOW
+
+`WINDOW`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/-w-i-n-d-o-w/inspect.md b/docs/api/shark-android/shark/-android-object-inspectors/-w-i-n-d-o-w/inspect.md
new file mode 100644
index 00000000..1fabd10a
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/-w-i-n-d-o-w/inspect.md
@@ -0,0 +1,5 @@
+[shark-android](../../../index.md) / [shark](../../index.md) / [AndroidObjectInspectors](../index.md) / [WINDOW](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: ObjectReporter): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/app-defaults.md b/docs/api/shark-android/shark/-android-object-inspectors/app-defaults.md
new file mode 100644
index 00000000..bed6aebc
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/app-defaults.md
@@ -0,0 +1,10 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidObjectInspectors](index.md) / [appDefaults](./app-defaults.md)
+
+# appDefaults
+
+`val appDefaults: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ObjectInspector>`
+
+**See Also**
+
+[AndroidObjectInspectors](index.md)
+
diff --git a/docs/api/shark-android/shark/-android-object-inspectors/index.md b/docs/api/shark-android/shark/-android-object-inspectors/index.md
new file mode 100644
index 00000000..7a7eb341
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-object-inspectors/index.md
@@ -0,0 +1,47 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidObjectInspectors](./index.md)
+
+# AndroidObjectInspectors
+
+`enum class AndroidObjectInspectors : ObjectInspector`
+
+A set of default [ObjectInspector](#)s that knows about common AOSP and library
+classes.
+
+These are heuristics based on our experience and knowledge of AOSP and various library
+internals. We only make a decision if we're reasonably sure the state of an object is
+unlikely to be the result of a programmer mistake.
+
+For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+will not be influenced by those mistakes.
+
+Most developers should use the entire set of default [ObjectInspector](#) by calling [appDefaults](app-defaults.md),
+unless there's a bug and you temporarily want to remove an inspector.
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [VIEW](-v-i-e-w/index.md) |  |
+| [EDITOR](-e-d-i-t-o-r/index.md) |  |
+| [ACTIVITY](-a-c-t-i-v-i-t-y/index.md) |  |
+| [CONTEXT_WRAPPER](-c-o-n-t-e-x-t_-w-r-a-p-p-e-r/index.md) |  |
+| [DIALOG](-d-i-a-l-o-g/index.md) |  |
+| [APPLICATION](-a-p-p-l-i-c-a-t-i-o-n/index.md) |  |
+| [INPUT_METHOD_MANAGER](-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r/index.md) |  |
+| [FRAGMENT](-f-r-a-g-m-e-n-t/index.md) |  |
+| [SUPPORT_FRAGMENT](-s-u-p-p-o-r-t_-f-r-a-g-m-e-n-t/index.md) |  |
+| [ANDROIDX_FRAGMENT](-a-n-d-r-o-i-d-x_-f-r-a-g-m-e-n-t/index.md) |  |
+| [MESSAGE_QUEUE](-m-e-s-s-a-g-e_-q-u-e-u-e/index.md) |  |
+| [MORTAR_PRESENTER](-m-o-r-t-a-r_-p-r-e-s-e-n-t-e-r/index.md) |  |
+| [MORTAR_SCOPE](-m-o-r-t-a-r_-s-c-o-p-e/index.md) |  |
+| [COORDINATOR](-c-o-o-r-d-i-n-a-t-o-r/index.md) |  |
+| [MAIN_THREAD](-m-a-i-n_-t-h-r-e-a-d/index.md) |  |
+| [VIEW_ROOT_IMPL](-v-i-e-w_-r-o-o-t_-i-m-p-l/index.md) |  |
+| [WINDOW](-w-i-n-d-o-w/index.md) |  |
+| [TOAST](-t-o-a-s-t/index.md) |  |
+
+### Companion Object Properties
+
+| Name | Summary |
+|---|---|
+| [appDefaults](app-defaults.md) | `val appDefaults: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ObjectInspector>` |
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-d_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-d_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..c5bcce5b
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-d_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ACCESSIBILITY_NODE_ID_MANAGER](./-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-d_-m-a-n-a-g-e-r.md)
+
+# ACCESSIBILITY_NODE_ID_MANAGER
+
+`ACCESSIBILITY_NODE_ID_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-n-f-o__-m-o-r-i-g-i-n-a-l-t-e-x-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-n-f-o__-m-o-r-i-g-i-n-a-l-t-e-x-t.md
new file mode 100644
index 00000000..8c7bffb4
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-n-f-o__-m-o-r-i-g-i-n-a-l-t-e-x-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ACCESSIBILITY_NODE_INFO__MORIGINALTEXT](./-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-n-f-o__-m-o-r-i-g-i-n-a-l-t-e-x-t.md)
+
+# ACCESSIBILITY_NODE_INFO__MORIGINALTEXT
+
+`ACCESSIBILITY_NODE_INFO__MORIGINALTEXT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-o-u-n-t_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-o-u-n-t_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..e1dc5586
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-c-o-u-n-t_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ACCOUNT_MANAGER](./-a-c-c-o-u-n-t_-m-a-n-a-g-e-r.md)
+
+# ACCOUNT_MANAGER
+
+`ACCOUNT_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-c-h-o-o-s-e_-m-o-d-e-l.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-c-h-o-o-s-e_-m-o-d-e-l.md
new file mode 100644
index 00000000..5cce0b2a
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-c-h-o-o-s-e_-m-o-d-e-l.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ACTIVITY_CHOOSE_MODEL](./-a-c-t-i-v-i-t-y_-c-h-o-o-s-e_-m-o-d-e-l.md)
+
+# ACTIVITY_CHOOSE_MODEL
+
+`ACTIVITY_CHOOSE_MODEL`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-c-l-i-e-n-t_-r-e-c-o-r-d__-n-e-x-t_-i-d-l-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-c-l-i-e-n-t_-r-e-c-o-r-d__-n-e-x-t_-i-d-l-e.md
new file mode 100644
index 00000000..bb30d9ac
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-c-l-i-e-n-t_-r-e-c-o-r-d__-n-e-x-t_-i-d-l-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ACTIVITY_CLIENT_RECORD__NEXT_IDLE](./-a-c-t-i-v-i-t-y_-c-l-i-e-n-t_-r-e-c-o-r-d__-n-e-x-t_-i-d-l-e.md)
+
+# ACTIVITY_CLIENT_RECORD__NEXT_IDLE
+
+`ACTIVITY_CLIENT_RECORD__NEXT_IDLE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-m-a-n-a-g-e-r_-m-c-o-n-t-e-x-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-m-a-n-a-g-e-r_-m-c-o-n-t-e-x-t.md
new file mode 100644
index 00000000..16d44ef7
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-c-t-i-v-i-t-y_-m-a-n-a-g-e-r_-m-c-o-n-t-e-x-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ACTIVITY_MANAGER_MCONTEXT](./-a-c-t-i-v-i-t-y_-m-a-n-a-g-e-r_-m-c-o-n-t-e-x-t.md)
+
+# ACTIVITY_MANAGER_MCONTEXT
+
+`ACTIVITY_MANAGER_MCONTEXT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-p-p_-w-i-d-g-e-t_-h-o-s-t_-c-a-l-l-b-a-c-k-s.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-p-p_-w-i-d-g-e-t_-h-o-s-t_-c-a-l-l-b-a-c-k-s.md
new file mode 100644
index 00000000..2d14504e
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-p-p_-w-i-d-g-e-t_-h-o-s-t_-c-a-l-l-b-a-c-k-s.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [APP_WIDGET_HOST_CALLBACKS](./-a-p-p_-w-i-d-g-e-t_-h-o-s-t_-c-a-l-l-b-a-c-k-s.md)
+
+# APP_WIDGET_HOST_CALLBACKS
+
+`APP_WIDGET_HOST_CALLBACKS`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-u-d-i-o_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-u-d-i-o_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..2d9ce488
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-u-d-i-o_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [AUDIO_MANAGER](./-a-u-d-i-o_-m-a-n-a-g-e-r.md)
+
+# AUDIO_MANAGER
+
+`AUDIO_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-u-d-i-o_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t_-s-t-a-t-i-c.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-u-d-i-o_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t_-s-t-a-t-i-c.md
new file mode 100644
index 00000000..65043b81
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-u-d-i-o_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t_-s-t-a-t-i-c.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [AUDIO_MANAGER__MCONTEXT_STATIC](./-a-u-d-i-o_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t_-s-t-a-t-i-c.md)
+
+# AUDIO_MANAGER__MCONTEXT_STATIC
+
+`AUDIO_MANAGER__MCONTEXT_STATIC`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-a-w_-r-e-s-o-u-r-c-e__-s-r-e-s-o-u-r-c-e-s.md b/docs/api/shark-android/shark/-android-reference-matchers/-a-w_-r-e-s-o-u-r-c-e__-s-r-e-s-o-u-r-c-e-s.md
new file mode 100644
index 00000000..cf61a60b
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-a-w_-r-e-s-o-u-r-c-e__-s-r-e-s-o-u-r-c-e-s.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [AW_RESOURCE__SRESOURCES](./-a-w_-r-e-s-o-u-r-c-e__-s-r-e-s-o-u-r-c-e-s.md)
+
+# AW_RESOURCE__SRESOURCES
+
+`AW_RESOURCE__SRESOURCES`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-b-a-c-k-d-r-o-p_-f-r-a-m-e_-r-e-n-d-e-r-e-r__-m-d-e-c-o-r-v-i-e-w.md b/docs/api/shark-android/shark/-android-reference-matchers/-b-a-c-k-d-r-o-p_-f-r-a-m-e_-r-e-n-d-e-r-e-r__-m-d-e-c-o-r-v-i-e-w.md
new file mode 100644
index 00000000..35e79b31
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-b-a-c-k-d-r-o-p_-f-r-a-m-e_-r-e-n-d-e-r-e-r__-m-d-e-c-o-r-v-i-e-w.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [BACKDROP_FRAME_RENDERER__MDECORVIEW](./-b-a-c-k-d-r-o-p_-f-r-a-m-e_-r-e-n-d-e-r-e-r__-m-d-e-c-o-r-v-i-e-w.md)
+
+# BACKDROP_FRAME_RENDERER__MDECORVIEW
+
+`BACKDROP_FRAME_RENDERER__MDECORVIEW`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-b-i-o-m-e-t-r-i-c_-p-r-o-m-p-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-b-i-o-m-e-t-r-i-c_-p-r-o-m-p-t.md
new file mode 100644
index 00000000..4a418f6a
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-b-i-o-m-e-t-r-i-c_-p-r-o-m-p-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [BIOMETRIC_PROMPT](./-b-i-o-m-e-t-r-i-c_-p-r-o-m-p-t.md)
+
+# BIOMETRIC_PROMPT
+
+`BIOMETRIC_PROMPT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-b-l-o-c-k-i-n-g_-q-u-e-u-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-b-l-o-c-k-i-n-g_-q-u-e-u-e.md
new file mode 100644
index 00000000..87ee7a80
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-b-l-o-c-k-i-n-g_-q-u-e-u-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [BLOCKING_QUEUE](./-b-l-o-c-k-i-n-g_-q-u-e-u-e.md)
+
+# BLOCKING_QUEUE
+
+`BLOCKING_QUEUE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-b-u-b-b-l-e_-p-o-p-u-p_-h-e-l-p-e-r__-s-h-e-l-p-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-b-u-b-b-l-e_-p-o-p-u-p_-h-e-l-p-e-r__-s-h-e-l-p-e-r.md
new file mode 100644
index 00000000..6236421b
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-b-u-b-b-l-e_-p-o-p-u-p_-h-e-l-p-e-r__-s-h-e-l-p-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [BUBBLE_POPUP_HELPER__SHELPER](./-b-u-b-b-l-e_-p-o-p-u-p_-h-e-l-p-e-r__-s-h-e-l-p-e-r.md)
+
+# BUBBLE_POPUP_HELPER__SHELPER
+
+`BUBBLE_POPUP_HELPER__SHELPER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-c-h-a-n-g-e_-w-a-t-c-h-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-c-h-a-n-g-e_-w-a-t-c-h-e-r.md
new file mode 100644
index 00000000..00ad9647
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-c-h-a-n-g-e_-w-a-t-c-h-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [CHANGE_WATCHER](./-c-h-a-n-g-e_-w-a-t-c-h-e-r.md)
+
+# CHANGE_WATCHER
+
+`CHANGE_WATCHER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-c-l-i-p-b-o-a-r-d_-e-x_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-c-l-i-p-b-o-a-r-d_-e-x_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..39ddae4d
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-c-l-i-p-b-o-a-r-d_-e-x_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [CLIPBOARD_EX_MANAGER](./-c-l-i-p-b-o-a-r-d_-e-x_-m-a-n-a-g-e-r.md)
+
+# CLIPBOARD_EX_MANAGER
+
+`CLIPBOARD_EX_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-c-l-i-p-b-o-a-r-d_-u-i_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-c-l-i-p-b-o-a-r-d_-u-i_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md
new file mode 100644
index 00000000..e3de3f16
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-c-l-i-p-b-o-a-r-d_-u-i_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [CLIPBOARD_UI_MANAGER__SINSTANCE](./-c-l-i-p-b-o-a-r-d_-u-i_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md)
+
+# CLIPBOARD_UI_MANAGER__SINSTANCE
+
+`CLIPBOARD_UI_MANAGER__SINSTANCE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-c-o-n-n-e-c-t-i-v-i-t-y_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-c-o-n-n-e-c-t-i-v-i-t-y_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md
new file mode 100644
index 00000000..60224478
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-c-o-n-n-e-c-t-i-v-i-t-y_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [CONNECTIVITY_MANAGER__SINSTANCE](./-c-o-n-n-e-c-t-i-v-i-t-y_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md)
+
+# CONNECTIVITY_MANAGER__SINSTANCE
+
+`CONNECTIVITY_MANAGER__SINSTANCE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-d-e-v-i-c-e_-p-o-l-i-c-y_-m-a-n-a-g-e-r__-s-e-t-t-i-n-g-s_-o-b-s-e-r-v-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-d-e-v-i-c-e_-p-o-l-i-c-y_-m-a-n-a-g-e-r__-s-e-t-t-i-n-g-s_-o-b-s-e-r-v-e-r.md
new file mode 100644
index 00000000..d490eb31
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-d-e-v-i-c-e_-p-o-l-i-c-y_-m-a-n-a-g-e-r__-s-e-t-t-i-n-g-s_-o-b-s-e-r-v-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER](./-d-e-v-i-c-e_-p-o-l-i-c-y_-m-a-n-a-g-e-r__-s-e-t-t-i-n-g-s_-o-b-s-e-r-v-e-r.md)
+
+# DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER
+
+`DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-e-d-i-t-t-e-x-t_-b-l-i-n-k_-m-e-s-s-a-g-e-q-u-e-u-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-e-d-i-t-t-e-x-t_-b-l-i-n-k_-m-e-s-s-a-g-e-q-u-e-u-e.md
new file mode 100644
index 00000000..6f507c6d
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-e-d-i-t-t-e-x-t_-b-l-i-n-k_-m-e-s-s-a-g-e-q-u-e-u-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [EDITTEXT_BLINK_MESSAGEQUEUE](./-e-d-i-t-t-e-x-t_-b-l-i-n-k_-m-e-s-s-a-g-e-q-u-e-u-e.md)
+
+# EDITTEXT_BLINK_MESSAGEQUEUE
+
+`EDITTEXT_BLINK_MESSAGEQUEUE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-e-v-e-n-t_-r-e-c-e-i-v-e-r__-m-m-e-s-s-a-g-e_-q-u-e-u-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-e-v-e-n-t_-r-e-c-e-i-v-e-r__-m-m-e-s-s-a-g-e_-q-u-e-u-e.md
new file mode 100644
index 00000000..6705018b
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-e-v-e-n-t_-r-e-c-e-i-v-e-r__-m-m-e-s-s-a-g-e_-q-u-e-u-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [EVENT_RECEIVER__MMESSAGE_QUEUE](./-e-v-e-n-t_-r-e-c-e-i-v-e-r__-m-m-e-s-s-a-g-e_-q-u-e-u-e.md)
+
+# EVENT_RECEIVER__MMESSAGE_QUEUE
+
+`EVENT_RECEIVER__MMESSAGE_QUEUE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-f-i-n-a-l-i-z-e-r_-w-a-t-c-h-d-o-g_-d-a-e-m-o-n.md b/docs/api/shark-android/shark/-android-reference-matchers/-f-i-n-a-l-i-z-e-r_-w-a-t-c-h-d-o-g_-d-a-e-m-o-n.md
new file mode 100644
index 00000000..7f7d0ac0
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-f-i-n-a-l-i-z-e-r_-w-a-t-c-h-d-o-g_-d-a-e-m-o-n.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [FINALIZER_WATCHDOG_DAEMON](./-f-i-n-a-l-i-z-e-r_-w-a-t-c-h-d-o-g_-d-a-e-m-o-n.md)
+
+# FINALIZER_WATCHDOG_DAEMON
+
+`FINALIZER_WATCHDOG_DAEMON`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-g-e-s-t-u-r-e_-b-o-o-s-t_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-g-e-s-t-u-r-e_-b-o-o-s-t_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..c2a0076d
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-g-e-s-t-u-r-e_-b-o-o-s-t_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [GESTURE_BOOST_MANAGER](./-g-e-s-t-u-r-e_-b-o-o-s-t_-m-a-n-a-g-e-r.md)
+
+# GESTURE_BOOST_MANAGER
+
+`GESTURE_BOOST_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-h-u-a-w-e-i.md b/docs/api/shark-android/shark/-android-reference-matchers/-h-u-a-w-e-i.md
new file mode 100644
index 00000000..22bf0312
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-h-u-a-w-e-i.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [HUAWEI](./-h-u-a-w-e-i.md)
+
+# HUAWEI
+
+`const val HUAWEI: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r_-i-s_-t-e-r-r-i-b-l-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r_-i-s_-t-e-r-r-i-b-l-e.md
new file mode 100644
index 00000000..879f1dfc
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r_-i-s_-t-e-r-r-i-b-l-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [INPUT_METHOD_MANAGER_IS_TERRIBLE](./-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r_-i-s_-t-e-r-r-i-b-l-e.md)
+
+# INPUT_METHOD_MANAGER_IS_TERRIBLE
+
+`INPUT_METHOD_MANAGER_IS_TERRIBLE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-i-n-s-t-r-u-m-e-n-t-a-t-i-o-n_-r-e-c-o-m-m-e-n-d_-a-c-t-i-v-i-t-y.md b/docs/api/shark-android/shark/-android-reference-matchers/-i-n-s-t-r-u-m-e-n-t-a-t-i-o-n_-r-e-c-o-m-m-e-n-d_-a-c-t-i-v-i-t-y.md
new file mode 100644
index 00000000..f00db08d
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-i-n-s-t-r-u-m-e-n-t-a-t-i-o-n_-r-e-c-o-m-m-e-n-d_-a-c-t-i-v-i-t-y.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [INSTRUMENTATION_RECOMMEND_ACTIVITY](./-i-n-s-t-r-u-m-e-n-t-a-t-i-o-n_-r-e-c-o-m-m-e-n-d_-a-c-t-i-v-i-t-y.md)
+
+# INSTRUMENTATION_RECOMMEND_ACTIVITY
+
+`INSTRUMENTATION_RECOMMEND_ACTIVITY`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-l-a-y-o-u-t_-t-r-a-n-s-i-t-i-o-n.md b/docs/api/shark-android/shark/-android-reference-matchers/-l-a-y-o-u-t_-t-r-a-n-s-i-t-i-o-n.md
new file mode 100644
index 00000000..70f0e2ac
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-l-a-y-o-u-t_-t-r-a-n-s-i-t-i-o-n.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [LAYOUT_TRANSITION](./-l-a-y-o-u-t_-t-r-a-n-s-i-t-i-o-n.md)
+
+# LAYOUT_TRANSITION
+
+`LAYOUT_TRANSITION`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-h-e-a-p_-d-u-m-p-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-h-e-a-p_-d-u-m-p-e-r.md
new file mode 100644
index 00000000..766dcf4f
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-h-e-a-p_-d-u-m-p-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [LEAK_CANARY_HEAP_DUMPER](./-l-e-a-k_-c-a-n-a-r-y_-h-e-a-p_-d-u-m-p-e-r.md)
+
+# LEAK_CANARY_HEAP_DUMPER
+
+`LEAK_CANARY_HEAP_DUMPER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-i-n-t-e-r-n-a-l.md b/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-i-n-t-e-r-n-a-l.md
new file mode 100644
index 00000000..36effd53
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-i-n-t-e-r-n-a-l.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [LEAK_CANARY_INTERNAL](./-l-e-a-k_-c-a-n-a-r-y_-i-n-t-e-r-n-a-l.md)
+
+# LEAK_CANARY_INTERNAL
+
+`LEAK_CANARY_INTERNAL`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-t-h-r-e-a-d.md b/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-t-h-r-e-a-d.md
new file mode 100644
index 00000000..1e4816dd
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-l-e-a-k_-c-a-n-a-r-y_-t-h-r-e-a-d.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [LEAK_CANARY_THREAD](./-l-e-a-k_-c-a-n-a-r-y_-t-h-r-e-a-d.md)
+
+# LEAK_CANARY_THREAD
+
+`LEAK_CANARY_THREAD`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-l-e-n-o-v-o.md b/docs/api/shark-android/shark/-android-reference-matchers/-l-e-n-o-v-o.md
new file mode 100644
index 00000000..12978a7b
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-l-e-n-o-v-o.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [LENOVO](./-l-e-n-o-v-o.md)
+
+# LENOVO
+
+`const val LENOVO: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-l-g-c-o-n-t-e-x-t__-m-c-o-n-t-e-x-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-l-g-c-o-n-t-e-x-t__-m-c-o-n-t-e-x-t.md
new file mode 100644
index 00000000..834f61e5
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-l-g-c-o-n-t-e-x-t__-m-c-o-n-t-e-x-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [LGCONTEXT__MCONTEXT](./-l-g-c-o-n-t-e-x-t__-m-c-o-n-t-e-x-t.md)
+
+# LGCONTEXT__MCONTEXT
+
+`LGCONTEXT__MCONTEXT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-l-g.md b/docs/api/shark-android/shark/-android-reference-matchers/-l-g.md
new file mode 100644
index 00000000..00e272ad
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-l-g.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [LG](./-l-g.md)
+
+# LG
+
+`const val LG: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-m-a-g-n-i-f-i-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-m-a-g-n-i-f-i-e-r.md
new file mode 100644
index 00000000..f8d2f271
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-m-a-g-n-i-f-i-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [MAGNIFIER](./-m-a-g-n-i-f-i-e-r.md)
+
+# MAGNIFIER
+
+`MAGNIFIER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-m-a-i-n.md b/docs/api/shark-android/shark/-android-reference-matchers/-m-a-i-n.md
new file mode 100644
index 00000000..54171dd2
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-m-a-i-n.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [MAIN](./-m-a-i-n.md)
+
+# MAIN
+
+`MAIN`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-m-a-p-p-e-r_-c-l-i-e-n-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-m-a-p-p-e-r_-c-l-i-e-n-t.md
new file mode 100644
index 00000000..ccf8a7e0
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-m-a-p-p-e-r_-c-l-i-e-n-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [MAPPER_CLIENT](./-m-a-p-p-e-r_-c-l-i-e-n-t.md)
+
+# MAPPER_CLIENT
+
+`MAPPER_CLIENT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-p-r-o-j-e-c-t-i-o-n_-c-a-l-l-b-a-c-k.md b/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-p-r-o-j-e-c-t-i-o-n_-c-a-l-l-b-a-c-k.md
new file mode 100644
index 00000000..f21d543e
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-p-r-o-j-e-c-t-i-o-n_-c-a-l-l-b-a-c-k.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [MEDIA_PROJECTION_CALLBACK](./-m-e-d-i-a_-p-r-o-j-e-c-t-i-o-n_-c-a-l-l-b-a-c-k.md)
+
+# MEDIA_PROJECTION_CALLBACK
+
+`MEDIA_PROJECTION_CALLBACK`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-s-c-a-n-n-e-r_-c-o-n-n-e-c-t-i-o-n.md b/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-s-c-a-n-n-e-r_-c-o-n-n-e-c-t-i-o-n.md
new file mode 100644
index 00000000..6b05f4e7
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-s-c-a-n-n-e-r_-c-o-n-n-e-c-t-i-o-n.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [MEDIA_SCANNER_CONNECTION](./-m-e-d-i-a_-s-c-a-n-n-e-r_-c-o-n-n-e-c-t-i-o-n.md)
+
+# MEDIA_SCANNER_CONNECTION
+
+`MEDIA_SCANNER_CONNECTION`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-s-e-s-s-i-o-n_-l-e-g-a-c-y_-h-e-l-p-e-r__-s-i-n-s-t-a-n-c-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-s-e-s-s-i-o-n_-l-e-g-a-c-y_-h-e-l-p-e-r__-s-i-n-s-t-a-n-c-e.md
new file mode 100644
index 00000000..88129761
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-m-e-d-i-a_-s-e-s-s-i-o-n_-l-e-g-a-c-y_-h-e-l-p-e-r__-s-i-n-s-t-a-n-c-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [MEDIA_SESSION_LEGACY_HELPER__SINSTANCE](./-m-e-d-i-a_-s-e-s-s-i-o-n_-l-e-g-a-c-y_-h-e-l-p-e-r__-s-i-n-s-t-a-n-c-e.md)
+
+# MEDIA_SESSION_LEGACY_HELPER__SINSTANCE
+
+`MEDIA_SESSION_LEGACY_HELPER__SINSTANCE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-m-e-i-z-u.md b/docs/api/shark-android/shark/-android-reference-matchers/-m-e-i-z-u.md
new file mode 100644
index 00000000..170fa82a
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-m-e-i-z-u.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [MEIZU](./-m-e-i-z-u.md)
+
+# MEIZU
+
+`const val MEIZU: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-m-o-t-o-r-o-l-a.md b/docs/api/shark-android/shark/-android-reference-matchers/-m-o-t-o-r-o-l-a.md
new file mode 100644
index 00000000..d2934484
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-m-o-t-o-r-o-l-a.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [MOTOROLA](./-m-o-t-o-r-o-l-a.md)
+
+# MOTOROLA
+
+`const val MOTOROLA: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-n-v-i-d-i-a.md b/docs/api/shark-android/shark/-android-reference-matchers/-n-v-i-d-i-a.md
new file mode 100644
index 00000000..9c850b37
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-n-v-i-d-i-a.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [NVIDIA](./-n-v-i-d-i-a.md)
+
+# NVIDIA
+
+`const val NVIDIA: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..b04535d7
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [PERSONA_MANAGER](./-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md)
+
+# PERSONA_MANAGER
+
+`PERSONA_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-r-e-f-e-r-e-n-c-e-s.md b/docs/api/shark-android/shark/-android-reference-matchers/-r-e-f-e-r-e-n-c-e-s.md
new file mode 100644
index 00000000..9bc9f3c5
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-r-e-f-e-r-e-n-c-e-s.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [REFERENCES](./-r-e-f-e-r-e-n-c-e-s.md)
+
+# REFERENCES
+
+`REFERENCES`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-r-e-s-o-u-r-c-e-s__-m-c-o-n-t-e-x-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-r-e-s-o-u-r-c-e-s__-m-c-o-n-t-e-x-t.md
new file mode 100644
index 00000000..528312b6
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-r-e-s-o-u-r-c-e-s__-m-c-o-n-t-e-x-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [RESOURCES__MCONTEXT](./-r-e-s-o-u-r-c-e-s__-m-c-o-n-t-e-x-t.md)
+
+# RESOURCES__MCONTEXT
+
+`RESOURCES__MCONTEXT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-a-m-s-u-n-g.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-a-m-s-u-n-g.md
new file mode 100644
index 00000000..63138a09
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-a-m-s-u-n-g.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SAMSUNG](./-s-a-m-s-u-n-g.md)
+
+# SAMSUNG
+
+`const val SAMSUNG: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-a-p-p_-i-c-o-n_-s-o-l-u-t-i-o-n.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-a-p-p_-i-c-o-n_-s-o-l-u-t-i-o-n.md
new file mode 100644
index 00000000..9af37135
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-a-p-p_-i-c-o-n_-s-o-l-u-t-i-o-n.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SEM_APP_ICON_SOLUTION](./-s-e-m_-a-p-p_-i-c-o-n_-s-o-l-u-t-i-o-n.md)
+
+# SEM_APP_ICON_SOLUTION
+
+`SEM_APP_ICON_SOLUTION`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-c-l-i-p-b-o-a-r-d_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-c-l-i-p-b-o-a-r-d_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md
new file mode 100644
index 00000000..6f7cb331
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-c-l-i-p-b-o-a-r-d_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SEM_CLIPBOARD_MANAGER__MCONTEXT](./-s-e-m_-c-l-i-p-b-o-a-r-d_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md)
+
+# SEM_CLIPBOARD_MANAGER__MCONTEXT
+
+`SEM_CLIPBOARD_MANAGER__MCONTEXT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-e-m-e-r-g-e-n-c-y_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-e-m-e-r-g-e-n-c-y_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md
new file mode 100644
index 00000000..6335951f
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-e-m-e-r-g-e-n-c-y_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SEM_EMERGENCY_MANAGER__MCONTEXT](./-s-e-m_-e-m-e-r-g-e-n-c-y_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md)
+
+# SEM_EMERGENCY_MANAGER__MCONTEXT
+
+`SEM_EMERGENCY_MANAGER__MCONTEXT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..c43d5872
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-e-m_-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SEM_PERSONA_MANAGER](./-s-e-m_-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md)
+
+# SEM_PERSONA_MANAGER
+
+`SEM_PERSONA_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-m-a-r-t_-c-o-v-e-r_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-m-a-r-t_-c-o-v-e-r_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..7212e9e1
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-m-a-r-t_-c-o-v-e-r_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SMART_COVER_MANAGER](./-s-m-a-r-t_-c-o-v-e-r_-m-a-n-a-g-e-r.md)
+
+# SMART_COVER_MANAGER
+
+`SMART_COVER_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-p-a-n_-c-o-n-t-r-o-l-l-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-a-n_-c-o-n-t-r-o-l-l-e-r.md
new file mode 100644
index 00000000..53156d88
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-a-n_-c-o-n-t-r-o-l-l-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SPAN_CONTROLLER](./-s-p-a-n_-c-o-n-t-r-o-l-l-e-r.md)
+
+# SPAN_CONTROLLER
+
+`SPAN_CONTROLLER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-e-c-h_-r-e-c-o-g-n-i-z-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-e-c-h_-r-e-c-o-g-n-i-z-e-r.md
new file mode 100644
index 00000000..49428294
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-e-c-h_-r-e-c-o-g-n-i-z-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SPEECH_RECOGNIZER](./-s-p-e-e-c-h_-r-e-c-o-g-n-i-z-e-r.md)
+
+# SPEECH_RECOGNIZER
+
+`SPEECH_RECOGNIZER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-l-l_-c-h-e-c-k-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-l-l_-c-h-e-c-k-e-r.md
new file mode 100644
index 00000000..90363f30
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-l-l_-c-h-e-c-k-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SPELL_CHECKER](./-s-p-e-l-l_-c-h-e-c-k-e-r.md)
+
+# SPELL_CHECKER
+
+`SPELL_CHECKER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-l-l_-c-h-e-c-k-e-r_-s-e-s-s-i-o-n.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-l-l_-c-h-e-c-k-e-r_-s-e-s-s-i-o-n.md
new file mode 100644
index 00000000..da596f1f
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-l-l_-c-h-e-c-k-e-r_-s-e-s-s-i-o-n.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SPELL_CHECKER_SESSION](./-s-p-e-l-l_-c-h-e-c-k-e-r_-s-e-s-s-i-o-n.md)
+
+# SPELL_CHECKER_SESSION
+
+`SPELL_CHECKER_SESSION`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-n_-g-e-s-t-u-r-e_-m-a-n-a-g-e-r.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-n_-g-e-s-t-u-r-e_-m-a-n-a-g-e-r.md
new file mode 100644
index 00000000..7b19cc0a
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-p-e-n_-g-e-s-t-u-r-e_-m-a-n-a-g-e-r.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SPEN_GESTURE_MANAGER](./-s-p-e-n_-g-e-s-t-u-r-e_-m-a-n-a-g-e-r.md)
+
+# SPEN_GESTURE_MANAGER
+
+`SPEN_GESTURE_MANAGER`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md
new file mode 100644
index 00000000..79903884
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [STATIC_MTARGET_VIEW](./-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md)
+
+# STATIC_MTARGET_VIEW
+
+`STATIC_MTARGET_VIEW`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-y-s-t-e-m_-s-e-n-s-o-r_-m-a-n-a-g-e-r__-m-a-p-p-c-o-n-t-e-x-t-i-m-p-l.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-y-s-t-e-m_-s-e-n-s-o-r_-m-a-n-a-g-e-r__-m-a-p-p-c-o-n-t-e-x-t-i-m-p-l.md
new file mode 100644
index 00000000..719b82ed
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-y-s-t-e-m_-s-e-n-s-o-r_-m-a-n-a-g-e-r__-m-a-p-p-c-o-n-t-e-x-t-i-m-p-l.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL](./-s-y-s-t-e-m_-s-e-n-s-o-r_-m-a-n-a-g-e-r__-m-a-p-p-c-o-n-t-e-x-t-i-m-p-l.md)
+
+# SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL
+
+`SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-l-i-n-e__-s-c-a-c-h-e-d.md b/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-l-i-n-e__-s-c-a-c-h-e-d.md
new file mode 100644
index 00000000..6f9ef812
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-l-i-n-e__-s-c-a-c-h-e-d.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [TEXT_LINE__SCACHED](./-t-e-x-t_-l-i-n-e__-s-c-a-c-h-e-d.md)
+
+# TEXT_LINE__SCACHED
+
+`TEXT_LINE__SCACHED`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-t-o_-s-p-e-e-c-h.md b/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-t-o_-s-p-e-e-c-h.md
new file mode 100644
index 00000000..f560bac2
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-t-o_-s-p-e-e-c-h.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [TEXT_TO_SPEECH](./-t-e-x-t_-t-o_-s-p-e-e-c-h.md)
+
+# TEXT_TO_SPEECH
+
+`TEXT_TO_SPEECH`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-v-i-e-w__-m-l-a-s-t_-h-o-v-e-r-e-d_-v-i-e-w.md b/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-v-i-e-w__-m-l-a-s-t_-h-o-v-e-r-e-d_-v-i-e-w.md
new file mode 100644
index 00000000..81160f14
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-t-e-x-t_-v-i-e-w__-m-l-a-s-t_-h-o-v-e-r-e-d_-v-i-e-w.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [TEXT_VIEW__MLAST_HOVERED_VIEW](./-t-e-x-t_-v-i-e-w__-m-l-a-s-t_-h-o-v-e-r-e-d_-v-i-e-w.md)
+
+# TEXT_VIEW__MLAST_HOVERED_VIEW
+
+`TEXT_VIEW__MLAST_HOVERED_VIEW`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-u-s-e-r_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md b/docs/api/shark-android/shark/-android-reference-matchers/-u-s-e-r_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md
new file mode 100644
index 00000000..f07bdcb7
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-u-s-e-r_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [USER_MANAGER__SINSTANCE](./-u-s-e-r_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md)
+
+# USER_MANAGER__SINSTANCE
+
+`USER_MANAGER__SINSTANCE`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-v-i-e-w-l-o-c-a-t-i-o-n-h-o-l-d-e-r_-r-o-o-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-v-i-e-w-l-o-c-a-t-i-o-n-h-o-l-d-e-r_-r-o-o-t.md
new file mode 100644
index 00000000..387286b8
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-v-i-e-w-l-o-c-a-t-i-o-n-h-o-l-d-e-r_-r-o-o-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [VIEWLOCATIONHOLDER_ROOT](./-v-i-e-w-l-o-c-a-t-i-o-n-h-o-l-d-e-r_-r-o-o-t.md)
+
+# VIEWLOCATIONHOLDER_ROOT
+
+`VIEWLOCATIONHOLDER_ROOT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-v-i-e-w_-c-o-n-f-i-g-u-r-a-t-i-o-n__-m-c-o-n-t-e-x-t.md b/docs/api/shark-android/shark/-android-reference-matchers/-v-i-e-w_-c-o-n-f-i-g-u-r-a-t-i-o-n__-m-c-o-n-t-e-x-t.md
new file mode 100644
index 00000000..933ae2a4
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-v-i-e-w_-c-o-n-f-i-g-u-r-a-t-i-o-n__-m-c-o-n-t-e-x-t.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [VIEW_CONFIGURATION__MCONTEXT](./-v-i-e-w_-c-o-n-f-i-g-u-r-a-t-i-o-n__-m-c-o-n-t-e-x-t.md)
+
+# VIEW_CONFIGURATION__MCONTEXT
+
+`VIEW_CONFIGURATION__MCONTEXT`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-v-i-v-o.md b/docs/api/shark-android/shark/-android-reference-matchers/-v-i-v-o.md
new file mode 100644
index 00000000..07c87254
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-v-i-v-o.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [VIVO](./-v-i-v-o.md)
+
+# VIVO
+
+`const val VIVO: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/app-defaults.md b/docs/api/shark-android/shark/-android-reference-matchers/app-defaults.md
new file mode 100644
index 00000000..e5ea8c0e
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/app-defaults.md
@@ -0,0 +1,10 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [appDefaults](./app-defaults.md)
+
+# appDefaults
+
+`val appDefaults: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher>`
+
+**See Also**
+
+[AndroidReferenceMatchers](index.md)
+
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/build-known-references.md b/docs/api/shark-android/shark/-android-reference-matchers/build-known-references.md
new file mode 100644
index 00000000..5cf9acee
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/build-known-references.md
@@ -0,0 +1,9 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [buildKnownReferences](./build-known-references.md)
+
+# buildKnownReferences
+
+`fun buildKnownReferences(referenceMatchers: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`AndroidReferenceMatchers`](index.md)`>): `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher>`
+
+Builds a list of [ReferenceMatcher](#) from the [referenceMatchers](build-known-references.md#shark.AndroidReferenceMatchers.Companion$buildKnownReferences(kotlin.collections.Set((shark.AndroidReferenceMatchers)))/referenceMatchers) set of
+[AndroidReferenceMatchers](index.md).
+
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/ignored-instance-field.md b/docs/api/shark-android/shark/-android-reference-matchers/ignored-instance-field.md
new file mode 100644
index 00000000..ab3bd1d4
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/ignored-instance-field.md
@@ -0,0 +1,8 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ignoredInstanceField](./ignored-instance-field.md)
+
+# ignoredInstanceField
+
+`fun ignoredInstanceField(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): IgnoredReferenceMatcher`
+
+Creates a [IgnoredReferenceMatcher](#) that matches a [InstanceFieldPattern](#).
+
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/ignored-java-local.md b/docs/api/shark-android/shark/-android-reference-matchers/ignored-java-local.md
new file mode 100644
index 00000000..91cc2cd5
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/ignored-java-local.md
@@ -0,0 +1,8 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ignoredJavaLocal](./ignored-java-local.md)
+
+# ignoredJavaLocal
+
+`fun ignoredJavaLocal(threadName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): IgnoredReferenceMatcher`
+
+Creates a [IgnoredReferenceMatcher](#) that matches a [JavaLocalPattern](#).
+
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/ignored-references-only.md b/docs/api/shark-android/shark/-android-reference-matchers/ignored-references-only.md
new file mode 100644
index 00000000..662844c8
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/ignored-references-only.md
@@ -0,0 +1,9 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [ignoredReferencesOnly](./ignored-references-only.md)
+
+# ignoredReferencesOnly
+
+`val ignoredReferencesOnly: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher>`
+
+Returns a list of [ReferenceMatcher](#) that only contains [IgnoredReferenceMatcher](#) and no
+[LibraryLeakReferenceMatcher](#).
+
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/index.md b/docs/api/shark-android/shark/-android-reference-matchers/index.md
new file mode 100644
index 00000000..ada4a330
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/index.md
@@ -0,0 +1,111 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](./index.md)
+
+# AndroidReferenceMatchers
+
+`enum class AndroidReferenceMatchers`
+
+[AndroidReferenceMatchers](./index.md) values add [ReferenceMatcher](#) instances to a global list via their
+[add](#) method. A [ReferenceMatcher](#) is either a [IgnoredReferenceMatcher](#) or
+a [LibraryLeakReferenceMatcher](#).
+
+[AndroidReferenceMatchers](./index.md) is used to build the list of known references that cannot ever create
+leaks (via [IgnoredReferenceMatcher](#)) as well as the list of known leaks in the Android Framework
+and¬†in manufacturer specific Android implementations.
+
+This class is a work in progress. You can help by reporting leak traces that seem to be caused
+by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+
+We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+manufacturer implementation, they usually share their builds across multiple models, and the
+leaks eventually get fixed in newer versions.
+
+Most app developers should use [appDefaults](app-defaults.md). However, you can also use a subset of
+[AndroidReferenceMatchers](./index.md) by creating an [EnumSet](https://docs.oracle.com/javase/6/docs/api/java/util/EnumSet.html) that matches your needs and calling
+[buildKnownReferences](build-known-references.md).
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [ACTIVITY_CLIENT_RECORD__NEXT_IDLE](-a-c-t-i-v-i-t-y_-c-l-i-e-n-t_-r-e-c-o-r-d__-n-e-x-t_-i-d-l-e.md) |  |
+| [SPAN_CONTROLLER](-s-p-a-n_-c-o-n-t-r-o-l-l-e-r.md) |  |
+| [MEDIA_SESSION_LEGACY_HELPER__SINSTANCE](-m-e-d-i-a_-s-e-s-s-i-o-n_-l-e-g-a-c-y_-h-e-l-p-e-r__-s-i-n-s-t-a-n-c-e.md) |  |
+| [TEXT_LINE__SCACHED](-t-e-x-t_-l-i-n-e__-s-c-a-c-h-e-d.md) |  |
+| [BLOCKING_QUEUE](-b-l-o-c-k-i-n-g_-q-u-e-u-e.md) |  |
+| [INPUT_METHOD_MANAGER_IS_TERRIBLE](-i-n-p-u-t_-m-e-t-h-o-d_-m-a-n-a-g-e-r_-i-s_-t-e-r-r-i-b-l-e.md) |  |
+| [LAYOUT_TRANSITION](-l-a-y-o-u-t_-t-r-a-n-s-i-t-i-o-n.md) |  |
+| [SPELL_CHECKER_SESSION](-s-p-e-l-l_-c-h-e-c-k-e-r_-s-e-s-s-i-o-n.md) |  |
+| [SPELL_CHECKER](-s-p-e-l-l_-c-h-e-c-k-e-r.md) |  |
+| [ACTIVITY_CHOOSE_MODEL](-a-c-t-i-v-i-t-y_-c-h-o-o-s-e_-m-o-d-e-l.md) |  |
+| [MEDIA_PROJECTION_CALLBACK](-m-e-d-i-a_-p-r-o-j-e-c-t-i-o-n_-c-a-l-l-b-a-c-k.md) |  |
+| [SPEECH_RECOGNIZER](-s-p-e-e-c-h_-r-e-c-o-g-n-i-z-e-r.md) |  |
+| [ACCOUNT_MANAGER](-a-c-c-o-u-n-t_-m-a-n-a-g-e-r.md) |  |
+| [MEDIA_SCANNER_CONNECTION](-m-e-d-i-a_-s-c-a-n-n-e-r_-c-o-n-n-e-c-t-i-o-n.md) |  |
+| [USER_MANAGER__SINSTANCE](-u-s-e-r_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md) |  |
+| [APP_WIDGET_HOST_CALLBACKS](-a-p-p_-w-i-d-g-e-t_-h-o-s-t_-c-a-l-l-b-a-c-k-s.md) |  |
+| [AUDIO_MANAGER](-a-u-d-i-o_-m-a-n-a-g-e-r.md) |  |
+| [EDITTEXT_BLINK_MESSAGEQUEUE](-e-d-i-t-t-e-x-t_-b-l-i-n-k_-m-e-s-s-a-g-e-q-u-e-u-e.md) |  |
+| [CONNECTIVITY_MANAGER__SINSTANCE](-c-o-n-n-e-c-t-i-v-i-t-y_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md) |  |
+| [ACCESSIBILITY_NODE_INFO__MORIGINALTEXT](-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-n-f-o__-m-o-r-i-g-i-n-a-l-t-e-x-t.md) |  |
+| [CHANGE_WATCHER](-c-h-a-n-g-e_-w-a-t-c-h-e-r.md) |  |
+| [BIOMETRIC_PROMPT](-b-i-o-m-e-t-r-i-c_-p-r-o-m-p-t.md) |  |
+| [MAGNIFIER](-m-a-g-n-i-f-i-e-r.md) |  |
+| [BACKDROP_FRAME_RENDERER__MDECORVIEW](-b-a-c-k-d-r-o-p_-f-r-a-m-e_-r-e-n-d-e-r-e-r__-m-d-e-c-o-r-v-i-e-w.md) |  |
+| [VIEWLOCATIONHOLDER_ROOT](-v-i-e-w-l-o-c-a-t-i-o-n-h-o-l-d-e-r_-r-o-o-t.md) |  |
+| [ACCESSIBILITY_NODE_ID_MANAGER](-a-c-c-e-s-s-i-b-i-l-i-t-y_-n-o-d-e_-i-d_-m-a-n-a-g-e-r.md) |  |
+| [TEXT_TO_SPEECH](-t-e-x-t_-t-o_-s-p-e-e-c-h.md) |  |
+| [SPEN_GESTURE_MANAGER](-s-p-e-n_-g-e-s-t-u-r-e_-m-a-n-a-g-e-r.md) |  |
+| [CLIPBOARD_UI_MANAGER__SINSTANCE](-c-l-i-p-b-o-a-r-d_-u-i_-m-a-n-a-g-e-r__-s-i-n-s-t-a-n-c-e.md) |  |
+| [SEM_CLIPBOARD_MANAGER__MCONTEXT](-s-e-m_-c-l-i-p-b-o-a-r-d_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md) |  |
+| [CLIPBOARD_EX_MANAGER](-c-l-i-p-b-o-a-r-d_-e-x_-m-a-n-a-g-e-r.md) |  |
+| [SEM_EMERGENCY_MANAGER__MCONTEXT](-s-e-m_-e-m-e-r-g-e-n-c-y_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t.md) |  |
+| [SEM_PERSONA_MANAGER](-s-e-m_-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md) |  |
+| [SEM_APP_ICON_SOLUTION](-s-e-m_-a-p-p_-i-c-o-n_-s-o-l-u-t-i-o-n.md) |  |
+| [AW_RESOURCE__SRESOURCES](-a-w_-r-e-s-o-u-r-c-e__-s-r-e-s-o-u-r-c-e-s.md) |  |
+| [TEXT_VIEW__MLAST_HOVERED_VIEW](-t-e-x-t_-v-i-e-w__-m-l-a-s-t_-h-o-v-e-r-e-d_-v-i-e-w.md) |  |
+| [PERSONA_MANAGER](-p-e-r-s-o-n-a_-m-a-n-a-g-e-r.md) |  |
+| [RESOURCES__MCONTEXT](-r-e-s-o-u-r-c-e-s__-m-c-o-n-t-e-x-t.md) |  |
+| [VIEW_CONFIGURATION__MCONTEXT](-v-i-e-w_-c-o-n-f-i-g-u-r-a-t-i-o-n__-m-c-o-n-t-e-x-t.md) |  |
+| [AUDIO_MANAGER__MCONTEXT_STATIC](-a-u-d-i-o_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t_-s-t-a-t-i-c.md) |  |
+| [ACTIVITY_MANAGER_MCONTEXT](-a-c-t-i-v-i-t-y_-m-a-n-a-g-e-r_-m-c-o-n-t-e-x-t.md) |  |
+| [STATIC_MTARGET_VIEW](-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md) |  |
+| [GESTURE_BOOST_MANAGER](-g-e-s-t-u-r-e_-b-o-o-s-t_-m-a-n-a-g-e-r.md) |  |
+| [BUBBLE_POPUP_HELPER__SHELPER](-b-u-b-b-l-e_-p-o-p-u-p_-h-e-l-p-e-r__-s-h-e-l-p-e-r.md) |  |
+| [LGCONTEXT__MCONTEXT](-l-g-c-o-n-t-e-x-t__-m-c-o-n-t-e-x-t.md) |  |
+| [SMART_COVER_MANAGER](-s-m-a-r-t_-c-o-v-e-r_-m-a-n-a-g-e-r.md) |  |
+| [MAPPER_CLIENT](-m-a-p-p-e-r_-c-l-i-e-n-t.md) |  |
+| [SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL](-s-y-s-t-e-m_-s-e-n-s-o-r_-m-a-n-a-g-e-r__-m-a-p-p-c-o-n-t-e-x-t-i-m-p-l.md) |  |
+| [INSTRUMENTATION_RECOMMEND_ACTIVITY](-i-n-s-t-r-u-m-e-n-t-a-t-i-o-n_-r-e-c-o-m-m-e-n-d_-a-c-t-i-v-i-t-y.md) |  |
+| [DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER](-d-e-v-i-c-e_-p-o-l-i-c-y_-m-a-n-a-g-e-r__-s-e-t-t-i-n-g-s_-o-b-s-e-r-v-e-r.md) |  |
+| [REFERENCES](-r-e-f-e-r-e-n-c-e-s.md) |  |
+| [FINALIZER_WATCHDOG_DAEMON](-f-i-n-a-l-i-z-e-r_-w-a-t-c-h-d-o-g_-d-a-e-m-o-n.md) |  |
+| [MAIN](-m-a-i-n.md) |  |
+| [LEAK_CANARY_THREAD](-l-e-a-k_-c-a-n-a-r-y_-t-h-r-e-a-d.md) |  |
+| [LEAK_CANARY_HEAP_DUMPER](-l-e-a-k_-c-a-n-a-r-y_-h-e-a-p_-d-u-m-p-e-r.md) |  |
+| [LEAK_CANARY_INTERNAL](-l-e-a-k_-c-a-n-a-r-y_-i-n-t-e-r-n-a-l.md) |  |
+| [EVENT_RECEIVER__MMESSAGE_QUEUE](-e-v-e-n-t_-r-e-c-e-i-v-e-r__-m-m-e-s-s-a-g-e_-q-u-e-u-e.md) |  |
+
+### Companion Object Properties
+
+| Name | Summary |
+|---|---|
+| [appDefaults](app-defaults.md) | `val appDefaults: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher>` |
+| [HUAWEI](-h-u-a-w-e-i.md) | `const val HUAWEI: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [ignoredReferencesOnly](ignored-references-only.md) | `val ignoredReferencesOnly: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher>`<br>Returns a list of [ReferenceMatcher](#) that only contains [IgnoredReferenceMatcher](#) and no [LibraryLeakReferenceMatcher](#). |
+| [LENOVO](-l-e-n-o-v-o.md) | `const val LENOVO: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [LG](-l-g.md) | `const val LG: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [MEIZU](-m-e-i-z-u.md) | `const val MEIZU: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [MOTOROLA](-m-o-t-o-r-o-l-a.md) | `const val MOTOROLA: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [NVIDIA](-n-v-i-d-i-a.md) | `const val NVIDIA: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [SAMSUNG](-s-a-m-s-u-n-g.md) | `const val SAMSUNG: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [VIVO](-v-i-v-o.md) | `const val VIVO: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [buildKnownReferences](build-known-references.md) | `fun buildKnownReferences(referenceMatchers: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`AndroidReferenceMatchers`](./index.md)`>): `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<ReferenceMatcher>`<br>Builds a list of [ReferenceMatcher](#) from the [referenceMatchers](build-known-references.md#shark.AndroidReferenceMatchers.Companion$buildKnownReferences(kotlin.collections.Set((shark.AndroidReferenceMatchers)))/referenceMatchers) set of [AndroidReferenceMatchers](./index.md). |
+| [ignoredInstanceField](ignored-instance-field.md) | `fun ignoredInstanceField(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): IgnoredReferenceMatcher`<br>Creates a [IgnoredReferenceMatcher](#) that matches a [InstanceFieldPattern](#). |
+| [ignoredJavaLocal](ignored-java-local.md) | `fun ignoredJavaLocal(threadName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): IgnoredReferenceMatcher`<br>Creates a [IgnoredReferenceMatcher](#) that matches a [JavaLocalPattern](#). |
+| [instanceFieldLeak](instance-field-leak.md) | `fun instanceFieldLeak(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)` = "", patternApplies: `[`AndroidBuildMirror`](../-android-build-mirror/index.md)`.() -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = ALWAYS): LibraryLeakReferenceMatcher`<br>Creates a [LibraryLeakReferenceMatcher](#) that matches a [InstanceFieldPattern](#). [description](instance-field-leak.md#shark.AndroidReferenceMatchers.Companion$instanceFieldLeak(kotlin.String, kotlin.String, kotlin.String, kotlin.Function1((shark.AndroidBuildMirror, kotlin.Boolean)))/description) should convey what we know about this library leak. |
+| [staticFieldLeak](static-field-leak.md) | `fun staticFieldLeak(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)` = "", patternApplies: `[`AndroidBuildMirror`](../-android-build-mirror/index.md)`.() -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = ALWAYS): LibraryLeakReferenceMatcher`<br>Creates a [LibraryLeakReferenceMatcher](#) that matches a [StaticFieldPattern](#). [description](static-field-leak.md#shark.AndroidReferenceMatchers.Companion$staticFieldLeak(kotlin.String, kotlin.String, kotlin.String, kotlin.Function1((shark.AndroidBuildMirror, kotlin.Boolean)))/description) should convey what we know about this library leak. |
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/instance-field-leak.md b/docs/api/shark-android/shark/-android-reference-matchers/instance-field-leak.md
new file mode 100644
index 00000000..e8b3df63
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/instance-field-leak.md
@@ -0,0 +1,9 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [instanceFieldLeak](./instance-field-leak.md)
+
+# instanceFieldLeak
+
+`fun instanceFieldLeak(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)` = "", patternApplies: `[`AndroidBuildMirror`](../-android-build-mirror/index.md)`.() -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = ALWAYS): LibraryLeakReferenceMatcher`
+
+Creates a [LibraryLeakReferenceMatcher](#) that matches a [InstanceFieldPattern](#).
+[description](instance-field-leak.md#shark.AndroidReferenceMatchers.Companion$instanceFieldLeak(kotlin.String, kotlin.String, kotlin.String, kotlin.Function1((shark.AndroidBuildMirror, kotlin.Boolean)))/description) should convey what we know about this library leak.
+
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/static-field-leak.md b/docs/api/shark-android/shark/-android-reference-matchers/static-field-leak.md
new file mode 100644
index 00000000..8da2d8ea
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/static-field-leak.md
@@ -0,0 +1,9 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [staticFieldLeak](./static-field-leak.md)
+
+# staticFieldLeak
+
+`fun staticFieldLeak(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)` = "", patternApplies: `[`AndroidBuildMirror`](../-android-build-mirror/index.md)`.() -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = ALWAYS): LibraryLeakReferenceMatcher`
+
+Creates a [LibraryLeakReferenceMatcher](#) that matches a [StaticFieldPattern](#).
+[description](static-field-leak.md#shark.AndroidReferenceMatchers.Companion$staticFieldLeak(kotlin.String, kotlin.String, kotlin.String, kotlin.Function1((shark.AndroidBuildMirror, kotlin.Boolean)))/description) should convey what we know about this library leak.
+
diff --git a/docs/api/shark-android/shark/index.md b/docs/api/shark-android/shark/index.md
new file mode 100644
index 00000000..ed70a6ae
--- /dev/null
+++ b/docs/api/shark-android/shark/index.md
@@ -0,0 +1,17 @@
+[shark-android](../index.md) / [shark](./index.md)
+
+## Package shark
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [AndroidBuildMirror](-android-build-mirror/index.md) | `class AndroidBuildMirror`<br>Caches values from the android.os.Build class in the heap dump. Retrieve a cached instances via [fromHeapGraph](-android-build-mirror/from-heap-graph.md). |
+| [AndroidObjectInspectors](-android-object-inspectors/index.md) | `enum class AndroidObjectInspectors : ObjectInspector`<br>A set of default [ObjectInspector](#)s that knows about common AOSP and library classes. |
+| [AndroidReferenceMatchers](-android-reference-matchers/index.md) | `enum class AndroidReferenceMatchers`<br>[AndroidReferenceMatchers](-android-reference-matchers/index.md) values add [ReferenceMatcher](#) instances to a global list via their [add](#) method. A [ReferenceMatcher](#) is either a [IgnoredReferenceMatcher](#) or a [LibraryLeakReferenceMatcher](#). |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [unwrapActivityContext](unwrap-activity-context.md) | `fun HeapInstance.unwrapActivityContext(): HeapInstance?`<br>Recursively unwraps `this` [HeapInstance](#) as a ContextWrapper until an Activity is found in which case it is returned. Returns null if no activity was found. |
diff --git a/docs/api/shark-android/shark/unwrap-activity-context.md b/docs/api/shark-android/shark/unwrap-activity-context.md
new file mode 100644
index 00000000..c64b3db0
--- /dev/null
+++ b/docs/api/shark-android/shark/unwrap-activity-context.md
@@ -0,0 +1,9 @@
+[shark-android](../index.md) / [shark](index.md) / [unwrapActivityContext](./unwrap-activity-context.md)
+
+# unwrapActivityContext
+
+`fun HeapInstance.unwrapActivityContext(): HeapInstance?`
+
+Recursively unwraps `this` [HeapInstance](#) as a ContextWrapper until an Activity is found in which case it is
+returned. Returns null if no activity was found.
+
diff --git a/docs/api/shark-graph/alltypes/index.md b/docs/api/shark-graph/alltypes/index.md
new file mode 100644
index 00000000..ea62e3ed
--- /dev/null
+++ b/docs/api/shark-graph/alltypes/index.md
@@ -0,0 +1,12 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [shark.GraphContext](../shark/-graph-context/index.md) | In memory store that can be used to store objects in a given [HeapGraph](../shark/-heap-graph/index.md) instance. This is a simple [MutableMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/index.html) of [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) to [Any](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html), but with unsafe generics access. |
+| [shark.HeapField](../shark/-heap-field/index.md) | Represents a static field or an instance field. |
+| [shark.HeapGraph](../shark/-heap-graph/index.md) | Enables navigation through the heap graph of objects. |
+| [shark.HeapObject](../shark/-heap-object/index.md) | An object in the heap dump. |
+| [shark.HeapValue](../shark/-heap-value/index.md) | Represents a value in the heap dump, which can be an object reference or a primitive type. |
+| [shark.HprofHeapGraph](../shark/-hprof-heap-graph/index.md) | A [HeapGraph](../shark/-heap-graph/index.md) that reads from an indexed [Hprof](#). Create a new instance with [indexHprof](../shark/-hprof-heap-graph/index-hprof.md). |
diff --git a/docs/api/shark-graph/index.md b/docs/api/shark-graph/index.md
new file mode 100644
index 00000000..3230fc45
--- /dev/null
+++ b/docs/api/shark-graph/index.md
@@ -0,0 +1,11 @@
+[shark-graph](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [shark](shark/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-graph/package-list b/docs/api/shark-graph/package-list
new file mode 100644
index 00000000..415577c3
--- /dev/null
+++ b/docs/api/shark-graph/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+shark
diff --git a/docs/api/shark-graph/shark/-graph-context/-init-.md b/docs/api/shark-graph/shark/-graph-context/-init-.md
new file mode 100644
index 00000000..23ec90a1
--- /dev/null
+++ b/docs/api/shark-graph/shark/-graph-context/-init-.md
@@ -0,0 +1,9 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [GraphContext](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`GraphContext()`
+
+In memory store that can be used to store objects in a given [HeapGraph](../-heap-graph/index.md) instance.
+This is a simple [MutableMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/index.html) of [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) to [Any](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html), but with unsafe generics access.
+
diff --git a/docs/api/shark-graph/shark/-graph-context/contains.md b/docs/api/shark-graph/shark/-graph-context/contains.md
new file mode 100644
index 00000000..c73f01fe
--- /dev/null
+++ b/docs/api/shark-graph/shark/-graph-context/contains.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [GraphContext](index.md) / [contains](./contains.md)
+
+# contains
+
+`operator fun contains(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+**See Also**
+
+[MutableMap.containsKey](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/contains-key.html)
+
diff --git a/docs/api/shark-graph/shark/-graph-context/get-or-put.md b/docs/api/shark-graph/shark/-graph-context/get-or-put.md
new file mode 100644
index 00000000..80fa34b9
--- /dev/null
+++ b/docs/api/shark-graph/shark/-graph-context/get-or-put.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [GraphContext](index.md) / [getOrPut](./get-or-put.md)
+
+# getOrPut
+
+`fun <T> getOrPut(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, defaultValue: () -> `[`T`](get-or-put.md#T)`): `[`T`](get-or-put.md#T)
+
+**See Also**
+
+[MutableMap.getOrPut](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-or-put.html)
+
diff --git a/docs/api/shark-graph/shark/-graph-context/get.md b/docs/api/shark-graph/shark/-graph-context/get.md
new file mode 100644
index 00000000..28c7e4c3
--- /dev/null
+++ b/docs/api/shark-graph/shark/-graph-context/get.md
@@ -0,0 +1,5 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [GraphContext](index.md) / [get](./get.md)
+
+# get
+
+`operator fun <T> get(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`T`](get.md#T)`?`
\ No newline at end of file
diff --git a/docs/api/shark-graph/shark/-graph-context/index.md b/docs/api/shark-graph/shark/-graph-context/index.md
new file mode 100644
index 00000000..0509cd2c
--- /dev/null
+++ b/docs/api/shark-graph/shark/-graph-context/index.md
@@ -0,0 +1,24 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [GraphContext](./index.md)
+
+# GraphContext
+
+`class GraphContext`
+
+In memory store that can be used to store objects in a given [HeapGraph](../-heap-graph/index.md) instance.
+This is a simple [MutableMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/index.html) of [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) to [Any](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html), but with unsafe generics access.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `GraphContext()`<br>In memory store that can be used to store objects in a given [HeapGraph](../-heap-graph/index.md) instance. This is a simple [MutableMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/index.html) of [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) to [Any](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html), but with unsafe generics access. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [contains](contains.md) | `operator fun contains(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
+| [get](get.md) | `operator fun <T> get(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`T`](get.md#T)`?` |
+| [getOrPut](get-or-put.md) | `fun <T> getOrPut(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, defaultValue: () -> `[`T`](get-or-put.md#T)`): `[`T`](get-or-put.md#T) |
+| [minusAssign](minus-assign.md) | `operator fun minusAssign(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [set](set.md) | `operator fun <T> set(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, value: `[`T`](set.md#T)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-graph/shark/-graph-context/minus-assign.md b/docs/api/shark-graph/shark/-graph-context/minus-assign.md
new file mode 100644
index 00000000..77641f91
--- /dev/null
+++ b/docs/api/shark-graph/shark/-graph-context/minus-assign.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [GraphContext](index.md) / [minusAssign](./minus-assign.md)
+
+# minusAssign
+
+`operator fun minusAssign(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+**See Also**
+
+[MutableMap.remove](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove.html)
+
diff --git a/docs/api/shark-graph/shark/-graph-context/set.md b/docs/api/shark-graph/shark/-graph-context/set.md
new file mode 100644
index 00000000..701480ac
--- /dev/null
+++ b/docs/api/shark-graph/shark/-graph-context/set.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [GraphContext](index.md) / [set](./set.md)
+
+# set
+
+`operator fun <T> set(key: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, value: `[`T`](set.md#T)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+**See Also**
+
+[MutableMap.set](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/set.html)
+
diff --git a/docs/api/shark-graph/shark/-heap-field/-init-.md b/docs/api/shark-graph/shark/-heap-field/-init-.md
new file mode 100644
index 00000000..47dac96c
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/-init-.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HeapField(declaringClass: `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`, name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, value: `[`HeapValue`](../-heap-value/index.md)`)`
+
+Represents a static field or an instance field.
+
diff --git a/docs/api/shark-graph/shark/-heap-field/declaring-class.md b/docs/api/shark-graph/shark/-heap-field/declaring-class.md
new file mode 100644
index 00000000..e8d5344d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/declaring-class.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](index.md) / [declaringClass](./declaring-class.md)
+
+# declaringClass
+
+`val declaringClass: `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)
+
+The class this field was declared in.
+
diff --git a/docs/api/shark-graph/shark/-heap-field/index.md b/docs/api/shark-graph/shark/-heap-field/index.md
new file mode 100644
index 00000000..1de0864e
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/index.md
@@ -0,0 +1,25 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](./index.md)
+
+# HeapField
+
+`class HeapField`
+
+Represents a static field or an instance field.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HeapField(declaringClass: `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`, name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, value: `[`HeapValue`](../-heap-value/index.md)`)`<br>Represents a static field or an instance field. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [declaringClass](declaring-class.md) | `val declaringClass: `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)<br>The class this field was declared in. |
+| [name](name.md) | `val name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Name of the field |
+| [value](value.md) | `val value: `[`HeapValue`](../-heap-value/index.md)<br>Value of the field. Also see shorthands [valueAsClass](value-as-class.md), [valueAsInstance](value-as-instance.md), [valueAsObjectArray](value-as-object-array.md), [valueAsPrimitiveArray](value-as-primitive-array.md). |
+| [valueAsClass](value-as-class.md) | `val valueAsClass: `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`?`<br>Return a [HeapClass](../-heap-object/-heap-class/index.md) is [value](value.md) references a class, and null otherwise. |
+| [valueAsInstance](value-as-instance.md) | `val valueAsInstance: `[`HeapObject.HeapInstance`](../-heap-object/-heap-instance/index.md)`?`<br>Return a [HeapInstance](../-heap-object/-heap-instance/index.md) is [value](value.md) references an instance, and null otherwise. |
+| [valueAsObjectArray](value-as-object-array.md) | `val valueAsObjectArray: `[`HeapObject.HeapObjectArray`](../-heap-object/-heap-object-array/index.md)`?`<br>Return a [HeapObjectArray](../-heap-object/-heap-object-array/index.md) is [value](value.md) references an object array, and null otherwise. |
+| [valueAsPrimitiveArray](value-as-primitive-array.md) | `val valueAsPrimitiveArray: `[`HeapObject.HeapPrimitiveArray`](../-heap-object/-heap-primitive-array/index.md)`?`<br>Return a [HeapPrimitiveArray](../-heap-object/-heap-primitive-array/index.md) is [value](value.md) references a primitive array, and null otherwise. |
diff --git a/docs/api/shark-graph/shark/-heap-field/name.md b/docs/api/shark-graph/shark/-heap-field/name.md
new file mode 100644
index 00000000..23e4fad1
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/name.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](index.md) / [name](./name.md)
+
+# name
+
+`val name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Name of the field
+
diff --git a/docs/api/shark-graph/shark/-heap-field/value-as-class.md b/docs/api/shark-graph/shark/-heap-field/value-as-class.md
new file mode 100644
index 00000000..a28c3f0e
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/value-as-class.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](index.md) / [valueAsClass](./value-as-class.md)
+
+# valueAsClass
+
+`val valueAsClass: `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`?`
+
+Return a [HeapClass](../-heap-object/-heap-class/index.md) is [value](value.md) references a class, and null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-field/value-as-instance.md b/docs/api/shark-graph/shark/-heap-field/value-as-instance.md
new file mode 100644
index 00000000..ed173f2d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/value-as-instance.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](index.md) / [valueAsInstance](./value-as-instance.md)
+
+# valueAsInstance
+
+`val valueAsInstance: `[`HeapObject.HeapInstance`](../-heap-object/-heap-instance/index.md)`?`
+
+Return a [HeapInstance](../-heap-object/-heap-instance/index.md) is [value](value.md) references an instance, and null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-field/value-as-object-array.md b/docs/api/shark-graph/shark/-heap-field/value-as-object-array.md
new file mode 100644
index 00000000..fc641c26
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/value-as-object-array.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](index.md) / [valueAsObjectArray](./value-as-object-array.md)
+
+# valueAsObjectArray
+
+`val valueAsObjectArray: `[`HeapObject.HeapObjectArray`](../-heap-object/-heap-object-array/index.md)`?`
+
+Return a [HeapObjectArray](../-heap-object/-heap-object-array/index.md) is [value](value.md) references an object array, and null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-field/value-as-primitive-array.md b/docs/api/shark-graph/shark/-heap-field/value-as-primitive-array.md
new file mode 100644
index 00000000..85534bf9
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/value-as-primitive-array.md
@@ -0,0 +1,9 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](index.md) / [valueAsPrimitiveArray](./value-as-primitive-array.md)
+
+# valueAsPrimitiveArray
+
+`val valueAsPrimitiveArray: `[`HeapObject.HeapPrimitiveArray`](../-heap-object/-heap-primitive-array/index.md)`?`
+
+Return a [HeapPrimitiveArray](../-heap-object/-heap-primitive-array/index.md) is [value](value.md) references a primitive array, and null
+otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-field/value.md b/docs/api/shark-graph/shark/-heap-field/value.md
new file mode 100644
index 00000000..a8564336
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-field/value.md
@@ -0,0 +1,9 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapField](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`HeapValue`](../-heap-value/index.md)
+
+Value of the field. Also see shorthands [valueAsClass](value-as-class.md), [valueAsInstance](value-as-instance.md),
+[valueAsObjectArray](value-as-object-array.md), [valueAsPrimitiveArray](value-as-primitive-array.md).
+
diff --git a/docs/api/shark-graph/shark/-heap-graph/classes.md b/docs/api/shark-graph/shark/-heap-graph/classes.md
new file mode 100644
index 00000000..df5d49b1
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/classes.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [classes](./classes.md)
+
+# classes
+
+`abstract val classes: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`>`
+
+Sequence of all classes in the heap dump.
+
+This sequence does not trigger any IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-graph/context.md b/docs/api/shark-graph/shark/-heap-graph/context.md
new file mode 100644
index 00000000..10e6a7ea
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/context.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [context](./context.md)
+
+# context
+
+`abstract val context: `[`GraphContext`](../-graph-context/index.md)
+
+In memory store that can be used to store objects this [HeapGraph](index.md) instance.
+
diff --git a/docs/api/shark-graph/shark/-heap-graph/find-class-by-name.md b/docs/api/shark-graph/shark/-heap-graph/find-class-by-name.md
new file mode 100644
index 00000000..3b7e9488
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/find-class-by-name.md
@@ -0,0 +1,9 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [findClassByName](./find-class-by-name.md)
+
+# findClassByName
+
+`abstract fun findClassByName(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`?`
+
+Returns the [HeapClass](../-heap-object/-heap-class/index.md) corresponding to the provided [className](find-class-by-name.md#shark.HeapGraph$findClassByName(kotlin.String)/className), or null if the
+class cannot be found.
+
diff --git a/docs/api/shark-graph/shark/-heap-graph/find-object-by-id.md b/docs/api/shark-graph/shark/-heap-graph/find-object-by-id.md
new file mode 100644
index 00000000..857c9c35
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/find-object-by-id.md
@@ -0,0 +1,9 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [findObjectById](./find-object-by-id.md)
+
+# findObjectById
+
+`abstract fun findObjectById(objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`HeapObject`](../-heap-object/index.md)
+
+Returns the [HeapObject](../-heap-object/index.md) corresponding to the provided [objectId](find-object-by-id.md#shark.HeapGraph$findObjectById(kotlin.Long)/objectId), and throws
+[IllegalArgumentException](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-argument-exception/index.html) otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-graph/gc-roots.md b/docs/api/shark-graph/shark/-heap-graph/gc-roots.md
new file mode 100644
index 00000000..88feeef8
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/gc-roots.md
@@ -0,0 +1,11 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [gcRoots](./gc-roots.md)
+
+# gcRoots
+
+`abstract val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`
+
+All GC roots which type matches types known to this heap graph and which point to non null
+references. You can retrieve the object that a GC Root points to by calling [findObjectById](find-object-by-id.md)
+with [GcRoot.id](#), however you need to first check that [objectExists](object-exists.md) returns true because
+GC roots can point to objects that don't exist in the heap dump.
+
diff --git a/docs/api/shark-graph/shark/-heap-graph/identifier-byte-size.md b/docs/api/shark-graph/shark/-heap-graph/identifier-byte-size.md
new file mode 100644
index 00000000..4e709404
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/identifier-byte-size.md
@@ -0,0 +1,5 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [identifierByteSize](./identifier-byte-size.md)
+
+# identifierByteSize
+
+`abstract val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-graph/shark/-heap-graph/index.md b/docs/api/shark-graph/shark/-heap-graph/index.md
new file mode 100644
index 00000000..727113f9
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/index.md
@@ -0,0 +1,32 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](./index.md)
+
+# HeapGraph
+
+`interface HeapGraph`
+
+Enables navigation through the heap graph of objects.
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classes](classes.md) | `abstract val classes: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`>`<br>Sequence of all classes in the heap dump. |
+| [context](context.md) | `abstract val context: `[`GraphContext`](../-graph-context/index.md)<br>In memory store that can be used to store objects this [HeapGraph](./index.md) instance. |
+| [gcRoots](gc-roots.md) | `abstract val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`<br>All GC roots which type matches types known to this heap graph and which point to non null references. You can retrieve the object that a GC Root points to by calling [findObjectById](find-object-by-id.md) with [GcRoot.id](#), however you need to first check that [objectExists](object-exists.md) returns true because GC roots can point to objects that don't exist in the heap dump. |
+| [identifierByteSize](identifier-byte-size.md) | `abstract val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [instances](instances.md) | `abstract val instances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-object/-heap-instance/index.md)`>`<br>Sequence of all instances in the heap dump. |
+| [objects](objects.md) | `abstract val objects: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject`](../-heap-object/index.md)`>`<br>Sequence of all objects in the heap dump. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [findClassByName](find-class-by-name.md) | `abstract fun findClassByName(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`?`<br>Returns the [HeapClass](../-heap-object/-heap-class/index.md) corresponding to the provided [className](find-class-by-name.md#shark.HeapGraph$findClassByName(kotlin.String)/className), or null if the class cannot be found. |
+| [findObjectById](find-object-by-id.md) | `abstract fun findObjectById(objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`HeapObject`](../-heap-object/index.md)<br>Returns the [HeapObject](../-heap-object/index.md) corresponding to the provided [objectId](find-object-by-id.md#shark.HeapGraph$findObjectById(kotlin.Long)/objectId), and throws [IllegalArgumentException](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-argument-exception/index.html) otherwise. |
+| [objectExists](object-exists.md) | `abstract fun objectExists(objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if the provided [objectId](object-exists.md#shark.HeapGraph$objectExists(kotlin.Long)/objectId) exists in the heap dump. |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [HprofHeapGraph](../-hprof-heap-graph/index.md) | `class HprofHeapGraph : `[`HeapGraph`](./index.md)<br>A [HeapGraph](./index.md) that reads from an indexed [Hprof](#). Create a new instance with [indexHprof](../-hprof-heap-graph/index-hprof.md). |
diff --git a/docs/api/shark-graph/shark/-heap-graph/instances.md b/docs/api/shark-graph/shark/-heap-graph/instances.md
new file mode 100644
index 00000000..1041b173
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/instances.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [instances](./instances.md)
+
+# instances
+
+`abstract val instances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-object/-heap-instance/index.md)`>`
+
+Sequence of all instances in the heap dump.
+
+This sequence does not trigger any IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-graph/object-exists.md b/docs/api/shark-graph/shark/-heap-graph/object-exists.md
new file mode 100644
index 00000000..552d4384
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/object-exists.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [objectExists](./object-exists.md)
+
+# objectExists
+
+`abstract fun objectExists(objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Returns true if the provided [objectId](object-exists.md#shark.HeapGraph$objectExists(kotlin.Long)/objectId) exists in the heap dump.
+
diff --git a/docs/api/shark-graph/shark/-heap-graph/objects.md b/docs/api/shark-graph/shark/-heap-graph/objects.md
new file mode 100644
index 00000000..19f7297a
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-graph/objects.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapGraph](index.md) / [objects](./objects.md)
+
+# objects
+
+`abstract val objects: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject`](../-heap-object/index.md)`>`
+
+Sequence of all objects in the heap dump.
+
+This sequence does not trigger any IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/class-hierarchy.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/class-hierarchy.md
new file mode 100644
index 00000000..cdc48c6d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/class-hierarchy.md
@@ -0,0 +1,9 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [classHierarchy](./class-hierarchy.md)
+
+# classHierarchy
+
+`val classHierarchy: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](index.md)`>`
+
+The class hierarchy starting at this class (included) and ending at the [Object](https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html) class
+(included).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/direct-instances.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/direct-instances.md
new file mode 100644
index 00000000..bf6990f3
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/direct-instances.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [directInstances](./direct-instances.md)
+
+# directInstances
+
+`val directInstances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-instance/index.md)`>`
+
+All direct instances of this class, ie excluding any instance of subclasses of this class.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/get.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/get.md
new file mode 100644
index 00000000..9071ccf3
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/get.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [get](./get.md)
+
+# get
+
+`operator fun get(fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`
+
+**See Also**
+
+[readStaticField](read-static-field.md)
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/graph.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/graph.md
new file mode 100644
index 00000000..3769da45
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/graph.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [graph](./graph.md)
+
+# graph
+
+`val graph: `[`HeapGraph`](../../-heap-graph/index.md)
+
+Overrides [HeapObject.graph](../graph.md)
+
+The graph of objects in the heap, which you can use to navigate the heap.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/index.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/index.md
new file mode 100644
index 00000000..f5c3def2
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/index.md
@@ -0,0 +1,44 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](./index.md)
+
+# HeapClass
+
+`class HeapClass : `[`HeapObject`](../index.md)
+
+A class in the heap dump.
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classHierarchy](class-hierarchy.md) | `val classHierarchy: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](./index.md)`>`<br>The class hierarchy starting at this class (included) and ending at the [Object](https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html) class (included). |
+| [directInstances](direct-instances.md) | `val directInstances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-instance/index.md)`>`<br>All direct instances of this class, ie excluding any instance of subclasses of this class. |
+| [graph](graph.md) | `val graph: `[`HeapGraph`](../../-heap-graph/index.md)<br>The graph of objects in the heap, which you can use to navigate the heap. |
+| [instanceByteSize](instance-byte-size.md) | `val instanceByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The total byte size of fields for instances of this class, as registered in the class dump. This includes the size of fields from superclasses. |
+| [instances](instances.md) | `val instances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-instance/index.md)`>`<br>All instances of this class, including instances of subclasses of this class. |
+| [name](name.md) | `val name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>The name of this class, identical to [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()). |
+| [objectId](object-id.md) | `val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The heap identifier of this object. |
+| [simpleName](simple-name.md) | `val simpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Returns [name](name.md) stripped of any string content before the last period (included). |
+| [subclasses](subclasses.md) | `val subclasses: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](./index.md)`>`<br>All the subclasses (direct and indirect) of this class, in the order they were recorded in the heap dump. |
+| [superclass](superclass.md) | `val superclass: `[`HeapObject.HeapClass`](./index.md)`?`<br>The [HeapClass](./index.md) representing the superclass of this [HeapClass](./index.md). If this [HeapClass](./index.md) represents either the [Object](https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html) class or a primitive type, then null is returned. If this [HeapClass](./index.md) represents an array class then the [HeapClass](./index.md) object representing the [Object](https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html) class is returned. |
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [asClass](../as-class.md) | `val asClass: `[`HeapObject.HeapClass`](./index.md)`?`<br>This [HeapObject](../index.md) as a [HeapClass](./index.md) if it is one, or null otherwise |
+| [asInstance](../as-instance.md) | `val asInstance: `[`HeapObject.HeapInstance`](../-heap-instance/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapInstance](../-heap-instance/index.md) if it is one, or null otherwise |
+| [asObjectArray](../as-object-array.md) | `val asObjectArray: `[`HeapObject.HeapObjectArray`](../-heap-object-array/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapObjectArray](../-heap-object-array/index.md) if it is one, or null otherwise |
+| [asPrimitiveArray](../as-primitive-array.md) | `val asPrimitiveArray: `[`HeapObject.HeapPrimitiveArray`](../-heap-primitive-array/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapPrimitiveArray](../-heap-primitive-array/index.md) if it is one, or null otherwise |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [get](get.md) | `operator fun get(fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?` |
+| [readFieldsByteSize](read-fields-byte-size.md) | `fun readFieldsByteSize(): `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The total byte size of fields for instances of this class, computed as the sum of the individual size of each field of this class. This does not include the size of fields from superclasses. |
+| [readRecord](read-record.md) | `fun readRecord(): ClassDumpRecord`<br>Reads and returns the underlying [ClassDumpRecord](#). |
+| [readStaticField](read-static-field.md) | `fun readStaticField(fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`<br>Returns a [HeapField](../../-heap-field/index.md) object that reflects the specified declared field of the class represented by this [HeapClass](./index.md) object, or null if this field does not exist. The [name](name.md) parameter specifies the simple name of the desired field. |
+| [readStaticFields](read-static-fields.md) | `fun readStaticFields(): `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapField`](../../-heap-field/index.md)`>`<br>The static fields of this class, as a sequence of [HeapField](../../-heap-field/index.md). |
+| [subclassOf](subclass-of.md) | `infix fun subclassOf(superclass: `[`HeapObject.HeapClass`](./index.md)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if [superclass](subclass-of.md#shark.HeapObject.HeapClass$subclassOf(shark.HeapObject.HeapClass)/superclass) is a superclass of this [HeapClass](./index.md). |
+| [superclassOf](superclass-of.md) | `infix fun superclassOf(subclass: `[`HeapObject.HeapClass`](./index.md)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if [subclass](superclass-of.md#shark.HeapObject.HeapClass$superclassOf(shark.HeapObject.HeapClass)/subclass) is a sub class of this [HeapClass](./index.md). |
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/instance-byte-size.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/instance-byte-size.md
new file mode 100644
index 00000000..bb9abe83
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/instance-byte-size.md
@@ -0,0 +1,13 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [instanceByteSize](./instance-byte-size.md)
+
+# instanceByteSize
+
+`val instanceByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+The total byte size of fields for instances of this class, as registered in the class dump.
+This includes the size of fields from superclasses.
+
+**See Also**
+
+[readFieldsByteSize](read-fields-byte-size.md)
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/instances.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/instances.md
new file mode 100644
index 00000000..cb5a742e
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/instances.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [instances](./instances.md)
+
+# instances
+
+`val instances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-instance/index.md)`>`
+
+All instances of this class, including instances of subclasses of this class.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/name.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/name.md
new file mode 100644
index 00000000..3f21245e
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/name.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [name](./name.md)
+
+# name
+
+`val name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+The name of this class, identical to [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/object-id.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/object-id.md
new file mode 100644
index 00000000..f230ecf8
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/object-id.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [objectId](./object-id.md)
+
+# objectId
+
+`val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [HeapObject.objectId](../object-id.md)
+
+The heap identifier of this object.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/read-fields-byte-size.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/read-fields-byte-size.md
new file mode 100644
index 00000000..0cf8dfa7
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/read-fields-byte-size.md
@@ -0,0 +1,16 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [readFieldsByteSize](./read-fields-byte-size.md)
+
+# readFieldsByteSize
+
+`fun readFieldsByteSize(): `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+The total byte size of fields for instances of this class, computed as the sum of the
+individual size of each field of this class. This does not include the size of fields from
+superclasses.
+
+This may trigger IO reads.
+
+**See Also**
+
+[instanceByteSize](instance-byte-size.md)
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/read-record.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/read-record.md
new file mode 100644
index 00000000..21f99386
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/read-record.md
@@ -0,0 +1,12 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [readRecord](./read-record.md)
+
+# readRecord
+
+`fun readRecord(): ClassDumpRecord`
+
+Overrides [HeapObject.readRecord](../read-record.md)
+
+Reads and returns the underlying [ClassDumpRecord](#).
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/read-static-field.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/read-static-field.md
new file mode 100644
index 00000000..092ee803
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/read-static-field.md
@@ -0,0 +1,14 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [readStaticField](./read-static-field.md)
+
+# readStaticField
+
+`fun readStaticField(fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`
+
+Returns a [HeapField](../../-heap-field/index.md) object that reflects the specified declared
+field of the class represented by this [HeapClass](index.md) object, or null if this field does not
+exist. The [name](name.md) parameter specifies the simple name of the desired field.
+
+Also available as a convenience operator: [get](get.md)
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/read-static-fields.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/read-static-fields.md
new file mode 100644
index 00000000..d3e990cd
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/read-static-fields.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [readStaticFields](./read-static-fields.md)
+
+# readStaticFields
+
+`fun readStaticFields(): `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapField`](../../-heap-field/index.md)`>`
+
+The static fields of this class, as a sequence of [HeapField](../../-heap-field/index.md).
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/simple-name.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/simple-name.md
new file mode 100644
index 00000000..93553b44
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/simple-name.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [simpleName](./simple-name.md)
+
+# simpleName
+
+`val simpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Returns [name](name.md) stripped of any string content before the last period (included).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/subclass-of.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/subclass-of.md
new file mode 100644
index 00000000..c84cda93
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/subclass-of.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [subclassOf](./subclass-of.md)
+
+# subclassOf
+
+`infix fun subclassOf(superclass: `[`HeapObject.HeapClass`](index.md)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Returns true if [superclass](subclass-of.md#shark.HeapObject.HeapClass$subclassOf(shark.HeapObject.HeapClass)/superclass) is a superclass of this [HeapClass](index.md).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/subclasses.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/subclasses.md
new file mode 100644
index 00000000..cae19b2f
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/subclasses.md
@@ -0,0 +1,9 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [subclasses](./subclasses.md)
+
+# subclasses
+
+`val subclasses: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](index.md)`>`
+
+All the subclasses (direct and indirect) of this class,
+in the order they were recorded in the heap dump.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/superclass-of.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/superclass-of.md
new file mode 100644
index 00000000..06ea7ca7
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/superclass-of.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [superclassOf](./superclass-of.md)
+
+# superclassOf
+
+`infix fun superclassOf(subclass: `[`HeapObject.HeapClass`](index.md)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Returns true if [subclass](superclass-of.md#shark.HeapObject.HeapClass$superclassOf(shark.HeapObject.HeapClass)/subclass) is a sub class of this [HeapClass](index.md).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/superclass.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/superclass.md
new file mode 100644
index 00000000..c646c035
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/superclass.md
@@ -0,0 +1,11 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [superclass](./superclass.md)
+
+# superclass
+
+`val superclass: `[`HeapObject.HeapClass`](index.md)`?`
+
+The [HeapClass](index.md) representing the superclass of this [HeapClass](index.md). If this [HeapClass](index.md)
+represents either the [Object](https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html) class or a primitive type, then
+null is returned. If this [HeapClass](index.md) represents an array class then the
+[HeapClass](index.md) object representing the [Object](https://docs.oracle.com/javase/6/docs/api/java/lang/Object.html) class is returned.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-class/to-string.md b/docs/api/shark-graph/shark/-heap-object/-heap-class/to-string.md
new file mode 100644
index 00000000..f226b489
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-class/to-string.md
@@ -0,0 +1,5 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapClass](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/byte-size.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/byte-size.md
new file mode 100644
index 00000000..274bdc75
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/byte-size.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [byteSize](./byte-size.md)
+
+# byteSize
+
+`val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+**See Also**
+
+[HeapClass.instanceByteSize](../-heap-class/instance-byte-size.md)
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/get.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/get.md
new file mode 100644
index 00000000..ba736614
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/get.md
@@ -0,0 +1,11 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [get](./get.md)
+
+# get
+
+`operator fun get(declaringClass: `[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`
+`operator fun get(declaringClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`
+
+**See Also**
+
+[readField](read-field.md)
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/graph.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/graph.md
new file mode 100644
index 00000000..6736d82f
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/graph.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [graph](./graph.md)
+
+# graph
+
+`val graph: `[`HeapGraph`](../../-heap-graph/index.md)
+
+Overrides [HeapObject.graph](../graph.md)
+
+The graph of objects in the heap, which you can use to navigate the heap.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/index.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/index.md
new file mode 100644
index 00000000..2e6a660a
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/index.md
@@ -0,0 +1,40 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](./index.md)
+
+# HeapInstance
+
+`class HeapInstance : `[`HeapObject`](../index.md)
+
+An instance in the heap dump.
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [graph](graph.md) | `val graph: `[`HeapGraph`](../../-heap-graph/index.md)<br>The graph of objects in the heap, which you can use to navigate the heap. |
+| [instanceClass](instance-class.md) | `val instanceClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)<br>The class of this instance. |
+| [instanceClassName](instance-class-name.md) | `val instanceClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>The name of the class of this instance, identical to [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()). |
+| [instanceClassSimpleName](instance-class-simple-name.md) | `val instanceClassSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Returns [instanceClassName](instance-class-name.md) stripped of any string content before the last period (included). |
+| [isPrimitiveWrapper](is-primitive-wrapper.md) | `val isPrimitiveWrapper: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether this is an instance of a primitive wrapper type. |
+| [objectId](object-id.md) | `val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The heap identifier of this object. |
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [asClass](../as-class.md) | `val asClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapClass](../-heap-class/index.md) if it is one, or null otherwise |
+| [asInstance](../as-instance.md) | `val asInstance: `[`HeapObject.HeapInstance`](./index.md)`?`<br>This [HeapObject](../index.md) as a [HeapInstance](./index.md) if it is one, or null otherwise |
+| [asObjectArray](../as-object-array.md) | `val asObjectArray: `[`HeapObject.HeapObjectArray`](../-heap-object-array/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapObjectArray](../-heap-object-array/index.md) if it is one, or null otherwise |
+| [asPrimitiveArray](../as-primitive-array.md) | `val asPrimitiveArray: `[`HeapObject.HeapPrimitiveArray`](../-heap-primitive-array/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapPrimitiveArray](../-heap-primitive-array/index.md) if it is one, or null otherwise |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [get](get.md) | `operator fun get(declaringClass: `[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`<br>`operator fun get(declaringClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?` |
+| [instanceOf](instance-of.md) | `infix fun instanceOf(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if this is an instance of the class named [className](instance-of.md#shark.HeapObject.HeapInstance$instanceOf(kotlin.String)/className) or an instance of a subclass of that class.`infix fun instanceOf(expectedClass: `[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<*>): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>`infix fun instanceOf(expectedClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if this is an instance of [expectedClass](instance-of.md#shark.HeapObject.HeapInstance$instanceOf(kotlin.reflect.KClass((kotlin.Any)))/expectedClass) or an instance of a subclass of that class. |
+| [readAsJavaString](read-as-java-string.md) | `fun readAsJavaString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`?`<br>If this [HeapInstance](./index.md) is an instance of the [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) class, returns a [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) instance with content that matches the string in the heap dump. Otherwise returns null. |
+| [readField](read-field.md) | `fun readField(declaringClass: `[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?``fun readField(declaringClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`<br>Returns a [HeapField](../../-heap-field/index.md) object that reflects the specified declared field of the instance represented by this [HeapInstance](./index.md) object, or null if this field does not exist. The [declaringClassName](read-field.md#shark.HeapObject.HeapInstance$readField(kotlin.String, kotlin.String)/declaringClassName) specifies the class in which the desired field is declared, and the [fieldName](read-field.md#shark.HeapObject.HeapInstance$readField(kotlin.String, kotlin.String)/fieldName) parameter specifies the simple name of the desired field. |
+| [readFields](read-fields.md) | `fun readFields(): `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapField`](../../-heap-field/index.md)`>`<br>The fields of this instance, as a sequence of [HeapField](../../-heap-field/index.md). |
+| [readRecord](read-record.md) | `fun readRecord(): InstanceDumpRecord`<br>Reads and returns the underlying [InstanceDumpRecord](#). |
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class-name.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class-name.md
new file mode 100644
index 00000000..57058598
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class-name.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [instanceClassName](./instance-class-name.md)
+
+# instanceClassName
+
+`val instanceClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+The name of the class of this instance, identical to [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class-simple-name.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class-simple-name.md
new file mode 100644
index 00000000..22351263
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class-simple-name.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [instanceClassSimpleName](./instance-class-simple-name.md)
+
+# instanceClassSimpleName
+
+`val instanceClassSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Returns [instanceClassName](instance-class-name.md) stripped of any string content before the last period (included).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class.md
new file mode 100644
index 00000000..344909d1
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-class.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [instanceClass](./instance-class.md)
+
+# instanceClass
+
+`val instanceClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)
+
+The class of this instance.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-of.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-of.md
new file mode 100644
index 00000000..1649067d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/instance-of.md
@@ -0,0 +1,15 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [instanceOf](./instance-of.md)
+
+# instanceOf
+
+`infix fun instanceOf(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Returns true if this is an instance of the class named [className](instance-of.md#shark.HeapObject.HeapInstance$instanceOf(kotlin.String)/className) or an instance of a
+subclass of that class.
+
+`infix fun instanceOf(expectedClass: `[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<*>): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+`infix fun instanceOf(expectedClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Returns true if this is an instance of [expectedClass](instance-of.md#shark.HeapObject.HeapInstance$instanceOf(kotlin.reflect.KClass((kotlin.Any)))/expectedClass) or an instance of a subclass of that
+class.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/is-primitive-wrapper.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/is-primitive-wrapper.md
new file mode 100644
index 00000000..b7046112
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/is-primitive-wrapper.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [isPrimitiveWrapper](./is-primitive-wrapper.md)
+
+# isPrimitiveWrapper
+
+`val isPrimitiveWrapper: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether this is an instance of a primitive wrapper type.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/object-id.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/object-id.md
new file mode 100644
index 00000000..bfa17b13
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/object-id.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [objectId](./object-id.md)
+
+# objectId
+
+`val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [HeapObject.objectId](../object-id.md)
+
+The heap identifier of this object.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-as-java-string.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-as-java-string.md
new file mode 100644
index 00000000..98d240c2
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-as-java-string.md
@@ -0,0 +1,11 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [readAsJavaString](./read-as-java-string.md)
+
+# readAsJavaString
+
+`fun readAsJavaString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`?`
+
+If this [HeapInstance](index.md) is an instance of the [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) class, returns a [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) instance
+with content that matches the string in the heap dump. Otherwise returns null.
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-field.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-field.md
new file mode 100644
index 00000000..b8db45b2
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-field.md
@@ -0,0 +1,21 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [readField](./read-field.md)
+
+# readField
+
+`fun readField(declaringClass: `[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`
+
+**See Also**
+
+[readField](./read-field.md)
+
+`fun readField(declaringClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapField`](../../-heap-field/index.md)`?`
+
+Returns a [HeapField](../../-heap-field/index.md) object that reflects the specified declared
+field of the instance represented by this [HeapInstance](index.md) object, or null if this field does
+not exist. The [declaringClassName](read-field.md#shark.HeapObject.HeapInstance$readField(kotlin.String, kotlin.String)/declaringClassName) specifies the class in which the desired field is
+declared, and the [fieldName](read-field.md#shark.HeapObject.HeapInstance$readField(kotlin.String, kotlin.String)/fieldName) parameter specifies the simple name of the desired field.
+
+Also available as a convenience operator: [get](get.md)
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-fields.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-fields.md
new file mode 100644
index 00000000..6c479fa5
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-fields.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [readFields](./read-fields.md)
+
+# readFields
+
+`fun readFields(): `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapField`](../../-heap-field/index.md)`>`
+
+The fields of this instance, as a sequence of [HeapField](../../-heap-field/index.md).
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-record.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-record.md
new file mode 100644
index 00000000..37a86a3d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/read-record.md
@@ -0,0 +1,12 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [readRecord](./read-record.md)
+
+# readRecord
+
+`fun readRecord(): InstanceDumpRecord`
+
+Overrides [HeapObject.readRecord](../read-record.md)
+
+Reads and returns the underlying [InstanceDumpRecord](#).
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-instance/to-string.md b/docs/api/shark-graph/shark/-heap-object/-heap-instance/to-string.md
new file mode 100644
index 00000000..e3471591
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-instance/to-string.md
@@ -0,0 +1,5 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapInstance](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class-name.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class-name.md
new file mode 100644
index 00000000..6097d58b
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class-name.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [arrayClassName](./array-class-name.md)
+
+# arrayClassName
+
+`val arrayClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+The name of the class of this array, identical to [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class-simple-name.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class-simple-name.md
new file mode 100644
index 00000000..d6765274
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class-simple-name.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [arrayClassSimpleName](./array-class-simple-name.md)
+
+# arrayClassSimpleName
+
+`val arrayClassSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Returns [arrayClassName](array-class-name.md) stripped of any string content before the last period (included).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class.md
new file mode 100644
index 00000000..971fbe76
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/array-class.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [arrayClass](./array-class.md)
+
+# arrayClass
+
+`val arrayClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)
+
+The class of this array.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/graph.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/graph.md
new file mode 100644
index 00000000..7ac65299
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/graph.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [graph](./graph.md)
+
+# graph
+
+`val graph: `[`HeapGraph`](../../-heap-graph/index.md)
+
+Overrides [HeapObject.graph](../graph.md)
+
+The graph of objects in the heap, which you can use to navigate the heap.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/index.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/index.md
new file mode 100644
index 00000000..73de8728
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/index.md
@@ -0,0 +1,36 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](./index.md)
+
+# HeapObjectArray
+
+`class HeapObjectArray : `[`HeapObject`](../index.md)
+
+An object array in the heap dump.
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [arrayClass](array-class.md) | `val arrayClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)<br>The class of this array. |
+| [arrayClassName](array-class-name.md) | `val arrayClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>The name of the class of this array, identical to [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()). |
+| [arrayClassSimpleName](array-class-simple-name.md) | `val arrayClassSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Returns [arrayClassName](array-class-name.md) stripped of any string content before the last period (included). |
+| [graph](graph.md) | `val graph: `[`HeapGraph`](../../-heap-graph/index.md)<br>The graph of objects in the heap, which you can use to navigate the heap. |
+| [isPrimitiveWrapperArray](is-primitive-wrapper-array.md) | `val isPrimitiveWrapperArray: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
+| [objectId](object-id.md) | `val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The heap identifier of this object. |
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [asClass](../as-class.md) | `val asClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapClass](../-heap-class/index.md) if it is one, or null otherwise |
+| [asInstance](../as-instance.md) | `val asInstance: `[`HeapObject.HeapInstance`](../-heap-instance/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapInstance](../-heap-instance/index.md) if it is one, or null otherwise |
+| [asObjectArray](../as-object-array.md) | `val asObjectArray: `[`HeapObject.HeapObjectArray`](./index.md)`?`<br>This [HeapObject](../index.md) as a [HeapObjectArray](./index.md) if it is one, or null otherwise |
+| [asPrimitiveArray](../as-primitive-array.md) | `val asPrimitiveArray: `[`HeapObject.HeapPrimitiveArray`](../-heap-primitive-array/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapPrimitiveArray](../-heap-primitive-array/index.md) if it is one, or null otherwise |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [readByteSize](read-byte-size.md) | `fun readByteSize(): `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The total byte shallow size of elements in this array. |
+| [readElements](read-elements.md) | `fun readElements(): `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapValue`](../../-heap-value/index.md)`>`<br>The elements in this array, as a sequence of [HeapValue](../../-heap-value/index.md). |
+| [readRecord](read-record.md) | `fun readRecord(): ObjectArrayDumpRecord`<br>Reads and returns the underlying [ObjectArrayDumpRecord](#). |
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/is-primitive-wrapper-array.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/is-primitive-wrapper-array.md
new file mode 100644
index 00000000..2315da84
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/is-primitive-wrapper-array.md
@@ -0,0 +1,5 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [isPrimitiveWrapperArray](./is-primitive-wrapper-array.md)
+
+# isPrimitiveWrapperArray
+
+`val isPrimitiveWrapperArray: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/object-id.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/object-id.md
new file mode 100644
index 00000000..e126bba8
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/object-id.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [objectId](./object-id.md)
+
+# objectId
+
+`val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [HeapObject.objectId](../object-id.md)
+
+The heap identifier of this object.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-byte-size.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-byte-size.md
new file mode 100644
index 00000000..9c288b6a
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-byte-size.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [readByteSize](./read-byte-size.md)
+
+# readByteSize
+
+`fun readByteSize(): `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+The total byte shallow size of elements in this array.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-elements.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-elements.md
new file mode 100644
index 00000000..d097dfd0
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-elements.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [readElements](./read-elements.md)
+
+# readElements
+
+`fun readElements(): `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapValue`](../../-heap-value/index.md)`>`
+
+The elements in this array, as a sequence of [HeapValue](../../-heap-value/index.md).
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-record.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-record.md
new file mode 100644
index 00000000..9062c1b2
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/read-record.md
@@ -0,0 +1,12 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [readRecord](./read-record.md)
+
+# readRecord
+
+`fun readRecord(): ObjectArrayDumpRecord`
+
+Overrides [HeapObject.readRecord](../read-record.md)
+
+Reads and returns the underlying [ObjectArrayDumpRecord](#).
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-object-array/to-string.md b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/to-string.md
new file mode 100644
index 00000000..481f6068
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-object-array/to-string.md
@@ -0,0 +1,5 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapObjectArray](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/array-class-name.md b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/array-class-name.md
new file mode 100644
index 00000000..789f2eac
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/array-class-name.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapPrimitiveArray](index.md) / [arrayClassName](./array-class-name.md)
+
+# arrayClassName
+
+`val arrayClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+The name of the class of this array, identical to [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()).
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/graph.md b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/graph.md
new file mode 100644
index 00000000..f01b7f96
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/graph.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapPrimitiveArray](index.md) / [graph](./graph.md)
+
+# graph
+
+`val graph: `[`HeapGraph`](../../-heap-graph/index.md)
+
+Overrides [HeapObject.graph](../graph.md)
+
+The graph of objects in the heap, which you can use to navigate the heap.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/index.md b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/index.md
new file mode 100644
index 00000000..734f6f50
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/index.md
@@ -0,0 +1,33 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapPrimitiveArray](./index.md)
+
+# HeapPrimitiveArray
+
+`class HeapPrimitiveArray : `[`HeapObject`](../index.md)
+
+A primitive array in the heap dump.
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [arrayClassName](array-class-name.md) | `val arrayClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>The name of the class of this array, identical to [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()). |
+| [graph](graph.md) | `val graph: `[`HeapGraph`](../../-heap-graph/index.md)<br>The graph of objects in the heap, which you can use to navigate the heap. |
+| [objectId](object-id.md) | `val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The heap identifier of this object. |
+| [primitiveType](primitive-type.md) | `val primitiveType: PrimitiveType`<br>The [PrimitiveType](#) of elements in this array. |
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [asClass](../as-class.md) | `val asClass: `[`HeapObject.HeapClass`](../-heap-class/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapClass](../-heap-class/index.md) if it is one, or null otherwise |
+| [asInstance](../as-instance.md) | `val asInstance: `[`HeapObject.HeapInstance`](../-heap-instance/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapInstance](../-heap-instance/index.md) if it is one, or null otherwise |
+| [asObjectArray](../as-object-array.md) | `val asObjectArray: `[`HeapObject.HeapObjectArray`](../-heap-object-array/index.md)`?`<br>This [HeapObject](../index.md) as a [HeapObjectArray](../-heap-object-array/index.md) if it is one, or null otherwise |
+| [asPrimitiveArray](../as-primitive-array.md) | `val asPrimitiveArray: `[`HeapObject.HeapPrimitiveArray`](./index.md)`?`<br>This [HeapObject](../index.md) as a [HeapPrimitiveArray](./index.md) if it is one, or null otherwise |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [readByteSize](read-byte-size.md) | `fun readByteSize(): `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The total byte shallow size of elements in this array. |
+| [readRecord](read-record.md) | `fun readRecord(): PrimitiveArrayDumpRecord`<br>Reads and returns the underlying [PrimitiveArrayDumpRecord](#). |
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/object-id.md b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/object-id.md
new file mode 100644
index 00000000..b3f19ade
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/object-id.md
@@ -0,0 +1,10 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapPrimitiveArray](index.md) / [objectId](./object-id.md)
+
+# objectId
+
+`val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [HeapObject.objectId](../object-id.md)
+
+The heap identifier of this object.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/primitive-type.md b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/primitive-type.md
new file mode 100644
index 00000000..5d37321d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/primitive-type.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapPrimitiveArray](index.md) / [primitiveType](./primitive-type.md)
+
+# primitiveType
+
+`val primitiveType: PrimitiveType`
+
+The [PrimitiveType](#) of elements in this array.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/read-byte-size.md b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/read-byte-size.md
new file mode 100644
index 00000000..77926b49
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/read-byte-size.md
@@ -0,0 +1,8 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapPrimitiveArray](index.md) / [readByteSize](./read-byte-size.md)
+
+# readByteSize
+
+`fun readByteSize(): `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+The total byte shallow size of elements in this array.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/read-record.md b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/read-record.md
new file mode 100644
index 00000000..8a936139
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/read-record.md
@@ -0,0 +1,12 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapPrimitiveArray](index.md) / [readRecord](./read-record.md)
+
+# readRecord
+
+`fun readRecord(): PrimitiveArrayDumpRecord`
+
+Overrides [HeapObject.readRecord](../read-record.md)
+
+Reads and returns the underlying [PrimitiveArrayDumpRecord](#).
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/to-string.md b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/to-string.md
new file mode 100644
index 00000000..7812aa28
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/-heap-primitive-array/to-string.md
@@ -0,0 +1,5 @@
+[shark-graph](../../../index.md) / [shark](../../index.md) / [HeapObject](../index.md) / [HeapPrimitiveArray](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-graph/shark/-heap-object/as-class.md b/docs/api/shark-graph/shark/-heap-object/as-class.md
new file mode 100644
index 00000000..cd6a7f6d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/as-class.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapObject](index.md) / [asClass](./as-class.md)
+
+# asClass
+
+`val asClass: `[`HeapObject.HeapClass`](-heap-class/index.md)`?`
+
+This [HeapObject](index.md) as a [HeapClass](-heap-class/index.md) if it is one, or null otherwise
+
diff --git a/docs/api/shark-graph/shark/-heap-object/as-instance.md b/docs/api/shark-graph/shark/-heap-object/as-instance.md
new file mode 100644
index 00000000..c4530105
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/as-instance.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapObject](index.md) / [asInstance](./as-instance.md)
+
+# asInstance
+
+`val asInstance: `[`HeapObject.HeapInstance`](-heap-instance/index.md)`?`
+
+This [HeapObject](index.md) as a [HeapInstance](-heap-instance/index.md) if it is one, or null otherwise
+
diff --git a/docs/api/shark-graph/shark/-heap-object/as-object-array.md b/docs/api/shark-graph/shark/-heap-object/as-object-array.md
new file mode 100644
index 00000000..62a6331e
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/as-object-array.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapObject](index.md) / [asObjectArray](./as-object-array.md)
+
+# asObjectArray
+
+`val asObjectArray: `[`HeapObject.HeapObjectArray`](-heap-object-array/index.md)`?`
+
+This [HeapObject](index.md) as a [HeapObjectArray](-heap-object-array/index.md) if it is one, or null otherwise
+
diff --git a/docs/api/shark-graph/shark/-heap-object/as-primitive-array.md b/docs/api/shark-graph/shark/-heap-object/as-primitive-array.md
new file mode 100644
index 00000000..dff3886a
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/as-primitive-array.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapObject](index.md) / [asPrimitiveArray](./as-primitive-array.md)
+
+# asPrimitiveArray
+
+`val asPrimitiveArray: `[`HeapObject.HeapPrimitiveArray`](-heap-primitive-array/index.md)`?`
+
+This [HeapObject](index.md) as a [HeapPrimitiveArray](-heap-primitive-array/index.md) if it is one, or null otherwise
+
diff --git a/docs/api/shark-graph/shark/-heap-object/graph.md b/docs/api/shark-graph/shark/-heap-object/graph.md
new file mode 100644
index 00000000..58098c67
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/graph.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapObject](index.md) / [graph](./graph.md)
+
+# graph
+
+`abstract val graph: `[`HeapGraph`](../-heap-graph/index.md)
+
+The graph of objects in the heap, which you can use to navigate the heap.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/index.md b/docs/api/shark-graph/shark/-heap-object/index.md
new file mode 100644
index 00000000..f3e84f67
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/index.md
@@ -0,0 +1,42 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapObject](./index.md)
+
+# HeapObject
+
+`sealed class HeapObject`
+
+An object in the heap dump.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [HeapClass](-heap-class/index.md) | `class HeapClass : `[`HeapObject`](./index.md)<br>A class in the heap dump. |
+| [HeapInstance](-heap-instance/index.md) | `class HeapInstance : `[`HeapObject`](./index.md)<br>An instance in the heap dump. |
+| [HeapObjectArray](-heap-object-array/index.md) | `class HeapObjectArray : `[`HeapObject`](./index.md)<br>An object array in the heap dump. |
+| [HeapPrimitiveArray](-heap-primitive-array/index.md) | `class HeapPrimitiveArray : `[`HeapObject`](./index.md)<br>A primitive array in the heap dump. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [asClass](as-class.md) | `val asClass: `[`HeapObject.HeapClass`](-heap-class/index.md)`?`<br>This [HeapObject](./index.md) as a [HeapClass](-heap-class/index.md) if it is one, or null otherwise |
+| [asInstance](as-instance.md) | `val asInstance: `[`HeapObject.HeapInstance`](-heap-instance/index.md)`?`<br>This [HeapObject](./index.md) as a [HeapInstance](-heap-instance/index.md) if it is one, or null otherwise |
+| [asObjectArray](as-object-array.md) | `val asObjectArray: `[`HeapObject.HeapObjectArray`](-heap-object-array/index.md)`?`<br>This [HeapObject](./index.md) as a [HeapObjectArray](-heap-object-array/index.md) if it is one, or null otherwise |
+| [asPrimitiveArray](as-primitive-array.md) | `val asPrimitiveArray: `[`HeapObject.HeapPrimitiveArray`](-heap-primitive-array/index.md)`?`<br>This [HeapObject](./index.md) as a [HeapPrimitiveArray](-heap-primitive-array/index.md) if it is one, or null otherwise |
+| [graph](graph.md) | `abstract val graph: `[`HeapGraph`](../-heap-graph/index.md)<br>The graph of objects in the heap, which you can use to navigate the heap. |
+| [objectId](object-id.md) | `abstract val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The heap identifier of this object. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [readRecord](read-record.md) | `abstract fun readRecord(): ObjectRecord`<br>Reads and returns the underlying [ObjectRecord](#). |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [HeapClass](-heap-class/index.md) | `class HeapClass : `[`HeapObject`](./index.md)<br>A class in the heap dump. |
+| [HeapInstance](-heap-instance/index.md) | `class HeapInstance : `[`HeapObject`](./index.md)<br>An instance in the heap dump. |
+| [HeapObjectArray](-heap-object-array/index.md) | `class HeapObjectArray : `[`HeapObject`](./index.md)<br>An object array in the heap dump. |
+| [HeapPrimitiveArray](-heap-primitive-array/index.md) | `class HeapPrimitiveArray : `[`HeapObject`](./index.md)<br>A primitive array in the heap dump. |
diff --git a/docs/api/shark-graph/shark/-heap-object/object-id.md b/docs/api/shark-graph/shark/-heap-object/object-id.md
new file mode 100644
index 00000000..1eb360e2
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/object-id.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapObject](index.md) / [objectId](./object-id.md)
+
+# objectId
+
+`abstract val objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+The heap identifier of this object.
+
diff --git a/docs/api/shark-graph/shark/-heap-object/read-record.md b/docs/api/shark-graph/shark/-heap-object/read-record.md
new file mode 100644
index 00000000..9a3f923c
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-object/read-record.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapObject](index.md) / [readRecord](./read-record.md)
+
+# readRecord
+
+`abstract fun readRecord(): ObjectRecord`
+
+Reads and returns the underlying [ObjectRecord](#).
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/-init-.md b/docs/api/shark-graph/shark/-heap-value/-init-.md
new file mode 100644
index 00000000..0bbcd273
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/-init-.md
@@ -0,0 +1,9 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HeapValue(graph: `[`HeapGraph`](../-heap-graph/index.md)`, holder: ValueHolder)`
+
+Represents a value in the heap dump, which can be an object reference or
+a primitive type.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-boolean.md b/docs/api/shark-graph/shark/-heap-value/as-boolean.md
new file mode 100644
index 00000000..8fc68b8f
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-boolean.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asBoolean](./as-boolean.md)
+
+# asBoolean
+
+`val asBoolean: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`?`
+
+This [HeapValue](index.md) as a [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) if it represents one, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-byte.md b/docs/api/shark-graph/shark/-heap-value/as-byte.md
new file mode 100644
index 00000000..42712cbb
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-byte.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asByte](./as-byte.md)
+
+# asByte
+
+`val asByte: `[`Byte`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html)`?`
+
+This [HeapValue](index.md) as a [Byte](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html) if it represents one, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-char.md b/docs/api/shark-graph/shark/-heap-value/as-char.md
new file mode 100644
index 00000000..91b4ef49
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-char.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asChar](./as-char.md)
+
+# asChar
+
+`val asChar: `[`Char`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html)`?`
+
+This [HeapValue](index.md) as a [Char](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html) if it represents one, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-double.md b/docs/api/shark-graph/shark/-heap-value/as-double.md
new file mode 100644
index 00000000..24fc97f9
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-double.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asDouble](./as-double.md)
+
+# asDouble
+
+`val asDouble: `[`Double`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)`?`
+
+This [HeapValue](index.md) as a [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html) if it represents one, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-float.md b/docs/api/shark-graph/shark/-heap-value/as-float.md
new file mode 100644
index 00000000..5f0866da
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-float.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asFloat](./as-float.md)
+
+# asFloat
+
+`val asFloat: `[`Float`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html)`?`
+
+This [HeapValue](index.md) as a [Float](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html) if it represents one, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-int.md b/docs/api/shark-graph/shark/-heap-value/as-int.md
new file mode 100644
index 00000000..11bed45b
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-int.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asInt](./as-int.md)
+
+# asInt
+
+`val asInt: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?`
+
+This [HeapValue](index.md) as an [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) if it represents one, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-long.md b/docs/api/shark-graph/shark/-heap-value/as-long.md
new file mode 100644
index 00000000..b0bc9c7a
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-long.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asLong](./as-long.md)
+
+# asLong
+
+`val asLong: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`?`
+
+This [HeapValue](index.md) as a [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) if it represents one, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-non-null-object-id.md b/docs/api/shark-graph/shark/-heap-value/as-non-null-object-id.md
new file mode 100644
index 00000000..cd69171d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-non-null-object-id.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asNonNullObjectId](./as-non-null-object-id.md)
+
+# asNonNullObjectId
+
+`val asNonNullObjectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`?`
+
+This [HeapValue](index.md) as a [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) if it represents a non null object reference, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-object-id.md b/docs/api/shark-graph/shark/-heap-value/as-object-id.md
new file mode 100644
index 00000000..2fbfff36
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-object-id.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asObjectId](./as-object-id.md)
+
+# asObjectId
+
+`val asObjectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`?`
+
+This [HeapValue](index.md) as a [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) if it represents an object reference, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-object.md b/docs/api/shark-graph/shark/-heap-value/as-object.md
new file mode 100644
index 00000000..fe7d0c03
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-object.md
@@ -0,0 +1,9 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asObject](./as-object.md)
+
+# asObject
+
+`val asObject: `[`HeapObject`](../-heap-object/index.md)`?`
+
+The [HeapObject](../-heap-object/index.md) referenced by this [HeapValue](index.md) if it represents a non null object reference,
+or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/as-short.md b/docs/api/shark-graph/shark/-heap-value/as-short.md
new file mode 100644
index 00000000..a8848025
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/as-short.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [asShort](./as-short.md)
+
+# asShort
+
+`val asShort: `[`Short`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html)`?`
+
+This [HeapValue](index.md) as a [Short](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html) if it represents one, or null otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/graph.md b/docs/api/shark-graph/shark/-heap-value/graph.md
new file mode 100644
index 00000000..c9d9751b
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/graph.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [graph](./graph.md)
+
+# graph
+
+`val graph: `[`HeapGraph`](../-heap-graph/index.md)
+
+The graph of objects in the heap, which you can use to navigate the heap.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/holder.md b/docs/api/shark-graph/shark/-heap-value/holder.md
new file mode 100644
index 00000000..f258001d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/holder.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [holder](./holder.md)
+
+# holder
+
+`val holder: ValueHolder`
+
+Holds the actual value that this [HeapValue](index.md) represents.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/index.md b/docs/api/shark-graph/shark/-heap-value/index.md
new file mode 100644
index 00000000..c6e8811e
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/index.md
@@ -0,0 +1,40 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](./index.md)
+
+# HeapValue
+
+`class HeapValue`
+
+Represents a value in the heap dump, which can be an object reference or
+a primitive type.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HeapValue(graph: `[`HeapGraph`](../-heap-graph/index.md)`, holder: ValueHolder)`<br>Represents a value in the heap dump, which can be an object reference or a primitive type. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [asBoolean](as-boolean.md) | `val asBoolean: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`?`<br>This [HeapValue](./index.md) as a [Boolean](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) if it represents one, or null otherwise. |
+| [asByte](as-byte.md) | `val asByte: `[`Byte`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html)`?`<br>This [HeapValue](./index.md) as a [Byte](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html) if it represents one, or null otherwise. |
+| [asChar](as-char.md) | `val asChar: `[`Char`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html)`?`<br>This [HeapValue](./index.md) as a [Char](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html) if it represents one, or null otherwise. |
+| [asDouble](as-double.md) | `val asDouble: `[`Double`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)`?`<br>This [HeapValue](./index.md) as a [Double](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html) if it represents one, or null otherwise. |
+| [asFloat](as-float.md) | `val asFloat: `[`Float`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html)`?`<br>This [HeapValue](./index.md) as a [Float](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html) if it represents one, or null otherwise. |
+| [asInt](as-int.md) | `val asInt: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?`<br>This [HeapValue](./index.md) as an [Int](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) if it represents one, or null otherwise. |
+| [asLong](as-long.md) | `val asLong: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`?`<br>This [HeapValue](./index.md) as a [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) if it represents one, or null otherwise. |
+| [asNonNullObjectId](as-non-null-object-id.md) | `val asNonNullObjectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`?`<br>This [HeapValue](./index.md) as a [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) if it represents a non null object reference, or null otherwise. |
+| [asObject](as-object.md) | `val asObject: `[`HeapObject`](../-heap-object/index.md)`?`<br>The [HeapObject](../-heap-object/index.md) referenced by this [HeapValue](./index.md) if it represents a non null object reference, or null otherwise. |
+| [asObjectId](as-object-id.md) | `val asObjectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`?`<br>This [HeapValue](./index.md) as a [Long](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) if it represents an object reference, or null otherwise. |
+| [asShort](as-short.md) | `val asShort: `[`Short`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html)`?`<br>This [HeapValue](./index.md) as a [Short](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html) if it represents one, or null otherwise. |
+| [graph](graph.md) | `val graph: `[`HeapGraph`](../-heap-graph/index.md)<br>The graph of objects in the heap, which you can use to navigate the heap. |
+| [holder](holder.md) | `val holder: ValueHolder`<br>Holds the actual value that this [HeapValue](./index.md) represents. |
+| [isNonNullReference](is-non-null-reference.md) | `val isNonNullReference: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>True is this [HeapValue](./index.md) represents a non null object reference, false otherwise. |
+| [isNullReference](is-null-reference.md) | `val isNullReference: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>True is this [HeapValue](./index.md) represents a null object reference, false otherwise. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [readAsJavaString](read-as-java-string.md) | `fun readAsJavaString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`?`<br>If this [HeapValue](./index.md) if it represents a non null object reference to an instance of the [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) class, returns a [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) instance with content that matches the string in the heap dump. Otherwise returns null. |
diff --git a/docs/api/shark-graph/shark/-heap-value/is-non-null-reference.md b/docs/api/shark-graph/shark/-heap-value/is-non-null-reference.md
new file mode 100644
index 00000000..f2e2b90a
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/is-non-null-reference.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [isNonNullReference](./is-non-null-reference.md)
+
+# isNonNullReference
+
+`val isNonNullReference: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+True is this [HeapValue](index.md) represents a non null object reference, false otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/is-null-reference.md b/docs/api/shark-graph/shark/-heap-value/is-null-reference.md
new file mode 100644
index 00000000..dbeeb759
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/is-null-reference.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [isNullReference](./is-null-reference.md)
+
+# isNullReference
+
+`val isNullReference: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+True is this [HeapValue](index.md) represents a null object reference, false otherwise.
+
diff --git a/docs/api/shark-graph/shark/-heap-value/read-as-java-string.md b/docs/api/shark-graph/shark/-heap-value/read-as-java-string.md
new file mode 100644
index 00000000..ecbba1a1
--- /dev/null
+++ b/docs/api/shark-graph/shark/-heap-value/read-as-java-string.md
@@ -0,0 +1,12 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HeapValue](index.md) / [readAsJavaString](./read-as-java-string.md)
+
+# readAsJavaString
+
+`fun readAsJavaString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`?`
+
+If this [HeapValue](index.md) if it represents a non null object reference to an instance of the
+[String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) class, returns a [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) instance with content that matches the string in the heap
+dump. Otherwise returns null.
+
+This may trigger IO reads.
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/classes.md b/docs/api/shark-graph/shark/-hprof-heap-graph/classes.md
new file mode 100644
index 00000000..fdadb1af
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/classes.md
@@ -0,0 +1,12 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [classes](./classes.md)
+
+# classes
+
+`val classes: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`>`
+
+Overrides [HeapGraph.classes](../-heap-graph/classes.md)
+
+Sequence of all classes in the heap dump.
+
+This sequence does not trigger any IO reads.
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/context.md b/docs/api/shark-graph/shark/-hprof-heap-graph/context.md
new file mode 100644
index 00000000..d8ab3507
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/context.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [context](./context.md)
+
+# context
+
+`val context: `[`GraphContext`](../-graph-context/index.md)
+
+Overrides [HeapGraph.context](../-heap-graph/context.md)
+
+In memory store that can be used to store objects this [HeapGraph](../-heap-graph/index.md) instance.
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/find-class-by-name.md b/docs/api/shark-graph/shark/-hprof-heap-graph/find-class-by-name.md
new file mode 100644
index 00000000..bbe68c62
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/find-class-by-name.md
@@ -0,0 +1,11 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [findClassByName](./find-class-by-name.md)
+
+# findClassByName
+
+`fun findClassByName(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`?`
+
+Overrides [HeapGraph.findClassByName](../-heap-graph/find-class-by-name.md)
+
+Returns the [HeapClass](../-heap-object/-heap-class/index.md) corresponding to the provided [className](../-heap-graph/find-class-by-name.md#shark.HeapGraph$findClassByName(kotlin.String)/className), or null if the
+class cannot be found.
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/find-object-by-id.md b/docs/api/shark-graph/shark/-hprof-heap-graph/find-object-by-id.md
new file mode 100644
index 00000000..6e204cf1
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/find-object-by-id.md
@@ -0,0 +1,11 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [findObjectById](./find-object-by-id.md)
+
+# findObjectById
+
+`fun findObjectById(objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`HeapObject`](../-heap-object/index.md)
+
+Overrides [HeapGraph.findObjectById](../-heap-graph/find-object-by-id.md)
+
+Returns the [HeapObject](../-heap-object/index.md) corresponding to the provided [objectId](../-heap-graph/find-object-by-id.md#shark.HeapGraph$findObjectById(kotlin.Long)/objectId), and throws
+[IllegalArgumentException](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-argument-exception/index.html) otherwise.
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/gc-roots.md b/docs/api/shark-graph/shark/-hprof-heap-graph/gc-roots.md
new file mode 100644
index 00000000..e585611f
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/gc-roots.md
@@ -0,0 +1,13 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [gcRoots](./gc-roots.md)
+
+# gcRoots
+
+`val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`
+
+Overrides [HeapGraph.gcRoots](../-heap-graph/gc-roots.md)
+
+All GC roots which type matches types known to this heap graph and which point to non null
+references. You can retrieve the object that a GC Root points to by calling [findObjectById](../-heap-graph/find-object-by-id.md)
+with [GcRoot.id](#), however you need to first check that [objectExists](../-heap-graph/object-exists.md) returns true because
+GC roots can point to objects that don't exist in the heap dump.
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/identifier-byte-size.md b/docs/api/shark-graph/shark/-hprof-heap-graph/identifier-byte-size.md
new file mode 100644
index 00000000..05c97b8d
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/identifier-byte-size.md
@@ -0,0 +1,8 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [identifierByteSize](./identifier-byte-size.md)
+
+# identifierByteSize
+
+`val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [HeapGraph.identifierByteSize](../-heap-graph/identifier-byte-size.md)
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/index-hprof.md b/docs/api/shark-graph/shark/-hprof-heap-graph/index-hprof.md
new file mode 100644
index 00000000..6b3317ae
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/index-hprof.md
@@ -0,0 +1,5 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [indexHprof](./index-hprof.md)
+
+# indexHprof
+
+`fun indexHprof(hprof: Hprof): `[`HeapGraph`](../-heap-graph/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/index.md b/docs/api/shark-graph/shark/-hprof-heap-graph/index.md
new file mode 100644
index 00000000..45e737e9
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/index.md
@@ -0,0 +1,32 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](./index.md)
+
+# HprofHeapGraph
+
+`class HprofHeapGraph : `[`HeapGraph`](../-heap-graph/index.md)
+
+A [HeapGraph](../-heap-graph/index.md) that reads from an indexed [Hprof](#). Create a new instance with [indexHprof](index-hprof.md).
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classes](classes.md) | `val classes: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`>`<br>Sequence of all classes in the heap dump. |
+| [context](context.md) | `val context: `[`GraphContext`](../-graph-context/index.md)<br>In memory store that can be used to store objects this [HeapGraph](../-heap-graph/index.md) instance. |
+| [gcRoots](gc-roots.md) | `val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`<br>All GC roots which type matches types known to this heap graph and which point to non null references. You can retrieve the object that a GC Root points to by calling [findObjectById](../-heap-graph/find-object-by-id.md) with [GcRoot.id](#), however you need to first check that [objectExists](../-heap-graph/object-exists.md) returns true because GC roots can point to objects that don't exist in the heap dump. |
+| [identifierByteSize](identifier-byte-size.md) | `val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [instances](instances.md) | `val instances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-object/-heap-instance/index.md)`>`<br>Sequence of all instances in the heap dump. |
+| [objects](objects.md) | `val objects: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject`](../-heap-object/index.md)`>`<br>Sequence of all objects in the heap dump. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [findClassByName](find-class-by-name.md) | `fun findClassByName(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`): `[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`?`<br>Returns the [HeapClass](../-heap-object/-heap-class/index.md) corresponding to the provided [className](../-heap-graph/find-class-by-name.md#shark.HeapGraph$findClassByName(kotlin.String)/className), or null if the class cannot be found. |
+| [findObjectById](find-object-by-id.md) | `fun findObjectById(objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`HeapObject`](../-heap-object/index.md)<br>Returns the [HeapObject](../-heap-object/index.md) corresponding to the provided [objectId](../-heap-graph/find-object-by-id.md#shark.HeapGraph$findObjectById(kotlin.Long)/objectId), and throws [IllegalArgumentException](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-argument-exception/index.html) otherwise. |
+| [objectExists](object-exists.md) | `fun objectExists(objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if the provided [objectId](../-heap-graph/object-exists.md#shark.HeapGraph$objectExists(kotlin.Long)/objectId) exists in the heap dump. |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [indexHprof](index-hprof.md) | `fun indexHprof(hprof: Hprof): `[`HeapGraph`](../-heap-graph/index.md) |
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/instances.md b/docs/api/shark-graph/shark/-hprof-heap-graph/instances.md
new file mode 100644
index 00000000..9137884f
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/instances.md
@@ -0,0 +1,12 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [instances](./instances.md)
+
+# instances
+
+`val instances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-object/-heap-instance/index.md)`>`
+
+Overrides [HeapGraph.instances](../-heap-graph/instances.md)
+
+Sequence of all instances in the heap dump.
+
+This sequence does not trigger any IO reads.
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/object-exists.md b/docs/api/shark-graph/shark/-hprof-heap-graph/object-exists.md
new file mode 100644
index 00000000..61f83efc
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/object-exists.md
@@ -0,0 +1,10 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [objectExists](./object-exists.md)
+
+# objectExists
+
+`fun objectExists(objectId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Overrides [HeapGraph.objectExists](../-heap-graph/object-exists.md)
+
+Returns true if the provided [objectId](../-heap-graph/object-exists.md#shark.HeapGraph$objectExists(kotlin.Long)/objectId) exists in the heap dump.
+
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/objects.md b/docs/api/shark-graph/shark/-hprof-heap-graph/objects.md
new file mode 100644
index 00000000..41c4d8c0
--- /dev/null
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/objects.md
@@ -0,0 +1,12 @@
+[shark-graph](../../index.md) / [shark](../index.md) / [HprofHeapGraph](index.md) / [objects](./objects.md)
+
+# objects
+
+`val objects: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject`](../-heap-object/index.md)`>`
+
+Overrides [HeapGraph.objects](../-heap-graph/objects.md)
+
+Sequence of all objects in the heap dump.
+
+This sequence does not trigger any IO reads.
+
diff --git a/docs/api/shark-graph/shark/index.md b/docs/api/shark-graph/shark/index.md
new file mode 100644
index 00000000..d3fba981
--- /dev/null
+++ b/docs/api/shark-graph/shark/index.md
@@ -0,0 +1,14 @@
+[shark-graph](../index.md) / [shark](./index.md)
+
+## Package shark
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [GraphContext](-graph-context/index.md) | `class GraphContext`<br>In memory store that can be used to store objects in a given [HeapGraph](-heap-graph/index.md) instance. This is a simple [MutableMap](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/index.html) of [String](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) to [Any](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html), but with unsafe generics access. |
+| [HeapField](-heap-field/index.md) | `class HeapField`<br>Represents a static field or an instance field. |
+| [HeapGraph](-heap-graph/index.md) | `interface HeapGraph`<br>Enables navigation through the heap graph of objects. |
+| [HeapObject](-heap-object/index.md) | `sealed class HeapObject`<br>An object in the heap dump. |
+| [HeapValue](-heap-value/index.md) | `class HeapValue`<br>Represents a value in the heap dump, which can be an object reference or a primitive type. |
+| [HprofHeapGraph](-hprof-heap-graph/index.md) | `class HprofHeapGraph : `[`HeapGraph`](-heap-graph/index.md)<br>A [HeapGraph](-heap-graph/index.md) that reads from an indexed [Hprof](#). Create a new instance with [indexHprof](-hprof-heap-graph/index-hprof.md). |
diff --git a/docs/api/shark-hprof/alltypes/index.md b/docs/api/shark-hprof/alltypes/index.md
new file mode 100644
index 00000000..a7361e3a
--- /dev/null
+++ b/docs/api/shark-hprof/alltypes/index.md
@@ -0,0 +1,15 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [shark.GcRoot](../shark/-gc-root/index.md) | A GcRoot as identified by [HprofRecord.HeapDumpRecord.GcRootRecord](../shark/-hprof-record/-heap-dump-record/-gc-root-record/index.md) in the heap dump. |
+| [shark.Hprof](../shark/-hprof/index.md) | An opened Hprof file which can be read via [reader](../shark/-hprof/reader.md). Open a new hprof with [open](../shark/-hprof/open.md), and don't forget to call [close](../shark/-hprof/close.md) once done. |
+| [shark.HprofPrimitiveArrayStripper](../shark/-hprof-primitive-array-stripper/index.md) | Converts a Hprof file to another file with all primitive arrays replaced with arrays of zeroes, which can be useful to remove PII. Char arrays are handled slightly differently because 0 would be the null character so instead these become arrays of '?'. |
+| [shark.HprofReader](../shark/-hprof-reader/index.md) | Reads hprof content from an Okio [BufferedSource](#). |
+| [shark.HprofRecord](../shark/-hprof-record/index.md) | A Hprof record. These data structure map 1:1 with how records are written in hprof files. |
+| [shark.HprofWriter](../shark/-hprof-writer/index.md) | Generates Hprof files. |
+| [shark.OnHprofRecordListener](../shark/-on-hprof-record-listener/index.md) | Listener passed in to [HprofReader.readHprofRecords](../shark/-hprof-reader/read-hprof-records.md), gets notified for each [HprofRecord](../shark/-hprof-record/index.md) found in the heap dump which types is in the set of the recordTypes parameter passed to [HprofReader.readHprofRecords](../shark/-hprof-reader/read-hprof-records.md). |
+| [shark.PrimitiveType](../shark/-primitive-type/index.md) | A primitive type in the prof. |
+| [shark.ValueHolder](../shark/-value-holder/index.md) | A value in the heap dump, which can be a [ReferenceHolder](../shark/-value-holder/-reference-holder/index.md) or a primitive type. |
diff --git a/docs/api/shark-hprof/index.md b/docs/api/shark-hprof/index.md
new file mode 100644
index 00000000..8368a6cf
--- /dev/null
+++ b/docs/api/shark-hprof/index.md
@@ -0,0 +1,11 @@
+[shark-hprof](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [shark](shark/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/package-list b/docs/api/shark-hprof/package-list
new file mode 100644
index 00000000..415577c3
--- /dev/null
+++ b/docs/api/shark-hprof/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+shark
diff --git a/docs/api/shark-hprof/shark/-gc-root/-debugger/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-debugger/-init-.md
new file mode 100644
index 00000000..a15ec6aa
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-debugger/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Debugger](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`Debugger(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+An object held by a connected debugger
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-debugger/id.md b/docs/api/shark-hprof/shark/-gc-root/-debugger/id.md
new file mode 100644
index 00000000..8fbc6f6e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-debugger/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Debugger](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-debugger/index.md b/docs/api/shark-hprof/shark/-gc-root/-debugger/index.md
new file mode 100644
index 00000000..a57ed5e2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-debugger/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Debugger](./index.md)
+
+# Debugger
+
+`class Debugger : `[`GcRoot`](../index.md)
+
+An object held by a connected debugger
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `Debugger(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>An object held by a connected debugger |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-finalizing/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-finalizing/-init-.md
new file mode 100644
index 00000000..c982ab37
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-finalizing/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Finalizing](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`Finalizing(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+An object that is in a queue, waiting for a finalizer to run.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-finalizing/id.md b/docs/api/shark-hprof/shark/-gc-root/-finalizing/id.md
new file mode 100644
index 00000000..a4dbf404
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-finalizing/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Finalizing](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-finalizing/index.md b/docs/api/shark-hprof/shark/-gc-root/-finalizing/index.md
new file mode 100644
index 00000000..ea566a83
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-finalizing/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Finalizing](./index.md)
+
+# Finalizing
+
+`class Finalizing : `[`GcRoot`](../index.md)
+
+An object that is in a queue, waiting for a finalizer to run.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `Finalizing(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>An object that is in a queue, waiting for a finalizer to run. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-interned-string/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-interned-string/-init-.md
new file mode 100644
index 00000000..0a4dbaf7
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-interned-string/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [InternedString](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`InternedString(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+An interned string, see [java.lang.String.intern](https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#intern()).
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-interned-string/id.md b/docs/api/shark-hprof/shark/-gc-root/-interned-string/id.md
new file mode 100644
index 00000000..27646f68
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-interned-string/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [InternedString](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-interned-string/index.md b/docs/api/shark-hprof/shark/-gc-root/-interned-string/index.md
new file mode 100644
index 00000000..4de4efc5
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-interned-string/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [InternedString](./index.md)
+
+# InternedString
+
+`class InternedString : `[`GcRoot`](../index.md)
+
+An interned string, see [java.lang.String.intern](https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#intern()).
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `InternedString(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>An interned string, see [java.lang.String.intern](https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#intern()). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-java-frame/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-java-frame/-init-.md
new file mode 100644
index 00000000..64297408
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-java-frame/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JavaFrame](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`JavaFrame(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, frameNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+A java local variable
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-java-frame/frame-number.md b/docs/api/shark-hprof/shark/-gc-root/-java-frame/frame-number.md
new file mode 100644
index 00000000..cabb5a9e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-java-frame/frame-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JavaFrame](index.md) / [frameNumber](./frame-number.md)
+
+# frameNumber
+
+`val frameNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+frame number in stack trace (-1 for empty)
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-java-frame/id.md b/docs/api/shark-hprof/shark/-gc-root/-java-frame/id.md
new file mode 100644
index 00000000..ab3f57f6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-java-frame/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JavaFrame](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-java-frame/index.md b/docs/api/shark-hprof/shark/-gc-root/-java-frame/index.md
new file mode 100644
index 00000000..646da8f0
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-java-frame/index.md
@@ -0,0 +1,21 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JavaFrame](./index.md)
+
+# JavaFrame
+
+`class JavaFrame : `[`GcRoot`](../index.md)
+
+A java local variable
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `JavaFrame(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, frameNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>A java local variable |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [frameNumber](frame-number.md) | `val frameNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>frame number in stack trace (-1 for empty) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
+| [threadSerialNumber](thread-serial-number.md) | `val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Corresponds to [ThreadObject.threadSerialNumber](../-thread-object/thread-serial-number.md) |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-java-frame/thread-serial-number.md b/docs/api/shark-hprof/shark/-gc-root/-java-frame/thread-serial-number.md
new file mode 100644
index 00000000..4f4694e6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-java-frame/thread-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JavaFrame](index.md) / [threadSerialNumber](./thread-serial-number.md)
+
+# threadSerialNumber
+
+`val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Corresponds to [ThreadObject.threadSerialNumber](../-thread-object/thread-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-global/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-jni-global/-init-.md
new file mode 100644
index 00000000..47d367f9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-global/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniGlobal](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`JniGlobal(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, jniGlobalRefId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+A global variable in native code.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-global/id.md b/docs/api/shark-hprof/shark/-gc-root/-jni-global/id.md
new file mode 100644
index 00000000..31e27277
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-global/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniGlobal](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-global/index.md b/docs/api/shark-hprof/shark/-gc-root/-jni-global/index.md
new file mode 100644
index 00000000..8d35fdfa
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-global/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniGlobal](./index.md)
+
+# JniGlobal
+
+`class JniGlobal : `[`GcRoot`](../index.md)
+
+A global variable in native code.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `JniGlobal(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, jniGlobalRefId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>A global variable in native code. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
+| [jniGlobalRefId](jni-global-ref-id.md) | `val jniGlobalRefId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-global/jni-global-ref-id.md b/docs/api/shark-hprof/shark/-gc-root/-jni-global/jni-global-ref-id.md
new file mode 100644
index 00000000..7a9494cd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-global/jni-global-ref-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniGlobal](index.md) / [jniGlobalRefId](./jni-global-ref-id.md)
+
+# jniGlobalRefId
+
+`val jniGlobalRefId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-local/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-jni-local/-init-.md
new file mode 100644
index 00000000..a0b1a2ed
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-local/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniLocal](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`JniLocal(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, frameNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+A local variable in native code.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-local/frame-number.md b/docs/api/shark-hprof/shark/-gc-root/-jni-local/frame-number.md
new file mode 100644
index 00000000..b4af873f
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-local/frame-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniLocal](index.md) / [frameNumber](./frame-number.md)
+
+# frameNumber
+
+`val frameNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+frame number in stack trace (-1 for empty)
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-local/id.md b/docs/api/shark-hprof/shark/-gc-root/-jni-local/id.md
new file mode 100644
index 00000000..e65ada98
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-local/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniLocal](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-local/index.md b/docs/api/shark-hprof/shark/-gc-root/-jni-local/index.md
new file mode 100644
index 00000000..4c9671e0
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-local/index.md
@@ -0,0 +1,21 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniLocal](./index.md)
+
+# JniLocal
+
+`class JniLocal : `[`GcRoot`](../index.md)
+
+A local variable in native code.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `JniLocal(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, frameNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>A local variable in native code. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [frameNumber](frame-number.md) | `val frameNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>frame number in stack trace (-1 for empty) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
+| [threadSerialNumber](thread-serial-number.md) | `val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Corresponds to [ThreadObject.threadSerialNumber](../-thread-object/thread-serial-number.md) |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-local/thread-serial-number.md b/docs/api/shark-hprof/shark/-gc-root/-jni-local/thread-serial-number.md
new file mode 100644
index 00000000..7c09d1db
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-local/thread-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniLocal](index.md) / [threadSerialNumber](./thread-serial-number.md)
+
+# threadSerialNumber
+
+`val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Corresponds to [ThreadObject.threadSerialNumber](../-thread-object/thread-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/-init-.md
new file mode 100644
index 00000000..4c9b33f8
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniMonitor](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`JniMonitor(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, stackDepth: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+It's unclear what this is, documentation welcome.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/id.md b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/id.md
new file mode 100644
index 00000000..8c6deb76
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniMonitor](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/index.md b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/index.md
new file mode 100644
index 00000000..8d8e69a9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/index.md
@@ -0,0 +1,21 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniMonitor](./index.md)
+
+# JniMonitor
+
+`class JniMonitor : `[`GcRoot`](../index.md)
+
+It's unclear what this is, documentation welcome.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `JniMonitor(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, stackDepth: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>It's unclear what this is, documentation welcome. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
+| [stackDepth](stack-depth.md) | `val stackDepth: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/stack-depth.md b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/stack-depth.md
new file mode 100644
index 00000000..8c188880
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/stack-depth.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniMonitor](index.md) / [stackDepth](./stack-depth.md)
+
+# stackDepth
+
+`val stackDepth: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/stack-trace-serial-number.md
new file mode 100644
index 00000000..51b1e09d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-jni-monitor/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [JniMonitor](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-gc-root/-monitor-used/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-monitor-used/-init-.md
new file mode 100644
index 00000000..7a6f752b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-monitor-used/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [MonitorUsed](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`MonitorUsed(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+Everything that called the wait() or notify() methods, or
+that is synchronized.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-monitor-used/id.md b/docs/api/shark-hprof/shark/-gc-root/-monitor-used/id.md
new file mode 100644
index 00000000..371674e0
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-monitor-used/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [MonitorUsed](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-monitor-used/index.md b/docs/api/shark-hprof/shark/-gc-root/-monitor-used/index.md
new file mode 100644
index 00000000..e92ab90e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-monitor-used/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [MonitorUsed](./index.md)
+
+# MonitorUsed
+
+`class MonitorUsed : `[`GcRoot`](../index.md)
+
+Everything that called the wait() or notify() methods, or
+that is synchronized.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `MonitorUsed(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>Everything that called the wait() or notify() methods, or that is synchronized. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-native-stack/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-native-stack/-init-.md
new file mode 100644
index 00000000..3f298ef2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-native-stack/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [NativeStack](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`NativeStack(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+Input or output parameters in native code
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-native-stack/id.md b/docs/api/shark-hprof/shark/-gc-root/-native-stack/id.md
new file mode 100644
index 00000000..c3562906
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-native-stack/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [NativeStack](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-native-stack/index.md b/docs/api/shark-hprof/shark/-gc-root/-native-stack/index.md
new file mode 100644
index 00000000..d477c713
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-native-stack/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [NativeStack](./index.md)
+
+# NativeStack
+
+`class NativeStack : `[`GcRoot`](../index.md)
+
+Input or output parameters in native code
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `NativeStack(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>Input or output parameters in native code |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
+| [threadSerialNumber](thread-serial-number.md) | `val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Corresponds to [ThreadObject.threadSerialNumber](../-thread-object/thread-serial-number.md) Note: the corresponding thread is sometimes not found, see: https://issuetracker.google.com/issues/122713143 |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-native-stack/thread-serial-number.md b/docs/api/shark-hprof/shark/-gc-root/-native-stack/thread-serial-number.md
new file mode 100644
index 00000000..3bbdc8c8
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-native-stack/thread-serial-number.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [NativeStack](index.md) / [threadSerialNumber](./thread-serial-number.md)
+
+# threadSerialNumber
+
+`val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Corresponds to [ThreadObject.threadSerialNumber](../-thread-object/thread-serial-number.md)
+Note: the corresponding thread is sometimes not found, see:
+https://issuetracker.google.com/issues/122713143
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/-init-.md
new file mode 100644
index 00000000..02481e03
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ReferenceCleanup](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ReferenceCleanup(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+It's unclear what this is, documentation welcome.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/id.md b/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/id.md
new file mode 100644
index 00000000..fd7c895c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ReferenceCleanup](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/index.md b/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/index.md
new file mode 100644
index 00000000..920029c3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-reference-cleanup/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ReferenceCleanup](./index.md)
+
+# ReferenceCleanup
+
+`class ReferenceCleanup : `[`GcRoot`](../index.md)
+
+It's unclear what this is, documentation welcome.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ReferenceCleanup(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>It's unclear what this is, documentation welcome. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-sticky-class/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-sticky-class/-init-.md
new file mode 100644
index 00000000..bae750a7
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-sticky-class/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [StickyClass](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`StickyClass(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+A system class
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-sticky-class/id.md b/docs/api/shark-hprof/shark/-gc-root/-sticky-class/id.md
new file mode 100644
index 00000000..ecda623e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-sticky-class/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [StickyClass](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-sticky-class/index.md b/docs/api/shark-hprof/shark/-gc-root/-sticky-class/index.md
new file mode 100644
index 00000000..9411bf27
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-sticky-class/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [StickyClass](./index.md)
+
+# StickyClass
+
+`class StickyClass : `[`GcRoot`](../index.md)
+
+A system class
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `StickyClass(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>A system class |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-block/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-thread-block/-init-.md
new file mode 100644
index 00000000..fe8a9c98
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-block/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadBlock](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ThreadBlock(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-block/id.md b/docs/api/shark-hprof/shark/-gc-root/-thread-block/id.md
new file mode 100644
index 00000000..60f1863a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-block/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadBlock](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-block/index.md b/docs/api/shark-hprof/shark/-gc-root/-thread-block/index.md
new file mode 100644
index 00000000..1ce409b7
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-block/index.md
@@ -0,0 +1,18 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadBlock](./index.md)
+
+# ThreadBlock
+
+`class ThreadBlock : `[`GcRoot`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ThreadBlock(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
+| [threadSerialNumber](thread-serial-number.md) | `val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Corresponds to [ThreadObject.threadSerialNumber](../-thread-object/thread-serial-number.md) |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-block/thread-serial-number.md b/docs/api/shark-hprof/shark/-gc-root/-thread-block/thread-serial-number.md
new file mode 100644
index 00000000..d0799886
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-block/thread-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadBlock](index.md) / [threadSerialNumber](./thread-serial-number.md)
+
+# threadSerialNumber
+
+`val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Corresponds to [ThreadObject.threadSerialNumber](../-thread-object/thread-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-object/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-thread-object/-init-.md
new file mode 100644
index 00000000..0322be0e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-object/-init-.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadObject](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ThreadObject(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+A thread.
+
+Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-object/id.md b/docs/api/shark-hprof/shark/-gc-root/-thread-object/id.md
new file mode 100644
index 00000000..f98f1a86
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-object/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadObject](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-object/index.md b/docs/api/shark-hprof/shark/-gc-root/-thread-object/index.md
new file mode 100644
index 00000000..67939e5b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-object/index.md
@@ -0,0 +1,23 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadObject](./index.md)
+
+# ThreadObject
+
+`class ThreadObject : `[`GcRoot`](../index.md)
+
+A thread.
+
+Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ThreadObject(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>A thread. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [threadSerialNumber](thread-serial-number.md) | `val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-object/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-gc-root/-thread-object/stack-trace-serial-number.md
new file mode 100644
index 00000000..24dbb596
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-object/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadObject](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-gc-root/-thread-object/thread-serial-number.md b/docs/api/shark-hprof/shark/-gc-root/-thread-object/thread-serial-number.md
new file mode 100644
index 00000000..0ed2667e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-thread-object/thread-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [ThreadObject](index.md) / [threadSerialNumber](./thread-serial-number.md)
+
+# threadSerialNumber
+
+`val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-gc-root/-unknown/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-unknown/-init-.md
new file mode 100644
index 00000000..95fa6d57
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-unknown/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Unknown](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`Unknown(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+An unknown gc root.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-unknown/id.md b/docs/api/shark-hprof/shark/-gc-root/-unknown/id.md
new file mode 100644
index 00000000..e72bfa09
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-unknown/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Unknown](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-unknown/index.md b/docs/api/shark-hprof/shark/-gc-root/-unknown/index.md
new file mode 100644
index 00000000..2ef04013
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-unknown/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Unknown](./index.md)
+
+# Unknown
+
+`class Unknown : `[`GcRoot`](../index.md)
+
+An unknown gc root.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `Unknown(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>An unknown gc root. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-unreachable/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-unreachable/-init-.md
new file mode 100644
index 00000000..d463f372
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-unreachable/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Unreachable](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`Unreachable(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+An object that is unreachable from any other root, but not a root itself.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-unreachable/id.md b/docs/api/shark-hprof/shark/-gc-root/-unreachable/id.md
new file mode 100644
index 00000000..f0923a68
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-unreachable/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Unreachable](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-unreachable/index.md b/docs/api/shark-hprof/shark/-gc-root/-unreachable/index.md
new file mode 100644
index 00000000..f8ab32ed
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-unreachable/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [Unreachable](./index.md)
+
+# Unreachable
+
+`class Unreachable : `[`GcRoot`](../index.md)
+
+An object that is unreachable from any other root, but not a root itself.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `Unreachable(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>An object that is unreachable from any other root, but not a root itself. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/-vm-internal/-init-.md b/docs/api/shark-hprof/shark/-gc-root/-vm-internal/-init-.md
new file mode 100644
index 00000000..3ae1ec0e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-vm-internal/-init-.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [VmInternal](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`VmInternal(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+It's unclear what this is, documentation welcome.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-vm-internal/id.md b/docs/api/shark-hprof/shark/-gc-root/-vm-internal/id.md
new file mode 100644
index 00000000..6134b1d7
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-vm-internal/id.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [VmInternal](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [GcRoot.id](../id.md)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/-vm-internal/index.md b/docs/api/shark-hprof/shark/-gc-root/-vm-internal/index.md
new file mode 100644
index 00000000..d09e9af5
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/-vm-internal/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [GcRoot](../index.md) / [VmInternal](./index.md)
+
+# VmInternal
+
+`class VmInternal : `[`GcRoot`](../index.md)
+
+It's unclear what this is, documentation welcome.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `VmInternal(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>It's unclear what this is, documentation welcome. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
diff --git a/docs/api/shark-hprof/shark/-gc-root/id.md b/docs/api/shark-hprof/shark/-gc-root/id.md
new file mode 100644
index 00000000..408d608c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [GcRoot](index.md) / [id](./id.md)
+
+# id
+
+`abstract val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+The object id of the object that this gc root references.
+
diff --git a/docs/api/shark-hprof/shark/-gc-root/index.md b/docs/api/shark-hprof/shark/-gc-root/index.md
new file mode 100644
index 00000000..85db15fd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-gc-root/index.md
@@ -0,0 +1,55 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [GcRoot](./index.md)
+
+# GcRoot
+
+`sealed class GcRoot`
+
+A GcRoot as identified by [HprofRecord.HeapDumpRecord.GcRootRecord](../-hprof-record/-heap-dump-record/-gc-root-record/index.md) in the heap dump.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Debugger](-debugger/index.md) | `class Debugger : `[`GcRoot`](./index.md)<br>An object held by a connected debugger |
+| [Finalizing](-finalizing/index.md) | `class Finalizing : `[`GcRoot`](./index.md)<br>An object that is in a queue, waiting for a finalizer to run. |
+| [InternedString](-interned-string/index.md) | `class InternedString : `[`GcRoot`](./index.md)<br>An interned string, see [java.lang.String.intern](https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#intern()). |
+| [JavaFrame](-java-frame/index.md) | `class JavaFrame : `[`GcRoot`](./index.md)<br>A java local variable |
+| [JniGlobal](-jni-global/index.md) | `class JniGlobal : `[`GcRoot`](./index.md)<br>A global variable in native code. |
+| [JniLocal](-jni-local/index.md) | `class JniLocal : `[`GcRoot`](./index.md)<br>A local variable in native code. |
+| [JniMonitor](-jni-monitor/index.md) | `class JniMonitor : `[`GcRoot`](./index.md)<br>It's unclear what this is, documentation welcome. |
+| [MonitorUsed](-monitor-used/index.md) | `class MonitorUsed : `[`GcRoot`](./index.md)<br>Everything that called the wait() or notify() methods, or that is synchronized. |
+| [NativeStack](-native-stack/index.md) | `class NativeStack : `[`GcRoot`](./index.md)<br>Input or output parameters in native code |
+| [ReferenceCleanup](-reference-cleanup/index.md) | `class ReferenceCleanup : `[`GcRoot`](./index.md)<br>It's unclear what this is, documentation welcome. |
+| [StickyClass](-sticky-class/index.md) | `class StickyClass : `[`GcRoot`](./index.md)<br>A system class |
+| [ThreadBlock](-thread-block/index.md) | `class ThreadBlock : `[`GcRoot`](./index.md) |
+| [ThreadObject](-thread-object/index.md) | `class ThreadObject : `[`GcRoot`](./index.md)<br>A thread. |
+| [Unknown](-unknown/index.md) | `class Unknown : `[`GcRoot`](./index.md)<br>An unknown gc root. |
+| [Unreachable](-unreachable/index.md) | `class Unreachable : `[`GcRoot`](./index.md)<br>An object that is unreachable from any other root, but not a root itself. |
+| [VmInternal](-vm-internal/index.md) | `class VmInternal : `[`GcRoot`](./index.md)<br>It's unclear what this is, documentation welcome. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `abstract val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The object id of the object that this gc root references. |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [Debugger](-debugger/index.md) | `class Debugger : `[`GcRoot`](./index.md)<br>An object held by a connected debugger |
+| [Finalizing](-finalizing/index.md) | `class Finalizing : `[`GcRoot`](./index.md)<br>An object that is in a queue, waiting for a finalizer to run. |
+| [InternedString](-interned-string/index.md) | `class InternedString : `[`GcRoot`](./index.md)<br>An interned string, see [java.lang.String.intern](https://docs.oracle.com/javase/6/docs/api/java/lang/String.html#intern()). |
+| [JavaFrame](-java-frame/index.md) | `class JavaFrame : `[`GcRoot`](./index.md)<br>A java local variable |
+| [JniGlobal](-jni-global/index.md) | `class JniGlobal : `[`GcRoot`](./index.md)<br>A global variable in native code. |
+| [JniLocal](-jni-local/index.md) | `class JniLocal : `[`GcRoot`](./index.md)<br>A local variable in native code. |
+| [JniMonitor](-jni-monitor/index.md) | `class JniMonitor : `[`GcRoot`](./index.md)<br>It's unclear what this is, documentation welcome. |
+| [MonitorUsed](-monitor-used/index.md) | `class MonitorUsed : `[`GcRoot`](./index.md)<br>Everything that called the wait() or notify() methods, or that is synchronized. |
+| [NativeStack](-native-stack/index.md) | `class NativeStack : `[`GcRoot`](./index.md)<br>Input or output parameters in native code |
+| [ReferenceCleanup](-reference-cleanup/index.md) | `class ReferenceCleanup : `[`GcRoot`](./index.md)<br>It's unclear what this is, documentation welcome. |
+| [StickyClass](-sticky-class/index.md) | `class StickyClass : `[`GcRoot`](./index.md)<br>A system class |
+| [ThreadBlock](-thread-block/index.md) | `class ThreadBlock : `[`GcRoot`](./index.md) |
+| [ThreadObject](-thread-object/index.md) | `class ThreadObject : `[`GcRoot`](./index.md)<br>A thread. |
+| [Unknown](-unknown/index.md) | `class Unknown : `[`GcRoot`](./index.md)<br>An unknown gc root. |
+| [Unreachable](-unreachable/index.md) | `class Unreachable : `[`GcRoot`](./index.md)<br>An object that is unreachable from any other root, but not a root itself. |
+| [VmInternal](-vm-internal/index.md) | `class VmInternal : `[`GcRoot`](./index.md)<br>It's unclear what this is, documentation welcome. |
diff --git a/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/-init-.md b/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/-init-.md
new file mode 100644
index 00000000..d88ea1c2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/-init-.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofPrimitiveArrayStripper](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HprofPrimitiveArrayStripper()`
+
+Converts a Hprof file to another file with all primitive arrays replaced with arrays of zeroes,
+which can be useful to remove PII. Char arrays are handled slightly differently because 0 would
+be the null character so instead these become arrays of '?'.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/index.md b/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/index.md
new file mode 100644
index 00000000..8602e6a8
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/index.md
@@ -0,0 +1,24 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofPrimitiveArrayStripper](./index.md)
+
+# HprofPrimitiveArrayStripper
+
+`class HprofPrimitiveArrayStripper`
+
+Converts a Hprof file to another file with all primitive arrays replaced with arrays of zeroes,
+which can be useful to remove PII. Char arrays are handled slightly differently because 0 would
+be the null character so instead these become arrays of '?'.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HprofPrimitiveArrayStripper()`<br>Converts a Hprof file to another file with all primitive arrays replaced with arrays of zeroes, which can be useful to remove PII. Char arrays are handled slightly differently because 0 would be the null character so instead these become arrays of '?'. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [stripPrimitiveArrays](strip-primitive-arrays.md) | `fun stripPrimitiveArrays(inputHprofFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, outputHprofFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)` = File(
+        inputHprofFile.parent, inputHprofFile.name.replace(
+        ".hprof", "-stripped.hprof"
+    ).let { if (it != inputHprofFile.name) it else inputHprofFile.name + "-stripped" })): `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/strip-primitive-arrays.md b/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/strip-primitive-arrays.md
new file mode 100644
index 00000000..13eb0ac7
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-primitive-array-stripper/strip-primitive-arrays.md
@@ -0,0 +1,13 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofPrimitiveArrayStripper](index.md) / [stripPrimitiveArrays](./strip-primitive-arrays.md)
+
+# stripPrimitiveArrays
+
+`fun stripPrimitiveArrays(inputHprofFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, outputHprofFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)` = File(
+        inputHprofFile.parent, inputHprofFile.name.replace(
+        ".hprof", "-stripped.hprof"
+    ).let { if (it != inputHprofFile.name) it else inputHprofFile.name + "-stripped" })): `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)
+
+**See Also**
+
+[HprofPrimitiveArrayStripper](index.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/-init-.md b/docs/api/shark-hprof/shark/-hprof-reader/-init-.md
new file mode 100644
index 00000000..6a240bc2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/-init-.md
@@ -0,0 +1,15 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HprofReader(source: BufferedSource, identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, startPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = 0L)`
+
+Reads hprof content from an Okio [BufferedSource](#).
+
+Not thread safe, should be used from a single thread.
+
+Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
+
+The Android Hprof format differs in some ways from that reference. This parser implementation
+is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/identifier-byte-size.md b/docs/api/shark-hprof/shark/-hprof-reader/identifier-byte-size.md
new file mode 100644
index 00000000..0247589b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/identifier-byte-size.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [identifierByteSize](./identifier-byte-size.md)
+
+# identifierByteSize
+
+`val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects,
+stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are not
+required to be.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/index.md b/docs/api/shark-hprof/shark/-hprof-reader/index.md
new file mode 100644
index 00000000..18961a86
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/index.md
@@ -0,0 +1,43 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](./index.md)
+
+# HprofReader
+
+`class HprofReader`
+
+Reads hprof content from an Okio [BufferedSource](#).
+
+Not thread safe, should be used from a single thread.
+
+Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
+
+The Android Hprof format differs in some ways from that reference. This parser implementation
+is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HprofReader(source: BufferedSource, identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, startPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = 0L)`<br>Reads hprof content from an Okio [BufferedSource](#). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [identifierByteSize](identifier-byte-size.md) | `val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects, stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are not required to be. |
+| [position](position.md) | `var position: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Starts at [startPosition](start-position.md) and increases as [HprofReader](./index.md) reads bytes. This is useful for tracking the position of content in the backing [source](#). This never resets. |
+| [startPosition](start-position.md) | `val startPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>How many bytes have already been read from [source](#) when this [HprofReader](./index.md) is created. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [readClassDumpRecord](read-class-dump-record.md) | `fun readClassDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-class-dump-record/index.md)<br>Reads a full class record after a class dump tag. |
+| [readClassSkipContentRecord](read-class-skip-content-record.md) | `fun readClassSkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md)<br>Reads a class record after a class dump tag, skipping its content. |
+| [readHprofRecords](read-hprof-records.md) | `fun readHprofRecords(recordTypes: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`HprofRecord`](../-hprof-record/index.md)`>>, listener: `[`OnHprofRecordListener`](../-on-hprof-record-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Reads all hprof records from [source](#). Assumes the [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) was has a source that currently points to the start position of hprof records. |
+| [readInstanceDumpRecord](read-instance-dump-record.md) | `fun readInstanceDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/index.md)<br>Reads a full instance record after a instance dump tag. |
+| [readInstanceSkipContentRecord](read-instance-skip-content-record.md) | `fun readInstanceSkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md)<br>Reads an instance record after a instance dump tag, skipping its content. |
+| [readObjectArrayDumpRecord](read-object-array-dump-record.md) | `fun readObjectArrayDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/index.md)<br>Reads a full object array record after a object array dump tag. |
+| [readObjectArraySkipContentRecord](read-object-array-skip-content-record.md) | `fun readObjectArraySkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md)<br>Reads an object array record after a object array dump tag, skipping its content. |
+| [readPrimitiveArrayDumpRecord](read-primitive-array-dump-record.md) | `fun readPrimitiveArrayDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md)<br>Reads a full primitive array record after a primitive array dump tag. |
+| [readPrimitiveArraySkipContentRecord](read-primitive-array-skip-content-record.md) | `fun readPrimitiveArraySkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md)<br>Reads a primitive array record after a primitive array dump tag, skipping its content. |
+| [readValue](read-value.md) | `fun readValue(type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`): `[`ValueHolder`](../-value-holder/index.md)<br>Reads a value in the heap dump, which can be a reference or a primitive type. |
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/position.md b/docs/api/shark-hprof/shark/-hprof-reader/position.md
new file mode 100644
index 00000000..1671c49a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/position.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [position](./position.md)
+
+# position
+
+`var position: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Starts at [startPosition](start-position.md) and increases as [HprofReader](index.md) reads bytes. This is useful
+for tracking the position of content in the backing [source](#). This never resets.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-class-dump-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-class-dump-record.md
new file mode 100644
index 00000000..501cd4bc
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-class-dump-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readClassDumpRecord](./read-class-dump-record.md)
+
+# readClassDumpRecord
+
+`fun readClassDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-class-dump-record/index.md)
+
+Reads a full class record after a class dump tag.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-class-skip-content-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-class-skip-content-record.md
new file mode 100644
index 00000000..bbba87a1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-class-skip-content-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readClassSkipContentRecord](./read-class-skip-content-record.md)
+
+# readClassSkipContentRecord
+
+`fun readClassSkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md)
+
+Reads a class record after a class dump tag, skipping its content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-hprof-records.md b/docs/api/shark-hprof/shark/-hprof-reader/read-hprof-records.md
new file mode 100644
index 00000000..9ccd30f6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-hprof-records.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readHprofRecords](./read-hprof-records.md)
+
+# readHprofRecords
+
+`fun readHprofRecords(recordTypes: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`HprofRecord`](../-hprof-record/index.md)`>>, listener: `[`OnHprofRecordListener`](../-on-hprof-record-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Reads all hprof records from [source](#).
+Assumes the [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) was has a source that currently points to the start position of hprof
+records.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-instance-dump-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-instance-dump-record.md
new file mode 100644
index 00000000..59b236f2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-instance-dump-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readInstanceDumpRecord](./read-instance-dump-record.md)
+
+# readInstanceDumpRecord
+
+`fun readInstanceDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/index.md)
+
+Reads a full instance record after a instance dump tag.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-instance-skip-content-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-instance-skip-content-record.md
new file mode 100644
index 00000000..73a06701
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-instance-skip-content-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readInstanceSkipContentRecord](./read-instance-skip-content-record.md)
+
+# readInstanceSkipContentRecord
+
+`fun readInstanceSkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md)
+
+Reads an instance record after a instance dump tag, skipping its content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-dump-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-dump-record.md
new file mode 100644
index 00000000..77cbdc46
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-dump-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readObjectArrayDumpRecord](./read-object-array-dump-record.md)
+
+# readObjectArrayDumpRecord
+
+`fun readObjectArrayDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/index.md)
+
+Reads a full object array record after a object array dump tag.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-skip-content-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-skip-content-record.md
new file mode 100644
index 00000000..1e9566ae
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-skip-content-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readObjectArraySkipContentRecord](./read-object-array-skip-content-record.md)
+
+# readObjectArraySkipContentRecord
+
+`fun readObjectArraySkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md)
+
+Reads an object array record after a object array dump tag, skipping its content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-dump-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-dump-record.md
new file mode 100644
index 00000000..f6d293b9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-dump-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readPrimitiveArrayDumpRecord](./read-primitive-array-dump-record.md)
+
+# readPrimitiveArrayDumpRecord
+
+`fun readPrimitiveArrayDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md)
+
+Reads a full primitive array record after a primitive array dump tag.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-skip-content-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-skip-content-record.md
new file mode 100644
index 00000000..f09dbf50
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-skip-content-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readPrimitiveArraySkipContentRecord](./read-primitive-array-skip-content-record.md)
+
+# readPrimitiveArraySkipContentRecord
+
+`fun readPrimitiveArraySkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md)
+
+Reads a primitive array record after a primitive array dump tag, skipping its content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-value.md b/docs/api/shark-hprof/shark/-hprof-reader/read-value.md
new file mode 100644
index 00000000..f476bc31
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-value.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readValue](./read-value.md)
+
+# readValue
+
+`fun readValue(type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`): `[`ValueHolder`](../-value-holder/index.md)
+
+Reads a value in the heap dump, which can be a reference or a primitive type.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/start-position.md b/docs/api/shark-hprof/shark/-hprof-reader/start-position.md
new file mode 100644
index 00000000..fed83964
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/start-position.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [startPosition](./start-position.md)
+
+# startPosition
+
+`val startPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+How many bytes have already been read from [source](#) when this [HprofReader](index.md) is created.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-end-record.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-end-record.md
new file mode 100644
index 00000000..0a9350e2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-end-record.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofRecord](index.md) / [HeapDumpEndRecord](./-heap-dump-end-record.md)
+
+# HeapDumpEndRecord
+
+`object HeapDumpEndRecord : `[`HprofRecord`](index.md)
+
+Terminates a series of heap dump segments. Concatenation of heap dump segments equals a
+heap dump.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/-init-.md
new file mode 100644
index 00000000..cbec5901
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../index.md) / [shark](../../../index.md) / [HprofRecord](../../index.md) / [HeapDumpRecord](../index.md) / [GcRootRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`GcRootRecord(gcRoot: `[`GcRoot`](../../../-gc-root/index.md)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/gc-root.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/gc-root.md
new file mode 100644
index 00000000..c8d15de1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/gc-root.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../index.md) / [shark](../../../index.md) / [HprofRecord](../../index.md) / [HeapDumpRecord](../index.md) / [GcRootRecord](index.md) / [gcRoot](./gc-root.md)
+
+# gcRoot
+
+`val gcRoot: `[`GcRoot`](../../../-gc-root/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/index.md
new file mode 100644
index 00000000..1da8ab92
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-gc-root-record/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../../index.md) / [shark](../../../index.md) / [HprofRecord](../../index.md) / [HeapDumpRecord](../index.md) / [GcRootRecord](./index.md)
+
+# GcRootRecord
+
+`class GcRootRecord : `[`HprofRecord.HeapDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `GcRootRecord(gcRoot: `[`GcRoot`](../../../-gc-root/index.md)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [gcRoot](gc-root.md) | `val gcRoot: `[`GcRoot`](../../../-gc-root/index.md) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/-init-.md
new file mode 100644
index 00000000..0ff6ba34
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../index.md) / [shark](../../../index.md) / [HprofRecord](../../index.md) / [HeapDumpRecord](../index.md) / [HeapDumpInfoRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HeapDumpInfoRecord(heapId: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, heapNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/heap-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/heap-id.md
new file mode 100644
index 00000000..17278c77
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/heap-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../index.md) / [shark](../../../index.md) / [HprofRecord](../../index.md) / [HeapDumpRecord](../index.md) / [HeapDumpInfoRecord](index.md) / [heapId](./heap-id.md)
+
+# heapId
+
+`val heapId: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/heap-name-string-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/heap-name-string-id.md
new file mode 100644
index 00000000..7b9f9210
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/heap-name-string-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../index.md) / [shark](../../../index.md) / [HprofRecord](../../index.md) / [HeapDumpRecord](../index.md) / [HeapDumpInfoRecord](index.md) / [heapNameStringId](./heap-name-string-id.md)
+
+# heapNameStringId
+
+`val heapNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/index.md
new file mode 100644
index 00000000..d6c6e39a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-heap-dump-info-record/index.md
@@ -0,0 +1,18 @@
+[shark-hprof](../../../../index.md) / [shark](../../../index.md) / [HprofRecord](../../index.md) / [HeapDumpRecord](../index.md) / [HeapDumpInfoRecord](./index.md)
+
+# HeapDumpInfoRecord
+
+`class HeapDumpInfoRecord : `[`HprofRecord.HeapDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HeapDumpInfoRecord(heapId: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, heapNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [heapId](heap-id.md) | `val heapId: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [heapNameStringId](heap-name-string-id.md) | `val heapNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/-init-.md
new file mode 100644
index 00000000..2212395e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [FieldRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`FieldRecord(nameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/index.md
new file mode 100644
index 00000000..eea8597b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/index.md
@@ -0,0 +1,18 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [FieldRecord](./index.md)
+
+# FieldRecord
+
+`data class FieldRecord`
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `FieldRecord(nameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [nameStringId](name-string-id.md) | `val nameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [type](type.md) | `val type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/name-string-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/name-string-id.md
new file mode 100644
index 00000000..bfbf6824
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/name-string-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [FieldRecord](index.md) / [nameStringId](./name-string-id.md)
+
+# nameStringId
+
+`val nameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/type.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/type.md
new file mode 100644
index 00000000..4664f655
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-field-record/type.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [FieldRecord](index.md) / [type](./type.md)
+
+# type
+
+`val type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-init-.md
new file mode 100644
index 00000000..7c7ef343
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ClassDumpRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, staticFields: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord`](-static-field-record/index.md)`>, fields: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord`](-field-record/index.md)`>)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/-init-.md
new file mode 100644
index 00000000..1daa8599
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [StaticFieldRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`StaticFieldRecord(nameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, value: `[`ValueHolder`](../../../../../-value-holder/index.md)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/index.md
new file mode 100644
index 00000000..ed811d42
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [StaticFieldRecord](./index.md)
+
+# StaticFieldRecord
+
+`data class StaticFieldRecord`
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `StaticFieldRecord(nameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, value: `[`ValueHolder`](../../../../../-value-holder/index.md)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [nameStringId](name-string-id.md) | `val nameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [type](type.md) | `val type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [value](value.md) | `val value: `[`ValueHolder`](../../../../../-value-holder/index.md) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/name-string-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/name-string-id.md
new file mode 100644
index 00000000..bd33cccd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/name-string-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [StaticFieldRecord](index.md) / [nameStringId](./name-string-id.md)
+
+# nameStringId
+
+`val nameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/type.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/type.md
new file mode 100644
index 00000000..ea687bff
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/type.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [StaticFieldRecord](index.md) / [type](./type.md)
+
+# type
+
+`val type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/value.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/value.md
new file mode 100644
index 00000000..3baab17b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/-static-field-record/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [ClassDumpRecord](../index.md) / [StaticFieldRecord](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`ValueHolder`](../../../../../-value-holder/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/class-loader-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/class-loader-id.md
new file mode 100644
index 00000000..86f1a467
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/class-loader-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [classLoaderId](./class-loader-id.md)
+
+# classLoaderId
+
+`val classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/fields.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/fields.md
new file mode 100644
index 00000000..e18b1be0
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/fields.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [fields](./fields.md)
+
+# fields
+
+`val fields: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord`](-field-record/index.md)`>`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/id.md
new file mode 100644
index 00000000..abb55dd6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/index.md
new file mode 100644
index 00000000..416060a3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/index.md
@@ -0,0 +1,32 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](./index.md)
+
+# ClassDumpRecord
+
+`class ClassDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [FieldRecord](-field-record/index.md) | `data class FieldRecord` |
+| [StaticFieldRecord](-static-field-record/index.md) | `data class StaticFieldRecord` |
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ClassDumpRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, staticFields: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord`](-static-field-record/index.md)`>, fields: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord`](-field-record/index.md)`>)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classLoaderId](class-loader-id.md) | `val classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [fields](fields.md) | `val fields: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord`](-field-record/index.md)`>` |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [instanceSize](instance-size.md) | `val instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [protectionDomainId](protection-domain-id.md) | `val protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [signersId](signers-id.md) | `val signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [staticFields](static-fields.md) | `val staticFields: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord`](-static-field-record/index.md)`>` |
+| [superclassId](superclass-id.md) | `val superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/instance-size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/instance-size.md
new file mode 100644
index 00000000..f356d895
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/instance-size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [instanceSize](./instance-size.md)
+
+# instanceSize
+
+`val instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/protection-domain-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/protection-domain-id.md
new file mode 100644
index 00000000..edd60eb3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/protection-domain-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [protectionDomainId](./protection-domain-id.md)
+
+# protectionDomainId
+
+`val protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/signers-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/signers-id.md
new file mode 100644
index 00000000..2250faee
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/signers-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [signersId](./signers-id.md)
+
+# signersId
+
+`val signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..7bcbff4e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/static-fields.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/static-fields.md
new file mode 100644
index 00000000..d9fc6067
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/static-fields.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [staticFields](./static-fields.md)
+
+# staticFields
+
+`val staticFields: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord`](-static-field-record/index.md)`>`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/superclass-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/superclass-id.md
new file mode 100644
index 00000000..8fab7371
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-dump-record/superclass-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassDumpRecord](index.md) / [superclassId](./superclass-id.md)
+
+# superclassId
+
+`val superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/-init-.md
new file mode 100644
index 00000000..9ea742b9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ClassSkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, staticFieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, fieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[ClassDumpRecord](../-class-dump-record/index.md) for when you don't need the class content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/class-loader-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/class-loader-id.md
new file mode 100644
index 00000000..7fca9b04
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/class-loader-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [classLoaderId](./class-loader-id.md)
+
+# classLoaderId
+
+`val classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/field-count.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/field-count.md
new file mode 100644
index 00000000..6605e137
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/field-count.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [fieldCount](./field-count.md)
+
+# fieldCount
+
+`val fieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/id.md
new file mode 100644
index 00000000..142f1570
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md
new file mode 100644
index 00000000..c5c8c29b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md
@@ -0,0 +1,28 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](./index.md)
+
+# ClassSkipContentRecord
+
+`class ClassSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[ClassDumpRecord](../-class-dump-record/index.md) for when you don't need the class content.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ClassSkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, staticFieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, fieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>This isn't a real record type as found in the heap dump. It's an alternative to [ClassDumpRecord](../-class-dump-record/index.md) for when you don't need the class content. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classLoaderId](class-loader-id.md) | `val classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [fieldCount](field-count.md) | `val fieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [instanceSize](instance-size.md) | `val instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [protectionDomainId](protection-domain-id.md) | `val protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [signersId](signers-id.md) | `val signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [staticFieldCount](static-field-count.md) | `val staticFieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [superclassId](superclass-id.md) | `val superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/instance-size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/instance-size.md
new file mode 100644
index 00000000..36090e41
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/instance-size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [instanceSize](./instance-size.md)
+
+# instanceSize
+
+`val instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/protection-domain-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/protection-domain-id.md
new file mode 100644
index 00000000..f6bc67f6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/protection-domain-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [protectionDomainId](./protection-domain-id.md)
+
+# protectionDomainId
+
+`val protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/signers-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/signers-id.md
new file mode 100644
index 00000000..d1b0531d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/signers-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [signersId](./signers-id.md)
+
+# signersId
+
+`val signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..bbb455c3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/static-field-count.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/static-field-count.md
new file mode 100644
index 00000000..76527a27
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/static-field-count.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [staticFieldCount](./static-field-count.md)
+
+# staticFieldCount
+
+`val staticFieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/superclass-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/superclass-id.md
new file mode 100644
index 00000000..df584767
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/superclass-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [superclassId](./superclass-id.md)
+
+# superclassId
+
+`val superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/-init-.md
new file mode 100644
index 00000000..46aa0f5d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceDumpRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`InstanceDumpRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, fieldValues: `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/class-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/class-id.md
new file mode 100644
index 00000000..6f48ed4a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/class-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceDumpRecord](index.md) / [classId](./class-id.md)
+
+# classId
+
+`val classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/field-values.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/field-values.md
new file mode 100644
index 00000000..bc33e1a6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/field-values.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceDumpRecord](index.md) / [fieldValues](./field-values.md)
+
+# fieldValues
+
+`val fieldValues: `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)
+
+Instance field values (this class, followed by super class, etc)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/id.md
new file mode 100644
index 00000000..d6678b24
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceDumpRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/index.md
new file mode 100644
index 00000000..21655157
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceDumpRecord](./index.md)
+
+# InstanceDumpRecord
+
+`class InstanceDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `InstanceDumpRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, fieldValues: `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classId](class-id.md) | `val classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [fieldValues](field-values.md) | `val fieldValues: `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)<br>Instance field values (this class, followed by super class, etc) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..fe3786a3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceDumpRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/-init-.md
new file mode 100644
index 00000000..6092d13c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`InstanceSkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[InstanceDumpRecord](../-instance-dump-record/index.md) for when you don't need the instance content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/class-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/class-id.md
new file mode 100644
index 00000000..03722b5d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/class-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](index.md) / [classId](./class-id.md)
+
+# classId
+
+`val classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/id.md
new file mode 100644
index 00000000..bc50ba0c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md
new file mode 100644
index 00000000..452a7ff8
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md
@@ -0,0 +1,22 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](./index.md)
+
+# InstanceSkipContentRecord
+
+`class InstanceSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[InstanceDumpRecord](../-instance-dump-record/index.md) for when you don't need the instance content.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `InstanceSkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>This isn't a real record type as found in the heap dump. It's an alternative to [InstanceDumpRecord](../-instance-dump-record/index.md) for when you don't need the instance content. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classId](class-id.md) | `val classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..09b3f109
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/-init-.md
new file mode 100644
index 00000000..47f5261e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArrayDumpRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ObjectArrayDumpRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, elementIds: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/array-class-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/array-class-id.md
new file mode 100644
index 00000000..123bd720
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/array-class-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArrayDumpRecord](index.md) / [arrayClassId](./array-class-id.md)
+
+# arrayClassId
+
+`val arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/element-ids.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/element-ids.md
new file mode 100644
index 00000000..7ca63aef
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/element-ids.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArrayDumpRecord](index.md) / [elementIds](./element-ids.md)
+
+# elementIds
+
+`val elementIds: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/id.md
new file mode 100644
index 00000000..b3fceab3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArrayDumpRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/index.md
new file mode 100644
index 00000000..4838d7b6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArrayDumpRecord](./index.md)
+
+# ObjectArrayDumpRecord
+
+`class ObjectArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ObjectArrayDumpRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, elementIds: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [arrayClassId](array-class-id.md) | `val arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [elementIds](element-ids.md) | `val elementIds: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..38e5c413
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArrayDumpRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/-init-.md
new file mode 100644
index 00000000..792a5391
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ObjectArraySkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[ObjectArrayDumpRecord](../-object-array-dump-record/index.md) for when you don't need the array content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/array-class-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/array-class-id.md
new file mode 100644
index 00000000..349eeb50
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/array-class-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [arrayClassId](./array-class-id.md)
+
+# arrayClassId
+
+`val arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/id.md
new file mode 100644
index 00000000..13a21bfd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md
new file mode 100644
index 00000000..6983c34a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md
@@ -0,0 +1,23 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](./index.md)
+
+# ObjectArraySkipContentRecord
+
+`class ObjectArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[ObjectArrayDumpRecord](../-object-array-dump-record/index.md) for when you don't need the array content.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ObjectArraySkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>This isn't a real record type as found in the heap dump. It's an alternative to [ObjectArrayDumpRecord](../-object-array-dump-record/index.md) for when you don't need the array content. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [arrayClassId](array-class-id.md) | `val arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/size.md
new file mode 100644
index 00000000..d336a001
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..3c25e3f3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/-init-.md
new file mode 100644
index 00000000..9d75cf70
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [BooleanArrayDump](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`BooleanArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`BooleanArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/array.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/array.md
new file mode 100644
index 00000000..d4a81ffb
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/array.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [BooleanArrayDump](index.md) / [array](./array.md)
+
+# array
+
+`val array: `[`BooleanArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/id.md
new file mode 100644
index 00000000..14b4a1ea
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [BooleanArrayDump](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.id](../id.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/index.md
new file mode 100644
index 00000000..2263929f
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [BooleanArrayDump](./index.md)
+
+# BooleanArrayDump
+
+`class BooleanArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `BooleanArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`BooleanArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [array](array.md) | `val array: `[`BooleanArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/size.md
new file mode 100644
index 00000000..8f0c0ce9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [BooleanArrayDump](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.size](../size.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/stack-trace-serial-number.md
new file mode 100644
index 00000000..756de81d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-boolean-array-dump/stack-trace-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [BooleanArrayDump](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.stackTraceSerialNumber](../stack-trace-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/-init-.md
new file mode 100644
index 00000000..da423db3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ByteArrayDump](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ByteArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/array.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/array.md
new file mode 100644
index 00000000..aa8b6a5f
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/array.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ByteArrayDump](index.md) / [array](./array.md)
+
+# array
+
+`val array: `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/id.md
new file mode 100644
index 00000000..9f176398
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ByteArrayDump](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.id](../id.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/index.md
new file mode 100644
index 00000000..a9c54355
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ByteArrayDump](./index.md)
+
+# ByteArrayDump
+
+`class ByteArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ByteArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [array](array.md) | `val array: `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/size.md
new file mode 100644
index 00000000..d9447691
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ByteArrayDump](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.size](../size.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/stack-trace-serial-number.md
new file mode 100644
index 00000000..4c715707
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-byte-array-dump/stack-trace-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ByteArrayDump](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.stackTraceSerialNumber](../stack-trace-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/-init-.md
new file mode 100644
index 00000000..494fdb29
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [CharArrayDump](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`CharArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`CharArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/array.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/array.md
new file mode 100644
index 00000000..c9fba8f5
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/array.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [CharArrayDump](index.md) / [array](./array.md)
+
+# array
+
+`val array: `[`CharArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/id.md
new file mode 100644
index 00000000..9210ae3f
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [CharArrayDump](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.id](../id.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/index.md
new file mode 100644
index 00000000..d4223b84
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [CharArrayDump](./index.md)
+
+# CharArrayDump
+
+`class CharArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `CharArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`CharArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [array](array.md) | `val array: `[`CharArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/size.md
new file mode 100644
index 00000000..90591ab6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [CharArrayDump](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.size](../size.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/stack-trace-serial-number.md
new file mode 100644
index 00000000..bb834fe1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-char-array-dump/stack-trace-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [CharArrayDump](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.stackTraceSerialNumber](../stack-trace-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/-init-.md
new file mode 100644
index 00000000..3e6b5d2a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [DoubleArrayDump](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`DoubleArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`DoubleArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/array.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/array.md
new file mode 100644
index 00000000..12c7b134
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/array.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [DoubleArrayDump](index.md) / [array](./array.md)
+
+# array
+
+`val array: `[`DoubleArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/id.md
new file mode 100644
index 00000000..4342ca58
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [DoubleArrayDump](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.id](../id.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/index.md
new file mode 100644
index 00000000..5b7137f6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [DoubleArrayDump](./index.md)
+
+# DoubleArrayDump
+
+`class DoubleArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `DoubleArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`DoubleArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [array](array.md) | `val array: `[`DoubleArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/size.md
new file mode 100644
index 00000000..55a98772
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [DoubleArrayDump](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.size](../size.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/stack-trace-serial-number.md
new file mode 100644
index 00000000..7fd29b73
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-double-array-dump/stack-trace-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [DoubleArrayDump](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.stackTraceSerialNumber](../stack-trace-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/-init-.md
new file mode 100644
index 00000000..08e799cc
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [FloatArrayDump](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`FloatArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`FloatArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/array.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/array.md
new file mode 100644
index 00000000..e4df5a67
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/array.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [FloatArrayDump](index.md) / [array](./array.md)
+
+# array
+
+`val array: `[`FloatArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/id.md
new file mode 100644
index 00000000..832bb574
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [FloatArrayDump](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.id](../id.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/index.md
new file mode 100644
index 00000000..67d27ac4
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [FloatArrayDump](./index.md)
+
+# FloatArrayDump
+
+`class FloatArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `FloatArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`FloatArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [array](array.md) | `val array: `[`FloatArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/size.md
new file mode 100644
index 00000000..cbeca359
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [FloatArrayDump](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.size](../size.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/stack-trace-serial-number.md
new file mode 100644
index 00000000..a51d1a4a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-float-array-dump/stack-trace-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [FloatArrayDump](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.stackTraceSerialNumber](../stack-trace-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/-init-.md
new file mode 100644
index 00000000..ab97a1b9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [IntArrayDump](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`IntArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`IntArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/array.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/array.md
new file mode 100644
index 00000000..4e7295f1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/array.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [IntArrayDump](index.md) / [array](./array.md)
+
+# array
+
+`val array: `[`IntArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/id.md
new file mode 100644
index 00000000..cea51728
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [IntArrayDump](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.id](../id.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/index.md
new file mode 100644
index 00000000..a2fcae53
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [IntArrayDump](./index.md)
+
+# IntArrayDump
+
+`class IntArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `IntArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`IntArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [array](array.md) | `val array: `[`IntArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/size.md
new file mode 100644
index 00000000..4d905f34
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [IntArrayDump](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.size](../size.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/stack-trace-serial-number.md
new file mode 100644
index 00000000..6a4a32f5
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-int-array-dump/stack-trace-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [IntArrayDump](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.stackTraceSerialNumber](../stack-trace-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/-init-.md
new file mode 100644
index 00000000..81f2b421
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [LongArrayDump](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`LongArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/array.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/array.md
new file mode 100644
index 00000000..fd7eb278
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/array.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [LongArrayDump](index.md) / [array](./array.md)
+
+# array
+
+`val array: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/id.md
new file mode 100644
index 00000000..d5fb4f08
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [LongArrayDump](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.id](../id.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/index.md
new file mode 100644
index 00000000..bbb85e4e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [LongArrayDump](./index.md)
+
+# LongArrayDump
+
+`class LongArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `LongArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [array](array.md) | `val array: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/size.md
new file mode 100644
index 00000000..8cb2e64e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [LongArrayDump](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.size](../size.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/stack-trace-serial-number.md
new file mode 100644
index 00000000..69286688
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-long-array-dump/stack-trace-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [LongArrayDump](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.stackTraceSerialNumber](../stack-trace-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/-init-.md
new file mode 100644
index 00000000..cdb0be09
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ShortArrayDump](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ShortArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`ShortArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/array.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/array.md
new file mode 100644
index 00000000..e0c23772
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/array.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ShortArrayDump](index.md) / [array](./array.md)
+
+# array
+
+`val array: `[`ShortArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/id.md
new file mode 100644
index 00000000..5053f7ef
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/id.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ShortArrayDump](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.id](../id.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/index.md
new file mode 100644
index 00000000..e9fb426a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ShortArrayDump](./index.md)
+
+# ShortArrayDump
+
+`class ShortArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ShortArrayDump(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, array: `[`ShortArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [array](array.md) | `val array: `[`ShortArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short-array/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/size.md
new file mode 100644
index 00000000..1b3a7f06
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ShortArrayDump](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.size](../size.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/stack-trace-serial-number.md
new file mode 100644
index 00000000..bda71d30
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/-short-array-dump/stack-trace-serial-number.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../../../../../index.md) / [shark](../../../../../index.md) / [HprofRecord](../../../../index.md) / [HeapDumpRecord](../../../index.md) / [ObjectRecord](../../index.md) / [PrimitiveArrayDumpRecord](../index.md) / [ShortArrayDump](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+Overrides [PrimitiveArrayDumpRecord.stackTraceSerialNumber](../stack-trace-serial-number.md)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/id.md
new file mode 100644
index 00000000..1f2f0c86
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArrayDumpRecord](index.md) / [id](./id.md)
+
+# id
+
+`abstract val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md
new file mode 100644
index 00000000..c8c44bd1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md
@@ -0,0 +1,39 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArrayDumpRecord](./index.md)
+
+# PrimitiveArrayDumpRecord
+
+`sealed class PrimitiveArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [BooleanArrayDump](-boolean-array-dump/index.md) | `class BooleanArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [ByteArrayDump](-byte-array-dump/index.md) | `class ByteArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [CharArrayDump](-char-array-dump/index.md) | `class CharArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [DoubleArrayDump](-double-array-dump/index.md) | `class DoubleArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [FloatArrayDump](-float-array-dump/index.md) | `class FloatArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [IntArrayDump](-int-array-dump/index.md) | `class IntArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [LongArrayDump](-long-array-dump/index.md) | `class LongArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [ShortArrayDump](-short-array-dump/index.md) | `class ShortArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `abstract val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `abstract val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `abstract val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [BooleanArrayDump](-boolean-array-dump/index.md) | `class BooleanArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [ByteArrayDump](-byte-array-dump/index.md) | `class ByteArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [CharArrayDump](-char-array-dump/index.md) | `class CharArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [DoubleArrayDump](-double-array-dump/index.md) | `class DoubleArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [FloatArrayDump](-float-array-dump/index.md) | `class FloatArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [IntArrayDump](-int-array-dump/index.md) | `class IntArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [LongArrayDump](-long-array-dump/index.md) | `class LongArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
+| [ShortArrayDump](-short-array-dump/index.md) | `class ShortArrayDump : `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](./index.md) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/size.md
new file mode 100644
index 00000000..e0b58e3a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArrayDumpRecord](index.md) / [size](./size.md)
+
+# size
+
+`abstract val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..6d6157bb
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArrayDumpRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`abstract val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/-init-.md
new file mode 100644
index 00000000..950055b1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`PrimitiveArraySkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, type: `[`PrimitiveType`](../../../../-primitive-type/index.md)`)`
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[PrimitiveArrayDumpRecord](../-primitive-array-dump-record/index.md) for when you don't need the array content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/id.md
new file mode 100644
index 00000000..f6e601bd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md
new file mode 100644
index 00000000..ee9f0150
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md
@@ -0,0 +1,23 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](./index.md)
+
+# PrimitiveArraySkipContentRecord
+
+`class PrimitiveArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[PrimitiveArrayDumpRecord](../-primitive-array-dump-record/index.md) for when you don't need the array content.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `PrimitiveArraySkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, type: `[`PrimitiveType`](../../../../-primitive-type/index.md)`)`<br>This isn't a real record type as found in the heap dump. It's an alternative to [PrimitiveArrayDumpRecord](../-primitive-array-dump-record/index.md) for when you don't need the array content. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [type](type.md) | `val type: `[`PrimitiveType`](../../../../-primitive-type/index.md) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/size.md
new file mode 100644
index 00000000..f653bf1b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..3e180378
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/type.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/type.md
new file mode 100644
index 00000000..c582abdf
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/type.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [type](./type.md)
+
+# type
+
+`val type: `[`PrimitiveType`](../../../../-primitive-type/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/index.md
new file mode 100644
index 00000000..5a3e02c0
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/index.md
@@ -0,0 +1,31 @@
+[shark-hprof](../../../../index.md) / [shark](../../../index.md) / [HprofRecord](../../index.md) / [HeapDumpRecord](../index.md) / [ObjectRecord](./index.md)
+
+# ObjectRecord
+
+`sealed class ObjectRecord : `[`HprofRecord.HeapDumpRecord`](../index.md)
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [ClassDumpRecord](-class-dump-record/index.md) | `class ClassDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [ClassSkipContentRecord](-class-skip-content-record/index.md) | `class ClassSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [ClassDumpRecord](-class-dump-record/index.md) for when you don't need the class content. |
+| [InstanceDumpRecord](-instance-dump-record/index.md) | `class InstanceDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [InstanceSkipContentRecord](-instance-skip-content-record/index.md) | `class InstanceSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [InstanceDumpRecord](-instance-dump-record/index.md) for when you don't need the instance content. |
+| [ObjectArrayDumpRecord](-object-array-dump-record/index.md) | `class ObjectArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [ObjectArraySkipContentRecord](-object-array-skip-content-record/index.md) | `class ObjectArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [ObjectArrayDumpRecord](-object-array-dump-record/index.md) for when you don't need the array content. |
+| [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) | `sealed class PrimitiveArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [PrimitiveArraySkipContentRecord](-primitive-array-skip-content-record/index.md) | `class PrimitiveArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) for when you don't need the array content. |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [ClassDumpRecord](-class-dump-record/index.md) | `class ClassDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [ClassSkipContentRecord](-class-skip-content-record/index.md) | `class ClassSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [ClassDumpRecord](-class-dump-record/index.md) for when you don't need the class content. |
+| [InstanceDumpRecord](-instance-dump-record/index.md) | `class InstanceDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [InstanceSkipContentRecord](-instance-skip-content-record/index.md) | `class InstanceSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [InstanceDumpRecord](-instance-dump-record/index.md) for when you don't need the instance content. |
+| [ObjectArrayDumpRecord](-object-array-dump-record/index.md) | `class ObjectArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [ObjectArraySkipContentRecord](-object-array-skip-content-record/index.md) | `class ObjectArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [ObjectArrayDumpRecord](-object-array-dump-record/index.md) for when you don't need the array content. |
+| [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) | `sealed class PrimitiveArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [PrimitiveArraySkipContentRecord](-primitive-array-skip-content-record/index.md) | `class PrimitiveArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) for when you don't need the array content. |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/index.md
new file mode 100644
index 00000000..ed4113de
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/index.md
@@ -0,0 +1,21 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [HeapDumpRecord](./index.md)
+
+# HeapDumpRecord
+
+`sealed class HeapDumpRecord : `[`HprofRecord`](../index.md)
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [GcRootRecord](-gc-root-record/index.md) | `class GcRootRecord : `[`HprofRecord.HeapDumpRecord`](./index.md) |
+| [HeapDumpInfoRecord](-heap-dump-info-record/index.md) | `class HeapDumpInfoRecord : `[`HprofRecord.HeapDumpRecord`](./index.md) |
+| [ObjectRecord](-object-record/index.md) | `sealed class ObjectRecord : `[`HprofRecord.HeapDumpRecord`](./index.md) |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [GcRootRecord](-gc-root-record/index.md) | `class GcRootRecord : `[`HprofRecord.HeapDumpRecord`](./index.md) |
+| [HeapDumpInfoRecord](-heap-dump-info-record/index.md) | `class HeapDumpInfoRecord : `[`HprofRecord.HeapDumpRecord`](./index.md) |
+| [ObjectRecord](-object-record/index.md) | `sealed class ObjectRecord : `[`HprofRecord.HeapDumpRecord`](./index.md) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/-init-.md
new file mode 100644
index 00000000..6632c7a2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [LoadClassRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`LoadClassRecord(classSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, classNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/class-name-string-id.md b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/class-name-string-id.md
new file mode 100644
index 00000000..5c93b395
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/class-name-string-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [LoadClassRecord](index.md) / [classNameStringId](./class-name-string-id.md)
+
+# classNameStringId
+
+`val classNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/class-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/class-serial-number.md
new file mode 100644
index 00000000..ec6f5e60
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/class-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [LoadClassRecord](index.md) / [classSerialNumber](./class-serial-number.md)
+
+# classSerialNumber
+
+`val classSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/id.md
new file mode 100644
index 00000000..29964f46
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [LoadClassRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/index.md
new file mode 100644
index 00000000..e9e1958e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/index.md
@@ -0,0 +1,20 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [LoadClassRecord](./index.md)
+
+# LoadClassRecord
+
+`class LoadClassRecord : `[`HprofRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `LoadClassRecord(classSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, classNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classNameStringId](class-name-string-id.md) | `val classNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [classSerialNumber](class-serial-number.md) | `val classSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..2fb26f6a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-load-class-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [LoadClassRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/-init-.md
new file mode 100644
index 00000000..da2a899a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackFrameRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`StackFrameRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, methodNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, methodSignatureStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, sourceFileNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, classSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, lineNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/class-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/class-serial-number.md
new file mode 100644
index 00000000..e893d46b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/class-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackFrameRecord](index.md) / [classSerialNumber](./class-serial-number.md)
+
+# classSerialNumber
+
+`val classSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/id.md
new file mode 100644
index 00000000..474b9363
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackFrameRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/index.md
new file mode 100644
index 00000000..a674e40f
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/index.md
@@ -0,0 +1,22 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackFrameRecord](./index.md)
+
+# StackFrameRecord
+
+`class StackFrameRecord : `[`HprofRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `StackFrameRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, methodNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, methodSignatureStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, sourceFileNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, classSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, lineNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classSerialNumber](class-serial-number.md) | `val classSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [lineNumber](line-number.md) | `val lineNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>0 line number 0 no line information available -1 unknown location -2 compiled method (Not implemented) -3 native method (Not implemented) |
+| [methodNameStringId](method-name-string-id.md) | `val methodNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [methodSignatureStringId](method-signature-string-id.md) | `val methodSignatureStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [sourceFileNameStringId](source-file-name-string-id.md) | `val sourceFileNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/line-number.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/line-number.md
new file mode 100644
index 00000000..21b7f7b3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/line-number.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackFrameRecord](index.md) / [lineNumber](./line-number.md)
+
+# lineNumber
+
+`val lineNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+0 line number
+0 no line information available
+-1 unknown location
+-2 compiled method (Not implemented)
+-3 native method (Not implemented)
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/method-name-string-id.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/method-name-string-id.md
new file mode 100644
index 00000000..19068196
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/method-name-string-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackFrameRecord](index.md) / [methodNameStringId](./method-name-string-id.md)
+
+# methodNameStringId
+
+`val methodNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/method-signature-string-id.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/method-signature-string-id.md
new file mode 100644
index 00000000..79c00eb5
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/method-signature-string-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackFrameRecord](index.md) / [methodSignatureStringId](./method-signature-string-id.md)
+
+# methodSignatureStringId
+
+`val methodSignatureStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/source-file-name-string-id.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/source-file-name-string-id.md
new file mode 100644
index 00000000..45fa84ea
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-frame-record/source-file-name-string-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackFrameRecord](index.md) / [sourceFileNameStringId](./source-file-name-string-id.md)
+
+# sourceFileNameStringId
+
+`val sourceFileNameStringId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/-init-.md
new file mode 100644
index 00000000..ffda58f3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackTraceRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`StackTraceRecord(stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, stackFrameIds: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/index.md
new file mode 100644
index 00000000..60db5e79
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/index.md
@@ -0,0 +1,19 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackTraceRecord](./index.md)
+
+# StackTraceRecord
+
+`class StackTraceRecord : `[`HprofRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `StackTraceRecord(stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, stackFrameIds: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [stackFrameIds](stack-frame-ids.md) | `val stackFrameIds: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [threadSerialNumber](thread-serial-number.md) | `val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/stack-frame-ids.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/stack-frame-ids.md
new file mode 100644
index 00000000..88bc154b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/stack-frame-ids.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackTraceRecord](index.md) / [stackFrameIds](./stack-frame-ids.md)
+
+# stackFrameIds
+
+`val stackFrameIds: `[`LongArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long-array/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..6ac93da7
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackTraceRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/thread-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/thread-serial-number.md
new file mode 100644
index 00000000..bd194285
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-stack-trace-record/thread-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StackTraceRecord](index.md) / [threadSerialNumber](./thread-serial-number.md)
+
+# threadSerialNumber
+
+`val threadSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-string-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-string-record/-init-.md
new file mode 100644
index 00000000..6d677783
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-string-record/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StringRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`StringRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, string: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-string-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-string-record/id.md
new file mode 100644
index 00000000..3de951ef
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-string-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StringRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-string-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-string-record/index.md
new file mode 100644
index 00000000..6bd6cc8a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-string-record/index.md
@@ -0,0 +1,18 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StringRecord](./index.md)
+
+# StringRecord
+
+`class StringRecord : `[`HprofRecord`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `StringRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, string: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [string](string.md) | `val string: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-string-record/string.md b/docs/api/shark-hprof/shark/-hprof-record/-string-record/string.md
new file mode 100644
index 00000000..d6357b5d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-string-record/string.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [HprofRecord](../index.md) / [StringRecord](index.md) / [string](./string.md)
+
+# string
+
+`val string: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/index.md
new file mode 100644
index 00000000..2a4b4dd2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/index.md
@@ -0,0 +1,29 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofRecord](./index.md)
+
+# HprofRecord
+
+`sealed class HprofRecord`
+
+A Hprof record. These data structure map 1:1 with how records are written in hprof files.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [HeapDumpEndRecord](-heap-dump-end-record.md) | `object HeapDumpEndRecord : `[`HprofRecord`](./index.md)<br>Terminates a series of heap dump segments. Concatenation of heap dump segments equals a heap dump. |
+| [HeapDumpRecord](-heap-dump-record/index.md) | `sealed class HeapDumpRecord : `[`HprofRecord`](./index.md) |
+| [LoadClassRecord](-load-class-record/index.md) | `class LoadClassRecord : `[`HprofRecord`](./index.md) |
+| [StackFrameRecord](-stack-frame-record/index.md) | `class StackFrameRecord : `[`HprofRecord`](./index.md) |
+| [StackTraceRecord](-stack-trace-record/index.md) | `class StackTraceRecord : `[`HprofRecord`](./index.md) |
+| [StringRecord](-string-record/index.md) | `class StringRecord : `[`HprofRecord`](./index.md) |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [HeapDumpEndRecord](-heap-dump-end-record.md) | `object HeapDumpEndRecord : `[`HprofRecord`](./index.md)<br>Terminates a series of heap dump segments. Concatenation of heap dump segments equals a heap dump. |
+| [HeapDumpRecord](-heap-dump-record/index.md) | `sealed class HeapDumpRecord : `[`HprofRecord`](./index.md) |
+| [LoadClassRecord](-load-class-record/index.md) | `class LoadClassRecord : `[`HprofRecord`](./index.md) |
+| [StackFrameRecord](-stack-frame-record/index.md) | `class StackFrameRecord : `[`HprofRecord`](./index.md) |
+| [StackTraceRecord](-stack-trace-record/index.md) | `class StackTraceRecord : `[`HprofRecord`](./index.md) |
+| [StringRecord](-string-record/index.md) | `class StringRecord : `[`HprofRecord`](./index.md) |
diff --git a/docs/api/shark-hprof/shark/-hprof-writer/close.md b/docs/api/shark-hprof/shark/-hprof-writer/close.md
new file mode 100644
index 00000000..7f13c54e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-writer/close.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofWriter](index.md) / [close](./close.md)
+
+# close
+
+`fun close(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Flushes to disk all [HprofRecord.HeapDumpRecord](../-hprof-record/-heap-dump-record/index.md) that are currently written to the in memory
+buffer, then closes the file.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-writer/hprof-version.md b/docs/api/shark-hprof/shark/-hprof-writer/hprof-version.md
new file mode 100644
index 00000000..07fa516c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-writer/hprof-version.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofWriter](index.md) / [hprofVersion](./hprof-version.md)
+
+# hprofVersion
+
+`val hprofVersion: `[`Hprof.HprofVersion`](../-hprof/-hprof-version/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-writer/identifier-byte-size.md b/docs/api/shark-hprof/shark/-hprof-writer/identifier-byte-size.md
new file mode 100644
index 00000000..0d4c12c3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-writer/identifier-byte-size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofWriter](index.md) / [identifierByteSize](./identifier-byte-size.md)
+
+# identifierByteSize
+
+`val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-writer/index.md b/docs/api/shark-hprof/shark/-hprof-writer/index.md
new file mode 100644
index 00000000..9082f03d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-writer/index.md
@@ -0,0 +1,30 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofWriter](./index.md)
+
+# HprofWriter
+
+`class HprofWriter : `[`Closeable`](https://docs.oracle.com/javase/6/docs/api/java/io/Closeable.html)
+
+Generates Hprof files.
+
+Call [open](open.md) to create an instance, [write](write.md) to add instances and [close](close.md) when you're done.
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [hprofVersion](hprof-version.md) | `val hprofVersion: `[`Hprof.HprofVersion`](../-hprof/-hprof-version/index.md) |
+| [identifierByteSize](identifier-byte-size.md) | `val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [close](close.md) | `fun close(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Flushes to disk all [HprofRecord.HeapDumpRecord](../-hprof-record/-heap-dump-record/index.md) that are currently written to the in memory buffer, then closes the file. |
+| [valuesToBytes](values-to-bytes.md) | `fun valuesToBytes(values: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ValueHolder`](../-value-holder/index.md)`>): `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)<br>Helper method for creating a [ByteArray](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html) for [InstanceDumpRecord.fieldValues](../-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/field-values.md) from a list of [ValueHolder](../-value-holder/index.md). |
+| [write](write.md) | `fun write(record: `[`HprofRecord`](../-hprof-record/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Appends a [HprofRecord](../-hprof-record/index.md) to the heap dump. If [record](write.md#shark.HprofWriter$write(shark.HprofRecord)/record) is a [HprofRecord.HeapDumpRecord](../-hprof-record/-heap-dump-record/index.md) then it will not be written to an in memory buffer and written to file only when the next a record that is not a [HprofRecord.HeapDumpRecord](../-hprof-record/-heap-dump-record/index.md) is written or when [close](close.md) is called. |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [open](open.md) | `fun open(hprofFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)` = 4, hprofVersion: `[`Hprof.HprofVersion`](../-hprof/-hprof-version/index.md)` = HprofVersion.ANDROID): `[`HprofWriter`](./index.md)<br>Opens a new file for writing hprof records. Don't forget to call [close](close.md) once done. |
diff --git a/docs/api/shark-hprof/shark/-hprof-writer/open.md b/docs/api/shark-hprof/shark/-hprof-writer/open.md
new file mode 100644
index 00000000..63430cf6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-writer/open.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofWriter](index.md) / [open](./open.md)
+
+# open
+
+`fun open(hprofFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)` = 4, hprofVersion: `[`Hprof.HprofVersion`](../-hprof/-hprof-version/index.md)` = HprofVersion.ANDROID): `[`HprofWriter`](index.md)
+
+Opens a new file for writing hprof records. Don't forget to call [close](close.md) once done.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-writer/values-to-bytes.md b/docs/api/shark-hprof/shark/-hprof-writer/values-to-bytes.md
new file mode 100644
index 00000000..eb5b8b92
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-writer/values-to-bytes.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofWriter](index.md) / [valuesToBytes](./values-to-bytes.md)
+
+# valuesToBytes
+
+`fun valuesToBytes(values: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ValueHolder`](../-value-holder/index.md)`>): `[`ByteArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html)
+
+Helper method for creating a [ByteArray](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte-array/index.html) for [InstanceDumpRecord.fieldValues](../-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/field-values.md) from a
+list of [ValueHolder](../-value-holder/index.md).
+
diff --git a/docs/api/shark-hprof/shark/-hprof-writer/write.md b/docs/api/shark-hprof/shark/-hprof-writer/write.md
new file mode 100644
index 00000000..5040f43c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-writer/write.md
@@ -0,0 +1,10 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofWriter](index.md) / [write](./write.md)
+
+# write
+
+`fun write(record: `[`HprofRecord`](../-hprof-record/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Appends a [HprofRecord](../-hprof-record/index.md) to the heap dump. If [record](write.md#shark.HprofWriter$write(shark.HprofRecord)/record) is a [HprofRecord.HeapDumpRecord](../-hprof-record/-heap-dump-record/index.md) then
+it will not be written to an in memory buffer and written to file only when the next a record
+that is not a [HprofRecord.HeapDumpRecord](../-hprof-record/-heap-dump-record/index.md) is written or when [close](close.md) is called.
+
diff --git a/docs/api/shark-hprof/shark/-hprof/-hprof-version/-a-n-d-r-o-i-d.md b/docs/api/shark-hprof/shark/-hprof/-hprof-version/-a-n-d-r-o-i-d.md
new file mode 100644
index 00000000..e14b8ba1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/-hprof-version/-a-n-d-r-o-i-d.md
@@ -0,0 +1,11 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [Hprof](../index.md) / [HprofVersion](index.md) / [ANDROID](./-a-n-d-r-o-i-d.md)
+
+# ANDROID
+
+`ANDROID`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [versionString](version-string.md) | `val versionString: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k1_2_-b-e-t-a3.md b/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k1_2_-b-e-t-a3.md
new file mode 100644
index 00000000..4694a67e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k1_2_-b-e-t-a3.md
@@ -0,0 +1,11 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [Hprof](../index.md) / [HprofVersion](index.md) / [JDK1_2_BETA3](./-j-d-k1_2_-b-e-t-a3.md)
+
+# JDK1_2_BETA3
+
+`JDK1_2_BETA3`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [versionString](version-string.md) | `val versionString: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k1_2_-b-e-t-a4.md b/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k1_2_-b-e-t-a4.md
new file mode 100644
index 00000000..27546f4f
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k1_2_-b-e-t-a4.md
@@ -0,0 +1,11 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [Hprof](../index.md) / [HprofVersion](index.md) / [JDK1_2_BETA4](./-j-d-k1_2_-b-e-t-a4.md)
+
+# JDK1_2_BETA4
+
+`JDK1_2_BETA4`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [versionString](version-string.md) | `val versionString: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k_6.md b/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k_6.md
new file mode 100644
index 00000000..511ba1e4
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/-hprof-version/-j-d-k_6.md
@@ -0,0 +1,11 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [Hprof](../index.md) / [HprofVersion](index.md) / [JDK_6](./-j-d-k_6.md)
+
+# JDK_6
+
+`JDK_6`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [versionString](version-string.md) | `val versionString: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof/-hprof-version/index.md b/docs/api/shark-hprof/shark/-hprof/-hprof-version/index.md
new file mode 100644
index 00000000..5b7f5683
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/-hprof-version/index.md
@@ -0,0 +1,22 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [Hprof](../index.md) / [HprofVersion](./index.md)
+
+# HprofVersion
+
+`enum class HprofVersion`
+
+Supported hprof versions
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [JDK1_2_BETA3](-j-d-k1_2_-b-e-t-a3.md) |  |
+| [JDK1_2_BETA4](-j-d-k1_2_-b-e-t-a4.md) |  |
+| [JDK_6](-j-d-k_6.md) |  |
+| [ANDROID](-a-n-d-r-o-i-d.md) |  |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [versionString](version-string.md) | `val versionString: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof/-hprof-version/version-string.md b/docs/api/shark-hprof/shark/-hprof/-hprof-version/version-string.md
new file mode 100644
index 00000000..8914a76f
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/-hprof-version/version-string.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [Hprof](../index.md) / [HprofVersion](index.md) / [versionString](./version-string.md)
+
+# versionString
+
+`val versionString: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof/close.md b/docs/api/shark-hprof/shark/-hprof/close.md
new file mode 100644
index 00000000..ac87c2f9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/close.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](index.md) / [close](./close.md)
+
+# close
+
+`fun close(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof/file-length.md b/docs/api/shark-hprof/shark/-hprof/file-length.md
new file mode 100644
index 00000000..0d417a79
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/file-length.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](index.md) / [fileLength](./file-length.md)
+
+# fileLength
+
+`val fileLength: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Length of the hprof file, in bytes.
+
diff --git a/docs/api/shark-hprof/shark/-hprof/heap-dump-timestamp.md b/docs/api/shark-hprof/shark/-hprof/heap-dump-timestamp.md
new file mode 100644
index 00000000..7a3f45fb
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/heap-dump-timestamp.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](index.md) / [heapDumpTimestamp](./heap-dump-timestamp.md)
+
+# heapDumpTimestamp
+
+`val heapDumpTimestamp: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Unix timestamp at which the heap was dumped.
+
diff --git a/docs/api/shark-hprof/shark/-hprof/hprof-version.md b/docs/api/shark-hprof/shark/-hprof/hprof-version.md
new file mode 100644
index 00000000..cf0f4817
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/hprof-version.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](index.md) / [hprofVersion](./hprof-version.md)
+
+# hprofVersion
+
+`val hprofVersion: `[`Hprof.HprofVersion`](-hprof-version/index.md)
+
+Version of the opened hprof, which is tied to the runtime where the heap was dumped.
+
diff --git a/docs/api/shark-hprof/shark/-hprof/index.md b/docs/api/shark-hprof/shark/-hprof/index.md
new file mode 100644
index 00000000..1d59f3f9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/index.md
@@ -0,0 +1,36 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](./index.md)
+
+# Hprof
+
+`class Hprof : `[`Closeable`](https://docs.oracle.com/javase/6/docs/api/java/io/Closeable.html)
+
+An opened Hprof file which can be read via [reader](reader.md). Open a new hprof with [open](open.md), and don't
+forget to call [close](close.md) once done.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [HprofVersion](-hprof-version/index.md) | `enum class HprofVersion`<br>Supported hprof versions |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [fileLength](file-length.md) | `val fileLength: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Length of the hprof file, in bytes. |
+| [heapDumpTimestamp](heap-dump-timestamp.md) | `val heapDumpTimestamp: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Unix timestamp at which the heap was dumped. |
+| [hprofVersion](hprof-version.md) | `val hprofVersion: `[`Hprof.HprofVersion`](-hprof-version/index.md)<br>Version of the opened hprof, which is tied to the runtime where the heap was dumped. |
+| [reader](reader.md) | `val reader: `[`HprofReader`](../-hprof-reader/index.md) |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [close](close.md) | `fun close(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+| [moveReaderTo](move-reader-to.md) | `fun moveReaderTo(newPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Moves [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) to a new position in the hprof file. This is transparent to the reader, and will not reset [HprofReader.position](../-hprof-reader/position.md). |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [open](open.md) | `fun open(hprofFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`): `[`Hprof`](./index.md)<br>Reads the headers of the provided [hprofFile](open.md#shark.Hprof.Companion$open(java.io.File)/hprofFile) and returns an opened [Hprof](./index.md). Don't forget to call [close](close.md) once done. |
diff --git a/docs/api/shark-hprof/shark/-hprof/move-reader-to.md b/docs/api/shark-hprof/shark/-hprof/move-reader-to.md
new file mode 100644
index 00000000..eda5d968
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/move-reader-to.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](index.md) / [moveReaderTo](./move-reader-to.md)
+
+# moveReaderTo
+
+`fun moveReaderTo(newPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Moves [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) to a new position in the hprof file. This is transparent to the reader, and
+will not reset [HprofReader.position](../-hprof-reader/position.md).
+
diff --git a/docs/api/shark-hprof/shark/-hprof/open.md b/docs/api/shark-hprof/shark/-hprof/open.md
new file mode 100644
index 00000000..098e3520
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/open.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](index.md) / [open](./open.md)
+
+# open
+
+`fun open(hprofFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`): `[`Hprof`](index.md)
+
+Reads the headers of the provided [hprofFile](open.md#shark.Hprof.Companion$open(java.io.File)/hprofFile) and returns an opened [Hprof](index.md). Don't forget
+to call [close](close.md) once done.
+
diff --git a/docs/api/shark-hprof/shark/-hprof/reader.md b/docs/api/shark-hprof/shark/-hprof/reader.md
new file mode 100644
index 00000000..8af155ef
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/reader.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](index.md) / [reader](./reader.md)
+
+# reader
+
+`val reader: `[`HprofReader`](../-hprof-reader/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-on-hprof-record-listener/index.md b/docs/api/shark-hprof/shark/-on-hprof-record-listener/index.md
new file mode 100644
index 00000000..c91fb6c1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-on-hprof-record-listener/index.md
@@ -0,0 +1,21 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [OnHprofRecordListener](./index.md)
+
+# OnHprofRecordListener
+
+`interface OnHprofRecordListener`
+
+Listener passed in to [HprofReader.readHprofRecords](../-hprof-reader/read-hprof-records.md), gets notified for each [HprofRecord](../-hprof-record/index.md)
+found in the heap dump which types is in the set of the recordTypes parameter passed to
+[HprofReader.readHprofRecords](../-hprof-reader/read-hprof-records.md).
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [onHprofRecord](on-hprof-record.md) | `abstract fun onHprofRecord(position: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, record: `[`HprofRecord`](../-hprof-record/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [invoke](invoke.md) | `operator fun invoke(block: (`[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, `[`HprofRecord`](../-hprof-record/index.md)`) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`OnHprofRecordListener`](./index.md)<br>Utility function to create a [OnHprofRecordListener](./index.md) from the passed in [block](invoke.md#shark.OnHprofRecordListener.Companion$invoke(kotlin.Function2((kotlin.Long, shark.HprofRecord, kotlin.Unit)))/block) lambda instead of using the anonymous `object : OnHprofRecordListener` syntax. |
diff --git a/docs/api/shark-hprof/shark/-on-hprof-record-listener/invoke.md b/docs/api/shark-hprof/shark/-on-hprof-record-listener/invoke.md
new file mode 100644
index 00000000..78c8acbd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-on-hprof-record-listener/invoke.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [OnHprofRecordListener](index.md) / [invoke](./invoke.md)
+
+# invoke
+
+`inline operator fun invoke(crossinline block: (`[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, `[`HprofRecord`](../-hprof-record/index.md)`) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`OnHprofRecordListener`](index.md)
+
+Utility function to create a [OnHprofRecordListener](index.md) from the passed in [block](invoke.md#shark.OnHprofRecordListener.Companion$invoke(kotlin.Function2((kotlin.Long, shark.HprofRecord, kotlin.Unit)))/block) lambda
+instead of using the anonymous `object : OnHprofRecordListener` syntax.
+
+Usage:
+
+``` kotlin
+val listener = OnHprofRecordListener { position, record ->
+
+}
+```
+
diff --git a/docs/api/shark-hprof/shark/-on-hprof-record-listener/on-hprof-record.md b/docs/api/shark-hprof/shark/-on-hprof-record-listener/on-hprof-record.md
new file mode 100644
index 00000000..32684521
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-on-hprof-record-listener/on-hprof-record.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [OnHprofRecordListener](index.md) / [onHprofRecord](./on-hprof-record.md)
+
+# onHprofRecord
+
+`abstract fun onHprofRecord(position: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, record: `[`HprofRecord`](../-hprof-record/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-b-o-o-l-e-a-n.md b/docs/api/shark-hprof/shark/-primitive-type/-b-o-o-l-e-a-n.md
new file mode 100644
index 00000000..ee83a4db
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-b-o-o-l-e-a-n.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [BOOLEAN](./-b-o-o-l-e-a-n.md)
+
+# BOOLEAN
+
+`BOOLEAN`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-b-y-t-e.md b/docs/api/shark-hprof/shark/-primitive-type/-b-y-t-e.md
new file mode 100644
index 00000000..f96eb3ad
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-b-y-t-e.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [BYTE](./-b-y-t-e.md)
+
+# BYTE
+
+`BYTE`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-c-h-a-r.md b/docs/api/shark-hprof/shark/-primitive-type/-c-h-a-r.md
new file mode 100644
index 00000000..dbcbb212
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-c-h-a-r.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [CHAR](./-c-h-a-r.md)
+
+# CHAR
+
+`CHAR`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-d-o-u-b-l-e.md b/docs/api/shark-hprof/shark/-primitive-type/-d-o-u-b-l-e.md
new file mode 100644
index 00000000..1801a603
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-d-o-u-b-l-e.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [DOUBLE](./-d-o-u-b-l-e.md)
+
+# DOUBLE
+
+`DOUBLE`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-f-l-o-a-t.md b/docs/api/shark-hprof/shark/-primitive-type/-f-l-o-a-t.md
new file mode 100644
index 00000000..36e14fb9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-f-l-o-a-t.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [FLOAT](./-f-l-o-a-t.md)
+
+# FLOAT
+
+`FLOAT`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-i-n-t.md b/docs/api/shark-hprof/shark/-primitive-type/-i-n-t.md
new file mode 100644
index 00000000..6de1383c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-i-n-t.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [INT](./-i-n-t.md)
+
+# INT
+
+`INT`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-l-o-n-g.md b/docs/api/shark-hprof/shark/-primitive-type/-l-o-n-g.md
new file mode 100644
index 00000000..eb37e46f
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-l-o-n-g.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [LONG](./-l-o-n-g.md)
+
+# LONG
+
+`LONG`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-r-e-f-e-r-e-n-c-e_-h-p-r-o-f_-t-y-p-e.md b/docs/api/shark-hprof/shark/-primitive-type/-r-e-f-e-r-e-n-c-e_-h-p-r-o-f_-t-y-p-e.md
new file mode 100644
index 00000000..0f63d69d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-r-e-f-e-r-e-n-c-e_-h-p-r-o-f_-t-y-p-e.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [REFERENCE_HPROF_TYPE](./-r-e-f-e-r-e-n-c-e_-h-p-r-o-f_-t-y-p-e.md)
+
+# REFERENCE_HPROF_TYPE
+
+`const val REFERENCE_HPROF_TYPE: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+The hprof defined "basic type" for references.
+
diff --git a/docs/api/shark-hprof/shark/-primitive-type/-s-h-o-r-t.md b/docs/api/shark-hprof/shark/-primitive-type/-s-h-o-r-t.md
new file mode 100644
index 00000000..835c76cd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/-s-h-o-r-t.md
@@ -0,0 +1,12 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [SHORT](./-s-h-o-r-t.md)
+
+# SHORT
+
+`SHORT`
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/byte-size-by-hprof-type.md b/docs/api/shark-hprof/shark/-primitive-type/byte-size-by-hprof-type.md
new file mode 100644
index 00000000..160a1969
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/byte-size-by-hprof-type.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [byteSizeByHprofType](./byte-size-by-hprof-type.md)
+
+# byteSizeByHprofType
+
+`val byteSizeByHprofType: `[`Map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)`<`[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`>`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-primitive-type/byte-size.md b/docs/api/shark-hprof/shark/-primitive-type/byte-size.md
new file mode 100644
index 00000000..f869facf
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/byte-size.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [byteSize](./byte-size.md)
+
+# byteSize
+
+`val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+The size in bytes for each value of that type.
+
diff --git a/docs/api/shark-hprof/shark/-primitive-type/hprof-type.md b/docs/api/shark-hprof/shark/-primitive-type/hprof-type.md
new file mode 100644
index 00000000..ca95bf3b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/hprof-type.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [hprofType](./hprof-type.md)
+
+# hprofType
+
+`val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
+
+The hprof defined "basic type".
+
diff --git a/docs/api/shark-hprof/shark/-primitive-type/index.md b/docs/api/shark-hprof/shark/-primitive-type/index.md
new file mode 100644
index 00000000..e67f6974
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/index.md
@@ -0,0 +1,35 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](./index.md)
+
+# PrimitiveType
+
+`enum class PrimitiveType`
+
+A primitive type in the prof.
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [BOOLEAN](-b-o-o-l-e-a-n.md) |  |
+| [CHAR](-c-h-a-r.md) |  |
+| [FLOAT](-f-l-o-a-t.md) |  |
+| [DOUBLE](-d-o-u-b-l-e.md) |  |
+| [BYTE](-b-y-t-e.md) |  |
+| [SHORT](-s-h-o-r-t.md) |  |
+| [INT](-i-n-t.md) |  |
+| [LONG](-l-o-n-g.md) |  |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [byteSize](byte-size.md) | `val byteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The size in bytes for each value of that type. |
+| [hprofType](hprof-type.md) | `val hprofType: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type". |
+
+### Companion Object Properties
+
+| Name | Summary |
+|---|---|
+| [byteSizeByHprofType](byte-size-by-hprof-type.md) | `val byteSizeByHprofType: `[`Map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)`<`[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`>` |
+| [primitiveTypeByHprofType](primitive-type-by-hprof-type.md) | `val primitiveTypeByHprofType: `[`Map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)`<`[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, `[`PrimitiveType`](./index.md)`>` |
+| [REFERENCE_HPROF_TYPE](-r-e-f-e-r-e-n-c-e_-h-p-r-o-f_-t-y-p-e.md) | `const val REFERENCE_HPROF_TYPE: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type" for references. |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/primitive-type-by-hprof-type.md b/docs/api/shark-hprof/shark/-primitive-type/primitive-type-by-hprof-type.md
new file mode 100644
index 00000000..ad2447ea
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/primitive-type-by-hprof-type.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [primitiveTypeByHprofType](./primitive-type-by-hprof-type.md)
+
+# primitiveTypeByHprofType
+
+`val primitiveTypeByHprofType: `[`Map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)`<`[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, `[`PrimitiveType`](index.md)`>`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/-init-.md
new file mode 100644
index 00000000..a3f8786b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [BooleanHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`BooleanHolder(value: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/index.md
new file mode 100644
index 00000000..cc826f66
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [BooleanHolder](./index.md)
+
+# BooleanHolder
+
+`data class BooleanHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `BooleanHolder(value: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [value](value.md) | `val value: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/value.md
new file mode 100644
index 00000000..f443da60
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-boolean-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [BooleanHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-byte-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-byte-holder/-init-.md
new file mode 100644
index 00000000..383336b4
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-byte-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ByteHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ByteHolder(value: `[`Byte`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-byte-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-byte-holder/index.md
new file mode 100644
index 00000000..aa985283
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-byte-holder/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ByteHolder](./index.md)
+
+# ByteHolder
+
+`data class ByteHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ByteHolder(value: `[`Byte`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [value](value.md) | `val value: `[`Byte`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-byte-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-byte-holder/value.md
new file mode 100644
index 00000000..c763f8b2
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-byte-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ByteHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Byte`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-byte/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-char-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-char-holder/-init-.md
new file mode 100644
index 00000000..52f54501
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-char-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [CharHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`CharHolder(value: `[`Char`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-char-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-char-holder/index.md
new file mode 100644
index 00000000..88f81c06
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-char-holder/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [CharHolder](./index.md)
+
+# CharHolder
+
+`data class CharHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `CharHolder(value: `[`Char`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [value](value.md) | `val value: `[`Char`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-char-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-char-holder/value.md
new file mode 100644
index 00000000..a756be04
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-char-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [CharHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Char`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-double-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-double-holder/-init-.md
new file mode 100644
index 00000000..22f99af9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-double-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [DoubleHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`DoubleHolder(value: `[`Double`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-double-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-double-holder/index.md
new file mode 100644
index 00000000..03693669
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-double-holder/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [DoubleHolder](./index.md)
+
+# DoubleHolder
+
+`data class DoubleHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `DoubleHolder(value: `[`Double`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [value](value.md) | `val value: `[`Double`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-double-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-double-holder/value.md
new file mode 100644
index 00000000..f82d5d5c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-double-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [DoubleHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Double`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-double/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-float-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-float-holder/-init-.md
new file mode 100644
index 00000000..f2b7c994
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-float-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [FloatHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`FloatHolder(value: `[`Float`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-float-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-float-holder/index.md
new file mode 100644
index 00000000..ff9ac779
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-float-holder/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [FloatHolder](./index.md)
+
+# FloatHolder
+
+`data class FloatHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `FloatHolder(value: `[`Float`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [value](value.md) | `val value: `[`Float`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-float-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-float-holder/value.md
new file mode 100644
index 00000000..f649e36e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-float-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [FloatHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Float`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-float/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-int-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-int-holder/-init-.md
new file mode 100644
index 00000000..b5702233
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-int-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [IntHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`IntHolder(value: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-int-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-int-holder/index.md
new file mode 100644
index 00000000..2cc5087d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-int-holder/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [IntHolder](./index.md)
+
+# IntHolder
+
+`data class IntHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `IntHolder(value: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [value](value.md) | `val value: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-int-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-int-holder/value.md
new file mode 100644
index 00000000..88ed05a1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-int-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [IntHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-long-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-long-holder/-init-.md
new file mode 100644
index 00000000..78b2b34e
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-long-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [LongHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`LongHolder(value: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-long-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-long-holder/index.md
new file mode 100644
index 00000000..e324576a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-long-holder/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [LongHolder](./index.md)
+
+# LongHolder
+
+`data class LongHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `LongHolder(value: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [value](value.md) | `val value: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-long-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-long-holder/value.md
new file mode 100644
index 00000000..44cb23cd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-long-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [LongHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-n-u-l-l_-r-e-f-e-r-e-n-c-e.md b/docs/api/shark-hprof/shark/-value-holder/-n-u-l-l_-r-e-f-e-r-e-n-c-e.md
new file mode 100644
index 00000000..a105a5a1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-n-u-l-l_-r-e-f-e-r-e-n-c-e.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [ValueHolder](index.md) / [NULL_REFERENCE](./-n-u-l-l_-r-e-f-e-r-e-n-c-e.md)
+
+# NULL_REFERENCE
+
+`const val NULL_REFERENCE: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-reference-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-reference-holder/-init-.md
new file mode 100644
index 00000000..3838d4b6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-reference-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ReferenceHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ReferenceHolder(value: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-reference-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-reference-holder/index.md
new file mode 100644
index 00000000..0cdbe33d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-reference-holder/index.md
@@ -0,0 +1,18 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ReferenceHolder](./index.md)
+
+# ReferenceHolder
+
+`data class ReferenceHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ReferenceHolder(value: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [isNull](is-null.md) | `val isNull: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
+| [value](value.md) | `val value: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-reference-holder/is-null.md b/docs/api/shark-hprof/shark/-value-holder/-reference-holder/is-null.md
new file mode 100644
index 00000000..a4bdfdb7
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-reference-holder/is-null.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ReferenceHolder](index.md) / [isNull](./is-null.md)
+
+# isNull
+
+`val isNull: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-reference-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-reference-holder/value.md
new file mode 100644
index 00000000..30547591
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-reference-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ReferenceHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-short-holder/-init-.md b/docs/api/shark-hprof/shark/-value-holder/-short-holder/-init-.md
new file mode 100644
index 00000000..572fbd21
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-short-holder/-init-.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ShortHolder](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ShortHolder(value: `[`Short`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/-short-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/-short-holder/index.md
new file mode 100644
index 00000000..63329281
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-short-holder/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ShortHolder](./index.md)
+
+# ShortHolder
+
+`data class ShortHolder : `[`ValueHolder`](../index.md)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ShortHolder(value: `[`Short`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [value](value.md) | `val value: `[`Short`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html) |
diff --git a/docs/api/shark-hprof/shark/-value-holder/-short-holder/value.md b/docs/api/shark-hprof/shark/-value-holder/-short-holder/value.md
new file mode 100644
index 00000000..7a24091b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/-short-holder/value.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../index.md) / [shark](../../index.md) / [ValueHolder](../index.md) / [ShortHolder](index.md) / [value](./value.md)
+
+# value
+
+`val value: `[`Short`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-short/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-value-holder/index.md b/docs/api/shark-hprof/shark/-value-holder/index.md
new file mode 100644
index 00000000..562cfad1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-value-holder/index.md
@@ -0,0 +1,42 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [ValueHolder](./index.md)
+
+# ValueHolder
+
+`sealed class ValueHolder`
+
+A value in the heap dump, which can be a [ReferenceHolder](-reference-holder/index.md) or
+a primitive type.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [BooleanHolder](-boolean-holder/index.md) | `data class BooleanHolder : `[`ValueHolder`](./index.md) |
+| [ByteHolder](-byte-holder/index.md) | `data class ByteHolder : `[`ValueHolder`](./index.md) |
+| [CharHolder](-char-holder/index.md) | `data class CharHolder : `[`ValueHolder`](./index.md) |
+| [DoubleHolder](-double-holder/index.md) | `data class DoubleHolder : `[`ValueHolder`](./index.md) |
+| [FloatHolder](-float-holder/index.md) | `data class FloatHolder : `[`ValueHolder`](./index.md) |
+| [IntHolder](-int-holder/index.md) | `data class IntHolder : `[`ValueHolder`](./index.md) |
+| [LongHolder](-long-holder/index.md) | `data class LongHolder : `[`ValueHolder`](./index.md) |
+| [ReferenceHolder](-reference-holder/index.md) | `data class ReferenceHolder : `[`ValueHolder`](./index.md) |
+| [ShortHolder](-short-holder/index.md) | `data class ShortHolder : `[`ValueHolder`](./index.md) |
+
+### Companion Object Properties
+
+| Name | Summary |
+|---|---|
+| [NULL_REFERENCE](-n-u-l-l_-r-e-f-e-r-e-n-c-e.md) | `const val NULL_REFERENCE: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [BooleanHolder](-boolean-holder/index.md) | `data class BooleanHolder : `[`ValueHolder`](./index.md) |
+| [ByteHolder](-byte-holder/index.md) | `data class ByteHolder : `[`ValueHolder`](./index.md) |
+| [CharHolder](-char-holder/index.md) | `data class CharHolder : `[`ValueHolder`](./index.md) |
+| [DoubleHolder](-double-holder/index.md) | `data class DoubleHolder : `[`ValueHolder`](./index.md) |
+| [FloatHolder](-float-holder/index.md) | `data class FloatHolder : `[`ValueHolder`](./index.md) |
+| [IntHolder](-int-holder/index.md) | `data class IntHolder : `[`ValueHolder`](./index.md) |
+| [LongHolder](-long-holder/index.md) | `data class LongHolder : `[`ValueHolder`](./index.md) |
+| [ReferenceHolder](-reference-holder/index.md) | `data class ReferenceHolder : `[`ValueHolder`](./index.md) |
+| [ShortHolder](-short-holder/index.md) | `data class ShortHolder : `[`ValueHolder`](./index.md) |
diff --git a/docs/api/shark-hprof/shark/index.md b/docs/api/shark-hprof/shark/index.md
new file mode 100644
index 00000000..345d3c9b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/index.md
@@ -0,0 +1,17 @@
+[shark-hprof](../index.md) / [shark](./index.md)
+
+## Package shark
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [GcRoot](-gc-root/index.md) | `sealed class GcRoot`<br>A GcRoot as identified by [HprofRecord.HeapDumpRecord.GcRootRecord](-hprof-record/-heap-dump-record/-gc-root-record/index.md) in the heap dump. |
+| [Hprof](-hprof/index.md) | `class Hprof : `[`Closeable`](https://docs.oracle.com/javase/6/docs/api/java/io/Closeable.html)<br>An opened Hprof file which can be read via [reader](-hprof/reader.md). Open a new hprof with [open](-hprof/open.md), and don't forget to call [close](-hprof/close.md) once done. |
+| [HprofPrimitiveArrayStripper](-hprof-primitive-array-stripper/index.md) | `class HprofPrimitiveArrayStripper`<br>Converts a Hprof file to another file with all primitive arrays replaced with arrays of zeroes, which can be useful to remove PII. Char arrays are handled slightly differently because 0 would be the null character so instead these become arrays of '?'. |
+| [HprofReader](-hprof-reader/index.md) | `class HprofReader`<br>Reads hprof content from an Okio [BufferedSource](#). |
+| [HprofRecord](-hprof-record/index.md) | `sealed class HprofRecord`<br>A Hprof record. These data structure map 1:1 with how records are written in hprof files. |
+| [HprofWriter](-hprof-writer/index.md) | `class HprofWriter : `[`Closeable`](https://docs.oracle.com/javase/6/docs/api/java/io/Closeable.html)<br>Generates Hprof files. |
+| [OnHprofRecordListener](-on-hprof-record-listener/index.md) | `interface OnHprofRecordListener`<br>Listener passed in to [HprofReader.readHprofRecords](-hprof-reader/read-hprof-records.md), gets notified for each [HprofRecord](-hprof-record/index.md) found in the heap dump which types is in the set of the recordTypes parameter passed to [HprofReader.readHprofRecords](-hprof-reader/read-hprof-records.md). |
+| [PrimitiveType](-primitive-type/index.md) | `enum class PrimitiveType`<br>A primitive type in the prof. |
+| [ValueHolder](-value-holder/index.md) | `sealed class ValueHolder`<br>A value in the heap dump, which can be a [ReferenceHolder](-value-holder/-reference-holder/index.md) or a primitive type. |
diff --git a/docs/api/shark-log/alltypes/index.md b/docs/api/shark-log/alltypes/index.md
new file mode 100644
index 00000000..7adb6d6e
--- /dev/null
+++ b/docs/api/shark-log/alltypes/index.md
@@ -0,0 +1,7 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [shark.SharkLog](../shark/-shark-log/index.md) | Central Logger for all Shark artifacts. Set [logger](../shark/-shark-log/logger.md) to change where these logs go. |
diff --git a/docs/api/shark-log/index.md b/docs/api/shark-log/index.md
new file mode 100644
index 00000000..f0e5e071
--- /dev/null
+++ b/docs/api/shark-log/index.md
@@ -0,0 +1,11 @@
+[shark-log](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [shark](shark/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-log/package-list b/docs/api/shark-log/package-list
new file mode 100644
index 00000000..415577c3
--- /dev/null
+++ b/docs/api/shark-log/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+shark
diff --git a/docs/api/shark-log/shark/-shark-log/-logger/d.md b/docs/api/shark-log/shark/-shark-log/-logger/d.md
new file mode 100644
index 00000000..8afe1098
--- /dev/null
+++ b/docs/api/shark-log/shark/-shark-log/-logger/d.md
@@ -0,0 +1,12 @@
+[shark-log](../../../index.md) / [shark](../../index.md) / [SharkLog](../index.md) / [Logger](index.md) / [d](./d.md)
+
+# d
+
+`abstract fun d(message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, vararg args: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`?): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Logs a debug message formatted with the passed in arguments.
+
+`abstract fun d(throwable: `[`Throwable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html)`, message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, vararg args: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`?): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Logs a [Throwable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html) and debug message formatted with the passed in arguments.
+
diff --git a/docs/api/shark-log/shark/-shark-log/-logger/index.md b/docs/api/shark-log/shark/-shark-log/-logger/index.md
new file mode 100644
index 00000000..ddf5942e
--- /dev/null
+++ b/docs/api/shark-log/shark/-shark-log/-logger/index.md
@@ -0,0 +1,15 @@
+[shark-log](../../../index.md) / [shark](../../index.md) / [SharkLog](../index.md) / [Logger](./index.md)
+
+# Logger
+
+`interface Logger`
+
+**See Also**
+
+[SharkLog](../index.md)
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [d](d.md) | `abstract fun d(message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, vararg args: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`?): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Logs a debug message formatted with the passed in arguments.`abstract fun d(throwable: `[`Throwable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html)`, message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, vararg args: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`?): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Logs a [Throwable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html) and debug message formatted with the passed in arguments. |
diff --git a/docs/api/shark-log/shark/-shark-log/d.md b/docs/api/shark-log/shark/-shark-log/d.md
new file mode 100644
index 00000000..01717102
--- /dev/null
+++ b/docs/api/shark-log/shark/-shark-log/d.md
@@ -0,0 +1,11 @@
+[shark-log](../../index.md) / [shark](../index.md) / [SharkLog](index.md) / [d](./d.md)
+
+# d
+
+`fun d(message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, vararg args: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`?): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+`fun d(throwable: `[`Throwable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html)`, message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, vararg args: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`?): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+**See Also**
+
+[Logger.d](-logger/d.md)
+
diff --git a/docs/api/shark-log/shark/-shark-log/index.md b/docs/api/shark-log/shark/-shark-log/index.md
new file mode 100644
index 00000000..a0cf19b6
--- /dev/null
+++ b/docs/api/shark-log/shark/-shark-log/index.md
@@ -0,0 +1,25 @@
+[shark-log](../../index.md) / [shark](../index.md) / [SharkLog](./index.md)
+
+# SharkLog
+
+`object SharkLog`
+
+Central Logger for all Shark artifacts. Set [logger](logger.md) to change where these logs go.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Logger](-logger/index.md) | `interface Logger` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [logger](logger.md) | `var logger: `[`SharkLog.Logger`](-logger/index.md)`?` |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [d](d.md) | `fun d(message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, vararg args: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`?): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>`fun d(throwable: `[`Throwable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html)`, message: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, vararg args: `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`?): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark-log/shark/-shark-log/logger.md b/docs/api/shark-log/shark/-shark-log/logger.md
new file mode 100644
index 00000000..05e91693
--- /dev/null
+++ b/docs/api/shark-log/shark/-shark-log/logger.md
@@ -0,0 +1,5 @@
+[shark-log](../../index.md) / [shark](../index.md) / [SharkLog](index.md) / [logger](./logger.md)
+
+# logger
+
+`var logger: `[`SharkLog.Logger`](-logger/index.md)`?`
\ No newline at end of file
diff --git a/docs/api/shark-log/shark/index.md b/docs/api/shark-log/shark/index.md
new file mode 100644
index 00000000..9829e456
--- /dev/null
+++ b/docs/api/shark-log/shark/index.md
@@ -0,0 +1,9 @@
+[shark-log](../index.md) / [shark](./index.md)
+
+## Package shark
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [SharkLog](-shark-log/index.md) | `object SharkLog`<br>Central Logger for all Shark artifacts. Set [logger](-shark-log/logger.md) to change where these logs go. |
diff --git a/docs/api/shark/alltypes/index.md b/docs/api/shark/alltypes/index.md
new file mode 100644
index 00000000..b9b2f20b
--- /dev/null
+++ b/docs/api/shark/alltypes/index.md
@@ -0,0 +1,27 @@
+
+
+### All Types
+
+| Name | Summary |
+|---|---|
+| [shark.ApplicationLeak](../shark/-application-leak/index.md) | A leak found by [HeapAnalyzer](../shark/-heap-analyzer/index.md) in your application. |
+| [shark.AppSingletonInspector](../shark/-app-singleton-inspector/index.md) | Inspector that automatically marks instances of the provided class names as not leaking because they're app wide singletons. |
+| [shark.HeapAnalysis](../shark/-heap-analysis/index.md) | The result of an analysis performed by [HeapAnalyzer](../shark/-heap-analyzer/index.md), either a [HeapAnalysisSuccess](../shark/-heap-analysis-success/index.md) or a [HeapAnalysisFailure](../shark/-heap-analysis-failure/index.md). This class is serializable however there are no guarantees of forward compatibility. |
+| [shark.HeapAnalysisException](../shark/-heap-analysis-exception/index.md) |  |
+| [shark.HeapAnalysisFailure](../shark/-heap-analysis-failure/index.md) | The analysis performed by [HeapAnalyzer](../shark/-heap-analyzer/index.md) did not complete successfully. |
+| [shark.HeapAnalysisSuccess](../shark/-heap-analysis-success/index.md) | The result of a successful heap analysis performed by [HeapAnalyzer](../shark/-heap-analyzer/index.md). |
+| [shark.HeapAnalyzer](../shark/-heap-analyzer/index.md) | Analyzes heap dumps to look for leaks. |
+| [shark.IgnoredReferenceMatcher](../shark/-ignored-reference-matcher/index.md) | [IgnoredReferenceMatcher](../shark/-ignored-reference-matcher/index.md) should be used to match references that cannot ever create leaks. The shortest path finder will never go through matching references. |
+| [shark.Leak](../shark/-leak/index.md) | A leak found by [HeapAnalyzer](../shark/-heap-analyzer/index.md), either an [ApplicationLeak](../shark/-application-leak/index.md) or a [LibraryLeak](../shark/-library-leak/index.md). |
+| [shark.LeakNodeStatus](../shark/-leak-node-status/index.md) |  |
+| [shark.LeakReference](../shark/-leak-reference/index.md) | A single field in a [LeakTraceElement](../shark/-leak-trace-element/index.md). |
+| [shark.LeakTrace](../shark/-leak-trace/index.md) | A chain of references that constitute the shortest strong reference path from a GC root to the leaking object. Fixing the leak usually means breaking one of the references in that chain. |
+| [shark.LeakTraceElement](../shark/-leak-trace-element/index.md) |  |
+| [shark.LibraryLeak](../shark/-library-leak/index.md) | A leak found by [HeapAnalyzer](../shark/-heap-analyzer/index.md), where the only path to the leaking object required going through a reference matched by [pattern](../shark/-library-leak/pattern.md), as provided to a [LibraryLeakReferenceMatcher](../shark/-library-leak-reference-matcher/index.md) instance. This is a known leak in library code that is beyond your control. |
+| [shark.LibraryLeakReferenceMatcher](../shark/-library-leak-reference-matcher/index.md) | [LibraryLeakReferenceMatcher](../shark/-library-leak-reference-matcher/index.md) should be used to match references in library code that are known to create leaks and are beyond your control. The shortest path finder will only go through matching references after it has exhausted references that don't match, prioritizing finding an application leak over a known library leak. Library leaks will be reported as [LibraryLeak](../shark/-library-leak/index.md) instead of [ApplicationLeak](../shark/-application-leak/index.md). |
+| [shark.ObjectInspector](../shark/-object-inspector/index.md) | Provides LeakCanary with insights about objects (classes, instances and arrays) found in the heap. [inspect](../shark/-object-inspector/inspect.md) will be called for each object that LeakCanary wants to know more about. The implementation can then use the provided [ObjectReporter](../shark/-object-reporter/index.md) to provide insights for that object. |
+| [shark.ObjectInspectors](../shark/-object-inspectors/index.md) | A set of default [ObjectInspector](../shark/-object-inspector/index.md)s that knows about common JDK objects. |
+| [shark.ObjectReporter](../shark/-object-reporter/index.md) | Enables [ObjectInspector](../shark/-object-inspector/index.md) implementations to provide insights on [heapObject](../shark/-object-reporter/heap-object.md), which is an object (class, instance or array) found in the heap. |
+| [shark.OnAnalysisProgressListener](../shark/-on-analysis-progress-listener/index.md) | Reports progress from the [HeapAnalyzer](../shark/-heap-analyzer/index.md) as they occur, as [Step](../shark/-on-analysis-progress-listener/-step/index.md) values. |
+| [shark.ReferenceMatcher](../shark/-reference-matcher/index.md) | Used to pattern match known patterns of references in the heap, either to ignore them ([IgnoredReferenceMatcher](../shark/-ignored-reference-matcher/index.md)) or to mark them as library leaks ([LibraryLeakReferenceMatcher](../shark/-library-leak-reference-matcher/index.md)). |
+| [shark.ReferencePattern](../shark/-reference-pattern/index.md) | A pattern that will match references for a given [ReferenceMatcher](../shark/-reference-matcher/index.md). |
diff --git a/docs/api/shark/index.md b/docs/api/shark/index.md
new file mode 100644
index 00000000..73375ceb
--- /dev/null
+++ b/docs/api/shark/index.md
@@ -0,0 +1,11 @@
+[shark](./index.md)
+
+### Packages
+
+| Name | Summary |
+|---|---|
+| [shark](shark/index.md) |  |
+
+### Index
+
+[All Types](alltypes/index.md)
\ No newline at end of file
diff --git a/docs/api/shark/package-list b/docs/api/shark/package-list
new file mode 100644
index 00000000..415577c3
--- /dev/null
+++ b/docs/api/shark/package-list
@@ -0,0 +1,4 @@
+$dokka.format:gfm
+$dokka.linkExtension:md
+
+shark
diff --git a/docs/api/shark/shark/-app-singleton-inspector/-init-.md b/docs/api/shark/shark/-app-singleton-inspector/-init-.md
new file mode 100644
index 00000000..1dbd4a5c
--- /dev/null
+++ b/docs/api/shark/shark/-app-singleton-inspector/-init-.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [AppSingletonInspector](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`AppSingletonInspector(vararg singletonClasses: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`
+
+Inspector that automatically marks instances of the provided class names as not leaking
+because they're app wide singletons.
+
diff --git a/docs/api/shark/shark/-app-singleton-inspector/index.md b/docs/api/shark/shark/-app-singleton-inspector/index.md
new file mode 100644
index 00000000..17c48696
--- /dev/null
+++ b/docs/api/shark/shark/-app-singleton-inspector/index.md
@@ -0,0 +1,20 @@
+[shark](../../index.md) / [shark](../index.md) / [AppSingletonInspector](./index.md)
+
+# AppSingletonInspector
+
+`class AppSingletonInspector : `[`ObjectInspector`](../-object-inspector/index.md)
+
+Inspector that automatically marks instances of the provided class names as not leaking
+because they're app wide singletons.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `AppSingletonInspector(vararg singletonClasses: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`<br>Inspector that automatically marks instances of the provided class names as not leaking because they're app wide singletons. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: `[`ObjectReporter`](../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark/shark/-app-singleton-inspector/inspect.md b/docs/api/shark/shark/-app-singleton-inspector/inspect.md
new file mode 100644
index 00000000..f90be2a2
--- /dev/null
+++ b/docs/api/shark/shark/-app-singleton-inspector/inspect.md
@@ -0,0 +1,12 @@
+[shark](../../index.md) / [shark](../index.md) / [AppSingletonInspector](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: `[`ObjectReporter`](../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Overrides [ObjectInspector.inspect](../-object-inspector/inspect.md)
+
+**See Also**
+
+[ObjectInspector](../-object-inspector/index.md)
+
diff --git a/docs/api/shark/shark/-application-leak/-init-.md b/docs/api/shark/shark/-application-leak/-init-.md
new file mode 100644
index 00000000..1656da86
--- /dev/null
+++ b/docs/api/shark/shark/-application-leak/-init-.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [ApplicationLeak](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ApplicationLeak(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, leakTrace: `[`LeakTrace`](../-leak-trace/index.md)`, retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?)`
+
+A leak found by [HeapAnalyzer](../-heap-analyzer/index.md) in your application.
+
diff --git a/docs/api/shark/shark/-application-leak/class-name.md b/docs/api/shark/shark/-application-leak/class-name.md
new file mode 100644
index 00000000..e2199ea0
--- /dev/null
+++ b/docs/api/shark/shark/-application-leak/class-name.md
@@ -0,0 +1,11 @@
+[shark](../../index.md) / [shark](../index.md) / [ApplicationLeak](index.md) / [className](./class-name.md)
+
+# className
+
+`val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Overrides [Leak.className](../-leak/class-name.md)
+
+Class name of the leaking object.
+The class name format is the same as what would be returned by [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()).
+
diff --git a/docs/api/shark/shark/-application-leak/create-group-hash.md b/docs/api/shark/shark/-application-leak/create-group-hash.md
new file mode 100644
index 00000000..247854d2
--- /dev/null
+++ b/docs/api/shark/shark/-application-leak/create-group-hash.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [ApplicationLeak](index.md) / [createGroupHash](./create-group-hash.md)
+
+# createGroupHash
+
+`protected fun createGroupHash(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Overrides [Leak.createGroupHash](../-leak/create-group-hash.md)
+
diff --git a/docs/api/shark/shark/-application-leak/index.md b/docs/api/shark/shark/-application-leak/index.md
new file mode 100644
index 00000000..485e415d
--- /dev/null
+++ b/docs/api/shark/shark/-application-leak/index.md
@@ -0,0 +1,34 @@
+[shark](../../index.md) / [shark](../index.md) / [ApplicationLeak](./index.md)
+
+# ApplicationLeak
+
+`data class ApplicationLeak : `[`Leak`](../-leak/index.md)
+
+A leak found by [HeapAnalyzer](../-heap-analyzer/index.md) in your application.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ApplicationLeak(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, leakTrace: `[`LeakTrace`](../-leak-trace/index.md)`, retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?)`<br>A leak found by [HeapAnalyzer](../-heap-analyzer/index.md) in your application. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [className](class-name.md) | `val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Class name of the leaking object. The class name format is the same as what would be returned by [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()). |
+| [leakTrace](leak-trace.md) | `val leakTrace: `[`LeakTrace`](../-leak-trace/index.md)<br>Shortest path from GC roots to the leaking object. |
+| [retainedHeapByteSize](retained-heap-byte-size.md) | `val retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?`<br>The number of bytes which would be freed if all references to the leaking object were released. Null if the retained heap size was not computed. |
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [classSimpleName](../-leak/class-simple-name.md) | `val classSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Returns [className](../-leak/class-name.md) stripped of any string content before the last period (included). |
+| [groupHash](../-leak/group-hash.md) | `val groupHash: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>A unique SHA1 hash that represents this group of leaks. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [createGroupHash](create-group-hash.md) | `fun createGroupHash(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark/shark/-application-leak/leak-trace.md b/docs/api/shark/shark/-application-leak/leak-trace.md
new file mode 100644
index 00000000..26dc4aa5
--- /dev/null
+++ b/docs/api/shark/shark/-application-leak/leak-trace.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [ApplicationLeak](index.md) / [leakTrace](./leak-trace.md)
+
+# leakTrace
+
+`val leakTrace: `[`LeakTrace`](../-leak-trace/index.md)
+
+Overrides [Leak.leakTrace](../-leak/leak-trace.md)
+
+Shortest path from GC roots to the leaking object.
+
diff --git a/docs/api/shark/shark/-application-leak/retained-heap-byte-size.md b/docs/api/shark/shark/-application-leak/retained-heap-byte-size.md
new file mode 100644
index 00000000..caa36392
--- /dev/null
+++ b/docs/api/shark/shark/-application-leak/retained-heap-byte-size.md
@@ -0,0 +1,11 @@
+[shark](../../index.md) / [shark](../index.md) / [ApplicationLeak](index.md) / [retainedHeapByteSize](./retained-heap-byte-size.md)
+
+# retainedHeapByteSize
+
+`val retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?`
+
+Overrides [Leak.retainedHeapByteSize](../-leak/retained-heap-byte-size.md)
+
+The number of bytes which would be freed if all references to the leaking object were
+released. Null if the retained heap size was not computed.
+
diff --git a/docs/api/shark/shark/-heap-analysis-exception/-init-.md b/docs/api/shark/shark/-heap-analysis-exception/-init-.md
new file mode 100644
index 00000000..1f0d38ff
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-exception/-init-.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisException](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HeapAnalysisException(cause: `[`Throwable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-heap-analysis-exception/index.md b/docs/api/shark/shark/-heap-analysis-exception/index.md
new file mode 100644
index 00000000..ec64d5b0
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-exception/index.md
@@ -0,0 +1,17 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisException](./index.md)
+
+# HeapAnalysisException
+
+`class HeapAnalysisException : `[`RuntimeException`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-runtime-exception/index.html)
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HeapAnalysisException(cause: `[`Throwable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html)`)` |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark/shark/-heap-analysis-exception/to-string.md b/docs/api/shark/shark/-heap-analysis-exception/to-string.md
new file mode 100644
index 00000000..9ad40469
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-exception/to-string.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisException](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-heap-analysis-failure/-init-.md b/docs/api/shark/shark/-heap-analysis-failure/-init-.md
new file mode 100644
index 00000000..759cb4d7
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-failure/-init-.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisFailure](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HeapAnalysisFailure(heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, exception: `[`HeapAnalysisException`](../-heap-analysis-exception/index.md)`)`
+
+The analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md) did not complete successfully.
+
diff --git a/docs/api/shark/shark/-heap-analysis-failure/analysis-duration-millis.md b/docs/api/shark/shark/-heap-analysis-failure/analysis-duration-millis.md
new file mode 100644
index 00000000..5ed5cbf7
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-failure/analysis-duration-millis.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisFailure](index.md) / [analysisDurationMillis](./analysis-duration-millis.md)
+
+# analysisDurationMillis
+
+`val analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [HeapAnalysis.analysisDurationMillis](../-heap-analysis/analysis-duration-millis.md)
+
+Total time spent analyzing the heap.
+
diff --git a/docs/api/shark/shark/-heap-analysis-failure/created-at-time-millis.md b/docs/api/shark/shark/-heap-analysis-failure/created-at-time-millis.md
new file mode 100644
index 00000000..cb523d89
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-failure/created-at-time-millis.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisFailure](index.md) / [createdAtTimeMillis](./created-at-time-millis.md)
+
+# createdAtTimeMillis
+
+`val createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [HeapAnalysis.createdAtTimeMillis](../-heap-analysis/created-at-time-millis.md)
+
+The [System.currentTimeMillis](https://docs.oracle.com/javase/6/docs/api/java/lang/System.html#currentTimeMillis()) when this [HeapAnalysis](../-heap-analysis/index.md) instance was created.
+
diff --git a/docs/api/shark/shark/-heap-analysis-failure/exception.md b/docs/api/shark/shark/-heap-analysis-failure/exception.md
new file mode 100644
index 00000000..91d72dd9
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-failure/exception.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisFailure](index.md) / [exception](./exception.md)
+
+# exception
+
+`val exception: `[`HeapAnalysisException`](../-heap-analysis-exception/index.md)
+
+An exception wrapping the actual exception that was thrown.
+
diff --git a/docs/api/shark/shark/-heap-analysis-failure/heap-dump-file.md b/docs/api/shark/shark/-heap-analysis-failure/heap-dump-file.md
new file mode 100644
index 00000000..d722daf2
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-failure/heap-dump-file.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisFailure](index.md) / [heapDumpFile](./heap-dump-file.md)
+
+# heapDumpFile
+
+`val heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)
+
+Overrides [HeapAnalysis.heapDumpFile](../-heap-analysis/heap-dump-file.md)
+
+The hprof file that was analyzed.
+
diff --git a/docs/api/shark/shark/-heap-analysis-failure/index.md b/docs/api/shark/shark/-heap-analysis-failure/index.md
new file mode 100644
index 00000000..e22b3d5f
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-failure/index.md
@@ -0,0 +1,22 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisFailure](./index.md)
+
+# HeapAnalysisFailure
+
+`data class HeapAnalysisFailure : `[`HeapAnalysis`](../-heap-analysis/index.md)
+
+The analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md) did not complete successfully.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HeapAnalysisFailure(heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, exception: `[`HeapAnalysisException`](../-heap-analysis-exception/index.md)`)`<br>The analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md) did not complete successfully. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [analysisDurationMillis](analysis-duration-millis.md) | `val analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Total time spent analyzing the heap. |
+| [createdAtTimeMillis](created-at-time-millis.md) | `val createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The [System.currentTimeMillis](https://docs.oracle.com/javase/6/docs/api/java/lang/System.html#currentTimeMillis()) when this [HeapAnalysis](../-heap-analysis/index.md) instance was created. |
+| [exception](exception.md) | `val exception: `[`HeapAnalysisException`](../-heap-analysis-exception/index.md)<br>An exception wrapping the actual exception that was thrown. |
+| [heapDumpFile](heap-dump-file.md) | `val heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)<br>The hprof file that was analyzed. |
diff --git a/docs/api/shark/shark/-heap-analysis-success/-init-.md b/docs/api/shark/shark/-heap-analysis-success/-init-.md
new file mode 100644
index 00000000..4de43e93
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-success/-init-.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisSuccess](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HeapAnalysisSuccess(heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, applicationLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ApplicationLeak`](../-application-leak/index.md)`>, libraryLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LibraryLeak`](../-library-leak/index.md)`>)`
+
+The result of a successful heap analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md).
+
diff --git a/docs/api/shark/shark/-heap-analysis-success/all-leaks.md b/docs/api/shark/shark/-heap-analysis-success/all-leaks.md
new file mode 100644
index 00000000..3b8e7ff0
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-success/all-leaks.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisSuccess](index.md) / [allLeaks](./all-leaks.md)
+
+# allLeaks
+
+`val allLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`Leak`](../-leak/index.md)`>`
+
+The list of [Leak](../-leak/index.md) found in the heap dump by [HeapAnalyzer](../-heap-analyzer/index.md), ie all [applicationLeaks](application-leaks.md) and
+all [libraryLeaks](library-leaks.md) in one list.
+
diff --git a/docs/api/shark/shark/-heap-analysis-success/analysis-duration-millis.md b/docs/api/shark/shark/-heap-analysis-success/analysis-duration-millis.md
new file mode 100644
index 00000000..0ca62574
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-success/analysis-duration-millis.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisSuccess](index.md) / [analysisDurationMillis](./analysis-duration-millis.md)
+
+# analysisDurationMillis
+
+`val analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [HeapAnalysis.analysisDurationMillis](../-heap-analysis/analysis-duration-millis.md)
+
+Total time spent analyzing the heap.
+
diff --git a/docs/api/shark/shark/-heap-analysis-success/application-leaks.md b/docs/api/shark/shark/-heap-analysis-success/application-leaks.md
new file mode 100644
index 00000000..855eeb50
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-success/application-leaks.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisSuccess](index.md) / [applicationLeaks](./application-leaks.md)
+
+# applicationLeaks
+
+`val applicationLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ApplicationLeak`](../-application-leak/index.md)`>`
+
+The list of [ApplicationLeak](../-application-leak/index.md) found in the heap dump by [HeapAnalyzer](../-heap-analyzer/index.md).
+
diff --git a/docs/api/shark/shark/-heap-analysis-success/created-at-time-millis.md b/docs/api/shark/shark/-heap-analysis-success/created-at-time-millis.md
new file mode 100644
index 00000000..c34fa494
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-success/created-at-time-millis.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisSuccess](index.md) / [createdAtTimeMillis](./created-at-time-millis.md)
+
+# createdAtTimeMillis
+
+`val createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Overrides [HeapAnalysis.createdAtTimeMillis](../-heap-analysis/created-at-time-millis.md)
+
+The [System.currentTimeMillis](https://docs.oracle.com/javase/6/docs/api/java/lang/System.html#currentTimeMillis()) when this [HeapAnalysis](../-heap-analysis/index.md) instance was created.
+
diff --git a/docs/api/shark/shark/-heap-analysis-success/heap-dump-file.md b/docs/api/shark/shark/-heap-analysis-success/heap-dump-file.md
new file mode 100644
index 00000000..a7cf7b6f
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-success/heap-dump-file.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisSuccess](index.md) / [heapDumpFile](./heap-dump-file.md)
+
+# heapDumpFile
+
+`val heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)
+
+Overrides [HeapAnalysis.heapDumpFile](../-heap-analysis/heap-dump-file.md)
+
+The hprof file that was analyzed.
+
diff --git a/docs/api/shark/shark/-heap-analysis-success/index.md b/docs/api/shark/shark/-heap-analysis-success/index.md
new file mode 100644
index 00000000..d8a2f0ca
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-success/index.md
@@ -0,0 +1,24 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisSuccess](./index.md)
+
+# HeapAnalysisSuccess
+
+`data class HeapAnalysisSuccess : `[`HeapAnalysis`](../-heap-analysis/index.md)
+
+The result of a successful heap analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md).
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HeapAnalysisSuccess(heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, applicationLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ApplicationLeak`](../-application-leak/index.md)`>, libraryLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LibraryLeak`](../-library-leak/index.md)`>)`<br>The result of a successful heap analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [allLeaks](all-leaks.md) | `val allLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`Leak`](../-leak/index.md)`>`<br>The list of [Leak](../-leak/index.md) found in the heap dump by [HeapAnalyzer](../-heap-analyzer/index.md), ie all [applicationLeaks](application-leaks.md) and all [libraryLeaks](library-leaks.md) in one list. |
+| [analysisDurationMillis](analysis-duration-millis.md) | `val analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Total time spent analyzing the heap. |
+| [applicationLeaks](application-leaks.md) | `val applicationLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ApplicationLeak`](../-application-leak/index.md)`>`<br>The list of [ApplicationLeak](../-application-leak/index.md) found in the heap dump by [HeapAnalyzer](../-heap-analyzer/index.md). |
+| [createdAtTimeMillis](created-at-time-millis.md) | `val createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The [System.currentTimeMillis](https://docs.oracle.com/javase/6/docs/api/java/lang/System.html#currentTimeMillis()) when this [HeapAnalysis](../-heap-analysis/index.md) instance was created. |
+| [heapDumpFile](heap-dump-file.md) | `val heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)<br>The hprof file that was analyzed. |
+| [libraryLeaks](library-leaks.md) | `val libraryLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LibraryLeak`](../-library-leak/index.md)`>`<br>The list of [LibraryLeak](../-library-leak/index.md) found in the heap dump by [HeapAnalyzer](../-heap-analyzer/index.md). |
diff --git a/docs/api/shark/shark/-heap-analysis-success/library-leaks.md b/docs/api/shark/shark/-heap-analysis-success/library-leaks.md
new file mode 100644
index 00000000..f45afe3e
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis-success/library-leaks.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysisSuccess](index.md) / [libraryLeaks](./library-leaks.md)
+
+# libraryLeaks
+
+`val libraryLeaks: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LibraryLeak`](../-library-leak/index.md)`>`
+
+The list of [LibraryLeak](../-library-leak/index.md) found in the heap dump by [HeapAnalyzer](../-heap-analyzer/index.md).
+
diff --git a/docs/api/shark/shark/-heap-analysis/analysis-duration-millis.md b/docs/api/shark/shark/-heap-analysis/analysis-duration-millis.md
new file mode 100644
index 00000000..1e2869a8
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis/analysis-duration-millis.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysis](index.md) / [analysisDurationMillis](./analysis-duration-millis.md)
+
+# analysisDurationMillis
+
+`abstract val analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Total time spent analyzing the heap.
+
diff --git a/docs/api/shark/shark/-heap-analysis/created-at-time-millis.md b/docs/api/shark/shark/-heap-analysis/created-at-time-millis.md
new file mode 100644
index 00000000..2e5f95dc
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis/created-at-time-millis.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysis](index.md) / [createdAtTimeMillis](./created-at-time-millis.md)
+
+# createdAtTimeMillis
+
+`abstract val createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+The [System.currentTimeMillis](https://docs.oracle.com/javase/6/docs/api/java/lang/System.html#currentTimeMillis()) when this [HeapAnalysis](index.md) instance was created.
+
diff --git a/docs/api/shark/shark/-heap-analysis/heap-dump-file.md b/docs/api/shark/shark/-heap-analysis/heap-dump-file.md
new file mode 100644
index 00000000..4256d764
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis/heap-dump-file.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysis](index.md) / [heapDumpFile](./heap-dump-file.md)
+
+# heapDumpFile
+
+`abstract val heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)
+
+The hprof file that was analyzed.
+
diff --git a/docs/api/shark/shark/-heap-analysis/index.md b/docs/api/shark/shark/-heap-analysis/index.md
new file mode 100644
index 00000000..724f6414
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analysis/index.md
@@ -0,0 +1,24 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalysis](./index.md)
+
+# HeapAnalysis
+
+`sealed class HeapAnalysis : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)
+
+The result of an analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md), either a [HeapAnalysisSuccess](../-heap-analysis-success/index.md) or a
+[HeapAnalysisFailure](../-heap-analysis-failure/index.md). This class is serializable however there are no guarantees of forward
+compatibility.
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [analysisDurationMillis](analysis-duration-millis.md) | `abstract val analysisDurationMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Total time spent analyzing the heap. |
+| [createdAtTimeMillis](created-at-time-millis.md) | `abstract val createdAtTimeMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The [System.currentTimeMillis](https://docs.oracle.com/javase/6/docs/api/java/lang/System.html#currentTimeMillis()) when this [HeapAnalysis](./index.md) instance was created. |
+| [heapDumpFile](heap-dump-file.md) | `abstract val heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)<br>The hprof file that was analyzed. |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [HeapAnalysisFailure](../-heap-analysis-failure/index.md) | `data class HeapAnalysisFailure : `[`HeapAnalysis`](./index.md)<br>The analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md) did not complete successfully. |
+| [HeapAnalysisSuccess](../-heap-analysis-success/index.md) | `data class HeapAnalysisSuccess : `[`HeapAnalysis`](./index.md)<br>The result of a successful heap analysis performed by [HeapAnalyzer](../-heap-analyzer/index.md). |
diff --git a/docs/api/shark/shark/-heap-analyzer/-init-.md b/docs/api/shark/shark/-heap-analyzer/-init-.md
new file mode 100644
index 00000000..4a9f400e
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analyzer/-init-.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalyzer](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`HeapAnalyzer(listener: `[`OnAnalysisProgressListener`](../-on-analysis-progress-listener/index.md)`)`
+
+Analyzes heap dumps to look for leaks.
+
diff --git a/docs/api/shark/shark/-heap-analyzer/analyze.md b/docs/api/shark/shark/-heap-analyzer/analyze.md
new file mode 100644
index 00000000..5846ae9f
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analyzer/analyze.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalyzer](index.md) / [analyze](./analyze.md)
+
+# analyze
+
+`fun analyze(heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, referenceMatchers: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ReferenceMatcher`](../-reference-matcher/index.md)`> = emptyList(), computeRetainedHeapSize: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = false, objectInspectors: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ObjectInspector`](../-object-inspector/index.md)`> = emptyList(), leakFinders: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ObjectInspector`](../-object-inspector/index.md)`> = objectInspectors): `[`HeapAnalysis`](../-heap-analysis/index.md)
+
+Searches the heap dump for leaking instances and then computes the shortest strong reference
+path from those instances to the GC roots.
+
diff --git a/docs/api/shark/shark/-heap-analyzer/index.md b/docs/api/shark/shark/-heap-analyzer/index.md
new file mode 100644
index 00000000..98b084b2
--- /dev/null
+++ b/docs/api/shark/shark/-heap-analyzer/index.md
@@ -0,0 +1,19 @@
+[shark](../../index.md) / [shark](../index.md) / [HeapAnalyzer](./index.md)
+
+# HeapAnalyzer
+
+`class HeapAnalyzer`
+
+Analyzes heap dumps to look for leaks.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `HeapAnalyzer(listener: `[`OnAnalysisProgressListener`](../-on-analysis-progress-listener/index.md)`)`<br>Analyzes heap dumps to look for leaks. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [analyze](analyze.md) | `fun analyze(heapDumpFile: `[`File`](https://docs.oracle.com/javase/6/docs/api/java/io/File.html)`, referenceMatchers: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ReferenceMatcher`](../-reference-matcher/index.md)`> = emptyList(), computeRetainedHeapSize: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = false, objectInspectors: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ObjectInspector`](../-object-inspector/index.md)`> = emptyList(), leakFinders: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ObjectInspector`](../-object-inspector/index.md)`> = objectInspectors): `[`HeapAnalysis`](../-heap-analysis/index.md)<br>Searches the heap dump for leaking instances and then computes the shortest strong reference path from those instances to the GC roots. |
diff --git a/docs/api/shark/shark/-ignored-reference-matcher/-init-.md b/docs/api/shark/shark/-ignored-reference-matcher/-init-.md
new file mode 100644
index 00000000..636a436e
--- /dev/null
+++ b/docs/api/shark/shark/-ignored-reference-matcher/-init-.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [IgnoredReferenceMatcher](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`IgnoredReferenceMatcher(pattern: `[`ReferencePattern`](../-reference-pattern/index.md)`)`
+
+[IgnoredReferenceMatcher](index.md) should be used to match references that cannot ever create leaks. The
+shortest path finder will never go through matching references.
+
diff --git a/docs/api/shark/shark/-ignored-reference-matcher/index.md b/docs/api/shark/shark/-ignored-reference-matcher/index.md
new file mode 100644
index 00000000..61462590
--- /dev/null
+++ b/docs/api/shark/shark/-ignored-reference-matcher/index.md
@@ -0,0 +1,20 @@
+[shark](../../index.md) / [shark](../index.md) / [IgnoredReferenceMatcher](./index.md)
+
+# IgnoredReferenceMatcher
+
+`class IgnoredReferenceMatcher : `[`ReferenceMatcher`](../-reference-matcher/index.md)
+
+[IgnoredReferenceMatcher](./index.md) should be used to match references that cannot ever create leaks. The
+shortest path finder will never go through matching references.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `IgnoredReferenceMatcher(pattern: `[`ReferencePattern`](../-reference-pattern/index.md)`)`<br>[IgnoredReferenceMatcher](./index.md) should be used to match references that cannot ever create leaks. The shortest path finder will never go through matching references. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [pattern](pattern.md) | `val pattern: `[`ReferencePattern`](../-reference-pattern/index.md)<br>The pattern that references will be matched against. |
diff --git a/docs/api/shark/shark/-ignored-reference-matcher/pattern.md b/docs/api/shark/shark/-ignored-reference-matcher/pattern.md
new file mode 100644
index 00000000..e06e79a4
--- /dev/null
+++ b/docs/api/shark/shark/-ignored-reference-matcher/pattern.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [IgnoredReferenceMatcher](index.md) / [pattern](./pattern.md)
+
+# pattern
+
+`val pattern: `[`ReferencePattern`](../-reference-pattern/index.md)
+
+Overrides [ReferenceMatcher.pattern](../-reference-matcher/pattern.md)
+
+The pattern that references will be matched against.
+
diff --git a/docs/api/shark/shark/-leak-node-status/-l-e-a-k-i-n-g.md b/docs/api/shark/shark/-leak-node-status/-l-e-a-k-i-n-g.md
new file mode 100644
index 00000000..78470f7c
--- /dev/null
+++ b/docs/api/shark/shark/-leak-node-status/-l-e-a-k-i-n-g.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakNodeStatus](index.md) / [LEAKING](./-l-e-a-k-i-n-g.md)
+
+# LEAKING
+
+`LEAKING`
+
+The instance was no longer needed and therefore expected to be unreachable.
+
diff --git a/docs/api/shark/shark/-leak-node-status/-n-o-t_-l-e-a-k-i-n-g.md b/docs/api/shark/shark/-leak-node-status/-n-o-t_-l-e-a-k-i-n-g.md
new file mode 100644
index 00000000..4e1e91b5
--- /dev/null
+++ b/docs/api/shark/shark/-leak-node-status/-n-o-t_-l-e-a-k-i-n-g.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakNodeStatus](index.md) / [NOT_LEAKING](./-n-o-t_-l-e-a-k-i-n-g.md)
+
+# NOT_LEAKING
+
+`NOT_LEAKING`
+
+The instance was needed and therefore expected to be reachable.
+
diff --git a/docs/api/shark/shark/-leak-node-status/-u-n-k-n-o-w-n.md b/docs/api/shark/shark/-leak-node-status/-u-n-k-n-o-w-n.md
new file mode 100644
index 00000000..1f16396c
--- /dev/null
+++ b/docs/api/shark/shark/-leak-node-status/-u-n-k-n-o-w-n.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakNodeStatus](index.md) / [UNKNOWN](./-u-n-k-n-o-w-n.md)
+
+# UNKNOWN
+
+`UNKNOWN`
+
+No decision can be made about the provided instance.
+
diff --git a/docs/api/shark/shark/-leak-node-status/index.md b/docs/api/shark/shark/-leak-node-status/index.md
new file mode 100644
index 00000000..e485f803
--- /dev/null
+++ b/docs/api/shark/shark/-leak-node-status/index.md
@@ -0,0 +1,13 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakNodeStatus](./index.md)
+
+# LeakNodeStatus
+
+`enum class LeakNodeStatus`
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [NOT_LEAKING](-n-o-t_-l-e-a-k-i-n-g.md) | The instance was needed and therefore expected to be reachable. |
+| [LEAKING](-l-e-a-k-i-n-g.md) | The instance was no longer needed and therefore expected to be unreachable. |
+| [UNKNOWN](-u-n-k-n-o-w-n.md) | No decision can be made about the provided instance. |
diff --git a/docs/api/shark/shark/-leak-reference/-init-.md b/docs/api/shark/shark/-leak-reference/-init-.md
new file mode 100644
index 00000000..e9d837c3
--- /dev/null
+++ b/docs/api/shark/shark/-leak-reference/-init-.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakReference](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`LeakReference(type: `[`LeakTraceElement.Type`](../-leak-trace-element/-type/index.md)`, name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`
+
+A single field in a [LeakTraceElement](../-leak-trace-element/index.md).
+
diff --git a/docs/api/shark/shark/-leak-reference/display-name.md b/docs/api/shark/shark/-leak-reference/display-name.md
new file mode 100644
index 00000000..1d3b0394
--- /dev/null
+++ b/docs/api/shark/shark/-leak-reference/display-name.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakReference](index.md) / [displayName](./display-name.md)
+
+# displayName
+
+`val displayName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-reference/grouping-name.md b/docs/api/shark/shark/-leak-reference/grouping-name.md
new file mode 100644
index 00000000..7e3fa47b
--- /dev/null
+++ b/docs/api/shark/shark/-leak-reference/grouping-name.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakReference](index.md) / [groupingName](./grouping-name.md)
+
+# groupingName
+
+`val groupingName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-reference/index.md b/docs/api/shark/shark/-leak-reference/index.md
new file mode 100644
index 00000000..56ff917c
--- /dev/null
+++ b/docs/api/shark/shark/-leak-reference/index.md
@@ -0,0 +1,22 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakReference](./index.md)
+
+# LeakReference
+
+`data class LeakReference : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)
+
+A single field in a [LeakTraceElement](../-leak-trace-element/index.md).
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `LeakReference(type: `[`LeakTraceElement.Type`](../-leak-trace-element/-type/index.md)`, name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`<br>A single field in a [LeakTraceElement](../-leak-trace-element/index.md). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [displayName](display-name.md) | `val displayName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [groupingName](grouping-name.md) | `val groupingName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [name](name.md) | `val name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [type](type.md) | `val type: `[`LeakTraceElement.Type`](../-leak-trace-element/-type/index.md) |
diff --git a/docs/api/shark/shark/-leak-reference/name.md b/docs/api/shark/shark/-leak-reference/name.md
new file mode 100644
index 00000000..3f89aaae
--- /dev/null
+++ b/docs/api/shark/shark/-leak-reference/name.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakReference](index.md) / [name](./name.md)
+
+# name
+
+`val name: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-reference/type.md b/docs/api/shark/shark/-leak-reference/type.md
new file mode 100644
index 00000000..d2555da6
--- /dev/null
+++ b/docs/api/shark/shark/-leak-reference/type.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakReference](index.md) / [type](./type.md)
+
+# type
+
+`val type: `[`LeakTraceElement.Type`](../-leak-trace-element/-type/index.md)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-holder/-a-r-r-a-y.md b/docs/api/shark/shark/-leak-trace-element/-holder/-a-r-r-a-y.md
new file mode 100644
index 00000000..47040199
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-holder/-a-r-r-a-y.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Holder](index.md) / [ARRAY](./-a-r-r-a-y.md)
+
+# ARRAY
+
+`ARRAY`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-holder/-c-l-a-s-s.md b/docs/api/shark/shark/-leak-trace-element/-holder/-c-l-a-s-s.md
new file mode 100644
index 00000000..bf63d78e
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-holder/-c-l-a-s-s.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Holder](index.md) / [CLASS](./-c-l-a-s-s.md)
+
+# CLASS
+
+`CLASS`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-holder/-o-b-j-e-c-t.md b/docs/api/shark/shark/-leak-trace-element/-holder/-o-b-j-e-c-t.md
new file mode 100644
index 00000000..54723485
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-holder/-o-b-j-e-c-t.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Holder](index.md) / [OBJECT](./-o-b-j-e-c-t.md)
+
+# OBJECT
+
+`OBJECT`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-holder/-t-h-r-e-a-d.md b/docs/api/shark/shark/-leak-trace-element/-holder/-t-h-r-e-a-d.md
new file mode 100644
index 00000000..c2706cdd
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-holder/-t-h-r-e-a-d.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Holder](index.md) / [THREAD](./-t-h-r-e-a-d.md)
+
+# THREAD
+
+`THREAD`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-holder/index.md b/docs/api/shark/shark/-leak-trace-element/-holder/index.md
new file mode 100644
index 00000000..85845b36
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-holder/index.md
@@ -0,0 +1,14 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Holder](./index.md)
+
+# Holder
+
+`enum class Holder`
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [OBJECT](-o-b-j-e-c-t.md) |  |
+| [CLASS](-c-l-a-s-s.md) |  |
+| [THREAD](-t-h-r-e-a-d.md) |  |
+| [ARRAY](-a-r-r-a-y.md) |  |
diff --git a/docs/api/shark/shark/-leak-trace-element/-init-.md b/docs/api/shark/shark/-leak-trace-element/-init-.md
new file mode 100644
index 00000000..b0bdcaa0
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-init-.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`LeakTraceElement(reference: `[`LeakReference`](../-leak-reference/index.md)`?, holder: `[`LeakTraceElement.Holder`](-holder/index.md)`, className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, labels: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>, leakStatus: `[`LeakNodeStatus`](../-leak-node-status/index.md)`, leakStatusReason: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-type/-a-r-r-a-y_-e-n-t-r-y.md b/docs/api/shark/shark/-leak-trace-element/-type/-a-r-r-a-y_-e-n-t-r-y.md
new file mode 100644
index 00000000..e5bbaea2
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-type/-a-r-r-a-y_-e-n-t-r-y.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Type](index.md) / [ARRAY_ENTRY](./-a-r-r-a-y_-e-n-t-r-y.md)
+
+# ARRAY_ENTRY
+
+`ARRAY_ENTRY`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-type/-i-n-s-t-a-n-c-e_-f-i-e-l-d.md b/docs/api/shark/shark/-leak-trace-element/-type/-i-n-s-t-a-n-c-e_-f-i-e-l-d.md
new file mode 100644
index 00000000..ad415fbd
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-type/-i-n-s-t-a-n-c-e_-f-i-e-l-d.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Type](index.md) / [INSTANCE_FIELD](./-i-n-s-t-a-n-c-e_-f-i-e-l-d.md)
+
+# INSTANCE_FIELD
+
+`INSTANCE_FIELD`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-type/-l-o-c-a-l.md b/docs/api/shark/shark/-leak-trace-element/-type/-l-o-c-a-l.md
new file mode 100644
index 00000000..2699b95f
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-type/-l-o-c-a-l.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Type](index.md) / [LOCAL](./-l-o-c-a-l.md)
+
+# LOCAL
+
+`LOCAL`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-type/-s-t-a-t-i-c_-f-i-e-l-d.md b/docs/api/shark/shark/-leak-trace-element/-type/-s-t-a-t-i-c_-f-i-e-l-d.md
new file mode 100644
index 00000000..2d773adf
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-type/-s-t-a-t-i-c_-f-i-e-l-d.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Type](index.md) / [STATIC_FIELD](./-s-t-a-t-i-c_-f-i-e-l-d.md)
+
+# STATIC_FIELD
+
+`STATIC_FIELD`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/-type/index.md b/docs/api/shark/shark/-leak-trace-element/-type/index.md
new file mode 100644
index 00000000..d888c67c
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/-type/index.md
@@ -0,0 +1,14 @@
+[shark](../../../index.md) / [shark](../../index.md) / [LeakTraceElement](../index.md) / [Type](./index.md)
+
+# Type
+
+`enum class Type`
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [INSTANCE_FIELD](-i-n-s-t-a-n-c-e_-f-i-e-l-d.md) |  |
+| [STATIC_FIELD](-s-t-a-t-i-c_-f-i-e-l-d.md) |  |
+| [LOCAL](-l-o-c-a-l.md) |  |
+| [ARRAY_ENTRY](-a-r-r-a-y_-e-n-t-r-y.md) |  |
diff --git a/docs/api/shark/shark/-leak-trace-element/class-name.md b/docs/api/shark/shark/-leak-trace-element/class-name.md
new file mode 100644
index 00000000..6be6d721
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/class-name.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](index.md) / [className](./class-name.md)
+
+# className
+
+`val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/class-simple-name.md b/docs/api/shark/shark/-leak-trace-element/class-simple-name.md
new file mode 100644
index 00000000..608e49b3
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/class-simple-name.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](index.md) / [classSimpleName](./class-simple-name.md)
+
+# classSimpleName
+
+`val classSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Returns {@link #className} without the package.
+
diff --git a/docs/api/shark/shark/-leak-trace-element/holder.md b/docs/api/shark/shark/-leak-trace-element/holder.md
new file mode 100644
index 00000000..51cef257
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/holder.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](index.md) / [holder](./holder.md)
+
+# holder
+
+`val holder: `[`LeakTraceElement.Holder`](-holder/index.md)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/index.md b/docs/api/shark/shark/-leak-trace-element/index.md
new file mode 100644
index 00000000..6ef89d9e
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/index.md
@@ -0,0 +1,30 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](./index.md)
+
+# LeakTraceElement
+
+`data class LeakTraceElement : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Holder](-holder/index.md) | `enum class Holder` |
+| [Type](-type/index.md) | `enum class Type` |
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `LeakTraceElement(reference: `[`LeakReference`](../-leak-reference/index.md)`?, holder: `[`LeakTraceElement.Holder`](-holder/index.md)`, className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, labels: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>, leakStatus: `[`LeakNodeStatus`](../-leak-node-status/index.md)`, leakStatusReason: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)` |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [className](class-name.md) | `val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [classSimpleName](class-simple-name.md) | `val classSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Returns {@link #className} without the package. |
+| [holder](holder.md) | `val holder: `[`LeakTraceElement.Holder`](-holder/index.md) |
+| [labels](labels.md) | `val labels: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`<br>Labels that were computed during analysis. A label provides extra information that helps understand the leak trace element. |
+| [leakStatus](leak-status.md) | `val leakStatus: `[`LeakNodeStatus`](../-leak-node-status/index.md) |
+| [leakStatusReason](leak-status-reason.md) | `val leakStatusReason: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [reference](reference.md) | `val reference: `[`LeakReference`](../-leak-reference/index.md)`?`<br>Information about the reference that points to the next [LeakTraceElement](./index.md) in [LeakTrace.elements](../-leak-trace/elements.md). Null if this is the last element in the leak trace, ie the leaking object. |
diff --git a/docs/api/shark/shark/-leak-trace-element/labels.md b/docs/api/shark/shark/-leak-trace-element/labels.md
new file mode 100644
index 00000000..00fdcd44
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/labels.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](index.md) / [labels](./labels.md)
+
+# labels
+
+`val labels: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`
+
+Labels that were computed during analysis. A label provides extra information that helps
+understand the leak trace element.
+
diff --git a/docs/api/shark/shark/-leak-trace-element/leak-status-reason.md b/docs/api/shark/shark/-leak-trace-element/leak-status-reason.md
new file mode 100644
index 00000000..862d304e
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/leak-status-reason.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](index.md) / [leakStatusReason](./leak-status-reason.md)
+
+# leakStatusReason
+
+`val leakStatusReason: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/leak-status.md b/docs/api/shark/shark/-leak-trace-element/leak-status.md
new file mode 100644
index 00000000..92a110ea
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/leak-status.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](index.md) / [leakStatus](./leak-status.md)
+
+# leakStatus
+
+`val leakStatus: `[`LeakNodeStatus`](../-leak-node-status/index.md)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace-element/reference.md b/docs/api/shark/shark/-leak-trace-element/reference.md
new file mode 100644
index 00000000..cd6973e7
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace-element/reference.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTraceElement](index.md) / [reference](./reference.md)
+
+# reference
+
+`val reference: `[`LeakReference`](../-leak-reference/index.md)`?`
+
+Information about the reference that points to the next [LeakTraceElement](index.md) in
+[LeakTrace.elements](../-leak-trace/elements.md). Null if this is the last element in the leak trace, ie the leaking
+object.
+
diff --git a/docs/api/shark/shark/-leak-trace/-init-.md b/docs/api/shark/shark/-leak-trace/-init-.md
new file mode 100644
index 00000000..6dbe2091
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace/-init-.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTrace](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`LeakTrace(elements: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LeakTraceElement`](../-leak-trace-element/index.md)`>)`
+
+A chain of references that constitute the shortest strong reference path from a GC root to the
+leaking object. Fixing the leak usually means breaking one of the references in that chain.
+
diff --git a/docs/api/shark/shark/-leak-trace/element-may-be-leak-cause.md b/docs/api/shark/shark/-leak-trace/element-may-be-leak-cause.md
new file mode 100644
index 00000000..36fb3527
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace/element-may-be-leak-cause.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTrace](index.md) / [elementMayBeLeakCause](./element-may-be-leak-cause.md)
+
+# elementMayBeLeakCause
+
+`fun elementMayBeLeakCause(index: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace/elements.md b/docs/api/shark/shark/-leak-trace/elements.md
new file mode 100644
index 00000000..fc287bd3
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace/elements.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTrace](index.md) / [elements](./elements.md)
+
+# elements
+
+`val elements: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LeakTraceElement`](../-leak-trace-element/index.md)`>`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace/index.md b/docs/api/shark/shark/-leak-trace/index.md
new file mode 100644
index 00000000..c7d58df2
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace/index.md
@@ -0,0 +1,28 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTrace](./index.md)
+
+# LeakTrace
+
+`data class LeakTrace : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)
+
+A chain of references that constitute the shortest strong reference path from a GC root to the
+leaking object. Fixing the leak usually means breaking one of the references in that chain.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `LeakTrace(elements: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LeakTraceElement`](../-leak-trace-element/index.md)`>)`<br>A chain of references that constitute the shortest strong reference path from a GC root to the leaking object. Fixing the leak usually means breaking one of the references in that chain. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [elements](elements.md) | `val elements: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LeakTraceElement`](../-leak-trace-element/index.md)`>` |
+| [leakCauses](leak-causes.md) | `val leakCauses: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LeakTraceElement`](../-leak-trace-element/index.md)`>` |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [elementMayBeLeakCause](element-may-be-leak-cause.md) | `fun elementMayBeLeakCause(index: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark/shark/-leak-trace/leak-causes.md b/docs/api/shark/shark/-leak-trace/leak-causes.md
new file mode 100644
index 00000000..33569b8a
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace/leak-causes.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTrace](index.md) / [leakCauses](./leak-causes.md)
+
+# leakCauses
+
+`val leakCauses: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`LeakTraceElement`](../-leak-trace-element/index.md)`>`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak-trace/to-string.md b/docs/api/shark/shark/-leak-trace/to-string.md
new file mode 100644
index 00000000..505b6fb7
--- /dev/null
+++ b/docs/api/shark/shark/-leak-trace/to-string.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [LeakTrace](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak/class-name.md b/docs/api/shark/shark/-leak/class-name.md
new file mode 100644
index 00000000..8b40e2b3
--- /dev/null
+++ b/docs/api/shark/shark/-leak/class-name.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [Leak](index.md) / [className](./class-name.md)
+
+# className
+
+`abstract val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Class name of the leaking object.
+The class name format is the same as what would be returned by [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()).
+
diff --git a/docs/api/shark/shark/-leak/class-simple-name.md b/docs/api/shark/shark/-leak/class-simple-name.md
new file mode 100644
index 00000000..717f776d
--- /dev/null
+++ b/docs/api/shark/shark/-leak/class-simple-name.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [Leak](index.md) / [classSimpleName](./class-simple-name.md)
+
+# classSimpleName
+
+`val classSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Returns [className](class-name.md) stripped of any string content before the last period (included).
+
diff --git a/docs/api/shark/shark/-leak/create-group-hash.md b/docs/api/shark/shark/-leak/create-group-hash.md
new file mode 100644
index 00000000..324616ce
--- /dev/null
+++ b/docs/api/shark/shark/-leak/create-group-hash.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [Leak](index.md) / [createGroupHash](./create-group-hash.md)
+
+# createGroupHash
+
+`protected abstract fun createGroupHash(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-leak/group-hash.md b/docs/api/shark/shark/-leak/group-hash.md
new file mode 100644
index 00000000..1cf68acc
--- /dev/null
+++ b/docs/api/shark/shark/-leak/group-hash.md
@@ -0,0 +1,11 @@
+[shark](../../index.md) / [shark](../index.md) / [Leak](index.md) / [groupHash](./group-hash.md)
+
+# groupHash
+
+`val groupHash: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+A unique SHA1 hash that represents this group of leaks.
+
+For [ApplicationLeak](../-application-leak/index.md) this is based on [LeakTrace.leakCauses](../-leak-trace/leak-causes.md) and for [LibraryLeak](../-library-leak/index.md) this is
+based on [LibraryLeak.pattern](../-library-leak/pattern.md).
+
diff --git a/docs/api/shark/shark/-leak/index.md b/docs/api/shark/shark/-leak/index.md
new file mode 100644
index 00000000..c521d4ea
--- /dev/null
+++ b/docs/api/shark/shark/-leak/index.md
@@ -0,0 +1,30 @@
+[shark](../../index.md) / [shark](../index.md) / [Leak](./index.md)
+
+# Leak
+
+`sealed class Leak : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)
+
+A leak found by [HeapAnalyzer](../-heap-analyzer/index.md), either an [ApplicationLeak](../-application-leak/index.md) or a [LibraryLeak](../-library-leak/index.md).
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [className](class-name.md) | `abstract val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Class name of the leaking object. The class name format is the same as what would be returned by [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()). |
+| [classSimpleName](class-simple-name.md) | `val classSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Returns [className](class-name.md) stripped of any string content before the last period (included). |
+| [groupHash](group-hash.md) | `val groupHash: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>A unique SHA1 hash that represents this group of leaks. |
+| [leakTrace](leak-trace.md) | `abstract val leakTrace: `[`LeakTrace`](../-leak-trace/index.md)<br>Shortest path from GC roots to the leaking object. |
+| [retainedHeapByteSize](retained-heap-byte-size.md) | `abstract val retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?`<br>The number of bytes which would be freed if all references to the leaking object were released. Null if the retained heap size was not computed. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [createGroupHash](create-group-hash.md) | `abstract fun createGroupHash(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [ApplicationLeak](../-application-leak/index.md) | `data class ApplicationLeak : `[`Leak`](./index.md)<br>A leak found by [HeapAnalyzer](../-heap-analyzer/index.md) in your application. |
+| [LibraryLeak](../-library-leak/index.md) | `data class LibraryLeak : `[`Leak`](./index.md)<br>A leak found by [HeapAnalyzer](../-heap-analyzer/index.md), where the only path to the leaking object required going through a reference matched by [pattern](../-library-leak/pattern.md), as provided to a [LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md) instance. This is a known leak in library code that is beyond your control. |
diff --git a/docs/api/shark/shark/-leak/leak-trace.md b/docs/api/shark/shark/-leak/leak-trace.md
new file mode 100644
index 00000000..589aa93a
--- /dev/null
+++ b/docs/api/shark/shark/-leak/leak-trace.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [Leak](index.md) / [leakTrace](./leak-trace.md)
+
+# leakTrace
+
+`abstract val leakTrace: `[`LeakTrace`](../-leak-trace/index.md)
+
+Shortest path from GC roots to the leaking object.
+
diff --git a/docs/api/shark/shark/-leak/retained-heap-byte-size.md b/docs/api/shark/shark/-leak/retained-heap-byte-size.md
new file mode 100644
index 00000000..a384f377
--- /dev/null
+++ b/docs/api/shark/shark/-leak/retained-heap-byte-size.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [Leak](index.md) / [retainedHeapByteSize](./retained-heap-byte-size.md)
+
+# retainedHeapByteSize
+
+`abstract val retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?`
+
+The number of bytes which would be freed if all references to the leaking object were
+released. Null if the retained heap size was not computed.
+
diff --git a/docs/api/shark/shark/-library-leak-reference-matcher/-init-.md b/docs/api/shark/shark/-library-leak-reference-matcher/-init-.md
new file mode 100644
index 00000000..c713eb83
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak-reference-matcher/-init-.md
@@ -0,0 +1,12 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeakReferenceMatcher](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`LibraryLeakReferenceMatcher(pattern: `[`ReferencePattern`](../-reference-pattern/index.md)`, description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)` = "", patternApplies: (HeapGraph) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = { true })`
+
+[LibraryLeakReferenceMatcher](index.md) should be used to match references in library code that are
+known to create leaks and are beyond your control. The shortest path finder will only go
+through matching references after it has exhausted references that don't match, prioritizing
+finding an application leak over a known library leak. Library leaks will be reported as
+[LibraryLeak](../-library-leak/index.md) instead of [ApplicationLeak](../-application-leak/index.md).
+
diff --git a/docs/api/shark/shark/-library-leak-reference-matcher/description.md b/docs/api/shark/shark/-library-leak-reference-matcher/description.md
new file mode 100644
index 00000000..b4323911
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak-reference-matcher/description.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeakReferenceMatcher](index.md) / [description](./description.md)
+
+# description
+
+`val description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+A description that conveys what we know about this library leak.
+
diff --git a/docs/api/shark/shark/-library-leak-reference-matcher/index.md b/docs/api/shark/shark/-library-leak-reference-matcher/index.md
new file mode 100644
index 00000000..3e4440b3
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak-reference-matcher/index.md
@@ -0,0 +1,25 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeakReferenceMatcher](./index.md)
+
+# LibraryLeakReferenceMatcher
+
+`data class LibraryLeakReferenceMatcher : `[`ReferenceMatcher`](../-reference-matcher/index.md)
+
+[LibraryLeakReferenceMatcher](./index.md) should be used to match references in library code that are
+known to create leaks and are beyond your control. The shortest path finder will only go
+through matching references after it has exhausted references that don't match, prioritizing
+finding an application leak over a known library leak. Library leaks will be reported as
+[LibraryLeak](../-library-leak/index.md) instead of [ApplicationLeak](../-application-leak/index.md).
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `LibraryLeakReferenceMatcher(pattern: `[`ReferencePattern`](../-reference-pattern/index.md)`, description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)` = "", patternApplies: (HeapGraph) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)` = { true })`<br>[LibraryLeakReferenceMatcher](./index.md) should be used to match references in library code that are known to create leaks and are beyond your control. The shortest path finder will only go through matching references after it has exhausted references that don't match, prioritizing finding an application leak over a known library leak. Library leaks will be reported as [LibraryLeak](../-library-leak/index.md) instead of [ApplicationLeak](../-application-leak/index.md). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [description](description.md) | `val description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>A description that conveys what we know about this library leak. |
+| [pattern](pattern.md) | `val pattern: `[`ReferencePattern`](../-reference-pattern/index.md)<br>The pattern that references will be matched against. |
+| [patternApplies](pattern-applies.md) | `val patternApplies: (HeapGraph) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Whether the identified leak may exist in the provided [HeapGraph](#). Defaults to true. If the heap dump comes from a VM that runs a different version of the library that doesn't have the leak, then this should return false. |
diff --git a/docs/api/shark/shark/-library-leak-reference-matcher/pattern-applies.md b/docs/api/shark/shark/-library-leak-reference-matcher/pattern-applies.md
new file mode 100644
index 00000000..24be4342
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak-reference-matcher/pattern-applies.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeakReferenceMatcher](index.md) / [patternApplies](./pattern-applies.md)
+
+# patternApplies
+
+`val patternApplies: (HeapGraph) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)
+
+Whether the identified leak may exist in the provided [HeapGraph](#). Defaults to true. If
+the heap dump comes from a VM that runs a different version of the library that doesn't
+have the leak, then this should return false.
+
diff --git a/docs/api/shark/shark/-library-leak-reference-matcher/pattern.md b/docs/api/shark/shark/-library-leak-reference-matcher/pattern.md
new file mode 100644
index 00000000..d5307245
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak-reference-matcher/pattern.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeakReferenceMatcher](index.md) / [pattern](./pattern.md)
+
+# pattern
+
+`val pattern: `[`ReferencePattern`](../-reference-pattern/index.md)
+
+Overrides [ReferenceMatcher.pattern](../-reference-matcher/pattern.md)
+
+The pattern that references will be matched against.
+
diff --git a/docs/api/shark/shark/-library-leak/-init-.md b/docs/api/shark/shark/-library-leak/-init-.md
new file mode 100644
index 00000000..8702aea3
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak/-init-.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeak](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`LibraryLeak(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, leakTrace: `[`LeakTrace`](../-leak-trace/index.md)`, retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?, pattern: `[`ReferencePattern`](../-reference-pattern/index.md)`, description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`
+
+A leak found by [HeapAnalyzer](../-heap-analyzer/index.md), where the only path to the leaking object required going
+through a reference matched by [pattern](pattern.md), as provided to a [LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md)
+instance. This is a known leak in library code that is beyond your control.
+
diff --git a/docs/api/shark/shark/-library-leak/class-name.md b/docs/api/shark/shark/-library-leak/class-name.md
new file mode 100644
index 00000000..8497a876
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak/class-name.md
@@ -0,0 +1,11 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeak](index.md) / [className](./class-name.md)
+
+# className
+
+`val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Overrides [Leak.className](../-leak/class-name.md)
+
+Class name of the leaking object.
+The class name format is the same as what would be returned by [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()).
+
diff --git a/docs/api/shark/shark/-library-leak/create-group-hash.md b/docs/api/shark/shark/-library-leak/create-group-hash.md
new file mode 100644
index 00000000..daccfae3
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak/create-group-hash.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeak](index.md) / [createGroupHash](./create-group-hash.md)
+
+# createGroupHash
+
+`protected fun createGroupHash(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+Overrides [Leak.createGroupHash](../-leak/create-group-hash.md)
+
diff --git a/docs/api/shark/shark/-library-leak/description.md b/docs/api/shark/shark/-library-leak/description.md
new file mode 100644
index 00000000..0ed73c6a
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak/description.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeak](index.md) / [description](./description.md)
+
+# description
+
+`val description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
+
+A description that conveys what we know about this library leak.
+
diff --git a/docs/api/shark/shark/-library-leak/index.md b/docs/api/shark/shark/-library-leak/index.md
new file mode 100644
index 00000000..fd69a2cb
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak/index.md
@@ -0,0 +1,38 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeak](./index.md)
+
+# LibraryLeak
+
+`data class LibraryLeak : `[`Leak`](../-leak/index.md)
+
+A leak found by [HeapAnalyzer](../-heap-analyzer/index.md), where the only path to the leaking object required going
+through a reference matched by [pattern](pattern.md), as provided to a [LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md)
+instance. This is a known leak in library code that is beyond your control.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `LibraryLeak(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, leakTrace: `[`LeakTrace`](../-leak-trace/index.md)`, retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?, pattern: `[`ReferencePattern`](../-reference-pattern/index.md)`, description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`<br>A leak found by [HeapAnalyzer](../-heap-analyzer/index.md), where the only path to the leaking object required going through a reference matched by [pattern](pattern.md), as provided to a [LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md) instance. This is a known leak in library code that is beyond your control. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [className](class-name.md) | `val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Class name of the leaking object. The class name format is the same as what would be returned by [Class.getName](https://docs.oracle.com/javase/6/docs/api/java/lang/Class.html#getName()). |
+| [description](description.md) | `val description: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>A description that conveys what we know about this library leak. |
+| [leakTrace](leak-trace.md) | `val leakTrace: `[`LeakTrace`](../-leak-trace/index.md)<br>Shortest path from GC roots to the leaking object. |
+| [pattern](pattern.md) | `val pattern: `[`ReferencePattern`](../-reference-pattern/index.md)<br>The pattern that matched one of the references in [leakTrace](leak-trace.md), as provided to a [LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md) instance. |
+| [retainedHeapByteSize](retained-heap-byte-size.md) | `val retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?`<br>The number of bytes which would be freed if all references to the leaking object were released. Null if the retained heap size was not computed. |
+
+### Inherited Properties
+
+| Name | Summary |
+|---|---|
+| [classSimpleName](../-leak/class-simple-name.md) | `val classSimpleName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>Returns [className](../-leak/class-name.md) stripped of any string content before the last period (included). |
+| [groupHash](../-leak/group-hash.md) | `val groupHash: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)<br>A unique SHA1 hash that represents this group of leaks. |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [createGroupHash](create-group-hash.md) | `fun createGroupHash(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark/shark/-library-leak/leak-trace.md b/docs/api/shark/shark/-library-leak/leak-trace.md
new file mode 100644
index 00000000..e2a17154
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak/leak-trace.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeak](index.md) / [leakTrace](./leak-trace.md)
+
+# leakTrace
+
+`val leakTrace: `[`LeakTrace`](../-leak-trace/index.md)
+
+Overrides [Leak.leakTrace](../-leak/leak-trace.md)
+
+Shortest path from GC roots to the leaking object.
+
diff --git a/docs/api/shark/shark/-library-leak/pattern.md b/docs/api/shark/shark/-library-leak/pattern.md
new file mode 100644
index 00000000..628adcd9
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak/pattern.md
@@ -0,0 +1,9 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeak](index.md) / [pattern](./pattern.md)
+
+# pattern
+
+`val pattern: `[`ReferencePattern`](../-reference-pattern/index.md)
+
+The pattern that matched one of the references in [leakTrace](leak-trace.md), as provided to a
+[LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md) instance.
+
diff --git a/docs/api/shark/shark/-library-leak/retained-heap-byte-size.md b/docs/api/shark/shark/-library-leak/retained-heap-byte-size.md
new file mode 100644
index 00000000..82302a6e
--- /dev/null
+++ b/docs/api/shark/shark/-library-leak/retained-heap-byte-size.md
@@ -0,0 +1,11 @@
+[shark](../../index.md) / [shark](../index.md) / [LibraryLeak](index.md) / [retainedHeapByteSize](./retained-heap-byte-size.md)
+
+# retainedHeapByteSize
+
+`val retainedHeapByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`?`
+
+Overrides [Leak.retainedHeapByteSize](../-leak/retained-heap-byte-size.md)
+
+The number of bytes which would be freed if all references to the leaking object were
+released. Null if the retained heap size was not computed.
+
diff --git a/docs/api/shark/shark/-object-inspector/index.md b/docs/api/shark/shark/-object-inspector/index.md
new file mode 100644
index 00000000..215974b8
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspector/index.md
@@ -0,0 +1,31 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectInspector](./index.md)
+
+# ObjectInspector
+
+`interface ObjectInspector`
+
+Provides LeakCanary with insights about objects (classes, instances and arrays) found in the
+heap. [inspect](inspect.md) will be called for each object that LeakCanary wants to know more about.
+The implementation can then use the provided [ObjectReporter](../-object-reporter/index.md) to provide insights for that
+object.
+
+You can create a [ObjectInspector](./index.md) from a lambda by calling [invoke](invoke.md).
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `abstract fun inspect(reporter: `[`ObjectReporter`](../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [invoke](invoke.md) | `operator fun invoke(block: (`[`ObjectReporter`](../-object-reporter/index.md)`) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`ObjectInspector`](./index.md)<br>Utility function to create a [ObjectInspector](./index.md) from the passed in [block](invoke.md#shark.ObjectInspector.Companion$invoke(kotlin.Function1((shark.ObjectReporter, kotlin.Unit)))/block) lambda instead of using the anonymous `object : OnHeapAnalyzedListener` syntax. |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [AppSingletonInspector](../-app-singleton-inspector/index.md) | `class AppSingletonInspector : `[`ObjectInspector`](./index.md)<br>Inspector that automatically marks instances of the provided class names as not leaking because they're app wide singletons. |
+| [ObjectInspectors](../-object-inspectors/index.md) | `enum class ObjectInspectors : `[`ObjectInspector`](./index.md)<br>A set of default [ObjectInspector](./index.md)s that knows about common JDK objects. |
diff --git a/docs/api/shark/shark/-object-inspector/inspect.md b/docs/api/shark/shark/-object-inspector/inspect.md
new file mode 100644
index 00000000..fd80f814
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspector/inspect.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectInspector](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`abstract fun inspect(reporter: `[`ObjectReporter`](../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+**See Also**
+
+[ObjectInspector](index.md)
+
diff --git a/docs/api/shark/shark/-object-inspector/invoke.md b/docs/api/shark/shark/-object-inspector/invoke.md
new file mode 100644
index 00000000..93427424
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspector/invoke.md
@@ -0,0 +1,17 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectInspector](index.md) / [invoke](./invoke.md)
+
+# invoke
+
+`inline operator fun invoke(crossinline block: (`[`ObjectReporter`](../-object-reporter/index.md)`) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`ObjectInspector`](index.md)
+
+Utility function to create a [ObjectInspector](index.md) from the passed in [block](invoke.md#shark.ObjectInspector.Companion$invoke(kotlin.Function1((shark.ObjectReporter, kotlin.Unit)))/block) lambda instead of
+using the anonymous `object : OnHeapAnalyzedListener` syntax.
+
+Usage:
+
+``` kotlin
+val inspector = ObjectInspector { reporter ->
+
+}
+```
+
diff --git a/docs/api/shark/shark/-object-inspectors/-a-n-o-n-y-m-o-u-s_-c-l-a-s-s/index.md b/docs/api/shark/shark/-object-inspectors/-a-n-o-n-y-m-o-u-s_-c-l-a-s-s/index.md
new file mode 100644
index 00000000..7b8c805d
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-a-n-o-n-y-m-o-u-s_-c-l-a-s-s/index.md
@@ -0,0 +1,11 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [ANONYMOUS_CLASS](./index.md)
+
+# ANONYMOUS_CLASS
+
+`ANONYMOUS_CLASS`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark/shark/-object-inspectors/-a-n-o-n-y-m-o-u-s_-c-l-a-s-s/inspect.md b/docs/api/shark/shark/-object-inspectors/-a-n-o-n-y-m-o-u-s_-c-l-a-s-s/inspect.md
new file mode 100644
index 00000000..fafca4eb
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-a-n-o-n-y-m-o-u-s_-c-l-a-s-s/inspect.md
@@ -0,0 +1,12 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [ANONYMOUS_CLASS](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Overrides [ObjectInspector.inspect](../../-object-inspector/inspect.md)
+
+**See Also**
+
+[ObjectInspector](../../-object-inspector/index.md)
+
diff --git a/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s-l-o-a-d-e-r/index.md b/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s-l-o-a-d-e-r/index.md
new file mode 100644
index 00000000..95ccad96
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s-l-o-a-d-e-r/index.md
@@ -0,0 +1,11 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [CLASSLOADER](./index.md)
+
+# CLASSLOADER
+
+`CLASSLOADER`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s-l-o-a-d-e-r/inspect.md b/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s-l-o-a-d-e-r/inspect.md
new file mode 100644
index 00000000..733bf9f3
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s-l-o-a-d-e-r/inspect.md
@@ -0,0 +1,12 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [CLASSLOADER](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Overrides [ObjectInspector.inspect](../../-object-inspector/inspect.md)
+
+**See Also**
+
+[ObjectInspector](../../-object-inspector/index.md)
+
diff --git a/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s/index.md b/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s/index.md
new file mode 100644
index 00000000..55df283a
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s/index.md
@@ -0,0 +1,11 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [CLASS](./index.md)
+
+# CLASS
+
+`CLASS`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s/inspect.md b/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s/inspect.md
new file mode 100644
index 00000000..540aeabf
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-c-l-a-s-s/inspect.md
@@ -0,0 +1,12 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [CLASS](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Overrides [ObjectInspector.inspect](../../-object-inspector/inspect.md)
+
+**See Also**
+
+[ObjectInspector](../../-object-inspector/index.md)
+
diff --git a/docs/api/shark/shark/-object-inspectors/-k-e-y-e-d_-w-e-a-k_-r-e-f-e-r-e-n-c-e/index.md b/docs/api/shark/shark/-object-inspectors/-k-e-y-e-d_-w-e-a-k_-r-e-f-e-r-e-n-c-e/index.md
new file mode 100644
index 00000000..420027b4
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-k-e-y-e-d_-w-e-a-k_-r-e-f-e-r-e-n-c-e/index.md
@@ -0,0 +1,11 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [KEYED_WEAK_REFERENCE](./index.md)
+
+# KEYED_WEAK_REFERENCE
+
+`KEYED_WEAK_REFERENCE`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark/shark/-object-inspectors/-k-e-y-e-d_-w-e-a-k_-r-e-f-e-r-e-n-c-e/inspect.md b/docs/api/shark/shark/-object-inspectors/-k-e-y-e-d_-w-e-a-k_-r-e-f-e-r-e-n-c-e/inspect.md
new file mode 100644
index 00000000..5a6c5907
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-k-e-y-e-d_-w-e-a-k_-r-e-f-e-r-e-n-c-e/inspect.md
@@ -0,0 +1,12 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [KEYED_WEAK_REFERENCE](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Overrides [ObjectInspector.inspect](../../-object-inspector/inspect.md)
+
+**See Also**
+
+[ObjectInspector](../../-object-inspector/index.md)
+
diff --git a/docs/api/shark/shark/-object-inspectors/-t-h-r-e-a-d/index.md b/docs/api/shark/shark/-object-inspectors/-t-h-r-e-a-d/index.md
new file mode 100644
index 00000000..20f7b733
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-t-h-r-e-a-d/index.md
@@ -0,0 +1,11 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [THREAD](./index.md)
+
+# THREAD
+
+`THREAD`
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](inspect.md) | `fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
diff --git a/docs/api/shark/shark/-object-inspectors/-t-h-r-e-a-d/inspect.md b/docs/api/shark/shark/-object-inspectors/-t-h-r-e-a-d/inspect.md
new file mode 100644
index 00000000..593c67a8
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/-t-h-r-e-a-d/inspect.md
@@ -0,0 +1,12 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ObjectInspectors](../index.md) / [THREAD](index.md) / [inspect](./inspect.md)
+
+# inspect
+
+`fun inspect(reporter: `[`ObjectReporter`](../../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Overrides [ObjectInspector.inspect](../../-object-inspector/inspect.md)
+
+**See Also**
+
+[ObjectInspector](../../-object-inspector/index.md)
+
diff --git a/docs/api/shark/shark/-object-inspectors/index.md b/docs/api/shark/shark/-object-inspectors/index.md
new file mode 100644
index 00000000..3b20a78d
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/index.md
@@ -0,0 +1,29 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectInspectors](./index.md)
+
+# ObjectInspectors
+
+`enum class ObjectInspectors : `[`ObjectInspector`](../-object-inspector/index.md)
+
+A set of default [ObjectInspector](../-object-inspector/index.md)s that knows about common JDK objects.
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [KEYED_WEAK_REFERENCE](-k-e-y-e-d_-w-e-a-k_-r-e-f-e-r-e-n-c-e/index.md) |  |
+| [CLASSLOADER](-c-l-a-s-s-l-o-a-d-e-r/index.md) |  |
+| [CLASS](-c-l-a-s-s/index.md) |  |
+| [ANONYMOUS_CLASS](-a-n-o-n-y-m-o-u-s_-c-l-a-s-s/index.md) |  |
+| [THREAD](-t-h-r-e-a-d/index.md) |  |
+
+### Inherited Functions
+
+| Name | Summary |
+|---|---|
+| [inspect](../-object-inspector/inspect.md) | `abstract fun inspect(reporter: `[`ObjectReporter`](../-object-reporter/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+
+### Companion Object Properties
+
+| Name | Summary |
+|---|---|
+| [jdkDefaults](jdk-defaults.md) | `val jdkDefaults: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ObjectInspector`](../-object-inspector/index.md)`>` |
diff --git a/docs/api/shark/shark/-object-inspectors/jdk-defaults.md b/docs/api/shark/shark/-object-inspectors/jdk-defaults.md
new file mode 100644
index 00000000..3fe8fa7d
--- /dev/null
+++ b/docs/api/shark/shark/-object-inspectors/jdk-defaults.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectInspectors](index.md) / [jdkDefaults](./jdk-defaults.md)
+
+# jdkDefaults
+
+`val jdkDefaults: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`ObjectInspector`](../-object-inspector/index.md)`>`
+
+**See Also**
+
+[ObjectInspectors](index.md)
+
diff --git a/docs/api/shark/shark/-object-reporter/-init-.md b/docs/api/shark/shark/-object-reporter/-init-.md
new file mode 100644
index 00000000..f23eec3a
--- /dev/null
+++ b/docs/api/shark/shark/-object-reporter/-init-.md
@@ -0,0 +1,12 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectReporter](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ObjectReporter(heapObject: HeapObject)`
+
+Enables [ObjectInspector](../-object-inspector/index.md) implementations to provide insights on [heapObject](heap-object.md), which is
+an object (class, instance or array) found in the heap.
+
+A given [ObjectReporter](index.md) only maps to one object in the heap, but is shared to many
+[ObjectInspector](../-object-inspector/index.md) implementations and accumulates insights.
+
diff --git a/docs/api/shark/shark/-object-reporter/heap-object.md b/docs/api/shark/shark/-object-reporter/heap-object.md
new file mode 100644
index 00000000..7d64bc62
--- /dev/null
+++ b/docs/api/shark/shark/-object-reporter/heap-object.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectReporter](index.md) / [heapObject](./heap-object.md)
+
+# heapObject
+
+`val heapObject: HeapObject`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-object-reporter/index.md b/docs/api/shark/shark/-object-reporter/index.md
new file mode 100644
index 00000000..c5ab1402
--- /dev/null
+++ b/docs/api/shark/shark/-object-reporter/index.md
@@ -0,0 +1,33 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectReporter](./index.md)
+
+# ObjectReporter
+
+`class ObjectReporter`
+
+Enables [ObjectInspector](../-object-inspector/index.md) implementations to provide insights on [heapObject](heap-object.md), which is
+an object (class, instance or array) found in the heap.
+
+A given [ObjectReporter](./index.md) only maps to one object in the heap, but is shared to many
+[ObjectInspector](../-object-inspector/index.md) implementations and accumulates insights.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ObjectReporter(heapObject: HeapObject)`<br>Enables [ObjectInspector](../-object-inspector/index.md) implementations to provide insights on [heapObject](heap-object.md), which is an object (class, instance or array) found in the heap. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [heapObject](heap-object.md) | `val heapObject: HeapObject` |
+| [labels](labels.md) | `val labels: `[`LinkedHashSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`<br>Labels that will be visible on the corresponding [heapObject](heap-object.md) in the leak trace. |
+| [leakingReasons](leaking-reasons.md) | `val leakingReasons: `[`MutableSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`<br>Reasons for which this object is expected to be unreachable (ie it's leaking). |
+| [likelyLeakingReasons](likely-leaking-reasons.md) | `val likelyLeakingReasons: `[`MutableSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>` |
+| [notLeakingReasons](not-leaking-reasons.md) | `val notLeakingReasons: `[`MutableSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`<br>Reasons for which this object is expected to be reachable (ie it's not leaking). |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [whenInstanceOf](when-instance-of.md) | `fun whenInstanceOf(expectedClass: `[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>, block: `[`ObjectReporter`](./index.md)`.(HeapInstance) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Runs [block](when-instance-of.md#shark.ObjectReporter$whenInstanceOf(kotlin.reflect.KClass((kotlin.Any)), kotlin.Function2((shark.ObjectReporter, shark.HeapObject.HeapInstance, kotlin.Unit)))/block) if [ObjectReporter.heapObject](heap-object.md) is an instance of [expectedClass](when-instance-of.md#shark.ObjectReporter$whenInstanceOf(kotlin.reflect.KClass((kotlin.Any)), kotlin.Function2((shark.ObjectReporter, shark.HeapObject.HeapInstance, kotlin.Unit)))/expectedClass).`fun whenInstanceOf(expectedClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, block: `[`ObjectReporter`](./index.md)`.(HeapInstance) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Runs [block](when-instance-of.md#shark.ObjectReporter$whenInstanceOf(kotlin.String, kotlin.Function2((shark.ObjectReporter, shark.HeapObject.HeapInstance, kotlin.Unit)))/block) if [ObjectReporter.heapObject](heap-object.md) is an instance of [expectedClassName](when-instance-of.md#shark.ObjectReporter$whenInstanceOf(kotlin.String, kotlin.Function2((shark.ObjectReporter, shark.HeapObject.HeapInstance, kotlin.Unit)))/expectedClassName). |
diff --git a/docs/api/shark/shark/-object-reporter/labels.md b/docs/api/shark/shark/-object-reporter/labels.md
new file mode 100644
index 00000000..8cda5947
--- /dev/null
+++ b/docs/api/shark/shark/-object-reporter/labels.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectReporter](index.md) / [labels](./labels.md)
+
+# labels
+
+`val labels: `[`LinkedHashSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`
+
+Labels that will be visible on the corresponding [heapObject](heap-object.md) in the leak trace.
+
diff --git a/docs/api/shark/shark/-object-reporter/leaking-reasons.md b/docs/api/shark/shark/-object-reporter/leaking-reasons.md
new file mode 100644
index 00000000..1069267a
--- /dev/null
+++ b/docs/api/shark/shark/-object-reporter/leaking-reasons.md
@@ -0,0 +1,12 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectReporter](index.md) / [leakingReasons](./leaking-reasons.md)
+
+# leakingReasons
+
+`val leakingReasons: `[`MutableSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`
+
+Reasons for which this object is expected to be unreachable (ie it's leaking).
+
+Only add reasons to this if you're 100% sure this object is leaking, otherwise add reasons to
+[likelyLeakingReasons](likely-leaking-reasons.md). The difference is that objects that are "likely leaking" are not
+considered to be leaking objects on which LeakCanary should compute the leak trace.
+
diff --git a/docs/api/shark/shark/-object-reporter/likely-leaking-reasons.md b/docs/api/shark/shark/-object-reporter/likely-leaking-reasons.md
new file mode 100644
index 00000000..115185ab
--- /dev/null
+++ b/docs/api/shark/shark/-object-reporter/likely-leaking-reasons.md
@@ -0,0 +1,10 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectReporter](index.md) / [likelyLeakingReasons](./likely-leaking-reasons.md)
+
+# likelyLeakingReasons
+
+`val likelyLeakingReasons: `[`MutableSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`
+
+**See Also**
+
+[leakingReasons](leaking-reasons.md)
+
diff --git a/docs/api/shark/shark/-object-reporter/not-leaking-reasons.md b/docs/api/shark/shark/-object-reporter/not-leaking-reasons.md
new file mode 100644
index 00000000..080471d3
--- /dev/null
+++ b/docs/api/shark/shark/-object-reporter/not-leaking-reasons.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectReporter](index.md) / [notLeakingReasons](./not-leaking-reasons.md)
+
+# notLeakingReasons
+
+`val notLeakingReasons: `[`MutableSet`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/index.html)`<`[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`>`
+
+Reasons for which this object is expected to be reachable (ie it's not leaking).
+
diff --git a/docs/api/shark/shark/-object-reporter/when-instance-of.md b/docs/api/shark/shark/-object-reporter/when-instance-of.md
new file mode 100644
index 00000000..f0412327
--- /dev/null
+++ b/docs/api/shark/shark/-object-reporter/when-instance-of.md
@@ -0,0 +1,12 @@
+[shark](../../index.md) / [shark](../index.md) / [ObjectReporter](index.md) / [whenInstanceOf](./when-instance-of.md)
+
+# whenInstanceOf
+
+`fun whenInstanceOf(expectedClass: `[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html)`>, block: `[`ObjectReporter`](index.md)`.(HeapInstance) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Runs [block](when-instance-of.md#shark.ObjectReporter$whenInstanceOf(kotlin.reflect.KClass((kotlin.Any)), kotlin.Function2((shark.ObjectReporter, shark.HeapObject.HeapInstance, kotlin.Unit)))/block) if [ObjectReporter.heapObject](heap-object.md) is an instance of [expectedClass](when-instance-of.md#shark.ObjectReporter$whenInstanceOf(kotlin.reflect.KClass((kotlin.Any)), kotlin.Function2((shark.ObjectReporter, shark.HeapObject.HeapInstance, kotlin.Unit)))/expectedClass).
+
+`fun whenInstanceOf(expectedClassName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, block: `[`ObjectReporter`](index.md)`.(HeapInstance) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
+
+Runs [block](when-instance-of.md#shark.ObjectReporter$whenInstanceOf(kotlin.String, kotlin.Function2((shark.ObjectReporter, shark.HeapObject.HeapInstance, kotlin.Unit)))/block) if [ObjectReporter.heapObject](heap-object.md) is an instance of [expectedClassName](when-instance-of.md#shark.ObjectReporter$whenInstanceOf(kotlin.String, kotlin.Function2((shark.ObjectReporter, shark.HeapObject.HeapInstance, kotlin.Unit)))/expectedClassName).
+
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-n-o_-o-p.md b/docs/api/shark/shark/-on-analysis-progress-listener/-n-o_-o-p.md
new file mode 100644
index 00000000..eba38bb0
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-n-o_-o-p.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [OnAnalysisProgressListener](index.md) / [NO_OP](./-n-o_-o-p.md)
+
+# NO_OP
+
+`val NO_OP: `[`OnAnalysisProgressListener`](index.md)
+
+A no-op [OnAnalysisProgressListener](index.md)
+
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-b-u-i-l-d-i-n-g_-l-e-a-k_-t-r-a-c-e-s.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-b-u-i-l-d-i-n-g_-l-e-a-k_-t-r-a-c-e-s.md
new file mode 100644
index 00000000..f1b21e21
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-b-u-i-l-d-i-n-g_-l-e-a-k_-t-r-a-c-e-s.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [BUILDING_LEAK_TRACES](./-b-u-i-l-d-i-n-g_-l-e-a-k_-t-r-a-c-e-s.md)
+
+# BUILDING_LEAK_TRACES
+
+`BUILDING_LEAK_TRACES`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-c-o-m-p-u-t-i-n-g_-n-a-t-i-v-e_-r-e-t-a-i-n-e-d_-s-i-z-e.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-c-o-m-p-u-t-i-n-g_-n-a-t-i-v-e_-r-e-t-a-i-n-e-d_-s-i-z-e.md
new file mode 100644
index 00000000..db43067a
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-c-o-m-p-u-t-i-n-g_-n-a-t-i-v-e_-r-e-t-a-i-n-e-d_-s-i-z-e.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [COMPUTING_NATIVE_RETAINED_SIZE](./-c-o-m-p-u-t-i-n-g_-n-a-t-i-v-e_-r-e-t-a-i-n-e-d_-s-i-z-e.md)
+
+# COMPUTING_NATIVE_RETAINED_SIZE
+
+`COMPUTING_NATIVE_RETAINED_SIZE`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-c-o-m-p-u-t-i-n-g_-r-e-t-a-i-n-e-d_-s-i-z-e.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-c-o-m-p-u-t-i-n-g_-r-e-t-a-i-n-e-d_-s-i-z-e.md
new file mode 100644
index 00000000..b2802554
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-c-o-m-p-u-t-i-n-g_-r-e-t-a-i-n-e-d_-s-i-z-e.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [COMPUTING_RETAINED_SIZE](./-c-o-m-p-u-t-i-n-g_-r-e-t-a-i-n-e-d_-s-i-z-e.md)
+
+# COMPUTING_RETAINED_SIZE
+
+`COMPUTING_RETAINED_SIZE`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-d-o-m-i-n-a-t-o-r-s.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-d-o-m-i-n-a-t-o-r-s.md
new file mode 100644
index 00000000..3215bf55
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-d-o-m-i-n-a-t-o-r-s.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [FINDING_DOMINATORS](./-f-i-n-d-i-n-g_-d-o-m-i-n-a-t-o-r-s.md)
+
+# FINDING_DOMINATORS
+
+`FINDING_DOMINATORS`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md
new file mode 100644
index 00000000..7f76a298
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [FINDING_LEAKING_INSTANCES](./-f-i-n-d-i-n-g_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md)
+
+# FINDING_LEAKING_INSTANCES
+
+`FINDING_LEAKING_INSTANCES`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-p-a-t-h-s_-t-o_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-p-a-t-h-s_-t-o_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md
new file mode 100644
index 00000000..6c80af56
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-f-i-n-d-i-n-g_-p-a-t-h-s_-t-o_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [FINDING_PATHS_TO_LEAKING_INSTANCES](./-f-i-n-d-i-n-g_-p-a-t-h-s_-t-o_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md)
+
+# FINDING_PATHS_TO_LEAKING_INSTANCES
+
+`FINDING_PATHS_TO_LEAKING_INSTANCES`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-p-a-r-s-i-n-g_-h-e-a-p_-d-u-m-p.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-p-a-r-s-i-n-g_-h-e-a-p_-d-u-m-p.md
new file mode 100644
index 00000000..b0fbf7df
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-p-a-r-s-i-n-g_-h-e-a-p_-d-u-m-p.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [PARSING_HEAP_DUMP](./-p-a-r-s-i-n-g_-h-e-a-p_-d-u-m-p.md)
+
+# PARSING_HEAP_DUMP
+
+`PARSING_HEAP_DUMP`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md
new file mode 100644
index 00000000..93bb0eac
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [REPORTING_HEAP_ANALYSIS](./-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md)
+
+# REPORTING_HEAP_ANALYSIS
+
+`REPORTING_HEAP_ANALYSIS`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/index.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/index.md
new file mode 100644
index 00000000..0eae9d12
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/index.md
@@ -0,0 +1,18 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](./index.md)
+
+# Step
+
+`enum class Step`
+
+### Enum Values
+
+| Name | Summary |
+|---|---|
+| [PARSING_HEAP_DUMP](-p-a-r-s-i-n-g_-h-e-a-p_-d-u-m-p.md) |  |
+| [FINDING_LEAKING_INSTANCES](-f-i-n-d-i-n-g_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md) |  |
+| [FINDING_PATHS_TO_LEAKING_INSTANCES](-f-i-n-d-i-n-g_-p-a-t-h-s_-t-o_-l-e-a-k-i-n-g_-i-n-s-t-a-n-c-e-s.md) |  |
+| [FINDING_DOMINATORS](-f-i-n-d-i-n-g_-d-o-m-i-n-a-t-o-r-s.md) |  |
+| [COMPUTING_NATIVE_RETAINED_SIZE](-c-o-m-p-u-t-i-n-g_-n-a-t-i-v-e_-r-e-t-a-i-n-e-d_-s-i-z-e.md) |  |
+| [COMPUTING_RETAINED_SIZE](-c-o-m-p-u-t-i-n-g_-r-e-t-a-i-n-e-d_-s-i-z-e.md) |  |
+| [BUILDING_LEAK_TRACES](-b-u-i-l-d-i-n-g_-l-e-a-k_-t-r-a-c-e-s.md) |  |
+| [REPORTING_HEAP_ANALYSIS](-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md) |  |
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/index.md b/docs/api/shark/shark/-on-analysis-progress-listener/index.md
new file mode 100644
index 00000000..ebc5b9bd
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/index.md
@@ -0,0 +1,31 @@
+[shark](../../index.md) / [shark](../index.md) / [OnAnalysisProgressListener](./index.md)
+
+# OnAnalysisProgressListener
+
+`interface OnAnalysisProgressListener`
+
+Reports progress from the [HeapAnalyzer](../-heap-analyzer/index.md) as they occur, as [Step](-step/index.md) values.
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [Step](-step/index.md) | `enum class Step` |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [onAnalysisProgress](on-analysis-progress.md) | `abstract fun onAnalysisProgress(step: `[`OnAnalysisProgressListener.Step`](-step/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
+
+### Companion Object Properties
+
+| Name | Summary |
+|---|---|
+| [NO_OP](-n-o_-o-p.md) | `val NO_OP: `[`OnAnalysisProgressListener`](./index.md)<br>A no-op [OnAnalysisProgressListener](./index.md) |
+
+### Companion Object Functions
+
+| Name | Summary |
+|---|---|
+| [invoke](invoke.md) | `operator fun invoke(block: (`[`OnAnalysisProgressListener.Step`](-step/index.md)`) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`OnAnalysisProgressListener`](./index.md)<br>Utility function to create a [OnAnalysisProgressListener](./index.md) from the passed in [block](invoke.md#shark.OnAnalysisProgressListener.Companion$invoke(kotlin.Function1((shark.OnAnalysisProgressListener.Step, kotlin.Unit)))/block) lambda instead of using the anonymous `object : OnAnalysisProgressListener` syntax. |
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/invoke.md b/docs/api/shark/shark/-on-analysis-progress-listener/invoke.md
new file mode 100644
index 00000000..26152c80
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/invoke.md
@@ -0,0 +1,17 @@
+[shark](../../index.md) / [shark](../index.md) / [OnAnalysisProgressListener](index.md) / [invoke](./invoke.md)
+
+# invoke
+
+`inline operator fun invoke(crossinline block: (`[`OnAnalysisProgressListener.Step`](-step/index.md)`) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`OnAnalysisProgressListener`](index.md)
+
+Utility function to create a [OnAnalysisProgressListener](index.md) from the passed in [block](invoke.md#shark.OnAnalysisProgressListener.Companion$invoke(kotlin.Function1((shark.OnAnalysisProgressListener.Step, kotlin.Unit)))/block) lambda
+instead of using the anonymous `object : OnAnalysisProgressListener` syntax.
+
+Usage:
+
+``` kotlin
+val listener = OnAnalysisProgressListener {
+
+}
+```
+
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/on-analysis-progress.md b/docs/api/shark/shark/-on-analysis-progress-listener/on-analysis-progress.md
new file mode 100644
index 00000000..a1cb5a9e
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/on-analysis-progress.md
@@ -0,0 +1,5 @@
+[shark](../../index.md) / [shark](../index.md) / [OnAnalysisProgressListener](index.md) / [onAnalysisProgress](./on-analysis-progress.md)
+
+# onAnalysisProgress
+
+`abstract fun onAnalysisProgress(step: `[`OnAnalysisProgressListener.Step`](-step/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-matcher/index.md b/docs/api/shark/shark/-reference-matcher/index.md
new file mode 100644
index 00000000..eddcc1e3
--- /dev/null
+++ b/docs/api/shark/shark/-reference-matcher/index.md
@@ -0,0 +1,21 @@
+[shark](../../index.md) / [shark](../index.md) / [ReferenceMatcher](./index.md)
+
+# ReferenceMatcher
+
+`sealed class ReferenceMatcher`
+
+Used to pattern match known patterns of references in the heap, either to ignore them
+([IgnoredReferenceMatcher](../-ignored-reference-matcher/index.md)) or to mark them as library leaks ([LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md)).
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [pattern](pattern.md) | `abstract val pattern: `[`ReferencePattern`](../-reference-pattern/index.md)<br>The pattern that references will be matched against. |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [IgnoredReferenceMatcher](../-ignored-reference-matcher/index.md) | `class IgnoredReferenceMatcher : `[`ReferenceMatcher`](./index.md)<br>[IgnoredReferenceMatcher](../-ignored-reference-matcher/index.md) should be used to match references that cannot ever create leaks. The shortest path finder will never go through matching references. |
+| [LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md) | `data class LibraryLeakReferenceMatcher : `[`ReferenceMatcher`](./index.md)<br>[LibraryLeakReferenceMatcher](../-library-leak-reference-matcher/index.md) should be used to match references in library code that are known to create leaks and are beyond your control. The shortest path finder will only go through matching references after it has exhausted references that don't match, prioritizing finding an application leak over a known library leak. Library leaks will be reported as [LibraryLeak](../-library-leak/index.md) instead of [ApplicationLeak](../-application-leak/index.md). |
diff --git a/docs/api/shark/shark/-reference-matcher/pattern.md b/docs/api/shark/shark/-reference-matcher/pattern.md
new file mode 100644
index 00000000..25b31f7e
--- /dev/null
+++ b/docs/api/shark/shark/-reference-matcher/pattern.md
@@ -0,0 +1,8 @@
+[shark](../../index.md) / [shark](../index.md) / [ReferenceMatcher](index.md) / [pattern](./pattern.md)
+
+# pattern
+
+`abstract val pattern: `[`ReferencePattern`](../-reference-pattern/index.md)
+
+The pattern that references will be matched against.
+
diff --git a/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/-init-.md b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/-init-.md
new file mode 100644
index 00000000..523558a6
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/-init-.md
@@ -0,0 +1,13 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [InstanceFieldPattern](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`InstanceFieldPattern(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`
+
+Matches instances field references, identified by [className](class-name.md) and [fieldName](field-name.md).
+
+Note: If [fieldName](field-name.md) is declared in a superclass it will still match for subclasses.
+This is to support overriding of rules for specific cases. If two [ReferenceMatcher](../../-reference-matcher/index.md) match for
+the same [fieldName](field-name.md) but for different [className](class-name.md) in a class hierarchy, then the closest
+class in the hierarchy wins.
+
diff --git a/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/class-name.md b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/class-name.md
new file mode 100644
index 00000000..fe141115
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/class-name.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [InstanceFieldPattern](index.md) / [className](./class-name.md)
+
+# className
+
+`val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/field-name.md b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/field-name.md
new file mode 100644
index 00000000..e981a572
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/field-name.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [InstanceFieldPattern](index.md) / [fieldName](./field-name.md)
+
+# fieldName
+
+`val fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/index.md b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/index.md
new file mode 100644
index 00000000..a94bd1d1
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/index.md
@@ -0,0 +1,31 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [InstanceFieldPattern](./index.md)
+
+# InstanceFieldPattern
+
+`data class InstanceFieldPattern : `[`ReferencePattern`](../index.md)
+
+Matches instances field references, identified by [className](class-name.md) and [fieldName](field-name.md).
+
+Note: If [fieldName](field-name.md) is declared in a superclass it will still match for subclasses.
+This is to support overriding of rules for specific cases. If two [ReferenceMatcher](../../-reference-matcher/index.md) match for
+the same [fieldName](field-name.md) but for different [className](class-name.md) in a class hierarchy, then the closest
+class in the hierarchy wins.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `InstanceFieldPattern(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`<br>Matches instances field references, identified by [className](class-name.md) and [fieldName](field-name.md). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [className](class-name.md) | `val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [fieldName](field-name.md) | `val fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/to-string.md b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/to-string.md
new file mode 100644
index 00000000..c21325b7
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-instance-field-pattern/to-string.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [InstanceFieldPattern](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-pattern/-java-local-pattern/-init-.md b/docs/api/shark/shark/-reference-pattern/-java-local-pattern/-init-.md
new file mode 100644
index 00000000..f9a29b4c
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-java-local-pattern/-init-.md
@@ -0,0 +1,8 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [JavaLocalPattern](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`JavaLocalPattern(threadName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`
+
+Matches local references held in the stack of frames of a given thread, identified by its name.
+
diff --git a/docs/api/shark/shark/-reference-pattern/-java-local-pattern/index.md b/docs/api/shark/shark/-reference-pattern/-java-local-pattern/index.md
new file mode 100644
index 00000000..4f26e912
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-java-local-pattern/index.md
@@ -0,0 +1,25 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [JavaLocalPattern](./index.md)
+
+# JavaLocalPattern
+
+`data class JavaLocalPattern : `[`ReferencePattern`](../index.md)
+
+Matches local references held in the stack of frames of a given thread, identified by its name.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `JavaLocalPattern(threadName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`<br>Matches local references held in the stack of frames of a given thread, identified by its name. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [threadName](thread-name.md) | `val threadName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark/shark/-reference-pattern/-java-local-pattern/thread-name.md b/docs/api/shark/shark/-reference-pattern/-java-local-pattern/thread-name.md
new file mode 100644
index 00000000..99e08b58
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-java-local-pattern/thread-name.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [JavaLocalPattern](index.md) / [threadName](./thread-name.md)
+
+# threadName
+
+`val threadName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-pattern/-java-local-pattern/to-string.md b/docs/api/shark/shark/-reference-pattern/-java-local-pattern/to-string.md
new file mode 100644
index 00000000..c11a2c15
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-java-local-pattern/to-string.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [JavaLocalPattern](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-pattern/-static-field-pattern/-init-.md b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/-init-.md
new file mode 100644
index 00000000..80129351
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/-init-.md
@@ -0,0 +1,8 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [StaticFieldPattern](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`StaticFieldPattern(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`
+
+Matches static field references, identified by [className](class-name.md) and [fieldName](field-name.md).
+
diff --git a/docs/api/shark/shark/-reference-pattern/-static-field-pattern/class-name.md b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/class-name.md
new file mode 100644
index 00000000..409b2e12
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/class-name.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [StaticFieldPattern](index.md) / [className](./class-name.md)
+
+# className
+
+`val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-pattern/-static-field-pattern/field-name.md b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/field-name.md
new file mode 100644
index 00000000..54025dd4
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/field-name.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [StaticFieldPattern](index.md) / [fieldName](./field-name.md)
+
+# fieldName
+
+`val fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-pattern/-static-field-pattern/index.md b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/index.md
new file mode 100644
index 00000000..461b2100
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/index.md
@@ -0,0 +1,26 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [StaticFieldPattern](./index.md)
+
+# StaticFieldPattern
+
+`data class StaticFieldPattern : `[`ReferencePattern`](../index.md)
+
+Matches static field references, identified by [className](class-name.md) and [fieldName](field-name.md).
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `StaticFieldPattern(className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`, fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)`)`<br>Matches static field references, identified by [className](class-name.md) and [fieldName](field-name.md). |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [className](class-name.md) | `val className: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+| [fieldName](field-name.md) | `val fieldName: `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
+
+### Functions
+
+| Name | Summary |
+|---|---|
+| [toString](to-string.md) | `fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html) |
diff --git a/docs/api/shark/shark/-reference-pattern/-static-field-pattern/to-string.md b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/to-string.md
new file mode 100644
index 00000000..9ecaf1c2
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/-static-field-pattern/to-string.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [ReferencePattern](../index.md) / [StaticFieldPattern](index.md) / [toString](./to-string.md)
+
+# toString
+
+`fun toString(): `[`String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html)
\ No newline at end of file
diff --git a/docs/api/shark/shark/-reference-pattern/index.md b/docs/api/shark/shark/-reference-pattern/index.md
new file mode 100644
index 00000000..11cf754b
--- /dev/null
+++ b/docs/api/shark/shark/-reference-pattern/index.md
@@ -0,0 +1,23 @@
+[shark](../../index.md) / [shark](../index.md) / [ReferencePattern](./index.md)
+
+# ReferencePattern
+
+`sealed class ReferencePattern : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)
+
+A pattern that will match references for a given [ReferenceMatcher](../-reference-matcher/index.md).
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [InstanceFieldPattern](-instance-field-pattern/index.md) | `data class InstanceFieldPattern : `[`ReferencePattern`](./index.md)<br>Matches instances field references, identified by [className](-instance-field-pattern/class-name.md) and [fieldName](-instance-field-pattern/field-name.md). |
+| [JavaLocalPattern](-java-local-pattern/index.md) | `data class JavaLocalPattern : `[`ReferencePattern`](./index.md)<br>Matches local references held in the stack of frames of a given thread, identified by its name. |
+| [StaticFieldPattern](-static-field-pattern/index.md) | `data class StaticFieldPattern : `[`ReferencePattern`](./index.md)<br>Matches static field references, identified by [className](-static-field-pattern/class-name.md) and [fieldName](-static-field-pattern/field-name.md). |
+
+### Inheritors
+
+| Name | Summary |
+|---|---|
+| [InstanceFieldPattern](-instance-field-pattern/index.md) | `data class InstanceFieldPattern : `[`ReferencePattern`](./index.md)<br>Matches instances field references, identified by [className](-instance-field-pattern/class-name.md) and [fieldName](-instance-field-pattern/field-name.md). |
+| [JavaLocalPattern](-java-local-pattern/index.md) | `data class JavaLocalPattern : `[`ReferencePattern`](./index.md)<br>Matches local references held in the stack of frames of a given thread, identified by its name. |
+| [StaticFieldPattern](-static-field-pattern/index.md) | `data class StaticFieldPattern : `[`ReferencePattern`](./index.md)<br>Matches static field references, identified by [className](-static-field-pattern/class-name.md) and [fieldName](-static-field-pattern/field-name.md). |
diff --git a/docs/api/shark/shark/index.md b/docs/api/shark/shark/index.md
new file mode 100644
index 00000000..6b2b2564
--- /dev/null
+++ b/docs/api/shark/shark/index.md
@@ -0,0 +1,34 @@
+[shark](../index.md) / [shark](./index.md)
+
+## Package shark
+
+### Types
+
+| Name | Summary |
+|---|---|
+| [ApplicationLeak](-application-leak/index.md) | `data class ApplicationLeak : `[`Leak`](-leak/index.md)<br>A leak found by [HeapAnalyzer](-heap-analyzer/index.md) in your application. |
+| [AppSingletonInspector](-app-singleton-inspector/index.md) | `class AppSingletonInspector : `[`ObjectInspector`](-object-inspector/index.md)<br>Inspector that automatically marks instances of the provided class names as not leaking because they're app wide singletons. |
+| [HeapAnalysis](-heap-analysis/index.md) | `sealed class HeapAnalysis : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)<br>The result of an analysis performed by [HeapAnalyzer](-heap-analyzer/index.md), either a [HeapAnalysisSuccess](-heap-analysis-success/index.md) or a [HeapAnalysisFailure](-heap-analysis-failure/index.md). This class is serializable however there are no guarantees of forward compatibility. |
+| [HeapAnalysisFailure](-heap-analysis-failure/index.md) | `data class HeapAnalysisFailure : `[`HeapAnalysis`](-heap-analysis/index.md)<br>The analysis performed by [HeapAnalyzer](-heap-analyzer/index.md) did not complete successfully. |
+| [HeapAnalysisSuccess](-heap-analysis-success/index.md) | `data class HeapAnalysisSuccess : `[`HeapAnalysis`](-heap-analysis/index.md)<br>The result of a successful heap analysis performed by [HeapAnalyzer](-heap-analyzer/index.md). |
+| [HeapAnalyzer](-heap-analyzer/index.md) | `class HeapAnalyzer`<br>Analyzes heap dumps to look for leaks. |
+| [IgnoredReferenceMatcher](-ignored-reference-matcher/index.md) | `class IgnoredReferenceMatcher : `[`ReferenceMatcher`](-reference-matcher/index.md)<br>[IgnoredReferenceMatcher](-ignored-reference-matcher/index.md) should be used to match references that cannot ever create leaks. The shortest path finder will never go through matching references. |
+| [Leak](-leak/index.md) | `sealed class Leak : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)<br>A leak found by [HeapAnalyzer](-heap-analyzer/index.md), either an [ApplicationLeak](-application-leak/index.md) or a [LibraryLeak](-library-leak/index.md). |
+| [LeakNodeStatus](-leak-node-status/index.md) | `enum class LeakNodeStatus` |
+| [LeakReference](-leak-reference/index.md) | `data class LeakReference : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)<br>A single field in a [LeakTraceElement](-leak-trace-element/index.md). |
+| [LeakTrace](-leak-trace/index.md) | `data class LeakTrace : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)<br>A chain of references that constitute the shortest strong reference path from a GC root to the leaking object. Fixing the leak usually means breaking one of the references in that chain. |
+| [LeakTraceElement](-leak-trace-element/index.md) | `data class LeakTraceElement : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html) |
+| [LibraryLeak](-library-leak/index.md) | `data class LibraryLeak : `[`Leak`](-leak/index.md)<br>A leak found by [HeapAnalyzer](-heap-analyzer/index.md), where the only path to the leaking object required going through a reference matched by [pattern](-library-leak/pattern.md), as provided to a [LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md) instance. This is a known leak in library code that is beyond your control. |
+| [LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md) | `data class LibraryLeakReferenceMatcher : `[`ReferenceMatcher`](-reference-matcher/index.md)<br>[LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md) should be used to match references in library code that are known to create leaks and are beyond your control. The shortest path finder will only go through matching references after it has exhausted references that don't match, prioritizing finding an application leak over a known library leak. Library leaks will be reported as [LibraryLeak](-library-leak/index.md) instead of [ApplicationLeak](-application-leak/index.md). |
+| [ObjectInspector](-object-inspector/index.md) | `interface ObjectInspector`<br>Provides LeakCanary with insights about objects (classes, instances and arrays) found in the heap. [inspect](-object-inspector/inspect.md) will be called for each object that LeakCanary wants to know more about. The implementation can then use the provided [ObjectReporter](-object-reporter/index.md) to provide insights for that object. |
+| [ObjectInspectors](-object-inspectors/index.md) | `enum class ObjectInspectors : `[`ObjectInspector`](-object-inspector/index.md)<br>A set of default [ObjectInspector](-object-inspector/index.md)s that knows about common JDK objects. |
+| [ObjectReporter](-object-reporter/index.md) | `class ObjectReporter`<br>Enables [ObjectInspector](-object-inspector/index.md) implementations to provide insights on [heapObject](-object-reporter/heap-object.md), which is an object (class, instance or array) found in the heap. |
+| [OnAnalysisProgressListener](-on-analysis-progress-listener/index.md) | `interface OnAnalysisProgressListener`<br>Reports progress from the [HeapAnalyzer](-heap-analyzer/index.md) as they occur, as [Step](-on-analysis-progress-listener/-step/index.md) values. |
+| [ReferenceMatcher](-reference-matcher/index.md) | `sealed class ReferenceMatcher`<br>Used to pattern match known patterns of references in the heap, either to ignore them ([IgnoredReferenceMatcher](-ignored-reference-matcher/index.md)) or to mark them as library leaks ([LibraryLeakReferenceMatcher](-library-leak-reference-matcher/index.md)). |
+| [ReferencePattern](-reference-pattern/index.md) | `sealed class ReferencePattern : `[`Serializable`](https://docs.oracle.com/javase/6/docs/api/java/io/Serializable.html)<br>A pattern that will match references for a given [ReferenceMatcher](-reference-matcher/index.md). |
+
+### Exceptions
+
+| Name | Summary |
+|---|---|
+| [HeapAnalysisException](-heap-analysis-exception/index.md) | `class HeapAnalysisException : `[`RuntimeException`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-runtime-exception/index.html) |
diff --git a/docs/assets/adaptative_icon.sketch b/docs/assets/adaptative_icon.sketch
new file mode 100644
index 00000000..7978b281
Binary files /dev/null and b/docs/assets/adaptative_icon.sketch differ
diff --git a/docs/assets/icon_1024.png b/docs/assets/icon_1024.png
new file mode 100644
index 00000000..f15c7586
Binary files /dev/null and b/docs/assets/icon_1024.png differ
diff --git a/docs/assets/icon_512.png b/docs/assets/icon_512.png
new file mode 100644
index 00000000..0ca6bedf
Binary files /dev/null and b/docs/assets/icon_512.png differ
diff --git a/docs/assets/kanary-200px.png b/docs/assets/kanary-200px.png
new file mode 100644
index 00000000..ce9c9eb3
Binary files /dev/null and b/docs/assets/kanary-200px.png differ
diff --git a/docs/assets/kanary-large.png b/docs/assets/kanary-large.png
new file mode 100644
index 00000000..6bb4975c
Binary files /dev/null and b/docs/assets/kanary-large.png differ
diff --git a/docs/assets/leakcanary_shirt.psd b/docs/assets/leakcanary_shirt.psd
new file mode 100644
index 00000000..2273b193
Binary files /dev/null and b/docs/assets/leakcanary_shirt.psd differ
diff --git a/docs/assets/repository-open-graph.png b/docs/assets/repository-open-graph.png
new file mode 100644
index 00000000..86269e91
Binary files /dev/null and b/docs/assets/repository-open-graph.png differ
diff --git a/docs/assets/screenshot.png b/docs/assets/screenshot.png
new file mode 100644
index 00000000..0211a7fd
Binary files /dev/null and b/docs/assets/screenshot.png differ
diff --git a/docs/assets/shark.psd b/docs/assets/shark.psd
new file mode 100644
index 00000000..b9209a65
Binary files /dev/null and b/docs/assets/shark.psd differ
diff --git a/docs/assets/source_icon.png b/docs/assets/source_icon.png
new file mode 100644
index 00000000..d04aace6
Binary files /dev/null and b/docs/assets/source_icon.png differ
diff --git a/docs/assets/sticker.png b/docs/assets/sticker.png
new file mode 100644
index 00000000..4b08925a
Binary files /dev/null and b/docs/assets/sticker.png differ
diff --git a/docs/assets/vector_falling_canary.svg b/docs/assets/vector_falling_canary.svg
new file mode 100644
index 00000000..480d0847
--- /dev/null
+++ b/docs/assets/vector_falling_canary.svg
@@ -0,0 +1,16 @@
+<svg width="185" height="185" viewBox="0 0 185 185" fill="none" xmlns="http://www.w3.org/2000/svg">
+<g clip-path="url(#clip0)">
+<path d="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109" stroke="#151C1F" stroke-width="4.257" stroke-linecap="round"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z" fill="#F5BD14"/>
+<path d="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z" fill="#F86932"/>
+<circle cx="45.3062" cy="70.8628" r="35.1642" transform="rotate(-33.8126 45.3062 70.8628)" fill="#FFCC32"/>
+<path d="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342" stroke="#151C1F" stroke-width="4.257" stroke-linecap="round"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z" fill="#FFCC32"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z" fill="#FFCC32"/>
+</g>
+<defs>
+<clipPath id="clip0">
+<rect width="185" height="185" fill="white"/>
+</clipPath>
+</defs>
+</svg>
diff --git a/docs/assets/vector_icon.afdesign b/docs/assets/vector_icon.afdesign
new file mode 100644
index 00000000..a30fcf97
Binary files /dev/null and b/docs/assets/vector_icon.afdesign differ
diff --git a/docs/assets/vector_icon.svg b/docs/assets/vector_icon.svg
new file mode 100644
index 00000000..9a17f0dc
--- /dev/null
+++ b/docs/assets/vector_icon.svg
@@ -0,0 +1,6 @@
+<?xml version="1.0" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
+    <image id="Container" x="33" y="44" width="443px" height="441px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbsAAAG5CAYAAAAXoZoVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAcMklEQVR4nO3dT4gkZ/nA8Wd6Zmc3mw1ZXEmCfxJCfgZJMDEHwaiRmEsQEolBAkET0Jw96CEXQQRFDyKePOXgIRhFBFFEzCFBEzRIFj0kIaJBCQZB8mezJG522Z3q38Gttqamqrq6u7q76u3PB4bu6Z3p6V525rvPW2/1bI3H4wCAlO2s+wF0YazYAEu1tbW1te7HsIitvnZi1oD19XkADF3bzvU5iL2KXVPg+vQ4Afivur71LXxrjd08cZv1dgDm0xCymT9v3fFbS+zqIld1c/E2oQNYraZGFf+sbRjXFb2Vxq4cuVnill+f9jkAdKdmSqv98/z9utsL7680eiuJ3bTINUWtTfAEEGBxbaazadfrLuu+xqqit9TYtY1c02Xx+iuvvBJ///vf44033ojXX39939upU6fi/PnzS3suAJvm6NGj8a53vStOnDhx4O2GG26Iyy67bF/UpgVvykS41OgtLXbF0LWJXPn6eDyOLMvixRdfjD/84Q/xzDPPxCuvvLKUxwrAbLa3t+PGG2+MW2+9NT7+8Y/HVVddVRu+ttFbZvCWEru60E2LW/7+yZMn46mnnoo//vGPcerUqc4fHwDduvbaa+NjH/tY3HHHHfH+97//QOzaRm9Zwes8dk2hqwpc8e2FF16IRx55JF588cVOHxMAqzEajeLOO++MBx54IE6cOHEgdnVTX/5+4Xqn0es0dnnoZo3cyy+/HD/84Q/jmWee6eyxALA+hw8fjnvvvTfuu+++OHr0aG30Wmxo6SR6ncWuKXTF4GVZNnn/9ddfj0cffTQef/zxyLKsk8cBQH9cfvnlcf/998fdd98dOzs7MRqN1jLldRK7cuiaJrk8di+88EJ885vfjDfffHPhrw9Av910003xta99LS6//PLK4LU4prdQ8BaOXVXoyteL01yWZfH444/HD37wA6cKAGyQq666Kr7xjW/ENddcsy94xesR1Ts4L16fO3gLxa4pdOXAjcfjuHDhQjzyyCPxi1/8Yu6vCcBwXXLJJfHwww/HRz/60QOhy9+P6D54c8euLnRVy5ZZlsXbb78d3/nOd+JPf/rTXF8PgDSMRqN48MEH47777psErjzpRXQbvLli1yZ0eeTG43GcPXs2Hn744fjb3/4289cCIE33339/fOELX5jEboZjeTPHbjTrJ0wLXR65/G1vby++//3vCx0A+/zkJz+Jp59+el8zql5opGLz48xT2kyxaxO6cvB++tOfxlNPPTXr4wIgcePxeDIMlQelvCX5x5WDN6vWsWuz67IYur29vXjmmWfi0UcfneuBAZC+c+fOxbe+9a14/fXXY29v78B0V3cO9qzT3czLmGVV01yWZfGPf/wjvve9781dYQA2w2uvvRbf/va349y5c5PglaO36HJmq9i13XmZR+/8+fPx3e9+N86ePTvjUwZgE/3lL3+Jxx57rHI5s4vgzbKMObms25Syt7cXe3t78cQTT8Q///nPmZ8sAJvrV7/6Vbz66qv7pru6jSuzmhq7umpWLV1mWRZnz56Nxx57bK4HA8DmOnfuXPz4xz9unOwiKl+acmoBG2NXt3xZdQAxn+x++ctfxhtvvLHI8wVgQz355JPx8ssvVwYvovp3oLZRG7um43TF94uhO336dPz85z9f4GkCsMmyLItHH320cikzD1+VadPdPCeVVz6ALMviZz/7WZw5c2bWuwSAiZMnT8YLL7xQu5xZNe1N03Y3Zu3GlPzy3Llz8cQTTyz2DAEgIn7zm9/UblKJ2H+ud65pupt2zO7A+3U7MZ977rl455135n5iAJD785//HOfOnTvwiirTNqvUqYxdsY5NU13x7dlnn+3sSQKw2c6cORPPP//8zKcf1E13TRtUDrxftwPzwoULcfLkyXmfEwAc8Oyzzx54RZWmE82bHIhduYrTjtVlWRYvvfRSnDp1qsOnCMCmO3ny5NRXVClqOu+u1TE7S5gArNqpU6fipZdeqvxtCAtNduVz66quF79I/sWff/75zp4cAOSee+65A92JmP3k8rkmu/JS5muvvdbFcwKAfV577bXaya5K3e1TN6hM24l54cKFePvttzt4SgCw36lTpxo3pjQcv9t3Q9UGlcovWBe9U6dO1f5yPQBYxOnTpw9siqwLXdNS5iR2bXZhVk13dmECsCz5QDXvKQe5upPKay/L46TYAbAsp0+frvzt5RHVQ1l+e1mb32d34LI42fl1PgAsS/4bdeZZuiyuWJZPPaj7hNr10rfeemumURIA2sjbknemKXjT4je6+IeVx+uK18vn2816jgMAzKrq/O7OjtkVv0j5/brz7QCgK3UDVvH9qo+r0+qYXdOOTABYhmLQyptT8tvbrjI2nlRe9UnlOy4Gz4QHQNfqdl+2+Zxcq5PKpx0QBIBlatpL0mZH5kynHtSdhgAAy9IUtrYNmhq7ui8qdACsUlN7Fj6pvOmLAsCyNZ0C19bUUw+6GB8BoAvzrio2vjZm1W2WLwFYpabuzH3MziuiANB3bU8mzxV/xU/ndw4AXVnkUNpcG1SEDoB1mLc/c+/GXOSLAsAsFu1NqxeCFjUA1qWLMwFaT3ZVr54CAKuySHcWWsYEgCEQOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTO4ABGI/H634IgyZ2AAMwHo8jy7J1P4zBEjuAARG8+YgdwMAI3uzEDqDnqo7XCd5sxA5goASvPbED6LmmnZiC147YAQyc4E0ndgA91vb8OsFrJnYAiRC8emIHkJAsy7zaSgWxA+ixecI1Ho8Fr0TsABIkePuJHUBPLRorwfsfsQNImOD9l9gB9FRXkRI8sQPYCJsePLED2BCbHDyxA+ihZUVpU4MndgAbZhODJ3YAPbTsGG1a8MQOYENtUvDEDqBnVhmgTQme2AFsuE0IntgB9Mw6wpN68MQOgIhIO3hiB8BEqsETO4Ae6UNoUgye2AFwQGrBEzsAKo3H48iybN0PoxNiB9AjfZymUgie2AEw1dCDJ3YAPdHHqa5oyMETOwBaG2rwxA6AmQwxeGIH0BN9X8YsGlrwxA6AuQwpeGIHwNyGEjyxA+iBIS1hlg0heGIHwML6HjyxA+iBIU92uT4HT+wA6Exfgyd2AHQqy7LeTapiB7BmfQtDF/r2K4LEDoCl6FPwxA6ApelL8MQOYM36EINl6kPwxA6ApVt38MQOYI3WPfGs0jqDJ3YArMy6gid2AKzUOoIndgBrtEnLmEWrDp7YAbAWqwye2AGwNqsKntgBrMmmLmGWrSJ4YgfA2i07eGIHsCYmu/2WGbydpdwrAMxB7ADYCMsInmVMgDWwhNms6yVNkx0AvZTHrovomewA6K3xeBx7e3sL34/YAayBZczVEjsAkid2ACRP7ABWzBLm6okdAMkTOwCSJ3YAK2YZc/XEDoDkiR3ACpnq1kPsAEie2AGQPLEDWCHLmOshdgAkT+wASJ7YAayIJcz1ETsAkid2ACRP7ABWxDLm+ogdAMkTO4AVMNWtl9gBkDyxAyB5YgewApYx10vsAEie2AGQPLEDWDJLmOsndgAkT+wASJ7YASyZZcz1EzsAkid2ACRP7ACWyBJmP4gdAMkTO4AlMtn1g9gBkDyxAyB5YgewJJYw+0PsAEie2AGQPLEDWBLLmP0hdgAkT+wASJ7YASyBJcx+ETsAkid2AEtgsusXsQMgeWIH0DFTXf+IHQDJEzsAkid2AB2zjNk/YgdA8sQOoEOmun4SOwCSJ3YAJE/sADpkGbOfxA6A5IkdQEdMdf0ldgAkT+wASJ7YAXTEMmZ/iR0AyRM7gA6Y6vpN7ABIntgBkDyxA+iAZcx+EzsAkid2AAsy1fWf2AGQPLEDWJDJrv/EDoDkiR3AAkx1wyB2ACRP7AAWYLIbBrEDIHliBzAnU91wiB0AyRM7gDmZ7IZD7ABIntgBzMFUNyxiB0DyxA5gDia7YRE7AJIndgAkT+wAZmQJc3jEDoDkiR3AjEx2wyN2ACRP7ABmYKobJrEDIHliBzADk90wiR0AyRM7gJZMdcMldgAtid1wiR0AyRM7gBZMdcMmdgAkT+wAWjDZDZvYAUwhdMMndgAkT+wApjDZDZ/YATQQujSIHQDJEzuABia7NIgdAMkTO4Aaprp0iB1ADbFLh9gBkDyxA6hgqkuL2AGQPLEDqGCyS4vYAZQIXXrEDoDkiR1AickuPWIHUCB0aRI7AJIndgAFJrs0iR3ARUKXLrEDuEjs0iV2ACRP7ADCVJc6sQMIsUud2AEbT+jSJ3YAJE/sgI1nskuf2AEbTeg2g9gBG03sNoPYARtL6DaH2AGQPLEDNpbJbnOIHbCRhG6ziB2wkcRus4gdsHGEbvOIHbBxxG7ziB2wUYRuM4kdsFHEbjOJHbAxhG5ziR2wMcRuc4kdsBGEbrOJHbARxG6ziR2QPKFD7ABIntgByTPZIXZA0oSOCLEDEid2RIgdkLAsy9b9EOgJsQOSZKKjSOyAJIkdRWIHJEfoKBM7IDliR5nYAUkROqqIHZCM8XgsdlQSOyAZQkcdsQOSIHQ0ETsgCWJHE7EDBs8rpTCN2AGDZqKjDbEDBk3saEPsgMGyfElbYgcMkomOWYgdMEhixyzEDhgcy5fMSuyAQTHRMQ+xAwbDa18yL7EDBkPomJfYAYPgOB2LEDug94SORYkd0GuWLumC2AG9ZUMKXRE7oJeEji6JHdBLQkeXxA7oHRtS6JrYAb0idCyD2AG9IXQsi9gBvSB0LJPYAWsndCyb2AFrJXSsgtgBayN0rMrOuh8AsHmcMM6qmeyAlRI61kHsgJUROtbFMiawEo7PsU4mO2DphI51M9kBS2PZkr4w2QFLIXT0ickO6JTI0UcmO6AzQkdfmeyAhYkcfSd2wELstGQIxA6Yi2mOIRE7YCYixxCJHdCKyDFkYgc0EjlSIHasXJZlsbW1FRExuaR/RI6UiB0rNxqNJjv48h+m4tcfIkeKxI612Nra2vcDNb9ejJ/wrY7AkTqxYy3ykNX9gC3+8DX1LUf5PxiQMrFjbaYFL1c19ZXvg/ZMcWwisWOt2gavqGr5UwDrmeBA7OiBeYJXJoD/I25wkNjRC10Er2xaAKveH5qq5wgcJHb0xjKCV1a+7/L7fYzhtMcMTCd29Er5lIRVaxuWZUZQzKB7YkfvFE867ytBgmHxm8rppdHIP02gO36i0FuCB3TFTxN6TfCALvhJQu/1YUckMGxiR+95UWhgUWLHIAgesAixYzAED5iX2DEoggfMQ+wYHMEDZiV2DJLYAbMQOwbLOXhAW35aMGiCB7ThJwWDJ3jANH5KkATBgzR19RtGOvkJMR6P/coT1k7wgDoL/3QQOfrELk1ITxedETuS4hw8SEfely6+p2f+TeX5F80vd3d3DwTPDxvWKf/35z9iMEzlQ2NHjx5d+D4bJ7titOoCdvz48YUfBHTNhAdpGI/HnXSm1TJm0w+N48eP26BCLwkeDN9oNIqdnf8uQi7y/bzQMbutra1J7CIsG9E/ggfDlA9R29vbB76H5/menil25eN1Ef9bxiwGT/ToE7GD4Sg2ZDwex+7ubkQs/n0892SXf+FDhw7FkSNHRI5ecw4eDEfek/F4HIcPH+7kPg/8BKia3qY5duxYZFkmePSa4EH/Fae6LMv27cRc5LDE5Lu/audl8Y7z6+UvtrW1FVdfffXkgRWLDH0jeNBfeTeyLJv05IMf/GDtx88Svrl3Yxajd8stt+yLnNDRZ4IH/VXuyJ133lk7jJVvazLzd33VtHfjjTfGzs7OvhoLHn1m0wr0S3lgyrIsLrvssrjkkksioj5ubb+Xp8auakmzfPvu7m584AMfOPBgBY++ckoC9E+5HzfccMOBASs36/fwzMuYdcfxbr755kmNTXcMgeBBP5Qnurwhd9111+Rj6vaNlP88v14208uFFd8fjUb73r/lllsiIg7ETvDoM8GDfijH7vDhw3HixInGwEV0sIzZtD5anuxGo1EcO3Ysrr/++skDNd0xFIIH61McjPb29ib9+NCHPhQRBye6qgmvaQPL1sUrtefZVX3itLd77rknIv473eUPWvAYAsGD9SlOdFmWxWg0igcffHCygjjtFLj8z5qMLn5Q5Ue1CV3xwVx99dVx880373vQgsdQCB6sVnnpMn+7/fbbY2dnp7Y1uaYJr2zfZFd3MnnVHRe/8Gg0mrz/2c9+Nkaj0b7pLg8e9J3YwWqUQ5f34vDhw3HvvfdWtqZpKXOa1rsxq0JXFbwTJ07ErbfeeuAJmO4YCiedw/IVY1fsxF133XVgiKoL3iym7sactpRZfkCj0SjuuuuuOHLkyIHgmfAYCsGD5akKXZZlcezYsbj99ttbha7NZpWi4mtjbhWuR/F6U+TKoct3Zt5zzz2T3TX5m+AxJIIH3SsvXeZvEREPPfTQvpZU9WWWwBW71njqQd0xvKoHUH679dZb47bbbjvwhCxpMiSCB92pCl3ehM985jNx3XXX1TalzUTXFL+ppx7s++DSMbppwbvnnnvi+uuvPzDhFZ8g9J1NK7C4uokuy7L48Ic/HJ/61Kcae1IVvogOTyov17NqU8r29nZsb2/vu769vR07OzvxxS9+Md797ndXPkHBYwickgDzq9p1WezAlVdeGQ888EBlT+qO3eUrLrMEr3zqwVbp/amnGxTfqh7kJZdcEg899NBkw8re3l5cuHBB9BgUwYPZTQvdkSNH4itf+cq+IanclLrJru6E81y5Z5WTXdU3dfmYXV3sytPdaDSKK664Ir70pS/FpZdeOnmiefAuXLjgtTQZBMGD9so7Li9cuDB5y0P31a9+NXZ3d/c1o9yPcgSrljDLmyqrtHoh6KolzDbLmMW3a6+9Nr785S/HVVdddWDCK056gkefCR40K09yxcjlP+OvuOKK+PrXvx4nTpyobUbdcmbVSmPE9KXMrXJYxhdvyG+vezmX4oSWv50/f37fW/G2/Pq5c+fiRz/6Ubz44osHgrnoAUhYFf8pg/9p04v89ptuuik+//nPx87OTuzs7MShQ4cml8W34m07OzuTfSBVS5s1097+w3JV37DF4FX9nqHiiYDF2FXFrer63t5ePP744/G73/0uxuNx662mxScC6yZ4bLJi4PLL/JBU3YuJfPrTn45PfvKTk9CVg1YVu/zjyhNf1QnnEZPVlwOh2Jn2hOpOMB+NRvtCtb29HVmWxfb29r44lq/n7rzzznjPe94Tv/71r+PNN9+cfEzTQUjRo2/KsVvVv0uRZV2qIlc1zRV//h87dizuv//+uO666/aFrhixqqDVDUER1b8Boen7r3Kyu/gExuUn07SzpmrCq7osr9+eP38+fv/738fTTz8dZ86cqTwmWF6jLT4p0WPdsiw7cNss/y6FiyGoi1x5oitGbnd3N+6444647bbb9gWtagmzPMnVLV/WTXVNOzEjpsSu6olVjal1wSsvX1a95Z979uzZePLJJ+PZZ5+N8+fP5w+41XQnfKxbVfBg6MqBy69PexuNRvGRj3wk7r777srzr8tBqwpeOY7FvR1NG1SqQhfRInZ1T65us0rTlNcUu/x+Tp8+Hb/97W/jr3/9a5w+fbr2pWBm2XIKq2BCY+hq9nBMvcyv7+7uxv/93//F5z73uX2nFIxGowNTXTl2VaErLm222c9RF7qIhthdfBKV013T7sxi7PLrdbErfnz5tdKyLIt//etf8dxzz8VLL70Ur776aozH48a4iR3rZsIjReXJLre1tRWXXnppXHfddfGJT3wirrzyysoXGilPdfn1cuzKf15cuqyLXf44Ll7WRqBxg8rW1tbWeDweb21tVYam+CK5xSBub2/vu738ufnnFx9slmWT9/PYve9974v3vve9kWVZvPnmm/H888/Hv//97/jPf/4Tb7/9dpw5cybeeeedyStmQx+Y8PzHMzWHDh2Ko0ePxtGjR+PYsWNx2WWXxTXXXBM33HBDHDp0qPbFRupiV/fWZnPKvJsVGye7iNmWM8sTXtWUV/V+eSmz/Mv8ipcR//vfc/7Q3nrrrTh9+vTkXI6K59DqLwO6UPXvcJYf/rMszYsKXakaSI4cORLHjx+P3d3dykNJxWNnTS8fWXUMrs2uzGmxm7YppWjqqQfT/kKK013bzys/2PyJ7O3t7bssb2HNL/OvmQf3+PHjcfnll0/uX9wAFtO0EXBa7KpeVaspeMWPaTPRVYR56v/62pxnt5VPd1XLmfn7VUuadX9xTX9J+bl2VedrlF9Dc9qBUwBmV7cBsOqt/HO8OJHl8aqb3KpCV/U6mFN247da3mg12TUFLw9T/mfTJr3yX9CisWsKnegBtFe3hF6MTP4zvnwKQNMSZjl4dUuW5dAVL2seb+t1/NbLmMXglZUjVfXAmv5XUPwL2tvbm1xWnYnfdrorEj2AZlXdqDtOV/czfNpSZtUUV7fjsuo8ulk3pRTNdMyubndmfhwtD115a+rW1lbs7e21Cl1+P/nLj9UFL/+65ejltxeJHUCzqg0q+WXT8bq6ya4ueOX4lT+nvPJXt3w5q5k3qBT/IuqCF1G9caX8wIuvhZmHLo9c+UVEy8ErT3WWMQEWN+/xuvyyKmDTLquWLqeFbpYlzIj5dmNuRfz3lIS2wav7i8oDVjxel7+VJ7umY3Y2qAB0p2ITyIHrdfsuqia8umXKNrsuuwhdxAKTXfEvpSp4VRGqi13dppSqJcy6pczi15nyqjCLPmWAQZvWirbTXdMmlbZvVeEsfr2KxzHXOubUk8qnqXpJsfyyHKaqKa0pblWhm2eDSuGxLvRcAVIxa/CmLWVWxW7abVX3Ufxa5cc5b+giOpjsCg+i8mXBImIy6eVPKP+44kuEFSe7cgyrohlxcKqzMQVgfk2bVPLLWSa8utvaHpvrKnQR3Sxj7juGd/H6gfG3ahorhq94vK9qils0dMIHUK0ucsXrs054VZfFZcqmaa7iMSz8unidTXZFVcfxqp5EHqliDIvBKx77swuTFJT/bXbwPQxLUTdl1U1jVZNa06aTVYYuooNjdmXjwh2WA1QVqbpz5preive9yPKlKAKbpm07Zpnuqm6bthu/+Gd1j62r0EUsIXYR9cHL36+bzOomt2nTXNVzEDKA+bQ5dpdfNgWv7rbi7VVfs8vITe5zWVEYV9xx06RXvK3NRDht96XYAcynqjU1m0Yqp7Sm61X3Ubi+tHX9pcUuV45e06TX9v3y/diMAtCtWTetlC+bPr7mPpd6AHvpscu1mfTa3NZ0e9X9AjC7pumu6s/nCVzhtqXv1FpZ7HJtJr26P2vz523+DICD2jRnWvCabq+4r5VtR1557HLTJr2m29s8ZrEDmM0s7ZkWtKb7WmXkJl9z3VGoil7hz5o+b9r9zv+gADbQtAbNOvkVblv7CaVrj13ZvPEDYHVahm/tkcv1LnZlTfEDoD/6FLey3seujggCrFafYzbNYGMHAG39P8QjHPIeCPK8AAAAAElFTkSuQmCC"/>
+    <path id="Canary Badge" d="M112.189,145.49L254.837,81.3501L396.288,145.49C396.288,145.49 396.862,207.984 396.288,231.803C400.997,350.37 312.745,416.946 254.837,430.897C196.973,416.761 109.794,350.592 112.189,231.803C112.756,203.667 112.189,145.49 112.189,145.49ZM175.089,342.14C175.089,342.14 184.466,327.557 200.474,320.28C204.922,315.034 207.831,307.409 215.292,300.115C219.468,296.033 226.552,291.174 233.166,288.656C239.785,286.137 247.648,284.843 255,285C262.352,285.157 268.152,286.319 277.281,289.599C300.356,298.133 328.246,333.945 334.028,349.404C315.038,361.253 296.986,374.343 277.281,397.842C273.2,395.993 262.831,392.31 245.929,394.232C225.332,398.578 205.605,369.407 206.507,353.455C194.408,348.947 175.089,342.14 175.089,342.14ZM239.502,332.155C236.224,332.127 234.144,330.44 233.732,328.884C233.319,327.329 235.679,323.517 237.026,322.821C244.051,319.192 251.916,319.735 251.916,319.735C251.916,319.735 254.299,332.28 239.502,332.155ZM238.929,221.803L270.281,221.803L270.281,254.418L238.929,254.418L238.929,221.803ZM238.929,136.356L270.281,136.356L270.281,205.834L238.929,205.834L238.929,136.356Z" style="fill:rgb(253,237,0);"/>
+</svg>
diff --git a/docs/changelog.md b/docs/changelog.md
index e315d1da..64ebfcf5 100644
--- a/docs/changelog.md
+++ b/docs/changelog.md
@@ -1,8 +1,61 @@
 # Change Log
 
-## Version 2.0 Alpha 3 (2019-07-04)
+## Version 2.0 Beta 3 (2019-08-22)
+
+LeakCanary 2 is in **beta**: the internals and APIs are mostly stable.
+
+Now is a great time to adopt it and provide feedback before the stable release. We're counting on you to find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/). 
+
+* Baseline memory usage for large hprofs divided by 3 and removed memory spikes [#1543](https://github.com/square/leakcanary/pull/1543)
+* Fixed crash when LeakCanary is initialized from another process [#1529](https://github.com/square/leakcanary/issues/1529)
+* Java local references are deprioritized to look for longer alternative paths [#1525](https://github.com/square/leakcanary/pull/1525)
+* Fixed `JavaLocalPattern` not matching on Lollipop [#1524](https://github.com/square/leakcanary/pull/1524)
+
+Many thanks to
+[@Armaxis](https://github.com/Armaxis),
+[@elihart](https://github.com/elihart),
+[@emartynov](https://github.com/emartynov),
+[@hmcgreevy-instil](https://github.com/hmcgreevy-instil),
+[@pyricau](https://github.com/pyricau)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-3 Milestone](https://github.com/square/leakcanary/milestone/11) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-2...v2.0-beta-3).
+
+## Version 2.0 Beta 2 (2019-08-02)
+
+* Fixed *Leak analysis failed: Object id not found in heap dump.* [#1516](https://github.com/square/leakcanary/issues/1516)
+* 10x speed increase of hprof indexing on large heap dumps [#1520](https://github.com/square/leakcanary/pull/1520)
+
+Many thanks to
+[@kolphi](https://github.com/kolphi),
+[@pyricau](https://github.com/pyricau),
+[@ZacSweers](https://github.com/ZacSweers)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-2 Milestone](https://github.com/square/leakcanary/milestone/10) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-1...v2.0-beta-2).
+
+## Version 2.0 Beta 1 (2019-07-30)
+
+* New standalone library! [Shark](shark.md) is the heap analyzer that powers LeakCanary 2, and it can run in any Java VM. It comes with a [CLI](shark.md#shark-cli): you can now run `shark-cli analyze-process com.example.myapp` from your computer.
+* New Heap Explorer directly on device! Open a Heap Analysis in LeakCanary, tap the options menu and select "Heap Explorer". This is still experimental and not very user friendly, contributions welcome!
+* **Large API rewrite** to improve usability. If you used the alpha with a customized configuration, there are breaking changes. Of note: LeakSentry became [AppWatcher](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/), RefWatcher became [ObjectWatcher](/leakcanary/api/leakcanary-object-watcher/leakcanary/-object-watcher/), AndroidExcludedRefs became [AndroidReferenceMatchers](/leakcanary/api/shark-android/shark/-android-reference-matchers/), AnalysisResultListener became [OnHeapAnalyzedListener](/leakcanary/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/), AndroidLeakTraceInspectors became [AndroidObjectInspectors](/leakcanary/api/shark-android/shark/-android-object-inspectors/).
+* The entire API surface is now documented and the documentation is available on this website: see the **LeakCanary API** tab at the top.
+* Removed the **dependency on Android X**. No more configuration issues! [#1462](https://github.com/square/leakcanary/issues/1462) 
+* Added **Proguard rules** for LeakCanary and ObjectWatcher. [#1500](https://github.com/square/leakcanary/pull/1500) 
+* Display LeakCanary version in the About screen. [#1448](https://github.com/square/leakcanary/issues/1448) 
+* Bug fixes, new reference matchers and object inspectors
 
-**Thanks for testing the alpha**, we're counting on you to help us find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/). 
+Many thanks to
+[@arctouch-carlosottoboni](https://github.com/arctouch-carlosottoboni),
+[@jemaystermind](https://github.com/jemaystermind),
+[@kushagrakumar27](https://github.com/kushagrakumar27),
+[@pyricau](https://github.com/pyricau),
+[@snkashis](https://github.com/snkashis)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-1 Milestone](https://github.com/square/leakcanary/milestone/9) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-3...v2.0-beta-1).
+
+## Version 2.0 Alpha 3 (2019-07-04)
 
 * [#1401](https://github.com/square/leakcanary/pull/1401) LeakCanary can now import all hprof files created from prior LeakCanary versions.
 * [#1414](https://github.com/square/leakcanary/pull/1414) New API: `RefWatcher.retainedInstances` which returns the instances that are currently considered retained.
@@ -58,7 +111,7 @@ For more details, see the [2.0-alpha-2 Milestone](https://github.com/square/leak
 
 ## Version 2.0 Alpha 1 (2019-04-23)
 
-<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0-200px.png" />
+![logo](images/logo-2.0-200px.png)
 
 * New [logo](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo), thanks [@flickator](https://github.com/flickator)!
 * Entirely rewritten to **100% Kotlin**
diff --git a/docs/contributing.md b/docs/contributing.md
deleted file mode 100644
index 7b4fb258..00000000
--- a/docs/contributing.md
+++ /dev/null
@@ -1,8 +0,0 @@
-# Contributing
-
-If you would like to contribute code to LeakCanary you can do so through GitHub by
-forking the repository and sending a pull request.
-
-When submitting code, please make every effort to follow existing conventions
-and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `./gradlew build`.
diff --git a/docs/dev-env.md b/docs/dev-env.md
new file mode 100644
index 00000000..d636ae06
--- /dev/null
+++ b/docs/dev-env.md
@@ -0,0 +1,16 @@
+# Dev Environment for LeakCanary contributors
+
+## Setup
+* Download [Android Studio](https://developer.android.com/studio)
+* We use two spaces code indentation, use `SquareAndroid` code style settings from https://github.com/square/java-code-styles
+* Build with `./gradlew build`
+* Running the failing UI tests to confirm leak detection correctly fails UI tests: `./gradlew leakcanary-sample:connectedCheck`
+* Normal UI tests: `./gradlew leakcanary-support-fragment:connectedCheck`
+
+
+## Static Code Analysis 
+* LeakCanary [uses](https://github.com/square/leakcanary/pull/1535) tool [Detekt](https://arturbosch.github.io/detekt/) for static Code analysis
+* Analyze whole project with `./gradlew check` or particular modules with `./gradlew :module-name:check`. Detekt will fail the build if any ruleset violations are found. **You should fix all issues before pushing the branch to remote**.
+  * There's also a **git pre-push** hook that will run analysis automatically before pushing branch to remote. If there are any violations - it will prevent the push. Fix the issues!
+  * You can bypass the git hook though; Travis CI will still run checks and will fail if any violations are found. 
+* Detekt report will be printed in console and saved to `/moduleDir/build/reports/
diff --git a/docs/faq.md b/docs/faq.md
index b5e4d21e..5838b19d 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -2,16 +2,16 @@
 
 ## Can a leak be caused by the Android SDK?
 
-Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt).
+Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidReferenceMatchers](/leakcanary/api/shark-android/shark/-android-reference-matchers/).
 
 If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
 
 1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
-2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions by switching branches on the GitHub mirror: [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
 3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
 4. If it's still happening, build a simple repro case.
 5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case.
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+6. Create a PR in LeakCanary to update [AndroidReferenceMatchers](/leakcanary/api/shark-android/shark/-android-reference-matchers/). Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
 
 ## How do I share a leak trace?
 
@@ -32,6 +32,10 @@ Here's how you can find the leaking instance in the heap dump:
 4. The `referent` field of that `KeyedWeakReference` is your leaking object.
 5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
 
+## How does LeakCanary get installed by only adding a dependency?
+
+On Android, content providers are created after the Application instance is created but before Application.onCreate() is called. The `leakcanary-object-watcher-android` artifact has a non exported ContentProvider defined in its `AndroidManifest.xml` file. When that ContentProvider is installed, it adds activity and fragment lifecycle listeners to the application.
+
 ## How many methods does LeakCanary add?
 
 **0**. LeakCanary is a debug only library.
@@ -42,7 +46,7 @@ Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://gith
 
 ```gradle
  dependencies {
-   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-4-SNAPSHOT'
+   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-4-SNAPSHOT'
  }
 ```
 
@@ -74,5 +78,5 @@ The name **LeakCanary** is a reference to the expression [canary in a coal mine]
 * [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
 
 <p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
+<img src="../images/logo-2.0.png" />
 </p>
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
index 8c76ccba..ba6771bb 100644
--- a/docs/fundamentals.md
+++ b/docs/fundamentals.md
@@ -10,7 +10,7 @@ For example, an Android activity instance is no longer needed after its `onDestr
 
 Most memory leaks are caused by bugs related to the lifecycle of objects. Here are a few common Android mistakes:
 
-* Storing an Activity context as a field in an object that survives activity recreation configuration changes.
+* Storing an Activity context as a field in an object that survives activity recreation due to configuration changes.
 * Registering a listener, broadcast receiver or RxJava subscription which references an object with lifecycle, and forgetting to unregister when the lifecycle reaches its end.
 * Storing a view in a static field, and not clearing that field when the view is detached.
 
@@ -24,17 +24,17 @@ When we first enabled LeakCanary in the Square Point Of Sale app, we were able t
 
 ### Detecting retained instances
 
-The foundation of LeakCanary is a library called LeakSentry. LeakSentry hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to a `RefWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc.
+The foundation of LeakCanary is a library called ObjectWatcher Android. It hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to an `ObjectWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, for example a detached view, a destroyed presenter, etc.
 
 If the weak references aren't cleared after waiting 5 seconds and running the garbage collector, the watched instances are considered *retained*, and potentially leaking.
 
 ### Dumping the heap
 
-When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
+When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored onto the Android file system. The default threshold is 5 retained instances when the app is visible, and 1 retained instance when the app is not visible.
 
 ### Analyzing the heap
 
-LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected: the **leak trace**. Leak trace is another name for the *shortest strong reference path from garbage collection roots to retained instances*. Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below [How do I fix a memory leak?](#how-do-i-fix-a-memory-leak)).
+LeakCanary parses the `.hprof` file using [Shark](shark.md) and finds the chain of references that prevents retained instances from being garbage collected: the **leak trace**. Leak trace is another name for the *shortest strong reference path from garbage collection roots to a retained object*. Once the leak trace is determined, LeakCanary uses its built-in knowledge of the Android framework to deduct which instances in the leak trace are leaking (see below [How do I fix a memory leak?](#how-do-i-fix-a-memory-leak)).
 
 ### Grouping leaks
 
@@ -113,7 +113,7 @@ At the top of the leak trace is a garbage-collection (GC) root. GC roots are spe
 is true)
 ```
 
-At the bottom of the leak trace is the leaking instance. This instance was passed to `RefWatcher.watch()` to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.
+At the bottom of the leak trace is the leaking instance. This instance was passed to [AppWatcher.objectWatcher](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/) to confirm it would be garbage collected, and it ended up not being garbage collected which triggered LeakCanary.
 
 ### Chain of references
 
@@ -143,17 +143,19 @@ The chain of references from the GC root to the leaking instance is what is prev
     ‚îÇ    View.mWindowAttachCount=1
 ```
 
-LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. You can customize this behavior and add your own heuristics by updating `LeakCanary.Config.leakTraceInspectors`.
+LeakCanary runs heuristics to determine the lifecycle state of the nodes of the leak trace, and therefore whether they are leaking or not. For example, if a view has `View#mAttachInfo = null` and `mParent != null` then it is detached yet has a parent, so that view is probably leaking. In the leak trace, for each node you'll see `Leaking: YES / NO / UNKNOWN` with an explanation in parenthesis. LeakCanary can also surface extra information about the state of a node, e.g. `View.mWindowAttachCount=1`. LeakCanary comes with a set of default heuristics: [AndroidObjectInspectors](/leakcanary/api/shark-android/shark/-android-object-inspectors/). You can add your own heuristics by updating [LeakCanary.Config.objectInspectors](/leakcanary/api/leakcanary-android-core/leakcanary/-leak-canary/-config/object-inspectors/) (see the [recipe](recipes.md#identifying-leaking-objects-and-labeling-objects)).
 
 ### Narrowing down the cause of a leak
 
 ```
     ‚î¨
-    ‚îú‚îÄ leakcanary.internal.InternalLeakCanary
-    ‚îÇ    Leaking: NO (it's a GC root and a class is never leaking)
-    ‚îÇ    ‚Üì static InternalLeakCanary.application
+    ‚îú‚îÄ android.provider.FontsContract
+    ‚îÇ    Leaking: NO (ExampleApplication‚Üì is not leaking and a class is never leaking)
+    ‚îÇ    GC Root: System class
+    ‚îÇ    ‚Üì static FontsContract.sContext
     ‚îú‚îÄ com.example.leakcanary.ExampleApplication
     ‚îÇ    Leaking: NO (Application is a singleton)
+    ‚îÇ    ExampleApplication does not wrap an activity context
     ‚îÇ    ‚Üì ExampleApplication.leakedViews
     ‚îÇ                         ~~~~~~~~~~~
     ‚îú‚îÄ java.util.ArrayList
@@ -162,13 +164,13 @@ LeakCanary runs heuristics to determine the lifecycle state of the nodes of the
     ‚îÇ                ~~~~~~~~~~~
     ‚îú‚îÄ java.lang.Object[]
     ‚îÇ    Leaking: UNKNOWN
-    ‚îÇ    ‚Üì array Object[].[0]
+    ‚îÇ    ‚Üì array Object[].[1]
     ‚îÇ                     ~~~
     ‚îú‚îÄ android.widget.TextView
-    ‚îÇ    Leaking: YES (View detached and has parent)
+    ‚îÇ    Leaking: YES (View.mContext references a destroyed activity)
     ‚îÇ    ‚Üì TextView.mContext
     ‚ï∞‚Üí com.example.leakcanary.MainActivity
-    ‚Äã     Leaking: YES (RefWatcher was watching this and MainActivity#mDestroyed is true)
+    ‚Äã     Leaking: YES (TextView‚Üë is leaking and Activity#mDestroyed is true and ObjectWatcher was watching this)
 ```
 
 If a node is not leaking, then any prior reference that points to it is not the source of the leak, and also not leaking. Similarly, if a node is leaking then any node down the leak trace is also leaking. From that, we can deduce that the leak is caused by a reference that is after the last `Leaking: NO`	and before the first `Leaking: YES`.
@@ -190,7 +192,7 @@ In this example, the last `Leaking: NO` is on `com.example.leakcanary.ExampleApp
 ...
 ```
 
-Looking at the [source](https://github.com/square/leakcanary/blob/master/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt#L23), we can see that `ExampleApplication` has a list field:
+Looking at the [source](https://github.com/square/leakcanary/blob/master/leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt#L23), we can see that `ExampleApplication` has a list field:
 
 ```
 open class ExampleApplication : Application() {
@@ -206,16 +208,23 @@ If you cannot figure out a leak, **please do not file an issue**. Instead, creat
 
 ## LeakCanary artifacts
 
-LeakCanary is released as several distinct libraries:
+LeakCanary is released as several libraries:
 
-* LeakSentry
-    * Detects retained instances.
+* Shark
+    * The heap analyzer that powers LeakCanary.
+    * See [Shark](shark.md) for details.
+* ObjectWatcher
+    * Used to watch retained objects and check if they become weakly reachable.
+    * Suitable for release builds.
+    * Artifact id: `com.squareup.leakcanary:leakcanary-object-watcher`.
+* ObjectWatcher Android
+    * Automatically detects retained destroyed activities and fragments.
     * Suitable for release builds.
-    * Artifact id: `com.squareup.leakcanary:leaksentry`.
+    * Artifact id: `com.squareup.leakcanary:leakcanary-object-watcher-android`.
 * LeakCanary
     * Dumps the heap and analyzes it.
     * Currently only suitable for debug builds.
-    * Depends on LeakSentry.
+    * Depends on ObjectWatcher Android.
     * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
 * LeakCanary for Instrumentation tests
     * Fails tests if a leak is detected.
@@ -223,3 +232,7 @@ LeakCanary is released as several distinct libraries:
     * Configures LeakCanary to wait for the end of tests before dumping the heap.
     * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
     * See [Running LeakCanary in instrumentation tests](recipes.md#running-leakcanary-in-instrumentation-tests).
+* LeakCanary Android separate process
+	* Enables running LeakCanary separately from the main app process.
+	* Artifact id: `com.squareup.leakcanary:leakcanary-android-process` (as a replacement for `com.squareup.leakcanary:leakcanary-android`).
+	* See [Running the LeakCanary analysis in a separate process](recipes.md#running-the-leakcanary-analysis-in-a-separate-process).
diff --git a/docs/getting_started.md b/docs/getting_started.md
index 2172d3c5..931160fd 100644
--- a/docs/getting_started.md
+++ b/docs/getting_started.md
@@ -5,7 +5,7 @@ Add LeakCanary to `build.gradle`:
 ```groovy
 dependencies {
   // debugImplementation because LeakCanary should only run in debug builds.
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-3'
 }
 ```
 
@@ -15,4 +15,4 @@ What's next?
 
 * Learn the [Fundamentals](fundamentals.md)
 * Try the [code recipes](recipes.md)
-* Read the [FAQ](faq.md)
+* Read the [FAQ](faq.md), e.g. [How does LeakCanary get installed by only adding a dependency?](faq.md#how-does-leakcanary-get-installed-by-only-adding-a-dependency)
diff --git a/docs/how_to_help.md b/docs/how_to_help.md
new file mode 100644
index 00000000..1a00c4e1
--- /dev/null
+++ b/docs/how_to_help.md
@@ -0,0 +1,7 @@
+# How to help
+
+You are most welcome to contribute code, answer [StackOverflow questions](http://stackoverflow.com/questions/tagged/leakcanary?sort=active), help manage GitHub issues and review pull requests.
+
+If you would like to contribute code to LeakCanary you can do so through GitHub by
+forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions
+and style in order to keep the code as readable as possible.
\ No newline at end of file
diff --git a/docs/images/logo-2.0-200px.png b/docs/images/logo-2.0-200px.png
new file mode 100644
index 00000000..005fd285
Binary files /dev/null and b/docs/images/logo-2.0-200px.png differ
diff --git a/docs/images/logo-2.0.png b/docs/images/logo-2.0.png
new file mode 100644
index 00000000..e1b3e927
Binary files /dev/null and b/docs/images/logo-2.0.png differ
diff --git a/docs/images/screenshot-2.0.png b/docs/images/screenshot-2.0.png
new file mode 100644
index 00000000..875db14a
Binary files /dev/null and b/docs/images/screenshot-2.0.png differ
diff --git a/docs/images/shark.png b/docs/images/shark.png
new file mode 100644
index 00000000..4afe96f3
Binary files /dev/null and b/docs/images/shark.png differ
diff --git a/docs/index.md b/docs/index.md
index d35383bf..c331d945 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -3,7 +3,7 @@
 LeakCanary is a memory leak detection library for Android.
 
 <p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
+<img src="images/screenshot-2.0.png" />
 </p>
 
 LeakCanary's knowledge of the internals of the Android Framework gives it a unique ability to narrow down the cause of each leak, helping developers dramatically reduce OutOfMemoryError crashes.
diff --git a/docs/recipes.md b/docs/recipes.md
index 2c31ea67..1f549f67 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -1,66 +1,100 @@
 # Code Recipes
 
-If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
+!!! bug
+    If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
 
-## Configuring LeakSentry
+## Watching objects with a lifecycle
+
+In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use [AppWatcher.objectWatcher](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/) to watch instances that should be garbage collected:
 
-LeakSentry can be configured by replacing `LeakSentry.config`:
 ```kotlin
-class DebugExampleApplication : ExampleApplication() {
+class MyService : Service {
 
-  override fun onCreate() {
-    super.onCreate()
-    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+  // ...
+
+  override fun onDestroy() {
+    super.onDestroy()
+    AppWatcher.objectWatcher.watch(this)
   }
 }
 ```
 
-## Configuring LeakCanary
+## Configuration
 
-LeakCanary can be configured by replacing `LeakCanary.config`:
+LeakCanary has a default configuration that should work well for most apps. You can also customize it to your needs. The LeakCanary configuration is held by two singleton objects (`AppWatcher` and `LeakCanary`) and can be updated at any time. Most developers configure LeakCanary in their **debug** [Application](https://developer.android.com/reference/android/app/Application) class:
 
 ```kotlin
-disableLeakCanaryButton.setOnClickListener {
-  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
+  }
 }
 ```
 
-## Watching objects with a lifecycle
 
-In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
+!!! info
+    You can create a debug application class in your `src/debug/java` folder. Don't forget to also register it in `src/debug/AndroidManifest.xml`.
 
-```kotlin
-class MyService : Service {
+To customize the detection of retained objects at runtime, update [AppWatcher.config](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config/):
 
-  // ...
+```
+AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
+```
 
-  override fun onDestroy() {
-    super.onDestroy()
-    LeakSentry.refWatcher.watch(this)
-  }
-}
+To customize the heap dumping & analysis, update [LeakCanary.config](/leakcanary/api/leakcanary-android-core/leakcanary/-leak-canary/config/):
+
+```
+LeakCanary.config = LeakCanary.config.copy(retainedVisibleThreshold = 3)
 ```
 
+The LeakCanary UI can be configured by overriding the following resources:
+
+* `mipmap/leak_canary_icon` see [Icon and label](#icon-and-label)
+* `string/leak_canary_display_activity_label` see [Icon and label](#icon-and-label)
+* `bool/leak_canary_add_dynamic_shortcut` see [Disabling LeakCanary](#disabling-leakcanary)
+* `bool/leak_canary_add_launcher_icon` see [Disabling LeakCanary](#disabling-leakcanary)
+* `layout/leak_canary_heap_dump_toast` the layout for the toast shown when the heap is dumped
+
+## Disabling LeakCanary
+
+Sometimes it's necessary to disable LeakCanary temporarily, for example for a product demo or when running performance tests. You have different options, depending on what you're trying to achieve:
+
+* Create a build variant that does not include the LeakCanary dependencies, see [Setting up LeakCanary for different product flavors](#setting-up-leakcanary-for-different-product-flavors).
+* Disable the tracking of retained objects: `AppWatcher.config = AppWatcher.config.copy(enabled = false)`.
+* Disable the heap dumping & analysis: `LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)`.
+* Hide the leak display activity launcher icon: override `R.bool.leak_canary_add_launcher_icon` or call `LeakCanary.showLeakDisplayActivityLauncherIcon(false)`
+
+!!! info
+    When you set `AppWatcher.config.enabled` to false, `AppWatcher.objectWatcher` will stop creating weak references to destroyed objects.
+
+	If instead you set `LeakCanary.Config.dumpHeap` to false, `AppWatcher.objectWatcher` will still keep track of retained objects, and LeakCanary will look for these objects when you change `LeakCanary.Config.dumpHeap` back to true.
+
 ## Counting retained instances in production
 
-`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
+The `com.squareup.leakcanary:leakcanary-android` dependency should only be used in debug builds. It depends on `com.squareup.leakcanary:leakcanary-object-watcher-android` which you can use in production to track and count retained instances.
 
 In your `build.gradle`:
 
 ```gradle
 dependencies {
-  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.0-beta-3'
 }
 ```
 
 In your leak reporting code:
 ```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+val retainedInstanceCount = AppWatcher.objectWatcher.retainedObjectCount
 ```
 
 ## Running LeakCanary in instrumentation tests
 
-Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
+Running leak detection in UI tests means you can detect memory leaks automatically in Continuous Integration prior to those leaks being merged into the codebase. However, as LeakCanary runs with a 5 seconds delay and freezes the VM to take a heap dump, this can introduce flakiness to the UI tests. Therefore LeakCanary automatically disables itself by setting `LeakCanary.config.dumpHeap` to `false` if it detects classes from the `androidx.test` dependency in the runtime classpath. If you run UI tests without `androidx.test`, we strongly advise that you set `dumpHeap` to `false`: `LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)`.
+
+LeakCanary provides an artifact dedicated to detecting leaks in UI tests which provides a run listener that waits for the end of a test, and if the test succeeds then it look for retained objects, trigger a heap dump if needed and perform an analysis.
+
+To set it up, add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
 
 ```
 androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
@@ -82,7 +116,7 @@ android {
 Run the instrumentation tests:
 
 ```
-./gradlew leakcanary-sample:connectedCheck
+./gradlew leakcanary-android-sample:connectedCheck
 ```
 
 You can extend `FailTestOnLeakRunListener` to customize the behavior.
@@ -118,80 +152,149 @@ res/
 
 You can change the default behavior to upload the analysis result to a server of your choosing.
 
-Create a custom `AnalysisResultListener` that delegates to the default: 
+Create a custom [OnHeapAnalyzedListener](/leakcanary/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/) that delegates to [DefaultOnHeapAnalyzedListener](/leakcanary/api/leakcanary-android-core/leakcanary/-default-on-heap-analyzed-listener/): 
 
 ```kotlin
-class LeakUploader : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
-  ) {
+class LeakUploader : OnHeapAnalyzedListener {
+
+  val defaultListener = DefaultOnHeapAnalyzedListener.create()
+
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
     TODO("Upload heap analysis to server")
 
     // Delegate to default behavior (notification and saving result)
-    DefaultAnalysisResultListener(application, heapAnalysis)
+    defaultListener.onHeapAnalyzed(heapAnalysis)
   }
 }
 ```
 
-Set `analysisResultListener` on the LeakCanary config:
+Set [LeakCanary.config.onHeapAnalyzedListener](/leakcanary/api/leakcanary-android-core/leakcanary/-leak-canary/-config/on-heap-analyzed-listener/):
 
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+    LeakCanary.config = LeakCanary.config.copy(onHeapAnalyzedListener = LeakUploader())
   }
 }
 ```
 
+## Matching known library leaks
 
-## Identifying 3rd party leaks as "won't fix"
-
-Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+Set [LeakCanary.Config.referenceMatchers](/leakcanary/api/leakcanary-android-core/leakcanary/-leak-canary/-config/reference-matchers/) to a list that builds on top of [AndroidReferenceMatchers.appDefaults](/leakcanary/api/shark-android/shark/-android-reference-matchers/app-defaults/):
 
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
-      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
-      val appDefaults = defaultFactory(hprofParser)
-      val customExclusion = Exclusion(
-          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
-          status = Exclusion.Status.WONT_FIX_LEAK,
-          reason = "SomeSingleton in library X has a static field leaking a context."
-      )
-      appDefaults + customExclusion
-    })
+    LeakCanary.config = LeakCanary.config.copy(
+        referenceMatchers = AndroidReferenceMatchers.appDefaults +
+            AndroidReferenceMatchers.staticFieldLeak(
+                className = "com.samsing.SomeSingleton",
+                fieldName = "sContext",
+                description = "SomeSingleton has a static field leaking a context.",
+                patternApplies = {
+                  manufacturer == "Samsing" && sdkInt == 26
+                }
+            )
+    )
   }
 }
 ```
 
-## Identifying leaking instances and labeling instances
+## Ignoring specific activities or fragment classes
+
+Sometimes a 3rd party library provides its own activities or fragments which contain a number of bugs leading to leaks of those specific 3rd party activities and fragments. You should push hard on that library to fix their memory leaks as it's directly impacting your application. That being said, until those are fixed, you have two options:
+
+1. Add the specific leaks as known library leaks (see [Matching known library leaks](#matching-known-library-leaks)). LeakCanary will run when those leaks are detected and then report them as known library leaks.
+2. Disable LeakCanary automatic activity or fragment watching (e.g. `AppWatcher.config = AppWatcher.config.copy(watchActivities = false)`) and then manually pass objects to `AppWatcher.objectWatcher.watch`.
+
+## Identifying leaking objects and labeling objects
 
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    val customLabeler: Labeler = { parser, node ->
-      listOf("Heap dump object id is ${node.instance}")
+    val addObjectIdLabel = ObjectInspector { reporter ->
+      reporter.addLabel("Heap dump object id is ${reporter.heapObject.objectId}")
     }
-    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
 
-    val customInspector: LeakInspector = { parser, node ->
-      with(parser) {
-        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
-          LeakNodeStatus.notLeaking("MySingleton is a singleton")
-        } else LeakNodeStatus.unknown()
+    val singletonsInspector =
+      AppSingletonInspector("com.example.MySingleton", "com.example.OtherSingleton")
+
+    val mmvmInspector = ObjectInspector { reporter ->
+      reporter.whenInstanceOf("com.mmvm.SomeViewModel") { instance ->
+        val destroyedField = instance["com.mmvm.SomeViewModel", "destroyed"]!!
+        if (destroyedField.value.asBoolean!!) {
+          reportLeaking("SomeViewModel.destroyed is true")
+        } else {
+          reportNotLeaking("SomeViewModel.destroyed is false")
+        }
       }
     }
-    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
 
-    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
+    LeakCanary.config = LeakCanary.config.copy(
+        objectInspectors = AndroidObjectInspectors.appDefaults +
+            listOf(addObjectIdLabel, singletonsInspector, mmvmInspector)
+    )
+  }
+}
+```
+
+## Running the LeakCanary analysis in a separate process
+
+LeakCanary runs in your main app process. LeakCanary 2 is optimized to keep memory usage low while analysing and runs in a background thread with priority `Process.THREAD_PRIORITY_BACKGROUND`. If you find that LeakCanary is still using too much memory or impacting the app process performance, you can configure it to run the analysis in a separate process.
+
+All you have to do is replace the `leakcanary-android` depedency with `leakcanary-android-process`:
+
+```groovy
+dependencies {
+  // debugImplementation 'com.squareup.leakcanary:leakcanary-android:${version}'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android-process:${version}'
+}
+```
+
+You can call [LeakCanaryProcess.isInAnalyzerProcess](/leakcanary/api/leakcanary-android-process/leakcanary/-leak-canary-process/is-in-analyzer-process/) to check if your Application class is being created in the LeakCanary process. This is useful when configuring libraries like Firebase that may crash when running in an unexpected process.
+
+## Setting up LeakCanary for different product flavors
+
+You can setup LeakCanary to run in a specific product flavors of your app. For example, create:
+
+```
+android {
+  flavorDimensions "default"
+  productFlavors {
+    prod {
+      // ...
+    }
+    qa {
+      // ...
+    }
+    dev {
+      // ...
+    }
   }
 }
-```
\ No newline at end of file
+```
+
+Then, define a custom configuration for the flavor for which you want to enable LeakCanary:
+
+```
+android {
+  // ...
+}
+configurations {
+    devDebugImplementation {}
+}
+```
+
+You can now add the LeakCanary dependency for that configuration:
+
+```
+dependencies {
+  devDebugImplementation "com.squareup.leakcanary:leakcanary-android:${version}"
+}
+```
diff --git a/docs/releasing.md b/docs/releasing.md
new file mode 100644
index 00000000..4626d973
--- /dev/null
+++ b/docs/releasing.md
@@ -0,0 +1,112 @@
+# Releasing LeakCanary
+
+* Create a local release branch from `master`
+```
+git checkout master
+git pull
+git checkout -b release_1.5
+```
+
+* Update `VERSION_NAME` in `gradle.properties` (remove `-SNAPSHOT`)
+```gradle
+VERSION_NAME = "1.5"
+```
+
+* Find all doc references to the current version and update them:
+
+```
+grep -R "2.0-beta-2" docs/
+```
+
+* Generate the Dokka docs
+
+```
+rm -rf docs/api
+./gradlew shark:dokka shark-android:dokka leakcanary-android-core:dokka leakcanary-android-instrumentation:dokka leakcanary-android-process:dokka shark-graph:dokka shark-hprof:dokka leakcanary-object-watcher-android:dokka shark-log:dokka leakcanary-object-watcher:dokka
+```
+
+* Update `docs/changelog.md` after checking out all changes:
+    * https://github.com/square/leakcanary/compare/v1.4...master
+* Take one last look
+```
+git diff
+```
+
+* Commit all local changes
+```
+git commit -am "Prepare 1.5 release"
+```
+
+* Perform a clean build
+```
+./gradlew clean build
+```
+
+* Create a tag and push it
+```
+git tag v1.5
+git push origin v1.5
+```
+
+* Make sure you have valid credentials to upload the artifacts
+
+`~/.gradle/gradle.properties`
+```
+SONATYPE_NEXUS_USERNAME=
+SONATYPE_NEXUS_PASSWORD=
+```
+
+* Upload the artifacts to Sonatype OSS Nexus
+
+```
+./gradlew uploadArchives --no-daemon --no-parallel
+```
+
+* Generate the CLI zip
+
+```
+./gradlew shark-cli:distZip
+```
+
+* Release to Maven Central
+    * Login to Sonatype OSS Nexus: https://oss.sonatype.org/
+    * Click on **Staging Repositories**
+    * Scroll to the bottom, you should see an entry named `comsquareup-XXXX`
+    * Check the box next to the `comsquareup-XXXX` entry, click **Close** then **Confirm**
+    * Wait a bit, hit **Refresh**, until the *Status* for that column changes to *Closed*.
+    * Check the box next to the `comsquareup-XXXX` entry, click **Release** then **Confirm**
+* Merge the release branch to master
+```
+git checkout master
+git pull
+git merge --no-ff release_1.5
+```
+* Update `VERSION_NAME` in `gradle.properties` (increase version and add `-SNAPSHOT`)
+```gradle
+VERSION_NAME = "2.0-alpha-4-SNAPSHOT"
+```
+* Update the snapshot version in `docs/faq.md`:
+```gradle
+ dependencies {
+   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-4-SNAPSHOT'
+ }
+```
+* Commit your changes
+```
+git commit -am "Prepare for next development iteration"
+```
+
+* Push your changes
+```
+git push
+```
+
+* Go to [Milestones](https://github.com/square/leakcanary/milestones), rename the current release to the version just released, and create a new *Next Release* milestone.
+* Wait for the release to be available [on Maven Central](https://repo1.maven.org/maven2/com/squareup/leakcanary/leakcanary-android/).
+* Redeploy the docs: `mkdocs serve` to check locally, `mkdocs gh-deploy` to deploy.
+* Go to the [Draft a new release](https://github.com/square/leakcanary/releases/new) page, enter the release name (v1.5) as tag and title, and have the description point to the changelog. You can find the direct anchor URL from the [Change Log](https://square.github.io/leakcanary/changelog) page on the doc site.
+```
+See [Change Log](https://square.github.io/leakcanary/changelog#version-20-alpha-2-2019-05-21)
+```
+* Add the CLIP zip from `shark-cli/build/distributions/` to the release. Update the documentation to point to it.
+* Tell your friends, update all of your apps, and tweet the new release. As a nice extra touch, mention external contributions.
\ No newline at end of file
diff --git a/docs/shark.md b/docs/shark.md
new file mode 100644
index 00000000..70896b75
--- /dev/null
+++ b/docs/shark.md
@@ -0,0 +1,156 @@
+# Shark ü¶à
+
+<!-- Made with http://patorjk.com/text-color-fader/ -->
+**Shark**: **<span style="color:#c757bc;">S</span><span style="color:#c858b7;">m</span><span style="color:#ca5ab2;">a</span><span style="color:#cb5bad;">r</span><span style="color:#cc5ca9;">t</span><span style="color:#ce5ea4;"> </span><span style="color:#cf5f9f;">H</span><span style="color:#d0609a;">e</span><span style="color:#d26295;">a</span><span style="color:#d36390;">p</span><span style="color:#d4658c;"> </span><span style="color:#d66687;">A</span><span style="color:#d76782;">n</span><span style="color:#d8697d;">a</span><span style="color:#da6a78;">l</span><span style="color:#db6b73;">y</span><span style="color:#dc6d6f;">s</span><span style="color:#de6e6a;">i</span><span style="color:#df6f65;">s</span><span style="color:#e07160;"> </span><span style="color:#e1725b;">R</span><span style="color:#e37356;">e</span><span style="color:#e47552;">p</span><span style="color:#e5764d;">o</span><span style="color:#e77748;">r</span><span style="color:#e87943;">t</span><span style="color:#e97a3e;">s</span><span style="color:#eb7b39;"> </span><span style="color:#ec7d35;">f</span><span style="color:#ed7e30;">o</span><span style="color:#ef802b;">r</span><span style="color:#f08126;"> </span><span style="color:#f18221;">K</span><span style="color:#f3841c;">o</span><span style="color:#f48518;">t</span><span style="color:#f58613;">l</span><span style="color:#f7880e;">i</span><span style="color:#f88909;">n</span>**
+
+<p align="center">
+<img src="../images/shark.png" />
+</p>
+
+Shark is the heap analyzer that powers LeakCanary 2. It's a Kotlin standalone heap analysis library that runs at **high speed** with a **low memory footprint**.
+
+Shark is released in layers:
+
+1. **Shark Hprof**: Read and write records in hprof files.
+2. **Shark Graph**: Navigate the heap object graph.
+3. **Shark**: Generate heap analysis reports.
+4. **Shark Android**: Android heuristics to generate tailored heap analysis reports.
+5. **Shark CLI**: Analyze the heap of debuggable apps installed on an Android device connected to your desktop. The output is similar to the output of LeakCanary, except you don't have to add the LeakCanary dependency to your app.
+6. **LeakCanary**: Builds on top. It automatically watches destroyed activities and fragments, triggers a heap dump, runs Shark Android and then displays the result.
+
+A few more things:
+
+* Shark is built on top of Okio. Okio makes it easy to parse heap dumps efficiently.
+* Shark is a 100% Kotlin library, and Kotlin is essential to its design, because Shark relies heavily on sealed classes and sequences to save memory.
+* Shark has the unique ability to help narrow down the cause of memory leaks through platform specific [heuristics](fundamentals.md#heuristics-and-labels).
+* Shark is heavily tested (80% test coverage).
+* Shark can run in both Java and Android VMs, with no other dependency than Okio and Kotlin.
+* Shark can analyze both Java and Android VM hprof files.
+
+## Shark CLI
+
+The Shark Command Line Interface (CLI) enables you to analyze heaps directly from your computer. It can dump the heap of an app installed on a connected Android device, analyze it, and even strip a heap dump of any sensitive data (e.g. PII, passwords or encryption keys) which is useful when sharing a heap dump.
+
+Download it [here](https://github.com/square/leakcanary/releases/download/v2.0-beta-3/shark-cli-2.0-beta-3.zip)!
+
+Usage instructions:
+
+```
+$ ./bin/shark-cli
+
+Shark CLI
+
+                 ^`.                 .=""=.
+ ^_              \  \               / _  _ \
+ \ \             {   \             |  d  b  |
+ {  \           /     `~~~--__     \   /\   /
+ {   \___----~~'              `~~-_/'-=\/=-'\,
+  \                         /// a  `~.      \ \
+  / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+  \/      \/    `~~~;   ,---~~-_`/ \        / \/
+                   /   /            '.    .'
+                  '._.'             _|`~~`|_
+                                    /|\  /|\
+
+Commands: [analyze-process, dump-process, analyze-hprof, strip-hprof]
+
+analyze-process: Dumps the heap for the provided process name, pulls the hprof file and analyzes it.
+  USAGE: analyze-process PROCESS_PACKAGE_NAME
+
+dump-process: Dumps the heap for the provided process name and pulls the hprof file.
+  USAGE: dump-process PROCESS_PACKAGE_NAME
+
+analyze-hprof: Analyzes the provided hprof file.
+  USAGE: analyze-hprof HPROF_FILE_PATH
+
+strip-hprof: Replaces all primitive arrays from the provided hprof file with arrays of zeroes.
+  USAGE: strip-hprof HPROF_FILE_PATH
+```
+
+## Shark code examples
+
+### Reading records in a hprof file
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-hprof:$sharkVersion'
+}
+```
+
+```kotlin
+// Prints all class and field names
+Hprof.open(heapDumpFile)
+    .use { hprof ->
+      hprof.reader.readHprofRecords(
+          recordTypes = setOf(StringRecord::class),
+          listener = OnHprofRecordListener { position, record ->
+            println((record as StringRecord).string)
+          })
+    }
+```
+
+### Navigating the heap object graph
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-graph:$sharkVersion'
+}
+```
+
+```kotlin
+// Prints all thread names
+Hprof.open(heapDumpFile)
+    .use { hprof ->
+      val heapGraph = HprofHeapGraph.indexHprof(hprof)
+      val threadClass = heapGraph.findClassByName("java.lang.Thread")!!
+      val threadNames: Sequence<String> = threadClass.instances.map { instance ->
+        val nameField = instance["java.lang.Thread", "name"]!!
+        nameField.value.readAsJavaString()!!
+      }
+      threadNames.forEach { println(it) }
+    }
+```
+
+### Generating a heap analysis report
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark:$sharkVersion'
+}
+```
+
+```kotlin
+val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+val analysis = heapAnalyzer.checkForLeaks(
+    heapDumpFile = heapDumpFile,
+    leakFinders = listOf(ObjectInspector { _, reporter ->
+      reporter.whenInstanceOf("com.example.ThingWithLifecycle") { instance ->
+        val field = instance["com.example.ThingWithLifecycle", "destroyed"]!!
+        val destroyed = field.value.asBoolean!!
+        if (destroyed) {
+          leakingReasons += "ThingWithLifecycle.destroyed = true"
+        }
+      }
+    })
+)
+println(analysis)
+```
+
+### Generating an Android heap analysis report
+
+```groovy
+dependencies {
+  implementation 'com.squareup.leakcanary:shark-android:$sharkVersion'
+}
+```
+
+
+```kotlin
+val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+val analysis = heapAnalyzer.checkForLeaks(
+    heapDumpFile = heapDumpFile,
+    referenceMatchers = AndroidReferenceMatchers.appDefaults,
+    objectInspectors = AndroidObjectInspectors.appDefaults
+)
+println(analysis)
+```
diff --git a/docs/support.md b/docs/support.md
index e8527600..13a92c9a 100644
--- a/docs/support.md
+++ b/docs/support.md
@@ -1,14 +1,12 @@
 # LeakCanary Support
 
-If you're looking for support for LeakCanary:
+If you're looking for help with LeakCanary:
 
 * Learn the [Fundamentals](fundamentals.md)
 * Try the [code recipes](recipes.md)
 * Read the [FAQ](https://square.github.io/leakcanary/faq/)
 * Watch [recorded presentations](recorded-presentations.md)
 * Read [blog articles](blog-articles.md)
-* Check out the StackOverflow [LeakCanary tag](http://stackoverflow.com/questions/tagged/leakcanary?sort=active) and ask a question
-
-Feel free to edit this file to add links to online communities that can help developers investigate LeakCanary leaks.
+* Ask a question [on StackOverflow](http://stackoverflow.com/questions/tagged/leakcanary?sort=active)
 
 
diff --git a/docs/theme/main.html b/docs/theme/main.html
new file mode 100644
index 00000000..c7a68575
--- /dev/null
+++ b/docs/theme/main.html
@@ -0,0 +1,29 @@
+{% extends "base.html" %}
+
+{% block content %}
+                {% if page.edit_url %}
+				  {% if "/api/" in page.edit_url %}
+				<span style="float: right">ü§î Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report it</a></span>
+                  {% else %}
+				<span style="float: right">ü§î Documentation issue? <a href="https://github.com/square/leakcanary/issues/new?assignees=&labels=type%3A+documentation&template=4-doc.md&title=Doc%20issue%20with%20{{ page.url }}%20page">Report</a> or <a href="{{ page.edit_url }}">edit</a></span>
+                  {% endif %}
+                {% endif %}
+                {% if not "\x3ch1" in page.content %}
+                  <h1>{{ page.title | default(config.site_name, true)}}</h1>
+                {% endif %}
+                {{ page.content }}
+                {% block source %}
+                  {% if page and page.meta and page.meta.source %}
+                    <h2 id="__source">{{ lang.t("meta.source") }}</h2>
+                    {% set repo = config.repo_url %}
+                    {% if repo | last == "/" %}
+                      {% set repo = repo[:-1] %}
+                    {% endif %}
+                    {% set path = page.meta.path | default([""]) %}
+                    {% set file = page.meta.source %}
+                    <a href="{{ [repo, path, file] | join('/') }}" title="{{ file }}" class="md-source-file">
+                      {{ file }}
+                    </a>
+                  {% endif %}
+                {% endblock %}
+{% endblock %}
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
index 480b6745..cd4204e2 100644
--- a/docs/upgrading-to-leakcanary-2.0.md
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -1,3 +1,10 @@
+LeakCanary 2 is a major rewrite. High level changes:
+
+* New heap analyzer, reimplemented from scratch to use 10 times less memory ([see Shark](shark.md)).
+* APIs updated to simplify configuration and provide access to the new heap analyzer.
+* Internals rewritten to 100% Kotlin.
+* Multiple leaks detected in one analysis, grouped per leak type
+
 ## Dependencies
 
 ### Before
@@ -15,7 +22,7 @@ dependencies {
 
 ```groovy
 dependencies {
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-3'
 }
 ```
 
@@ -24,8 +31,8 @@ dependencies {
 * The `leakcanary-android-no-op` artifact is gone. If you have compile errors, see below.
   * **Question**: if there's no no-op anymore, how do I ensure none of this runs during release builds?
   * **Answer**: as long as you add `leakcanary-android` as `debugImplementation`, there won't be any code referencing LeakCanary in your release builds.
-* LeakCanary now **depends on AndroidX** instead of the support library.
-* Detection of AndroidX fragments is now automatic if you have the AndroidX fragments dependency.
+* LeakCanary does not depend on the support library anymore, and it doesn't depend on AndroidX either.
+* Detection of AndroidX fragments is automatic if you have the AndroidX fragments dependency.
 
 ## Default setup code
 
@@ -61,58 +68,58 @@ There is no more code for default setup.
 ### Before
 
 ```kotlin
-val refWatcher = LeakCanary.installedRefWatcher()
+val refWatcher: RefWatcher = LeakCanary.installedRefWatcher()
 ```
 
 ### Now
 
 ```kotlin
-val refWatcher = LeakSentry.refWatcher
+val objectWatcher: ObjectWatcher = AppWatcher.objectWatcher
 ```
 
 ## Compile errors because RefWatcher is used in release code
 
-If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. `RefWatcher` now lives in the `leaksentry` artifact, which is suitable for production. You have two options:
+If you were using `RefWatcher` in non debug code, you now get a compile error because the no-op artifact is gone. [ObjectWatcher](/leakcanary/api/leakcanary-object-watcher/leakcanary/-object-watcher/) now lives in the `object-watcher` artifact, which is suitable for production. You have two options:
 
-### Option 1: Add `leaksentry` to release builds.
+### Option 1: Add `object-watcher-android` to release builds.
 
 ```groovy
 dependencies {
-  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.0-beta-3'
 }
 ```
 
-* It will automatically keep weak references on activities, fragments, and any instance you pass to `RefWatcher`.
+* It will automatically keep weak references to destroyed activities, fragments, and any instance you pass to [AppWatcher.objectWatcher](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/object-watcher/).
 * It will not trigger heap dumps or anything else that LeakCanary does.
 * It's very little code and should have a no impact on your release app.
-* You can use it to count how many instances are retained, for instance to add metadata to OutOfMemoryError crashes:
+* You can use it to count how many objects are retained, for example to add metadata to OutOfMemoryError crashes:
 
 ```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedInstanceCount
+val retainedObjectCount = AppWatcher.objectWatcher.retainedObjectCount
 ```
 
-### Option 2: Make your own `RefWatcher` interface
+### Option 2: Make your own `ObjectWatcher` interface
 
 ```kotlin
 // In shared code
-interface MaybeRefWatcher {
-  fun watch(watchedInstance: Any)
+interface MaybeObjectWatcher {
+  fun watch(watchedObject: Any)
 
-  object None : MaybeRefWatcher {
-    override fun watch(watchedInstance: Any) {
+  object None : MaybeObjectWatcher {
+    override fun watch(watchedObject: Any) {
     }
   }
 }
 
 // In debug code
-class RealRefWatcher : MaybeRefWatcher {
-  override fun watch(watchedInstance: Any) {
-    LeakSentry.refWatcher.watch(watchedInstance)
+class RealObjectWatcher : MaybeObjectWatcher {
+  override fun watch(watchedObject: Any) {
+    AppWatcher.objectWatcher.watch(watchedObject)
   }
 }
 ```
 
-Use MaybeRefWatcher.None in release code and RealRefWatcher in debug code.
+Use `MaybeObjectWatcher.None` in release code and `RealObjectWatcher` in debug code.
 
 ## Configuring LeakCanary
 
@@ -131,18 +138,19 @@ public class DebugExampleApplication extends ExampleApplication {
 
 ### Now
 
-LeakSentry is in charge of detecting memory leaks. Its configuration can be updated at any time by replacing `LeakSentry.config`:
+AppWatcher is in charge of detecting retained objects. Its configuration can be updated at any time by replacing [AppWatcher.config](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config/):
+
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
   }
 }
 ```
 
-LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing `LeakCanary.config`:
+LeakCanary is in charge of taking heap dumps and analyzing them. Its configuration can be updated at any time by replacing [LeakCanary.config](/leakcanary/api/leakcanary-android-core/leakcanary/-leak-canary/config/):
 
 ```kotlin
 disableLeakCanaryButton.setOnClickListener {
@@ -236,21 +244,36 @@ RefWatcher refWatcher = LeakCanary.refWatcher(this)
 ### Now
 
 ```Kotlin
-LeakCanary.config = LeakCanary.config.copy(
-    analysisResultListener = { application, heapAnalysis ->
-      // TODO Upload result to server
-      DefaultAnalysisResultListener(application, heapAnalysis)
-    }
-)
+class LeakUploader : OnHeapAnalyzedListener {
+
+  val defaultListener = DefaultOnHeapAnalyzedListener.create()
+
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+    TODO("Upload heap analysis to server")
+
+    // Delegate to default behavior (notification and saving result)
+    defaultListener.onHeapAnalyzed(heapAnalysis)
+  }
+}
+
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(
+        onHeapAnalyzedListener = LeakUploader()
+    )
+  }
+}
 ```
 
-### Marking known framework leaks as won't fix
+### Matching known library leaks
 
 ### Before
 
 ```java
 ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
-    .instanceField("com.example.ExampleClass", "exampleField")
+    .staticField("com.samsing.SomeSingleton", "sContext")
     .build();
 RefWatcher refWatcher = LeakCanary.refWatcher(this)
   .excludedRefs(excludedRefs)
@@ -262,19 +285,17 @@ RefWatcher refWatcher = LeakCanary.refWatcher(this)
 
 ```kotlin
 LeakCanary.config = LeakCanary.config.copy(
-  exclusionsFactory = { parser ->
-    val build = BuildMirror.readFromHprof(parser)
-    val exclusions =
-      AndroidExcludedRefs.exclusionsMatchingBuild(AndroidExcludedRefs.appDefaults, build)
-          .toMutableList()
-    exclusions += Exclusion(
-        type = InstanceFieldExclusion("com.example.ExampleClass", "exampleField")
-    )
-    exclusions
-  }
+    referenceMatchers = AndroidReferenceMatchers.appDefaults +
+        AndroidReferenceMatchers.staticFieldLeak(
+            "com.samsing.SomeSingleton",
+            "sContext"
+        )
 )
 ```
 
+!!! info
+    There is no equivalent API to `ExcludedRefs.Builder.clazz()` because it led to abuses. Instead see [Ignoring specific activities or fragment classes](recipes.md#ignoring-specific-activities-or-fragment-classes).
+
 ## Public API packages
 
 ### Before
diff --git a/gradle.properties b/gradle.properties
index 176c24f4..2b06e649 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,7 +1,7 @@
 GROUP=com.squareup.leakcanary
-VERSION_NAME=2.0-alpha-4-SNAPSHOT
+VERSION_NAME=2.0-beta-4-SNAPSHOT
 
-POM_DESCRIPTION=Leak Canary
+POM_DESCRIPTION=LeakCanary
 
 POM_URL=http://github.com/square/leakcanary/
 POM_SCM_URL=http://github.com/square/leakcanary/
@@ -16,3 +16,8 @@ POM_DEVELOPER_ID=square
 POM_DEVELOPER_NAME=Square, Inc.
 
 android.useAndroidX=true
+
+#Gradle properties: https://docs.gradle.org/current/userguide/build_environment.html
+org.gradle.caching=true
+org.gradle.configureondemand=true
+org.gradle.parallel=true
\ No newline at end of file
diff --git a/gradle/checkstyle.gradle b/gradle/checkstyle.gradle
deleted file mode 100644
index afc5281a..00000000
--- a/gradle/checkstyle.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: 'checkstyle'
-
-checkstyle {
-  configFile rootProject.file('checkstyle.xml')
-  ignoreFailures false
-  showViolations true
-}
-
-task checkstyle(type: Checkstyle) {
-  configFile rootProject.file('checkstyle.xml')
-  source 'src/main/java'
-  ignoreFailures false
-  showViolations true
-  include '**/*.java'
-
-  classpath = files()
-}
-
-afterEvaluate {
-  if (project.tasks.getByName("check")) {
-    check.dependsOn('checkstyle')
-  }
-}
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ee69dd68..ca9d6281 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.6.2-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/hooks/pre-push b/hooks/pre-push
new file mode 100644
index 00000000..3c0d5fc1
--- /dev/null
+++ b/hooks/pre-push
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+echo "Running static analysis..."
+
+# Run static analysis tools
+./gradlew detekt
+
+status=$?
+
+if [ "$status" = 0 ] ; then
+    echo "Static analysis found no problems."
+    exit 0
+else
+    echo 1>&2 "Static analysis found violations! Fix them before pushing your code!"
+    echo "See generated reports above or in /<project_dir>/build/reports folder"
+    exit 1
+fi
diff --git a/leakcanary-analyzer/gradle.properties b/leakcanary-analyzer/gradle.properties
deleted file mode 100644
index ed79fc10..00000000
--- a/leakcanary-analyzer/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-analyzer
-POM_NAME=LeakCanary Analyzer
-POM_PACKAGING=jar
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
deleted file mode 100644
index 52ca9f9c..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
+++ /dev/null
@@ -1,32 +0,0 @@
-package leakcanary
-
-interface AnalyzerProgressListener {
-
-  // These steps should be defined in the order in which they occur.
-  enum class Step {
-    READING_HEAP_DUMP_FILE,
-    PARSING_HEAP_DUMP,
-    SCANNING_HEAP_DUMP,
-    FINDING_WATCHED_REFERENCES,
-    DEDUPLICATING_GC_ROOTS,
-    FINDING_LEAKING_REF,
-    FINDING_LEAKING_REFS,
-    FINDING_SHORTEST_PATH,
-    FINDING_SHORTEST_PATHS,
-    FINDING_DOMINATORS,
-    COMPUTING_NATIVE_RETAINED_SIZE,
-    COMPUTING_RETAINED_SIZE,
-    BUILDING_LEAK_TRACE,
-    BUILDING_LEAK_TRACES,
-    COMPUTING_DOMINATORS
-  }
-
-  fun onProgressUpdate(step: Step)
-
-  companion object {
-    val NONE = object : AnalyzerProgressListener {
-      override fun onProgressUpdate(step: Step) {
-      }
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt
deleted file mode 100644
index 0e1eb917..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt
+++ /dev/null
@@ -1,1131 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import leakcanary.Exclusion.ExclusionType
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
-import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.Status
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import java.lang.ref.PhantomReference
-import java.lang.ref.SoftReference
-import java.lang.ref.WeakReference
-import java.util.EnumSet
-
-/**
- * The first parameter is the value of android.os.Build.MANUFACTURER and the second
- * parameter is the value of android.os.Build.VERSION.SDK_INT. Returns true if the known
- * reference should be applied on the provided manufacturer / sdk int.
- */
-typealias BuildFilter = (String, Int) -> Boolean
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- *
- * Most app developers should use [appDefaults]. However, you can also pick the
- * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
- * [buildKnownReferences]
- */
-class AndroidKnownReference private constructor(
-  val type: ExclusionType,
-  val reason: String?,
-  val status: Status,
-  val filter: BuildFilter
-) {
-
-  companion object {
-    private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
-    const val SAMSUNG = "samsung"
-    const val MOTOROLA = "motorola"
-    const val LENOVO = "LENOVO"
-    const val LG = "LGE"
-    const val NVIDIA = "NVIDIA"
-    const val MEIZU = "Meizu"
-    const val HUAWEI = "HUAWEI"
-    const val VIVO = "vivo"
-
-    /**
-     * This returns the references in the leak path that should be ignored by all on Android.
-     */
-    val androidDefaults: Set<AndroidKnownReference>
-      get() = buildKnownReferences(
-          EnumSet.of(
-              Defaults.REFERENCES,
-              Defaults.FINALIZER_WATCHDOG_DAEMON,
-              Defaults.MAIN,
-              Defaults.LEAK_CANARY_THREAD,
-              Defaults.EVENT_RECEIVER__MMESSAGE_QUEUE
-          )
-      )
-
-    /**
-     * This returns the references in the leak path that can be ignored for app developers. This
-     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-     */
-    val appDefaults: Set<AndroidKnownReference>
-      get() = buildKnownReferences(EnumSet.allOf(Defaults::class.java))
-
-    fun buildKnownReferences(defaults: Set<Defaults>): Set<AndroidKnownReference> {
-      val resultSet = mutableSetOf<AndroidKnownReference>()
-      defaults.forEach {
-        it.add(resultSet)
-      }
-      return resultSet
-    }
-
-    private val NO_FILTER: BuildFilter = { _, _ ->
-      true
-    }
-
-    fun staticField(
-      className: String,
-      fieldName: String,
-      reason: String? = null,
-      status: Status = WONT_FIX_LEAK,
-      filter: BuildFilter = NO_FILTER
-    ) = AndroidKnownReference(StaticFieldExclusion(className, fieldName), reason, status, filter)
-
-    fun instanceField(
-      className: String,
-      fieldName: String,
-      reason: String? = null,
-      status: Status = WONT_FIX_LEAK,
-      filter: BuildFilter = NO_FILTER
-    ) = AndroidKnownReference(InstanceFieldExclusion(className, fieldName), reason, status, filter)
-
-    fun javaLocal(
-      threadName: String,
-      reason: String? = null,
-      status: Status = WONT_FIX_LEAK,
-      filter: BuildFilter = NO_FILTER
-    ) = AndroidKnownReference(JavaLocalExclusion(threadName), reason, status, filter)
-
-    /**
-     * Used to transform [AndroidKnownReference] instances to [Exclusion] which is what
-     * the heap analyzer actually uses. The resulting set should only be used
-     * for exactly one analysis, it caches the Android version information.
-     */
-    fun mapToExclusions(knownReferences: Set<AndroidKnownReference>): List<Exclusion> {
-      val buildMirror = BuildMirror()
-      return knownReferences.map { knownReference ->
-        Exclusion(
-            knownReference.type, knownReference.reason, knownReference.status,
-            buildMirror.wrapFilter(knownReference.filter)
-        )
-      }
-    }
-  }
-
-  enum class Defaults {
-    // ######## Android Framework known leaks ########
-
-    ACTIVITY_CLIENT_RECORD__NEXT_IDLE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.app.ActivityThread\$ActivityClientRecord", "nextIdle",
-            reason = "Android AOSP sometimes keeps a reference to a destroyed activity as a"
-                + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-                + " Not sure what's going on there, input welcome."
-        ) { _, sdkInt ->
-          sdkInt in 19..27
-        }
-      }
-    },
-
-    SPAN_CONTROLLER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason =
-          ("Editor inserts a special span, which has a reference to the EditText. That span is a"
-              + " NoCopySpan, which makes sure it gets dropped when creating a new"
-              + " SpannableStringBuilder from a given CharSequence."
-              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-              + " reference to the textview and therefore the entire view hierarchy & activity"
-              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
-
-        references += instanceField(
-            "android.widget.Editor\$SpanController", "this$0", reason
-        ) { _, sdkInt ->
-          sdkInt <= 19
-        }
-
-        references += instanceField(
-            "android.widget.Editor\$EasyEditSpanController", "this$0", reason
-        ) { _, sdkInt ->
-          sdkInt <= 19
-        }
-      }
-    },
-
-    MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references +=
-          staticField(
-              "android.media.session.MediaSessionLegacyHelper", "sInstance",
-              reason = "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-                  + " keeps a reference to the context it's given the first time"
-                  + " MediaSessionLegacyHelper.getHelper() is called."
-                  + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-                  + " calling context.getApplicationContext()."
-                  + " Fix: https://github.com/android/platform_frameworks_base/commit"
-                  + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-                  + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-                  + " in Application.onCreate() and pass it the application context."
-          ) { _, sdkInt ->
-            sdkInt == 21
-          }
-      }
-    },
-
-    TEXT_LINE__SCACHED {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.text.TextLine", "sCached",
-            reason = "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-                + " at least two bugs that created memory leaks by not correctly clearing the"
-                + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-                + " https://github.com/android/platform_frameworks_base/commit"
-                + "/893d6fe48d37f71e683f722457bea646994a10"
-                + " The second was fixed, not released yet:"
-                + " https://github.com/android/platform_frameworks_base/commit"
-                + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-                + " To fix this, you could access TextLine.sCached and clear the pool every now"
-                + " and then (e.g. on activity destroy)."
-        ) { _, sdkInt ->
-          sdkInt <= 22
-        }
-      }
-    },
-
-    BLOCKING_QUEUE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason = ("A thread waiting on a blocking queue will leak the last"
-            + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-            + " keeps a local reference to the last message it received. That message then gets"
-            + " recycled and can be used again. As long as all messages are recycled after being"
-            + " used, this won't be a problem, because these references are cleared when being"
-            + " recycled. However, dialogs create template Message instances to be copied when a"
-            + " message needs to be sent. These Message templates holds references to the dialog"
-            + " listeners, which most likely leads to holding a reference onto the activity in some"
-            + " way. Dialogs never recycle their template Message, assuming these Message instances"
-            + " will get GCed when the dialog is GCed."
-            + " The combination of these two things creates a high potential for memory leaks as soon"
-            + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-            + " sleep for a long time."
-            + " To fix this, you could post empty messages to the idle handler threads from time to"
-            + " time. This won't be easy because you cannot access all handler threads, but a library"
-            + " that is widely used should consider doing this for its own handler threads. This leaks"
-            + " has been shown to happen in both Dalvik and ART.")
-
-        references += instanceField("android.os.Message", "obj", reason)
-        references += instanceField("android.os.Message", "next", reason)
-        references += instanceField("android.os.Message", "target", reason)
-      }
-    },
-
-    INPUT_METHOD_MANAGER_IS_TERRIBLE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
-            + " leaks a reference to it until a new view asks for keyboard input."
-            + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-            + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mNextServedView", reason
-        ) { _, sdkInt ->
-          sdkInt in 15..27
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mServedView", reason
-        ) { _, sdkInt ->
-          sdkInt in 15..27
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mServedInputConnection", reason
-        ) { _, sdkInt ->
-          sdkInt in 15..27
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mLastSrvView"
-            ,
-            reason =
-            "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
-        ) { manufacturer, sdkInt ->
-          manufacturer == HUAWEI && sdkInt in 23..27
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mCurRootView",
-            reason = "The singleton InputMethodManager is holding a reference to mCurRootView long"
-                + " after the activity has been destroyed."
-                + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-                + "#issuecomment-100579429"
-                + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
-        ) { _, sdkInt ->
-          sdkInt in 15..28
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mImeInsetsConsumer",
-            reason = """
-              Android Q Beta has a leak where InputMethodManager.mImeInsetsConsumer isn't set to
-              null when the activity is destroyed.
-            """.trimIndent()
-        ) { _, sdkInt ->
-          sdkInt == 28
-        }
-
-        references += instanceField(
-            "android.view.inputmethod.InputMethodManager", "mCurrentInputConnection",
-            reason = """
-              In Android Q Beta InputMethodManager keeps its EditableInputConnection after the
-              activity has been destroyed.
-            """.trimIndent()
-        ) { _, sdkInt ->
-          sdkInt == 28
-        }
-      }
-    },
-
-    LAYOUT_TRANSITION {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.animation.LayoutTransition$1", "val\$parent",
-            reason = "LayoutTransition leaks parent ViewGroup through"
-                + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-                + " window is destroyed. Tracked here:"
-                + " https://code.google.com/p/android/issues/detail?id=171830"
-        ) { _, sdkInt ->
-          sdkInt in 14..22
-        }
-      }
-    },
-
-    SPELL_CHECKER_SESSION {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.view.textservice.SpellCheckerSession$1", "this$0",
-            reason = "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-                + " SpellCheckerSession is closed before the service is connected."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
-        ) { _, sdkInt ->
-          sdkInt in 16..24
-        }
-      }
-    },
-
-    SPELL_CHECKER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.widget.SpellChecker$1", "this$0",
-            reason = "SpellChecker holds on to a detached view that points to a destroyed activity."
-                + " mSpellRunnable is being enqueued, and that callback should be removed when "
-                + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
-                + " called after the view was detached."
-        ) { _, sdkInt ->
-          sdkInt == 22
-        }
-      }
-    },
-
-    ACTIVITY_CHOOSE_MODEL {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason = ("ActivityChooserModel holds a static reference to the last set"
-            + " ActivityChooserModelPolicy which can be an activity context."
-            + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-            + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
-
-
-        references += instanceField(
-            "android.support.v7.internal.widget.ActivityChooserModel",
-            "mActivityChoserModelPolicy",
-            reason = reason
-        ) { _, sdkInt ->
-          sdkInt in 15..22
-        }
-
-        references += instanceField(
-            "android.widget.ActivityChooserModel", "mActivityChoserModelPolicy",
-            reason = reason
-        )
-      }
-    },
-
-    MEDIA_PROJECTION_CALLBACK {
-      override fun add(references: MutableSet<AndroidKnownReference>) {
-        references += instanceField("android.media.projection.MediaProjection\$MediaProjectionCallback",
-            "this$0", reason = """
-              MediaProjectionCallback is held by another process, and holds on to MediaProjection
-              which has an activity as its context.
-            """.trimIndent()) { _, sdkInt ->
-          sdkInt in 22..28
-        }
-      }
-
-    },
-
-    SPEECH_RECOGNIZER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.speech.SpeechRecognizer\$InternalListener", "this$0"
-            ,
-            reason = "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-                + " class and leaked the SpeechRecognizer which leaked an activity context."
-                + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-                + " /b37866db469e81aca534ff6186bdafd44352329b"
-        ) { _, sdkInt ->
-          sdkInt < 21
-        }
-      }
-    },
-
-    ACCOUNT_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.accounts.AccountManager\$AmsTask\$Response", "this$1"
-            ,
-            reason =
-            "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
-                + " probably because the reference to the response in the other process hasn't been"
-                + " cleared."
-                + " AccountManager\$AmsTask is holding on to the activity reference to use for"
-                + " launching a new sub- Activity."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-                + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-                + " with the returned future to to get the result and correctly start an activity"
-                + " when it's available."
-        ) { _, sdkInt ->
-          sdkInt <= 27
-        }
-      }
-    },
-
-    MEDIA_SCANNER_CONNECTION {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.media.MediaScannerConnection", "mContext",
-
-            reason =
-            "The static method MediaScannerConnection.scanFile() takes an activity context"
-                + " but the service might not disconnect after the activity has been destroyed."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-                + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-                + " application context. Call connect() and disconnect() manually."
-        ) { _, sdkInt ->
-          sdkInt <= 22
-        }
-      }
-    },
-
-    USER_MANAGER__SINSTANCE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.os.UserManager", "mContext",
-            reason =
-            "UserManager has a static sInstance field that creates an instance and caches it"
-                + " the first time UserManager.get() is called. This instance is created with the"
-                + " outer context (which is an activity base context)."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-                + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-                + "/27db46850b708070452c0ce49daf5f79503fbde6"
-                + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-                + " UserManager instance gets cached with a reference to the application context."
-        ) { _, sdkInt ->
-          sdkInt in 18..25
-        }
-      }
-    },
-
-    APP_WIDGET_HOST_CALLBACKS {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.appwidget.AppWidgetHost\$Callbacks", "this$0"
-            ,
-            reason =
-            "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
-                + " code. The reference to the `mContext` was not being cleared, which caused the"
-                + " Callbacks instance to retain this reference"
-                + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-                + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
-        ) { _, sdkInt ->
-          sdkInt < 22
-        }
-      }
-    },
-
-    AUDIO_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.media.AudioManager$1", "this$0",
-            reason =
-            "Prior to Android M, VideoView required audio focus from AudioManager and"
-                + " never abandoned it, which leaks the Activity context through the AudioManager."
-                + " The root of the problem is that AudioManager uses whichever"
-                + " context it receives, which in the case of the VideoView example is an Activity,"
-                + " even though it only needs the application's context. The issue is fixed in"
-                + " Android M, and the AudioManager now uses the application's context."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-                + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
-        ) { _, sdkInt ->
-          sdkInt <= 22
-        }
-      }
-    },
-
-    EDITTEXT_BLINK_MESSAGEQUEUE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.widget.Editor\$Blink", "this$0",
-            reason =
-            "The EditText Blink of the Cursor is implemented using a callback and Messages,"
-                + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-                + " contains a blinking cursor is detached, a message is posted with a delay after the"
-                + " dialog has been closed and as a result leaks the Activity."
-                + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
-                + " dismiss() method of the dialog."
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-                + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-                + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
-        ) { _, sdkInt ->
-          sdkInt <= 22
-        }
-      }
-    },
-
-    CONNECTIVITY_MANAGER__SINSTANCE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.net.ConnectivityManager", "sInstance",
-            reason =
-            "ConnectivityManager has a sInstance field that is set when the first"
-                + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
-                + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
-                + " ConnectivityManager instance is created with the activity context and stored in"
-                + " sInstance. That activity context then leaks forever."
-                + " Until this is fixed, app developers can prevent this leak by making sure the"
-                + " ConnectivityManager is first created with an App Context. E.g. in some static"
-                + " init do: context.getApplicationContext()"
-                + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
-                + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
-                + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
-                + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
-        ) { _, sdkInt ->
-          sdkInt <= 23
-        }
-      }
-    },
-
-    ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.view.accessibility.AccessibilityNodeInfo", "mOriginalText"
-            ,
-            reason =
-            "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
-                + " AccessibilityNodeInfo instances are released back in the pool,"
-                + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
-                + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
-                + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
-                + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
-                + "android/view/accessibility/AccessibilityNodeInfo.java"
-        ) { _, sdkInt ->
-          sdkInt in 26..27
-        }
-      }
-    },
-
-    BACKDROP_FRAME_RENDERER__MDECORVIEW {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.android.internal.policy.BackdropFrameRenderer", "mDecorView"
-            ,
-            reason =
-            "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
-                + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
-                + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
-                + " activity"
-        ) { _, sdkInt ->
-          sdkInt in 24..26
-        }
-      }
-    },
-
-    VIEWLOCATIONHOLDER_ROOT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.view.ViewGroup\$ViewLocationHolder",
-            "mRoot"
-            ,
-            reason = "In Android P, ViewLocationHolder has an mRoot field that is not cleared " +
-                "in its clear() method. Introduced in https://github.com/aosp-mirror" +
-                "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
-                "report: https://issuetracker.google.com/issues/112792715"
-        ) { _, sdkInt ->
-          sdkInt == 28
-        }
-      }
-    },
-
-    ACCESSIBILITY_NODE_ID_MANAGER {
-      override fun add(references: MutableSet<AndroidKnownReference>) {
-        references += instanceField(
-            "android.view.accessibility.AccessibilityNodeIdManager", "mIdsToViews"
-            ,
-            reason = """
-              Android Q Beta added AccessibilityNodeIdManager which stores all views from their
-              onAttachedToWindow() call, until detached. Unfortunately it's possible to trigger
-              the view framework to call detach before attach (by having a view removing itself
-              from its parent in onAttach, which then causes AccessibilityNodeIdManager to keep
-              children view forever. Future releases of Q will hold weak references.
-            """.trimIndent()
-        ) { _, sdkInt ->
-          sdkInt == 28
-        }
-      }
-
-    },
-
-    TEXT_TO_SPEECH {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        val reason =
-          ("TextToSpeech.shutdown() does not release its references to context objects." +
-              " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
-              " keeping the references, resulting the context objects leaked." +
-              " Developers might be able to mitigate the issue by passing application context" +
-              " to TextToSpeech constructor." +
-              " Tracked at: https://github.com/square/leakcanary/issues/1210 and" +
-              " https://issuetracker.google.com/issues/129250419")
-        references += instanceField(
-            "android.speech.tts.TextToSpeech", "mContext",
-            reason = reason
-        ) { _, sdkInt ->
-          sdkInt == 24
-        }
-
-        references += instanceField(
-            "android.speech.tts.TtsEngines", "mContext",
-            reason = reason
-        ) { _, sdkInt ->
-          sdkInt == 24
-        }
-      }
-    },
-
-    // ######## Manufacturer specific known leaks ########
-
-    // SAMSUNG
-
-    SPEN_GESTURE_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "com.samsung.android.smartclip.SpenGestureManager", "mContext"
-            ,
-            reason =
-            "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    CLIPBOARD_UI_MANAGER__SINSTANCE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.sec.clipboard.ClipboardUIManager", "mContext"
-            ,
-            reason =
-            "ClipboardUIManager is a static singleton that leaks an activity context."
-                + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-                + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-                + " application context. Example: https://gist.github.com/cypressious/"
-                + "91c4fb1455470d803a602838dfcd5774"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 19..21
-        }
-      }
-    },
-
-    SEM_CLIPBOARD_MANAGER__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.samsung.android.content.clipboard.SemClipboardManager",
-            "mContext"
-            ,
-            reason =
-            "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 19..24
-        }
-        references += instanceField(
-            "com.samsung.android.content.clipboard.SemClipboardManager$3",
-            "this$0"
-            ,
-            reason =
-            "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 22..28
-        }
-      }
-    },
-
-    SEM_EMERGENCY_MANAGER__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.samsung.android.emergencymode.SemEmergencyManager", "mContext"
-            ,
-            reason =
-            "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 19..24
-        }
-      }
-    },
-
-    SEM_PERSONA_MANAGER {
-      override fun add(references: MutableSet<AndroidKnownReference>) {
-        references += instanceField(
-            "com.samsung.android.knox.SemPersonaManager", "mContext"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 24
-        }
-      }
-    },
-
-    SEM_APP_ICON_SOLUTION {
-      override fun add(references: MutableSet<AndroidKnownReference>) {
-        references += instanceField(
-            "android.app.SemAppIconSolution", "mContext"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 28
-        }
-      }
-    },
-
-    AW_RESOURCE__SRESOURCES {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        // AwResource#setResources() is called with resources that hold a reference to the
-        // activity context (instead of the application context) and doesn't clear it.
-        // Not sure what's going on there, input welcome.
-        references += staticField(
-            "com.android.org.chromium.android_webview.AwResource", "sResources"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    TEXT_VIEW__MLAST_HOVERED_VIEW {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.widget.TextView", "mLastHoveredView",
-            reason =
-            "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 19..28
-        }
-      }
-    },
-
-    PERSONA_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.os.PersonaManager", "mContext",
-            reason =
-            "android.app.LoadedApk.mResources has a reference to"
-                + " android.content.res.Resources.mPersonaManager which has a reference to"
-                + " android.os.PersonaManager.mContext which is an activity."
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    RESOURCES__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.content.res.Resources", "mContext",
-            reason =
-            "In AOSP the Resources class does not have a context."
-                + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-                + " instance that has a context that is the activity."
-                + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    VIEW_CONFIGURATION__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.view.ViewConfiguration", "mContext",
-            reason =
-            "In AOSP the ViewConfiguration class does not have a context."
-                + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-                + " ViewConfiguration instance that has a context that is the activity."
-                + " Observed here: https://github.com/square/leakcanary/issues"
-                + "/1#issuecomment-100324683"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    AUDIO_MANAGER__MCONTEXT_STATIC {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.media.AudioManager", "mContext_static",
-            reason =
-            "Samsung added a static mContext_static field to AudioManager, holds a reference"
-                + " to the activity."
-                + " Observed here: https://github.com/square/leakcanary/issues/32"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt == 19
-        }
-      }
-    },
-
-    ACTIVITY_MANAGER_MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.app.ActivityManager", "mContext",
-            reason =
-            "Samsung added a static mContext field to ActivityManager, holds a reference"
-                + " to the activity."
-                + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
-                + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
-        ) { manufacturer, sdkInt ->
-          manufacturer == SAMSUNG && sdkInt in 22..23
-        }
-      }
-    },
-
-    // OTHER MANUFACTURERS
-
-    GESTURE_BOOST_MANAGER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.gestureboost.GestureBoostManager", "mContext"
-            ,
-            reason =
-            "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
-        ) { manufacturer, sdkInt ->
-          manufacturer == HUAWEI && sdkInt in 24..25
-        }
-      }
-    },
-
-    BUBBLE_POPUP_HELPER__SHELPER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.widget.BubblePopupHelper", "sHelper",
-            reason =
-            "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
-        ) { manufacturer, sdkInt ->
-          manufacturer == LG && sdkInt in 19..22
-        }
-      }
-    },
-
-    LGCONTEXT__MCONTEXT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.lge.systemservice.core.LGContext", "mContext",
-            reason = "LGContext is a static singleton that leaks an activity context."
-        ) { manufacturer, sdkInt ->
-          manufacturer == LG && sdkInt == 21
-        }
-      }
-    },
-
-    MAPPER_CLIENT {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0"
-            ,
-            reason =
-            "Not sure exactly what ControllerMapper is about, but there is an anonymous"
-                + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-                + " ControllerMapper.MapperClient which leaks the activity context."
-        ) { manufacturer, sdkInt ->
-          manufacturer == NVIDIA && sdkInt == 19
-        }
-      }
-    },
-
-    SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.hardware.SystemSensorManager", "mAppContextImpl"
-            ,
-            reason =
-            "SystemSensorManager stores a reference to context"
-                + " in a static field in its constructor."
-                + " Fix: use application context to get SensorManager"
-        ) { manufacturer, sdkInt ->
-          (manufacturer == LENOVO && sdkInt == 19) || (manufacturer == VIVO && sdkInt == 22)
-        }
-      }
-    },
-
-    INSTRUMENTATION_RECOMMEND_ACTIVITY {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += staticField(
-            "android.app.Instrumentation", "mRecommendActivity",
-            reason =
-            "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
-                + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
-                + " above"
-        ) { manufacturer, sdkInt ->
-          manufacturer == MEIZU && sdkInt in 21..22
-        }
-      }
-    },
-
-    DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            "android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0"
-            ,
-            reason =
-            "DevicePolicyManager keeps a reference to the context it has been created with"
-                + " instead of extracting the application context. In this Motorola build,"
-                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                + " observer, which is held into memory by a binder transport object."
-        ) { manufacturer, sdkInt ->
-          manufacturer == MOTOROLA && sdkInt in 19..22
-        }
-      }
-    },
-
-
-    // ######## General known references (not leaks) ########
-
-    REFERENCES {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += instanceField(
-            WeakReference::class.java.name, "referent",
-            status = WEAKLY_REACHABLE
-        )
-        references += instanceField(
-            KeyedWeakReference::class.java.name, "referent"
-            ,
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            SoftReference::class.java.name, "referent",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            PhantomReference::class.java.name, "referent",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.Finalizer", "prev",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.Finalizer", "element",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.Finalizer", "next",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.FinalizerReference", "prev",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.FinalizerReference", "element",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "java.lang.ref.FinalizerReference", "next",
-            status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "sun.misc.Cleaner", "prev", status = NEVER_REACHABLE
-        )
-        references += instanceField(
-            "sun.misc.Cleaner", "next", status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    FINALIZER_WATCHDOG_DAEMON {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-        // reference to the object and it was about to be GCed.
-        references += javaLocal(
-            "FinalizerWatchdogDaemon",
-            status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    MAIN {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        // The main thread stack is ever changing so local variables aren't likely to hold references
-        // for long. If this is on the shortest path, it's probably that there's a longer path with
-        // a real leak.
-        references += javaLocal(
-            "main",
-            status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    LEAK_CANARY_THREAD {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        references += javaLocal(
-            LEAK_CANARY_THREAD_NAME,
-            status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    EVENT_RECEIVER__MMESSAGE_QUEUE {
-      override fun add(
-        references: MutableSet<AndroidKnownReference>
-      ) {
-        //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-        // the native peer of the receiver is using them.
-        // The main thread message queue is held on by the main Looper, but that might be a longer
-        // path. Let's not confuse people with a shorter path that is less meaningful.
-        references += instanceField(
-            "android.view.Choreographer\$FrameDisplayEventReceiver",
-            "mMessageQueue"
-            ,
-            status = NEVER_REACHABLE
-        )
-      }
-    },
-
-    ;
-
-    internal abstract fun add(references: MutableSet<AndroidKnownReference>)
-  }
-
-
-}
-
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
deleted file mode 100644
index 6c08e69d..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import kotlin.reflect.KClass
-
-/**
- * A set of default [LeakInspector]s that knows about common AOSP and library
- * classes.
- *
- * These are heuristics based on our experience and knowledge of AOSP and various library
- * internals. We only make a decision if we're reasonably sure the state of an object is
- * unlikely to be the result of a programmer mistake.
- *
- * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
- * will not be influenced by those mistakes.
- */
-enum class AndroidLeakTraceInspectors : LeakTraceInspector {
-
-  VIEW {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.view.View") { instance ->
-        // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
-        // next toast view
-        val mParentRef = instance["android.view.View", "mParent"]!!.value
-        val mParentSet = mParentRef.isNonNullReference
-        val viewDetached = instance["android.view.View", "mAttachInfo"]!!.value.isNullReference
-
-        if (mParentSet) {
-          if (viewDetached) {
-            reportLeaking("View detached and has parent")
-          } else {
-            val viewParent = mParentRef.asObject!!.asInstance!!
-            if (viewParent instanceOf "android.view.View" &&
-                viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference) {
-              reportLeaking("View attached but parent detached (attach disorder)")
-            } else {
-              reportNotLeaking("View attached")
-            }
-          }
-        }
-
-        if (mParentSet) {
-          addLabel("View#mParent is set")
-        } else {
-          addLabel("View#mParent is null")
-        }
-
-        if (viewDetached) {
-          addLabel("View#mAttachInfo is null (view detached)")
-        } else {
-          addLabel("View#mAttachInfo is not null (view attached)")
-        }
-
-        // TODO Add back support for view id labels, see https://github.com/square/leakcanary/issues/1297
-
-        val mWindowAttachCount = instance["android.view.View", "mWindowAttachCount"]?.value?.asInt
-
-        if (mWindowAttachCount != null) {
-          addLabel("View.mWindowAttachCount=$mWindowAttachCount")
-        }
-      }
-    }
-  },
-
-  ACTIVITY {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.app.Activity") { instance ->
-        // Activity.mDestroyed was introduced in 17.
-        // https://android.googlesource.com/platform/frameworks/base/+
-        // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
-        val field = instance["android.app.Activity", "mDestroyed"]
-
-        if (field != null) {
-          if (field.value.asBoolean!!) {
-            reportLeaking(field describedWithValue "true")
-          } else {
-            reportNotLeaking(field describedWithValue "false")
-          }
-        }
-      }
-    }
-  },
-
-  CONTEXT_WRAPPER {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.content.ContextWrapper") { instance ->
-        // Activity is already taken care of
-        if (!(instance instanceOf "android.app.Activity")) {
-          var context = instance
-
-          val visitedInstances = mutableListOf<Long>()
-          var keepUnwrapping = true
-          while (keepUnwrapping) {
-            visitedInstances += context.objectId
-            keepUnwrapping = false
-            val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
-
-            if (mBase.isNonNullReference) {
-              context = mBase.asObject!!.asInstance!!
-              if (context instanceOf "android.app.Activity") {
-                val mDestroyed = instance["android.app.Activity", "mDestroyed"]
-                if (mDestroyed != null) {
-                  if (mDestroyed.value.asBoolean!!) {
-                    reportLeaking(
-                        "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed true"
-                    )
-                  } else {
-                    // We can't assume it's not leaking, because this context might have a shorter lifecycle
-                    // than the activity. So we'll just add a label.
-                    addLabel("${instance.classSimpleName} wraps an Activity with Activity.mDestroyed false")
-                  }
-                }
-              } else if (context instanceOf "android.content.ContextWrapper" &&
-                  // Avoids infinite loops
-                  context.objectId !in visitedInstances
-              ) {
-                keepUnwrapping = true
-              }
-            }
-          }
-        }
-      }
-    }
-  },
-
-  DIALOG {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.app.Dialog") { instance ->
-        val mDecor = instance["android.app.Dialog", "mDecor"]!!
-        if (mDecor.value.isNullReference) {
-          reportLeaking(mDecor describedWithValue "null")
-        } else {
-          reportNotLeaking(mDecor describedWithValue "not null")
-        }
-      }
-    }
-  },
-
-  APPLICATION {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.app.Application") {
-        reportNotLeaking("Application is a singleton")
-      }
-    }
-  },
-
-  INPUT_METHOD_MANAGER {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.view.inputmethod.InputMethodManager") {
-        reportNotLeaking("InputMethodManager is a singleton")
-      }
-    }
-  },
-
-  CLASSLOADER {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf(ClassLoader::class) {
-        reportNotLeaking("A ClassLoader is never leaking")
-      }
-    }
-  },
-
-  CLASS {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEach { reporter ->
-        if (reporter.objectRecord is GraphClassRecord) {
-          reporter.reportNotLeaking("a class is never leaking")
-        }
-      }
-    }
-  },
-
-  FRAGMENT {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.app.Fragment") { instance ->
-        val fragmentManager = instance["android.app.Fragment", "mFragmentManager"]!!
-        if (fragmentManager.value.isNullReference) {
-          reportLeaking(fragmentManager describedWithValue "null")
-        } else {
-          reportNotLeaking(fragmentManager describedWithValue "not null")
-        }
-        val mTag = instance["android.app.Fragment", "mTag"]?.value?.readAsJavaString()
-        if (!mTag.isNullOrEmpty()) {
-          addLabel("Fragment.mTag=$mTag")
-        }
-      }
-    }
-  },
-
-  SUPPORT_FRAGMENT {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.support.v4.app.Fragment") { instance ->
-        val fragmentManager = instance["android.support.v4.app.Fragment", "mFragmentManager"]!!
-        if (fragmentManager.value.isNullReference) {
-          reportLeaking(fragmentManager describedWithValue "null")
-        } else {
-          reportNotLeaking(fragmentManager describedWithValue "not null")
-        }
-        val mTag = instance["android.support.v4.app.Fragment", "mTag"]?.value?.readAsJavaString()
-        if (!mTag.isNullOrEmpty()) {
-          addLabel("Fragment.mTag=$mTag")
-        }
-      }
-    }
-  },
-
-  ANDROIDX_FRAGMENT {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("androidx.fragment.app.Fragment") { instance ->
-        val fragmentManager = instance["androidx.fragment.app.Fragment", "mFragmentManager"]!!
-        if (fragmentManager.value.isNullReference) {
-          reportLeaking(fragmentManager describedWithValue "null")
-        } else {
-          reportNotLeaking(fragmentManager describedWithValue "not null")
-        }
-        val mTag = instance["androidx.fragment.app.Fragment", "mTag"]?.value?.readAsJavaString()
-        if (!mTag.isNullOrEmpty()) {
-          addLabel("Fragment.mTag=$mTag")
-        }
-      }
-    }
-  },
-
-  MESSAGE_QUEUE {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.os.MessageQueue") { instance ->
-        val mQuitting = instance["android.os.MessageQueue", "mQuitting"]!!
-        if (mQuitting.value.asBoolean!!) {
-          reportLeaking(mQuitting describedWithValue "true")
-        } else {
-          reportNotLeaking(mQuitting describedWithValue "false")
-        }
-      }
-    }
-  },
-
-  MORTAR_PRESENTER {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("mortar.Presenter") { instance ->
-        // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
-        // should be unreachable, so in that case we don't know their reachability status. However,
-        // when the view is null, we're pretty sure they  never leaking.
-        val view = instance["mortar.Presenter", "view"]!!
-        if (view.value.isNullReference) {
-          reportLeaking(view describedWithValue "null")
-        }
-      }
-    }
-  },
-
-  COORDINATOR {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
-        val attached = instance["com.squareup.coordinators.Coordinator", "attached"]
-        if (attached!!.value.asBoolean!!) {
-          reportNotLeaking(attached describedWithValue "true")
-        } else {
-          reportLeaking(attached describedWithValue "false")
-        }
-      }
-    }
-  },
-
-  ANONYMOUS_CLASS {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEach { reporter ->
-        if (reporter.objectRecord is GraphInstanceRecord) {
-          val classRecord = reporter.objectRecord.instanceClass
-          if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
-            val parentClassRecord = classRecord.superClass!!
-            if (parentClassRecord.name == "java.lang.Object") {
-              try {
-                // This is an anonymous class implementing an interface. The API does not give access
-                // to the interfaces implemented by the class. We check if it's in the class path and
-                // use that instead.
-                val actualClass = Class.forName(classRecord.name)
-                val interfaces = actualClass.interfaces
-                reporter.addLabel(
-                    if (interfaces.isNotEmpty()) {
-                      val implementedInterface = interfaces[0]
-                      "Anonymous class implementing ${implementedInterface.name}"
-                    } else {
-                      "Anonymous subclass of java.lang.Object"
-                    }
-                )
-              } catch (ignored: ClassNotFoundException) {
-              }
-            } else {
-              // Makes it easier to figure out which anonymous class we're looking at.
-              reporter.addLabel("Anonymous subclass of ${parentClassRecord.name}")
-            }
-          }
-        }
-      }
-    }
-  },
-
-  THREAD {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf(Thread::class) { instance ->
-        val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
-        if (threadName == "main") {
-          reportNotLeaking("the main thread always runs")
-        }
-        addLabel("Thread name: '$threadName'")
-      }
-    }
-  },
-
-  WINDOW {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.view.Window") { instance ->
-        val mDestroyed = instance["android.view.Window", "mDestroyed"]!!
-
-        if (mDestroyed.value.asBoolean!!) {
-          reportLeaking(mDestroyed describedWithValue "true")
-        } else {
-          reportNotLeaking(mDestroyed describedWithValue "false")
-        }
-      }
-    }
-  },
-
-  TOAST {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.widget.Toast") { instance ->
-        val tnInstance =
-          instance["android.widget.Toast", "mTN"]!!.value.asObject!!.asInstance!!
-        // mWM is set in android.widget.Toast.TN#handleShow and never unset, so this toast was never
-        // shown, we don't know if it's leaking.
-        if (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference) {
-          // mView is reset to null in android.widget.Toast.TN#handleHide
-          if (tnInstance["android.widget.Toast\$TN", "mView"]!!.value.isNullReference) {
-            reportLeaking(
-                "This toast is done showing (Toast.mTN.mWM != null && Toast.mTN.mView == null)"
-            )
-          } else {
-            reportNotLeaking(
-                "This toast is showing (Toast.mTN.mWM != null && Toast.mTN.mView != null)"
-            )
-          }
-        }
-      }
-    }
-  },
-
-  TOAST_TN {
-    override fun inspect(
-      graph: HprofGraph,
-      leakTrace: List<LeakTraceElementReporter>
-    ) {
-      leakTrace.forEachInstanceOf("android.widget.Toast\$TN") {
-        reportNotLeaking("Toast.TN (Transient Notification) is never leaking")
-      }
-    }
-  };
-
-  companion object {
-    fun defaultInspectors(): List<LeakTraceInspector> {
-      return values().toList()
-    }
-  }
-}
-
-private infix fun GraphField.describedWithValue(valueDescription: String): String {
-  return "${classRecord.simpleName}#$name is $valueDescription"
-}
-
-inline fun List<LeakTraceElementReporter>.forEachInstanceOf(
-  expectedClass: KClass<out Any>,
-  action: LeakTraceElementReporter.(GraphInstanceRecord) -> Unit
-) {
-  forEachInstanceOf(expectedClass.java.name, action)
-}
-
-inline fun List<LeakTraceElementReporter>.forEachInstanceOf(
-  className: String,
-  action: LeakTraceElementReporter.(GraphInstanceRecord) -> Unit
-) {
-  for (reporter in this) {
-    if (reporter.objectRecord is GraphInstanceRecord && reporter.objectRecord instanceOf className) {
-      reporter.action(reporter.objectRecord)
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
deleted file mode 100644
index bc2ab18d..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
+++ /dev/null
@@ -1,26 +0,0 @@
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-
-/**
- * Inspector that automatically marks instances of the provided class names as not leaking
- * because they're app wide singletons.
- */
-class AppSingletonInspector(private vararg val singletonClasses: String) : LeakTraceInspector {
-  override fun inspect(
-    graph: HprofGraph,
-    leakTrace: List<LeakTraceElementReporter>
-  ) {
-    leakTrace.forEach { reporter ->
-      if (reporter.objectRecord is GraphInstanceRecord) {
-        reporter.objectRecord.instanceClass
-            .classHierarchy
-            .forEach { classRecord ->
-              if (classRecord.name in singletonClasses) {
-                reporter.reportNotLeaking("${classRecord.name} is an app singleton")
-              }
-            }
-      }
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
deleted file mode 100644
index 3cdfab9c..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-package leakcanary
-
-import kotlin.properties.Delegates.notNull
-
-/**
- * Turns BuildFilter into exclusion filters that HeapAnalyzer understand. Since retrieving from
- * the Hprof is not free, [BuildMirror] provides a caching mechanism. Make sure to use different
- * [BuildMirror] and set of filters for every hprof parsing.
- */
-class BuildMirror {
-
-  lateinit var manufacturer: String
-  var sdkInt: Int by notNull()
-
-  fun wrapFilter(filter: BuildFilter): (HprofGraph) -> Boolean = { graph ->
-    if (!::manufacturer.isInitialized) {
-      val buildClass = graph.indexedClass("android.os.Build")!!
-      val versionClass = graph.indexedClass("android.os.Build\$VERSION")!!
-      manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
-      sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
-    }
-    filter(manufacturer, sdkInt)
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
deleted file mode 100644
index d949e1b8..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
+++ /dev/null
@@ -1,89 +0,0 @@
-package leakcanary
-
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import java.io.Serializable
-
-/**
- * Deprioritizes specific references from being taken into account when computing the shortest strong
- * reference path from a suspected leaking instance to the GC roots.
- *
- * This class lets you ignore known memory leaks that you known about. If the shortest path
- * matches [Exclusion], than the heap analyzer should look for a longer path with nothing
- * matching in [Exclusion].
- *
- * Exclusions should be used to match patterns of known leaks that are beyond your control, for
- * examples leaks in the Android Framework or in 3rd party libraries. This won't fix the leaks,
- * and LeakCanary will still trigger, but at least it'll indicate that there's nothing you can do
- * about it.
- */
-data class Exclusion(
-  val type: ExclusionType,
-  val reason: String? = null,
-  val status: Status = WONT_FIX_LEAK,
-  val filter: (HprofGraph) -> Boolean = {true}
-) {
-  val description
-    get() = ExclusionDescription(type.matching, reason)
-
-  // Note: the enum order matters for shortest paths, do not reorder
-  enum class Status {
-    /**
-     * References matching this cannot create leaks.
-     * The shortest path finder will never go through references that match this exclusion.
-     */
-    NEVER_REACHABLE,
-    /**
-     * References matching this are known to create leaks, but those leaks will not be fixed.
-     * The shortest path finder will only go through references that match this exclusion after it
-     * has exhausted references that don't match any exclusion.
-     */
-    WONT_FIX_LEAK,
-    /**
-     * The shortest path finder will only go through references that match this exclusion after it
-     * has exhausted references that match known leak exclusions.
-     */
-    WEAKLY_REACHABLE
-  }
-
-  sealed class ExclusionType {
-    abstract val matching: String
-
-    /**
-     * Local references held in the stack of frames of a given thread.
-     */
-    class JavaLocalExclusion(
-      val threadName: String
-    ) : ExclusionType() {
-      override val matching: String
-        get() = "local variable on thread $threadName"
-    }
-
-    class StaticFieldExclusion(
-      val className: String,
-      val fieldName: String
-    ) : ExclusionType() {
-      override val matching: String
-        get() = "static field $className#$fieldName"
-    }
-
-    /**
-     * Excludes a member field of an instance of a class. [fieldName] can belong to a superclass
-     * and will still match for subclasses. This is to support overriding of rules for specific
-     * cases. If two exclusions for the same field name but different classname match in a class
-     * hierarchy, then the closest class in the hierarchy wins.
-     */
-    class InstanceFieldExclusion(
-      val className: String,
-      val fieldName: String
-    ) : ExclusionType() {
-      override val matching: String
-        get() = "field $className#$fieldName"
-    }
-  }
-
-}
-
-class ExclusionDescription(
-  val matching: String,
-  val reason: String? = null
-) : Serializable
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
deleted file mode 100644
index 442b6f4d..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
+++ /dev/null
@@ -1,121 +0,0 @@
-package leakcanary
-
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import leakcanary.internal.createSHA1Hash
-import java.io.File
-import java.io.Serializable
-
-sealed class HeapAnalysis : Serializable {
-  abstract val heapDumpFile: File
-  abstract val createdAtTimeMillis: Long
-  /** Total time spent analyzing the heap.  */
-  abstract val analysisDurationMillis: Long
-}
-
-data class HeapAnalysisFailure(
-  override val heapDumpFile: File,
-  override val createdAtTimeMillis: Long,
-  override val analysisDurationMillis: Long,
-  val exception: HeapAnalysisException
-) : HeapAnalysis()
-
-data class HeapAnalysisSuccess(
-  override val heapDumpFile: File,
-  override val createdAtTimeMillis: Long,
-  override val analysisDurationMillis: Long,
-  val retainedInstances: List<RetainedInstance>
-) : HeapAnalysis()
-
-sealed class RetainedInstance : Serializable {
-  /**
-   * Key associated to the [leakcanary.KeyedWeakReference] used to detect the memory leak.
-   * When analyzing a heap dump manually, search for all [leakcanary.KeyedWeakReference] instances,
-   * then open the one that has its "key" field set to this value. Its "referent" field contains the
-   * retained instance. Computing the shortest path to GC roots on that retained instance should
-   * enable you to figure out the cause of the leak, if any.
-   */
-  abstract val referenceKey: String
-  /**
-   * User defined name to help identify the retained instance.
-   */
-  abstract val referenceName: String
-  /**
-   * Class name of the retained instance.
-   * The class name format is the same as what would be returned by [Class.getName].
-   */
-  abstract val instanceClassName: String
-  /**
-   * Time from the request to watch the reference until the heap was dumped.
-   */
-  abstract val watchDurationMillis: Long
-  /**
-   * Time from when the instance was considered retained until the heap was dumped.
-   */
-  abstract val retainedDurationMillis: Long
-}
-
-data class NoPathToInstance(
-  override val referenceKey: String,
-  override val referenceName: String,
-  override val instanceClassName: String,
-  override val watchDurationMillis: Long,
-  override val retainedDurationMillis: Long
-) : RetainedInstance()
-
-data class LeakingInstance(
-  override val referenceKey: String,
-  override val referenceName: String,
-  override val instanceClassName: String,
-  override val watchDurationMillis: Long,
-  override val retainedDurationMillis: Long,
-
-  /**
-   * True if the only path to the leaking reference is through excluded references. Usually, that
-   * means you can safely ignore this report.
-   */
-  val exclusionStatus: Exclusion.Status?,
-  /**
-   * Shortest path to GC roots for the leaking instance.
-   */
-  val leakTrace: LeakTrace,
-  /**
-   * The number of bytes which would be freed if all references to the leaking object were
-   * released. Null if the retained heap size was not computed.
-   */
-  val retainedHeapSize: Int?
-
-) : RetainedInstance() {
-
-  val groupHash = createGroupHash()
-
-  val instanceClassSimpleName: String
-    get() {
-      val separator = instanceClassName.lastIndexOf('.')
-      return if (separator == -1) instanceClassName else instanceClassName.substring(separator + 1)
-    }
-
-  private fun createGroupHash(): String {
-    val uniqueString = if (exclusionStatus == WONT_FIX_LEAK) {
-      leakTrace.firstElementExclusion.matching
-    } else {
-      leakTrace.leakCauses
-          .joinToString(separator = "") { element ->
-            val referenceName = element.reference!!.groupingName
-            element.className + referenceName
-          }
-    }
-    return uniqueString.createSHA1Hash()
-  }
-}
-
-fun HeapAnalysis.leakingInstances(): List<LeakingInstance> {
-  if (this is HeapAnalysisFailure) {
-    return emptyList()
-  }
-  val success = this as HeapAnalysisSuccess
-  return success.retainedInstances.filter { it is LeakingInstance }
-      .map { it as LeakingInstance }
-}
-
-fun HeapAnalysis.applicationLeaks(): List<LeakingInstance> =
-  leakingInstances().filter { it.exclusionStatus == null }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
deleted file mode 100644
index b1a14d8d..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ /dev/null
@@ -1,619 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
-import leakcanary.AnalyzerProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
-import leakcanary.AnalyzerProgressListener.Step.COMPUTING_RETAINED_SIZE
-import leakcanary.AnalyzerProgressListener.Step.FINDING_WATCHED_REFERENCES
-import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
-import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.ReferenceCleanup
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.LeakNode.ChildNode
-import leakcanary.LeakNodeStatus.LEAKING
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.LeakTraceElement.Holder.ARRAY
-import leakcanary.LeakTraceElement.Holder.CLASS
-import leakcanary.LeakTraceElement.Holder.OBJECT
-import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.PrimitiveType.BOOLEAN
-import leakcanary.PrimitiveType.BYTE
-import leakcanary.PrimitiveType.CHAR
-import leakcanary.PrimitiveType.DOUBLE
-import leakcanary.PrimitiveType.FLOAT
-import leakcanary.PrimitiveType.INT
-import leakcanary.PrimitiveType.LONG
-import leakcanary.PrimitiveType.SHORT
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.internal.KeyedWeakReferenceMirror
-import leakcanary.internal.ShortestPathFinder
-import leakcanary.internal.ShortestPathFinder.Result
-import leakcanary.internal.ShortestPathFinder.Results
-import leakcanary.internal.hppc.LongLongScatterMap
-import leakcanary.internal.lastSegment
-import java.io.Closeable
-import java.io.File
-import java.util.ArrayList
-import java.util.LinkedHashMap
-import java.util.concurrent.TimeUnit.NANOSECONDS
-import kotlin.reflect.KClass
-
-/**
- * Analyzes heap dumps to look for leaks.
- */
-class HeapAnalyzer constructor(
-  private val listener: AnalyzerProgressListener
-) {
-
-  /**
-   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  fun checkForLeaks(
-    heapDumpFile: File,
-    exclusions: List<Exclusion> = emptyList(),
-    computeRetainedHeapSize: Boolean = false,
-    leakTraceInspectors: List<LeakTraceInspector> = emptyList()
-  ): HeapAnalysis {
-    val analysisStartNanoTime = System.nanoTime()
-
-    if (!heapDumpFile.exists()) {
-      val exception = IllegalArgumentException("File does not exist: $heapDumpFile")
-      return HeapAnalysisFailure(
-          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-          HeapAnalysisException(exception)
-      )
-    }
-
-    listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
-
-    try {
-      listener.onProgressUpdate(SCANNING_HEAP_DUMP)
-      val (graph, hprofCloseable, gcRootIds, keyedWeakReferenceInstances, cleaners) = scan(
-          heapDumpFile, computeRetainedHeapSize
-      )
-      hprofCloseable.use {
-        val analysisResults = mutableMapOf<String, RetainedInstance>()
-        listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
-
-        val retainedWeakRefs = findLeakingReferences(graph, keyedWeakReferenceInstances)
-
-        if (retainedWeakRefs.isEmpty()) {
-          val exception = IllegalStateException("No retained instances found in heap dump")
-          return HeapAnalysisFailure(
-              heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-              HeapAnalysisException(exception)
-          )
-        }
-
-        val (pathResults, dominatedInstances) =
-          findShortestPaths(
-              graph, exclusions, retainedWeakRefs, gcRootIds,
-              computeRetainedHeapSize
-          )
-
-        val retainedSizes = if (computeRetainedHeapSize) {
-          computeRetainedSizes(graph, pathResults, dominatedInstances, cleaners)
-        } else {
-          null
-        }
-
-        buildLeakTraces(
-            leakTraceInspectors, pathResults, graph,
-            retainedWeakRefs, analysisResults, retainedSizes
-        )
-
-        addRemainingInstancesWithNoPath(retainedWeakRefs, analysisResults)
-
-        return HeapAnalysisSuccess(
-            heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-            analysisResults.values.toList()
-        )
-      }
-    } catch (exception: Throwable) {
-      return HeapAnalysisFailure(
-          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-          HeapAnalysisException(exception)
-      )
-    }
-  }
-
-  private data class ScanResult(
-    val graph: HprofGraph,
-    val hprofCloseable: Closeable,
-    val gcRootIds: MutableList<GcRoot>,
-    val keyedWeakReferenceInstances: List<GraphInstanceRecord>,
-    val cleaners: MutableList<Long>
-  )
-
-  private fun scan(
-    hprofFile: File,
-    computeRetainedSize: Boolean
-  ): ScanResult {
-    val gcRoot = mutableListOf<GcRoot>()
-    val cleaners = mutableListOf<Long>()
-
-    val recordListener = object : OnRecordListener {
-      override fun recordTypes(): Set<KClass<out Record>> = setOf(GcRootRecord::class)
-
-      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
-      }
-
-      override fun onRecord(
-        position: Long,
-        record: Record
-      ) {
-        when (record) {
-          is GcRootRecord -> {
-            // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
-            // to do? What's VmInternal exactly? History does not go further than
-            // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
-            // We should log to figure out what objects VmInternal points to.
-            when (record.gcRoot) {
-              // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
-              // belongs to
-              is ThreadObject,
-              is JniGlobal,
-              is JniLocal,
-              is JavaFrame,
-              is NativeStack,
-              is StickyClass,
-              is ThreadBlock,
-              is MonitorUsed,
-                // TODO What is this and why do we care about it as a root?
-              is ReferenceCleanup,
-              is JniMonitor
-              -> {
-                gcRoot.add(record.gcRoot)
-              }
-            }
-          }
-          else -> {
-            throw IllegalArgumentException("Unexpected record $record")
-          }
-        }
-      }
-    }
-    val (graph, hprofCloseable) = HprofGraph.readHprof(hprofFile, recordListener)
-
-    val keyedWeakReferenceInstances = mutableListOf<GraphInstanceRecord>()
-    graph.instanceSequence()
-        .forEach { instance ->
-          val className = instance.className
-          if (className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference") {
-            keyedWeakReferenceInstances.add(instance)
-          } else if (computeRetainedSize && className == "sun.misc.Cleaner") {
-            cleaners.add(instance.objectId)
-          }
-        }
-    return ScanResult(graph, hprofCloseable, gcRoot, keyedWeakReferenceInstances, cleaners)
-  }
-
-  private fun findLeakingReferences(
-    graph: HprofGraph,
-    keyedWeakReferenceInstances: List<GraphInstanceRecord>
-  ): MutableList<KeyedWeakReferenceMirror> {
-
-    val keyedWeakReferenceClass = graph.indexedClass(KeyedWeakReference::class.java.name)
-
-    val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
-      null
-    } else {
-      keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
-    }
-
-    if (heapDumpUptimeMillis == null) {
-      CanaryLog.d(
-          "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
-              "this must be a heap dump from an older version of LeakCanary."
-      )
-    }
-
-    val retainedInstances = mutableListOf<KeyedWeakReferenceMirror>()
-    keyedWeakReferenceInstances.forEach { record ->
-      val weakRef =
-        KeyedWeakReferenceMirror.fromInstance(record, heapDumpUptimeMillis)
-      if (weakRef.isRetained && weakRef.hasReferent) {
-        retainedInstances.add(weakRef)
-      }
-    }
-    return retainedInstances
-  }
-
-  private fun findShortestPaths(
-    graph: HprofGraph,
-    exclusions: List<Exclusion>,
-    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<GcRoot>,
-    computeDominators: Boolean
-  ): Results {
-    val pathFinder = ShortestPathFinder()
-    return pathFinder.findPaths(
-        graph, exclusions, leakingWeakRefs, gcRootIds, computeDominators, listener
-    )
-  }
-
-  private fun computeRetainedSizes(
-    graph: HprofGraph,
-    results: List<Result>,
-    dominatedInstances: LongLongScatterMap,
-    cleaners: MutableList<Long>
-  ): List<Int> {
-    listener.onProgressUpdate(COMPUTING_NATIVE_RETAINED_SIZE)
-
-    // Map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
-    val nativeSizes = mutableMapOf<Long, Int>().withDefault { 0 }
-    // Doc from perflib:
-    // Native allocations can be identified by looking at instances of
-    // libcore.util.NativeAllocationRegistry$CleanerThunk. The "owning" Java object is the
-    // "referent" field of the "sun.misc.Cleaner" instance with a hard reference to the
-    // CleanerThunk.
-    //
-    // The size is in the 'size' field of the libcore.util.NativeAllocationRegistry instance
-    // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
-    // the CleanerThunk. The hprof does not include the native bytes pointed to.
-
-    cleaners.forEach { objectId ->
-      val cleaner = graph.indexedObject(objectId).asInstance!!
-      val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
-      val thunkId = thunkField?.value?.asNonNullObjectIdReference
-      val referentId =
-        cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectIdReference
-      if (thunkId != null && referentId != null) {
-        val thunkRecord = thunkField.value.asObject
-        if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
-          val allocationRegistryIdField =
-            thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
-          if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
-            val allocationRegistryRecord = allocationRegistryIdField.value.asObject
-            if (allocationRegistryRecord is GraphInstanceRecord && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
-              var nativeSize = nativeSizes.getValue(referentId)
-              nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
-                  ?: 0
-              nativeSizes[referentId] = nativeSize
-            }
-          }
-        }
-      }
-    }
-
-    listener.onProgressUpdate(COMPUTING_RETAINED_SIZE)
-
-    val sizeByDominator = LinkedHashMap<Long, Int>().withDefault { 0 }
-
-    // Include self size for leaking instances
-    val leakingInstanceIds = mutableSetOf<Long>()
-    results.forEach { result ->
-      val leakingInstanceId = result.weakReference.referent.value
-      leakingInstanceIds.add(leakingInstanceId)
-      val instanceRecord = graph.indexedObject(leakingInstanceId).asInstance!!
-      val classRecord = instanceRecord.instanceClass
-      var retainedSize = sizeByDominator.getValue(leakingInstanceId)
-
-      retainedSize += classRecord.readRecord()
-          .instanceSize
-      sizeByDominator[leakingInstanceId] = retainedSize
-    }
-
-    // Compute the size of each dominated instance and add to dominator
-    dominatedInstances.forEach { instanceId, dominatorId ->
-      // Avoid double reporting as those sizes will move up to the root dominator
-      if (instanceId !in leakingInstanceIds) {
-        val currentSize = sizeByDominator.getValue(dominatorId)
-        val nativeSize = nativeSizes.getValue(instanceId)
-        val shallowSize = graph.computeShallowSize(graph.indexedObject(instanceId))
-        sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
-      }
-    }
-
-    // Move retained sizes from dominated leaking instance to dominators leaking instances.
-    // Keep doing this until nothing moves.
-    var sizedMoved: Boolean
-    do {
-      sizedMoved = false
-      results.map { it.weakReference.referent.value }
-          .forEach { leakingInstanceId ->
-            val dominator = dominatedInstances[leakingInstanceId]
-            if (dominator != null) {
-              val retainedSize = sizeByDominator.getValue(leakingInstanceId)
-              if (retainedSize > 0) {
-                sizeByDominator[leakingInstanceId] = 0
-                val dominatorRetainedSize = sizeByDominator.getValue(dominator)
-                sizeByDominator[dominator] = retainedSize + dominatorRetainedSize
-                sizedMoved = true
-              }
-            }
-          }
-    } while (sizedMoved)
-    dominatedInstances.release()
-    return results.map { result ->
-      sizeByDominator[result.weakReference.referent.value]!!
-    }
-  }
-
-  private fun buildLeakTraces(
-    leakTraceInspectors: List<LeakTraceInspector>,
-    pathResults: List<Result>,
-    graph: HprofGraph,
-    leakingWeakRefs: MutableList<KeyedWeakReferenceMirror>,
-    analysisResults: MutableMap<String, RetainedInstance>,
-    retainedSizes: List<Int>?
-  ) {
-    listener.onProgressUpdate(BUILDING_LEAK_TRACES)
-
-    pathResults.forEachIndexed { index, pathResult ->
-      val weakReference = pathResult.weakReference
-      val removed = leakingWeakRefs.remove(weakReference)
-      if (!removed) {
-        throw IllegalStateException(
-            "ShortestPathFinder found an instance we didn't ask it to find: $pathResult"
-        )
-      }
-
-      val leakTrace =
-        buildLeakTrace(graph, leakTraceInspectors, pathResult.leakingNode)
-
-      // We get the class name from the heap dump rather than the weak reference because primitive
-      // arrays are more readable that way, e.g. "[C" at runtime vs "char[]" in the heap dump.
-      val instanceClassName =
-        recordClassName(graph.indexedObject(pathResult.leakingNode.instance))
-
-      val leakDetected = LeakingInstance(
-          referenceKey = weakReference.key,
-          referenceName = weakReference.name,
-          instanceClassName = instanceClassName,
-          watchDurationMillis = weakReference.watchDurationMillis,
-          retainedDurationMillis = weakReference.retainedDurationMillis ?: 0,
-          exclusionStatus = pathResult.exclusionStatus, leakTrace = leakTrace,
-          retainedHeapSize = retainedSizes?.get(index)
-      )
-      analysisResults[weakReference.key] = leakDetected
-    }
-  }
-
-  private fun addRemainingInstancesWithNoPath(
-    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    analysisResults: MutableMap<String, RetainedInstance>
-  ) {
-    leakingWeakRefs.forEach { refWithNoPath ->
-      val key = refWithNoPath.key
-      val name = refWithNoPath.name
-      val className = refWithNoPath.className
-      val noLeak = NoPathToInstance(
-          key, name, className, refWithNoPath.watchDurationMillis,
-          refWithNoPath.retainedDurationMillis ?: 0
-      )
-      analysisResults[key] = noLeak
-    }
-  }
-
-  private fun buildLeakTrace(
-    graph: HprofGraph,
-    leakTraceInspectors: List<LeakTraceInspector>,
-    leakingNode: LeakNode
-  ): LeakTrace {
-    val elements = ArrayList<LeakTraceElement>()
-    // We iterate from the leak to the GC root
-    val ignored = leakingNode.instance
-
-    val leafNode = ChildNode(ignored, Int.MAX_VALUE, null, leakingNode, null)
-
-    var node: LeakNode = leafNode
-    val nodes = mutableListOf<LeakNode>()
-    val leakReporters = mutableListOf<LeakTraceElementReporter>()
-    while (node is ChildNode) {
-      nodes.add(0, node.parent)
-      leakReporters.add(
-          0, LeakTraceElementReporter(graph.indexedObject(node.parent.instance))
-      )
-      node = node.parent
-    }
-
-    leakTraceInspectors.forEach { it.inspect(graph, leakReporters) }
-
-    val leakStatuses = computeLeakStatuses(leakReporters)
-
-    node = leafNode
-    while (node is ChildNode) {
-      val index = (nodes.size - elements.size) - 1
-      val leakReporter = leakReporters[index]
-      val leakStatus = leakStatuses[index]
-      elements.add(0, buildLeakElement(graph, node, leakReporter.labels, leakStatus))
-      node = node.parent
-    }
-    return LeakTrace(elements)
-  }
-
-  private fun computeLeakStatuses(
-    leakReporters: List<LeakTraceElementReporter>
-  ): List<LeakNodeStatusAndReason> {
-    var lastNotLeakingElementIndex = 0
-    val lastElementIndex = leakReporters.size - 1
-    var firstLeakingElementIndex = lastElementIndex
-
-    val leakStatuses = ArrayList<LeakNodeStatusAndReason>()
-
-    for ((index, reporter) in leakReporters.withIndex()) {
-      val leakStatus = inspectElementLeakStatus(reporter)
-      leakStatuses.add(leakStatus)
-      if (leakStatus.status == NOT_LEAKING) {
-        lastNotLeakingElementIndex = index
-        // Reset firstLeakingElementIndex so that we never have
-        // firstLeakingElementIndex < lastNotLeakingElementIndex
-        firstLeakingElementIndex = lastElementIndex
-      } else if (firstLeakingElementIndex == lastElementIndex && leakStatus.status == LEAKING) {
-        firstLeakingElementIndex = index
-      }
-    }
-
-    leakStatuses[0] = when (leakStatuses[0].status) {
-      UNKNOWN -> LeakNodeStatus.notLeaking("it's a GC root")
-      NOT_LEAKING -> LeakNodeStatus.notLeaking(
-          "it's a GC root and ${leakStatuses[0].reason}"
-      )
-      LEAKING -> LeakNodeStatus.notLeaking(
-          "it's a GC root. Conflicts with ${leakStatuses[0].reason}"
-      )
-    }
-
-    leakStatuses[lastElementIndex] = when (leakStatuses[lastElementIndex].status) {
-      UNKNOWN -> LeakNodeStatus.leaking("RefWatcher was watching this")
-      LEAKING -> LeakNodeStatus.leaking(
-          "RefWatcher was watching this and ${leakStatuses[lastElementIndex].reason}"
-      )
-      NOT_LEAKING -> LeakNodeStatus.leaking(
-          "RefWatcher was watching this. Conflicts with ${leakStatuses[lastElementIndex].reason}"
-      )
-    }
-
-    val simpleClassNames = leakReporters.map { reporter ->
-      recordClassName(reporter.objectRecord).lastSegment('.')
-    }
-
-    // First and last are always known.
-    for (i in 1 until lastElementIndex) {
-      val leakStatus = leakStatuses[i]
-      if (i < lastNotLeakingElementIndex) {
-        val nextNotLeakingName = simpleClassNames[i + 1]
-        leakStatuses[i] = when (leakStatus.status) {
-          UNKNOWN -> LeakNodeStatus.notLeaking("$nextNotLeakingName‚Üì is not leaking")
-          NOT_LEAKING -> LeakNodeStatus.notLeaking(
-              "$nextNotLeakingName‚Üì is not leaking and ${leakStatus.reason}"
-          )
-          LEAKING -> LeakNodeStatus.notLeaking(
-              "$nextNotLeakingName‚Üì is not leaking. Conflicts with ${leakStatus.reason}"
-          )
-        }
-      } else if (i > firstLeakingElementIndex) {
-        val previousLeakingName = simpleClassNames[i - 1]
-        leakStatuses[i] = LeakNodeStatus.leaking("$previousLeakingName‚Üë is leaking")
-
-        leakStatuses[i] = when (leakStatus.status) {
-          UNKNOWN -> LeakNodeStatus.leaking("$previousLeakingName‚Üë is leaking")
-          LEAKING -> LeakNodeStatus.leaking(
-              "$previousLeakingName‚Üë is leaking and ${leakStatus.reason}"
-          )
-          NOT_LEAKING -> throw IllegalStateException("Should never happen")
-        }
-      }
-    }
-    return leakStatuses
-  }
-
-  private fun inspectElementLeakStatus(
-    reporter: LeakTraceElementReporter
-  ): LeakNodeStatusAndReason {
-    var current = LeakNodeStatus.unknown()
-    for (statusAndReason in reporter.leakNodeStatuses) {
-      current = when {
-        current.status == UNKNOWN -> statusAndReason
-        current.status == LEAKING && statusAndReason.status == LEAKING -> {
-          LeakNodeStatus.leaking("${current.reason} and ${statusAndReason.reason}")
-        }
-        current.status == NOT_LEAKING && statusAndReason.status == NOT_LEAKING -> {
-          LeakNodeStatus.notLeaking("${current.reason} and ${statusAndReason.reason}")
-        }
-        current.status == NOT_LEAKING && statusAndReason.status == LEAKING -> {
-          LeakNodeStatus.notLeaking(
-              "${current.reason}. Conflicts with ${statusAndReason.reason}"
-          )
-        }
-        current.status == LEAKING && statusAndReason.status == NOT_LEAKING -> {
-          LeakNodeStatus.notLeaking(
-              "${statusAndReason.reason}. Conflicts with ${current.reason}"
-          )
-        }
-        else -> throw IllegalStateException(
-            "Should never happen ${current.status} ${statusAndReason.reason}"
-        )
-      }
-    }
-    return current
-  }
-
-  private fun buildLeakElement(
-    graph: HprofGraph,
-    node: ChildNode,
-    labels: List<String>,
-    leakStatus: LeakNodeStatusAndReason
-  ): LeakTraceElement {
-    val objectId = node.parent.instance
-
-    val graphRecord = graph.indexedObject(objectId)
-
-    val className = recordClassName(graphRecord)
-
-    val holderType = if (graphRecord is GraphClassRecord) {
-      CLASS
-    } else if (graphRecord is GraphObjectArrayRecord || graphRecord is GraphPrimitiveArrayRecord) {
-      ARRAY
-    } else {
-      val instanceRecord = graphRecord.asInstance!!
-      if (instanceRecord.instanceClass.classHierarchy.any { it.name == Thread::class.java.name }) {
-        THREAD
-      } else {
-        OBJECT
-      }
-    }
-    return LeakTraceElement(
-        node.leakReference, holderType, className, node.exclusion, labels, leakStatus
-    )
-  }
-
-  private fun recordClassName(
-    graphRecord: GraphObjectRecord
-  ): String {
-    return when (graphRecord) {
-      is GraphClassRecord -> graphRecord.name
-      is GraphInstanceRecord -> graphRecord.className
-      is GraphObjectArrayRecord -> graphRecord.arrayClassName
-      is GraphPrimitiveArrayRecord -> when (graphRecord.primitiveType) {
-        BOOLEAN -> "boolean[]"
-        CHAR -> "char[]"
-        FLOAT -> "float[]"
-        DOUBLE -> "double[]"
-        BYTE -> "byte[]"
-        SHORT -> "short[]"
-        INT -> "int[]"
-        LONG -> "long[]"
-      }
-    }
-  }
-
-  private fun since(analysisStartNanoTime: Long): Long {
-    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
-  }
-
-  companion object {
-    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
-    internal val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
deleted file mode 100644
index 60ef3694..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
+++ /dev/null
@@ -1,23 +0,0 @@
-package leakcanary
-
-sealed class LeakNode {
-  abstract val instance: Long
-  /** Used by the shortest path finder to create a segmented FIFO queue using a priority queue. */
-  abstract val visitOrder: Int
-
-  class RootNode(
-    override val instance: Long,
-    override val visitOrder: Int
-  ) : LeakNode()
-
-  class ChildNode(
-    override val instance: Long,
-    override val visitOrder: Int,
-    val exclusion: ExclusionDescription?,
-    val parent: LeakNode,
-    /**
-     * The reference from the parent to this node
-     */
-    val leakReference: LeakReference?
-  ) : LeakNode()
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
deleted file mode 100644
index 526ef11f..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
+++ /dev/null
@@ -1,33 +0,0 @@
-package leakcanary
-
-import java.io.Serializable
-
-enum class LeakNodeStatus {
-  NOT_LEAKING,
-  LEAKING,
-  UNKNOWN;
-
-  companion object {
-    private val UNKNOWN_REACHABILITY = LeakNodeStatusAndReason(UNKNOWN, "")
-
-    /** The instance was needed and therefore expected to be reachable.  */
-    fun notLeaking(reason: String): LeakNodeStatusAndReason {
-      return LeakNodeStatusAndReason(NOT_LEAKING, reason)
-    }
-
-    /** The instance was no longer needed and therefore expected to be unreachable.  */
-    fun leaking(reason: String): LeakNodeStatusAndReason {
-      return LeakNodeStatusAndReason(LEAKING, reason)
-    }
-
-    /** No decision can be made about the provided instance.  */
-    fun unknown(): LeakNodeStatusAndReason {
-      return UNKNOWN_REACHABILITY
-    }
-  }
-}
-
-class LeakNodeStatusAndReason internal constructor(
-  val status: LeakNodeStatus,
-  val reason: String
-) : Serializable
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
deleted file mode 100644
index 1f05e5cb..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
+++ /dev/null
@@ -1,40 +0,0 @@
-package leakcanary
-
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.internal.renderToString
-import java.io.Serializable
-
-/**
- * A chain of references that constitute the shortest strong reference path from a leaking instance
- * to the GC roots. Fixing the leak usually means breaking one of the references in that chain.
- */
-data class LeakTrace(
-  val elements: List<LeakTraceElement>
-) : Serializable {
-
-  val firstElementExclusion
-    get() = elements.first { element ->
-      element.exclusion != null
-    }.exclusion!!
-
-  val leakCauses = elements.filterIndexed { index, _ ->
-    elementMayBeLeakCause(index)
-  }
-
-  override fun toString(): String {
-    return "\n${renderToString()}\n"
-  }
-
-  fun elementMayBeLeakCause(index: Int): Boolean {
-    return when (elements[index].leakStatusAndReason.status) {
-      UNKNOWN -> true
-      NOT_LEAKING -> if (index < elements.lastIndex) {
-        elements[index + 1].leakStatusAndReason.status != NOT_LEAKING
-      } else {
-        true
-      }
-      else -> false
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt
deleted file mode 100644
index a9344870..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt
+++ /dev/null
@@ -1,26 +0,0 @@
-package leakcanary
-
-class LeakTraceElementReporter(val objectRecord: GraphObjectRecord) {
-
-  private val mutableLabels = mutableListOf<String>()
-  private val mutableLeakNodeStatuses = mutableListOf<LeakNodeStatusAndReason>()
-
-  val labels: List<String>
-    get() = mutableLabels
-
-  val leakNodeStatuses: List<LeakNodeStatusAndReason>
-    get() = mutableLeakNodeStatuses
-
-  fun addLabel(label: String) {
-    mutableLabels += label
-  }
-
-  fun reportLeaking(reason: String) {
-    mutableLeakNodeStatuses += LeakNodeStatus.leaking(reason)
-  }
-
-  fun reportNotLeaking(reason: String) {
-    mutableLeakNodeStatuses += LeakNodeStatus.notLeaking(reason)
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt
deleted file mode 100644
index 786bddb8..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt
+++ /dev/null
@@ -1,8 +0,0 @@
-package leakcanary
-
-interface LeakTraceInspector {
-  fun inspect(
-    graph: HprofGraph,
-    leakTrace: List<LeakTraceElementReporter>
-  )
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
deleted file mode 100644
index 43007024..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ /dev/null
@@ -1,627 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import leakcanary.AnalyzerProgressListener
-import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
-import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
-import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.Status
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.GcRoot
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HprofGraph
-import leakcanary.HprofReader
-import leakcanary.LeakNode
-import leakcanary.LeakNode.ChildNode
-import leakcanary.LeakNode.RootNode
-import leakcanary.LeakReference
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
-import leakcanary.LeakTraceElement.Type.LOCAL
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.internal.hppc.LongLongScatterMap
-import leakcanary.internal.hppc.LongScatterSet
-import java.util.LinkedHashMap
-import java.util.PriorityQueue
-
-/**
- * Not thread safe.
- *
- * Finds the shortest path from leaking references to a gc root, ignoring excluded
- * refs first and then including the ones that are not "always ignorable" as needed if no path is
- * found.
- *
- * Skips enqueuing strings as an optimization, so if the leaking reference is a string then it will
- * never be found.
- */
-internal class ShortestPathFinder {
-
-  /**
-   * A segmented FIFO queue. The queue is segmented by [Status]. Within each segment the elements
-   * are ordered FIFO.
-   */
-  private val toVisitQueue = PriorityQueue<LeakNode>(1024, Comparator { node1, node2 ->
-    val priorityComparison = toVisitMap[node1.instance]!!.compareTo(toVisitMap[node2.instance]!!)
-    if (priorityComparison != 0) {
-      priorityComparison
-    } else {
-      node1.visitOrder.compareTo(node2.visitOrder)
-    }
-  })
-  /** Set of instances to visit */
-  private val toVisitMap = LinkedHashMap<Long, Status>()
-  private val visitedSet = LongScatterSet()
-  private lateinit var referentMap: Map<Long, KeyedWeakReferenceMirror>
-  private var visitOrder = 0
-
-  /**
-   * Map of instances to their leaking dominator.
-   * var because the instance will be returned by [findPaths] and replaced with a new empty map
-   * here (copying it could be expensive).
-   *
-   * If an instance has been added to [toVisitMap] or [visitedSet] and is missing from
-   * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
-   * and cannot be dominated by a leaking instance.
-   */
-  private var dominatedInstances = LongLongScatterMap()
-  private var sizeOfObjectInstances = 0
-
-  class Result(
-    val leakingNode: LeakNode,
-    val exclusionStatus: Status?,
-    val weakReference: KeyedWeakReferenceMirror
-  )
-
-  data class Results(
-    val results: List<Result>,
-    val dominatedInstances: LongLongScatterMap
-  )
-
-  fun findPaths(
-    graph: HprofGraph,
-    exclusions: List<Exclusion>,
-    leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<GcRoot>,
-    computeDominators: Boolean,
-    listener: AnalyzerProgressListener
-  ): Results {
-    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
-    clearState()
-
-    val objectClass = graph.indexedClass("java.lang.Object")
-    sizeOfObjectInstances = if (objectClass != null) {
-      // In Android 16 ClassDumpRecord.instanceSize can be 8 yet there are 0 fields.
-      // Better rely on our own computation of instance size.
-      // See #1374
-      val objectClassFieldSize = objectClass.readRecord()
-          .fields.sumBy {
-        graph.sizeOfFieldType(it.type)
-      }
-
-      // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
-      val sizeOfObjectOnArt =
-        graph.sizeOfFieldType(HprofReader.OBJECT_TYPE) + graph.sizeOfFieldType(HprofReader.INT_TYPE)
-      if (objectClassFieldSize == sizeOfObjectOnArt) {
-        sizeOfObjectOnArt
-      } else {
-        0
-      }
-    } else {
-      0
-    }
-
-    val fieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
-    val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
-    val threadNames = mutableMapOf<String, Exclusion>()
-
-    exclusions.filter { it.filter(graph) }
-        .forEach { exclusion ->
-          when (exclusion.type) {
-            is ExclusionType.JavaLocalExclusion -> {
-              threadNames[exclusion.type.threadName] = exclusion
-            }
-            is StaticFieldExclusion -> {
-              val mapOrNull = staticFieldNameByClassName[exclusion.type.className]
-              val map = if (mapOrNull != null) mapOrNull else {
-                val newMap = mutableMapOf<String, Exclusion>()
-                staticFieldNameByClassName[exclusion.type.className] = newMap
-                newMap
-              }
-              map[exclusion.type.fieldName] = exclusion
-            }
-            is InstanceFieldExclusion -> {
-              val mapOrNull = fieldNameByClassName[exclusion.type.className]
-              val map = if (mapOrNull != null) mapOrNull else {
-                val newMap = mutableMapOf<String, Exclusion>()
-                fieldNameByClassName[exclusion.type.className] = newMap
-                newMap
-              }
-              map[exclusion.type.fieldName] = exclusion
-            }
-          }
-        }
-
-    // Referent object id to weak ref mirror
-    referentMap = leakingWeakRefs.associateBy { it.referent.value }
-
-    enqueueGcRoots(graph, gcRootIds, threadNames, computeDominators)
-
-    var lowestPriority = ALWAYS_REACHABLE
-    val results = mutableListOf<Result>()
-    visitingQueue@ while (!toVisitQueue.isEmpty()) {
-      val node = toVisitQueue.poll()!!
-      val priority = toVisitMap[node.instance]!!
-      // Lowest priority has the highest value
-      if (priority > lowestPriority) {
-        lowestPriority = priority
-      }
-
-      toVisitMap.remove(node.instance)
-
-      if (checkSeen(node)) {
-        continue
-      }
-
-      val weakReference = referentMap[node.instance]
-      if (weakReference != null) {
-        val exclusionPriority = if (lowestPriority == ALWAYS_REACHABLE) null else lowestPriority
-        results.add(Result(node, exclusionPriority, weakReference))
-        // Found all refs, stop searching (unless computing retained size which stops on weak reachables)
-        if (results.size == leakingWeakRefs.size) {
-          if (computeDominators && lowestPriority < WEAKLY_REACHABLE) {
-            listener.onProgressUpdate(FINDING_DOMINATORS)
-          } else {
-            break@visitingQueue
-          }
-        }
-      }
-
-      if (results.size == leakingWeakRefs.size && computeDominators && lowestPriority >= WEAKLY_REACHABLE) {
-        break@visitingQueue
-      }
-
-      when (val graphRecord = graph.indexedObject(node.instance)) {
-        is GraphClassRecord -> visitClassRecord(
-            graph, graphRecord, node, staticFieldNameByClassName, computeDominators
-        )
-        is GraphInstanceRecord -> visitInstanceRecord(
-            graph, graphRecord, node, fieldNameByClassName, computeDominators
-        )
-        is GraphObjectArrayRecord -> visitObjectArrayRecord(
-            graph, graphRecord.readRecord(), node, computeDominators
-        )
-      }
-    }
-
-    val dominatedInstances = this.dominatedInstances
-
-    clearState()
-
-    return Results(results, dominatedInstances)
-  }
-
-  private fun checkSeen(node: LeakNode): Boolean {
-    val neverSeen = visitedSet.add(node.instance)
-    return !neverSeen
-  }
-
-  private fun clearState() {
-    toVisitQueue.clear()
-    toVisitMap.clear()
-    visitedSet.release()
-    visitOrder = 0
-    referentMap = emptyMap()
-    dominatedInstances = LongLongScatterMap()
-    sizeOfObjectInstances = 0
-  }
-
-  private fun enqueueGcRoots(
-    graph: HprofGraph,
-    gcRoots: MutableList<GcRoot>,
-    threadNameExclusions: Map<String, Exclusion>,
-    computeDominators: Boolean
-  ) {
-    gcRoots.removeAll { it.id == 0L }
-
-    // Sorting GC roots to get stable shortest path
-    // Once sorted all ThreadObject Gc Roots are located before JavaLocalExclusion Gc Roots.
-    // This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
-    // built before JavaFrames.
-    sortGcRoots(graph, gcRoots)
-
-    val threadsBySerialNumber = mutableMapOf<Int, ThreadObject>()
-    gcRoots.forEach { gcRoot ->
-      if (computeDominators) {
-        undominateWithSkips(graph, gcRoot.id)
-      }
-      when (gcRoot) {
-        is ThreadObject -> {
-          threadsBySerialNumber[gcRoot.threadSerialNumber] = gcRoot
-          enqueue(graph, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
-        }
-        is JavaFrame -> {
-          val threadRoot = threadsBySerialNumber.getValue(gcRoot.threadSerialNumber)
-          val threadInstance = graph.indexedObject(threadRoot.id).asInstance!!
-          val threadName = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()
-          val exclusion = threadNameExclusions[threadName]
-
-          if (exclusion == null || exclusion.status != NEVER_REACHABLE) {
-            // visitOrder is unused as this root node isn't enqueued.
-            val rootNode = RootNode(threadRoot.id, visitOrder = 0)
-            // TODO #1352 Instead of <Java Local>, it should be <local variable in Foo.bar()>
-            // We should also add the full stacktrace as a label of thread objects
-            val leakReference = LeakReference(LOCAL, "")
-            enqueue(
-                graph,
-                ChildNode(gcRoot.id, visitOrder++, exclusion?.description, rootNode, leakReference),
-                exclusionPriority = exclusion?.status
-            )
-          }
-        }
-        else -> enqueue(graph, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
-      }
-    }
-    gcRoots.clear()
-  }
-
-  private fun sortGcRoots(
-    graph: HprofGraph,
-    gcRoots: MutableList<GcRoot>
-  ) {
-    val rootClassName: (GcRoot) -> String = {
-      when (val graphObject = graph.indexedObject(it.id)) {
-        is GraphClassRecord -> {
-          graphObject.name
-        }
-        is GraphInstanceRecord -> {
-          graphObject.className
-        }
-        is GraphObjectArrayRecord -> {
-          graphObject.arrayClassName
-        }
-        is GraphPrimitiveArrayRecord -> {
-          graphObject.primitiveType.name
-        }
-      }
-    }
-    gcRoots.sortWith(Comparator { root1, root2 ->
-      // Sorting based on type name first. In reverse order so that ThreadObject is before JavaLocalExclusion
-      val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
-      if (gcRootTypeComparison != 0) {
-        gcRootTypeComparison
-      } else {
-        rootClassName(root1).compareTo(rootClassName(root2))
-      }
-    })
-  }
-
-  private fun visitClassRecord(
-    graph: HprofGraph,
-    classRecord: GraphClassRecord,
-    node: LeakNode,
-    staticFieldNameByClassName: Map<String, Map<String, Exclusion>>,
-    computeRetainedHeapSize: Boolean
-  ) {
-    val ignoredStaticFields = staticFieldNameByClassName[classRecord.name] ?: emptyMap()
-
-    for (staticField in classRecord.readStaticFields()) {
-      if (!staticField.value.isNonNullReference) {
-        continue
-      }
-
-      val fieldName = staticField.name
-      if (fieldName == "\$staticOverhead") {
-        continue
-      }
-
-      val objectId = staticField.value.asObjectIdReference!!
-
-      if (computeRetainedHeapSize) {
-        undominateWithSkips(graph, objectId)
-      }
-
-      val leakReference = LeakReference(STATIC_FIELD, fieldName)
-
-      val exclusion = ignoredStaticFields[fieldName]
-
-      enqueue(
-          graph,
-          ChildNode(objectId, visitOrder++, exclusion?.description, node, leakReference),
-          exclusion?.status
-      )
-    }
-  }
-
-  private fun visitInstanceRecord(
-    graph: HprofGraph,
-    instanceRecord: GraphInstanceRecord,
-    parent: LeakNode,
-    fieldNameByClassName: Map<String, Map<String, Exclusion>>,
-    computeRetainedHeapSize: Boolean
-  ) {
-    val ignoredFields = LinkedHashMap<String, Exclusion>()
-
-    instanceRecord.instanceClass.classHierarchy.forEach {
-      val classExclusions = fieldNameByClassName[it.name]
-      if (classExclusions != null) {
-        for ((fieldName, exclusion) in classExclusions) {
-          if (!ignoredFields.containsKey(fieldName)) {
-            ignoredFields[fieldName] = exclusion
-          }
-        }
-      }
-    }
-
-    val fieldNamesAndValues = instanceRecord.readFields()
-        .toMutableList()
-
-    fieldNamesAndValues.sortBy { it.name }
-
-    fieldNamesAndValues.filter { it.value.isNonNullReference }
-        .forEach { field ->
-          val objectId = field.value.asObjectIdReference!!
-          if (computeRetainedHeapSize) {
-            updateDominatorWithSkips(graph, parent.instance, objectId)
-          }
-
-          val exclusion = ignoredFields[field.name]
-          enqueue(
-              graph, ChildNode(
-              objectId,
-              visitOrder++, exclusion?.description, parent,
-              LeakReference(INSTANCE_FIELD, field.name)
-          ), exclusion?.status
-          )
-        }
-  }
-
-  private fun visitObjectArrayRecord(
-    graph: HprofGraph,
-    record: ObjectArrayDumpRecord,
-    parentNode: LeakNode,
-    computeRetainedHeapSize: Boolean
-  ) {
-    record.elementIds.forEachIndexed { index, elementId ->
-      if (computeRetainedHeapSize) {
-        updateDominatorWithSkips(graph, parentNode.instance, elementId)
-      }
-      val name = Integer.toString(index)
-      val reference = LeakReference(ARRAY_ENTRY, name)
-      enqueue(graph, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
-    }
-  }
-
-  private fun enqueue(
-    graph: HprofGraph,
-    node: LeakNode,
-    exclusionPriority: Status?
-  ) {
-    // 0L is null
-    if (node.instance == 0L) {
-      return
-    }
-    if (visitedSet.contains(node.instance)) {
-      return
-    }
-    if (exclusionPriority == NEVER_REACHABLE) {
-      return
-    }
-
-    val nodePriority = exclusionPriority ?: ALWAYS_REACHABLE
-
-    // Whether we want to visit now or later, we should skip if this is already to visit.
-    val existingPriority = toVisitMap[node.instance]
-
-    if (existingPriority != null && existingPriority <= nodePriority) {
-      return
-    }
-
-    val isLeakingInstance = referentMap[node.instance] != null
-
-    if (!isLeakingInstance) {
-      val skip = when (val graphObject = graph.indexedObject(node.instance)) {
-        is GraphClassRecord -> false
-        is GraphInstanceRecord ->
-          when {
-            graphObject.isPrimitiveWrapper -> true
-            graphObject.className == "java.lang.String" -> true
-            graphObject.instanceClass.instanceSize <= sizeOfObjectInstances -> true
-            else -> false
-          }
-        is GraphObjectArrayRecord -> when {
-          graphObject.isPrimitiveWrapperArray -> true
-          else -> false
-        }
-        is GraphPrimitiveArrayRecord -> true
-      }
-      if (skip) {
-        return
-      }
-    }
-
-    if (existingPriority != null) {
-      toVisitQueue.removeAll { it.instance == node.instance }
-    }
-    toVisitMap[node.instance] = nodePriority
-    toVisitQueue.add(node)
-  }
-
-  private fun updateDominatorWithSkips(
-    graph: HprofGraph,
-    parentObjectId: Long,
-    objectId: Long
-  ) {
-
-    when (val graphObject = graph.indexedObject(objectId)) {
-      is GraphClassRecord -> {
-        undominate(objectId, false)
-      }
-      is GraphInstanceRecord -> {
-        // String internal array is never enqueued
-        if (graphObject.className == "java.lang.String") {
-          updateDominator(parentObjectId, objectId, true)
-          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
-          if (valueId != null) {
-            updateDominator(parentObjectId, valueId, true)
-          }
-        } else {
-          updateDominator(parentObjectId, objectId, false)
-        }
-      }
-      is GraphObjectArrayRecord -> {
-        // Primitive wrapper array elements are never enqueued
-        if (graphObject.isPrimitiveWrapperArray) {
-          updateDominator(parentObjectId, objectId, true)
-          for (wrapperId in graphObject.readRecord().elementIds) {
-            updateDominator(parentObjectId, wrapperId, true)
-          }
-        } else {
-          updateDominator(parentObjectId, objectId, false)
-        }
-      }
-      else -> {
-        updateDominator(parentObjectId, objectId, false)
-      }
-    }
-  }
-
-  private fun updateDominator(
-    parent: Long,
-    instance: Long,
-    neverEnqueued: Boolean
-  ) {
-    val currentDominator = dominatedInstances[instance]
-    if (currentDominator == null && (instance in visitedSet || instance in toVisitMap)) {
-      return
-    }
-    val parentDominator = dominatedInstances[parent]
-
-    val parentIsRetainedInstance = referentMap.containsKey(parent)
-
-    val nextDominator = if (parentIsRetainedInstance) parent else parentDominator
-
-    if (nextDominator == null) {
-      // parent is not a retained instance and parent has no dominator, but it must have been
-      // visited therefore we know parent belongs to undominated.
-      if (neverEnqueued) {
-        visitedSet.add(instance)
-      }
-
-      if (currentDominator != null) {
-        dominatedInstances.remove(instance)
-      }
-      return
-    }
-    if (currentDominator == null) {
-      dominatedInstances[instance] = nextDominator
-    } else {
-      val parentDominators = mutableListOf<Long>()
-      val currentDominators = mutableListOf<Long>()
-      var dominator: Long? = nextDominator
-      while (dominator != null) {
-        parentDominators.add(dominator)
-        dominator = dominatedInstances[dominator]
-      }
-      dominator = currentDominator
-      while (dominator != null) {
-        currentDominators.add(dominator)
-        dominator = dominatedInstances[dominator]
-      }
-
-      var sharedDominator: Long? = null
-      exit@ for (parentD in parentDominators) {
-        for (currentD in currentDominators) {
-          if (currentD == parentD) {
-            sharedDominator = currentD
-            break@exit
-          }
-        }
-      }
-      if (sharedDominator == null) {
-        dominatedInstances.remove(instance)
-        if (neverEnqueued) {
-          visitedSet.add(instance)
-        }
-      } else {
-        dominatedInstances[instance] = sharedDominator
-      }
-    }
-  }
-
-  private fun undominateWithSkips(
-    graph: HprofGraph,
-    objectId: Long
-  ) {
-    when (val graphObject = graph.indexedObject(objectId)) {
-      is GraphClassRecord -> {
-        undominate(objectId, false)
-      }
-      is GraphInstanceRecord -> {
-        // String internal array is never enqueued
-        if (graphObject.className == "java.lang.String") {
-          undominate(objectId, true)
-          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectIdReference
-          if (valueId != null) {
-            undominate(valueId, true)
-          }
-        } else {
-          undominate(objectId, false)
-        }
-      }
-      is GraphObjectArrayRecord -> {
-        // Primitive wrapper array elements are never enqueued
-        if (graphObject.isPrimitiveWrapperArray) {
-          undominate(objectId, true)
-          for (wrapperId in graphObject.readRecord().elementIds) {
-            undominate(wrapperId, true)
-          }
-        } else {
-          undominate(objectId, false)
-        }
-      }
-      else -> {
-        undominate(objectId, false)
-      }
-    }
-  }
-
-  private fun undominate(
-    instance: Long,
-    neverEnqueued: Boolean
-  ) {
-    dominatedInstances.remove(instance)
-    if (neverEnqueued) {
-      visitedSet.add(instance)
-    }
-  }
-
-  companion object {
-    // Since NEVER_REACHABLE never ends up in the queue, we use its value to mean "ALWAYS_REACHABLE"
-    // For this to work we need NEVER_REACHABLE to be declared as the first enum value.
-    private val ALWAYS_REACHABLE = NEVER_REACHABLE
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
deleted file mode 100644
index f0df046b..00000000
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
+++ /dev/null
@@ -1,133 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
-import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.KeyedWeakReference
-import leakcanary.LeakingInstance
-import leakcanary.NoPathToInstance
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Before
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.TemporaryFolder
-import java.io.File
-import java.lang.ref.WeakReference
-
-class ExclusionTest {
-
-  @get:Rule
-  var testFolder = TemporaryFolder()
-  private lateinit var hprofFile: File
-
-  @Before
-  fun setUp() {
-    hprofFile = testFolder.newFile("temp.hprof")
-  }
-
-  @Test fun shortestPathExcluded() {
-    hprofFile.writeTwoPathsToInstance()
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")))
-    )
-
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements).hasSize(3)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("HasLeaking")
-    assertThat(leak.leakTrace.elements[1].reference!!.name).isEqualTo("leaking")
-    assertThat(leak.leakTrace.elements[2].className).isEqualTo("Leaking")
-  }
-
-  @Test fun allPathsExcluded_ShortestWins() {
-    hprofFile.writeTwoPathsToInstance()
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(
-            Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")),
-            Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"))
-        )
-    )
-
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
-    assertThat(leak.leakTrace.elements).hasSize(2)
-    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
-    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
-    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
-  }
-
-  @Test fun noPathToInstanceNeverReachable() {
-    hprofFile.writeTwoPathsToInstance()
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(
-            Exclusion(StaticFieldExclusion("GcRoot", "shortestPath"), status = NEVER_REACHABLE),
-            Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"), status = NEVER_REACHABLE)
-        )
-    )
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
-  }
-
-  @Test fun excludedThread() {
-    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(Exclusion(JavaLocalExclusion("kroutine"), status = WONT_FIX_LEAK))
-    )
-
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
-  }
-
-  @Test fun weaklyReachableExclusion() {
-    hprofFile.dump {
-      "GcRoot" clazz {
-        staticField["ref"] =
-          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
-      }
-    }
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(
-            Exclusion(
-                type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-                status = WEAKLY_REACHABLE
-            )
-        )
-    )
-
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.exclusionStatus).isEqualTo(WEAKLY_REACHABLE)
-  }
-
-  @Test fun overrideSuperclassExclusion() {
-    hprofFile.dump {
-      "GcRoot" clazz {
-        staticField["ref"] =
-          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
-      }
-    }
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        exclusions = listOf(
-            Exclusion(
-                type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-                status = WEAKLY_REACHABLE
-            ), Exclusion(
-            type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
-            status = NEVER_REACHABLE
-        )
-        )
-    )
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
deleted file mode 100644
index d4e0b835..00000000
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ /dev/null
@@ -1,304 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.GcRoot
-import leakcanary.GcRoot.StickyClass
-import leakcanary.HeapValue
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.HprofReader
-import leakcanary.HprofWriter
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StringRecord
-import okio.Buffer
-import java.io.Closeable
-import java.io.File
-import java.util.UUID
-import kotlin.reflect.KClass
-
-class HprofWriterHelper constructor(
-  private val writer: HprofWriter
-) : Closeable {
-
-  private var lastId = 0L
-  private val id: Long
-    get() = ++lastId
-
-  private val typeSizes = mapOf(
-      // object
-      HprofReader.OBJECT_TYPE to writer.idSize,
-      HprofReader.BOOLEAN_TYPE to HprofReader.BOOLEAN_SIZE,
-      HprofReader.CHAR_TYPE to HprofReader.CHAR_SIZE,
-      HprofReader.FLOAT_TYPE to HprofReader.FLOAT_SIZE,
-      HprofReader.DOUBLE_TYPE to HprofReader.DOUBLE_SIZE,
-      HprofReader.BYTE_TYPE to HprofReader.BYTE_SIZE,
-      HprofReader.SHORT_TYPE to HprofReader.SHORT_SIZE,
-      HprofReader.INT_TYPE to HprofReader.INT_SIZE,
-      HprofReader.LONG_TYPE to HprofReader.LONG_SIZE
-  )
-
-  private val classDumps = mutableMapOf<Long, ClassDumpRecord>()
-
-  private val objectClassId = clazz(superClassId = 0, className = "java.lang.Object")
-  private val objectArrayClassId = arrayClass("java.lang.Object")
-  private val stringClassId = clazz(
-      className = "java.lang.String", fields = listOf(
-      "value" to ObjectReference::class,
-      "count" to IntValue::class
-  )
-  )
-
-  private val referenceClassId  = clazz(
-      className = "java.lang.ref.Reference",
-      fields = listOf(
-          "referent" to ObjectReference::class
-      )
-  )
-
-  private val weakReferenceClassId = clazz(
-      className = "java.lang.ref.WeakReference",
-      superClassId = referenceClassId
-  )
-  private val keyedWeakReferenceClassId = clazz(
-      superClassId = weakReferenceClassId,
-      className = "leakcanary.KeyedWeakReference",
-      staticFields = listOf("heapDumpUptimeMillis" to LongValue(Long.MAX_VALUE)),
-      fields = listOf(
-          "key" to ObjectReference::class,
-          "name" to ObjectReference::class,
-          "className" to ObjectReference::class,
-          "watchUptimeMillis" to LongValue::class,
-          "retainedUptimeMillis" to LongValue::class
-      )
-  )
-
-  fun clazz(
-    className: String,
-    superClassId: Long = -1L, // -1 defaults to java.lang.Object
-    staticFields: List<Pair<String, HeapValue>> = emptyList(),
-    fields: List<Pair<String, KClass<out HeapValue>>> = emptyList()
-  ): Long {
-    val classNameRecord = StringRecord(id, className)
-    writer.write(classNameRecord)
-    val loadClass = LoadClassRecord(1, id, 1, classNameRecord.id)
-    writer.write(loadClass)
-
-    val staticFieldRecords = staticFields.map {
-      val fieldName = StringRecord(id, it.first)
-      writer.write(fieldName)
-      StaticFieldRecord(fieldName.id, typeOf(it.second), it.second)
-    }
-
-    val fieldRecords = fields.map {
-      val fieldName = StringRecord(id, it.first)
-      writer.write(fieldName)
-      FieldRecord(fieldName.id, typeOf(it.second))
-    }
-
-    var instanceSize = fieldRecords.sumBy {
-      typeSizes.getValue(it.type)
-    }
-
-    var nextUpId = if (superClassId == -1L) objectClassId else superClassId
-    while (nextUpId != 0L) {
-      val nextUp = classDumps[nextUpId]!!
-      instanceSize += nextUp.fields.sumBy {
-        typeSizes.getValue(it.type)
-      }
-      nextUpId = nextUp.superClassId
-    }
-    val classDump = ClassDumpRecord(
-        id = loadClass.id,
-        stackTraceSerialNumber = 1,
-        superClassId = if (superClassId == -1L) objectClassId else superClassId,
-        classLoaderId = 0,
-        signersId = 0,
-        protectionDomainId = 0,
-        instanceSize = instanceSize,
-        staticFields = staticFieldRecords,
-        fields = fieldRecords
-    )
-    classDumps[loadClass.id] = classDump
-    writer.write(classDump)
-    val gcRoot = StickyClass(classDump.id)
-    gcRoot(gcRoot)
-    return classDump.id
-  }
-
-  fun gcRoot(gcRoot: GcRoot) {
-    val gcRootRecord = GcRootRecord(gcRoot = gcRoot)
-    writer.write(gcRootRecord)
-  }
-
-  fun arrayClass(className: String): Long {
-    return clazz(className = "$className[]")
-  }
-
-  fun string(
-    string: String
-  ): ObjectReference {
-    return instance(
-        stringClassId,
-        fields = listOf(string.charArrayDump, IntValue(string.length))
-    )
-  }
-
-  fun keyedWeakReference(
-    className: String,
-    referentInstanceId: ObjectReference
-  ): ObjectReference {
-    val referenceKey = string(UUID.randomUUID().toString())
-    return instance(
-        classId = keyedWeakReferenceClassId,
-        fields = listOf(
-            referenceKey,
-            string(""),
-            string(className),
-            LongValue(System.currentTimeMillis()),
-            LongValue(System.currentTimeMillis()),
-            ObjectReference(referentInstanceId.value)
-        )
-    )
-  }
-
-  fun instance(
-    classId: Long,
-    fields: List<HeapValue> = emptyList()
-  ): ObjectReference {
-    val fieldsBuffer = Buffer()
-    fields.forEach { value ->
-      with(writer) {
-        fieldsBuffer.writeValue(value)
-      }
-    }
-    val instanceDump = InstanceDumpRecord(
-        id = id,
-        stackTraceSerialNumber = 1,
-        classId = classId,
-        fieldValues = fieldsBuffer.readByteArray()
-    )
-    writer.write(instanceDump)
-    return ObjectReference(instanceDump.id)
-  }
-
-  inner class InstanceAndClassDefinition {
-    val field = LinkedHashMap<String, HeapValue>()
-    val staticField = LinkedHashMap<String, HeapValue>()
-  }
-
-  inner class ClassDefinition {
-    val staticField = LinkedHashMap<String, HeapValue>()
-  }
-
-  infix fun String.watchedInstance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
-    val instance = this.instance(block)
-    keyedWeakReference("DummyClassName", instance)
-    return instance
-  }
-
-  infix fun String.instance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
-    val definition = InstanceAndClassDefinition()
-    block(definition)
-
-    val classFields = definition.field.map {
-      it.key to it.value::class
-    }
-
-    val staticFields = definition.staticField.map { it.key to it.value }
-
-    val instanceFields = definition.field.map { it.value }
-
-    return instance(clazz(this, fields = classFields, staticFields = staticFields), instanceFields)
-  }
-
-  infix fun String.clazz(block: ClassDefinition.() -> Unit): Long {
-    val definition = ClassDefinition()
-    block(definition)
-
-    val staticFields = definition.staticField.map { it.key to it.value }
-    return clazz(this, staticFields = staticFields)
-  }
-
-  val String.charArrayDump: ObjectReference
-    get() {
-      val arrayDump = CharArrayDump(id, 1, toCharArray())
-      writer.write(arrayDump)
-      return ObjectReference(arrayDump.id)
-    }
-
-  fun objectArray(
-    vararg elements: ObjectReference
-  ): ObjectReference {
-    return objectArrayOf(objectArrayClassId, *elements)
-  }
-
-  fun objectArrayOf(
-    classId: Long,
-    vararg elements: ObjectReference
-  ): ObjectReference {
-    return ObjectReference(objectArray(classId, elements.map { it.value }.toLongArray()))
-  }
-
-  fun objectArray(
-    classId: Long,
-    array: LongArray
-  ): Long {
-    val arrayDump = ObjectArrayDumpRecord(id, 1, classId, array)
-    writer.write(arrayDump)
-    return arrayDump.id
-  }
-
-  private fun typeOf(wrapper: HeapValue): Int {
-    return when (wrapper) {
-      is ObjectReference -> HprofReader.OBJECT_TYPE
-      is BooleanValue -> HprofReader.BOOLEAN_TYPE
-      is CharValue -> HprofReader.CHAR_TYPE
-      is FloatValue -> HprofReader.FLOAT_TYPE
-      is DoubleValue -> HprofReader.DOUBLE_TYPE
-      is ByteValue -> HprofReader.BYTE_TYPE
-      is ShortValue -> HprofReader.SHORT_TYPE
-      is IntValue -> HprofReader.INT_TYPE
-      is LongValue -> HprofReader.LONG_TYPE
-    }
-  }
-
-  private fun typeOf(wrapperClass: KClass<out HeapValue>): Int {
-    return when (wrapperClass) {
-      ObjectReference::class -> HprofReader.OBJECT_TYPE
-      BooleanValue::class -> HprofReader.BOOLEAN_TYPE
-      CharValue::class -> HprofReader.CHAR_TYPE
-      FloatValue::class -> HprofReader.FLOAT_TYPE
-      DoubleValue::class -> HprofReader.DOUBLE_TYPE
-      ByteValue::class -> HprofReader.BYTE_TYPE
-      ShortValue::class -> HprofReader.SHORT_TYPE
-      IntValue::class -> HprofReader.INT_TYPE
-      LongValue::class -> HprofReader.LONG_TYPE
-      else -> throw IllegalArgumentException("Unexpected class $wrapperClass")
-    }
-  }
-
-  override fun close() {
-    writer.close()
-  }
-}
-
-fun File.dump(block: HprofWriterHelper.() -> Unit) {
-  HprofWriterHelper(HprofWriter.open(this)).use(block)
-}
-
-fun HprofWriter.helper(block: HprofWriterHelper.() -> Unit) {
-  HprofWriterHelper(this).use(block)
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
deleted file mode 100644
index 284f3248..00000000
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.AndroidLeakTraceInspectors
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HprofGraph
-import leakcanary.LeakTraceElementReporter
-import leakcanary.LeakTraceInspector
-import leakcanary.LeakingInstance
-import leakcanary.forEachInstanceOf
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Before
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.TemporaryFolder
-import java.io.File
-
-class LabelerTest {
-
-  @get:Rule
-  var testFolder = TemporaryFolder()
-  private lateinit var hprofFile: File
-
-  @Before
-  fun setUp() {
-    hprofFile = testFolder.newFile("temp.hprof")
-  }
-
-  @Test fun stringContentAsLabel() {
-    hprofFile.writeSinglePathToString("World")
-
-    val labeler = object : LeakTraceInspector{
-      override fun inspect(
-        graph: HprofGraph,
-        leakTrace: List<LeakTraceElementReporter>
-      ) {
-        leakTrace.forEachInstanceOf("java.lang.String")  { instance ->
-          addLabel("Hello ${instance.readAsJavaString()}")
-        }
-      }
-    }
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakTraceInspectors = listOf(labeler))
-
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-
-    assertThat(leak.leakTrace.elements.last().labels).isEqualTo(listOf("Hello World"))
-  }
-
-  @Test fun threadNameLabel() {
-    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
-
-    val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakTraceInspectors = listOf(AndroidLeakTraceInspectors.THREAD))
-
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-
-    assertThat(leak.leakTrace.elements.first().labels).contains("Thread name: 'kroutine'")
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
deleted file mode 100644
index 785e69e9..00000000
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
+++ /dev/null
@@ -1,65 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.AndroidKnownReference
-import leakcanary.AndroidLeakTraceInspectors
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.LeakingInstance
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Test
-import java.io.File
-
-class LegacyHprofTest {
-
-  @Test fun preM() {
-    val analysis = analyzeHprof("leak_asynctask_pre_m.hprof")
-
-    assertThat(analysis.retainedInstances).hasSize(2)
-    val leak1 = analysis.retainedInstances[0] as LeakingInstance
-    val leak2 = analysis.retainedInstances[1] as LeakingInstance
-    assertThat(leak1.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
-    assertThat(leak2.instanceClassName).isEqualTo("android.graphics.Bitmap")
-  }
-
-  @Test fun androidM() {
-    val analysis = analyzeHprof("leak_asynctask_m.hprof")
-
-    assertThat(analysis.retainedInstances).hasSize(1)
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
-  }
-
-  @Test fun androidO() {
-    val analysis = analyzeHprof("leak_asynctask_o.hprof")
-
-    assertThat(analysis.retainedInstances).hasSize(1)
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
-  }
-
-  @Test fun gcRootInNonPrimaryHeap() {
-    val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
-
-    assertThat(analysis.retainedInstances).hasSize(1)
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
-  }
-
-  private fun analyzeHprof(fileName: String): HeapAnalysisSuccess {
-    val classLoader = Thread.currentThread()
-        .contextClassLoader
-    val url = classLoader.getResource(fileName)
-    val hprofFile = File(url.path)
-
-    val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
-        leakTraceInspectors = AndroidLeakTraceInspectors.defaultInspectors(),
-        exclusions = AndroidKnownReference.mapToExclusions(AndroidKnownReference.appDefaults)
-    )
-    if (analysis is HeapAnalysisFailure) {
-      print(analysis)
-    }
-    return analysis as HeapAnalysisSuccess
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
deleted file mode 100644
index b74b5bf3..00000000
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ /dev/null
@@ -1,104 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.AnalyzerProgressListener
-import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
-import leakcanary.HeapAnalyzer
-import leakcanary.KeyedWeakReference
-import leakcanary.LeakTraceInspector
-import java.io.File
-import java.lang.ref.PhantomReference
-import java.lang.ref.SoftReference
-import java.lang.ref.WeakReference
-
-@Suppress("UNCHECKED_CAST")
-fun <T : HeapAnalysis> File.checkForLeaks(
-  leakTraceInspectors: List<LeakTraceInspector> = emptyList(),
-  computeRetainedHeapSize: Boolean = false,
-  exclusions: List<Exclusion> = defaultExclusionsFactory
-): T {
-  val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
-  val result = heapAnalyzer.checkForLeaks(
-      this, exclusions, computeRetainedHeapSize, leakTraceInspectors
-  )
-  if (result is HeapAnalysisFailure) {
-    println(result)
-  }
-  return result as T
-}
-
-val defaultExclusionsFactory: List<Exclusion> =
-  listOf(
-      Exclusion(
-          type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-          status = WEAKLY_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion(SoftReference::class.java.name, "referent"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion(PhantomReference::class.java.name, "referent"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "prev"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "element"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.Finalizer", "next"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "prev"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "element"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "next"),
-          status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion("sun.misc.Cleaner", "prev"), status = NEVER_REACHABLE
-      )
-      ,
-      Exclusion(
-          type = InstanceFieldExclusion("sun.misc.Cleaner", "next"), status = NEVER_REACHABLE
-      )
-      ,
-
-      Exclusion(
-          type = JavaLocalExclusion("FinalizerWatchdogDaemon"),
-          status = NEVER_REACHABLE
-      ),
-      Exclusion(
-          type = JavaLocalExclusion("main"),
-          status = NEVER_REACHABLE
-      )
-  )
\ No newline at end of file
diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
index 89d39306..26d64a86 100644
--- a/leakcanary-android-core/build.gradle
+++ b/leakcanary-android-core/build.gradle
@@ -2,11 +2,10 @@ apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 
 dependencies {
-  api project(':leakcanary-analyzer')
-  api project(':leakcanary-leaksentry')
+  api project(':shark-android')
+  api project(':leakcanary-object-watcher-android')
+  api project(':leakcanary-object-watcher-android-androidx')
 
-  implementation deps.androidx.annotation
-  implementation deps.androidx.core
   implementation deps.kotlin.stdlib
 
   testImplementation deps.junit
@@ -34,5 +33,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-core/consumer-proguard-rules.pro b/leakcanary-android-core/consumer-proguard-rules.pro
index 48ffcc28..72f9d6c5 100644
--- a/leakcanary-android-core/consumer-proguard-rules.pro
+++ b/leakcanary-android-core/consumer-proguard-rules.pro
@@ -1,9 +1,6 @@
--dontwarn com.squareup.haha.guava.**
--dontwarn com.squareup.haha.perflib.**
--dontwarn com.squareup.haha.trove.**
--dontwarn com.squareup.leakcanary.**
--keep class com.squareup.haha.** { *; }
--keep class com.squareup.leakcanary.** { *; }
-
+# Loaded via reflection & referenced by shark.AndroidReferenceMatchers.LEAK_CANARY_INTERNAL
+-keep class leakcanary.internal.InternalLeakCanary { *; }
+# Referenced by shark.AndroidReferenceMatchers.LEAK_CANARY_HEAP_DUMPER
+-keep class leakcanary.internal.AndroidHeapDumper { *; }
 # Marshmallow removed Notification.setLatestEventInfo()
 -dontwarn android.app.Notification
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
similarity index 66%
rename from leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
rename to leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
index 8c24a7d1..bbe4c3f0 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultAnalysisResultListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -2,8 +2,7 @@ package leakcanary
 
 import android.app.Application
 import com.squareup.leakcanary.core.R
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.NotificationType.LEAKCANARY_RESULT
 import leakcanary.internal.Notifications
 import leakcanary.internal.activity.LeakActivity
@@ -14,15 +13,20 @@ import leakcanary.internal.activity.screen.GroupListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
 import leakcanary.internal.activity.screen.HeapAnalysisListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisSuccessScreen
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
 
-object DefaultAnalysisResultListener : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
-  ) {
+/**
+ * Default [OnHeapAnalyzedListener] implementation, which will store the analysis to disk and
+ * show a notification summarizing the result.
+ */
+class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHeapAnalyzedListener {
 
+  override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
     // TODO better log that include leakcanary version, exclusions, etc.
-    CanaryLog.d("%s", heapAnalysis)
+    SharkLog.d { "$heapAnalysis" }
 
     val (id, groupProjections) = LeaksDbHelper(application)
         .writableDatabase.use { db ->
@@ -38,22 +42,20 @@ object DefaultAnalysisResultListener : AnalysisResultListener {
         var leakCount = 0
         var newLeakCount = 0
         var knownLeakCount = 0
-        var wontFixLeakCount = 0
+        var libraryLeakCount = 0
 
         for ((_, projection) in groupProjections) {
-          if (projection.exclusionStatus != WEAKLY_REACHABLE) {
-            leakCount += projection.leakCount
-            when {
-              projection.exclusionStatus == WONT_FIX_LEAK -> wontFixLeakCount += projection.leakCount
-              projection.isNew -> newLeakCount += projection.leakCount
-              else -> knownLeakCount += projection.leakCount
-            }
+          leakCount += projection.leakCount
+          when {
+            projection.isLibraryLeak -> libraryLeakCount += projection.leakCount
+            projection.isNew -> newLeakCount += projection.leakCount
+            else -> knownLeakCount += projection.leakCount
           }
         }
 
         application.getString(
             R.string.leak_canary_analysis_success_notification, leakCount, newLeakCount,
-            knownLeakCount, wontFixLeakCount
+            knownLeakCount, libraryLeakCount
         ) to HeapAnalysisSuccessScreen(id)
       }
     }
@@ -70,4 +72,9 @@ object DefaultAnalysisResultListener : AnalysisResultListener {
         LEAKCANARY_RESULT
     )
   }
+
+  companion object {
+    fun create(): OnHeapAnalyzedListener =
+      DefaultOnHeapAnalyzedListener(InternalLeakCanary.application)
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 251a6407..6ef368ed 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -1,18 +1,45 @@
 package leakcanary
 
-import android.app.Application
 import android.content.Intent
+import leakcanary.LeakCanary.config
 import leakcanary.internal.InternalLeakCanary
+import shark.AndroidObjectInspectors
+import shark.AndroidReferenceMatchers
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+import shark.ObjectInspector
+import shark.ReferenceMatcher
+import shark.SharkLog
 
-typealias AnalysisResultListener = (Application, HeapAnalysis) -> Unit
-
+/**
+ * The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher]. AppWatcher
+ * notifies LeakCanary of retained instances, which in turns dumps the heap, analyses it and
+ * publishes the results.
+ *
+ * LeakCanary can be configured by updating [config].
+ */
 object LeakCanary {
 
+  /**
+   * LeakCanary configuration data class. Properties can be updated via [copy].
+   *
+   * @see [config]
+   */
   data class Config(
+    /**
+     * Whether LeakCanary should dump the heap when enough retained instances are found. This needs
+     * to be true for LeakCanary to work, but sometimes you may want to temporarily disable
+     * LeakCanary (e.g. for a product demo).
+     *
+     * Defaults to true.
+     */
     val dumpHeap: Boolean = true,
     /**
-     * The debugger can create temporary memory leaks (for instance if a thread is blocked on a
-     * breakpoint) so by default LeakCanary does not dump the heap when the debugger is attached.
+     * If [dumpHeapWhenDebugging] is false then LeakCanary will not dump the heap
+     * when the debugger is attached. The debugger can create temporary memory leaks (for instance
+     * if a thread is blocked on a breakpoint).
+     *
+     * Defaults to false.
      */
     val dumpHeapWhenDebugging: Boolean = false,
     /**
@@ -22,52 +49,135 @@ object LeakCanary {
      * especially frustrating as the Android Framework has a number of leaks that cannot easily
      * be fixed.
      *
-     * When the app becomes invisible, LeakCanary dumps the heap immediately.
+     * When the app becomes invisible, LeakCanary dumps the heap after
+     * [AppWatcher.Config.watchDurationMillis] ms.
+     *
+     * The app is considered visible if it has at least one activity in started state.
      *
      * A higher threshold means LeakCanary will dump the heap less often, therefore it won't be
      * bothering developers as much but it could miss some leaks.
+     *
+     * Defaults to 5.
      */
     val retainedVisibleThreshold: Int = 5,
 
-    val knownReferences: Set<AndroidKnownReference> = AndroidKnownReference.appDefaults,
+    /**
+     * Known patterns of references in the heap, lister here either to ignore them
+     * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+     *
+     * When adding your own custom [LibraryLeakReferenceMatcher] instances, you'll most
+     * likely want to set [LibraryLeakReferenceMatcher.patternApplies] with a filter that checks
+     * for the Android OS version and manufacturer. The build information can be obtained by calling
+     * [shark.AndroidBuildMirror.fromHeapGraph].
+     *
+     * Defaults to [AndroidReferenceMatchers.appDefaults]
+     */
+    val referenceMatchers: List<ReferenceMatcher> = AndroidReferenceMatchers.appDefaults,
 
-    val leakTraceInspectors: List<LeakTraceInspector> = AndroidLeakTraceInspectors.defaultInspectors(),
+    /**
+     * List of [ObjectInspector] that provide LeakCanary with insights about objects found in the
+     * heap. You can create your own [ObjectInspector] implementations, and also add
+     * a [shark.AppSingletonInspector] instance created with the list of internal singletons.
+     *
+     * Defaults to [AndroidObjectInspectors.appDefaults]
+     */
+    val objectInspectors: List<ObjectInspector> = AndroidObjectInspectors.appDefaults,
 
     /**
-     * Called with the heap analysis result from a background thread.
-     * The heap dump file will be removed immediately after this function is invoked.
+     * Called on a background thread when the heap analysis is complete.
      * If you want leaks to be added to the activity that lists leaks, make sure to delegate
-     * calls to [DefaultAnalysisResultListener].
+     * calls to a [DefaultOnHeapAnalyzedListener].
+     *
+     * Defaults to [DefaultOnHeapAnalyzedListener]
      */
-    val analysisResultListener: AnalysisResultListener = DefaultAnalysisResultListener,
+    val onHeapAnalyzedListener: OnHeapAnalyzedListener = DefaultOnHeapAnalyzedListener.create(),
+
     /**
-     * Whether to compute the total number of bytes in memory that would be reclaimed if the
-     * detected leaks didn't happen. This includes native memory associated to Java objects
-     * (e.g. bitmaps).
-     * Computing the retained heap size can slow down the leak analysis and is off by default.
+     * Whether to compute the retained heap size, which is the total number of bytes in memory that
+     * would be reclaimed if the detected leaks didn't happen. This includes native memory
+     * associated to Java objects (e.g. Android bitmaps).
+     *
+     * Computing the retained heap size can slow down the analysis because it requires navigating
+     * from GC roots through the entire object graph, whereas [shark.HeapAnalyzer] would otherwise
+     * stop as soon as all leaking instances are found.
+     *
+     * Defaults to true.
      */
-    val computeRetainedHeapSize: Boolean = false,
+    val computeRetainedHeapSize: Boolean = true,
 
     /**
-     * How many heap dumps are kept locally. When this threshold is reached LeakCanary starts
-     * deleting the older heap dumps. As several heap dumps may be enqueued you should avoid
-     * going down to 1 or 2.
+     * How many heap dumps are kept on the Android device for this app package. When this threshold
+     * is reached LeakCanary deletes the older heap dumps. As several heap dumps may be enqueued
+     * you should avoid going down to 1 or 2.
+     *
+     * Defaults to 7.
      */
     val maxStoredHeapDumps: Int = 7,
 
     /**
-     * LeakCanary always attempts to store heap dumps on the external storage first. If the
-     * WRITE_EXTERNAL_STORAGE permission is not granted and [requestWriteExternalStoragePermission]
-     * is true, then LeakCanary will display a notification to ask for that permission.
+     * LeakCanary always attempts to store heap dumps on the external storage if the
+     * WRITE_EXTERNAL_STORAGE is already granted, and otherwise uses the app storage.
+     * If the WRITE_EXTERNAL_STORAGE permission is not granted and
+     * [requestWriteExternalStoragePermission] is true, then LeakCanary will display a notification
+     * to ask for that permission.
+     *
+     * Defaults to false because that permission notification can be annoying.
      */
-    val requestWriteExternalStoragePermission: Boolean = false
+    val requestWriteExternalStoragePermission: Boolean = false,
 
+    /**
+     * When true, [objectInspectors] are used to find leaks instead of only checking instances
+     * tracked by [KeyedWeakReference]. This leads to finding more leaks and shorter leak traces.
+     * However this also means the same leaking instances will be found in every heap dump for a
+     * given process life.
+     *
+     * Defaults to false.
+     */
+    val useExperimentalLeakFinders: Boolean = false
   )
 
+  /**
+   * The current LeakCanary configuration. Can be updated at any time, usually by replacing it with
+   * a mutated copy, e.g.:
+   *
+   * ```
+   * LeakCanary.config = LeakCanary.config.copy(computeRetainedHeapSize = true)
+   * ```
+   */
   @Volatile
-  var config: Config = if (LeakSentry.isInstalled) Config() else InternalLeakCanary.noInstallConfig
+  var config: Config = if (AppWatcher.isInstalled) Config() else InternalLeakCanary.noInstallConfig
+    set(value) {
+      field = value
+      SharkLog.d { "Updated LeakCanary.config to $value" }
+    }
+
+  /**
+   * Returns a new [Intent] that can be used to programmatically launch the leak display activity.
+   */
+  fun newLeakDisplayActivityIntent() = InternalLeakCanary.leakDisplayActivityIntent
+
+  /**
+   * Dynamically shows / hides the launcher icon for the leak display activity.
+   * Note: you can change the default value by overriding the leak_canary_add_launcher_icon
+   * boolean resource:
+   *
+   * ```
+   * <?xml version="1.0" encoding="utf-8"?>
+   * <resources>
+   *   <bool name="leak_canary_add_launcher_icon">false</bool>
+   * </resources>
+   * ```
+   */
+  fun showLeakDisplayActivityLauncherIcon(showLauncherIcon: Boolean) {
+    InternalLeakCanary.setEnabledBlocking(
+        "leakcanary.internal.activity.LeakLauncherActivity", showLauncherIcon
+    )
+  }
 
-  /** [Intent] that can be used to programmatically launch the leak display activity. */
-  val leakDisplayActivityIntent
-    get() = InternalLeakCanary.leakDisplayActivityIntent
+  /**
+   * Immediately triggers a heap dump and analysis, if there is at least one retained instance
+   * tracked by [AppWatcher.objectWatcher]. If there are no retained instances then the heap will not
+   * be dumped and a notification will be shown instead.
+   */
+  fun dumpHeap() = InternalLeakCanary.onDumpHeapReceived()
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
new file mode 100644
index 00000000..fe95de38
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
@@ -0,0 +1,40 @@
+package leakcanary
+
+import leakcanary.OnHeapAnalyzedListener.Companion.invoke
+import shark.HeapAnalysis
+import shark.ObjectInspector.Companion.invoke
+
+/**
+ * Listener set in [LeakCanary.Config] and called by LeakCanary on a background thread when the
+ * heap analysis is complete.
+ *
+ * You can create a [OnHeapAnalyzedListener] from a lambda by calling [invoke].
+ */
+interface OnHeapAnalyzedListener {
+
+  /**
+   * @see OnHeapAnalyzedListener
+   */
+  fun onHeapAnalyzed(heapAnalysis: HeapAnalysis)
+
+  companion object {
+    /**
+     * Utility function to create a [OnHeapAnalyzedListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnHeapAnalyzedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnHeapAnalyzedListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (HeapAnalysis) -> Unit): OnHeapAnalyzedListener =
+      object : OnHeapAnalyzedListener {
+        override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
+          block(heapAnalysis)
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index 17655635..f5217869 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -30,9 +30,9 @@ import android.view.LayoutInflater
 import android.view.View
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.InternalLeakCanary.noOpDelegate
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import shark.SharkLog
 import java.io.File
 import java.util.concurrent.TimeUnit.SECONDS
 
@@ -68,7 +68,7 @@ internal class AndroidHeapDumper(
     showToast(waitingForToast)
 
     if (!waitingForToast.wait(5, SECONDS)) {
-      CanaryLog.d("Did not dump heap, too much time waiting for Toast.")
+      SharkLog.d { "Did not dump heap, too much time waiting for Toast." }
       return null
     }
 
@@ -87,13 +87,13 @@ internal class AndroidHeapDumper(
     return try {
       Debug.dumpHprofData(heapDumpFile.absolutePath)
       if (heapDumpFile.length() == 0L) {
-        CanaryLog.d("Dumped heap file is 0 byte length")
+        SharkLog.d { "Dumped heap file is 0 byte length" }
         null
       } else {
         heapDumpFile
       }
     } catch (e: Exception) {
-      CanaryLog.d(e, "Could not dump heap")
+      SharkLog.d(e) { "Could not dump heap" }
       // Abort heap dump
       null
     } finally {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 06c6eec8..e663e4f1 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -16,6 +16,7 @@
 package leakcanary.internal
 
 import android.content.Context
+import android.text.Html
 import android.text.SpannableStringBuilder
 import android.text.Spanned
 import android.text.format.DateUtils
@@ -23,16 +24,7 @@ import android.view.View
 import android.view.ViewGroup
 import android.widget.BaseAdapter
 import android.widget.TextView
-import androidx.annotation.ColorRes
-import androidx.core.content.ContextCompat
-import androidx.core.text.HtmlCompat
 import com.squareup.leakcanary.core.R
-import leakcanary.LeakNodeStatus.LEAKING
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.LeakTrace
-import leakcanary.LeakTraceElement
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import leakcanary.internal.DisplayLeakConnectorView.Type
 import leakcanary.internal.DisplayLeakConnectorView.Type.END
 import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
@@ -45,35 +37,26 @@ import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.START
 import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
-import leakcanary.internal.MoreDetailsView.Details.CLOSED
-import leakcanary.internal.MoreDetailsView.Details.NONE
-import leakcanary.internal.MoreDetailsView.Details.OPENED
 import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
+import leakcanary.internal.navigation.getColorCompat
 import leakcanary.internal.navigation.inflate
-
-internal class DisplayLeakAdapter private constructor(
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.LeakTrace
+import shark.LeakTraceElement
+import shark.LeakTraceElement.Type.STATIC_FIELD
+
+@Suppress("DEPRECATION", "TooManyFunctions")
+internal class DisplayLeakAdapter constructor(
   context: Context,
   private val leakTrace: LeakTrace,
-  private val referenceName: String,
-  private val instanceProjections: List<InstanceProjection>
+  private val groupDescription: String = "",
+  private val instanceProjections: List<InstanceProjection> = emptyList()
 ) : BaseAdapter() {
 
   private val isLeakGroup = instanceProjections.isNotEmpty()
 
-  constructor(
-    context: Context,
-    leakTrace: LeakTrace,
-    referenceName: String
-  ) : this(context, leakTrace, referenceName, emptyList())
-
-  constructor(
-    context: Context,
-    leakTrace: LeakTrace,
-    instanceProjections: List<InstanceProjection>
-  ) : this(context, leakTrace, "", instanceProjections)
-
-  private val opened = BooleanArray(TOP_ROW_COUNT + leakTrace.elements.size)
-
   private val classNameColorHexString: String
   private val leakColorHexString: String
   private val referenceColorHexString: String
@@ -114,7 +97,7 @@ internal class DisplayLeakAdapter private constructor(
 
   private fun bindTopRow(view: View) {
     val textView = view.findViewById<TextView>(R.id.leak_canary_row_text)
-    textView.text = view.context.packageName
+    textView.text = groupDescription
   }
 
   private fun bindConnectorRow(
@@ -122,52 +105,30 @@ internal class DisplayLeakAdapter private constructor(
     position: Int
   ) {
     val titleView = view.findViewById<TextView>(R.id.leak_canary_row_title)
-    val detailView = view.findViewById<TextView>(R.id.leak_canary_row_details)
     val connector = view.findViewById<DisplayLeakConnectorView>(R.id.leak_canary_row_connector)
-    val moreDetailsView = view.findViewById<MoreDetailsView>(R.id.leak_canary_row_more)
 
     connector.setType(getConnectorType(position))
 
-    moreDetailsView.setDetails(
-        when {
-          isLeakGroup -> NONE
-          // Learn more row
-          isFirstConnectorRow(position) -> NONE
-          opened[position] -> OPENED
-          else -> CLOSED
-        }
-    )
-
-    if (opened[position]) {
-      detailView.visibility = View.VISIBLE
-    } else {
-      detailView.visibility = View.GONE
-    }
-
     val resources = view.resources
     if (isFirstConnectorRow(position)) {
       titleView.text = if (isLeakGroup) {
-        HtmlCompat.fromHtml(
+        Html.fromHtml(
             """
               <font color='$helpColorHexString'>
                 <b>Known likely causes of leak group</b>
               </font>
-            """,
-            HtmlCompat.FROM_HTML_MODE_LEGACY
+            """
         )
       } else {
-        HtmlCompat.fromHtml(
+        Html.fromHtml(
             """
               <font color='$helpColorHexString'>
                 <b>${resources.getString(R.string.leak_canary_help_title)}</b>
               </font>
-            """,
-            HtmlCompat.FROM_HTML_MODE_LEGACY
+            """
         )
       }
     } else {
-      val isLast = position == (TOP_ROW_COUNT + leakTrace.elements.size) - 1
-
       val elementIndex = elementIndex(position)
       val element = leakTrace.elements[elementIndex]
 
@@ -178,11 +139,6 @@ internal class DisplayLeakAdapter private constructor(
       val htmlTitle = htmlTitle(element, maybeLeakCause, view.context)
 
       titleView.text = htmlTitle
-
-      if (opened[position]) {
-        val htmlDetail = htmlDetails(isLast, element)
-        detailView.text = htmlDetail
-      }
     }
   }
 
@@ -222,10 +178,10 @@ internal class DisplayLeakAdapter private constructor(
 
     htmlString += "<br>"
 
-    val reachabilityString = when (element.leakStatusAndReason.status) {
+    val reachabilityString = when (element.leakStatus) {
       UNKNOWN -> "UNKNOWN"
-      NOT_LEAKING -> "NO (${element.leakStatusAndReason.reason})"
-      LEAKING -> "YES (${element.leakStatusAndReason.reason})"
+      NOT_LEAKING -> "NO (${element.leakStatusReason})"
+      LEAKING -> "YES (${element.leakStatusReason})"
     }
 
     val indentation = "&nbsp;".repeat(4)
@@ -252,13 +208,7 @@ internal class DisplayLeakAdapter private constructor(
 
       htmlString += "$indentation$styledClassName.${if (maybeLeakCause) "<b>$referenceName</b>" else referenceName}"
     }
-
-    val exclusion = element.exclusion
-    if (exclusion != null) {
-      htmlString += " (excluded)"
-    }
-    val builder =
-      HtmlCompat.fromHtml(htmlString, HtmlCompat.FROM_HTML_MODE_LEGACY) as SpannableStringBuilder
+    val builder = Html.fromHtml(htmlString) as SpannableStringBuilder
     if (maybeLeakCause) {
       SquigglySpan.replaceUnderlineSpans(builder, context)
     }
@@ -266,26 +216,7 @@ internal class DisplayLeakAdapter private constructor(
     return builder
   }
 
-  private fun htmlDetails(
-    isLeakingInstance: Boolean,
-    element: LeakTraceElement
-  ): Spanned {
-    var htmlString = ""
-    val exclusion = element.exclusion
-    if (exclusion != null) {
-      htmlString += "<br/><br/>Excluded by rule"
-      htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>"
-      if (exclusion.reason != null) {
-        htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>"
-      }
-    }
-    if (isLeakingInstance && referenceName != "") {
-      htmlString += " <font color='$extraColorHexString'>$referenceName</font>"
-    }
-
-    return HtmlCompat.fromHtml(htmlString, HtmlCompat.FROM_HTML_MODE_LEGACY)
-  }
-
+  @Suppress("ReturnCount")
   private fun getConnectorType(position: Int): Type {
     if (isFirstConnectorRow(position)) {
       return if (isLeakGroup) HELP_LEAK_GROUP else HELP
@@ -294,23 +225,23 @@ internal class DisplayLeakAdapter private constructor(
         return START_LAST_REACHABLE
       }
       val nextReachability = leakTrace.elements[elementIndex(position + 1)]
-      return if (nextReachability.leakStatusAndReason.status != NOT_LEAKING) {
+      return if (nextReachability.leakStatus != NOT_LEAKING) {
         START_LAST_REACHABLE
       } else START
     } else {
       val isLeakingInstance = position == count - 1
       if (isLeakingInstance) {
         val previousReachability = leakTrace.elements[elementIndex(position - 1)]
-        return if (previousReachability.leakStatusAndReason.status != LEAKING) {
+        return if (previousReachability.leakStatus != LEAKING) {
           END_FIRST_UNREACHABLE
         } else END
       } else {
         val reachability = leakTrace.elements[elementIndex(position)]
-        when (reachability.leakStatusAndReason.status) {
+        when (reachability.leakStatus) {
           UNKNOWN -> return NODE_UNKNOWN
           NOT_LEAKING -> {
             val nextReachability = leakTrace.elements[elementIndex(position + 1)]
-            return if (nextReachability.leakStatusAndReason.status != NOT_LEAKING) {
+            return if (nextReachability.leakStatus != NOT_LEAKING) {
               NODE_LAST_REACHABLE
             } else {
               NODE_REACHABLE
@@ -318,13 +249,15 @@ internal class DisplayLeakAdapter private constructor(
           }
           LEAKING -> {
             val previousReachability = leakTrace.elements[elementIndex(position - 1)]
-            return if (previousReachability.leakStatusAndReason.status != LEAKING) {
+            return if (previousReachability.leakStatus != LEAKING) {
               NODE_FIRST_UNREACHABLE
             } else {
               NODE_UNREACHABLE
             }
           }
-          else -> throw IllegalStateException("Unknown value: " + reachability.leakStatusAndReason.status)
+          else -> throw IllegalStateException(
+              "Unknown value: " + reachability.leakStatus
+          )
         }
       }
     }
@@ -334,11 +267,6 @@ internal class DisplayLeakAdapter private constructor(
 
   fun isFirstConnectorRow(position: Int) = position == TOP_ROW_COUNT - 1
 
-  fun toggleRow(position: Int) {
-    opened[position] = !opened[position]
-    notifyDataSetChanged()
-  }
-
   override fun getCount() = TOP_ROW_COUNT + leakTrace.elements.size + instanceProjections.size
 
   override fun getItem(position: Int) = null
@@ -365,8 +293,11 @@ internal class DisplayLeakAdapter private constructor(
     private const val TOP_ROW_COUNT = 2
 
     // https://stackoverflow.com/a/6540378/703646
-    private fun hexStringColor(context: Context, @ColorRes colorResId: Int): String {
-      return String.format("#%06X", 0xFFFFFF and ContextCompat.getColor(context, colorResId))
+    private fun hexStringColor(
+      context: Context,
+      colorResId: Int
+    ): String {
+      return String.format("#%06X", 0xFFFFFF and context.getColorCompat(colorResId))
     }
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
index 923e20ae..03c7fbc5 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakConnectorView.kt
@@ -26,7 +26,6 @@ import android.graphics.PorterDuff.Mode.CLEAR
 import android.graphics.PorterDuffXfermode
 import android.util.AttributeSet
 import android.view.View
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.DisplayLeakConnectorView.Type.END
 import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
@@ -39,6 +38,7 @@ import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNKNOWN
 import leakcanary.internal.DisplayLeakConnectorView.Type.NODE_UNREACHABLE
 import leakcanary.internal.DisplayLeakConnectorView.Type.START
 import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
+import leakcanary.internal.navigation.getColorCompat
 
 internal class DisplayLeakConnectorView(
   context: Context,
@@ -81,18 +81,18 @@ internal class DisplayLeakConnectorView(
         .toFloat()
 
     classNamePaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    classNamePaint.color = ContextCompat.getColor(context, R.color.leak_canary_class_name)
+    classNamePaint.color = context.getColorCompat(R.color.leak_canary_class_name)
     classNamePaint.strokeWidth = strokeSize
 
     leakGroupRootPaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    leakGroupRootPaint.color = ContextCompat.getColor(context, R.color.leak_canary_class_name)
+    leakGroupRootPaint.color = context.getColorCompat(R.color.leak_canary_class_name)
     leakGroupRootPaint.strokeWidth = strokeSize
     val pathLines = resources.getDimensionPixelSize(R.dimen.leak_canary_connector_leak_dash_line)
         .toFloat()
     leakGroupRootPaint.pathEffect = DashPathEffect(floatArrayOf(pathLines, pathLines), 0f)
 
     leakPaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    leakPaint.color = ContextCompat.getColor(context, R.color.leak_canary_leak)
+    leakPaint.color = context.getColorCompat(R.color.leak_canary_leak)
     leakPaint.style = Paint.Style.STROKE
     leakPaint.strokeWidth = strokeSize
 
@@ -105,7 +105,7 @@ internal class DisplayLeakConnectorView(
     clearPaint.xfermode = CLEAR_XFER_MODE
 
     referencePaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    referencePaint.color = ContextCompat.getColor(context, R.color.leak_canary_reference)
+    referencePaint.color = context.getColorCompat(R.color.leak_canary_reference)
     referencePaint.strokeWidth = strokeSize
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
index 9208e0d1..1f6eb5fd 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/ForegroundService.kt
@@ -22,7 +22,7 @@ import android.os.IBinder
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 
-abstract class ForegroundService(
+internal abstract class ForegroundService(
   name: String,
   private val notificationContentTitleResId: Int,
   private val notificationId: Int
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index 263f6946..ef41a185 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -17,14 +17,14 @@ package leakcanary.internal
 
 import android.content.Context
 import android.content.Intent
+import android.os.Build.VERSION.SDK_INT
 import android.os.Process
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
-import leakcanary.AnalyzerProgressListener
-import leakcanary.AndroidKnownReference
-import leakcanary.CanaryLog
-import leakcanary.HeapAnalyzer
 import leakcanary.LeakCanary
+import shark.OnAnalysisProgressListener
+import shark.HeapAnalyzer
+import shark.ObjectInspectors
+import shark.SharkLog
 import java.io.File
 
 /**
@@ -34,11 +34,11 @@ internal class HeapAnalyzerService : ForegroundService(
     HeapAnalyzerService::class.java.simpleName,
     R.string.leak_canary_notification_analysing,
     R.id.leak_canary_notification_analyzing_heap
-), AnalyzerProgressListener {
+), OnAnalysisProgressListener {
 
   override fun onHandleIntentInForeground(intent: Intent?) {
     if (intent == null) {
-      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.")
+      SharkLog.d { "HeapAnalyzerService received a null intent, ignoring." }
       return
     }
     // Since we're running in the main process we should be careful not to impact it.
@@ -56,19 +56,21 @@ internal class HeapAnalyzerService : ForegroundService(
     val heapAnalyzer = HeapAnalyzer(this)
     val config = LeakCanary.config
 
-    val exclusions = AndroidKnownReference.mapToExclusions(config.knownReferences)
 
     val heapAnalysis =
-      heapAnalyzer.checkForLeaks(
-          heapDumpFile, exclusions, config.computeRetainedHeapSize, config.leakTraceInspectors
+      heapAnalyzer.analyze(
+          heapDumpFile, config.referenceMatchers, config.computeRetainedHeapSize, config.objectInspectors,
+          if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
+              ObjectInspectors.KEYED_WEAK_REFERENCE
+          )
       )
 
-    config.analysisResultListener(application, heapAnalysis)
+    config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)
   }
 
-  override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
-    val percent = (100f * step.ordinal / AnalyzerProgressListener.Step.values().size).toInt()
-    CanaryLog.d("Analysis in progress, working on: %s", step.name)
+  override fun onAnalysisProgress(step: OnAnalysisProgressListener.Step) {
+    val percent = (100f * step.ordinal / shark.OnAnalysisProgressListener.Step.values().size).toInt()
+    SharkLog.d { "Analysis in progress, working on: ${step.name}" }
     val lowercase = step.name.replace("_", " ")
         .toLowerCase()
     val message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1)
@@ -84,7 +86,19 @@ internal class HeapAnalyzerService : ForegroundService(
     ) {
       val intent = Intent(context, HeapAnalyzerService::class.java)
       intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)
-      ContextCompat.startForegroundService(context, intent)
+      startForegroundService(context, intent)
+    }
+
+    fun startForegroundService(
+      context: Context,
+      intent: Intent
+    ) {
+      if (SDK_INT >= 26) {
+        context.startForegroundService(intent)
+      } else {
+        // Pre-O behavior.
+        context.startService(intent)
+      }
     }
   }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index ee54c63d..dac85914 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -7,20 +7,21 @@ import android.content.Context
 import android.os.Handler
 import android.os.SystemClock
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.GcTrigger
 import leakcanary.KeyedWeakReference
 import leakcanary.LeakCanary.Config
-import leakcanary.LeakSentry
-import leakcanary.RefWatcher
+import leakcanary.AppWatcher
+import leakcanary.ObjectWatcher
 import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
 import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import shark.SharkLog
 
+@Suppress("TooManyFunctions")
 internal class HeapDumpTrigger(
   private val application: Application,
   private val backgroundHandler: Handler,
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val gcTrigger: GcTrigger,
   private val heapDumper: HeapDumper,
   private val configProvider: () -> Config
@@ -36,7 +37,7 @@ internal class HeapDumpTrigger(
   @Volatile
   private var checkScheduled: Boolean = false
 
-  private var lastDisplayedRetainedInstanceCount = 0
+  private var lastDisplayedRetainedObjectCount = 0
 
   private val scheduleDismissRetainedCountNotification = {
     dismissRetainedCountNotification()
@@ -54,7 +55,7 @@ internal class HeapDumpTrigger(
   private val applicationInvisibleLessThanWatchPeriod: Boolean
     get() {
       val applicationInvisibleAt = applicationInvisibleAt
-      return applicationInvisibleAt != -1L && SystemClock.uptimeMillis() - applicationInvisibleAt < LeakSentry.config.watchDurationMillis
+      return applicationInvisibleAt != -1L && SystemClock.uptimeMillis() - applicationInvisibleAt < AppWatcher.config.watchDurationMillis
     }
 
   @Volatile
@@ -65,55 +66,54 @@ internal class HeapDumpTrigger(
       applicationInvisibleAt = -1L
     } else {
       applicationInvisibleAt = SystemClock.uptimeMillis()
-      scheduleRetainedInstanceCheck("app became invisible", LeakSentry.config.watchDurationMillis)
+      scheduleRetainedObjectCheck("app became invisible", AppWatcher.config.watchDurationMillis)
     }
   }
 
-  fun onReferenceRetained() {
-    scheduleRetainedInstanceCheck("found new instance retained")
+  fun onObjectRetained() {
+    scheduleRetainedObjectCheck("found new object retained")
   }
 
-  private fun checkRetainedInstances(reason: String) {
+  private fun checkRetainedObjects(reason: String) {
     val config = configProvider()
     // A tick will be rescheduled when this is turned back on.
     if (!config.dumpHeap) {
-      CanaryLog.d("No checking for retained instance: LeakCanary.Config.dumpHeap is false")
+      SharkLog.d { "No checking for retained object: LeakCanary.Config.dumpHeap is false" }
       return
     }
-    CanaryLog.d("Checking retained instances because %s", reason)
+    SharkLog.d { "Checking retained object because $reason" }
 
-    var retainedReferenceCount = refWatcher.retainedInstanceCount
+    var retainedReferenceCount = objectWatcher.retainedObjectCount
 
     if (retainedReferenceCount > 0) {
       gcTrigger.runGc()
-      retainedReferenceCount = refWatcher.retainedInstanceCount
+      retainedReferenceCount = objectWatcher.retainedObjectCount
     }
 
     if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
     if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
       showRetainedCountWithDebuggerAttached(retainedReferenceCount)
-      scheduleRetainedInstanceCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
-      CanaryLog.d(
-          "Not checking for leaks while the debugger is attached, will retry in %d ms",
-          WAIT_FOR_DEBUG_MILLIS
-      )
+      scheduleRetainedObjectCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
+      SharkLog.d {
+          "Not checking for leaks while the debugger is attached, will retry in $WAIT_FOR_DEBUG_MILLIS ms"
+      }
       return
     }
 
-    CanaryLog.d("Found %d retained references, dumping the heap", retainedReferenceCount)
+    SharkLog.d { "Found $retainedReferenceCount retained references, dumping the heap" }
     val heapDumpUptimeMillis = SystemClock.uptimeMillis()
     KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
     dismissRetainedCountNotification()
     val heapDumpFile = heapDumper.dumpHeap()
     if (heapDumpFile == null) {
-      CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
-      scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      SharkLog.d { "Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms" }
+      scheduleRetainedObjectCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
       showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
       return
     }
-    lastDisplayedRetainedInstanceCount = 0
-    refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+    lastDisplayedRetainedObjectCount = 0
+    objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
 
     HeapAnalyzerService.runAnalysis(application, heapDumpFile)
   }
@@ -122,16 +122,17 @@ internal class HeapDumpTrigger(
     backgroundHandler.post {
       dismissNoRetainedOnTapNotification()
       gcTrigger.runGc()
-      val retainedReferenceCount = refWatcher.retainedInstanceCount
+      val retainedReferenceCount = objectWatcher.retainedObjectCount
       if (retainedReferenceCount == 0) {
-        CanaryLog.d("No retained instances after GC")
+        SharkLog.d { "No retained objects after GC" }
+        @Suppress("DEPRECATION")
         val builder = Notification.Builder(application)
             .setContentTitle(
-                application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+                application.getString(R.string.leak_canary_notification_no_retained_object_title)
             )
             .setContentText(
                 application.getString(
-                    R.string.leak_canary_notification_no_retained_instance_content
+                    R.string.leak_canary_notification_no_retained_object_content
                 )
             )
             .setAutoCancel(true)
@@ -139,28 +140,28 @@ internal class HeapDumpTrigger(
         val notification =
           Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
         notificationManager.notify(
-            R.id.leak_canary_notification_no_retained_instance_on_tap, notification
+            R.id.leak_canary_notification_no_retained_object_on_tap, notification
         )
         backgroundHandler.postDelayed(
             scheduleDismissNoRetainedOnTapNotification,
-            DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+            DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS
         )
-        lastDisplayedRetainedInstanceCount = 0
+        lastDisplayedRetainedObjectCount = 0
         return@post
       }
 
       val heapDumpUptimeMillis = SystemClock.uptimeMillis()
       KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
-      CanaryLog.d("Dumping the heap because user tapped notification")
+      SharkLog.d { "Dumping the heap because user tapped notification" }
 
       val heapDumpFile = heapDumper.dumpHeap()
       if (heapDumpFile == null) {
-        CanaryLog.d("Failed to dump heap")
+        SharkLog.d { "Failed to dump heap" }
         showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
         return@post
       }
-      lastDisplayedRetainedInstanceCount = 0
-      refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+      lastDisplayedRetainedObjectCount = 0
+      objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
       HeapAnalyzerService.runAnalysis(application, heapDumpFile)
     }
   }
@@ -169,26 +170,24 @@ internal class HeapDumpTrigger(
     retainedKeysCount: Int,
     retainedVisibleThreshold: Int
   ): Boolean {
-    val countChanged = lastDisplayedRetainedInstanceCount != retainedKeysCount
-    lastDisplayedRetainedInstanceCount = retainedKeysCount
+    val countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount
+    lastDisplayedRetainedObjectCount = retainedKeysCount
     if (retainedKeysCount == 0) {
-      CanaryLog.d("No retained instances")
+      SharkLog.d { "No retained objects" }
       if (countChanged) {
-        showNoMoreRetainedInstanceNotification()
+        showNoMoreRetainedObjectNotification()
       }
       return true
     }
 
     if (retainedKeysCount < retainedVisibleThreshold) {
       if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
-        CanaryLog.d(
-            "Found %d retained instances, which is less than the visible threshold of %d",
-            retainedKeysCount,
-            retainedVisibleThreshold
-        )
+        SharkLog.d {
+            "Found $retainedKeysCount retained objects, which is less than the visible threshold of $retainedVisibleThreshold"
+        }
         showRetainedCountBelowThresholdNotification(retainedKeysCount, retainedVisibleThreshold)
-        scheduleRetainedInstanceCheck(
-            "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
+        scheduleRetainedObjectCheck(
+            "Showing retained objects notification", WAIT_FOR_OBJECT_THRESHOLD_MILLIS
         )
         return true
       }
@@ -196,116 +195,117 @@ internal class HeapDumpTrigger(
     return false
   }
 
-  private fun scheduleRetainedInstanceCheck(reason: String) {
+  private fun scheduleRetainedObjectCheck(reason: String) {
     if (checkScheduled) {
-      CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
+      SharkLog.d { "Already scheduled retained check, ignoring ($reason)" }
       return
     }
     checkScheduled = true
     backgroundHandler.post {
       checkScheduled = false
-      checkRetainedInstances(reason)
+      checkRetainedObjects(reason)
     }
   }
 
-  private fun scheduleRetainedInstanceCheck(
+  private fun scheduleRetainedObjectCheck(
     reason: String,
     delayMillis: Long
   ) {
     if (checkScheduled) {
-      CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
+      SharkLog.d { "Already scheduled retained check, ignoring ($reason)" }
       return
     }
     checkScheduled = true
     backgroundHandler.postDelayed({
       checkScheduled = false
-      checkRetainedInstances(reason)
+      checkRetainedObjects(reason)
     }, delayMillis)
   }
 
   private fun showRetainedCountBelowThresholdNotification(
-    instanceCount: Int,
+    objectCount: Int,
     retainedVisibleThreshold: Int
   ) {
     showRetainedCountNotification(
-        instanceCount, application.getString(
+        objectCount, application.getString(
         R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold
     )
     )
   }
 
-  private fun showRetainedCountWithDebuggerAttached(instanceCount: Int) {
+  private fun showRetainedCountWithDebuggerAttached(objectCount: Int) {
     showRetainedCountNotification(
-        instanceCount,
+        objectCount,
         application.getString(R.string.leak_canary_notification_retained_debugger_attached)
     )
   }
 
-  private fun showRetainedCountWithHeapDumpFailed(instanceCount: Int) {
+  private fun showRetainedCountWithHeapDumpFailed(objectCount: Int) {
     showRetainedCountNotification(
-        instanceCount, application.getString(R.string.leak_canary_notification_retained_dump_failed)
+        objectCount, application.getString(R.string.leak_canary_notification_retained_dump_failed)
     )
   }
 
-  private fun showNoMoreRetainedInstanceNotification() {
+  private fun showNoMoreRetainedObjectNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
     if (!Notifications.canShowNotification) {
       return
     }
     val builder = Notification.Builder(application)
         .setContentTitle(
-            application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+            application.getString(R.string.leak_canary_notification_no_retained_object_title)
         )
         .setContentText(
             application.getString(
-                R.string.leak_canary_notification_no_retained_instance_content
+                R.string.leak_canary_notification_no_retained_object_content
             )
         )
         .setAutoCancel(true)
         .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
     val notification =
       Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
-    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+    notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
     backgroundHandler.postDelayed(
-        scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+        scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS
     )
   }
 
   private fun showRetainedCountNotification(
-    instanceCount: Int,
+    objectCount: Int,
     contentText: String
   ) {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
     if (!Notifications.canShowNotification) {
       return
     }
+    @Suppress("DEPRECATION")
     val builder = Notification.Builder(application)
         .setContentTitle(
-            application.getString(R.string.leak_canary_notification_retained_title, instanceCount)
+            application.getString(R.string.leak_canary_notification_retained_title, objectCount)
         )
         .setContentText(contentText)
         .setAutoCancel(true)
         .setContentIntent(NotificationReceiver.pendingIntent(application, DUMP_HEAP))
     val notification =
       Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
-    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+    notificationManager.notify(R.id.leak_canary_notification_retained_objects, notification)
   }
 
   private fun dismissRetainedCountNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
-    notificationManager.cancel(R.id.leak_canary_notification_retained_instances)
+    notificationManager.cancel(R.id.leak_canary_notification_retained_objects)
   }
 
   private fun dismissNoRetainedOnTapNotification() {
     backgroundHandler.removeCallbacks(scheduleDismissNoRetainedOnTapNotification)
-    notificationManager.cancel(R.id.leak_canary_notification_no_retained_instance_on_tap)
+    notificationManager.cancel(R.id.leak_canary_notification_no_retained_object_on_tap)
   }
 
   companion object {
     private const val WAIT_FOR_DEBUG_MILLIS = 20_000L
     private const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
-    private const val WAIT_FOR_INSTANCE_THRESHOLD_MILLIS = 2_000L
-    private const val DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS = 30_000L
+    private const val WAIT_FOR_OBJECT_THRESHOLD_MILLIS = 2_000L
+    private const val DISMISS_NO_RETAINED_OBJECT_NOTIFICATION_MILLIS = 30_000L
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 8c71a08b..431d3434 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -4,6 +4,9 @@ import android.app.Application
 import android.app.Instrumentation
 import android.content.ComponentName
 import android.content.Intent
+import android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED
+import android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED
+import android.content.pm.PackageManager.DONT_KILL_APP
 import android.content.pm.ShortcutInfo.Builder
 import android.content.pm.ShortcutManager
 import android.graphics.drawable.Icon
@@ -12,15 +15,19 @@ import android.os.Build.VERSION_CODES
 import android.os.Handler
 import android.os.HandlerThread
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.GcTrigger
 import leakcanary.LeakCanary
 import leakcanary.LeakCanary.Config
-import leakcanary.LeakSentry
+import leakcanary.AppWatcher
+import leakcanary.OnHeapAnalyzedListener
+import leakcanary.OnObjectRetainedListener
 import leakcanary.internal.activity.LeakActivity
+import shark.SharkLog
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
 import java.util.concurrent.atomic.AtomicReference
 
-internal object InternalLeakCanary : LeakSentryListener {
+internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
 
   private const val DYNAMIC_SHORTCUT_ID = "com.squareup.leakcanary.dynamic_shortcut"
 
@@ -44,12 +51,17 @@ internal object InternalLeakCanary : LeakSentryListener {
 
   val noInstallConfig: Config
     get() = Config(
-        dumpHeap = false, knownReferences = emptySet(), leakTraceInspectors = emptyList()
+        dumpHeap = false,
+        referenceMatchers = emptyList(),
+        objectInspectors = emptyList(),
+        onHeapAnalyzedListener = OnHeapAnalyzedListener {}
     )
 
-  override fun onLeakSentryInstalled(application: Application) {
+  override fun invoke(application: Application) {
     this.application = application
 
+    AppWatcher.objectWatcher.addOnObjectRetainedListener(this)
+
     val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
 
     val gcTrigger = GcTrigger.Default
@@ -61,7 +73,8 @@ internal object InternalLeakCanary : LeakSentryListener {
     val backgroundHandler = Handler(handlerThread.looper)
 
     heapDumpTrigger = HeapDumpTrigger(
-        application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider
+        application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,
+        configProvider
     )
     application.registerVisibilityListener { applicationVisible ->
       this.applicationVisible = applicationVisible
@@ -94,12 +107,13 @@ internal object InternalLeakCanary : LeakSentryListener {
       }
 
       if (runningInInstrumentationTests) {
-        CanaryLog.d("Instrumentation test detected, setting LeakCanary.Config.dumpHeap to false")
+        SharkLog.d { "Instrumentation test detected, setting LeakCanary.Config.dumpHeap to false" }
         LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
       }
     }
   }
 
+  @Suppress("ReturnCount")
   private fun addDynamicShortcut(application: Application) {
     if (VERSION.SDK_INT < VERSION_CODES.N_MR1) {
       return
@@ -144,16 +158,10 @@ internal object InternalLeakCanary : LeakSentryListener {
       longLabel = leakActivityLabel
       shortLabel = leakActivityLabel
     } else {
-
       val firstLauncherActivityLabel = if (firstMainActivity.labelRes != 0) {
         application.getString(firstMainActivity.labelRes)
       } else {
-        val applicationInfo = application.applicationInfo
-        if (applicationInfo.labelRes != 0) {
-          application.getString(applicationInfo.labelRes)
-        } else {
-          applicationInfo.nonLocalizedLabel.toString()
-        }
+        application.packageManager.getApplicationLabel(application.applicationInfo)
       }
       val fullLengthLabel = "$firstLauncherActivityLabel $leakActivityLabel"
       // short label should be under 10 and long label under 25
@@ -196,18 +204,17 @@ internal object InternalLeakCanary : LeakSentryListener {
     try {
       shortcutManager.addDynamicShortcuts(listOf(shortcut))
     } catch (ignored: Throwable) {
-      CanaryLog.d(
-          ignored,
-          "Could not add dynamic shortcut. " +
-              "shortcutCount=$shortcutCount, " +
-              "maxShortcutCountPerActivity=${shortcutManager.maxShortcutCountPerActivity}"
-      )
+      SharkLog.d(ignored) {
+        "Could not add dynamic shortcut. " +
+            "shortcutCount=$shortcutCount, " +
+            "maxShortcutCountPerActivity=${shortcutManager.maxShortcutCountPerActivity}"
+      }
     }
   }
 
-  override fun onReferenceRetained() {
+  override fun onObjectRetained() {
     if (this::heapDumpTrigger.isInitialized) {
-      heapDumpTrigger.onReferenceRetained()
+      heapDumpTrigger.onObjectRetained()
     }
   }
 
@@ -217,5 +224,26 @@ internal object InternalLeakCanary : LeakSentryListener {
     }
   }
 
+  fun setEnabledBlocking(
+    componentClassName: String,
+    enabled: Boolean
+  ) {
+    val component = ComponentName(application, componentClassName)
+    val newState =
+      if (enabled) COMPONENT_ENABLED_STATE_ENABLED else COMPONENT_ENABLED_STATE_DISABLED
+    // Blocks on IPC.
+    application.packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP)
+  }
+
+  inline fun <reified T : Any> noOpDelegate(): T {
+    val javaClass = T::class.java
+    val noOpHandler = InvocationHandler { _, _, _ ->
+      // no op
+    }
+    return Proxy.newProxyInstance(
+        javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    ) as T
+  }
+
   private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
index cade0684..16d0c143 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakCanaryFileProvider.kt
@@ -1,9 +1,583 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package leakcanary.internal
 
-import androidx.core.content.FileProvider
+import android.content.ContentProvider
+import android.content.ContentValues
+import android.content.Context
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.content.pm.ProviderInfo
+import android.database.Cursor
+import android.database.MatrixCursor
+import android.net.Uri
+import android.os.Build
+import android.os.Environment
+import android.os.ParcelFileDescriptor
+import android.provider.OpenableColumns
+import android.text.TextUtils
+import android.webkit.MimeTypeMap
+import org.xmlpull.v1.XmlPullParser.END_DOCUMENT
+import org.xmlpull.v1.XmlPullParser.START_TAG
+import org.xmlpull.v1.XmlPullParserException
+import java.io.File
+import java.io.FileNotFoundException
+import java.io.IOException
+import java.util.HashMap
 
 /**
- * There can only be one [FileProvider] provider registered per app, so we extend that class
- * just to use a distinct name.
+ * Copy of androidx.core.content.FileProvider, converted to Kotlin.
  */
-internal class LeakCanaryFileProvider : FileProvider()
+internal class LeakCanaryFileProvider : ContentProvider() {
+
+  private var mStrategy: PathStrategy? = null
+
+  /**
+   * The default FileProvider implementation does not need to be initialized. If you want to
+   * override this method, you must provide your own subclass of FileProvider.
+   */
+  override fun onCreate(): Boolean {
+    return true
+  }
+
+  /**
+   * After the FileProvider is instantiated, this method is called to provide the system with
+   * information about the provider.
+   *
+   * @param context A [Context] for the current component.
+   * @param info A [ProviderInfo] for the new provider.
+   */
+  override fun attachInfo(
+    context: Context,
+    info: ProviderInfo
+  ) {
+    super.attachInfo(context, info)
+
+    // Sanity check our security
+    if (info.exported) {
+      throw SecurityException("Provider must not be exported")
+    }
+    if (!info.grantUriPermissions) {
+      throw SecurityException("Provider must grant uri permissions")
+    }
+
+    mStrategy = getPathStrategy(context, info.authority)
+  }
+
+  /**
+   * Use a content URI returned by
+   * [getUriForFile()][.getUriForFile] to get information about a file
+   * managed by the FileProvider.
+   * FileProvider reports the column names defined in [android.provider.OpenableColumns]:
+   *
+   *  * [android.provider.OpenableColumns.DISPLAY_NAME]
+   *  * [android.provider.OpenableColumns.SIZE]
+   *
+   * For more information, see
+   * [ ContentProvider.query()][ContentProvider.query].
+   *
+   * @param uri A content URI returned by [.getUriForFile].
+   * @param projection The list of columns to put into the [Cursor]. If null all columns are
+   * included.
+   * @param selection Selection criteria to apply. If null then all data that matches the content
+   * URI is returned.
+   * @param selectionArgs An array of [java.lang.String], containing arguments to bind to
+   * the *selection* parameter. The *query* method scans *selection* from left to
+   * right and iterates through *selectionArgs*, replacing the current "?" character in
+   * *selection* with the value at the current position in *selectionArgs*. The
+   * values are bound to *selection* as [java.lang.String] values.
+   * @param sortOrder A [java.lang.String] containing the column name(s) on which to sort
+   * the resulting [Cursor].
+   * @return A [Cursor] containing the results of the query.
+   */
+  override fun query(
+    uri: Uri,
+    projectionArg: Array<String>?,
+    selection: String?,
+    selectionArgs: Array<String>?,
+    sortOrder: String?
+  ): Cursor? {
+    val projection = projectionArg ?: COLUMNS
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy!!.getFileForUri(uri)
+
+    var cols = arrayOfNulls<String>(projection.size)
+    var values = arrayOfNulls<Any>(projection.size)
+    var i = 0
+    for (col in projection) {
+      if (OpenableColumns.DISPLAY_NAME == col) {
+        cols[i] = OpenableColumns.DISPLAY_NAME
+        values[i++] = file.name
+      } else if (OpenableColumns.SIZE == col) {
+        cols[i] = OpenableColumns.SIZE
+        values[i++] = file.length()
+      }
+    }
+
+    cols = copyOfStringArray(cols, i)
+    values = copyOfAnyArray(values, i)
+
+    val cursor = MatrixCursor(cols, 1)
+    cursor.addRow(values)
+    return cursor
+  }
+
+  /**
+   * Returns the MIME type of a content URI returned by
+   * [getUriForFile()][.getUriForFile].
+   *
+   * @param uri A content URI returned by
+   * [getUriForFile()][.getUriForFile].
+   * @return If the associated file has an extension, the MIME type associated with that
+   * extension; otherwise `application/octet-stream`.
+   */
+  override fun getType(uri: Uri): String? {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy!!.getFileForUri(uri)
+
+    val lastDot = file.name.lastIndexOf('.')
+    if (lastDot >= 0) {
+      val extension = file.name.substring(lastDot + 1)
+      val mime = MimeTypeMap.getSingleton()
+          .getMimeTypeFromExtension(extension)
+      if (mime != null) {
+        return mime
+      }
+    }
+
+    return "application/octet-stream"
+  }
+
+  /**
+   * By default, this method throws an [java.lang.UnsupportedOperationException]. You must
+   * subclass FileProvider if you want to provide different functionality.
+   */
+  override fun insert(
+    uri: Uri,
+    values: ContentValues?
+  ): Uri? {
+    throw UnsupportedOperationException("No external inserts")
+  }
+
+  /**
+   * By default, this method throws an [java.lang.UnsupportedOperationException]. You must
+   * subclass FileProvider if you want to provide different functionality.
+   */
+  override fun update(
+    uri: Uri,
+    values: ContentValues?,
+    selection: String?,
+    selectionArgs: Array<String>?
+  ): Int {
+    throw UnsupportedOperationException("No external updates")
+  }
+
+  /**
+   * Deletes the file associated with the specified content URI, as
+   * returned by [getUriForFile()][.getUriForFile]. Notice that this
+   * method does **not** throw an [java.io.IOException]; you must check its return value.
+   *
+   * @param uri A content URI for a file, as returned by
+   * [getUriForFile()][.getUriForFile].
+   * @param selection Ignored. Set to `null`.
+   * @param selectionArgs Ignored. Set to `null`.
+   * @return 1 if the delete succeeds; otherwise, 0.
+   */
+  override fun delete(
+    uri: Uri,
+    selection: String?,
+    selectionArgs: Array<String>?
+  ): Int {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy!!.getFileForUri(uri)
+    return if (file.delete()) 1 else 0
+  }
+
+  /**
+   * By default, FileProvider automatically returns the
+   * [ParcelFileDescriptor] for a file associated with a `content://`
+   * [Uri]. To get the [ParcelFileDescriptor], call
+   * [ ContentResolver.openFileDescriptor][android.content.ContentResolver.openFileDescriptor].
+   *
+   * To override this method, you must provide your own subclass of FileProvider.
+   *
+   * @param uri A content URI associated with a file, as returned by
+   * [getUriForFile()][.getUriForFile].
+   * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
+   * write access, or "rwt" for read and write access that truncates any existing file.
+   * @return A new [ParcelFileDescriptor] with which you can access the file.
+   */
+  @Throws(FileNotFoundException::class)
+  override fun openFile(
+    uri: Uri,
+    mode: String
+  ): ParcelFileDescriptor? {
+    // ContentProvider has already checked granted permissions
+    val file = mStrategy!!.getFileForUri(uri)
+    val fileMode = modeToMode(mode)
+    return ParcelFileDescriptor.open(file, fileMode)
+  }
+
+  /**
+   * Strategy for mapping between [File] and [Uri].
+   *
+   *
+   * Strategies must be symmetric so that mapping a [File] to a
+   * [Uri] and then back to a [File] points at the original
+   * target.
+   *
+   *
+   * Strategies must remain consistent across app launches, and not rely on
+   * dynamic state. This ensures that any generated [Uri] can still be
+   * resolved if your process is killed and later restarted.
+   *
+   * @see SimplePathStrategy
+   */
+  internal interface PathStrategy {
+    /**
+     * Return a [Uri] that represents the given [File].
+     */
+    fun getUriForFile(file: File): Uri
+
+    /**
+     * Return a [File] that represents the given [Uri].
+     */
+    fun getFileForUri(uri: Uri): File
+  }
+
+  /**
+   * Strategy that provides access to files living under a narrow whitelist of
+   * filesystem roots. It will throw [SecurityException] if callers try
+   * accessing files outside the configured roots.
+   *
+   *
+   * For example, if configured with
+   * `addRoot("myfiles", context.getFilesDir())`, then
+   * `context.getFileStreamPath("foo.txt")` would map to
+   * `content://myauthority/myfiles/foo.txt`.
+   */
+  internal class SimplePathStrategy(private val mAuthority: String) : PathStrategy {
+    private val mRoots = HashMap<String, File>()
+
+    /**
+     * Add a mapping from a name to a filesystem root. The provider only offers
+     * access to files that live under configured roots.
+     */
+    fun addRoot(
+      name: String,
+      root: File
+    ) {
+
+      if (TextUtils.isEmpty(name)) {
+        throw IllegalArgumentException("Name must not be empty")
+      }
+
+      mRoots[name] = try {
+        // Resolve to canonical path to keep path checking fast
+        root.canonicalFile
+      } catch (e: IOException) {
+        throw IllegalArgumentException(
+            "Failed to resolve canonical path for $root", e
+        )
+      }
+    }
+
+    override fun getUriForFile(file: File): Uri {
+      var path: String
+      try {
+        path = file.canonicalPath
+      } catch (e: IOException) {
+        throw IllegalArgumentException("Failed to resolve canonical path for $file")
+      }
+
+      // Find the most-specific root path
+      var mostSpecific: MutableMap.MutableEntry<String, File>? = null
+      for (root in mRoots.entries) {
+        val rootPath = root.value.path
+        if (path.startsWith(
+                rootPath
+            ) && (mostSpecific == null || rootPath.length > mostSpecific.value.path.length)
+        ) {
+          mostSpecific = root
+        }
+      }
+
+      if (mostSpecific == null) {
+        throw IllegalArgumentException(
+            "Failed to find configured root that contains $path"
+        )
+      }
+
+      // Start at first char of path under root
+      val rootPath = mostSpecific.value.path
+      if (rootPath.endsWith("/")) {
+        path = path.substring(rootPath.length)
+      } else {
+        path = path.substring(rootPath.length + 1)
+      }
+
+      // Encode the tag and path separately
+      path = Uri.encode(mostSpecific.key) + '/'.toString() + Uri.encode(path, "/")
+      return Uri.Builder()
+          .scheme("content")
+          .authority(mAuthority)
+          .encodedPath(path)
+          .build()
+    }
+
+    override fun getFileForUri(uri: Uri): File {
+      var path = uri.encodedPath
+
+      val splitIndex = path!!.indexOf('/', 1)
+      val tag = Uri.decode(path.substring(1, splitIndex))
+      path = Uri.decode(path.substring(splitIndex + 1))
+
+      val root =
+        mRoots[tag] ?: throw IllegalArgumentException("Unable to find configured root for $uri")
+
+      var file = File(root, path!!)
+      try {
+        file = file.canonicalFile
+      } catch (e: IOException) {
+        throw IllegalArgumentException("Failed to resolve canonical path for $file")
+      }
+
+      if (!file.path.startsWith(root.path)) {
+        throw SecurityException("Resolved path jumped beyond configured root")
+      }
+
+      return file
+    }
+  }
+
+  companion object {
+    private val COLUMNS = arrayOf(OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE)
+
+    private val META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS"
+
+    private val TAG_ROOT_PATH = "root-path"
+    private val TAG_FILES_PATH = "files-path"
+    private val TAG_CACHE_PATH = "cache-path"
+    private val TAG_EXTERNAL = "external-path"
+    private val TAG_EXTERNAL_FILES = "external-files-path"
+    private val TAG_EXTERNAL_CACHE = "external-cache-path"
+    private val TAG_EXTERNAL_MEDIA = "external-media-path"
+
+    private val ATTR_NAME = "name"
+    private val ATTR_PATH = "path"
+
+    private val DEVICE_ROOT = File("/")
+
+    private val sCache = HashMap<String, PathStrategy>()
+
+    /**
+     * Return a content URI for a given [File]. Specific temporary
+     * permissions for the content URI can be set with
+     * [Context.grantUriPermission], or added
+     * to an [Intent] by calling [setData()][Intent.setData] and then
+     * [setFlags()][Intent.setFlags]; in both cases, the applicable flags are
+     * [Intent.FLAG_GRANT_READ_URI_PERMISSION] and
+     * [Intent.FLAG_GRANT_WRITE_URI_PERMISSION]. A FileProvider can only return a
+     * `content` [Uri] for file paths defined in their `<paths>`
+     * meta-data element. See the Class Overview for more information.
+     *
+     * @param context A [Context] for the current component.
+     * @param authority The authority of a [FileProvider] defined in a
+     * `<provider>` element in your app's manifest.
+     * @param file A [File] pointing to the filename for which you want a
+     * `content` [Uri].
+     * @return A content URI for the file.
+     * @throws IllegalArgumentException When the given [File] is outside
+     * the paths supported by the provider.
+     */
+    fun getUriForFile(
+      context: Context,
+      authority: String,
+      file: File
+    ): Uri {
+      val strategy = getPathStrategy(context, authority)
+      return strategy!!.getUriForFile(file)
+    }
+
+    /**
+     * Return [PathStrategy] for given authority, either by parsing or
+     * returning from cache.
+     */
+    private fun getPathStrategy(
+      context: Context,
+      authority: String
+    ): PathStrategy? {
+      var strat: PathStrategy?
+      synchronized(sCache) {
+        strat = sCache[authority]
+        if (strat == null) {
+          try {
+            strat = parsePathStrategy(context, authority)
+          } catch (e: IOException) {
+            throw IllegalArgumentException(
+                "Failed to parse $META_DATA_FILE_PROVIDER_PATHS meta-data", e
+            )
+          } catch (e: XmlPullParserException) {
+            throw IllegalArgumentException(
+                "Failed to parse $META_DATA_FILE_PROVIDER_PATHS meta-data", e
+            )
+          }
+          sCache[authority] = strat!!
+        }
+      }
+      return strat
+    }
+
+    /**
+     * Parse and return [PathStrategy] for given authority as defined in
+     * [.META_DATA_FILE_PROVIDER_PATHS] `<meta-data>`.
+     *
+     * @see .getPathStrategy
+     */
+    @Throws(IOException::class, XmlPullParserException::class)
+    private fun parsePathStrategy(
+      context: Context,
+      authority: String
+    ): PathStrategy {
+      val strat = SimplePathStrategy(authority)
+
+      val info = context.packageManager
+          .resolveContentProvider(authority, PackageManager.GET_META_DATA)!!
+      val resourceParser = info.loadXmlMetaData(
+          context.packageManager, META_DATA_FILE_PROVIDER_PATHS
+      ) ?: throw IllegalArgumentException(
+          "Missing $META_DATA_FILE_PROVIDER_PATHS meta-data"
+      )
+
+      var type = 0
+      while (({ type = resourceParser.next(); type }()) != END_DOCUMENT) {
+        if (type == START_TAG) {
+          val tag = resourceParser.name
+
+          val name = resourceParser.getAttributeValue(null, ATTR_NAME)
+          val path = resourceParser.getAttributeValue(null, ATTR_PATH)
+
+          var target: File? = null
+          if (TAG_ROOT_PATH == tag) {
+            target = DEVICE_ROOT
+          } else if (TAG_FILES_PATH == tag) {
+            target = context.filesDir
+          } else if (TAG_CACHE_PATH == tag) {
+            target = context.cacheDir
+          } else if (TAG_EXTERNAL == tag) {
+            target = Environment.getExternalStorageDirectory()
+          } else if (TAG_EXTERNAL_FILES == tag) {
+            val externalFilesDirs = getExternalFilesDirs(context, null)
+            if (externalFilesDirs.isNotEmpty()) {
+              target = externalFilesDirs[0]
+            }
+          } else if (TAG_EXTERNAL_CACHE == tag) {
+            val externalCacheDirs = getExternalCacheDirs(context)
+            if (externalCacheDirs.isNotEmpty()) {
+              target = externalCacheDirs[0]
+            }
+          } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && TAG_EXTERNAL_MEDIA == tag) {
+            val externalMediaDirs = context.externalMediaDirs
+            if (externalMediaDirs.isNotEmpty()) {
+              target = externalMediaDirs[0]
+            }
+          }
+
+          if (target != null) {
+            strat.addRoot(name, buildPath(target, path))
+          }
+        }
+      }
+
+      return strat
+    }
+
+    private fun getExternalFilesDirs(
+      context: Context,
+      type: String?
+    ): Array<File> {
+      return if (Build.VERSION.SDK_INT >= 19) {
+        context.getExternalFilesDirs(type)
+      } else {
+        arrayOf<File>(context.getExternalFilesDir(type)!!)
+      }
+    }
+
+    private fun getExternalCacheDirs(context: Context): Array<File> {
+      return if (Build.VERSION.SDK_INT >= 19) {
+        context.externalCacheDirs
+      } else {
+        arrayOf(context.externalCacheDir!!)
+      }
+    }
+
+    /**
+     * Copied from ContentResolver.java
+     */
+    private fun modeToMode(mode: String): Int {
+      val modeBits: Int
+      if ("r" == mode) {
+        modeBits = ParcelFileDescriptor.MODE_READ_ONLY
+      } else if ("w" == mode || "wt" == mode) {
+        modeBits = (ParcelFileDescriptor.MODE_WRITE_ONLY
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_TRUNCATE)
+      } else if ("wa" == mode) {
+        modeBits = (ParcelFileDescriptor.MODE_WRITE_ONLY
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_APPEND)
+      } else if ("rw" == mode) {
+        modeBits = ParcelFileDescriptor.MODE_READ_WRITE or ParcelFileDescriptor.MODE_CREATE
+      } else if ("rwt" == mode) {
+        modeBits = (ParcelFileDescriptor.MODE_READ_WRITE
+            or ParcelFileDescriptor.MODE_CREATE
+            or ParcelFileDescriptor.MODE_TRUNCATE)
+      } else {
+        throw IllegalArgumentException("Invalid mode: $mode")
+      }
+      return modeBits
+    }
+
+    private fun buildPath(
+      base: File,
+      vararg segments: String
+    ): File {
+      var cur = base
+      for (segment in segments) {
+        cur = File(cur, segment)
+      }
+      return cur
+    }
+
+    private fun copyOfStringArray(
+      original: Array<String?>,
+      newLength: Int
+    ): Array<String?> {
+      val result = arrayOfNulls<String>(newLength)
+      System.arraycopy(original, 0, result, 0, newLength)
+      return result
+    }
+
+    private fun copyOfAnyArray(
+      original: Array<Any?>,
+      newLength: Int
+    ): Array<Any?> {
+      val result = arrayOfNulls<Any>(newLength)
+      System.arraycopy(original, 0, result, 0, newLength)
+      return result
+    }
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index a42d6fdc..2c614672 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -24,8 +24,8 @@ import android.os.Build.VERSION_CODES.M
 import android.os.Environment
 import android.os.Environment.DIRECTORY_DOWNLOADS
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import shark.SharkLog
 import java.io.File
 import java.io.FilenameFilter
 import java.text.SimpleDateFormat
@@ -56,12 +56,12 @@ internal class LeakDirectoryProvider constructor(
 
     val externalFiles = externalStorageDirectory().listFiles(filter)
     if (externalFiles != null) {
-      files.addAll(Arrays.asList(*externalFiles))
+      files.addAll(externalFiles)
     }
 
     val appFiles = appStorageDirectory().listFiles(filter)
     if (appFiles != null) {
-      files.addAll(Arrays.asList(*appFiles))
+      files.addAll(appFiles)
     }
     return files
   }
@@ -73,29 +73,27 @@ internal class LeakDirectoryProvider constructor(
     if (!directoryWritableAfterMkdirs(storageDirectory)) {
       if (!hasStoragePermission()) {
         if (requestExternalStoragePermission()) {
-          CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted, requesting")
+          SharkLog.d { "WRITE_EXTERNAL_STORAGE permission not granted, requesting" }
           requestWritePermissionNotification()
         } else {
-          CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted, ignoring")
+          SharkLog.d { "WRITE_EXTERNAL_STORAGE permission not granted, ignoring" }
         }
       } else {
         val state = Environment.getExternalStorageState()
         if (Environment.MEDIA_MOUNTED != state) {
-          CanaryLog.d("External storage not mounted, state: %s", state)
+          SharkLog.d { "External storage not mounted, state: $state" }
         } else {
-          CanaryLog.d(
-              "Could not create heap dump directory in external storage: [%s]",
-              storageDirectory.absolutePath
-          )
+          SharkLog.d {
+              "Could not create heap dump directory in external storage: [${storageDirectory.absolutePath}]"
+          }
         }
       }
       // Fallback to app storage.
       storageDirectory = appStorageDirectory()
       if (!directoryWritableAfterMkdirs(storageDirectory)) {
-        CanaryLog.d(
-            "Could not create heap dump directory in app storage: [%s]",
-            storageDirectory.absolutePath
-        )
+        SharkLog.d {
+            "Could not create heap dump directory in app storage: [${storageDirectory.absolutePath}]"
+        }
         return null
       }
     }
@@ -116,7 +114,7 @@ internal class LeakDirectoryProvider constructor(
         filesDeletedClearDirectory += path
       }
       if (!deleted) {
-        CanaryLog.d("Could not delete file %s", file.path)
+        SharkLog.d { "Could not delete file ${file.path}" }
       }
     }
   }
@@ -154,6 +152,7 @@ internal class LeakDirectoryProvider constructor(
     )
   }
 
+  @Suppress("DEPRECATION")
   private fun externalStorageDirectory(): File {
     val downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
     return File(downloadsDirectory, "leakcanary-" + context.packageName)
@@ -182,7 +181,7 @@ internal class LeakDirectoryProvider constructor(
 
     val filesToRemove = hprofFiles.size - maxStoredHeapDumps
     if (filesToRemove > 0) {
-      CanaryLog.d("Removing %d heap dumps", filesToRemove)
+      SharkLog.d { "Removing $filesToRemove heap dumps" }
       // Sort with oldest modified first.
       hprofFiles.sortWith(Comparator { lhs, rhs ->
         java.lang.Long.valueOf(lhs.lastModified())
@@ -194,7 +193,7 @@ internal class LeakDirectoryProvider constructor(
         if (deleted) {
           filesDeletedTooOld += path
         } else {
-          CanaryLog.d("Could not delete old hprof file %s", hprofFiles[i].path)
+          SharkLog.d { "Could not delete old hprof file ${hprofFiles[i].path}" }
         }
       }
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt
deleted file mode 100644
index ab13f6ea..00000000
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/MoreDetailsView.kt
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import android.annotation.SuppressLint
-import android.content.Context
-import android.graphics.Canvas
-import android.graphics.Color
-import android.graphics.Paint
-import android.util.AttributeSet
-import android.view.View
-import com.squareup.leakcanary.core.R
-import leakcanary.internal.MoreDetailsView.Details.CLOSED
-import leakcanary.internal.MoreDetailsView.Details.OPENED
-
-internal class MoreDetailsView(
-  context: Context,
-  attrs: AttributeSet
-) : View(context, attrs) {
-
-  enum class Details {
-    OPENED,
-    CLOSED,
-    NONE
-  }
-
-  private val iconPaint: Paint
-
-  private var details = Details.NONE
-
-  init {
-    val resources = resources
-    iconPaint = Paint(Paint.ANTI_ALIAS_FLAG)
-    val strokeSize = resources.getDimensionPixelSize(R.dimen.leak_canary_more_stroke_width)
-        .toFloat()
-    iconPaint.strokeWidth = strokeSize
-
-    // This lint check doesn't work for libraries which have a common prefix.
-    @SuppressLint("CustomViewStyleable") //
-    val a = context.obtainStyledAttributes(attrs, R.styleable.leak_canary_MoreDetailsView)
-    val plusColor =
-      a.getColor(R.styleable.leak_canary_MoreDetailsView_leak_canary_plus_color, Color.BLACK)
-    a.recycle()
-
-    iconPaint.color = plusColor
-  }
-
-  override fun onDraw(canvas: Canvas) {
-    val width = width
-    val height = height
-    val halfHeight = height / 2
-    val halfWidth = width / 2
-
-    if (details == OPENED) {
-      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
-    } else if (details == CLOSED) {
-      canvas.drawLine(0f, halfHeight.toFloat(), width.toFloat(), halfHeight.toFloat(), iconPaint)
-      canvas.drawLine(halfWidth.toFloat(), 0f, halfWidth.toFloat(), height.toFloat(), iconPaint)
-    }
-  }
-
-  fun setDetails(details: Details) {
-    if (details != this.details) {
-      this.details = details
-      invalidate()
-    }
-  }
-}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
index f7e7f86c..d4663f50 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
@@ -4,9 +4,9 @@ import android.app.PendingIntent
 import android.content.BroadcastReceiver
 import android.content.Context
 import android.content.Intent
-import leakcanary.CanaryLog
 import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
 import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
+import shark.SharkLog
 
 internal class NotificationReceiver : BroadcastReceiver() {
 
@@ -27,7 +27,7 @@ internal class NotificationReceiver : BroadcastReceiver() {
         // Do nothing, the notification has auto cancel true.
       }
       else -> {
-        CanaryLog.d("NotificationReceiver received unknown intent action for $intent")
+        SharkLog.d { "NotificationReceiver received unknown intent action for $intent" }
       }
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
index 677f7f48..d9f59cde 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationType.kt
@@ -1,9 +1,8 @@
 package leakcanary.internal
 
-import androidx.annotation.StringRes
 import com.squareup.leakcanary.core.R
 
-enum class NotificationType(@StringRes val nameResId: Int, val importance: Int) {
+internal enum class NotificationType(val nameResId: Int, val importance: Int) {
   LEAKCANARY_LOW(
       R.string.leak_canary_notification_channel_low, IMPORTANCE_LOW
   ),
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
index 3559c153..a636bea2 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
@@ -36,6 +36,7 @@ internal object Notifications {
     !InternalLeakCanary.application.packageManager.isInstantApp
   } else true
 
+  @Suppress("LongParameterList")
   fun showNotification(
     context: Context,
     contentTitle: CharSequence,
@@ -83,6 +84,7 @@ internal object Notifications {
     }
 
     return if (SDK_INT < JELLY_BEAN) {
+      @Suppress("DEPRECATION")
       builder.notification
     } else {
       builder.build()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
index 5d470a4d..2710a5bc 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/RowElementLayout.kt
@@ -34,9 +34,7 @@ internal class RowElementLayout(
   private val moreMarginTop: Int
 
   private var connector: View? = null
-  private var moreButton: View? = null
   private var title: View? = null
-  private var details: View? = null
 
   init {
     val resources = resources
@@ -51,9 +49,7 @@ internal class RowElementLayout(
   override fun onFinishInflate() {
     super.onFinishInflate()
     connector = findViewById(R.id.leak_canary_row_connector)
-    moreButton = findViewById(R.id.leak_canary_row_more)
     title = findViewById(R.id.leak_canary_row_title)
-    details = findViewById(R.id.leak_canary_row_details)
   }
 
   override fun onMeasure(
@@ -66,18 +62,7 @@ internal class RowElementLayout(
     val titleHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
     title!!.measure(titleWidthSpec, titleHeightSpec)
 
-    val moreSizeSpec = View.MeasureSpec.makeMeasureSpec(moreSize, View.MeasureSpec.EXACTLY)
-    moreButton!!.measure(moreSizeSpec, moreSizeSpec)
-
     var totalHeight = titleMarginTop + title!!.measuredHeight
-
-    val detailsWidth = availableWidth - connectorWidth - 3 * rowMargins
-    val detailsWidthSpec = View.MeasureSpec.makeMeasureSpec(detailsWidth, View.MeasureSpec.AT_MOST)
-    val detailsHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)
-    details!!.measure(detailsWidthSpec, detailsHeightSpec)
-    if (details!!.visibility != View.GONE) {
-      totalHeight += details!!.measuredHeight
-    }
     totalHeight = Math.max(totalHeight, minHeight)
 
     val connectorWidthSpec =
@@ -96,24 +81,11 @@ internal class RowElementLayout(
     r: Int,
     b: Int
   ) {
-    val width = measuredWidth
     val connectorRight = rowMargins + connector!!.measuredWidth
     connector!!.layout(rowMargins, 0, connectorRight, connector!!.measuredHeight)
 
-    moreButton!!.layout(
-        width - rowMargins - moreSize, moreMarginTop, width - rowMargins,
-        moreMarginTop + moreSize
-    )
-
     val titleLeft = connectorRight + rowMargins
     val titleBottom = titleMarginTop + title!!.measuredHeight
     title!!.layout(titleLeft, titleMarginTop, titleLeft + title!!.measuredWidth, titleBottom)
-
-    if (details!!.visibility != View.GONE) {
-      details!!.layout(
-          titleLeft, titleBottom, width - rowMargins,
-          titleBottom + details!!.measuredHeight
-      )
-    }
   }
 }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
similarity index 65%
rename from leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt
rename to leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
index 786cb3aa..b5cefe21 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Serializables.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
@@ -1,4 +1,4 @@
-package leakcanary
+package leakcanary.internal
 
 import java.io.ByteArrayInputStream
 import java.io.ByteArrayOutputStream
@@ -6,23 +6,18 @@ import java.io.ObjectInputStream
 import java.io.ObjectOutputStream
 import java.io.Serializable
 
-fun Serializable.toByteArray(): ByteArray {
+internal fun Serializable.toByteArray(): ByteArray {
   val outputStream = ByteArrayOutputStream()
   ObjectOutputStream(outputStream).writeObject(this)
   return outputStream.toByteArray()
 }
 
-object Serializables {
+internal object Serializables {
 
   inline fun <reified T> fromByteArray(byteArray: ByteArray): T? {
     val inputStream = ByteArrayInputStream(byteArray)
     return try {
-      val deserializedObject = ObjectInputStream(inputStream).readObject()
-      if (deserializedObject is T) {
-        deserializedObject
-      } else {
-        null
-      }
+      ObjectInputStream(inputStream).readObject() as? T
     } catch (ignored: Throwable) {
       null
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
index 747f488f..68e59a65 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
@@ -22,8 +22,8 @@ import android.graphics.Path
 import android.text.SpannableStringBuilder
 import android.text.style.ReplacementSpan
 import android.text.style.UnderlineSpan
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.navigation.getColorCompat
 
 /**
  * Inspired from https://github.com/flavienlaurent/spans and
@@ -44,7 +44,7 @@ internal class SquigglySpan(context: Context) : ReplacementSpan() {
   init {
     val resources = context.resources
     squigglyPaint.style = Paint.Style.STROKE
-    squigglyPaint.color = ContextCompat.getColor(context, R.color.leak_canary_leak)
+    squigglyPaint.color = context.getColorCompat(R.color.leak_canary_leak)
     val strokeWidth =
       resources.getDimensionPixelSize(R.dimen.leak_canary_squiggly_span_stroke_width)
           .toFloat()
@@ -59,7 +59,7 @@ internal class SquigglySpan(context: Context) : ReplacementSpan() {
     path = Path()
     val waveHeight = 2 * amplitude + strokeWidth
     halfWaveHeight = waveHeight / 2
-    referenceColor = ContextCompat.getColor(context, R.color.leak_canary_reference)
+    referenceColor = context.getColorCompat(R.color.leak_canary_reference)
   }
 
   override fun getSize(
@@ -113,6 +113,7 @@ internal class SquigglySpan(context: Context) : ReplacementSpan() {
       }
     }
 
+    @Suppress("LongParameterList")
     private fun squigglyHorizontalPath(
       path: Path,
       left: Float,
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
index ca214b51..72dca8a3 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/VisibilityTracker.kt
@@ -2,7 +2,7 @@ package leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.internal.InternalLeakCanary.noOpDelegate
 
 internal class VisibilityTracker(
   private val listener: (Boolean) -> Unit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
index bd1ba2e0..7810176f 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
@@ -7,13 +7,13 @@ import android.net.Uri
 import android.os.AsyncTask
 import android.os.Bundle
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.internal.HeapAnalyzerService
 import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.activity.db.Db
 import leakcanary.internal.activity.screen.GroupListScreen
 import leakcanary.internal.navigation.NavigatingActivity
 import leakcanary.internal.navigation.Screen
+import shark.SharkLog
 import java.io.FileInputStream
 import java.io.IOException
 
@@ -47,9 +47,9 @@ internal class LeakActivity : NavigatingActivity() {
     resultCode: Int,
     returnIntent: Intent?
   ) {
-    CanaryLog.d(
+    SharkLog.d {
         "Got activity result with requestCode=$requestCode resultCode=$resultCode returnIntent=$returnIntent"
-    )
+    }
     if (requestCode == FILE_REQUEST_CODE && resultCode == RESULT_OK && returnIntent != null) {
       returnIntent.data?.let { fileUri ->
         AsyncTask.THREAD_POOL_EXECUTOR.execute {
@@ -77,7 +77,7 @@ internal class LeakActivity : NavigatingActivity() {
             }
       }
     } catch (e: IOException) {
-      CanaryLog.d(e, "Could not imported Hprof file")
+      SharkLog.d(e) { "Could not imported Hprof file" }
     }
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
index d6e750d7..50582257 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -9,8 +9,8 @@ import android.net.Uri
 import android.os.AsyncTask
 import android.view.View
 import android.widget.Toast
-import androidx.core.content.FileProvider
 import com.squareup.leakcanary.core.R
+import leakcanary.internal.LeakCanaryFileProvider
 import leakcanary.internal.navigation.activity
 import java.io.File
 
@@ -27,7 +27,7 @@ internal fun View.share(content: String) {
 internal fun View.shareHeapDump(heapDumpFile: File) {
   AsyncTask.SERIAL_EXECUTOR.execute {
     heapDumpFile.setReadable(true, false)
-    val heapDumpUri = FileProvider.getUriForFile(
+    val heapDumpUri = LeakCanaryFileProvider.getUriForFile(
         activity,
         "com.squareup.leakcanary.fileprovider." + activity.packageName,
         heapDumpFile
@@ -50,10 +50,10 @@ internal fun View.shareToStackOverflow(content: String) {
   // AsyncTask was needed here due to setPrimaryClip making a disk write which
   // violated StrictMode if on the main thread
   AsyncTask.execute {
-    clipboard.primaryClip = ClipData.newPlainText(
+    clipboard.setPrimaryClip(ClipData.newPlainText(
         context.getString(R.string.leak_canary_leak_clipdata_label),
         "```\n$content```"
-    )
+    ))
   }
   Toast.makeText(context, R.string.leak_canary_leak_copied, Toast.LENGTH_LONG)
       .show()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index 69b48390..780f862e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -4,16 +4,15 @@ import android.content.ContentValues
 import android.content.Context
 import android.database.sqlite.SQLiteDatabase
 import android.os.AsyncTask
-import leakcanary.CanaryLog
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.Serializables
 import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.LeakDirectoryProvider
-import leakcanary.leakingInstances
-import leakcanary.toByteArray
+import leakcanary.internal.Serializables
+import leakcanary.internal.toByteArray
 import org.intellij.lang.annotations.Language
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
 import java.io.File
 
 internal object HeapAnalysisTable {
@@ -40,7 +39,7 @@ internal object HeapAnalysisTable {
     values.put("object", heapAnalysis.toByteArray())
     when (heapAnalysis) {
       is HeapAnalysisSuccess -> {
-        values.put("retained_instance_count", heapAnalysis.retainedInstances.size)
+        values.put("retained_instance_count", heapAnalysis.allLeaks.size)
       }
       is HeapAnalysisFailure -> {
         val cause = heapAnalysis.exception.cause!!
@@ -51,12 +50,14 @@ internal object HeapAnalysisTable {
 
     return db.inTransaction {
       val heapAnalysisId = db.insertOrThrow("heap_analysis", null, values)
-      heapAnalysis.leakingInstances()
-          .forEach { leakingInstance ->
-            LeakingInstanceTable.insert(
-                db, heapAnalysisId, leakingInstance
-            )
-          }
+      if (heapAnalysis is HeapAnalysisSuccess) {
+        heapAnalysis.allLeaks
+            .forEach { leakingInstance ->
+              LeakingInstanceTable.insert(
+                  db, heapAnalysisId, leakingInstance
+              )
+            }
+      }
       heapAnalysisId
     }
   }
@@ -126,7 +127,7 @@ internal object HeapAnalysisTable {
         if (heapDumpDeleted) {
           LeakDirectoryProvider.filesDeletedRemoveLeak += path
         } else {
-          CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.path)
+          SharkLog.d { "Could not delete heap dump file ${heapDumpFile.path}" }
         }
       }
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index 0803bb72..774a732a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -2,16 +2,15 @@ package leakcanary.internal.activity.db
 
 import android.content.ContentValues
 import android.database.sqlite.SQLiteDatabase
-import leakcanary.Exclusion
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import leakcanary.LeakTrace
-import leakcanary.LeakTraceElement
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakingInstance
-import leakcanary.Serializables
+import leakcanary.internal.Serializables
+import leakcanary.internal.toByteArray
 import leakcanary.internal.utils.to
-import leakcanary.toByteArray
 import org.intellij.lang.annotations.Language
+import shark.Leak
+import shark.LibraryLeak
+import shark.LeakTrace
+import shark.LeakTraceElement
+import shark.LeakTraceElement.Type.ARRAY_ENTRY
 
 internal object LeakingInstanceTable {
 
@@ -24,7 +23,7 @@ internal object LeakingInstanceTable {
         group_hash TEXT,
         group_description TEXT,
         class_simple_name TEXT,
-        exclusion_status INTEGER,
+        is_library_leak INTEGER,
         object BLOB
         )"""
 
@@ -40,22 +39,22 @@ internal object LeakingInstanceTable {
   fun insert(
     db: SQLiteDatabase,
     heapAnalysisId: Long,
-    leakingInstance: LeakingInstance
+    leak: Leak
   ): Long {
     val values = ContentValues()
     values.put("heap_analysis_id", heapAnalysisId)
-    values.put("group_hash", leakingInstance.groupHash)
-    values.put("group_description", leakingInstance.createGroupDescription())
-    values.put("class_simple_name", leakingInstance.instanceClassSimpleName)
-    values.put("object", leakingInstance.toByteArray())
-    values.put("exclusion_status", leakingInstance.exclusionStatus?.ordinal ?: -1)
+    values.put("group_hash", leak.groupHash)
+    values.put("group_description", leak.createGroupDescription())
+    values.put("class_simple_name", leak.classSimpleName)
+    values.put("object", leak.toByteArray())
+    values.put("is_library_leak", if (leak is LibraryLeak) 1 else 0)
     return db.insertOrThrow("leaking_instance", null, values)
   }
 
   fun retrieve(
     db: SQLiteDatabase,
     id: Long
-  ): Pair<Long, LeakingInstance>? {
+  ): Pair<Long, Leak>? {
     return db.rawQuery(
         """
           SELECT
@@ -68,7 +67,7 @@ internal object LeakingInstanceTable {
         .use { cursor ->
           if (cursor.moveToNext()) {
             val heapAnalysisId = cursor.getLong(0)
-            val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(1))
+            val leakingInstance = Serializables.fromByteArray<Leak>(cursor.getBlob(1))
             if (leakingInstance == null) {
               null
             } else {
@@ -86,7 +85,7 @@ internal object LeakingInstanceTable {
     val leakCount: Int,
     val totalLeakCount: Int,
     val isNew: Boolean,
-    val exclusionStatus: Exclusion.Status?
+    val isLibraryLeak: Boolean
   )
 
   fun retrieveAllByHeapAnalysisId(
@@ -108,7 +107,7 @@ internal object LeakingInstanceTable {
           , MAX(created_at_time_millis) as created_at_time_millis
           , SUM(CASE WHEN heap_analysis_id=$heapAnalysisId THEN 1 ELSE 0 END) as leak_count
           , COUNT(*) as total_leak_count
-          , MIN(exclusion_status) as exclusion_status
+          , MIN(is_library_leak) as is_library_leak
           FROM leaking_instance l
           LEFT JOIN heap_analysis h ON l.heap_analysis_id = h.id
           GROUP BY 1, 2
@@ -125,12 +124,10 @@ internal object LeakingInstanceTable {
             val leakCount = cursor.getInt(3)
             val totalLeakCount = cursor.getInt(4)
             val isNew = isLatestHeapAnalysis && leakCount == totalLeakCount
-            val exclusionStatusOrdinal = cursor.getInt(5)
-            val exclusionStatus =
-              if (exclusionStatusOrdinal == -1) null else Exclusion.Status.values()[exclusionStatusOrdinal]
+            val isLibraryLeak = cursor.getInt(5) == 1
             val group = HeapAnalysisGroupProjection(
                 hash, description, createdAtTimeMillis, leakCount, totalLeakCount, isNew,
-                exclusionStatus
+                isLibraryLeak
             )
             projectionsByHash[hash] = group
           }
@@ -198,14 +195,11 @@ internal object LeakingInstanceTable {
     )
         .use { cursor ->
           if (cursor.moveToNext()) {
-            val leakingInstance = Serializables.fromByteArray<LeakingInstance>(cursor.getBlob(0))!!
+            val leakingInstance = Serializables.fromByteArray<Leak>(cursor.getBlob(0))!!
             val leakTrace = leakingInstance.leakTrace
 
-            val groupLeakTrace = if (leakingInstance.exclusionStatus == WONT_FIX_LEAK) {
-              val index = leakTrace.elements.indexOfFirst { element -> element.exclusion != null }
-              LeakTrace(
-                  elements = listOf(leakTrace.elements[index].copy(labels = emptyList()))
-              )
+            val groupLeakTrace = if (leakingInstance is LibraryLeak) {
+              LeakTrace(elements = emptyList())
             } else {
               val elements = mutableListOf<LeakTraceElement>()
               for (index in 0 until leakTrace.elements.size) {
@@ -215,9 +209,10 @@ internal object LeakingInstanceTable {
                   val reference = element.reference!!
                   if (reference.type == ARRAY_ENTRY) {
                     // No array index in groups
-                    element = element.copy(reference = reference.copy(name = "x"), labels = emptyList())
+                    element =
+                      element.copy(reference = reference.copy(name = "x"), labels = emptySet(), leakStatusReason = "")
                   } else {
-                    element = element.copy(labels = emptyList())
+                    element = element.copy(labels = emptySet(), leakStatusReason = "")
                   }
 
                   elements.add(element)
@@ -271,14 +266,14 @@ internal object LeakingInstanceTable {
     db.delete("leaking_instance", null, null)
   }
 
-  private fun LeakingInstance.createGroupDescription(): String {
-    return if (exclusionStatus == WONT_FIX_LEAK) {
-      leakTrace.firstElementExclusion.matching
+  private fun Leak.createGroupDescription(): String {
+    return if (this is LibraryLeak) {
+      "Library Leak: " + pattern.toString()
     } else {
       val leakCauses = leakTrace.leakCauses
       if (leakCauses.isEmpty()) {
         // Should rarely happen, don't expect to see 0 unknown and 100% leaking or 100% not leaking
-        instanceClassName
+        className
       } else {
         val element = leakCauses.first()
         val referenceName = element.reference!!.groupingName
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 2a010a8e..aed738d9 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -26,6 +26,6 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
 
   companion object {
     // Last updated for next after 2.0-alpha-3
-    private const val VERSION = 11
+    private const val VERSION = 16
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
index 005e697d..628befce 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupListScreen.kt
@@ -1,14 +1,17 @@
 package leakcanary.internal.activity.screen
 
 import android.app.AlertDialog
+import android.content.Context
+import android.graphics.drawable.Drawable
+import android.os.Build.VERSION.SDK_INT
+import android.text.Html
 import android.text.format.DateUtils
 import android.text.method.LinkMovementMethod
 import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
-import androidx.core.content.ContextCompat
-import androidx.core.text.HtmlCompat
+import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
 import leakcanary.internal.activity.LeakActivity
 import leakcanary.internal.activity.db.LeakingInstanceTable
@@ -37,16 +40,14 @@ internal class GroupListScreen : Screen() {
               true
             }
 
-        menu.add(R.string.leak_canary_about_title)
+        menu.add(R.string.leak_canary_about_menu)
             .setOnMenuItemClickListener {
+              @Suppress("DEPRECATION")
               val dialog = AlertDialog.Builder(context)
-                  .setIcon(ContextCompat.getDrawable(context, R.drawable.leak_canary_icon))
-                  .setTitle(R.string.leak_canary_about_title)
+                  .setIcon(context.getDrawableCompat(R.drawable.leak_canary_icon))
+                  .setTitle(resources.getString(R.string.leak_canary_about_title, BuildConfig.LIBRARY_VERSION))
                   .setMessage(
-                      HtmlCompat.fromHtml(
-                          resources.getString(R.string.leak_canary_about_message),
-                          HtmlCompat.FROM_HTML_MODE_LEGACY
-                      )
+                      Html.fromHtml(resources.getString(R.string.leak_canary_about_message))
                   )
                   .setPositiveButton(android.R.string.ok, null)
                   .show()
@@ -64,6 +65,15 @@ internal class GroupListScreen : Screen() {
 
     }
 
+  private fun Context.getDrawableCompat(id: Int): Drawable {
+    if (SDK_INT >= 21) {
+      return getDrawable(id)!!
+    } else  {
+      @Suppress("DEPRECATION")
+      return resources.getDrawable(id)
+    }
+  }
+
   private fun View.onGroupsRetrieved(projections: List<GroupProjection>) {
     activity.title =
       resources.getString(R.string.leak_canary_group_list_screen_title, projections.size)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
index 7c2d567a..08d7c0d5 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
@@ -5,7 +5,6 @@ import android.view.ViewGroup
 import android.widget.ListView
 import com.squareup.leakcanary.core.R
 import com.squareup.leakcanary.core.R.plurals
-import leakcanary.LeakTrace
 import leakcanary.internal.DisplayLeakAdapter
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
@@ -14,6 +13,7 @@ import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goTo
 import leakcanary.internal.navigation.inflate
+import shark.LeakTrace
 
 internal class GroupScreen(private val groupHash: String) : Screen() {
   override fun createView(container: ViewGroup) =
@@ -46,7 +46,7 @@ internal class GroupScreen(private val groupHash: String) : Screen() {
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val adapter = DisplayLeakAdapter(context, leakTrace, projections)
+    val adapter = DisplayLeakAdapter(context, leakTrace, groupDescription, projections)
     listView.adapter = adapter
 
     listView.setOnItemClickListener { _, _, position, _ ->
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
index e058a835..211e95e6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
@@ -5,7 +5,6 @@ import android.view.ViewGroup
 import android.widget.TextView
 import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
-import leakcanary.HeapAnalysisFailure
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.share
@@ -15,6 +14,7 @@ import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goBack
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.HeapAnalysisFailure
 
 internal class HeapAnalysisFailureScreen(
   private val analysisId: Long
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
index 6eb7ab03..7225747a 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisListScreen.kt
@@ -84,7 +84,7 @@ internal class HeapAnalysisListScreen : Screen() {
         )
 
         val title = projection.exceptionSummary ?: resources.getQuantityString(
-            R.plurals.leak_canary_heap_analysis_list_retained_instances,
+            R.plurals.leak_canary_heap_analysis_list_retained_objects,
             projection.retainedInstanceCount, projection.retainedInstanceCount
         )
         titleView.text = "$index. $title"
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
index b1aa79a0..546a1d63 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -6,11 +6,6 @@ import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
 import com.squareup.leakcanary.core.R
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.Exclusion.Status.WONT_FIX_LEAK
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.LeakingInstance
-import leakcanary.NoPathToInstance
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.LeakingInstanceTable.HeapAnalysisGroupProjection
@@ -23,6 +18,7 @@ import leakcanary.internal.navigation.goBack
 import leakcanary.internal.navigation.goTo
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.HeapAnalysisSuccess
 
 internal class HeapAnalysisSuccessScreen(
   private val analysisId: Long
@@ -54,7 +50,7 @@ internal class HeapAnalysisSuccessScreen(
   ) {
     activity.title = resources.getString(
         R.string.leak_canary_heap_analysis_success_screen_title,
-        heapAnalysis.retainedInstances.size
+        heapAnalysis.allLeaks.size
     )
 
     onCreateOptionsMenu { menu ->
@@ -79,26 +75,23 @@ internal class HeapAnalysisSuccessScreen(
               goTo(RenderHeapDumpScreen(heapAnalysis.heapDumpFile))
               true
             }
+        menu.add(R.string.leak_canary_options_menu_explore_heap_dump)
+            .setOnMenuItemClickListener {
+              goTo(HprofExplorerScreen(heapAnalysis.heapDumpFile))
+              true
+            }
       }
     }
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val retainedInstances = heapAnalysis.retainedInstances
+    val retainedInstances = heapAnalysis.allLeaks
 
-    var noPathToInstanceCount = 0
     retainedInstances.forEach { retainedInstance ->
-      when (retainedInstance) {
-        is LeakingInstance -> {
-          if (leakGroupByHash[retainedInstance.groupHash] == null) {
-            throw IllegalStateException(
-                "Removing groups is not supported, this should never happen."
-            )
-          }
-        }
-        is NoPathToInstance -> {
-          noPathToInstanceCount++
-        }
+      if (leakGroupByHash[retainedInstance.groupHash] == null) {
+        throw IllegalStateException(
+            "Removing groups is not supported, this should never happen."
+        )
       }
     }
 
@@ -107,19 +100,9 @@ internal class HeapAnalysisSuccessScreen(
     val leakGroups = leakGroupByHash.values.toList()
 
     rowList.addAll(leakGroups.map { projection ->
-      val description = when (projection.exclusionStatus) {
-        WONT_FIX_LEAK -> {
-          "[Won't Fix] ${projection.description}"
-        }
-        WEAKLY_REACHABLE -> {
-          "[Weakly Reachable] ${projection.description}"
-        }
-        else -> {
-          projection.description
-        }
-      }
+      val description = projection.description
 
-      val titleText = if (projection.isNew && projection.exclusionStatus == null) {
+      val titleText = if (projection.isNew && !projection.isLibraryLeak) {
         resources.getString(
             R.string.leak_canary_heap_analysis_success_screen_row_title_new, projection.leakCount,
             description
@@ -140,15 +123,6 @@ internal class HeapAnalysisSuccessScreen(
       titleText to timeText
     })
 
-    if (noPathToInstanceCount > 0) {
-      rowList.add(
-          resources.getString(
-              R.string.leak_canary_heap_analysis_success_screen_no_path_to_instance_count,
-              noPathToInstanceCount
-          ) to ""
-      )
-    }
-
     listView.adapter =
       SimpleListAdapter(R.layout.leak_canary_leak_row, rowList) { view, position ->
         val titleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index d310f95d..daa827f4 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -10,32 +10,31 @@ import android.graphics.Paint
 import android.graphics.Paint.Style.FILL
 import android.graphics.Paint.Style.STROKE
 import android.graphics.Rect
-import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
-import leakcanary.HprofPushRecordsParser
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.Record
-import leakcanary.Record.HeapDumpEndRecord
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StackTraceRecord
-import leakcanary.Record.StringRecord
+import leakcanary.internal.navigation.getColorCompat
+import shark.Hprof
+import shark.HprofRecord
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.OnHprofRecordListener
 import java.io.File
-import kotlin.reflect.KClass
 
-object HeapDumpRenderer {
+internal object HeapDumpRenderer {
 
   private class HasDensity(resources: Resources) {
     val density = resources.displayMetrics.density
@@ -47,6 +46,7 @@ object HeapDumpRenderer {
       get() = this * density
   }
 
+  @Suppress("LongMethod")
   fun render(
     context: Context,
     heapDumpFile: File,
@@ -58,23 +58,23 @@ object HeapDumpRenderer {
     sourceBytesPerPixel: Int
   ): Bitmap = with(HasDensity(context.resources)) {
     val recordPositions = mutableListOf<Pair<Int, Long>>()
-    var currentRecord: Record? = null
+    var currentRecord: HprofRecord? = null
 
-    val otherColor = ContextCompat.getColor(context, R.color.leak_canary_heap_other)
-    val stackTraceColor = ContextCompat.getColor(context, R.color.leak_canary_heap_stack_trace)
-    val hprofStringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_hprof_string)
-    val loadClassColor = ContextCompat.getColor(context, R.color.leak_canary_heap_load_class)
-    val classDumpColor = ContextCompat.getColor(context, R.color.leak_canary_heap_class_dump)
-    val instanceColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance)
-    val objectArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_object_array)
-    val booleanArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_boolean_array)
-    val charArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_char_array)
-    val floatArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_float_array)
-    val doubleArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_double_array)
-    val byteArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_byte_array)
-    val shortArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_short_array)
-    val intArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_int_array)
-    val longArrayColor = ContextCompat.getColor(context, R.color.leak_canary_heap_long_array)
+    val otherColor = context.getColorCompat(R.color.leak_canary_heap_other)
+    val stackTraceColor = context.getColorCompat(R.color.leak_canary_heap_stack_trace)
+    val hprofStringColor = context.getColorCompat(R.color.leak_canary_heap_hprof_string)
+    val loadClassColor = context.getColorCompat(R.color.leak_canary_heap_load_class)
+    val classDumpColor = context.getColorCompat(R.color.leak_canary_heap_class_dump)
+    val instanceColor = context.getColorCompat(R.color.leak_canary_heap_instance)
+    val objectArrayColor = context.getColorCompat(R.color.leak_canary_heap_object_array)
+    val booleanArrayColor = context.getColorCompat(R.color.leak_canary_heap_boolean_array)
+    val charArrayColor = context.getColorCompat(R.color.leak_canary_heap_char_array)
+    val floatArrayColor = context.getColorCompat(R.color.leak_canary_heap_float_array)
+    val doubleArrayColor = context.getColorCompat(R.color.leak_canary_heap_double_array)
+    val byteArrayColor = context.getColorCompat(R.color.leak_canary_heap_byte_array)
+    val shortArrayColor = context.getColorCompat(R.color.leak_canary_heap_short_array)
+    val intArrayColor = context.getColorCompat(R.color.leak_canary_heap_int_array)
+    val longArrayColor = context.getColorCompat(R.color.leak_canary_heap_long_array)
     val colors = mapOf(
         StringRecord::class to hprofStringColor,
         LoadClassRecord::class to loadClassColor,
@@ -94,194 +94,188 @@ object HeapDumpRenderer {
         GcRootRecord::class to otherColor
     )
 
-    val appHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_app)
-    val imageHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_image)
-    val zygoteHeapColor = ContextCompat.getColor(context, R.color.leak_canary_heap_zygote)
-    val stringColor = ContextCompat.getColor(context, R.color.leak_canary_heap_instance_string)
+    val appHeapColor = context.getColorCompat(R.color.leak_canary_heap_app)
+    val imageHeapColor = context.getColorCompat(R.color.leak_canary_heap_image)
+    val zygoteHeapColor = context.getColorCompat(R.color.leak_canary_heap_zygote)
+    val stringColor = context.getColorCompat(R.color.leak_canary_heap_instance_string)
 
-    val parser = HprofPushRecordsParser()
-    val reader = parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
-      override fun recordTypes(): Set<KClass<out Record>> = setOf(Record::class)
+    var lastPosition = 0L
 
-      val hprofStringCache = mutableMapOf<Long, String>()
-      val classNames = mutableMapOf<Long, Long>()
-
-      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
-      }
-
-      override fun onRecord(
-        position: Long,
-        record: Record
-      ) {
-        when (record) {
-          is StringRecord -> {
-            hprofStringCache[record.id] = record.string
-          }
-          is LoadClassRecord -> {
-            classNames[record.id] = record.classNameStringId
-          }
-        }
-        val localCurrentRecord = currentRecord
-        when {
-          localCurrentRecord is HeapDumpInfoRecord -> {
-            val colorForHeapInfo =
-              when (hprofStringCache[localCurrentRecord.heapNameStringId]) {
-                // The primary heap on which your app allocates memory.
-                "app" -> appHeapColor
-                // The system boot image, containing classes that are preloaded during boot time.
-                // Allocations here are guaranteed to never move or go away.
-                "image" -> imageHeapColor
-                // The copy-on-write heap where an app process is forked from in the Android system.
-                "zygote" -> zygoteHeapColor
-                // JNI heap: The heap that shows where Java Native Interface (JNI) references are allocated and released.
-                // default heap: When no heap is specified by the system
-                else -> otherColor
+    Hprof.open(heapDumpFile)
+        .use { hprof ->
+          val hprofStringCache = mutableMapOf<Long, String>()
+          val classNames = mutableMapOf<Long, Long>()
+          hprof.reader.readHprofRecords(
+              setOf(HprofRecord::class), OnHprofRecordListener { position, record ->
+            lastPosition = position
+            when (record) {
+              is StringRecord -> {
+                hprofStringCache[record.id] = record.string
               }
-            recordPositions.add(colorForHeapInfo to position)
-            currentRecord = record
-          }
-          localCurrentRecord is InstanceDumpRecord
-              && hprofStringCache[classNames[localCurrentRecord.classId]] == "java.lang.String"
-              && (record !is InstanceDumpRecord || hprofStringCache[classNames[record.classId]]
-              != "java.lang.String")
-          -> {
-            recordPositions.add(stringColor to position)
-            currentRecord = record
-          }
-          currentRecord == null -> {
-            recordPositions.add(otherColor to position)
-            currentRecord = record
-          }
-          currentRecord!!::class != record::class -> {
-            recordPositions.add(colors.getValue(currentRecord!!::class) to position)
-            currentRecord = record
-          }
-        }
-      }
-    }))
-    val heapLength = reader.position
-    reader.close()
+              is LoadClassRecord -> {
+                classNames[record.id] = record.classNameStringId
+              }
+            }
+            val localCurrentRecord = currentRecord
+            when {
+              localCurrentRecord is HeapDumpInfoRecord -> {
+                val colorForHeapInfo =
+                  when (hprofStringCache[localCurrentRecord.heapNameStringId]) {
+                    // The primary heap on which your app allocates memory.
+                    "app" -> appHeapColor
+                    // The system boot image, containing classes that are preloaded during boot time.
+                    // Allocations here are guaranteed to never move or go away.
+                    "image" -> imageHeapColor
+                    // The copy-on-write heap where an app process is forked from in the Android system.
+                    "zygote" -> zygoteHeapColor
+                    // JNI heap: The heap that shows where Java Native Interface (JNI) references are allocated and released.
+                    // default heap: When no heap is specified by the system
+                    else -> otherColor
+                  }
+                recordPositions.add(colorForHeapInfo to position)
+                currentRecord = record
+              }
+              localCurrentRecord is InstanceDumpRecord
+                  && hprofStringCache[classNames[localCurrentRecord.classId]] == "java.lang.String"
+                  && (record !is InstanceDumpRecord || hprofStringCache[classNames[record.classId]]
+                  != "java.lang.String")
+              -> {
+                recordPositions.add(stringColor to position)
+                currentRecord = record
+              }
+              currentRecord == null -> {
+                recordPositions.add(otherColor to position)
+                currentRecord = record
+              }
+              currentRecord!!::class != record::class -> {
+                recordPositions.add(colors.getValue(currentRecord!!::class) to position)
+                currentRecord = record
+              }
+            }
+          })
+          val heapLength = lastPosition
 
-    val width = sourceWidth
-    var height: Int
-    val bytesPerPixel: Double
+          val width = sourceWidth
+          var height: Int
+          val bytesPerPixel: Double
 
-    if (sourceBytesPerPixel > 0) {
-      bytesPerPixel = sourceBytesPerPixel.toDouble()
-      height = Math.ceil((heapLength / bytesPerPixel) / width)
-          .toInt()
-    } else {
-      height = sourceHeight
-      bytesPerPixel = heapLength * 1.0 / (width * height)
-    }
+          if (sourceBytesPerPixel > 0) {
+            bytesPerPixel = sourceBytesPerPixel.toDouble()
+            height = Math.ceil((heapLength / bytesPerPixel) / width)
+                .toInt()
+          } else {
+            height = sourceHeight
+            bytesPerPixel = heapLength * 1.0 / (width * height)
+          }
 
-    val bitmap: Bitmap =
-      Bitmap.createBitmap(width, height, ARGB_8888)
+          val bitmap: Bitmap =
+            Bitmap.createBitmap(width, height, ARGB_8888)
 
-    val canvas = Canvas(bitmap)
+          val canvas = Canvas(bitmap)
 
-    val legend = mapOf(
-        "Hprof string" to hprofStringColor,
-        "Class name" to loadClassColor,
-        "App heap" to appHeapColor,
-        "Image heap" to imageHeapColor,
-        "Zygote heap" to zygoteHeapColor,
-        "Other heap" to otherColor,
-        "Class content" to classDumpColor,
-        "Instance" to instanceColor,
-        "String" to stringColor,
-        "Object array" to objectArrayColor,
-        "Boolean array" to booleanArrayColor,
-        "Char array" to charArrayColor,
-        "Float array" to floatArrayColor,
-        "Double array" to doubleArrayColor,
-        "Byte array" to byteArrayColor,
-        "Short array" to shortArrayColor,
-        "Int array" to intArrayColor,
-        "Long array" to longArrayColor,
-        "Stack trace" to stackTraceColor,
-        "Heap End" to otherColor
-    )
+          val legend = mapOf(
+              "Hprof string" to hprofStringColor,
+              "Class name" to loadClassColor,
+              "App heap" to appHeapColor,
+              "Image heap" to imageHeapColor,
+              "Zygote heap" to zygoteHeapColor,
+              "Other heap" to otherColor,
+              "Class content" to classDumpColor,
+              "Instance" to instanceColor,
+              "String" to stringColor,
+              "Object array" to objectArrayColor,
+              "Boolean array" to booleanArrayColor,
+              "Char array" to charArrayColor,
+              "Float array" to floatArrayColor,
+              "Double array" to doubleArrayColor,
+              "Byte array" to byteArrayColor,
+              "Short array" to shortArrayColor,
+              "Int array" to intArrayColor,
+              "Long array" to longArrayColor,
+              "Stack trace" to stackTraceColor,
+              "Heap End" to otherColor
+          )
 
-    val legendTextPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+          val legendTextPaint = Paint(Paint.ANTI_ALIAS_FLAG)
 
-    legendTextPaint.color = Color.WHITE
-    legendTextPaint.style = FILL
-    canvas.drawPaint(legendTextPaint)
+          legendTextPaint.color = Color.WHITE
+          legendTextPaint.style = FILL
+          canvas.drawPaint(legendTextPaint)
 
-    val legendSquareFillPaint = Paint()
-    legendSquareFillPaint.style = FILL
-    val legendSquareStrokePaint = Paint()
-    legendSquareStrokePaint.style = STROKE
-    legendSquareStrokePaint.strokeWidth = 0.8f.dp
-    legendSquareStrokePaint.color = Color.BLACK
+          val legendSquareFillPaint = Paint()
+          legendSquareFillPaint.style = FILL
+          val legendSquareStrokePaint = Paint()
+          legendSquareStrokePaint.style = STROKE
+          legendSquareStrokePaint.strokeWidth = 0.8f.dp
+          legendSquareStrokePaint.color = Color.BLACK
 
-    legendTextPaint.color = Color.BLACK
-    legendTextPaint.textSize = 16.dp
+          legendTextPaint.color = Color.BLACK
+          legendTextPaint.textSize = 16.dp
 
-    val metrics = legendTextPaint.fontMetrics
-    val textHeight = metrics.descent - metrics.ascent
+          val metrics = legendTextPaint.fontMetrics
+          val textHeight = metrics.descent - metrics.ascent
 
-    val xBounds = Rect()
-    legendTextPaint.getTextBounds("x", 0, 1, xBounds)
-    val squareSize = xBounds.height()
-    val squarePaddingTop = (textHeight - squareSize) / 2
-    val squareToTextPadding = 4.dp
-    val blockToBlockPadding = 8.dp
+          val xBounds = Rect()
+          legendTextPaint.getTextBounds("x", 0, 1, xBounds)
+          val squareSize = xBounds.height()
+          val squarePaddingTop = (textHeight - squareSize) / 2
+          val squareToTextPadding = 4.dp
+          val blockToBlockPadding = 8.dp
 
-    var maxTextWidth = 0f
-    for (name in legend.keys) {
-      maxTextWidth = Math.max(maxTextWidth, legendTextPaint.measureText(name))
-    }
+          var maxTextWidth = 0f
+          for (name in legend.keys) {
+            maxTextWidth = Math.max(maxTextWidth, legendTextPaint.measureText(name))
+          }
 
-    val padding = 8.dp
-    var blockLeft = padding
-    var blockTop = padding
-    val legendWidth = width - 2 * padding
-    for ((name, color) in legend) {
-      if (blockLeft + squareSize + squareToTextPadding + maxTextWidth > legendWidth) {
-        blockLeft = padding
-        blockTop += textHeight
-      }
+          val padding = 8.dp
+          var blockLeft = padding
+          var blockTop = padding
+          val legendWidth = width - 2 * padding
+          for ((name, color) in legend) {
+            if (blockLeft + squareSize + squareToTextPadding + maxTextWidth > legendWidth) {
+              blockLeft = padding
+              blockTop += textHeight
+            }
 
-      legendSquareFillPaint.color = color
-      canvas.drawRect(
-          blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
-          blockTop + squarePaddingTop + squareSize,
-          legendSquareFillPaint
-      )
-      canvas.drawRect(
-          blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
-          blockTop + squarePaddingTop + squareSize,
-          legendSquareStrokePaint
-      )
-      blockLeft += squareSize + squareToTextPadding
-      canvas.drawText(name, blockLeft, blockTop - metrics.ascent, legendTextPaint)
-      blockLeft += maxTextWidth
-      blockLeft += blockToBlockPadding
-    }
-    val legendHeight = blockTop + textHeight + padding
-    val source = Rect(0, 0, width, legendHeight.toInt())
-    val destination = Rect(0, (height - legendHeight).toInt(), width, height)
-    canvas.drawBitmap(bitmap, source, destination, null)
-    height -= legendHeight.toInt()
+            legendSquareFillPaint.color = color
+            canvas.drawRect(
+                blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+                blockTop + squarePaddingTop + squareSize,
+                legendSquareFillPaint
+            )
+            canvas.drawRect(
+                blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+                blockTop + squarePaddingTop + squareSize,
+                legendSquareStrokePaint
+            )
+            blockLeft += squareSize + squareToTextPadding
+            canvas.drawText(name, blockLeft, blockTop - metrics.ascent, legendTextPaint)
+            blockLeft += maxTextWidth
+            blockLeft += blockToBlockPadding
+          }
+          val legendHeight = blockTop + textHeight + padding
+          val source = Rect(0, 0, width, legendHeight.toInt())
+          val destination = Rect(0, (height - legendHeight).toInt(), width, height)
+          canvas.drawBitmap(bitmap, source, destination, null)
+          height -= legendHeight.toInt()
 
-    val pixelPaint = Paint()
-    pixelPaint.style = FILL
+          val pixelPaint = Paint()
+          pixelPaint.style = FILL
 
-    var recordIndex = 0
-    for (y in 0 until height) {
-      for (x in 0 until width) {
-        val bitmapPosition = y * width + x
-        val heapPosition = (bitmapPosition * bytesPerPixel).toInt()
-        while (heapPosition > recordPositions[recordIndex].second && recordIndex < recordPositions.lastIndex) {
-          recordIndex++
+          var recordIndex = 0
+          for (y in 0 until height) {
+            for (x in 0 until width) {
+              val bitmapPosition = y * width + x
+              val heapPosition = (bitmapPosition * bytesPerPixel).toInt()
+              while (heapPosition > recordPositions[recordIndex].second && recordIndex < recordPositions.lastIndex) {
+                recordIndex++
+              }
+              pixelPaint.color = recordPositions[recordIndex].first
+              canvas.drawPoint(x.toFloat(), y.toFloat(), pixelPaint)
+            }
+          }
+          return bitmap
         }
-        pixelPaint.color = recordPositions[recordIndex].first
-        canvas.drawPoint(x.toFloat(), y.toFloat(), pixelPaint)
-      }
-    }
-    return bitmap
-  }
 
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
new file mode 100644
index 00000000..46f8dd18
--- /dev/null
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -0,0 +1,314 @@
+package leakcanary.internal.activity.screen
+
+import android.app.AlertDialog
+import android.view.View
+import android.view.View.OnAttachStateChangeListener
+import android.view.View.VISIBLE
+import android.view.ViewGroup
+import android.widget.EditText
+import android.widget.ListView
+import android.widget.TextView
+import android.widget.Toast
+import com.squareup.leakcanary.core.R
+import leakcanary.internal.activity.db.Io
+import leakcanary.internal.activity.db.executeOnIo
+import leakcanary.internal.activity.ui.SimpleListAdapter
+import leakcanary.internal.navigation.Screen
+import leakcanary.internal.navigation.activity
+import leakcanary.internal.navigation.inflate
+import shark.HeapField
+import shark.HprofHeapGraph
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HeapValue
+import shark.Hprof
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.io.Closeable
+import java.io.File
+
+internal class HprofExplorerScreen(
+  private val heapDumpFile: File
+) : Screen() {
+  override fun createView(container: ViewGroup) =
+    container.inflate(R.layout.leak_canary_hprof_explorer).apply {
+      container.activity.title = resources.getString(R.string.leak_canary_loading_title)
+
+      lateinit var closeable: Closeable
+
+      addOnAttachStateChangeListener(object : OnAttachStateChangeListener {
+        override fun onViewAttachedToWindow(view: View) {
+        }
+
+        override fun onViewDetachedFromWindow(view: View) {
+          Io.execute {
+            closeable.close()
+          }
+        }
+      })
+
+      executeOnIo {
+        val hprof = Hprof.open(heapDumpFile)
+        closeable = hprof
+        val graph = HprofHeapGraph.indexHprof(hprof)
+        updateUi {
+          container.activity.title =
+            resources.getString(R.string.leak_canary_options_menu_explore_heap_dump)
+          val titleView = findViewById<TextView>(R.id.leak_canary_explorer_title)
+          val searchView = findViewById<View>(R.id.leak_canary_search_button)
+          val listView = findViewById<ListView>(R.id.leak_canary_explorer_list)
+          titleView.visibility = VISIBLE
+          searchView.visibility = VISIBLE
+          listView.visibility = VISIBLE
+          searchView.setOnClickListener {
+            val input = EditText(context)
+            AlertDialog.Builder(context)
+                .setIcon(android.R.drawable.ic_dialog_alert)
+                .setTitle("Type a fully qualified class name")
+                .setView(input)
+                .setPositiveButton(android.R.string.ok) { _, _ ->
+                  executeOnIo {
+                    val partialClassName = input.text.toString()
+                    val matchingClasses = graph.classes
+                        .filter { partialClassName in it.name }
+                        .toList()
+
+                    if (matchingClasses.isEmpty()) {
+                      updateUi {
+                        Toast.makeText(
+                            context, "No class matching [$partialClassName]", Toast.LENGTH_LONG
+                        )
+                            .show()
+                      }
+                    } else {
+                      updateUi {
+                        titleView.text =
+                          "${matchingClasses.size} classes matching [$partialClassName]"
+                        listView.adapter = SimpleListAdapter(
+                            R.layout.leak_canary_leak_row, matchingClasses
+                        ) { view, position ->
+                          val itemTitleView = view.findViewById<TextView>(R.id.leak_canary_row_text)
+                          itemTitleView.text = matchingClasses[position].name
+                        }
+                        listView.setOnItemClickListener { _, _, position, _ ->
+                          val selectedClass = matchingClasses[position]
+                          showClass(titleView, listView, selectedClass)
+                        }
+                      }
+                    }
+                  }
+                }
+                .setNegativeButton(android.R.string.cancel, null)
+                .show()
+          }
+        }
+      }
+    }
+
+  private fun View.showClass(
+    titleView: TextView,
+    listView: ListView,
+    selectedClass: HeapClass
+  ) {
+    executeOnIo {
+      val className = selectedClass.name
+      val instances = selectedClass.directInstances.toList()
+      val staticFields = selectedClass.readStaticFields()
+          .fieldsAsString()
+      updateUi {
+        titleView.text =
+          "Class $className (${instances.size} instances)"
+        listView.adapter = SimpleListAdapter(
+            R.layout.leak_canary_leak_row, staticFields + instances
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          if (position < staticFields.size) {
+            itemTitleView.text = staticFields[position].second
+          } else {
+            itemTitleView.text = "@${instances[position - staticFields.size].objectId}"
+          }
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          if (position < staticFields.size) {
+            val staticField = staticFields[position].first
+            onHeapValueClicked(titleView, listView, staticField.value)
+          } else {
+            val instance = instances[position - staticFields.size]
+            showInstance(titleView, listView, instance)
+          }
+        }
+      }
+    }
+  }
+
+  private fun View.showInstance(
+    titleView: TextView,
+    listView: ListView,
+    instance: HeapInstance
+  ) {
+    executeOnIo {
+      val fields = instance.readFields()
+          .fieldsAsString()
+      val className = instance.instanceClassName
+      updateUi {
+        titleView.text = "Instance @${instance.objectId} of class $className"
+        listView.adapter = SimpleListAdapter(
+            R.layout.leak_canary_leak_row, fields
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = fields[position].second
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          val field = fields[position].first
+          onHeapValueClicked(titleView, listView, field.value)
+        }
+      }
+    }
+  }
+
+  private fun View.showObjectArray(
+    titleView: TextView,
+    listView: ListView,
+    instance: HeapObjectArray
+  ) {
+    executeOnIo {
+      val elements = instance.readElements()
+          .mapIndexed { index: Int, element: HeapValue ->
+            element to "[$index] = ${element.heapValueAsString()}"
+          }
+          .toList()
+      val arrayClassName = instance.arrayClassName
+      val className = arrayClassName.substring(0, arrayClassName.length - 2)
+      updateUi {
+        titleView.text = "Array $className[${elements.size}]"
+        listView.adapter = SimpleListAdapter(
+            R.layout.leak_canary_leak_row, elements
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = elements[position].second
+        }
+        listView.setOnItemClickListener { _, _, position, _ ->
+          val element = elements[position].first
+          onHeapValueClicked(titleView, listView, element)
+        }
+      }
+    }
+  }
+
+  private fun View.showPrimitiveArray(
+    titleView: TextView,
+    listView: ListView,
+    instance: HeapPrimitiveArray
+  ) {
+    executeOnIo {
+      val (type, values) = when (val record = instance.readRecord()) {
+        is BooleanArrayDump -> "boolean" to record.array.map { it.toString() }
+        is CharArrayDump -> "char" to record.array.map { "'$it'" }
+        is FloatArrayDump -> "float" to record.array.map { it.toString() }
+        is DoubleArrayDump -> "double" to record.array.map { it.toString() }
+        is ByteArrayDump -> "byte" to record.array.map { it.toString() }
+        is ShortArrayDump -> "short" to record.array.map { it.toString() }
+        is IntArrayDump -> "int" to record.array.map { it.toString() }
+        is LongArrayDump -> "long" to record.array.map { it.toString() }
+      }
+      updateUi {
+        titleView.text = "Array $type[${values.size}]"
+        listView.adapter = SimpleListAdapter(
+            R.layout.leak_canary_leak_row, values
+        ) { view, position ->
+          val itemTitleView =
+            view.findViewById<TextView>(R.id.leak_canary_row_text)
+          itemTitleView.text = "$type ${values[position]}"
+        }
+        listView.setOnItemClickListener { _, _, _, _ ->
+        }
+      }
+    }
+  }
+
+  private fun View.onHeapValueClicked(
+    titleView: TextView,
+    listView: ListView,
+    heapValue: HeapValue
+  ) {
+    if (heapValue.isNonNullReference) {
+      when (val objectRecord = heapValue.asObject!!) {
+        is HeapInstance -> {
+          showInstance(titleView, listView, objectRecord)
+        }
+        is HeapClass -> {
+          showClass(titleView, listView, objectRecord)
+        }
+        is HeapObjectArray -> {
+          showObjectArray(titleView, listView, objectRecord)
+        }
+        is HeapPrimitiveArray -> {
+          showPrimitiveArray(titleView, listView, objectRecord)
+        }
+      }
+    }
+  }
+
+  private fun Sequence<HeapField>.fieldsAsString(): List<Pair<HeapField, String>> {
+    return map { field ->
+      field to "${field.declaringClass.simpleName}.${field.name} = ${field.value.heapValueAsString()}"
+    }
+        .toList()
+  }
+
+  private fun HeapValue.heapValueAsString(): String {
+    return when (val heapValue = holder) {
+      is ReferenceHolder -> {
+        if (isNullReference) {
+          "null"
+        } else {
+          when (val objectRecord = asObject!!) {
+            is HeapInstance -> {
+              if (objectRecord instanceOf "java.lang.String") {
+                "${objectRecord.instanceClassName}@${heapValue.value} \"${objectRecord.readAsJavaString()!!}\""
+              } else {
+                "${objectRecord.instanceClassName}@${heapValue.value}"
+              }
+            }
+            is HeapClass -> {
+              "Class ${objectRecord.name}"
+            }
+            is HeapObjectArray -> {
+              objectRecord.arrayClassName
+            }
+            is HeapPrimitiveArray -> objectRecord.arrayClassName
+          }
+        }
+      }
+      is BooleanHolder -> "boolean ${heapValue.value}"
+      is CharHolder -> "char ${heapValue.value}"
+      is FloatHolder -> "float ${heapValue.value}"
+      is DoubleHolder -> "double ${heapValue.value}"
+      is ByteHolder -> "byte ${heapValue.value}"
+      is ShortHolder -> "short ${heapValue.value}"
+      is IntHolder -> "int ${heapValue.value}"
+      is LongHolder -> "long ${heapValue.value}"
+    }
+
+  }
+}
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
index fd83040f..3a1bacac 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -6,7 +6,6 @@ import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import com.squareup.leakcanary.core.R
-import leakcanary.LeakingInstance
 import leakcanary.internal.DisplayLeakAdapter
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.executeOnDb
@@ -19,6 +18,8 @@ import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goTo
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.Leak
+import shark.LibraryLeak
 import java.io.Serializable
 
 internal class LeakingInstanceScreen private constructor(
@@ -30,7 +31,7 @@ internal class LeakingInstanceScreen private constructor(
   sealed class InstanceOrId : Serializable {
     class Instance(
       val heapAnalysisId: Long,
-      val instance: LeakingInstance
+      val instance: Leak
     ) : InstanceOrId()
 
     class Id(val id: Long) : InstanceOrId()
@@ -62,24 +63,22 @@ internal class LeakingInstanceScreen private constructor(
 
   private fun View.onInstanceRetrieved(
     heapAnalysisId: Long,
-    leakingInstance: LeakingInstance
+    leak: Leak
   ) {
-    val classSimpleName = leakingInstance.instanceClassSimpleName
+    val classSimpleName = leak.classSimpleName
     activity.title =
       resources.getString(R.string.leak_canary_class_has_leaked, classSimpleName)
 
     val listView = findViewById<ListView>(R.id.leak_canary_list)
 
-    val adapter =
-      DisplayLeakAdapter(context, leakingInstance.leakTrace, leakingInstance.referenceName)
+    val groupDescription = if (leak is LibraryLeak) "Library Leak: " +leak.pattern.toString() else ""
+    val adapter = DisplayLeakAdapter(context, leak.leakTrace, groupDescription)
     listView.adapter = adapter
 
     listView.setOnItemClickListener { _, _, position, _ ->
       if (adapter.isLearnMoreRow(position)) {
         val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(LEARN_MORE_URL))
         activity.startActivity(browserIntent)
-      } else {
-        adapter.toggleRow(position)
       }
     }
 
@@ -92,13 +91,13 @@ internal class LeakingInstanceScreen private constructor(
       menu.add(R.string.leak_canary_share_leak)
           .setOnMenuItemClickListener {
             // TODO Add version information
-            share(leakingInstance.toString())
+            share(leak.toString())
             true
           }
       menu.add(R.string.leak_canary_stackoverflow_share)
           .setOnMenuItemClickListener {
             // TODO Add version information
-            shareToStackOverflow(leakingInstance.toString())
+            shareToStackOverflow(leak.toString())
             true
           }
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
index 7311da16..e660fb16 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -11,15 +11,15 @@ import android.view.ViewGroup
 import android.view.ViewTreeObserver.OnGlobalLayoutListener
 import android.widget.ImageView
 import android.widget.Toast
-import androidx.core.content.FileProvider
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.internal.InternalLeakCanary
+import leakcanary.internal.LeakCanaryFileProvider
 import leakcanary.internal.activity.db.executeOnIo
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.SharkLog
 import java.io.File
 import java.io.FileOutputStream
 import java.io.IOException
@@ -85,15 +85,15 @@ internal class RenderHeapDumpScreen(
                     .show()
                 executeOnIo {
                   val bitmap = HeapDumpRenderer.render(context, heapDumpFile, 2048, 0, 4)
-                  val storageDir =
+                  @Suppress("DEPRECATION") val storageDir =
                     Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS)
 
                   val imageFile = File(storageDir, "${heapDumpFile.name}.png")
                   val saved = savePng(imageFile, bitmap)
                   if (saved) {
-                    CanaryLog.d("Png saved at $imageFile")
+                    SharkLog.d { "Png saved at $imageFile" }
                     imageFile.setReadable(true, false)
-                    val imageUri = FileProvider.getUriForFile(
+                    val imageUri = LeakCanaryFileProvider.getUriForFile(
                         activity,
                         "com.squareup.leakcanary.fileprovider." + activity.packageName,
                         imageFile
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
index 29264091..43ce0128 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/ui/SimpleListAdapter.kt
@@ -3,11 +3,9 @@ package leakcanary.internal.activity.ui
 import android.view.View
 import android.view.ViewGroup
 import android.widget.BaseAdapter
-import androidx.annotation.LayoutRes
 import leakcanary.internal.navigation.inflate
 
-class SimpleListAdapter<T>(
-  @LayoutRes
+internal class SimpleListAdapter<T>(
   private val rowResId: Int,
   private val items: List<T>,
   private val bindView: SimpleListAdapter<T>.(View, Int) -> Unit
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
index f53117e1..a45ee811 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/NavigatingActivity.kt
@@ -123,7 +123,9 @@ internal abstract class NavigatingActivity : Activity() {
     val actionBar = actionBar
         ?: // https://github.com/square/leakcanary/issues/967
         return
-    actionBar.setDisplayHomeAsUpEnabled(backstack.size > 0)
+    val homeEnabled = backstack.size > 0
+    actionBar.setDisplayHomeAsUpEnabled(homeEnabled)
+    actionBar.setHomeButtonEnabled(homeEnabled)
   }
 
   override fun onCreateOptionsMenu(menu: Menu): Boolean {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
index 13603e4e..89d3c5ec 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/Views.kt
@@ -1,13 +1,14 @@
 package leakcanary.internal.navigation
 
 import android.app.Activity
+import android.content.Context
+import android.os.Build.VERSION
 import android.view.LayoutInflater
 import android.view.Menu
 import android.view.View
 import android.view.ViewGroup
-import androidx.annotation.LayoutRes
 
-internal fun ViewGroup.inflate(@LayoutRes layoutResId: Int) = LayoutInflater.from(context)
+internal fun ViewGroup.inflate(layoutResId: Int) = LayoutInflater.from(context)
     .inflate(layoutResId, this, false)!!
 
 internal val View.activity
@@ -27,4 +28,12 @@ internal fun View.goTo(screen: Screen) {
 
 internal fun View.goBack() {
   activity<NavigatingActivity>().goBack()
+}
+
+internal fun Context.getColorCompat(id: Int): Int {
+  return if (VERSION.SDK_INT >= 23) {
+    getColor(id)
+  } else {
+    resources.getColor(id)
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
index 6a3164d3..15dfaecb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/utils/Tuples.kt
@@ -1,3 +1,3 @@
 package leakcanary.internal.utils
 
-infix fun <A, B, C> Pair<A, B>.to(that: C): Triple<A, B, C> = Triple(first, second, that)
+internal infix fun <A, B, C> Pair<A, B>.to(that: C): Triple<A, B, C> = Triple(first, second, that)
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml
new file mode 100644
index 00000000..3f98e4f2
--- /dev/null
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_hprof_explorer.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/leak_canary_background_color"
+    android:orientation="vertical"
+    >
+  <Button
+      android:id="@+id/leak_canary_search_button"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:text="@string/leak_canary_explorer_search_classes"
+      android:visibility="invisible"
+      />
+  <TextView
+      android:id="@+id/leak_canary_explorer_title"
+      android:layout_width="match_parent"
+      android:layout_height="wrap_content"
+      android:visibility="invisible"
+      />
+  <ListView
+      android:id="@+id/leak_canary_explorer_list"
+      android:layout_width="match_parent"
+      android:layout_height="match_parent"
+      android:divider="@null"
+      android:dividerHeight="0dp"
+      android:visibility="invisible"
+      />
+</LinearLayout>
diff --git a/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
index 7a19621e..194e6f6a 100644
--- a/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
+++ b/leakcanary-android-core/src/main/res/layout/leak_canary_ref_row.xml
@@ -16,7 +16,6 @@
   -->
 <leakcanary.internal.RowElementLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:lib="http://schemas.android.com/apk/res-auto"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:clipChildren="false"
@@ -28,24 +27,9 @@
       android:layout_height="wrap_content"
       />
 
-  <leakcanary.internal.MoreDetailsView
-      android:id="@+id/leak_canary_row_more"
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      lib:leak_canary_plus_color="@color/leak_canary_class_name"
-      />
-
   <TextView
       android:id="@+id/leak_canary_row_title"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       />
-
-  <TextView
-      android:id="@+id/leak_canary_row_details"
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      android:visibility="gone"
-      />
-
 </leakcanary.internal.RowElementLayout>
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
index b5b1e2c9..ed47a273 100644
--- a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -14,7 +14,7 @@
   ~ limitations under the License.
   -->
 <resources>
-  <string name="leak_canary_about_title">About LeakCanary</string>
+  <string name="leak_canary_about_title">About LeakCanary %s</string>
   <string name="leak_canary_about_message"><![CDATA[<a href="https://github.com/square/leakcanary">LeakCanary</a>
   ist eine Memory-Leak-Detection Bibliothek f√ºr Android, erstellt von
   <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> und open-sourced von <a href="https://square.github.io">Square</a>.<br><br>
@@ -48,7 +48,7 @@
   <string name="leak_canary_options_menu_permission_toast">Bitte erlaube zun√§chst die Speicher-Berechtigung, siehe Benachrichtigung‚Ä¶</string>
   <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendere HQ Bitmap, das k√∂nnte eine Weile dauern‚Ä¶</string>
   <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Rendere HQ Bitmap, das k√∂nnte eine Weile dauern‚Ä¶</string>
-  <plurals name="leak_canary_heap_analysis_list_retained_instances">
+  <plurals name="leak_canary_heap_analysis_list_retained_objects">
     <item quantity="one">%d erhaltene Instanz</item>
     <item quantity="other">%d erhaltene Instanzen</item>
   </plurals>
@@ -70,6 +70,5 @@
   <string name="leak_canary_options_menu_import_hprof_file">Hprof Datei importieren &amp; analysieren</string>
   <string name="leak_canary_options_menu_see_analysis_list">Siehe Analyse-Liste</string>
   <string name="leak_canary_options_menu_render_heap_dump">Heap Dump rendern</string>
-  <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d erhaltene Instanzen ohne Leaks</string>
   <string name="leak_canary_help_title">Tippe hier, um mehr zu erfahren</string>
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
index d352338b..c1074bd4 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
@@ -19,6 +19,6 @@
   <item type="id" name="leak_canary_notification_analysis_result" />
   <item type="id" name="leak_canary_notification_dumping_heap" />
   <item type="id" name="leak_canary_notification_analyzing_heap" />
-  <item type="id" name="leak_canary_notification_retained_instances" />
-  <item type="id" name="leak_canary_notification_no_retained_instance_on_tap" />
+  <item type="id" name="leak_canary_notification_retained_objects" />
+  <item type="id" name="leak_canary_notification_no_retained_object_on_tap" />
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index 314fdf00..523de211 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -15,16 +15,18 @@
   ~ limitations under the License.
   -->
 <resources xmlns:tools="http://schemas.android.com/tools" tools:ignore="MissingTranslation">
-  <string name="leak_canary_about_title">About LeakCanary</string>
+  <string name="leak_canary_about_menu">About LeakCanary</string>
+  <string name="leak_canary_about_title">About LeakCanary %s</string>
   <string name="leak_canary_about_message"><![CDATA[<a href="https://github.com/square/leakcanary">LeakCanary</a>
   is a memory leak detection library for Android, created by
   <a href="https://twitter.com/Piwai">Pierre-Yves Ricau</a> and open sourced by <a href="https://square.github.io">Square</a>.<br><br>
   We welcome contributions from the community, please do not hesitate to
   <a href="https://github.com/square/leakcanary/issues">report an issue</a> or open a pull request!<br>]]></string>
   <string name="leak_canary_analysis_failed">Leak analysis failed</string>
-  <string name="leak_canary_analysis_success_notification">Analysis done: %1$d leaks (%2$d new, %3$d known, %4$d won\'t fix)</string>
+  <string name="leak_canary_analysis_success_notification">Analysis done: %1$d leaks (%2$d new, %3$d known, %4$d library)</string>
   <string name="leak_canary_class_has_leaked">%1$s Leaked</string>
   <string name="leak_canary_download_dump">You can download the heap dump via \"Menu > Share Heap Dump\" or \"adb pull %1$s\"</string>
+  <string name="leak_canary_explorer_search_classes">Search classes</string>
   <string name="leak_canary_loading_title">Loading‚Ä¶</string>
   <string name="leak_canary_notification_analysing">Analyzing Heap Dump</string>
   <string name="leak_canary_notification_channel_low">LeakCanary Low Priority</string>
@@ -32,12 +34,12 @@
   <string name="leak_canary_notification_dumping">Dumping Heap</string>
   <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
   <string name="leak_canary_notification_message">Click for more details</string>
-  <string name="leak_canary_notification_no_retained_instance_title">All retained instances were garbage collected</string>
-  <string name="leak_canary_notification_no_retained_instance_content">Tap to dismiss</string>
+  <string name="leak_canary_notification_no_retained_object_title">All retained objects were garbage collected</string>
+  <string name="leak_canary_notification_no_retained_object_content">Tap to dismiss</string>
   <string name="leak_canary_notification_retained_debugger_attached">Waiting for debugger to detach</string>
   <string name="leak_canary_notification_retained_dump_failed">Failed to dump heap</string>
-  <string name="leak_canary_notification_retained_title">%d retained instances, tap to dump heap</string>
-  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained instances</string>
+  <string name="leak_canary_notification_retained_title">%d retained objects, tap to dump heap</string>
+  <string name="leak_canary_notification_retained_visible">App visible, waiting until %d retained objects</string>
   <string name="leak_canary_share_leak">Share Info</string>
   <string name="leak_canary_share_heap_dump">Share Heap Dump</string>
   <string name="leak_canary_share_with">Share with‚Ä¶</string>
@@ -59,15 +61,15 @@
   <string name="leak_canary_options_menu_permission_toast">Please grant the External Storage Permission first, see notification‚Ä¶</string>
   <string name="leak_canary_generating_hq_bitmap_toast_notice">Rendering HQ Bitmap, this may take a while‚Ä¶</string>
   <string name="leak_canary_generating_hq_bitmap_toast_failure_notice">Rendering HQ Bitmap, this may take a while‚Ä¶</string>
-  <plurals name="leak_canary_heap_analysis_list_retained_instances">
-    <item quantity="one">%d Retained Instance</item>
-    <item quantity="other">%d Retained Instances</item>
+  <plurals name="leak_canary_heap_analysis_list_retained_objects">
+    <item quantity="one">%d Retained Objects</item>
+    <item quantity="other">%d Retained Objects</item>
   </plurals>
   <string name="leak_canary_share_heap_dump_bitmap_screen_title">Share Heap Dump Bitmap</string>
   <string name="leak_canary_heap_dump_screen_title">Heap Dump %s</string>
   <string name="leak_canary_analysis_deleted_title">Analysis Deleted</string>
   <string name="leak_canary_go_to_heap_analysis">Go to Heap Analysis</string>
-  <string name="leak_canary_heap_analysis_success_screen_title">Heap Analysis (%d Retained Instances)</string>
+  <string name="leak_canary_heap_analysis_success_screen_title">Heap Analysis (%d Retained Objects)</string>
   <string name="leak_canary_heap_analysis_success_screen_row_title">(%1$d / %2$d Total) %3$s</string>
   <string name="leak_canary_heap_analysis_success_screen_row_title_new">[NEW] (%1$d) %2$s</string>
   <string name="leak_canary_heap_analysis_success_screen_row_time_format">Latest: %s</string>
@@ -82,6 +84,6 @@
   <string name="leak_canary_options_menu_import_hprof_file">Import &amp; Analyze Hprof File</string>
   <string name="leak_canary_options_menu_see_analysis_list">See Analysis List</string>
   <string name="leak_canary_options_menu_render_heap_dump">Render Heap Dump</string>
-  <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d non leaking retained instances</string>
+  <string name="leak_canary_options_menu_explore_heap_dump">Explore Heap Dump</string>
   <string name="leak_canary_help_title">Tap here to learn more</string>
 </resources>
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
index 02f90246..e8cb5436 100644
--- a/leakcanary-android-instrumentation/build.gradle
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -28,5 +28,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
index db8d12fe..cd9660ab 100644
--- a/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
+++ b/leakcanary-android-instrumentation/src/androidTest/AndroidManifest.xml
@@ -15,14 +15,9 @@
   ~ limitations under the License.
   -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
     package="com.squareup.leakcanary.instrumentation.test">
-  <!-- Disabled debuggable for accurate performance results -->
-  <application android:name="leakcanary.InstrumentationTestApplication"
-      android:debuggable="false"
-      tools:ignore="HardcodedDebugMode"
-      tools:replace="android:debuggable"
-      >
+
+  <application android:name="leakcanary.InstrumentationTestApplication">
     <activity android:name="leakcanary.TestActivity"/>
   </application>
 </manifest>
diff --git a/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof b/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof
new file mode 100644
index 00000000..5caeb42b
Binary files /dev/null and b/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof differ
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
index f8513a60..404ea845 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -9,11 +9,12 @@ import android.view.View
 import androidx.test.core.app.ApplicationProvider.getApplicationContext
 import androidx.test.rule.ActivityTestRule
 import leakcanary.TestUtils.assertLeak
-import leakcanary.internal.InternalHelper.noOpDelegate
 import org.junit.After
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
 import java.util.concurrent.CountDownLatch
 
 class FragmentLeakTest {
@@ -24,13 +25,13 @@ class FragmentLeakTest {
   )
 
   @Before fun setUp() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    AppWatcher.objectWatcher
+        .clearWatchedObjects()
   }
 
   @After fun tearDown() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    AppWatcher.objectWatcher
+        .clearWatchedObjects()
   }
 
   @Test
@@ -109,5 +110,15 @@ class FragmentLeakTest {
   companion object {
     private const val TOUCH_MODE = true
     private const val LAUNCH_ACTIVITY = true
+
+    inline fun <reified T : Any> noOpDelegate(): T {
+      val javaClass = T::class.java
+      val noOpHandler = InvocationHandler { _, _, _ ->
+        // no op
+      }
+      return Proxy.newProxyInstance(
+          javaClass.classLoader, arrayOf(javaClass), noOpHandler
+      ) as T
+    }
   }
 }
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt
new file mode 100644
index 00000000..7b03ad3c
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt
@@ -0,0 +1,30 @@
+package leakcanary
+
+import android.os.SystemClock
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.Test
+import shark.Hprof
+import shark.HprofHeapGraph
+import shark.SharkLog
+import java.io.File
+import java.io.FileOutputStream
+
+class IndexingTest {
+
+  @Test fun indexHprof() {
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    val heapDumpFile = File(context.filesDir, "AnalysisDurationTest.hprof")
+    context.assets.open("large-dump.hprof").copyTo(FileOutputStream(heapDumpFile))
+
+    Hprof.open(heapDumpFile).use { hprof ->
+      SharkLog.d { "Start indexing" }
+      val before = SystemClock.uptimeMillis()
+      HprofHeapGraph.indexHprof(hprof)
+      val durationMs = (SystemClock.uptimeMillis() - before)
+      SharkLog.d { "Indexing took $durationMs ms" }
+    }
+  }
+}
+
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
index 3f15083f..c74a112f 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -13,18 +13,18 @@ import java.util.Date
 class InstrumentationLeakDetectorTest {
 
   @Before fun setUp() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    AppWatcher.objectWatcher
+        .clearWatchedObjects()
   }
 
   @After fun tearDown() {
-    LeakSentry.refWatcher
-        .clearWatchedInstances()
+    AppWatcher.objectWatcher
+        .clearWatchedObjects()
   }
 
   @Test fun detectsLeak() {
     leaking = Date()
-    val refWatcher = LeakSentry.refWatcher
+    val refWatcher = AppWatcher.objectWatcher
     refWatcher.watch(leaking)
     assertLeak(Date::class.java)
   }
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
new file mode 100644
index 00000000..6ef22468
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
@@ -0,0 +1,53 @@
+package leakcanary
+
+import android.util.Log
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.Ignore
+import org.junit.Test
+import shark.AndroidObjectInspectors
+import shark.AndroidReferenceMatchers
+import shark.HeapAnalyzer
+import shark.ObjectInspectors.KEYED_WEAK_REFERENCE
+import shark.OnAnalysisProgressListener
+import shark.OnAnalysisProgressListener.Step
+import shark.SharkLog
+import java.io.File
+import java.io.FileOutputStream
+
+class ProfiledTest {
+
+  @Ignore
+  @Test fun analyzeLargeDump() {
+    profileAnalysis("large-dump.hprof")
+  }
+
+  private fun profileAnalysis(fileName: String) {
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    val heapDumpFile = File(context.filesDir, "ProfiledTest.hprof")
+    context.assets.open(fileName)
+        .copyTo(FileOutputStream(heapDumpFile))
+
+    SharkLog.d { "Waiting, please start profiler" }
+    Profiler.waitForSamplingStart()
+
+    val analyzer = HeapAnalyzer(object : OnAnalysisProgressListener {
+      override fun onAnalysisProgress(step: Step) {
+        Log.d("LeakCanary", step.name)
+      }
+    })
+    val result = analyzer.analyze(
+        heapDumpFile = heapDumpFile,
+        referenceMatchers = AndroidReferenceMatchers.appDefaults,
+        objectInspectors = AndroidObjectInspectors.appDefaults,
+        computeRetainedHeapSize = true,
+        leakFinders = listOf(KEYED_WEAK_REFERENCE)
+    )
+    SharkLog.d { result.toString() }
+    // Giving time to stop CPU profiler (otherwise trace won't succeed)
+    Profiler.waitForSamplingStop()
+  }
+
+}
+
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt
new file mode 100644
index 00000000..9c053c31
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt
@@ -0,0 +1,59 @@
+package leakcanary
+
+import shark.SharkLog
+
+/**
+ * Helper class for working with Android Studio's Profiler
+ */
+internal object Profiler {
+  private const val SLEEP_TIME_MILLIS = 1000L
+  private const val SAMPLING_THREAD_NAME = "Sampling Profiler"
+
+  /**
+   * Wait until Profiler is attached and CPU Sampling is started.
+   * Calling this on main thread can lead to ANR if you try to interact with UI while it's waiting for
+   * profiler.
+   * Note: only works with 'Sample Java Methods' profiling, won't work with 'Trace Java Methods'!
+   */
+  fun waitForSamplingStart() {
+    SharkLog.d { "Waiting for sampling to start. Go to Profiler -> CPU -> Record" }
+    sleepUntil { samplingThreadExists() }
+    Thread.sleep(SLEEP_TIME_MILLIS) //Wait a bit more to ensure profiler started sampling
+    SharkLog.d { "Sampling started! Proceeding..." }
+  }
+
+
+  /**
+   * Wait until CPU Sampling stops.
+   * Calling this on main thread can lead to ANR if you try to interact with UI while it's waiting for
+   * profiler.
+   */
+  fun waitForSamplingStop() {
+    SharkLog.d { "Waiting for sampling to stop. Go to Profiler -> CPU -> Stop recording" }
+    sleepUntil { !samplingThreadExists() }
+    SharkLog.d { "Sampling stopped! Proceeding..." }
+  }
+
+  private inline fun sleepUntil(condition: () -> Boolean) {
+    while (true) {
+      if (condition()) return else Thread.sleep(SLEEP_TIME_MILLIS)
+    }
+  }
+
+  private fun samplingThreadExists() = findThread(SAMPLING_THREAD_NAME) != null
+
+  /**
+   * Utility to get thread by its name; in case of multiple matches first one will be returned.
+   */
+  private fun findThread(threadName: String): Thread? {
+    // Based on https://stackoverflow.com/a/1323480
+    var rootGroup = Thread.currentThread().threadGroup
+    while (rootGroup.parent != null) rootGroup = rootGroup.parent
+
+    var threads = arrayOfNulls<Thread>(rootGroup.activeCount())
+    while (rootGroup.enumerate(threads, true) == threads.size) {
+      threads = arrayOfNulls(threads.size * 2)
+    }
+    return threads.firstOrNull { it?.name == threadName }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
index 639e4d8d..96c2b0c6 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
@@ -2,18 +2,24 @@ package leakcanary
 
 import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
 import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
+import shark.HeapAnalysisSuccess
 
 object TestUtils {
   fun assertLeak(expectedLeakClass: Class<*>) {
     val leakDetector = InstrumentationLeakDetector()
-    val result = leakDetector.detectLeaks()
 
-    val heapAnalysis = when (result) {
+    val heapAnalysis = when (val result = leakDetector.detectLeaks()) {
       is NoAnalysis -> throw AssertionError("Expected analysis to be performed")
       is AnalysisPerformed -> result.heapAnalysis
     }
 
-    val applicationLeaks = heapAnalysis.applicationLeaks()
+    if (heapAnalysis !is HeapAnalysisSuccess) {
+      throw AssertionError(
+          "Expected analysis success not $heapAnalysis"
+      )
+    }
+
+    val applicationLeaks = heapAnalysis.applicationLeaks
     if (applicationLeaks.size != 1) {
       throw AssertionError(
           "Expected exactly one leak in $heapAnalysis"
@@ -22,9 +28,9 @@ object TestUtils {
 
     val leakInstance = applicationLeaks.first()
 
-    if (leakInstance.instanceClassName != expectedLeakClass.name) {
+    if (leakInstance.className != expectedLeakClass.name) {
       throw AssertionError(
-          "Expected a leak of $expectedLeakClass, not ${leakInstance.instanceClassName} in $heapAnalysis"
+          "Expected a leak of $expectedLeakClass, not ${leakInstance.className} in $heapAnalysis"
       )
     }
   }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
index 346cd239..2d49a655 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailAnnotatedTestOnLeakRunListener.kt
@@ -4,8 +4,7 @@ import org.junit.runner.Description
 import org.junit.runner.notification.RunListener
 
 /**
- *
- * A JUnit [RunListener] subclassing [FailTestOnLeakRunListener] for detecting memory
+ * A JUnit [RunListener] extending [FailTestOnLeakRunListener] to detecting memory
  * leaks in Android instrumentation tests only when the [FailTestOnLeak] annotation
  * is used.
  *
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
index 1721e18c..024e3aa0 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeak.kt
@@ -1,7 +1,6 @@
 package leakcanary
 
 /**
- *
  * An [Annotation] class to be used in conjunction with [FailAnnotatedTestOnLeakRunListener]
  * for detecting memory leaks. When using [FailAnnotatedTestOnLeakRunListener], the tests
  * should be annotated with this class in order for the listener to detect memory leaks.
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
index cd470232..2c24698c 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -17,6 +17,7 @@ package leakcanary
 
 import android.app.Instrumentation
 import android.os.Bundle
+import android.util.Log
 import androidx.test.internal.runner.listener.InstrumentationResultPrinter
 import androidx.test.internal.runner.listener.InstrumentationResultPrinter.REPORT_VALUE_RESULT_FAILURE
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
@@ -25,16 +26,19 @@ import org.junit.runner.Description
 import org.junit.runner.Result
 import org.junit.runner.notification.Failure
 import org.junit.runner.notification.RunListener
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
 
 /**
  *
- * A JUnit [RunListener] for detecting memory leaks in Android instrumentation tests. It
- * waits for the end of a test, and if the test succeeds then it will look for leaking
- * references, trigger a heap dump if needed and perform an analysis.
+ * A JUnit [RunListener] that uses [InstrumentationLeakDetector] to detect memory leaks in Android
+ * instrumentation tests. It waits for the end of a test, and if the test succeeds then it will
+ * look for retained objects, trigger a heap dump if needed and perform an analysis.
  *
- *  [FailTestOnLeakRunListener] can be subclassed to override
- * [skipLeakDetectionReason], [reportLeaks]
- * or [buildLeakDetectedMessage]
+ *  [FailTestOnLeakRunListener] can be subclassed to override [skipLeakDetectionReason] and
+ *  [onAnalysisPerformed]
  *
  * @see InstrumentationLeakDetector
  */
@@ -60,7 +64,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   /**
    * Can be overridden to skip leak detection based on the description provided when a test
-   * is started. Returns null to continue leak detection, or a string describing the reason for
+   * is started. Return null to continue leak detection, or a string describing the reason for
    * skipping otherwise.
    */
   protected open fun skipLeakDetectionReason(description: Description): String? {
@@ -81,7 +85,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   override fun testFinished(description: Description) {
     detectLeaks()
-    LeakSentry.refWatcher.clearWatchedInstances()
+    AppWatcher.objectWatcher.clearWatchedObjects()
   }
 
   override fun testRunStarted(description: Description) {
@@ -92,7 +96,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   private fun detectLeaks() {
     if (skipLeakDetectionReason != null) {
-      CanaryLog.d("Skipping leak detection because the test %s", skipLeakDetectionReason)
+      SharkLog.d { "Skipping leak detection because the test $skipLeakDetectionReason" }
       skipLeakDetectionReason = null
       return
     }
@@ -101,46 +105,35 @@ open class FailTestOnLeakRunListener : RunListener() {
     val result = leakDetector.detectLeaks()
 
     if (result is AnalysisPerformed) {
-      val applicationLeaks = result.heapAnalysis.applicationLeaks()
-      if (applicationLeaks.isNotEmpty()) {
-        reportLeaks(result.heapAnalysis, applicationLeaks)
-      }
+      onAnalysisPerformed(heapAnalysis = result.heapAnalysis)
     }
   }
 
-  /** Can be overridden to report leaks in a different way or do additional reporting.  */
-  protected open fun reportLeaks(
-    heapAnalysis: HeapAnalysis,
-    applicationLeaks: List<LeakingInstance>
-  ) {
-    val message = buildLeakDetectedMessage(heapAnalysis, applicationLeaks)
-
-    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message)
-    getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle)
-  }
-
-  /** Can be overridden to customize the failure string message.  */
-  protected open fun buildLeakDetectedMessage(
-    heapAnalysis: HeapAnalysis,
-    applicationLeaks: List<LeakingInstance>
-  ): String {
-    val failureMessage = StringBuilder()
-    failureMessage.append(
-        "Test failed because memory leaks were detected, see leak traces below.\n"
-    )
-    failureMessage.append(SEPARATOR)
-
-    applicationLeaks.forEach { applicationLeak ->
-      // TODO Improve rendering
-      failureMessage.append(applicationLeak.toString())
-      failureMessage.append("\n ")
-      failureMessage.append(SEPARATOR)
+  /**
+   * Called when a heap analysis has been performed and a result is available.
+   *
+   * The default implementation call [failTest] if the [heapAnalysis] failed or if
+   * [HeapAnalysisSuccess.applicationLeaks] is not empty.
+   */
+  protected open fun onAnalysisPerformed(heapAnalysis: HeapAnalysis) {
+    when (heapAnalysis) {
+      is HeapAnalysisFailure -> {
+        failTest(Log.getStackTraceString(heapAnalysis.exception))
+      }
+      is HeapAnalysisSuccess -> {
+        val applicationLeaks = heapAnalysis.applicationLeaks
+        if (applicationLeaks.isNotEmpty()) {
+          failTest("Test failed because application memory leaks were detected:\n$heapAnalysis")
+        }
+      }
     }
-
-    return failureMessage.toString()
   }
 
-  companion object {
-    private const val SEPARATOR = "######################################\n"
+  /**
+   * Reports that the test has failed, with the provided [message].
+   */
+  protected fun failTest(message: String) {
+    bundle.putString(InstrumentationResultPrinter.REPORT_KEY_STACK, message)
+    getInstrumentation().sendStatus(REPORT_VALUE_RESULT_FAILURE, bundle)
   }
 }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 3310522f..16753eb7 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -19,46 +19,33 @@ import android.os.Debug
 import android.os.SystemClock
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
 import leakcanary.GcTrigger.Default.runGc
+import leakcanary.InstrumentationLeakDetector.Companion.updateConfig
 import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
 import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
 import org.junit.runner.notification.RunListener
+import shark.HeapAnalysis
+import shark.HeapAnalysisException
+import shark.HeapAnalysisFailure
+import shark.HeapAnalyzer
+import shark.ObjectInspectors
+import shark.SharkLog
 import java.io.File
 
 /**
- * TODO Update this doc to match LeakCanary 2.0
- *
  * [InstrumentationLeakDetector] can be used to detect memory leaks in instrumentation tests.
  *
  * To use it, you need to:
  *
- *  * Install a custom RefWatcher that will not trigger heapdumps while the tests run.
- *  * Add an instrumentation test listener (a [RunListener]) that will invoke
- * [detectLeaks]
- *
- * ### Installing the instrumentation RefWatcher
- *
- * For [detectLeaks] to work correctly, the [RefWatcher] must keep track of
- * references but not trigger any heap dump until this [detectLeaks] runs, otherwise an
- * analysis in progress might prevent this listener from performing its own analysis.
- *
- * Create and install the [RefWatcher] instance using
- * [instrumentationRefWatcher] instead of
- * [LeakCanary.install] or [LeakCanary.refWatcher].
- *
- * ```
- * public class InstrumentationExampleApplication extends ExampleApplication {
- *  @Override protected void setupLeakCanary() {
- *    InstrumentationLeakDetector.instrumentationRefWatcher(this)
- *      .buildAndInstall();
- *  }
- * }
- * ```
+ *  - Call [updateConfig] so that [AppWatcher] will watch objects and [LeakCanary] will not dump
+ *  the heap on retained objects
+ *  - Add an instrumentation test listener (e.g. [FailTestOnLeakRunListener]) that will invoke
+ * [detectLeaks].
  *
  * ### Add an instrumentation test listener
  *
- * LeakCanary provides [FailTestOnLeakRunListener], but you should feel free to implement
- * your own [RunListener] and call [.detectLeaks] directly if you need a more custom
- * behavior (for instance running it only once per test suite, or reporting to a backend).
+ * LeakCanary provides [FailTestOnLeakRunListener], but you can also implement
+ * your own [RunListener] and call [detectLeaks] directly if you need a more custom
+ * behavior (for instance running it only once per test suite).
  *
  * All you need to do is add the following to the defaultConfig of your build.gradle:
  *
@@ -80,46 +67,53 @@ import java.io.File
  * ```
  *
  * ### Rationale
- * Instead of using the [FailTestOnLeakRunListener], one could simply enable LeakCanary in
+ * Instead of using the [InstrumentationLeakDetector], one could simply enable LeakCanary in
  * instrumentation tests.
  *
  * This approach would have two disadvantages:
  *
- *  * Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
+ *  - Heap dumps freeze the VM, and the leak analysis is IO and CPU heavy. This can slow down
  * the test and introduce flakiness
- *  * The leak analysis is asynchronous by default, and happens in a separate process. This means
- * the tests could finish and the process die before the analysis is finished.
+ *  - The leak analysis is asynchronous by default. This means the tests could finish and the
+ *  process die before the analysis is finished.
  *
- * The approach taken here is to collect all references to watch as you run the test, but not
+ * The approach taken here is to collect all objects to watch as you run the test, but not
  * do any heap dump during the test. Then, at the end, if any of the watched objects is still in
  * memory we dump the heap and perform a blocking analysis. There is only one heap dump performed,
- * no matter the number of objects leaking.
+ * no matter the number of objects retained.
  */
 class InstrumentationLeakDetector {
 
+  /**
+   * The result of calling [detectLeaks], which is either [NoAnalysis] or [AnalysisPerformed].
+   */
   sealed class Result {
     object NoAnalysis : Result()
     class AnalysisPerformed(val heapAnalysis: HeapAnalysis) : Result()
   }
 
+  /**
+   * Looks for retained objects, triggers a heap dump if needed and performs an analysis.
+   */
+  @Suppress("ReturnCount")
   fun detectLeaks(): Result {
     val leakDetectionTime = SystemClock.uptimeMillis()
-    val watchDurationMillis = LeakSentry.config.watchDurationMillis
+    val watchDurationMillis = AppWatcher.config.watchDurationMillis
     val instrumentation = getInstrumentation()
     val context = instrumentation.targetContext
-    val refWatcher = LeakSentry.refWatcher
+    val refWatcher = AppWatcher.objectWatcher
 
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
     instrumentation.waitForIdleSync()
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
     runGc()
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
@@ -127,7 +121,7 @@ class InstrumentationLeakDetector {
     // Android simply has way too many delayed posts that aren't canceled when views are detached.
     SystemClock.sleep(2000)
 
-    if (!refWatcher.hasWatchedInstances) {
+    if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
     }
 
@@ -143,7 +137,7 @@ class InstrumentationLeakDetector {
 
     runGc()
 
-    if (!refWatcher.hasRetainedInstances) {
+    if (!refWatcher.hasRetainedObjects) {
       return NoAnalysis
     }
 
@@ -158,7 +152,7 @@ class InstrumentationLeakDetector {
     try {
       Debug.dumpHprofData(heapDumpFile.absolutePath)
     } catch (exception: Exception) {
-      CanaryLog.d(exception, "Could not dump heap")
+      SharkLog.d(exception) { "Could not dump heap" }
       return AnalysisPerformed(
           HeapAnalysisFailure(
               heapDumpFile, analysisDurationMillis = 0,
@@ -168,17 +162,21 @@ class InstrumentationLeakDetector {
       )
     }
 
-    refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
+    refWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
 
-    val listener = AnalyzerProgressListener.NONE
+    val listener = shark.OnAnalysisProgressListener.NO_OP
 
     val heapAnalyzer = HeapAnalyzer(listener)
-    val heapAnalysis = heapAnalyzer.checkForLeaks(
-        heapDumpFile, AndroidKnownReference.mapToExclusions(config.knownReferences), config.computeRetainedHeapSize,
-        config.leakTraceInspectors
+    val heapAnalysis = heapAnalyzer.analyze(
+        heapDumpFile, config.referenceMatchers,
+        config.computeRetainedHeapSize,
+        config.objectInspectors,
+        if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
+            ObjectInspectors.KEYED_WEAK_REFERENCE
+        )
     )
 
-    CanaryLog.d("Heap Analysis:\n%s", heapAnalysis)
+    SharkLog.d { "Heap Analysis:\n$heapAnalysis" }
 
     return AnalysisPerformed(heapAnalysis)
   }
@@ -186,12 +184,14 @@ class InstrumentationLeakDetector {
   companion object {
 
     /**
-     * Configures LeakCanary to not dump the heap so that instrumentation tests run smoothly,
-     * and we can look for leaks at the end of a test. This is automatically called by
-     * [FailTestOnLeakRunListener] when the tests start running.
+     * Configures [AppWatcher] to watch objects and [LeakCanary] to not dump the heap on retained
+     * objects so that instrumentation tests run smoothly, and we can look for leaks at the end of
+     * a test. This is automatically called by [FailTestOnLeakRunListener] when the tests start
+     * running.
      */
     fun updateConfig() {
-      LeakSentry.config = LeakSentry.config.copy(enabled = true)
+      AppWatcher.config = AppWatcher.config.copy(enabled = true)
+      LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
     }
   }
 }
diff --git a/leakcanary-android-process/build.gradle b/leakcanary-android-process/build.gradle
index 2c2b98eb..a21e2b5e 100644
--- a/leakcanary-android-process/build.gradle
+++ b/leakcanary-android-process/build.gradle
@@ -20,5 +20,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-process/src/main/AndroidManifest.xml b/leakcanary-android-process/src/main/AndroidManifest.xml
index 59728db4..6e787bc8 100644
--- a/leakcanary-android-process/src/main/AndroidManifest.xml
+++ b/leakcanary-android-process/src/main/AndroidManifest.xml
@@ -21,13 +21,13 @@
     <service
         android:name="leakcanary.internal.HeapAnalyzerService"
         android:exported="false"
-        android:process=":leakcanary"
-        >
-      <intent-filter>
-        <action android:name="leakcanary.ANALYSIS_ACTION"/>
-      </intent-filter>
-    </service>
+        android:process=":leakcanary" />
 
+    <provider
+        android:name="leakcanary.internal.AppWatcherInstaller$LeakCanaryProcess"
+        android:authorities="${applicationId}.leakcanary-process.installer"
+        android:process=":leakcanary"
+        android:exported="false"/>
   </application>
 
 </manifest>
diff --git a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
index 39186f60..1eac2da6 100644
--- a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
+++ b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
@@ -7,7 +7,16 @@ import android.content.Context
 import android.content.pm.PackageInfo
 import android.content.pm.PackageManager
 import android.content.pm.ServiceInfo
+import shark.SharkLog
 
+/**
+ * Used to determine whether the current process is the LeakCanary analyzer process. By depending
+ * on the `leakcanary-android-process` artifact instead of the `leakcanary-android`, LeakCanary
+ * will automatically run its analysis in a separate process.
+ *
+ * As such, you'll need to be careful to do any custom configuration of LeakCanary in both the main
+ * process and the analyzer process.
+ */
 object LeakCanaryProcess {
 
   @Volatile private var isInAnalyzerProcess: Boolean? = null
@@ -35,6 +44,7 @@ object LeakCanaryProcess {
     return isInAnalyzerProcess
   }
 
+  @Suppress("ReturnCount")
   private fun isInServiceProcess(
     context: Context,
     serviceClass: Class<out Service>
@@ -44,7 +54,7 @@ object LeakCanaryProcess {
     try {
       packageInfo = packageManager.getPackageInfo(context.packageName, PackageManager.GET_SERVICES)
     } catch (e: Exception) {
-      CanaryLog.d(e, "Could not get package info for %s", context.packageName)
+      SharkLog.d(e) { "Could not get package info for ${context.packageName}" }
       return false
     }
 
@@ -61,12 +71,10 @@ object LeakCanaryProcess {
     }
 
     if (serviceInfo.processName == null) {
-      CanaryLog.d("Did not expect service %s to have a null process name", serviceClass)
+      SharkLog.d { "Did not expect service $serviceClass to have a null process name" }
       return false
     } else if (serviceInfo.processName == mainProcess) {
-      CanaryLog.d(
-          "Did not expect service %s to run in main process %s", serviceClass, mainProcess
-      )
+      SharkLog.d { "Did not expect service $serviceClass to run in main process $mainProcess" }
       // Technically we are in the service process, but we're not in the service dedicated process.
       return false
     }
@@ -79,7 +87,7 @@ object LeakCanaryProcess {
       runningProcesses = activityManager.runningAppProcesses
     } catch (exception: SecurityException) {
       // https://github.com/square/leakcanary/issues/948
-      CanaryLog.d("Could not get running app processes %d", exception)
+      SharkLog.d { "Could not get running app processes $exception" }
       return false
     }
 
@@ -92,7 +100,7 @@ object LeakCanaryProcess {
       }
     }
     if (myProcess == null) {
-      CanaryLog.d("Could not find running process for %d", myPid)
+      SharkLog.d { "Could not find running process for $myPid" }
       return false
     }
 
diff --git a/leakcanary-sample/build.gradle b/leakcanary-android-sample/build.gradle
similarity index 85%
rename from leakcanary-sample/build.gradle
rename to leakcanary-android-sample/build.gradle
index ad05c169..dd517107 100644
--- a/leakcanary-sample/build.gradle
+++ b/leakcanary-android-sample/build.gradle
@@ -37,7 +37,16 @@ android {
   }
 
   buildTypes {
-    debug
+    // Build with ./gradlew leakcanary-android-sample:installDebug -Pminify
+    if (project.hasProperty('minify')) {
+      debug {
+        minifyEnabled true
+        proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
+      }
+    } else {
+      debug
+    }
+
     release
   }
 
diff --git a/leakcanary-leaksentry/src/androidTest/AndroidManifest.xml b/leakcanary-android-sample/src/androidTest/AndroidManifest.xml
similarity index 100%
rename from leakcanary-leaksentry/src/androidTest/AndroidManifest.xml
rename to leakcanary-android-sample/src/androidTest/AndroidManifest.xml
diff --git a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt b/leakcanary-android-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
similarity index 94%
rename from leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
rename to leakcanary-android-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
index b07ec28f..8be7b1b0 100644
--- a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
+++ b/leakcanary-android-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
@@ -18,7 +18,7 @@ import org.junit.Test
  *
  * ./gradlew leakcanary-sample:connectedCheck
  *
- * To set this up, we installed a special RefWatcher dedicated to detecting leaks in
+ * To set this up, we installed a special ObjectWatcher dedicated to detecting leaks in
  * instrumentation tests in [InstrumentationExampleApplication], and then added the FailTestOnLeakRunListener
  * to the config of our build.gradle:
  *
diff --git a/leakcanary-sample/src/main/AndroidManifest.xml b/leakcanary-android-sample/src/main/AndroidManifest.xml
similarity index 100%
rename from leakcanary-sample/src/main/AndroidManifest.xml
rename to leakcanary-android-sample/src/main/AndroidManifest.xml
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
similarity index 100%
rename from leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
rename to leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
similarity index 100%
rename from leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
rename to leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
similarity index 100%
rename from leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
rename to leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/MainActivity.kt
similarity index 100%
rename from leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
rename to leakcanary-android-sample/src/main/java/com/example/leakcanary/MainActivity.kt
diff --git a/leakcanary-sample/src/main/res/layout/main_activity.xml b/leakcanary-android-sample/src/main/res/layout/main_activity.xml
similarity index 100%
rename from leakcanary-sample/src/main/res/layout/main_activity.xml
rename to leakcanary-android-sample/src/main/res/layout/main_activity.xml
diff --git a/leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-hdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-hdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-mdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-mdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-android-sample/src/main/res/values/strings.xml
similarity index 100%
rename from leakcanary-sample/src/main/res/values/strings.xml
rename to leakcanary-android-sample/src/main/res/values/strings.xml
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index 2c2b98eb..a21e2b5e 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -20,5 +20,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index 0ee35e1c..7ad651e4 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -20,13 +20,7 @@
   <application>
     <service
         android:name="leakcanary.internal.HeapAnalyzerService"
-        android:exported="false"
-        >
-      <intent-filter>
-        <action android:name="leakcanary.ANALYSIS_ACTION"/>
-      </intent-filter>
-    </service>
-
+        android:exported="false" />
   </application>
 
 </manifest>
diff --git a/leakcanary-haha/gradle.properties b/leakcanary-haha/gradle.properties
deleted file mode 100644
index b7629a2c..00000000
--- a/leakcanary-haha/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-haha
-POM_NAME=LeakCanary Headless Android Heap Analyzer
-POM_PACKAGING=jar
diff --git a/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt b/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
deleted file mode 100644
index 9ab4dfe5..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
+++ /dev/null
@@ -1,7 +0,0 @@
-package leakcanary
-
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-
-interface FieldValuesReader {
-  fun readValue(field: FieldRecord): HeapValue
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
deleted file mode 100644
index ce400a5b..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
+++ /dev/null
@@ -1,9 +0,0 @@
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphClassRecord
-
-class GraphField(
-  val classRecord: GraphClassRecord,
-  val name: String,
-  val value: GraphHeapValue
-)
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
deleted file mode 100644
index a19c8de3..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
+++ /dev/null
@@ -1,65 +0,0 @@
-package leakcanary
-
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-
-class GraphHeapValue(
-  private val graph: HprofGraph,
-  val actual: HeapValue
-) {
-  val asBoolean: Boolean?
-    get() = if (actual is BooleanValue) actual.value else null
-
-  val asChar: Char?
-    get() = if (actual is CharValue) actual.value else null
-
-  val asFloat: Float?
-    get() = if (actual is FloatValue) actual.value else null
-
-  val asDouble: Double?
-    get() = if (actual is DoubleValue) actual.value else null
-
-  val asByte: Byte?
-    get() = if (actual is ByteValue) actual.value else null
-
-  val asShort: Short?
-    get() = if (actual is ShortValue) actual.value else null
-
-  val asInt: Int?
-    get() = if (actual is IntValue) actual.value else null
-
-  val asLong: Long?
-    get() = if (actual is LongValue) actual.value else null
-
-  val asObjectIdReference: Long?
-    get() = if (actual is ObjectReference) actual.value else null
-
-  val asNonNullObjectIdReference: Long?
-    get() = if (actual is ObjectReference && !actual.isNull) actual.value else null
-
-  val isNullReference: Boolean
-    get() = actual is ObjectReference && actual.isNull
-
-  val isNonNullReference: Boolean
-    get() = actual is ObjectReference && !actual.isNull
-
-  val asObject: GraphObjectRecord?
-    get() {
-      return if (actual is ObjectReference && !actual.isNull) {
-        return graph.indexedObject(actual.value)
-      } else {
-        null
-      }
-    }
-
-  fun readAsJavaString(): String? {
-    return asObject?.asInstance?.readAsJavaString()
-  }
-}
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
deleted file mode 100644
index 69ff4183..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
+++ /dev/null
@@ -1,232 +0,0 @@
-package leakcanary
-
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.internal.IndexedObject.IndexedClass
-import leakcanary.internal.IndexedObject.IndexedInstance
-import leakcanary.internal.IndexedObject.IndexedObjectArray
-import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
-import java.nio.charset.Charset
-import kotlin.reflect.KClass
-
-sealed class GraphObjectRecord {
-
-  abstract val objectId: Long
-
-  abstract fun readRecord(): ObjectRecord
-
-  val asClass: GraphClassRecord?
-    get() = if (this is GraphClassRecord) this else null
-
-  val asInstance: GraphInstanceRecord?
-    get() = if (this is GraphInstanceRecord) this else null
-
-  val asObjectArray: GraphObjectArrayRecord?
-    get() = if (this is GraphObjectArrayRecord) this else null
-
-  val asPrimitiveArray: GraphPrimitiveArrayRecord?
-    get() = if (this is GraphPrimitiveArrayRecord) this else null
-
-  class GraphClassRecord internal constructor(
-    private val graph: HprofGraph,
-    private val indexedObject: IndexedClass,
-    override val objectId: Long
-  ) : GraphObjectRecord() {
-    override fun readRecord(): ClassDumpRecord {
-      return graph.readClassDumpRecord(objectId, indexedObject)
-    }
-
-    val name: String
-      get() = graph.className(objectId)
-
-    val simpleName: String
-      get() {
-        val className = this.name
-        val separator = className.lastIndexOf('.')
-        return if (separator == -1) {
-          className
-        } else {
-          className.substring(separator + 1)
-        }
-      }
-
-    val instanceSize: Int
-      get() = indexedObject.instanceSize
-
-    val superClass: GraphClassRecord?
-      get() {
-        if (indexedObject.superClassId == 0L) return null
-        return graph.indexedObject(indexedObject.superClassId) as GraphClassRecord
-      }
-
-    val classHierarchy: Sequence<GraphClassRecord>
-      get() = generateSequence(this) { it.superClass }
-
-    fun readStaticFields(): List<GraphField> {
-      val fields = mutableListOf<GraphField>()
-      for (fieldRecord in readRecord().staticFields) {
-        fields += GraphField(
-            this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
-        )
-      }
-      return fields
-    }
-
-    operator fun get(fieldName: String): GraphField? {
-      for (fieldRecord in readRecord().staticFields) {
-        if (graph.staticFieldName(fieldRecord) == fieldName) {
-          return GraphField(
-              this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
-          )
-        }
-      }
-      return null
-    }
-  }
-
-  class GraphInstanceRecord internal constructor(
-    private val graph: HprofGraph,
-    private val indexedObject: IndexedInstance,
-    override val objectId: Long,
-    val isPrimitiveWrapper: Boolean
-  ) : GraphObjectRecord() {
-    override fun readRecord(): InstanceDumpRecord {
-      return graph.readInstanceDumpRecord(objectId, indexedObject)
-    }
-
-    infix fun instanceOf(className: String): Boolean {
-      var currentClassId = indexedObject.classId
-      while (currentClassId != 0L) {
-        if (graph.className(currentClassId) == className) {
-          return true
-        }
-
-        val currentClassRecord = graph.readObjectRecord(currentClassId) as ClassDumpRecord
-        currentClassId = currentClassRecord.superClassId
-      }
-      return false
-    }
-
-    infix fun instanceOf(expectedClass: KClass<*>) =
-      this instanceOf expectedClass.java.name
-
-    operator fun get(
-      declaringClass: KClass<out Any>,
-      fieldName: String
-    ): GraphField? {
-      return get(declaringClass.java.name, fieldName)
-    }
-
-    operator fun get(
-      declaringClassName: String,
-      fieldName: String
-    ): GraphField? {
-      return readFields().firstOrNull { field -> field.classRecord.name == declaringClassName && field.name == fieldName }
-    }
-
-    val className: String
-      get() = graph.className(indexedObject.classId)
-
-    val classSimpleName: String
-      get() {
-        val className = this.className
-        val separator = className.lastIndexOf('.')
-        return if (separator == -1) {
-          className
-        } else {
-          className.substring(separator + 1)
-        }
-      }
-
-    val instanceClass: GraphClassRecord
-      get() {
-        return graph.indexedObject(indexedObject.classId) as GraphClassRecord
-      }
-
-    fun readFields(): Sequence<GraphField> {
-      val fieldReader by lazy {
-        graph.createFieldValuesReader(readRecord())
-      }
-      return instanceClass.classHierarchy
-          .map { classRecord ->
-            classRecord.readRecord()
-                .fields.asSequence()
-                .map { fieldRecord ->
-                  val fieldName = graph.fieldName(fieldRecord)
-                  val fieldValue = fieldReader.readValue(fieldRecord)
-                  GraphField(classRecord, fieldName, GraphHeapValue(graph, fieldValue))
-                }
-          }
-          .flatten()
-    }
-
-    fun readAsJavaString(): String? {
-      if (className != "java.lang.String") {
-        return null
-      }
-      val count = this["java.lang.String", "count"]!!.value.asInt!!
-      if (count == 0) {
-        return ""
-      }
-
-      // Prior to API 26 String.value was a char array.
-      // Since API 26 String.value is backed by native code. The vast majority of strings in a
-      // heap dump are backed by a byte array, but we still find a few backed by a char array.
-      when (val valueRecord =
-        this["java.lang.String", "value"]!!.value.asObject!!.readRecord()) {
-        is CharArrayDump -> {
-          // < API 23
-          // As of Marshmallow, substrings no longer share their parent strings' char arrays
-          // eliminating the need for String.offset
-          // https://android-review.googlesource.com/#/c/83611/
-          val offset = this["java.lang.String", "offset"]?.value?.asInt ?: 0
-
-          val chars = valueRecord.array.copyOfRange(offset, offset + count)
-          return String(chars)
-        }
-        is ByteArrayDump -> {
-          return String(valueRecord.array, Charset.forName("UTF-8"))
-        }
-        else -> throw UnsupportedOperationException(
-            "'value' field ${this["java.lang.String", "value"]!!.value} was expected to be either" +
-                " a char or byte array in string instance with id $objectId"
-        )
-      }
-    }
-  }
-
-  class GraphObjectArrayRecord internal constructor(
-    private val graph: HprofGraph,
-    private val indexedObject: IndexedObjectArray,
-    override val objectId: Long,
-    val isPrimitiveWrapperArray: Boolean
-  ) : GraphObjectRecord() {
-
-    val arrayClassName: String
-      get() = graph.className(indexedObject.arrayClassId)
-
-    override fun readRecord(): ObjectArrayDumpRecord {
-      return graph.readObjectArrayDumpRecord(objectId, indexedObject)
-    }
-
-  }
-
-  class GraphPrimitiveArrayRecord internal constructor(
-    private val graph: HprofGraph,
-    private val indexedObject: IndexedPrimitiveArray,
-    override val objectId: Long
-  ) : GraphObjectRecord() {
-    val primitiveType: PrimitiveType
-      get() = indexedObject.primitiveType
-
-    override fun readRecord(): PrimitiveArrayDumpRecord {
-      return graph.readPrimitiveArrayDumpRecord(objectId, indexedObject)
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
deleted file mode 100644
index 3178c479..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
+++ /dev/null
@@ -1,84 +0,0 @@
-package leakcanary
-
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-
-sealed class HeapValue {
-  data class ObjectReference(val value: Long) : HeapValue() {
-    val isNull
-      get() = value == 0L
-  }
-
-  data class BooleanValue(val value: Boolean) : HeapValue()
-  data class CharValue(val value: Char) : HeapValue()
-  data class FloatValue(val value: Float) : HeapValue()
-  data class DoubleValue(val value: Double) : HeapValue()
-  data class ByteValue(val value: Byte) : HeapValue()
-  data class ShortValue(val value: Short) : HeapValue()
-  data class IntValue(val value: Int) : HeapValue()
-  data class LongValue(val value: Long) : HeapValue()
-}
-
-val HeapValue?.isNullReference
-  get() = this is ObjectReference && isNull
-
-val HeapValue?.reference
-  get() = if (this is ObjectReference && !isNull) {
-    this.value
-  } else
-    null
-
-val HeapValue?.boolean
-  get() = if (this is BooleanValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.char
-  get() = if (this is CharValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.float
-  get() = if (this is FloatValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.double
-  get() = if (this is DoubleValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.byte
-  get() = if (this is ByteValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.short
-  get() = if (this is ShortValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.int
-  get() = if (this is IntValue) {
-    this.value
-  } else
-    null
-
-val HeapValue?.long
-  get() = if (this is LongValue) {
-    this.value
-  } else
-    null
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
deleted file mode 100644
index 71810636..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ /dev/null
@@ -1,216 +0,0 @@
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.internal.HprofInMemoryIndex
-import leakcanary.internal.IndexedObject
-import leakcanary.internal.IndexedObject.IndexedClass
-import leakcanary.internal.IndexedObject.IndexedInstance
-import leakcanary.internal.IndexedObject.IndexedObjectArray
-import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
-import leakcanary.internal.LruCache
-import okio.Buffer
-import java.io.Closeable
-import java.io.File
-
-/**
- * Enables navigation through the Hprof graph of objects.
- */
-class HprofGraph internal constructor(
-  private val reader: SeekableHprofReader,
-  private val index: HprofInMemoryIndex
-) {
-
-  /**
-   * LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
-   * This is based on running InstrumentationLeakDetectorTest a bunch of time on a
-   * Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
-   */
-  private val objectCache = LruCache<Long, ObjectRecord>(3000)
-
-  fun indexedClass(className: String): GraphClassRecord? {
-    val classId = index.classId(className)
-    return if (classId == null) {
-      null
-    } else {
-      return indexedObject(classId) as GraphClassRecord
-    }
-  }
-
-  fun readObjectRecord(objectId: Long): ObjectRecord {
-    return when (val indexedObject = index.indexedObject(objectId)) {
-      is IndexedInstance -> readInstanceDumpRecord(objectId, indexedObject)
-      is IndexedClass -> readClassDumpRecord(objectId, indexedObject)
-      is IndexedObjectArray -> readObjectArrayDumpRecord(objectId, indexedObject)
-      is IndexedPrimitiveArray -> readPrimitiveArrayDumpRecord(objectId, indexedObject)
-    }
-  }
-
-  fun indexedObject(objectId: Long): GraphObjectRecord {
-    return when (val indexedObject = index.indexedObject(objectId)) {
-      is IndexedClass -> GraphClassRecord(this, indexedObject, objectId)
-      is IndexedInstance -> {
-        val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
-        GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
-      }
-      is IndexedObjectArray -> {
-        val isPrimitiveWrapperArray =
-          index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
-        GraphObjectArrayRecord(this, indexedObject, objectId, isPrimitiveWrapperArray)
-      }
-      is IndexedPrimitiveArray -> GraphPrimitiveArrayRecord(this, indexedObject, objectId)
-    }
-  }
-
-  fun computeShallowSize(graphObject: GraphObjectRecord): Int {
-    return when (graphObject) {
-      is GraphInstanceRecord -> graphObject.instanceClass.instanceSize
-      is GraphObjectArrayRecord -> graphObject.readRecord().elementIds.size * index.idSize
-      is GraphPrimitiveArrayRecord -> when (val record = graphObject.readRecord()) {
-        is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
-        is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
-        is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
-        is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
-        is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
-        is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
-        is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
-        is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
-      }
-      is GraphClassRecord -> throw IllegalStateException(
-          "Unexpected record ${graphObject.readRecord()}"
-      )
-    }
-  }
-
-  fun instanceSequence(): Sequence<GraphInstanceRecord> {
-    return index.indexedInstanceSequence()
-        .map {
-          val objectId = it.first
-          val indexedObject = it.second
-          val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
-          GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
-        }
-  }
-
-  fun classSequence(): Sequence<GraphClassRecord> {
-    return index.indexedClassSequence()
-        .map {
-          val objectId = it.first
-          val indexedObject = it.second
-          GraphClassRecord(this, indexedObject, objectId)
-        }
-  }
-
-  fun sizeOfFieldType(hprofType: Int) = index.sizeOfFieldType(hprofType)
-
-  internal fun fieldName(fieldRecord: FieldRecord): String {
-    return index.hprofStringById(fieldRecord.nameStringId)
-  }
-
-  internal fun staticFieldName(fieldRecord: StaticFieldRecord): String {
-    return index.hprofStringById(fieldRecord.nameStringId)
-  }
-
-  internal fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
-    val buffer = Buffer()
-    buffer.write(record.fieldValues)
-
-    val reader = HprofReader(buffer, 0, index.idSize)
-
-    return object : FieldValuesReader {
-      override fun readValue(field: FieldRecord): HeapValue {
-        return reader.readValue(field.type)
-      }
-    }
-  }
-
-  internal fun className(classId: Long): String {
-    return index.className(classId)
-  }
-
-  internal fun readObjectArrayDumpRecord(
-    objectId: Long,
-    indexedObject: IndexedObjectArray
-  ): ObjectArrayDumpRecord {
-    return readObjectRecord(objectId, indexedObject) {
-      reader.readObjectArrayDumpRecord()
-    }
-  }
-
-  internal fun readPrimitiveArrayDumpRecord(
-    objectId: Long,
-    indexedObject: IndexedPrimitiveArray
-  ): PrimitiveArrayDumpRecord {
-    return readObjectRecord(objectId, indexedObject) {
-      reader.readPrimitiveArrayDumpRecord()
-    }
-  }
-
-  internal fun readClassDumpRecord(
-    objectId: Long,
-    indexedObject: IndexedClass
-  ): ClassDumpRecord {
-    return readObjectRecord(objectId, indexedObject) {
-      reader.readClassDumpRecord()
-    }
-  }
-
-  internal fun readInstanceDumpRecord(
-    objectId: Long,
-    indexedObject: IndexedInstance
-  ): InstanceDumpRecord {
-    return readObjectRecord(objectId, indexedObject) {
-      reader.readInstanceDumpRecord()
-    }
-  }
-
-  private fun <T : ObjectRecord> readObjectRecord(
-    objectId: Long,
-    indexedObject: IndexedObject,
-    readBlock: () -> T
-  ): T {
-    val objectRecordOrNull = objectCache[objectId]
-    @Suppress("UNCHECKED_CAST")
-    if (objectRecordOrNull != null) {
-      return objectRecordOrNull as T
-    }
-    reader.moveTo(indexedObject.position)
-    return readBlock().apply { objectCache.put(objectId, this) }
-  }
-
-  companion object {
-    fun readHprof(
-      heapDump: File,
-      vararg onRecordListeners: OnRecordListener
-    ): Pair<HprofGraph, Closeable> {
-      val indexListener = HprofInMemoryIndex.createOnRecordListener()
-
-      val parser = HprofPushRecordsParser()
-
-      val reader = parser.readHprofRecords(heapDump, setOf(indexListener) + onRecordListeners)
-
-      val hprofGraph = HprofGraph(reader, indexListener.buildIndex())
-
-      return hprofGraph to reader
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
deleted file mode 100644
index 10b6847f..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
+++ /dev/null
@@ -1,658 +0,0 @@
-package leakcanary
-
-import leakcanary.GcRoot.Debugger
-import leakcanary.GcRoot.Finalizing
-import leakcanary.GcRoot.InternedString
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.ReferenceCleanup
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GcRoot.Unknown
-import leakcanary.GcRoot.Unreachable
-import leakcanary.GcRoot.VmInternal
-import leakcanary.HprofReader.Companion.INT_SIZE
-import leakcanary.HprofReader.Companion.LONG_SIZE
-import leakcanary.Record.HeapDumpEndRecord
-import leakcanary.Record.HeapDumpRecord
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StackFrameRecord
-import leakcanary.Record.StackTraceRecord
-import leakcanary.Record.StringRecord
-import okio.buffer
-import okio.source
-import java.io.File
-import kotlin.reflect.KClass
-
-/**
- * A streaming push heap dump parser.
- *
- * Expected usage: call [readHprofRecords] once, which will go read through the entire heap dump
- * and notify the provided listener of records found.
- *
- * This class is not thread safe, should be used from a single thread.
- *
- * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
- *
- * The Android Hprof format differs in some ways from that reference. This parser implementation
- * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
- */
-class HprofPushRecordsParser {
-
-  interface OnRecordListener {
-    fun recordTypes(): Set<KClass<out Record>>
-
-    fun onTypeSizesAvailable(typeSizes: Map<Int, Int>)
-
-    fun onRecord(
-      position: Long,
-      record: Record
-    )
-  }
-
-  fun readHprofRecords(
-    heapDump: File,
-    listeners: Set<OnRecordListener>
-  ): SeekableHprofReader {
-    if (heapDump.length() == 0L) {
-      throw IllegalArgumentException("Heap dump file is 0 byte length")
-    }
-    val inputStream = heapDump.inputStream()
-    val channel = inputStream.channel
-    val source = inputStream.source()
-        .buffer()
-
-    val endOfVersionString = source.indexOf(0)
-    source.skip(endOfVersionString + 1)
-    val idSize = source.readInt()
-    val startPosition = endOfVersionString + 1 + 4
-
-    val reader = SeekableHprofReader(channel, source, startPosition, idSize)
-
-    listeners.forEach { it.onTypeSizesAvailable(reader.typeSizes) }
-
-    reader.readHprofRecords(listeners)
-    return reader
-  }
-
-  private fun SeekableHprofReader.readHprofRecords(listeners: Set<OnRecordListener>) {
-
-    val readStringRecord = mutableSetOf<OnRecordListener>()
-    val readLoadClassRecord = mutableSetOf<OnRecordListener>()
-    val readStackFrameRecord = mutableSetOf<OnRecordListener>()
-    val readStackTraceRecord = mutableSetOf<OnRecordListener>()
-    val readGcRootRecord = mutableSetOf<OnRecordListener>()
-    val readClassDumpRecord = mutableSetOf<OnRecordListener>()
-    val readInstanceDumpRecord = mutableSetOf<OnRecordListener>()
-    val readObjectArrayDumpRecord = mutableSetOf<OnRecordListener>()
-    val readPrimitiveArrayDumpRecord = mutableSetOf<OnRecordListener>()
-    val readHeapDumpInfoRecord = mutableSetOf<OnRecordListener>()
-    val readHeapDumpEnd = mutableSetOf<OnRecordListener>()
-
-    for (listener in listeners) {
-      val config = listener.recordTypes()
-      config.forEach { recordClass ->
-        when (recordClass) {
-          Record::class -> {
-            readStringRecord += listener
-            readLoadClassRecord += listener
-            readStackFrameRecord += listener
-            readStackTraceRecord += listener
-            readGcRootRecord += listener
-            readClassDumpRecord += listener
-            readInstanceDumpRecord += listener
-            readObjectArrayDumpRecord += listener
-            readPrimitiveArrayDumpRecord += listener
-            readHeapDumpInfoRecord += listener
-            readHeapDumpEnd += listener
-          }
-          StringRecord::class -> {
-            readStringRecord += listener
-          }
-          LoadClassRecord::class -> {
-            readLoadClassRecord += listener
-          }
-          HeapDumpEndRecord::class -> {
-            readHeapDumpEnd += listener
-          }
-          StackFrameRecord::class -> {
-            readStackFrameRecord += listener
-          }
-          StackTraceRecord::class -> {
-            readStackTraceRecord += listener
-          }
-          HeapDumpRecord::class -> {
-            readGcRootRecord += listener
-            readClassDumpRecord += listener
-            readInstanceDumpRecord += listener
-            readObjectArrayDumpRecord += listener
-            readPrimitiveArrayDumpRecord += listener
-            readHeapDumpInfoRecord += listener
-          }
-          GcRootRecord::class -> {
-            readGcRootRecord += listener
-          }
-          ObjectRecord::class -> {
-            readClassDumpRecord += listener
-            readInstanceDumpRecord += listener
-            readObjectArrayDumpRecord += listener
-            readPrimitiveArrayDumpRecord += listener
-          }
-          ClassDumpRecord::class -> {
-            readClassDumpRecord += listener
-          }
-          InstanceDumpRecord::class -> {
-            readInstanceDumpRecord += listener
-          }
-          ObjectArrayDumpRecord::class -> {
-            readObjectArrayDumpRecord += listener
-          }
-          PrimitiveArrayDumpRecord::class -> {
-            readPrimitiveArrayDumpRecord += listener
-          }
-          HeapDumpInfoRecord::class -> {
-            readHeapDumpInfoRecord += listener
-          }
-        }
-      }
-    }
-
-    // heap dump timestamp
-    skip(LONG_SIZE)
-
-    while (!exhausted()) {
-      // type of the record
-      val tag = readUnsignedByte()
-
-      // number of microseconds since the time stamp in the header
-      skip(INT_SIZE)
-
-      // number of bytes that follow and belong to this record
-      val length = readUnsignedInt()
-
-      when (tag) {
-        STRING_IN_UTF8 -> {
-          if (readStringRecord.isNotEmpty()) {
-            val recordPosition = position
-            val id = readId()
-            val stringLength = length - idSize
-            val string = readUtf8(stringLength)
-            val record = StringRecord(id, string)
-            readStringRecord.forEach { it.onRecord(recordPosition, record) }
-          } else {
-            skip(length)
-          }
-        }
-        LOAD_CLASS -> {
-          if (readLoadClassRecord.isNotEmpty()) {
-            val recordPosition = position
-            val classSerialNumber = readInt()
-            val id = readId()
-            val stackTraceSerialNumber = readInt()
-            val classNameStringId = readId()
-            val record = LoadClassRecord(
-                classSerialNumber = classSerialNumber,
-                id = id,
-                stackTraceSerialNumber = stackTraceSerialNumber,
-                classNameStringId = classNameStringId
-            )
-            readLoadClassRecord.forEach {
-              it.onRecord(recordPosition, record)
-            }
-          } else {
-            skip(length)
-          }
-        }
-        STACK_FRAME -> {
-          if (readStackFrameRecord.isNotEmpty()) {
-            val recordPosition = position
-            val record = StackFrameRecord(
-                id = readId(),
-                methodNameStringId = readId(),
-                methodSignatureStringId = readId(),
-                sourceFileNameStringId = readId(),
-                classSerialNumber = readInt(),
-                lineNumber = readInt()
-            )
-            readStackFrameRecord.forEach {
-              it.onRecord(recordPosition, record)
-            }
-          } else {
-            skip(length)
-          }
-        }
-        STACK_TRACE -> {
-          if (readStackTraceRecord.isNotEmpty()) {
-            val recordPosition = position
-            val stackTraceSerialNumber = readInt()
-            val threadSerialNumber = readInt()
-            val frameCount = readInt()
-            val stackFrameIds = readIdArray(frameCount)
-            val record = StackTraceRecord(
-                stackTraceSerialNumber = stackTraceSerialNumber,
-                threadSerialNumber = threadSerialNumber,
-                stackFrameIds = stackFrameIds
-            )
-            readStackTraceRecord.forEach {
-              it.onRecord(recordPosition, record)
-            }
-          } else {
-            skip(length)
-          }
-        }
-        HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
-          val heapDumpStart = position
-          var previousTag = 0
-          while (position - heapDumpStart < length) {
-            val heapDumpTag = readUnsignedByte()
-
-            when (heapDumpTag) {
-              ROOT_UNKNOWN -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val record = GcRootRecord(gcRoot = Unknown(id = readId()))
-                  readGcRootRecord.forEach { it.onRecord(recordPosition, record) }
-                } else {
-                  skip(idSize)
-                }
-              }
-              ROOT_JNI_GLOBAL -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord =
-                    GcRootRecord(gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId()))
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + idSize)
-                }
-              }
-
-              ROOT_JNI_LOCAL -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = JniLocal(
-                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
-                      )
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_JAVA_FRAME -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = JavaFrame(
-                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
-                      )
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_NATIVE_STACK -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE)
-                }
-              }
-
-              ROOT_STICKY_CLASS -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = StickyClass(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              // An object that was referenced from an active thread block.
-              ROOT_THREAD_BLOCK -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE)
-                }
-              }
-
-              ROOT_MONITOR_USED -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = MonitorUsed(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_THREAD_OBJECT -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = ThreadObject(
-                          id = readId(),
-                          threadSerialNumber = readInt(),
-                          stackTraceSerialNumber = readInt()
-                      )
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_INTERNED_STRING -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(gcRoot = InternedString(id = readId()))
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_FINALIZING -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = Finalizing(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_DEBUGGER -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = Debugger(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_REFERENCE_CLEANUP -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = ReferenceCleanup(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_VM_INTERNAL -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = VmInternal(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_JNI_MONITOR -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = JniMonitor(
-                          id = readId(), stackTraceSerialNumber = readInt(),
-                          stackDepth = readInt()
-                      )
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_UNREACHABLE -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = Unreachable(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-              CLASS_DUMP -> {
-                if (readClassDumpRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val record = readClassDumpRecord()
-                  readClassDumpRecord.forEach {
-                    it.onRecord(recordPosition, record)
-                  }
-                } else {
-                  skipClassDumpRecord()
-                }
-              }
-
-              INSTANCE_DUMP -> {
-                if (readInstanceDumpRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val instanceDumpRecord = readInstanceDumpRecord()
-                  readInstanceDumpRecord.forEach {
-                    it.onRecord(recordPosition, instanceDumpRecord)
-                  }
-                } else {
-                  skipInstanceDumpRecord()
-                }
-              }
-
-              OBJECT_ARRAY_DUMP -> {
-                if (readObjectArrayDumpRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val arrayRecord = readObjectArrayDumpRecord()
-                  readObjectArrayDumpRecord.forEach {
-                    it.onRecord(recordPosition, arrayRecord)
-                  }
-                } else {
-                  skipObjectArrayDumpRecord()
-                }
-              }
-
-              PRIMITIVE_ARRAY_DUMP -> {
-                if (readPrimitiveArrayDumpRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val record = readPrimitiveArrayDumpRecord()
-                  readPrimitiveArrayDumpRecord.forEach {
-                    it.onRecord(recordPosition, record)
-                  }
-                } else {
-                  skipPrimitiveArrayDumpRecord()
-                }
-              }
-
-              PRIMITIVE_ARRAY_NODATA -> {
-                throw UnsupportedOperationException("PRIMITIVE_ARRAY_NODATA cannot be parsed")
-              }
-
-              HEAP_DUMP_INFO -> {
-                if (readHeapDumpInfoRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val record = readHeapDumpInfoRecord()
-                  readHeapDumpInfoRecord.forEach {
-                    it.onRecord(recordPosition, record)
-                  }
-                } else {
-                  skipHeapDumpInfoRecord()
-                }
-              }
-
-              else -> throw IllegalStateException(
-                  "Unknown tag $heapDumpTag after $previousTag"
-              )
-            }
-            previousTag = heapDumpTag
-          }
-        }
-        HEAP_DUMP_END -> {
-          if (readHeapDumpEnd.isNotEmpty()) {
-            val recordPosition = position
-            val record = HeapDumpEndRecord
-            readHeapDumpEnd.forEach {
-              it.onRecord(recordPosition, record)
-            }
-          }
-        }
-        else -> {
-          skip(length)
-        }
-      }
-    }
-  }
-
-  companion object {
-    internal const val STRING_IN_UTF8 = 0x01
-    internal const val LOAD_CLASS = 0x02
-    internal const val UNLOAD_CLASS = 0x03
-    internal const val STACK_FRAME = 0x04
-    internal const val STACK_TRACE = 0x05
-    internal const val ALLOC_SITES = 0x06
-    internal const val HEAP_SUMMARY = 0x07
-    // TODO Maybe parse this?
-    internal const val START_THREAD = 0x0a
-    internal const val END_THREAD = 0x0b
-    internal const val HEAP_DUMP = 0x0c
-    internal const val HEAP_DUMP_SEGMENT = 0x1c
-    internal const val HEAP_DUMP_END = 0x2c
-    internal const val CPU_SAMPLES = 0x0d
-    internal const val CONTROL_SETTINGS = 0x0e
-    internal const val ROOT_UNKNOWN = 0xff
-    internal const val ROOT_JNI_GLOBAL = 0x01
-    internal const val ROOT_JNI_LOCAL = 0x02
-    internal const val ROOT_JAVA_FRAME = 0x03
-    internal const val ROOT_NATIVE_STACK = 0x04
-    internal const val ROOT_STICKY_CLASS = 0x05
-    internal const val ROOT_THREAD_BLOCK = 0x06
-    internal const val ROOT_MONITOR_USED = 0x07
-    internal const val ROOT_THREAD_OBJECT = 0x08
-    internal const val CLASS_DUMP = 0x20
-    internal const val INSTANCE_DUMP = 0x21
-    internal const val OBJECT_ARRAY_DUMP = 0x22
-    internal const val PRIMITIVE_ARRAY_DUMP = 0x23
-
-    /**
-     * Android format addition
-     *
-     * Specifies information about which heap certain objects came from. When a sub-tag of this type
-     * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
-     * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
-     * HEAP_DUMP[_SEGMENT].  Multiple HEAP_DUMP_INFO entries may appear in a single
-     * HEAP_DUMP[_SEGMENT].
-     *
-     * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
-     */
-    internal const val HEAP_DUMP_INFO = 0xfe
-    internal const val ROOT_INTERNED_STRING = 0x89
-    internal const val ROOT_FINALIZING = 0x8a
-    internal const val ROOT_DEBUGGER = 0x8b
-    internal const val ROOT_REFERENCE_CLEANUP = 0x8c
-    internal const val ROOT_VM_INTERNAL = 0x8d
-    internal const val ROOT_JNI_MONITOR = 0x8e
-    internal const val ROOT_UNREACHABLE = 0x90
-    internal const val PRIMITIVE_ARRAY_NODATA = 0xc3
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
deleted file mode 100644
index 596228ef..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
+++ /dev/null
@@ -1,411 +0,0 @@
-package leakcanary
-
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import okio.BufferedSource
-import java.io.Closeable
-import java.nio.charset.Charset
-
-/**
- * Not thread safe, should be used from a single thread.
- */
-open class HprofReader constructor(
-  protected var source: BufferedSource,
-  protected val startPosition: Long,
-  val idSize: Int
-): Closeable {
-  override fun close() {
-    source.close()
-  }
-
-  var position: Long = startPosition
-    protected set
-
-  val isOpen
-    get() = source.isOpen
-
-  val typeSizes = mapOf(
-      // object
-      OBJECT_TYPE to idSize,
-      BOOLEAN_TYPE to BOOLEAN_SIZE,
-      CHAR_TYPE to CHAR_SIZE,
-      FLOAT_TYPE to FLOAT_SIZE,
-      DOUBLE_TYPE to DOUBLE_SIZE,
-      BYTE_TYPE to BYTE_SIZE,
-      SHORT_TYPE to SHORT_SIZE,
-      INT_TYPE to INT_SIZE,
-      LONG_TYPE to LONG_SIZE
-  )
-
-  fun readValue(type: Int): HeapValue {
-    return when (type) {
-      OBJECT_TYPE -> ObjectReference(readId())
-      BOOLEAN_TYPE -> BooleanValue(readBoolean())
-      CHAR_TYPE -> CharValue(readChar())
-      FLOAT_TYPE -> FloatValue(readFloat())
-      DOUBLE_TYPE -> DoubleValue(readDouble())
-      BYTE_TYPE -> ByteValue(readByte())
-      SHORT_TYPE -> ShortValue(readShort())
-      INT_TYPE -> IntValue(readInt())
-      LONG_TYPE -> LongValue(readLong())
-      else -> throw IllegalStateException("Unknown type $type")
-    }
-  }
-
-  fun typeSize(type: Int): Int {
-    return typeSizes.getValue(type)
-  }
-
-  fun readShort(): Short {
-    position += SHORT_SIZE
-    return source.readShort()
-  }
-
-  fun readInt(): Int {
-    position += INT_SIZE
-    return source.readInt()
-  }
-
-  fun readIdArray(arrayLength: Int): LongArray {
-    return LongArray(arrayLength) { readId() }
-  }
-
-  fun readBooleanArray(arrayLength: Int): BooleanArray {
-    return BooleanArray(arrayLength) { readByte().toInt() != 0 }
-  }
-
-  fun readCharArray(arrayLength: Int): CharArray {
-    return readString(CHAR_SIZE * arrayLength, Charsets.UTF_16BE).toCharArray()
-  }
-
-  fun readString(
-    byteCount: Int,
-    charset: Charset
-  ): String {
-    position += byteCount
-    return source.readString(byteCount.toLong(), charset)
-  }
-
-  fun readFloatArray(arrayLength: Int): FloatArray {
-    return FloatArray(arrayLength) { readFloat() }
-  }
-
-  fun readDoubleArray(arrayLength: Int): DoubleArray {
-    return DoubleArray(arrayLength) { readDouble() }
-  }
-
-  fun readShortArray(arrayLength: Int): ShortArray {
-    return ShortArray(arrayLength) { readShort() }
-  }
-
-  fun readIntArray(arrayLength: Int): IntArray {
-    return IntArray(arrayLength) { readInt() }
-  }
-
-  fun readLongArray(arrayLength: Int): LongArray {
-    return LongArray(arrayLength) { readLong() }
-  }
-
-  fun readLong(): Long {
-    position += LONG_SIZE
-    return source.readLong()
-  }
-
-  fun exhausted() = source.exhausted()
-
-  open fun skip(byteCount: Long) {
-    position += byteCount
-    return source.skip(byteCount)
-  }
-
-  fun readByte(): Byte {
-    position += BYTE_SIZE
-    return source.readByte()
-  }
-
-  fun readBoolean(): Boolean {
-    position += BOOLEAN_SIZE
-    return source.readByte().toInt() != 0
-  }
-
-  fun readByteArray(byteCount: Int): ByteArray {
-    position += byteCount
-    return source.readByteArray(byteCount.toLong())
-  }
-
-  fun readChar(): Char {
-    return readString(CHAR_SIZE, Charsets.UTF_16BE)[0]
-  }
-
-  fun readFloat(): Float {
-    return Float.fromBits(readInt())
-  }
-
-  fun readDouble(): Double {
-    return Double.fromBits(readLong())
-  }
-
-  fun readId(): Long {
-    // As long as we don't interpret IDs, reading signed values here is fine.
-    return when (idSize) {
-      1 -> readByte().toLong()
-      2 -> readShort().toLong()
-      4 -> readInt().toLong()
-      8 -> readLong()
-      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
-    }
-  }
-
-  fun readUtf8(byteCount: Long): String {
-    position += byteCount
-    return source.readUtf8(byteCount)
-  }
-
-  fun readUnsignedInt(): Long {
-    return readInt().toLong() and INT_MASK
-  }
-
-  fun readUnsignedByte(): Int {
-    return readByte().toInt() and BYTE_MASK
-  }
-
-  fun readUnsignedShort(): Int {
-    return readShort().toInt() and 0xFFFF
-  }
-
-  fun skip(byteCount: Int) {
-    position += byteCount
-    return source.skip(byteCount.toLong())
-  }
-
-  fun readInstanceDumpRecord(): InstanceDumpRecord {
-    val id = readId()
-    val stackTraceSerialNumber = readInt()
-    val classId = readId()
-    val remainingBytesInInstance = readInt()
-    val fieldValues = readByteArray(remainingBytesInInstance)
-    return InstanceDumpRecord(
-        id = id,
-        stackTraceSerialNumber = stackTraceSerialNumber,
-        classId = classId,
-        fieldValues = fieldValues
-    )
-  }
-
-  fun readClassDumpRecord(): ClassDumpRecord {
-    val id = readId()
-    // stack trace serial number
-    val stackTraceSerialNumber = readInt()
-    val superClassId = readId()
-    // class loader object ID
-    val classLoaderId = readId()
-    // signers object ID
-    val signersId = readId()
-    // protection domain object ID
-    val protectionDomainId = readId()
-    // reserved
-    readId()
-    // reserved
-    readId()
-
-    // instance size (in bytes)
-    // Useful to compute retained size
-    val instanceSize = readInt()
-
-    // Skip over the constant pool
-    val constantPoolCount = readUnsignedShort()
-    for (i in 0 until constantPoolCount) {
-      // constant pool index
-      skip(SHORT_SIZE)
-      skip(typeSize(readUnsignedByte()))
-    }
-
-    val staticFieldCount = readUnsignedShort()
-    val staticFields = ArrayList<StaticFieldRecord>(staticFieldCount)
-    for (i in 0 until staticFieldCount) {
-
-      val nameStringId = readId()
-      val type = readUnsignedByte()
-      val value = readValue(type)
-
-      staticFields.add(
-          StaticFieldRecord(
-              nameStringId = nameStringId,
-              type = type,
-              value = value
-          )
-      )
-    }
-
-    val fieldCount = readUnsignedShort()
-    val fields = ArrayList<FieldRecord>(fieldCount)
-    for (i in 0 until fieldCount) {
-      fields.add(FieldRecord(nameStringId = readId(), type = readUnsignedByte()))
-    }
-
-    return ClassDumpRecord(
-        id = id,
-        stackTraceSerialNumber = stackTraceSerialNumber,
-        superClassId = superClassId,
-        classLoaderId = classLoaderId,
-        signersId = signersId,
-        protectionDomainId = protectionDomainId,
-        instanceSize = instanceSize,
-        staticFields = staticFields,
-        fields = fields
-    )
-  }
-
-  fun skipInstanceDumpRecord() {
-    skip(idSize + INT_SIZE + idSize)
-    val remainingBytesInInstance = readInt()
-    skip(remainingBytesInInstance)
-  }
-
-  fun skipClassDumpRecord() {
-    skip(
-        idSize + INT_SIZE + idSize + idSize + idSize + idSize + idSize + idSize + INT_SIZE
-    )
-    // Skip over the constant pool
-    val constantPoolCount = readUnsignedShort()
-    for (i in 0 until constantPoolCount) {
-      // constant pool index
-      skip(SHORT_SIZE)
-      skip(typeSize(readUnsignedByte()))
-    }
-
-    val staticFieldCount = readUnsignedShort()
-
-    for (i in 0 until staticFieldCount) {
-      skip(idSize)
-      val type = readUnsignedByte()
-      skip(typeSize(type))
-    }
-
-    val fieldCount = readUnsignedShort()
-    skip(fieldCount * (idSize + BYTE_SIZE))
-  }
-
-  fun readObjectArrayDumpRecord(
-  ): ObjectArrayDumpRecord {
-    val id = readId()
-    // stack trace serial number
-    val stackTraceSerialNumber = readInt()
-    val arrayLength = readInt()
-    val arrayClassId = readId()
-    val elementIds = readIdArray(arrayLength)
-    return ObjectArrayDumpRecord(
-        id = id,
-        stackTraceSerialNumber = stackTraceSerialNumber,
-        arrayClassId = arrayClassId,
-        elementIds = elementIds
-    )
-  }
-
-  fun skipObjectArrayDumpRecord() {
-    skip(idSize + INT_SIZE)
-    val arrayLength = readInt()
-    skip(idSize + arrayLength * idSize)
-  }
-
-  fun readPrimitiveArrayDumpRecord(): PrimitiveArrayDumpRecord {
-    val id = readId()
-    val stackTraceSerialNumber = readInt()
-    // length
-    val arrayLength = readInt()
-    val type = readUnsignedByte()
-    return when (type) {
-      BOOLEAN_TYPE -> BooleanArrayDump(
-          id, stackTraceSerialNumber, readBooleanArray(arrayLength)
-      )
-      CHAR_TYPE -> CharArrayDump(
-          id, stackTraceSerialNumber, readCharArray(arrayLength)
-      )
-      FLOAT_TYPE -> FloatArrayDump(
-          id, stackTraceSerialNumber, readFloatArray(arrayLength)
-      )
-      DOUBLE_TYPE -> DoubleArrayDump(
-          id, stackTraceSerialNumber, readDoubleArray(arrayLength)
-      )
-      BYTE_TYPE -> ByteArrayDump(
-          id, stackTraceSerialNumber, readByteArray(arrayLength)
-      )
-      SHORT_TYPE -> ShortArrayDump(
-          id, stackTraceSerialNumber, readShortArray(arrayLength)
-      )
-      INT_TYPE -> IntArrayDump(
-          id, stackTraceSerialNumber, readIntArray(arrayLength)
-      )
-      LONG_TYPE -> LongArrayDump(
-          id, stackTraceSerialNumber, readLongArray(arrayLength)
-      )
-      else -> throw IllegalStateException("Unexpected type $type")
-    }
-  }
-
-  fun skipPrimitiveArrayDumpRecord() {
-    skip(idSize + INT_SIZE)
-    val arrayLength = readInt()
-    val type = readUnsignedByte()
-    skip(idSize + arrayLength * typeSize(type))
-  }
-
-  fun readHeapDumpInfoRecord(): HeapDumpInfoRecord {
-    val heapId = readInt()
-    return HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
-  }
-
-  fun skipHeapDumpInfoRecord() {
-    skip(idSize + idSize)
-  }
-
-  val tagPositionAfterReadingId
-    get() = position - (idSize + BYTE_SIZE)
-
-  companion object {
-    const val BOOLEAN_SIZE = 1
-    const val CHAR_SIZE = 2
-    const val FLOAT_SIZE = 4
-    const val DOUBLE_SIZE = 8
-    const val BYTE_SIZE = 1
-    const val SHORT_SIZE = 2
-    const val INT_SIZE = 4
-    const val LONG_SIZE = 8
-
-    const val OBJECT_TYPE = 2
-    const val BOOLEAN_TYPE = 4
-    const val CHAR_TYPE = 5
-    const val FLOAT_TYPE = 6
-    const val DOUBLE_TYPE = 7
-    const val BYTE_TYPE = 8
-    const val SHORT_TYPE = 9
-    const val INT_TYPE = 10
-    const val LONG_TYPE = 11
-
-    const val INT_MASK = 0xffffffffL
-    const val BYTE_MASK = 0xff
-  }
-
-}
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
deleted file mode 100644
index f3d730f9..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HydratedClass.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-package leakcanary
-
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-
-class HydratedClass(
-  val record: ClassDumpRecord,
-  val className: String,
-  val staticFieldNames: List<String>,
-  val fieldNames: List<String>
-) {
-  inline fun <reified T : HeapValue> staticFieldValue(name: String): T {
-    return staticFieldValueOrNull(name) ?: throw IllegalArgumentException(
-        "Could not find static field $name in class $className with id ${record.id} and static fields $staticFieldNames"
-    )
-  }
-
-  fun fieldType(name: String): Int {
-    fieldNames.forEachIndexed { index, fieldName ->
-      if (fieldName == name) {
-        return record.fields[index].type
-      }
-    }
-    throw IllegalArgumentException(
-        "Could not find field $name in class $className with id ${record.id} and fields $fieldNames"
-    )
-  }
-
-  inline fun <reified T : HeapValue> staticFieldValueOrNull(name: String): T? {
-    staticFieldNames.forEachIndexed { fieldIndex, fieldName ->
-      if (fieldName == name) {
-        val fieldValue = record.staticFields[fieldIndex].value
-        return if (fieldValue is T) {
-          fieldValue
-        } else null
-      }
-    }
-    return null
-  }
-
-  operator fun get(name: String): HeapValue? = staticFieldValueOrNull(name)
-
-  fun hasStaticField(name: String): Boolean {
-    staticFieldNames.forEach { fieldName ->
-      if (fieldName == name) {
-        return true
-      }
-    }
-    return false
-  }
-
-  val simpleClassName: String
-    get() {
-      val separator = className.lastIndexOf('.')
-      return if (separator == -1) {
-        className
-      } else {
-        className.substring(separator + 1)
-      }
-    }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt b/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
deleted file mode 100644
index 87affe41..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HydratedInstance.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-package leakcanary
-
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-
-class HydratedInstance(
-  val record: InstanceDumpRecord,
-  val classHierarchy: List<HydratedClass>,
-  /**
-   * One list of field values per class
-   */
-  val fieldValues: List<List<HeapValue>>
-) {
-  inline fun <reified T : HeapValue> fieldValue(name: String): T {
-    return fieldValueOrNull(name) ?: throw IllegalArgumentException(
-        "Could not find field $name in instance with id ${record.id}"
-    )
-  }
-
-  inline fun <reified T : HeapValue> fieldValueOrNull(name: String): T? {
-    classHierarchy.forEachIndexed { classIndex, hydratedClass ->
-      hydratedClass.fieldNames.forEachIndexed { fieldIndex, fieldName ->
-        if (fieldName == name) {
-          val fieldValue = fieldValues[classIndex][fieldIndex]
-          return if (fieldValue is T) {
-            fieldValue
-          } else null
-        }
-      }
-    }
-    return null
-  }
-
-  operator fun get(name: String): HeapValue? = fieldValueOrNull(name)
-
-  fun hasField(name: String): Boolean {
-    classHierarchy.forEach { hydratedClass ->
-      hydratedClass.fieldNames.forEach { fieldName ->
-        if (fieldName == name) {
-          return true
-        }
-      }
-    }
-    return false
-  }
-
-  fun isInstanceOf(className: String): Boolean {
-    return classHierarchy.any { it.className == className }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt b/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt
deleted file mode 100644
index f809124d..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-package leakcanary
-
-enum class PrimitiveType {
-  BOOLEAN,
-  CHAR,
-  FLOAT,
-  DOUBLE,
-  BYTE,
-  SHORT,
-  INT,
-  LONG
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
deleted file mode 100644
index d5ec5a22..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
+++ /dev/null
@@ -1,25 +0,0 @@
-package leakcanary
-
-import okio.BufferedSource
-import java.nio.channels.FileChannel
-
-class SeekableHprofReader(
-  private val channel: FileChannel,
-  source: BufferedSource,
-  startPosition: Long,
-  idSize: Int
-) : HprofReader(source, startPosition, idSize) {
-
-  fun moveTo(newPosition: Long) {
-    if (position == newPosition) {
-      return
-    }
-    source.buffer.clear()
-    channel.position(newPosition)
-    position = newPosition
-  }
-
-  fun reset() {
-    moveTo(startPosition)
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt b/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
deleted file mode 100644
index 031e1c9a..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
+++ /dev/null
@@ -1,193 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.HprofReader
-import leakcanary.PrimitiveType
-import leakcanary.Record
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StringRecord
-import leakcanary.internal.IndexedObject.IndexedClass
-import leakcanary.internal.IndexedObject.IndexedInstance
-import leakcanary.internal.IndexedObject.IndexedObjectArray
-import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
-import kotlin.reflect.KClass
-
-/**
- * This class is not thread safe, should be used from a single thread.
- */
-internal class HprofInMemoryIndex private constructor(
-  private val hprofStringCache: LongToStringSparseArray,
-  private val classNames: LongToLongSparseArray,
-  private val objectIndex: LongToObjectSparseArray<IndexedObject>,
-  private val typeSizes: Map<Int, Int>,
-  val primitiveWrapperTypes: Set<Long>
-) {
-  val idSize: Int
-    get() = typeSizes.getValue(HprofReader.OBJECT_TYPE)
-
-  fun sizeOfFieldType(hprofType: Int): Int = typeSizes.getValue(hprofType)
-
-  fun hprofStringById(id: Long): String {
-    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
-  }
-
-  fun className(classId: Long): String {
-    // String, primitive types
-    return hprofStringById(classNames[classId])
-  }
-
-  fun classId(className: String): Long? {
-    // Note: this performs two linear scans over arrays
-    return hprofStringCache.getKey(className)
-        ?.let { stringId -> classNames.getKey(stringId) }
-  }
-
-  fun indexedClassSequence(): Sequence<Pair<Long, IndexedClass>> {
-    return objectIndex.entrySequence()
-        .filter { it.second is IndexedClass }
-        .map { it.first to it.second as IndexedClass }
-  }
-
-  fun indexedInstanceSequence(): Sequence<Pair<Long, IndexedInstance>> {
-    return objectIndex.entrySequence()
-        .filter { it.second is IndexedInstance }
-        .map { it.first to it.second as IndexedInstance }
-  }
-
-  fun indexedObject(objectId: Long): IndexedObject {
-    return objectIndex[objectId]
-  }
-
-  class Builder : OnRecordListener {
-    /**
-     * Map of string id to string
-     * This currently keeps all the hprof strings that we could care about: class names,
-     * static field names and instance fields names
-     */
-    // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
-    // memory.
-    // Another option is to switch back to reading from the file system as necessary, and keep a much
-    // smaller cache for strings we need during shortest path (those are for exclusions)
-    private val hprofStringCache = LongToStringSparseArray(60000)
-
-    /**
-     * class id to string id
-     */
-    private val classNames = LongToLongSparseArray(20000)
-
-    /**
-     * Object id to [IndexedObject].
-     * The id can be for classes instances, classes, object arrays and primitive arrays
-     */
-    private val objectIndex = LongToObjectSparseArray<IndexedObject>(250000)
-
-    /**
-     * Class ids for primitive wrapper types
-     */
-    private val primitiveWrapperTypes = mutableSetOf<Long>()
-
-    /**
-     * String ids for class names of primitive wrapper types
-     */
-    private val primitiveWrapperClassNames = mutableSetOf<Long>()
-
-    private lateinit var typeSizes: Map<Int, Int>
-    private var consumed = false
-
-    override fun recordTypes(): Set<KClass<out Record>> = setOf(
-        StringRecord::class,
-        LoadClassRecord::class,
-        ClassDumpRecord::class,
-        InstanceDumpRecord::class,
-        ObjectArrayDumpRecord::class,
-        PrimitiveArrayDumpRecord::class
-    )
-
-    override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
-      this.typeSizes = typeSizes
-    }
-
-    override fun onRecord(
-      position: Long,
-      record: Record
-    ) {
-      if (consumed) {
-        throw IllegalStateException("This builder instance already produced a HprofInMemoryIndex")
-      }
-      when (record) {
-        is StringRecord -> {
-          if (PRIMITIVE_WRAPPER_TYPES.contains(record.string)) {
-            primitiveWrapperClassNames.add(record.id)
-          }
-          hprofStringCache[record.id] = record.string
-        }
-        is LoadClassRecord -> {
-          classNames[record.id] = record.classNameStringId
-          if (primitiveWrapperClassNames.contains(record.classNameStringId)) {
-            primitiveWrapperTypes.add(record.id)
-          }
-        }
-        is ClassDumpRecord -> {
-          objectIndex[record.id] = IndexedClass(position, record.superClassId, record.instanceSize)
-        }
-        is InstanceDumpRecord -> {
-          objectIndex[record.id] =
-            IndexedInstance(position, record.classId)
-        }
-        is ObjectArrayDumpRecord -> {
-          objectIndex[record.id] = IndexedObjectArray(position, record.arrayClassId)
-        }
-        is PrimitiveArrayDumpRecord -> {
-          val primitiveType = when (record) {
-            is BooleanArrayDump -> PrimitiveType.BOOLEAN
-            is CharArrayDump -> PrimitiveType.CHAR
-            is FloatArrayDump -> PrimitiveType.FLOAT
-            is DoubleArrayDump -> PrimitiveType.DOUBLE
-            is ByteArrayDump -> PrimitiveType.BYTE
-            is ShortArrayDump -> PrimitiveType.SHORT
-            is IntArrayDump -> PrimitiveType.INT
-            is LongArrayDump -> PrimitiveType.LONG
-          }
-          objectIndex[record.id] = IndexedPrimitiveArray(position, primitiveType)
-        }
-      }
-    }
-
-    fun buildIndex(): HprofInMemoryIndex {
-      consumed = true
-      // Passing references to avoid copying the underlying data structures.
-      return HprofInMemoryIndex(
-          hprofStringCache, classNames, objectIndex,
-          typeSizes,
-          primitiveWrapperTypes
-      )
-    }
-
-  }
-
-  companion object {
-
-    private val PRIMITIVE_WRAPPER_TYPES = setOf<String>(
-        Boolean::class.java.name, Char::class.java.name, Float::class.java.name,
-        Double::class.java.name, Byte::class.java.name, Short::class.java.name,
-        Int::class.java.name, Long::class.java.name
-    )
-
-    fun createOnRecordListener(): Builder {
-      return Builder()
-    }
-
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
deleted file mode 100644
index 4f701ae1..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
+++ /dev/null
@@ -1,82 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.internal.SparseArrayUtils.appendInt
-import leakcanary.internal.SparseArrayUtils.appendLong
-import leakcanary.internal.SparseArrayUtils.binarySearch
-import leakcanary.internal.SparseArrayUtils.insertInt
-import leakcanary.internal.SparseArrayUtils.insertLong
-
-/**
- * Same as [LongToLongSparseArray] but long to int instead.
- */
-internal class LongToIntSparseArray(initialCapacity: Int) : Cloneable {
-  private var keys: LongArray
-  private var values: IntArray
-
-  var size: Int = 0
-    private set
-
-  init {
-    keys = LongArray(initialCapacity)
-    values = IntArray(initialCapacity)
-    size = 0
-  }
-
-  operator fun get(key: Long): Int {
-    val i = binarySearch(keys, size, key)
-
-    return if (i < 0 || values[i] == DELETED_INT) {
-      DELETED_INT
-    } else {
-      values[i]
-    }
-  }
-
-  operator fun set(
-    key: Long,
-    value: Int
-  ) {
-    require(value != DELETED_INT) {
-      "$DELETED_INT is a magic value that indicates a deleted entry"
-    }
-
-    if (size != 0 && key <= keys[size - 1]) {
-      insert(key, value)
-      return
-    }
-
-    keys = appendLong(keys, size, key)
-    values = appendInt(values, size, value)
-    size++
-  }
-
-  private fun insert(
-    key: Long,
-    value: Int
-  ) {
-    if (value == DELETED_INT) {
-      throw IllegalArgumentException("$DELETED_INT is a special value")
-    }
-    var i = binarySearch(keys, size, key)
-
-    if (i >= 0) {
-      values[i] = value
-    } else {
-      i = i.inv()
-
-      if (i < size && values[i] == DELETED_INT) {
-        keys[i] = key
-        values[i] = value
-        return
-      }
-
-      keys = insertLong(keys, size, i, key)
-      values = insertInt(values, size, i, value)
-      size++
-    }
-  }
-
-  companion object {
-    private const val DELETED_INT = 0
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
deleted file mode 100644
index 4a9dd23c..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
+++ /dev/null
@@ -1,93 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.internal.SparseArrayUtils.appendLong
-import leakcanary.internal.SparseArrayUtils.binarySearch
-import leakcanary.internal.SparseArrayUtils.insertLong
-
-/**
- * Based on android.util.LongSparseArray, but with several tweaks:
- *
- * - Values array is a LongArray
- * - No compaction, ever. This object can only keep growing, until it is garbage collected. Note
- * that there is no remove() method.
- */
-internal class LongToLongSparseArray(initialCapacity: Int) : Cloneable {
-  private var keys: LongArray
-  private var values: LongArray
-
-  var size: Int = 0
-    private set
-
-  init {
-    keys = LongArray(initialCapacity)
-    values = LongArray(initialCapacity)
-    size = 0
-  }
-
-  operator fun get(key: Long): Long {
-    val i = binarySearch(keys, size, key)
-
-    return if (i < 0 || values[i] == DELETED_LONG) {
-      DELETED_LONG
-    } else {
-      values[i]
-    }
-  }
-
-  fun getKey(value: Long): Long? {
-    for (i in 0 until size) {
-      if (values[i] == value) {
-        return keys[i]
-      }
-    }
-    return null
-  }
-
-  operator fun set(
-    key: Long,
-    value: Long
-  ) {
-    require(value != DELETED_LONG) {
-      "$DELETED_LONG is a magic value that indicates a deleted entry"
-    }
-
-    if (size != 0 && key <= keys[size - 1]) {
-      insert(key, value)
-      return
-    }
-
-    keys = appendLong(keys, size, key)
-    values = appendLong(values, size, value)
-    size++
-  }
-
-  private fun insert(
-    key: Long,
-    value: Long
-  ) {
-    if (value == DELETED_LONG) {
-      throw IllegalArgumentException("$DELETED_LONG is a special value")
-    }
-    var i = binarySearch(keys, size, key)
-
-    if (i >= 0) {
-      values[i] = value
-    } else {
-      i = i.inv()
-
-      if (i < size && values[i] == DELETED_LONG) {
-        keys[i] = key
-        values[i] = value
-        return
-      }
-
-      keys = insertLong(keys, size, i, key)
-      values = insertLong(values, size, i, value)
-      size++
-    }
-  }
-
-  companion object {
-    private const val DELETED_LONG: Long = 0
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
deleted file mode 100644
index cf2ff87a..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
+++ /dev/null
@@ -1,77 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.internal.SparseArrayUtils.appendLong
-import leakcanary.internal.SparseArrayUtils.appendObject
-import leakcanary.internal.SparseArrayUtils.binarySearch
-import leakcanary.internal.SparseArrayUtils.insertLong
-import leakcanary.internal.SparseArrayUtils.insertObject
-
-/**
- * Same as [LongToLongSparseArray] but long to object instead.
- */
-internal class LongToObjectSparseArray<T>(initialCapacity: Int) : Cloneable {
-  private var keys: LongArray
-  private var values: Array<T?>
-
-  var size: Int = 0
-    private set
-
-  init {
-    keys = LongArray(initialCapacity)
-    @Suppress("UNCHECKED_CAST")
-    values = arrayOfNulls<Any?>(initialCapacity) as Array<T?>
-    size = 0
-  }
-
-  operator fun get(key: Long): T {
-    val i = binarySearch(keys, size, key)
-
-    return if (i < 0 || values[i] == null) {
-      throw NullPointerException("Key $key not set")
-    } else {
-      values[i]!!
-    }
-  }
-
-  operator fun set(
-    key: Long,
-    value: T
-  ) {
-    if (size != 0 && key <= keys[size - 1]) {
-      insert(key, value)
-      return
-    }
-
-    keys = appendLong(keys, size, key)
-    values = appendObject(values, size, value)
-    size++
-  }
-
-  fun entrySequence(): Sequence<Pair<Long, T>> {
-    return (0..size).asSequence().filter { values[it] != null }.map { keys[it] to values[it]!! }
-  }
-
-  private fun insert(
-    key: Long,
-    value: T
-  ) {
-    var i = binarySearch(keys, size, key)
-
-    if (i >= 0) {
-      values[i] = value
-    } else {
-      i = i.inv()
-
-      if (i < size && values[i] == null) {
-        keys[i] = key
-        values[i] = value
-        return
-      }
-
-      keys = insertLong(keys, size, i, key)
-      values = insertObject(values, size, i, value)
-      size++
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt b/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
deleted file mode 100644
index 67ec9435..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
+++ /dev/null
@@ -1,81 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.internal.SparseArrayUtils.appendLong
-import leakcanary.internal.SparseArrayUtils.appendString
-import leakcanary.internal.SparseArrayUtils.binarySearch
-import leakcanary.internal.SparseArrayUtils.insertLong
-import leakcanary.internal.SparseArrayUtils.insertString
-
-/**
- * Same as [LongToLongSparseArray] but long to string instead.
- */
-internal class LongToStringSparseArray(initialCapacity: Int) : Cloneable {
-
-  private var keys: LongArray
-  private var values: Array<String?>
-
-  var size: Int = 0
-    private set
-
-  init {
-    keys = LongArray(initialCapacity)
-    values = arrayOfNulls(initialCapacity)
-    size = 0
-  }
-
-  operator fun get(key: Long): String? {
-    val i = binarySearch(keys, size, key)
-
-    return if (i < 0 || values[i] == null) {
-      null
-    } else {
-      values[i]
-    }
-  }
-
-  fun getKey(value: String): Long? {
-    for (i in 0 until size) {
-      if (values[i] == value) {
-        return keys[i]
-      }
-    }
-    return null
-  }
-
-  operator fun set(
-    key: Long,
-    value: String
-  ) {
-    if (size != 0 && key <= keys[size - 1]) {
-      insert(key, value)
-      return
-    }
-
-    keys = appendLong(keys, size, key)
-    values = appendString(values, size, value)
-    size++
-  }
-
-  private fun insert(
-    key: Long,
-    value: String
-  ) {
-    var i = binarySearch(keys, size, key)
-
-    if (i >= 0) {
-      values[i] = value
-    } else {
-      i = i.inv()
-
-      if (i < size && values[i] == null) {
-        keys[i] = key
-        values[i] = value
-        return
-      }
-
-      keys = insertLong(keys, size, i, key)
-      values = insertString(values, size, i, value)
-      size++
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt b/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
deleted file mode 100644
index 8a3e0557..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
+++ /dev/null
@@ -1,170 +0,0 @@
-package leakcanary.internal
-
-internal object SparseArrayUtils {
-
-  fun insertInt(
-    array: IntArray,
-    currentSize: Int,
-    index: Int,
-    element: Int
-  ): IntArray {
-    if (currentSize + 1 <= array.size) {
-      System.arraycopy(array, index, array, index + 1, currentSize - index)
-      array[index] = element
-      return array
-    }
-
-    val newArray = IntArray(growSize(currentSize))
-    System.arraycopy(array, 0, newArray, 0, index)
-    newArray[index] = element
-    System.arraycopy(array, index, newArray, index + 1, array.size - index)
-    return newArray
-  }
-
-  fun <T> insertObject(
-    array: Array<T?>,
-    currentSize: Int,
-    index: Int,
-    element: T
-  ): Array<T?> {
-    if (currentSize + 1 <= array.size) {
-      System.arraycopy(array, index, array, index + 1, currentSize - index)
-      array[index] = element
-      return array
-    }
-
-    @Suppress("UNCHECKED_CAST")
-    val newArray = arrayOfNulls<Any?>(growSize(currentSize)) as Array<T?>
-    System.arraycopy(array, 0, newArray, 0, index)
-    newArray[index] = element
-    System.arraycopy(array, index, newArray, index + 1, array.size - index)
-    return newArray
-  }
-
-  fun insertLong(
-    array: LongArray,
-    currentSize: Int,
-    index: Int,
-    element: Long
-  ): LongArray {
-    if (currentSize + 1 <= array.size) {
-      System.arraycopy(array, index, array, index + 1, currentSize - index)
-      array[index] = element
-      return array
-    }
-
-    val newArray = LongArray(growSize(currentSize))
-    System.arraycopy(array, 0, newArray, 0, index)
-    newArray[index] = element
-    System.arraycopy(array, index, newArray, index + 1, array.size - index)
-    return newArray
-  }
-
-  fun insertString(
-    array: Array<String?>,
-    currentSize: Int,
-    index: Int,
-    element: String?
-  ): Array<String?> {
-    if (currentSize + 1 <= array.size) {
-      System.arraycopy(array, index, array, index + 1, currentSize - index)
-      array[index] = element
-      return array
-    }
-
-    val newArray = arrayOfNulls<String>(growSize(currentSize))
-    System.arraycopy(array, 0, newArray, 0, index)
-    newArray[index] = element
-    System.arraycopy(array, index, newArray, index + 1, array.size - index)
-    return newArray
-  }
-
-  fun appendInt(
-    array: IntArray,
-    currentSize: Int,
-    element: Int
-  ): IntArray {
-    var returnedArray = array
-    if (currentSize + 1 > returnedArray.size) {
-      val newArray = IntArray(growSize(currentSize))
-      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
-      returnedArray = newArray
-    }
-    returnedArray[currentSize] = element
-    return returnedArray
-  }
-
-  fun appendLong(
-    array: LongArray,
-    currentSize: Int,
-    element: Long
-  ): LongArray {
-    var returnedArray = array
-    if (currentSize + 1 > returnedArray.size) {
-      val newArray = LongArray(growSize(currentSize))
-      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
-      returnedArray = newArray
-    }
-    returnedArray[currentSize] = element
-    return returnedArray
-  }
-
-  fun <T> appendObject(
-    array: Array<T?>,
-    currentSize: Int,
-    element: T
-  ): Array<T?> {
-    var returnedArray = array
-    if (currentSize + 1 > returnedArray.size) {
-      @Suppress("UNCHECKED_CAST")
-      val newArray = arrayOfNulls<Any?>(growSize(currentSize)) as Array<T?>
-      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
-      returnedArray = newArray
-    }
-    returnedArray[currentSize] = element
-    return returnedArray
-  }
-
-  fun appendString(
-    array: Array<String?>,
-    currentSize: Int,
-    element: String?
-  ): Array<String?> {
-    var returnedArray = array
-    if (currentSize + 1 > returnedArray.size) {
-
-      val newArray = arrayOfNulls<String>(growSize(currentSize))
-      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
-      returnedArray = newArray
-    }
-    returnedArray[currentSize] = element
-    return returnedArray
-  }
-
-  /**
-   * Android array helpers use 2. C++ uses 2. ArrayList uses 1.5
-   * We're dealing with large arrays here so being conservative is good for memory.
-   */
-  private fun growSize(currentSize: Int) = (currentSize * 1.5).toInt()
-
-  fun binarySearch(
-    array: LongArray?,
-    size: Int,
-    value: Long
-  ): Int {
-    var lo = 0
-    var hi = size - 1
-
-    while (lo <= hi) {
-      val mid = (lo + hi).ushr(1)
-      val midVal = array!![mid]
-
-      when {
-        midVal < value -> lo = mid + 1
-        midVal > value -> hi = mid - 1
-        else -> return mid  // value found
-      }
-    }
-    return lo.inv()  // value not present
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/gradle.properties b/leakcanary-leaksentry/gradle.properties
deleted file mode 100644
index a0b9bd2c..00000000
--- a/leakcanary-leaksentry/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leaksentry
-POM_NAME=LeakSentry
-POM_PACKAGING=aar
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
deleted file mode 100644
index c79c1d45..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-package leakcanary
-
-import android.app.Application
-import leakcanary.internal.InternalLeakSentry
-import java.util.concurrent.TimeUnit
-
-object LeakSentry {
-
-  data class Config(
-    /**
-     * Whether LeakSentry should watch instances (by keeping weak references to them). Default is
-     * true in debuggable builds and false is non debuggable builds.
-     */
-    val enabled: Boolean = InternalLeakSentry.isDebuggableBuild,
-    /**
-     * Whether LeakCanary should automatically watch destroyed activities.
-     */
-    val watchActivities: Boolean = true,
-    /**
-     * Whether LeakCanary should automatically watch destroyed fragments.
-     */
-    val watchFragments: Boolean = true,
-    /**
-     * Whether LeakCanary should automatically watch destroyed fragment views.
-     */
-    val watchFragmentViews: Boolean = true,
-    /**
-     * How long to wait before reporting a watched instance as retained. Default is 5 seconds.
-     */
-    val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
-  )
-
-  @Volatile
-  var config: Config = if (isInstalled) Config() else Config(enabled = false)
-
-  val refWatcher
-    get() = InternalLeakSentry.refWatcher
-
-  /** @see [manualInstall] */
-  val isInstalled
-    get() = InternalLeakSentry.isInstalled
-
-  /**
-   * [LeakSentry] is automatically installed on main process start by
-   * [leakcanary.internal.LeakSentryInstaller] which is registered in the AndroidManifest.xml of
-   * your app. If you disabled [leakcanary.internal.LeakSentryInstaller] or you need LeakSentry
-   * or LeakCanary to run outside of the main process then you can call this method to install
-   * [LeakSentry].
-   */
-  fun manualInstall(application: Application) = InternalLeakSentry.install(application)
-
-}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
deleted file mode 100644
index 2b7e8e45..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
+++ /dev/null
@@ -1,39 +0,0 @@
-package leakcanary.internal
-
-import android.util.Log
-import leakcanary.CanaryLog.Logger
-
-internal class DefaultCanaryLog : Logger {
-
-  override fun d(
-    message: String,
-    vararg args: Any?
-  ) {
-    val formatted = if (args.isNotEmpty()) {
-      String.format(message, *args)
-    } else {
-      message
-    }
-    if (formatted.length < 4000) {
-      Log.d("LeakCanary", formatted)
-    } else {
-      val lines = formatted.split("\n".toRegex())
-          .toTypedArray()
-      for (line in lines) {
-        Log.d("LeakCanary", line)
-      }
-    }
-  }
-
-  override fun d(
-    throwable: Throwable?,
-    message: String,
-    vararg args: Any?
-  ) {
-    d(
-        String.format(message, *args) + '\n'.toString() + Log.getStackTraceString(
-            throwable
-        )
-    )
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
deleted file mode 100644
index 54976015..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal
-
-import android.app.Activity
-import android.app.Application
-import android.os.Build.VERSION.SDK_INT
-import android.os.Build.VERSION_CODES.O
-import android.os.Bundle
-import leakcanary.LeakSentry
-import leakcanary.RefWatcher
-import leakcanary.internal.InternalHelper.noOpDelegate
-
-/**
- * Internal class used to watch for fragments leaks.
- */
-internal interface FragmentDestroyWatcher {
-
-  fun watchFragments(activity: Activity)
-
-  companion object {
-
-    private const val SUPPORT_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
-
-    fun install(
-      application: Application,
-      refWatcher: RefWatcher,
-      configProvider: () -> LeakSentry.Config
-    ) {
-      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
-
-      if (SDK_INT >= O) {
-        fragmentDestroyWatchers.add(
-            AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
-        )
-      }
-
-      if (classAvailable(
-              SUPPORT_FRAGMENT_CLASS_NAME
-          )
-      ) {
-        fragmentDestroyWatchers.add(
-            SupportFragmentDestroyWatcher(refWatcher, configProvider)
-        )
-      }
-
-      if (fragmentDestroyWatchers.size == 0) {
-        return
-      }
-
-      application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
-        override fun onActivityCreated(
-          activity: Activity,
-          savedInstanceState: Bundle?
-        ) {
-          for (watcher in fragmentDestroyWatchers) {
-            watcher.watchFragments(activity)
-          }
-        }
-      })
-    }
-
-    private fun classAvailable(className: String): Boolean {
-      return try {
-        Class.forName(className)
-        true
-      } catch (e: ClassNotFoundException) {
-        false
-      }
-    }
-  }
-}
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
deleted file mode 100644
index 64e05ead..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalHelper.kt
+++ /dev/null
@@ -1,18 +0,0 @@
-package leakcanary.internal
-
-import java.lang.reflect.InvocationHandler
-import java.lang.reflect.Proxy
-
-/** Visible across several internal modules. */
-object InternalHelper {
-  inline fun <reified T : Any> noOpDelegate(): T {
-    val javaClass = T::class.java
-    val noOpHandler = InvocationHandler { _, _, _ ->
-      // no op
-    }
-    return Proxy.newProxyInstance(
-        javaClass.classLoader, arrayOf(javaClass), noOpHandler
-    ) as T
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
deleted file mode 100644
index d91fecaf..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ /dev/null
@@ -1,79 +0,0 @@
-package leakcanary.internal
-
-import android.app.Application
-import android.content.pm.ApplicationInfo
-import android.os.Handler
-import android.os.Looper
-import android.os.SystemClock
-import leakcanary.CanaryLog
-import leakcanary.Clock
-import leakcanary.LeakSentry
-import leakcanary.RefWatcher
-import java.util.concurrent.Executor
-
-internal object InternalLeakSentry {
-
-  val isInstalled
-    get() = ::application.isInitialized
-
-  private val listener: LeakSentryListener
-
-  val isDebuggableBuild by lazy {
-    (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
-  }
-
-  lateinit var application: Application
-
-  private val clock = object : Clock {
-    override fun uptimeMillis(): Long {
-      return SystemClock.uptimeMillis()
-    }
-  }
-
-  private val mainHandler = Handler(Looper.getMainLooper())
-
-  init {
-    listener = try {
-      val leakCanaryListener = Class.forName("leakcanary.internal.InternalLeakCanary")
-      leakCanaryListener.getDeclaredField("INSTANCE").get(null) as LeakSentryListener
-    } catch (ignored: Throwable) {
-      LeakSentryListener.None
-    }
-  }
-
-  private val checkRetainedExecutor = Executor {
-    mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
-  }
-  val refWatcher = RefWatcher(
-      clock = clock,
-      checkRetainedExecutor = checkRetainedExecutor,
-      onInstanceRetained = { listener.onReferenceRetained() },
-      isEnabled = { LeakSentry.config.enabled }
-  )
-
-  fun install(application: Application) {
-    CanaryLog.d("Installing LeakSentry")
-    checkMainThread()
-    if (this::application.isInitialized) {
-      return
-    }
-    InternalLeakSentry.application = application
-
-    val configProvider = { LeakSentry.config }
-    ActivityDestroyWatcher.install(
-        application, refWatcher, configProvider
-    )
-    FragmentDestroyWatcher.install(
-        application, refWatcher, configProvider
-    )
-    listener.onLeakSentryInstalled(application)
-  }
-
-  private fun checkMainThread() {
-    if (Looper.getMainLooper().thread !== Thread.currentThread()) {
-      throw UnsupportedOperationException(
-          "Should be called from the main thread, not ${Thread.currentThread()}"
-      )
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
deleted file mode 100644
index 362550b1..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryListener.kt
+++ /dev/null
@@ -1,16 +0,0 @@
-package leakcanary.internal
-
-import android.app.Application
-
-interface LeakSentryListener {
-  fun onLeakSentryInstalled(application: Application)
-  fun onReferenceRetained()
-
-  object None : LeakSentryListener {
-    override fun onLeakSentryInstalled(application: Application) {
-    }
-
-    override fun onReferenceRetained() {
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-log/gradle.properties b/leakcanary-log/gradle.properties
deleted file mode 100644
index d14febb2..00000000
--- a/leakcanary-log/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-log
-POM_NAME=LeakCanary Log
-POM_PACKAGING=jar
diff --git a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt b/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
deleted file mode 100644
index a2eccf46..00000000
--- a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-package leakcanary
-
-object CanaryLog {
-
-  interface Logger {
-    fun d(
-      message: String,
-      vararg args: Any?
-    )
-
-    fun d(
-      throwable: Throwable?,
-      message: String,
-      vararg args: Any?
-    )
-  }
-
-  @Volatile var logger: Logger? = null
-
-  fun d(
-    message: String,
-    vararg args: Any?
-  ) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    val logger = logger ?: return
-    logger.d(message, *args)
-  }
-
-  fun d(
-    throwable: Throwable?,
-    message: String,
-    vararg args: Any?
-  ) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    val logger = logger ?: return
-    logger.d(throwable, message, *args)
-  }
-}
diff --git a/leakcanary-object-watcher-android-androidx/build.gradle b/leakcanary-object-watcher-android-androidx/build.gradle
new file mode 100644
index 00000000..99f4467d
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/build.gradle
@@ -0,0 +1,25 @@
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+dependencies {
+  api project(':leakcanary-object-watcher-android')
+
+  implementation deps.kotlin.stdlib
+  // Optional dependency
+  compileOnly deps.androidx.fragment
+}
+
+android {
+  compileSdkVersion versions.compileSdk
+  defaultConfig {
+    minSdkVersion versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+    check 'Interoperability'
+  }
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro b/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
new file mode 100644
index 00000000..7f67c8b2
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/consumer-proguard-rules.pro
@@ -0,0 +1,2 @@
+# AndroidXFragmentDestroyWatcher is loaded via reflection
+-keep class leakcanary.internal.AndroidXFragmentDestroyWatcher { *; }
diff --git a/leakcanary-object-watcher-android-androidx/gradle.properties b/leakcanary-object-watcher-android-androidx/gradle.properties
new file mode 100644
index 00000000..2a0b9c8f
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android-androidx
+POM_NAME=LeakCanary Object Watcher for Android extension: Android X fragments support
+POM_PACKAGING=aar
diff --git a/leakcanary-object-watcher-android-androidx/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android-androidx/src/main/AndroidManifest.xml
new file mode 100644
index 00000000..22eac305
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/src/main/AndroidManifest.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    package="com.squareup.leakcanary.fragments.androidx"
+    >
+</manifest>
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
similarity index 83%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
rename to leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
index a4fc2f29..8ce9f73a 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/SupportFragmentDestroyWatcher.kt
+++ b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -19,13 +19,13 @@ import android.app.Activity
 import androidx.fragment.app.Fragment
 import androidx.fragment.app.FragmentActivity
 import androidx.fragment.app.FragmentManager
-import leakcanary.RefWatcher
-import leakcanary.LeakSentry.Config
+import leakcanary.AppWatcher.Config
+import leakcanary.ObjectWatcher
 
-internal class SupportFragmentDestroyWatcher(
-  private val refWatcher: RefWatcher,
+internal class AndroidXFragmentDestroyWatcher(
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
-) : FragmentDestroyWatcher {
+) : (Activity) -> Unit {
 
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
 
@@ -35,7 +35,7 @@ internal class SupportFragmentDestroyWatcher(
     ) {
       val view = fragment.view
       if (view != null && configProvider().watchFragmentViews) {
-        refWatcher.watch(view)
+        objectWatcher.watch(view)
       }
     }
 
@@ -44,12 +44,12 @@ internal class SupportFragmentDestroyWatcher(
       fragment: Fragment
     ) {
       if (configProvider().watchFragments) {
-        refWatcher.watch(fragment)
+        objectWatcher.watch(fragment)
       }
     }
   }
 
-  override fun watchFragments(activity: Activity) {
+  override fun invoke(activity: Activity) {
     if (activity is FragmentActivity) {
       val supportFragmentManager = activity.supportFragmentManager
       supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
diff --git a/leakcanary-leaksentry/build.gradle b/leakcanary-object-watcher-android/build.gradle
similarity index 73%
rename from leakcanary-leaksentry/build.gradle
rename to leakcanary-object-watcher-android/build.gradle
index dd0f4e90..f7eb35a0 100644
--- a/leakcanary-leaksentry/build.gradle
+++ b/leakcanary-object-watcher-android/build.gradle
@@ -2,12 +2,9 @@ apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 
 dependencies {
-  api project(':leakcanary-watcher')
+  api project(':leakcanary-object-watcher')
 
-  implementation deps.androidx.core
   implementation deps.kotlin.stdlib
-  // Optional dependency
-  compileOnly deps.androidx.fragment
 }
 
 android {
@@ -15,6 +12,7 @@ android {
 
   defaultConfig {
     minSdkVersion versions.minSdk
+    consumerProguardFiles 'consumer-proguard-rules.pro'
   }
 
   lintOptions {
@@ -28,5 +26,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-object-watcher-android/consumer-proguard-rules.pro b/leakcanary-object-watcher-android/consumer-proguard-rules.pro
new file mode 100644
index 00000000..04653f44
--- /dev/null
+++ b/leakcanary-object-watcher-android/consumer-proguard-rules.pro
@@ -0,0 +1,4 @@
+# A ContentProvider that gets created by Android on startup
+-keep class leakcanary.internal.AppWatcherInstaller { <init>(); }
+# KeyedWeakReference is looked up in the hprof file
+-keep class leakcanary.KeyedWeakReference { *; }
diff --git a/leakcanary-object-watcher-android/gradle.properties b/leakcanary-object-watcher-android/gradle.properties
new file mode 100644
index 00000000..30530624
--- /dev/null
+++ b/leakcanary-object-watcher-android/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android
+POM_NAME=LeakCanary Object Watcher for Android
+POM_PACKAGING=aar
diff --git a/leakcanary-sample/src/androidTest/AndroidManifest.xml b/leakcanary-object-watcher-android/src/androidTest/AndroidManifest.xml
similarity index 100%
rename from leakcanary-sample/src/androidTest/AndroidManifest.xml
rename to leakcanary-object-watcher-android/src/androidTest/AndroidManifest.xml
diff --git a/leakcanary-leaksentry/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
similarity index 52%
rename from leakcanary-leaksentry/src/main/AndroidManifest.xml
rename to leakcanary-object-watcher-android/src/main/AndroidManifest.xml
index 3b42b180..aa51d7c5 100644
--- a/leakcanary-leaksentry/src/main/AndroidManifest.xml
+++ b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest
     xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary.leaksentry"
+    package="com.squareup.leakcanary.objectwatcher"
     >
 
   <application>
     <provider
-        android:name="leakcanary.internal.LeakSentryInstaller"
-        android:authorities="${applicationId}.leak-sentry-installer"
+        android:name="leakcanary.internal.AppWatcherInstaller$MainProcess"
+        android:authorities="${applicationId}.leakcanary-installer"
         android:exported="false"/>
   </application>
 </manifest>
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
new file mode 100644
index 00000000..2e6e7aaa
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
@@ -0,0 +1,88 @@
+package leakcanary
+
+import android.app.Application
+import leakcanary.AppWatcher.objectWatcher
+import leakcanary.internal.InternalAppWatcher
+import shark.SharkLog
+import java.util.concurrent.TimeUnit
+
+/**
+ * The entry point API for using [ObjectWatcher] in an Android app. [AppWatcher.objectWatcher] is
+ * in charge of detecting retained objects, and [AppWatcher] is auto configured on app start to
+ * pass it activity and fragment instances. Call [ObjectWatcher.watch] on [objectWatcher] to
+ * watch any other object that you expect to be unreachable.
+ */
+object AppWatcher {
+
+  data class Config(
+    /**
+     * Whether AppWatcher should watch objects (by keeping weak references to them).
+     *
+     * Default to true in debuggable builds and false is non debuggable builds.
+     */
+    val enabled: Boolean = InternalAppWatcher.isDebuggableBuild,
+
+    /**
+     * Whether AppWatcher should automatically watch destroyed activity instances.
+     *
+     * Defaults to true.
+     */
+    val watchActivities: Boolean = true,
+
+    /**
+     * Whether AppWatcher should automatically watch destroyed fragment instances.
+     *
+     * Defaults to true.
+     */
+    val watchFragments: Boolean = true,
+
+    /**
+     * Whether AppWatcher should automatically watch destroyed fragment view instances.
+     *
+     * Defaults to true.
+     */
+    val watchFragmentViews: Boolean = true,
+
+    /**
+     * How long to wait before reporting a watched object as retained.
+     *
+     * Default to 5 seconds.
+     */
+    val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
+  )
+
+  /**
+   * The current AppWatcher configuration. Can be updated at any time, usually by replacing it with
+   * a mutated copy, e.g.:
+   *
+   * ```
+   * LeakCanary.config = LeakCanary.config.copy(enabled = false)
+   * ```
+   */
+  @Volatile
+  var config: Config = if (isInstalled) Config() else Config(enabled = false)
+    set(value) {
+      field = value
+      SharkLog.d { "Updated AppWatcher.config to $value" }
+    }
+
+  /**
+   * The [ObjectWatcher] used by AppWatcher to detect retained objects.
+   */
+  val objectWatcher
+    get() = InternalAppWatcher.objectWatcher
+
+  /** @see [manualInstall] */
+  val isInstalled
+    get() = InternalAppWatcher.isInstalled
+
+  /**
+   * [AppWatcher] is automatically installed on main process start by
+   * [leakcanary.internal.AppWatcherInstaller] which is registered in the AndroidManifest.xml of
+   * your app. If you disabled [leakcanary.internal.AppWatcherInstaller] or you need AppWatcher
+   * or LeakCanary to run outside of the main process then you can call this method to install
+   * [AppWatcher].
+   */
+  fun manualInstall(application: Application) = InternalAppWatcher.install(application)
+
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
similarity index 80%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
index aec2cc7c..f2984ec7 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -17,12 +17,12 @@ package leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.LeakSentry.Config
-import leakcanary.RefWatcher
-import leakcanary.internal.InternalHelper.noOpDelegate
+import leakcanary.AppWatcher.Config
+import leakcanary.ObjectWatcher
+import leakcanary.internal.InternalAppWatcher.noOpDelegate
 
 internal class ActivityDestroyWatcher private constructor(
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
 ) {
 
@@ -30,7 +30,7 @@ internal class ActivityDestroyWatcher private constructor(
     object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
       override fun onActivityDestroyed(activity: Activity) {
         if (configProvider().watchActivities) {
-          refWatcher.watch(activity)
+          objectWatcher.watch(activity)
         }
       }
     }
@@ -38,11 +38,11 @@ internal class ActivityDestroyWatcher private constructor(
   companion object {
     fun install(
       application: Application,
-      refWatcher: RefWatcher,
+      objectWatcher: ObjectWatcher,
       configProvider: () -> Config
     ) {
       val activityDestroyWatcher =
-        ActivityDestroyWatcher(refWatcher, configProvider)
+        ActivityDestroyWatcher(objectWatcher, configProvider)
       application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
     }
   }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
similarity index 80%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
index 62ef6a25..7c48562a 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -17,20 +17,18 @@
 
 package leakcanary.internal
 
+import android.annotation.SuppressLint
 import android.app.Activity
 import android.app.Fragment
 import android.app.FragmentManager
-import android.os.Build
-import androidx.annotation.RequiresApi
-import leakcanary.RefWatcher
-import leakcanary.LeakSentry.Config
+import leakcanary.AppWatcher.Config
+import leakcanary.ObjectWatcher
 
-@RequiresApi(Build.VERSION_CODES.O) //
+@SuppressLint("NewApi")
 internal class AndroidOFragmentDestroyWatcher(
-  private val refWatcher: RefWatcher,
+  private val objectWatcher: ObjectWatcher,
   private val configProvider: () -> Config
-) : FragmentDestroyWatcher {
-
+) : (Activity) -> Unit {
   private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
 
     override fun onFragmentViewDestroyed(
@@ -39,7 +37,7 @@ internal class AndroidOFragmentDestroyWatcher(
     ) {
       val view = fragment.view
       if (view != null && configProvider().watchFragmentViews) {
-        refWatcher.watch(view)
+        objectWatcher.watch(view)
       }
     }
 
@@ -48,12 +46,12 @@ internal class AndroidOFragmentDestroyWatcher(
       fragment: Fragment
     ) {
       if (configProvider().watchFragments) {
-        refWatcher.watch(fragment)
+        objectWatcher.watch(fragment)
       }
     }
   }
 
-  override fun watchFragments(activity: Activity) {
+  override fun invoke(activity: Activity) {
     val fragmentManager = activity.fragmentManager
     fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
   }
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
similarity index 55%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
index 84cf968b..95b0f544 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
@@ -5,18 +5,34 @@ import android.content.ContentProvider
 import android.content.ContentValues
 import android.database.Cursor
 import android.net.Uri
-import leakcanary.CanaryLog
+import leakcanary.AppWatcher
 
 /**
- * Content providers are loaded before the application class is created. [LeakSentryInstaller] is
- * used to install [leaksentry.LeakSentry] on application start.
+ * Content providers are loaded before the application class is created. [AppWatcherInstaller] is
+ * used to install [leakcanary.AppWatcher] on application start.
  */
-internal class LeakSentryInstaller : ContentProvider() {
+internal sealed class AppWatcherInstaller : ContentProvider() {
+
+  /**
+   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.
+   */
+  internal class MainProcess : AppWatcherInstaller()
+
+  /**
+   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,
+   * [LeakCanaryProcess] automatically sets up the LeakCanary code
+   */
+  internal class LeakCanaryProcess : AppWatcherInstaller() {
+    override fun onCreate(): Boolean {
+      super.onCreate()
+      AppWatcher.config = AppWatcher.config.copy(enabled = false)
+      return true
+    }
+  }
 
   override fun onCreate(): Boolean {
-    CanaryLog.logger = DefaultCanaryLog()
     val application = context!!.applicationContext as Application
-    InternalLeakSentry.install(application)
+    InternalAppWatcher.install(application)
     return true
   }
 
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
new file mode 100644
index 00000000..c43bc944
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
@@ -0,0 +1,25 @@
+package leakcanary.internal
+
+import android.util.Log
+import shark.SharkLog.Logger
+
+internal class DefaultCanaryLog : Logger {
+
+  override fun d(message: String) {
+    if (message.length < 4000) {
+      Log.d("LeakCanary", message)
+    } else {
+      message.split(NEW_LINE_REGEX).forEach {line ->
+        Log.d("LeakCanary", line)
+      }
+    }
+  }
+
+  override fun d(throwable: Throwable, message: String) {
+    d("$message\n${Log.getStackTraceString(throwable)}")
+  }
+
+  companion object {
+    val NEW_LINE_REGEX = "\n".toRegex()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
new file mode 100644
index 00000000..9b4059c2
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary.internal
+
+import android.app.Activity
+import android.app.Application
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.O
+import android.os.Bundle
+import leakcanary.AppWatcher
+import leakcanary.ObjectWatcher
+import leakcanary.internal.InternalAppWatcher.noOpDelegate
+
+/**
+ * Internal class used to watch for fragments leaks.
+ */
+internal object FragmentDestroyWatcher {
+
+  private const val ANDROIDX_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+  private const val ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =
+    "leakcanary.internal.AndroidXFragmentDestroyWatcher"
+
+  fun install(
+    application: Application,
+    objectWatcher: ObjectWatcher,
+    configProvider: () -> AppWatcher.Config
+  ) {
+    val fragmentDestroyWatchers = mutableListOf<(Activity) -> Unit>()
+
+    if (SDK_INT >= O) {
+      fragmentDestroyWatchers.add(
+          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)
+      )
+    }
+
+    if (classAvailable(ANDROIDX_FRAGMENT_CLASS_NAME) &&
+        classAvailable(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
+    ) {
+      val watcherConstructor = Class.forName(ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME)
+          .getDeclaredConstructor(ObjectWatcher::class.java, Function0::class.java)
+      @kotlin.Suppress("UNCHECKED_CAST")
+      fragmentDestroyWatchers.add(
+          watcherConstructor.newInstance(objectWatcher, configProvider) as (Activity) -> Unit
+      )
+    }
+
+    if (fragmentDestroyWatchers.size == 0) {
+      return
+    }
+
+    application.registerActivityLifecycleCallbacks(object : Application.ActivityLifecycleCallbacks by noOpDelegate() {
+      override fun onActivityCreated(
+        activity: Activity,
+        savedInstanceState: Bundle?
+      ) {
+        for (watcher in fragmentDestroyWatchers) {
+          watcher(activity)
+        }
+      }
+    })
+  }
+
+  private fun classAvailable(className: String): Boolean {
+    return try {
+      Class.forName(className)
+      true
+    } catch (e: ClassNotFoundException) {
+      false
+    }
+  }
+}
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt
new file mode 100644
index 00000000..578e28ad
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt
@@ -0,0 +1,99 @@
+package leakcanary.internal
+
+import android.app.Application
+import android.content.pm.ApplicationInfo
+import android.os.Handler
+import android.os.Looper
+import android.os.SystemClock
+import leakcanary.Clock
+import leakcanary.AppWatcher
+import leakcanary.ObjectWatcher
+import leakcanary.OnObjectRetainedListener
+import shark.SharkLog
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.Proxy
+import java.util.concurrent.Executor
+
+internal object InternalAppWatcher {
+
+  val isInstalled
+    get() = ::application.isInitialized
+
+  private val onAppWatcherInstalled: (Application) -> Unit
+
+  val isDebuggableBuild by lazy {
+    (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
+  }
+
+  lateinit var application: Application
+
+  private val clock = object : Clock {
+    override fun uptimeMillis(): Long {
+      return SystemClock.uptimeMillis()
+    }
+  }
+
+  private val mainHandler = Handler(Looper.getMainLooper())
+
+  init {
+    val internalLeakCanary = try {
+      val leakCanaryListener = Class.forName("leakcanary.internal.InternalLeakCanary")
+      leakCanaryListener.getDeclaredField("INSTANCE")
+          .get(null)
+    } catch (ignored: Throwable) {
+      NoLeakCanary
+    }
+    @kotlin.Suppress("UNCHECKED_CAST")
+    onAppWatcherInstalled = internalLeakCanary as (Application) -> Unit
+  }
+
+  private val checkRetainedExecutor = Executor {
+    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)
+  }
+  val objectWatcher = ObjectWatcher(
+      clock = clock,
+      checkRetainedExecutor = checkRetainedExecutor,
+      isEnabled = { AppWatcher.config.enabled }
+  )
+
+  fun install(application: Application) {
+    SharkLog.logger = DefaultCanaryLog()
+    SharkLog.d { "Installing AppWatcher" }
+    checkMainThread()
+    if (this::application.isInitialized) {
+      return
+    }
+    InternalAppWatcher.application = application
+
+    val configProvider = { AppWatcher.config }
+    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)
+    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)
+    onAppWatcherInstalled(application)
+  }
+
+  inline fun <reified T : Any> noOpDelegate(): T {
+    val javaClass = T::class.java
+    val noOpHandler = InvocationHandler { _, _, _ ->
+      // no op
+    }
+    return Proxy.newProxyInstance(
+        javaClass.classLoader, arrayOf(javaClass), noOpHandler
+    ) as T
+  }
+
+  private fun checkMainThread() {
+    if (Looper.getMainLooper().thread !== Thread.currentThread()) {
+      throw UnsupportedOperationException(
+          "Should be called from the main thread, not ${Thread.currentThread()}"
+      )
+    }
+  }
+
+  object NoLeakCanary : (Application) -> Unit, OnObjectRetainedListener {
+    override fun invoke(application: Application) {
+    }
+
+    override fun onObjectRetained() {
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-watcher/build.gradle b/leakcanary-object-watcher/build.gradle
similarity index 78%
rename from leakcanary-watcher/build.gradle
rename to leakcanary-object-watcher/build.gradle
index 984bad02..57d9c255 100644
--- a/leakcanary-watcher/build.gradle
+++ b/leakcanary-object-watcher/build.gradle
@@ -6,11 +6,10 @@ targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
   implementation deps.kotlin.stdlib
-  api project(':leakcanary-log')
+  api project(':shark-log')
 
   testImplementation deps.assertj_core
   testImplementation deps.junit
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-object-watcher/gradle.properties b/leakcanary-object-watcher/gradle.properties
new file mode 100644
index 00000000..16794121
--- /dev/null
+++ b/leakcanary-object-watcher/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher
+POM_NAME=LeakCanary Object Watcher
+POM_PACKAGING=jar
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
new file mode 100644
index 00000000..749e97f9
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
@@ -0,0 +1,11 @@
+package leakcanary
+
+/**
+ * An interface to abstract the SystemClock.uptimeMillis() Android API in non Android artifacts.
+ */
+interface Clock {
+  /**
+   * On Android VMs, this should return android.os.SystemClock.uptimeMillis().
+   */
+  fun uptimeMillis(): Long
+}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt b/leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt
similarity index 82%
rename from leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
rename to leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt
index 023889b8..762432b7 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt
@@ -16,13 +16,20 @@
 package leakcanary
 
 /**
- * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
- * in the reference queue yet. This gives the application a hook to run the GC before the [ ] checks the reference queue again, to avoid taking a heap dump if possible.
+ * [GcTrigger] is used to try triggering garbage collection and enqueuing [KeyedWeakReference] into
+ * the associated [java.lang.ref.ReferenceQueue]. The default implementation [Default] comes from
+ * AOSP.
  */
 interface GcTrigger {
 
+  /**
+   * Attempts to run garbage collection.
+   */
   fun runGc()
 
+  /**
+   * Default implementation of [GcTrigger].
+   */
   object Default : GcTrigger {
     override fun runGc() {
       // Code taken from AOSP FinalizationTest:
diff --git a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
similarity index 61%
rename from leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
rename to leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
index dde8d61c..e6137c30 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -15,10 +15,18 @@
  */
 package leakcanary
 
+import leakcanary.KeyedWeakReference.Companion.heapDumpUptimeMillis
 import java.lang.ref.ReferenceQueue
 import java.lang.ref.WeakReference
 
-@Suppress("unused")
+/**
+ * A weak reference used by [ObjectWatcher] to determine which objects become weakly reachable
+ * and which don't. [ObjectWatcher] uses [key] to keep track of [KeyedWeakReference] instances that
+ * haven't made it into the associated [ReferenceQueue] yet.
+ *
+ * [heapDumpUptimeMillis] should be set with the current time from [Clock.uptimeMillis] right
+ * before dumping the heap, so that we can later determine how long an object was retained.
+ */
 class KeyedWeakReference(
   referent: Any,
   val key: String,
@@ -28,12 +36,10 @@ class KeyedWeakReference(
 ) : WeakReference<Any>(
     referent, referenceQueue
 ) {
-  val className: String = referent.javaClass.name
-
   /**
-   * Compared against [heapDumpUptimeMillis] so that the Hprof Parser knows only to look at
-   * instances that were moved to retained, then used to remove weak references post heap dump.
-   **/
+   * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn't
+   * been yet.
+   */
   @Volatile
   var retainedUptimeMillis = -1L
 
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt b/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
new file mode 100644
index 00000000..07474a42
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import shark.SharkLog
+import java.lang.ref.ReferenceQueue
+import java.util.UUID
+import java.util.concurrent.Executor
+
+/**
+ * [ObjectWatcher] can be passed objects to [watch]. It will create [KeyedWeakReference] instances
+ * that reference watches objects, and check if those references have been cleared as expected on
+ * the [checkRetainedExecutor] executor. If not, these objects are considered retained and
+ * [ObjectWatcher] will then notify the [onObjectRetainedListener] on that executor thread.
+ *
+ * [checkRetainedExecutor] is expected to run its tasks on a background thread, with a significant
+ * to give the GC the opportunity to identify weakly reachable objects.
+ *
+ * [ObjectWatcher] is thread safe.
+ */
+// Thread safe by locking on all methods, which is reasonably efficient given how often
+// these methods are accessed.
+class ObjectWatcher constructor(
+  private val clock: Clock,
+  private val checkRetainedExecutor: Executor,
+  /**
+   * Calls to [watch] will be ignored when [isEnabled] returns false
+   */
+  private val isEnabled: () -> Boolean = { true }
+) {
+
+  private val onObjectRetainedListeners = mutableSetOf<OnObjectRetainedListener>()
+
+  /**
+   * References passed to [watch].
+   */
+  private val watchedObjects = mutableMapOf<String, KeyedWeakReference>()
+
+  private val queue = ReferenceQueue<Any>()
+
+  /**
+   * Returns true if there are watched objects that aren't weakly reachable, and
+   * have been watched for long enough to be considered retained.
+   */
+  val hasRetainedObjects: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.any { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns the number of retained objects, ie the number of watched objects that aren't weakly
+   * reachable, and have been watched for long enough to be considered retained.
+   */
+  val retainedObjectCount: Int
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.count { it.value.retainedUptimeMillis != -1L }
+    }
+
+  /**
+   * Returns true if there are watched objects that aren't weakly reachable, even
+   * if they haven't been watched for long enough to be considered retained.
+   */
+  val hasWatchedObjects: Boolean
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      return watchedObjects.isNotEmpty()
+    }
+
+  /**
+   * Returns the objects that are currently considered retained. Useful for logging purposes.
+   * Be careful with those objects and release them ASAP as you may creating longer lived leaks
+   * then the one that are already there.
+   */
+  val retainedObjects: List<Any>
+    @Synchronized get() {
+      removeWeaklyReachableObjects()
+      val instances = mutableListOf<Any>()
+      for (weakReference in watchedObjects.values) {
+        if (weakReference.retainedUptimeMillis != -1L) {
+          val instance = weakReference.get()
+          if (instance != null) {
+            instances.add(instance)
+          }
+        }
+      }
+      return instances
+    }
+
+  @Synchronized fun addOnObjectRetainedListener(listener: OnObjectRetainedListener) {
+    onObjectRetainedListeners.add(listener)
+  }
+
+  @Synchronized fun removeOnObjectRetainedListener(listener: OnObjectRetainedListener) {
+    onObjectRetainedListeners.remove(listener)
+  }
+
+  /**
+   * Identical to [watch] with an empty string reference name.
+   */
+  @Synchronized fun watch(watchedObject: Any) {
+    watch(watchedObject, "")
+  }
+
+  /**
+   * Watches the provided [watchedObject].
+   *
+   * @param name A logical identifier for the watched object.
+   */
+  @Synchronized fun watch(
+    watchedObject: Any,
+    name: String
+  ) {
+    if (!isEnabled()) {
+      return
+    }
+    removeWeaklyReachableObjects()
+    val key = UUID.randomUUID()
+        .toString()
+    val watchUptimeMillis = clock.uptimeMillis()
+    val reference =
+      KeyedWeakReference(watchedObject, key, name, watchUptimeMillis, queue)
+    SharkLog.d {
+        "Watching " +
+            (if (watchedObject is Class<*>) watchedObject.toString() else "instance of ${watchedObject.javaClass.name}") +
+            (if (name.isNotEmpty()) " named $name" else "") +
+            " with key $key"
+    }
+
+    watchedObjects[key] = reference
+    checkRetainedExecutor.execute {
+      moveToRetained(key)
+    }
+  }
+
+  /**
+   * Clears all [KeyedWeakReference] that were created before [heapDumpUptimeMillis] (based on
+   * [clock] [Clock.uptimeMillis])
+   */
+  @Synchronized fun clearObjectsWatchedBefore(heapDumpUptimeMillis: Long) {
+    val weakRefsToRemove =
+      watchedObjects.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
+    weakRefsToRemove.values.forEach { it.clear() }
+    watchedObjects.keys.removeAll(weakRefsToRemove.keys)
+  }
+
+  /**
+   * Clears all [KeyedWeakReference]
+   */
+  @Synchronized fun clearWatchedObjects() {
+    watchedObjects.values.forEach { it.clear() }
+    watchedObjects.clear()
+  }
+
+  @Synchronized private fun moveToRetained(key: String) {
+    removeWeaklyReachableObjects()
+    val retainedRef = watchedObjects[key]
+    if (retainedRef != null) {
+      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
+      onObjectRetainedListeners.forEach { it.onObjectRetained() }
+    }
+  }
+
+  private fun removeWeaklyReachableObjects() {
+    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+    // reachable. This is before finalization or garbage collection has actually happened.
+    var ref: KeyedWeakReference?
+    do {
+      ref = queue.poll() as KeyedWeakReference?
+      if (ref != null) {
+        watchedObjects.remove(ref.key)
+      }
+    } while (ref != null)
+  }
+}
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt b/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
new file mode 100644
index 00000000..89f43aeb
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
@@ -0,0 +1,33 @@
+package leakcanary
+
+/**
+ * Listener used by [ObjectWatcher] to report retained objects.
+ */
+interface OnObjectRetainedListener {
+
+  /**
+   * A watched object became retained.
+   */
+  fun onObjectRetained()
+
+  companion object {
+    /**
+     * Utility function to create a [OnObjectRetainedListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnObjectRetainedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnObjectRetainedListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: () -> Unit): OnObjectRetainedListener =
+      object : OnObjectRetainedListener {
+        override fun onObjectRetained() {
+          block()
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt b/leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
similarity index 58%
rename from leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
rename to leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
index 2d76440b..42bd88b0 100644
--- a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
+++ b/leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
@@ -5,35 +5,32 @@ import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
 import java.util.concurrent.Executor
 
-class RefWatcherTest {
-
-  private val onRefRetained: () -> Unit = {
-  }
+class ObjectWatcherTest {
 
   private val checkRetainedExecutor: Executor = Executor {
     it.run()
   }
 
-  val refWatcher = RefWatcher(object : Clock {
+  private val objectWatcher = ObjectWatcher(object : Clock {
     override fun uptimeMillis(): Long {
       return time
     }
-  }, checkRetainedExecutor, onRefRetained)
+  }, checkRetainedExecutor).apply { addOnObjectRetainedListener(OnObjectRetainedListener {}) }
   var time: Long = 0
 
   var ref: Any? = Any()
 
   @Test fun `unreachable object not retained`() {
-    refWatcher.watch(ref!!)
+    objectWatcher.watch(ref!!)
     ref = null
     runGc()
-    assertThat(refWatcher.hasRetainedInstances).isFalse()
+    assertThat(objectWatcher.hasRetainedObjects).isFalse()
   }
 
   @Test fun `reachable object retained`() {
-    refWatcher.watch(ref!!)
+    objectWatcher.watch(ref!!)
     runGc()
-    assertThat(refWatcher.hasRetainedInstances).isTrue()
+    assertThat(objectWatcher.hasRetainedObjects).isTrue()
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-watcher/gradle.properties b/leakcanary-watcher/gradle.properties
deleted file mode 100644
index cbcadeeb..00000000
--- a/leakcanary-watcher/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-watcher
-POM_NAME=LeakCanary Watcher
-POM_PACKAGING=jar
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
deleted file mode 100644
index bd3b146b..00000000
--- a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt
+++ /dev/null
@@ -1,6 +0,0 @@
-package leakcanary
-
-interface Clock {
-  /** See Android SystemClock.uptimeMillis().  */
-  fun uptimeMillis(): Long
-}
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
deleted file mode 100644
index 4709d4bb..00000000
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import java.lang.ref.ReferenceQueue
-import java.util.UUID
-import java.util.concurrent.Executor
-
-/**
- * Thread safe by locking on all methods, which is reasonably efficient given how often
- * these methods are accessed.
- */
-class RefWatcher constructor(
-  private val clock: Clock,
-  private val checkRetainedExecutor: Executor,
-  private val onInstanceRetained: () -> Unit,
-  /**
-   * Calls to [watch] will be ignored when [isEnabled] returns false
-   */
-  private val isEnabled: () -> Boolean = { true }
-) {
-
-  /**
-   * References passed to [watch].
-   */
-  private val watchedInstances = mutableMapOf<String, KeyedWeakReference>()
-
-  private val queue = ReferenceQueue<Any>()
-
-  /**
-   * Returns true if there are watched instances that aren't weakly reachable, and
-   * have been watched for long enough to be considered retained.
-   */
-  val hasRetainedInstances: Boolean
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.any { it.value.retainedUptimeMillis != -1L }
-    }
-
-  val retainedInstanceCount: Int
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.count { it.value.retainedUptimeMillis != -1L }
-    }
-
-  /**
-   * Returns true if there are watched instances that aren't weakly reachable, even
-   * if they haven't been watched for long enough to be considered retained.
-   */
-  val hasWatchedInstances: Boolean
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      return watchedInstances.isNotEmpty()
-    }
-
-  /**
-   * Returns the instances that are currently considered retained. Useful for logging purposes.
-   * Be careful with those instances and release them ASAP as you may creating longer lived leaks
-   * then the one that are already there.
-   */
-  val retainedInstances: List<Any>
-    @Synchronized get() {
-      removeWeaklyReachableInstances()
-      val instances = mutableListOf<Any>()
-      for (weakReference in watchedInstances.values) {
-        if (weakReference.retainedUptimeMillis != -1L) {
-          val instance = weakReference.get()
-          if (instance != null) {
-            instances.add(instance)
-          }
-        }
-      }
-      return instances
-    }
-
-  /**
-   * Identical to [.watch] with an empty string reference name.
-   */
-  @Synchronized fun watch(watchedInstance: Any) {
-    watch(watchedInstance, "")
-  }
-
-  /**
-   * Watches the provided instances.
-   *
-   * @param name A logical identifier for the watched object.
-   */
-  @Synchronized fun watch(
-    watchedInstance: Any,
-    name: String
-  ) {
-    if (!isEnabled()) {
-      return
-    }
-    removeWeaklyReachableInstances()
-    val key = UUID.randomUUID()
-        .toString()
-    val watchUptimeMillis = clock.uptimeMillis()
-    val reference =
-      KeyedWeakReference(watchedInstance, key, name, watchUptimeMillis, queue)
-    if (name != "") {
-      CanaryLog.d(
-          "Watching instance of %s named %s with key %s", reference.className,
-          name, key
-      )
-    } else {
-      CanaryLog.d(
-          "Watching instance of %s with key %s", reference.className, key
-      )
-    }
-
-    watchedInstances[key] = reference
-    checkRetainedExecutor.execute {
-      moveToRetained(key)
-    }
-  }
-
-  @Synchronized private fun moveToRetained(key: String) {
-    removeWeaklyReachableInstances()
-    val retainedRef = watchedInstances[key]
-    if (retainedRef != null) {
-      retainedRef.retainedUptimeMillis = clock.uptimeMillis()
-      onInstanceRetained()
-    }
-  }
-
-  @Synchronized fun removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis: Long) {
-    val retainedBeforeHeapdump =
-      watchedInstances.filter { it.value.retainedUptimeMillis in 0..heapDumpUptimeMillis }
-          .keys
-    watchedInstances.keys.removeAll(retainedBeforeHeapdump)
-  }
-
-  @Synchronized fun clearWatchedInstances() {
-    watchedInstances.clear()
-  }
-
-  private fun removeWeaklyReachableInstances() {
-    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
-    // reachable. This is before finalization or garbage collection has actually happened.
-    var ref: KeyedWeakReference?
-    do {
-      ref = queue.poll() as KeyedWeakReference?
-      if (ref != null) {
-        watchedInstances.remove(ref.key)
-      }
-    } while (ref != null)
-  }
-}
diff --git a/mkdocs.yml b/mkdocs.yml
index 10eede1a..7edc2f4b 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -13,11 +13,14 @@ copyright: 'Copyright &copy; 2015 Square, Inc.'
 
 theme:
   name: 'material'
+  custom_dir: 'docs/theme'
   logo: 'images/logo.png'
   favicon: 'images/logo.png'
   palette:
     primary: 'deep-orange'
     accent: 'deep-purple'
+  feature:
+    tabs: true
 
 markdown_extensions:
   - smarty
@@ -44,14 +47,32 @@ nav:
   - 'Fundamentals': fundamentals.md
   - 'Code recipes': recipes.md
   - 'FAQ': faq.md
-  - 'Stack Overflow ‚èè': https://stackoverflow.com/questions/tagged/leakcanary?sort=active
   - 'Change Log': changelog.md
-  - 'Support': support.md
-  - 'Upgrading to LeakCanary 2': upgrading-to-leakcanary-2.0.md
-  - 'Blog Articles': blog-articles.md
-  - 'Recorded Presentations': recorded-presentations.md
-  - 'Contributing': contributing.md
-  - 'Code of Conduct': code_of_conduct.md
+  - 'Help & Community':
+    - 'Support': support.md
+    - 'Upgrading to LeakCanary 2': upgrading-to-leakcanary-2.0.md
+    - 'Recorded Presentations': recorded-presentations.md
+    - 'Blog Articles': blog-articles.md
+    - 'Stack Overflow ‚èè': https://stackoverflow.com/questions/tagged/leakcanary?sort=active
+    - 'Contributing':
+        - 'How to help': how_to_help.md
+        - 'Code of Conduct': code_of_conduct.md
+        - 'Dev Environment': dev-env.md
+        - 'Releasing': releasing.md
+  - 'Shark':
+    - 'Overview': shark.md
+    - 'Shark API':
+      - 'Shark': api/shark/shark/index.md
+      - 'Extension: Shark Android': api/shark-android/shark/index.md
+      - 'Core: Graph': api/shark-graph/shark/index.md
+      - 'Core: Hprof': api/shark-hprof/shark/index.md
+      - 'Core: Logs': api/shark-log/shark/index.md
+  - 'LeakCanary API':
+    - 'LeakCanary': api/leakcanary-android-core/leakcanary/index.md
+    - 'ObjectWatcher Android': api/leakcanary-object-watcher-android/leakcanary/index.md
+    - 'Extension: Instrumentation tests': api/leakcanary-android-instrumentation/leakcanary/index.md
+    - 'Extension: Separate process': api/leakcanary-android-process/leakcanary/index.md
+    - 'Core: ObjectWatcher': api/leakcanary-object-watcher/leakcanary/index.md
 
 # Google Analytics. Add export LEAKCANARY_GOOGLE_ANALYTICS_KEY="UA-XXXXXXXXX-X" to your ~/.bashrc
 google_analytics:
diff --git a/settings.gradle b/settings.gradle
index ed968aba..51e7d44d 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,10 +1,15 @@
-include ':leakcanary-analyzer'
 include ':leakcanary-android'
 include ':leakcanary-android-core'
 include ':leakcanary-android-instrumentation'
 include ':leakcanary-android-process'
-include ':leakcanary-haha'
-include ':leakcanary-leaksentry'
-include ':leakcanary-log'
-include ':leakcanary-sample'
-include ':leakcanary-watcher'
\ No newline at end of file
+include ':leakcanary-android-sample'
+include ':leakcanary-object-watcher'
+include ':leakcanary-object-watcher-android'
+include ':leakcanary-object-watcher-android-androidx'
+include ':shark'
+include ':shark-android'
+include ':shark-cli'
+include ':shark-graph'
+include ':shark-hprof'
+include ':shark-log'
+include ':shark-test'
diff --git a/leakcanary-analyzer/build.gradle b/shark-android/build.gradle
similarity index 56%
rename from leakcanary-analyzer/build.gradle
rename to shark-android/build.gradle
index cf4d3a4a..b4532853 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/shark-android/build.gradle
@@ -5,10 +5,8 @@ sourceCompatibility = JavaVersion.VERSION_1_7
 targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  api project(':leakcanary-watcher')
-  api project(':leakcanary-haha')
+  api project(':shark')
 
-  implementation deps.androidx.annotation
   implementation deps.kotlin.stdlib
 
   testImplementation deps.assertj_core
@@ -16,5 +14,4 @@ dependencies {
   testImplementation deps.okio
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-android/gradle.properties b/shark-android/gradle.properties
new file mode 100644
index 00000000..e2aa8623
--- /dev/null
+++ b/shark-android/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-android
+POM_NAME=Shark for Android heaps
+POM_PACKAGING=jar
diff --git a/shark-android/src/main/java/shark/AndroidBuildMirror.kt b/shark-android/src/main/java/shark/AndroidBuildMirror.kt
new file mode 100644
index 00000000..3c4ac5bb
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidBuildMirror.kt
@@ -0,0 +1,31 @@
+package shark
+
+/**
+ * Caches values from the android.os.Build class in the heap dump.
+ * Retrieve a cached instances via [fromHeapGraph].
+ */
+class AndroidBuildMirror(
+  /**
+   * Value of android.os.Build.MANUFACTURER
+   */
+  val manufacturer: String,
+  /**
+   * Value of android.os.Build.VERSION.SDK_INT
+   */
+  val sdkInt: Int
+) {
+  companion object {
+    /**
+     * @see AndroidBuildMirror
+     */
+    fun fromHeapGraph(graph: HeapGraph): AndroidBuildMirror {
+      return graph.context.getOrPut(AndroidBuildMirror::class.java.name) {
+        val buildClass = graph.findClassByName("android.os.Build")!!
+        val versionClass = graph.findClassByName("android.os.Build\$VERSION")!!
+        val manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
+        val sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
+        AndroidBuildMirror(manufacturer, sdkInt)
+      }
+    }
+  }
+}
diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
new file mode 100644
index 00000000..5808425b
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -0,0 +1,463 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import shark.AndroidObjectInspectors.Companion.appDefaults
+import shark.HeapObject.HeapInstance
+
+/**
+ * A set of default [ObjectInspector]s that knows about common AOSP and library
+ * classes.
+ *
+ * These are heuristics based on our experience and knowledge of AOSP and various library
+ * internals. We only make a decision if we're reasonably sure the state of an object is
+ * unlikely to be the result of a programmer mistake.
+ *
+ * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+ * will not be influenced by those mistakes.
+ *
+ * Most developers should use the entire set of default [ObjectInspector] by calling [appDefaults],
+ * unless there's a bug and you temporarily want to remove an inspector.
+ */
+enum class AndroidObjectInspectors : ObjectInspector {
+
+  VIEW {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.view.View") { instance ->
+        // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
+        // next toast view
+        val mParentRef = instance["android.view.View", "mParent"]!!.value
+        val mParentSet = mParentRef.isNonNullReference
+        val mWindowAttachCount =
+          instance["android.view.View", "mWindowAttachCount"]?.value!!.asInt!!
+        val viewDetached = instance["android.view.View", "mAttachInfo"]!!.value.isNullReference
+        val mContext = instance["android.view.View", "mContext"]!!.value.asObject!!.asInstance!!
+
+        val activityContext = mContext.unwrapActivityContext()
+        labels += if (activityContext == null) {
+          "mContext instance of ${mContext.instanceClassName}, not wrapping activity"
+        } else {
+          val activityDescription =
+            "with mDestroyed = " + (activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
+                ?: "UNKNOWN")
+          if (activityContext == mContext) {
+            "mContext instance of ${activityContext.instanceClassName} $activityDescription"
+          } else {
+            "mContext instance of ${mContext.instanceClassName}, wrapping activity ${activityContext.instanceClassName} $activityDescription"
+          }
+        }
+        if (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true) {
+          leakingReasons += "View.mContext references a destroyed activity"
+        } else {
+          if (mParentSet && mWindowAttachCount > 0) {
+            if (viewDetached) {
+              likelyLeakingReasons += "View detached and has parent"
+            } else {
+              val viewParent = mParentRef.asObject!!.asInstance!!
+              if (viewParent instanceOf "android.view.View") {
+                if (viewParent["android.view.View", "mAttachInfo"]!!.value.isNullReference) {
+                  likelyLeakingReasons += "View attached but parent ${viewParent.instanceClassName} detached (attach disorder)"
+                } else {
+                  notLeakingReasons += "View attached"
+                  labels += "View.parent ${viewParent.instanceClassName} attached as well"
+                }
+              } else {
+                notLeakingReasons += "View attached"
+                labels += "Parent ${viewParent.instanceClassName} not a android.view.View"
+              }
+            }
+          }
+        }
+
+        if (mParentSet) {
+          labels += "View#mParent is set"
+        } else {
+          labels += "View#mParent is null"
+        }
+
+        if (viewDetached) {
+          labels += "View#mAttachInfo is null (view detached)"
+        } else {
+          labels += "View#mAttachInfo is not null (view attached)"
+        }
+
+        // TODO Add back support for view id labels, see https://github.com/square/leakcanary/issues/1297
+
+        labels += "View.mWindowAttachCount = $mWindowAttachCount"
+      }
+    }
+  },
+
+  EDITOR {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.widget.Editor") { instance ->
+        applyFromField(VIEW, instance["android.widget.Editor", "mTextView"])
+      }
+    }
+  },
+
+  ACTIVITY {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Activity") { instance ->
+        // Activity.mDestroyed was introduced in 17.
+        // https://android.googlesource.com/platform/frameworks/base/+
+        // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
+        val field = instance["android.app.Activity", "mDestroyed"]
+
+        if (field != null) {
+          if (field.value.asBoolean!!) {
+            leakingReasons += field describedWithValue "true"
+          } else {
+            notLeakingReasons += field describedWithValue "false"
+          }
+        }
+      }
+    }
+  },
+
+  CONTEXT_WRAPPER {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.content.ContextWrapper") { instance ->
+        // Activity is already taken care of
+        if (!(instance instanceOf "android.app.Activity")) {
+          val activityContext = instance.unwrapActivityContext()
+          if (activityContext != null) {
+            val mDestroyed = activityContext["android.app.Activity", "mDestroyed"]
+            if (mDestroyed != null) {
+              if (mDestroyed.value.asBoolean!!) {
+                leakingReasons += "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed true"
+              } else {
+                // We can't assume it's not leaking, because this context might have a shorter lifecycle
+                // than the activity. So we'll just add a label.
+                labels += "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed false"
+              }
+            }
+          } else {
+            labels += "${instance.instanceClassSimpleName} does not wrap an activity context"
+          }
+        }
+      }
+    }
+  },
+
+  DIALOG {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Dialog") { instance ->
+        val mDecor = instance["android.app.Dialog", "mDecor"]!!
+        if (mDecor.value.isNullReference) {
+          leakingReasons += mDecor describedWithValue "null"
+        } else {
+          notLeakingReasons += mDecor describedWithValue "not null"
+        }
+      }
+    }
+  },
+
+  APPLICATION {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Application") {
+        notLeakingReasons += "Application is a singleton"
+      }
+    }
+  },
+
+  INPUT_METHOD_MANAGER {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.view.inputmethod.InputMethodManager") {
+        notLeakingReasons += "InputMethodManager is a singleton"
+      }
+    }
+  },
+
+  FRAGMENT {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.app.Fragment") { instance ->
+        val fragmentManager = instance["android.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          leakingReasons += fragmentManager describedWithValue "null"
+        } else {
+          notLeakingReasons += fragmentManager describedWithValue "not null"
+        }
+        val mTag = instance["android.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          labels += "Fragment.mTag=$mTag"
+        }
+      }
+    }
+  },
+
+  SUPPORT_FRAGMENT {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.support.v4.app.Fragment") { instance ->
+        val fragmentManager = instance["android.support.v4.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          leakingReasons += fragmentManager describedWithValue "null"
+        } else {
+          notLeakingReasons += fragmentManager describedWithValue "not null"
+        }
+        val mTag = instance["android.support.v4.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          labels += "Fragment.mTag=$mTag"
+        }
+      }
+    }
+  },
+
+  ANDROIDX_FRAGMENT {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("androidx.fragment.app.Fragment") { instance ->
+        val fragmentManager = instance["androidx.fragment.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          leakingReasons += fragmentManager describedWithValue "null"
+        } else {
+          notLeakingReasons += fragmentManager describedWithValue "not null"
+        }
+        val mTag = instance["androidx.fragment.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          labels += "Fragment.mTag=$mTag"
+        }
+      }
+    }
+  },
+
+  MESSAGE_QUEUE {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.os.MessageQueue") { instance ->
+        // mQuiting had a typo and was renamed to mQuitting
+        // https://android.googlesource.com/platform/frameworks/base/+/013cf847bcfd2828d34dced60adf2d3dd98021dc
+        val mQuitting = instance["android.os.MessageQueue", "mQuitting"]
+            ?: instance["android.os.MessageQueue", "mQuiting"]!!
+        if (mQuitting.value.asBoolean!!) {
+          leakingReasons += mQuitting describedWithValue "true"
+        } else {
+          notLeakingReasons += mQuitting describedWithValue "false"
+        }
+      }
+    }
+  },
+
+  MORTAR_PRESENTER {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("mortar.Presenter") { instance ->
+        // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
+        // should be unreachable, so in that case we don't know their reachability status. However,
+        // when the view is null, we're pretty sure they  never leaking.
+        val view = instance["mortar.Presenter", "view"]!!
+        if (view.value.isNullReference) {
+          leakingReasons += view describedWithValue "null"
+        } else {
+          labels += view describedWithValue "set"
+        }
+      }
+    }
+  },
+
+  MORTAR_SCOPE {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("mortar.MortarScope") { instance ->
+        val dead = instance["mortar.MortarScope", "dead"]!!.value.asBoolean!!
+        val scopeName = instance["mortar.MortarScope", "name"]!!.value.readAsJavaString()
+        if (dead) {
+          leakingReasons += "mortar.MortarScope.dead is true for scope $scopeName"
+        } else {
+          notLeakingReasons += "mortar.MortarScope.dead is false for scope $scopeName"
+        }
+      }
+    }
+  },
+
+  COORDINATOR {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
+        val attached = instance["com.squareup.coordinators.Coordinator", "attached"]
+        if (attached!!.value.asBoolean!!) {
+          notLeakingReasons += attached describedWithValue "true"
+        } else {
+          leakingReasons += attached describedWithValue "false"
+        }
+      }
+    }
+  },
+
+  MAIN_THREAD {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(Thread::class) { instance ->
+        val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
+        if (threadName == "main") {
+          notLeakingReasons += "the main thread always runs"
+        }
+      }
+    }
+  },
+
+  VIEW_ROOT_IMPL {
+    override fun inspect(reporter: ObjectReporter) {
+      reporter.whenInstanceOf("android.view.ViewRootImpl") { instance ->
+        val mViewField = instance["android.view.ViewRootImpl", "mView"]!!
+        if (mViewField.value.isNullReference) {
+          leakingReasons += mViewField describedWithValue "null"
+        } else {
+          notLeakingReasons += mViewField describedWithValue "not null"
+        }
+      }
+    }
+  },
+
+  WINDOW {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.view.Window") { instance ->
+        val mDestroyed = instance["android.view.Window", "mDestroyed"]!!
+
+        if (mDestroyed.value.asBoolean!!) {
+          leakingReasons += mDestroyed describedWithValue "true"
+        } else {
+          notLeakingReasons += mDestroyed describedWithValue "false"
+        }
+      }
+    }
+  },
+
+  TOAST {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf("android.widget.Toast") { instance ->
+        val tnInstance =
+          instance["android.widget.Toast", "mTN"]!!.value.asObject!!.asInstance!!
+        // mWM is set in android.widget.Toast.TN#handleShow and never unset, so this toast was never
+        // shown, we don't know if it's leaking.
+        if (tnInstance["android.widget.Toast\$TN", "mWM"]!!.value.isNonNullReference) {
+          // mView is reset to null in android.widget.Toast.TN#handleHide
+          if (tnInstance["android.widget.Toast\$TN", "mView"]!!.value.isNullReference) {
+            leakingReasons += "This toast is done showing (Toast.mTN.mWM != null && Toast.mTN.mView == null)"
+          } else {
+            notLeakingReasons += "This toast is showing (Toast.mTN.mWM != null && Toast.mTN.mView != null)"
+          }
+        }
+      }
+    }
+  };
+
+  companion object {
+    /** @see AndroidObjectInspectors */
+    val appDefaults: List<ObjectInspector>
+      get() {
+        return values().toList() + ObjectInspectors.jdkDefaults
+      }
+  }
+}
+
+private infix fun HeapField.describedWithValue(valueDescription: String): String {
+  return "${declaringClass.simpleName}#$name is $valueDescription"
+}
+
+private fun ObjectReporter.applyFromField(
+  inspector: ObjectInspector,
+  field: HeapField?
+) {
+  if (field == null) {
+    return
+  }
+  if (field.value.isNullReference) {
+    return
+  }
+  val heapObject = field.value.asObject!!
+  val delegateReporter = ObjectReporter(heapObject)
+  inspector.inspect(delegateReporter)
+  val prefix = "${field.declaringClass.simpleName}#${field.name}:"
+
+  labels += delegateReporter.labels.map { "$prefix $it" }
+  leakingReasons += delegateReporter.leakingReasons.map { "$prefix $it" }
+  likelyLeakingReasons += delegateReporter.likelyLeakingReasons.map { "$prefix $it" }
+  notLeakingReasons += delegateReporter.notLeakingReasons.map { "$prefix $it" }
+}
+
+/**
+ * Recursively unwraps `this` [HeapInstance] as a ContextWrapper until an Activity is found in which case it is
+ * returned. Returns null if no activity was found.
+ */
+@Suppress("NestedBlockDepth")
+fun HeapInstance.unwrapActivityContext(): HeapInstance? {
+  if (this instanceOf "android.app.Activity") {
+    return this
+  }
+  if (this instanceOf "android.content.ContextWrapper") {
+    var context = this
+    val visitedInstances = mutableListOf<Long>()
+    var keepUnwrapping = true
+    while (keepUnwrapping) {
+      visitedInstances += context.objectId
+      keepUnwrapping = false
+      val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
+
+      if (mBase.isNonNullReference) {
+        var parentContext = context
+        context = mBase.asObject!!.asInstance!!
+        if (context instanceOf "android.app.Activity") {
+          return context
+        } else {
+          if (parentContext instanceOf "com.android.internal.policy.DecorContext") {
+            // mBase isn't an activity, let's unwrap DecorContext.mPhoneWindow.mContext instead
+            val mPhoneWindowField =
+              parentContext["com.android.internal.policy.DecorContext", "mPhoneWindow"]
+            if (mPhoneWindowField != null) {
+              val phoneWindow = mPhoneWindowField.valueAsInstance!!
+              context = phoneWindow["android.view.Window", "mContext"]!!.valueAsInstance!!
+              if (context instanceOf "android.app.Activity") {
+                return context
+              }
+            }
+          }
+          if (context instanceOf "android.content.ContextWrapper" &&
+              // Avoids infinite loops
+              context.objectId !in visitedInstances
+          ) {
+            keepUnwrapping = true
+          }
+        }
+      }
+    }
+  }
+  return null
+}
\ No newline at end of file
diff --git a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
new file mode 100644
index 00000000..ad8f6d28
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
@@ -0,0 +1,1309 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import shark.AndroidReferenceMatchers.Companion.appDefaults
+import shark.AndroidReferenceMatchers.Companion.buildKnownReferences
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.NativeGlobalVariablePattern
+import shark.ReferencePattern.StaticFieldPattern
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import java.util.EnumSet
+
+/**
+ * [AndroidReferenceMatchers] values add [ReferenceMatcher] instances to a global list via their
+ * [add] method. A [ReferenceMatcher] is either a [IgnoredReferenceMatcher] or
+ * a [LibraryLeakReferenceMatcher].
+ *
+ * [AndroidReferenceMatchers] is used to build the list of known references that cannot ever create
+ * leaks (via [IgnoredReferenceMatcher]) as well as the list of known leaks in the Android Framework
+ * and¬†in manufacturer specific Android implementations.
+ *
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use [appDefaults]. However, you can also use a subset of
+ * [AndroidReferenceMatchers] by creating an [EnumSet] that matches your needs and calling
+ * [buildKnownReferences].
+ */
+enum class AndroidReferenceMatchers {
+
+  // ######## Android Framework known leaks ########
+
+  ACTIVITY_CLIENT_RECORD__NEXT_IDLE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.app.ActivityThread\$ActivityClientRecord", "nextIdle",
+          description = "Android AOSP sometimes keeps a reference to a destroyed activity as a"
+              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+              + " Not sure what's going on there, input welcome."
+      ) {
+        sdkInt in 19..27
+      }
+    }
+  },
+
+  SPAN_CONTROLLER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("Editor inserts a special span, which has a reference to the EditText. That span is a"
+            + " NoCopySpan, which makes sure it gets dropped when creating a new"
+            + " SpannableStringBuilder from a given CharSequence."
+            + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+            + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+            + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+            + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+            + " reference to the textview and therefore the entire view hierarchy & activity"
+            + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+            + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+            + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+            + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
+
+      references += instanceFieldLeak(
+          "android.widget.Editor\$SpanController", "this$0", description
+      ) {
+        sdkInt <= 19
+      }
+
+      references += instanceFieldLeak(
+          "android.widget.Editor\$EasyEditSpanController", "this$0", description
+      ) {
+        sdkInt <= 19
+      }
+    }
+  },
+
+  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references +=
+        staticFieldLeak(
+            "android.media.session.MediaSessionLegacyHelper", "sInstance",
+            description = "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+                + " keeps a reference to the context it's given the first time"
+                + " MediaSessionLegacyHelper.getHelper() is called."
+                + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+                + " calling context.getApplicationContext()."
+                + " Fix: https://github.com/android/platform_frameworks_base/commit"
+                + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+                + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+                + " in Application.onCreate() and pass it the application context."
+        ) {
+          sdkInt == 21
+        }
+    }
+  },
+
+  TEXT_LINE__SCACHED {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.text.TextLine", "sCached",
+          description = "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+              + " at least two bugs that created memory leaks by not correctly clearing the"
+              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/893d6fe48d37f71e683f722457bea646994a10"
+              + " The second was fixed, not released yet:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+              + " To fix this, you could access TextLine.sCached and clear the pool every now"
+              + " and then (e.g. on activity destroy)."
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  BLOCKING_QUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description = ("A thread waiting on a blocking queue will leak the last"
+          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+          + " keeps a local reference to the last message it received. That message then gets"
+          + " recycled and can be used again. As long as all messages are recycled after being"
+          + " used, this won't be a problem, because these references are cleared when being"
+          + " recycled. However, dialogs create template Message instances to be copied when a"
+          + " message needs to be sent. These Message templates holds references to the dialog"
+          + " listeners, which most likely leads to holding a reference onto the activity in some"
+          + " way. Dialogs never recycle their template Message, assuming these Message instances"
+          + " will get GCed when the dialog is GCed."
+          + " The combination of these two things creates a high potential for memory leaks as soon"
+          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+          + " sleep for a long time."
+          + " To fix this, you could post empty messages to the idle handler threads from time to"
+          + " time. This won't be easy because you cannot access all handler threads, but a library"
+          + " that is widely used should consider doing this for its own handler threads. This leaks"
+          + " has been shown to happen in both Dalvik and ART.")
+
+      references += instanceFieldLeak("android.os.Message", "obj", description)
+      references += instanceFieldLeak("android.os.Message", "next", description)
+      references += instanceFieldLeak("android.os.Message", "target", description)
+    }
+  },
+
+  INPUT_METHOD_MANAGER_IS_TERRIBLE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("When we detach a view that receives keyboard input, the InputMethodManager"
+            + " leaks a reference to it until a new view asks for keyboard input."
+            + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+            + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mNextServedView", description
+      ) {
+        sdkInt in 15..27
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mServedView", description
+      ) {
+        sdkInt in 15..27
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mServedInputConnection", description
+      ) {
+        sdkInt in 15..27
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mLastSrvView"
+          ,
+          description =
+          "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
+      ) {
+        manufacturer == HUAWEI && sdkInt in 23..28
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mCurRootView",
+          description = "The singleton InputMethodManager is holding a reference to mCurRootView long"
+              + " after the activity has been destroyed."
+              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+              + "#issuecomment-100579429"
+              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
+      ) {
+        sdkInt in 15..28
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mImeInsetsConsumer",
+          description = """
+              Android Q Beta has a leak where InputMethodManager.mImeInsetsConsumer isn't set to
+              null when the activity is destroyed.
+            """.trimIndent()
+      ) {
+        sdkInt == 28
+      }
+
+      references += instanceFieldLeak(
+          "android.view.inputmethod.InputMethodManager", "mCurrentInputConnection",
+          description = """
+              In Android Q Beta InputMethodManager keeps its EditableInputConnection after the
+              activity has been destroyed.
+            """.trimIndent()
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  LAYOUT_TRANSITION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.animation.LayoutTransition$1", "val\$parent",
+          description = "LayoutTransition leaks parent ViewGroup through"
+              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+              + " window is destroyed. Tracked here:"
+              + " https://code.google.com/p/android/issues/detail?id=171830"
+      ) {
+        sdkInt in 14..22
+      }
+    }
+  },
+
+  SPELL_CHECKER_SESSION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.view.textservice.SpellCheckerSession$1", "this$0",
+          description = "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+              + " SpellCheckerSession is closed before the service is connected."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
+      ) {
+        sdkInt in 16..24
+      }
+    }
+  },
+
+  SPELL_CHECKER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.widget.SpellChecker$1", "this$0",
+          description = "SpellChecker holds on to a detached view that points to a destroyed activity."
+              + " mSpellRunnable is being enqueued, and that callback should be removed when "
+              + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+              + " called after the view was detached."
+      ) {
+        sdkInt == 22
+      }
+    }
+  },
+
+  ACTIVITY_CHOOSE_MODEL {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description = ("ActivityChooserModel holds a static reference to the last set"
+          + " ActivityChooserModelPolicy which can be an activity context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
+
+
+      references += instanceFieldLeak(
+          "android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy",
+          description = description
+      ) {
+        sdkInt in 15..22
+      }
+
+      references += instanceFieldLeak(
+          "android.widget.ActivityChooserModel", "mActivityChoserModelPolicy",
+          description = description
+      )
+    }
+  },
+
+  MEDIA_PROJECTION_CALLBACK {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.media.projection.MediaProjection\$MediaProjectionCallback",
+          "this$0", description = """
+              MediaProjectionCallback is held by another process, and holds on to MediaProjection
+              which has an activity as its context.
+            """.trimIndent()
+      ) {
+        sdkInt in 22..28
+      }
+    }
+
+  },
+
+  SPEECH_RECOGNIZER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.speech.SpeechRecognizer\$InternalListener", "this$0"
+          ,
+          description = "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+              + " class and leaked the SpeechRecognizer which leaked an activity context."
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + " /b37866db469e81aca534ff6186bdafd44352329b"
+      ) {
+        sdkInt < 21
+      }
+    }
+  },
+
+  ACCOUNT_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.accounts.AccountManager\$AmsTask\$Response", "this$1"
+          ,
+          description =
+          "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
+              + " probably because the reference to the response in the other process hasn't been"
+              + " cleared."
+              + " AccountManager\$AmsTask is holding on to the activity reference to use for"
+              + " launching a new sub- Activity."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+              + " with the returned future to to get the result and correctly start an activity"
+              + " when it's available."
+      ) {
+        sdkInt <= 27
+      }
+    }
+  },
+
+  MEDIA_SCANNER_CONNECTION {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.media.MediaScannerConnection", "mContext",
+
+          description =
+          "The static method MediaScannerConnection.scanFile() takes an activity context"
+              + " but the service might not disconnect after the activity has been destroyed."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+              + " application context. Call connect() and disconnect() manually."
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  USER_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.os.UserManager", "mContext",
+          description =
+          "UserManager has a static sInstance field that creates an instance and caches it"
+              + " the first time UserManager.get() is called. This instance is created with the"
+              + " outer context (which is an activity base context)."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+              + "/27db46850b708070452c0ce49daf5f79503fbde6"
+              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+              + " UserManager instance gets cached with a reference to the application context."
+      ) {
+        sdkInt in 18..25
+      }
+    }
+  },
+
+  APP_WIDGET_HOST_CALLBACKS {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.appwidget.AppWidgetHost\$Callbacks", "this$0"
+          ,
+          description =
+          "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
+              + " code. The reference to the `mContext` was not being cleared, which caused the"
+              + " Callbacks instance to retain this reference"
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
+      ) {
+        sdkInt < 22
+      }
+    }
+  },
+
+  AUDIO_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.media.AudioManager$1", "this$0",
+          description =
+          "Prior to Android M, VideoView required audio focus from AudioManager and"
+              + " never abandoned it, which leaks the Activity context through the AudioManager."
+              + " The root of the problem is that AudioManager uses whichever"
+              + " context it receives, which in the case of the VideoView example is an Activity,"
+              + " even though it only needs the application's context. The issue is fixed in"
+              + " Android M, and the AudioManager now uses the application's context."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
+      ) {
+        sdkInt <= 22
+      }
+    }
+  },
+
+  EDITTEXT_BLINK_MESSAGEQUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.widget.Editor\$Blink", "this$0",
+          description =
+          "The EditText Blink of the Cursor is implemented using a callback and Messages,"
+              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+              + " contains a blinking cursor is detached, a message is posted with a delay after the"
+              + " dialog has been closed and as a result leaks the Activity."
+              + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+              + " dismiss() method of the dialog."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
+      ) {
+        sdkInt <= 23
+      }
+    }
+  },
+
+  CONNECTIVITY_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.net.ConnectivityManager", "sInstance",
+          description =
+          "ConnectivityManager has a sInstance field that is set when the first"
+              + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+              + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+              + " ConnectivityManager instance is created with the activity context and stored in"
+              + " sInstance. That activity context then leaks forever."
+              + " Until this is fixed, app developers can prevent this leak by making sure the"
+              + " ConnectivityManager is first created with an App Context. E.g. in some static"
+              + " init do: context.getApplicationContext()"
+              + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+              + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+              + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
+      ) {
+        sdkInt <= 23
+      }
+    }
+  },
+
+  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.view.accessibility.AccessibilityNodeInfo", "mOriginalText"
+          ,
+          description =
+          "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
+              + " AccessibilityNodeInfo instances are released back in the pool,"
+              + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
+              + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
+              + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+              + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+              + "android/view/accessibility/AccessibilityNodeInfo.java"
+      ) {
+        sdkInt in 26..27
+      }
+    }
+  },
+
+  ASSIST_STRUCTURE {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.app.assist.AssistStructure\$ViewNodeText", "mText"
+          ,
+          description = "AssistStructure (google assistant / autofill) holds on to text spannables" +
+              " on the screen. TextView.ChangeWatcher and android.widget.Editor end up in spans and" +
+              " typically hold on to the view hierarchy"
+      ) {
+        sdkInt in 24..28
+      }
+    }
+  },
+
+  ACCESSIBILITY_ITERATORS {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.widget.AccessibilityIterators\$LineTextSegmentIterator", "mLayout"
+          ,
+          description = "AccessibilityIterators holds on to text layouts which can hold on to spans" +
+              " TextView.ChangeWatcher and android.widget.Editor end up in spans and" +
+              " typically hold on to the view hierarchy"
+      ) {
+        sdkInt == 27
+      }
+    }
+  },
+
+  BIOMETRIC_PROMPT {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.hardware.biometrics.BiometricPrompt", "mFingerprintManager"
+          ,
+          description = "BiometricPrompt holds on to a FingerprintManager which holds on to a " +
+              "destroyed activity."
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  MAGNIFIER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.widget.Magnifier\$InternalPopupWindow", "mCallback"
+          ,
+          description = "android.widget.Magnifier.InternalPopupWindow registers a frame callback" +
+              " on android.view.ThreadedRenderer.SimpleRenderer which holds it as a native" +
+              " reference. android.widget.Editor\$InsertionHandleView registers an" +
+              " OnOperationCompleteCallback on Magnifier.InternalPopupWindow. These references are" +
+              " held after the activity has been destroyed."
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  BACKDROP_FRAME_RENDERER__MDECORVIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.android.internal.policy.BackdropFrameRenderer", "mDecorView"
+          ,
+          description =
+          "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
+              + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+              + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
+              + " activity"
+      ) {
+        sdkInt in 24..26
+      }
+    }
+  },
+
+  VIEWLOCATIONHOLDER_ROOT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.view.ViewGroup\$ViewLocationHolder",
+          "mRoot"
+          ,
+          description = "In Android P, ViewLocationHolder has an mRoot field that is not cleared " +
+              "in its clear() method. Introduced in https://github.com/aosp-mirror" +
+              "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
+              "report: https://issuetracker.google.com/issues/112792715"
+      ) {
+        sdkInt == 28
+      }
+    }
+  },
+
+  ACCESSIBILITY_NODE_ID_MANAGER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.view.accessibility.AccessibilityNodeIdManager", "mIdsToViews"
+          ,
+          description = """
+              Android Q Beta added AccessibilityNodeIdManager which stores all views from their
+              onAttachedToWindow() call, until detached. Unfortunately it's possible to trigger
+              the view framework to call detach before attach (by having a view removing itself
+              from its parent in onAttach, which then causes AccessibilityNodeIdManager to keep
+              children view forever. Future releases of Q will hold weak references.
+            """.trimIndent()
+      ) {
+        sdkInt in 28..29
+      }
+    }
+  },
+
+  TEXT_TO_SPEECH {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description =
+        ("TextToSpeech.shutdown() does not release its references to context objects." +
+            " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
+            " keeping the references, resulting the context objects leaked." +
+            " Developers might be able to mitigate the issue by passing application context" +
+            " to TextToSpeech constructor." +
+            " Tracked at: https://github.com/square/leakcanary/issues/1210 and" +
+            " https://issuetracker.google.com/issues/129250419")
+      references += instanceFieldLeak(
+          "android.speech.tts.TextToSpeech", "mContext",
+          description = description
+      ) {
+        sdkInt == 24
+      }
+
+      references += instanceFieldLeak(
+          "android.speech.tts.TtsEngines", "mContext",
+          description = description
+      ) {
+        sdkInt == 24
+      }
+    }
+  },
+
+  WINDOW_MANAGER_GLOBAL {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.view.WindowManagerGlobal", "mRoots"
+          ,
+          description = """
+              ViewRootImpl references a destroyed activity yet it's not detached (still has a view)
+               and WindowManagerGlobal still references it.
+            """.trimIndent()
+      ) {
+        sdkInt == 27
+      }
+    }
+  },
+
+  CONTROLLED_INPUT_CONNECTION_WRAPPER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += nativeGlobalVariableLeak(
+          "android.view.inputmethod.InputMethodManager\$ControlledInputConnectionWrapper",
+          description = """
+        ControlledInputConnectionWrapper is held by a global variable in native code. 
+      """.trimIndent()
+      )
+    }
+  },
+
+  TOAST_TN {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += nativeGlobalVariableLeak(
+          "android.widget.Toast\$TN",
+          description = """
+        Toast.TN is held by a global variable in native code due to an IPC call to show the toast.
+      """.trimIndent()
+      )
+    }
+  },
+
+  // ######## Manufacturer specific known leaks ########
+
+  // SAMSUNG
+
+  SPEN_GESTURE_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "com.samsung.android.smartclip.SpenGestureManager", "mContext"
+          ,
+          description =
+          "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  CLIPBOARD_UI_MANAGER__SINSTANCE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.sec.clipboard.ClipboardUIManager", "mContext"
+          ,
+          description =
+          "ClipboardUIManager is a static singleton that leaks an activity context."
+              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+              + " application context. Example: https://gist.github.com/cypressious/"
+              + "91c4fb1455470d803a602838dfcd5774"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..21
+      }
+    }
+  },
+
+  SEM_CLIPBOARD_MANAGER__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      val description = """
+         SemClipboardManager inner classes are held by native references due to IPC calls 
+      """.trimIndent()
+      references += nativeGlobalVariableLeak(
+          "com.samsung.android.content.clipboard.SemClipboardManager$1", description
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..28
+      }
+      references += nativeGlobalVariableLeak(
+          "com.samsung.android.content.clipboard.SemClipboardManager$3", description
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..28
+      }
+    }
+  },
+
+  CLIPBOARD_EX_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.sec.clipboard.ClipboardExManager", "mContext",
+          description = "android.sec.clipboard.ClipboardExManager\$IClipboardDataPasteEventImpl\$1" +
+              " is a native callback that holds IClipboardDataPasteEventImpl which holds" +
+              " ClipboardExManager which has a destroyed activity as mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 23
+      }
+      references += instanceFieldLeak(
+          "android.sec.clipboard.ClipboardExManager", "mPersonaManager",
+          description = "android.sec.clipboard.ClipboardExManager\$IClipboardDataPasteEventImpl\$1" +
+              " is a native callback that holds IClipboardDataPasteEventImpl which holds" +
+              " ClipboardExManager which holds PersonaManager which has a destroyed activity as" +
+              " mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 23
+      }
+      references += instanceFieldLeak(
+          "android.widget.TextView\$IClipboardDataPasteEventImpl", "this\$0",
+          description = "TextView\$IClipboardDataPasteEventImpl\$1 is held by a native ref, and" +
+              " IClipboardDataPasteEventImpl ends up leaking a detached textview"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 22
+      }
+    }
+  },
+
+  SEM_EMERGENCY_MANAGER__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.samsung.android.emergencymode.SemEmergencyManager", "mContext"
+          ,
+          description =
+          "SemEmergencyManager is a static singleton that leaks a DecorContext." +
+              " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..24
+      }
+    }
+  },
+
+  SEM_PERSONA_MANAGER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "com.samsung.android.knox.SemPersonaManager", "mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 24
+      }
+    }
+  },
+
+  SEM_APP_ICON_SOLUTION {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.app.SemAppIconSolution", "mContext"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 28
+      }
+    }
+  },
+
+  AW_RESOURCE__SRESOURCES {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // AwResource#setResources() is called with resources that hold a reference to the
+      // activity context (instead of the application context) and doesn't clear it.
+      // Not sure what's going on there, input welcome.
+      references += staticFieldLeak(
+          "com.android.org.chromium.android_webview.AwResource", "sResources"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  TEXT_VIEW__MLAST_HOVERED_VIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.widget.TextView", "mLastHoveredView",
+          description =
+          "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 19..28
+      }
+    }
+  },
+
+  PERSONA_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.os.PersonaManager", "mContext",
+          description =
+          "android.app.LoadedApk.mResources has a reference to"
+              + " android.content.res.Resources.mPersonaManager which has a reference to"
+              + " android.os.PersonaManager.mContext which is an activity."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  RESOURCES__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.content.res.Resources", "mContext",
+          description =
+          "In AOSP the Resources class does not have a context."
+              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+              + " instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  VIEW_CONFIGURATION__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.view.ViewConfiguration", "mContext",
+          description =
+          "In AOSP the ViewConfiguration class does not have a context."
+              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+              + " ViewConfiguration instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues"
+              + "/1#issuecomment-100324683"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  AUDIO_MANAGER__MCONTEXT_STATIC {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.media.AudioManager", "mContext_static",
+          description =
+          "Samsung added a static mContext_static field to AudioManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/32"
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 19
+      }
+    }
+  },
+
+  ACTIVITY_MANAGER_MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.app.ActivityManager", "mContext",
+          description =
+          "Samsung added a static mContext field to ActivityManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+              + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
+      ) {
+        manufacturer == SAMSUNG && sdkInt in 22..23
+      }
+    }
+  },
+
+  STATIC_MTARGET_VIEW {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.widget.TextView", "mTargetView",
+          description =
+          "Samsung added a static mTargetView field to TextView which holds on to detached views."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 27
+      }
+    }
+  },
+
+  // OTHER MANUFACTURERS
+
+  GESTURE_BOOST_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.gestureboost.GestureBoostManager", "mContext"
+          ,
+          description =
+          "GestureBoostManager is a static singleton that leaks an activity context." +
+              " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+      ) {
+        manufacturer == HUAWEI && sdkInt in 24..25
+      }
+    }
+  },
+
+  BUBBLE_POPUP_HELPER__SHELPER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.widget.BubblePopupHelper", "sHelper",
+          description =
+          "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
+      ) {
+        manufacturer == LG && sdkInt in 19..22
+      }
+    }
+  },
+
+  LGCONTEXT__MCONTEXT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.lge.systemservice.core.LGContext", "mContext",
+          description = "LGContext is a static singleton that leaks an activity context."
+      ) {
+        manufacturer == LG && sdkInt == 21
+      }
+    }
+  },
+
+  SMART_COVER_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.lge.systemservice.core.SmartCoverManager", "mContext",
+          description = "SmartCoverManager\$CallbackRegister is a callback held by a native ref," +
+              " and SmartCoverManager ends up leaking an activity context."
+      ) {
+        manufacturer == LG && sdkInt == 27
+      }
+    }
+  },
+
+  MAPPER_CLIENT {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0"
+          ,
+          description =
+          "Not sure exactly what ControllerMapper is about, but there is an anonymous"
+              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+              + " ControllerMapper.MapperClient which leaks the activity context."
+      ) {
+        manufacturer == NVIDIA && sdkInt == 19
+      }
+    }
+  },
+
+  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.hardware.SystemSensorManager", "mAppContextImpl"
+          ,
+          description =
+          "SystemSensorManager stores a reference to context"
+              + " in a static field in its constructor."
+              + " Fix: use application context to get SensorManager"
+      ) {
+        (manufacturer == LENOVO && sdkInt == 19) || (manufacturer == VIVO && sdkInt == 22)
+      }
+    }
+  },
+
+  INSTRUMENTATION_RECOMMEND_ACTIVITY {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.app.Instrumentation", "mRecommendActivity",
+          description =
+          "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
+              + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+              + " above"
+      ) {
+        manufacturer == MEIZU && sdkInt in 21..22
+      }
+    }
+  },
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += instanceFieldLeak(
+          "android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0"
+          ,
+          description =
+          "DevicePolicyManager keeps a reference to the context it has been created with"
+              + " instead of extracting the application context. In this Motorola build,"
+              + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+              + " observer, which is held into memory by a binder transport object."
+      ) {
+        manufacturer == MOTOROLA && sdkInt in 19..22
+      }
+    }
+  },
+
+  EXTENDED_STATUS_BAR_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.app.ExtendedStatusBarManager", "sInstance"
+          ,
+          description =
+          """
+            ExtendedStatusBarManager is held in a static sInstance field and has a mContext
+            field which references a decor context which references a destroyed activity.
+          """.trimIndent()
+      ) {
+        manufacturer == SHARP && sdkInt == 28
+      }
+    }
+  },
+
+  OEM_SCENE_CALL_BLOCKER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "com.oneplus.util.OemSceneCallBlocker", "sContext",
+          description =
+          """
+            OemSceneCallBlocker has a sContext static field which holds on to an activity instance.
+          """.trimIndent()
+      ) {
+        manufacturer == ONE_PLUS && sdkInt == 28
+      }
+    }
+  },
+
+  // ######## Ignored references (not leaks) ########
+
+  REFERENCES {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += ignoredInstanceField(WeakReference::class.java.name, "referent")
+      references += ignoredInstanceField("leakcanary.KeyedWeakReference", "referent")
+      references += ignoredInstanceField(SoftReference::class.java.name, "referent")
+      references += ignoredInstanceField(PhantomReference::class.java.name, "referent")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "prev")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "element")
+      references += ignoredInstanceField("java.lang.ref.Finalizer", "next")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "prev")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "element")
+      references += ignoredInstanceField("java.lang.ref.FinalizerReference", "next")
+      references += ignoredInstanceField("sun.misc.Cleaner", "prev")
+      references += ignoredInstanceField("sun.misc.Cleaner", "next")
+    }
+  },
+
+  FINALIZER_WATCHDOG_DAEMON {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+      // reference to the object and it was about to be GCed.
+      references += ignoredJavaLocal("FinalizerWatchdogDaemon")
+    }
+  },
+
+  MAIN {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      // The main thread stack is ever changing so local variables aren't likely to hold references
+      // for long. If this is on the shortest path, it's probably that there's a longer path with
+      // a real leak.
+      references += ignoredJavaLocal("main")
+    }
+  },
+
+  LEAK_CANARY_THREAD {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += ignoredJavaLocal(LEAK_CANARY_THREAD_NAME)
+    }
+  },
+
+  LEAK_CANARY_HEAP_DUMPER {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      // Holds on to the resumed activity (which is never destroyed), so this will not cause leaks
+      // but may surface on the path when a resumed activity holds on to destroyed objects.
+      // Would have a path that doesn't include LeakCanary instead.
+      references += ignoredInstanceField("leakcanary.internal.AndroidHeapDumper", "resumedActivity")
+    }
+  },
+
+  LEAK_CANARY_INTERNAL {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += ignoredInstanceField("leakcanary.internal.InternalLeakCanary", "application")
+    }
+  },
+
+  EVENT_RECEIVER__MMESSAGE_QUEUE {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+      // the native peer of the receiver is using them.
+      // The main thread message queue is held on by the main Looper, but that might be a longer
+      // path. Let's not confuse people with a shorter path that is less meaningful.
+      references += ignoredInstanceField(
+          "android.view.Choreographer\$FrameDisplayEventReceiver", "mMessageQueue"
+      )
+    }
+  },
+
+  ;
+
+  internal abstract fun add(references: MutableList<ReferenceMatcher>)
+
+  companion object {
+    private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+    const val SAMSUNG = "samsung"
+    const val MOTOROLA = "motorola"
+    const val LENOVO = "LENOVO"
+    const val LG = "LGE"
+    const val NVIDIA = "NVIDIA"
+    const val MEIZU = "Meizu"
+    const val ONE_PLUS = "OnePlus"
+    const val HUAWEI = "HUAWEI"
+    const val VIVO = "vivo"
+    const val SHARP = "SHARP"
+
+    /**
+     * Returns a list of [ReferenceMatcher] that only contains [IgnoredReferenceMatcher] and no
+     * [LibraryLeakReferenceMatcher].
+     */
+    val ignoredReferencesOnly: List<ReferenceMatcher>
+      get() = buildKnownReferences(
+          EnumSet.of(
+              REFERENCES,
+              FINALIZER_WATCHDOG_DAEMON,
+              MAIN,
+              LEAK_CANARY_THREAD,
+              EVENT_RECEIVER__MMESSAGE_QUEUE
+          )
+      )
+
+    /**
+     * @see [AndroidReferenceMatchers]
+     */
+    val appDefaults: List<ReferenceMatcher>
+      get() = buildKnownReferences(EnumSet.allOf(AndroidReferenceMatchers::class.java))
+
+    /**
+     * Builds a list of [ReferenceMatcher] from the [referenceMatchers] set of
+     * [AndroidReferenceMatchers].
+     */
+    fun buildKnownReferences(referenceMatchers: Set<AndroidReferenceMatchers>): List<ReferenceMatcher> {
+      val resultSet = mutableListOf<ReferenceMatcher>()
+      referenceMatchers.forEach {
+        it.add(resultSet)
+      }
+      return resultSet
+    }
+
+    private val ALWAYS: AndroidBuildMirror.() -> Boolean = {
+      true
+    }
+
+    /**
+     * Creates a [LibraryLeakReferenceMatcher] that matches a [StaticFieldPattern].
+     * [description] should convey what we know about this library leak.
+     */
+    fun staticFieldLeak(
+      className: String,
+      fieldName: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(StaticFieldPattern(className, fieldName), description, patternApplies)
+    }
+
+    /**
+     * Creates a [LibraryLeakReferenceMatcher] that matches a [InstanceFieldPattern].
+     * [description] should convey what we know about this library leak.
+     */
+    fun instanceFieldLeak(
+      className: String,
+      fieldName: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(InstanceFieldPattern(className, fieldName), description, patternApplies)
+    }
+
+    fun nativeGlobalVariableLeak(
+      className: String,
+      description: String = "",
+      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
+    ): LibraryLeakReferenceMatcher {
+      return libraryLeak(NativeGlobalVariablePattern(className), description, patternApplies)
+    }
+
+    private fun libraryLeak(
+      referencePattern: ReferencePattern,
+      description: String,
+      patternApplies: AndroidBuildMirror.() -> Boolean
+    ): LibraryLeakReferenceMatcher {
+      return LibraryLeakReferenceMatcher(
+          pattern = referencePattern,
+          description = description,
+          patternApplies = { graph ->
+            AndroidBuildMirror.fromHeapGraph(graph)
+                .patternApplies()
+          }
+      )
+    }
+
+    /**
+     * Creates a [IgnoredReferenceMatcher] that matches a [InstanceFieldPattern].
+     */
+    fun ignoredInstanceField(
+      className: String,
+      fieldName: String
+    ): IgnoredReferenceMatcher {
+      return IgnoredReferenceMatcher(pattern = InstanceFieldPattern(className, fieldName))
+    }
+
+    /**
+     * Creates a [IgnoredReferenceMatcher] that matches a [JavaLocalPattern].
+     */
+    fun ignoredJavaLocal(
+      threadName: String
+    ): IgnoredReferenceMatcher {
+      return IgnoredReferenceMatcher(pattern = JavaLocalPattern(threadName))
+    }
+  }
+
+}
+
diff --git a/shark-android/src/test/java/shark/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
new file mode 100644
index 00000000..f2a1278a
--- /dev/null
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -0,0 +1,127 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.DESTROYED
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_ACTIVITY
+import shark.LegacyHprofTest.WRAPS_ACTIVITY.NOT_DESTROYED
+import java.io.File
+
+class LegacyHprofTest {
+
+  @Test fun preM() {
+    val analysis = analyzeHprof("leak_asynctask_pre_m.hprof")
+    assertThat(analysis.applicationLeaks).hasSize(2)
+    val leak1 = analysis.applicationLeaks[0]
+    val leak2 = analysis.applicationLeaks[1]
+    assertThat(leak1.className).isEqualTo("android.graphics.Bitmap")
+    assertThat(leak2.className).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  @Test fun androidM() {
+    val analysis = analyzeHprof("leak_asynctask_m.hprof")
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
+    assertThat(leak.leakTrace.elements[0].labels).contains("GC Root: System class")
+  }
+
+  @Test fun gcRootReferencesUnknownObject() {
+    val analysis = analyzeHprof("gcroot_unknown_object.hprof")
+
+    assertThat(analysis.applicationLeaks).hasSize(2)
+  }
+
+  @Test fun androidMStripped() {
+    val stripper = HprofPrimitiveArrayStripper()
+    val sourceHprof = fileFromResources("leak_asynctask_m.hprof")
+    val strippedHprof = stripper.stripPrimitiveArrays(sourceHprof)
+
+    assertThat(readThreadNames(sourceHprof)).contains("AsyncTask #1")
+    assertThat(readThreadNames(strippedHprof)).allMatch { threadName ->
+      threadName.all { character -> character == '?' }
+    }
+  }
+
+  private fun readThreadNames(hprofFile: File): List<String> {
+    val threadNames = Hprof.open(hprofFile)
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof)
+          graph.findClassByName("java.lang.Thread")!!.instances.map { instance ->
+            instance["java.lang.Thread", "name"]!!.value.readAsJavaString()!!
+          }
+              .toList()
+        }
+    return threadNames
+  }
+
+  @Test fun androidO() {
+    val analysis = analyzeHprof("leak_asynctask_o.hprof")
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  private enum class WRAPS_ACTIVITY {
+    DESTROYED,
+    NOT_DESTROYED,
+    NOT_ACTIVITY
+  }
+
+  @Test fun androidOCountActivityWrappingContexts() {
+    val contextWrapperStatuses = Hprof.open(fileFromResources("leak_asynctask_o.hprof"))
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof)
+          graph.instances.filter { it instanceOf "android.content.ContextWrapper" && !(it instanceOf "android.app.Activity") }
+              .map { instance ->
+                val reporter = ObjectReporter(instance)
+                AndroidObjectInspectors.CONTEXT_WRAPPER.inspect(reporter)
+                if (reporter.leakingReasons.size == 1) {
+                  DESTROYED
+                } else if (reporter.labels.size == 1) {
+                  if ("Activity.mDestroyed false" in reporter.labels.first()) {
+                    NOT_DESTROYED
+                  } else {
+                    NOT_ACTIVITY
+                  }
+                } else throw IllegalStateException(
+                    "Unexpected, should have 1 leaking status ${reporter.leakingReasons} or one label ${reporter.labels}"
+                )
+              }
+              .toList()
+        }
+    assertThat(contextWrapperStatuses.filter { it == DESTROYED }).hasSize(12)
+    assertThat(contextWrapperStatuses.filter { it == NOT_DESTROYED }).hasSize(6)
+    assertThat(contextWrapperStatuses.filter { it == NOT_ACTIVITY }).hasSize(1)
+  }
+
+  @Test fun gcRootInNonPrimaryHeap() {
+    val analysis = analyzeHprof("gc_root_in_non_primary_heap.hprof")
+
+    assertThat(analysis.applicationLeaks).hasSize(1)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("com.example.leakcanary.MainActivity")
+  }
+
+  private fun analyzeHprof(fileName: String): HeapAnalysisSuccess {
+    return analyzeHprof(fileFromResources(fileName))
+  }
+
+  private fun fileFromResources(fileName: String): File {
+    val classLoader = Thread.currentThread()
+        .contextClassLoader
+    val url = classLoader.getResource(fileName)
+    return File(url.path)
+  }
+
+  private fun analyzeHprof(hprofFile: File): HeapAnalysisSuccess {
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.analyze(
+        hprofFile, AndroidReferenceMatchers.appDefaults, false, AndroidObjectInspectors.appDefaults
+    )
+    println(analysis)
+    return analysis as HeapAnalysisSuccess
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof b/shark-android/src/test/resources/gc_root_in_non_primary_heap.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof
rename to shark-android/src/test/resources/gc_root_in_non_primary_heap.hprof
diff --git a/shark-android/src/test/resources/gcroot_unknown_object.hprof b/shark-android/src/test/resources/gcroot_unknown_object.hprof
new file mode 100755
index 00000000..f08f4545
Binary files /dev/null and b/shark-android/src/test/resources/gcroot_unknown_object.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof b/shark-android/src/test/resources/leak_asynctask_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
rename to shark-android/src/test/resources/leak_asynctask_m.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof b/shark-android/src/test/resources/leak_asynctask_o.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof
rename to shark-android/src/test/resources/leak_asynctask_o.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof b/shark-android/src/test/resources/leak_asynctask_pre_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
rename to shark-android/src/test/resources/leak_asynctask_pre_m.hprof
diff --git a/shark-cli/build.gradle b/shark-cli/build.gradle
new file mode 100644
index 00000000..533e9f79
--- /dev/null
+++ b/shark-cli/build.gradle
@@ -0,0 +1,29 @@
+apply plugin: 'java'
+apply plugin: 'kotlin'
+apply plugin: 'application'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':shark-android')
+
+  implementation deps.kotlin.stdlib
+}
+
+def mainClass = 'shark.MainKt'
+
+application {
+  mainClassName = mainClass
+}
+
+jar {
+  manifest {
+    attributes 'Main-Class': mainClass
+  }
+  from {
+    configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
+  }
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-cli/gradle.properties b/shark-cli/gradle.properties
new file mode 100644
index 00000000..8f2712b1
--- /dev/null
+++ b/shark-cli/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-cli
+POM_NAME=Shark Command Line Interface
+POM_PACKAGING=jar
diff --git a/shark-cli/src/main/java/shark/CLILogger.kt b/shark-cli/src/main/java/shark/CLILogger.kt
new file mode 100644
index 00000000..bb6a38a1
--- /dev/null
+++ b/shark-cli/src/main/java/shark/CLILogger.kt
@@ -0,0 +1,24 @@
+package shark
+
+import shark.SharkLog.Logger
+import java.io.PrintWriter
+import java.io.StringWriter
+
+class CLILogger : Logger {
+
+  override fun d(message: String) {
+    println(message)
+  }
+
+  override fun d(throwable: Throwable, message: String) {
+    d("$message\n${getStackTraceString(throwable)}")
+  }
+
+  private fun getStackTraceString(throwable: Throwable): String {
+    val stringWriter = StringWriter()
+    val printWriter = PrintWriter(stringWriter, false)
+    throwable.printStackTrace(printWriter)
+    printWriter.flush()
+    return stringWriter.toString()
+  }
+}
\ No newline at end of file
diff --git a/shark-cli/src/main/java/shark/Main.kt b/shark-cli/src/main/java/shark/Main.kt
new file mode 100644
index 00000000..2fddb10d
--- /dev/null
+++ b/shark-cli/src/main/java/shark/Main.kt
@@ -0,0 +1,196 @@
+package shark
+
+import java.io.File
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+import java.util.concurrent.TimeUnit.SECONDS
+
+fun main(args: Array<String>) {
+  SharkLog.logger = CLILogger()
+  when (args.size) {
+    2 -> {
+      when (args[0]) {
+        "analyze-process" -> {
+          val heapDumpFile = dumpHeap(args[1])
+          analyze(heapDumpFile)
+        }
+        "dump-process" -> dumpHeap(args[1])
+        "analyze-hprof" -> analyze(File(args[1]))
+        "strip-hprof" -> stripHprof(File(args[1]))
+        else -> printHelp()
+      }
+    }
+    4 -> {
+      val heapFile = when (args[0]) {
+        "analyze-process" -> {
+          dumpHeap(args[1])
+        }
+        "analyze-hprof" -> {
+          File(args[1])
+        }
+        else -> {
+          printHelp()
+          null
+        }
+      }
+
+      val mappingFile = if (args[2] == "-proguard-mapping") File(args[3]) else null
+
+      if (heapFile != null && mappingFile != null) {
+        analyze(heapFile, mappingFile)
+      } else {
+        printHelp()
+      }
+    }
+    else -> printHelp()
+  }
+}
+
+fun printHelp() {
+  val workingDirectory = File(System.getProperty("user.dir"))
+
+  // ASCII art is a remix of a shark from -David "TAZ" Baltazar- and chick from jgs.
+  SharkLog.d {
+    """
+    Shark CLI, running in directory $workingDirectory
+
+                     ^`.                 .=""=.
+     ^_              \  \               / _  _ \
+     \ \             {   \             |  d  b  |
+     {  \           /     `~~~--__     \   /\   /
+     {   \___----~~'              `~~-_/'-=\/=-'\,
+      \                         /// a  `~.      \ \
+      / /~~~~-, ,__.    ,      ///  __,,,,)      \ |
+      \/      \/    `~~~;   ,---~~-_`/ \        / \/
+                       /   /            '.    .'
+                      '._.'             _|`~~`|_
+                                        /|\  /|\
+
+    Commands: [analyze-process, dump-process, analyze-hprof, strip-hprof]
+
+    analyze-process: Dumps the heap for the provided process name, pulls the hprof file and analyzes it.
+      USAGE: analyze-process PROCESS_PACKAGE_NAME
+             (optional) -proguard-mapping PROGUARD_MAPPING_FILE_PATH
+
+    dump-process: Dumps the heap for the provided process name and pulls the hprof file.
+      USAGE: dump-process PROCESS_PACKAGE_NAME
+
+    analyze-hprof: Analyzes the provided hprof file.
+      USAGE: analyze-hprof HPROF_FILE_PATH
+             (optional) -proguard-mapping PROGUARD_MAPPING_FILE_PATH
+
+    strip-hprof: Replaces all primitive arrays from the provided hprof file with arrays of zeroes and generates a new "-stripped" hprof file.
+      USAGE: strip-hprof HPROF_FILE_PATH
+  """.trimIndent()
+  }
+}
+
+private fun dumpHeap(packageName: String): File {
+  val workingDirectory = File(System.getProperty("user.dir"))
+
+  val processList = runCommand(workingDirectory, "adb", "shell", "ps")
+
+  val matchingProcesses = processList.lines()
+      .filter { it.contains(packageName) }
+      .map {
+        val columns = Regex("\\s+").split(it)
+        columns[8] to columns[1]
+      }
+
+  val (processName, processId) = if (matchingProcesses.size == 1) {
+    matchingProcesses[0]
+  } else if (matchingProcesses.isEmpty()) {
+    SharkLog.d { "No process matching \"$packageName\"" }
+    System.exit(1)
+    throw RuntimeException("System exiting with error")
+  } else {
+    val matchingExactly = matchingProcesses.firstOrNull { it.first == packageName }
+    if (matchingExactly != null) {
+      matchingExactly
+    } else {
+      SharkLog.d {
+        "More than one process matches \"$packageName\" but none matches exactly: ${matchingProcesses.map { it.first }}"
+      }
+      System.exit(1)
+      throw RuntimeException("System exiting with error")
+    }
+  }
+
+  val heapDumpFileName =
+    SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'-$processName.hprof'", Locale.US).format(
+        Date()
+    )
+
+  val heapDumpDevicePath = "/data/local/tmp/$heapDumpFileName"
+
+  SharkLog.d {
+    "Dumping heap for process \"$processName\" with pid $processId to $heapDumpDevicePath"
+  }
+
+  runCommand(
+      workingDirectory, "adb", "shell", "am", "dumpheap", processId, heapDumpDevicePath
+  )
+
+  // Dump heap takes time but adb returns immediately.
+  Thread.sleep(5000)
+
+  SharkLog.d { "Pulling $heapDumpDevicePath" }
+
+  val pullResult = runCommand(workingDirectory, "adb", "pull", heapDumpDevicePath)
+  SharkLog.d { pullResult }
+  SharkLog.d { "Removing $heapDumpDevicePath" }
+
+  runCommand(workingDirectory, "adb", "shell", "rm", heapDumpDevicePath)
+
+  val heapDumpFile = File(workingDirectory, heapDumpFileName)
+  SharkLog.d { "Pulled heap dump to $heapDumpFile" }
+
+  return heapDumpFile
+}
+
+private fun runCommand(
+  directory: File,
+  vararg arguments: String
+): String {
+  val process = ProcessBuilder(*arguments)
+      .directory(directory)
+      .start()
+      .also { it.waitFor(10, SECONDS) }
+
+  if (process.exitValue() != 0) {
+    throw Exception(process.errorStream.bufferedReader().readText())
+  }
+  return process.inputStream.bufferedReader()
+      .readText()
+}
+
+private fun analyze(
+  heapDumpFile: File,
+  proguardMappingFile: File? = null
+) {
+  val listener = OnAnalysisProgressListener { step ->
+    SharkLog.d { step.name }
+  }
+
+  val proguardMapping = proguardMappingFile?.let {
+    ProguardMappingReader(it.inputStream()).readProguardMapping()
+  }
+
+  val heapAnalyzer = HeapAnalyzer(listener)
+  SharkLog.d { "Analyzing heap dump $heapDumpFile" }
+  val heapAnalysis = heapAnalyzer.analyze(
+      heapDumpFile, AndroidReferenceMatchers.appDefaults, true,
+      AndroidObjectInspectors.appDefaults,
+      proguardMapping = proguardMapping
+  )
+
+  SharkLog.d { heapAnalysis.toString() }
+}
+
+private fun stripHprof(heapDumpFile: File) {
+  SharkLog.d { "Stripping primitive arrays in heap dump $heapDumpFile" }
+  val stripper = HprofPrimitiveArrayStripper()
+  val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
+  SharkLog.d { "Stripped primitive arrays to $outputFile" }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/build.gradle b/shark-graph/build.gradle
similarity index 66%
rename from leakcanary-haha/build.gradle
rename to shark-graph/build.gradle
index ee1d5a52..ce649ba5 100644
--- a/leakcanary-haha/build.gradle
+++ b/shark-graph/build.gradle
@@ -5,14 +5,14 @@ sourceCompatibility = JavaVersion.VERSION_1_7
 targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  api project(':leakcanary-log')
+  api project(':shark-hprof')
 
   implementation deps.kotlin.stdlib
   implementation deps.okio
 
   testImplementation deps.assertj_core
   testImplementation deps.junit
+  testImplementation project(':shark-test')
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-graph/gradle.properties b/shark-graph/gradle.properties
new file mode 100644
index 00000000..0049f0e5
--- /dev/null
+++ b/shark-graph/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-graph
+POM_NAME=Shark Graph
+POM_PACKAGING=jar
diff --git a/shark-graph/src/main/java/shark/GraphContext.kt b/shark-graph/src/main/java/shark/GraphContext.kt
new file mode 100644
index 00000000..63952f1a
--- /dev/null
+++ b/shark-graph/src/main/java/shark/GraphContext.kt
@@ -0,0 +1,51 @@
+package shark
+
+/**
+ * In memory store that can be used to store objects in a given [HeapGraph] instance.
+ * This is a simple [MutableMap] of [String] to [Any], but with unsafe generics access.
+ */
+class GraphContext {
+  private val store = mutableMapOf<String, Any>()
+  operator fun <T> get(key: String): T? {
+    @Suppress("UNCHECKED_CAST")
+    return store[key] as T?
+  }
+
+  /**
+   * @see MutableMap.getOrPut
+   */
+  fun <T> getOrPut(
+    key: String,
+    defaultValue: () -> T
+  ): T {
+    @Suppress("UNCHECKED_CAST")
+    return store.getOrPut(key, {
+      defaultValue() as Any
+    }) as T
+  }
+
+  /**
+   * @see MutableMap.set
+   */
+  operator fun <T> set(
+    key: String,
+    value: T
+  ) {
+    store[key] = (value as Any)
+  }
+
+  /**
+   * @see MutableMap.containsKey
+   */
+  operator fun contains(key: String): Boolean {
+    return key in store
+  }
+
+  /**
+   * @see MutableMap.remove
+   */
+  operator fun minusAssign(key: String) {
+    @Suppress("UNCHECKED_CAST")
+    store -= key
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapField.kt b/shark-graph/src/main/java/shark/HeapField.kt
new file mode 100644
index 00000000..e4500c4b
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapField.kt
@@ -0,0 +1,51 @@
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+
+/**
+ * Represents a static field or an instance field.
+ */
+class HeapField(
+  /**
+   * The class this field was declared in.
+   */
+  val declaringClass: HeapClass,
+  /**
+   * Name of the field
+   */
+  val name: String,
+  /**
+   * Value of the field. Also see shorthands [valueAsClass], [valueAsInstance],
+   * [valueAsObjectArray], [valueAsPrimitiveArray].
+   */
+  val value: HeapValue
+) {
+
+  /**
+   * Return a [HeapClass] is [value] references a class, and null otherwise.
+   */
+  val valueAsClass: HeapClass?
+    get() = value.asObject?.asClass
+
+  /**
+   * Return a [HeapInstance] is [value] references an instance, and null otherwise.
+   */
+  val valueAsInstance: HeapInstance?
+    get() = value.asObject?.asInstance
+
+  /**
+   * Return a [HeapObjectArray] is [value] references an object array, and null otherwise.
+   */
+  val valueAsObjectArray: HeapObjectArray?
+    get() = value.asObject?.asObjectArray
+
+  /**
+   * Return a [HeapPrimitiveArray] is [value] references a primitive array, and null
+   * otherwise.
+   */
+  val valueAsPrimitiveArray: HeapPrimitiveArray?
+    get() = value.asObject?.asPrimitiveArray
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapGraph.kt b/shark-graph/src/main/java/shark/HeapGraph.kt
new file mode 100644
index 00000000..1b64a971
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapGraph.kt
@@ -0,0 +1,58 @@
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+
+/**
+ * Enables navigation through the heap graph of objects.
+ */
+interface HeapGraph {
+  val identifierByteSize: Int
+  /**
+   * In memory store that can be used to store objects this [HeapGraph] instance.
+   */
+  val context: GraphContext
+  /**
+   * All GC roots which type matches types known to this heap graph and which point to non null
+   * references. You can retrieve the object that a GC Root points to by calling [findObjectById]
+   * with [GcRoot.id], however you need to first check that [objectExists] returns true because
+   * GC roots can point to objects that don't exist in the heap dump.
+   */
+  val gcRoots: List<GcRoot>
+  /**
+   * Sequence of all objects in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val objects: Sequence<HeapObject>
+  /**
+   * Sequence of all classes in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val classes: Sequence<HeapClass>
+  /**
+   * Sequence of all instances in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val instances: Sequence<HeapInstance>
+
+  /**
+   * Returns the [HeapObject] corresponding to the provided [objectId], and throws
+   * [IllegalArgumentException] otherwise.
+   */
+  @Throws(IllegalArgumentException::class)
+  fun findObjectById(objectId: Long): HeapObject
+
+  /**
+   * Returns the [HeapClass] corresponding to the provided [className], or null if the
+   * class cannot be found.
+   */
+  fun findClassByName(className: String): HeapClass?
+
+  /**
+   * Returns true if the provided [objectId] exists in the heap dump.
+   */
+  fun objectExists(objectId: Long): Boolean
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapObject.kt b/shark-graph/src/main/java/shark/HeapObject.kt
new file mode 100644
index 00000000..e38c1931
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapObject.kt
@@ -0,0 +1,565 @@
+package shark
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.ReferenceHolder
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
+import java.nio.charset.Charset
+import kotlin.reflect.KClass
+
+/**
+ * An object in the heap dump.
+ */
+sealed class HeapObject {
+
+  /**
+   * The graph of objects in the heap, which you can use to navigate the heap.
+   */
+
+  abstract val graph: HeapGraph
+
+  /**
+   * The heap identifier of this object.
+   */
+  abstract val objectId: Long
+
+  /**
+   * Reads and returns the underlying [ObjectRecord].
+   *
+   * This may trigger IO reads.
+   */
+  abstract fun readRecord(): ObjectRecord
+
+  /**
+   * This [HeapObject] as a [HeapClass] if it is one, or null otherwise
+   */
+  val asClass: HeapClass?
+    get() = if (this is HeapClass) this else null
+
+  /**
+   * This [HeapObject] as a [HeapInstance] if it is one, or null otherwise
+   */
+  val asInstance: HeapInstance?
+    get() = if (this is HeapInstance) this else null
+
+  /**
+   * This [HeapObject] as a [HeapObjectArray] if it is one, or null otherwise
+   */
+  val asObjectArray: HeapObjectArray?
+    get() = if (this is HeapObjectArray) this else null
+
+  /**
+   * This [HeapObject] as a [HeapPrimitiveArray] if it is one, or null otherwise
+   */
+  val asPrimitiveArray: HeapPrimitiveArray?
+    get() = if (this is HeapPrimitiveArray) this else null
+
+  /**
+   * A class in the heap dump.
+   */
+  class HeapClass internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    private val indexedObject: IndexedClass,
+    override val objectId: Long
+  ) : HeapObject() {
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * The name of this class, identical to [Class.getName].
+     */
+    val name: String
+      get() = hprofGraph.className(objectId)
+
+    /**
+     * Returns [name] stripped of any string content before the last period (included).
+     */
+    val simpleName: String
+      get() = classSimpleName(name)
+
+    /**
+     * The total byte size of fields for instances of this class, as registered in the class dump.
+     * This includes the size of fields from superclasses.
+     *
+     * @see readFieldsByteSize
+     */
+    val instanceByteSize: Int
+      get() = indexedObject.instanceSize
+
+    /**
+     * The total byte size of fields for instances of this class, computed as the sum of the
+     * individual size of each field of this class. This does not include the size of fields from
+     * superclasses.
+     *
+     * This may trigger IO reads.
+     *
+     * @see instanceByteSize
+     */
+    fun readFieldsByteSize(): Int {
+      return readRecord()
+          .fields.sumBy {
+        if (it.type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+          hprofGraph.identifierByteSize
+        } else PrimitiveType.byteSizeByHprofType.getValue(it.type)
+      }
+    }
+
+    /**
+     * The [HeapClass] representing the superclass of this [HeapClass]. If this [HeapClass]
+     * represents either the [Object] class or a primitive type, then
+     * null is returned. If this [HeapClass] represents an array class then the
+     * [HeapClass] object representing the [Object] class is returned.
+     */
+    val superclass: HeapClass?
+      get() {
+        if (indexedObject.superclassId == ValueHolder.NULL_REFERENCE) return null
+        return hprofGraph.findObjectById(indexedObject.superclassId) as HeapClass
+      }
+
+    /**
+     * The class hierarchy starting at this class (included) and ending at the [Object] class
+     * (included).
+     */
+    val classHierarchy: Sequence<HeapClass>
+      get() = generateSequence(this) { it.superclass }
+
+    /**
+     * All the subclasses (direct and indirect) of this class,
+     * in the order they were recorded in the heap dump.
+     */
+    val subclasses: Sequence<HeapClass>
+      get() = hprofGraph.classes.filter { it subclassOf this }
+
+    /**
+     * Returns true if [subclass] is a sub class of this [HeapClass].
+     */
+    infix fun superclassOf(subclass: HeapClass): Boolean {
+      return subclass.classHierarchy.any { it.objectId == objectId }
+    }
+
+    /**
+     * Returns true if [superclass] is a superclass of this [HeapClass].
+     */
+    infix fun subclassOf(superclass: HeapClass): Boolean {
+      return classHierarchy.any { it.objectId == superclass.objectId }
+    }
+
+    /**
+     * All instances of this class, including instances of subclasses of this class.
+     */
+    val instances: Sequence<HeapInstance>
+      get() = hprofGraph.instances.filter { it instanceOf this }
+
+    /**
+     * All direct instances of this class, ie excluding any instance of subclasses of this class.
+     */
+    val directInstances: Sequence<HeapInstance>
+      get() = hprofGraph.instances.filter { it.indexedObject.classId == objectId }
+
+    /**
+     * Reads and returns the underlying [ClassDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): ClassDumpRecord {
+      return hprofGraph.readClassDumpRecord(objectId, indexedObject)
+    }
+
+    /**
+     * The static fields of this class, as a sequence of [HeapField].
+     *
+     * This may trigger IO reads.
+     */
+    fun readStaticFields(): Sequence<HeapField> {
+      return readRecord().staticFields.asSequence()
+          .map { fieldRecord ->
+            HeapField(
+                this, hprofGraph.staticFieldName(objectId, fieldRecord),
+                HeapValue(hprofGraph, fieldRecord.value)
+            )
+          }
+    }
+
+    /**
+     * Returns a [HeapField] object that reflects the specified declared
+     * field of the class represented by this [HeapClass] object, or null if this field does not
+     * exist. The [name] parameter specifies the simple name of the desired field.
+     *
+     * Also available as a convenience operator: [get]
+     *
+     * This may trigger IO reads.
+     */
+    fun readStaticField(fieldName: String): HeapField? {
+      for (fieldRecord in readRecord().staticFields) {
+        if (hprofGraph.staticFieldName(objectId, fieldRecord) == fieldName) {
+          return HeapField(
+              this, hprofGraph.staticFieldName(objectId, fieldRecord),
+              HeapValue(hprofGraph, fieldRecord.value)
+          )
+        }
+      }
+      return null
+    }
+
+    /**
+     * @see readStaticField
+     */
+    operator fun get(fieldName: String) = readStaticField(fieldName)
+
+    override fun toString(): String {
+      return "class $name"
+    }
+  }
+
+  /**
+   * An instance in the heap dump.
+   */
+  class HeapInstance internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    internal val indexedObject: IndexedInstance,
+    override val objectId: Long,
+    /**
+     * Whether this is an instance of a primitive wrapper type.
+     */
+    val isPrimitiveWrapper: Boolean
+  ) : HeapObject() {
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * @see HeapClass.instanceByteSize
+     */
+    val byteSize
+      get() = instanceClass.instanceByteSize
+
+    /**
+     * The name of the class of this instance, identical to [Class.getName].
+     */
+    val instanceClassName: String
+      get() = hprofGraph.className(indexedObject.classId)
+
+    /**
+     * Returns [instanceClassName] stripped of any string content before the last period (included).
+     */
+    val instanceClassSimpleName: String
+      get() = classSimpleName(instanceClassName)
+
+    /**
+     * The class of this instance.
+     */
+    val instanceClass: HeapClass
+      get() = hprofGraph.findObjectById(indexedObject.classId) as HeapClass
+
+    /**
+     * Reads and returns the underlying [InstanceDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): InstanceDumpRecord {
+      return hprofGraph.readInstanceDumpRecord(objectId, indexedObject)
+    }
+
+    /**
+     * Returns true if this is an instance of the class named [className] or an instance of a
+     * subclass of that class.
+     */
+    infix fun instanceOf(className: String): Boolean =
+      instanceClass.classHierarchy.any { it.name == className }
+
+    /**
+     * Returns true if this is an instance of [expectedClass] or an instance of a subclass of that
+     * class.
+     */
+    infix fun instanceOf(expectedClass: KClass<*>) =
+      this instanceOf expectedClass.java.name
+
+    /**
+     * Returns true if this is an instance of [expectedClass] or an instance of a subclass of that
+     * class.
+     */
+    infix fun instanceOf(expectedClass: HeapClass) =
+      instanceClass.classHierarchy.any { it.objectId == expectedClass.objectId }
+
+    /**
+     * @see readField
+     */
+    fun readField(
+      declaringClass: KClass<out Any>,
+      fieldName: String
+    ): HeapField? {
+      return readField(declaringClass.java.name, fieldName)
+    }
+
+    /**
+     * Returns a [HeapField] object that reflects the specified declared
+     * field of the instance represented by this [HeapInstance] object, or null if this field does
+     * not exist. The [declaringClassName] specifies the class in which the desired field is
+     * declared, and the [fieldName] parameter specifies the simple name of the desired field.
+     *
+     * Also available as a convenience operator: [get]
+     *
+     * This may trigger IO reads.
+     */
+    fun readField(
+      declaringClassName: String,
+      fieldName: String
+    ): HeapField? {
+      return readFields().firstOrNull { field -> field.declaringClass.name == declaringClassName && field.name == fieldName }
+    }
+
+    /**
+     * @see readField
+     */
+    operator fun get(
+      declaringClass: KClass<out Any>,
+      fieldName: String
+    ): HeapField? {
+      return readField(declaringClass, fieldName)
+    }
+
+    /**
+     * @see readField
+     */
+    operator fun get(
+      declaringClassName: String,
+      fieldName: String
+    ) = readField(declaringClassName, fieldName)
+
+    /**
+     * The fields of this instance, as a sequence of [HeapField].
+     *
+     * This may trigger IO reads.
+     */
+    fun readFields(): Sequence<HeapField> {
+      val fieldReader by lazy {
+        hprofGraph.createFieldValuesReader(readRecord())
+      }
+      return instanceClass.classHierarchy
+          .map { heapClass ->
+            heapClass.readRecord()
+                .fields.asSequence()
+                .map { fieldRecord ->
+                  val fieldName = hprofGraph.fieldName(heapClass.objectId, fieldRecord)
+                  val fieldValue = fieldReader.readValue(fieldRecord)
+                  HeapField(heapClass, fieldName, HeapValue(hprofGraph, fieldValue))
+                }
+          }
+          .flatten()
+    }
+
+    /**
+     * If this [HeapInstance] is an instance of the [String] class, returns a [String] instance
+     * with content that matches the string in the heap dump. Otherwise returns null.
+     *
+     * This may trigger IO reads.
+     */
+    fun readAsJavaString(): String? {
+      if (instanceClassName != "java.lang.String") {
+        return null
+      }
+
+      // JVM strings don't have a count field.
+      val count = this["java.lang.String", "count"]?.value?.asInt
+      if (count == 0) {
+        return ""
+      }
+
+      // Prior to API 26 String.value was a char array.
+      // Since API 26 String.value is backed by native code. The vast majority of strings in a
+      // heap dump are backed by a byte array, but we still find a few backed by a char array.
+      when (val valueRecord =
+        this["java.lang.String", "value"]!!.value.asObject!!.readRecord()) {
+        is CharArrayDump -> {
+          // < API 23
+          // As of Marshmallow, substrings no longer share their parent strings' char arrays
+          // eliminating the need for String.offset
+          // https://android-review.googlesource.com/#/c/83611/
+          val offset = this["java.lang.String", "offset"]?.value?.asInt
+
+          val chars = if (count != null && offset != null) {
+            // Handle heap dumps where all primitive arrays have been replaced with empty arrays,
+            // e.g. with HprofPrimitiveArrayStripper
+            val toIndex = if (offset + count > valueRecord.array.size) {
+              valueRecord.array.size
+            } else offset + count
+            valueRecord.array.copyOfRange(offset, toIndex)
+          } else {
+            valueRecord.array
+          }
+          return String(chars)
+        }
+        is ByteArrayDump -> {
+          return String(valueRecord.array, Charset.forName("UTF-8"))
+        }
+        else -> throw UnsupportedOperationException(
+            "'value' field ${this["java.lang.String", "value"]!!.value} was expected to be either" +
+                " a char or byte array in string instance with id $objectId"
+        )
+      }
+    }
+
+    override fun toString(): String {
+      return "instance @$objectId of $instanceClassName"
+    }
+  }
+
+  /**
+   * An object array in the heap dump.
+   */
+  class HeapObjectArray internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    private val indexedObject: IndexedObjectArray,
+    override val objectId: Long,
+    val isPrimitiveWrapperArray: Boolean
+  ) : HeapObject() {
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * The name of the class of this array, identical to [Class.getName].
+     */
+    val arrayClassName: String
+      get() = hprofGraph.className(indexedObject.arrayClassId)
+
+    /**
+     * Returns [arrayClassName] stripped of any string content before the last period (included).
+     */
+    val arrayClassSimpleName: String
+      get() = classSimpleName(arrayClassName)
+
+    /**
+     * The class of this array.
+     */
+    val arrayClass: HeapClass
+      get() = hprofGraph.findObjectById(indexedObject.arrayClassId) as HeapClass
+
+    /**
+     * The total byte shallow size of elements in this array.
+     */
+    fun readByteSize(): Int {
+      return readRecord().elementIds.size * hprofGraph.identifierByteSize
+    }
+
+    /**
+     * Reads and returns the underlying [ObjectArrayDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): ObjectArrayDumpRecord {
+      return hprofGraph.readObjectArrayDumpRecord(objectId, indexedObject)
+    }
+
+    /**
+     * The elements in this array, as a sequence of [HeapValue].
+     *
+     * This may trigger IO reads.
+     */
+    fun readElements(): Sequence<HeapValue> {
+      return readRecord().elementIds.asSequence()
+          .map { HeapValue(hprofGraph, ReferenceHolder(it)) }
+    }
+
+    override fun toString(): String {
+      return "object array @$objectId of $arrayClassName"
+    }
+  }
+
+  /**
+   * A primitive array in the heap dump.
+   */
+  class HeapPrimitiveArray internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    private val indexedObject: IndexedPrimitiveArray,
+    override val objectId: Long
+  ) : HeapObject() {
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * The total byte shallow size of elements in this array.
+     */
+    fun readByteSize(): Int {
+      return when (val record = readRecord()) {
+        is BooleanArrayDump -> record.array.size * PrimitiveType.BOOLEAN.byteSize
+        is CharArrayDump -> record.array.size * PrimitiveType.CHAR.byteSize
+        is FloatArrayDump -> record.array.size * PrimitiveType.FLOAT.byteSize
+        is DoubleArrayDump -> record.array.size * PrimitiveType.DOUBLE.byteSize
+        is ByteArrayDump -> record.array.size * PrimitiveType.BYTE.byteSize
+        is ShortArrayDump -> record.array.size * PrimitiveType.SHORT.byteSize
+        is IntArrayDump -> record.array.size * PrimitiveType.INT.byteSize
+        is LongArrayDump -> record.array.size * PrimitiveType.LONG.byteSize
+      }
+    }
+
+    /**
+     * The [PrimitiveType] of elements in this array.
+     */
+    val primitiveType: PrimitiveType
+      get() = indexedObject.primitiveType
+
+    /**
+     * The name of the class of this array, identical to [Class.getName].
+     */
+    val arrayClassName: String
+      get() = when (primitiveType) {
+        BOOLEAN -> "boolean[]"
+        CHAR -> "char[]"
+        FLOAT -> "float[]"
+        DOUBLE -> "double[]"
+        BYTE -> "byte[]"
+        SHORT -> "short[]"
+        INT -> "int[]"
+        LONG -> "long[]"
+      }
+
+    /**
+     * Reads and returns the underlying [PrimitiveArrayDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): PrimitiveArrayDumpRecord {
+      return hprofGraph.readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
+
+    override fun toString(): String {
+      return "primitive array @$objectId of $arrayClassName"
+    }
+  }
+
+  companion object {
+    private fun classSimpleName(className: String): String {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapValue.kt b/shark-graph/src/main/java/shark/HeapValue.kt
new file mode 100644
index 00000000..b28d8cd6
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapValue.kt
@@ -0,0 +1,123 @@
+package shark
+
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+
+/**
+ * Represents a value in the heap dump, which can be an object reference or
+ * a primitive type.
+ */
+class HeapValue(
+  /**
+   * The graph of objects in the heap, which you can use to navigate the heap.
+   */
+  val graph: HeapGraph,
+  /**
+   * Holds the actual value that this [HeapValue] represents.
+   */
+  val holder: ValueHolder
+) {
+
+  /**
+   * This [HeapValue] as a [Boolean] if it represents one, or null otherwise.
+   */
+  val asBoolean: Boolean?
+    get() = if (holder is BooleanHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Char] if it represents one, or null otherwise.
+   */
+  val asChar: Char?
+    get() = if (holder is CharHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Float] if it represents one, or null otherwise.
+   */
+  val asFloat: Float?
+    get() = if (holder is FloatHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Double] if it represents one, or null otherwise.
+   */
+  val asDouble: Double?
+    get() = if (holder is DoubleHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Byte] if it represents one, or null otherwise.
+   */
+  val asByte: Byte?
+    get() = if (holder is ByteHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Short] if it represents one, or null otherwise.
+   */
+  val asShort: Short?
+    get() = if (holder is ShortHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as an [Int] if it represents one, or null otherwise.
+   */
+  val asInt: Int?
+    get() = if (holder is IntHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents one, or null otherwise.
+   */
+  val asLong: Long?
+    get() = if (holder is LongHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents an object reference, or null otherwise.
+   */
+  val asObjectId: Long?
+    get() = if (holder is ReferenceHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents a non null object reference, or null otherwise.
+   */
+  val asNonNullObjectId: Long?
+    get() = if (holder is ReferenceHolder && !holder.isNull) holder.value else null
+
+  /**
+   * True is this [HeapValue] represents a null object reference, false otherwise.
+   */
+  val isNullReference: Boolean
+    get() = holder is ReferenceHolder && holder.isNull
+
+  /**
+   * True is this [HeapValue] represents a non null object reference, false otherwise.
+   */
+  val isNonNullReference: Boolean
+    get() = holder is ReferenceHolder && !holder.isNull
+
+  /**
+   * The [HeapObject] referenced by this [HeapValue] if it represents a non null object reference,
+   * or null otherwise.
+   */
+  val asObject: HeapObject?
+    get() {
+      return if (holder is ReferenceHolder && !holder.isNull) {
+        return graph.findObjectById(holder.value)
+      } else {
+        null
+      }
+    }
+
+  /**
+   * If this [HeapValue] if it represents a non null object reference to an instance of the
+   * [String] class, returns a [String] instance with content that matches the string in the heap
+   * dump. Otherwise returns null.
+   *
+   * This may trigger IO reads.
+   */
+  fun readAsJavaString(): String? {
+    return asObject?.asInstance?.readAsJavaString()
+  }
+}
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
new file mode 100644
index 00000000..0a23e73c
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -0,0 +1,191 @@
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofHeapGraph.Companion.indexHprof
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.internal.FieldValuesReader
+import shark.internal.HprofInMemoryIndex
+import shark.internal.IndexedObject
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
+import shark.internal.LruCache
+
+/**
+ * A [HeapGraph] that reads from an indexed [Hprof]. Create a new instance with [indexHprof].
+ */
+@Suppress("TooManyFunctions")
+class HprofHeapGraph internal constructor(
+  private val hprof: Hprof,
+  private val index: HprofInMemoryIndex
+) : HeapGraph {
+
+  override val identifierByteSize: Int get() = hprof.reader.identifierByteSize
+
+  override val context = GraphContext()
+
+  override val gcRoots: List<GcRoot>
+    get() = index.gcRoots()
+
+  override val objects: Sequence<HeapObject>
+    get() {
+      return index.indexedObjectSequence()
+          .map {
+            wrapIndexedObject(it.second, it.first)
+          }
+    }
+
+  override val classes: Sequence<HeapClass>
+    get() {
+      return index.indexedClassSequence()
+          .map {
+            val objectId = it.first
+            val indexedObject = it.second
+            HeapClass(this, indexedObject, objectId)
+          }
+    }
+
+  override val instances: Sequence<HeapInstance>
+    get() {
+      return index.indexedInstanceSequence()
+          .map {
+            val objectId = it.first
+            val indexedObject = it.second
+            val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+            HeapInstance(this, indexedObject, objectId, isPrimitiveWrapper)
+          }
+    }
+
+  // LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
+  // This is based on running InstrumentationLeakDetectorTest a bunch of time on a
+  // Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+  private val objectCache = LruCache<Long, ObjectRecord>(3000)
+
+  override fun findObjectById(objectId: Long): HeapObject {
+    return wrapIndexedObject(index.indexedObject(objectId), objectId)
+  }
+
+  override fun findClassByName(className: String): HeapClass? {
+    val classId = index.classId(className)
+    return if (classId == null) {
+      null
+    } else {
+      return findObjectById(classId) as HeapClass
+    }
+  }
+
+  override fun objectExists(objectId: Long): Boolean {
+    return index.objectIdIsIndexed(objectId)
+  }
+
+  internal fun fieldName(
+    classId: Long,
+    fieldRecord: FieldRecord
+  ): String {
+    return index.fieldName(classId, fieldRecord.nameStringId)
+  }
+
+  internal fun staticFieldName(
+    classId: Long,
+    fieldRecord: StaticFieldRecord
+  ): String {
+    return index.fieldName(classId, fieldRecord.nameStringId)
+  }
+
+  internal fun createFieldValuesReader(record: InstanceDumpRecord) =
+    FieldValuesReader(record, identifierByteSize)
+
+  internal fun className(classId: Long): String {
+    return index.className(classId)
+  }
+
+  internal fun readObjectArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedObjectArray
+  ): ObjectArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      hprof.reader.readObjectArrayDumpRecord()
+    }
+  }
+
+  internal fun readPrimitiveArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedPrimitiveArray
+  ): PrimitiveArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      hprof.reader.readPrimitiveArrayDumpRecord()
+    }
+  }
+
+  internal fun readClassDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedClass
+  ): ClassDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      hprof.reader.readClassDumpRecord()
+    }
+  }
+
+  internal fun readInstanceDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedInstance
+  ): InstanceDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      hprof.reader.readInstanceDumpRecord()
+    }
+  }
+
+  private fun <T : ObjectRecord> readObjectRecord(
+    objectId: Long,
+    indexedObject: IndexedObject,
+    readBlock: () -> T
+  ): T {
+    val objectRecordOrNull = objectCache[objectId]
+    @Suppress("UNCHECKED_CAST")
+    if (objectRecordOrNull != null) {
+      return objectRecordOrNull as T
+    }
+    hprof.moveReaderTo(indexedObject.position)
+    return readBlock().apply { objectCache.put(objectId, this) }
+  }
+
+  private fun wrapIndexedObject(
+    indexedObject: IndexedObject,
+    objectId: Long
+  ): HeapObject {
+    return when (indexedObject) {
+      is IndexedClass -> HeapClass(this, indexedObject, objectId)
+      is IndexedInstance -> {
+        val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+        HeapInstance(this, indexedObject, objectId, isPrimitiveWrapper)
+      }
+      is IndexedObjectArray -> {
+        val isPrimitiveWrapperArray =
+          index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
+        HeapObjectArray(this, indexedObject, objectId, isPrimitiveWrapperArray)
+      }
+      is IndexedPrimitiveArray -> HeapPrimitiveArray(this, indexedObject, objectId)
+    }
+  }
+
+  companion object {
+    fun indexHprof(
+      hprof: Hprof,
+      proguardMapping: ProguardMapping? = null
+    ): HeapGraph {
+      val index = HprofInMemoryIndex.createReadingHprof(hprof, proguardMapping)
+      return HprofHeapGraph(hprof, index)
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/ProguardMapping.kt b/shark-graph/src/main/java/shark/ProguardMapping.kt
new file mode 100644
index 00000000..d25d6fbf
--- /dev/null
+++ b/shark-graph/src/main/java/shark/ProguardMapping.kt
@@ -0,0 +1,34 @@
+package shark
+
+class ProguardMapping {
+
+  // Classes can be simply stored as a obfuscatedName -> clearName
+  // For fields it's a bit more complicated since we need to know
+  // the class that a given field belongs to (two different classes
+  // can have a field with the same name). So files are stored as:
+  // obfuscatedClassName.obfuscatedFieldName -> clearFieldName
+  private val obfuscatedToClearNamesMap = linkedMapOf<String, String>()
+
+  /**
+   * Returns deobfuscated class name or original string if there is no
+   * mapping for given obfuscated name.
+   */
+  fun deobfuscateClassName(obfuscatedClassName: String): String {
+    return obfuscatedToClearNamesMap[obfuscatedClassName] ?: obfuscatedClassName
+  }
+
+  /**
+   * Returns deobfuscated field name or original string if there is no
+   * mapping for given obfuscated name.
+   */
+  fun deobfuscateFieldName(obfuscatedClass: String, obfuscatedField: String): String {
+    return obfuscatedToClearNamesMap["$obfuscatedClass.$obfuscatedField"] ?: return obfuscatedField
+  }
+
+  /**
+   * Adds entry to the obfuscatedToClearNamesMap map.
+   */
+  fun addMapping(obfuscatedName: String, clearName: String) {
+    obfuscatedToClearNamesMap[obfuscatedName] = clearName
+  }
+}
diff --git a/shark-graph/src/main/java/shark/ProguardMappingReader.kt b/shark-graph/src/main/java/shark/ProguardMappingReader.kt
new file mode 100644
index 00000000..cfc9bda3
--- /dev/null
+++ b/shark-graph/src/main/java/shark/ProguardMappingReader.kt
@@ -0,0 +1,89 @@
+package shark
+
+import java.io.FileNotFoundException
+import java.io.IOException
+import java.io.InputStream
+import java.text.ParseException
+
+class ProguardMappingReader(
+  private val proguardMappingInputStream: InputStream
+) {
+
+  @Throws(FileNotFoundException::class, IOException::class, ParseException::class)
+  fun readProguardMapping(): ProguardMapping {
+    val proguardMapping = ProguardMapping()
+    proguardMappingInputStream.bufferedReader(Charsets.UTF_8).use { bufferedReader ->
+
+      var currentClassName: String? = null
+      while (true) {
+        val line = bufferedReader.readLine()?.trim() ?: break
+
+        if (line.isEmpty() || line.startsWith(HASH_SYMBOL)) {
+          // empty line or comment
+          continue
+        }
+
+        if (line.endsWith(COLON_SYMBOL)) {
+          currentClassName = parseClassMapping(line, proguardMapping)
+        } else if (currentClassName != null) {
+          val isMethodMapping = line.contains(OPENING_PAREN_SYMBOL)
+          if (!isMethodMapping) {
+            parseClassField(line, currentClassName, proguardMapping)
+          }
+        }
+      }
+    }
+    return proguardMapping
+  }
+
+  // classes are stored as "clearName -> obfuscatedName:"
+  private fun parseClassMapping(line: String, proguardMapping: ProguardMapping): String? {
+    val arrowPosition = line.indexOf(ARROW_SYMBOL)
+    if (arrowPosition == -1) {
+      return null
+    }
+
+    val colonPosition = line.indexOf(COLON_SYMBOL, arrowPosition + ARROW_SYMBOL.length)
+    if (colonPosition == -1) {
+      return null
+    }
+
+    val clearClassName = line.substring(0, arrowPosition).trim()
+    val obfuscatedClassName =
+        line.substring(arrowPosition + ARROW_SYMBOL.length, colonPosition).trim()
+
+    proguardMapping.addMapping(obfuscatedClassName, clearClassName)
+
+    return obfuscatedClassName
+  }
+
+  // fields are stored as "typeName clearFieldName -> obfuscatedFieldName"
+  private fun parseClassField(
+    line: String,
+    currentClassName: String,
+    proguardMapping: ProguardMapping
+  ) {
+    val spacePosition = line.indexOf(SPACE_SYMBOL)
+    if (spacePosition == -1) {
+      return
+    }
+
+    val arrowPosition = line.indexOf(ARROW_SYMBOL, spacePosition + SPACE_SYMBOL.length)
+    if (arrowPosition == -1) {
+      return
+    }
+
+    val clearFieldName = line.substring(spacePosition + SPACE_SYMBOL.length, arrowPosition).trim()
+    val obfuscatedFieldName = line.substring(arrowPosition + ARROW_SYMBOL.length).trim()
+
+    proguardMapping.addMapping("$currentClassName.$obfuscatedFieldName", clearFieldName)
+  }
+
+  companion object {
+    private const val HASH_SYMBOL = "#"
+    private const val ARROW_SYMBOL = "->"
+    private const val COLON_SYMBOL = ":"
+    private const val SPACE_SYMBOL = " "
+    private const val OPENING_PAREN_SYMBOL = "("
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/ByteSubArray.kt b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
new file mode 100644
index 00000000..ab634de6
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
@@ -0,0 +1,106 @@
+package shark.internal
+
+/**
+ * Provides read access to a sub part of a larger array.
+ */
+internal class ByteSubArray(
+  private val array: ByteArray,
+  private val rangeStart: Int,
+  size: Int,
+  private val longIdentifiers: Boolean
+) {
+
+  private val endInclusive = size - 1
+
+  private var currentIndex = 0
+
+  fun readByte(): Byte {
+    val index = currentIndex
+    currentIndex++
+    require(index in 0..endInclusive) {
+      "Index $index should be between 0 and $endInclusive"
+    }
+    return array[rangeStart + index]
+  }
+
+  fun readId(): Long {
+    return if (longIdentifiers) {
+      readLong()
+    } else {
+      readInt().toLong()
+    }
+  }
+
+  fun readInt(): Int {
+    val index = currentIndex
+    currentIndex += 4
+    require(index >= 0 && index <= endInclusive - 3) {
+      "Index $index should be between 0 and ${endInclusive - 3}"
+    }
+    return array.readInt(rangeStart + index)
+  }
+
+  fun readTruncatedLong(byteCount: Int): Long {
+    val index = currentIndex
+    currentIndex += byteCount
+    require(index >= 0 && index <= endInclusive - (byteCount - 1)) {
+      "Index $index should be between 0 and ${endInclusive - (byteCount - 1)}"
+    }
+    var pos = rangeStart + index
+    val array = array
+
+    var value = 0L
+
+    var shift = (byteCount - 1) * 8
+    while (shift >= 8) {
+      value = value or (array[pos++] and 0xffL shl shift)
+      shift -= 8
+    }
+    value = value or (array[pos] and 0xffL)
+    return value
+  }
+
+  fun readLong(): Long {
+    val index = currentIndex
+    currentIndex += 8
+    require(index >= 0 && index <= endInclusive - 7) {
+      "Index $index should be between 0 and ${endInclusive - 7}"
+    }
+    return array.readLong(rangeStart + index)
+  }
+}
+
+internal fun ByteArray.readShort(index: Int): Short {
+  var pos = index
+  val array = this
+  val valueAsInt = array[pos++] and 0xff shl 8 or (array[pos] and 0xff)
+  return valueAsInt.toShort()
+}
+
+internal fun ByteArray.readInt(index: Int): Int {
+  var pos = index
+  val array = this
+  return (array[pos++] and 0xff shl 24
+      or (array[pos++] and 0xff shl 16)
+      or (array[pos++] and 0xff shl 8)
+      or (array[pos] and 0xff))
+}
+
+internal fun ByteArray.readLong(index: Int): Long {
+  var pos = index
+  val array = this
+  return (array[pos++] and 0xffL shl 56
+      or (array[pos++] and 0xffL shl 48)
+      or (array[pos++] and 0xffL shl 40)
+      or (array[pos++] and 0xffL shl 32)
+      or (array[pos++] and 0xffL shl 24)
+      or (array[pos++] and 0xffL shl 16)
+      or (array[pos++] and 0xffL shl 8)
+      or (array[pos] and 0xffL))
+}
+
+@Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+@Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+private inline infix fun Byte.and(other: Int): Int = toInt() and other
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt b/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
new file mode 100644
index 00000000..666e0a9e
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
@@ -0,0 +1,113 @@
+package shark.internal
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.PrimitiveType
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+
+internal class FieldValuesReader(
+  private val record: InstanceDumpRecord,
+  private val identifierByteSize: Int
+) {
+
+  private var position = 0
+
+  fun readValue(field: FieldRecord): ValueHolder {
+    return when (field.type) {
+      PrimitiveType.REFERENCE_HPROF_TYPE -> ReferenceHolder(readId())
+      BOOLEAN_TYPE -> BooleanHolder(readBoolean())
+      CHAR_TYPE -> CharHolder(readChar())
+      FLOAT_TYPE -> FloatHolder(readFloat())
+      DOUBLE_TYPE -> DoubleHolder(readDouble())
+      BYTE_TYPE -> ByteHolder(readByte())
+      SHORT_TYPE -> ShortHolder(readShort())
+      INT_TYPE -> IntHolder(readInt())
+      LONG_TYPE -> LongHolder(readLong())
+      else -> throw IllegalStateException("Unknown type ${field.type}")
+    }
+  }
+
+  private fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    return when (identifierByteSize) {
+      1 -> readByte().toLong()
+      2 -> readShort().toLong()
+      4 -> readInt().toLong()
+      8 -> readLong()
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  private fun readBoolean(): Boolean {
+    val value = record.fieldValues[position]
+    position++
+    return value != 0.toByte()
+  }
+
+  private fun readByte(): Byte {
+    val value = record.fieldValues[position]
+    position++
+    return value
+  }
+
+  private fun readInt(): Int {
+    val value = record.fieldValues.readInt(position)
+    position += 4
+    return value
+  }
+
+  private fun readShort(): Short {
+    val value = record.fieldValues.readShort(position)
+    position += 2
+    return value
+  }
+
+  private fun readLong(): Long {
+    val value = record.fieldValues.readLong(position)
+    position += 8
+    return value
+  }
+
+  private fun readFloat(): Float {
+    return Float.fromBits(readInt())
+  }
+
+  private fun readDouble(): Double {
+    return Double.fromBits(readLong())
+  }
+
+  private fun readChar(): Char {
+    val string = String(record.fieldValues, position, 2, Charsets.UTF_16BE)
+    position += 2
+    return string[0]
+  }
+
+  companion object {
+    private val BOOLEAN_TYPE = BOOLEAN.hprofType
+    private val CHAR_TYPE = CHAR.hprofType
+    private val FLOAT_TYPE = FLOAT.hprofType
+    private val DOUBLE_TYPE = DOUBLE.hprofType
+    private val BYTE_TYPE = BYTE.hprofType
+    private val SHORT_TYPE = SHORT.hprofType
+    private val INT_TYPE = INT.hprofType
+    private val LONG_TYPE = LONG.hprofType
+  }
+
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
new file mode 100644
index 00000000..91eb1749
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -0,0 +1,438 @@
+package shark.internal
+
+import shark.GcRoot
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.Hprof
+import shark.HprofRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+import shark.OnHprofRecordListener
+import shark.PrimitiveType
+import shark.ProguardMapping
+import shark.ValueHolder
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
+import shark.internal.hppc.LongLongScatterMap
+import shark.internal.hppc.LongObjectScatterMap
+import kotlin.reflect.KClass
+
+/**
+ * This class is not thread safe, should be used from a single thread.
+ */
+@Suppress("TooManyFunctions")
+internal class HprofInMemoryIndex private constructor(
+  private val positionSize: Int,
+  private val hprofStringCache: LongObjectScatterMap<String>,
+  private val classNames: LongLongScatterMap,
+  private val classIndex: SortedBytesMap,
+  private val instanceIndex: SortedBytesMap,
+  private val objectArrayIndex: SortedBytesMap,
+  private val primitiveArrayIndex: SortedBytesMap,
+  private val gcRoots: List<GcRoot>,
+  private val proguardMapping: ProguardMapping?,
+  val primitiveWrapperTypes: Set<Long>
+) {
+
+  fun fieldName(
+    classId: Long,
+    id: Long
+  ): String {
+    val fieldNameString = hprofStringById(id)
+    return proguardMapping?.let {
+      val classNameStringId = classNames[classId]
+      val classNameString = hprofStringById(classNameStringId)
+      proguardMapping.deobfuscateFieldName(classNameString, fieldNameString)
+    } ?: fieldNameString
+  }
+
+  fun className(classId: Long): String {
+    // String, primitive types
+    val classNameStringId = classNames[classId]
+    val classNameString = hprofStringById(classNameStringId)
+    return proguardMapping?.deobfuscateClassName(classNameString) ?: classNameString
+  }
+
+  fun classId(className: String): Long? {
+    // Note: this performs two linear scans over arrays
+    val hprofStringId = hprofStringCache.entrySequence()
+        .firstOrNull { it.second == className }
+        ?.first
+    return hprofStringId?.let { stringId ->
+      classNames.entrySequence()
+          .firstOrNull { it.second == stringId }
+          ?.first
+    }
+  }
+
+  fun indexedClassSequence(): Sequence<Pair<Long, IndexedClass>> {
+    return classIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          id to IndexedClass(
+              position = array.readTruncatedLong(positionSize),
+              superclassId = array.readId(),
+              instanceSize = array.readInt()
+          )
+        }
+  }
+
+  fun indexedInstanceSequence(): Sequence<Pair<Long, IndexedInstance>> {
+    return instanceIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          val instance = IndexedInstance(
+              position = array.readTruncatedLong(positionSize),
+              classId = array.readId()
+          )
+          id to instance
+        }
+  }
+
+  fun indexedObjectArraySequence(): Sequence<Pair<Long, IndexedObjectArray>> {
+    return objectArrayIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          val objectArray = IndexedObjectArray(
+              position = array.readTruncatedLong(positionSize),
+              arrayClassId = array.readId()
+          )
+          id to objectArray
+        }
+  }
+
+  fun indexedPrimitiveArraySequence(): Sequence<Pair<Long, IndexedPrimitiveArray>> {
+    return primitiveArrayIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+
+          val primitiveArray = IndexedPrimitiveArray(
+              position = array.readTruncatedLong(positionSize),
+              primitiveType = PrimitiveType.values()[array.readByte().toInt()]
+          )
+          id to primitiveArray
+        }
+  }
+
+  fun indexedObjectSequence(): Sequence<Pair<Long, IndexedObject>> {
+    return indexedClassSequence() +
+        indexedInstanceSequence() +
+        indexedObjectArraySequence() +
+        indexedPrimitiveArraySequence()
+  }
+
+  fun gcRoots(): List<GcRoot> {
+    return gcRoots
+  }
+
+  fun indexedObject(objectId: Long): IndexedObject {
+    return indexedObjectOrNull(objectId) ?: throw IllegalArgumentException(
+        "Object id $objectId not found in heap dump."
+    )
+  }
+
+  @Suppress("ReturnCount")
+  private fun indexedObjectOrNull(objectId: Long): IndexedObject? {
+    var array: ByteSubArray? = classIndex[objectId]
+    if (array != null) {
+      return IndexedClass(
+          position = array.readTruncatedLong(positionSize),
+          superclassId = array.readId(),
+          instanceSize = array.readInt()
+      )
+    }
+    array = instanceIndex[objectId]
+    if (array != null) {
+      return IndexedInstance(
+          position = array.readTruncatedLong(positionSize),
+          classId = array.readId()
+      )
+    }
+    array = objectArrayIndex[objectId]
+    if (array != null) {
+      return IndexedObjectArray(
+          position = array.readTruncatedLong(positionSize),
+          arrayClassId = array.readId()
+      )
+    }
+    array = primitiveArrayIndex[objectId]
+    if (array != null) {
+      return IndexedPrimitiveArray(
+          position = array.readTruncatedLong(positionSize),
+          primitiveType = PrimitiveType.values()[array.readByte().toInt()]
+      )
+    }
+    return null
+  }
+
+  @Suppress("ReturnCount")
+  fun objectIdIsIndexed(objectId: Long): Boolean {
+    if (classIndex[objectId] != null) {
+      return true
+    }
+    if (instanceIndex[objectId] != null) {
+      return true
+    }
+    if (objectArrayIndex[objectId] != null) {
+      return true
+    }
+    if (primitiveArrayIndex[objectId] != null) {
+      return true
+    }
+    return false
+  }
+
+  private fun hprofStringById(id: Long): String {
+    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
+  }
+
+  private class Builder(
+    longIdentifiers: Boolean,
+    fileLength: Long,
+    classCount: Int,
+    instanceCount: Int,
+    objectArrayCount: Int,
+    primitiveArrayCount: Int,
+    private val indexedGcRootsTypes: Set<KClass<out GcRoot>>
+  ) : OnHprofRecordListener {
+
+    private val identifierSize = if (longIdentifiers) 8 else 4
+    private val positionSize = byteSizeForUnsigned(fileLength)
+
+    /**
+     * Map of string id to string
+     * This currently keeps all the hprof strings that we could care about: class names,
+     * static field names and instance fields names
+     */
+    // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
+    // memory. Can be stored as 3 arrays: array of keys, array of values which are indexes into
+    // a large array of string bytes. Each "entry" consists of a size, the index of the previous
+    // segment and then the segment content.
+
+    private val hprofStringCache = LongObjectScatterMap<String>()
+
+    /**
+     * class id to string id
+     */
+    private val classNames = LongLongScatterMap()
+
+    private val classIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize + 4,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = classCount
+    )
+    private val instanceIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = instanceCount
+    )
+    private val objectArrayIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = objectArrayCount
+    )
+    private val primitiveArrayIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + 1,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = primitiveArrayCount
+    )
+
+    /**
+     * Class ids for primitive wrapper types
+     */
+    private val primitiveWrapperTypes = mutableSetOf<Long>()
+
+    /**
+     * String ids for class names of primitive wrapper types
+     */
+    private val primitiveWrapperClassNames = mutableSetOf<Long>()
+
+    private val gcRoots = mutableListOf<GcRoot>()
+
+    override fun onHprofRecord(
+      position: Long,
+      record: HprofRecord
+    ) {
+      when (record) {
+        is StringRecord -> {
+          if (PRIMITIVE_WRAPPER_TYPES.contains(record.string)) {
+            primitiveWrapperClassNames.add(record.id)
+          }
+          // JVM heap dumps use "/" for package separators (vs "." for Android heap dumps)
+          hprofStringCache[record.id] = record.string.replace('/', '.')
+        }
+        is LoadClassRecord -> {
+          classNames[record.id] = record.classNameStringId
+          if (primitiveWrapperClassNames.contains(record.classNameStringId)) {
+            primitiveWrapperTypes.add(record.id)
+          }
+        }
+        is GcRootRecord -> {
+          val gcRoot = record.gcRoot
+          if (gcRoot.id != ValueHolder.NULL_REFERENCE && gcRoot::class in indexedGcRootsTypes) {
+            gcRoots += gcRoot
+          }
+        }
+        is ClassSkipContentRecord -> {
+          classIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.superclassId)
+                writeInt(record.instanceSize)
+              }
+        }
+        is InstanceSkipContentRecord -> {
+          instanceIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.classId)
+              }
+        }
+        is ObjectArraySkipContentRecord -> {
+          objectArrayIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.arrayClassId)
+              }
+        }
+        is PrimitiveArraySkipContentRecord -> {
+          primitiveArrayIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeByte(record.type.ordinal.toByte())
+              }
+        }
+      }
+    }
+
+    fun buildIndex(
+      proguardMapping: ProguardMapping?
+    ): HprofInMemoryIndex {
+      val sortedInstanceIndex = instanceIndex.moveToSortedMap()
+      val sortedObjectArrayIndex = objectArrayIndex.moveToSortedMap()
+      val sortedPrimitiveArrayIndex = primitiveArrayIndex.moveToSortedMap()
+      val sortedClassIndex = classIndex.moveToSortedMap()
+      // Passing references to avoid copying the underlying data structures.
+      return HprofInMemoryIndex(
+          positionSize,
+          hprofStringCache, classNames, sortedClassIndex, sortedInstanceIndex,
+          sortedObjectArrayIndex,
+          sortedPrimitiveArrayIndex, gcRoots,
+          proguardMapping,
+          primitiveWrapperTypes
+      )
+    }
+
+  }
+
+  companion object {
+
+    private val PRIMITIVE_WRAPPER_TYPES = setOf<String>(
+        Boolean::class.java.name, Char::class.java.name, Float::class.java.name,
+        Double::class.java.name, Byte::class.java.name, Short::class.java.name,
+        Int::class.java.name, Long::class.java.name
+    )
+
+    private fun byteSizeForUnsigned(maxValue: Long): Int {
+      var value = maxValue
+      var byteCount = 0
+      while (value != 0L) {
+        value = value shr 8
+        byteCount++
+      }
+      return byteCount
+    }
+
+    fun createReadingHprof(
+      hprof: Hprof,
+      proguardMapping: ProguardMapping?,
+      indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
+          JniGlobal::class,
+          JavaFrame::class,
+          JniLocal::class,
+          MonitorUsed::class,
+          NativeStack::class,
+          StickyClass::class,
+          ThreadBlock::class,
+          // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
+          // belongs to
+          ThreadObject::class,
+          JniMonitor::class
+          /*
+          Not included here:
+
+          VmInternal: Ignoring because we've got 150K of it, but is this the right thing
+          to do? What's VmInternal exactly? History does not go further than
+          https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+          We should log to figure out what objects VmInternal points to.
+
+          ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
+
+          Unknown: it's unknown, should we care?
+
+          We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
+           */
+      )
+    ): HprofInMemoryIndex {
+      val recordTypes = setOf(
+          StringRecord::class,
+          LoadClassRecord::class,
+          ClassSkipContentRecord::class,
+          InstanceSkipContentRecord::class,
+          ObjectArraySkipContentRecord::class,
+          PrimitiveArraySkipContentRecord::class,
+          GcRootRecord::class
+      )
+      val reader = hprof.reader
+
+      // First pass to count and correctly size arrays once and for all.
+      var classCount = 0
+      var instanceCount = 0
+      var objectArrayCount = 0
+      var primitiveArrayCount = 0
+      reader.readHprofRecords(setOf(
+          LoadClassRecord::class,
+          InstanceSkipContentRecord::class,
+          ObjectArraySkipContentRecord::class,
+          PrimitiveArraySkipContentRecord::class
+      ), OnHprofRecordListener { position, record ->
+        when (record) {
+          is LoadClassRecord -> classCount++
+          is InstanceSkipContentRecord -> instanceCount++
+          is ObjectArraySkipContentRecord -> objectArrayCount++
+          is PrimitiveArraySkipContentRecord -> primitiveArrayCount++
+        }
+      })
+
+      hprof.moveReaderTo(reader.startPosition)
+      val indexBuilderListener =
+        Builder(
+            reader.identifierByteSize == 8, hprof.fileLength, classCount, instanceCount,
+            objectArrayCount, primitiveArrayCount, indexedGcRootTypes
+        )
+
+      reader.readHprofRecords(recordTypes, indexBuilderListener)
+
+      return indexBuilderListener.buildIndex(proguardMapping)
+    }
+
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt b/shark-graph/src/main/java/shark/internal/IndexedObject.kt
similarity index 88%
rename from leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt
rename to shark-graph/src/main/java/shark/internal/IndexedObject.kt
index 925fe8f1..007beb80 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt
+++ b/shark-graph/src/main/java/shark/internal/IndexedObject.kt
@@ -1,13 +1,13 @@
-package leakcanary.internal
+package shark.internal
 
-import leakcanary.PrimitiveType
+import shark.PrimitiveType
 
 internal sealed class IndexedObject {
   abstract val position: Long
 
   class IndexedClass(
     override val position: Long,
-    val superClassId: Long,
+    val superclassId: Long,
     val instanceSize: Int
   ) : IndexedObject()
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt b/shark-graph/src/main/java/shark/internal/LruCache.kt
similarity index 98%
rename from leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt
rename to shark-graph/src/main/java/shark/internal/LruCache.kt
index 46d81d9b..aae02c72 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt
+++ b/shark-graph/src/main/java/shark/internal/LruCache.kt
@@ -1,4 +1,4 @@
-package leakcanary.internal
+package shark.internal
 
 import java.util.LinkedHashMap
 import kotlin.collections.MutableMap.MutableEntry
diff --git a/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
new file mode 100644
index 00000000..54658e88
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
@@ -0,0 +1,69 @@
+package shark.internal
+
+/**
+ * A read only map of `id` => `byte array` sorted by id, where `id` is a long if [longIdentifiers]
+ * is true and an int otherwise. Each entry has a value byte array of size [bytesPerValue].
+ *
+ * Instances are created by [UnsortedByteEntries]
+ *
+ * [get] and [contains] perform a binary search to locate a specific entry by key.
+ */
+internal class SortedBytesMap(
+  private val longIdentifiers: Boolean,
+  private val bytesPerValue: Int,
+  private val sortedEntries: ByteArray
+) {
+  private val bytesPerKey = if (longIdentifiers) 8 else 4
+  private val bytesPerEntry = bytesPerKey + bytesPerValue
+
+  private val size = sortedEntries.size / bytesPerEntry
+
+  operator fun get(key: Long): ByteSubArray? {
+    val keyIndex = binarySearch(key)
+    if (keyIndex < 0) {
+      return null
+    }
+    val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
+    return ByteSubArray(sortedEntries, valueIndex, bytesPerValue, longIdentifiers)
+  }
+
+  operator fun contains(key: Long): Boolean {
+    val keyIndex = binarySearch(key)
+    return keyIndex >= 0
+  }
+
+  fun entrySequence(): Sequence<Pair<Long, ByteSubArray>> {
+    return (0 until size).asSequence()
+        .map { keyIndex ->
+          val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
+          keyAt(keyIndex) to ByteSubArray(sortedEntries, valueIndex, bytesPerValue, longIdentifiers)
+        }
+  }
+
+  private fun binarySearch(
+    key: Long
+  ): Int {
+    val startIndex = 0
+    val endIndex = size
+    var lo = startIndex
+    var hi = endIndex - 1
+    while (lo <= hi) {
+      val mid = (lo + hi).ushr(1)
+      val midVal = keyAt(mid)
+      when {
+        midVal < key -> lo = mid + 1
+        midVal > key -> hi = mid - 1
+        else -> return mid
+      }
+    }
+    return lo.inv()
+  }
+
+  private fun keyAt(index: Int): Long {
+    val keyIndex = index * bytesPerEntry
+    return if (longIdentifiers)
+      sortedEntries.readLong(keyIndex)
+    else
+      sortedEntries.readInt(keyIndex).toLong()
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
new file mode 100644
index 00000000..9dfc81dd
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
@@ -0,0 +1,195 @@
+package shark.internal
+
+import shark.internal.aosp.ByteArrayComparator
+import shark.internal.aosp.ByteArrayTimSort
+
+/**
+ * Wraps a byte array of entries where each entry is an id followed by bytes for the value.
+ * `id` is a long if [longIdentifiers] is true and an int otherwise. Each entry has [bytesPerValue]
+ * value bytes. Entries are appended into the array via [append]. Once done, the backing array
+ * is sorted and turned into a [SortedBytesMap] by calling [moveToSortedMap].
+ */
+internal class UnsortedByteEntries(
+  private val bytesPerValue: Int,
+  private val longIdentifiers: Boolean,
+  private val initialCapacity: Int = 4,
+  private val growthFactor: Double = 2.0
+) {
+
+  private val bytesPerEntry = bytesPerValue + if (longIdentifiers) 8 else 4
+
+  private var entries: ByteArray? = null
+  private val subArray = MutableByteSubArray()
+  private var subArrayIndex = 0
+
+  private var assigned: Int = 0
+  private var currentCapacity = 0
+
+  fun append(
+    key: Long
+  ): MutableByteSubArray {
+    if (entries == null) {
+      currentCapacity = initialCapacity
+      entries = ByteArray(currentCapacity * bytesPerEntry)
+    } else {
+      if (currentCapacity == assigned) {
+        val newCapacity = (currentCapacity * growthFactor).toInt()
+        growEntries(newCapacity)
+        currentCapacity = newCapacity
+      }
+    }
+    assigned++
+    subArrayIndex = 0
+    subArray.writeId(key)
+    return subArray
+  }
+
+  fun moveToSortedMap(): SortedBytesMap {
+    if (assigned == 0) {
+      return SortedBytesMap(longIdentifiers, bytesPerValue, ByteArray(0))
+    }
+    val entries = entries!!
+    // Sort entries by keys, which are ids of 4 or 8 bytes.
+    ByteArrayTimSort.sort(entries, 0, assigned, bytesPerEntry, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        return if (longIdentifiers) {
+          readLong(o1Array, o1Index * entrySize)
+              .compareTo(
+                  readLong(o2Array, o2Index * entrySize)
+              )
+        } else {
+          readInt(o1Array, o1Index * entrySize)
+              .compareTo(
+                  readInt(o2Array, o2Index * entrySize)
+              )
+        }
+      }
+    })
+    val sortedEntries = if (entries.size > assigned * bytesPerEntry) {
+      entries.copyOf(assigned * bytesPerEntry)
+    } else entries
+    this.entries = null
+    assigned = 0
+    return SortedBytesMap(
+        longIdentifiers, bytesPerValue, sortedEntries
+    )
+  }
+
+  private fun readInt(
+    array: ByteArray,
+    index: Int
+  ): Int {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+        or (array[pos++] and 0xff shl 16)
+        or (array[pos++] and 0xff shl 8)
+        or (array[pos] and 0xff))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+
+  private fun readLong(
+    array: ByteArray,
+    index: Int
+  ): Long {
+    var pos = index
+    return (array[pos++] and 0xffL shl 56
+        or (array[pos++] and 0xffL shl 48)
+        or (array[pos++] and 0xffL shl 40)
+        or (array[pos++] and 0xffL shl 32)
+        or (array[pos++] and 0xffL shl 24)
+        or (array[pos++] and 0xffL shl 16)
+        or (array[pos++] and 0xffL shl 8)
+        or (array[pos] and 0xffL))
+  }
+
+  private fun growEntries(newCapacity: Int) {
+    val newEntries = ByteArray(newCapacity * bytesPerEntry)
+    System.arraycopy(entries, 0, newEntries, 0, assigned * bytesPerEntry)
+    entries = newEntries
+  }
+
+  internal inner class MutableByteSubArray {
+    fun writeByte(value: Byte) {
+      val index = subArrayIndex
+      subArrayIndex++
+      require(index in 0..bytesPerEntry) {
+        "Index $index should be between 0 and $bytesPerEntry"
+      }
+      val valuesIndex = ((assigned - 1) * bytesPerEntry) + index
+      entries!![valuesIndex] = value
+    }
+
+    fun writeId(value: Long) {
+      if (longIdentifiers) {
+        writeLong(value)
+      } else {
+        writeInt(value.toInt())
+      }
+    }
+
+    fun writeInt(value: Int) {
+      val index = subArrayIndex
+      subArrayIndex += 4
+      require(index >= 0 && index <= bytesPerEntry - 4) {
+        "Index $index should be between 0 and ${bytesPerEntry - 4}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      values[pos++] = (value ushr 24 and 0xff).toByte()
+      values[pos++] = (value ushr 16 and 0xff).toByte()
+      values[pos++] = (value ushr 8 and 0xff).toByte()
+      values[pos] = (value and 0xff).toByte()
+    }
+
+    fun writeTruncatedLong(
+      value: Long,
+      byteCount: Int
+    ) {
+      val index = subArrayIndex
+      subArrayIndex += byteCount
+      require(index >= 0 && index <= bytesPerEntry - byteCount) {
+        "Index $index should be between 0 and ${bytesPerEntry - byteCount}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+
+      var shift = (byteCount - 1) * 8
+      while(shift >= 8) {
+        values[pos++] = (value ushr shift and 0xffL).toByte()
+        shift -= 8
+      }
+      values[pos] = (value and 0xffL).toByte()
+    }
+
+    fun writeLong(value: Long) {
+      val index = subArrayIndex
+      subArrayIndex += 8
+      require(index >= 0 && index <= bytesPerEntry - 8) {
+        "Index $index should be between 0 and ${bytesPerEntry - 8}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      values[pos++] = (value ushr 56 and 0xffL).toByte()
+      values[pos++] = (value ushr 48 and 0xffL).toByte()
+      values[pos++] = (value ushr 40 and 0xffL).toByte()
+      values[pos++] = (value ushr 32 and 0xffL).toByte()
+      values[pos++] = (value ushr 24 and 0xffL).toByte()
+      values[pos++] = (value ushr 16 and 0xffL).toByte()
+      values[pos++] = (value ushr 8 and 0xffL).toByte()
+      values[pos] = (value and 0xffL).toByte()
+    }
+  }
+
+}
+
diff --git a/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt
new file mode 100644
index 00000000..b77672d4
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt
@@ -0,0 +1,15 @@
+package shark.internal.aosp
+
+internal interface ByteArrayComparator {
+
+  /**
+   * Indexes are divided by entrySize
+   */
+  fun compare(
+    entrySize: Int,
+    o1Array: ByteArray,
+    o1Index: Int,
+    o2Array: ByteArray,
+    o2Index: Int
+  ): Int
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt
new file mode 100644
index 00000000..11b13604
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt
@@ -0,0 +1,1073 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark.internal.aosp
+
+/*
+This is TimSort.java from AOSP (Jelly Bean MR2, Apache 2 license), converted to Kotlin and adapted
+to work with byte array chunks. The passed in byte array is virtually divided into entries of a
+fixed number of bytes N. Each entry is compared by a custom comparator.
+
+ Copied from https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/java/util/TimSort.java
+*/
+
+/**
+ * A stable, adaptive, iterative mergesort that requires far fewer than
+ * n lg(n) comparisons when running on partially sorted arrays, while
+ * offering performance comparable to a traditional mergesort when run
+ * on random arrays.  Like all proper mergesorts, this sort is stable and
+ * runs O(n log n) time (worst case).  In the worst case, this sort requires
+ * temporary storage space for n/2 object references; in the best case,
+ * it requires only a small constant amount of space.
+ *
+ * This implementation was adapted from Tim Peters's list sort for
+ * Python, which is described in detail here:
+ *
+ * http://svn.python.org/projects/python/trunk/Objects/listsort.txt
+ *
+ * Tim's C code may be found here:
+ *
+ * http://svn.python.org/projects/python/trunk/Objects/listobject.c
+ *
+ * The underlying techniques are described in this paper (and may have
+ * even earlier origins):
+ *
+ * "Optimistic Sorting and Information Theoretic Complexity"
+ * Peter McIlroy
+ * SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
+ * pp 467-474, Austin, Texas, 25-27 January 1993.
+ *
+ * While the API to this class consists solely of static methods, it is
+ * (privately) instantiable; a TimSort instance holds the state of an ongoing
+ * sort, assuming the input array is large enough to warrant the full-blown
+ * TimSort. Small arrays are sorted in place, using a binary insertion sort.
+ */
+@Suppress("ComplexMethod", "ComplexCondition", "LongMethod", "LongParameterList")
+internal class ByteArrayTimSort
+/**
+ * Creates a TimSort instance to maintain the state of an ongoing sort.
+ *
+ * @param a the array to be sorted
+ * @param c the comparator to determine the order of the sort
+ */
+private constructor(
+  /**
+   * The array being sorted.
+   */
+  private val a: ByteArray,
+  /**
+   * The comparator for this sort.
+   */
+  private val c: ByteArrayComparator,
+
+  private val entrySize: Int
+) {
+  /**
+   * This controls when we get *into* galloping mode.  It is initialized
+   * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
+   * random data, and lower for highly structured data.
+   */
+  private var minGallop = MIN_GALLOP
+  /**
+   * Temp storage for merges.
+   */
+  private var tmp: ByteArray? = null // Actual runtime type will be Object[], regardless of T
+  /**
+   * A stack of pending runs yet to be merged.  Run i starts at
+   * address base[i] and extends for len[i] elements.  It's always
+   * true (so long as the indices are in bounds) that:
+   *
+   * runBase[i] + runLen[i] == runBase[i + 1]
+   *
+   * so we could cut the storage for this, but it's a minor amount,
+   * and keeping all the info explicit simplifies the code.
+   */
+  private var stackSize = 0  // Number of pending runs on stack
+  private val runBase: IntArray
+  private val runLen: IntArray
+
+  init {
+    // Allocate temp storage (which may be increased later if necessary)
+    val len = a.size / entrySize
+    val newArray = ByteArray(
+        entrySize *
+            if (len < 2 * INITIAL_TMP_STORAGE_LENGTH)
+              len.ushr(1)
+            else
+              INITIAL_TMP_STORAGE_LENGTH
+    )
+    tmp = newArray
+    /*
+         * Allocate runs-to-be-merged stack (which cannot be expanded).  The
+         * stack length requirements are described in listsort.txt.  The C
+         * version always uses the same stack length (85), but this was
+         * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
+         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
+         * large) stack lengths for smaller arrays.  The "magic numbers" in the
+         * computation below must be changed if MIN_MERGE is decreased.  See
+         * the MIN_MERGE declaration above for more information.
+         */
+    val stackLen = if (len < 120)
+      5
+    else if (len < 1542)
+      10
+    else if (len < 119151) 19 else 40
+    runBase = IntArray(stackLen)
+    runLen = IntArray(stackLen)
+  }
+
+  /**
+   * Pushes the specified run onto the pending-run stack.
+   *
+   * @param runBase index of the first element in the run
+   * @param runLen  the number of elements in the run
+   */
+  private fun pushRun(
+    runBase: Int,
+    runLen: Int
+  ) {
+    this.runBase[stackSize] = runBase
+    this.runLen[stackSize] = runLen
+    stackSize++
+  }
+
+  /**
+   * Examines the stack of runs waiting to be merged and merges adjacent runs
+   * until the stack invariants are reestablished:
+   *
+   * 1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
+   * 2. runLen[i - 2] > runLen[i - 1]
+   *
+   * This method is called each time a new run is pushed onto the stack,
+   * so the invariants are guaranteed to hold for i < stackSize upon
+   * entry to the method.
+   */
+  // Fixed with http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/
+  private fun mergeCollapse() {
+    while (stackSize > 1) {
+      var n = stackSize - 2
+      if (n >= 1 && runLen[n - 1] <= runLen[n] + runLen[n + 1] || n >= 2 && runLen[n - 2] <= runLen[n] + runLen[n - 1]) {
+        if (runLen[n - 1] < runLen[n + 1])
+          n--
+      } else if (runLen[n] > runLen[n + 1]) {
+        break // Invariant is established
+      }
+      mergeAt(n)
+    }
+  }
+
+  /**
+   * Merges all runs on the stack until only one remains.  This method is
+   * called once, to complete the sort.
+   */
+  private fun mergeForceCollapse() {
+    while (stackSize > 1) {
+      var n = stackSize - 2
+      if (n > 0 && runLen[n - 1] < runLen[n + 1])
+        n--
+      mergeAt(n)
+    }
+  }
+
+  /**
+   * Merges the two runs at stack indices i and i+1.  Run i must be
+   * the penultimate or antepenultimate run on the stack.  In other words,
+   * i must be equal to stackSize-2 or stackSize-3.
+   *
+   * @param i stack index of the first of the two runs to merge
+   */
+  private fun mergeAt(i: Int) {
+    if (DEBUG) assert(stackSize >= 2)
+    if (DEBUG) assert(i >= 0)
+    if (DEBUG) assert(i == stackSize - 2 || i == stackSize - 3)
+    var base1 = runBase[i]
+    var len1 = runLen[i]
+    val base2 = runBase[i + 1]
+    var len2 = runLen[i + 1]
+    if (DEBUG) assert(len1 > 0 && len2 > 0)
+    if (DEBUG) assert(base1 + len1 == base2)
+    /*
+         * Record the length of the combined runs; if i is the 3rd-last
+         * run now, also slide over the last run (which isn't involved
+         * in this merge).  The current run (i+1) goes away in any case.
+         */
+    runLen[i] = len1 + len2
+    if (i == stackSize - 3) {
+      runBase[i + 1] = runBase[i + 2]
+      runLen[i + 1] = runLen[i + 2]
+    }
+    stackSize--
+    /*
+         * Find where the first element of run2 goes in run1. Prior elements
+         * in run1 can be ignored (because they're already in place).
+         */
+    val k = gallopRight(a, base2, a, base1, len1, 0, entrySize, c)
+    if (DEBUG) assert(k >= 0)
+    base1 += k
+    len1 -= k
+    if (len1 == 0)
+      return
+    /*
+         * Find where the last element of run1 goes in run2. Subsequent elements
+         * in run2 can be ignored (because they're already in place).
+         */
+    len2 = gallopLeft(a, base1 + len1 - 1, a, base2, len2, len2 - 1, entrySize, c)
+    if (DEBUG) assert(len2 >= 0)
+    if (len2 == 0)
+      return
+    // Merge remaining runs, using tmp array with min(len1, len2) elements
+    if (len1 <= len2)
+      mergeLo(base1, len1, base2, len2)
+    else
+      mergeHi(base1, len1, base2, len2)
+  }
+
+  /**
+   * Merges two adjacent runs in place, in a stable fashion.  The first
+   * element of the first run must be greater than the first element of the
+   * second run (a[base1] > a[base2]), and the last element of the first run
+   * (a[base1 + len1-1]) must be greater than all elements of the second run.
+   *
+   * For performance, this method should be called only when len1 <= len2;
+   * its twin, mergeHi should be called if len1 >= len2.  (Either method
+   * may be called if len1 == len2.)
+   *
+   * @param base1 index of first element in first run to be merged
+   * @param len1  length of first run to be merged (must be > 0)
+   * @param base2 index of first element in second run to be merged
+   * (must be aBase + aLen)
+   * @param len2  length of second run to be merged (must be > 0)
+   */
+  private fun mergeLo(
+    base1: Int,
+    len1: Int,
+    base2: Int,
+    len2: Int
+  ) {
+    var len1 = len1
+    var len2 = len2
+    if (DEBUG) assert(len1 > 0 && len2 > 0 && base1 + len1 == base2)
+    // Copy first run into temp array
+    val a = this.a // For performance
+    val entrySize = entrySize
+    val tmp = ensureCapacity(len1)
+    System.arraycopy(a, base1 * entrySize, tmp, 0, len1 * entrySize)
+    var cursor1 = 0       // Indexes into tmp array
+    var cursor2 = base2   // Indexes int a
+    var dest = base1      // Indexes int a
+    // Move first element of second run and deal with degenerate cases
+    val destIndex = dest * entrySize
+    val cursor2Index = cursor2 * entrySize
+    for (i in 0 until entrySize) {
+      a[destIndex + i] = a[cursor2Index + i]
+    }
+    dest++
+    cursor2++
+
+    if (--len2 == 0) {
+      System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, len1 * entrySize)
+      return
+    }
+    if (len1 == 1) {
+      System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, len2 * entrySize)
+      val destLen2Index = (dest + len2) * entrySize
+      val cursor1Index = cursor1 * entrySize
+      for (i in 0 until entrySize) {
+        a[destLen2Index + i] = tmp[cursor1Index + i] // Last elt of run 1 to end of merge
+      }
+      return
+    }
+    val c = this.c  // Use local variable for performance
+    var minGallop = this.minGallop    //  "    "       "     "      "
+    outer@ while (true) {
+      var count1 = 0 // Number of times in a row that first run won
+      var count2 = 0 // Number of times in a row that second run won
+      /*
+       * Do the straightforward thing until (if ever) one run starts
+       * winning consistently.
+       */
+      do {
+        if (DEBUG) assert(len1 > 1 && len2 > 0)
+        if (c.compare(entrySize, a, cursor2, tmp, cursor1) < 0) {
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = a[cursor2Index + i]
+          }
+          dest++
+          cursor2++
+          count2++
+          count1 = 0
+          if (--len2 == 0)
+            break@outer
+        } else {
+          val destIndex = dest * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor1Index + i]
+          }
+          dest++
+          cursor1++
+          count1++
+          count2 = 0
+          if (--len1 == 1)
+            break@outer
+        }
+      } while (count1 or count2 < minGallop)
+      /*
+             * One run is winning so consistently that galloping may be a
+             * huge win. So try that, and continue galloping until (if ever)
+             * neither run appears to be winning consistently anymore.
+             */
+      do {
+        if (DEBUG) assert(len1 > 1 && len2 > 0)
+        count1 = gallopRight(a, cursor2, tmp, cursor1, len1, 0, entrySize, c)
+        if (count1 != 0) {
+          System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, count1 * entrySize)
+          dest += count1
+          cursor1 += count1
+          len1 -= count1
+          if (len1 <= 1)
+          // len1 == 1 || len1 == 0
+            break@outer
+        }
+        var destIndex = dest * entrySize
+        val cursor2Index = cursor2 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = a[cursor2Index + i]
+        }
+        dest++
+        cursor2++
+        if (--len2 == 0)
+          break@outer
+        count2 = gallopLeft(tmp, cursor1, a, cursor2, len2, 0, entrySize, c)
+        if (count2 != 0) {
+          System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, count2 * entrySize)
+          dest += count2
+          cursor2 += count2
+          len2 -= count2
+          if (len2 == 0)
+            break@outer
+        }
+        destIndex = dest * entrySize
+        val cursor1Index = cursor1 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = tmp[cursor1Index + i]
+        }
+        dest++
+        cursor1++
+        if (--len1 == 1)
+          break@outer
+        minGallop--
+      } while ((count1 >= MIN_GALLOP) or (count2 >= MIN_GALLOP))
+      if (minGallop < 0)
+        minGallop = 0
+      minGallop += 2  // Penalize for leaving gallop mode
+    }  // End of "outer" loop
+    this.minGallop = if (minGallop < 1) 1 else minGallop  // Write back to field
+    if (len1 == 1) {
+      if (DEBUG) assert(len2 > 0)
+      System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, len2 * entrySize)
+      val destLen2Index = (dest + len2) * entrySize
+      val cursor1Index = cursor1 * entrySize
+      for (i in 0 until entrySize) {
+        a[destLen2Index + i] = tmp[cursor1Index + i] //  Last elt of run 1 to end of merge
+      }
+    } else if (len1 == 0) {
+      throw IllegalArgumentException(
+          "Comparison method violates its general contract!"
+      )
+    } else {
+      if (DEBUG) assert(len2 == 0)
+      if (DEBUG) assert(len1 > 1)
+      System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, len1 * entrySize)
+    }
+  }
+
+  /**
+   * Like mergeLo, except that this method should be called only if
+   * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
+   * may be called if len1 == len2.)
+   *
+   * @param base1 index of first element in first run to be merged
+   * @param len1  length of first run to be merged (must be > 0)
+   * @param base2 index of first element in second run to be merged
+   * (must be aBase + aLen)
+   * @param len2  length of second run to be merged (must be > 0)
+   */
+  private fun mergeHi(
+    base1: Int,
+    len1: Int,
+    base2: Int,
+    len2: Int
+  ) {
+    var len1 = len1
+    var len2 = len2
+    if (DEBUG) assert(len1 > 0 && len2 > 0 && base1 + len1 == base2)
+    // Copy second run into temp array
+    val a = this.a // For performance
+    val tmp = ensureCapacity(len2)
+    val entrySize = entrySize
+    System.arraycopy(a, base2 * entrySize, tmp, 0, len2 * entrySize)
+    var cursor1 = base1 + len1 - 1  // Indexes into a
+    var cursor2 = len2 - 1          // Indexes into tmp array
+    var dest = base2 + len2 - 1     // Indexes into a
+    // Move last element of first run and deal with degenerate cases
+    var destIndex = dest * entrySize
+    val cursor1Index = cursor1 * entrySize
+    for (i in 0 until entrySize) {
+      a[destIndex + i] = a[cursor1Index + i]
+    }
+    dest--
+    cursor1--
+    if (--len1 == 0) {
+      System.arraycopy(tmp, 0, a, (dest - (len2 - 1)) * entrySize, len2 * entrySize)
+      return
+    }
+    if (len2 == 1) {
+      dest -= len1
+      cursor1 -= len1
+      System.arraycopy(a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, len1 * entrySize)
+      val destIndex = dest * entrySize
+      val cursor2Index = cursor2 * entrySize
+      for (i in 0 until entrySize) {
+        a[destIndex + i] = tmp[cursor2Index + i]
+      }
+      return
+    }
+    val c = this.c  // Use local variable for performance
+    var minGallop = this.minGallop    //  "    "       "     "      "
+    outer@ while (true) {
+      var count1 = 0 // Number of times in a row that first run won
+      var count2 = 0 // Number of times in a row that second run won
+      /*
+             * Do the straightforward thing until (if ever) one run
+             * appears to win consistently.
+             */
+      do {
+        if (DEBUG) assert(len1 > 0 && len2 > 1)
+        if (c.compare(entrySize, tmp, cursor2, a, cursor1) < 0) {
+          val destIndex = dest * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = a[cursor1Index + i]
+          }
+          dest--
+          cursor1--
+          count1++
+          count2 = 0
+          if (--len1 == 0)
+            break@outer
+        } else {
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor2Index + i]
+          }
+          dest--
+          cursor2--
+          count2++
+          count1 = 0
+          if (--len2 == 1)
+            break@outer
+        }
+      } while (count1 or count2 < minGallop)
+      /*
+             * One run is winning so consistently that galloping may be a
+             * huge win. So try that, and continue galloping until (if ever)
+             * neither run appears to be winning consistently anymore.
+             */
+      do {
+        if (DEBUG) assert(len1 > 0 && len2 > 1)
+        count1 = len1 - gallopRight(tmp, cursor2, a, base1, len1, len1 - 1, entrySize, c)
+        if (count1 != 0) {
+          dest -= count1
+          cursor1 -= count1
+          len1 -= count1
+          System.arraycopy(
+              a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, count1 * entrySize
+          )
+          if (len1 == 0)
+            break@outer
+        }
+        destIndex = dest * entrySize
+        val cursor2Index = cursor2 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = tmp[cursor2Index + i]
+        }
+        dest--
+        cursor2--
+        if (--len2 == 1)
+          break@outer
+        count2 = len2 - gallopLeft(a, cursor1, tmp, 0, len2, len2 - 1, entrySize, c)
+        if (count2 != 0) {
+          dest -= count2
+          cursor2 -= count2
+          len2 -= count2
+          System.arraycopy(
+              tmp, (cursor2 + 1) * entrySize, a, (dest + 1) * entrySize, count2 * entrySize
+          )
+          if (len2 <= 1)
+          // len2 == 1 || len2 == 0
+            break@outer
+        }
+        val destIndex = dest * entrySize
+        val cursor1Index = cursor1 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = a[cursor1Index + i]
+        }
+        dest--
+        cursor1--
+        if (--len1 == 0)
+          break@outer
+        minGallop--
+      } while ((count1 >= MIN_GALLOP) or (count2 >= MIN_GALLOP))
+      if (minGallop < 0)
+        minGallop = 0
+      minGallop += 2  // Penalize for leaving gallop mode
+    }  // End of "outer" loop
+    this.minGallop = if (minGallop < 1) 1 else minGallop  // Write back to field
+    if (len2 == 1) {
+      if (DEBUG) assert(len1 > 0)
+      dest -= len1
+      cursor1 -= len1
+      System.arraycopy(a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, len1 * entrySize)
+      val destIndex = dest * entrySize
+      val cursor2Index = cursor2 * entrySize
+      for (i in 0 until entrySize) {
+        a[destIndex + i] = tmp[cursor2Index + i] // Move first elt of run2 to front of merge
+      }
+    } else if (len2 == 0) {
+      throw IllegalArgumentException(
+          "Comparison method violates its general contract!"
+      )
+    } else {
+      if (DEBUG) assert(len1 == 0)
+      if (DEBUG) assert(len2 > 0)
+      System.arraycopy(tmp, 0, a, (dest - (len2 - 1)) * entrySize, len2 * entrySize)
+    }
+  }
+
+  /**
+   * Ensures that the external array tmp has at least the specified
+   * number of elements, increasing its size if necessary.  The size
+   * increases exponentially to ensure amortized linear time complexity.
+   *
+   * @param minCapacity the minimum required capacity of the tmp array
+   * @return tmp, whether or not it grew
+   */
+  private fun ensureCapacity(minCapacity: Int): ByteArray {
+    if (tmp!!.size < minCapacity * entrySize) {
+      // Compute smallest power of 2 > minCapacity
+      var newSize = minCapacity
+      newSize = newSize or (newSize shr 1)
+      newSize = newSize or (newSize shr 2)
+      newSize = newSize or (newSize shr 4)
+      newSize = newSize or (newSize shr 8)
+      newSize = newSize or (newSize shr 16)
+      newSize++
+      if (newSize < 0)
+      // Not bloody likely!
+        newSize = minCapacity
+      else
+        newSize = Math.min(newSize, (a.size / entrySize).ushr(1))
+      val newArray = ByteArray(newSize * entrySize)
+      tmp = newArray
+    }
+    return tmp!!
+  }
+
+  companion object {
+    /**
+     * This is the minimum sized sequence that will be merged.  Shorter
+     * sequences will be lengthened by calling binarySort.  If the entire
+     * array is less than this length, no merges will be performed.
+     *
+     * This constant should be a power of two.  It was 64 in Tim Peter's C
+     * implementation, but 32 was empirically determined to work better in
+     * this implementation.  In the unlikely event that you set this constant
+     * to be a number that's not a power of two, you'll need to change the
+     * [.minRunLength] computation.
+     *
+     * If you decrease this constant, you must change the stackLen
+     * computation in the TimSort constructor, or you risk an
+     * ArrayOutOfBounds exception.  See listsort.txt for a discussion
+     * of the minimum stack length required as a function of the length
+     * of the array being sorted and the minimum merge sequence length.
+     */
+    private val MIN_MERGE = 32
+    /**
+     * When we get into galloping mode, we stay there until both runs win less
+     * often than MIN_GALLOP consecutive times.
+     */
+    private val MIN_GALLOP = 7
+    /**
+     * Maximum initial size of tmp array, which is used for merging.  The array
+     * can grow to accommodate demand.
+     *
+     * Unlike Tim's original C version, we do not allocate this much storage
+     * when sorting smaller arrays.  This change was required for performance.
+     */
+    private val INITIAL_TMP_STORAGE_LENGTH = 256
+    /**
+     * Asserts have been placed in if-statements for performace. To enable them,
+     * set this field to true and enable them in VM with a command line flag.
+     * If you modify this class, please do test the asserts!
+     */
+    private val DEBUG = false
+
+    /*
+     * The next two methods (which are package private and static) constitute
+     * the entire API of this class.  Each of these methods obeys the contract
+     * of the public method with the same signature in java.util.Arrays.
+     */
+    fun sort(
+      a: ByteArray,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      sort(a, 0, a.size / entrySize, entrySize, c)
+    }
+
+    fun sort(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      var lo = lo
+      checkStartAndEnd(a.size / entrySize, lo, hi)
+      var nRemaining = hi - lo
+      if (nRemaining < 2)
+        return   // Arrays of size 0 and 1 are always sorted
+      // If array is small, do a "mini-TimSort" with no merges
+      if (nRemaining < MIN_MERGE) {
+        val initRunLen = countRunAndMakeAscending(a, lo, hi, entrySize, c)
+        binarySort(a, lo, hi, lo + initRunLen, entrySize, c)
+        return
+      }
+      /**
+       * March over the array once, left to right, finding natural runs,
+       * extending short natural runs to minRun elements, and merging runs
+       * to maintain stack invariant.
+       */
+      val ts = ByteArrayTimSort(a, c, entrySize)
+      val minRun = minRunLength(nRemaining)
+      do {
+        // Identify next run
+        var runLen = countRunAndMakeAscending(a, lo, hi, entrySize, c)
+        // If run is short, extend to min(minRun, nRemaining)
+        if (runLen < minRun) {
+          val force = if (nRemaining <= minRun) nRemaining else minRun
+          binarySort(a, lo, lo + force, lo + runLen, entrySize, c)
+          runLen = force
+        }
+        // Push run onto pending-run stack, and maybe merge
+        ts.pushRun(lo, runLen)
+        ts.mergeCollapse()
+        // Advance to find next run
+        lo += runLen
+        nRemaining -= runLen
+      } while (nRemaining != 0)
+      // Merge all remaining runs to complete sort
+      if (DEBUG) assert(lo == hi)
+      ts.mergeForceCollapse()
+      if (DEBUG) assert(ts.stackSize == 1)
+    }
+
+    private fun checkStartAndEnd(
+      len: Int,
+      start: Int,
+      end: Int
+    ) {
+      if (start < 0 || end > len) {
+        throw ArrayIndexOutOfBoundsException(
+            "start < 0 || end > len."
+                + " start=" + start + ", end=" + end + ", len=" + len
+        )
+      }
+      if (start > end) {
+        throw IllegalArgumentException("start > end: $start > $end")
+      }
+    }
+
+    /**
+     * Sorts the specified portion of the specified array using a binary
+     * insertion sort.  This is the best method for sorting small numbers
+     * of elements.  It requires O(n log n) compares, but O(n^2) data
+     * movement (worst case).
+     *
+     * If the initial part of the specified range is already sorted,
+     * this method can take advantage of it: the method assumes that the
+     * elements from index `lo`, inclusive, to `start`,
+     * exclusive are already sorted.
+     *
+     * @param a the array in which a range is to be sorted
+     * @param lo the index of the first element in the range to be sorted
+     * @param hi the index after the last element in the range to be sorted
+     * @param start the index of the first element in the range that is
+     * not already known to be sorted (@code lo <= start <= hi}
+     * @param c comparator to used for the sort
+     */
+    private fun binarySort(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      start: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      var start = start
+      if (DEBUG) assert(lo <= start && start <= hi)
+      if (start == lo)
+        start++
+      val pivot = ByteArray(entrySize)
+      while (start < hi) {
+        val startIndex = start * entrySize
+        for (i in 0 until entrySize) {
+          pivot[i] = a[startIndex + i]
+        }
+        // Set left (and right) to the index where a[start] (pivot) belongs
+        var left = lo
+        var right = start
+        if (DEBUG) assert(left <= right)
+        /*
+             * Invariants:
+             *   pivot >= all in [lo, left).
+             *   pivot <  all in [right, start).
+             */
+        while (left < right) {
+          val mid = (left + right).ushr(1)
+          if (c.compare(entrySize, pivot, 0, a, mid) < 0)
+            right = mid
+          else
+            left = mid + 1
+        }
+        if (DEBUG) assert(left == right)
+        /*
+             * The invariants still hold: pivot >= all in [lo, left) and
+             * pivot < all in [left, start), so pivot belongs at left.  Note
+             * that if there are elements equal to pivot, left points to the
+             * first slot after them -- that's why this sort is stable.
+             * Slide elements over to make room for pivot.
+             */
+        val n = start - left  // The number of elements to move
+        // Switch is just an optimization for arraycopy in default case
+        when (n) {
+          2 -> {
+            val leftIndex = left * entrySize
+            val leftPlusOneIndex = (left + 1) * entrySize
+            val leftPlusTwoIndex = (left + 2) * entrySize
+            for (i in 0 until entrySize) {
+              a[leftPlusTwoIndex + i] = a[leftPlusOneIndex + i]
+            }
+            for (i in 0 until entrySize) {
+              a[leftPlusOneIndex + i] = a[leftIndex + i]
+            }
+          }
+          1 -> {
+            val leftIndex = left * entrySize
+            val leftPlusOneIndex = (left + 1) * entrySize
+            for (i in 0 until entrySize) {
+              a[leftPlusOneIndex + i] = a[leftIndex + i]
+            }
+          }
+          else -> {
+            System.arraycopy(a, left * entrySize, a, (left + 1) * entrySize, n * entrySize)
+          }
+        }
+        val leftIndex = left * entrySize
+        for (i in 0 until entrySize) {
+          a[leftIndex + i] = pivot[i]
+        }
+        start++
+      }
+    }
+
+    /**
+     * Returns the length of the run beginning at the specified position in
+     * the specified array and reverses the run if it is descending (ensuring
+     * that the run will always be ascending when the method returns).
+     *
+     * A run is the longest ascending sequence with:
+     *
+     * a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
+     *
+     * or the longest descending sequence with:
+     *
+     * a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
+     *
+     * For its intended use in a stable mergesort, the strictness of the
+     * definition of "descending" is needed so that the call can safely
+     * reverse a descending sequence without violating stability.
+     *
+     * @param a the array in which a run is to be counted and possibly reversed
+     * @param lo index of the first element in the run
+     * @param hi index after the last element that may be contained in the run.
+     * It is required that @code{lo < hi}.
+     * @param c the comparator to used for the sort
+     * @return  the length of the run beginning at the specified position in
+     * the specified array
+     */
+    private fun countRunAndMakeAscending(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(lo < hi)
+      var runHi = lo + 1
+      if (runHi == hi)
+        return 1
+      // Find end of run, and reverse range if descending
+
+      val comparison = c.compare(entrySize, a, runHi, a, lo)
+      runHi++
+      if (comparison < 0) { // Descending
+        while (runHi < hi && c.compare(entrySize, a, runHi, a, runHi - 1) < 0)
+          runHi++
+        reverseRange(a, lo, runHi, entrySize)
+      } else {                              // Ascending
+        while (runHi < hi && c.compare(entrySize, a, runHi, a, runHi - 1) >= 0)
+          runHi++
+      }
+      return runHi - lo
+    }
+
+    /**
+     * Reverse the specified range of the specified array.
+     *
+     * @param a the array in which a range is to be reversed
+     * @param lo the index of the first element in the range to be reversed
+     * @param hi the index after the last element in the range to be reversed
+     */
+    private fun reverseRange(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int
+    ) {
+      var lo = lo
+      var hi = hi
+      hi--
+      while (lo < hi) {
+        val loIndex = lo * entrySize
+        val hiIndex = hi * entrySize
+        for (i in 0 until entrySize) {
+          val t = a[loIndex + i]
+          a[loIndex + i] = a[hiIndex + i]
+          a[hiIndex + i] = t
+        }
+        lo++
+        hi--
+      }
+    }
+
+    /**
+     * Returns the minimum acceptable run length for an array of the specified
+     * length. Natural runs shorter than this will be extended with
+     * [.binarySort].
+     *
+     * Roughly speaking, the computation is:
+     *
+     * If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
+     * Else if n is an exact power of 2, return MIN_MERGE/2.
+     * Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
+     * is close to, but strictly less than, an exact power of 2.
+     *
+     * For the rationale, see listsort.txt.
+     *
+     * @param n the length of the array to be sorted
+     * @return the length of the minimum run to be merged
+     */
+    private fun minRunLength(n: Int): Int {
+      var n = n
+      if (DEBUG) assert(n >= 0)
+      var r = 0      // Becomes 1 if any 1 bits are shifted off
+      while (n >= MIN_MERGE) {
+        r = r or (n and 1)
+        n = n shr 1
+      }
+      return n + r
+    }
+
+    /**
+     * Locates the position at which to insert the specified key into the
+     * specified sorted range; if the range contains an element equal to key,
+     * returns the index of the leftmost equal element.
+     *
+     * @param key the key whose insertion point to search for
+     * @param a the array in which to search
+     * @param base the index of the first element in the range
+     * @param len the length of the range; must be > 0
+     * @param hint the index at which to begin the search, 0 <= hint < n.
+     * The closer hint is to the result, the faster this method will run.
+     * @param c the comparator used to order the range, and to search
+     * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
+     * pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
+     * In other words, key belongs at index b + k; or in other words,
+     * the first k elements of a should precede key, and the last n - k
+     * should follow it.
+     */
+    private fun gallopLeft(
+      keyArray: ByteArray,
+        // Index already divided by entrySize
+      keyIndex: Int,
+      a: ByteArray,
+      base: Int,
+      len: Int,
+      hint: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(len > 0 && hint >= 0 && hint < len)
+      var lastOfs = 0
+      var ofs = 1
+      if (c.compare(entrySize, keyArray, keyIndex, a, base + hint) > 0) {
+        // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
+        val maxOfs = len - hint
+        while (ofs < maxOfs && c.compare(entrySize, keyArray, keyIndex, a, base + hint + ofs) > 0) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to base
+        lastOfs += hint
+        ofs += hint
+      } else { // key <= a[base + hint]
+        // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
+        val maxOfs = hint + 1
+        while (ofs < maxOfs && c.compare(
+                entrySize, keyArray, keyIndex, a, base + hint - ofs
+            ) <= 0
+        ) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to base
+        val tmp = lastOfs
+        lastOfs = hint - ofs
+        ofs = hint - tmp
+      }
+      if (DEBUG) assert(-1 <= lastOfs && lastOfs < ofs && ofs <= len)
+      /*
+         * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
+         * to the right of lastOfs but no farther right than ofs.  Do a binary
+         * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
+         */
+      lastOfs++
+      while (lastOfs < ofs) {
+        val m = lastOfs + (ofs - lastOfs).ushr(1)
+        if (c.compare(entrySize, keyArray, keyIndex, a, base + m) > 0)
+          lastOfs = m + 1  // a[base + m] < key
+        else
+          ofs = m          // key <= a[base + m]
+      }
+      if (DEBUG) assert(lastOfs == ofs)    // so a[base + ofs - 1] < key <= a[base + ofs]
+      return ofs
+    }
+
+    /**
+     * Like gallopLeft, except that if the range contains an element equal to
+     * key, gallopRight returns the index after the rightmost equal element.
+     *
+     * @param key the key whose insertion point to search for
+     * @param a the array in which to search
+     * @param base the index of the first element in the range
+     * @param len the length of the range; must be > 0
+     * @param hint the index at which to begin the search, 0 <= hint < n.
+     * The closer hint is to the result, the faster this method will run.
+     * @param c the comparator used to order the range, and to search
+     * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
+     */
+    private fun gallopRight(
+      keyArray: ByteArray,
+        // Index already divided by entrySize
+      keyIndex: Int,
+      a: ByteArray,
+      base: Int,
+      len: Int,
+      hint: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(len > 0 && hint >= 0 && hint < len)
+      var ofs = 1
+      var lastOfs = 0
+      if (c.compare(entrySize, keyArray, keyIndex, a, base + hint) < 0) {
+        // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
+        val maxOfs = hint + 1
+        while (ofs < maxOfs && c.compare(entrySize, keyArray, keyIndex, a, base + hint - ofs) < 0) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to b
+        val tmp = lastOfs
+        lastOfs = hint - ofs
+        ofs = hint - tmp
+      } else { // a[b + hint] <= key
+        // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
+        val maxOfs = len - hint
+        while (ofs < maxOfs && c.compare(
+                entrySize, keyArray, keyIndex, a, base + hint + ofs
+            ) >= 0
+        ) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to b
+        lastOfs += hint
+        ofs += hint
+      }
+      if (DEBUG) assert(-1 <= lastOfs && lastOfs < ofs && ofs <= len)
+      /*
+         * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
+         * the right of lastOfs but no farther right than ofs.  Do a binary
+         * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
+         */
+      lastOfs++
+      while (lastOfs < ofs) {
+        val m = lastOfs + (ofs - lastOfs).ushr(1)
+        if (c.compare(entrySize, keyArray, keyIndex, a, base + m) < 0)
+          ofs = m          // key < a[b + m]
+        else
+          lastOfs = m + 1  // a[b + m] <= key
+      }
+      if (DEBUG) assert(lastOfs == ofs)    // so a[b + ofs - 1] <= key < a[b + ofs]
+      return ofs
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt b/shark-graph/src/main/java/shark/internal/hppc/HHPC.kt
similarity index 73%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt
rename to shark-graph/src/main/java/shark/internal/hppc/HHPC.kt
index 08357b54..01cebe29 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/HHPC.kt
@@ -1,4 +1,20 @@
-package leakcanary.internal.hppc
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
 
 import java.util.Locale
 
@@ -17,7 +33,6 @@ internal object HHPC {
   private const val MIN_HASH_ARRAY_LENGTH = 4
   private const val MAX_HASH_ARRAY_LENGTH = (-0x80000000).ushr(1)
 
-
   fun minBufferSize(
     elements: Int,
     loadFactor: Double
@@ -43,7 +58,6 @@ internal object HHPC {
     return length.toInt()
   }
 
-
   fun nextHighestPowerOfTwo(input: Long): Long {
     var v = input
     v--
@@ -57,7 +71,6 @@ internal object HHPC {
     return v
   }
 
-
   fun expandAtCount(
     arraySize: Int,
     loadFactor: Double
@@ -65,7 +78,6 @@ internal object HHPC {
     return Math.min(arraySize - 1, Math.ceil(arraySize * loadFactor).toInt())
   }
 
-
   fun nextBufferSize(
     arraySize: Int,
     elements: Int,
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
new file mode 100644
index 00000000..a37d1ceb
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
@@ -0,0 +1,403 @@
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongLongScatterMap copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+@Suppress("TooManyFunctions")
+class LongLongScatterMap {
+  /**
+   * The array holding keys.
+   */
+  private var keys: LongArray = longArrayOf()
+
+  /**
+   * The array holding values.
+   */
+  private var values: LongArray = longArrayOf()
+
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any (use [.size] instead).
+   *
+   * @see .size
+   */
+  private var assigned: Int = 0
+
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask: Int = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt: Int = 0
+
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey: Boolean = false
+
+  /**
+   * The load factor for [.keys].
+   */
+  private var loadFactor: Double = 0.75
+
+  val isEmpty: Boolean
+    get() = size == 0
+
+  init {
+    ensureCapacity(4)
+  }
+
+  operator fun set(
+    key: Long,
+    value: Long
+  ): Long {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = true
+      val previousValue = values[mask + 1]
+      values[mask + 1] = value
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          values[slot] = value
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key, value)
+      } else {
+        keys[slot] = key
+        values[slot] = value
+      }
+
+      assigned++
+      return 0L
+    }
+  }
+
+  fun remove(key: Long): Long {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = false
+      val previousValue = values[mask + 1]
+      values[mask + 1] = 0L
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          shiftConflictingKeys(slot)
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return 0L
+    }
+  }
+
+  /**
+   * Being given a key looks it up in the map and returns the slot where element sits, so it later
+   * can be retrieved with [getSlotValue]; return '-1' if element not found.
+   * Why so complicated and not just make [get] return null if value not found? The reason is performance:
+   * this approach prevents unnecessary boxing of the primitive long that would happen with nullable Long?
+   */
+  fun getSlot(key: Long): Int {
+    if (key == 0L) {
+      return if (hasEmptyKey) mask + 1 else -1
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return slot
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return -1
+    }
+  }
+
+  /**
+   * Being given a slot of element retrieves it from the collection
+   */
+  fun getSlotValue(slot: Int): Long = values[slot]
+
+  /**
+   * Returns an element matching a provided [key]; throws [IllegalArgumentException] if element not found
+   */
+  operator fun get(key: Long): Long {
+    val slot = getSlot(key)
+    require(slot != -1) { "Unknown key $key" }
+
+    return getSlotValue(slot)
+  }
+
+  fun forEach(block: (Long, Long) -> Unit) {
+    val max = mask + 1
+    var slot = -1
+
+    exitWhile@while (true) {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            block(existing, values[slot])
+            continue@exitWhile
+          }
+          slot++
+        }
+      }
+
+      if (slot == max && hasEmptyKey) {
+        slot++
+        block(0L, values[max])
+        continue@exitWhile
+      }
+      break@exitWhile
+    }
+  }
+
+  fun entrySequence(): Sequence<Pair<Long, Long>> {
+    val max = mask + 1
+    var slot = -1
+    return generateSequence {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            return@generateSequence existing to values[slot]
+          }
+          slot++
+        }
+      }
+      if (slot == max && hasEmptyKey) {
+        slot++
+        return@generateSequence  0L to values[max]
+      }
+      return@generateSequence null
+    }
+  }
+
+  fun containsKey(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return false
+    }
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+
+    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+  }
+
+  val size: Int
+    get() {
+      return assigned + if (hasEmptyKey) 1 else 0
+    }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      val prevValues = this.values
+      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      if (!isEmpty) {
+        rehash(prevKeys, prevValues)
+      }
+    }
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HHPC.mixPhi(key)
+  }
+
+  /**
+   * Rehash from old buffers to new buffers.
+   */
+  private fun rehash(
+    fromKeys: LongArray,
+    fromValues: LongArray
+  ) {
+    // Rehash all stored key/value pairs into the new buffers.
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+    var existing: Long
+
+    // Copy the zero element's slot, then rehash everything else.
+    var from = fromKeys.size - 1
+    keys[keys.size - 1] = fromKeys[from]
+    values[values.size - 1] = fromValues[from]
+    while (--from >= 0) {
+      existing = fromKeys[from]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+        values[slot] = fromValues[from]
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+      this.values = LongArray(arraySize + emptyElementSlot)
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      this.values = prevValues
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Not enough memory to allocate buffers for rehashing: %,d -> %,d",
+              this.mask + 1,
+              arraySize
+          ), e
+      )
+    }
+
+    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  /**
+   * This method is invoked when there is a new key/ value pair to be inserted into
+   * the buffers but there is not enough empty slots to do so.
+   *
+   * New buffers are allocated. If this succeeds, we know we can proceed
+   * with rehashing so we assign the pending element to the previous buffer
+   * (possibly violating the invariant of having at least one empty slot)
+   * and rehash all keys, substituting new buffers at the end.
+   */
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long,
+    pendingValue: Long
+  ) {
+
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    allocateBuffers(HHPC.nextBufferSize(mask + 1, size, loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+    prevValues[slot] = pendingValue
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys, prevValues)
+  }
+
+  /**
+   * Shift all the slot-conflicting keys and values allocated to
+   * (and including) `slot`.
+   */
+  private fun shiftConflictingKeys(gapSlotArg: Int) {
+    var gapSlot = gapSlotArg
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+
+    // Perform shifts of conflicting keys to fill in the gap.
+    var distance = 0
+    while (true) {
+      val slot = gapSlot + ++distance and mask
+      val existing = keys[slot]
+      if (existing == 0L) {
+        break
+      }
+
+      val idealSlot = hashKey(existing)
+      val shift = slot - idealSlot and mask
+      if (shift >= distance) {
+        // Entry at this position was originally at or before the gap slot.
+        // Move the conflict-shifted entry to the gap's position and repeat the procedure
+        // for any entries to the right of the current position, treating it
+        // as the new gap.
+        keys[gapSlot] = existing
+        values[gapSlot] = values[slot]
+        gapSlot = slot
+        distance = 0
+      }
+    }
+
+    // Mark the last found gap slot without a conflict as empty.
+    keys[gapSlot] = 0L
+    values[gapSlot] = 0L
+    assigned--
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
similarity index 83%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt
rename to shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
index 90e13d31..d705f685 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
@@ -1,4 +1,20 @@
-package leakcanary.internal.hppc
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
 
 import java.util.Locale
 
@@ -7,7 +23,8 @@ import java.util.Locale
  *
  * See https://github.com/carrotsearch/hppc .
  */
-internal class LongLongScatterMap {
+@Suppress("TooManyFunctions")
+internal class LongObjectScatterMap<T> {
   /**
    * The array holding keys.
    */
@@ -16,7 +33,8 @@ internal class LongLongScatterMap {
   /**
    * The array holding values.
    */
-  private var values: LongArray = longArrayOf()
+  @Suppress("UNCHECKED_CAST")
+  private var values: Array<T?> = emptyArray<Any?>() as Array<T?>
 
   /**
    * The number of stored keys (assigned key slots), excluding the special
@@ -55,8 +73,8 @@ internal class LongLongScatterMap {
 
   operator fun set(
     key: Long,
-    value: Long
-  ): Long {
+    value: T
+  ): T? {
     val mask = this.mask
     if (key == 0L) {
       hasEmptyKey = true
@@ -86,16 +104,16 @@ internal class LongLongScatterMap {
       }
 
       assigned++
-      return 0L
+      return null
     }
   }
 
-  fun remove(key: Long): Long {
+  fun remove(key: Long): T? {
     val mask = this.mask
     if (key == 0L) {
       hasEmptyKey = false
       val previousValue = values[mask + 1]
-      values[mask + 1] = 0L
+      values[mask + 1] = null
       return previousValue
     } else {
       val keys = this.keys
@@ -112,11 +130,11 @@ internal class LongLongScatterMap {
         existing = keys[slot]
       }
 
-      return 0L
+      return null
     }
   }
 
-  operator fun get(key: Long): Long? {
+  operator fun get(key: Long): T? {
     if (key == 0L) {
       return if (hasEmptyKey) values[mask + 1] else null
     } else {
@@ -137,30 +155,26 @@ internal class LongLongScatterMap {
     }
   }
 
-  fun forEach(block: (Long, Long) -> Unit) {
+  fun entrySequence(): Sequence<Pair<Long, T>> {
     val max = mask + 1
     var slot = -1
-
-    exitWhile@while (true) {
+    return generateSequence {
       if (slot < max) {
         var existing: Long
         slot++
         while (slot < max) {
           existing = keys[slot]
           if (existing != 0L) {
-            block(existing, values[slot])
-            continue@exitWhile
+            return@generateSequence existing to values[slot]!!
           }
           slot++
         }
       }
-
       if (slot == max && hasEmptyKey) {
         slot++
-        block(0L, values[max])
-        continue@exitWhile
+        return@generateSequence  0L to values[max]!!
       }
-      break@exitWhile
+      return@generateSequence null
     }
   }
 
@@ -217,7 +231,7 @@ internal class LongLongScatterMap {
    */
   private fun rehash(
     fromKeys: LongArray,
-    fromValues: LongArray
+    fromValues: Array<T?>
   ) {
     // Rehash all stored key/value pairs into the new buffers.
     val keys = this.keys
@@ -254,7 +268,8 @@ internal class LongLongScatterMap {
     try {
       val emptyElementSlot = 1
       this.keys = LongArray(arraySize + emptyElementSlot)
-      this.values = LongArray(arraySize + emptyElementSlot)
+      @Suppress("UNCHECKED_CAST")
+      this.values = arrayOfNulls<Any?>(arraySize + emptyElementSlot) as Array<T?>
     } catch (e: OutOfMemoryError) {
       this.keys = prevKeys
       this.values = prevValues
@@ -284,7 +299,7 @@ internal class LongLongScatterMap {
   private fun allocateThenInsertThenRehash(
     slot: Int,
     pendingKey: Long,
-    pendingValue: Long
+    pendingValue: T
   ) {
 
     // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
@@ -305,8 +320,8 @@ internal class LongLongScatterMap {
    * Shift all the slot-conflicting keys and values allocated to
    * (and including) `slot`.
    */
-  private fun shiftConflictingKeys(gapSlot: Int) {
-    var gapSlot = gapSlot
+  private fun shiftConflictingKeys(gapSlotArg: Int) {
+    var gapSlot = gapSlotArg
     val keys = this.keys
     val values = this.values
     val mask = this.mask
@@ -336,7 +351,7 @@ internal class LongLongScatterMap {
 
     // Mark the last found gap slot without a conflict as empty.
     keys[gapSlot] = 0L
-    values[gapSlot] = 0L
+    values[gapSlot] = null
     assigned--
   }
 }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
similarity index 85%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt
rename to shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
index 7a4034f2..3aecfc24 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
@@ -1,4 +1,20 @@
-package leakcanary.internal.hppc
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
 
 import java.util.Locale
 
@@ -7,7 +23,7 @@ import java.util.Locale
  *
  * See https://github.com/carrotsearch/hppc .
  */
-internal class LongScatterSet {
+class LongScatterSet {
   /** The hash array holding keys.  */
   private var keys: LongArray = longArrayOf()
   /**
diff --git a/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
new file mode 100644
index 00000000..292f41e0
--- /dev/null
+++ b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
@@ -0,0 +1,110 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.internal.aosp.ByteArrayComparator
+import shark.internal.aosp.ByteArrayTimSort
+import java.lang.IllegalStateException
+import kotlin.random.Random
+
+class ByteArrayTimSortTest {
+
+  @Test fun smallArray1BytePerEntry() {
+    val toSort = byteArrayOf(2, 1, 4)
+
+    ByteArrayTimSort.sort(toSort, 0, 3, 1, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        return o1Array[o1Index].compareTo(o2Array[o2Index])
+      }
+    })
+    assertThat(toSort).containsExactly(1, 2, 4)
+  }
+
+  @Test fun smallArray3BytesPerEntry1ByteKey() {
+    val toSort = byteArrayOf(2, 3, 3, 1, 5, 5, 4, 6, 6)
+
+    ByteArrayTimSort.sort(toSort, 3, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        // Sort based on first byte
+        return o1Array[o1Index * entrySize].compareTo(o2Array[o2Index * entrySize])
+      }
+    })
+    assertThat(toSort).containsExactly(1, 5, 5, 2, 3, 3, 4, 6, 6)
+  }
+
+  @Test fun largeRandomArray8BytesPerEntry4BytesKey() {
+    val entryCount = 10000
+    val entrySize = 8
+    val random = Random(Int.MIN_VALUE)
+    val librarySorted = random.nextBytes(entryCount * entrySize)
+
+    class Entry(val eightBytes: ByteArray) : Comparable<Entry> {
+      override fun compareTo(other: Entry): Int {
+        val compared = readInt(eightBytes, 0).compareTo(readInt(other.eightBytes, 0))
+        if (compared == 0){
+          return readInt(eightBytes, 4).compareTo(readInt(other.eightBytes, 4))
+        }
+        return compared
+      }
+    }
+
+    val androidSorted = arrayOfNulls<Entry>(entryCount)
+    for (i in 0 until entryCount) {
+      val index = i * entrySize
+      androidSorted[i] = Entry(librarySorted.copyOfRange(index, index + entrySize))
+    }
+    androidSorted.sort()
+    val androidSortedAsBytes = ByteArray(entryCount * entrySize)
+
+    for (i in 0 until entryCount) {
+        System.arraycopy(
+            androidSorted[i]!!.eightBytes, 0, androidSortedAsBytes, i * entrySize, entrySize
+        )
+    }
+
+    ByteArrayTimSort.sort(librarySorted, entrySize, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        val compared = readInt(o1Array, o1Index * entrySize).compareTo(readInt(o2Array, o2Index * entrySize))
+        if (compared == 0) {
+          return readInt(o1Array, o1Index * entrySize + 4).compareTo(readInt(o2Array, o2Index * entrySize + 4))
+        }
+        return compared
+      }
+    })
+
+    assertThat(librarySorted.asList()).isEqualTo(androidSortedAsBytes.asList())
+  }
+
+  fun readInt(
+    array: ByteArray,
+    index: Int
+  ): Int {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+        or (array[pos++] and 0xff shl 16)
+        or (array[pos++] and 0xff shl 8)
+        or (array[pos] and 0xff))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+
+}
\ No newline at end of file
diff --git a/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt b/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
new file mode 100644
index 00000000..86ea4a39
--- /dev/null
+++ b/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
@@ -0,0 +1,72 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.CHAR
+import java.io.File
+
+class HprofPrimitiveArrayStripperTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  @Test
+  fun stripHprof() {
+    val hprofFile = testFolder.newFile("temp.hprof")
+
+    val booleanArray = BooleanArrayDump(id, 1, booleanArrayOf(true, false, true, true))
+    val charArray = CharArrayDump(id, 1, "Hello World!".toCharArray())
+    hprofFile.writeRecords(listOf(booleanArray, charArray))
+
+    val stripper = HprofPrimitiveArrayStripper()
+
+    val strippedFile = stripper.stripPrimitiveArrays(hprofFile)
+
+    strippedFile.readHprof { graph ->
+      val booleanArrays = graph.objects
+          .filter { it is HeapPrimitiveArray && it.primitiveType == BOOLEAN }
+          .map { it.readRecord() as BooleanArrayDump }
+          .toList()
+      assertThat(booleanArrays).hasSize(1)
+      assertThat(booleanArrays[0].id).isEqualTo(booleanArray.id)
+      assertThat(booleanArrays[0].array).isEqualTo(booleanArrayOf(false, false, false, false))
+
+      val charArrays = graph.objects
+          .filter { it is HeapPrimitiveArray && it.primitiveType == CHAR }
+          .map { it.readRecord() as CharArrayDump }
+          .toList()
+      assertThat(charArrays).hasSize(1)
+      assertThat(charArrays[0].id).isEqualTo(charArray.id)
+      assertThat(charArrays[0].array).isEqualTo("????????????".toCharArray())
+    }
+  }
+
+  private fun File.writeRecords(
+    records: List<HprofRecord>
+  ) {
+    HprofWriter.open(this)
+        .use { writer ->
+          records.forEach { record ->
+            writer.write(record)
+          }
+        }
+  }
+
+  fun File.readHprof(block: (HeapGraph) -> Unit) {
+    Hprof.open(this)
+        .use { hprof ->
+          block(HprofHeapGraph.indexHprof(hprof))
+        }
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt b/shark-graph/src/test/java/shark/HprofWriterTest.kt
similarity index 73%
rename from leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
rename to shark-graph/src/test/java/shark/HprofWriterTest.kt
index a3d0b26d..68ff199f 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
+++ b/shark-graph/src/test/java/shark/HprofWriterTest.kt
@@ -1,16 +1,16 @@
-package leakcanary
+package shark
 
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StringRecord
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
 class HprofWriterTest {
@@ -30,7 +30,9 @@ class HprofWriterTest {
     hprofFile.writeRecords(records)
 
     hprofFile.readHprof { graph ->
-      val treasureChestClass = graph.indexedClass(TREASURE_CHEST_CLASS_NAME)!!
+      val treasureChestClass = graph.findClassByName(
+          TREASURE_CHEST_CLASS_NAME
+      )!!
       val baguetteInstance =
         treasureChestClass[CONTENT_FIELD_NAME]!!.value.asObject!!.asInstance!!
 
@@ -40,11 +42,14 @@ class HprofWriterTest {
     }
   }
 
-  private fun createRecords(): List<Record> {
+  private fun createRecords(): List<HprofRecord> {
     val magicWandClassName = StringRecord(id, MAGIC_WAND_CLASS_NAME)
     val baguetteClassName = StringRecord(id, BAGUETTE_CLASS_NAME)
     val answerFieldName = StringRecord(id, ANSWER_FIELD_NAME)
-    val treasureChestClassName = StringRecord(id, TREASURE_CHEST_CLASS_NAME)
+    val treasureChestClassName = StringRecord(
+        id,
+        TREASURE_CHEST_CLASS_NAME
+    )
     val contentFieldName = StringRecord(id, CONTENT_FIELD_NAME)
     val loadMagicWandClass = LoadClassRecord(1, id, 1, magicWandClassName.id)
     val loadBaguetteClass = LoadClassRecord(1, id, 1, baguetteClassName.id)
@@ -52,7 +57,7 @@ class HprofWriterTest {
     val magicWandClassDump = ClassDumpRecord(
         id = loadMagicWandClass.id,
         stackTraceSerialNumber = 1,
-        superClassId = 0,
+        superclassId = 0,
         classLoaderId = 0,
         signersId = 0,
         protectionDomainId = 0,
@@ -63,13 +68,13 @@ class HprofWriterTest {
     val baguetteClassDump = ClassDumpRecord(
         id = loadBaguetteClass.id,
         stackTraceSerialNumber = 1,
-        superClassId = loadMagicWandClass.id,
+        superclassId = loadMagicWandClass.id,
         classLoaderId = 0,
         signersId = 0,
         protectionDomainId = 0,
         instanceSize = 0,
         staticFields = emptyList(),
-        fields = listOf(FieldRecord(answerFieldName.id, HprofReader.INT_TYPE))
+        fields = listOf(FieldRecord(answerFieldName.id, PrimitiveType.INT.hprofType))
     )
 
     val baguetteInstanceDump = InstanceDumpRecord(
@@ -82,15 +87,15 @@ class HprofWriterTest {
     val treasureChestClassDump = ClassDumpRecord(
         id = loadTreasureChestClass.id,
         stackTraceSerialNumber = 1,
-        superClassId = 0,
+        superclassId = 0,
         classLoaderId = 0,
         signersId = 0,
         protectionDomainId = 0,
         instanceSize = 0,
         staticFields = listOf(
             StaticFieldRecord(
-                contentFieldName.id, HprofReader.OBJECT_TYPE,
-                ObjectReference(baguetteInstanceDump.id)
+                contentFieldName.id, PrimitiveType.REFERENCE_HPROF_TYPE,
+                ReferenceHolder(baguetteInstanceDump.id)
             )
         ),
         fields = emptyList()
@@ -105,7 +110,7 @@ class HprofWriterTest {
   }
 
   private fun File.writeRecords(
-    records: List<Record>
+    records: List<HprofRecord>
   ) {
     HprofWriter.open(this)
         .use { writer ->
@@ -115,11 +120,11 @@ class HprofWriterTest {
         }
   }
 
-  fun File.readHprof(block: (HprofGraph) -> Unit) {
-    val (graph, closeable) = HprofGraph.readHprof(this)
-    closeable.use {
-      block(graph)
-    }
+  fun File.readHprof(block: (HeapGraph) -> Unit) {
+    Hprof.open(this)
+        .use { hprof ->
+          block(HprofHeapGraph.indexHprof(hprof))
+        }
   }
 
   companion object {
diff --git a/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt b/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt
new file mode 100644
index 00000000..61d203a9
--- /dev/null
+++ b/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt
@@ -0,0 +1,41 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import kotlin.reflect.KClass
+
+class JvmHprofParsingTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @Test fun dumpHeapAndReadString() {
+    val hprofFolder = testFolder.newFolder()
+    val hprofFile = File(hprofFolder, "jvm_heap.hprof")
+
+    JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
+
+    Hprof.open(hprofFile)
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof)
+          val testInstances = graph.instances
+              .filter { it.instanceClassName == JvmHprofParsingTest::class.name }
+              .toList()
+
+          assertThat(testInstances).hasSize(1)
+          val test = testInstances[0]
+          val folderPath = test[JvmHprofParsingTest::class.name, "testFolder"]!!
+              .valueAsInstance!![TemporaryFolder::class.name, "folder"]!!
+              .valueAsInstance!![File::class.name, "path"]!!
+              .value.readAsJavaString()!!
+
+          assertThat(folderPath).isEqualTo(testFolder.root.path)
+        }
+  }
+}
+
+private val KClass<out Any>.name: String
+  get() = this.java.name
\ No newline at end of file
diff --git a/shark-graph/src/test/java/shark/ProguardMappingTest.kt b/shark-graph/src/test/java/shark/ProguardMappingTest.kt
new file mode 100644
index 00000000..c664b67f
--- /dev/null
+++ b/shark-graph/src/test/java/shark/ProguardMappingTest.kt
@@ -0,0 +1,44 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class ProguardMappingTest {
+
+  @Test
+  fun readAndParseMappingFile() {
+    val proguardMappingText = """
+            # comment
+            com.test.ClearClassName1 -> com.test.ObfuscatedClassName1:
+                com.test.FieldType1 clearFieldName1 -> obfuscatedFieldName1
+            com.test.ClearClassName2 -> com.test.ObfuscatedClassName2:
+                com.test.FieldType2 clearFieldName2 -> obfuscatedFieldName2
+        """.trimIndent()
+
+    val proguardMapping =
+        ProguardMappingReader(proguardMappingText.byteInputStream(Charsets.UTF_8))
+            .readProguardMapping()
+
+    assertThat(
+        proguardMapping.deobfuscateClassName("com.test.ObfuscatedClassName1")
+    ).isEqualTo("com.test.ClearClassName1")
+
+    assertThat(
+        proguardMapping.deobfuscateFieldName(
+            "com.test.ObfuscatedClassName1",
+            "obfuscatedFieldName1"
+        )
+    ).isEqualTo("clearFieldName1")
+
+    assertThat(
+        proguardMapping.deobfuscateClassName("com.test.ObfuscatedClassName2")
+    ).isEqualTo("com.test.ClearClassName2")
+
+    assertThat(
+        proguardMapping.deobfuscateFieldName(
+            "com.test.ObfuscatedClassName2",
+            "obfuscatedFieldName2"
+        )
+    ).isEqualTo("clearFieldName2")
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/test/java/shark/SortedBytesMapTest.kt b/shark-graph/src/test/java/shark/SortedBytesMapTest.kt
new file mode 100644
index 00000000..a089564a
--- /dev/null
+++ b/shark-graph/src/test/java/shark/SortedBytesMapTest.kt
@@ -0,0 +1,204 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.internal.UnsortedByteEntries
+import java.util.Arrays
+import kotlin.random.Random
+
+class SortedBytesMapTest {
+
+  @Test fun writeAndReadLongValue() {
+    val unsortedEntries = UnsortedByteEntries(bytesPerValue = 8, longIdentifiers = false)
+    unsortedEntries.append(1)
+        .apply {
+          writeLong(Long.MIN_VALUE)
+        }
+
+    val array = unsortedEntries.moveToSortedMap()[1]!!
+    assertThat(array.readLong()).isEqualTo(Long.MIN_VALUE)
+  }
+
+  @Test fun writeAndReadTruncatedLongValue() {
+    val maxUnsigned3Bytes = 0x00000FFFL
+    val unsortedMap = UnsortedByteEntries(bytesPerValue = 3, longIdentifiers = false)
+    unsortedMap.append(1)
+        .apply {
+          writeTruncatedLong(maxUnsigned3Bytes, 3)
+        }
+
+    val array = unsortedMap.moveToSortedMap()[1]!!
+    assertThat(array.readTruncatedLong(3)).isEqualTo(maxUnsigned3Bytes)
+  }
+
+  @Test fun fourEntriesWithLongKey1ByteValueSorted() {
+    val unsortedEntries = UnsortedByteEntries(bytesPerValue = 1, longIdentifiers = true)
+    unsortedEntries.append(42)
+        .apply {
+          writeByte(4)
+        }
+    unsortedEntries.append(0)
+        .apply {
+          writeByte(3)
+        }
+    unsortedEntries.append(3)
+        .apply {
+          writeByte(20)
+        }
+    unsortedEntries.append(Long.MAX_VALUE)
+        .apply {
+          writeByte(127)
+        }
+    val sortedEntries = unsortedEntries.moveToSortedMap()
+        .entrySequence()
+        .toList()
+
+    assertThat(sortedEntries.map { it.first }).containsExactly(0, 3, 42, Long.MAX_VALUE)
+    assertThat(
+        sortedEntries.map {
+          byteArrayOf(
+              it.second.readByte()
+          )
+        }).containsExactly(
+        byteArrayOf(3), byteArrayOf(20), byteArrayOf(4),
+        byteArrayOf(127)
+    )
+  }
+
+  @Test fun fourEntriesWithLongKey3ByteValueSorted() {
+    val unsortedMap = UnsortedByteEntries(bytesPerValue = 3, longIdentifiers = true)
+    unsortedMap.append(42)
+        .apply {
+          writeByte(4)
+          writeByte(2)
+          writeByte(0)
+        }
+    unsortedMap.append(0)
+        .apply {
+          writeByte(3)
+          writeByte(2)
+          writeByte(1)
+        }
+    unsortedMap.append(3)
+        .apply {
+          writeByte(20)
+          writeByte(52)
+          writeByte(-17)
+        }
+    unsortedMap.append(Long.MAX_VALUE)
+        .apply {
+          writeByte(127)
+          writeByte(0)
+          writeByte(-128)
+        }
+    val sortedEntries = unsortedMap.moveToSortedMap()
+        .entrySequence()
+        .toList()
+
+    assertThat(sortedEntries.map { it.first }).containsExactly(0, 3, 42, Long.MAX_VALUE)
+    assertThat(
+        sortedEntries.map {
+          byteArrayOf(
+              it.second.readByte(), it.second.readByte(), it.second.readByte()
+          )
+        }).containsExactly(
+        byteArrayOf(3, 2, 1), byteArrayOf(20, 52, -17), byteArrayOf(4, 2, 0),
+        byteArrayOf(127, 0, -128)
+    )
+  }
+
+  class Entry(
+    val key: Long,
+    val value: ByteArray
+  ) : Comparable<Entry> {
+    override fun compareTo(other: Entry): Int = key.compareTo(other.key)
+    override fun equals(other: Any?): Boolean {
+      if (this === other) return true
+      if (javaClass != other?.javaClass) return false
+
+      other as Entry
+
+      if (key != other.key) return false
+      if (!value.contentEquals(other.value)) return false
+
+      return true
+    }
+
+    override fun toString(): String {
+      return "Entry(key=$key, value=${Arrays.toString(value)})"
+    }
+
+  }
+
+  @Test fun largeRandomArrayIntKey3ByteValueSorted() {
+    val random = Random(Long.MAX_VALUE)
+
+    val bytesPerValue = 3
+    val longIdentifiers = false
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextInt().toLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  @Test fun largeRandomArrayLongKey3ByteValueSorted() {
+    val random = Random(42)
+
+    val bytesPerValue = 3
+    val longIdentifiers = true
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  @Test fun largeRandomArrayLongKey7ByteValueSorted() {
+    val random = Random(Long.MIN_VALUE)
+
+    val bytesPerValue = 7
+    val longIdentifiers = true
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  private fun sortAndCompare(
+    bytesPerValue: Int,
+    longIdentifiers: Boolean,
+    sourceEntryArray: Array<Entry>
+  ) {
+    val unsortedEntries =
+      UnsortedByteEntries(bytesPerValue = bytesPerValue, longIdentifiers = longIdentifiers)
+
+    sourceEntryArray.forEach { entry ->
+      val subArray = unsortedEntries.append(entry.key)
+      entry.value.forEach { subArray.writeByte(it) }
+    }
+
+    val sortedMap = unsortedEntries.moveToSortedMap()
+    sourceEntryArray.sort()
+
+    val sortedEntryArray = sortedMap.entrySequence()
+        .map {
+          val key = it.first
+          val value = it.second
+
+          val bytes = mutableListOf<Byte>()
+          for (i in 0 until bytesPerValue) {
+            bytes += value.readByte()
+          }
+          Entry(key, bytes.toByteArray())
+        }
+        .toList()
+        .toTypedArray()
+
+    assertThat(sortedEntryArray).isEqualTo(sourceEntryArray)
+  }
+}
diff --git a/shark-hprof/build.gradle b/shark-hprof/build.gradle
new file mode 100644
index 00000000..64a64587
--- /dev/null
+++ b/shark-hprof/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':shark-log')
+
+  implementation deps.kotlin.stdlib
+  implementation deps.okio
+
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
+  testImplementation project(':shark-test')
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-hprof/gradle.properties b/shark-hprof/gradle.properties
new file mode 100644
index 00000000..585cfc8d
--- /dev/null
+++ b/shark-hprof/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-hprof
+POM_NAME=Shark Hprof
+POM_PACKAGING=jar
diff --git a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt b/shark-hprof/src/main/java/shark/GcRoot.kt
similarity index 69%
rename from leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
rename to shark-hprof/src/main/java/shark/GcRoot.kt
index fa7b3b9f..4745c2cd 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
+++ b/shark-hprof/src/main/java/shark/GcRoot.kt
@@ -1,9 +1,18 @@
-package leakcanary
+package shark
 
+/**
+ * A GcRoot as identified by [HprofRecord.HeapDumpRecord.GcRootRecord] in the heap dump.
+ */
 sealed class GcRoot {
 
+  /**
+   * The object id of the object that this gc root references.
+   */
   abstract val id: Long
 
+  /**
+   * An unknown gc root.
+   */
   class Unknown(override val id: Long) : GcRoot()
 
   /**
@@ -19,6 +28,7 @@ sealed class GcRoot {
    */
   class JniLocal(
     override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
     val threadSerialNumber: Int,
     /**
      * frame number in stack trace (-1 for empty)
@@ -27,10 +37,11 @@ sealed class GcRoot {
   ) : GcRoot()
 
   /**
-   * Java local variable
+   * A java local variable
    */
   class JavaFrame(
     override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
     val threadSerialNumber: Int,
     /**
      * frame number in stack trace (-1 for empty)
@@ -44,19 +55,21 @@ sealed class GcRoot {
   class NativeStack(
     override val id: Long,
     /**
-     * Thread is sometimes not found, see:
+     * Corresponds to [ThreadObject.threadSerialNumber]
+     * Note: the corresponding thread is sometimes not found, see:
      * https://issuetracker.google.com/issues/122713143
      */
     val threadSerialNumber: Int
   ) : GcRoot()
 
   /**
-   * System class
+   * A system class
    */
   class StickyClass(override val id: Long) : GcRoot()
 
   class ThreadBlock(
     override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
     val threadSerialNumber: Int
   ) : GcRoot()
 
@@ -67,6 +80,8 @@ sealed class GcRoot {
   class MonitorUsed(override val id: Long) : GcRoot()
 
   /**
+   * A thread.
+   *
    * Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
    */
   class ThreadObject(
@@ -75,16 +90,28 @@ sealed class GcRoot {
     val stackTraceSerialNumber: Int
   ) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class ReferenceCleanup(override val id: Long) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class VmInternal(override val id: Long) : GcRoot()
 
+  /**
+   * It's unclear what this is, documentation welcome.
+   */
   class JniMonitor(
     override val id: Long,
     val stackTraceSerialNumber: Int,
     val stackDepth: Int
   ) : GcRoot()
 
+  /**
+   * An interned string, see [java.lang.String.intern].
+   */
   class InternedString(override val id: Long) : GcRoot()
 
   /**
@@ -92,6 +119,9 @@ sealed class GcRoot {
    */
   class Finalizing(override val id: Long) : GcRoot()
 
+  /**
+   * An object held by a connected debugger
+   */
   class Debugger(override val id: Long) : GcRoot()
 
   /**
diff --git a/shark-hprof/src/main/java/shark/Hprof.kt b/shark-hprof/src/main/java/shark/Hprof.kt
new file mode 100644
index 00000000..ecfc7952
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/Hprof.kt
@@ -0,0 +1,102 @@
+package shark
+
+import okio.BufferedSource
+import okio.buffer
+import okio.source
+import shark.Hprof.Companion.open
+import java.io.Closeable
+import java.io.File
+import java.nio.channels.FileChannel
+
+/**
+ * An opened Hprof file which can be read via [reader]. Open a new hprof with [open], and don't
+ * forget to call [close] once done.
+ */
+class Hprof private constructor(
+  private val channel: FileChannel,
+  private val source: BufferedSource,
+  val reader: HprofReader,
+  /** Unix timestamp at which the heap was dumped. */
+  val heapDumpTimestamp: Long,
+  /** Version of the opened hprof, which is tied to the runtime where the heap was dumped. */
+  val hprofVersion: HprofVersion,
+  /**
+   * Length of the hprof file, in bytes.
+   */
+  val fileLength: Long
+) : Closeable {
+
+  override fun close() {
+    source.close()
+  }
+
+  /**
+   * Moves [reader] to a new position in the hprof file. This is transparent to the reader, and
+   * will not reset [HprofReader.position].
+   */
+  fun moveReaderTo(newPosition: Long) {
+    val currentPosition = reader.position
+
+    if (currentPosition == newPosition) {
+      return
+    }
+    source.buffer.clear()
+    channel.position(newPosition)
+    reader.position = newPosition
+  }
+
+  /**
+   * Supported hprof versions
+   */
+  enum class HprofVersion(val versionString: String) {
+    JDK1_2_BETA3("JAVA PROFILE 1.0"),
+    JDK1_2_BETA4("JAVA PROFILE 1.0.1"),
+    JDK_6("JAVA PROFILE 1.0.2"),
+    ANDROID("JAVA PROFILE 1.0.3")
+  }
+
+  companion object {
+    private val supportedVersions = HprofVersion.values()
+        .map { it.versionString to it }
+        .toMap()
+
+    /**
+     * Reads the headers of the provided [hprofFile] and returns an opened [Hprof]. Don't forget
+     * to call [close] once done.
+     */
+    fun open(hprofFile: File): Hprof {
+      val fileLength = hprofFile.length()
+      if (fileLength == 0L) {
+        throw IllegalArgumentException("Hprof file is 0 byte length")
+      }
+      val inputStream = hprofFile.inputStream()
+      val channel = inputStream.channel
+      val source = inputStream.source()
+          .buffer()
+
+      val endOfVersionString = source.indexOf(0)
+      val versionName = source.readUtf8(endOfVersionString)
+
+      val hprofVersion = supportedVersions[versionName]
+
+      require(hprofVersion != null) {
+        "Unsupported Hprof version [$versionName] not in supported list ${supportedVersions.keys}"
+      }
+      // Skip the 0 at the end of the version string.
+      source.skip(1)
+      val identifierByteSize = source.readInt()
+
+      // heap dump timestamp
+      val heapDumpTimestamp = source.readLong()
+
+      val byteReadCount = endOfVersionString + 1 + 4 + 8
+
+      val reader = HprofReader(source, identifierByteSize, byteReadCount)
+
+      return Hprof(
+          channel, source, reader, heapDumpTimestamp, hprofVersion, fileLength
+      )
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
new file mode 100644
index 00000000..b603e06a
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
@@ -0,0 +1,100 @@
+package shark
+
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import java.io.File
+
+/**
+ * Converts a Hprof file to another file with all primitive arrays replaced with arrays of zeroes,
+ * which can be useful to remove PII. Char arrays are handled slightly differently because 0 would
+ * be the null character so instead these become arrays of '?'.
+ */
+class HprofPrimitiveArrayStripper {
+
+  /**
+   * @see HprofPrimitiveArrayStripper
+   */
+  fun stripPrimitiveArrays(
+    inputHprofFile: File,
+    /**
+     * Optional output file. Defaults to a file in the same directory as [inputHprofFile], with
+     * the same name and "-stripped" prepended before the ".hprof" extension. If the file extension
+     * is not ".hprof", then "-stripped" is added at the end of the file.
+     */
+    outputHprofFile: File = File(
+        inputHprofFile.parent, inputHprofFile.name.replace(
+        ".hprof", "-stripped.hprof"
+    ).let { if (it != inputHprofFile.name) it else inputHprofFile.name + "-stripped" })
+  ): File {
+    Hprof.open(inputHprofFile)
+        .use { hprof ->
+          val reader = hprof.reader
+          HprofWriter.open(
+              outputHprofFile,
+              identifierByteSize = reader.identifierByteSize,
+              hprofVersion = hprof.hprofVersion
+          )
+              .use { writer ->
+                reader.readHprofRecords(setOf(HprofRecord::class),
+                    OnHprofRecordListener { _,
+                      record ->
+                      // HprofWriter automatically emits HeapDumpEndRecord, because it flushes
+                      // all continuous heap dump sub records as one heap dump record.
+                      if (record is HeapDumpEndRecord) {
+                        return@OnHprofRecordListener
+                      }
+                      writer.write(
+                          when (record) {
+                            is BooleanArrayDump -> BooleanArrayDump(
+                                record.id, record.stackTraceSerialNumber,
+                                BooleanArray(record.array.size)
+                            )
+                            is CharArrayDump -> CharArrayDump(
+                                record.id, record.stackTraceSerialNumber,
+                                CharArray(record.array.size) {
+                                  '?'
+                                }
+                            )
+                            is FloatArrayDump -> FloatArrayDump(
+                                record.id, record.stackTraceSerialNumber,
+                                FloatArray(record.array.size)
+                            )
+                            is DoubleArrayDump -> DoubleArrayDump(
+                                record.id, record.stackTraceSerialNumber,
+                                DoubleArray(record.array.size)
+                            )
+                            is ByteArrayDump -> ByteArrayDump(
+                                record.id, record.stackTraceSerialNumber,
+                                ByteArray(record.array.size)
+                            )
+                            is ShortArrayDump -> ShortArrayDump(
+                                record.id, record.stackTraceSerialNumber,
+                                ShortArray(record.array.size)
+                            )
+                            is IntArrayDump -> IntArrayDump(
+                                record.id, record.stackTraceSerialNumber,
+                                IntArray(record.array.size)
+                            )
+                            is LongArrayDump -> LongArrayDump(
+                                record.id, record.stackTraceSerialNumber,
+                                LongArray(record.array.size)
+                            )
+                            else -> {
+                              record
+                            }
+                          }
+                      )
+                    })
+              }
+        }
+    return outputHprofFile
+  }
+
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/HprofReader.kt b/shark-hprof/src/main/java/shark/HprofReader.kt
new file mode 100644
index 00000000..685e98c1
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofReader.kt
@@ -0,0 +1,1035 @@
+package shark
+
+import okio.BufferedSource
+import shark.GcRoot.Debugger
+import shark.GcRoot.Finalizing
+import shark.GcRoot.InternedString
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.GcRoot.Unknown
+import shark.GcRoot.Unreachable
+import shark.GcRoot.VmInternal
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackFrameRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.nio.charset.Charset
+import kotlin.reflect.KClass
+
+/**
+ * Reads hprof content from an Okio [BufferedSource].
+ *
+ * Not thread safe, should be used from a single thread.
+ *
+ * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
+ *
+ * The Android Hprof format differs in some ways from that reference. This parser implementation
+ * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
+ */
+@Suppress("LargeClass", "TooManyFunctions")
+class HprofReader constructor(
+  private var source: BufferedSource,
+  /**
+   * Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects,
+   * stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are not
+   * required to be.
+   */
+  val identifierByteSize: Int,
+  /**
+   * How many bytes have already been read from [source] when this [HprofReader] is created.
+   */
+  val startPosition: Long = 0L
+) {
+
+  /**
+   * Starts at [startPosition] and increases as [HprofReader] reads bytes. This is useful
+   * for tracking the position of content in the backing [source]. This never resets.
+   */
+  var position = startPosition
+    internal set
+
+  private val typeSizes =
+    PrimitiveType.byteSizeByHprofType + (PrimitiveType.REFERENCE_HPROF_TYPE to identifierByteSize)
+
+  /**
+   * Reads all hprof records from [source].
+   * Assumes the [reader] was has a source that currently points to the start position of hprof
+   * records.
+   */
+  @Suppress("ComplexMethod", "LongMethod")
+  fun readHprofRecords(
+    recordTypes: Set<KClass<out HprofRecord>>,
+    listener: OnHprofRecordListener
+  ) {
+    val readAllRecords = HprofRecord::class in recordTypes
+    val readStringRecord = readAllRecords || StringRecord::class in recordTypes
+    val readLoadClassRecord = readAllRecords || LoadClassRecord::class in recordTypes
+    val readHeapDumpEndRecord = readAllRecords || HeapDumpEndRecord::class in recordTypes
+    val readStackFrameRecord = readAllRecords || StackFrameRecord::class in recordTypes
+    val readStackTraceRecord = readAllRecords || StackTraceRecord::class in recordTypes
+
+    val readAllHeapDumpRecords = readAllRecords || HeapDumpRecord::class in recordTypes
+
+    val readGcRootRecord = readAllHeapDumpRecords || GcRootRecord::class in recordTypes
+    val readHeapDumpInfoRecord = readAllRecords || HeapDumpInfoRecord::class in recordTypes
+
+    val readAllObjectRecords = readAllHeapDumpRecords || ObjectRecord::class in recordTypes
+
+    val readClassDumpRecord = readAllObjectRecords || ClassDumpRecord::class in recordTypes
+    val readClassSkipContentRecord = ClassSkipContentRecord::class in recordTypes
+    val readInstanceDumpRecord = readAllObjectRecords || InstanceDumpRecord::class in recordTypes
+    val readInstanceSkipContentRecord = InstanceSkipContentRecord::class in recordTypes
+    val readObjectArrayDumpRecord =
+      readAllObjectRecords || ObjectArrayDumpRecord::class in recordTypes
+    val readObjectArraySkipContentRecord = ObjectArraySkipContentRecord::class in recordTypes
+    val readPrimitiveArrayDumpRecord =
+      readAllObjectRecords || PrimitiveArrayDumpRecord::class in recordTypes
+    val readPrimitiveArraySkipContentRecord = PrimitiveArraySkipContentRecord::class in recordTypes
+
+    val intByteSize = INT.byteSize
+
+    while (!exhausted()) {
+      // type of the record
+      val tag = readUnsignedByte()
+
+      // number of microseconds since the time stamp in the header
+      skip(intByteSize)
+
+      // number of bytes that follow and belong to this record
+      val length = readUnsignedInt()
+
+      when (tag) {
+        STRING_IN_UTF8 -> {
+          if (readStringRecord) {
+            val recordPosition = position
+            val id = readId()
+            val stringLength = length - identifierByteSize
+            val string = readUtf8(stringLength)
+            val record = StringRecord(id, string)
+            listener.onHprofRecord(recordPosition, record)
+          } else {
+            skip(length)
+          }
+        }
+        LOAD_CLASS -> {
+          if (readLoadClassRecord) {
+            val recordPosition = position
+            val classSerialNumber = readInt()
+            val id = readId()
+            val stackTraceSerialNumber = readInt()
+            val classNameStringId = readId()
+            val record = LoadClassRecord(
+                classSerialNumber = classSerialNumber,
+                id = id,
+                stackTraceSerialNumber = stackTraceSerialNumber,
+                classNameStringId = classNameStringId
+            )
+            listener.onHprofRecord(recordPosition, record)
+          } else {
+            skip(length)
+          }
+        }
+        STACK_FRAME -> {
+          if (readStackFrameRecord) {
+            val recordPosition = position
+            val record = StackFrameRecord(
+                id = readId(),
+                methodNameStringId = readId(),
+                methodSignatureStringId = readId(),
+                sourceFileNameStringId = readId(),
+                classSerialNumber = readInt(),
+                lineNumber = readInt()
+            )
+            listener.onHprofRecord(recordPosition, record)
+          } else {
+            skip(length)
+          }
+        }
+        STACK_TRACE -> {
+          if (readStackTraceRecord) {
+            val recordPosition = position
+            val stackTraceSerialNumber = readInt()
+            val threadSerialNumber = readInt()
+            val frameCount = readInt()
+            val stackFrameIds = readIdArray(frameCount)
+            val record = StackTraceRecord(
+                stackTraceSerialNumber = stackTraceSerialNumber,
+                threadSerialNumber = threadSerialNumber,
+                stackFrameIds = stackFrameIds
+            )
+            listener.onHprofRecord(recordPosition, record)
+          } else {
+            skip(length)
+          }
+        }
+        HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
+          val heapDumpStart = position
+          var previousTag = 0
+          var previousTagPosition = 0L
+          while (position - heapDumpStart < length) {
+            val heapDumpTagPosition = position
+            val heapDumpTag = readUnsignedByte()
+
+            when (heapDumpTag) {
+              ROOT_UNKNOWN -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val record = GcRootRecord(gcRoot = Unknown(id = readId()))
+                  listener.onHprofRecord(recordPosition, record)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+              ROOT_JNI_GLOBAL -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord =
+                    GcRootRecord(gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId()))
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + identifierByteSize)
+                }
+              }
+
+              ROOT_JNI_LOCAL -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JniLocal(
+                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                      )
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize + intByteSize)
+                }
+              }
+
+              ROOT_JAVA_FRAME -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JavaFrame(
+                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                      )
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize + intByteSize)
+                }
+              }
+
+              ROOT_NATIVE_STACK -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize)
+                }
+              }
+
+              ROOT_STICKY_CLASS -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = StickyClass(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              // An object that was referenced from an active thread block.
+              ROOT_THREAD_BLOCK -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize)
+                }
+              }
+
+              ROOT_MONITOR_USED -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = MonitorUsed(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_THREAD_OBJECT -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ThreadObject(
+                          id = readId(),
+                          threadSerialNumber = readInt(),
+                          stackTraceSerialNumber = readInt()
+                      )
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize + intByteSize)
+                }
+              }
+
+              ROOT_INTERNED_STRING -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(gcRoot = InternedString(id = readId()))
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_FINALIZING -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Finalizing(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_DEBUGGER -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Debugger(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_REFERENCE_CLEANUP -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ReferenceCleanup(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_VM_INTERNAL -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = VmInternal(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_JNI_MONITOR -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JniMonitor(
+                          id = readId(), stackTraceSerialNumber = readInt(),
+                          stackDepth = readInt()
+                      )
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize + intByteSize)
+                }
+              }
+
+              ROOT_UNREACHABLE -> {
+                if (readGcRootRecord) {
+                  val recordPosition = position
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Unreachable(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+              CLASS_DUMP -> {
+                when {
+                  readClassDumpRecord -> {
+                    val recordPosition = position
+                    val record = readClassDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readClassSkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readClassSkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipClassDumpRecord()
+                }
+              }
+              INSTANCE_DUMP -> {
+                when {
+                  readInstanceDumpRecord -> {
+                    val recordPosition = position
+                    val record = readInstanceDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readInstanceSkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readInstanceSkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipInstanceDumpRecord()
+                }
+              }
+
+              OBJECT_ARRAY_DUMP -> {
+                when {
+                  readObjectArrayDumpRecord -> {
+                    val recordPosition = position
+                    val arrayRecord = readObjectArrayDumpRecord()
+                    listener.onHprofRecord(recordPosition, arrayRecord)
+                  }
+                  readObjectArraySkipContentRecord -> {
+                    val recordPosition = position
+                    val arrayRecord = readObjectArraySkipContentRecord()
+                    listener.onHprofRecord(recordPosition, arrayRecord)
+                  }
+                  else -> skipObjectArrayDumpRecord()
+                }
+              }
+
+              PRIMITIVE_ARRAY_DUMP -> {
+                when {
+                  readPrimitiveArrayDumpRecord -> {
+                    val recordPosition = position
+                    val record = readPrimitiveArrayDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readPrimitiveArraySkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readPrimitiveArraySkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipPrimitiveArrayDumpRecord()
+                }
+              }
+
+              PRIMITIVE_ARRAY_NODATA -> {
+                throw UnsupportedOperationException("PRIMITIVE_ARRAY_NODATA cannot be parsed")
+              }
+
+              HEAP_DUMP_INFO -> {
+                if (readHeapDumpInfoRecord) {
+                  val recordPosition = position
+                  val record = readHeapDumpInfoRecord()
+                  listener.onHprofRecord(recordPosition, record)
+                } else {
+                  skipHeapDumpInfoRecord()
+                }
+              }
+              else -> throw IllegalStateException(
+                  "Unknown tag ${"0x%02x".format(heapDumpTag)} at $heapDumpTagPosition after ${"0x%02x".format(previousTag)} at $previousTagPosition"
+              )
+            }
+            previousTag = heapDumpTag
+            previousTagPosition = heapDumpTagPosition
+          }
+        }
+        HEAP_DUMP_END -> {
+          if (readHeapDumpEndRecord) {
+            val recordPosition = position
+            val record = HeapDumpEndRecord
+            listener.onHprofRecord(recordPosition, record)
+          }
+        }
+        else -> {
+          skip(length)
+        }
+      }
+    }
+  }
+
+  /**
+   * Reads a full instance record after a instance dump tag.
+   */
+  fun readInstanceDumpRecord(): InstanceDumpRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    val classId = readId()
+    val remainingBytesInInstance = readInt()
+    val fieldValues = readByteArray(remainingBytesInInstance)
+    return InstanceDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        classId = classId,
+        fieldValues = fieldValues
+    )
+  }
+
+  /**
+   * Reads an instance record after a instance dump tag, skipping its content.
+   */
+  fun readInstanceSkipContentRecord(): InstanceSkipContentRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    val classId = readId()
+    val remainingBytesInInstance = readInt()
+    skip(remainingBytesInInstance)
+    return InstanceSkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        classId = classId
+    )
+  }
+
+  /**
+   * Reads a full class record after a class dump tag.
+   */
+  fun readClassDumpRecord(): ClassDumpRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val superclassId = readId()
+    // class loader object ID
+    val classLoaderId = readId()
+    // signers object ID
+    val signersId = readId()
+    // protection domain object ID
+    val protectionDomainId = readId()
+    // reserved
+    readId()
+    // reserved
+    readId()
+
+    // instance size (in bytes)
+    // Useful to compute retained size
+    val instanceSize = readInt()
+
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+    val staticFields = ArrayList<StaticFieldRecord>(staticFieldCount)
+    for (i in 0 until staticFieldCount) {
+
+      val nameStringId = readId()
+      val type = readUnsignedByte()
+      val value = readValue(type)
+
+      staticFields.add(
+          StaticFieldRecord(
+              nameStringId = nameStringId,
+              type = type,
+              value = value
+          )
+      )
+    }
+
+    val fieldCount = readUnsignedShort()
+    val fields = ArrayList<FieldRecord>(fieldCount)
+    for (i in 0 until fieldCount) {
+      fields.add(FieldRecord(nameStringId = readId(), type = readUnsignedByte()))
+    }
+
+    return ClassDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        superclassId = superclassId,
+        classLoaderId = classLoaderId,
+        signersId = signersId,
+        protectionDomainId = protectionDomainId,
+        instanceSize = instanceSize,
+        staticFields = staticFields,
+        fields = fields
+    )
+  }
+
+  /**
+   * Reads a class record after a class dump tag, skipping its content.
+   */
+  fun readClassSkipContentRecord(): ClassSkipContentRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val superclassId = readId()
+    // class loader object ID
+    val classLoaderId = readId()
+    // signers object ID
+    val signersId = readId()
+    // protection domain object ID
+    val protectionDomainId = readId()
+    // reserved
+    readId()
+    // reserved
+    readId()
+
+    // instance size (in bytes)
+    // Useful to compute retained size
+    val instanceSize = readInt()
+
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+    for (i in 0 until staticFieldCount) {
+      skip(identifierByteSize)
+      val type = readUnsignedByte()
+      skip(
+          if (type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+            identifierByteSize
+          } else {
+            PrimitiveType.byteSizeByHprofType.getValue(type)
+          }
+      )
+    }
+
+    val fieldCount = readUnsignedShort()
+    // Each field takes id + byte.
+    skip((identifierByteSize + 1) * fieldCount)
+    return ClassSkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        superclassId = superclassId,
+        classLoaderId = classLoaderId,
+        signersId = signersId,
+        protectionDomainId = protectionDomainId,
+        instanceSize = instanceSize,
+        staticFieldCount = staticFieldCount,
+        fieldCount = fieldCount
+    )
+  }
+
+  /**
+   * Reads a full primitive array record after a primitive array dump tag.
+   */
+  fun readPrimitiveArrayDumpRecord(): PrimitiveArrayDumpRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    // length
+    val arrayLength = readInt()
+    return when (val type = readUnsignedByte()) {
+      BOOLEAN_TYPE -> BooleanArrayDump(
+          id, stackTraceSerialNumber, readBooleanArray(arrayLength)
+      )
+      CHAR_TYPE -> CharArrayDump(
+          id, stackTraceSerialNumber, readCharArray(arrayLength)
+      )
+      FLOAT_TYPE -> FloatArrayDump(
+          id, stackTraceSerialNumber, readFloatArray(arrayLength)
+      )
+      DOUBLE_TYPE -> DoubleArrayDump(
+          id, stackTraceSerialNumber, readDoubleArray(arrayLength)
+      )
+      BYTE_TYPE -> ByteArrayDump(
+          id, stackTraceSerialNumber, readByteArray(arrayLength)
+      )
+      SHORT_TYPE -> ShortArrayDump(
+          id, stackTraceSerialNumber, readShortArray(arrayLength)
+      )
+      INT_TYPE -> IntArrayDump(
+          id, stackTraceSerialNumber, readIntArray(arrayLength)
+      )
+      LONG_TYPE -> LongArrayDump(
+          id, stackTraceSerialNumber, readLongArray(arrayLength)
+      )
+      else -> throw IllegalStateException("Unexpected type $type")
+    }
+  }
+
+  /**
+   * Reads a primitive array record after a primitive array dump tag, skipping its content.
+   */
+  fun readPrimitiveArraySkipContentRecord(): PrimitiveArraySkipContentRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    // length
+    val arrayLength = readInt()
+    val type = PrimitiveType.primitiveTypeByHprofType.getValue(readUnsignedByte())
+    skip(arrayLength * type.byteSize)
+    return PrimitiveArraySkipContentRecord(id, stackTraceSerialNumber, arrayLength, type)
+  }
+
+  /**
+   * Reads a full object array record after a object array dump tag.
+   */
+  fun readObjectArrayDumpRecord(
+  ): ObjectArrayDumpRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val arrayLength = readInt()
+    val arrayClassId = readId()
+    val elementIds = readIdArray(arrayLength)
+    return ObjectArrayDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        arrayClassId = arrayClassId,
+        elementIds = elementIds
+    )
+  }
+
+  /**
+   * Reads an object array record after a object array dump tag, skipping its content.
+   */
+  fun readObjectArraySkipContentRecord(
+  ): ObjectArraySkipContentRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val arrayLength = readInt()
+    val arrayClassId = readId()
+    skip(identifierByteSize * arrayLength)
+    return ObjectArraySkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        arrayClassId = arrayClassId,
+        size = arrayLength
+    )
+  }
+
+  /**
+   * Reads a value in the heap dump, which can be a reference or a primitive type.
+   */
+  fun readValue(type: Int): ValueHolder {
+    return when (type) {
+      PrimitiveType.REFERENCE_HPROF_TYPE -> ReferenceHolder(readId())
+      BOOLEAN_TYPE -> BooleanHolder(readBoolean())
+      CHAR_TYPE -> CharHolder(readChar())
+      FLOAT_TYPE -> FloatHolder(readFloat())
+      DOUBLE_TYPE -> DoubleHolder(readDouble())
+      BYTE_TYPE -> ByteHolder(readByte())
+      SHORT_TYPE -> ShortHolder(readShort())
+      INT_TYPE -> IntHolder(readInt())
+      LONG_TYPE -> LongHolder(readLong())
+      else -> throw IllegalStateException("Unknown type $type")
+    }
+  }
+
+  private fun typeSize(type: Int): Int {
+    return typeSizes.getValue(type)
+  }
+
+  private fun readShort(): Short {
+    position += SHORT_SIZE
+    return source.readShort()
+  }
+
+  private fun readInt(): Int {
+    position += INT_SIZE
+    return source.readInt()
+  }
+
+  private fun readIdArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readId() }
+  }
+
+  private fun readBooleanArray(arrayLength: Int): BooleanArray {
+    return BooleanArray(arrayLength) { readByte().toInt() != 0 }
+  }
+
+  private fun readCharArray(arrayLength: Int): CharArray {
+    return readString(CHAR_SIZE * arrayLength, Charsets.UTF_16BE).toCharArray()
+  }
+
+  private fun readString(
+    byteCount: Int,
+    charset: Charset
+  ): String {
+    position += byteCount
+    return source.readString(byteCount.toLong(), charset)
+  }
+
+  private fun readFloatArray(arrayLength: Int): FloatArray {
+    return FloatArray(arrayLength) { readFloat() }
+  }
+
+  private fun readDoubleArray(arrayLength: Int): DoubleArray {
+    return DoubleArray(arrayLength) { readDouble() }
+  }
+
+  private fun readShortArray(arrayLength: Int): ShortArray {
+    return ShortArray(arrayLength) { readShort() }
+  }
+
+  private fun readIntArray(arrayLength: Int): IntArray {
+    return IntArray(arrayLength) { readInt() }
+  }
+
+  private fun readLongArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readLong() }
+  }
+
+  private fun readLong(): Long {
+    position += LONG_SIZE
+    return source.readLong()
+  }
+
+  private fun exhausted() = source.exhausted()
+
+  private fun skip(byteCount: Long) {
+    position += byteCount
+    return source.skip(byteCount)
+  }
+
+  private fun readByte(): Byte {
+    position += BYTE_SIZE
+    return source.readByte()
+  }
+
+  private fun readBoolean(): Boolean {
+    position += BOOLEAN_SIZE
+    return source.readByte().toInt() != 0
+  }
+
+  private fun readByteArray(byteCount: Int): ByteArray {
+    position += byteCount
+    return source.readByteArray(byteCount.toLong())
+  }
+
+  private fun readChar(): Char {
+    return readString(CHAR_SIZE, Charsets.UTF_16BE)[0]
+  }
+
+  private fun readFloat(): Float {
+    return Float.fromBits(readInt())
+  }
+
+  private fun readDouble(): Double {
+    return Double.fromBits(readLong())
+  }
+
+  private fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    return when (identifierByteSize) {
+      1 -> readByte().toLong()
+      2 -> readShort().toLong()
+      4 -> readInt().toLong()
+      8 -> readLong()
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  private fun readUtf8(byteCount: Long): String {
+    position += byteCount
+    return source.readUtf8(byteCount)
+  }
+
+  private fun readUnsignedInt(): Long {
+    return readInt().toLong() and INT_MASK
+  }
+
+  private fun readUnsignedByte(): Int {
+    return readByte().toInt() and BYTE_MASK
+  }
+
+  private fun readUnsignedShort(): Int {
+    return readShort().toInt() and 0xFFFF
+  }
+
+  private fun skip(byteCount: Int) {
+    position += byteCount
+    return source.skip(byteCount.toLong())
+  }
+
+  private fun skipInstanceDumpRecord() {
+    skip(identifierByteSize + INT_SIZE + identifierByteSize)
+    val remainingBytesInInstance = readInt()
+    skip(remainingBytesInInstance)
+  }
+
+  private fun skipClassDumpRecord() {
+    skip(
+        identifierByteSize + INT_SIZE + identifierByteSize + identifierByteSize + identifierByteSize +
+            identifierByteSize + identifierByteSize + identifierByteSize + INT_SIZE
+    )
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+
+    for (i in 0 until staticFieldCount) {
+      skip(identifierByteSize)
+      val type = readUnsignedByte()
+      skip(typeSize(type))
+    }
+
+    val fieldCount = readUnsignedShort()
+    skip(fieldCount * (identifierByteSize + BYTE_SIZE))
+  }
+
+  private fun skipObjectArrayDumpRecord() {
+    skip(identifierByteSize + INT_SIZE)
+    val arrayLength = readInt()
+    skip(identifierByteSize + arrayLength * identifierByteSize)
+  }
+
+  private fun skipPrimitiveArrayDumpRecord() {
+    skip(identifierByteSize + INT_SIZE)
+    val arrayLength = readInt()
+    val type = readUnsignedByte()
+    skip(arrayLength * typeSize(type))
+  }
+
+  private fun readHeapDumpInfoRecord(): HeapDumpInfoRecord {
+    val heapId = readInt()
+    return HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
+  }
+
+  private fun skipHeapDumpInfoRecord() {
+    skip(identifierByteSize + identifierByteSize)
+  }
+
+  companion object {
+    private val BOOLEAN_SIZE = BOOLEAN.byteSize
+    private val CHAR_SIZE = CHAR.byteSize
+    private val FLOAT_SIZE = FLOAT.byteSize
+    private val DOUBLE_SIZE = DOUBLE.byteSize
+    private val BYTE_SIZE = BYTE.byteSize
+    private val SHORT_SIZE = SHORT.byteSize
+    private val INT_SIZE = PrimitiveType.INT.byteSize
+    private val LONG_SIZE = LONG.byteSize
+
+    private val BOOLEAN_TYPE = BOOLEAN.hprofType
+    private val CHAR_TYPE = CHAR.hprofType
+    private val FLOAT_TYPE = FLOAT.hprofType
+    private val DOUBLE_TYPE = DOUBLE.hprofType
+    private val BYTE_TYPE = BYTE.hprofType
+    private val SHORT_TYPE = SHORT.hprofType
+    private val INT_TYPE = PrimitiveType.INT.hprofType
+    private val LONG_TYPE = LONG.hprofType
+
+    private const val INT_MASK = 0xffffffffL
+    private const val BYTE_MASK = 0xff
+
+    internal const val STRING_IN_UTF8 = 0x01
+    internal const val LOAD_CLASS = 0x02
+    internal const val UNLOAD_CLASS = 0x03
+    internal const val STACK_FRAME = 0x04
+    internal const val STACK_TRACE = 0x05
+    internal const val ALLOC_SITES = 0x06
+    internal const val HEAP_SUMMARY = 0x07
+    // TODO Maybe parse this?
+    internal const val START_THREAD = 0x0a
+    internal const val END_THREAD = 0x0b
+    internal const val HEAP_DUMP = 0x0c
+    internal const val HEAP_DUMP_SEGMENT = 0x1c
+    internal const val HEAP_DUMP_END = 0x2c
+    internal const val CPU_SAMPLES = 0x0d
+    internal const val CONTROL_SETTINGS = 0x0e
+    internal const val ROOT_UNKNOWN = 0xff
+    internal const val ROOT_JNI_GLOBAL = 0x01
+    internal const val ROOT_JNI_LOCAL = 0x02
+    internal const val ROOT_JAVA_FRAME = 0x03
+    internal const val ROOT_NATIVE_STACK = 0x04
+    internal const val ROOT_STICKY_CLASS = 0x05
+    internal const val ROOT_THREAD_BLOCK = 0x06
+    internal const val ROOT_MONITOR_USED = 0x07
+    internal const val ROOT_THREAD_OBJECT = 0x08
+    internal const val CLASS_DUMP = 0x20
+    internal const val INSTANCE_DUMP = 0x21
+    internal const val OBJECT_ARRAY_DUMP = 0x22
+    internal const val PRIMITIVE_ARRAY_DUMP = 0x23
+
+    /**
+     * Android format addition
+     *
+     * Specifies information about which heap certain objects came from. When a sub-tag of this type
+     * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
+     * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
+     * HEAP_DUMP[_SEGMENT].  Multiple HEAP_DUMP_INFO entries may appear in a single
+     * HEAP_DUMP[_SEGMENT].
+     *
+     * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
+     */
+    internal const val HEAP_DUMP_INFO = 0xfe
+    internal const val ROOT_INTERNED_STRING = 0x89
+    internal const val ROOT_FINALIZING = 0x8a
+    internal const val ROOT_DEBUGGER = 0x8b
+    internal const val ROOT_REFERENCE_CLEANUP = 0x8c
+    internal const val ROOT_VM_INTERNAL = 0x8d
+    internal const val ROOT_JNI_MONITOR = 0x8e
+    internal const val ROOT_UNREACHABLE = 0x90
+    internal const val PRIMITIVE_ARRAY_NODATA = 0xc3
+  }
+
+}
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/shark-hprof/src/main/java/shark/HprofRecord.kt
similarity index 65%
rename from leakcanary-haha/src/main/java/leakcanary/Record.kt
rename to shark-hprof/src/main/java/shark/HprofRecord.kt
index cd139855..66cb0656 100644
--- a/leakcanary-haha/src/main/java/leakcanary/Record.kt
+++ b/shark-hprof/src/main/java/shark/HprofRecord.kt
@@ -1,19 +1,26 @@
-package leakcanary
+package shark
 
-sealed class Record {
+/**
+ * A Hprof record. These data structure map 1:1 with how records are written in hprof files.
+ */
+sealed class HprofRecord {
   class StringRecord(
     val id: Long,
     val string: String
-  ) : Record()
+  ) : HprofRecord()
 
   class LoadClassRecord(
     val classSerialNumber: Int,
     val id: Long,
     val stackTraceSerialNumber: Int,
     val classNameStringId: Long
-  ) : Record()
+  ) : HprofRecord()
 
-  object HeapDumpEndRecord : Record()
+  /**
+   * Terminates a series of heap dump segments. Concatenation of heap dump segments equals a
+   * heap dump.
+   */
+  object HeapDumpEndRecord : HprofRecord()
 
   class StackFrameRecord(
     val id: Long,
@@ -29,15 +36,15 @@ sealed class Record {
      * -3 native method (Not implemented)
      */
     val lineNumber: Int
-  ) : Record()
+  ) : HprofRecord()
 
   class StackTraceRecord(
     val stackTraceSerialNumber: Int,
     val threadSerialNumber: Int,
     val stackFrameIds: LongArray
-  ) : Record()
+  ) : HprofRecord()
 
-  sealed class HeapDumpRecord : Record() {
+  sealed class HeapDumpRecord : HprofRecord() {
     class GcRootRecord(
       val gcRoot: GcRoot
     ) : HeapDumpRecord()
@@ -46,7 +53,7 @@ sealed class Record {
       class ClassDumpRecord(
         val id: Long,
         val stackTraceSerialNumber: Int,
-        val superClassId: Long,
+        val superclassId: Long,
         val classLoaderId: Long,
         val signersId: Long,
         val protectionDomainId: Long,
@@ -57,7 +64,7 @@ sealed class Record {
         data class StaticFieldRecord(
           val nameStringId: Long,
           val type: Int,
-          val value: HeapValue
+          val value: ValueHolder
         )
 
         data class FieldRecord(
@@ -66,13 +73,42 @@ sealed class Record {
         )
       }
 
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [ClassDumpRecord] for when you don't need the class content.
+       */
+      class ClassSkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val superclassId: Long,
+        val classLoaderId: Long,
+        val signersId: Long,
+        val protectionDomainId: Long,
+        val instanceSize: Int,
+        val staticFieldCount: Int,
+        val fieldCount: Int
+      ) : ObjectRecord()
+
       class InstanceDumpRecord(
         val id: Long,
         val stackTraceSerialNumber: Int,
         val classId: Long,
+        /**
+         * Instance field values (this class, followed by super class, etc)
+         */
         val fieldValues: ByteArray
       ) : ObjectRecord()
 
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [InstanceDumpRecord] for when you don't need the instance content.
+       */
+      class InstanceSkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val classId: Long
+      ) : ObjectRecord()
+
       class ObjectArrayDumpRecord(
         val id: Long,
         val stackTraceSerialNumber: Int,
@@ -81,11 +117,16 @@ sealed class Record {
       ) : ObjectRecord()
 
       /**
-       * Note: we could move the arrays to the parent class as a ByteString or ByteArray
-       * and then each subtype can create a new array of the right type if needed.
-       * However, experimenting with live parsing has shown that we never to read arrays except
-       * when we want to display leak trace information, in which case we do need the data.
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [ObjectArrayDumpRecord] for when you don't need the array content.
        */
+      class ObjectArraySkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val arrayClassId: Long,
+        val size: Int
+      ) : ObjectRecord()
+
       sealed class PrimitiveArrayDumpRecord : ObjectRecord() {
         abstract val id: Long
         abstract val stackTraceSerialNumber: Int
@@ -163,6 +204,17 @@ sealed class Record {
             get() = array.size
         }
       }
+
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [PrimitiveArrayDumpRecord] for when you don't need the array content.
+       */
+      class PrimitiveArraySkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val size: Int,
+        val type: PrimitiveType
+      ) : ObjectRecord()
     }
 
     class HeapDumpInfoRecord(
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt b/shark-hprof/src/main/java/shark/HprofWriter.kt
similarity index 56%
rename from leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
rename to shark-hprof/src/main/java/shark/HprofWriter.kt
index 421f922d..cae40126 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
+++ b/shark-hprof/src/main/java/shark/HprofWriter.kt
@@ -1,76 +1,134 @@
-package leakcanary
+package shark
 
-import leakcanary.GcRoot.Debugger
-import leakcanary.GcRoot.Finalizing
-import leakcanary.GcRoot.InternedString
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.ReferenceCleanup
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GcRoot.Unknown
-import leakcanary.GcRoot.Unreachable
-import leakcanary.GcRoot.VmInternal
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.Record.HeapDumpEndRecord
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StackTraceRecord
-import leakcanary.Record.StringRecord
 import okio.Buffer
 import okio.BufferedSink
 import okio.buffer
 import okio.sink
+import shark.GcRoot.Debugger
+import shark.GcRoot.Finalizing
+import shark.GcRoot.InternedString
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.GcRoot.Unknown
+import shark.GcRoot.Unreachable
+import shark.GcRoot.VmInternal
+import shark.Hprof.HprofVersion
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.HprofWriter.Companion.open
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
 import java.io.Closeable
 import java.io.File
 
+/**
+ * Generates Hprof files.
+ *
+ * Call [open] to create an instance, [write] to add instances and [close] when you're done.
+ */
+@Suppress("TooManyFunctions")
 class HprofWriter private constructor(
   private val sink: BufferedSink,
-  val idSize: Int
+  val identifierByteSize: Int,
+  val hprofVersion: HprofVersion
 ) : Closeable {
 
   private val workBuffer = Buffer()
 
-  fun write(record: Record) {
+  /**
+   * Appends a [HprofRecord] to the heap dump. If [record] is a [HprofRecord.HeapDumpRecord] then
+   * it will not be written to an in memory buffer and written to file only when the next a record
+   * that is not a [HprofRecord.HeapDumpRecord] is written or when [close] is called.
+   */
+  fun write(record: HprofRecord) {
     sink.write(record)
   }
 
-  private fun BufferedSink.write(record: Record) {
+  /**
+   * Helper method for creating a [ByteArray] for [InstanceDumpRecord.fieldValues] from a
+   * list of [ValueHolder].
+   */
+  fun valuesToBytes(values: List<ValueHolder>): ByteArray {
+    val valuesBuffer = Buffer()
+    values.forEach { value ->
+        valuesBuffer.writeValue(value)
+    }
+    return valuesBuffer.readByteArray()
+  }
+
+  /**
+   * Flushes to disk all [HprofRecord.HeapDumpRecord] that are currently written to the in memory
+   * buffer, then closes the file.
+   */
+  override fun close() {
+    sink.flushHeapBuffer()
+    sink.close()
+  }
+
+  private fun BufferedSink.writeValue(wrapper: ValueHolder) {
+    when (wrapper) {
+      is ReferenceHolder -> writeId(wrapper.value)
+      is BooleanHolder -> writeBoolean(wrapper.value)
+      is CharHolder -> write(charArrayOf(wrapper.value))
+      is FloatHolder -> writeFloat(wrapper.value)
+      is DoubleHolder -> writeDouble(wrapper.value)
+      is ByteHolder -> writeByte(wrapper.value.toInt())
+      is ShortHolder -> writeShort(wrapper.value.toInt())
+      is IntHolder -> writeInt(wrapper.value)
+      is LongHolder -> writeLong(wrapper.value)
+    }
+  }
+
+  @Suppress("LongMethod")
+  private fun BufferedSink.write(record: HprofRecord) {
     when (record) {
       is StringRecord -> {
-        writeNonHeapRecord(HprofPushRecordsParser.STRING_IN_UTF8) {
+        writeNonHeapRecord(HprofReader.STRING_IN_UTF8) {
           writeId(record.id)
           writeUtf8(record.string)
         }
       }
       is LoadClassRecord -> {
-        writeNonHeapRecord(HprofPushRecordsParser.LOAD_CLASS) {
+        writeNonHeapRecord(HprofReader.LOAD_CLASS) {
           writeInt(record.classSerialNumber)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
@@ -78,7 +136,7 @@ class HprofWriter private constructor(
         }
       }
       is StackTraceRecord -> {
-        writeNonHeapRecord(HprofPushRecordsParser.STACK_TRACE) {
+        writeNonHeapRecord(HprofReader.STACK_TRACE) {
           writeInt(record.stackTraceSerialNumber)
           writeInt(record.threadSerialNumber)
           writeInt(record.stackFrameIds.size)
@@ -89,80 +147,80 @@ class HprofWriter private constructor(
         with(workBuffer) {
           when (val gcRoot = record.gcRoot) {
             is Unknown -> {
-              writeByte(HprofPushRecordsParser.ROOT_UNKNOWN)
+              writeByte(HprofReader.ROOT_UNKNOWN)
               writeId(gcRoot.id)
             }
             is JniGlobal -> {
               writeByte(
-                  HprofPushRecordsParser.ROOT_JNI_GLOBAL
+                  HprofReader.ROOT_JNI_GLOBAL
               )
               writeId(gcRoot.id)
               writeId(gcRoot.jniGlobalRefId)
             }
             is JniLocal -> {
-              writeByte(HprofPushRecordsParser.ROOT_JNI_LOCAL)
+              writeByte(HprofReader.ROOT_JNI_LOCAL)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.frameNumber)
             }
             is JavaFrame -> {
-              writeByte(HprofPushRecordsParser.ROOT_JAVA_FRAME)
+              writeByte(HprofReader.ROOT_JAVA_FRAME)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.frameNumber)
             }
             is NativeStack -> {
-              writeByte(HprofPushRecordsParser.ROOT_NATIVE_STACK)
+              writeByte(HprofReader.ROOT_NATIVE_STACK)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
             }
             is StickyClass -> {
-              writeByte(HprofPushRecordsParser.ROOT_STICKY_CLASS)
+              writeByte(HprofReader.ROOT_STICKY_CLASS)
               writeId(gcRoot.id)
             }
             is ThreadBlock -> {
-              writeByte(HprofPushRecordsParser.ROOT_THREAD_BLOCK)
+              writeByte(HprofReader.ROOT_THREAD_BLOCK)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
             }
             is MonitorUsed -> {
-              writeByte(HprofPushRecordsParser.ROOT_MONITOR_USED)
+              writeByte(HprofReader.ROOT_MONITOR_USED)
               writeId(gcRoot.id)
             }
             is ThreadObject -> {
-              writeByte(HprofPushRecordsParser.ROOT_THREAD_OBJECT)
+              writeByte(HprofReader.ROOT_THREAD_OBJECT)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.stackTraceSerialNumber)
             }
             is ReferenceCleanup -> {
-              writeByte(HprofPushRecordsParser.ROOT_REFERENCE_CLEANUP)
+              writeByte(HprofReader.ROOT_REFERENCE_CLEANUP)
               writeId(gcRoot.id)
             }
             is VmInternal -> {
-              writeByte(HprofPushRecordsParser.ROOT_VM_INTERNAL)
+              writeByte(HprofReader.ROOT_VM_INTERNAL)
               writeId(gcRoot.id)
             }
             is JniMonitor -> {
-              writeByte(HprofPushRecordsParser.ROOT_JNI_MONITOR)
+              writeByte(HprofReader.ROOT_JNI_MONITOR)
               writeId(gcRoot.id)
               writeInt(gcRoot.stackTraceSerialNumber)
               writeInt(gcRoot.stackDepth)
             }
             is InternedString -> {
-              writeByte(HprofPushRecordsParser.ROOT_INTERNED_STRING)
+              writeByte(HprofReader.ROOT_INTERNED_STRING)
               writeId(gcRoot.id)
             }
             is Finalizing -> {
-              writeByte(HprofPushRecordsParser.ROOT_FINALIZING)
+              writeByte(HprofReader.ROOT_FINALIZING)
               writeId(gcRoot.id)
             }
             is Debugger -> {
-              writeByte(HprofPushRecordsParser.ROOT_DEBUGGER)
+              writeByte(HprofReader.ROOT_DEBUGGER)
               writeId(gcRoot.id)
             }
             is Unreachable -> {
-              writeByte(HprofPushRecordsParser.ROOT_UNREACHABLE)
+              writeByte(HprofReader.ROOT_UNREACHABLE)
               writeId(gcRoot.id)
             }
           }
@@ -170,10 +228,10 @@ class HprofWriter private constructor(
       }
       is ClassDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.CLASS_DUMP)
+          writeByte(HprofReader.CLASS_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
-          writeId(record.superClassId)
+          writeId(record.superclassId)
           writeId(record.classLoaderId)
           writeId(record.signersId)
           writeId(record.protectionDomainId)
@@ -200,7 +258,7 @@ class HprofWriter private constructor(
       }
       is InstanceDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.INSTANCE_DUMP)
+          writeByte(HprofReader.INSTANCE_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
           writeId(record.classId)
@@ -210,7 +268,7 @@ class HprofWriter private constructor(
       }
       is ObjectArrayDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.OBJECT_ARRAY_DUMP)
+          writeByte(HprofReader.OBJECT_ARRAY_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
           writeInt(record.elementIds.size)
@@ -220,49 +278,49 @@ class HprofWriter private constructor(
       }
       is PrimitiveArrayDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.PRIMITIVE_ARRAY_DUMP)
+          writeByte(HprofReader.PRIMITIVE_ARRAY_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
 
           when (record) {
             is BooleanArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.BOOLEAN_TYPE)
+              writeByte(BOOLEAN.hprofType)
               write(record.array)
             }
             is CharArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.CHAR_TYPE)
+              writeByte(CHAR.hprofType)
               write(record.array)
             }
             is FloatArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.FLOAT_TYPE)
+              writeByte(FLOAT.hprofType)
               write(record.array)
             }
             is DoubleArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.DOUBLE_TYPE)
+              writeByte(DOUBLE.hprofType)
               write(record.array)
             }
             is ByteArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.BYTE_TYPE)
+              writeByte(BYTE.hprofType)
               write(record.array)
             }
             is ShortArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.SHORT_TYPE)
+              writeByte(SHORT.hprofType)
               write(record.array)
             }
             is IntArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.INT_TYPE)
+              writeByte(INT.hprofType)
               write(record.array)
             }
             is LongArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.LONG_TYPE)
+              writeByte(LONG.hprofType)
               write(record.array)
             }
           }
@@ -270,7 +328,7 @@ class HprofWriter private constructor(
       }
       is HeapDumpInfoRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.HEAP_DUMP_INFO)
+          writeByte(HprofReader.HEAP_DUMP_INFO)
           writeInt(record.heapId)
           writeId(record.heapNameStringId)
         }
@@ -281,20 +339,6 @@ class HprofWriter private constructor(
     }
   }
 
-  fun BufferedSink.writeValue(wrapper: HeapValue) {
-    when (wrapper) {
-      is ObjectReference -> writeId(wrapper.value)
-      is BooleanValue -> writeBoolean(wrapper.value)
-      is CharValue -> write(charArrayOf(wrapper.value))
-      is FloatValue -> writeFloat(wrapper.value)
-      is DoubleValue -> writeDouble(wrapper.value)
-      is ByteValue -> writeByte(wrapper.value.toInt())
-      is ShortValue -> writeShort(wrapper.value.toInt())
-      is IntValue -> writeInt(wrapper.value)
-      is LongValue -> writeLong(wrapper.value)
-    }
-  }
-
   private fun BufferedSink.writeDouble(value: Double) {
     writeLong(value.toBits())
   }
@@ -351,9 +395,9 @@ class HprofWriter private constructor(
 
   private fun BufferedSink.flushHeapBuffer() {
     if (workBuffer.size > 0) {
-      writeTagHeader(HprofPushRecordsParser.HEAP_DUMP, workBuffer.size)
+      writeTagHeader(HprofReader.HEAP_DUMP, workBuffer.size)
       writeAll(workBuffer)
-      writeTagHeader(HprofPushRecordsParser.HEAP_DUMP_END, 0)
+      writeTagHeader(HprofReader.HEAP_DUMP_END, 0)
     }
   }
 
@@ -368,7 +412,7 @@ class HprofWriter private constructor(
   }
 
   private fun BufferedSink.writeId(id: Long) {
-    when (idSize) {
+    when (identifierByteSize) {
       1 -> writeByte(id.toInt())
       2 -> writeShort(id.toInt())
       4 -> writeInt(id.toInt())
@@ -377,28 +421,30 @@ class HprofWriter private constructor(
     }
   }
 
-  override fun close() {
-    sink.flushHeapBuffer()
-    sink.close()
-  }
-
   companion object {
+    /**
+     * Opens a new file for writing hprof records. Don't forget to call [close] once done.
+     */
     fun open(
       hprofFile: File,
-      idSize: Int = 4
+      /**
+       * Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects,
+       * stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are
+       * not required to be.
+       */
+      identifierByteSize: Int = 4,
+      /** Version of the opened hprof, which is tied to the runtime where the heap was dumped. */
+      hprofVersion: HprofVersion = HprofVersion.ANDROID
     ): HprofWriter {
-
       val sink = hprofFile.outputStream()
           .sink()
           .buffer()
-
-      val hprofVersion = "JAVA PROFILE 1.0.3"
-      sink.writeUtf8(hprofVersion)
+      sink.writeUtf8(hprofVersion.versionString)
       sink.writeByte(0)
-      sink.writeInt(idSize)
+      sink.writeInt(identifierByteSize)
       val heapDumpTimestamp = System.currentTimeMillis()
       sink.writeLong(heapDumpTimestamp)
-      return HprofWriter(sink, idSize)
+      return HprofWriter(sink, identifierByteSize, hprofVersion)
     }
   }
 }
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt b/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt
new file mode 100644
index 00000000..c613e3f2
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt
@@ -0,0 +1,40 @@
+package shark
+
+/**
+ * Listener passed in to [HprofReader.readHprofRecords], gets notified for each [HprofRecord]
+ * found in the heap dump which types is in the set of the recordTypes parameter passed to
+ * [HprofReader.readHprofRecords].
+ */
+interface OnHprofRecordListener {
+  fun onHprofRecord(
+    /**
+     * The position of the record in the underlying hprof file.
+     */
+    position: Long,
+    record: HprofRecord
+  )
+
+  companion object {
+    /**
+     * Utility function to create a [OnHprofRecordListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnHprofRecordListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnHprofRecordListener { position, record ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (Long, HprofRecord) -> Unit): OnHprofRecordListener =
+      object : OnHprofRecordListener {
+        override fun onHprofRecord(
+          position: Long,
+          record: HprofRecord
+        ) {
+          block(position, record)
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/PrimitiveType.kt b/shark-hprof/src/main/java/shark/PrimitiveType.kt
new file mode 100644
index 00000000..62794fc0
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/PrimitiveType.kt
@@ -0,0 +1,35 @@
+package shark
+
+/**
+ * A primitive type in the prof.
+ */
+enum class PrimitiveType(
+  /**
+   * The hprof defined "basic type".
+   */
+  val hprofType: Int,
+  /**
+   * The size in bytes for each value of that type.
+   */
+  val byteSize: Int
+) {
+  BOOLEAN(4, 1),
+  CHAR(5, 2),
+  FLOAT(6, 4),
+  DOUBLE(7, 8),
+  BYTE(8, 1),
+  SHORT(9, 2),
+  INT(10, 4),
+  LONG(11, 8);
+
+  companion object {
+    /**
+     * The hprof defined "basic type" for references.
+     */
+    const val REFERENCE_HPROF_TYPE = 2
+
+    val byteSizeByHprofType = values().map { it.hprofType to it.byteSize }.toMap()
+
+    val primitiveTypeByHprofType = values().map { it.hprofType to it }.toMap()
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/ValueHolder.kt b/shark-hprof/src/main/java/shark/ValueHolder.kt
new file mode 100644
index 00000000..ed53c436
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ValueHolder.kt
@@ -0,0 +1,27 @@
+package shark
+
+import shark.ValueHolder.ReferenceHolder
+
+/**
+ * A value in the heap dump, which can be a [ReferenceHolder] or
+ * a primitive type.
+ */
+sealed class ValueHolder {
+  data class ReferenceHolder(val value: Long) : ValueHolder() {
+    val isNull
+      get() = value == NULL_REFERENCE
+  }
+
+  data class BooleanHolder(val value: Boolean) : ValueHolder()
+  data class CharHolder(val value: Char) : ValueHolder()
+  data class FloatHolder(val value: Float) : ValueHolder()
+  data class DoubleHolder(val value: Double) : ValueHolder()
+  data class ByteHolder(val value: Byte) : ValueHolder()
+  data class ShortHolder(val value: Short) : ValueHolder()
+  data class IntHolder(val value: Int) : ValueHolder()
+  data class LongHolder(val value: Long) : ValueHolder()
+
+  companion object {
+    const val NULL_REFERENCE = 0L
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt b/shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt
new file mode 100644
index 00000000..4810b932
--- /dev/null
+++ b/shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt
@@ -0,0 +1,46 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import kotlin.text.Charsets.UTF_8
+
+class HprofReaderPrimitiveArrayTest {
+
+    @get:Rule
+    var heapDumpRule = HeapDumpRule()
+
+    @Test
+    fun skips_primitive_arrays_correctly() {
+        val heapDump = heapDumpRule.dumpHeap()
+
+        Hprof.open(heapDump).use { hprof ->
+            hprof.reader.readHprofRecords(
+                    emptySet(), // skip everything including primitive arrays
+                    OnHprofRecordListener { _, _ -> })
+        }
+    }
+
+    @Test
+    fun reads_primitive_arrays_correctly() {
+        val byteArray = ("Sharks also have a sensory organ called the \"ampullae of Lorenzini\" " +
+                         "which they use to \"feel\" the electrical field coming from its prey.")
+                .toByteArray(UTF_8)
+
+        val heapDump = heapDumpRule.dumpHeap()
+
+        var myByteArrayIsInHeapDump = false
+        Hprof.open(heapDump).use { hprof ->
+            hprof.reader.readHprofRecords(
+                    setOf(HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord::class),
+                    OnHprofRecordListener { _, record ->
+                        if (record is HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump) {
+                            if (byteArray.contentEquals(record.array)) {
+                                myByteArrayIsInHeapDump = true
+                            }
+                        }
+                    })
+        }
+        assertThat(myByteArrayIsInHeapDump).isTrue()
+    }
+}
\ No newline at end of file
diff --git a/leakcanary-log/build.gradle b/shark-log/build.gradle
similarity index 78%
rename from leakcanary-log/build.gradle
rename to shark-log/build.gradle
index 6655f74f..0a05974f 100644
--- a/leakcanary-log/build.gradle
+++ b/shark-log/build.gradle
@@ -6,7 +6,9 @@ targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
   implementation deps.kotlin.stdlib
+
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/shark-log/gradle.properties b/shark-log/gradle.properties
new file mode 100644
index 00000000..319b4dfc
--- /dev/null
+++ b/shark-log/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-log
+POM_NAME=Shark Log
+POM_PACKAGING=jar
diff --git a/shark-log/src/main/java/shark/SharkLog.kt b/shark-log/src/main/java/shark/SharkLog.kt
new file mode 100644
index 00000000..673dee6a
--- /dev/null
+++ b/shark-log/src/main/java/shark/SharkLog.kt
@@ -0,0 +1,43 @@
+package shark
+
+/**
+ * Central Logger for all Shark artifacts. Set [logger] to change where these logs go.
+ */
+object SharkLog {
+
+  /**
+   * @see SharkLog
+   */
+  interface Logger {
+
+    /**
+     * Logs a debug message formatted with the passed in arguments.
+     */
+    fun d(message: String)
+
+    /**
+     * Logs a [Throwable] and debug message formatted with the passed in arguments.
+     */
+    fun d(throwable: Throwable, message: String)
+  }
+
+  @Volatile var logger: Logger? = null
+
+  /**
+   * @see Logger.d
+   */
+  inline fun d(message: () -> String) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    val logger = logger ?: return
+    logger.d(message.invoke())
+  }
+
+  /**
+   * @see Logger.d
+   */
+  inline fun d(throwable: Throwable, message: () -> String) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    val logger = logger ?: return
+    logger.d(throwable, message.invoke())
+  }
+}
diff --git a/shark-log/src/test/java/shark/SharkLogTest.kt b/shark-log/src/test/java/shark/SharkLogTest.kt
new file mode 100644
index 00000000..5466fa4b
--- /dev/null
+++ b/shark-log/src/test/java/shark/SharkLogTest.kt
@@ -0,0 +1,45 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.SharkLog.Logger
+import java.io.ByteArrayOutputStream
+import java.io.PrintStream
+
+class SharkLogTest {
+
+  private class StreamLogger(private val stream: PrintStream) : Logger {
+    override fun d(message: String) = stream.print(message)
+    override fun d(throwable: Throwable, message: String) = stream.print("$message ${throwable.message}")
+  }
+
+  @Test fun `logging works when logger is set`() {
+    val outputStream = ByteArrayOutputStream()
+
+    SharkLog.logger = StreamLogger(PrintStream(outputStream))
+
+    // Test debug logging
+    SharkLog.d { "Test debug" }
+    assertThat(outputStream.toString()).isEqualTo("Test debug")
+  }
+
+  @Test fun `logging with exception works when logger is set`() {
+    val outputStream = ByteArrayOutputStream()
+
+    SharkLog.logger = StreamLogger(PrintStream(outputStream))
+
+    // Test error logging
+    SharkLog.d(Exception("Test exception")) { "Test error" }
+    assertThat(outputStream.toString()).isEqualTo("Test error Test exception")
+  }
+
+  @Test fun `logging is no-op without logger and string is ignored`() {
+    SharkLog.logger = null
+
+    // Logging message will throw an exception when attempting to use it
+    // But since it's in lambda string will not be accessed
+    SharkLog.d { "".substring(1) }
+
+    SharkLog.d(Exception("Test exception")) { "".substring(1) }
+  }
+}
\ No newline at end of file
diff --git a/shark-test/build.gradle b/shark-test/build.gradle
new file mode 100644
index 00000000..3e527c9c
--- /dev/null
+++ b/shark-test/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+    implementation deps.kotlin.stdlib
+    implementation deps.assertj_core
+    implementation deps.junit
+}
+
diff --git a/shark-test/src/main/kotlin/shark/HeapDumpRule.kt b/shark-test/src/main/kotlin/shark/HeapDumpRule.kt
new file mode 100644
index 00000000..89abd305
--- /dev/null
+++ b/shark-test/src/main/kotlin/shark/HeapDumpRule.kt
@@ -0,0 +1,27 @@
+package shark
+
+import org.junit.rules.ExternalResource
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import java.io.IOException
+import java.util.UUID
+
+class HeapDumpRule : ExternalResource() {
+    private val temporaryFolder = TemporaryFolder()
+
+    @Throws(Throwable::class)
+    override fun before() {
+        temporaryFolder.create()
+    }
+
+    override fun after() {
+        temporaryFolder.delete()
+    }
+
+    @Throws(IOException::class)
+    fun dumpHeap(): File {
+        val hprof = File(temporaryFolder.root, "heapDump" + UUID.randomUUID() + ".hprof")
+        JvmTestHeapDumper.dumpHeap(hprof.absolutePath)
+        return hprof
+    }
+}
diff --git a/shark-test/src/main/kotlin/shark/JvmTestHeapDumper.kt b/shark-test/src/main/kotlin/shark/JvmTestHeapDumper.kt
new file mode 100644
index 00000000..58e4d498
--- /dev/null
+++ b/shark-test/src/main/kotlin/shark/JvmTestHeapDumper.kt
@@ -0,0 +1,23 @@
+package shark
+
+import com.sun.management.HotSpotDiagnosticMXBean
+import java.lang.management.ManagementFactory
+
+object JvmTestHeapDumper {
+  private val hotspotMBean: HotSpotDiagnosticMXBean by lazy {
+    val mBeanServer = ManagementFactory.getPlatformMBeanServer()
+    ManagementFactory.newPlatformMXBeanProxy(
+        mBeanServer,
+        "com.sun.management:type=HotSpotDiagnostic",
+        HotSpotDiagnosticMXBean::class.java
+    )
+  }
+
+  fun dumpHeap(
+    fileName: String
+  ) {
+    val live = true
+    hotspotMBean.dumpHeap(fileName, live)
+  }
+
+}
\ No newline at end of file
diff --git a/shark/build.gradle b/shark/build.gradle
new file mode 100644
index 00000000..c4eb5b85
--- /dev/null
+++ b/shark/build.gradle
@@ -0,0 +1,17 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':shark-graph')
+
+  implementation deps.kotlin.stdlib
+
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
+  testImplementation deps.okio
+}
+
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark/gradle.properties b/shark/gradle.properties
new file mode 100644
index 00000000..0053d064
--- /dev/null
+++ b/shark/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark
+POM_NAME=Shark
+POM_PACKAGING=jar
diff --git a/shark/src/main/java/shark/AppSingletonInspector.kt b/shark/src/main/java/shark/AppSingletonInspector.kt
new file mode 100644
index 00000000..b5f56eba
--- /dev/null
+++ b/shark/src/main/java/shark/AppSingletonInspector.kt
@@ -0,0 +1,23 @@
+package shark
+
+import shark.HeapObject.HeapInstance
+
+/**
+ * Inspector that automatically marks instances of the provided class names as not leaking
+ * because they're app wide singletons.
+ */
+class AppSingletonInspector(private vararg val singletonClasses: String) : ObjectInspector {
+  override fun inspect(
+    reporter: ObjectReporter
+  ) {
+    if (reporter.heapObject is HeapInstance) {
+      reporter.heapObject.instanceClass
+          .classHierarchy
+          .forEach { heapClass ->
+            if (heapClass.name in singletonClasses) {
+              reporter.notLeakingReasons += "${heapClass.name} is an app singleton"
+            }
+          }
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalysis.kt b/shark/src/main/java/shark/HeapAnalysis.kt
new file mode 100644
index 00000000..8aeb101d
--- /dev/null
+++ b/shark/src/main/java/shark/HeapAnalysis.kt
@@ -0,0 +1,146 @@
+package shark
+
+import shark.internal.createSHA1Hash
+import java.io.File
+import java.io.Serializable
+
+/**
+ * The result of an analysis performed by [HeapAnalyzer], either a [HeapAnalysisSuccess] or a
+ * [HeapAnalysisFailure]. This class is serializable however there are no guarantees of forward
+ * compatibility.
+ */
+sealed class HeapAnalysis : Serializable {
+  /**
+   * The hprof file that was analyzed.
+   */
+  abstract val heapDumpFile: File
+
+  /**
+   * The [System.currentTimeMillis] when this [HeapAnalysis] instance was created.
+   */
+  abstract val createdAtTimeMillis: Long
+
+  /**
+   * Total time spent analyzing the heap.
+   */
+  abstract val analysisDurationMillis: Long
+}
+
+/**
+ * The analysis performed by [HeapAnalyzer] did not complete successfully.
+ */
+data class HeapAnalysisFailure(
+  override val heapDumpFile: File,
+  override val createdAtTimeMillis: Long,
+  override val analysisDurationMillis: Long,
+  /**
+   * An exception wrapping the actual exception that was thrown.
+   */
+  val exception: HeapAnalysisException
+) : HeapAnalysis()
+
+/**
+ * The result of a successful heap analysis performed by [HeapAnalyzer].
+ */
+data class HeapAnalysisSuccess(
+  override val heapDumpFile: File,
+  override val createdAtTimeMillis: Long,
+  override val analysisDurationMillis: Long,
+  /**
+   * The list of [ApplicationLeak] found in the heap dump by [HeapAnalyzer].
+   */
+  val applicationLeaks: List<ApplicationLeak>,
+  /**
+   * The list of [LibraryLeak] found in the heap dump by [HeapAnalyzer].
+   */
+  val libraryLeaks: List<LibraryLeak>
+) : HeapAnalysis() {
+  /**
+   * The list of [Leak] found in the heap dump by [HeapAnalyzer], ie all [applicationLeaks] and
+   * all [libraryLeaks] in one list.
+   */
+  val allLeaks: List<Leak>
+    get() = applicationLeaks + libraryLeaks
+}
+
+/**
+ * A leak found by [HeapAnalyzer], either an [ApplicationLeak] or a [LibraryLeak].
+ */
+sealed class Leak : Serializable {
+  /**
+   * Class name of the leaking object.
+   * The class name format is the same as what would be returned by [Class.getName].
+   */
+  abstract val className: String
+
+  /**
+   * Shortest path from GC roots to the leaking object.
+   */
+  abstract val leakTrace: LeakTrace
+
+  /**
+   * The number of bytes which would be freed if all references to the leaking object were
+   * released. Null if the retained heap size was not computed.
+   */
+  abstract val retainedHeapByteSize: Int?
+
+  /**
+   * A unique SHA1 hash that represents this group of leaks.
+   *
+   * For [ApplicationLeak] this is based on [LeakTrace.leakCauses] and for [LibraryLeak] this is
+   * based on [LibraryLeak.pattern].
+   */
+  val groupHash
+    get() = createGroupHash()
+
+  /**
+   * Returns [className] stripped of any string content before the last period (included).
+   */
+  val classSimpleName: String
+    get() {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) className else className.substring(separator + 1)
+    }
+
+  protected abstract fun createGroupHash(): String
+}
+
+/**
+ * A leak found by [HeapAnalyzer], where the only path to the leaking object required going
+ * through a reference matched by [pattern], as provided to a [LibraryLeakReferenceMatcher]
+ * instance. This is a known leak in library code that is beyond your control.
+ */
+data class LibraryLeak(
+  override val className: String,
+  override val leakTrace: LeakTrace,
+  override val retainedHeapByteSize: Int?,
+  /**
+   * The pattern that matched one of the references in [leakTrace], as provided to a
+   * [LibraryLeakReferenceMatcher] instance.
+   */
+  val pattern: ReferencePattern,
+  /**
+   * A description that conveys what we know about this library leak.
+   */
+  val description: String
+) : Leak() {
+  override fun createGroupHash() = pattern.toString().createSHA1Hash()
+}
+
+/**
+ * A leak found by [HeapAnalyzer] in your application.
+ */
+data class ApplicationLeak(
+  override val className: String,
+  override val leakTrace: LeakTrace,
+  override val retainedHeapByteSize: Int?
+) : Leak() {
+  override fun createGroupHash(): String {
+    return leakTrace.leakCauses
+        .joinToString(separator = "") { element ->
+          val referenceName = element.reference!!.groupingName
+          element.className + referenceName
+        }
+        .createSHA1Hash()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt b/shark/src/main/java/shark/HeapAnalysisException.kt
similarity index 93%
rename from leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt
rename to shark/src/main/java/shark/HeapAnalysisException.kt
index 313fafde..5a1205a2 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt
+++ b/shark/src/main/java/shark/HeapAnalysisException.kt
@@ -1,4 +1,4 @@
-package leakcanary
+package shark
 
 import java.io.PrintWriter
 import java.io.StringWriter
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
new file mode 100644
index 00000000..1ad4ca5b
--- /dev/null
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -0,0 +1,540 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.HeapAnalyzer.TrieNode.LeafNode
+import shark.HeapAnalyzer.TrieNode.ParentNode
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.LeakTraceElement.Holder.ARRAY
+import shark.LeakTraceElement.Holder.CLASS
+import shark.LeakTraceElement.Holder.OBJECT
+import shark.LeakTraceElement.Holder.THREAD
+import shark.OnAnalysisProgressListener.Step.BUILDING_LEAK_TRACES
+import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.FINDING_LEAKING_INSTANCES
+import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
+import shark.OnAnalysisProgressListener.Step.REPORTING_HEAP_ANALYSIS
+import shark.internal.PathFinder
+import shark.internal.PathFinder.PathFindingResults
+import shark.internal.ReferencePathNode
+import shark.internal.ReferencePathNode.ChildNode
+import shark.internal.ReferencePathNode.LibraryLeakNode
+import shark.internal.ReferencePathNode.RootNode
+import shark.internal.lastSegment
+import java.io.File
+import java.util.ArrayList
+import java.util.LinkedHashMap
+import java.util.concurrent.TimeUnit.NANOSECONDS
+
+/**
+ * Analyzes heap dumps to look for leaks.
+ */
+@Suppress("TooManyFunctions")
+class HeapAnalyzer constructor(
+  private val listener: OnAnalysisProgressListener
+) {
+
+  private class FindLeakInput(
+    val graph: HeapGraph,
+    val leakFinders: List<ObjectInspector>,
+    val referenceMatchers: List<ReferenceMatcher>,
+    val computeRetainedHeapSize: Boolean,
+    val objectInspectors: List<ObjectInspector>
+  )
+
+  /**
+   * Searches the heap dump for leaking instances and then computes the shortest strong reference
+   * path from those instances to the GC roots.
+   */
+  fun analyze(
+    heapDumpFile: File,
+    referenceMatchers: List<ReferenceMatcher> = emptyList(),
+    computeRetainedHeapSize: Boolean = false,
+    objectInspectors: List<ObjectInspector> = emptyList(),
+    leakFinders: List<ObjectInspector> = objectInspectors,
+    proguardMapping: ProguardMapping? = null
+  ): HeapAnalysis {
+    val analysisStartNanoTime = System.nanoTime()
+
+    if (!heapDumpFile.exists()) {
+      val exception = IllegalArgumentException("File does not exist: $heapDumpFile")
+      listener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
+      return HeapAnalysisFailure(
+          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    }
+
+    try {
+      listener.onAnalysisProgress(PARSING_HEAP_DUMP)
+      Hprof.open(heapDumpFile)
+          .use { hprof ->
+            val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)
+
+            val findLeakInput = FindLeakInput(
+                graph, leakFinders, referenceMatchers, computeRetainedHeapSize, objectInspectors
+            )
+            val (applicationLeaks, libraryLeaks) = findLeakInput.findLeaks()
+            listener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
+            return HeapAnalysisSuccess(
+                heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+                applicationLeaks, libraryLeaks
+            )
+          }
+    } catch (exception: Throwable) {
+      listener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
+      return HeapAnalysisFailure(
+          heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
+          HeapAnalysisException(exception)
+      )
+    }
+  }
+
+  private fun FindLeakInput.findLeaks(): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
+    val leakingInstanceObjectIds = findLeakingObjects()
+
+    val pathFinder = PathFinder(graph, listener, referenceMatchers)
+    val pathFindingResults =
+      pathFinder.findPathsFromGcRoots(leakingInstanceObjectIds, computeRetainedHeapSize)
+
+    return buildLeakTraces(pathFindingResults)
+  }
+
+  private fun FindLeakInput.findLeakingObjects(): Set<Long> {
+    listener.onAnalysisProgress(FINDING_LEAKING_INSTANCES)
+    return graph.objects
+        .filter { objectRecord ->
+          val reporter = ObjectReporter(objectRecord)
+          leakFinders.any { inspector ->
+            inspector.inspect(reporter)
+            reporter.leakingReasons.isNotEmpty()
+          }
+        }
+        .map { it.objectId }
+        .toSet()
+  }
+
+  internal sealed class TrieNode {
+    abstract val objectId: Long
+
+    class ParentNode(override val objectId: Long) : TrieNode() {
+      val children = mutableMapOf<Long, TrieNode>()
+      override fun toString(): String {
+        return "ParentNode(objectId=$objectId, children=$children)"
+      }
+    }
+
+    class LeafNode(
+      override val objectId: Long,
+      val pathNode: ReferencePathNode
+    ) : TrieNode()
+
+  }
+
+  private fun deduplicateShortestPaths(inputPathResults: List<ReferencePathNode>): List<ReferencePathNode> {
+    val rootTrieNode = ParentNode(0)
+
+    for (pathNode in inputPathResults) {
+      // Go through the linked list of nodes and build the reverse list of instances from
+      // root to leaking.
+      val path = mutableListOf<Long>()
+      var leakNode: ReferencePathNode = pathNode
+      while (leakNode is ChildNode) {
+        path.add(0, leakNode.objectId)
+        leakNode = leakNode.parent
+      }
+      path.add(0, leakNode.objectId)
+      updateTrie(pathNode, path, 0, rootTrieNode)
+    }
+
+    val outputPathResults = mutableListOf<ReferencePathNode>()
+    findResultsInTrie(rootTrieNode, outputPathResults)
+    return outputPathResults
+  }
+
+  private fun updateTrie(
+    pathNode: ReferencePathNode,
+    path: List<Long>,
+    pathIndex: Int,
+    parentNode: ParentNode
+  ) {
+    val objectId = path[pathIndex]
+    if (pathIndex == path.lastIndex) {
+      // Replace any preexisting children, this is shorter.
+      parentNode.children[objectId] = LeafNode(objectId, pathNode)
+    } else {
+      val childNode = parentNode.children[objectId] ?: {
+        val newChildNode = ParentNode(objectId)
+        parentNode.children[objectId] = newChildNode
+        newChildNode
+      }()
+      if (childNode is ParentNode) {
+        updateTrie(pathNode, path, pathIndex + 1, childNode)
+      }
+    }
+  }
+
+  private fun findResultsInTrie(
+    parentNode: ParentNode,
+    outputPathResults: MutableList<ReferencePathNode>
+  ) {
+    parentNode.children.values.forEach { childNode ->
+      when (childNode) {
+        is ParentNode -> {
+          findResultsInTrie(childNode, outputPathResults)
+        }
+        is LeafNode -> {
+          outputPathResults += childNode.pathNode
+        }
+      }
+    }
+  }
+
+  private fun FindLeakInput.computeRetainedSizes(pathFindingResults: PathFindingResults): List<Int>? {
+    if (!computeRetainedHeapSize) {
+      return null
+    }
+    val pathsToLeakingInstances = pathFindingResults.pathsToLeakingObjects
+    val dominatedInstances = pathFindingResults.dominatedObjectIds
+
+    listener.onAnalysisProgress(COMPUTING_NATIVE_RETAINED_SIZE)
+
+    // Map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
+    val nativeSizes = mutableMapOf<Long, Int>().withDefault { 0 }
+    // Doc from perflib:
+    // Native allocations can be identified by looking at instances of
+    // libcore.util.NativeAllocationRegistry$CleanerThunk. The "owning" Java object is the
+    // "referent" field of the "sun.misc.Cleaner" instance with a hard reference to the
+    // CleanerThunk.
+    //
+    // The size is in the 'size' field of the libcore.util.NativeAllocationRegistry instance
+    // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
+    // the CleanerThunk. The hprof does not include the native bytes pointed to.
+
+    graph.instances
+        .filter { it.instanceClassName == "sun.misc.Cleaner" }
+        .forEach { cleaner ->
+          val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
+          val thunkId = thunkField?.value?.asNonNullObjectId
+          val referentId =
+            cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectId
+          if (thunkId != null && referentId != null) {
+            val thunkRecord = thunkField.value.asObject
+            if (thunkRecord is HeapInstance && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
+              val allocationRegistryIdField =
+                thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
+              if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
+                val allocationRegistryRecord = allocationRegistryIdField.value.asObject
+                if (allocationRegistryRecord is HeapInstance && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
+                  var nativeSize = nativeSizes.getValue(referentId)
+                  nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
+                      ?: 0
+                  nativeSizes[referentId] = nativeSize
+                }
+              }
+            }
+          }
+        }
+
+    listener.onAnalysisProgress(COMPUTING_RETAINED_SIZE)
+
+    val sizeByDominator = LinkedHashMap<Long, Int>().withDefault { 0 }
+
+    // Include self size for leaking instances
+    val leakingInstanceIds = mutableSetOf<Long>()
+    pathsToLeakingInstances.forEach { pathNode ->
+      val leakingInstanceObjectId = pathNode.objectId
+      leakingInstanceIds.add(leakingInstanceObjectId)
+      val instanceRecord = graph.findObjectById(leakingInstanceObjectId).asInstance!!
+      val heapClass = instanceRecord.instanceClass
+      var retainedSize = sizeByDominator.getValue(leakingInstanceObjectId)
+
+      retainedSize += heapClass.instanceByteSize
+      sizeByDominator[leakingInstanceObjectId] = retainedSize
+    }
+
+    // Compute the size of each dominated instance and add to dominator
+    dominatedInstances.forEach { instanceId, dominatorId ->
+      // Avoid double reporting as those sizes will move up to the root dominator
+      if (instanceId !in leakingInstanceIds) {
+        val currentSize = sizeByDominator.getValue(dominatorId)
+        val nativeSize = nativeSizes.getValue(instanceId)
+        val shallowSize = when (val objectRecord = graph.findObjectById(instanceId)) {
+          is HeapInstance -> objectRecord.byteSize
+          is HeapObjectArray -> objectRecord.readByteSize()
+          is HeapPrimitiveArray -> objectRecord.readByteSize()
+          is HeapClass -> throw IllegalStateException(
+              "Unexpected class record $objectRecord"
+          )
+        }
+        sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
+      }
+    }
+
+    // Move retained sizes from dominated leaking instance to dominators leaking instances.
+    // Keep doing this until nothing moves.
+    var sizedMoved: Boolean
+    do {
+      sizedMoved = false
+      pathsToLeakingInstances.map { it.objectId }
+          .forEach { leakingInstanceId ->
+            val dominatorSlot = dominatedInstances.getSlot(leakingInstanceId)
+            if (dominatorSlot != -1) {
+              val dominator = dominatedInstances.getSlotValue(dominatorSlot)
+              val retainedSize = sizeByDominator.getValue(leakingInstanceId)
+              if (retainedSize > 0) {
+                sizeByDominator[leakingInstanceId] = 0
+                val dominatorRetainedSize = sizeByDominator.getValue(dominator)
+                sizeByDominator[dominator] = retainedSize + dominatorRetainedSize
+                sizedMoved = true
+              }
+            }
+          }
+    } while (sizedMoved)
+    dominatedInstances.release()
+    return pathsToLeakingInstances.map { pathNode ->
+      sizeByDominator[pathNode.objectId]!!
+    }
+  }
+
+  private fun FindLeakInput.buildLeakTraces(pathFindingResults: PathFindingResults): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
+    val retainedSizes = computeRetainedSizes(pathFindingResults)
+
+    listener.onAnalysisProgress(BUILDING_LEAK_TRACES)
+
+    val applicationLeaks = mutableListOf<ApplicationLeak>()
+    val libraryLeaks = mutableListOf<LibraryLeak>()
+
+    val deduplicatedPaths = deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)
+
+    deduplicatedPaths.forEachIndexed { index, pathNode ->
+      val shortestChildPath = mutableListOf<ChildNode>()
+
+      var node: ReferencePathNode = pathNode
+      while (node is ChildNode) {
+        shortestChildPath.add(0, node)
+        node = node.parent
+      }
+      val rootNode = node as RootNode
+
+      val leakTrace =
+        buildLeakTrace(graph, objectInspectors, rootNode, shortestChildPath)
+
+      val className =
+        recordClassName(graph.findObjectById(pathNode.objectId))
+
+      val firstLibraryLeakNode = if (rootNode is LibraryLeakNode) rootNode else
+        shortestChildPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
+
+      if (firstLibraryLeakNode != null) {
+        val matcher = firstLibraryLeakNode.matcher
+        libraryLeaks += LibraryLeak(
+            className, leakTrace, retainedSizes?.get(index), matcher.pattern, matcher.description
+        )
+      } else {
+        applicationLeaks += ApplicationLeak(className, leakTrace, retainedSizes?.get(index))
+      }
+    }
+    return applicationLeaks to libraryLeaks
+  }
+
+  private fun buildLeakTrace(
+    graph: HeapGraph,
+    objectInspectors: List<ObjectInspector>,
+    rootNode: RootNode,
+    shortestChildPath: List<ChildNode>
+  ): LeakTrace {
+    val shortestPath = shortestChildPath.toMutableList<ReferencePathNode>()
+    shortestPath.add(0, rootNode)
+
+    val leakReporters = shortestPath.map {
+      ObjectReporter(graph.findObjectById(it.objectId))
+    }
+
+    // Looping on inspectors first to get more cache hits.
+    objectInspectors.forEach { inspector ->
+      leakReporters.forEach { reporter ->
+        inspector.inspect(reporter)
+      }
+    }
+
+    val leakStatuses = computeLeakStatuses(rootNode, leakReporters)
+
+    val elements = shortestPath.mapIndexed { index, pathNode ->
+      val leakReporter = leakReporters[index]
+      val (leakStatus, leakStatusReason) = leakStatuses[index]
+      val reference =
+        if (index < shortestPath.lastIndex) (shortestPath[index + 1] as ChildNode).referenceFromParent else null
+      buildLeakElement(
+          graph, pathNode, reference, leakReporter.labels, leakStatus, leakStatusReason
+      )
+    }
+    return LeakTrace(elements)
+  }
+
+  private fun computeLeakStatuses(
+    rootNode: RootNode,
+    leakReporters: List<ObjectReporter>
+  ): List<Pair<LeakNodeStatus, String>> {
+    val lastElementIndex = leakReporters.size - 1
+
+    val rootNodeReporter = leakReporters[0]
+
+    rootNodeReporter.labels +=
+      "GC Root: " + when (rootNode.gcRoot) {
+        is ThreadObject -> "Thread object"
+        is JniGlobal -> "Global variable in native code"
+        is JniLocal -> "Local variable in native code"
+        is JavaFrame -> "Java local variable"
+        is NativeStack -> "Input or output parameters in native code"
+        is StickyClass -> "System class"
+        is ThreadBlock -> "Thread block"
+        is MonitorUsed -> "Monitor (anything that called the wait() or notify() methods, or that is synchronized.)"
+        is ReferenceCleanup -> "Reference cleanup"
+        is JniMonitor -> "Root JNI monitor"
+        else -> throw IllegalStateException("Unexpected gc root ${rootNode.gcRoot}")
+      }
+
+    var lastNotLeakingElementIndex = 0
+    var firstLeakingElementIndex = lastElementIndex
+
+    val leakStatuses = ArrayList<Pair<LeakNodeStatus, String>>()
+
+    for ((index, reporter) in leakReporters.withIndex()) {
+      val resolvedStatusPair = resolveStatus(reporter)
+      leakStatuses.add(resolvedStatusPair)
+      val (leakStatus, _) = resolvedStatusPair
+      if (leakStatus == NOT_LEAKING) {
+        lastNotLeakingElementIndex = index
+        // Reset firstLeakingElementIndex so that we never have
+        // firstLeakingElementIndex < lastNotLeakingElementIndex
+        firstLeakingElementIndex = lastElementIndex
+      } else if (firstLeakingElementIndex == lastElementIndex && leakStatus == LEAKING) {
+        firstLeakingElementIndex = index
+      }
+    }
+
+    val simpleClassNames = leakReporters.map { reporter ->
+      recordClassName(reporter.heapObject).lastSegment('.')
+    }
+
+    // First and last are always known.
+    for (i in 0..lastElementIndex) {
+      val (leakStatus, leakStatusReason) = leakStatuses[i]
+      if (i < lastNotLeakingElementIndex) {
+        val nextNotLeakingName = simpleClassNames[i + 1]
+        leakStatuses[i] = when (leakStatus) {
+          UNKNOWN -> NOT_LEAKING to "$nextNotLeakingName‚Üì is not leaking"
+          NOT_LEAKING -> NOT_LEAKING to "$nextNotLeakingName‚Üì is not leaking and $leakStatusReason"
+          LEAKING -> NOT_LEAKING to "$nextNotLeakingName‚Üì is not leaking. Conflicts with $leakStatusReason"
+        }
+      } else if (i > firstLeakingElementIndex) {
+        val previousLeakingName = simpleClassNames[i - 1]
+        leakStatuses[i] = when (leakStatus) {
+          UNKNOWN -> LEAKING to "$previousLeakingName‚Üë is leaking"
+          LEAKING -> LEAKING to "$previousLeakingName‚Üë is leaking and $leakStatusReason"
+          NOT_LEAKING -> throw IllegalStateException("Should never happen")
+        }
+      }
+    }
+    return leakStatuses
+  }
+
+  private fun resolveStatus(
+    reporter: ObjectReporter
+  ): Pair<LeakNodeStatus, String> {
+    var status = UNKNOWN
+    var reason = ""
+    if (reporter.notLeakingReasons.isNotEmpty()) {
+      status = NOT_LEAKING
+      reason = reporter.notLeakingReasons.joinToString(" and ")
+    }
+
+    val leakingReasons = reporter.leakingReasons + reporter.likelyLeakingReasons
+    if (leakingReasons.isNotEmpty()) {
+      // NOT_LEAKING wins over LEAKING
+      if (status == NOT_LEAKING) {
+        reason += ". Conflicts with ${leakingReasons.joinToString(" and ")}"
+      } else {
+        status = LEAKING
+        reason = leakingReasons.joinToString(" and ")
+      }
+    }
+    return status to reason
+  }
+
+  @Suppress("LongParameterList")
+  private fun buildLeakElement(
+    graph: HeapGraph,
+    node: ReferencePathNode,
+    reference: LeakReference?,
+    labels: Set<String>,
+    leakStatus: LeakNodeStatus,
+    leakStatusReason: String
+  ): LeakTraceElement {
+    val objectId = node.objectId
+
+    val graphRecord = graph.findObjectById(objectId)
+
+    val className = recordClassName(graphRecord)
+
+    val holderType = if (graphRecord is HeapClass) {
+      CLASS
+    } else if (graphRecord is HeapObjectArray || graphRecord is HeapPrimitiveArray) {
+      ARRAY
+    } else {
+      val instanceRecord = graphRecord.asInstance!!
+      if (instanceRecord.instanceClass.classHierarchy.any { it.name == Thread::class.java.name }) {
+        THREAD
+      } else {
+        OBJECT
+      }
+    }
+    return LeakTraceElement(reference, holderType, className, labels, leakStatus, leakStatusReason)
+  }
+
+  private fun recordClassName(
+    heap: HeapObject
+  ): String {
+    return when (heap) {
+      is HeapClass -> heap.name
+      is HeapInstance -> heap.instanceClassName
+      is HeapObjectArray -> heap.arrayClassName
+      is HeapPrimitiveArray -> heap.arrayClassName
+    }
+  }
+
+  private fun since(analysisStartNanoTime: Long): Long {
+    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
+  }
+}
diff --git a/shark/src/main/java/shark/LeakNodeStatus.kt b/shark/src/main/java/shark/LeakNodeStatus.kt
new file mode 100644
index 00000000..a8193c1c
--- /dev/null
+++ b/shark/src/main/java/shark/LeakNodeStatus.kt
@@ -0,0 +1,10 @@
+package shark
+
+enum class LeakNodeStatus {
+  /** The instance was needed and therefore expected to be reachable. */
+  NOT_LEAKING,
+  /** The instance was no longer needed and therefore expected to be unreachable. */
+  LEAKING,
+  /** No decision can be made about the provided instance. */
+  UNKNOWN;
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt b/shark/src/main/java/shark/LeakReference.kt
similarity index 82%
rename from leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
rename to shark/src/main/java/shark/LeakReference.kt
index 1673d2d4..58124214 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
+++ b/shark/src/main/java/shark/LeakReference.kt
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package leakcanary
+package shark
 
-import leakcanary.LeakTraceElement.Type
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
-import leakcanary.LeakTraceElement.Type.LOCAL
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import shark.LeakTraceElement.Type
+import shark.LeakTraceElement.Type.ARRAY_ENTRY
+import shark.LeakTraceElement.Type.INSTANCE_FIELD
+import shark.LeakTraceElement.Type.LOCAL
+import shark.LeakTraceElement.Type.STATIC_FIELD
 import java.io.Serializable
 
 /**
diff --git a/shark/src/main/java/shark/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
new file mode 100644
index 00000000..386765fb
--- /dev/null
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -0,0 +1,34 @@
+package shark
+
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.internal.renderToString
+import java.io.Serializable
+
+/**
+ * A chain of references that constitute the shortest strong reference path from a GC root to the
+ * leaking object. Fixing the leak usually means breaking one of the references in that chain.
+ */
+data class LeakTrace(
+  val elements: List<LeakTraceElement>
+) : Serializable {
+  val leakCauses = elements.filterIndexed { index, _ ->
+    elementMayBeLeakCause(index)
+  }
+
+  override fun toString(): String {
+    return "\n${renderToString()}\n"
+  }
+
+  fun elementMayBeLeakCause(index: Int): Boolean {
+    return when (elements[index].leakStatus) {
+      UNKNOWN -> true
+      NOT_LEAKING -> if (index < elements.lastIndex) {
+        elements[index + 1].leakStatus != NOT_LEAKING
+      } else {
+        false
+      }
+      else -> false
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt b/shark/src/main/java/shark/LeakTraceElement.kt
similarity index 51%
rename from leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
rename to shark/src/main/java/shark/LeakTraceElement.kt
index 940bf3fa..ff511769 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
+++ b/shark/src/main/java/shark/LeakTraceElement.kt
@@ -1,12 +1,13 @@
-package leakcanary
+package shark
 
-import leakcanary.internal.lastSegment
+import shark.internal.lastSegment
 import java.io.Serializable
 
 data class LeakTraceElement(
   /**
-   * Information about the reference that points to the next [LeakTraceElement] in the leak
-   * chain. Null if this is the last element in the leak trace, ie the leaking object.
+   * Information about the reference that points to the next [LeakTraceElement] in
+   * [LeakTrace.elements]. Null if this is the last element in the leak trace, ie the leaking
+   * object.
    */
   val reference: LeakReference?,
 
@@ -14,15 +15,14 @@ data class LeakTraceElement(
 
   val className: String,
 
-  /** If not null, there was no path that could exclude this element.  */
-  val exclusion: ExclusionDescription?,
-
   /**
-   * Ordered labels that were computed during analysis. A label provides
-   * extra information that helps understand the leak trace element.
+   * Labels that were computed during analysis. A label provides extra information that helps
+   * understand the leak trace element.
    */
-  val labels: List<String>,
-  val leakStatusAndReason: LeakNodeStatusAndReason
+  val labels: Set<String>,
+  val leakStatus: LeakNodeStatus,
+  val leakStatusReason: String
+
 ) : Serializable {
 
   /**
diff --git a/shark/src/main/java/shark/ObjectInspector.kt b/shark/src/main/java/shark/ObjectInspector.kt
new file mode 100644
index 00000000..f0621504
--- /dev/null
+++ b/shark/src/main/java/shark/ObjectInspector.kt
@@ -0,0 +1,42 @@
+package shark
+
+import shark.ObjectInspector.Companion.invoke
+
+/**
+ * Provides LeakCanary with insights about objects (classes, instances and arrays) found in the
+ * heap. [inspect] will be called for each object that LeakCanary wants to know more about.
+ * The implementation can then use the provided [ObjectReporter] to provide insights for that
+ * object.
+ *
+ * You can create a [ObjectInspector] from a lambda by calling [invoke].
+ */
+interface ObjectInspector {
+
+  /**
+   * @see [ObjectInspector]
+   */
+  fun inspect(reporter: ObjectReporter)
+
+  companion object {
+    /**
+     * Utility function to create a [ObjectInspector] from the passed in [block] lambda instead of
+     * using the anonymous `object : OnHeapAnalyzedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val inspector = ObjectInspector { reporter ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (ObjectReporter) -> Unit): ObjectInspector =
+      object : ObjectInspector {
+        override fun inspect(
+          reporter: ObjectReporter
+        ) {
+          block(reporter)
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/ObjectInspectors.kt b/shark/src/main/java/shark/ObjectInspectors.kt
new file mode 100644
index 00000000..195f93e8
--- /dev/null
+++ b/shark/src/main/java/shark/ObjectInspectors.kt
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.internal.KeyedWeakReferenceMirror
+
+/**
+ * A set of default [ObjectInspector]s that knows about common JDK objects.
+ */
+enum class ObjectInspectors : ObjectInspector {
+
+  KEYED_WEAK_REFERENCE {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      val graph = reporter.heapObject.graph
+      val references: List<KeyedWeakReferenceMirror> =
+        graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
+          val keyedWeakReferenceClass = graph.findClassByName("leakcanary.KeyedWeakReference")
+
+          val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
+            null
+          } else {
+            keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+          }
+
+          if (heapDumpUptimeMillis == null) {
+            SharkLog.d {
+                "leakcanary.KeyedWeakReference.heapDumpUptimeMillis field not found, " +
+                    "this must be a heap dump from an older version of LeakCanary."
+            }
+          }
+
+          val addedToContext: List<KeyedWeakReferenceMirror> = graph.instances
+              .filter { instance ->
+                val className = instance.instanceClassName
+                className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
+              }
+              .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
+              .filter { it.hasReferent }
+              .toList()
+          graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
+          addedToContext
+        }
+
+      val objectId = reporter.heapObject.objectId
+      references.forEach { ref ->
+        if (ref.referent.value == objectId) {
+          reporter.leakingReasons += "ObjectWatcher was watching this"
+          reporter.labels += "key = ${ref.key}"
+          if (ref.name.isNotEmpty()) {
+            reporter.labels += "name = ${ref.name}"
+          }
+          if (ref.watchDurationMillis != null) {
+            reporter.labels += "watchDurationMillis = ${ref.watchDurationMillis}"
+          }
+          if (ref.retainedDurationMillis != null) {
+            reporter.labels += "retainedDurationMillis = ${ref.retainedDurationMillis}"
+          }
+        }
+      }
+    }
+  },
+
+  CLASSLOADER {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(ClassLoader::class) {
+        notLeakingReasons += "A ClassLoader is never leaking"
+      }
+    }
+  },
+
+  CLASS {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      if (reporter.heapObject is HeapClass) {
+        reporter.notLeakingReasons += "a class is never leaking"
+      }
+    }
+  },
+
+  ANONYMOUS_CLASS {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      val heapObject = reporter.heapObject
+      if (heapObject is HeapInstance) {
+        val instanceClass = heapObject.instanceClass
+        if (instanceClass.name.matches(ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
+          val parentClassRecord = instanceClass.superclass!!
+          if (parentClassRecord.name == "java.lang.Object") {
+            try {
+              // This is an anonymous class implementing an interface. The API does not give access
+              // to the interfaces implemented by the class. We check if it's in the class path and
+              // use that instead.
+              val actualClass = Class.forName(instanceClass.name)
+              val interfaces = actualClass.interfaces
+              reporter.labels += if (interfaces.isNotEmpty()) {
+                val implementedInterface = interfaces[0]
+                "Anonymous class implementing ${implementedInterface.name}"
+              } else {
+                "Anonymous subclass of java.lang.Object"
+              }
+            } catch (ignored: ClassNotFoundException) {
+            }
+          } else {
+            // Makes it easier to figure out which anonymous class we're looking at.
+            reporter.labels += "Anonymous subclass of ${parentClassRecord.name}"
+          }
+        }
+      }
+    }
+  },
+
+  THREAD {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(Thread::class) { instance ->
+        val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
+        labels += "Thread name: '$threadName'"
+      }
+    }
+  };
+
+  companion object {
+    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
+    private val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
+    /** @see ObjectInspectors */
+    val jdkDefaults: List<ObjectInspector>
+      get() {
+        return values().toList()
+      }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/ObjectReporter.kt b/shark/src/main/java/shark/ObjectReporter.kt
new file mode 100644
index 00000000..850d968a
--- /dev/null
+++ b/shark/src/main/java/shark/ObjectReporter.kt
@@ -0,0 +1,62 @@
+package shark
+
+import shark.HeapObject.HeapInstance
+import kotlin.reflect.KClass
+
+/**
+ * Enables [ObjectInspector] implementations to provide insights on [heapObject], which is
+ * an object (class, instance or array) found in the heap.
+ *
+ * A given [ObjectReporter] only maps to one object in the heap, but is shared to many
+ * [ObjectInspector] implementations and accumulates insights.
+ */
+class ObjectReporter constructor(val heapObject: HeapObject) {
+
+  /**
+   * Labels that will be visible on the corresponding [heapObject] in the leak trace.
+   */
+  val labels = linkedSetOf<String>()
+
+  /**
+   * Reasons for which this object is expected to be unreachable (ie it's leaking).
+   *
+   * Only add reasons to this if you're 100% sure this object is leaking, otherwise add reasons to
+   * [likelyLeakingReasons]. The difference is that objects that are "likely leaking" are not
+   * considered to be leaking objects on which LeakCanary should compute the leak trace.
+   */
+  val leakingReasons = mutableSetOf<String>()
+
+  /**
+   * @see leakingReasons
+   */
+  val likelyLeakingReasons = mutableSetOf<String>()
+
+  /**
+   * Reasons for which this object is expected to be reachable (ie it's not leaking).
+   */
+  val notLeakingReasons = mutableSetOf<String>()
+
+  /**
+   * Runs [block] if [ObjectReporter.heapObject] is an instance of [expectedClass].
+   */
+  fun whenInstanceOf(
+    expectedClass: KClass<out Any>,
+    block: ObjectReporter.(HeapInstance) -> Unit
+  ) {
+    whenInstanceOf(expectedClass.java.name, block)
+  }
+
+  /**
+   * Runs [block] if [ObjectReporter.heapObject] is an instance of [expectedClassName].
+   */
+  fun whenInstanceOf(
+    expectedClassName: String,
+    block: ObjectReporter.(HeapInstance) -> Unit
+  ) {
+    val heapObject = heapObject
+    if (heapObject is HeapInstance && heapObject instanceOf expectedClassName) {
+      block(heapObject)
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/OnAnalysisProgressListener.kt b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
new file mode 100644
index 00000000..c2c99fef
--- /dev/null
+++ b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
@@ -0,0 +1,51 @@
+package shark
+
+/**
+ * Reports progress from the [HeapAnalyzer] as they occur, as [Step] values.
+ */
+interface OnAnalysisProgressListener {
+
+  // These steps are defined in the order in which they occur.
+  enum class Step {
+    PARSING_HEAP_DUMP,
+    FINDING_LEAKING_INSTANCES,
+    FINDING_PATHS_TO_LEAKING_OBJECTS,
+    FINDING_DOMINATORS,
+    COMPUTING_NATIVE_RETAINED_SIZE,
+    COMPUTING_RETAINED_SIZE,
+    BUILDING_LEAK_TRACES,
+    REPORTING_HEAP_ANALYSIS
+  }
+
+  fun onAnalysisProgress(step: Step)
+
+  companion object {
+
+    /**
+     * A no-op [OnAnalysisProgressListener]
+     */
+    val NO_OP = object : OnAnalysisProgressListener {
+      override fun onAnalysisProgress(step: Step) {
+      }
+    }
+
+    /**
+     * Utility function to create a [OnAnalysisProgressListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnAnalysisProgressListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnAnalysisProgressListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (Step) -> Unit): OnAnalysisProgressListener =
+      object : OnAnalysisProgressListener {
+        override fun onAnalysisProgress(step: Step) {
+          block(step)
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/ReferenceMatcher.kt b/shark/src/main/java/shark/ReferenceMatcher.kt
new file mode 100644
index 00000000..b758ae84
--- /dev/null
+++ b/shark/src/main/java/shark/ReferenceMatcher.kt
@@ -0,0 +1,39 @@
+package shark
+
+/**
+ * Used to pattern match known patterns of references in the heap, either to ignore them
+ * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+ */
+sealed class ReferenceMatcher {
+
+  /** The pattern that references will be matched against. */
+  abstract val pattern: ReferencePattern
+
+}
+
+/**
+ * [LibraryLeakReferenceMatcher] should be used to match references in library code that are
+ * known to create leaks and are beyond your control. The shortest path finder will only go
+ * through matching references after it has exhausted references that don't match, prioritizing
+ * finding an application leak over a known library leak. Library leaks will be reported as
+ * [LibraryLeak] instead of [ApplicationLeak].
+ */
+data class LibraryLeakReferenceMatcher(
+  override val pattern: ReferencePattern,
+  /**
+   * A description that conveys what we know about this library leak.
+   */
+  val description: String = "",
+  /**
+   * Whether the identified leak may exist in the provided [HeapGraph]. Defaults to true. If
+   * the heap dump comes from a VM that runs a different version of the library that doesn't
+   * have the leak, then this should return false.
+   */
+  val patternApplies: (HeapGraph) -> Boolean = { true }
+) : ReferenceMatcher()
+
+/**
+ * [IgnoredReferenceMatcher] should be used to match references that cannot ever create leaks. The
+ * shortest path finder will never go through matching references.
+ */
+class IgnoredReferenceMatcher(override val pattern: ReferencePattern) : ReferenceMatcher()
diff --git a/shark/src/main/java/shark/ReferencePattern.kt b/shark/src/main/java/shark/ReferencePattern.kt
new file mode 100644
index 00000000..eb17d5ed
--- /dev/null
+++ b/shark/src/main/java/shark/ReferencePattern.kt
@@ -0,0 +1,52 @@
+package shark
+
+import java.io.Serializable
+
+/**
+ * A pattern that will match references for a given [ReferenceMatcher].
+ */
+sealed class ReferencePattern : Serializable {
+
+  /**
+   * Matches local references held in the stack of frames of a given thread, identified by its name.
+   */
+  data class JavaLocalPattern(
+    val threadName: String
+  ) : ReferencePattern() {
+    override fun toString() = "local variable on thread $threadName"
+  }
+
+  /**
+   * Matches static field references, identified by [className] and [fieldName].
+   */
+  data class StaticFieldPattern(
+    val className: String,
+    val fieldName: String
+  ) : ReferencePattern() {
+    override fun toString() = "static field $className#$fieldName"
+  }
+
+  /**
+   * Matches instances field references, identified by [className] and [fieldName].
+   *
+   * Note: If [fieldName] is declared in a superclass it will still match for subclasses.
+   * This is to support overriding of rules for specific cases. If two [ReferenceMatcher] match for
+   * the same [fieldName] but for different [className] in a class hierarchy, then the closest
+   * class in the hierarchy wins.
+   */
+  data class InstanceFieldPattern(
+    val className: String,
+    val fieldName: String
+  ) : ReferencePattern() {
+    override fun toString() = "instance field $className#$fieldName"
+  }
+
+  /**
+   * Matches native global variables (also known as jni global gc roots) that reference
+   * Java objects. The class name will match against classes, instances and object arrays with
+   * a matching class name.
+   */
+  data class NativeGlobalVariablePattern(val className: String) : ReferencePattern() {
+    override fun toString() = "native global variable referencing $className"
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt
similarity index 68%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
rename to shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt
index 9ccacdab..8a3e3699 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt
@@ -1,22 +1,21 @@
-package leakcanary.internal
+package shark.internal
 
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.HeapValue.ObjectReference
+import shark.HeapObject.HeapInstance
+import shark.ValueHolder
+import shark.ValueHolder.ReferenceHolder
 
 internal class KeyedWeakReferenceMirror(
-  val referent: ObjectReference,
+  val referent: ReferenceHolder,
   val key: String,
     // The name field does not exist in pre 1.0 heap dumps.
   val name: String,
-  // 0 in pre 2.0 alpha 3 heap dumps
-  val watchDurationMillis: Long,
-    // The className field does not exist in pre 2.0 heap dumps.
-  val className: String,
+  // null in pre 2.0 alpha 3 heap dumps
+  val watchDurationMillis: Long?,
     // null in pre 2.0 alpha 3 heap dumps, -1 if the instance is not retained.
   val retainedDurationMillis: Long?
 ) {
 
-  val hasReferent = referent.value != 0L
+  val hasReferent = referent.value != ValueHolder.NULL_REFERENCE
 
   val isRetained = retainedDurationMillis == null || retainedDurationMillis != -1L
 
@@ -25,15 +24,15 @@ internal class KeyedWeakReferenceMirror(
     private const val UNKNOWN_LEGACY = "Unknown (legacy)"
 
     fun fromInstance(
-      weakRef: GraphInstanceRecord,
+      weakRef: HeapInstance,
       // Null for pre 2.0 alpha 3 heap dumps
       heapDumpUptimeMillis: Long?
     ): KeyedWeakReferenceMirror {
 
-      val keyWeakRefClassName = weakRef.className
+      val keyWeakRefClassName = weakRef.instanceClassName
       val watchDurationMillis = if (heapDumpUptimeMillis != null)
         heapDumpUptimeMillis - weakRef[keyWeakRefClassName, "watchUptimeMillis"]!!.value.asLong!!
-      else 0L
+      else null
 
       val retainedDurationMillis = if (heapDumpUptimeMillis != null) {
         val retainedUptimeMillis = weakRef[keyWeakRefClassName, "retainedUptimeMillis"]!!.value.asLong!!
@@ -43,14 +42,12 @@ internal class KeyedWeakReferenceMirror(
       val keyString = weakRef[keyWeakRefClassName, "key"]!!.value.readAsJavaString()!!
 
       val name = weakRef[keyWeakRefClassName, "name"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
-      val className = weakRef[keyWeakRefClassName, "className"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
       return KeyedWeakReferenceMirror(
           watchDurationMillis = watchDurationMillis,
           retainedDurationMillis = retainedDurationMillis,
-          referent = weakRef["java.lang.ref.Reference", "referent"]!!.value.actual as ObjectReference,
+          referent = weakRef["java.lang.ref.Reference", "referent"]!!.value.holder as ReferenceHolder,
           key = keyString,
-          name = name,
-          className = className
+          name = name
       )
     }
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
similarity index 62%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
rename to shark/src/main/java/shark/internal/LeakTraceRenderer.kt
index 476a011f..3603848d 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
+++ b/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
@@ -1,17 +1,16 @@
-package leakcanary.internal
+package shark.internal
 
-import leakcanary.LeakNodeStatus.LEAKING
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.LeakNodeStatusAndReason
-import leakcanary.LeakTrace
-import leakcanary.LeakTraceElement
-import leakcanary.LeakTraceElement.Holder.ARRAY
-import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.LeakTrace
+import shark.LeakTraceElement
+import shark.LeakTraceElement.Holder.ARRAY
+import shark.LeakTraceElement.Holder.THREAD
+import shark.LeakTraceElement.Type.STATIC_FIELD
 import java.util.Locale
 
-fun LeakTrace.renderToString(): String {
+internal fun LeakTrace.renderToString(): String {
   var result = "‚î¨"
 
   elements.forEachIndexed { index, element ->
@@ -29,11 +28,10 @@ fun LeakTrace.renderToString(): String {
       "$ZERO_WIDTH_SPACE     "
     }
 
-    val currentReachability = elements[index].leakStatusAndReason
-    result += "\n" + contentPrefix + "Leaking: " + currentReachability.renderToString()
-
-    if (element.exclusion != null) {
-      result += "\n" + contentPrefix + "Matches exclusion ${element.exclusion.matching}"
+    result += "\n" + contentPrefix + "Leaking: " + when (elements[index].leakStatus) {
+      UNKNOWN -> "UNKNOWN"
+      NOT_LEAKING -> "NO (${elements[index].leakStatusReason})"
+      LEAKING -> "YES (${elements[index].leakStatusReason})"
     }
 
     for (label in element.labels) {
@@ -48,14 +46,6 @@ fun LeakTrace.renderToString(): String {
   return result
 }
 
-private fun LeakNodeStatusAndReason.renderToString(): String {
-  return when (status) {
-    UNKNOWN -> "UNKNOWN"
-    NOT_LEAKING -> "NO ($reason)"
-    LEAKING -> "YES ($reason)"
-  }
-}
-
 private fun getNextElementString(
   leakTrace: LeakTrace,
   element: LeakTraceElement,
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
new file mode 100644
index 00000000..aeb344b8
--- /dev/null
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -0,0 +1,681 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark.internal
+
+import shark.GcRoot
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.ThreadObject
+import shark.HeapGraph
+import shark.HeapObject
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.IgnoredReferenceMatcher
+import shark.LeakReference
+import shark.LeakTraceElement.Type.ARRAY_ENTRY
+import shark.LeakTraceElement.Type.INSTANCE_FIELD
+import shark.LeakTraceElement.Type.LOCAL
+import shark.LeakTraceElement.Type.STATIC_FIELD
+import shark.LibraryLeakReferenceMatcher
+import shark.OnAnalysisProgressListener
+import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
+import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_LEAKING_OBJECTS
+import shark.PrimitiveType.INT
+import shark.ReferenceMatcher
+import shark.ReferencePattern
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.NativeGlobalVariablePattern
+import shark.ReferencePattern.StaticFieldPattern
+import shark.SharkLog
+import shark.ValueHolder
+import shark.internal.ReferencePathNode.ChildNode.LibraryLeakChildNode
+import shark.internal.ReferencePathNode.ChildNode.NormalNode
+import shark.internal.ReferencePathNode.LibraryLeakNode
+import shark.internal.ReferencePathNode.RootNode
+import shark.internal.ReferencePathNode.RootNode.LibraryLeakRootNode
+import shark.internal.ReferencePathNode.RootNode.NormalRootNode
+import shark.internal.hppc.LongLongScatterMap
+import shark.internal.hppc.LongScatterSet
+import java.util.ArrayDeque
+import java.util.Deque
+import java.util.LinkedHashMap
+
+/**
+ * Not thread safe.
+ *
+ * Finds the shortest path from leaking references to a gc root, first ignoring references
+ * identified as "to visit last" and then visiting them as needed if no path is
+ * found.
+ */
+@Suppress("TooManyFunctions")
+internal class PathFinder(
+  private val graph: HeapGraph,
+  private val listener: OnAnalysisProgressListener,
+  referenceMatchers: List<ReferenceMatcher>
+) {
+
+  class PathFindingResults(
+    val pathsToLeakingObjects: List<ReferencePathNode>,
+    val dominatedObjectIds: LongLongScatterMap
+  )
+
+  private class State(
+    val leakingObjectIds: Set<Long>,
+    val sizeOfObjectInstances: Int,
+    val computeRetainedHeapSize: Boolean
+  ) {
+
+    /** Set of objects to visit */
+    val toVisitQueue: Deque<ReferencePathNode> = ArrayDeque()
+
+    /**
+     * Objects to visit when [toVisitQueue] is empty. Should contain [JavaFrame] gc roots first,
+     * then [LibraryLeakNode].
+     */
+    val toVisitLastQueue: Deque<ReferencePathNode> = ArrayDeque()
+    /**
+     * Enables fast checking of whether a node is already in the queue.
+     */
+    val toVisitSet = HashSet<Long>()
+    val toVisitLastSet = HashSet<Long>()
+
+    val visitedSet = LongScatterSet()
+
+    /**
+     * Map of objects to their leaking dominator.
+     * If an object has been added to [toVisitSet] or [visitedSet] and is missing from
+     * [dominatedObjectIds] then it's considered "undomitable" ie it is dominated by gc roots
+     * and cannot be dominated by a leaking object.
+     */
+    val dominatedObjectIds = LongLongScatterMap()
+
+    val queuesNotEmpty: Boolean
+      get() = toVisitQueue.isNotEmpty() || toVisitLastQueue.isNotEmpty()
+  }
+
+  private val fieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
+  private val staticFieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
+  private val threadNameReferenceMatchers: Map<String, ReferenceMatcher>
+  private val jniGlobalReferenceMatchers: Map<String, ReferenceMatcher>
+
+  init {
+    val fieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
+    val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, ReferenceMatcher>>()
+    val threadNames = mutableMapOf<String, ReferenceMatcher>()
+    val jniGlobals = mutableMapOf<String, ReferenceMatcher>()
+
+    referenceMatchers.filter {
+      (it is IgnoredReferenceMatcher || (it is LibraryLeakReferenceMatcher && it.patternApplies(
+          graph
+      )))
+    }
+        .forEach { referenceMatcher ->
+          when (val pattern = referenceMatcher.pattern) {
+            is ReferencePattern.JavaLocalPattern -> {
+              threadNames[pattern.threadName] = referenceMatcher
+            }
+            is StaticFieldPattern -> {
+              val mapOrNull = staticFieldNameByClassName[pattern.className]
+              val map = if (mapOrNull != null) mapOrNull else {
+                val newMap = mutableMapOf<String, ReferenceMatcher>()
+                staticFieldNameByClassName[pattern.className] = newMap
+                newMap
+              }
+              map[pattern.fieldName] = referenceMatcher
+            }
+            is InstanceFieldPattern -> {
+              val mapOrNull = fieldNameByClassName[pattern.className]
+              val map = if (mapOrNull != null) mapOrNull else {
+                val newMap = mutableMapOf<String, ReferenceMatcher>()
+                fieldNameByClassName[pattern.className] = newMap
+                newMap
+              }
+              map[pattern.fieldName] = referenceMatcher
+            }
+            is NativeGlobalVariablePattern -> {
+              jniGlobals[pattern.className] = referenceMatcher
+            }
+          }
+        }
+    this.fieldNameByClassName = fieldNameByClassName
+    this.staticFieldNameByClassName = staticFieldNameByClassName
+    this.threadNameReferenceMatchers = threadNames
+    this.jniGlobalReferenceMatchers = jniGlobals
+  }
+
+  fun findPathsFromGcRoots(
+    leakingObjectIds: Set<Long>,
+    computeRetainedHeapSize: Boolean
+  ): PathFindingResults {
+    listener.onAnalysisProgress(FINDING_PATHS_TO_LEAKING_OBJECTS)
+
+    val sizeOfObjectInstances = determineSizeOfObjectInstances(graph)
+
+    val state = State(leakingObjectIds, sizeOfObjectInstances, computeRetainedHeapSize)
+
+    return state.findPathsFromGcRoots()
+  }
+
+  private fun determineSizeOfObjectInstances(graph: HeapGraph): Int {
+    val objectClass = graph.findClassByName("java.lang.Object")
+    return if (objectClass != null) {
+      // In Android 16 ClassDumpRecord.instanceSize for java.lang.Object can be 8 yet there are 0
+      // fields. This is likely because there is extra per instance data that isn't coming from
+      // fields in the Object class. See #1374
+      val objectClassFieldSize = objectClass.readFieldsByteSize()
+
+      // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
+      val sizeOfObjectOnArt = graph.identifierByteSize + INT.byteSize
+      if (objectClassFieldSize == sizeOfObjectOnArt) {
+        sizeOfObjectOnArt
+      } else {
+        0
+      }
+    } else {
+      0
+    }
+  }
+
+  private fun State.findPathsFromGcRoots(): PathFindingResults {
+    enqueueGcRoots()
+
+    val shortestPathsToLeakingObjects = mutableListOf<ReferencePathNode>()
+    visitingQueue@ while (queuesNotEmpty) {
+      val node = poll()
+
+      if (checkSeen(node)) {
+        throw IllegalStateException(
+            "Node $node objectId=${node.objectId} should not be enqueued when already visited or enqueued"
+        )
+      }
+
+      if (node.objectId in leakingObjectIds) {
+        shortestPathsToLeakingObjects.add(node)
+        // Found all refs, stop searching (unless computing retained size)
+        if (shortestPathsToLeakingObjects.size == leakingObjectIds.size) {
+          if (computeRetainedHeapSize) {
+            listener.onAnalysisProgress(FINDING_DOMINATORS)
+          } else {
+            break@visitingQueue
+          }
+        }
+      }
+
+      when (val heapObject = graph.findObjectById(node.objectId)) {
+        is HeapClass -> visitClassRecord(heapObject, node)
+        is HeapInstance -> visitInstance(heapObject, node)
+        is HeapObjectArray -> visitObjectArray(heapObject, node)
+      }
+    }
+    return PathFindingResults(shortestPathsToLeakingObjects, dominatedObjectIds)
+  }
+
+  private fun State.poll(): ReferencePathNode {
+    return if (!toVisitQueue.isEmpty()) {
+      val removedNode = toVisitQueue.poll()
+      toVisitSet.remove(removedNode.objectId)
+      removedNode
+    } else {
+      val removedNode = toVisitLastQueue.poll()
+      toVisitLastSet.remove(removedNode.objectId)
+      removedNode
+    }
+  }
+
+  private fun State.checkSeen(node: ReferencePathNode): Boolean {
+    val neverSeen = visitedSet.add(node.objectId)
+    return !neverSeen
+  }
+
+  private fun State.enqueueGcRoots() {
+    val gcRoots = sortedGcRoots()
+
+    val threadNames = mutableMapOf<HeapInstance, String>()
+    val threadsBySerialNumber = mutableMapOf<Int, Pair<HeapInstance, ThreadObject>>()
+    gcRoots.forEach { (objectRecord, gcRoot) ->
+      if (computeRetainedHeapSize) {
+        undominateWithSkips(gcRoot.id)
+      }
+      when (gcRoot) {
+        is ThreadObject -> {
+          threadsBySerialNumber[gcRoot.threadSerialNumber] = objectRecord.asInstance!! to gcRoot
+          enqueue(NormalRootNode(gcRoot.id, gcRoot))
+        }
+        is JavaFrame -> {
+          val (threadInstance, threadRoot) = threadsBySerialNumber.getValue(
+              gcRoot.threadSerialNumber
+          )
+          val threadName = threadNames[threadInstance] ?: {
+            val name = threadInstance[Thread::class, "name"]?.value?.readAsJavaString() ?: ""
+            threadNames[threadInstance] = name
+            name
+          }()
+          val referenceMatcher = threadNameReferenceMatchers[threadName]
+
+          if (referenceMatcher !is IgnoredReferenceMatcher) {
+            val rootNode = NormalRootNode(threadRoot.id, gcRoot)
+            // Unfortunately Android heap dumps do not include stack trace data, so
+            // JavaFrame.frameNumber is always -1 and we cannot know which method is causing the
+            // reference to be held.
+            val leakReference = LeakReference(LOCAL, "")
+
+            val childNode = if (referenceMatcher is LibraryLeakReferenceMatcher) {
+              LibraryLeakChildNode(gcRoot.id, rootNode, leakReference, referenceMatcher)
+            } else {
+              NormalNode(gcRoot.id, rootNode, leakReference)
+            }
+            enqueue(childNode)
+          }
+        }
+        is JniGlobal -> {
+          val referenceMatcher = when (objectRecord) {
+            is HeapClass -> jniGlobalReferenceMatchers[objectRecord.name]
+            is HeapInstance -> jniGlobalReferenceMatchers[objectRecord.instanceClassName]
+            is HeapObjectArray -> jniGlobalReferenceMatchers[objectRecord.arrayClassName]
+            is HeapPrimitiveArray -> jniGlobalReferenceMatchers[objectRecord.arrayClassName]
+          }
+          if (referenceMatcher !is IgnoredReferenceMatcher) {
+            if (referenceMatcher is LibraryLeakReferenceMatcher)
+              enqueue(LibraryLeakRootNode(gcRoot.id, gcRoot, referenceMatcher))
+          } else {
+            enqueue(NormalRootNode(gcRoot.id, gcRoot))
+          }
+        }
+        else -> enqueue(NormalRootNode(gcRoot.id, gcRoot))
+      }
+    }
+  }
+
+  /**
+   * Sorting GC roots to get stable shortest path
+   * Once sorted all ThreadObject Gc Roots are located before JavaLocalPattern Gc Roots.
+   * This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
+   * built before JavaFrames.
+   */
+  private fun sortedGcRoots(): List<Pair<HeapObject, GcRoot>> {
+    val rootClassName: (HeapObject) -> String = { graphObject ->
+      when (graphObject) {
+        is HeapClass -> {
+          graphObject.name
+        }
+        is HeapInstance -> {
+          graphObject.instanceClassName
+        }
+        is HeapObjectArray -> {
+          graphObject.arrayClassName
+        }
+        is HeapPrimitiveArray -> {
+          graphObject.arrayClassName
+        }
+      }
+    }
+
+    return graph.gcRoots
+        .filter { gcRoot ->
+          // GC roots sometimes reference objects that don't exist in the heap dump
+          // See https://github.com/square/leakcanary/issues/1516
+          graph.objectExists(gcRoot.id)
+        }
+        .map { graph.findObjectById(it.id) to it }
+        .sortedWith(Comparator { (graphObject1, root1), (graphObject2, root2) ->
+          // Sorting based on pattern name first. In reverse order so that ThreadObject is before JavaLocalPattern
+          val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
+          if (gcRootTypeComparison != 0) {
+            gcRootTypeComparison
+          } else {
+            rootClassName(graphObject1).compareTo(rootClassName(graphObject2))
+          }
+        })
+  }
+
+  private fun State.visitClassRecord(
+    heapClass: HeapClass,
+    parent: ReferencePathNode
+  ) {
+    val ignoredStaticFields = staticFieldNameByClassName[heapClass.name] ?: emptyMap()
+
+    for (staticField in heapClass.readStaticFields()) {
+      if (!staticField.value.isNonNullReference) {
+        continue
+      }
+
+      val fieldName = staticField.name
+      if (fieldName == "\$staticOverhead") {
+        continue
+      }
+
+      val objectId = staticField.value.asObjectId!!
+
+      if (computeRetainedHeapSize) {
+        undominateWithSkips(objectId)
+      }
+
+      val node = when (val referenceMatcher = ignoredStaticFields[fieldName]) {
+        null -> NormalNode(objectId, parent, LeakReference(STATIC_FIELD, fieldName))
+        is LibraryLeakReferenceMatcher -> LibraryLeakChildNode(
+            objectId, parent, LeakReference(STATIC_FIELD, fieldName), referenceMatcher
+        )
+        is IgnoredReferenceMatcher -> null
+      }
+      if (node != null) {
+        enqueue(node)
+      }
+    }
+  }
+
+  private fun State.visitInstance(
+    instance: HeapInstance,
+    parent: ReferencePathNode
+  ) {
+    val fieldReferenceMatchers = LinkedHashMap<String, ReferenceMatcher>()
+
+    instance.instanceClass.classHierarchy.forEach {
+      val referenceMatcherByField = fieldNameByClassName[it.name]
+      if (referenceMatcherByField != null) {
+        for ((fieldName, referenceMatcher) in referenceMatcherByField) {
+          if (!fieldReferenceMatchers.containsKey(fieldName)) {
+            fieldReferenceMatchers[fieldName] = referenceMatcher
+          }
+        }
+      }
+    }
+
+    val threadLocalValuesMatcher = if (instance instanceOf "java.lang.Thread") {
+      val threadName = instance["java.lang.Thread", "name"]?.value?.readAsJavaString()
+      threadNameReferenceMatchers[threadName]
+    } else null
+
+    val fieldNamesAndValues = instance.readFields()
+        .filter { it.value.isNonNullReference }
+        .toMutableList()
+
+    fieldNamesAndValues.sortBy { it.name }
+
+    fieldNamesAndValues.forEach { field ->
+      val objectId = field.value.asObjectId!!
+      if (computeRetainedHeapSize) {
+        updateDominatorWithSkips(parent.objectId, objectId)
+      }
+
+      val node =
+        if (threadLocalValuesMatcher != null && field.declaringClass.name == "java.lang.Thread" && field.name == "localValues") {
+          // Earlier Android versions store local references in a Thread.localValues field.
+          if (threadLocalValuesMatcher is LibraryLeakReferenceMatcher) {
+            LibraryLeakChildNode(
+                objectId, parent, LeakReference(INSTANCE_FIELD, field.name),
+                threadLocalValuesMatcher
+            )
+          } else {
+            null
+          }
+        } else when (val referenceMatcher = fieldReferenceMatchers[field.name]) {
+          null -> NormalNode(objectId, parent, LeakReference(INSTANCE_FIELD, field.name))
+          is LibraryLeakReferenceMatcher ->
+            LibraryLeakChildNode(
+                objectId, parent, LeakReference(INSTANCE_FIELD, field.name), referenceMatcher
+            )
+          is IgnoredReferenceMatcher -> null
+        }
+      if (node != null) {
+        enqueue(node)
+      }
+    }
+  }
+
+  private fun State.visitObjectArray(
+    objectArray: HeapObjectArray,
+    parent: ReferencePathNode
+  ) {
+    val record = objectArray.readRecord()
+    val nonNullElementIds = record.elementIds.filter { objectId ->
+      objectId != ValueHolder.NULL_REFERENCE && graph.objectExists(objectId)
+    }
+    nonNullElementIds.forEachIndexed { index, elementId ->
+      if (computeRetainedHeapSize) {
+        updateDominatorWithSkips(parent.objectId, elementId)
+      }
+      val name = index.toString()
+      enqueue(NormalNode(elementId, parent, LeakReference(ARRAY_ENTRY, name)))
+    }
+  }
+
+  @Suppress("ReturnCount")
+  private fun State.enqueue(
+    node: ReferencePathNode
+  ) {
+    if (node.objectId == ValueHolder.NULL_REFERENCE) {
+      return
+    }
+    if (visitedSet.contains(node.objectId)) {
+      return
+    }
+    // Already enqueued => shorter or equal distance
+    if (toVisitSet.contains(node.objectId)) {
+      return
+    }
+
+    val visitLast =
+      node is LibraryLeakNode ||
+          // We deprioritize thread objects because on Lollipop the thread local values are stored
+          // as a field.
+          (node is RootNode && node.gcRoot is ThreadObject) ||
+          (node is NormalNode && node.parent is RootNode && node.parent.gcRoot is JavaFrame)
+
+    if (toVisitLastSet.contains(node.objectId)) {
+      // Already enqueued => shorter or equal distance amongst library leak ref patterns.
+      if (visitLast) {
+        return
+      } else {
+        toVisitQueue.add(node)
+        toVisitSet.add(node.objectId)
+        val nodeToRemove = toVisitLastQueue.first { it.objectId == node.objectId }
+        toVisitLastQueue.remove(nodeToRemove)
+        toVisitLastSet.remove(node.objectId)
+        return
+      }
+    }
+
+    val isLeakingObject = node.objectId in leakingObjectIds
+
+    if (!isLeakingObject) {
+      val skip = when (val graphObject = graph.findObjectById(node.objectId)) {
+        is HeapClass -> false
+        is HeapInstance ->
+          when {
+            graphObject.isPrimitiveWrapper -> true
+            graphObject.instanceClassName == "java.lang.String" -> true
+            graphObject.instanceClass.instanceByteSize <= sizeOfObjectInstances -> true
+            else -> false
+          }
+        is HeapObjectArray -> when {
+          graphObject.isPrimitiveWrapperArray -> true
+          else -> false
+        }
+        is HeapPrimitiveArray -> true
+      }
+      if (skip) {
+        return
+      }
+    }
+    if (visitLast) {
+      toVisitLastQueue.add(node)
+      toVisitLastSet.add(node.objectId)
+    } else {
+      toVisitQueue.add(node)
+      toVisitSet.add(node.objectId)
+    }
+  }
+
+  private fun State.updateDominatorWithSkips(
+    parentObjectId: Long,
+    objectId: Long
+  ) {
+
+    when (val graphObject = graph.findObjectById(objectId)) {
+      is HeapClass -> {
+        undominate(objectId, false)
+      }
+      is HeapInstance -> {
+        // String internal array is never enqueued
+        if (graphObject.instanceClassName == "java.lang.String") {
+          updateDominator(parentObjectId, objectId, true)
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
+          if (valueId != null) {
+            updateDominator(parentObjectId, valueId, true)
+          }
+        } else {
+          updateDominator(parentObjectId, objectId, false)
+        }
+      }
+      is HeapObjectArray -> {
+        // Primitive wrapper array elements are never enqueued
+        if (graphObject.isPrimitiveWrapperArray) {
+          updateDominator(parentObjectId, objectId, true)
+          for (wrapperId in graphObject.readRecord().elementIds) {
+            updateDominator(parentObjectId, wrapperId, true)
+          }
+        } else {
+          updateDominator(parentObjectId, objectId, false)
+        }
+      }
+      else -> {
+        updateDominator(parentObjectId, objectId, false)
+      }
+    }
+  }
+
+  @Suppress("ComplexCondition")
+  private fun State.updateDominator(
+    parent: Long,
+    objectId: Long,
+    neverEnqueued: Boolean
+  ) {
+    val currentDominatorSlot = dominatedObjectIds.getSlot(objectId)
+    if (currentDominatorSlot == -1 && (objectId in visitedSet || objectId in toVisitSet || objectId in toVisitLastSet)) {
+      return
+    }
+    val parentDominatorSlot = dominatedObjectIds.getSlot(parent)
+
+    val parentIsRetainedObject = parent in leakingObjectIds
+
+    if (!parentIsRetainedObject && parentDominatorSlot == -1) {
+      // parent is not a retained instance and parent has no dominator, but it must have been
+      // visited therefore we know parent belongs to undominated.
+      if (neverEnqueued) {
+        visitedSet.add(objectId)
+      }
+
+      if (currentDominatorSlot != -1) {
+        dominatedObjectIds.remove(objectId)
+      }
+      return
+    }
+    val nextDominator =
+      if (parentIsRetainedObject) parent else dominatedObjectIds.getSlotValue(parentDominatorSlot)
+    if (currentDominatorSlot == -1) {
+      dominatedObjectIds[objectId] = nextDominator
+    } else {
+      val parentDominators = mutableListOf<Long>()
+      val currentDominators = mutableListOf<Long>()
+      var stop = false
+      var dominator: Long = nextDominator
+      while (!stop) {
+        parentDominators.add(dominator)
+        val nextDominatorSlot = dominatedObjectIds.getSlot(dominator)
+        if (nextDominatorSlot == -1) {
+          stop = true
+        } else {
+          dominator = dominatedObjectIds.getSlotValue(nextDominatorSlot)
+        }
+      }
+      stop = false
+      dominator = dominatedObjectIds.getSlotValue(currentDominatorSlot)
+      while (!stop) {
+        currentDominators.add(dominator)
+        val nextDominatorSlot = dominatedObjectIds.getSlot(dominator)
+        if (nextDominatorSlot == -1) {
+          stop = true
+        } else {
+          dominator = dominatedObjectIds.getSlotValue(nextDominatorSlot)
+        }
+      }
+
+      var sharedDominator: Long? = null
+      exit@ for (parentD in parentDominators) {
+        for (currentD in currentDominators) {
+          if (currentD == parentD) {
+            sharedDominator = currentD
+            break@exit
+          }
+        }
+      }
+      if (sharedDominator == null) {
+        dominatedObjectIds.remove(objectId)
+        if (neverEnqueued) {
+          visitedSet.add(objectId)
+        }
+      } else {
+        dominatedObjectIds[objectId] = sharedDominator
+      }
+    }
+  }
+
+  private fun State.undominateWithSkips(objectId: Long) {
+    when (val graphObject = graph.findObjectById(objectId)) {
+      is HeapClass -> {
+        undominate(objectId, false)
+      }
+      is HeapInstance -> {
+        // String internal array is never enqueued
+        if (graphObject.instanceClassName == "java.lang.String") {
+          undominate(objectId, true)
+          val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
+          if (valueId != null) {
+            undominate(valueId, true)
+          }
+        } else {
+          undominate(objectId, false)
+        }
+      }
+      is HeapObjectArray -> {
+        // Primitive wrapper array elements are never enqueued
+        if (graphObject.isPrimitiveWrapperArray) {
+          undominate(objectId, true)
+          for (wrapperId in graphObject.readRecord().elementIds) {
+            undominate(wrapperId, true)
+          }
+        } else {
+          undominate(objectId, false)
+        }
+      }
+      else -> {
+        undominate(objectId, false)
+      }
+    }
+  }
+
+  private fun State.undominate(
+    objectId: Long,
+    neverEnqueued: Boolean
+  ) {
+    dominatedObjectIds.remove(objectId)
+    if (neverEnqueued) {
+      visitedSet.add(objectId)
+    }
+  }
+}
diff --git a/shark/src/main/java/shark/internal/ReferencePathNode.kt b/shark/src/main/java/shark/internal/ReferencePathNode.kt
new file mode 100644
index 00000000..bf83a23b
--- /dev/null
+++ b/shark/src/main/java/shark/internal/ReferencePathNode.kt
@@ -0,0 +1,53 @@
+package shark.internal
+
+import shark.GcRoot
+import shark.LeakReference
+import shark.LibraryLeakReferenceMatcher
+
+internal sealed class ReferencePathNode {
+  abstract val objectId: Long
+
+  interface LibraryLeakNode {
+    val matcher: LibraryLeakReferenceMatcher
+  }
+
+  sealed class RootNode : ReferencePathNode() {
+    abstract val gcRoot: GcRoot
+
+    class LibraryLeakRootNode(
+      override val objectId: Long,
+      override val gcRoot: GcRoot,
+      override val matcher: LibraryLeakReferenceMatcher
+    ) : RootNode(), LibraryLeakNode
+
+    class NormalRootNode(
+      override val objectId: Long,
+      override val gcRoot: GcRoot
+    ) : RootNode()
+
+  }
+
+  sealed class ChildNode : ReferencePathNode() {
+
+    abstract val parent: ReferencePathNode
+
+    /**
+     * The reference from the parent to this node
+     */
+    abstract val referenceFromParent: LeakReference
+
+    class LibraryLeakChildNode(
+      override val objectId: Long,
+      override val parent: ReferencePathNode,
+      override val referenceFromParent: LeakReference,
+      override val matcher: LibraryLeakReferenceMatcher
+    ) : ChildNode(), LibraryLeakNode
+
+    class NormalNode(
+      override val objectId: Long,
+      override val parent: ReferencePathNode,
+      override val referenceFromParent: LeakReference
+    ) : ChildNode()
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt b/shark/src/main/java/shark/internal/Strings.kt
similarity index 97%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
rename to shark/src/main/java/shark/internal/Strings.kt
index 366f852f..d562cb08 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
+++ b/shark/src/main/java/shark/internal/Strings.kt
@@ -1,4 +1,4 @@
-package leakcanary.internal
+package shark.internal
 
 import java.nio.charset.Charset
 import java.security.MessageDigest
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/shark/src/test/java/shark/HeapAnalyzerTest.kt
similarity index 67%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
rename to shark/src/test/java/shark/HeapAnalyzerTest.kt
index 4665e516..f0b7a901 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
+++ b/shark/src/test/java/shark/HeapAnalyzerTest.kt
@@ -1,18 +1,14 @@
-package leakcanary.internal
-
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.LeakTraceElement.Type.LOCAL
-import leakcanary.LeakingInstance
-import leakcanary.NoPathToInstance
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.GcRoot.ThreadObject
+import shark.LeakTraceElement.Type.LOCAL
+import shark.LeakTraceElement.Type.STATIC_FIELD
+import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
 class HeapAnalyzerTest {
@@ -30,23 +26,23 @@ class HeapAnalyzerTest {
     hprofFile.writeSinglePathToInstance()
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(LeakingInstance::class.java)
+    assertThat(analysis.applicationLeaks[0]).isInstanceOf(Leak::class.java)
   }
 
   @Test fun pathToString() {
     hprofFile.writeSinglePathToString()
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.instanceClassName).isEqualTo("java.lang.String")
+    assertThat(leak.className).isEqualTo("java.lang.String")
   }
 
   @Test fun pathToCharArray() {
     hprofFile.writeSinglePathsToCharArrays(listOf("Hello"))
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.instanceClassName).isEqualTo("char[]")
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.className).isEqualTo("char[]")
   }
 
   // Two char arrays to ensure we keep going after finding the first one
@@ -61,7 +57,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
@@ -73,23 +69,22 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+    assertThat(analysis.applicationLeaks).isEmpty()
   }
 
   @Test fun weakRefCleared() {
     hprofFile.writeWeakReferenceCleared()
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisFailure>()
-    assertThat(analysis.exception.cause).isInstanceOf(IllegalStateException::class.java)
-        .hasMessage("No retained instances found in heap dump")
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    assertThat(analysis.applicationLeaks).isEmpty()
   }
 
   @Test fun failsNoRetainedKeys() {
     hprofFile.writeMultipleActivityLeaks(0)
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysis>()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(analysis).isInstanceOf(HeapAnalysisFailure::class.java)
+    assertThat(analysis.applicationLeaks).isEmpty()
   }
 
   @Test fun findMultipleLeaks() {
@@ -97,8 +92,8 @@ class HeapAnalyzerTest {
 
     val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    assertThat(leaks.retainedInstances).hasSize(5)
-        .hasOnlyElementsOfType(LeakingInstance::class.java)
+    assertThat(leaks.applicationLeaks).hasSize(5)
+        .hasOnlyElementsOfType(Leak::class.java)
   }
 
   @Test fun localVariableLeak() {
@@ -106,20 +101,32 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
     assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(LOCAL)
     assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
   }
 
+  @Test fun localVariableLeakShortestPathGoesLast() {
+    hprofFile.writeTwoPathJavaLocalShorterLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    println(analysis)
+
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements).hasSize(3)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(STATIC_FIELD)
+  }
+
   @Test fun threadFieldLeak() {
     hprofFile.dump {
       val threadClassId =
-        clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
+        clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
       val myThreadClassId = clazz(
-          className = "MyThread", superClassId = threadClassId,
-          fields = listOf("leaking" to ObjectReference::class)
+          className = "MyThread", superclassId = threadClassId,
+          fields = listOf("leaking" to ReferenceHolder::class)
       )
       val threadInstance =
         instance(myThreadClassId, listOf("Leaking" watchedInstance {}, string("Thread Name")))
@@ -132,7 +139,7 @@ class HeapAnalyzerTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("leaking")
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt b/shark/src/test/java/shark/HeapDumps.kt
similarity index 54%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
rename to shark/src/test/java/shark/HeapDumps.kt
index 9d61a1e4..86cc55d1 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
+++ b/shark/src/test/java/shark/HeapDumps.kt
@@ -1,23 +1,22 @@
-package leakcanary.internal
+package shark
 
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HprofWriter
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.ThreadObject
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
 fun File.writeWeakReferenceCleared() {
   HprofWriter.open(this)
       .helper {
-        keyedWeakReference("Leaking", ObjectReference(0))
+        keyedWeakReference(ReferenceHolder(0))
       }
 }
 
 fun File.writeNoPathToInstance() {
   HprofWriter.open(this)
       .helper {
-        keyedWeakReference("Leaking", instance(clazz("Leaking")))
+        keyedWeakReference(instance(clazz("Leaking")))
       }
 }
 
@@ -25,7 +24,7 @@ fun File.writeSinglePathToInstance() {
   HprofWriter.open(this)
       .helper {
         val leaking = instance(clazz("Leaking"))
-        keyedWeakReference("Leaking", leaking)
+        keyedWeakReference(leaking)
         clazz(
             "GcRoot", staticFields = listOf(
             "shortestPath" to leaking
@@ -38,7 +37,7 @@ fun File.writeSinglePathToString(value: String = "Hi") {
   HprofWriter.open(this)
       .helper {
         val leaking = string(value)
-        keyedWeakReference("java.lang.String", leaking)
+        keyedWeakReference(leaking)
         clazz(
             "GcRoot", staticFields = listOf(
             "shortestPath" to leaking
@@ -53,13 +52,13 @@ fun File.writeSinglePathsToCharArrays(values: List<String>) {
         val arrays = mutableListOf<Long>()
         values.forEach {
           val leaking = it.charArrayDump
-          keyedWeakReference("char[]", leaking)
+          keyedWeakReference(leaking)
           arrays.add(leaking.value)
         }
         clazz(
             className = "GcRoot",
             staticFields = listOf(
-                "arrays" to ObjectReference(
+                "arrays" to ReferenceHolder(
                     objectArray(clazz("char[][]"), arrays.toLongArray())
                 )
             )
@@ -72,9 +71,9 @@ fun File.writeTwoPathsToInstance() {
   HprofWriter.open(this)
       .helper {
         val leaking = instance(clazz("Leaking"))
-        keyedWeakReference("Leaking", leaking)
+        keyedWeakReference(leaking)
         val hasLeaking = instance(
-            clazz("HasLeaking", fields = listOf("leaking" to ObjectReference::class)),
+            clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
             fields = listOf(leaking)
         )
         clazz(
@@ -91,17 +90,17 @@ fun File.writeMultipleActivityLeaks(leakCount: Int) {
       .helper {
         val activityClassId = clazz(
             className = "android.app.Activity",
-            fields = listOf("mDestroyed" to BooleanValue::class)
+            fields = listOf("mDestroyed" to BooleanHolder::class)
         )
         val exampleActivityClassId = clazz(
-            superClassId = activityClassId,
+            superclassId = activityClassId,
             className = "com.example.ExampleActivity"
         )
         val activityArrayClassId = arrayClass("com.example.ExampleActivity")
 
-        val destroyedActivities = mutableListOf<ObjectReference>()
+        val destroyedActivities = mutableListOf<ReferenceHolder>()
         for (i in 1..leakCount) {
-          destroyedActivities.add(instance(exampleActivityClassId, listOf(BooleanValue(true))))
+          destroyedActivities.add(instance(exampleActivityClassId, listOf(BooleanHolder(true))))
         }
 
         clazz(
@@ -114,7 +113,7 @@ fun File.writeMultipleActivityLeaks(leakCount: Int) {
             )
         )
         destroyedActivities.forEach { instanceId ->
-          keyedWeakReference("com.example.ExampleActivity", instanceId)
+          keyedWeakReference(instanceId)
         }
       }
 }
@@ -125,8 +124,8 @@ fun File.writeJavaLocalLeak(
 ) {
   dump {
     val threadClassId =
-      clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
-    val myThreadClassId = clazz(className = threadClass, superClassId = threadClassId)
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
+    val myThreadClassId = clazz(className = threadClass, superclassId = threadClassId)
     val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
     gcRoot(
         ThreadObject(
@@ -137,4 +136,55 @@ fun File.writeJavaLocalLeak(
     val leaking = "Leaking" watchedInstance {}
     gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
   }
+}
+
+fun File.writeLollipopJavaLocalLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadLocalValues = "java.lang.ThreadLocal\$Values" instance {
+      field["table"] = objectArray("Leaking" watchedInstance {})
+    }
+
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class, "localValues" to ReferenceHolder::class))
+    val myThreadClassId = clazz(className = threadClass, superclassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName), threadLocalValues))
+    gcRoot(
+        ThreadObject(
+            id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+    )
+  }
+}
+
+fun File.writeTwoPathJavaLocalShorterLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
+    val myThreadClassId = clazz(className = threadClass, superclassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
+    gcRoot(
+        ThreadObject(
+            id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+    )
+
+    val leaking = "Leaking" watchedInstance {}
+    gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
+
+    val hasLeaking = instance(
+        clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
+        fields = listOf(leaking)
+    )
+    clazz(
+        "GcRoot", staticFields = listOf(
+        "longestPath" to hasLeaking
+    )
+    )
+  }
 }
\ No newline at end of file
diff --git a/shark/src/test/java/shark/HprofWriterHelper.kt b/shark/src/test/java/shark/HprofWriterHelper.kt
new file mode 100644
index 00000000..8f93245d
--- /dev/null
+++ b/shark/src/test/java/shark/HprofWriterHelper.kt
@@ -0,0 +1,298 @@
+package shark
+
+import shark.GcRoot.StickyClass
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.io.Closeable
+import java.io.File
+import java.util.UUID
+import kotlin.random.Random
+import kotlin.reflect.KClass
+
+class HprofWriterHelper constructor(
+  private val writer: HprofWriter
+) : Closeable {
+
+  private var lastId = 0L
+  private val id: Long
+    get() = ++lastId
+
+  private val weakRefKeyRandom = Random(42)
+
+  // Sequence identical for every test run
+  private val weakRefKey: String
+    get() =
+      UUID(weakRefKeyRandom.nextLong(), weakRefKeyRandom.nextLong()).toString()
+
+  private val typeSizes =
+    PrimitiveType.byteSizeByHprofType + (PrimitiveType.REFERENCE_HPROF_TYPE to writer.identifierByteSize)
+
+  private val classDumps = mutableMapOf<Long, ClassDumpRecord>()
+
+  private val objectClassId = clazz(superclassId = 0, className = "java.lang.Object")
+  private val objectArrayClassId = arrayClass("java.lang.Object")
+  private val stringClassId = clazz(
+      className = "java.lang.String", fields = listOf(
+      "value" to ReferenceHolder::class,
+      "count" to IntHolder::class
+  )
+  )
+
+  private val referenceClassId = clazz(
+      className = "java.lang.ref.Reference",
+      fields = listOf(
+          "referent" to ReferenceHolder::class
+      )
+  )
+
+  private val weakReferenceClassId = clazz(
+      className = "java.lang.ref.WeakReference",
+      superclassId = referenceClassId
+  )
+  private val keyedWeakReferenceClassId = clazz(
+      superclassId = weakReferenceClassId,
+      className = "leakcanary.KeyedWeakReference",
+      staticFields = listOf("heapDumpUptimeMillis" to LongHolder(30000)),
+      fields = listOf(
+          "key" to ReferenceHolder::class,
+          "name" to ReferenceHolder::class,
+          "watchUptimeMillis" to LongHolder::class,
+          "retainedUptimeMillis" to LongHolder::class
+      )
+  )
+
+  fun clazz(
+    className: String,
+    superclassId: Long = -1L, // -1 defaults to java.lang.Object
+    staticFields: List<Pair<String, ValueHolder>> = emptyList(),
+    fields: List<Pair<String, KClass<out ValueHolder>>> = emptyList()
+  ): Long {
+    val classNameRecord = StringRecord(id, className)
+    writer.write(classNameRecord)
+    val loadClass = LoadClassRecord(1, id, 1, classNameRecord.id)
+    writer.write(loadClass)
+
+    val staticFieldRecords = staticFields.map {
+      val fieldName = StringRecord(id, it.first)
+      writer.write(fieldName)
+      StaticFieldRecord(fieldName.id, typeOf(it.second), it.second)
+    }
+
+    val fieldRecords = fields.map {
+      val fieldName = StringRecord(id, it.first)
+      writer.write(fieldName)
+      FieldRecord(fieldName.id, typeOf(it.second))
+    }
+
+    var instanceSize = fieldRecords.sumBy {
+      typeSizes.getValue(it.type)
+    }
+
+    var nextUpId = if (superclassId == -1L) objectClassId else superclassId
+    while (nextUpId != 0L) {
+      val nextUp = classDumps[nextUpId]!!
+      instanceSize += nextUp.fields.sumBy {
+        typeSizes.getValue(it.type)
+      }
+      nextUpId = nextUp.superclassId
+    }
+    val classDump = ClassDumpRecord(
+        id = loadClass.id,
+        stackTraceSerialNumber = 1,
+        superclassId = if (superclassId == -1L) objectClassId else superclassId,
+        classLoaderId = 0,
+        signersId = 0,
+        protectionDomainId = 0,
+        instanceSize = instanceSize,
+        staticFields = staticFieldRecords,
+        fields = fieldRecords
+    )
+    classDumps[loadClass.id] = classDump
+    writer.write(classDump)
+    val gcRoot = StickyClass(classDump.id)
+    gcRoot(gcRoot)
+    return classDump.id
+  }
+
+  fun gcRoot(gcRoot: GcRoot) {
+    val gcRootRecord = GcRootRecord(gcRoot = gcRoot)
+    writer.write(gcRootRecord)
+  }
+
+  fun arrayClass(className: String): Long {
+    return clazz(className = "$className[]")
+  }
+
+  fun string(
+    string: String
+  ): ReferenceHolder {
+    return instance(
+        stringClassId,
+        fields = listOf(string.charArrayDump, IntHolder(string.length))
+    )
+  }
+
+  fun keyedWeakReference(
+    referentInstanceId: ReferenceHolder
+  ): ReferenceHolder {
+    val referenceKey = string(weakRefKey)
+    return instance(
+        classId = keyedWeakReferenceClassId,
+        fields = listOf(
+            referenceKey,
+            string(""),
+            LongHolder(5000),
+            LongHolder(20000),
+            ReferenceHolder(referentInstanceId.value)
+        )
+    )
+  }
+
+  fun instance(
+    classId: Long,
+    fields: List<ValueHolder> = emptyList()
+  ): ReferenceHolder {
+    val instanceDump = InstanceDumpRecord(
+        id = id,
+        stackTraceSerialNumber = 1,
+        classId = classId,
+        fieldValues = writer.valuesToBytes(fields)
+    )
+    writer.write(instanceDump)
+    return ReferenceHolder(instanceDump.id)
+  }
+
+  inner class InstanceAndClassDefinition {
+    val field = LinkedHashMap<String, ValueHolder>()
+    val staticField = LinkedHashMap<String, ValueHolder>()
+  }
+
+  inner class ClassDefinition {
+    val staticField = LinkedHashMap<String, ValueHolder>()
+  }
+
+  infix fun String.watchedInstance(block: InstanceAndClassDefinition.() -> Unit): ReferenceHolder {
+    val instance = this.instance(block)
+    keyedWeakReference(instance)
+    return instance
+  }
+
+  infix fun String.instance(block: InstanceAndClassDefinition.() -> Unit): ReferenceHolder {
+    val definition = InstanceAndClassDefinition()
+    block(definition)
+
+    val classFields = definition.field.map {
+      it.key to it.value::class
+    }
+
+    val staticFields = definition.staticField.map { it.key to it.value }
+
+    val instanceFields = definition.field.map { it.value }
+
+    return instance(clazz(this, fields = classFields, staticFields = staticFields), instanceFields)
+  }
+
+  infix fun String.clazz(block: ClassDefinition.() -> Unit): Long {
+    val definition = ClassDefinition()
+    block(definition)
+
+    val staticFields = definition.staticField.map { it.key to it.value }
+    return clazz(this, staticFields = staticFields)
+  }
+
+  val String.charArrayDump: ReferenceHolder
+    get() {
+      val arrayDump = CharArrayDump(id, 1, toCharArray())
+      writer.write(arrayDump)
+      return ReferenceHolder(arrayDump.id)
+    }
+
+  fun objectArray(
+    vararg elements: ReferenceHolder
+  ): ReferenceHolder {
+    return objectArrayOf(objectArrayClassId, *elements)
+  }
+
+  fun objectArrayOf(
+    classId: Long,
+    vararg elements: ReferenceHolder
+  ): ReferenceHolder {
+    return ReferenceHolder(objectArray(classId, elements.map { it.value }.toLongArray()))
+  }
+
+  fun objectArray(
+    classId: Long,
+    array: LongArray
+  ): Long {
+    val arrayDump = ObjectArrayDumpRecord(id, 1, classId, array)
+    writer.write(arrayDump)
+    return arrayDump.id
+  }
+
+  private fun typeOf(wrapper: ValueHolder): Int {
+    return when (wrapper) {
+      is ReferenceHolder -> PrimitiveType.REFERENCE_HPROF_TYPE
+      is BooleanHolder -> BOOLEAN.hprofType
+      is CharHolder -> CHAR.hprofType
+      is FloatHolder -> FLOAT.hprofType
+      is DoubleHolder -> DOUBLE.hprofType
+      is ByteHolder -> BYTE.hprofType
+      is ShortHolder -> SHORT.hprofType
+      is IntHolder -> INT.hprofType
+      is LongHolder -> LONG.hprofType
+    }
+  }
+
+  private fun typeOf(wrapperClass: KClass<out ValueHolder>): Int {
+    return when (wrapperClass) {
+      ReferenceHolder::class -> PrimitiveType.REFERENCE_HPROF_TYPE
+      BooleanHolder::class -> BOOLEAN.hprofType
+      CharHolder::class -> CHAR.hprofType
+      FloatHolder::class -> FLOAT.hprofType
+      DoubleHolder::class -> DOUBLE.hprofType
+      ByteHolder::class -> BYTE.hprofType
+      ShortHolder::class -> SHORT.hprofType
+      IntHolder::class -> INT.hprofType
+      LongHolder::class -> LONG.hprofType
+      else -> throw IllegalArgumentException("Unexpected class $wrapperClass")
+    }
+  }
+
+  override fun close() {
+    writer.close()
+  }
+}
+
+fun File.dump(block: HprofWriterHelper.() -> Unit) {
+  HprofWriterHelper(HprofWriter.open(this))
+      .use(block)
+}
+
+fun HprofWriter.helper(block: HprofWriterHelper.() -> Unit) {
+  HprofWriterHelper(this)
+      .use(block)
+}
\ No newline at end of file
diff --git a/shark/src/test/java/shark/LabelerTest.kt b/shark/src/test/java/shark/LabelerTest.kt
new file mode 100644
index 00000000..425d4caf
--- /dev/null
+++ b/shark/src/test/java/shark/LabelerTest.kt
@@ -0,0 +1,52 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+
+class LabelerTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun stringContentAsLabel() {
+    hprofFile.writeSinglePathToString("World")
+
+    val labeler = object : ObjectInspector {
+      override fun inspect(
+        reporter: ObjectReporter
+      ) {
+        reporter.whenInstanceOf("java.lang.String")  { instance ->
+          labels += "Hello ${instance.readAsJavaString()}"
+        }
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(labeler))
+
+    val leak = analysis.applicationLeaks[0]
+
+    assertThat(leak.leakTrace.elements.last().labels).contains("Hello World")
+  }
+
+  @Test fun threadNameLabel() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(ObjectInspectors.THREAD))
+
+    val leak = analysis.applicationLeaks[0]
+
+    assertThat(leak.leakTrace.elements.first().labels).contains("Thread name: 'kroutine'")
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/shark/src/test/java/shark/LeakStatusTest.kt
similarity index 52%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
rename to shark/src/test/java/shark/LeakStatusTest.kt
index 761db959..643d747a 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
+++ b/shark/src/test/java/shark/LeakStatusTest.kt
@@ -1,20 +1,15 @@
-package leakcanary.internal
-
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HprofGraph
-import leakcanary.LeakNodeStatus.LEAKING
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.LeakTraceElementReporter
-import leakcanary.LeakTraceInspector
-import leakcanary.LeakingInstance
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
 import java.io.File
 
 class LeakStatusTest {
@@ -28,14 +23,16 @@ class LeakStatusTest {
     hprofFile = testFolder.newFile("temp.hprof")
   }
 
-  @Test fun gcRootsNotLeaking() {
+  @Test fun gcRootClassNotLeaking() {
     hprofFile.writeSinglePathToInstance()
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        objectInspectors = listOf(ObjectInspectors.CLASS)
+    )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
   }
 
   @Test fun leakingInstanceLeaking() {
@@ -43,9 +40,9 @@ class LeakStatusTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(LEAKING)
   }
 
   @Test fun defaultsToUnknown() {
@@ -59,9 +56,9 @@ class LeakStatusTest {
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(UNKNOWN)
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(UNKNOWN)
   }
 
   @Test fun inspectorNotLeaking() {
@@ -74,11 +71,11 @@ class LeakStatusTest {
     }
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        leakTraceInspectors = listOf(notLeaking("Class1"))
+        objectInspectors = listOf(notLeakingInstance("Class1"))
     )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
   }
 
   @Test fun inspectorLeaking() {
@@ -92,11 +89,11 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Class1"))
+          objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
   }
 
   @Test fun leakingWinsUnknown() {
@@ -110,11 +107,11 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Class1"))
+          objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
   }
 
   @Test fun notLeakingWhenNextIsNotLeaking() {
@@ -132,11 +129,11 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(notLeaking("Class3"))
+          objectInspectors = listOf(notLeakingInstance("Class3"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
   }
 
   @Test fun leakingWhenPreviousIsLeaking() {
@@ -154,48 +151,12 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Class1"))
-      )
-
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.status).isEqualTo(LEAKING)
-  }
-
-  @Test fun notLeakingWinsConflicts() {
-    hprofFile.dump {
-      "GcRoot" clazz {
-        staticField["staticField1"] = "Class1" instance {
-          field["field1"] = "Class2" instance {
-            field["field2"] = "Class3" instance {
-              field["field3"] = "Leaking" watchedInstance {}
-            }
-          }
-        }
-      }
-    }
-
-    val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
-              notLeaking("Class3"), leaking("Class1")
-          )
+          objectInspectors = listOf(leakingInstance("Class1"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[0].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[0].leakStatusAndReason.reason).isEqualTo("it's a GC root")
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
-        "Class2‚Üì is not leaking. Conflicts with Class1 is leaking"
-    )
-    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.reason).isEqualTo(
-        "Class3‚Üì is not leaking"
-    )
-    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[3].leakStatusAndReason.reason).isEqualTo(
-        "Class3 is not leaking"
-    )
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
   }
 
   @Test fun middleUnknown() {
@@ -213,44 +174,46 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
-              notLeaking("Class1"), leaking("Class3")
+          objectInspectors = listOf(
+              notLeakingInstance("Class1"), leakingInstance("Class3")
           )
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[2].leakStatusAndReason.status).isEqualTo(UNKNOWN)
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements[2].leakStatus).isEqualTo(UNKNOWN)
   }
 
-  @Test fun gcRootsNotLeakingConflictingWithInspector() {
+  @Test fun gcRootClassNotLeakingConflictingWithInspector() {
     hprofFile.writeSinglePathToInstance()
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("GcRoot"))
+          objectInspectors = listOf(leakingClass("GcRoot"), ObjectInspectors.CLASS)
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
-        "it's a GC root. Conflicts with GcRoot is leaking"
+    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.first().leakStatusReason).isEqualTo(
+        "a class is never leaking. Conflicts with GcRoot is leaking"
     )
   }
 
-  @Test fun gcRootsNotLeakingAgreesWithInspector() {
+  @Test fun gcRootClassNotLeakingAgreesWithInspector() {
     hprofFile.writeSinglePathToInstance()
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(notLeaking("GcRoot"))
+          objectInspectors = listOf(notLeakingClass("GcRoot"), ObjectInspectors.CLASS)
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    println(analysis)
+
+    val leak = analysis.applicationLeaks[0]
 
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements.first().leakStatusAndReason.reason).isEqualTo(
-        "it's a GC root and GcRoot is not leaking"
+    assertThat(leak.leakTrace.elements.first().leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.first().leakStatusReason).isEqualTo(
+        "GcRoot is not leaking and a class is never leaking"
     )
   }
 
@@ -258,13 +221,13 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(notLeaking("Leaking"))
+          objectInspectors = listOf(notLeakingInstance("Leaking"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
-        "RefWatcher was watching this. Conflicts with Leaking is not leaking"
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatusReason).isEqualTo(
+        "Leaking is not leaking. Conflicts with ObjectWatcher was watching this"
     )
   }
 
@@ -272,13 +235,13 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Leaking"))
+          objectInspectors = listOf(leakingInstance("Leaking"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.status).isEqualTo(LEAKING)
-    assertThat(leak.leakTrace.elements.last().leakStatusAndReason.reason).isEqualTo(
-        "RefWatcher was watching this and Leaking is leaking"
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements.last().leakStatus).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements.last().leakStatusReason).isEqualTo(
+        "Leaking is leaking and ObjectWatcher was watching this"
     )
   }
 
@@ -293,14 +256,14 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
-              notLeaking("Class1"), leaking("Class1")
+          objectInspectors = listOf(
+              notLeakingInstance("Class1"), leakingInstance("Class1")
           )
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
         "Class1 is not leaking. Conflicts with Class1 is leaking"
     )
   }
@@ -316,15 +279,15 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
-              notLeaking("Class1"), notLeaking("Class1")
+          objectInspectors = listOf(
+              notLeakingInstance("Class1"), notLeakingInstance("Class1")
           )
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(NOT_LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
-        "Class1 is not leaking and Class1 is not leaking"
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(NOT_LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
+        "Class1 is not leaking"
     )
   }
 
@@ -339,13 +302,13 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(leaking("Class1"), leaking("Class1"))
+          objectInspectors = listOf(leakingInstance("Class1"), leakingInstance("Class1"))
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.status).isEqualTo(LEAKING)
-    assertThat(leak.leakTrace.elements[1].leakStatusAndReason.reason).isEqualTo(
-        "Class1 is leaking and Class1 is leaking"
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements[1].leakStatus).isEqualTo(LEAKING)
+    assertThat(leak.leakTrace.elements[1].leakStatusReason).isEqualTo(
+        "Class1 is leaking"
     )
   }
 
@@ -364,12 +327,12 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(
-              notLeaking("Class1"), leaking("Class3")
+          objectInspectors = listOf(
+              notLeakingInstance("Class1"), leakingInstance("Class3")
           )
       )
 
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    val leak = analysis.applicationLeaks[0]
     assertThat(leak.leakTrace.elementMayBeLeakCause(0)).isFalse()
     assertThat(leak.leakTrace.elementMayBeLeakCause(1)).isTrue()
     assertThat(leak.leakTrace.elementMayBeLeakCause(2)).isTrue()
@@ -461,37 +424,53 @@ class LeakStatusTest {
     assertThat(hash1).isEqualTo(hash2)
   }
 
-  private fun notLeaking(className: String): LeakTraceInspector {
-    return object : LeakTraceInspector {
+  private fun notLeakingInstance(className: String): ObjectInspector {
+    return object : ObjectInspector {
       override fun inspect(
-        graph: HprofGraph,
-        leakTrace: List<LeakTraceElementReporter>
+        reporter: ObjectReporter
       ) {
-        leakTrace.forEach { reporter ->
-          val record = reporter.objectRecord
-          if (record is GraphInstanceRecord && record.className == className) {
-            reporter.reportNotLeaking("$className is not leaking")
-          } else if (record is GraphClassRecord && record.name == className) {
-            reporter.reportNotLeaking("$className is not leaking")
-          }
+        val record = reporter.heapObject
+        if (record is HeapInstance && record.instanceClassName == className) {
+          reporter.notLeakingReasons += "$className is not leaking"
         }
       }
     }
   }
 
-  private fun leaking(className: String): LeakTraceInspector {
-    return object : LeakTraceInspector {
+  private fun leakingInstance(className: String): ObjectInspector {
+    return object : ObjectInspector {
       override fun inspect(
-        graph: HprofGraph,
-        leakTrace: List<LeakTraceElementReporter>
+        reporter: ObjectReporter
       ) {
-        leakTrace.forEach { reporter ->
-          val record = reporter.objectRecord
-          if (record is GraphInstanceRecord && record.className == className) {
-            reporter.reportLeaking("$className is leaking")
-          } else if (record is GraphClassRecord && record.name == className) {
-            reporter.reportLeaking("$className is leaking")
-          }
+        val record = reporter.heapObject
+        if (record is HeapInstance && record.instanceClassName == className) {
+          reporter.leakingReasons += "$className is leaking"
+        }
+      }
+    }
+  }
+
+  private fun notLeakingClass(className: String): ObjectInspector {
+    return object : ObjectInspector {
+      override fun inspect(
+        reporter: ObjectReporter
+      ) {
+        val record = reporter.heapObject
+        if (record is HeapClass && record.name == className) {
+          reporter.notLeakingReasons += "$className is not leaking"
+        }
+      }
+    }
+  }
+
+  private fun leakingClass(className: String): ObjectInspector {
+    return object : ObjectInspector {
+      override fun inspect(
+        reporter: ObjectReporter
+      ) {
+        val record = reporter.heapObject
+        if (record is HeapClass && record.name == className) {
+          reporter.leakingReasons += "$className is leaking"
         }
       }
     }
@@ -503,9 +482,12 @@ class LeakStatusTest {
   ): String {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(notLeaking(notLeaking), leaking(leaking))
+          objectInspectors = listOf(notLeakingInstance(notLeaking), leakingInstance(leaking))
       )
-    val leak = analysis.retainedInstances[0] as LeakingInstance
+    require(analysis.applicationLeaks.size == 1) {
+      "Expecting 1 retained instance in ${analysis.applicationLeaks}"
+    }
+    val leak = analysis.applicationLeaks[0]
     return leak.groupHash
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/shark/src/test/java/shark/LeakTraceRendererTest.kt
similarity index 52%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
rename to shark/src/test/java/shark/LeakTraceRendererTest.kt
index 0bcdfaeb..a946699b 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
+++ b/shark/src/test/java/shark/LeakTraceRendererTest.kt
@@ -1,18 +1,12 @@
-package leakcanary.internal
-
-import leakcanary.Exclusion
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HprofGraph
-import leakcanary.LeakTraceElementReporter
-import leakcanary.LeakTraceInspector
-import leakcanary.LeakingInstance
-import leakcanary.forEachInstanceOf
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.internal.renderToString
 import java.io.File
 
 class LeakTraceRendererTest {
@@ -38,11 +32,48 @@ class LeakTraceRendererTest {
     analysis renders """
     ‚î¨
     ‚îú‚îÄ GcRoot
-    ‚îÇ    Leaking: NO (it's a GC root)
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    GC Root: System class
     ‚îÇ    ‚Üì static GcRoot.leak
     ‚îÇ                    ~~~~
     ‚ï∞‚Üí Leaking
-    ‚Äã     Leaking: YES (RefWatcher was watching this)
+    ‚Äã     Leaking: YES (ObjectWatcher was watching this)
+    ‚Äã     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    ‚Äã     watchDurationMillis = 25000
+    ‚Äã     retainedDurationMillis = 10000
+    """
+  }
+
+  @Test fun rendersDeobfuscatedSimplePath() {
+    hprofFile.dump {
+      "a" clazz {
+        staticField["b.c"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val proguardMappingText = """
+            GcRoot -> a:
+                type leak -> b.c
+        """.trimIndent()
+
+    val reader = ProguardMappingReader(proguardMappingText.byteInputStream(Charsets.UTF_8))
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        proguardMapping = reader.readProguardMapping()
+    )
+
+    analysis renders """
+    ‚î¨
+    ‚îú‚îÄ GcRoot
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    GC Root: System class
+    ‚îÇ    ‚Üì static GcRoot.leak
+    ‚îÇ                    ~~~~
+    ‚ï∞‚Üí Leaking
+    ‚Äã     Leaking: YES (ObjectWatcher was watching this)
+    ‚Äã     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    ‚Äã     watchDurationMillis = 25000
+    ‚Äã     retainedDurationMillis = 10000
     """
   }
 
@@ -59,13 +90,12 @@ class LeakTraceRendererTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakTraceInspectors = listOf(object : LeakTraceInspector {
+          objectInspectors = listOf(object : ObjectInspector {
             override fun inspect(
-              graph: HprofGraph,
-              leakTrace: List<LeakTraceElementReporter>
+              reporter: ObjectReporter
             ) {
-              leakTrace.forEachInstanceOf("ClassB") {
-                reportLeaking("because reasons")
+              reporter.whenInstanceOf("ClassB") {
+                leakingReasons += "because reasons"
               }
             }
           })
@@ -74,18 +104,16 @@ class LeakTraceRendererTest {
     analysis renders """
     ‚î¨
     ‚îú‚îÄ GcRoot
-    ‚îÇ    Leaking: NO (it's a GC root)
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    GC Root: System class
     ‚îÇ    ‚Üì static GcRoot.instanceA
     ‚îÇ                    ~~~~~~~~~
     ‚îú‚îÄ ClassA
     ‚îÇ    Leaking: UNKNOWN
     ‚îÇ    ‚Üì ClassA.instanceB
     ‚îÇ             ~~~~~~~~~
-    ‚îú‚îÄ ClassB
-    ‚îÇ    Leaking: YES (because reasons)
-    ‚îÇ    ‚Üì ClassB.leak
-    ‚ï∞‚Üí Leaking
-    ‚Äã     Leaking: YES (RefWatcher was watching this)
+    ‚ï∞‚Üí ClassB
+    ‚Äã     Leaking: YES (because reasons)
     """
   }
 
@@ -97,14 +125,11 @@ class LeakTraceRendererTest {
     }
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        leakTraceInspectors = listOf(object : LeakTraceInspector {
+        objectInspectors = listOf(object : ObjectInspector {
           override fun inspect(
-            graph: HprofGraph,
-            leakTrace: List<LeakTraceElementReporter>
+            reporter: ObjectReporter
           ) {
-            leakTrace.forEach { reporter ->
-              reporter.addLabel("¬Ø\\_(„ÉÑ)_/¬Ø")
-            }
+            reporter.labels += "¬Ø\\_(„ÉÑ)_/¬Ø"
           }
 
         })
@@ -113,13 +138,17 @@ class LeakTraceRendererTest {
     analysis renders """
     ‚î¨
     ‚îú‚îÄ GcRoot
-    ‚îÇ    Leaking: NO (it's a GC root)
+    ‚îÇ    Leaking: UNKNOWN
     ‚îÇ    ¬Ø\_(„ÉÑ)_/¬Ø
+    ‚îÇ    GC Root: System class
     ‚îÇ    ‚Üì static GcRoot.leak
     ‚îÇ                    ~~~~
     ‚ï∞‚Üí Leaking
-    ‚Äã     Leaking: YES (RefWatcher was watching this)
+    ‚Äã     Leaking: YES (ObjectWatcher was watching this)
     ‚Äã     ¬Ø\_(„ÉÑ)_/¬Ø
+    ‚Äã     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    ‚Äã     watchDurationMillis = 25000
+    ‚Äã     retainedDurationMillis = 10000
     """
   }
 
@@ -134,22 +163,27 @@ class LeakTraceRendererTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          exclusions = listOf(Exclusion(type = InstanceFieldExclusion("ClassA", "leak")))
+          referenceMatchers = listOf(
+              LibraryLeakReferenceMatcher(pattern = InstanceFieldPattern("ClassA", "leak"))
+          )
       )
 
-    analysis renders """
+    analysis rendersLibraryLeak """
     ‚î¨
     ‚îú‚îÄ GcRoot
-    ‚îÇ    Leaking: NO (it's a GC root)
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    GC Root: System class
     ‚îÇ    ‚Üì static GcRoot.instanceA
     ‚îÇ                    ~~~~~~~~~
     ‚îú‚îÄ ClassA
     ‚îÇ    Leaking: UNKNOWN
-    ‚îÇ    Matches exclusion field ClassA#leak
     ‚îÇ    ‚Üì ClassA.leak
     ‚îÇ             ~~~~
     ‚ï∞‚Üí Leaking
-    ‚Äã     Leaking: YES (RefWatcher was watching this)
+    ‚Äã     Leaking: YES (ObjectWatcher was watching this)
+    ‚Äã     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    ‚Äã     watchDurationMillis = 25000
+    ‚Äã     retainedDurationMillis = 10000
     """
   }
 
@@ -166,7 +200,8 @@ class LeakTraceRendererTest {
     analysis renders """
     ‚î¨
     ‚îú‚îÄ GcRoot
-    ‚îÇ    Leaking: NO (it's a GC root)
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    GC Root: System class
     ‚îÇ    ‚Üì static GcRoot.array
     ‚îÇ                    ~~~~~
     ‚îú‚îÄ java.lang.Object[]
@@ -174,7 +209,10 @@ class LeakTraceRendererTest {
     ‚îÇ    ‚Üì array Object[].[0]
     ‚îÇ                     ~~~
     ‚ï∞‚Üí Leaking
-    ‚Äã     Leaking: YES (RefWatcher was watching this)
+    ‚Äã     Leaking: YES (ObjectWatcher was watching this)
+    ‚Äã     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    ‚Äã     watchDurationMillis = 25000
+    ‚Äã     retainedDurationMillis = 10000
     """
   }
 
@@ -187,17 +225,26 @@ class LeakTraceRendererTest {
     analysis renders """
     ‚î¨
     ‚îú‚îÄ MyThread
-    ‚îÇ    Leaking: NO (it's a GC root)
+    ‚îÇ    Leaking: UNKNOWN
+    ‚îÇ    GC Root: Java local variable
     ‚îÇ    ‚Üì thread MyThread.<Java Local>
     ‚îÇ                      ~~~~~~~~~~~~
     ‚ï∞‚Üí Leaking
-    ‚Äã     Leaking: YES (RefWatcher was watching this)
+    ‚Äã     Leaking: YES (ObjectWatcher was watching this)
+    ‚Äã     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    ‚Äã     watchDurationMillis = 25000
+    ‚Äã     retainedDurationMillis = 10000
     """
   }
 
   private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
-    val leak = retainedInstances[0] as LeakingInstance
-    assertThat(leak.leakTrace.renderToString()).isEqualTo(
+    assertThat(applicationLeaks[0].leakTrace.renderToString()).isEqualTo(
+        expectedString.trimIndent()
+    )
+  }
+
+  private infix fun HeapAnalysisSuccess.rendersLibraryLeak(expectedString: String) {
+    assertThat(libraryLeaks[0].leakTrace.renderToString()).isEqualTo(
         expectedString.trimIndent()
     )
   }
diff --git a/shark/src/test/java/shark/ReferenceMatcherTest.kt b/shark/src/test/java/shark/ReferenceMatcherTest.kt
new file mode 100644
index 00000000..f9831986
--- /dev/null
+++ b/shark/src/test/java/shark/ReferenceMatcherTest.kt
@@ -0,0 +1,157 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import shark.GcRoot.JniGlobal
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.NativeGlobalVariablePattern
+import shark.ReferencePattern.StaticFieldPattern
+import shark.ValueHolder.ReferenceHolder
+import java.io.File
+import java.lang.ref.WeakReference
+
+class ReferenceMatcherTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+  private lateinit var hprofFile: File
+
+  @Before
+  fun setUp() {
+    hprofFile = testFolder.newFile("temp.hprof")
+  }
+
+  @Test fun shortestPathExcluded() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+            LibraryLeakReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath"))
+        )
+    )
+
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements).hasSize(3)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("HasLeaking")
+    assertThat(leak.leakTrace.elements[1].reference!!.name).isEqualTo("leaking")
+    assertThat(leak.leakTrace.elements[2].className).isEqualTo("Leaking")
+  }
+
+  @Test fun allPathsExcluded_ShortestWins() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val expectedMatcher = LibraryLeakReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+            expectedMatcher,
+            LibraryLeakReferenceMatcher(InstanceFieldPattern("HasLeaking", "leaking"))
+        )
+    )
+
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(expectedMatcher.pattern)
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
+  @Test fun noPathToInstanceNeverReachable() {
+    hprofFile.writeTwoPathsToInstance()
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+            IgnoredReferenceMatcher(StaticFieldPattern("GcRoot", "shortestPath")),
+            IgnoredReferenceMatcher(InstanceFieldPattern("HasLeaking", "leaking"))
+        )
+    )
+    assertThat(analysis.libraryLeaks).isEmpty()
+  }
+
+  @Test fun excludedThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val matcher = LibraryLeakReferenceMatcher(JavaLocalPattern("kroutine"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(matcher)
+    )
+
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(matcher.pattern)
+  }
+
+  @Test fun excludedLollipopThread() {
+    hprofFile.writeLollipopJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val matcher = LibraryLeakReferenceMatcher(JavaLocalPattern("kroutine"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(matcher)
+    )
+
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(matcher.pattern)
+  }
+
+  @Test fun overrideSuperclassExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(
+            LibraryLeakReferenceMatcher(
+                pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
+            ),
+            IgnoredReferenceMatcher(
+                pattern = InstanceFieldPattern("leakcanary.KeyedWeakReference", "referent")
+            )
+        )
+    )
+    assertThat(analysis.libraryLeaks).isEmpty()
+  }
+
+  @Test fun nativeGlobalVariableLibraryLeak() {
+    hprofFile.dump {
+      gcRoot(JniGlobal(id = "Leaking".watchedInstance {}.value, jniGlobalRefId = 42))
+    }
+
+    val matcher = LibraryLeakReferenceMatcher(NativeGlobalVariablePattern("Leaking"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(matcher)
+    )
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(matcher.pattern)
+  }
+
+  @Test fun nativeGlobalVariableShortestPathExcluded() {
+    hprofFile.dump {
+      val leaking = instance(clazz("Leaking"))
+      keyedWeakReference(leaking)
+      val hasLeaking = instance(
+          clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
+          fields = listOf(leaking)
+      )
+      clazz("GcRoot", staticFields = listOf("longestPath" to hasLeaking))
+      gcRoot(JniGlobal(id = leaking.value, jniGlobalRefId = 42))
+    }
+
+    val matcher = LibraryLeakReferenceMatcher(NativeGlobalVariablePattern("Leaking"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(matcher)
+    )
+    val leak = analysis.applicationLeaks[0]
+    assertThat(leak.leakTrace.elements).hasSize(3)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("longestPath")
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/shark/src/test/java/shark/RetainedSizeTest.kt
similarity index 78%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
rename to shark/src/test/java/shark/RetainedSizeTest.kt
index 78197952..598c7531 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
+++ b/shark/src/test/java/shark/RetainedSizeTest.kt
@@ -1,18 +1,14 @@
-package leakcanary.internal
-
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HeapValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.LeakingInstance
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
 import java.io.File
 
 class RetainedSizeTest {
@@ -42,7 +38,7 @@ class RetainedSizeTest {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
-          field["answer"] = LongValue(42)
+          field["answer"] = LongHolder(42)
         }
       }
     }
@@ -88,7 +84,7 @@ class RetainedSizeTest {
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
           field["answer"] = "FortyTwo" instance {
-            field["number"] = IntValue(42)
+            field["number"] = IntHolder(42)
           }
         }
       }
@@ -105,7 +101,7 @@ class RetainedSizeTest {
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
           field["answer"] = "java.lang.Integer" instance {
-            field["value"] = IntValue(42)
+            field["value"] = IntHolder(42)
           }
         }
       }
@@ -119,7 +115,7 @@ class RetainedSizeTest {
 
   @Test fun leakingInstanceWithPrimitiveWrapperArray() {
     hprofFile.dump {
-      val intWrapperClass = clazz("java.lang.Integer", fields = listOf("value" to IntValue::class))
+      val intWrapperClass = clazz("java.lang.Integer", fields = listOf("value" to IntHolder::class))
 
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
@@ -127,11 +123,11 @@ class RetainedSizeTest {
               intWrapperClass,
               instance(
                   intWrapperClass,
-                  fields = listOf<HeapValue>(IntValue(4))
+                  fields = listOf<ValueHolder>(IntHolder(4))
               ),
               instance(
                   intWrapperClass,
-                  fields = listOf<HeapValue>(IntValue(2))
+                  fields = listOf<ValueHolder>(IntHolder(2))
               )
           )
         }
@@ -197,13 +193,13 @@ class RetainedSizeTest {
 
   @Test fun leakingInstanceWithSuperClass() {
     hprofFile.dump {
-      val parentClass = clazz("Parent", fields = listOf("value" to LongValue::class))
+      val parentClass = clazz("Parent", fields = listOf("value" to LongHolder::class))
       val childClass =
-        clazz("Child", superClassId = parentClass, fields = listOf("value" to IntValue::class))
+        clazz("Child", superclassId = parentClass, fields = listOf("value" to IntHolder::class))
 
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
-          field["answer"] = instance(childClass, listOf(LongValue(42), IntValue(42)))
+          field["answer"] = instance(childClass, listOf(LongHolder(42), IntHolder(42)))
         }
       }
     }
@@ -218,11 +214,11 @@ class RetainedSizeTest {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["shortestPath"] = "GrandParentLeaking" watchedInstance {
-          field["answer"] = ShortValue(42)
+          field["answer"] = ShortHolder(42)
           field["child"] = "ParentLeaking" watchedInstance {
-            field["answer"] = IntValue(42)
+            field["answer"] = IntHolder(42)
             field["child"] = "ChildLeaking" watchedInstance {
-              field["answer"] = LongValue(42)
+              field["answer"] = LongHolder(42)
             }
           }
         }
@@ -230,20 +226,13 @@ class RetainedSizeTest {
     }
 
     val retainedInstances = retainedInstances()
-    require(retainedInstances.size == 3)
+    require(retainedInstances.size == 1)
 
-    retainedInstances.forEach { instance ->
-      when (instance.instanceClassName) {
-        "GrandParentLeaking" -> {
-          // 4 bytes per ref * 2 + short + int + long
-          assertThat(instance.retainedHeapSize).isEqualTo(22)
-        }
-        "ParentLeaking", "ChildLeaking" -> {
-          assertThat(instance.retainedHeapSize).isEqualTo(0)
-        }
-        else -> throw IllegalStateException("Unexpected ${instance.instanceClassName}")
-      }
-    }
+    val instance = retainedInstances[0]
+
+    assertThat(instance.className).isEqualTo("GrandParentLeaking")
+    // 4 bytes per ref * 2 + short + int + long
+    assertThat(instance.retainedHeapByteSize).isEqualTo(22)
   }
 
   @Test fun crossDominatedIsNotDominated() {
@@ -266,7 +255,7 @@ class RetainedSizeTest {
 
     retainedInstances.forEach { instance ->
       // 4 byte reference
-      assertThat(instance.retainedHeapSize).isEqualTo(4)
+      assertThat(instance.retainedHeapByteSize).isEqualTo(4)
     }
   }
 
@@ -278,22 +267,22 @@ class RetainedSizeTest {
 
     hprofFile.dump {
       val bitmap = "android.graphics.Bitmap" instance {
-        field["mWidth"] = IntValue(width)
-        field["mHeight"] = IntValue(height)
+        field["mWidth"] = IntHolder(width)
+        field["mHeight"] = IntHolder(height)
       }
 
       val referenceClass =
-        clazz("java.lang.ref.Reference", fields = listOf("referent" to ObjectReference::class))
+        clazz("java.lang.ref.Reference", fields = listOf("referent" to ReferenceHolder::class))
       val cleanerClass = clazz(
           "sun.misc.Cleaner", clazz("java.lang.ref.PhantomReference", referenceClass),
-          fields = listOf("thunk" to ObjectReference::class)
+          fields = listOf("thunk" to ReferenceHolder::class)
       )
 
       instance(
           cleanerClass,
           fields = listOf("libcore.util.NativeAllocationRegistry\$CleanerThunk" instance {
             field["this\$0"] = "libcore.util.NativeAllocationRegistry" instance {
-              field["size"] = LongValue(nativeBitmapSize.toLong())
+              field["size"] = LongHolder(nativeBitmapSize.toLong())
             }
           }, bitmap)
       )
@@ -311,16 +300,16 @@ class RetainedSizeTest {
     assertThat(retainedSize).isEqualTo(12 + nativeBitmapSize)
   }
 
-  private fun retainedInstances(): List<LeakingInstance> {
+  private fun retainedInstances(): List<Leak> {
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>(computeRetainedHeapSize = true)
     println(analysis.toString())
     analysis as HeapAnalysisSuccess
-    return analysis.retainedInstances.map { it as LeakingInstance }
+    return analysis.applicationLeaks.map { it }
   }
 
   private fun firstRetainedSize(): Int {
     return retainedInstances()
-        .map { it.retainedHeapSize!! }
+        .map { it.retainedHeapByteSize!! }
         .first()
   }
 
diff --git a/shark/src/test/java/shark/TestUtil.kt b/shark/src/test/java/shark/TestUtil.kt
new file mode 100644
index 00000000..a55b5df5
--- /dev/null
+++ b/shark/src/test/java/shark/TestUtil.kt
@@ -0,0 +1,93 @@
+package shark
+
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
+import java.io.File
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+
+@Suppress("UNCHECKED_CAST")
+fun <T : HeapAnalysis> File.checkForLeaks(
+  objectInspectors: List<ObjectInspector> = emptyList(),
+  computeRetainedHeapSize: Boolean = false,
+  referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
+  proguardMapping: ProguardMapping? = null
+): T {
+  val inspectors = if (ObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
+    objectInspectors + ObjectInspectors.KEYED_WEAK_REFERENCE
+  } else {
+    objectInspectors
+  }
+  val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+  val result = heapAnalyzer.analyze(
+      this,
+      referenceMatchers,
+      computeRetainedHeapSize,
+      inspectors,
+      proguardMapping = proguardMapping
+  )
+  if (result is HeapAnalysisFailure) {
+    println(result)
+  }
+  return result as T
+}
+
+val defaultReferenceMatchers: List<ReferenceMatcher> =
+  listOf(
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("leakcanary.KeyedWeakReference", "referent")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern(SoftReference::class.java.name, "referent")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern(PhantomReference::class.java.name, "referent")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "prev")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "element")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.Finalizer", "next")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "prev")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "element")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("java.lang.ref.FinalizerReference", "next")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("sun.misc.Cleaner", "prev")
+      )
+      ,
+      IgnoredReferenceMatcher(
+          pattern = InstanceFieldPattern("sun.misc.Cleaner", "next")
+      )
+      ,
+
+      IgnoredReferenceMatcher(
+          pattern = JavaLocalPattern("FinalizerWatchdogDaemon")
+      ),
+      IgnoredReferenceMatcher(
+          pattern = JavaLocalPattern("main")
+      )
+  )
\ No newline at end of file
