diff --git a/build.gradle b/build.gradle
index b0568c40..45b2703d 100644
--- a/build.gradle
+++ b/build.gradle
@@ -26,19 +26,19 @@ ext {
   javaVersion = JavaVersion.VERSION_1_7
 
   GROUP = 'com.squareup.leakcanary'
-  VERSION_NAME = "1.4-SNAPSHOT"
+  VERSION_NAME = "1.4.1-SNAPSHOT"
   POM_PACKAGING = "pom"
   POM_DESCRIPTION= "Leak Canary"
 
-  POM_URL="http://github.com/square/leakcanary/"
-  POM_SCM_URL="http://github.com/square/leakcanary/"
-  POM_SCM_CONNECTION="scm:git:https://github.com/square/leakcanary.git"
-  POM_SCM_DEV_CONNECTION="scm:git:git@github.com:square/leakcanary.git"
+  POM_URL="http://github.com/veqtor/leakcanary/"
+  POM_SCM_URL="http://github.com/veqtor/leakcanary/"
+  POM_SCM_CONNECTION="scm:git:https://github.com/veqtor/leakcanary.git"
+  POM_SCM_DEV_CONNECTION="scm:git:git@github.com:veqtor/leakcanary.git"
 
   POM_LICENCE_NAME="The Apache Software License, Version 2.0"
   POM_LICENCE_URL="http://www.apache.org/licenses/LICENSE-2.0.txt"
   POM_LICENCE_DIST="repo"
 
-  POM_DEVELOPER_ID="square"
-  POM_DEVELOPER_NAME="Square, Inc."
+  POM_DEVELOPER_ID="veqtor"
+  POM_DEVELOPER_NAME="Veqtor"
 }
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
deleted file mode 100644
index 60e6bc79..00000000
--- a/leakcanary-analyzer/build.gradle
+++ /dev/null
@@ -1,59 +0,0 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
-
-dependencies {
-  compile 'com.squareup.haha:haha:2.0.2'
-  compile project(':leakcanary-watcher')
-  testCompile 'junit:junit:4.12'
-  testCompile 'org.assertj:assertj-core:1.7.0'
-}
-
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "jar${name.capitalize()}", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
-
-
-// See: https://code.google.com/p/android/issues/detail?id=64887#c13
-task copyTestResources(type: Copy) {
-  from "${projectDir}/src/test/resources"
-  into "${buildDir}/classes/test"
-}
-
-afterEvaluate { project ->
-  testDebugUnitTest.dependsOn copyTestResources
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
-}
-
-apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-analyzer/gradle.properties b/leakcanary-analyzer/gradle.properties
deleted file mode 100644
index 9ef04082..00000000
--- a/leakcanary-analyzer/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-analyzer
-POM_NAME=LeakCanary Analyzer
-POM_PACKAGING=jar
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/AndroidManifest.xml b/leakcanary-analyzer/src/main/AndroidManifest.xml
deleted file mode 100644
index 3bde165b..00000000
--- a/leakcanary-analyzer/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<manifest
-    package="com.squareup.leakcanary.analyzer">
-  <application/>
-</manifest>
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java b/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
deleted file mode 100644
index 227bcb59..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/haha/perflib/HahaSpy.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.haha.perflib;
-
-public final class HahaSpy {
-
-  public static Instance allocatingThread(Instance instance) {
-    Snapshot snapshot = instance.mHeap.mSnapshot;
-    int threadSerialNumber;
-    if (instance instanceof RootObj) {
-      threadSerialNumber = ((RootObj) instance).mThread;
-    } else {
-      threadSerialNumber = instance.mStack.mThreadSerialNumber;
-    }
-    ThreadObj thread = snapshot.getThread(threadSerialNumber);
-    return snapshot.findInstance(thread.mId);
-  }
-
-  private HahaSpy() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
deleted file mode 100644
index 4c8270c1..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-public final class AnalysisResult implements Serializable {
-
-  public static AnalysisResult noLeak(long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
-  }
-
-  public static AnalysisResult leakDetected(boolean excludedLeak, String className,
-      LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
-    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, retainedHeapSize,
-        analysisDurationMs);
-  }
-
-  public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, failure, 0, analysisDurationMs);
-  }
-
-  /** True if a leak was found in the heap dump. */
-  public final boolean leakFound;
-
-  /**
-   * True if {@link #leakFound} is true and the only path to the leaking reference is
-   * through excluded references. Usually, that means you can safely ignore this report.
-   */
-  public final boolean excludedLeak;
-
-  /**
-   * Class name of the object that leaked if {@link #leakFound} is true, null otherwise.
-   * The class name format is the same as what would be returned by {@link Class#getName()}.
-   */
-  public final String className;
-
-  /**
-   * Shortest path to GC roots for the leaking object if {@link #leakFound} is true, null
-   * otherwise. This can be used as a unique signature for the leak.
-   */
-  public final LeakTrace leakTrace;
-
-  /** Null unless the analysis failed. */
-  public final Throwable failure;
-
-  /**
-   * The number of bytes which would be freed if all references to the leaking object were
-   * released. 0 if {@link #leakFound} is false.
-   */
-  public final long retainedHeapSize;
-
-  /** Total time spent analyzing the heap. */
-  public final long analysisDurationMs;
-
-  private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
-      LeakTrace leakTrace, Throwable failure, long retainedHeapSize, long analysisDurationMs) {
-    this.leakFound = leakFound;
-    this.excludedLeak = excludedLeak;
-    this.className = className;
-    this.leakTrace = leakTrace;
-    this.failure = failure;
-    this.retainedHeapSize = retainedHeapSize;
-    this.analysisDurationMs = analysisDurationMs;
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
deleted file mode 100644
index fe01cd23..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Heap;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.Type;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.Arrays.asList;
-
-public final class HahaHelper {
-
-  private static final Set<String> WRAPPER_TYPES = new HashSet<>(
-      asList(Boolean.class.getName(), Character.class.getName(), Float.class.getName(),
-          Double.class.getName(), Byte.class.getName(), Short.class.getName(),
-          Integer.class.getName(), Long.class.getName()));
-
-  static String fieldToString(Map.Entry<Field, Object> entry) {
-    return fieldToString(entry.getKey(), entry.getValue());
-  }
-
-  static String fieldToString(ClassInstance.FieldValue fieldValue) {
-    return fieldToString(fieldValue.getField(), fieldValue.getValue());
-  }
-
-  static String fieldToString(Field field, Object value) {
-    return field.getName() + " = " + value;
-  }
-
-  static String threadName(Instance holder) {
-    List<ClassInstance.FieldValue> values = classInstanceValues(holder);
-    Object nameField = fieldValue(values, "name");
-    if (nameField == null) {
-      // Sometimes we can't find the String at the expected memory address in the heap dump.
-      // See https://github.com/square/leakcanary/issues/417 .
-      return "Thread name not available";
-    }
-    return asString(nameField);
-  }
-
-  static boolean extendsThread(ClassObj clazz) {
-    boolean extendsThread = false;
-    ClassObj parentClass = clazz;
-    while (parentClass.getSuperClassObj() != null) {
-      if (clazz.getClassName().equals(Thread.class.getName())) {
-        extendsThread = true;
-        break;
-      }
-      parentClass = parentClass.getSuperClassObj();
-    }
-    return extendsThread;
-  }
-
-  static String asString(Object stringObject) {
-    Instance instance = (Instance) stringObject;
-    List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-
-    Integer count = fieldValue(values, "count");
-    Object value = fieldValue(values, "value");
-    Integer offset;
-    ArrayInstance charArray;
-    if (isCharArray(value)) {
-      charArray = (ArrayInstance) value;
-      offset = 0;
-      // < API 23
-      // As of Marshmallow, substrings no longer share their parent strings' char arrays
-      // eliminating the need for String.offset
-      // https://android-review.googlesource.com/#/c/83611/
-      if (hasField(values, "offset")) {
-        offset = fieldValue(values, "offset");
-      }
-    } else {
-      // In M preview 2, the underlying char buffer resides in the heap with ID equaling the
-      // String's ID + 16.
-      // https://android-review.googlesource.com/#/c/160380/2/android/src/com/android/tools/idea/
-      // editors/hprof/descriptors/InstanceFieldDescriptorImpl.java
-      // This workaround is only needed for M preview 2, as it has been fixed on the hprof
-      // generation end by reintroducing a virtual "value" variable.
-      // https://android.googlesource.com/platform/art/+/master/runtime/hprof/hprof.cc#1242
-      Heap heap = instance.getHeap();
-      Instance inlineInstance = heap.getInstance(instance.getId() + 16);
-      if (isCharArray(inlineInstance)) {
-        charArray = (ArrayInstance) inlineInstance;
-        offset = 0;
-      } else {
-        throw new UnsupportedOperationException("Could not find char array in " + instance);
-      }
-    }
-    checkNotNull(count, "count");
-    checkNotNull(charArray, "charArray");
-    checkNotNull(offset, "offset");
-
-    if (count == 0) {
-      return "";
-    }
-
-    char[] chars = charArray.asCharArray(offset, count);
-
-    return new String(chars);
-  }
-
-  public static boolean isPrimitiveWrapper(Object value) {
-    if (!(value instanceof ClassInstance)) {
-      return false;
-    }
-    return WRAPPER_TYPES.contains(((ClassInstance) value).getClassObj().getClassName());
-  }
-
-  public static boolean isPrimitiveOrWrapperArray(Object value) {
-    if (!(value instanceof ArrayInstance)) {
-      return false;
-    }
-    ArrayInstance arrayInstance = (ArrayInstance) value;
-    if (arrayInstance.getArrayType() != Type.OBJECT) {
-      return true;
-    }
-    return WRAPPER_TYPES.contains(arrayInstance.getClassObj().getClassName());
-  }
-
-  private static boolean isCharArray(Object value) {
-    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
-  }
-
-  static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
-    ClassInstance classInstance = (ClassInstance) instance;
-    return classInstance.getValues();
-  }
-
-  static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
-    for (ClassInstance.FieldValue fieldValue : values) {
-      if (fieldValue.getField().getName().equals(fieldName)) {
-        //noinspection unchecked
-        return (T) fieldValue.getValue();
-      }
-    }
-    throw new IllegalArgumentException("Field " + fieldName + " does not exists");
-  }
-
-  static boolean hasField(List<ClassInstance.FieldValue> values, String fieldName) {
-    for (ClassInstance.FieldValue fieldValue : values) {
-      if (fieldValue.getField().getName().equals(fieldName)) {
-        //noinspection unchecked
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private HahaHelper() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
deleted file mode 100644
index 3b1effb6..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.HprofParser;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.RootType;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import com.squareup.haha.perflib.io.HprofBuffer;
-import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
-import com.squareup.haha.trove.THashMap;
-import com.squareup.haha.trove.TObjectProcedure;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import static com.squareup.leakcanary.AnalysisResult.failure;
-import static com.squareup.leakcanary.AnalysisResult.leakDetected;
-import static com.squareup.leakcanary.AnalysisResult.noLeak;
-import static com.squareup.leakcanary.HahaHelper.asString;
-import static com.squareup.leakcanary.HahaHelper.classInstanceValues;
-import static com.squareup.leakcanary.HahaHelper.extendsThread;
-import static com.squareup.leakcanary.HahaHelper.fieldToString;
-import static com.squareup.leakcanary.HahaHelper.fieldValue;
-import static com.squareup.leakcanary.HahaHelper.threadName;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-/**
- * Analyzes heap dumps generated by a {@link RefWatcher} to verify if suspected leaks are real.
- */
-public final class HeapAnalyzer {
-
-  private static final String ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$";
-
-  private final ExcludedRefs excludedRefs;
-
-  public HeapAnalyzer(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
-  }
-
-  /**
-   * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
-    long analysisStartNanoTime = System.nanoTime();
-
-    if (!heapDumpFile.exists()) {
-      Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
-      return failure(exception, since(analysisStartNanoTime));
-    }
-
-    try {
-      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
-      HprofParser parser = new HprofParser(buffer);
-      Snapshot snapshot = parser.parse();
-      deduplicateGcRoots(snapshot);
-
-      Instance leakingRef = findLeakingReference(referenceKey, snapshot);
-
-      // False alarm, weak reference was cleared in between key check and heap dump.
-      if (leakingRef == null) {
-        return noLeak(since(analysisStartNanoTime));
-      }
-
-      return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);
-    } catch (Throwable e) {
-      return failure(e, since(analysisStartNanoTime));
-    }
-  }
-
-  /**
-   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
-   */
-  void deduplicateGcRoots(Snapshot snapshot) {
-    // THashMap has a smaller memory footprint than HashMap.
-    final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
-
-    final List<RootObj> gcRoots = (ArrayList) snapshot.getGCRoots();
-    for (RootObj root : gcRoots) {
-      String key = generateRootKey(root);
-      if (!uniqueRootMap.containsKey(key)) {
-        uniqueRootMap.put(key, root);
-      }
-    }
-
-    // Repopulate snapshot with unique GC roots.
-    gcRoots.clear();
-    uniqueRootMap.forEach(new TObjectProcedure<String>() {
-      @Override
-      public boolean execute(String key) {
-        return gcRoots.add(uniqueRootMap.get(key));
-      }
-    });
-  }
-
-  private String generateRootKey(RootObj root) {
-    return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
-  }
-
-  private Instance findLeakingReference(String key, Snapshot snapshot) {
-    ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
-    List<String> keysFound = new ArrayList<>();
-    for (Instance instance : refClass.getInstancesList()) {
-      List<ClassInstance.FieldValue> values = classInstanceValues(instance);
-      String keyCandidate = asString(fieldValue(values, "key"));
-      if (keyCandidate.equals(key)) {
-        return fieldValue(values, "referent");
-      }
-      keysFound.add(keyCandidate);
-    }
-    throw new IllegalStateException(
-        "Could not find weak reference with key " + key + " in " + keysFound);
-  }
-
-  private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapshot,
-      Instance leakingRef) {
-
-    ShortestPathFinder pathFinder = new ShortestPathFinder(excludedRefs);
-    ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);
-
-    // False alarm, no strong reference path to GC Roots.
-    if (result.leakingNode == null) {
-      return noLeak(since(analysisStartNanoTime));
-    }
-
-    LeakTrace leakTrace = buildLeakTrace(result.leakingNode);
-
-    String className = leakingRef.getClassObj().getClassName();
-
-    // Side effect: computes retained size.
-    snapshot.computeDominators();
-
-    Instance leakingInstance = result.leakingNode.instance;
-
-    long retainedSize = leakingInstance.getTotalRetainedSize();
-
-    retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
-
-    return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
-        since(analysisStartNanoTime));
-  }
-
-  /**
-   * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
-   * in the retained size because their root dominator is a native gc root.
-   * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
-   * add the bitmap size.
-   *
-   * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
-   * accounted for, however bitmaps set in layouts are not.
-   */
-  private int computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
-    int bitmapRetainedSize = 0;
-    ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
-
-    for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
-      if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
-        ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
-        // Native bitmaps have mBuffer set to null. We sadly can't account for them.
-        if (mBufferInstance == null) {
-          continue;
-        }
-        long bufferSize = mBufferInstance.getTotalRetainedSize();
-        long bitmapSize = bitmapInstance.getTotalRetainedSize();
-        // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
-        // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
-        if (bitmapSize < bufferSize) {
-          bitmapSize += bufferSize;
-        }
-        bitmapRetainedSize += bitmapSize;
-      }
-    }
-    return bitmapRetainedSize;
-  }
-
-  private boolean isIgnoredDominator(Instance dominator, Instance instance) {
-    boolean foundNativeRoot = false;
-    while (true) {
-      Instance immediateDominator = instance.getImmediateDominator();
-      if (immediateDominator instanceof RootObj
-          && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
-        // Ignore native roots
-        instance = instance.getNextInstanceToGcRoot();
-        foundNativeRoot = true;
-      } else {
-        instance = immediateDominator;
-      }
-      if (instance == null) {
-        return false;
-      }
-      if (instance == dominator) {
-        return foundNativeRoot;
-      }
-    }
-  }
-
-  private LeakTrace buildLeakTrace(LeakNode leakingNode) {
-    List<LeakTraceElement> elements = new ArrayList<>();
-    // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, null, leakingNode, null, null);
-    while (node != null) {
-      LeakTraceElement element = buildLeakElement(node);
-      if (element != null) {
-        elements.add(0, element);
-      }
-      node = node.parent;
-    }
-    return new LeakTrace(elements);
-  }
-
-  private LeakTraceElement buildLeakElement(LeakNode node) {
-    if (node.parent == null) {
-      // Ignore any root node.
-      return null;
-    }
-    Instance holder = node.parent.instance;
-
-    if (holder instanceof RootObj) {
-      return null;
-    }
-    LeakTraceElement.Type type = node.referenceType;
-    String referenceName = node.referenceName;
-
-    LeakTraceElement.Holder holderType;
-    String className;
-    String extra = null;
-    List<String> fields = new ArrayList<>();
-    if (holder instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) holder;
-      holderType = CLASS;
-      className = classObj.getClassName();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        Field field = entry.getKey();
-        Object value = entry.getValue();
-        fields.add("static " + field.getName() + " = " + value);
-      }
-    } else if (holder instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) holder;
-      holderType = ARRAY;
-      className = arrayInstance.getClassObj().getClassName();
-      if (arrayInstance.getArrayType() == Type.OBJECT) {
-        Object[] values = arrayInstance.getValues();
-        for (int i = 0; i < values.length; i++) {
-          fields.add("[" + i + "] = " + values[i]);
-        }
-      }
-    } else {
-      ClassInstance classInstance = (ClassInstance) holder;
-      ClassObj classObj = holder.getClassObj();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        fields.add("static " + fieldToString(entry));
-      }
-      for (ClassInstance.FieldValue field : classInstance.getValues()) {
-        fields.add(fieldToString(field));
-      }
-      className = classObj.getClassName();
-
-      if (extendsThread(classObj)) {
-        holderType = THREAD;
-        String threadName = threadName(holder);
-        extra = "(named '" + threadName + "')";
-      } else if (className.matches(ANONYMOUS_CLASS_NAME_PATTERN)) {
-        String parentClassName = classObj.getSuperClassObj().getClassName();
-        if (Object.class.getName().equals(parentClassName)) {
-          holderType = OBJECT;
-          try {
-            // This is an anonymous class implementing an interface. The API does not give access
-            // to the interfaces implemented by the class. We check if it's in the class path and
-            // use that instead.
-            Class<?> actualClass = Class.forName(classObj.getClassName());
-            Class<?>[] interfaces = actualClass.getInterfaces();
-            if (interfaces.length > 0) {
-              Class<?> implementedInterface = interfaces[0];
-              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
-            } else {
-              extra = "(anonymous subclass of java.lang.Object)";
-            }
-          } catch (ClassNotFoundException ignored) {
-          }
-        } else {
-          holderType = OBJECT;
-          // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous subclass of " + parentClassName + ")";
-        }
-      } else {
-        holderType = OBJECT;
-      }
-    }
-    return new LeakTraceElement(referenceName, type, holderType, className, extra, node.exclusion,
-        fields);
-  }
-
-  private long since(long analysisStartNanoTime) {
-    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime);
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
deleted file mode 100644
index b30df278..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.Instance;
-
-final class LeakNode {
-  /** May be null. */
-  final Exclusion exclusion;
-  final Instance instance;
-  final LeakNode parent;
-  final String referenceName;
-  final LeakTraceElement.Type referenceType;
-
-  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent,
-      String referenceName, LeakTraceElement.Type referenceType) {
-    this.exclusion = exclusion;
-    this.instance = instance;
-    this.parent = parent;
-    this.referenceName = referenceName;
-    this.referenceType = referenceType;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
deleted file mode 100644
index 607db22c..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTrace.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-import static java.util.Collections.unmodifiableList;
-
-/**
- * A chain of references that constitute the shortest strong reference path from a leaking instance
- * to the GC roots. Fixing the leak usually means breaking one of the references in that chain.
- */
-public final class LeakTrace implements Serializable {
-
-  public final List<LeakTraceElement> elements;
-
-  LeakTrace(List<LeakTraceElement> elements) {
-    this.elements = unmodifiableList(new ArrayList<>(elements));
-  }
-
-  @Override public String toString() {
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < elements.size(); i++) {
-      LeakTraceElement element = elements.get(i);
-      sb.append("* ");
-      if (i == 0) {
-        sb.append("GC ROOT ");
-      } else if (i == elements.size() - 1) {
-        sb.append("leaks ");
-      } else {
-        sb.append("references ");
-      }
-      sb.append(element).append("\n");
-    }
-    return sb.toString();
-  }
-
-  public String toDetailedString() {
-    String string = "";
-    for (LeakTraceElement element : elements) {
-      string += element.toDetailedString();
-    }
-    return string;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
deleted file mode 100644
index 89ef31e3..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.List;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static java.util.Collections.unmodifiableList;
-import static java.util.Locale.US;
-
-/** Represents one reference in the chain of references that holds a leaking object in memory. */
-public final class LeakTraceElement implements Serializable {
-
-  public enum Type {
-    INSTANCE_FIELD, STATIC_FIELD, LOCAL, ARRAY_ENTRY
-  }
-
-  public enum Holder {
-    OBJECT, CLASS, THREAD, ARRAY
-  }
-
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
-  public final String referenceName;
-
-  /** Null if this is the last element in the leak trace, ie the leaking object. */
-  public final Type type;
-  public final Holder holder;
-  public final String className;
-
-  /** Additional information, may be null. */
-  public final String extra;
-
-  /** If not null, there was no path that could exclude this element. */
-  public final Exclusion exclusion;
-
-  /** List of all fields (member and static) for that object. */
-  public final List<String> fields;
-
-  LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
-      Exclusion exclusion, List<String> fields) {
-    this.referenceName = referenceName;
-    this.type = type;
-    this.holder = holder;
-    this.className = className;
-    this.extra = extra;
-    this.exclusion = exclusion;
-    this.fields = unmodifiableList(new ArrayList<>(fields));
-  }
-
-  @Override public String toString() {
-    String string = "";
-
-    if (type == STATIC_FIELD) {
-      string += "static ";
-    }
-
-    if (holder == ARRAY || holder == THREAD) {
-      string += holder.name().toLowerCase(US) + " ";
-    }
-
-    string += className;
-
-    if (referenceName != null) {
-      string += "." + referenceName;
-    } else {
-      string += " instance";
-    }
-
-    if (extra != null) {
-      string += " " + extra;
-    }
-
-    if (exclusion != null) {
-      string += " , matching exclusion " + exclusion.matching;
-    }
-
-    return string;
-  }
-
-  public String toDetailedString() {
-    String string = "* ";
-    if (holder == ARRAY) {
-      string += "Array of";
-    } else if (holder == CLASS) {
-      string += "Class";
-    } else {
-      string += "Instance of";
-    }
-    string += " " + className + "\n";
-    for (String field : fields) {
-      string += "|   " + field + "\n";
-    }
-    return string;
-  }
-}
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
deleted file mode 100644
index db6100ef..00000000
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.HahaSpy;
-import com.squareup.haha.perflib.Instance;
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.RootType;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.Queue;
-
-import static com.squareup.leakcanary.HahaHelper.isPrimitiveOrWrapperArray;
-import static com.squareup.leakcanary.HahaHelper.isPrimitiveWrapper;
-import static com.squareup.leakcanary.HahaHelper.threadName;
-import static com.squareup.leakcanary.LeakTraceElement.Type.ARRAY_ENTRY;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.LOCAL;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-
-/**
- * Not thread safe.
- *
- * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
- * refs first and then including the ones that are not "always ignorable" as needed if no path is
- * found.
- */
-final class ShortestPathFinder {
-
-  private final ExcludedRefs excludedRefs;
-  private final Queue<LeakNode> toVisitQueue;
-  private final Queue<LeakNode> toVisitIfNoPathQueue;
-  private final LinkedHashSet<Instance> toVisitSet;
-  private final LinkedHashSet<Instance> toVisitIfNoPathSet;
-  private final LinkedHashSet<Instance> visitedSet;
-  private boolean canIgnoreStrings;
-
-  ShortestPathFinder(ExcludedRefs excludedRefs) {
-    this.excludedRefs = excludedRefs;
-    toVisitQueue = new LinkedList<>();
-    toVisitIfNoPathQueue = new LinkedList<>();
-    toVisitSet = new LinkedHashSet<>();
-    toVisitIfNoPathSet = new LinkedHashSet<>();
-    visitedSet = new LinkedHashSet<>();
-  }
-
-  static final class Result {
-    final LeakNode leakingNode;
-    final boolean excludingKnownLeaks;
-
-    Result(LeakNode leakingNode, boolean excludingKnownLeaks) {
-      this.leakingNode = leakingNode;
-      this.excludingKnownLeaks = excludingKnownLeaks;
-    }
-  }
-
-  Result findPath(Snapshot snapshot, Instance leakingRef) {
-    clearState();
-    canIgnoreStrings = !isString(leakingRef);
-
-    enqueueGcRoots(snapshot);
-
-    boolean excludingKnownLeaks = false;
-    LeakNode leakingNode = null;
-    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
-      LeakNode node;
-      if (!toVisitQueue.isEmpty()) {
-        node = toVisitQueue.poll();
-      } else {
-        node = toVisitIfNoPathQueue.poll();
-        if (node.exclusion == null) {
-          throw new IllegalStateException("Expected node to have an exclusion " + node);
-        }
-        excludingKnownLeaks = true;
-      }
-
-      // Termination
-      if (node.instance == leakingRef) {
-        leakingNode = node;
-        break;
-      }
-
-      if (checkSeen(node)) {
-        continue;
-      }
-
-      if (node.instance instanceof RootObj) {
-        visitRootObj(node);
-      } else if (node.instance instanceof ClassObj) {
-        visitClassObj(node);
-      } else if (node.instance instanceof ClassInstance) {
-        visitClassInstance(node);
-      } else if (node.instance instanceof ArrayInstance) {
-        visitArrayInstance(node);
-      } else {
-        throw new IllegalStateException("Unexpected type for " + node.instance);
-      }
-    }
-    return new Result(leakingNode, excludingKnownLeaks);
-  }
-
-  private void clearState() {
-    toVisitQueue.clear();
-    toVisitIfNoPathQueue.clear();
-    toVisitSet.clear();
-    toVisitIfNoPathSet.clear();
-    visitedSet.clear();
-  }
-
-  private void enqueueGcRoots(Snapshot snapshot) {
-    for (RootObj rootObj : snapshot.getGCRoots()) {
-      switch (rootObj.getRootType()) {
-        case JAVA_LOCAL:
-          Instance thread = HahaSpy.allocatingThread(rootObj);
-          String threadName = threadName(thread);
-          Exclusion params = excludedRefs.threadNames.get(threadName);
-          if (params == null || !params.alwaysExclude) {
-            enqueue(params, null, rootObj, null, null);
-          }
-          break;
-        case INTERNED_STRING:
-        case DEBUGGER:
-        case INVALID_TYPE:
-          // An object that is unreachable from any other root, but not a root itself.
-        case UNREACHABLE:
-        case UNKNOWN:
-          // An object that is in a queue, waiting for a finalizer to run.
-        case FINALIZING:
-          break;
-        case SYSTEM_CLASS:
-        case VM_INTERNAL:
-          // A local variable in native code.
-        case NATIVE_LOCAL:
-          // A global variable in native code.
-        case NATIVE_STATIC:
-          // An object that was referenced from an active thread block.
-        case THREAD_BLOCK:
-          // Everything that called the wait() or notify() methods, or that is synchronized.
-        case BUSY_MONITOR:
-        case NATIVE_MONITOR:
-        case REFERENCE_CLEANUP:
-          // Input or output parameters in native code.
-        case NATIVE_STACK:
-        case JAVA_STATIC:
-          enqueue(null, null, rootObj, null, null);
-          break;
-        default:
-          throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
-      }
-    }
-  }
-
-  private boolean checkSeen(LeakNode node) {
-    return !visitedSet.add(node.instance);
-  }
-
-  private void visitRootObj(LeakNode node) {
-    RootObj rootObj = (RootObj) node.instance;
-    Instance child = rootObj.getReferredInstance();
-
-    Exclusion exclusion = rootSuperClassAlwaysIgnored(child);
-
-    if (exclusion != null && exclusion.alwaysExclude) {
-      return;
-    }
-
-    if (rootObj.getRootType() == RootType.JAVA_LOCAL) {
-      Instance holder = HahaSpy.allocatingThread(rootObj);
-      // We switch the parent node with the thread instance that holds
-      // the local reference.
-      LeakNode parent = new LeakNode(null, holder, null, null, null);
-      if (node.exclusion != null) {
-        exclusion = node.exclusion;
-      }
-      enqueue(exclusion, parent, child, "<Java Local>", LOCAL);
-    } else {
-      enqueue(exclusion, node, child, null, null);
-    }
-  }
-
-  private Exclusion rootSuperClassAlwaysIgnored(Instance child) {
-    if (child == null) {
-      return null;
-    }
-    Exclusion matchingParams = null;
-    ClassObj superClassObj = child.getClassObj();
-    while (superClassObj != null) {
-      Exclusion params = excludedRefs.rootClassNames.get(superClassObj.getClassName());
-      if (params != null) {
-        // true overrides null or false.
-        if (matchingParams == null || !matchingParams.alwaysExclude) {
-          matchingParams = params;
-        }
-      }
-      superClassObj = superClassObj.getSuperClassObj();
-    }
-    return matchingParams;
-  }
-
-  private void visitClassObj(LeakNode node) {
-    ClassObj classObj = (ClassObj) node.instance;
-    Map<String, Exclusion> ignoredStaticFields =
-        excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());
-    for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-      Field field = entry.getKey();
-      if (field.getType() != Type.OBJECT) {
-        continue;
-      }
-      String fieldName = field.getName();
-      if (fieldName.equals("$staticOverhead")) {
-        continue;
-      }
-      Instance child = (Instance) entry.getValue();
-      boolean visit = true;
-      if (ignoredStaticFields != null) {
-        Exclusion params = ignoredStaticFields.get(fieldName);
-        if (params != null) {
-          visit = false;
-          if (!params.alwaysExclude) {
-            enqueue(params, node, child, fieldName, STATIC_FIELD);
-          }
-        }
-      }
-      if (visit) {
-        enqueue(null, node, child, fieldName, STATIC_FIELD);
-      }
-    }
-  }
-
-  private void visitClassInstance(LeakNode node) {
-    ClassInstance classInstance = (ClassInstance) node.instance;
-    Map<String, Exclusion> ignoredFields = new LinkedHashMap<>();
-    ClassObj superClassObj = classInstance.getClassObj();
-    Exclusion classExclusion = null;
-    while (superClassObj != null) {
-      Exclusion params = excludedRefs.classNames.get(superClassObj.getClassName());
-      if (params != null) {
-        // true overrides null or false.
-        if (classExclusion == null || !classExclusion.alwaysExclude) {
-          classExclusion = params;
-        }
-      }
-      Map<String, Exclusion> classIgnoredFields =
-          excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());
-      if (classIgnoredFields != null) {
-        ignoredFields.putAll(classIgnoredFields);
-      }
-      superClassObj = superClassObj.getSuperClassObj();
-    }
-
-    if (classExclusion != null && classExclusion.alwaysExclude) {
-      return;
-    }
-
-    for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
-      Exclusion fieldExclusion = classExclusion;
-      Field field = fieldValue.getField();
-      if (field.getType() != Type.OBJECT) {
-        continue;
-      }
-      Instance child = (Instance) fieldValue.getValue();
-      String fieldName = field.getName();
-      Exclusion params = ignoredFields.get(fieldName);
-      // If we found a field exclusion and it's stronger than a class exclusion
-      if (params != null && (fieldExclusion == null || (params.alwaysExclude
-          && !fieldExclusion.alwaysExclude))) {
-        fieldExclusion = params;
-      }
-      enqueue(fieldExclusion, node, child, fieldName, INSTANCE_FIELD);
-    }
-  }
-
-  private void visitArrayInstance(LeakNode node) {
-    ArrayInstance arrayInstance = (ArrayInstance) node.instance;
-    Type arrayType = arrayInstance.getArrayType();
-    if (arrayType == Type.OBJECT) {
-      Object[] values = arrayInstance.getValues();
-      for (int i = 0; i < values.length; i++) {
-        Instance child = (Instance) values[i];
-        enqueue(null, node, child, "[" + i + "]", ARRAY_ENTRY);
-      }
-    }
-  }
-
-  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child, String referenceName,
-      LeakTraceElement.Type referenceType) {
-    if (child == null) {
-      return;
-    }
-    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
-      return;
-    }
-    // Whether we want to visit now or later, we should skip if this is already to visit.
-    if (toVisitSet.contains(child)) {
-      return;
-    }
-    boolean visitNow = exclusion == null;
-    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
-      return;
-    }
-    if (canIgnoreStrings && isString(child)) {
-      return;
-    }
-    if (visitedSet.contains(child)) {
-      return;
-    }
-    LeakNode childNode = new LeakNode(exclusion, child, parent, referenceName, referenceType);
-    if (visitNow) {
-      toVisitSet.add(child);
-      toVisitQueue.add(childNode);
-    } else {
-      toVisitIfNoPathSet.add(child);
-      toVisitIfNoPathQueue.add(childNode);
-    }
-  }
-
-  private boolean isString(Instance instance) {
-    return instance.getClassObj() != null && instance.getClassObj()
-        .getClassName()
-        .equals(String.class.getName());
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
deleted file mode 100644
index ad43d493..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import java.util.Collection;
-import java.util.List;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static java.util.Arrays.asList;
-import static org.hamcrest.core.StringContains.containsString;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(Parameterized.class) //
-public class AsyncTaskLeakTest {
-
-  static final String ASYNC_TASK_THREAD = "AsyncTask #1";
-  static final String ASYNC_TASK_CLASS = "android.os.AsyncTask";
-  static final String EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR";
-  static final String EXECUTOR_FIELD_2 = "sDefaultExecutor";
-
-  @Parameterized.Parameters public static Collection<Object[]> data() {
-    return asList(new Object[][] {
-        { ASYNC_TASK }, //
-        { ASYNC_TASK_MPREVIEW2 }, //
-        { ASYNC_TASK_M_POSTPREVIEW2 } //
-    });
-  }
-
-  private final TestUtil.HeapDumpFile heapDumpFile;
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  public AsyncTaskLeakTest(TestUtil.HeapDumpFile heapDumpFile) {
-    this.heapDumpFile = heapDumpFile;
-  }
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void leakFound() {
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(Thread.class.getName(), gcRoot.className);
-    assertEquals(THREAD, gcRoot.holder);
-    assertThat(gcRoot.extra, containsString(ASYNC_TASK_THREAD));
-  }
-
-  @Test public void excludeThread() {
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(ASYNC_TASK_CLASS, gcRoot.className);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertTrue(gcRoot.referenceName.equals(EXECUTOR_FIELD_1) || gcRoot.referenceName.equals(
-        EXECUTOR_FIELD_2));
-  }
-
-  @Test public void excludeStatic() {
-    excludedRefs.thread(ASYNC_TASK_THREAD).named(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1).named(EXECUTOR_FIELD_1);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2).named(EXECUTOR_FIELD_2);
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-    LeakTrace leakTrace = result.leakTrace;
-    List<LeakTraceElement> elements = leakTrace.elements;
-    Exclusion exclusion = elements.get(0).exclusion;
-
-    List<String> expectedExclusions = asList(ASYNC_TASK_THREAD, EXECUTOR_FIELD_1, EXECUTOR_FIELD_2);
-    assertTrue(expectedExclusions.contains(exclusion.name));
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
deleted file mode 100644
index ba62c2ad..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.io.HprofBuffer;
-
-import java.io.UnsupportedEncodingException;
-import java.util.List;
-
-public final class FakeHprofBuffer implements HprofBuffer {
-  private List<Byte> byteList;
-  private List<byte[]> byteArrayList;
-
-  private int[] intsToRead;
-  private int intIndex = -1;
-  private String[] stringsToRead;
-  private int stringIndex = -1;
-
-  public void setIntsToRead(int... ints) {
-    intsToRead = ints;
-    intIndex = 0;
-  }
-
-  public void setStringsToRead(String... strings) {
-    stringsToRead = strings;
-    stringIndex = 0;
-  }
-
-  @Override
-  public byte readByte() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void read(byte[] bytes) {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void readSubSequence(byte[] bytes, int start, int length) {
-    if (stringsToRead == null || stringIndex < 0 || stringIndex >= stringsToRead.length) {
-      throw new UnsupportedOperationException("no bytes to read");
-    }
-
-    String s = stringsToRead[stringIndex++];
-    try {
-      System.arraycopy(s.getBytes("UTF-16BE"), start, bytes, 0, length);
-    } catch (UnsupportedEncodingException e) {
-      throw new UnsupportedOperationException(e);
-    }
-  }
-
-  @Override
-  public char readChar() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public short readShort() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public int readInt() {
-    if (intsToRead == null || intIndex < 0 || intIndex >= intsToRead.length) {
-      throw new UnsupportedOperationException("no bytes to read");
-    }
-    return intsToRead[intIndex++];
-  }
-
-  @Override
-  public long readLong() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public float readFloat() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public double readDouble() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public void setPosition(long l) {}
-
-  @Override
-  public long position() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public boolean hasRemaining() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-
-  @Override
-  public long remaining() {
-    throw new UnsupportedOperationException("no bytes to read");
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
deleted file mode 100644
index 03178cbe..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
+++ /dev/null
@@ -1,146 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.ArrayInstance;
-import com.squareup.haha.perflib.ClassInstance;
-import com.squareup.haha.perflib.ClassObj;
-import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Snapshot;
-import com.squareup.haha.perflib.Type;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class HahaHelperTest {
-  private static final int STRING_CLASS_ID = 100;
-  private static final int CHAR_ARRAY_CLASS_ID = 101;
-  private static final int STRING_INSTANCE_ID = 102;
-  private static final int VALUE_ARRAY_INSTANCE_ID = 103;
-
-  private static final int VALUE_ARRAY_LENGTH = 6;
-  private static final int COUNT_VALUE = 5;
-  private static final int OFFSET_VALUE = 1;
-
-  private FakeHprofBuffer buffer;
-  private Snapshot snapshot;
-
-  @Before
-  public void setUp() {
-    buffer = new FakeHprofBuffer();
-
-    snapshot = new Snapshot(buffer);
-    // set HPROF identifier size; required for Object instance field lookups
-    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
-    snapshot.setIdSize(4);
-  }
-
-  @Test
-  public void readStringOffsetFromHeapDumpInstance() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("bcdef"));
-  }
-
-  @Test
-  public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue() {
-    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("abcde"));
-  }
-
-  @Test
-  public void defaultToZeroStringOffsetWhenReadingMPreview2HeapDump() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createCharArrayValueInstance_M_Preview2();
-
-    String actual = HahaHelper.asString(stringInstance);
-    assertTrue(actual.equals("abcde"));
-  }
-
-  @Test
-  public void throwExceptionWhenMissingCharArrayValueForStringInMPreview2HeapDump() {
-    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
-    buffer.setStringsToRead("abcdef");
-
-    addStringClassToSnapshotWithFields(snapshot, new Field[]{
-            new Field(Type.INT, "count"),
-            new Field(Type.INT, "offset"),
-            new Field(Type.OBJECT, "value")
-    });
-
-    ClassInstance stringInstance = createStringInstance();
-    createObjectValueInstance_M_Preview2();
-
-    try {
-      HahaHelper.asString(stringInstance);
-      fail("this test should have thrown UnsupportedOperationException");
-    }
-    catch (UnsupportedOperationException uoe) {
-      String message = uoe.getMessage();
-      assertTrue(message.equals("Could not find char array in " + stringInstance));
-    }
-  }
-
-  private void addStringClassToSnapshotWithFields(Snapshot snapshot, Field[] fields) {
-    ClassObj charArrayClass = new ClassObj(0, null, "char[]", 0);
-    snapshot.addClass(CHAR_ARRAY_CLASS_ID, charArrayClass);
-
-    ClassObj stringClass = new ClassObj(0, null, "string", 0);
-    stringClass.setFields(fields);
-    snapshot.addClass(STRING_CLASS_ID, stringClass);
-  }
-
-  private void createCharArrayValueInstance() {
-    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
-  }
-
-  private void createCharArrayValueInstance_M_Preview2() {
-    ArrayInstance valueInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
-    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
-  }
-
-  private void createObjectValueInstance_M_Preview2() {
-    ClassInstance valueInstance = new ClassInstance(0, null, 0);
-    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
-  }
-
-  private ClassInstance createStringInstance() {
-    ClassInstance stringInstance = new ClassInstance(STRING_INSTANCE_ID, null, 100);
-    stringInstance.setClassId(STRING_CLASS_ID);
-    snapshot.addInstance(0, stringInstance);
-    return stringInstance;
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
deleted file mode 100644
index 0d5607d8..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package com.squareup.leakcanary;
-
-import com.squareup.haha.perflib.RootObj;
-import com.squareup.haha.perflib.Snapshot;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-import static com.squareup.haha.perflib.RootType.NATIVE_STATIC;
-import static com.squareup.haha.perflib.RootType.SYSTEM_CLASS;
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class HeapAnalyzerTest {
-  private static final ExcludedRefs NO_EXCLUDED_REFS = null;
-  private static final List<RootObj> DUP_ROOTS =
-          asList(new RootObj(SYSTEM_CLASS, 6L),
-                  new RootObj(SYSTEM_CLASS, 5L),
-                  new RootObj(SYSTEM_CLASS, 3L),
-                  new RootObj(SYSTEM_CLASS, 5L),
-                  new RootObj(NATIVE_STATIC, 3L));
-
-  private HeapAnalyzer heapAnalyzer;
-
-  @Before
-  public void setUp() {
-    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
-  }
-
-  @Test
-  public void ensureUniqueRoots() {
-    Snapshot snapshot = createSnapshot(DUP_ROOTS);
-
-    heapAnalyzer.deduplicateGcRoots(snapshot);
-
-    Collection<RootObj> uniqueRoots = snapshot.getGCRoots();
-    assertThat(uniqueRoots).hasSize(4);
-
-    List<Long> rootIds = new ArrayList<>();
-    for (RootObj root : uniqueRoots) {
-      rootIds.add(root.getId());
-    }
-    Collections.sort(rootIds);
-
-    // 3 appears twice because even though two RootObjs have the same id, they're different types.
-    assertThat(rootIds).containsExactly(3L, 3L, 5L, 6L);
-  }
-
-  private Snapshot createSnapshot(List<RootObj> gcRoots) {
-    Snapshot snapshot = new Snapshot(null);
-    for (RootObj root : gcRoots) {
-      snapshot.addRoot(root);
-    }
-    return snapshot;
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
deleted file mode 100644
index a414687d..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import java.util.Arrays;
-import java.util.Collection;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static org.junit.Assert.assertEquals;
-
-/**
- * This test makes sure there is no regression on the retained size calculation.
- */
-@RunWith(Parameterized.class) //
-public class RetainedSizeTest {
-
-  @Parameterized.Parameters public static Collection<Object[]> data() {
-    return Arrays.asList(new Object[][] {
-        { ASYNC_TASK, 207_407 }, //
-        { ASYNC_TASK_MPREVIEW2, 1_604 }, //
-        { ASYNC_TASK_M_POSTPREVIEW2, 1_870 }, //
-        { SERVICE_BINDER, 378 }, //
-        { SERVICE_BINDER_IGNORED, 378 }, //
-    });
-  }
-
-  private final TestUtil.HeapDumpFile heapDumpFile;
-  private final long expectedRetainedHeapSize;
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  public RetainedSizeTest(TestUtil.HeapDumpFile heapDumpFile, long expectedRetainedHeapSize) {
-    this.heapDumpFile = heapDumpFile;
-    this.expectedRetainedHeapSize = expectedRetainedHeapSize;
-  }
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void leakFound() {
-    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
-    assertEquals(expectedRetainedHeapSize, result.retainedHeapSize);
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
deleted file mode 100644
index a54feeb1..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.WeakReference;
-import org.junit.Before;
-import org.junit.Test;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
-import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
-import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
-import static com.squareup.leakcanary.TestUtil.analyze;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * leak_service_binder_ignored.hprof contains a "normal" leak when binding to a service, where
- * leak_service_binder.hprof contains a leak where a binder is leaked by a static field.
- */
-public class ServiceBinderLeakTest {
-
-  ExcludedRefs.BuilderWithParams excludedRefs;
-
-  @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude();
-  }
-
-  @Test public void realBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder").alwaysExclude();
-
-    AnalysisResult result = analyze(SERVICE_BINDER, excludedRefs);
-
-    assertTrue(result.leakFound);
-    assertFalse(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(STATIC_FIELD, gcRoot.type);
-    assertEquals("com.example.leakcanary.LeakyService", gcRoot.className);
-    assertEquals(CLASS, gcRoot.holder);
-  }
-
-  @Test public void ignorableBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder");
-
-    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
-
-    assertTrue(result.leakFound);
-    assertTrue(result.excludedLeak);
-    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
-    assertEquals(INSTANCE_FIELD, gcRoot.type);
-    assertEquals("com.example.leakcanary.LeakyService$MyBinder", gcRoot.className);
-    assertEquals(OBJECT, gcRoot.holder);
-  }
-
-  @Test public void alwaysIgnorableBinderLeak() {
-    excludedRefs.rootClass("android.os.Binder").alwaysExclude();
-
-    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
-
-    assertFalse(result.leakFound);
-  }
-}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
deleted file mode 100644
index e3666e5d..00000000
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.net.URL;
-
-final class TestUtil {
-
-  enum HeapDumpFile {
-    ASYNC_TASK("leak_asynctask.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"),
-    ASYNC_TASK_MPREVIEW2("leak_asynctask_mpreview2.hprof", "1114018e-e154-435f-9a3d-da63ae9b47fa"),
-    ASYNC_TASK_M_POSTPREVIEW2("leak_asynctask_m_postpreview2.hprof",
-        "25ae1778-7c1d-4ec7-ac50-5cce55424069"),
-
-    SERVICE_BINDER("leak_service_binder.hprof", "b3abfae6-2c53-42e1-b8c1-96b0558dbeae"),
-    SERVICE_BINDER_IGNORED("leak_service_binder_ignored.hprof",
-        "6e524414-9581-4ce7-8690-e8ddf8b82454"),;
-
-    private final String filename;
-    private final String referenceKey;
-
-    HeapDumpFile(String filename, String referenceKey) {
-      this.filename = filename;
-      this.referenceKey = referenceKey;
-    }
-
-  }
-
-  static File fileFromName(String filename) {
-    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-    URL url = classLoader.getResource(filename);
-    return new File(url.getPath());
-  }
-
-  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.BuilderWithParams excludedRefs) {
-    File file = fileFromName(heapDumpFile.filename);
-    String referenceKey = heapDumpFile.referenceKey;
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
-    AnalysisResult result = heapAnalyzer.checkForLeak(file, referenceKey);
-    if (result.failure != null) {
-      result.failure.printStackTrace();
-    }
-    if (result.leakTrace != null) {
-      System.out.println(result.leakTrace);
-    }
-    return result;
-  }
-
-  private TestUtil() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
deleted file mode 100644
index a1d60adc..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof
deleted file mode 100644
index 6945c82d..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof
deleted file mode 100644
index 548f3a2a..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof
deleted file mode 100644
index af1dab18..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof
deleted file mode 100644
index cdb867c4..00000000
Binary files a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof and /dev/null differ
diff --git a/leakcanary-android-no-op/build.gradle b/leakcanary-android-no-op/build.gradle
index 5f3dc025..6f88d092 100644
--- a/leakcanary-android-no-op/build.gradle
+++ b/leakcanary-android-no-op/build.gradle
@@ -11,9 +11,11 @@ apply plugin: 'com.android.library'
 
 repositories {
   mavenCentral()
+  maven { url "https://jitpack.io" }
 }
 
 dependencies {
+  compile 'com.github.jitpack:gradle-simple:1.0'
 }
 
 android {
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
new file mode 100644
index 00000000..ccde6d19
--- /dev/null
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+import java.util.LinkedHashMap;
+import java.util.Map;
+/**
+ * Prevents specific references from being taken into account when computing the shortest reference
+ * path from a suspected leaking instance to the GC roots.
+ *
+ * This class lets you ignore known memory leaks that you know about. If the shortest path
+ * matches {@link ExcludedRefs}, than the heap analyzer should look for a longer path with nothing
+ * matching in {@link ExcludedRefs}.
+ */
+public final class ExcludedRefs implements Serializable {
+
+    public static Builder builder() {
+        return new BuilderWithParams();
+    }
+
+    ExcludedRefs(BuilderWithParams builder) {
+    }
+
+
+    @Override public String toString() {
+        String string = "";
+
+        return string;
+    }
+
+    static final class ParamsBuilder {
+        final String matching;
+
+        ParamsBuilder(String matching) {
+            this.matching = matching;
+        }
+    }
+
+    public interface Builder {
+        BuilderWithParams instanceField(String className, String fieldName);
+
+        BuilderWithParams staticField(String className, String fieldName);
+
+        BuilderWithParams thread(String threadName);
+
+        BuilderWithParams clazz(String className);
+
+        BuilderWithParams rootClass(String rootSuperClassName);
+
+        ExcludedRefs build();
+    }
+
+    public static final class BuilderWithParams implements Builder {
+
+        private final Map<String, Map<String, ParamsBuilder>> fieldNameByClassName =
+                new LinkedHashMap<>();
+        private final Map<String, Map<String, ParamsBuilder>> staticFieldNameByClassName =
+                new LinkedHashMap<>();
+        private final Map<String, ParamsBuilder> threadNames = new LinkedHashMap<>();
+        private final Map<String, ParamsBuilder> classNames = new LinkedHashMap<>();
+        private final Map<String, ParamsBuilder> rootClassNames = new LinkedHashMap<>();
+
+        private ParamsBuilder lastParams;
+
+        BuilderWithParams() {
+        }
+
+        @Override public BuilderWithParams instanceField(String className, String fieldName) {
+            return this;
+        }
+
+        @Override public BuilderWithParams staticField(String className, String fieldName) {
+            return this;
+        }
+
+        @Override public BuilderWithParams thread(String threadName) {
+            return this;
+        }
+
+        /** Ignores all fields and static fields of all subclasses of the provided class name. */
+        @Override public BuilderWithParams clazz(String className) {
+            return this;
+        }
+
+        /** Ignores any GC root that belongs to a subclass of the provided class name. */
+        @Override public BuilderWithParams rootClass(String rootClassName) {
+            return this;
+        }
+
+        public BuilderWithParams named(String name) {
+            return this;
+        }
+
+        public BuilderWithParams reason(String reason) {
+            return this;
+        }
+
+        public BuilderWithParams alwaysExclude() {
+            return this;
+        }
+
+        public ExcludedRefs build() {
+            return new ExcludedRefs(this);
+        }
+    }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/HeapDump.java
similarity index 64%
rename from leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
rename to leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/HeapDump.java
index 715d089a..4cdac576 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -16,14 +16,15 @@
 package com.squareup.leakcanary;
 
 import java.io.File;
+import java.io.Serializable;
 
-public interface HeapDumper {
+public final class HeapDump implements Serializable {
 
-  File NO_DUMP = null;
+    public interface Listener {
+        void analyze(HeapDump heapDump);
+    }
 
-  /**
-   * @return a {@link File} referencing the heap dump, or {@link #NO_DUMP} if the heap could not be
-   * dumped.
-   */
-  File dumpHeap();
-}
\ No newline at end of file
+    public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
+                    ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
+    }
+}
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 8fc8a58c..0e64c8f5 100644
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -1,6 +1,7 @@
 package com.squareup.leakcanary;
 
 import android.app.Application;
+import android.content.Context;
 
 /**
  * A no-op version of {@link LeakCanary} that can be used in release builds.
@@ -14,4 +15,21 @@ public static RefWatcher install(Application application) {
   private LeakCanary() {
     throw new AssertionError();
   }
+
+  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
+                                          ExcludedRefs excludedRefs) {
+    return RefWatcher.DISABLED;
+  }
+
+  public static void enableDisplayLeakActivity(Context context) {
+  }
+
+  public static void setDisplayLeakActivityDirectoryProvider(
+          LeakDirectoryProvider leakDirectoryProvider) {
+  }
+
+  public static boolean isInAnalyzerProcess(Context context) {
+    return false;
+  }
+
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
similarity index 76%
rename from leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
rename to leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
index 1e7ebf87..457c1b96 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
@@ -25,13 +25,13 @@
  */
 public interface LeakDirectoryProvider {
 
-  /** Returns a path to an existing directory were leaks can be stored. */
-  File leakDirectory();
+    /** Returns a path to an existing directory were leaks can be stored. */
+    File leakDirectory();
 
-  void requestWritePermissionNotification();
+    void requestWritePermissionNotification();
 
-  void requestPermission(Activity activity);
+    void requestPermission(Activity activity);
 
-  /** True if we can currently write to the leak directory. */
-  boolean isLeakStorageWritable();
+    /** True if we can currently write to the leak directory. */
+    boolean isLeakStorageWritable();
 }
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
deleted file mode 100644
index beb07063..00000000
--- a/leakcanary-android/build.gradle
+++ /dev/null
@@ -1,42 +0,0 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
-
-dependencies {
-  compile project(':leakcanary-analyzer')
-}
-
-def gitSha() {
-  return 'git rev-parse --short HEAD'.execute().text.trim()
-}
-
-android {
-  resourcePrefix 'leak_canary_'
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-    buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
-    buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
-    consumerProguardFiles 'consumer-proguard-rules.pro'
-  }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
-}
-
-apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android/consumer-proguard-rules.pro
deleted file mode 100644
index 48ffcc28..00000000
--- a/leakcanary-android/consumer-proguard-rules.pro
+++ /dev/null
@@ -1,9 +0,0 @@
--dontwarn com.squareup.haha.guava.**
--dontwarn com.squareup.haha.perflib.**
--dontwarn com.squareup.haha.trove.**
--dontwarn com.squareup.leakcanary.**
--keep class com.squareup.haha.** { *; }
--keep class com.squareup.leakcanary.** { *; }
-
-# Marshmallow removed Notification.setLatestEventInfo()
--dontwarn android.app.Notification
diff --git a/leakcanary-android/gradle.properties b/leakcanary-android/gradle.properties
deleted file mode 100644
index beee3e6f..00000000
--- a/leakcanary-android/gradle.properties
+++ /dev/null
@@ -1,2 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-android
-POM_NAME=LeakCanary for Android
\ No newline at end of file
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
deleted file mode 100644
index b5393171..00000000
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,59 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary"
-    >
-
-  <!-- To store the heap dumps and leak analysis results. -->
-  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
-  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
-
-  <application>
-    <service
-        android:name=".internal.HeapAnalyzerService"
-        android:process=":leakcanary"
-        android:enabled="false"
-        />
-    <service
-        android:name=".DisplayLeakService"
-        android:enabled="false"
-        />
-    <activity
-        android:theme="@style/leak_canary_LeakCanary.Base"
-        android:name=".internal.DisplayLeakActivity"
-        android:enabled="false"
-        android:label="@string/leak_canary_display_activity_label"
-        android:icon="@drawable/leak_canary_icon"
-        android:taskAffinity="com.squareup.leakcanary"
-        >
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN"/>
-        <category android:name="android.intent.category.LAUNCHER"/>
-      </intent-filter>
-    </activity>
-    <activity
-        android:theme="@style/leak_canary_Theme.Transparent"
-        android:name=".internal.RequestStoragePermissionActivity"
-        android:taskAffinity="com.squareup.leakcanary"
-        android:enabled="false"
-        android:icon="@drawable/leak_canary_icon"
-        android:label="@string/leak_canary_storage_permission_activity_label"
-        />
-
-  </application>
-</manifest>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
deleted file mode 100644
index 9b193831..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AbstractAnalysisResultService.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.IntentService;
-import android.content.Context;
-import android.content.Intent;
-
-public abstract class AbstractAnalysisResultService extends IntentService {
-
-  private static final String HEAP_DUMP_EXTRA = "heap_dump_extra";
-  private static final String RESULT_EXTRA = "result_extra";
-
-  public static void sendResultToListener(Context context, String listenerServiceClassName,
-      HeapDump heapDump, AnalysisResult result) {
-    Class<?> listenerServiceClass;
-    try {
-      listenerServiceClass = Class.forName(listenerServiceClassName);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-    Intent intent = new Intent(context, listenerServiceClass);
-    intent.putExtra(HEAP_DUMP_EXTRA, heapDump);
-    intent.putExtra(RESULT_EXTRA, result);
-    context.startService(intent);
-  }
-
-  public AbstractAnalysisResultService() {
-    super(AbstractAnalysisResultService.class.getName());
-  }
-
-  @Override protected final void onHandleIntent(Intent intent) {
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAP_DUMP_EXTRA);
-    AnalysisResult result = (AnalysisResult) intent.getSerializableExtra(RESULT_EXTRA);
-    try {
-      onHeapAnalyzed(heapDump, result);
-    } finally {
-      //noinspection ResultOfMethodCallIgnored
-      heapDump.heapDumpFile.delete();
-    }
-  }
-
-  /**
-   * Called after a heap dump is analyzed, whether or not a leak was found.
-   * Check {@link AnalysisResult#leakFound} and {@link AnalysisResult#excludedLeak} to see if there
-   * was a leak and if it can be ignored.
-   *
-   * This will be called from a background intent service thread.
-   * <p>
-   * It's OK to block here and wait for the heap dump to be uploaded.
-   * <p>
-   * The heap dump file will be deleted immediately after this callback returns.
-   */
-  protected abstract void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result);
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
deleted file mode 100644
index 160e840f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.Application;
-import android.os.Bundle;
-
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-@TargetApi(ICE_CREAM_SANDWICH) public final class ActivityRefWatcher {
-
-  public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
-    if (SDK_INT < ICE_CREAM_SANDWICH) {
-      // If you need to support Android < ICS, override onDestroy() in your base activity.
-      return;
-    }
-    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
-    activityRefWatcher.watchActivities();
-  }
-
-  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
-      new Application.ActivityLifecycleCallbacks() {
-        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        }
-
-        @Override public void onActivityStarted(Activity activity) {
-        }
-
-        @Override public void onActivityResumed(Activity activity) {
-        }
-
-        @Override public void onActivityPaused(Activity activity) {
-        }
-
-        @Override public void onActivityStopped(Activity activity) {
-        }
-
-        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-        }
-
-        @Override public void onActivityDestroyed(Activity activity) {
-          ActivityRefWatcher.this.onActivityDestroyed(activity);
-        }
-      };
-
-  private final Application application;
-  private final RefWatcher refWatcher;
-
-  /**
-   * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
-   * after they have been destroyed.
-   */
-  public ActivityRefWatcher(Application application, final RefWatcher refWatcher) {
-    this.application = checkNotNull(application, "application");
-    this.refWatcher = checkNotNull(refWatcher, "refWatcher");
-  }
-
-  void onActivityDestroyed(Activity activity) {
-    refWatcher.watch(activity);
-  }
-
-  public void watchActivities() {
-    // Make sure you don't get installed twice.
-    stopWatchingActivities();
-    application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
-  }
-
-  public void stopWatchingActivities() {
-    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
deleted file mode 100644
index 7c58b997..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidDebuggerControl.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.os.Debug;
-
-public final class AndroidDebuggerControl implements DebuggerControl {
-  @Override public boolean isDebuggerAttached() {
-    return Debug.isDebuggerConnected();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
deleted file mode 100644
index e4a9dfd5..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ /dev/null
@@ -1,488 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.PhantomReference;
-import java.lang.ref.SoftReference;
-import java.lang.ref.WeakReference;
-import java.util.EnumSet;
-
-import static android.os.Build.MANUFACTURER;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ECLAIR;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.KITKAT;
-import static android.os.Build.VERSION_CODES.LOLLIPOP;
-import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
-import static android.os.Build.VERSION_CODES.M;
-import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- *
- * Most app developers should use {@link #createAppDefaults()}. However, you can also pick the
- * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
- * {@link #createBuilder(EnumSet)}
- */
-public enum AndroidExcludedRefs {
-
-  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
-          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
-              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-              + " Not sure what's going on there, input welcome.");
-    }
-  },
-
-  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason =
-          "Editor inserts a special span, which has a reference to the EditText. That span is a"
-              + " NoCopySpan, which makes sure it gets dropped when creating a new"
-              + " SpannableStringBuilder from a given CharSequence."
-              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-              + " reference to the textview and therefore the entire view hierarchy & activity"
-              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
-          .reason(reason);
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
-    }
-  },
-
-  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
-          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-              + " keeps a reference to the context it's given the first time"
-              + " MediaSessionLegacyHelper.getHelper() is called."
-              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-              + " calling context.getApplicationContext()."
-              + " Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-              + " in Application.onCreate() and pass it the application context.");
-    }
-  },
-
-  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.text.TextLine", "sCached")
-          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-              + " at least two bugs that created memory leaks by not correctly clearing the"
-              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/893d6fe48d37f71e683f722457bea646994a10"
-              + " The second was fixed, not released yet:"
-              + " https://github.com/android/platform_frameworks_base/commit"
-              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-              + " To fix this, you could access TextLine.sCached and clear the pool every now"
-              + " and then (e.g. on activity destroy).");
-    }
-  },
-
-  BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "Prior to ART, a thread waiting on a blocking queue will leak the last"
-          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-          + " keeps a local reference to the last message it received. That message then gets"
-          + " recycled and can be used again. As long as all messages are recycled after being"
-          + "used, this won't be a problem, because these references are cleared when being"
-          + "recycled. However, dialogs create template Message instances to be copied when a"
-          + "message needs to be sent. These Message templates holds references to the dialog"
-          + "listeners, which most likely leads to holding a reference onto the activity in some"
-          + "way. Dialogs never recycle their template Message, assuming these Message instances"
-          + " will get GCed when the dialog is GCed."
-          + " The combination of these two things creates a high potential for memory leaks as soon"
-          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-          + " sleep for a long time."
-          + " To fix this, you could post empty messages to the idle handler threads from time to"
-          + " time. This won't be easy because you cannot access all handler threads, but a library"
-          + "that is widely used should consider doing this for its own handler threads.";
-      excluded.instanceField("android.os.Message", "obj").reason(reason);
-      excluded.instanceField("android.os.Message", "next").reason(reason);
-      excluded.instanceField("android.os.Message", "target").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
-          + " leaks a reference to it until a new view asks for keyboard input."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
-          .reason(reason);
-      excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection").reason(reason);
-    }
-  },
-
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
-          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
-              + " after the activity has been destroyed."
-              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-              + "#issuecomment-100579429"
-              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
-    }
-  },
-
-  LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
-          .reason("LayoutTransition leaks parent ViewGroup through"
-              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-              + " window is destroyed. Tracked here:"
-              + " https://code.google.com/p/android/issues/detail?id=171830");
-    }
-  },
-
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
-          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-              + " SpellCheckerSession is closed before the service is connected."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
-    }
-  },
-
-  ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      String reason = "ActivityChooserModel holds a static reference to the last set"
-          + " ActivityChooserModelPolicy which can be an activity context."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
-      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy").reason(reason);
-      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
-          .reason(reason);
-    }
-  },
-
-  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
-          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-              + " class and leaked the SpeechRecognizer which leaked an activity context."
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + " /b37866db469e81aca534ff6186bdafd44352329b");
-    }
-  },
-
-  ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
-          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
-              + " probably because the reference to the response in the other process hasn't been"
-              + " cleared."
-              + " AccountManager$AmsTask is holding on to the activity reference to use for"
-              + " launching a new sub- Activity."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-              + " with the returned future to to get the result and correctly start an activity"
-              + " when it's available.");
-    }
-  },
-
-  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
-          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
-              + " but the service might not disconnect after the activity has been destroyed."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-              + " application context. Call connect() and disconnect() manually.");
-    }
-  },
-
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.UserManager", "mContext")
-          .reason("UserManager has a static sInstance field that creates an instance and caches it"
-              + " the first time UserManager.get() is called. This instance is created with the"
-              + " outer context (which is an activity base context)."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-              + "/27db46850b708070452c0ce49daf5f79503fbde6"
-              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-              + " UserManager instance gets cached with a reference to the application context.");
-    }
-  },
-
-  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
-          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
-              + " code. The reference to the `mContext` was not being cleared, which caused the"
-              + " Callbacks instance to retain this reference"
-              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
-    }
-  },
-
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
-            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
-                + " instead of extracting the application context. In this Motorola build,"
-                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                + " observer, which is held into memory by a binder transport object.");
-      }
-    }
-  },
-
-  SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
-          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
-              + " activity. Yes, a STATIC mContext field.");
-    }
-  },
-
-  CLIPBOARD_UI_MANAGER__SINSTANCE(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
-          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
-              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-              + " application context. Example: https://gist.github.com/pepyakin"
-              + "/8d2221501fd572d4a61c");
-    }
-  },
-
-  BUBBLE_POPUP_HELPER__SHELPER(
-      LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
-          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
-              + "focused view.");
-    }
-  },
-
-  AW_RESOURCE__SRESOURCES(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources");
-    }
-  },
-
-  MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
-          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
-              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-              + " ControllerMapper.MapperClient which leaks the activity context.");
-    }
-  },
-
-  TEXT_VIEW__MLAST_HOVERED_VIEW(
-      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.widget.TextView", "mLastHoveredView")
-          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
-              + " view.");
-    }
-  },
-
-  PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.os.PersonaManager", "mContext")
-          .reason("android.app.LoadedApk.mResources has a reference to"
-              + " android.content.res.Resources.mPersonaManager which has a reference to"
-              + " android.os.PersonaManager.mContext which is an activity.");
-    }
-  },
-
-  RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.content.res.Resources", "mContext")
-          .reason("In AOSP the Resources class does not have a context."
-              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-              + " instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
-    }
-  },
-
-  VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.view.ViewConfiguration", "mContext")
-          .reason("In AOSP the ViewConfiguration class does not have a context."
-              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-              + " ViewConfiguration instance that has a context that is the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues"
-              + "/1#issuecomment-100324683");
-    }
-  },
-
-  AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.staticField("android.media.AudioManager", "mContext_static")
-          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
-              + " to the activity."
-              + " Observed here: https://github.com/square/leakcanary/issues/32");
-    }
-  },
-
-  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.media.AudioManager$1", "this$0")
-          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
-              + " never abandoned it, which leaks the Activity context through the AudioManager."
-              + " The root of the problem is that AudioManager uses whichever"
-              + " context it receives, which in the case of the VideoView example is an Activity,"
-              + " even though it only needs the application's context. The issue is fixed in"
-              + " Android M, and the AudioManager now uses the application's context."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
-    }
-  },
-
-  EDITTEXT_BLINK_MESSAGEQUEUE {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.instanceField("android.widget.Editor$Blink", "this$0")
-          .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
-              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-              + " contains a blinking cursor is detached a message is posted with a delay after the"
-              + " dialog has been closed and as a result leaks the Activity."
-              + " This can be fixed manually by calling setCursorEnabled(false) in the dismiss()"
-              + " method of the dialog."
-              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
-    }
-  },
-
-  SERVICE_BINDER {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // We should ignore leaks where an android.os.Binder is the root of the leak.
-      // When you bind and unbind from a Service, the OS will keep a reference to the Binder
-      // until the client binder has been GC'ed. This means the Binder can be retained after
-      // Service.onDestroy() is called.
-      excluded.rootClass("android.os.Binder").alwaysExclude();
-    }
-  },
-
-  SOFT_REFERENCES {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
-      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
-      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
-      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
-      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
-    }
-  },
-
-  FINALIZER_WATCHDOG_DAEMON {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-      // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
-    }
-  },
-
-  MAIN {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // The main thread stack is ever changing so local variables aren't likely to hold references
-      // for long. If this is on the shortest path, it's probably that there's a longer path with
-      // a real leak.
-      excluded.thread("main").alwaysExclude();
-    }
-  },
-
-  LEAK_CANARY_THREAD {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
-    }
-  },
-
-  EVENT_RECEIVER__MMESSAGE_QUEUE {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-      // the native peer of the receiver is using them.
-      // The main thread message queue is held on by the main Looper, but that might be a longer
-      // path. Let's not confuse people with a shorter path that is less meaningful.
-      excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue").alwaysExclude();
-    }
-  };
-
-  /**
-   * This returns the references in the leak path that should be ignored by all on Android.
-   */
-  public static ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(
-        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-            EVENT_RECEIVER__MMESSAGE_QUEUE, SERVICE_BINDER));
-  }
-
-  /**
-   * This returns the references in the leak path that can be ignored for app developers. This
-   * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-   * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-   * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-   */
-  public static ExcludedRefs.Builder createAppDefaults() {
-    return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
-  }
-
-  public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
-    for (AndroidExcludedRefs ref : refs) {
-      if (ref.applies) {
-        ref.add(excluded);
-        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
-      }
-    }
-    return excluded;
-  }
-
-  final boolean applies;
-
-  AndroidExcludedRefs() {
-    this(true);
-  }
-
-  AndroidExcludedRefs(boolean applies) {
-    this.applies = applies;
-  }
-
-  abstract void add(ExcludedRefs.Builder excluded);
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
deleted file mode 100644
index c46435f3..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import android.os.Debug;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.MessageQueue;
-import android.view.Gravity;
-import android.view.LayoutInflater;
-import android.widget.Toast;
-import com.squareup.leakcanary.internal.FutureResult;
-import com.squareup.leakcanary.internal.LeakCanaryInternals;
-import java.io.File;
-import java.io.IOException;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-public final class AndroidHeapDumper implements HeapDumper {
-
-  private static final String HEAPDUMP_FILE = "suspected_leak_heapdump.hprof";
-
-  final Context context;
-  final LeakDirectoryProvider leakDirectoryProvider;
-  private final Handler mainHandler;
-
-  public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
-    this.leakDirectoryProvider = leakDirectoryProvider;
-    this.context = context.getApplicationContext();
-    mainHandler = new Handler(Looper.getMainLooper());
-  }
-
-  @Override public File dumpHeap() {
-    if (!leakDirectoryProvider.isLeakStorageWritable()) {
-      CanaryLog.d("Could not write to leak storage to dump heap.");
-      leakDirectoryProvider.requestWritePermissionNotification();
-      return NO_DUMP;
-    }
-    File heapDumpFile = getHeapDumpFile();
-    // Atomic way to check for existence & create the file if it doesn't exist.
-    // Prevents several processes in the same app to attempt a heapdump at the same time.
-    boolean fileCreated;
-    try {
-      fileCreated = heapDumpFile.createNewFile();
-    } catch (IOException e) {
-      cleanup();
-      CanaryLog.d(e, "Could not check if heap dump file exists");
-      return NO_DUMP;
-    }
-
-    if (!fileCreated) {
-      CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
-      // Heap analysis in progress, let's not put too much pressure on the device.
-      return NO_DUMP;
-    }
-
-    FutureResult<Toast> waitingForToast = new FutureResult<>();
-    showToast(waitingForToast);
-
-    if (!waitingForToast.wait(5, SECONDS)) {
-      CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
-      return NO_DUMP;
-    }
-
-    Toast toast = waitingForToast.get();
-    try {
-      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
-      cancelToast(toast);
-      return heapDumpFile;
-    } catch (Exception e) {
-      cleanup();
-      CanaryLog.d(e, "Could not perform heap dump");
-      // Abort heap dump
-      return NO_DUMP;
-    }
-  }
-
-  /**
-   * Call this on app startup to clean up all heap dump files that had not been handled yet when
-   * the app process was killed.
-   */
-  public void cleanup() {
-    LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
-      @Override public void run() {
-        if (!leakDirectoryProvider.isLeakStorageWritable()) {
-          CanaryLog.d("Could not attempt cleanup, leak storage not writable.");
-          return;
-        }
-        File heapDumpFile = getHeapDumpFile();
-        if (heapDumpFile.exists()) {
-          CanaryLog.d("Previous analysis did not complete correctly, cleaning: %s", heapDumpFile);
-          boolean success = heapDumpFile.delete();
-          if (!success) {
-            CanaryLog.d("Could not delete file %s", heapDumpFile.getPath());
-          }
-        }
-      }
-    });
-  }
-
-  File getHeapDumpFile() {
-    return new File(leakDirectoryProvider.leakDirectory(), HEAPDUMP_FILE);
-  }
-
-  private void showToast(final FutureResult<Toast> waitingForToast) {
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        final Toast toast = new Toast(context);
-        toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
-        toast.setDuration(Toast.LENGTH_LONG);
-        LayoutInflater inflater = LayoutInflater.from(context);
-        toast.setView(inflater.inflate(R.layout.leak_canary_heap_dump_toast, null));
-        toast.show();
-        // Waiting for Idle to make sure Toast gets rendered.
-        Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-          @Override public boolean queueIdle() {
-            waitingForToast.set(toast);
-            return false;
-          }
-        });
-      }
-    });
-  }
-
-  private void cancelToast(final Toast toast) {
-    mainHandler.post(new Runnable() {
-      @Override public void run() {
-        toast.cancel();
-      }
-    });
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
deleted file mode 100644
index 8f8eff4b..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.Looper;
-import android.os.MessageQueue;
-import java.util.concurrent.Executor;
-
-/**
- * {@link Executor} suitable for watching Android reference leaks. This executor waits for the main
- * thread to be idle then posts to a serial background thread with a delay of
- * {@link R.integer#leak_canary_watch_delay_millis} seconds.
- */
-public final class AndroidWatchExecutor implements Executor {
-
-  static final String LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump";
-  private final Handler mainHandler;
-  final Handler backgroundHandler;
-  final long delayMillis;
-
-  public AndroidWatchExecutor(int delayMillis) {
-    mainHandler = new Handler(Looper.getMainLooper());
-    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
-    handlerThread.start();
-    backgroundHandler = new Handler(handlerThread.getLooper());
-    this.delayMillis = delayMillis;
-  }
-
-  @Override public void execute(final Runnable command) {
-    if (isOnMainThread()) {
-      executeDelayedAfterIdleUnsafe(command);
-    } else {
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          executeDelayedAfterIdleUnsafe(command);
-        }
-      });
-    }
-  }
-
-  private boolean isOnMainThread() {
-    return Looper.getMainLooper().getThread() == Thread.currentThread();
-  }
-
-  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
-    // This needs to be called from the main thread.
-    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
-      @Override public boolean queueIdle() {
-        backgroundHandler.postDelayed(runnable, delayMillis);
-        return false;
-      }
-    });
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
deleted file mode 100644
index b4e288db..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package com.squareup.leakcanary;
-
-import android.util.Log;
-
-public final class CanaryLog {
-
-  private static volatile Logger logger = new DefaultLogger();
-
-  public interface Logger {
-    void d(String message, Object... args);
-
-    void d(Throwable throwable, String message, Object... args);
-  }
-
-  private static class DefaultLogger implements Logger {
-    DefaultLogger() { }
-
-    @Override public void d(String message, Object... args) {
-      String formatted = String.format(message, args);
-      if (formatted.length() < 4000) {
-        Log.d("LeakCanary", formatted);
-      } else {
-        String[] lines = formatted.split("\n");
-        for (String line : lines) {
-          Log.d("LeakCanary", line);
-        }
-      }
-    }
-
-    @Override public void d(Throwable throwable, String message, Object... args) {
-      d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
-    }
-  }
-
-  public static void setLogger(Logger logger) {
-    CanaryLog.logger = logger;
-  }
-
-  public static void d(String message, Object... args) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    Logger logger = CanaryLog.logger;
-    if (logger == null) {
-      return;
-    }
-    logger.d(message, args);
-  }
-
-  public static void d(Throwable throwable, String message, Object... args) {
-    // Local variable to prevent the ref from becoming null after the null check.
-    Logger logger = CanaryLog.logger;
-    if (logger == null) {
-      return;
-    }
-    logger.d(throwable, message, args);
-  }
-
-  private CanaryLog() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
deleted file mode 100644
index 812b6e64..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.os.Environment;
-import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
-import java.io.File;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.M;
-import static android.os.Environment.DIRECTORY_DOWNLOADS;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
-
-public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
-
-  private final Context context;
-
-  public DefaultLeakDirectoryProvider(Context context) {
-    this.context = context.getApplicationContext();
-  }
-
-  @Override public File leakDirectory() {
-    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
-    File directory = new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
-    boolean success = directory.mkdirs();
-    if (!success && !directory.exists()) {
-      throw new UnsupportedOperationException(
-          "Could not create leak directory " + directory.getPath());
-    }
-    return directory;
-  }
-
-  @Override public void requestWritePermissionNotification() {
-    if (hasStoragePermission()) {
-      return;
-    }
-    PendingIntent pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context);
-    String contentTitle = context.getString(R.string.leak_canary_permission_notification_title);
-    CharSequence packageName = context.getPackageName();
-    String contentText =
-        context.getString(R.string.leak_canary_permission_notification_text, packageName);
-    showNotification(context, contentTitle, contentText, pendingIntent);
-  }
-
-  @TargetApi(M) @Override public void requestPermission(Activity activity) {
-    if (hasStoragePermission()) {
-      return;
-    }
-    String[] permissions = {
-        WRITE_EXTERNAL_STORAGE
-    };
-    activity.requestPermissions(permissions, 42);
-  }
-
-  @Override public boolean isLeakStorageWritable() {
-    if (!hasStoragePermission()) {
-      return false;
-    }
-    String state = Environment.getExternalStorageState();
-    return Environment.MEDIA_MOUNTED.equals(state);
-  }
-
-  @TargetApi(M) private boolean hasStoragePermission() {
-    if (SDK_INT < M) {
-      return true;
-    }
-    return context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
deleted file mode 100644
index afdc4e94..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.PendingIntent;
-import android.content.res.Resources;
-import com.squareup.leakcanary.internal.DisplayLeakActivity;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.ObjectOutputStream;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.Locale;
-
-import static android.text.format.Formatter.formatShortFileSize;
-import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
-
-/**
- * Logs leak analysis results, and then shows a notification which will start {@link
- * DisplayLeakActivity}.
- *
- * You can extend this class and override {@link #afterDefaultHandling(HeapDump, AnalysisResult,
- * String)} to add custom behavior, e.g. uploading the heap dump.
- */
-public class DisplayLeakService extends AbstractAnalysisResultService {
-
-  @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
-    String leakInfo = leakInfo(this, heapDump, result, true);
-    CanaryLog.d(leakInfo);
-
-    boolean resultSaved = false;
-    boolean shouldSaveResult = result.leakFound || result.failure != null;
-    if (shouldSaveResult) {
-      heapDump = renameHeapdump(heapDump);
-      resultSaved = saveResult(heapDump, result);
-    }
-
-    PendingIntent pendingIntent;
-    String contentTitle;
-    String contentText;
-
-    if (!shouldSaveResult) {
-      contentTitle = getString(R.string.leak_canary_no_leak_title);
-      contentText = getString(R.string.leak_canary_no_leak_text);
-      pendingIntent = null;
-    } else if (resultSaved) {
-      pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
-
-      if (result.failure == null) {
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        if (result.excludedLeak) {
-          contentTitle = getString(R.string.leak_canary_leak_excluded, className, size);
-        } else {
-          contentTitle = getString(R.string.leak_canary_class_has_leaked, className, size);
-        }
-      } else {
-        contentTitle = getString(R.string.leak_canary_analysis_failed);
-      }
-      contentText = getString(R.string.leak_canary_notification_message);
-    } else {
-      contentTitle = getString(R.string.leak_canary_could_not_save_title);
-      contentText = getString(R.string.leak_canary_could_not_save_text);
-      pendingIntent = null;
-    }
-    showNotification(this, contentTitle, contentText, pendingIntent);
-    afterDefaultHandling(heapDump, result, leakInfo);
-  }
-
-  private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
-    File resultFile = new File(heapDump.heapDumpFile.getParentFile(),
-        heapDump.heapDumpFile.getName() + ".result");
-    FileOutputStream fos = null;
-    try {
-      fos = new FileOutputStream(resultFile);
-      ObjectOutputStream oos = new ObjectOutputStream(fos);
-      oos.writeObject(heapDump);
-      oos.writeObject(result);
-      return true;
-    } catch (IOException e) {
-      CanaryLog.d(e, "Could not save leak analysis result to disk.");
-    } finally {
-      if (fos != null) {
-        try {
-          fos.close();
-        } catch (IOException ignored) {
-        }
-      }
-    }
-    return false;
-  }
-
-  private HeapDump renameHeapdump(HeapDump heapDump) {
-    String fileName =
-        new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
-
-    File newFile = new File(heapDump.heapDumpFile.getParent(), fileName);
-    boolean renamed = heapDump.heapDumpFile.renameTo(newFile);
-    if (!renamed) {
-      CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
-          newFile.getPath());
-    }
-    heapDump =
-        new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName, heapDump.excludedRefs,
-            heapDump.watchDurationMs, heapDump.gcDurationMs, heapDump.heapDumpDurationMs);
-
-    Resources resources = getResources();
-    int maxStoredHeapDumps =
-        Math.max(resources.getInteger(R.integer.leak_canary_max_stored_leaks), 1);
-    File[] hprofFiles = heapDump.heapDumpFile.getParentFile().listFiles(new FilenameFilter() {
-      @Override public boolean accept(File dir, String filename) {
-        return filename.endsWith(".hprof");
-      }
-    });
-
-    if (hprofFiles.length > maxStoredHeapDumps) {
-      // Sort with oldest modified first.
-      Arrays.sort(hprofFiles, new Comparator<File>() {
-        @Override public int compare(File lhs, File rhs) {
-          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
-        }
-      });
-      boolean deleted = hprofFiles[0].delete();
-      if (!deleted) {
-        CanaryLog.d("Could not delete old hprof file %s", hprofFiles[0].getPath());
-      }
-    }
-    return heapDump;
-  }
-
-  /**
-   * You can override this method and do a blocking call to a server to upload the leak trace and
-   * the heap dump. Don't forget to check {@link AnalysisResult#leakFound} and {@link
-   * AnalysisResult#excludedLeak} first.
-   */
-  protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
deleted file mode 100644
index 1081ae34..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.app.Application;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.os.Build;
-import android.util.Log;
-import com.squareup.leakcanary.internal.DisplayLeakActivity;
-import com.squareup.leakcanary.internal.HeapAnalyzerService;
-
-import static android.text.format.Formatter.formatShortFileSize;
-import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
-import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
-
-public final class LeakCanary {
-
-  /**
-   * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
-   * references (on ICS+).
-   */
-  public static RefWatcher install(Application application) {
-    return install(application, DisplayLeakService.class,
-        AndroidExcludedRefs.createAppDefaults().build());
-  }
-
-  /**
-   * Creates a {@link RefWatcher} that reports results to the provided service, and starts watching
-   * activity references (on ICS+).
-   */
-  public static RefWatcher install(Application application,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass,
-      ExcludedRefs excludedRefs) {
-    if (isInAnalyzerProcess(application)) {
-      return RefWatcher.DISABLED;
-    }
-    enableDisplayLeakActivity(application);
-    HeapDump.Listener heapDumpListener =
-        new ServiceHeapDumpListener(application, listenerServiceClass);
-    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
-    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);
-    return refWatcher;
-  }
-
-  /**
-   * Creates a {@link RefWatcher} with a default configuration suitable for Android.
-   */
-  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
-      ExcludedRefs excludedRefs) {
-    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);
-    heapDumper.cleanup();
-    Resources resources = context.getResources();
-    int watchDelayMillis = resources.getInteger(R.integer.leak_canary_watch_delay_millis);
-    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);
-    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,
-        heapDumpListener, excludedRefs);
-  }
-
-  public static void enableDisplayLeakActivity(Context context) {
-    setEnabled(context, DisplayLeakActivity.class, true);
-  }
-
-  public static void setDisplayLeakActivityDirectoryProvider(
-      LeakDirectoryProvider leakDirectoryProvider) {
-    DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
-  }
-
-  /** Returns a string representation of the result of a heap analysis. */
-  public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
-      boolean detailed) {
-    PackageManager packageManager = context.getPackageManager();
-    String packageName = context.getPackageName();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(packageName, 0);
-    } catch (PackageManager.NameNotFoundException e) {
-      throw new RuntimeException(e);
-    }
-    String versionName = packageInfo.versionName;
-    int versionCode = packageInfo.versionCode;
-    String info = "In " + packageName + ":" + versionName + ":" + versionCode + ".\n";
-    String detailedString = "";
-    if (result.leakFound) {
-      if (result.excludedLeak) {
-        info += "* EXCLUDED LEAK.\n";
-      }
-      info += "* " + result.className;
-      if (!heapDump.referenceName.equals("")) {
-        info += " (" + heapDump.referenceName + ")";
-      }
-      info += " has leaked:\n" + result.leakTrace.toString() + "\n";
-      info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
-      if (detailed) {
-        detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
-      }
-    } else if (result.failure != null) {
-      // We duplicate the library version & Sha information because bug reports often only contain
-      // the stacktrace.
-      info += "* FAILURE in " + LIBRARY_VERSION + " " + GIT_SHA + ":" + Log.getStackTraceString(
-          result.failure) + "\n";
-    } else {
-      info += "* NO LEAK FOUND.\n\n";
-    }
-    if (detailed) {
-      detailedString += "* Excluded Refs:\n" + heapDump.excludedRefs;
-    }
-
-    info += "* Reference Key: "
-        + heapDump.referenceKey
-        + "\n"
-        + "* Device: "
-        + Build.MANUFACTURER
-        + " "
-        + Build.BRAND
-        + " "
-        + Build.MODEL
-        + " "
-        + Build.PRODUCT
-        + "\n"
-        + "* Android Version: "
-        + Build.VERSION.RELEASE
-        + " API: "
-        + Build.VERSION.SDK_INT
-        + " LeakCanary: "
-        + LIBRARY_VERSION
-        + " "
-        + GIT_SHA
-        + "\n"
-        + "* Durations: watch="
-        + heapDump.watchDurationMs
-        + "ms, gc="
-        + heapDump.gcDurationMs
-        + "ms, heap dump="
-        + heapDump.heapDumpDurationMs
-        + "ms, analysis="
-        + result.analysisDurationMs
-        + "ms"
-        + "\n"
-        + detailedString;
-
-    return info;
-  }
-
-  /**
-   * Whether the current process is the process running the {@link HeapAnalyzerService}, which is
-   * a different process than the normal app process.
-   */
-  public static boolean isInAnalyzerProcess(Context context) {
-    return isInServiceProcess(context, HeapAnalyzerService.class);
-  }
-
-  private LeakCanary() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
deleted file mode 100644
index 2ccb1422..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ServiceHeapDumpListener.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import android.content.Context;
-import com.squareup.leakcanary.internal.HeapAnalyzerService;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
-
-public final class ServiceHeapDumpListener implements HeapDump.Listener {
-
-  private final Context context;
-  private final Class<? extends AbstractAnalysisResultService> listenerServiceClass;
-
-  public ServiceHeapDumpListener(Context context,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    setEnabled(context, listenerServiceClass, true);
-    setEnabled(context, HeapAnalyzerService.class, true);
-    this.listenerServiceClass = checkNotNull(listenerServiceClass, "listenerServiceClass");
-    this.context = checkNotNull(context, "context").getApplicationContext();
-  }
-
-  @Override public void analyze(HeapDump heapDump) {
-    checkNotNull(heapDump, "heapDump");
-    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
deleted file mode 100644
index 4ab1baf2..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ /dev/null
@@ -1,522 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.text.format.DateUtils;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.ListAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
-import com.squareup.leakcanary.HeapDump;
-import com.squareup.leakcanary.LeakDirectoryProvider;
-import com.squareup.leakcanary.R;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FilenameFilter;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.concurrent.Executor;
-
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
-import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
-import static android.text.format.Formatter.formatShortFileSize;
-import static android.view.View.GONE;
-import static android.view.View.VISIBLE;
-import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
-import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
-import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
-
-@SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-public final class DisplayLeakActivity extends Activity {
-
-  private static LeakDirectoryProvider leakDirectoryProvider = null;
-
-  private static final String SHOW_LEAK_EXTRA = "show_latest";
-
-  public static PendingIntent createPendingIntent(Context context) {
-    return createPendingIntent(context, null);
-  }
-
-  public static PendingIntent createPendingIntent(Context context, String referenceKey) {
-    Intent intent = new Intent(context, DisplayLeakActivity.class);
-    intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
-    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
-    DisplayLeakActivity.leakDirectoryProvider = leakDirectoryProvider;
-  }
-
-  private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
-    LeakDirectoryProvider leakDirectoryProvider = DisplayLeakActivity.leakDirectoryProvider;
-    if (leakDirectoryProvider == null) {
-      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
-    }
-    return leakDirectoryProvider;
-  }
-
-  // null until it's been first loaded.
-  List<Leak> leaks;
-  String visibleLeakRefKey;
-
-  private ListView listView;
-  private TextView failureView;
-  private Button actionButton;
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState != null) {
-      visibleLeakRefKey = savedInstanceState.getString("visibleLeakRefKey");
-    } else {
-      Intent intent = getIntent();
-      if (intent.hasExtra(SHOW_LEAK_EXTRA)) {
-        visibleLeakRefKey = intent.getStringExtra(SHOW_LEAK_EXTRA);
-      }
-    }
-
-    //noinspection unchecked
-    leaks = (List<Leak>) getLastNonConfigurationInstance();
-
-    setContentView(R.layout.leak_canary_display_leak);
-
-    listView = (ListView) findViewById(R.id.leak_canary_display_leak_list);
-    failureView = (TextView) findViewById(R.id.leak_canary_display_leak_failure);
-    actionButton = (Button) findViewById(R.id.leak_canary_action);
-
-    updateUi();
-  }
-
-  // No, it's not deprecated. Android lies.
-  @Override public Object onRetainNonConfigurationInstance() {
-    return leaks;
-  }
-
-  @Override protected void onSaveInstanceState(Bundle outState) {
-    super.onSaveInstanceState(outState);
-    outState.putString("visibleLeakRefKey", visibleLeakRefKey);
-  }
-
-  @Override protected void onResume() {
-    super.onResume();
-    LeakDirectoryProvider leakDirectoryProvider = leakDirectoryProvider(this);
-    if (leakDirectoryProvider.isLeakStorageWritable()) {
-      File leakDirectory = leakDirectoryProvider.leakDirectory();
-      LoadLeaks.load(this, leakDirectory);
-    } else {
-      leakDirectoryProvider.requestPermission(this);
-    }
-  }
-
-  @Override public void setTheme(int resid) {
-    // We don't want this to be called with an incompatible theme.
-    // This could happen if you implement runtime switching of themes
-    // using ActivityLifecycleCallbacks.
-    if (resid != R.style.leak_canary_LeakCanary_Base) {
-      return;
-    }
-    super.setTheme(resid);
-  }
-
-  @Override protected void onDestroy() {
-    super.onDestroy();
-    LoadLeaks.forgetActivity();
-  }
-
-  @Override public boolean onCreateOptionsMenu(Menu menu) {
-    Leak visibleLeak = getVisibleLeak();
-    if (visibleLeak != null) {
-      menu.add(R.string.leak_canary_share_leak)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareLeak();
-              return true;
-            }
-          });
-      if (visibleLeak.heapDump.heapDumpFile.exists()) {
-        menu.add(R.string.leak_canary_share_heap_dump)
-            .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-              @Override public boolean onMenuItemClick(MenuItem item) {
-                shareHeapDump();
-                return true;
-              }
-            });
-      }
-      return true;
-    }
-    return false;
-  }
-
-  @Override public boolean onOptionsItemSelected(MenuItem item) {
-    if (item.getItemId() == android.R.id.home) {
-      visibleLeakRefKey = null;
-      updateUi();
-    }
-    return true;
-  }
-
-  @Override public void onBackPressed() {
-    if (visibleLeakRefKey != null) {
-      visibleLeakRefKey = null;
-      updateUi();
-    } else {
-      super.onBackPressed();
-    }
-  }
-
-  void shareLeak() {
-    Leak visibleLeak = getVisibleLeak();
-    String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("text/plain");
-    intent.putExtra(Intent.EXTRA_TEXT, leakInfo);
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  void shareHeapDump() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    heapDumpFile.setReadable(true, false);
-    Intent intent = new Intent(Intent.ACTION_SEND);
-    intent.setType("application/octet-stream");
-    intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(heapDumpFile));
-    startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
-  }
-
-  void deleteVisibleLeak() {
-    Leak visibleLeak = getVisibleLeak();
-    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
-    File resultFile = visibleLeak.resultFile;
-    boolean resultDeleted = resultFile.delete();
-    if (!resultDeleted) {
-      CanaryLog.d("Could not delete result file %s", resultFile.getPath());
-    }
-    boolean heapDumpDeleted = heapDumpFile.delete();
-    if (!heapDumpDeleted) {
-      CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
-    }
-    visibleLeakRefKey = null;
-    leaks.remove(visibleLeak);
-    updateUi();
-  }
-
-  void deleteAllLeaks() {
-    File leakDirectory = leakDirectoryProvider(DisplayLeakActivity.this).leakDirectory();
-    File[] files = leakDirectory.listFiles();
-    if (files != null) {
-      for (File file : files) {
-        boolean deleted = file.delete();
-        if (!deleted) {
-          CanaryLog.d("Could not delete file %s", file.getPath());
-        }
-      }
-    }
-    leaks = Collections.emptyList();
-    updateUi();
-  }
-
-  void updateUi() {
-    if (leaks == null) {
-      setTitle("Loading leaks...");
-      return;
-    }
-    if (leaks.isEmpty()) {
-      visibleLeakRefKey = null;
-    }
-
-    final Leak visibleLeak = getVisibleLeak();
-    if (visibleLeak == null) {
-      visibleLeakRefKey = null;
-    }
-
-    ListAdapter listAdapter = listView.getAdapter();
-    // Reset to defaults
-    listView.setVisibility(VISIBLE);
-    failureView.setVisibility(GONE);
-
-    if (visibleLeak != null) {
-      AnalysisResult result = visibleLeak.result;
-      if (result.failure != null) {
-        listView.setVisibility(GONE);
-        failureView.setVisibility(VISIBLE);
-        String failureMessage = getString(R.string.leak_canary_failure_report)
-            + LIBRARY_VERSION
-            + " "
-            + GIT_SHA
-            + "\n"
-            + Log.getStackTraceString(result.failure);
-        failureView.setText(failureMessage);
-        setTitle(R.string.leak_canary_analysis_failed);
-        invalidateOptionsMenu();
-        getActionBar().setDisplayHomeAsUpEnabled(true);
-        actionButton.setVisibility(VISIBLE);
-        actionButton.setText(R.string.leak_canary_delete);
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            deleteVisibleLeak();
-          }
-        });
-        listView.setAdapter(null);
-      } else {
-        final DisplayLeakAdapter adapter;
-        if (listAdapter instanceof DisplayLeakAdapter) {
-          adapter = (DisplayLeakAdapter) listAdapter;
-        } else {
-          adapter = new DisplayLeakAdapter();
-          listView.setAdapter(adapter);
-          listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-              adapter.toggleRow(position);
-            }
-          });
-          invalidateOptionsMenu();
-          getActionBar().setDisplayHomeAsUpEnabled(true);
-          actionButton.setVisibility(VISIBLE);
-          actionButton.setText(R.string.leak_canary_delete);
-          actionButton.setOnClickListener(new View.OnClickListener() {
-            @Override public void onClick(View v) {
-              deleteVisibleLeak();
-            }
-          });
-        }
-        HeapDump heapDump = visibleLeak.heapDump;
-        adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        String size = formatShortFileSize(this, result.retainedHeapSize);
-        String className = classSimpleName(result.className);
-        setTitle(getString(R.string.leak_canary_class_has_leaked, className, size));
-      }
-    } else {
-      if (listAdapter instanceof LeakListAdapter) {
-        ((LeakListAdapter) listAdapter).notifyDataSetChanged();
-      } else {
-        LeakListAdapter adapter = new LeakListAdapter();
-        listView.setAdapter(adapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-          @Override
-          public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-            visibleLeakRefKey = leaks.get(position).heapDump.referenceKey;
-            updateUi();
-          }
-        });
-        invalidateOptionsMenu();
-        setTitle(getString(R.string.leak_canary_leak_list_title, getPackageName()));
-        getActionBar().setDisplayHomeAsUpEnabled(false);
-        actionButton.setText(R.string.leak_canary_delete_all);
-        actionButton.setOnClickListener(new View.OnClickListener() {
-          @Override public void onClick(View v) {
-            deleteAllLeaks();
-          }
-        });
-      }
-      actionButton.setVisibility(leaks.size() == 0 ? GONE : VISIBLE);
-    }
-  }
-
-  Leak getVisibleLeak() {
-    if (leaks == null) {
-      return null;
-    }
-    for (Leak leak : leaks) {
-      if (leak.heapDump.referenceKey.equals(visibleLeakRefKey)) {
-        return leak;
-      }
-    }
-    return null;
-  }
-
-  class LeakListAdapter extends BaseAdapter {
-
-    @Override public int getCount() {
-      return leaks.size();
-    }
-
-    @Override public Leak getItem(int position) {
-      return leaks.get(position);
-    }
-
-    @Override public long getItemId(int position) {
-      return position;
-    }
-
-    @Override public View getView(int position, View convertView, ViewGroup parent) {
-      if (convertView == null) {
-        convertView = LayoutInflater.from(DisplayLeakActivity.this)
-            .inflate(R.layout.leak_canary_leak_row, parent, false);
-      }
-      TextView titleView = (TextView) convertView.findViewById(R.id.leak_canary_row_text);
-      TextView timeView = (TextView) convertView.findViewById(R.id.leak_canary_row_time);
-      Leak leak = getItem(position);
-
-      String index = (leaks.size() - position) + ". ";
-
-      String title;
-      if (leak.result.failure == null) {
-        String className = classSimpleName(leak.result.className);
-        String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
-        title = getString(R.string.leak_canary_class_has_leaked, className, size);
-        if (leak.result.excludedLeak) {
-          title = getString(R.string.leak_canary_excluded_row, title);
-        }
-        title = index + title;
-      } else {
-        title = index
-            + leak.result.failure.getClass().getSimpleName()
-            + " "
-            + leak.result.failure.getMessage();
-      }
-      titleView.setText(title);
-      String time =
-          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.resultFile.lastModified(),
-              FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
-      timeView.setText(time);
-      return convertView;
-    }
-  }
-
-  static class Leak {
-    final HeapDump heapDump;
-    final AnalysisResult result;
-    final File resultFile;
-
-    Leak(HeapDump heapDump, AnalysisResult result, File resultFile) {
-      this.heapDump = heapDump;
-      this.result = result;
-      this.resultFile = resultFile;
-    }
-  }
-
-  static class LoadLeaks implements Runnable {
-
-    static final List<LoadLeaks> inFlight = new ArrayList<>();
-
-    static final Executor backgroundExecutor = newSingleThreadExecutor("LoadLeaks");
-
-    static void load(DisplayLeakActivity activity, File leakDirectory) {
-      LoadLeaks loadLeaks = new LoadLeaks(activity, leakDirectory);
-      inFlight.add(loadLeaks);
-      backgroundExecutor.execute(loadLeaks);
-    }
-
-    static void forgetActivity() {
-      for (LoadLeaks loadLeaks : inFlight) {
-        loadLeaks.activityOrNull = null;
-      }
-      inFlight.clear();
-    }
-
-    DisplayLeakActivity activityOrNull;
-    private final File leakDirectory;
-    private final Handler mainHandler;
-
-    LoadLeaks(DisplayLeakActivity activity, File leakDirectory) {
-      this.activityOrNull = activity;
-      this.leakDirectory = leakDirectory;
-      mainHandler = new Handler(Looper.getMainLooper());
-    }
-
-    @Override public void run() {
-      final List<Leak> leaks = new ArrayList<>();
-      File[] files = leakDirectory.listFiles(new FilenameFilter() {
-        @Override public boolean accept(File dir, String filename) {
-          return filename.endsWith(".result");
-        }
-      });
-
-      if (files != null) {
-        for (File resultFile : files) {
-          FileInputStream fis = null;
-          try {
-            fis = new FileInputStream(resultFile);
-            ObjectInputStream ois = new ObjectInputStream(fis);
-            HeapDump heapDump = (HeapDump) ois.readObject();
-            AnalysisResult result = (AnalysisResult) ois.readObject();
-            leaks.add(new Leak(heapDump, result, resultFile));
-          } catch (IOException | ClassNotFoundException e) {
-            // Likely a change in the serializable result class.
-            // Let's remove the files, we can't read them anymore.
-            boolean deleted = resultFile.delete();
-            if (deleted) {
-              CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
-            } else {
-              CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
-                  resultFile);
-            }
-          } finally {
-            if (fis != null) {
-              try {
-                fis.close();
-              } catch (IOException ignored) {
-              }
-            }
-          }
-        }
-        Collections.sort(leaks, new Comparator<Leak>() {
-          @Override public int compare(Leak lhs, Leak rhs) {
-            return Long.valueOf(rhs.resultFile.lastModified())
-                .compareTo(lhs.resultFile.lastModified());
-          }
-        });
-      }
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          inFlight.remove(LoadLeaks.this);
-          if (activityOrNull != null) {
-            activityOrNull.leaks = leaks;
-            activityOrNull.updateUi();
-          }
-        }
-      });
-    }
-  }
-
-  static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
deleted file mode 100644
index fd23cfbd..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.text.Html;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.BaseAdapter;
-import android.widget.TextView;
-import com.squareup.leakcanary.Exclusion;
-import com.squareup.leakcanary.LeakTrace;
-import com.squareup.leakcanary.LeakTraceElement;
-import com.squareup.leakcanary.R;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
-import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
-import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
-
-final class DisplayLeakAdapter extends BaseAdapter {
-
-  private static final int TOP_ROW = 0;
-  private static final int NORMAL_ROW = 1;
-
-  private boolean[] opened = new boolean[0];
-
-  private List<LeakTraceElement> elements = Collections.emptyList();
-  private String referenceKey;
-  private String referenceName = "";
-
-  @Override public View getView(int position, View convertView, ViewGroup parent) {
-    Context context = parent.getContext();
-    if (getItemViewType(position) == TOP_ROW) {
-      if (convertView == null) {
-        convertView =
-            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_top_row, parent, false);
-      }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
-      textView.setText(context.getPackageName());
-    } else {
-      if (convertView == null) {
-        convertView =
-            LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
-      }
-      TextView textView = findById(convertView, R.id.leak_canary_row_text);
-
-      boolean isRoot = position == 1;
-      boolean isLeakingInstance = position == getCount() - 1;
-      LeakTraceElement element = getItem(position);
-      String htmlString = elementToHtmlString(element, isRoot, opened[position]);
-      if (isLeakingInstance && !referenceName.equals("") && opened[position]) {
-        htmlString += " <font color='#919191'>" + referenceName + "</font>";
-      }
-      textView.setText(Html.fromHtml(htmlString));
-
-      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
-      if (isRoot) {
-        connector.setType(DisplayLeakConnectorView.Type.START);
-      } else {
-        if (isLeakingInstance) {
-          connector.setType(DisplayLeakConnectorView.Type.END);
-        } else {
-          connector.setType(DisplayLeakConnectorView.Type.NODE);
-        }
-      }
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
-      moreDetailsView.setOpened(opened[position]);
-    }
-
-    return convertView;
-  }
-
-  private String elementToHtmlString(LeakTraceElement element, boolean root, boolean opened) {
-    String htmlString = "";
-
-    if (element.referenceName == null) {
-      htmlString += "leaks ";
-    } else if (!root) {
-      htmlString += "references ";
-    }
-
-    if (element.type == STATIC_FIELD) {
-      htmlString += "<font color='#c48a47'>static</font> ";
-    }
-
-    if (element.holder == ARRAY || element.holder == THREAD) {
-      htmlString += "<font color='#f3cf83'>" + element.holder.name().toLowerCase() + "</font> ";
-    }
-
-    int separator = element.className.lastIndexOf('.');
-    String qualifier;
-    String simpleName;
-    if (separator == -1) {
-      qualifier = "";
-      simpleName = element.className;
-    } else {
-      qualifier = element.className.substring(0, separator + 1);
-      simpleName = element.className.substring(separator + 1);
-    }
-
-    if (opened) {
-      htmlString += "<font color='#919191'>" + qualifier + "</font>";
-    }
-
-    String styledClassName = "<font color='#ffffff'>" + simpleName + "</font>";
-
-    htmlString += styledClassName;
-
-    if (element.referenceName != null) {
-      htmlString += ".<font color='#998bb5'>" + element.referenceName.replaceAll("<", "&lt;")
-          .replaceAll(">", "&gt;") + "</font>";
-    } else {
-      htmlString += " <font color='#f3cf83'>instance</font>";
-    }
-
-    if (opened && element.extra != null) {
-      htmlString += " <font color='#919191'>" + element.extra + "</font>";
-    }
-
-    Exclusion exclusion = element.exclusion;
-    if (exclusion != null) {
-      if (opened) {
-        htmlString += "<br/><br/>Excluded by rule";
-        if (exclusion.name != null) {
-          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
-        }
-        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
-        if (exclusion.reason != null) {
-          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
-        }
-      } else {
-        htmlString += " (excluded)";
-      }
-    }
-
-    return htmlString;
-  }
-
-  public void update(LeakTrace leakTrace, String referenceKey, String referenceName) {
-    if (referenceKey.equals(this.referenceKey)) {
-      // Same data, nothing to change.
-      return;
-    }
-    this.referenceKey = referenceKey;
-    this.referenceName = referenceName;
-    this.elements = new ArrayList<>(leakTrace.elements);
-    opened = new boolean[1 + elements.size()];
-    notifyDataSetChanged();
-  }
-
-  public void toggleRow(int position) {
-    opened[position] = !opened[position];
-    notifyDataSetChanged();
-  }
-
-  @Override public int getCount() {
-    return 1 + elements.size();
-  }
-
-  @Override public LeakTraceElement getItem(int position) {
-    if (getItemViewType(position) == TOP_ROW) {
-      return null;
-    }
-    return elements.get(position - 1);
-  }
-
-  @Override public int getViewTypeCount() {
-    return 2;
-  }
-
-  @Override public int getItemViewType(int position) {
-    if (position == 0) {
-      return TOP_ROW;
-    }
-    return NORMAL_ROW;
-  }
-
-  @Override public long getItemId(int position) {
-    return position;
-  }
-
-  @SuppressWarnings("unchecked") private static <T extends View> T findById(View view, int id) {
-    return (T) view.findViewById(id);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
deleted file mode 100644
index e854ac2a..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakConnectorView.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.util.AttributeSet;
-import android.view.View;
-
-import static android.graphics.Bitmap.Config.ARGB_8888;
-
-public final class DisplayLeakConnectorView extends View {
-
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint rootPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint leakPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-  private static final Paint clearPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.LIGHT_GREY);
-    rootPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-    leakPaint.setColor(LeakCanaryUi.LEAK_COLOR);
-    clearPaint.setColor(Color.TRANSPARENT);
-    clearPaint.setXfermode(LeakCanaryUi.CLEAR_XFER_MODE);
-  }
-
-  public enum Type {
-    START, NODE, END
-  }
-
-  private Type type;
-  private Bitmap cache;
-
-  public DisplayLeakConnectorView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    type = Type.NODE;
-  }
-
-  @SuppressWarnings("SuspiciousNameCombination") @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-
-    if (cache != null && (cache.getWidth() != width || cache.getHeight() != height)) {
-      cache.recycle();
-      cache = null;
-    }
-
-    if (cache == null) {
-      cache = Bitmap.createBitmap(width, height, ARGB_8888);
-
-      Canvas cacheCanvas = new Canvas(cache);
-
-      float halfWidth = width / 2f;
-      float halfHeight = height / 2f;
-      float thirdWidth = width / 3f;
-
-      float strokeSize = LeakCanaryUi.dpToPixel(4f, getResources());
-
-      iconPaint.setStrokeWidth(strokeSize);
-      rootPaint.setStrokeWidth(strokeSize);
-
-      switch (type) {
-        case NODE:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-          break;
-        case START:
-          float radiusClear = halfWidth - strokeSize / 2f;
-          cacheCanvas.drawRect(0, 0, width, radiusClear, rootPaint);
-          cacheCanvas.drawCircle(0, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawCircle(width, radiusClear, radiusClear, clearPaint);
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, rootPaint);
-          cacheCanvas.drawLine(halfWidth, halfHeight, halfWidth, height, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, halfWidth, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, clearPaint);
-          break;
-        default:
-          cacheCanvas.drawLine(halfWidth, 0, halfWidth, halfHeight, iconPaint);
-          cacheCanvas.drawCircle(halfWidth, halfHeight, thirdWidth, leakPaint);
-          break;
-      }
-    }
-    canvas.drawBitmap(cache, 0, 0, null);
-  }
-
-  public void setType(Type type) {
-    if (type != this.type) {
-      this.type = type;
-      if (cache != null) {
-        cache.recycle();
-        cache = null;
-      }
-      invalidate();
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
deleted file mode 100644
index 8cd6b27f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FutureResult.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-
-public final class FutureResult<T> {
-
-  private final AtomicReference<T> resultHolder;
-  private final CountDownLatch latch;
-
-  public FutureResult() {
-    resultHolder = new AtomicReference<>();
-    latch = new CountDownLatch(1);
-  }
-
-  public boolean wait(long timeout, TimeUnit unit) {
-    try {
-      return latch.await(timeout, unit);
-    } catch (InterruptedException e) {
-      throw new RuntimeException("Did not expect thread to be interrupted", e);
-    }
-  }
-
-  public T get() {
-    if (latch.getCount() > 0) {
-      throw new IllegalStateException("Call wait() and check its result");
-    }
-    return resultHolder.get();
-  }
-
-  public void set(T result) {
-    resultHolder.set(result);
-    latch.countDown();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
deleted file mode 100644
index d03dad94..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.app.IntentService;
-import android.content.Context;
-import android.content.Intent;
-import com.squareup.leakcanary.AbstractAnalysisResultService;
-import com.squareup.leakcanary.AnalysisResult;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.HeapAnalyzer;
-import com.squareup.leakcanary.HeapDump;
-
-/**
- * This service runs in a separate process to avoid slowing down the app process or making it run
- * out of memory.
- */
-public final class HeapAnalyzerService extends IntentService {
-
-  private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
-  private static final String HEAPDUMP_EXTRA = "heapdump_extra";
-
-  public static void runAnalysis(Context context, HeapDump heapDump,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
-    Intent intent = new Intent(context, HeapAnalyzerService.class);
-    intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());
-    intent.putExtra(HEAPDUMP_EXTRA, heapDump);
-    context.startService(intent);
-  }
-
-  public HeapAnalyzerService() {
-    super(HeapAnalyzerService.class.getSimpleName());
-  }
-
-  @Override protected void onHandleIntent(Intent intent) {
-    if (intent == null) {
-      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
-      return;
-    }
-    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
-    HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
-
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);
-
-    AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
-    AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
deleted file mode 100644
index cdb5a055..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.ActivityManager;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.ServiceInfo;
-import com.squareup.leakcanary.CanaryLog;
-import com.squareup.leakcanary.R;
-import java.lang.reflect.Method;
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
-import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
-import static android.content.pm.PackageManager.DONT_KILL_APP;
-import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.HONEYCOMB;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-
-public final class LeakCanaryInternals {
-
-  public static final String SAMSUNG = "samsung";
-  public static final String MOTOROLA = "motorola";
-  public static final String LG = "LGE";
-  public static final String NVIDIA = "NVIDIA";
-
-  private static final Executor fileIoExecutor = newSingleThreadExecutor("File-IO");
-
-  public static void executeOnFileIoThread(Runnable runnable) {
-    fileIoExecutor.execute(runnable);
-  }
-
-  /** Extracts the class simple name out of a string containing a fully qualified class name. */
-  public static String classSimpleName(String className) {
-    int separator = className.lastIndexOf('.');
-    if (separator == -1) {
-      return className;
-    } else {
-      return className.substring(separator + 1);
-    }
-  }
-
-  public static void setEnabled(Context context, final Class<?> componentClass,
-      final boolean enabled) {
-    final Context appContext = context.getApplicationContext();
-    executeOnFileIoThread(new Runnable() {
-      @Override public void run() {
-        setEnabledBlocking(appContext, componentClass, enabled);
-      }
-    });
-  }
-
-  public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
-      boolean enabled) {
-    ComponentName component = new ComponentName(appContext, componentClass);
-    PackageManager packageManager = appContext.getPackageManager();
-    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-    // Blocks on IPC.
-    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
-  }
-
-  public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
-    PackageManager packageManager = context.getPackageManager();
-    PackageInfo packageInfo;
-    try {
-      packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
-    } catch (Exception e) {
-      CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
-      return false;
-    }
-    String mainProcess = packageInfo.applicationInfo.processName;
-
-    ComponentName component = new ComponentName(context, serviceClass);
-    ServiceInfo serviceInfo;
-    try {
-      serviceInfo = packageManager.getServiceInfo(component, 0);
-    } catch (PackageManager.NameNotFoundException ignored) {
-      // Service is disabled.
-      return false;
-    }
-
-    if (serviceInfo.processName.equals(mainProcess)) {
-      CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
-      // Technically we are in the service process, but we're not in the service dedicated process.
-      return false;
-    }
-
-    int myPid = android.os.Process.myPid();
-    ActivityManager activityManager =
-        (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-    ActivityManager.RunningAppProcessInfo myProcess = null;
-    List<ActivityManager.RunningAppProcessInfo> runningProcesses =
-        activityManager.getRunningAppProcesses();
-    if (runningProcesses != null) {
-      for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
-        if (process.pid == myPid) {
-          myProcess = process;
-          break;
-        }
-      }
-    }
-    if (myProcess == null) {
-      CanaryLog.d("Could not find running process for %d", myPid);
-      return false;
-    }
-
-    return myProcess.processName.equals(serviceInfo.processName);
-  }
-
-  @TargetApi(HONEYCOMB)
-  public static void showNotification(Context context, CharSequence contentTitle,
-      CharSequence contentText, PendingIntent pendingIntent) {
-    NotificationManager notificationManager =
-        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-
-    Notification notification;
-    if (SDK_INT < HONEYCOMB) {
-      notification = new Notification();
-      notification.icon = R.drawable.leak_canary_notification;
-      notification.when = System.currentTimeMillis();
-      notification.flags |= Notification.FLAG_AUTO_CANCEL;
-      try {
-        Method method =
-            Notification.class.getMethod("setLatestEventInfo", Context.class, CharSequence.class,
-                CharSequence.class, PendingIntent.class);
-        method.invoke(notification, context, contentTitle, contentText, pendingIntent);
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    } else {
-      Notification.Builder builder = new Notification.Builder(context) //
-          .setSmallIcon(R.drawable.leak_canary_notification)
-          .setWhen(System.currentTimeMillis())
-          .setContentTitle(contentTitle)
-          .setContentText(contentText)
-          .setAutoCancel(true)
-          .setContentIntent(pendingIntent);
-      if (SDK_INT < JELLY_BEAN) {
-        notification = builder.getNotification();
-      } else {
-        notification = builder.build();
-      }
-    }
-    notificationManager.notify(0xDEAFBEEF, notification);
-  }
-
-  public static Executor newSingleThreadExecutor(String threadName) {
-    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
-  }
-
-  private LeakCanaryInternals() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
deleted file mode 100644
index 4eb3a3a0..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import java.util.concurrent.ThreadFactory;
-
-/**
- * This is intended to only be used with a single thread executor.
- */
-final class LeakCanarySingleThreadFactory implements ThreadFactory {
-
-  private final String threadName;
-
-  LeakCanarySingleThreadFactory(String threadName) {
-    this.threadName = "LeakCanary-" + threadName;
-  }
-
-  @Override public Thread newThread(Runnable runnable) {
-    return new Thread(runnable, threadName);
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
deleted file mode 100644
index 74fbf986..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryUi.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.res.Resources;
-import android.graphics.PorterDuffXfermode;
-import android.util.DisplayMetrics;
-
-import static android.graphics.PorterDuff.Mode.CLEAR;
-
-final class LeakCanaryUi {
-  static final int LIGHT_GREY = 0xFFbababa;
-  static final int ROOT_COLOR = 0xFF84a6c5;
-  static final int LEAK_COLOR = 0xFFb1554e;
-
-  static final PorterDuffXfermode CLEAR_XFER_MODE = new PorterDuffXfermode(CLEAR);
-
-  /**
-   * Converts from device independent pixels (dp or dip) to
-   * device dependent pixels. This method returns the input
-   * multiplied by the display's density. The result is not
-   * rounded nor clamped.
-   *
-   * The value returned by this method is well suited for
-   * drawing with the Canvas API but should not be used to
-   * set layout dimensions.
-   *
-   * @param dp The value in dp to convert to pixels
-   * @param resources An instances of Resources
-   */
-  static float dpToPixel(float dp, Resources resources) {
-    DisplayMetrics metrics = resources.getDisplayMetrics();
-    return metrics.density * dp;
-  }
-
-  private LeakCanaryUi() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
deleted file mode 100644
index 81bf8a0f..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/MoreDetailsView.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.util.AttributeSet;
-import android.view.View;
-
-public final class MoreDetailsView extends View {
-
-  private static final Paint iconPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-  static {
-    iconPaint.setColor(LeakCanaryUi.ROOT_COLOR);
-  }
-
-  public MoreDetailsView(Context context, AttributeSet attrs) {
-    super(context, attrs);
-
-    float strokeSize = LeakCanaryUi.dpToPixel(2f, getResources());
-    iconPaint.setStrokeWidth(strokeSize);
-  }
-
-  private boolean opened;
-
-  @Override protected void onDraw(Canvas canvas) {
-    int width = getWidth();
-    int height = getHeight();
-    int halfHeight = height / 2;
-    int halfWidth = width / 2;
-
-    if (opened) {
-      canvas.drawLine(0, halfHeight, width, halfHeight, iconPaint);
-    } else {
-      canvas.drawLine(0, halfHeight, width, halfHeight, iconPaint);
-      canvas.drawLine(halfWidth, 0, halfWidth, height, iconPaint);
-    }
-  }
-
-  public void setOpened(boolean opened) {
-    if (opened != this.opened) {
-      this.opened = opened;
-      invalidate();
-    }
-  }
-}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
deleted file mode 100644
index 3d8a23f1..00000000
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary.internal;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Bundle;
-import android.widget.Toast;
-import com.squareup.leakcanary.R;
-
-import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
-import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
-import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
-import static android.content.pm.PackageManager.PERMISSION_GRANTED;
-import static android.os.Build.VERSION_CODES.M;
-import static android.widget.Toast.LENGTH_LONG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
-
-@TargetApi(M) //
-public class RequestStoragePermissionActivity extends Activity {
-
-  public static PendingIntent createPendingIntent(Context context) {
-    setEnabledBlocking(context, RequestStoragePermissionActivity.class, true);
-    Intent intent = new Intent(context, RequestStoragePermissionActivity.class);
-    intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TOP);
-    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
-  }
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    if (savedInstanceState == null) {
-      if (hasStoragePermission()) {
-        finish();
-        return;
-      }
-      String[] permissions = {
-          WRITE_EXTERNAL_STORAGE
-      };
-      requestPermissions(permissions, 42);
-    }
-  }
-
-  @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
-      int[] grantResults) {
-    if (!hasStoragePermission()) {
-      Toast.makeText(getApplication(), R.string.leak_canary_permission_not_granted, LENGTH_LONG)
-          .show();
-    }
-    finish();
-  }
-
-  private boolean hasStoragePermission() {
-    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
-  }
-}
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 07bb09fc..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
deleted file mode 100755
index 74348d82..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png
deleted file mode 100755
index 13b33116..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 9738ad81..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
deleted file mode 100755
index 37f5057f..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png
deleted file mode 100755
index dc92783b..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 538e0214..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
deleted file mode 100755
index 56a94f27..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png
deleted file mode 100755
index 1e1b977f..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index d3ef4b71..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
deleted file mode 100755
index 34b7d41b..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png
deleted file mode 100755
index c652efdd..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 4713f18d..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
deleted file mode 100755
index 855d6052..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png
deleted file mode 100755
index bb458f2c..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml b/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
deleted file mode 100644
index a90b8c2c..00000000
--- a/leakcanary-android/src/main/res/drawable/leak_canary_toast_background.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<shape xmlns:android="http://schemas.android.com/apk/res/android">
-  <solid android:color="#cc000000"/>
-  <corners android:radius="16dp"/>
-</shape>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
deleted file mode 100644
index 8e56c3d1..00000000
--- a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
+++ /dev/null
@@ -1,46 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:orientation="vertical"
-    android:background="#3c3c3c"
-    >
-  <ListView
-      android:id="@+id/leak_canary_display_leak_list"
-      android:layout_width="match_parent"
-      android:layout_height="0dp"
-      android:layout_weight="1"
-      android:dividerHeight="0dp"
-      android:divider="@null"
-      />
-  <TextView
-      android:id="@+id/leak_canary_display_leak_failure"
-      android:layout_width="match_parent"
-      android:layout_height="0dp"
-      android:layout_weight="1"
-      android:textSize="12sp"
-      android:visibility="gone"
-      />
-  <Button
-      android:id="@+id/leak_canary_action"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:visibility="gone"
-      />
-
-</LinearLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml b/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
deleted file mode 100644
index d6057ed2..00000000
--- a/leakcanary-android/src/main/res/layout/leak_canary_heap_dump_toast.xml
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="wrap_content"
-    android:layout_height="wrap_content"
-    android:orientation="vertical"
-    android:background="@drawable/leak_canary_toast_background"
-    android:padding="16dp"
-    >
-  <ImageView
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      android:layout_gravity="center_horizontal"
-      android:src="@drawable/leak_canary_icon"/>
-
-  <TextView
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      android:layout_gravity="center_horizontal"
-      android:textColor="#ffffff"
-      android:textSize="18sp"
-      android:text="@string/leak_canary_toast_heap_dump"
-      />
-
-</LinearLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
deleted file mode 100644
index c5c5ac7f..00000000
--- a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
+++ /dev/null
@@ -1,43 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:padding="16dp"
-    android:orientation="horizontal"
-    >
-
-  <TextView
-      android:id="@+id/leak_canary_row_text"
-      android:layout_width="0dp"
-      android:layout_weight="1"
-      android:layout_height="wrap_content"
-      android:layout_gravity="center_vertical"
-      android:textSize="18sp"
-      />
-
-  <TextView
-      android:id="@+id/leak_canary_row_time"
-      android:layout_width="wrap_content"
-      android:layout_height="wrap_content"
-      android:layout_gravity="center_vertical"
-      android:textColor="#919191"
-      android:textSize="14sp"
-      />
-
-</LinearLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
deleted file mode 100644
index 947af46c..00000000
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:orientation="horizontal"
-    >
-
-  <com.squareup.leakcanary.internal.DisplayLeakConnectorView
-      android:id="@+id/leak_canary_row_connector"
-      android:layout_width="16dp"
-      android:layout_height="match_parent"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
-      />
-
-  <TextView
-      android:id="@+id/leak_canary_row_text"
-      android:layout_width="0dp"
-      android:layout_weight="1"
-      android:layout_height="wrap_content"
-      android:layout_gravity="center_vertical"
-      />
-
-  <com.squareup.leakcanary.internal.MoreDetailsView
-      android:id="@+id/leak_canary_row_more"
-      android:layout_width="12dp"
-      android:layout_height="12dp"
-      android:layout_gravity="center_vertical"
-      android:layout_marginStart="16dp"
-      android:layout_marginEnd="16dp"
-      />
-
-</LinearLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
deleted file mode 100644
index c4803b76..00000000
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<TextView
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/leak_canary_row_text"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:layout_margin="16dp"
-    android:textSize="18sp"
-    android:background="#84a6c5"
-    android:padding="16dp"
-    android:textColor="#ffffff"
-    />
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
deleted file mode 100644
index a176ac0d..00000000
--- a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?><!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-    <string name="leak_canary_class_has_leaked">%1$s hat %2$s geleaked</string>
-    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
-    <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
-    <string name="leak_canary_leak_list_title">Leaks in %s</string>
-    <string name="leak_canary_notification_message">Für mehr Details hier klicken</string>
-    <string name="leak_canary_share_leak">Info teilen</string>
-    <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
-    <string name="leak_canary_share_with">Teilen mit…</string>
-    <string name="leak_canary_display_activity_label">Leaks</string>
-    <string name="leak_canary_storage_permission_activity_label">Storage Berechtigung</string>
-    <string name="leak_canary_toast_heap_dump">Analysiere Speichert, die App wird einfrieren. Brrr.</string>
-    <string name="leak_canary_delete">Löschen</string>
-    <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary\n"</string>
-    <string name="leak_canary_delete_all">Alle löschen</string>
-    <string name="leak_canary_could_not_save_title">Konnte Ergebnis nicht speichern.</string>
-    <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
-    <string name="leak_canary_no_leak_title">Kein Leak gefunden</string>
-    <string name="leak_canary_no_leak_text">Der GC war untätig.</string>
-    <string name="leak_canary_excluded_row">[Ausgeschlossen] %s</string>
-    <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
-    <string name="leak_canary_permission_notification_title">Leak detektiert, benötige Berechtigung</string>
-    <string name="leak_canary_permission_notification_text">Hier klicken um Storage Berechtigung für %s zu aktivieren.</string>
-</resources>
diff --git a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
deleted file mode 100644
index 409cb66b..00000000
--- a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
-  </style>
-</resources>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml b/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
deleted file mode 100644
index 0a43b8f9..00000000
--- a/leakcanary-android/src/main/res/values-v21/leak_canary_themes.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Material">
-  </style>
-</resources>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/values/leak_canary_int.xml b/leakcanary-android/src/main/res/values/leak_canary_int.xml
deleted file mode 100644
index b7197372..00000000
--- a/leakcanary-android/src/main/res/values/leak_canary_int.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <integer name="leak_canary_max_stored_leaks">7</integer>
-  <integer name="leak_canary_watch_delay_millis">5000</integer>
-</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_public.xml b/leakcanary-android/src/main/res/values/leak_canary_public.xml
deleted file mode 100644
index b5f11b97..00000000
--- a/leakcanary-android/src/main/res/values/leak_canary_public.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-
-  <public name="leak_canary_display_activity_label" type="string"/>
-  <public name="leak_canary_heap_dump_toast" type="layout"/>
-  <public name="leak_canary_icon" type="drawable"/>
-  <public name="leak_canary_max_stored_leaks" type="integer"/>
-  <public name="leak_canary_watch_delay_millis" type="integer"/>
-
-</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
deleted file mode 100644
index d9aaee13..00000000
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
-  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
-  <string name="leak_canary_analysis_failed">Leak analysis failed</string>
-  <string name="leak_canary_leak_list_title">Leaks in %s</string>
-  <string name="leak_canary_notification_message">Click for more details</string>
-  <string name="leak_canary_share_leak">Share info</string>
-  <string name="leak_canary_share_heap_dump">Share heap dump</string>
-  <string name="leak_canary_share_with">Share with…</string>
-  <string name="leak_canary_display_activity_label">Leaks</string>
-  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
-  <string name="leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
-  <string name="leak_canary_delete">Delete</string>
-  <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
-  <string name="leak_canary_delete_all">Delete all</string>
-  <string name="leak_canary_could_not_save_title">Could not save result.</string>
-  <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
-  <string name="leak_canary_no_leak_title">No leak found</string>
-  <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
-  <string name="leak_canary_excluded_row">[Excluded] %s</string>
-  <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
-  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
-  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
-</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_themes.xml b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
deleted file mode 100644
index eebd0333..00000000
--- a/leakcanary-android/src/main/res/values/leak_canary_themes.xml
+++ /dev/null
@@ -1,28 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme">
-  </style>
-
-  <style name="leak_canary_Theme.Transparent" parent="android:Theme">
-    <item name="android:windowIsTranslucent">true</item>
-    <item name="android:windowBackground">@android:color/transparent</item>
-    <item name="android:windowContentOverlay">@null</item>
-    <item name="android:windowNoTitle">true</item>
-    <item name="android:backgroundDimEnabled">false</item>
-  </style>
-</resources>
diff --git a/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
deleted file mode 100644
index d80081b8..00000000
--- a/leakcanary-sample/build.gradle
+++ /dev/null
@@ -1,29 +0,0 @@
-apply plugin: 'com.android.application'
-
-dependencies {
-  debugCompile project(':leakcanary-android')
-  releaseCompile project(':leakcanary-android-no-op');
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-
-  compileOptions {
-    sourceCompatibility rootProject.ext.javaVersion
-    targetCompatibility rootProject.ext.javaVersion
-  }
-
-  defaultConfig {
-    applicationId "com.example.leakcanary"
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.compileSdkVersion
-
-    versionCode 1
-    versionName "1.0"
-  }
-
-  buildTypes {
-    debug
-  }
-}
diff --git a/leakcanary-sample/src/main/AndroidManifest.xml b/leakcanary-sample/src/main/AndroidManifest.xml
deleted file mode 100644
index d72ca551..00000000
--- a/leakcanary-sample/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<manifest
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.example.leakcanary"
-    >
-  <application android:name=".ExampleApplication" android:allowBackup="false"
-      android:icon="@drawable/ic_launcher"
-      >
-    <activity
-        android:label="@string/app_name"
-        android:name=".MainActivity"
-        >
-      <intent-filter>
-        <action android:name="android.intent.action.MAIN"/>
-        <category android:name="android.intent.category.LAUNCHER"/>
-        <category android:name="android.intent.category.DEFAULT"/>
-      </intent-filter>
-    </activity>
-  </application>
-</manifest>
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
deleted file mode 100644
index 942be776..00000000
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.leakcanary;
-
-import android.app.Application;
-import android.os.StrictMode;
-import com.squareup.leakcanary.LeakCanary;
-
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.GINGERBREAD;
-
-public class ExampleApplication extends Application {
-
-  @Override public void onCreate() {
-    super.onCreate();
-    enabledStrictMode();
-    LeakCanary.install(this);
-  }
-
-  private void enabledStrictMode() {
-    if (SDK_INT >= GINGERBREAD) {
-      StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
-          .detectAll() //
-          .penaltyLog() //
-          .penaltyDeath() //
-          .build());
-    }
-  }
-}
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
deleted file mode 100644
index 870f59b1..00000000
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.leakcanary;
-
-import android.app.Activity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.SystemClock;
-import android.view.View;
-
-public class MainActivity extends Activity {
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    setContentView(R.layout.main_activity);
-
-    View button = findViewById(R.id.async_task);
-    button.setOnClickListener(new View.OnClickListener() {
-      @Override public void onClick(View v) {
-        startAsyncTask();
-      }
-    });
-  }
-
-  void startAsyncTask() {
-    // This async task is an anonymous class and therefore has a hidden reference to the outer
-    // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation),
-    // the activity instance will leak.
-    new AsyncTask<Void, Void, Void>() {
-      @Override protected Void doInBackground(Void... params) {
-        // Do some slow work in background
-        SystemClock.sleep(20000);
-        return null;
-      }
-    }.execute();
-  }
-}
-
-
diff --git a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
deleted file mode 100755
index 65948fa3..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
deleted file mode 100755
index 5d826c42..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
deleted file mode 100755
index c9c7ec58..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
deleted file mode 100755
index cb8a98ab..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
deleted file mode 100755
index 3ca3a7f6..00000000
Binary files a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png and /dev/null differ
diff --git a/leakcanary-sample/src/main/res/layout/main_activity.xml b/leakcanary-sample/src/main/res/layout/main_activity.xml
deleted file mode 100644
index 2dc62d61..00000000
--- a/leakcanary-sample/src/main/res/layout/main_activity.xml
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<LinearLayout
-    xmlns:android="http://schemas.android.com/apk/res/android"
-    android:orientation="vertical"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    android:layout_margin="16dp"
-    >
-
-  <TextView
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:layout_marginBottom="16dp"
-      android:text="@string/helper_text"
-      />
-
-  <Button
-      android:id="@+id/async_task"
-      android:layout_width="match_parent"
-      android:layout_height="wrap_content"
-      android:text="@string/start_async_task"
-      />
-
-</LinearLayout>
\ No newline at end of file
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
deleted file mode 100644
index 9e5bf782..00000000
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <string name="app_name">LeakCanary Sample</string>
-  <string name="start_async_task">Start new AsyncTask</string>
-  <string name="helper_text">Start the async task, <b>rotate the screen</b> and wait for a bit. A
-    wild notification appears.
-  </string>
-  <string name="leak_canary_display_activity_label">Leaks Sample</string>
-</resources>
\ No newline at end of file
diff --git a/leakcanary-watcher/build.gradle b/leakcanary-watcher/build.gradle
deleted file mode 100644
index ac0cac77..00000000
--- a/leakcanary-watcher/build.gradle
+++ /dev/null
@@ -1,45 +0,0 @@
-version rootProject.ext.VERSION_NAME
-group rootProject.ext.GROUP
-
-buildscript {
-  repositories {
-    mavenCentral()
-  }
-}
-
-apply plugin: 'com.android.library'
-
-repositories {
-  mavenCentral()
-}
-
-dependencies {
-  testCompile 'junit:junit:4.12'
-}
-
-android.libraryVariants.all { variant ->
-  def name = variant.buildType.name
-  if (name.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
-    return; // Skip debug builds.
-  }
-  def task = project.tasks.create "jar${name.capitalize()}", Jar
-  task.dependsOn variant.javaCompile
-  task.from variant.javaCompile.destinationDir
-  artifacts.add('archives', task);
-}
-
-android {
-  compileSdkVersion rootProject.ext.compileSdkVersion
-  buildToolsVersion rootProject.ext.buildToolsVersion
-  defaultConfig {
-    minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
-  }
-}
-
-task sourceJar(type: Jar) {
-  from 'src/main/java'
-}
-
-apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-watcher/gradle.properties b/leakcanary-watcher/gradle.properties
deleted file mode 100644
index cbcadeeb..00000000
--- a/leakcanary-watcher/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-watcher
-POM_NAME=LeakCanary Watcher
-POM_PACKAGING=jar
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/AndroidManifest.xml b/leakcanary-watcher/src/main/AndroidManifest.xml
deleted file mode 100644
index 3f8d7ca9..00000000
--- a/leakcanary-watcher/src/main/AndroidManifest.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<manifest
-    package="com.squareup.leakcanary.watcher">
-  <application/>
-</manifest>
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
deleted file mode 100644
index fdd03be2..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/DebuggerControl.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-/**
- * Gives the opportunity to skip checking if a reference is gone when the debugger is connected.
- * An attached debugger might retain references and create false positives.
- */
-public interface DebuggerControl {
-  DebuggerControl NONE = new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      return false;
-    }
-  };
-
-  boolean isDebuggerAttached();
-}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
deleted file mode 100644
index 47662445..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.Collections.unmodifiableMap;
-
-/**
- * Prevents specific references from being taken into account when computing the shortest reference
- * path from a suspected leaking instance to the GC roots.
- *
- * This class lets you ignore known memory leaks that you know about. If the shortest path
- * matches {@link ExcludedRefs}, than the heap analyzer should look for a longer path with nothing
- * matching in {@link ExcludedRefs}.
- */
-public final class ExcludedRefs implements Serializable {
-
-  public static Builder builder() {
-    return new BuilderWithParams();
-  }
-
-  public final Map<String, Map<String, Exclusion>> fieldNameByClassName;
-  public final Map<String, Map<String, Exclusion>> staticFieldNameByClassName;
-  public final Map<String, Exclusion> threadNames;
-  public final Map<String, Exclusion> classNames;
-  public final Map<String, Exclusion> rootClassNames;
-
-  ExcludedRefs(BuilderWithParams builder) {
-    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName);
-    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName);
-    this.threadNames = unmodifiableRefMap(builder.threadNames);
-    this.classNames = unmodifiableRefMap(builder.classNames);
-    this.rootClassNames = unmodifiableRefMap(builder.rootClassNames);
-  }
-
-  private Map<String, Map<String, Exclusion>> unmodifiableRefStringMap(
-      Map<String, Map<String, ParamsBuilder>> mapmap) {
-    LinkedHashMap<String, Map<String, Exclusion>> fieldNameByClassName = new LinkedHashMap<>();
-    for (Map.Entry<String, Map<String, ParamsBuilder>> entry : mapmap.entrySet()) {
-      fieldNameByClassName.put(entry.getKey(), unmodifiableRefMap(entry.getValue()));
-    }
-    return unmodifiableMap(fieldNameByClassName);
-  }
-
-  private Map<String, Exclusion> unmodifiableRefMap(Map<String, ParamsBuilder> fieldBuilderMap) {
-    Map<String, Exclusion> fieldMap = new LinkedHashMap<>();
-    for (Map.Entry<String, ParamsBuilder> fieldEntry : fieldBuilderMap.entrySet()) {
-      fieldMap.put(fieldEntry.getKey(), new Exclusion(fieldEntry.getValue()));
-    }
-    return unmodifiableMap(fieldMap);
-  }
-
-  @Override public String toString() {
-    String string = "";
-    for (Map.Entry<String, Map<String, Exclusion>> classes : fieldNameByClassName.entrySet()) {
-      String clazz = classes.getKey();
-      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
-        String always = field.getValue().alwaysExclude ? " (always)" : "";
-        string += "| Field: " + clazz + "." + field.getKey() + always + "\n";
-      }
-    }
-    for (Map.Entry<String, Map<String, Exclusion>> classes : staticFieldNameByClassName.entrySet()) {
-      String clazz = classes.getKey();
-      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
-        String always = field.getValue().alwaysExclude ? " (always)" : "";
-        string += "| Static field: " + clazz + "." + field.getKey() + always + "\n";
-      }
-    }
-    for (Map.Entry<String, Exclusion> thread : threadNames.entrySet()) {
-      String always = thread.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Thread:" + thread.getKey() + always + "\n";
-    }
-    for (Map.Entry<String, Exclusion> clazz : classNames.entrySet()) {
-      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Class:" + clazz.getKey() + always + "\n";
-    }
-    for (Map.Entry<String, Exclusion> clazz : rootClassNames.entrySet()) {
-      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
-      string += "| Root Class:" + clazz.getKey() + always + "\n";
-    }
-    return string;
-  }
-
-  static final class ParamsBuilder {
-    String name;
-    String reason;
-    boolean alwaysExclude;
-    final String matching;
-
-    ParamsBuilder(String matching) {
-      this.matching = matching;
-    }
-  }
-
-  public interface Builder {
-    BuilderWithParams instanceField(String className, String fieldName);
-
-    BuilderWithParams staticField(String className, String fieldName);
-
-    BuilderWithParams thread(String threadName);
-
-    BuilderWithParams clazz(String className);
-
-    BuilderWithParams rootClass(String rootSuperClassName);
-
-    ExcludedRefs build();
-  }
-
-  public static final class BuilderWithParams implements Builder {
-
-    private final Map<String, Map<String, ParamsBuilder>> fieldNameByClassName =
-        new LinkedHashMap<>();
-    private final Map<String, Map<String, ParamsBuilder>> staticFieldNameByClassName =
-        new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> threadNames = new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> classNames = new LinkedHashMap<>();
-    private final Map<String, ParamsBuilder> rootClassNames = new LinkedHashMap<>();
-
-    private ParamsBuilder lastParams;
-
-    BuilderWithParams() {
-    }
-
-    @Override public BuilderWithParams instanceField(String className, String fieldName) {
-      checkNotNull(className, "className");
-      checkNotNull(fieldName, "fieldName");
-      Map<String, ParamsBuilder> excludedFields = fieldNameByClassName.get(className);
-      if (excludedFields == null) {
-        excludedFields = new LinkedHashMap<>();
-        fieldNameByClassName.put(className, excludedFields);
-      }
-      lastParams = new ParamsBuilder("field " + className + "#" + fieldName);
-      excludedFields.put(fieldName, lastParams);
-      return this;
-    }
-
-    @Override public BuilderWithParams staticField(String className, String fieldName) {
-      checkNotNull(className, "className");
-      checkNotNull(fieldName, "fieldName");
-      Map<String, ParamsBuilder> excludedFields = staticFieldNameByClassName.get(className);
-      if (excludedFields == null) {
-        excludedFields = new LinkedHashMap<>();
-        staticFieldNameByClassName.put(className, excludedFields);
-      }
-      lastParams = new ParamsBuilder("static field " + className + "#" + fieldName);
-      excludedFields.put(fieldName, lastParams);
-      return this;
-    }
-
-    @Override public BuilderWithParams thread(String threadName) {
-      checkNotNull(threadName, "threadName");
-      lastParams = new ParamsBuilder("any threads named " + threadName);
-      threadNames.put(threadName, lastParams);
-      return this;
-    }
-
-    /** Ignores all fields and static fields of all subclasses of the provided class name. */
-    @Override public BuilderWithParams clazz(String className) {
-      checkNotNull(className, "className");
-      lastParams = new ParamsBuilder("any subclass of " + className);
-      classNames.put(className, lastParams);
-      return this;
-    }
-
-    /** Ignores any GC root that belongs to a subclass of the provided class name. */
-    @Override public BuilderWithParams rootClass(String rootClassName) {
-      checkNotNull(rootClassName, "rootClassName");
-      lastParams = new ParamsBuilder("any GC root subclass of " + rootClassName);
-      rootClassNames.put(rootClassName, lastParams);
-      return this;
-    }
-
-    public BuilderWithParams named(String name) {
-      lastParams.name = name;
-      return this;
-    }
-
-    public BuilderWithParams reason(String reason) {
-      lastParams.reason = reason;
-      return this;
-    }
-
-    public BuilderWithParams alwaysExclude() {
-      lastParams.alwaysExclude = true;
-      return this;
-    }
-
-    public ExcludedRefs build() {
-      return new ExcludedRefs(this);
-    }
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
deleted file mode 100644
index 4d87d05e..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.squareup.leakcanary;
-
-import java.io.Serializable;
-
-public final class Exclusion implements Serializable {
-  public final String name;
-  public final String reason;
-  public final boolean alwaysExclude;
-  public final String matching;
-
-  Exclusion(ExcludedRefs.ParamsBuilder builder) {
-    this.name = builder.name;
-    this.reason = builder.reason;
-    this.alwaysExclude = builder.alwaysExclude;
-    this.matching = builder.matching;
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
deleted file mode 100644
index 8beade52..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2011 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-/**
- * Called when a watched reference is expected to be weakly reachable, but hasn't been enqueued
- * in the reference queue yet. This gives the application a hook to run the GC before the {@link
- * RefWatcher} checks the reference queue again, to avoid taking a heap dump if possible.
- */
-public interface GcTrigger {
-  GcTrigger DEFAULT = new GcTrigger() {
-    @Override public void runGc() {
-      // Code taken from AOSP FinalizationTest:
-      // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
-      // java/lang/ref/FinalizationTester.java
-      // System.gc() does not garbage collect every time. Runtime.gc() is
-      // more likely to perfom a gc.
-      Runtime.getRuntime().gc();
-      enqueueReferences();
-      System.runFinalization();
-    }
-
-    private void enqueueReferences() {
-      // Hack. We don't have a programmatic way to wait for the reference queue daemon to move
-      // references to the appropriate queues.
-      try {
-        Thread.sleep(100);
-      } catch (InterruptedException e) {
-        throw new AssertionError();
-      }
-    }
-  };
-
-  void runGc();
-}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
deleted file mode 100644
index fe88f38e..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.io.Serializable;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-public final class HeapDump implements Serializable {
-
-  public interface Listener {
-    void analyze(HeapDump heapDump);
-  }
-
-  /** The heap dump file, which you might want to upload somewhere. */
-  public final File heapDumpFile;
-
-  /**
-   * Key associated to the {@link KeyedWeakReference} used to detect the memory leak.
-   * When analyzing a heap dump, search for all {@link KeyedWeakReference} instances, then open
-   * the one that has its "key" field set to this value. Its "referent" field contains the
-   * leaking object. Computing the shortest path to GC roots on that leaking object should enable
-   * you to figure out the cause of the leak.
-   */
-  public final String referenceKey;
-
-  /**
-   * User defined name to help identify the leaking instance.
-   */
-  public final String referenceName;
-
-  /** References that should be ignored when analyzing this heap dump. */
-  public final ExcludedRefs excludedRefs;
-
-  /** Time from the request to watch the reference until the GC was triggered. */
-  public final long watchDurationMs;
-  public final long gcDurationMs;
-  public final long heapDumpDurationMs;
-
-  public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
-      ExcludedRefs excludedRefs, long watchDurationMs, long gcDurationMs, long heapDumpDurationMs) {
-    this.heapDumpFile = checkNotNull(heapDumpFile, "heapDumpFile");
-    this.referenceKey = checkNotNull(referenceKey, "referenceKey");
-    this.referenceName = checkNotNull(referenceName, "referenceName");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    this.watchDurationMs = watchDurationMs;
-    this.gcDurationMs = gcDurationMs;
-    this.heapDumpDurationMs = heapDumpDurationMs;
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
deleted file mode 100644
index 9932308a..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-
-/** @see {@link HeapDump#referenceKey}. */
-final class KeyedWeakReference extends WeakReference<Object> {
-  public final String key;
-  public final String name;
-
-  KeyedWeakReference(Object referent, String key, String name,
-      ReferenceQueue<Object> referenceQueue) {
-    super(checkNotNull(referent, "referent"), checkNotNull(referenceQueue, "referenceQueue"));
-    this.key = checkNotNull(key, "key");
-    this.name = checkNotNull(name, "name");
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
deleted file mode 100644
index f7521e90..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Preconditions.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-final class Preconditions {
-
-  /**
-   * Returns instance unless it's null.
-   *
-   * @throws NullPointerException if instance is null
-   */
-  static <T> T checkNotNull(T instance, String name) {
-    if (instance == null) {
-      throw new NullPointerException(name + " must not be null");
-    }
-    return instance;
-  }
-
-  private Preconditions() {
-    throw new AssertionError();
-  }
-}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
deleted file mode 100644
index 5d124535..00000000
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.lang.ref.ReferenceQueue;
-import java.util.Set;
-import java.util.UUID;
-import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.Executor;
-
-import static com.squareup.leakcanary.Preconditions.checkNotNull;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
-/**
- * Watches references that should become weakly reachable. When the {@link RefWatcher} detects that
- * a reference might not be weakly reachable when it should, it triggers the {@link HeapDumper}.
- *
- * <p>This class is thread-safe: you can call {@link #watch(Object)} from any thread.
- */
-public final class RefWatcher {
-
-  public static final RefWatcher DISABLED = new RefWatcher(new Executor() {
-    @Override public void execute(Runnable command) {
-    }
-  }, new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      // Skips watching.
-      return true;
-    }
-  }, GcTrigger.DEFAULT, new HeapDumper() {
-    @Override public File dumpHeap() {
-      return null;
-    }
-  }, new HeapDump.Listener() {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }, new ExcludedRefs.BuilderWithParams().build());
-
-  private final Executor watchExecutor;
-  private final DebuggerControl debuggerControl;
-  private final GcTrigger gcTrigger;
-  private final HeapDumper heapDumper;
-  private final Set<String> retainedKeys;
-  private final ReferenceQueue<Object> queue;
-  private final HeapDump.Listener heapdumpListener;
-  private final ExcludedRefs excludedRefs;
-
-  public RefWatcher(Executor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
-      HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
-    this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
-    this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
-    this.gcTrigger = checkNotNull(gcTrigger, "gcTrigger");
-    this.heapDumper = checkNotNull(heapDumper, "heapDumper");
-    this.heapdumpListener = checkNotNull(heapdumpListener, "heapdumpListener");
-    this.excludedRefs = checkNotNull(excludedRefs, "excludedRefs");
-    retainedKeys = new CopyOnWriteArraySet<>();
-    queue = new ReferenceQueue<>();
-  }
-
-  /**
-   * Identical to {@link #watch(Object, String)} with an empty string reference name.
-   *
-   * @see #watch(Object, String)
-   */
-  public void watch(Object watchedReference) {
-    watch(watchedReference, "");
-  }
-
-  /**
-   * Watches the provided references and checks if it can be GCed. This method is non blocking,
-   * the check is done on the {@link Executor} this {@link RefWatcher} has been constructed with.
-   *
-   * @param referenceName An logical identifier for the watched object.
-   */
-  public void watch(Object watchedReference, String referenceName) {
-    checkNotNull(watchedReference, "watchedReference");
-    checkNotNull(referenceName, "referenceName");
-    if (debuggerControl.isDebuggerAttached()) {
-      return;
-    }
-    final long watchStartNanoTime = System.nanoTime();
-    String key = UUID.randomUUID().toString();
-    retainedKeys.add(key);
-    final KeyedWeakReference reference =
-        new KeyedWeakReference(watchedReference, key, referenceName, queue);
-
-    watchExecutor.execute(new Runnable() {
-      @Override public void run() {
-        ensureGone(reference, watchStartNanoTime);
-      }
-    });
-  }
-
-  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
-    long gcStartNanoTime = System.nanoTime();
-
-    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
-    removeWeaklyReachableReferences();
-    if (gone(reference) || debuggerControl.isDebuggerAttached()) {
-      return;
-    }
-    gcTrigger.runGc();
-    removeWeaklyReachableReferences();
-    if (!gone(reference)) {
-      long startDumpHeap = System.nanoTime();
-      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
-
-      File heapDumpFile = heapDumper.dumpHeap();
-
-      if (heapDumpFile == HeapDumper.NO_DUMP) {
-        // Could not dump the heap, abort.
-        return;
-      }
-      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
-      heapdumpListener.analyze(
-          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
-              gcDurationMs, heapDumpDurationMs));
-    }
-  }
-
-  private boolean gone(KeyedWeakReference reference) {
-    return !retainedKeys.contains(reference.key);
-  }
-
-  private void removeWeaklyReachableReferences() {
-    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
-    // reachable. This is before finalization or garbage collection has actually happened.
-    KeyedWeakReference ref;
-    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
-      retainedKeys.remove(ref.key);
-    }
-  }
-}
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
deleted file mode 100644
index 15b44def..00000000
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.leakcanary;
-
-import java.io.File;
-import java.util.concurrent.Executor;
-import org.junit.Test;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public class RefWatcherTest {
-
-  static final ExcludedRefs NO_REF = new ExcludedRefs.BuilderWithParams().build();
-
-  static class TestDumper implements HeapDumper {
-    boolean called;
-
-    @Override public File dumpHeap() {
-      called = true;
-      return new File("");
-    }
-  }
-
-  static class TestListener implements HeapDump.Listener {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }
-
-  @SuppressWarnings("FieldCanBeLocal") Object ref;
-
-  static class TestExecutor implements Executor {
-    Runnable command;
-
-    @Override public void execute(Runnable command) {
-      this.command = command;
-    }
-  }
-
-  /**
-   * In theory, this test doesn't have a 100% chance of success. In practice, {@link
-   * GcTrigger#DEFAULT} is good enough.
-   */
-  @Test public void unreachableObject_noDump() {
-    TestDumper dumper = new TestDumper();
-    TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = defaultWatcher(dumper, executor);
-    refWatcher.watch(new Object());
-    executor.command.run();
-    assertFalse(dumper.called);
-  }
-
-  @Test public void retainedObject_triggersDump() {
-    TestDumper dumper = new TestDumper();
-    TestExecutor executor = new TestExecutor();
-    RefWatcher refWatcher = defaultWatcher(dumper, executor);
-    ref = new Object();
-    refWatcher.watch(ref);
-    executor.command.run();
-    assertTrue(dumper.called);
-  }
-
-  private RefWatcher defaultWatcher(TestDumper dumper, TestExecutor executor) {
-    return new RefWatcher(executor, DebuggerControl.NONE, GcTrigger.DEFAULT, dumper,
-        new TestListener(), NO_REF);
-  }
-}
diff --git a/settings.gradle b/settings.gradle
index 73da17f3..4593ca69 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,5 +1 @@
-include ':leakcanary-watcher'
-include ':leakcanary-analyzer'
-include ':leakcanary-android'
 include ':leakcanary-android-no-op'
-include ':leakcanary-sample'
