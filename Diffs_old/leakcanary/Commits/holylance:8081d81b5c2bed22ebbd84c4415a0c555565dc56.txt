diff --git a/build.gradle b/build.gradle
index 74017215..0f3efbb0 100644
--- a/build.gradle
+++ b/build.gradle
@@ -127,10 +127,20 @@ subprojects {
   }
 
   afterEvaluate {
-    project.tasks.getByName('check').dependsOn 'detekt'
+    tasks.getByName('check').dependsOn 'detekt'
+    tasks.getByName('assemble').dependsOn installGitHooks
+    tasks.getByName('clean').dependsOn installGitHooks
   }
 
   dependencies {
     errorprone "com.google.errorprone:error_prone_core:${versions.errorProne}"
   }
 }
+
+//Copies git hooks from /hooks folder into .git; currently used to run Detekt during push
+//Git hook installation
+task installGitHooks(type: Copy) {
+  from new File(rootProject.rootDir, 'hooks')
+  into { new File(rootProject.rootDir, '.git/hooks') }
+  fileMode 0777 //Make files executable
+}
\ No newline at end of file
diff --git a/docs/dev-env.md b/docs/dev-env.md
index d5e6c0cd..d636ae06 100644
--- a/docs/dev-env.md
+++ b/docs/dev-env.md
@@ -10,7 +10,7 @@
 
 ## Static Code Analysis 
 * LeakCanary [uses](https://github.com/square/leakcanary/pull/1535) tool [Detekt](https://arturbosch.github.io/detekt/) for static Code analysis
-* Analyze whole project with `./gradlew check` or particular modules with `./gradlew :module-name:check` 
-* Detekt will fail the build if any ruleset violations are found. **You should fix all issues before pushing the branch to remote**.
-* If you don't - Travis CI build will fail the check for you. A [git push hook](https://github.com/square/leakcanary/issues/1547) will prevent pushing failing builds in future.
+* Analyze whole project with `./gradlew check` or particular modules with `./gradlew :module-name:check`. Detekt will fail the build if any ruleset violations are found. **You should fix all issues before pushing the branch to remote**.
+  * There's also a **git pre-push** hook that will run analysis automatically before pushing branch to remote. If there are any violations - it will prevent the push. Fix the issues!
+  * You can bypass the git hook though; Travis CI will still run checks and will fail if any violations are found. 
 * Detekt report will be printed in console and saved to `/moduleDir/build/reports/
diff --git a/hooks/pre-push b/hooks/pre-push
new file mode 100644
index 00000000..3c0d5fc1
--- /dev/null
+++ b/hooks/pre-push
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+echo "Running static analysis..."
+
+# Run static analysis tools
+./gradlew detekt
+
+status=$?
+
+if [ "$status" = 0 ] ; then
+    echo "Static analysis found no problems."
+    exit 0
+else
+    echo 1>&2 "Static analysis found violations! Fix them before pushing your code!"
+    echo "See generated reports above or in /<project_dir>/build/reports folder"
+    exit 1
+fi
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
new file mode 100644
index 00000000..45bf7c17
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
@@ -0,0 +1,51 @@
+package leakcanary
+
+import android.util.Log
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.Ignore
+import org.junit.Test
+import shark.AndroidObjectInspectors
+import shark.AndroidReferenceMatchers
+import shark.HeapAnalyzer
+import shark.ObjectInspectors.KEYED_WEAK_REFERENCE
+import shark.OnAnalysisProgressListener
+import shark.OnAnalysisProgressListener.Step
+import shark.SharkLog
+import java.io.File
+import java.io.FileOutputStream
+
+class ProfiledTest {
+
+  @Ignore
+  @Test fun analyzeLargeDump() {
+    profileAnalysis("large-dump.hprof")
+  }
+
+  private fun profileAnalysis(fileName: String) {
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    val heapDumpFile = File(context.filesDir, "ProfiledTest.hprof")
+    context.assets.open(fileName)
+        .copyTo(FileOutputStream(heapDumpFile))
+
+    SharkLog.d { "Waiting, please start profiler" }
+    Thread.sleep(20000)
+
+    val analyzer = HeapAnalyzer(object : OnAnalysisProgressListener {
+      override fun onAnalysisProgress(step: Step) {
+        Log.d("LeakCanary", step.name)
+      }
+    })
+    val result = analyzer.analyze(
+        heapDumpFile = heapDumpFile,
+        referenceMatchers = AndroidReferenceMatchers.appDefaults,
+        objectInspectors = AndroidObjectInspectors.appDefaults,
+        computeRetainedHeapSize = true,
+        leakFinders = listOf(KEYED_WEAK_REFERENCE)
+    )
+    SharkLog.d { result.toString() }
+  }
+
+}
+
diff --git a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
index 5fa0f797..46bb84f5 100644
--- a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
+++ b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
@@ -513,16 +513,30 @@ enum class AndroidReferenceMatchers {
     }
   },
 
-  CHANGE_WATCHER {
+  ASSIST_STRUCTURE {
     override fun add(references: MutableList<ReferenceMatcher>) {
       references += instanceFieldLeak(
-          "android.widget.TextView\$ChangeWatcher", "this\$0"
+          "android.app.assist.AssistStructure\$ViewNodeText", "mText"
           ,
           description = "AssistStructure (google assistant / autofill) holds on to text spannables" +
-              " on the screen. One such spannables is unfortunately TextView.ChangeWatcher, which" +
-              " ends up leaking the textview."
+              " on the screen. TextView.ChangeWatcher and android.widget.Editor end up in spans and" +
+              " typically hold on to the view hierarchy"
       ) {
-        sdkInt in 24..25
+        sdkInt in 24..27
+      }
+    }
+  },
+
+  ACCESSIBILITY_ITERATORS {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.widget.AccessibilityIterators\$LineTextSegmentIterator", "mLayout"
+          ,
+          description = "AccessibilityIterators holds on to text layouts which can hold on to spans" +
+              " TextView.ChangeWatcher and android.widget.Editor end up in spans and" +
+              " typically hold on to the view hierarchy"
+      ) {
+        sdkInt == 27
       }
     }
   },
@@ -608,7 +622,6 @@ enum class AndroidReferenceMatchers {
         sdkInt in 28..29
       }
     }
-
   },
 
   TEXT_TO_SPEECH {
@@ -639,6 +652,21 @@ enum class AndroidReferenceMatchers {
     }
   },
 
+  WINDOW_MANAGER_GLOBAL {
+    override fun add(references: MutableList<ReferenceMatcher>) {
+      references += instanceFieldLeak(
+          "android.view.WindowManagerGlobal", "mRoots"
+          ,
+          description = """
+              ViewRootImpl references a destroyed activity yet it's not detached (still has a view)
+               and WindowManagerGlobal still references it.
+            """.trimIndent()
+      ) {
+        sdkInt == 27
+      }
+    }
+  },
+
   // ######## Manufacturer specific known leaks ########
 
   // SAMSUNG
@@ -687,7 +715,7 @@ enum class AndroidReferenceMatchers {
           ,
           description =
           "SemClipboardManager is held in memory by an anonymous inner class" +
-            " implementation of android.os.Binder, thereby leaking an activity context."
+              " implementation of android.os.Binder, thereby leaking an activity context."
       ) {
         manufacturer == SAMSUNG && sdkInt in 19..24
       }
@@ -697,10 +725,20 @@ enum class AndroidReferenceMatchers {
           ,
           description =
           "SemClipboardManager is held in memory by an anonymous inner class" +
-            " implementation of android.os.Binder, thereby leaking an activity context."
+              " implementation of android.os.Binder, thereby leaking an activity context."
       ) {
         manufacturer == SAMSUNG && sdkInt in 22..28
       }
+      references += instanceFieldLeak(
+          "com.samsung.android.content.clipboard.SemClipboardManager$1",
+          "this$0"
+          ,
+          description =
+          "SemClipboardManager is held in memory by an anonymous inner class" +
+              " implementation of android.os.Binder, thereby leaking an activity context."
+      ) {
+        manufacturer == SAMSUNG && sdkInt == 24
+      }
     }
   },
 
@@ -735,8 +773,6 @@ enum class AndroidReferenceMatchers {
     }
   },
 
-
-
   SEM_EMERGENCY_MANAGER__MCONTEXT {
     override fun add(
       references: MutableList<ReferenceMatcher>
@@ -746,7 +782,7 @@ enum class AndroidReferenceMatchers {
           ,
           description =
           "SemEmergencyManager is a static singleton that leaks a DecorContext." +
-            " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+              " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
       ) {
         manufacturer == SAMSUNG && sdkInt in 19..24
       }
@@ -911,7 +947,7 @@ enum class AndroidReferenceMatchers {
           ,
           description =
           "GestureBoostManager is a static singleton that leaks an activity context." +
-            " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+              " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
       ) {
         manufacturer == HUAWEI && sdkInt in 24..25
       }
@@ -1027,6 +1063,24 @@ enum class AndroidReferenceMatchers {
     }
   },
 
+  EXTENDED_STATUS_BAR_MANAGER {
+    override fun add(
+      references: MutableList<ReferenceMatcher>
+    ) {
+      references += staticFieldLeak(
+          "android.app.ExtendedStatusBarManager", "sInstance"
+          ,
+          description =
+          """
+            ExtendedStatusBarManager is held in a static sInstance field and has a mContext
+            field which references a decor context which references a destroyed activity.
+          """.trimIndent()
+      ) {
+        manufacturer == SHARP && sdkInt == 28
+      }
+    }
+  },
+
   // ######## Ignored references (not leaks) ########
 
   REFERENCES {
@@ -1120,6 +1174,7 @@ enum class AndroidReferenceMatchers {
     const val MEIZU = "Meizu"
     const val HUAWEI = "HUAWEI"
     const val VIVO = "vivo"
+    const val SHARP = "SHARP"
 
     /**
      * Returns a list of [ReferenceMatcher] that only contains [IgnoredReferenceMatcher] and no
