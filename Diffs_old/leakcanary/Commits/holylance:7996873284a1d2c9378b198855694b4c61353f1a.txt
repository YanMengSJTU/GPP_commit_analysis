diff --git a/build.gradle b/build.gradle
index 6a55c257..a0a51484 100644
--- a/build.gradle
+++ b/build.gradle
@@ -71,6 +71,14 @@ subprojects {
       prefix = "com.squareup.leakcanary"
       suppress = true
     }
+    packageOptions {
+      prefix = "shark.internal"
+      suppress = true
+    }
+    packageOptions {
+      prefix = "leakcanary.internal"
+      suppress = true
+    }
     outputFormat = 'gfm'
     outputDirectory = "$rootDir/docs/api"
   }
diff --git a/docs/api/shark-graph/shark/-heap-graph/gc-roots.md b/docs/api/shark-graph/shark/-heap-graph/gc-roots.md
index bc7d2722..88feeef8 100644
--- a/docs/api/shark-graph/shark/-heap-graph/gc-roots.md
+++ b/docs/api/shark-graph/shark/-heap-graph/gc-roots.md
@@ -5,5 +5,7 @@
 `abstract val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`
 
 All GC roots which type matches types known to this heap graph and which point to non null
-references.
+references. You can retrieve the object that a GC Root points to by calling [findObjectById](find-object-by-id.md)
+with [GcRoot.id](#), however you need to first check that [objectExists](object-exists.md) returns true because
+GC roots can point to objects that don't exist in the heap dump.
 
diff --git a/docs/api/shark-graph/shark/-heap-graph/index.md b/docs/api/shark-graph/shark/-heap-graph/index.md
index b05eef92..727113f9 100644
--- a/docs/api/shark-graph/shark/-heap-graph/index.md
+++ b/docs/api/shark-graph/shark/-heap-graph/index.md
@@ -12,7 +12,7 @@ Enables navigation through the heap graph of objects.
 |---|---|
 | [classes](classes.md) | `abstract val classes: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`>`<br>Sequence of all classes in the heap dump. |
 | [context](context.md) | `abstract val context: `[`GraphContext`](../-graph-context/index.md)<br>In memory store that can be used to store objects this [HeapGraph](./index.md) instance. |
-| [gcRoots](gc-roots.md) | `abstract val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`<br>All GC roots which type matches types known to this heap graph and which point to non null references. |
+| [gcRoots](gc-roots.md) | `abstract val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`<br>All GC roots which type matches types known to this heap graph and which point to non null references. You can retrieve the object that a GC Root points to by calling [findObjectById](find-object-by-id.md) with [GcRoot.id](#), however you need to first check that [objectExists](object-exists.md) returns true because GC roots can point to objects that don't exist in the heap dump. |
 | [identifierByteSize](identifier-byte-size.md) | `abstract val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
 | [instances](instances.md) | `abstract val instances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-object/-heap-instance/index.md)`>`<br>Sequence of all instances in the heap dump. |
 | [objects](objects.md) | `abstract val objects: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject`](../-heap-object/index.md)`>`<br>Sequence of all objects in the heap dump. |
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/gc-roots.md b/docs/api/shark-graph/shark/-hprof-heap-graph/gc-roots.md
index e602ba20..e585611f 100644
--- a/docs/api/shark-graph/shark/-hprof-heap-graph/gc-roots.md
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/gc-roots.md
@@ -7,5 +7,7 @@
 Overrides [HeapGraph.gcRoots](../-heap-graph/gc-roots.md)
 
 All GC roots which type matches types known to this heap graph and which point to non null
-references.
+references. You can retrieve the object that a GC Root points to by calling [findObjectById](../-heap-graph/find-object-by-id.md)
+with [GcRoot.id](#), however you need to first check that [objectExists](../-heap-graph/object-exists.md) returns true because
+GC roots can point to objects that don't exist in the heap dump.
 
diff --git a/docs/api/shark-graph/shark/-hprof-heap-graph/index.md b/docs/api/shark-graph/shark/-hprof-heap-graph/index.md
index 2ddb101b..45e737e9 100644
--- a/docs/api/shark-graph/shark/-hprof-heap-graph/index.md
+++ b/docs/api/shark-graph/shark/-hprof-heap-graph/index.md
@@ -12,7 +12,7 @@ A [HeapGraph](../-heap-graph/index.md) that reads from an indexed [Hprof](#). Cr
 |---|---|
 | [classes](classes.md) | `val classes: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapClass`](../-heap-object/-heap-class/index.md)`>`<br>Sequence of all classes in the heap dump. |
 | [context](context.md) | `val context: `[`GraphContext`](../-graph-context/index.md)<br>In memory store that can be used to store objects this [HeapGraph](../-heap-graph/index.md) instance. |
-| [gcRoots](gc-roots.md) | `val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`<br>All GC roots which type matches types known to this heap graph and which point to non null references. |
+| [gcRoots](gc-roots.md) | `val gcRoots: `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<GcRoot>`<br>All GC roots which type matches types known to this heap graph and which point to non null references. You can retrieve the object that a GC Root points to by calling [findObjectById](../-heap-graph/find-object-by-id.md) with [GcRoot.id](#), however you need to first check that [objectExists](../-heap-graph/object-exists.md) returns true because GC roots can point to objects that don't exist in the heap dump. |
 | [identifierByteSize](identifier-byte-size.md) | `val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
 | [instances](instances.md) | `val instances: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject.HeapInstance`](../-heap-object/-heap-instance/index.md)`>`<br>Sequence of all instances in the heap dump. |
 | [objects](objects.md) | `val objects: `[`Sequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/index.html)`<`[`HeapObject`](../-heap-object/index.md)`>`<br>Sequence of all objects in the heap dump. |
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md
new file mode 100644
index 00000000..93bb0eac
--- /dev/null
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md
@@ -0,0 +1,5 @@
+[shark](../../../index.md) / [shark](../../index.md) / [OnAnalysisProgressListener](../index.md) / [Step](index.md) / [REPORTING_HEAP_ANALYSIS](./-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md)
+
+# REPORTING_HEAP_ANALYSIS
+
+`REPORTING_HEAP_ANALYSIS`
\ No newline at end of file
diff --git a/docs/api/shark/shark/-on-analysis-progress-listener/-step/index.md b/docs/api/shark/shark/-on-analysis-progress-listener/-step/index.md
index 92c3173e..0eae9d12 100644
--- a/docs/api/shark/shark/-on-analysis-progress-listener/-step/index.md
+++ b/docs/api/shark/shark/-on-analysis-progress-listener/-step/index.md
@@ -15,3 +15,4 @@
 | [COMPUTING_NATIVE_RETAINED_SIZE](-c-o-m-p-u-t-i-n-g_-n-a-t-i-v-e_-r-e-t-a-i-n-e-d_-s-i-z-e.md) |  |
 | [COMPUTING_RETAINED_SIZE](-c-o-m-p-u-t-i-n-g_-r-e-t-a-i-n-e-d_-s-i-z-e.md) |  |
 | [BUILDING_LEAK_TRACES](-b-u-i-l-d-i-n-g_-l-e-a-k_-t-r-a-c-e-s.md) |  |
+| [REPORTING_HEAP_ANALYSIS](-r-e-p-o-r-t-i-n-g_-h-e-a-p_-a-n-a-l-y-s-i-s.md) |  |
diff --git a/docs/changelog.md b/docs/changelog.md
index ca285bff..2215c120 100644
--- a/docs/changelog.md
+++ b/docs/changelog.md
@@ -1,11 +1,24 @@
 # Change Log
 
-## Version 2.0 Beta 1 (2019-07-30)
+## Version 2.0 Beta 2 (2019-08-02)
 
 LeakCanary 2 reached **beta status**: the internals and APIs are mostly stable.
 
 Now is a great time to adopt it and provide feedback before the stable release. We're counting on you to find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/). 
 
+* Fixed *Leak analysis failed: Object id not found in heap dump.* [#1516](https://github.com/square/leakcanary/issues/1516)
+* 10x speed increase of hprof indexing on large heap dumps [#1520](https://github.com/square/leakcanary/pull/1520)
+
+Many thanks to
+[@kolphi](https://github.com/kolphi),
+[@pyricau](https://github.com/pyricau),
+[@ZacSweers](https://github.com/ZacSweers)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-2 Milestone](https://github.com/square/leakcanary/milestone/10) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-1...v2.0-beta-2).
+
+## Version 2.0 Beta 1 (2019-07-30)
+
 * New standalone library! [Shark](shark.md) is the heap analyzer that powers LeakCanary 2, and it can run in any Java VM. It comes with a [CLI](shark.md#shark-cli): you can now run `shark-cli analyze-process com.example.myapp` from your computer.
 * New Heap Explorer directly on device! Open a Heap Analysis in LeakCanary, tap the options menu and select "Heap Explorer". This is still experimental and not very user friendly, contributions welcome!
 * **Large API rewrite** to improve usability. If you used the alpha with a customized configuration, there are breaking changes. Of note: LeakSentry became [AppWatcher](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/), RefWatcher became [ObjectWatcher](/leakcanary/api/leakcanary-object-watcher/leakcanary/-object-watcher/), AndroidExcludedRefs became [AndroidReferenceMatchers](/leakcanary/api/shark-android/shark/-android-reference-matchers/), AnalysisResultListener became [OnHeapAnalyzedListener](/leakcanary/api/leakcanary-android-core/leakcanary/-on-heap-analyzed-listener/), AndroidLeakTraceInspectors became [AndroidObjectInspectors](/leakcanary/api/shark-android/shark/-android-object-inspectors/).
@@ -23,7 +36,7 @@ Many thanks to
 [@snkashis](https://github.com/snkashis)
 for the contributions, bug reports and feature requests.
 
-For more details, see the [2.0-beta-1 Milestone](https://github.com/square/leakcanary/milestone/1) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-3...v2.0-beta-1).
+For more details, see the [2.0-beta-1 Milestone](https://github.com/square/leakcanary/milestone/9) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-alpha-3...v2.0-beta-1).
 
 ## Version 2.0 Alpha 3 (2019-07-04)
 
diff --git a/docs/faq.md b/docs/faq.md
index ec251c50..edc8387a 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -46,7 +46,7 @@ Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://gith
 
 ```gradle
  dependencies {
-   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-2-SNAPSHOT'
+   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-3-SNAPSHOT'
  }
 ```
 
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
index 8a115ce2..16597889 100644
--- a/docs/fundamentals.md
+++ b/docs/fundamentals.md
@@ -216,11 +216,11 @@ LeakCanary is released as several libraries:
 * ObjectWatcher
     * Used to watch retained objects and check if they become weakly reachable.
     * Suitable for release builds.
-    * Artifact id: `com.squareup.leakcanary:object-watcher`.
+    * Artifact id: `com.squareup.leakcanary:leakcanary-object-watcher`.
 * ObjectWatcher Android
     * Automatically detects retained destroyed activities and fragments.
     * Suitable for release builds.
-    * Artifact id: `com.squareup.leakcanary:object-watcher-android`.
+    * Artifact id: `com.squareup.leakcanary:leakcanary-object-watcher-android`.
 * LeakCanary
     * Dumps the heap and analyzes it.
     * Currently only suitable for debug builds.
diff --git a/docs/getting_started.md b/docs/getting_started.md
index 4bde7cd6..6ed84eb9 100644
--- a/docs/getting_started.md
+++ b/docs/getting_started.md
@@ -5,7 +5,7 @@ Add LeakCanary to `build.gradle`:
 ```groovy
 dependencies {
   // debugImplementation because LeakCanary should only run in debug builds.
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-1'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-2'
 }
 ```
 
diff --git a/docs/recipes.md b/docs/recipes.md
index 50b5c94a..4ea73d80 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -61,13 +61,13 @@ Sometimes it's necessary to disable LeakCanary temporarily, for example for a pr
 
 ## Counting retained instances in production
 
-`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:object-watcher-android` which you can use in production to track and count retained instances.
+`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leakcanary-object-watcher-android` which you can use in production to track and count retained instances.
 
 In your `build.gradle`:
 
 ```gradle
 dependencies {
-  implementation 'com.squareup.leakcanary:object-watcher-android:2.0-beta-1'
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.0-beta-2'
 }
 ```
 
diff --git a/docs/shark.md b/docs/shark.md
index 8e7e45bc..1998bac7 100644
--- a/docs/shark.md
+++ b/docs/shark.md
@@ -31,7 +31,7 @@ A few more things:
 
 The Shark Command Line Interface (CLI) enables you to analyze heaps directly from your computer. It can dump the heap of an app installed on a connected Android device, analyze it, and even strip a heap dump of any sensitive data (e.g. PII, passwords or encryption keys) which is useful when sharing a heap dump.
 
-Download it [here](https://github.com/square/leakcanary/releases/download/v2.0-beta-1/shark-cli-2.0-beta-1.zip)!
+Download it [here](https://github.com/square/leakcanary/releases/download/v2.0-beta-2/shark-cli-2.0-beta-2.zip)!
 
 Usage instructions:
 
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
index bad33fdc..7f2d5906 100644
--- a/docs/upgrading-to-leakcanary-2.0.md
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -22,7 +22,7 @@ dependencies {
 
 ```groovy
 dependencies {
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-1'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-2'
 }
 ```
 
@@ -85,7 +85,7 @@ If you were using `RefWatcher` in non debug code, you now get a compile error be
 
 ```groovy
 dependencies {
-  implementation 'com.squareup.leakcanary:object-watcher-android:2.0-beta-1'
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.0-beta-2'
 }
 ```
 
diff --git a/gradle.properties b/gradle.properties
index fc790e98..151e678d 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,5 +1,5 @@
 GROUP=com.squareup.leakcanary
-VERSION_NAME=2.0-beta-2-SNAPSHOT
+VERSION_NAME=2.0-beta-3-SNAPSHOT
 
 POM_DESCRIPTION=Leak Canary
 
diff --git a/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof b/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof
new file mode 100644
index 00000000..5caeb42b
Binary files /dev/null and b/leakcanary-android-instrumentation/src/androidTest/assets/large-dump.hprof differ
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisDurationTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisDurationTest.kt
new file mode 100644
index 00000000..ac183fe9
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisDurationTest.kt
@@ -0,0 +1,30 @@
+package leakcanary
+
+import android.os.SystemClock
+import androidx.test.platform.app.InstrumentationRegistry
+import org.junit.Test
+import shark.Hprof
+import shark.HprofHeapGraph
+import shark.SharkLog
+import java.io.File
+import java.io.FileOutputStream
+
+class IndexingTest {
+
+  @Test fun indexHprof() {
+    val instrumentation = InstrumentationRegistry.getInstrumentation()
+    val context = instrumentation.targetContext
+
+    val heapDumpFile = File(context.filesDir, "AnalysisDurationTest.hprof")
+    context.assets.open("large-dump.hprof").copyTo(FileOutputStream(heapDumpFile))
+
+    Hprof.open(heapDumpFile).use { hprof ->
+      SharkLog.d("Start indexing")
+      val before = SystemClock.uptimeMillis()
+      HprofHeapGraph.indexHprof(hprof)
+      val durationMs = (SystemClock.uptimeMillis() - before)
+      SharkLog.d("Indexing took $durationMs ms")
+    }
+  }
+}
+
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index 70cd1a6f..c7dd5485 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -34,15 +34,17 @@ import shark.internal.IndexedObject.IndexedClass
 import shark.internal.IndexedObject.IndexedInstance
 import shark.internal.IndexedObject.IndexedObjectArray
 import shark.internal.IndexedObject.IndexedPrimitiveArray
+import shark.internal.hppc.LongLongScatterMap
+import shark.internal.hppc.LongObjectScatterMap
 import kotlin.reflect.KClass
 
 /**
  * This class is not thread safe, should be used from a single thread.
  */
 internal class HprofInMemoryIndex private constructor(
-  private val hprofStringCache: LongToStringSparseArray,
-  private val classNames: LongToLongSparseArray,
-  private val objectIndex: LongToObjectSparseArray<IndexedObject>,
+  private val hprofStringCache: LongObjectScatterMap<String>,
+  private val classNames: LongLongScatterMap,
+  private val objectIndex: LongObjectScatterMap<IndexedObject>,
   private val gcRoots: List<GcRoot>,
   val primitiveWrapperTypes: Set<Long>
 ) {
@@ -53,13 +55,20 @@ internal class HprofInMemoryIndex private constructor(
 
   fun className(classId: Long): String {
     // String, primitive types
-    return hprofStringById(classNames[classId])
+    val classNameStringId =
+      classNames[classId] ?: throw IllegalArgumentException("Unknown class id $classId")
+    return hprofStringById(classNameStringId)
   }
 
   fun classId(className: String): Long? {
     // Note: this performs two linear scans over arrays
-    return hprofStringCache.getKey(className)
-        ?.let { stringId -> classNames.getKey(stringId) }
+    return hprofStringCache.entrySequence()
+        .firstOrNull { it.second == className }
+        ?.first?.let { stringId ->
+      classNames.entrySequence()
+          .firstOrNull { it.second == stringId }
+          ?.first
+    }
   }
 
   fun indexedClassSequence(): Sequence<Pair<Long, IndexedClass>> {
@@ -104,19 +113,19 @@ internal class HprofInMemoryIndex private constructor(
     // memory.
     // Another option is to switch back to reading from the file system as necessary, and keep a much
     // smaller cache for strings we need during shortest path (those are for exclusions)
-    private val hprofStringCache = LongToStringSparseArray(60000)
+    private val hprofStringCache = LongObjectScatterMap<String>()
 
     /**
      * class id to string id
      */
-    private val classNames = LongToLongSparseArray(20000)
+    private val classNames = LongLongScatterMap()
 
     /**
      * Object id to [IndexedObject].
      * The id can be for classes instances, classes, object arrays and primitive arrays
      */
     private val objectIndex =
-      LongToObjectSparseArray<IndexedObject>(250000)
+      LongObjectScatterMap<IndexedObject>()
 
     /**
      * Class ids for primitive wrapper types
@@ -197,33 +206,36 @@ internal class HprofInMemoryIndex private constructor(
         Int::class.java.name, Long::class.java.name
     )
 
-    fun createReadingHprof(reader: HprofReader, indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
-        JniGlobal::class,
-        JavaFrame::class,
-        JniLocal::class,
-        MonitorUsed::class,
-        NativeStack::class,
-        StickyClass::class,
-        ThreadBlock::class,
-        // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
-        // belongs to
-        ThreadObject::class,
-        JniMonitor::class
-        /*
-        Not included here:
-
-        VmInternal: Ignoring because we've got 150K of it, but is this the right thing
-        to do? What's VmInternal exactly? History does not go further than
-        https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
-        We should log to figure out what objects VmInternal points to.
-
-        ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
-
-        Unknown: it's unknown, should we care?
-
-        We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
-         */
-    )): HprofInMemoryIndex {
+    fun createReadingHprof(
+      reader: HprofReader,
+      indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
+          JniGlobal::class,
+          JavaFrame::class,
+          JniLocal::class,
+          MonitorUsed::class,
+          NativeStack::class,
+          StickyClass::class,
+          ThreadBlock::class,
+          // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
+          // belongs to
+          ThreadObject::class,
+          JniMonitor::class
+          /*
+          Not included here:
+
+          VmInternal: Ignoring because we've got 150K of it, but is this the right thing
+          to do? What's VmInternal exactly? History does not go further than
+          https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+          We should log to figure out what objects VmInternal points to.
+
+          ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
+
+          Unknown: it's unknown, should we care?
+
+          We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
+           */
+      )
+    ): HprofInMemoryIndex {
       val recordTypes = setOf(
           StringRecord::class,
           LoadClassRecord::class,
diff --git a/shark-graph/src/main/java/shark/internal/LongToIntSparseArray.kt b/shark-graph/src/main/java/shark/internal/LongToIntSparseArray.kt
deleted file mode 100644
index e4ac75f9..00000000
--- a/shark-graph/src/main/java/shark/internal/LongToIntSparseArray.kt
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package shark.internal
-
-import shark.internal.SparseArrayUtils.appendInt
-import shark.internal.SparseArrayUtils.appendLong
-import shark.internal.SparseArrayUtils.binarySearch
-import shark.internal.SparseArrayUtils.insertInt
-import shark.internal.SparseArrayUtils.insertLong
-
-/**
- * Same as [LongToLongSparseArray] but long to int instead.
- */
-internal class LongToIntSparseArray(initialCapacity: Int) : Cloneable {
-  private var keys: LongArray
-  private var values: IntArray
-
-  var size: Int = 0
-    private set
-
-  init {
-    keys = LongArray(initialCapacity)
-    values = IntArray(initialCapacity)
-    size = 0
-  }
-
-  operator fun get(key: Long): Int {
-    val i = binarySearch(keys, size, key)
-
-    return if (i < 0 || values[i] == DELETED_INT) {
-      DELETED_INT
-    } else {
-      values[i]
-    }
-  }
-
-  operator fun set(
-    key: Long,
-    value: Int
-  ) {
-    require(value != DELETED_INT) {
-      "$DELETED_INT is a magic value that indicates a deleted entry"
-    }
-
-    if (size != 0 && key <= keys[size - 1]) {
-      insert(key, value)
-      return
-    }
-
-    keys = appendLong(keys, size, key)
-    values = appendInt(values, size, value)
-    size++
-  }
-
-  private fun insert(
-    key: Long,
-    value: Int
-  ) {
-    if (value == DELETED_INT) {
-      throw IllegalArgumentException("$DELETED_INT is a special value")
-    }
-    var i = binarySearch(keys, size, key)
-
-    if (i >= 0) {
-      values[i] = value
-    } else {
-      i = i.inv()
-
-      if (i < size && values[i] == DELETED_INT) {
-        keys[i] = key
-        values[i] = value
-        return
-      }
-
-      keys = insertLong(keys, size, i, key)
-      values = insertInt(values, size, i, value)
-      size++
-    }
-  }
-
-  companion object {
-    private const val DELETED_INT = 0
-  }
-}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/LongToLongSparseArray.kt b/shark-graph/src/main/java/shark/internal/LongToLongSparseArray.kt
deleted file mode 100644
index 0c165cac..00000000
--- a/shark-graph/src/main/java/shark/internal/LongToLongSparseArray.kt
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package shark.internal
-
-import shark.internal.SparseArrayUtils.appendLong
-import shark.internal.SparseArrayUtils.binarySearch
-import shark.internal.SparseArrayUtils.insertLong
-
-/**
- * Based on android.util.LongSparseArray, but with several tweaks:
- *
- * - Values array is a LongArray
- * - No compaction, ever. This object can only keep growing, until it is garbage collected. Note
- * that there is no remove() method.
- */
-internal class LongToLongSparseArray(initialCapacity: Int) : Cloneable {
-  private var keys: LongArray
-  private var values: LongArray
-
-  var size: Int = 0
-    private set
-
-  init {
-    keys = LongArray(initialCapacity)
-    values = LongArray(initialCapacity)
-    size = 0
-  }
-
-  operator fun get(key: Long): Long {
-    val i = binarySearch(keys, size, key)
-
-    return if (i < 0 || values[i] == DELETED_LONG) {
-      DELETED_LONG
-    } else {
-      values[i]
-    }
-  }
-
-  fun getKey(value: Long): Long? {
-    for (i in 0 until size) {
-      if (values[i] == value) {
-        return keys[i]
-      }
-    }
-    return null
-  }
-
-  operator fun set(
-    key: Long,
-    value: Long
-  ) {
-    require(value != DELETED_LONG) {
-      "$DELETED_LONG is a magic value that indicates a deleted entry"
-    }
-
-    if (size != 0 && key <= keys[size - 1]) {
-      insert(key, value)
-      return
-    }
-
-    keys = appendLong(keys, size, key)
-    values = appendLong(values, size, value)
-    size++
-  }
-
-  private fun insert(
-    key: Long,
-    value: Long
-  ) {
-    if (value == DELETED_LONG) {
-      throw IllegalArgumentException("$DELETED_LONG is a special value")
-    }
-    var i = binarySearch(keys, size, key)
-
-    if (i >= 0) {
-      values[i] = value
-    } else {
-      i = i.inv()
-
-      if (i < size && values[i] == DELETED_LONG) {
-        keys[i] = key
-        values[i] = value
-        return
-      }
-
-      keys = insertLong(keys, size, i, key)
-      values = insertLong(values, size, i, value)
-      size++
-    }
-  }
-
-  companion object {
-    private const val DELETED_LONG: Long = 0
-  }
-}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/LongToObjectSparseArray.kt b/shark-graph/src/main/java/shark/internal/LongToObjectSparseArray.kt
deleted file mode 100644
index e7452bf6..00000000
--- a/shark-graph/src/main/java/shark/internal/LongToObjectSparseArray.kt
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package shark.internal
-
-import shark.internal.SparseArrayUtils.appendLong
-import shark.internal.SparseArrayUtils.appendObject
-import shark.internal.SparseArrayUtils.binarySearch
-import shark.internal.SparseArrayUtils.insertLong
-import shark.internal.SparseArrayUtils.insertObject
-
-/**
- * Same as [LongToLongSparseArray] but long to object instead.
- */
-internal class LongToObjectSparseArray<T>(initialCapacity: Int) : Cloneable {
-  private var keys: LongArray
-  private var values: Array<T?>
-
-  var size: Int = 0
-    private set
-
-  init {
-    keys = LongArray(initialCapacity)
-    @Suppress("UNCHECKED_CAST")
-    values = arrayOfNulls<Any?>(initialCapacity) as Array<T?>
-    size = 0
-  }
-
-  operator fun get(key: Long): T? {
-    val i = binarySearch(keys, size, key)
-
-    return if (i < 0 || values[i] == null) {
-      null
-    } else {
-      values[i]!!
-    }
-  }
-
-  operator fun set(
-    key: Long,
-    value: T
-  ) {
-    if (size != 0 && key <= keys[size - 1]) {
-      insert(key, value)
-      return
-    }
-
-    keys = appendLong(keys, size, key)
-    values = appendObject(values, size, value)
-    size++
-  }
-
-  fun entrySequence(): Sequence<Pair<Long, T>> {
-    return (0..size).asSequence().filter { values[it] != null }.map { keys[it] to values[it]!! }
-  }
-
-  private fun insert(
-    key: Long,
-    value: T
-  ) {
-    var i = binarySearch(keys, size, key)
-
-    if (i >= 0) {
-      values[i] = value
-    } else {
-      i = i.inv()
-
-      if (i < size && values[i] == null) {
-        keys[i] = key
-        values[i] = value
-        return
-      }
-
-      keys = insertLong(keys, size, i, key)
-      values = insertObject(values, size, i, value)
-      size++
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/LongToStringSparseArray.kt b/shark-graph/src/main/java/shark/internal/LongToStringSparseArray.kt
deleted file mode 100644
index b17d9531..00000000
--- a/shark-graph/src/main/java/shark/internal/LongToStringSparseArray.kt
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package shark.internal
-
-import shark.internal.SparseArrayUtils.appendLong
-import shark.internal.SparseArrayUtils.appendString
-import shark.internal.SparseArrayUtils.binarySearch
-import shark.internal.SparseArrayUtils.insertLong
-import shark.internal.SparseArrayUtils.insertString
-
-/**
- * Same as [LongToLongSparseArray] but long to string instead.
- */
-internal class LongToStringSparseArray(initialCapacity: Int) : Cloneable {
-
-  private var keys: LongArray
-  private var values: Array<String?>
-
-  var size: Int = 0
-    private set
-
-  init {
-    keys = LongArray(initialCapacity)
-    values = arrayOfNulls(initialCapacity)
-    size = 0
-  }
-
-  operator fun get(key: Long): String? {
-    val i = binarySearch(keys, size, key)
-
-    return if (i < 0 || values[i] == null) {
-      null
-    } else {
-      values[i]
-    }
-  }
-
-  fun getKey(value: String): Long? {
-    for (i in 0 until size) {
-      if (values[i] == value) {
-        return keys[i]
-      }
-    }
-    return null
-  }
-
-  operator fun set(
-    key: Long,
-    value: String
-  ) {
-    if (size != 0 && key <= keys[size - 1]) {
-      insert(key, value)
-      return
-    }
-
-    keys = appendLong(keys, size, key)
-    values = appendString(values, size, value)
-    size++
-  }
-
-  private fun insert(
-    key: Long,
-    value: String
-  ) {
-    var i = binarySearch(keys, size, key)
-
-    if (i >= 0) {
-      values[i] = value
-    } else {
-      i = i.inv()
-
-      if (i < size && values[i] == null) {
-        keys[i] = key
-        values[i] = value
-        return
-      }
-
-      keys = insertLong(keys, size, i, key)
-      values = insertString(values, size, i, value)
-      size++
-    }
-  }
-}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/SparseArrayUtils.kt b/shark-graph/src/main/java/shark/internal/SparseArrayUtils.kt
deleted file mode 100644
index a23a5ab5..00000000
--- a/shark-graph/src/main/java/shark/internal/SparseArrayUtils.kt
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package shark.internal
-
-internal object SparseArrayUtils {
-
-  fun insertInt(
-    array: IntArray,
-    currentSize: Int,
-    index: Int,
-    element: Int
-  ): IntArray {
-    if (currentSize + 1 <= array.size) {
-      System.arraycopy(array, index, array, index + 1, currentSize - index)
-      array[index] = element
-      return array
-    }
-
-    val newArray = IntArray(growSize(currentSize))
-    System.arraycopy(array, 0, newArray, 0, index)
-    newArray[index] = element
-    System.arraycopy(array, index, newArray, index + 1, array.size - index)
-    return newArray
-  }
-
-  fun <T> insertObject(
-    array: Array<T?>,
-    currentSize: Int,
-    index: Int,
-    element: T
-  ): Array<T?> {
-    if (currentSize + 1 <= array.size) {
-      System.arraycopy(array, index, array, index + 1, currentSize - index)
-      array[index] = element
-      return array
-    }
-
-    @Suppress("UNCHECKED_CAST")
-    val newArray = arrayOfNulls<Any?>(growSize(currentSize)) as Array<T?>
-    System.arraycopy(array, 0, newArray, 0, index)
-    newArray[index] = element
-    System.arraycopy(array, index, newArray, index + 1, array.size - index)
-    return newArray
-  }
-
-  fun insertLong(
-    array: LongArray,
-    currentSize: Int,
-    index: Int,
-    element: Long
-  ): LongArray {
-    if (currentSize + 1 <= array.size) {
-      System.arraycopy(array, index, array, index + 1, currentSize - index)
-      array[index] = element
-      return array
-    }
-
-    val newArray = LongArray(growSize(currentSize))
-    System.arraycopy(array, 0, newArray, 0, index)
-    newArray[index] = element
-    System.arraycopy(array, index, newArray, index + 1, array.size - index)
-    return newArray
-  }
-
-  fun insertString(
-    array: Array<String?>,
-    currentSize: Int,
-    index: Int,
-    element: String?
-  ): Array<String?> {
-    if (currentSize + 1 <= array.size) {
-      System.arraycopy(array, index, array, index + 1, currentSize - index)
-      array[index] = element
-      return array
-    }
-
-    val newArray = arrayOfNulls<String>(growSize(currentSize))
-    System.arraycopy(array, 0, newArray, 0, index)
-    newArray[index] = element
-    System.arraycopy(array, index, newArray, index + 1, array.size - index)
-    return newArray
-  }
-
-  fun appendInt(
-    array: IntArray,
-    currentSize: Int,
-    element: Int
-  ): IntArray {
-    var returnedArray = array
-    if (currentSize + 1 > returnedArray.size) {
-      val newArray = IntArray(growSize(currentSize))
-      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
-      returnedArray = newArray
-    }
-    returnedArray[currentSize] = element
-    return returnedArray
-  }
-
-  fun appendLong(
-    array: LongArray,
-    currentSize: Int,
-    element: Long
-  ): LongArray {
-    var returnedArray = array
-    if (currentSize + 1 > returnedArray.size) {
-      val newArray = LongArray(growSize(currentSize))
-      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
-      returnedArray = newArray
-    }
-    returnedArray[currentSize] = element
-    return returnedArray
-  }
-
-  fun <T> appendObject(
-    array: Array<T?>,
-    currentSize: Int,
-    element: T
-  ): Array<T?> {
-    var returnedArray = array
-    if (currentSize + 1 > returnedArray.size) {
-      @Suppress("UNCHECKED_CAST")
-      val newArray = arrayOfNulls<Any?>(growSize(currentSize)) as Array<T?>
-      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
-      returnedArray = newArray
-    }
-    returnedArray[currentSize] = element
-    return returnedArray
-  }
-
-  fun appendString(
-    array: Array<String?>,
-    currentSize: Int,
-    element: String?
-  ): Array<String?> {
-    var returnedArray = array
-    if (currentSize + 1 > returnedArray.size) {
-
-      val newArray = arrayOfNulls<String>(growSize(currentSize))
-      System.arraycopy(returnedArray, 0, newArray, 0, currentSize)
-      returnedArray = newArray
-    }
-    returnedArray[currentSize] = element
-    return returnedArray
-  }
-
-  /**
-   * Android array helpers use 2. C++ uses 2. ArrayList uses 1.5
-   * We're dealing with large arrays here so being conservative is good for memory.
-   */
-  private fun growSize(currentSize: Int) = (currentSize * 1.5).toInt()
-
-  fun binarySearch(
-    array: LongArray?,
-    size: Int,
-    value: Long
-  ): Int {
-    var lo = 0
-    var hi = size - 1
-
-    while (lo <= hi) {
-      val mid = (lo + hi).ushr(1)
-      val midVal = array!![mid]
-
-      when {
-        midVal < value -> lo = mid + 1
-        midVal > value -> hi = mid - 1
-        else -> return mid  // value found
-      }
-    }
-    return lo.inv()  // value not present
-  }
-}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/internal/hppc/HHPC.kt b/shark-graph/src/main/java/shark/internal/hppc/HHPC.kt
similarity index 100%
rename from shark/src/main/java/shark/internal/hppc/HHPC.kt
rename to shark-graph/src/main/java/shark/internal/hppc/HHPC.kt
diff --git a/shark/src/main/java/shark/internal/hppc/LongLongScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
similarity index 94%
rename from shark/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
rename to shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
index 4d87fd83..084f5fa5 100644
--- a/shark/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
@@ -23,7 +23,7 @@ import java.util.Locale
  *
  * See https://github.com/carrotsearch/hppc .
  */
-internal class LongLongScatterMap {
+class LongLongScatterMap {
   /**
    * The array holding keys.
    */
@@ -180,6 +180,29 @@ internal class LongLongScatterMap {
     }
   }
 
+  fun entrySequence(): Sequence<Pair<Long, Long>> {
+    val max = mask + 1
+    var slot = -1
+    return generateSequence {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            return@generateSequence existing to values[slot]
+          }
+          slot++
+        }
+      }
+      if (slot == max && hasEmptyKey) {
+        slot++
+        return@generateSequence  0L to values[max]
+      }
+      return@generateSequence null
+    }
+  }
+
   fun containsKey(key: Long): Boolean {
     if (key == 0L) {
       return hasEmptyKey
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
new file mode 100644
index 00000000..f1b8234e
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
@@ -0,0 +1,356 @@
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
+
+import java.util.Locale
+
+/**
+ * Code from com.carrotsearch.hppc.LongLongScatterMap copy pasted, inlined and converted to Kotlin.
+ *
+ * See https://github.com/carrotsearch/hppc .
+ */
+internal class LongObjectScatterMap<T> {
+  /**
+   * The array holding keys.
+   */
+  private var keys: LongArray = longArrayOf()
+
+  /**
+   * The array holding values.
+   */
+  @Suppress("UNCHECKED_CAST")
+  private var values: Array<T?> = emptyArray<Any?>() as Array<T?>
+
+  /**
+   * The number of stored keys (assigned key slots), excluding the special
+   * "empty" key, if any (use [.size] instead).
+   *
+   * @see .size
+   */
+  private var assigned: Int = 0
+
+  /**
+   * Mask for slot scans in [.keys].
+   */
+  private var mask: Int = 0
+
+  /**
+   * Expand (rehash) [.keys] when [.assigned] hits this value.
+   */
+  private var resizeAt: Int = 0
+
+  /**
+   * Special treatment for the "empty slot" key marker.
+   */
+  private var hasEmptyKey: Boolean = false
+
+  /**
+   * The load factor for [.keys].
+   */
+  private var loadFactor: Double = 0.75
+
+  val isEmpty: Boolean
+    get() = size == 0
+
+  init {
+    ensureCapacity(4)
+  }
+
+  operator fun set(
+    key: Long,
+    value: T
+  ): T? {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = true
+      val previousValue = values[mask + 1]
+      values[mask + 1] = value
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          values[slot] = value
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      if (assigned == resizeAt) {
+        allocateThenInsertThenRehash(slot, key, value)
+      } else {
+        keys[slot] = key
+        values[slot] = value
+      }
+
+      assigned++
+      return null
+    }
+  }
+
+  fun remove(key: Long): T? {
+    val mask = this.mask
+    if (key == 0L) {
+      hasEmptyKey = false
+      val previousValue = values[mask + 1]
+      values[mask + 1] = null
+      return previousValue
+    } else {
+      val keys = this.keys
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          val previousValue = values[slot]
+          shiftConflictingKeys(slot)
+          return previousValue
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return null
+    }
+  }
+
+  operator fun get(key: Long): T? {
+    if (key == 0L) {
+      return if (hasEmptyKey) values[mask + 1] else null
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return values[slot]
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return null
+    }
+  }
+
+  fun entrySequence(): Sequence<Pair<Long, T>> {
+    val max = mask + 1
+    var slot = -1
+    return generateSequence {
+      if (slot < max) {
+        var existing: Long
+        slot++
+        while (slot < max) {
+          existing = keys[slot]
+          if (existing != 0L) {
+            return@generateSequence existing to values[slot]!!
+          }
+          slot++
+        }
+      }
+      if (slot == max && hasEmptyKey) {
+        slot++
+        return@generateSequence  0L to values[max]!!
+      }
+      return@generateSequence null
+    }
+  }
+
+  fun containsKey(key: Long): Boolean {
+    if (key == 0L) {
+      return hasEmptyKey
+    } else {
+      val keys = this.keys
+      val mask = this.mask
+      var slot = hashKey(key) and mask
+
+      var existing = keys[slot]
+      while (existing != 0L) {
+        if (existing == key) {
+          return true
+        }
+        slot = slot + 1 and mask
+        existing = keys[slot]
+      }
+
+      return false
+    }
+  }
+
+  fun release() {
+    assigned = 0
+    hasEmptyKey = false
+
+    allocateBuffers(HHPC.minBufferSize(4, loadFactor))
+  }
+
+  val size: Int
+    get() {
+      return assigned + if (hasEmptyKey) 1 else 0
+    }
+
+  fun ensureCapacity(expectedElements: Int) {
+    if (expectedElements > resizeAt) {
+      val prevKeys = this.keys
+      val prevValues = this.values
+      allocateBuffers(HHPC.minBufferSize(expectedElements, loadFactor))
+      if (!isEmpty) {
+        rehash(prevKeys, prevValues)
+      }
+    }
+  }
+
+  private fun hashKey(key: Long): Int {
+    return HHPC.mixPhi(key)
+  }
+
+  /**
+   * Rehash from old buffers to new buffers.
+   */
+  private fun rehash(
+    fromKeys: LongArray,
+    fromValues: Array<T?>
+  ) {
+    // Rehash all stored key/value pairs into the new buffers.
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+    var existing: Long
+
+    // Copy the zero element's slot, then rehash everything else.
+    var from = fromKeys.size - 1
+    keys[keys.size - 1] = fromKeys[from]
+    values[values.size - 1] = fromValues[from]
+    while (--from >= 0) {
+      existing = fromKeys[from]
+      if (existing != 0L) {
+        var slot = hashKey(existing) and mask
+        while (keys[slot] != 0L) {
+          slot = slot + 1 and mask
+        }
+        keys[slot] = existing
+        values[slot] = fromValues[from]
+      }
+    }
+  }
+
+  /**
+   * Allocate new internal buffers. This method attempts to allocate
+   * and assign internal buffers atomically (either allocations succeed or not).
+   */
+  private fun allocateBuffers(arraySize: Int) {
+
+    // Ensure no change is done if we hit an OOM.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    try {
+      val emptyElementSlot = 1
+      this.keys = LongArray(arraySize + emptyElementSlot)
+      @Suppress("UNCHECKED_CAST")
+      this.values = arrayOfNulls<Any?>(arraySize + emptyElementSlot) as Array<T?>
+    } catch (e: OutOfMemoryError) {
+      this.keys = prevKeys
+      this.values = prevValues
+      throw RuntimeException(
+          String.format(
+              Locale.ROOT,
+              "Not enough memory to allocate buffers for rehashing: %,d -> %,d",
+              this.mask + 1,
+              arraySize
+          ), e
+      )
+    }
+
+    this.resizeAt = HHPC.expandAtCount(arraySize, loadFactor)
+    this.mask = arraySize - 1
+  }
+
+  /**
+   * This method is invoked when there is a new key/ value pair to be inserted into
+   * the buffers but there is not enough empty slots to do so.
+   *
+   * New buffers are allocated. If this succeeds, we know we can proceed
+   * with rehashing so we assign the pending element to the previous buffer
+   * (possibly violating the invariant of having at least one empty slot)
+   * and rehash all keys, substituting new buffers at the end.
+   */
+  private fun allocateThenInsertThenRehash(
+    slot: Int,
+    pendingKey: Long,
+    pendingValue: T
+  ) {
+
+    // Try to allocate new buffers first. If we OOM, we leave in a consistent state.
+    val prevKeys = this.keys
+    val prevValues = this.values
+    allocateBuffers(HHPC.nextBufferSize(mask + 1, size, loadFactor))
+
+    // We have succeeded at allocating new data so insert the pending key/value at
+    // the free slot in the old arrays before rehashing.
+    prevKeys[slot] = pendingKey
+    prevValues[slot] = pendingValue
+
+    // Rehash old keys, including the pending key.
+    rehash(prevKeys, prevValues)
+  }
+
+  /**
+   * Shift all the slot-conflicting keys and values allocated to
+   * (and including) `slot`.
+   */
+  private fun shiftConflictingKeys(gapSlotArg: Int) {
+    var gapSlot = gapSlotArg
+    val keys = this.keys
+    val values = this.values
+    val mask = this.mask
+
+    // Perform shifts of conflicting keys to fill in the gap.
+    var distance = 0
+    while (true) {
+      val slot = gapSlot + ++distance and mask
+      val existing = keys[slot]
+      if (existing == 0L) {
+        break
+      }
+
+      val idealSlot = hashKey(existing)
+      val shift = slot - idealSlot and mask
+      if (shift >= distance) {
+        // Entry at this position was originally at or before the gap slot.
+        // Move the conflict-shifted entry to the gap's position and repeat the procedure
+        // for any entries to the right of the current position, treating it
+        // as the new gap.
+        keys[gapSlot] = existing
+        values[gapSlot] = values[slot]
+        gapSlot = slot
+        distance = 0
+      }
+    }
+
+    // Mark the last found gap slot without a conflict as empty.
+    keys[gapSlot] = 0L
+    values[gapSlot] = null
+    assigned--
+  }
+}
diff --git a/shark/src/main/java/shark/internal/hppc/LongScatterSet.kt b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
similarity index 99%
rename from shark/src/main/java/shark/internal/hppc/LongScatterSet.kt
rename to shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
index a061da1e..3aecfc24 100644
--- a/shark/src/main/java/shark/internal/hppc/LongScatterSet.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongScatterSet.kt
@@ -23,7 +23,7 @@ import java.util.Locale
  *
  * See https://github.com/carrotsearch/hppc .
  */
-internal class LongScatterSet {
+class LongScatterSet {
   /** The hash array holding keys.  */
   private var keys: LongArray = longArrayOf()
   /**
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index 4004e805..18e80db5 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -43,6 +43,7 @@ import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
 import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
 import shark.OnAnalysisProgressListener.Step.FINDING_LEAKING_INSTANCES
 import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
+import shark.OnAnalysisProgressListener.Step.REPORTING_HEAP_ANALYSIS
 import shark.internal.PathFinder
 import shark.internal.PathFinder.PathFindingResults
 import shark.internal.ReferencePathNode
@@ -85,6 +86,7 @@ class HeapAnalyzer constructor(
 
     if (!heapDumpFile.exists()) {
       val exception = IllegalArgumentException("File does not exist: $heapDumpFile")
+      listener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
       return HeapAnalysisFailure(
           heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
           HeapAnalysisException(exception)
@@ -101,12 +103,14 @@ class HeapAnalyzer constructor(
                 graph, leakFinders, referenceMatchers, computeRetainedHeapSize, objectInspectors
             )
             val (applicationLeaks, libraryLeaks) = findLeakInput.findLeaks()
+            listener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
             return HeapAnalysisSuccess(
                 heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
                 applicationLeaks, libraryLeaks
             )
           }
     } catch (exception: Throwable) {
+      listener.onAnalysisProgress(REPORTING_HEAP_ANALYSIS)
       return HeapAnalysisFailure(
           heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
           HeapAnalysisException(exception)
diff --git a/shark/src/main/java/shark/OnAnalysisProgressListener.kt b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
index 93e76352..d5da1cf8 100644
--- a/shark/src/main/java/shark/OnAnalysisProgressListener.kt
+++ b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
@@ -14,6 +14,7 @@ interface OnAnalysisProgressListener {
     COMPUTING_NATIVE_RETAINED_SIZE,
     COMPUTING_RETAINED_SIZE,
     BUILDING_LEAK_TRACES,
+    REPORTING_HEAP_ANALYSIS
   }
 
   fun onAnalysisProgress(step: Step)
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
index cc94b0b3..096ddedf 100644
--- a/shark/src/main/java/shark/internal/PathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -63,6 +63,45 @@ internal class PathFinder(
   referenceMatchers: List<ReferenceMatcher>
 ) {
 
+  class PathFindingResults(
+    val pathsToLeakingInstances: List<ReferencePathNode>,
+    val dominatedInstances: LongLongScatterMap
+  )
+
+  private class State(
+    val leakingInstanceObjectIds: Set<Long>,
+    val sizeOfObjectInstances: Int,
+    val computeRetainedHeapSize: Boolean
+  ) {
+
+    /** Set of instances to visit */
+    val toVisitQueue: Deque<ReferencePathNode> = ArrayDeque()
+
+    /**
+     * Instances to visit when [toVisitQueue] is empty. Should contain [JavaFrame] gc roots first,
+     * then [LibraryLeakNode].
+     */
+    val toVisitLastQueue: Deque<ReferencePathNode> = ArrayDeque()
+    /**
+     * Enables fast checking of whether a node is already in the queue.
+     */
+    val toVisitSet = HashSet<Long>()
+    val toVisitLastSet = HashSet<Long>()
+
+    val visitedSet = LongScatterSet()
+
+    /**
+     * Map of instances to their leaking dominator.
+     * If an instance has been added to [toVisitSet] or [visitedSet] and is missing from
+     * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
+     * and cannot be dominated by a leaking instance.
+     */
+    val dominatedInstances = LongLongScatterMap()
+
+    val queuesNotEmpty: Boolean
+      get() = toVisitQueue.isNotEmpty() || toVisitLastQueue.isNotEmpty()
+  }
+
   private val fieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
   private val staticFieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>
   private val threadNameReferenceMatchers: Map<String, ReferenceMatcher>
@@ -107,45 +146,6 @@ internal class PathFinder(
     this.threadNameReferenceMatchers = threadNames
   }
 
-  private class State(
-    val leakingInstanceObjectIds: Set<Long>,
-    val sizeOfObjectInstances: Int,
-    val computeRetainedHeapSize: Boolean
-  ) {
-
-    /** Set of instances to visit */
-    val toVisitQueue: Deque<ReferencePathNode> = ArrayDeque()
-
-    /**
-     * Instances to visit when [toVisitQueue] is empty. Should contain [JavaFrame] gc roots first,
-     * then [LibraryLeakNode].
-     */
-    val toVisitLastQueue: Deque<ReferencePathNode> = ArrayDeque()
-    /**
-     * Enables fast checking of whether a node is already in the queue.
-     */
-    val toVisitSet = HashSet<Long>()
-    val toVisitLastSet = HashSet<Long>()
-
-    val visitedSet = LongScatterSet()
-
-    /**
-     * Map of instances to their leaking dominator.
-     * If an instance has been added to [toVisitSet] or [visitedSet] and is missing from
-     * [dominatedInstances] then it's considered "undomitable" ie it is dominated by gc roots
-     * and cannot be dominated by a leaking instance.
-     */
-    val dominatedInstances = LongLongScatterMap()
-
-    val queuesNotEmpty: Boolean
-      get() = toVisitQueue.isNotEmpty() || toVisitLastQueue.isNotEmpty()
-  }
-
-  class PathFindingResults(
-    val pathsToLeakingInstances: List<ReferencePathNode>,
-    val dominatedInstances: LongLongScatterMap
-  )
-
   fun findPathsFromGcRoots(
     leakingInstanceObjectIds: Set<Long>,
     computeRetainedHeapSize: Boolean
@@ -300,7 +300,10 @@ internal class PathFinder(
           // See https://github.com/square/leakcanary/issues/1516
           val objectExists = graph.objectExists(gcRoot.id)
           if (!objectExists) {
-            SharkLog.d("%s gc root ignored because it's pointing to unknown object @%s", gcRoot::class.java.simpleName, gcRoot.id)
+            SharkLog.d(
+                "%s gc root ignored because it's pointing to unknown object @%s",
+                gcRoot::class.java.simpleName, gcRoot.id
+            )
           }
           objectExists
         }
@@ -368,6 +371,11 @@ internal class PathFinder(
       }
     }
 
+    val threadLocalValuesMatcher = if (instance instanceOf "java.lang.Thread") {
+      val threadName = instance["java.lang.Thread", "name"]?.value?.readAsJavaString()
+      threadNameReferenceMatchers[threadName]
+    } else null
+
     val fieldNamesAndValues = instance.readFields()
         .filter { it.value.isNonNullReference }
         .toMutableList()
@@ -379,14 +387,26 @@ internal class PathFinder(
       if (computeRetainedHeapSize) {
         updateDominatorWithSkips(parent.instance, objectId)
       }
-      val node = when (val referenceMatcher = fieldReferenceMatchers[field.name]) {
-        null -> NormalNode(objectId, parent, LeakReference(INSTANCE_FIELD, field.name))
-        is LibraryLeakReferenceMatcher ->
-          LibraryLeakNode(
-              objectId, parent, LeakReference(INSTANCE_FIELD, field.name), referenceMatcher
-          )
-        is IgnoredReferenceMatcher -> null
-      }
+
+      val node =
+        if (threadLocalValuesMatcher != null && field.declaringClass.name == "java.lang.Thread" && field.name == "localValues") {
+          // Earlier Android versions store local references in a Thread.localValues field.
+          if (threadLocalValuesMatcher is LibraryLeakReferenceMatcher) {
+            LibraryLeakNode(
+                objectId, parent, LeakReference(INSTANCE_FIELD, field.name),
+                threadLocalValuesMatcher
+            )
+          } else {
+            null
+          }
+        } else when (val referenceMatcher = fieldReferenceMatchers[field.name]) {
+          null -> NormalNode(objectId, parent, LeakReference(INSTANCE_FIELD, field.name))
+          is LibraryLeakReferenceMatcher ->
+            LibraryLeakNode(
+                objectId, parent, LeakReference(INSTANCE_FIELD, field.name), referenceMatcher
+            )
+          is IgnoredReferenceMatcher -> null
+        }
       if (node != null) {
         enqueue(node)
       }
@@ -432,6 +452,9 @@ internal class PathFinder(
 
     val visitLast =
       node is LibraryLeakNode ||
+          // We deprioritize thread objects because on Lollipop the thread local values are stored
+          // as a field.
+          (node is RootNode && node.gcRoot is ThreadObject) ||
           (node is NormalNode && node.parent is RootNode && node.parent.gcRoot is JavaFrame)
 
     if (toVisitLastSet.contains(node.instance)) {
diff --git a/shark/src/test/java/shark/HeapDumps.kt b/shark/src/test/java/shark/HeapDumps.kt
index 961490af..86cc55d1 100644
--- a/shark/src/test/java/shark/HeapDumps.kt
+++ b/shark/src/test/java/shark/HeapDumps.kt
@@ -138,6 +138,27 @@ fun File.writeJavaLocalLeak(
   }
 }
 
+fun File.writeLollipopJavaLocalLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadLocalValues = "java.lang.ThreadLocal\$Values" instance {
+      field["table"] = objectArray("Leaking" watchedInstance {})
+    }
+
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class, "localValues" to ReferenceHolder::class))
+    val myThreadClassId = clazz(className = threadClass, superclassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName), threadLocalValues))
+    gcRoot(
+        ThreadObject(
+            id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+    )
+  }
+}
+
 fun File.writeTwoPathJavaLocalShorterLeak(
   threadClass: String,
   threadName: String
diff --git a/shark/src/test/java/shark/ReferenceMatcherTest.kt b/shark/src/test/java/shark/ReferenceMatcherTest.kt
index a610a650..bf1c1007 100644
--- a/shark/src/test/java/shark/ReferenceMatcherTest.kt
+++ b/shark/src/test/java/shark/ReferenceMatcherTest.kt
@@ -5,8 +5,6 @@ import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
-import shark.IgnoredReferenceMatcher
-import shark.LibraryLeakReferenceMatcher
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.ReferencePattern.JavaLocalPattern
 import shark.ReferencePattern.StaticFieldPattern
@@ -85,6 +83,18 @@ class ReferenceMatcherTest {
     assertThat(leak.pattern).isEqualTo(matcher.pattern)
   }
 
+  @Test fun excludedLollipopThread() {
+    hprofFile.writeLollipopJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val matcher = LibraryLeakReferenceMatcher(JavaLocalPattern("kroutine"))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        referenceMatchers = listOf(matcher)
+    )
+
+    val leak = analysis.libraryLeaks[0]
+    assertThat(leak.pattern).isEqualTo(matcher.pattern)
+  }
+
   @Test fun overrideSuperclassExclusion() {
     hprofFile.dump {
       "GcRoot" clazz {
