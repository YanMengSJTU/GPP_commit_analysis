diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt
index f882c5ea..12a3d8c0 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt
@@ -1,7 +1,7 @@
 package leakcanary
 
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.HeapValue.ObjectReference
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 
 enum class AndroidLabelers : Labeler {
 
@@ -9,18 +9,23 @@ enum class AndroidLabelers : Labeler {
     override fun invoke(
       parser: HprofParser,
       node: LeakNode
-    ): List<String> = with(HprofGraph(parser)) {
-      val record = ObjectReference(node.instance)
-          .record
-      if (record instanceOf "androidx.fragment.app.Fragment" || record instanceOf "android.app.Fragment") {
-        record as InstanceDumpRecord
-        val mTag = record["mTag"].record.string
+    ): List<String> {
+      val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
+      val record = heapValue.readObjectRecord()!!
+
+      if (record is GraphInstanceRecord && (
+              record instanceOf "androidx.fragment.app.Fragment" ||
+                  record instanceOf "android.app.Fragment")
+      ) {
+        val mTag = record["mTag"]?.value?.readAsJavaString()
         if (!mTag.isNullOrEmpty()) {
           return listOf("Fragment.mTag=$mTag")
         }
       }
+
       return emptyList()
     }
-  };
+  }
+  ;
 
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt
index 9ef74e9d..c60f35c4 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt
@@ -15,8 +15,9 @@
  */
 package leakcanary
 
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.HeapValue.ObjectReference
 import kotlin.reflect.KClass
 
 /**
@@ -37,17 +38,17 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown("android.view.View") { instance ->
-        // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
-        // next toast view
-        if (instance["mParent"].reference == null) {
-          LeakNodeStatus.unknown()
-        } else if (!instance.hasField("mAttachInfo")) {
-          LeakNodeStatus.unknown()
-        } else if (instance["mAttachInfo"].reference == null) {
-          LeakNodeStatus.leaking("View detached and has parent")
-        } else {
-          LeakNodeStatus.notLeaking("View attached")
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          "android.view.View"
+      ) { instance ->
+        when {
+          // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
+          // next toast view
+          instance["mParent"]!!.value.isNullReference -> LeakNodeStatus.unknown()
+          instance["mAttachInfo"]!!.value.isNullReference -> LeakNodeStatus.leaking(
+              "View detached and has parent"
+          )
+          else -> LeakNodeStatus.notLeaking("View attached")
         }
       }
   },
@@ -57,8 +58,22 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown("android.app.Activity") { instance ->
-        instance.leakingWhenTrue("mDestroyed")
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          "android.app.Activity"
+      ) { instance ->
+        val field = instance["mDestroyed"]
+        // Activity.mDestroyed was introduced in 17.
+        // https://android.googlesource.com/platform/frameworks/base/+
+        // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
+        if (field == null) {
+          return@instanceOfOrUnknown LeakNodeStatus.unknown()
+        }
+
+        if (field.value.asBoolean!!) {
+          LeakNodeStatus.leaking(field describedWithValue "true")
+        } else {
+          LeakNodeStatus.notLeaking(field describedWithValue "false")
+        }
       }
   },
 
@@ -67,8 +82,15 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown("android.app.Dialog") { instance ->
-        instance.leakingWhenNull("mDecor")
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          "android.app.Dialog"
+      ) { instance ->
+        val field = instance["mDecor"]!!
+        if (field.value.isNullReference) {
+          LeakNodeStatus.leaking(field describedWithValue "null")
+        } else {
+          LeakNodeStatus.notLeaking(field describedWithValue "not null")
+        }
       }
   },
 
@@ -76,10 +98,14 @@ enum class AndroidLeakInspectors : LeakInspector {
     override fun invoke(
       parser: HprofParser,
       node: LeakNode
-    ): LeakNodeStatusAndReason = with(parser) {
-      return if (node.instance.objectRecord.isInstanceOf("android.app.Application")) {
+    ): LeakNodeStatusAndReason {
+      val record =
+        GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).readObjectRecord()
+      return if (record?.asInstance?.instanceOf("android.app.Application") == true) {
         LeakNodeStatus.notLeaking("Application is a singleton")
-      } else LeakNodeStatus.unknown()
+      } else {
+        LeakNodeStatus.unknown()
+      }
     }
   },
 
@@ -87,10 +113,14 @@ enum class AndroidLeakInspectors : LeakInspector {
     override fun invoke(
       parser: HprofParser,
       node: LeakNode
-    ): LeakNodeStatusAndReason = with(parser) {
-      return if (node.instance.objectRecord.isInstanceOf(ClassLoader::class)) {
-        LeakNodeStatus.notLeaking("Classloader never leaking")
-      } else LeakNodeStatus.unknown()
+    ): LeakNodeStatusAndReason {
+      val record =
+        GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).readObjectRecord()
+      return if (record?.asInstance?.instanceOf(ClassLoader::class) == true) {
+        LeakNodeStatus.notLeaking("A ClassLoader is never leaking")
+      } else {
+        LeakNodeStatus.unknown()
+      }
     }
   },
 
@@ -98,8 +128,10 @@ enum class AndroidLeakInspectors : LeakInspector {
     override fun invoke(
       parser: HprofParser,
       node: LeakNode
-    ): LeakNodeStatusAndReason = with(parser) {
-      return if (node.instance.objectRecord is ClassDumpRecord) {
+    ): LeakNodeStatusAndReason {
+      val record =
+        GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).readObjectRecord()
+      return if (record is GraphClassRecord) {
         LeakNodeStatus.notLeaking("a class is never leaking")
       } else LeakNodeStatus.unknown()
     }
@@ -111,8 +143,15 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown("android.app.Fragment") { instance ->
-        instance.leakingWhenNull("mFragmentManager")
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          "android.app.Fragment"
+      ) { instance ->
+        val field = instance["mFragmentManager"]!!
+        if (field.value.isNullReference) {
+          LeakNodeStatus.leaking(field describedWithValue "null")
+        } else {
+          LeakNodeStatus.notLeaking(field describedWithValue "not null")
+        }
       }
   },
 
@@ -121,8 +160,15 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown("android.support.v4.app.Fragment") { instance ->
-        instance.leakingWhenNull("mFragmentManager")
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          "android.support.v4.app.Fragment"
+      ) { instance ->
+        val field = instance["mFragmentManager"]!!
+        if (field.value.isNullReference) {
+          LeakNodeStatus.leaking(field describedWithValue "null")
+        } else {
+          LeakNodeStatus.notLeaking(field describedWithValue "not null")
+        }
       }
   },
 
@@ -131,12 +177,16 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown("android.os.MessageQueue") { instance ->
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          "android.os.MessageQueue"
+      ) { instance ->
         // If the queue is not quitting, maybe it should actually have been, we don't know.
         // However, if it's quitting, it is very likely that's not a bug.
-        when (instance["mQuitting"].boolean) {
-          true -> LeakNodeStatus.leaking("MessageQueue#mQuitting is true")
-          else -> LeakNodeStatus.unknown()
+        val field = instance["mQuitting"]!!
+        if (field.value.asBoolean == true) {
+          LeakNodeStatus.leaking(field describedWithValue "true")
+        } else {
+          LeakNodeStatus.unknown()
         }
       }
   },
@@ -146,12 +196,15 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown("mortar.Presenter") { instance ->
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          "mortar.Presenter"
+      ) { instance ->
         // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
         // should be unreachable, so in that case we don't know their reachability status. However,
         // when the view is null, we're pretty sure they  never leaking.
-        if (instance["view"].isNullReference) {
-          LeakNodeStatus.leaking("Presenter#view is null")
+        val field = instance["view"]!!
+        if (field.value.isNullReference) {
+          LeakNodeStatus.leaking(field describedWithValue "null")
         } else {
           LeakNodeStatus.unknown()
         }
@@ -163,8 +216,10 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown(Thread::class) { instance ->
-        if (instance["name"].reference.stringOrNull == "main") {
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          Thread::class
+      ) { instance ->
+        if (instance["name"]!!.value.readAsJavaString() == "main") {
           LeakNodeStatus.notLeaking("the main thread always runs")
         } else {
           LeakNodeStatus.unknown()
@@ -177,8 +232,16 @@ enum class AndroidLeakInspectors : LeakInspector {
       parser: HprofParser,
       node: LeakNode
     ): LeakNodeStatusAndReason =
-      (parser to node).instanceOfOrUnknown("android.view.Window") { instance ->
-        instance.leakingWhenTrue("mDestroyed")
+      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
+          "android.view.Window"
+      ) { instance ->
+        val field = instance["mDestroyed"]!!
+
+        if (field.value.asBoolean!!) {
+          LeakNodeStatus.leaking(field describedWithValue "true")
+        } else {
+          LeakNodeStatus.notLeaking(field describedWithValue "false")
+        }
       }
   },
 
@@ -186,8 +249,14 @@ enum class AndroidLeakInspectors : LeakInspector {
     override fun invoke(
       parser: HprofParser,
       node: LeakNode
-    ): LeakNodeStatusAndReason = with(parser) {
-      return if (node.instance.objectRecord.isInstanceOf("android.widget.Toast\$TN")) {
+    ): LeakNodeStatusAndReason {
+      val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
+
+
+      return if (heapValue.readObjectRecord()?.asInstance?.instanceOf(
+              "android.widget.Toast\$TN"
+          ) == true
+      ) {
         LeakNodeStatus.notLeaking(
             "Toast.TN (Transient Notification) is never leaking"
         )
@@ -207,58 +276,21 @@ enum class AndroidLeakInspectors : LeakInspector {
   }
 }
 
-inline fun Pair<HprofParser, LeakNode>.instanceOfOrUnknown(
+fun GraphHeapValue.instanceOfOrUnknown(
   expectedClass: KClass<out Any>,
-  block: HprofParser.(HydratedInstance) -> LeakNodeStatusAndReason
+  block: (GraphInstanceRecord) -> LeakNodeStatusAndReason
 ): LeakNodeStatusAndReason = instanceOfOrUnknown(expectedClass.java.name, block)
 
-inline fun Pair<HprofParser, LeakNode>.instanceOfOrUnknown(
-  className: String,
-  block: HprofParser.(HydratedInstance) -> LeakNodeStatusAndReason
-): LeakNodeStatusAndReason =
-  this.instanceOf(className)?.let { first.block(it) } ?: LeakNodeStatus.unknown()
-
-fun Pair<HprofParser, LeakNode>.instanceOf(className: String): HydratedInstance? = with(first) {
-  val record = second.instance.objectRecord
-  if (!record.isInstanceOf(className)) {
-    null
-  } else {
-    hydrateInstance(record as InstanceDumpRecord)
-  }
-}
-
-fun HydratedInstance.leakingWhenNull(
-  fieldName: String
+fun GraphHeapValue.instanceOfOrUnknown(
+  expectedClass: String,
+  block: (GraphInstanceRecord) -> LeakNodeStatusAndReason
 ): LeakNodeStatusAndReason {
-  val className = classHierarchy[0].simpleClassName
-  if (!hasField(fieldName)) {
-    return LeakNodeStatus.unknown()
-  }
-  val value = this[fieldName].reference
-
-  return if (value == null) {
-    LeakNodeStatus.leaking(
-        "$className#$fieldName is null"
-    )
-  } else {
-    LeakNodeStatus.notLeaking(
-        "$className#$fieldName is not null"
-    )
-  }
+  val record = readObjectRecord()?.asInstance
+  return if (record != null && record instanceOf expectedClass) {
+    block(record)
+  } else LeakNodeStatus.unknown()
 }
 
-fun HydratedInstance.leakingWhenTrue(
-  fieldName: String
-): LeakNodeStatusAndReason {
-  val className = classHierarchy[0].simpleClassName
-
-  return when (this[fieldName].boolean) {
-    null -> LeakNodeStatus.unknown()
-    true -> LeakNodeStatus.leaking(
-        "$className#$fieldName is true"
-    )
-    false -> LeakNodeStatus.notLeaking(
-        "$className#$fieldName is false"
-    )
-  }
+private infix fun GraphField.describedWithValue(valueDescription: String): String {
+  return "${classRecord.simpleName}#$name is $valueDescription"
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index 01ac5e29..d197003d 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -31,6 +31,7 @@ import leakcanary.GcRoot.ReferenceCleanup
 import leakcanary.GcRoot.StickyClass
 import leakcanary.GcRoot.ThreadBlock
 import leakcanary.GcRoot.ThreadObject
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNodeStatus.LEAKING
@@ -98,14 +99,16 @@ class HeapAnalyzer constructor(
     try {
       HprofParser.open(heapDumpFile)
           .use { parser ->
+            val graph = HprofGraph(parser)
             listener.onProgressUpdate(SCANNING_HEAP_DUMP)
             val (gcRootIds, keyedWeakReferenceInstances, cleaners) = scan(
+                graph,
                 parser, computeRetainedHeapSize
             )
             val analysisResults = mutableMapOf<String, RetainedInstance>()
             listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
 
-            val retainedWeakRefs = findLeakingReferences(parser, keyedWeakReferenceInstances)
+            val retainedWeakRefs = findLeakingReferences(graph, keyedWeakReferenceInstances)
 
             if (retainedWeakRefs.isEmpty()) {
               val exception = IllegalStateException("No retained instances found in heap dump")
@@ -149,23 +152,28 @@ class HeapAnalyzer constructor(
 
   private data class ScanResult(
     val gcRootIds: MutableList<GcRoot>,
-    val keyedWeakReferenceInstances: List<InstanceDumpRecord>,
+    val keyedWeakReferenceInstances: List<GraphInstanceRecord>,
     val cleaners: MutableList<Long>
   )
 
   private fun scan(
+    graph: HprofGraph,
     parser: HprofParser,
     computeRetainedSize: Boolean
   ): ScanResult {
-    val keyedWeakReferenceInstances = mutableListOf<InstanceDumpRecord>()
+    val keyedWeakReferenceInstances = mutableListOf<GraphInstanceRecord>()
     val gcRoot = mutableListOf<GcRoot>()
     val cleaners = mutableListOf<Long>()
     val callbacks = RecordCallbacks()
         .on(InstanceDumpRecord::class.java) { record ->
           when (parser.className(record.classId)) {
-            KeyedWeakReference::class.java.name -> keyedWeakReferenceInstances.add(record)
+            KeyedWeakReference::class.java.name -> keyedWeakReferenceInstances.add(
+                GraphInstanceRecord(graph, record)
+            )
             // Pre 2.0 KeyedWeakReference
-            "com.squareup.leakcanary.KeyedWeakReference" -> keyedWeakReferenceInstances.add(record)
+            "com.squareup.leakcanary.KeyedWeakReference" -> keyedWeakReferenceInstances.add(
+                GraphInstanceRecord(graph, record)
+            )
             "sun.misc.Cleaner" -> if (computeRetainedSize) cleaners.add(record.id)
           }
         }
@@ -198,17 +206,16 @@ class HeapAnalyzer constructor(
   }
 
   private fun findLeakingReferences(
-    parser: HprofParser,
-    keyedWeakReferenceInstances: List<InstanceDumpRecord>
+    graph: HprofGraph,
+    keyedWeakReferenceInstances: List<GraphInstanceRecord>
   ): MutableList<KeyedWeakReferenceMirror> {
 
-    val keyedWeakReferenceClassId = parser.classId(KeyedWeakReference::class.java.name)
+    val keyedWeakReferenceClass = graph.readClass(KeyedWeakReference::class.java.name)
 
-    val heapDumpUptimeMillis = if (keyedWeakReferenceClassId == null) {
+    val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
       null
     } else {
-      val keyedWeakReferenceClass = parser.hydrateClassHierarchy(keyedWeakReferenceClassId)[0]
-      keyedWeakReferenceClass["heapDumpUptimeMillis"].long
+      keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
     }
 
     if (heapDumpUptimeMillis == null) {
@@ -221,9 +228,7 @@ class HeapAnalyzer constructor(
     val retainedInstances = mutableListOf<KeyedWeakReferenceMirror>()
     keyedWeakReferenceInstances.forEach { record ->
       val weakRef =
-        KeyedWeakReferenceMirror.fromInstance(
-            parser, parser.hydrateInstance(record), heapDumpUptimeMillis
-        )
+        KeyedWeakReferenceMirror.fromInstance(record, heapDumpUptimeMillis)
       if (weakRef.isRetained && weakRef.hasReferent) {
         retainedInstances.add(weakRef)
       }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
index 5862b9f6..093cb90b 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
@@ -1,5 +1,6 @@
 package leakcanary
 
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.HeapValue.BooleanValue
 import leakcanary.HeapValue.ByteValue
 import leakcanary.HeapValue.CharValue
@@ -9,8 +10,6 @@ import leakcanary.HeapValue.IntValue
 import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 
 typealias Labeler = (HprofParser, LeakNode) -> List<String>
 
@@ -22,61 +21,64 @@ typealias Labeler = (HprofParser, LeakNode) -> List<String>
 class AllFieldsLabeler(
   private val labelStaticFields: Boolean = false
 ) : Labeler {
+
   override fun invoke(
     parser: HprofParser,
     node: LeakNode
-  ): List<String> = with(HprofGraph(parser)) {
+  ): List<String> {
+    val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
     val labels = mutableListOf<String>()
 
-    val record = ObjectReference(node.instance).record
-    if (record is InstanceDumpRecord) {
-      var classRecord = record.classRecord
+    val record = heapValue.readObjectRecord()
+    if (record is GraphInstanceRecord) {
+      var classRecord = record.readClass()
 
-      val allFields = record.fields
+      val instanceField = record.readFields()
 
       var classIndex = 0
       while (classRecord.name != "java.lang.Object") {
-        val fields = allFields[classIndex]
+        val fields = instanceField[classIndex]
 
         labels.add("Class ${classRecord.name}")
         if (labelStaticFields) {
-          classRecord.staticFieldNames.forEachIndexed { index, name ->
-            val valueString = heapValueAsString(classRecord.staticFields[index].value)
-            labels.add("  static $name=$valueString")
+
+          for (field in classRecord.staticFields) {
+            val valueString = heapValueAsString(field.value)
+            labels.add("  static ${field.name}=$valueString")
           }
         }
 
-        for ((name, value) in fields) {
-          labels.add("  $name=${heapValueAsString(value)}")
+        for (field in fields) {
+          labels.add("  ${field.name}=${heapValueAsString(field.value)}")
         }
         classIndex++
-        classRecord = classRecord.superClassRecord!!
+        classRecord = classRecord.readSuperClass()!!
       }
     }
     return labels
   }
 
-  private fun HprofGraph.heapValueAsString(heapValue: HeapValue): String {
-    return when (heapValue) {
+  private fun heapValueAsString(heapValue: GraphHeapValue): String {
+    return when (val actualValue = heapValue.actual) {
       is ObjectReference -> {
-        if (heapValue.isNull) {
+        if (heapValue.isNullReference) {
           "null"
         } else {
           when {
-            heapValue.isString -> "\"${heapValue.record.string}\""
-            heapValue.isClass -> (heapValue.record as ClassDumpRecord).name
-            else -> "@${heapValue.value}"
+            heapValue.referencesJavaString -> "\"${heapValue.readAsJavaString()!!}\""
+            heapValue.referencesClass -> heapValue.readObjectRecord()!!.asClass!!.name
+            else -> "@${actualValue.value}"
           }
         }
       }
-      is BooleanValue -> heapValue.value.toString()
-      is CharValue -> heapValue.value.toString()
-      is FloatValue -> heapValue.value.toString()
-      is DoubleValue -> heapValue.value.toString()
-      is ByteValue -> heapValue.value.toString()
-      is ShortValue -> heapValue.value.toString()
-      is IntValue -> heapValue.value.toString()
-      is LongValue -> heapValue.value.toString()
+      is BooleanValue -> actualValue.value.toString()
+      is CharValue -> actualValue.value.toString()
+      is FloatValue -> actualValue.value.toString()
+      is DoubleValue -> actualValue.value.toString()
+      is ByteValue -> actualValue.value.toString()
+      is ShortValue -> actualValue.value.toString()
+      is IntValue -> actualValue.value.toString()
+      is LongValue -> actualValue.value.toString()
     }
   }
 }
@@ -85,19 +87,19 @@ object InstanceDefaultLabeler : Labeler {
   override fun invoke(
     parser: HprofParser,
     node: LeakNode
-  ): List<String> = with(HprofGraph(parser)) {
-    val record = ObjectReference(node.instance).record
-    if (record is InstanceDumpRecord) {
+  ): List<String> {
+    val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
+
+    val record = heapValue.readObjectRecord()!!
+    if (record is GraphInstanceRecord) {
       val labels = mutableListOf<String>()
       if (record instanceOf Thread::class) {
-        // Sometimes we can't find the String at the expected memory address in the heap dump.
-        // See https://github.com/square/leakcanary/issues/417
-        val threadName = record["name"].record.string ?: "not available"
+        val threadName = record["name"]!!.value.readAsJavaString()
         labels.add("Thread name: '$threadName'")
       } else {
-        val classRecord = record.classRecord
+        val classRecord = record.readClass()
         if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
-          val parentClassRecord = classRecord.superClassRecord!!
+          val parentClassRecord = classRecord.readSuperClass()!!
           if (parentClassRecord.name == "java.lang.Object") {
             try {
               // This is an anonymous class implementing an interface. The API does not give access
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
index fa97567b..f606e7c8 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
@@ -1,9 +1,7 @@
 package leakcanary.internal
 
-import leakcanary.HeapValue.LongValue
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.HeapValue.ObjectReference
-import leakcanary.HprofParser
-import leakcanary.HydratedInstance
 
 internal class KeyedWeakReferenceMirror(
   val referent: ObjectReference,
@@ -27,38 +25,31 @@ internal class KeyedWeakReferenceMirror(
     private const val UNKNOWN_LEGACY = "Unknown (legacy)"
 
     fun fromInstance(
-      parser: HprofParser,
-      weakRef: HydratedInstance,
+      weakRef: GraphInstanceRecord,
       // Null for pre 2.0 alpha 3 heap dumps
       heapDumpUptimeMillis: Long?
     ): KeyedWeakReferenceMirror {
 
       val watchDurationMillis = if (heapDumpUptimeMillis != null)
-        heapDumpUptimeMillis - weakRef.fieldValue<LongValue>("watchUptimeMillis").value
+        heapDumpUptimeMillis - weakRef["watchUptimeMillis"]!!.value.asLong!!
       else 0L
 
       val retainedDurationMillis = if (heapDumpUptimeMillis != null) {
-        val retainedUptimeMillis = weakRef.fieldValue<LongValue>("retainedUptimeMillis")
-            .value
+        val retainedUptimeMillis = weakRef["retainedUptimeMillis"]!!.value.asLong!!
         if (retainedUptimeMillis == -1L) -1L else heapDumpUptimeMillis - retainedUptimeMillis
       } else null
 
-      val key = weakRef.fieldValue<ObjectReference>("key")
-      val keyString = parser.retrieveString(key)
-
-      val name = weakRef.fieldValueOrNull<ObjectReference>("name")
-      val nameString = if (name != null) parser.retrieveString(name) else UNKNOWN_LEGACY
-      val className = weakRef.fieldValueOrNull<ObjectReference>("className")
-      val classNameString =
-        if (className != null) parser.retrieveString(className) else UNKNOWN_LEGACY
+      val keyString = weakRef["key"]!!.value.readAsJavaString()!!
 
+      val name = weakRef["name"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
+      val className = weakRef["className"]?.value?.readAsJavaString() ?: UNKNOWN_LEGACY
       return KeyedWeakReferenceMirror(
           watchDurationMillis = watchDurationMillis,
           retainedDurationMillis = retainedDurationMillis,
-          referent = weakRef.fieldValue("referent"),
+          referent = weakRef["referent"]!!.value.actual as ObjectReference,
           key = keyString,
-          name = nameString,
-          className = classNameString
+          name = name,
+          className = className
       )
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt b/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt
index 398181f0..7ba7ce80 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt
@@ -2,9 +2,8 @@ package leakcanary
 
 import android.app.Application
 import android.content.res.Resources.NotFoundException
-import leakcanary.HeapValue.IntValue
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.HeapValue.ObjectReference
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 
 class ViewLabeler(
   private val application: Application
@@ -12,14 +11,13 @@ class ViewLabeler(
   override fun invoke(
     parser: HprofParser,
     node: LeakNode
-  ): List<String> = with(HprofGraph(parser)) {
-    val record = ObjectReference(node.instance)
-        .record
+  ): List<String> {
+    val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
+    val record = heapValue.readObjectRecord()
 
-    if (record instanceOf "android.view.View") {
+    if (record is GraphInstanceRecord && record instanceOf "android.view.View") {
       val viewLabels = mutableListOf<String>()
-      record as InstanceDumpRecord
-      val mAttachInfo = record["mAttachInfo"]
+      val mAttachInfo = record["mAttachInfo"]?.value
       if (mAttachInfo != null) {
         if (mAttachInfo.isNullReference) {
           viewLabels.add("View#mAttachInfo is null (view detached)")
@@ -28,7 +26,7 @@ class ViewLabeler(
         }
       }
 
-      val mParent = record["mParent"]
+      val mParent = record["mParent"]?.value
       if (mParent != null) {
         if (mParent.isNullReference) {
           viewLabels.add("View#mParent is null")
@@ -37,24 +35,24 @@ class ViewLabeler(
         }
       }
 
-      val mID = record["mId"]
-      if (mID is IntValue) {
-        if (mID.value != 0) {
+      val mID = record["mId"]?.value?.asInt
+      if (mID != null) {
+        if (mID != 0) {
           try {
-            val name = application.resources.getResourceEntryName(mID.value)
-            viewLabels.add("View.mID=R.id.$name (${mID.value})")
+            val name = application.resources.getResourceEntryName(mID)
+            viewLabels.add("View.mID=R.id.$name ($mID)")
           } catch (ignored: NotFoundException) {
-            viewLabels.add("View.mID=${mID.value} (name not found)")
+            viewLabels.add("View.mID=$mID (name not found)")
           }
         } else {
           viewLabels.add("View.mID=0")
         }
       }
 
-      val mWindowAttachCount = record["mWindowAttachCount"]
+      val mWindowAttachCount = record["mWindowAttachCount"]?.value?.asInt
 
-      if (mWindowAttachCount is IntValue) {
-        viewLabels.add("View.mWindowAttachCount=${mWindowAttachCount.value}")
+      if (mWindowAttachCount != null) {
+        viewLabels.add("View.mWindowAttachCount=$mWindowAttachCount")
       }
       return viewLabels
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index 8f3177f8..6abc37c2 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -71,7 +71,7 @@ internal class HeapDumpTrigger(
       return
     }
 
-    var retainedReferenceCount = refWatcher.retainedReferenceCount
+    var retainedReferenceCount = refWatcher.retainedInstanceCount
 
     if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
@@ -87,7 +87,7 @@ internal class HeapDumpTrigger(
 
     gcTrigger.runGc()
 
-    retainedReferenceCount = refWatcher.retainedReferenceCount
+    retainedReferenceCount = refWatcher.retainedInstanceCount
 
     if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
@@ -103,7 +103,7 @@ internal class HeapDumpTrigger(
       return
     }
 
-    refWatcher.removeKeysRetainedBeforeHeapDump(heapDumpUptimeMillis)
+    refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
 
     HeapAnalyzerService.runAnalysis(application, heapDumpFile)
   }
@@ -111,7 +111,7 @@ internal class HeapDumpTrigger(
   fun onDumpHeapReceived() {
     backgroundHandler.post {
       gcTrigger.runGc()
-      val retainedReferenceCount = refWatcher.retainedReferenceCount
+      val retainedReferenceCount = refWatcher.retainedInstanceCount
       if (retainedReferenceCount == 0) {
         CanaryLog.d("No retained instances after GC")
         val builder = Notification.Builder(application)
@@ -142,7 +142,7 @@ internal class HeapDumpTrigger(
         return@post
       }
 
-      refWatcher.removeKeysRetainedBeforeHeapDump(heapDumpUptimeMillis)
+      refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
       HeapAnalyzerService.runAnalysis(application, heapDumpFile)
     }
   }
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
index 048dacf1..f8513a60 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -25,12 +25,12 @@ class FragmentLeakTest {
 
   @Before fun setUp() {
     LeakSentry.refWatcher
-        .clearWatchedReferences()
+        .clearWatchedInstances()
   }
 
   @After fun tearDown() {
     LeakSentry.refWatcher
-        .clearWatchedReferences()
+        .clearWatchedInstances()
   }
 
   @Test
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
index dcc44bc6..3f15083f 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -14,12 +14,12 @@ class InstrumentationLeakDetectorTest {
 
   @Before fun setUp() {
     LeakSentry.refWatcher
-        .clearWatchedReferences()
+        .clearWatchedInstances()
   }
 
   @After fun tearDown() {
     LeakSentry.refWatcher
-        .clearWatchedReferences()
+        .clearWatchedInstances()
   }
 
   @Test fun detectsLeak() {
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
index 6259a841..cd470232 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -81,7 +81,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   override fun testFinished(description: Description) {
     detectLeaks()
-    LeakSentry.refWatcher.clearWatchedReferences()
+    LeakSentry.refWatcher.clearWatchedInstances()
   }
 
   override fun testRunStarted(description: Description) {
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index a38a6dd5..8d0921a1 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -109,17 +109,17 @@ class InstrumentationLeakDetector {
     val context = instrumentation.targetContext
     val refWatcher = LeakSentry.refWatcher
 
-    if (!refWatcher.hasWatchedReferences) {
+    if (!refWatcher.hasWatchedInstances) {
       return NoAnalysis
     }
 
     instrumentation.waitForIdleSync()
-    if (!refWatcher.hasWatchedReferences) {
+    if (!refWatcher.hasWatchedInstances) {
       return NoAnalysis
     }
 
     runGc()
-    if (!refWatcher.hasWatchedReferences) {
+    if (!refWatcher.hasWatchedInstances) {
       return NoAnalysis
     }
 
@@ -127,7 +127,7 @@ class InstrumentationLeakDetector {
     // Android simply has way too many delayed posts that aren't canceled when views are detached.
     SystemClock.sleep(2000)
 
-    if (!refWatcher.hasWatchedReferences) {
+    if (!refWatcher.hasWatchedInstances) {
       return NoAnalysis
     }
 
@@ -143,7 +143,7 @@ class InstrumentationLeakDetector {
 
     runGc()
 
-    if (!refWatcher.hasRetainedReferences) {
+    if (!refWatcher.hasRetainedInstances) {
       return NoAnalysis
     }
 
@@ -168,7 +168,7 @@ class InstrumentationLeakDetector {
       )
     }
 
-    refWatcher.removeKeysRetainedBeforeHeapDump(heapDumpUptimeMillis)
+    refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
 
     val listener = AnalyzerProgressListener.NONE
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt b/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
new file mode 100644
index 00000000..9ab4dfe5
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/FieldValuesReader.kt
@@ -0,0 +1,7 @@
+package leakcanary
+
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+
+interface FieldValuesReader {
+  fun readValue(field: FieldRecord): HeapValue
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
new file mode 100644
index 00000000..ce400a5b
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
@@ -0,0 +1,9 @@
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphClassRecord
+
+class GraphField(
+  val classRecord: GraphClassRecord,
+  val name: String,
+  val value: GraphHeapValue
+)
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
new file mode 100644
index 00000000..ee314480
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
@@ -0,0 +1,75 @@
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
+import leakcanary.HeapValue.BooleanValue
+import leakcanary.HeapValue.ByteValue
+import leakcanary.HeapValue.CharValue
+import leakcanary.HeapValue.DoubleValue
+import leakcanary.HeapValue.FloatValue
+import leakcanary.HeapValue.IntValue
+import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.HeapValue.ShortValue
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+
+class GraphHeapValue(
+  private val graph: HprofGraph,
+  val actual: HeapValue
+) {
+  val asBoolean: Boolean?
+    get() = if (actual is BooleanValue) actual.value else null
+
+  val asChar: Char?
+    get() = if (actual is CharValue) actual.value else null
+
+  val asFloat: Float?
+    get() = if (actual is FloatValue) actual.value else null
+
+  val asDouble: Double?
+    get() = if (actual is DoubleValue) actual.value else null
+
+  val asByte: Byte?
+    get() = if (actual is ByteValue) actual.value else null
+
+  val asShort: Short?
+    get() = if (actual is ShortValue) actual.value else null
+
+  val asInt: Int?
+    get() = if (actual is IntValue) actual.value else null
+
+  val asLong: Long?
+    get() = if (actual is LongValue) actual.value else null
+
+  val isNullReference: Boolean
+    get() = actual is ObjectReference && actual.isNull
+
+  val referencesJavaString: Boolean
+    get() = actual is ObjectReference && graph.referencesJavaString(actual)
+
+  val referencesClass: Boolean
+    get() = actual is ObjectReference && graph.referencesClass(actual)
+
+
+  fun readAsJavaString(): String? {
+    return readObjectRecord()?.asInstance?.readAsJavaString()
+  }
+
+  fun readObjectRecord(): GraphObjectRecord? {
+    return if (actual is ObjectReference && !actual.isNull) {
+      return when (val objectRecord = graph.readObjectRecord(actual.value)) {
+        is ClassDumpRecord -> GraphClassRecord(graph, objectRecord)
+        is InstanceDumpRecord -> GraphInstanceRecord(graph, objectRecord)
+        is ObjectArrayDumpRecord -> GraphObjectArrayRecord(graph, objectRecord)
+        is PrimitiveArrayDumpRecord -> GraphPrimitiveArrayRecord(objectRecord)
+      }
+    } else {
+      null
+    }
+  }
+}
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
new file mode 100644
index 00000000..482ab6f0
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
@@ -0,0 +1,205 @@
+package leakcanary
+
+import leakcanary.Record.HeapDumpRecord.ObjectRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import java.nio.charset.Charset
+import kotlin.reflect.KClass
+
+sealed class GraphObjectRecord {
+  abstract val record: ObjectRecord
+
+  val asClass: GraphClassRecord?
+    get() = if (this is GraphClassRecord) this else null
+
+  val asInstance: GraphInstanceRecord?
+    get() = if (this is GraphInstanceRecord) this else null
+
+  val asObjectArray: GraphObjectArrayRecord?
+    get() = if (this is GraphObjectArrayRecord) this else null
+
+  val asPrimitiveArray: GraphPrimitiveArrayRecord?
+    get() = if (this is GraphPrimitiveArrayRecord) this else null
+
+  class GraphClassRecord(
+    private val graph: HprofGraph,
+    override val record: ClassDumpRecord
+  ) : GraphObjectRecord() {
+
+    val name: String
+      get() = graph.className(record.id)
+
+    val simpleName: String
+      get() {
+        val className = this.name
+        val separator = className.lastIndexOf('.')
+        return if (separator == -1) {
+          className
+        } else {
+          className.substring(separator + 1)
+        }
+      }
+
+    fun readSuperClass(): GraphClassRecord? {
+      if (record.superClassId == 0L) return null
+      val superClassRecord = graph.readObjectRecord(record.superClassId) as ClassDumpRecord
+      return GraphClassRecord(graph, superClassRecord)
+    }
+
+    val staticFields
+      get(): List<GraphField> {
+        val fields = mutableListOf<GraphField>()
+        for (fieldRecord in record.staticFields) {
+          fields += GraphField(
+              this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
+          )
+        }
+        return fields
+      }
+
+    operator fun get(fieldName: String): GraphField? {
+      for (fieldRecord in record.staticFields) {
+        if (graph.staticFieldName(fieldRecord) == fieldName) {
+          return GraphField(
+              this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
+          )
+        }
+      }
+      return null
+    }
+  }
+
+  class GraphInstanceRecord(
+    private val graph: HprofGraph,
+    override val record: InstanceDumpRecord
+  ) : GraphObjectRecord() {
+
+    infix fun instanceOf(className: String): Boolean {
+      var currentClassId = record.classId
+      while (currentClassId != 0L) {
+        if (graph.className(currentClassId) == className) {
+          return true
+        }
+
+        val currentClassRecord = graph.readObjectRecord(currentClassId) as ClassDumpRecord
+        currentClassId = currentClassRecord.superClassId
+      }
+      return false
+    }
+
+    infix fun instanceOf(expectedClass: KClass<*>) =
+      this instanceOf expectedClass.java.name
+
+    operator fun get(fieldName: String): GraphField? {
+      val fieldReader = graph.createFieldValuesReader(record)
+
+      var currentClassId = record.classId
+
+      do {
+        val classRecord = graph.readObjectRecord(currentClassId) as ClassDumpRecord
+
+        for (fieldRecord in classRecord.fields) {
+          val fieldValue = fieldReader.readValue(fieldRecord)
+
+          if (graph.fieldName(fieldRecord) == fieldName) {
+            return GraphField(
+                GraphClassRecord(graph, classRecord), fieldName, GraphHeapValue(graph, fieldValue)
+            )
+          }
+        }
+        currentClassId = classRecord.superClassId
+      } while (currentClassId != 0L)
+      return null
+    }
+
+    val className: String
+      get() = graph.className(record.classId)
+
+    val simpleClassName: String
+      get() {
+        val className = this.className
+        val separator = className.lastIndexOf('.')
+        return if (separator == -1) {
+          className
+        } else {
+          className.substring(separator + 1)
+        }
+      }
+
+    fun readClass(): GraphClassRecord {
+      val classRecord = graph.readObjectRecord(record.classId) as ClassDumpRecord
+      return GraphClassRecord(graph, classRecord)
+    }
+
+    fun readFields(): List<List<GraphField>> {
+      val allFields = mutableListOf<List<GraphField>>()
+      val fieldReader = graph.createFieldValuesReader(record)
+
+      var currentClassId = record.classId
+      do {
+        val classFields = mutableListOf<GraphField>()
+        allFields += classFields
+
+        val classRecord = graph.readObjectRecord(currentClassId) as ClassDumpRecord
+
+        for (fieldRecord in classRecord.fields) {
+          val fieldName = graph.fieldName(fieldRecord)
+          val fieldValue = fieldReader.readValue(fieldRecord)
+          classFields += GraphField(
+              GraphClassRecord(graph, classRecord), fieldName, GraphHeapValue(graph, fieldValue)
+          )
+        }
+        currentClassId = classRecord.superClassId
+      } while (currentClassId != 0L)
+      return allFields
+    }
+
+    fun readAsJavaString(): String? {
+      if (!graph.isJavaString(record)) {
+        return null
+      }
+      val count = this["count"]!!.value.asInt!!
+      if (count == 0) {
+        return ""
+      }
+
+      // Prior to API 26 String.value was a char array.
+      // Since API 26 String.value is backed by native code. The vast majority of strings in a
+      // heap dump are backed by a byte array, but we still find a few backed by a char array.
+      when (val valueRecord = this["value"]!!.value.readObjectRecord()!!.record) {
+        is CharArrayDump -> {
+          // < API 23
+          // As of Marshmallow, substrings no longer share their parent strings' char arrays
+          // eliminating the need for String.offset
+          // https://android-review.googlesource.com/#/c/83611/
+          val offset = this["offset"]?.value?.asInt ?: 0
+
+          val chars = valueRecord.array.copyOfRange(offset, offset + count)
+          return String(chars)
+        }
+        is ByteArrayDump -> {
+          return String(valueRecord.array, Charset.forName("UTF-8"))
+        }
+        else -> throw UnsupportedOperationException(
+            "'value' field ${this["value"]!!.value} was expected to be either a char or byte array in string instance with id ${record.id}"
+        )
+      }
+    }
+  }
+
+  class GraphObjectArrayRecord(
+    private val graph: HprofGraph,
+    override val record: ObjectArrayDumpRecord
+  ) : GraphObjectRecord() {
+  }
+
+  class GraphPrimitiveArrayRecord(
+    override val record: PrimitiveArrayDumpRecord
+  ) : GraphObjectRecord() {
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
index f6ac1d0c..b55d3033 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -1,164 +1,65 @@
 package leakcanary
 
+import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.ObjectIdMetadata.CLASS
-import leakcanary.ObjectIdMetadata.INSTANCE
 import leakcanary.ObjectIdMetadata.STRING
 import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
 import okio.Buffer
-import java.nio.charset.Charset
-import kotlin.reflect.KClass
 
 class HprofGraph(private val parser: HprofParser) {
 
-  val HeapValue?.record: ObjectRecord?
-    get() = if (this is ObjectReference && !isNull) {
-      parser.retrieveRecord(this)
-    } else
+  fun readClass(className: String): GraphClassRecord? {
+    val classId = parser.classId(className)
+    return if (classId == null) {
       null
-
-  val ObjectReference.isString: Boolean
-    get() = if (value == 0L) false else parser.objectIdMetadata(value) == STRING
-
-  val ObjectReference.isClass: Boolean
-    get() = if (value == 0L) false else parser.objectIdMetadata(value) == CLASS
-
-  val ObjectReference.isInstance: Boolean
-    get() = if (value == 0L) false else parser.objectIdMetadata(value) == INSTANCE
-
-  infix fun ObjectRecord?.instanceOf(expectedClass: KClass<*>) =
-    this instanceOf expectedClass.java.name
-
-  infix fun ObjectRecord?.instanceOf(className: String): Boolean {
-    if (this !is InstanceDumpRecord) {
-      return false
-    }
-
-    var currentClassId = classId
-    while (currentClassId != 0L) {
-      if (parser.className(currentClassId) == className) {
-        return true
-      }
-      val currentClassRecord = parser.retrieveRecordById(currentClassId) as ClassDumpRecord
-      currentClassId = currentClassRecord.superClassId
+    } else {
+      GraphClassRecord(this, readObjectRecord(classId) as ClassDumpRecord)
     }
-    return false
   }
 
-  val ObjectRecord?.string: String?
-    get() {
-      if (this == null) {
-        return null
-      } else {
-        if (this is InstanceDumpRecord && parser.objectIdMetadata(id) == STRING) {
-          val count = this["count"].int!!
-
-          if (count == 0) {
-            return ""
-          }
-
-          // Prior to API 26 String.value was a char array.
-          // Since API 26 String.value is backed by native code. The vast majority of strings in a
-          // heap dump are backed by a byte array, but we still find a few backed by a char array.
-          when (val valueRecord = this["value"]?.record) {
-            is CharArrayDump -> {
-              // < API 23
-              // As of Marshmallow, substrings no longer share their parent strings' char arrays
-              // eliminating the need for String.offset
-              // https://android-review.googlesource.com/#/c/83611/
-              val offset = this["offset"].int ?: 0
-
-              val chars = valueRecord.array.copyOfRange(offset, offset + count)
-              return String(chars)
-            }
-            is ByteArrayDump -> {
-              return String(valueRecord.array, Charset.forName("UTF-8"))
-            }
-            else -> throw UnsupportedOperationException(
-                "'value' field ${this["value"]} was expected to be either a char or byte array in string instance with id $id"
-            )
-          }
-        } else {
-          return null
-        }
-      }
-    }
-
-  operator fun ObjectArrayDumpRecord.get(index: Int) = ObjectReference(elementIds[index])
-
-  val InstanceDumpRecord.classRecord
-    get() = parser.retrieveRecordById(classId) as ClassDumpRecord
+  fun readObjectRecord(objectId: Long): ObjectRecord {
+    return parser.retrieveRecordById(objectId)
+  }
 
-  val ClassDumpRecord.superClassRecord
-    get() = if (superClassId == 0L) null else
-      parser.retrieveRecordById(superClassId) as ClassDumpRecord
+  fun className(classId: Long): String {
+    return parser.className(classId)
+  }
 
-  val ClassDumpRecord.name
-    get() = parser.className(id)
+  fun fieldName(fieldRecord: FieldRecord): String {
+    return parser.hprofStringById(fieldRecord.nameStringId)
+  }
 
-  val ClassDumpRecord.staticFieldNames
-    get(): List<String> {
-      val fieldNames = mutableListOf<String>()
-      for (field in staticFields) {
-        fieldNames += parser.hprofStringById(field.nameStringId)
-      }
-      return fieldNames
-    }
+  fun staticFieldName(fieldRecord: StaticFieldRecord): String {
+    return parser.hprofStringById(fieldRecord.nameStringId)
+  }
 
-  operator fun InstanceDumpRecord.get(fieldName: String): HeapValue? {
+  fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
     val buffer = Buffer()
-    buffer.write(fieldValues)
-    val valuesReader = HprofReader(buffer, 0, parser.idSize)
-
-    var currentClassId = classId
+    buffer.write(record.fieldValues)
 
-    do {
-      val classRecord = parser.retrieveRecordById(currentClassId) as ClassDumpRecord
+    val reader = HprofReader(buffer, 0, parser.idSize)
 
-      for (fieldRecord in classRecord.fields) {
-        val fieldValue = valuesReader.readValue(fieldRecord.type)
-
-        if (parser.hprofStringById(fieldRecord.nameStringId) == fieldName) {
-          return fieldValue
-        }
+    return object : FieldValuesReader {
+      override fun readValue(field: FieldRecord): HeapValue {
+        return reader.readValue(field.type)
       }
-      currentClassId = classRecord.superClassId
-    } while (currentClassId != 0L)
-    return null
+    }
   }
 
-  val InstanceDumpRecord.fields: List<Map<String, HeapValue>>
-    get() {
-      val allFields = mutableListOf<Map<String, HeapValue>>()
-      val buffer = Buffer()
-      buffer.write(fieldValues)
-      val valuesReader = HprofReader(buffer, 0, parser.idSize)
-
-      var currentClassId = classId
-
-      do {
-
-        val classFields = mutableMapOf<String, HeapValue>()
-        allFields += classFields
-
-        val classRecord = parser.retrieveRecordById(currentClassId) as ClassDumpRecord
-
-        for (fieldRecord in classRecord.fields) {
-          val fieldValue = valuesReader.readValue(fieldRecord.type)
-          classFields[parser.hprofStringById(fieldRecord.nameStringId)] = fieldValue
-        }
-        currentClassId = classRecord.superClassId
-      } while (currentClassId != 0L)
-      return allFields
-    }
+  fun isJavaString(record: InstanceDumpRecord): Boolean {
+    return parser.objectIdMetadata(record.id) == STRING
+  }
 
-  infix fun ObjectRecord?.directInstanceOf(className: String): Boolean {
-    return this is InstanceDumpRecord && parser.className(classId) == className
+  fun referencesJavaString(reference: ObjectReference): Boolean {
+    return !reference.isNull && parser.objectIdMetadata(reference.value) == STRING
   }
 
+  fun referencesClass(reference: ObjectReference): Boolean {
+    return !reference.isNull && parser.objectIdMetadata(reference.value) == CLASS
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
index f6a02ffa..002326a6 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -32,6 +32,7 @@ import leakcanary.Record.HeapDumpRecord.GcRootRecord
 import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
@@ -705,10 +706,6 @@ class HprofParser private constructor(
     return metadata
   }
 
-  fun retrieveRecord(reference: ObjectReference): ObjectRecord {
-    return retrieveRecordById(reference.value)
-  }
-
   fun retrieveRecordById(objectId: Long): ObjectRecord {
     val objectRecordOrNull = objectCache[objectId]
     if (objectRecordOrNull != null) {
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
index a0317e8d..d91fecaf 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ b/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
@@ -47,7 +47,7 @@ internal object InternalLeakSentry {
   val refWatcher = RefWatcher(
       clock = clock,
       checkRetainedExecutor = checkRetainedExecutor,
-      onReferenceRetained = { listener.onReferenceRetained() },
+      onInstanceRetained = { listener.onReferenceRetained() },
       isEnabled = { LeakSentry.config.enabled }
   )
 
diff --git a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
index 5dbc8632..4709d4bb 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
+++ b/leakcanary-watcher/src/main/java/leakcanary/RefWatcher.kt
@@ -26,7 +26,7 @@ import java.util.concurrent.Executor
 class RefWatcher constructor(
   private val clock: Clock,
   private val checkRetainedExecutor: Executor,
-  private val onReferenceRetained: () -> Unit,
+  private val onInstanceRetained: () -> Unit,
   /**
    * Calls to [watch] will be ignored when [isEnabled] returns false
    */
@@ -36,7 +36,7 @@ class RefWatcher constructor(
   /**
    * References passed to [watch].
    */
-  private val watchedReferences = mutableMapOf<String, KeyedWeakReference>()
+  private val watchedInstances = mutableMapOf<String, KeyedWeakReference>()
 
   private val queue = ReferenceQueue<Any>()
 
@@ -44,26 +44,26 @@ class RefWatcher constructor(
    * Returns true if there are watched instances that aren't weakly reachable, and
    * have been watched for long enough to be considered retained.
    */
-  val hasRetainedReferences: Boolean
+  val hasRetainedInstances: Boolean
     @Synchronized get() {
-      removeWeaklyReachableReferences()
-      return watchedReferences.any { it.value.retainedUptimeMillis != -1L }
+      removeWeaklyReachableInstances()
+      return watchedInstances.any { it.value.retainedUptimeMillis != -1L }
     }
 
-  val retainedReferenceCount: Int
+  val retainedInstanceCount: Int
     @Synchronized get() {
-      removeWeaklyReachableReferences()
-      return watchedReferences.count { it.value.retainedUptimeMillis != -1L }
+      removeWeaklyReachableInstances()
+      return watchedInstances.count { it.value.retainedUptimeMillis != -1L }
     }
 
   /**
    * Returns true if there are watched instances that aren't weakly reachable, even
    * if they haven't been watched for long enough to be considered retained.
    */
-  val hasWatchedReferences: Boolean
+  val hasWatchedInstances: Boolean
     @Synchronized get() {
-      removeWeaklyReachableReferences()
-      return watchedReferences.isNotEmpty()
+      removeWeaklyReachableInstances()
+      return watchedInstances.isNotEmpty()
     }
 
   /**
@@ -73,11 +73,11 @@ class RefWatcher constructor(
    */
   val retainedInstances: List<Any>
     @Synchronized get() {
-      removeWeaklyReachableReferences()
+      removeWeaklyReachableInstances()
       val instances = mutableListOf<Any>()
-      for (reference in watchedReferences.values) {
-        if (reference.retainedUptimeMillis != -1L) {
-          val instance = reference.get()
+      for (weakReference in watchedInstances.values) {
+        if (weakReference.retainedUptimeMillis != -1L) {
+          val instance = weakReference.get()
           if (instance != null) {
             instances.add(instance)
           }
@@ -89,32 +89,32 @@ class RefWatcher constructor(
   /**
    * Identical to [.watch] with an empty string reference name.
    */
-  @Synchronized fun watch(watchedReference: Any) {
-    watch(watchedReference, "")
+  @Synchronized fun watch(watchedInstance: Any) {
+    watch(watchedInstance, "")
   }
 
   /**
-   * Watches the provided references.
+   * Watches the provided instances.
    *
-   * @param referenceName An logical identifier for the watched object.
+   * @param name A logical identifier for the watched object.
    */
   @Synchronized fun watch(
-    watchedReference: Any,
-    referenceName: String
+    watchedInstance: Any,
+    name: String
   ) {
     if (!isEnabled()) {
       return
     }
-    removeWeaklyReachableReferences()
+    removeWeaklyReachableInstances()
     val key = UUID.randomUUID()
         .toString()
     val watchUptimeMillis = clock.uptimeMillis()
     val reference =
-      KeyedWeakReference(watchedReference, key, referenceName, watchUptimeMillis, queue)
-    if (referenceName != "") {
+      KeyedWeakReference(watchedInstance, key, name, watchUptimeMillis, queue)
+    if (name != "") {
       CanaryLog.d(
           "Watching instance of %s named %s with key %s", reference.className,
-          referenceName, key
+          name, key
       )
     } else {
       CanaryLog.d(
@@ -122,40 +122,40 @@ class RefWatcher constructor(
       )
     }
 
-    watchedReferences[key] = reference
+    watchedInstances[key] = reference
     checkRetainedExecutor.execute {
       moveToRetained(key)
     }
   }
 
   @Synchronized private fun moveToRetained(key: String) {
-    removeWeaklyReachableReferences()
-    val retainedRef = watchedReferences[key]
+    removeWeaklyReachableInstances()
+    val retainedRef = watchedInstances[key]
     if (retainedRef != null) {
       retainedRef.retainedUptimeMillis = clock.uptimeMillis()
-      onReferenceRetained()
+      onInstanceRetained()
     }
   }
 
-  @Synchronized fun removeKeysRetainedBeforeHeapDump(heapDumpUptimeMillis: Long) {
+  @Synchronized fun removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis: Long) {
     val retainedBeforeHeapdump =
-      watchedReferences.filter { it.value.retainedUptimeMillis in 0..heapDumpUptimeMillis }
+      watchedInstances.filter { it.value.retainedUptimeMillis in 0..heapDumpUptimeMillis }
           .keys
-    watchedReferences.keys.removeAll(retainedBeforeHeapdump)
+    watchedInstances.keys.removeAll(retainedBeforeHeapdump)
   }
 
-  @Synchronized fun clearWatchedReferences() {
-    watchedReferences.clear()
+  @Synchronized fun clearWatchedInstances() {
+    watchedInstances.clear()
   }
 
-  private fun removeWeaklyReachableReferences() {
+  private fun removeWeaklyReachableInstances() {
     // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
     // reachable. This is before finalization or garbage collection has actually happened.
     var ref: KeyedWeakReference?
     do {
       ref = queue.poll() as KeyedWeakReference?
       if (ref != null) {
-        watchedReferences.remove(ref.key)
+        watchedInstances.remove(ref.key)
       }
     } while (ref != null)
   }
diff --git a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt b/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
index a7226e1c..2d76440b 100644
--- a/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
+++ b/leakcanary-watcher/src/test/java/leakcanary/RefWatcherTest.kt
@@ -27,13 +27,13 @@ class RefWatcherTest {
     refWatcher.watch(ref!!)
     ref = null
     runGc()
-    assertThat(refWatcher.hasRetainedReferences).isFalse()
+    assertThat(refWatcher.hasRetainedInstances).isFalse()
   }
 
   @Test fun `reachable object retained`() {
     refWatcher.watch(ref!!)
     runGc()
-    assertThat(refWatcher.hasRetainedReferences).isTrue()
+    assertThat(refWatcher.hasRetainedInstances).isTrue()
   }
 
 }
\ No newline at end of file
