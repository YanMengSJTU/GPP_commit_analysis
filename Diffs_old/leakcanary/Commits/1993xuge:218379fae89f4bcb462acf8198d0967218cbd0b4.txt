diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
index 67177ca3..7abe836b 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
@@ -40,7 +40,7 @@ public static void install(@NonNull Context context, @NonNull RefWatcher refWatc
         // 创建一个 ActivityRefWatcher对象
         ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
 
-        // 注册 Activity生命周期的Callback，
+        // 注册 监听Activity生命周期的Callback，
         // 在这个Callback中只关心所有Activity的Destory事件，因为 LeakCanary是在Activity被销毁时 才去watch
         application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);
     }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 66a1c53b..53669e5d 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -49,7 +49,6 @@ RefWatcher install(@NonNull Application application) {
                 // 在白名单里面的泄漏case，不会被记录，也不会通过DisplayLeakService通知给用户
                 // 如果我们发现有系统的内存泄漏，当前是无法解决的，就可以继承这个类，增加相应的白名单，避免开发时不必要的内存泄漏上报
                 .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
-
                 .buildAndInstall();
     }
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
index 7e38acc0..ed87b27a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/FragmentRefWatcher.java
@@ -49,6 +49,8 @@ public static void install(Context context, RefWatcher refWatcher) {
             }
 
             try {
+                // SupportFragmentRefWatcher 属于leakcanary-support-fragment中的类
+                // 如果未依赖 leakcanary-support-fragment 则找不到这个类
                 Class<?> fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);
                 Constructor<?> constructor =
                         fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index d83b7432..0787b460 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -199,6 +199,7 @@ private boolean gone(KeyedWeakReference reference) {
     }
 
     /**
+     *
      * 循环从引用队列中取出加入其中的虚引用KeyedWeakReference对象，将标识这个虚引用的key从retainedKeys中移除。
      * retainedKeys中剩下的就是 标识 未被垃圾回收的被检测对象的虚引用的key
      */
