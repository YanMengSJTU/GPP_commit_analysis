diff --git a/gradle.properties b/gradle.properties
index 838a4e84..432b2d16 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,16 +1,31 @@
-GROUP=com.squareup.leakcanary
+## Project-wide Gradle settings.
+#
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+#
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx1024m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+#
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
+#Fri May 11 20:59:58 CST 2018
+systemProp.http.proxyPort=8080
+POM_LICENCE_URL=http\://www.apache.org/licenses/LICENSE-2.0.txt
 VERSION_NAME=1.6-SNAPSHOT
-
-POM_DESCRIPTION=Leak Canary
-
-POM_URL=http://github.com/square/leakcanary/
-POM_SCM_URL=http://github.com/square/leakcanary/
-POM_SCM_CONNECTION=scm:git:https://github.com/square/leakcanary.git
-POM_SCM_DEV_CONNECTION=scm:git:git@github.com:square/leakcanary.git
-
-POM_LICENCE_NAME=The Apache Software License, Version 2.0
-POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
-POM_LICENCE_DIST=repo
-
 POM_DEVELOPER_ID=square
-POM_DEVELOPER_NAME=Square, Inc.
\ No newline at end of file
+POM_SCM_DEV_CONNECTION=scm\:git\:git@github.com\:square/leakcanary.git
+POM_SCM_URL=http\://github.com/square/leakcanary/
+systemProp.https.proxyHost=dev-proxy.oa.com
+GROUP=com.squareup.leakcanary
+POM_LICENCE_DIST=repo
+POM_DEVELOPER_NAME=Square, Inc.
+systemProp.http.proxyHost=dev-proxy.oa.com
+systemProp.https.proxyPort=8080
+POM_URL=http\://github.com/square/leakcanary/
+POM_SCM_CONNECTION=scm\:git\:https\://github.com/square/leakcanary.git
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_DESCRIPTION=Leak Canary
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index 0075abcd..f5c96da0 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -102,7 +102,7 @@ public HeapAnalyzer(ExcludedRefs excludedRefs) {
    * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
    * and then computes the shortest strong reference path from that instance to the GC roots.
    */
-  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
+  public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) { // referenceKey是生成的uuid
     long analysisStartNanoTime = System.nanoTime();
 
     if (!heapDumpFile.exists()) {
@@ -113,6 +113,7 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
     try {
       HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
       HprofParser parser = new HprofParser(buffer);
+      // Snapshot类似Jsoup的Document，方便的解析hprof
       Snapshot snapshot = parser.parse();
       deduplicateGcRoots(snapshot);
 
@@ -136,8 +137,14 @@ void deduplicateGcRoots(Snapshot snapshot) {
     // THashMap has a smaller memory footprint than HashMap.
     final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
 
+    // 获取GCRoots，GCRoots存在于SnapShot里面的default heap
     final Collection<RootObj> gcRoots = snapshot.getGCRoots();
+    // 遍历GCRoot，针对每个GCRoot生成特有的key值，类似于native static@0x82763689
+    // 将GCRoot添加到map中，达到去重的目的
+    // RootObj的name和id一样就是同一个对象
     for (RootObj root : gcRoots) {
+      // 遍历每个GCRoot，生成一个key
+      // 类似： native static@0x82763689
       String key = generateRootKey(root);
       if (!uniqueRootMap.containsKey(key)) {
         uniqueRootMap.put(key, root);
@@ -145,7 +152,7 @@ void deduplicateGcRoots(Snapshot snapshot) {
     }
 
     // Repopulate snapshot with unique GC roots.
-    gcRoots.clear();
+    gcRoots.clear(); // 清空从snapShot中拿到的gcRoots，并重新赋值，此后这个gcRoot中的root对象是唯一的
     uniqueRootMap.forEach(new TObjectProcedure<String>() {
       @Override public boolean execute(String key) {
         return gcRoots.add(uniqueRootMap.get(key));
@@ -154,10 +161,16 @@ void deduplicateGcRoots(Snapshot snapshot) {
   }
 
   private String generateRootKey(RootObj root) {
+    /**
+     * {@link com.squareup.haha.perflib.RootType}
+      */
+    //
     return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
   }
 
   private Instance findLeakingReference(String key, Snapshot snapshot) {
+    // 找到KeyedWeakReference类型的对象
+    // 类似的 也可以找到android.graphic.Bitmap等其他对象
     ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
     List<String> keysFound = new ArrayList<>();
     for (Instance instance : refClass.getInstancesList()) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index d03dad94..43fae168 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -50,9 +50,11 @@ public HeapAnalyzerService() {
       CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
       return;
     }
-    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
+
+    String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);// DisplayLeakService
     HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);
 
+    // HeapAnalyzer用于分析为我们监控的这个对象
     HeapAnalyzer heapAnalyzer = new HeapAnalyzer(heapDump.excludedRefs);
 
     AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 8a01a472..e2aa5381 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -108,6 +108,7 @@ private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakRefer
       // The debugger can create false leaks.
       return RETRY;
     }
+    // 移除虚引用对象后，判断要监控的这个引用是否已经不在了，即当前要监控的这个引用其实处于虚引用队列中
     if (gone(reference)) {
       return DONE;
     }
@@ -117,12 +118,15 @@ private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakRefer
       long startDumpHeap = System.nanoTime();
       long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
 
+      // 这个对象还存在,dump hprof文件
       File heapDumpFile = heapDumper.dumpHeap();
       if (heapDumpFile == RETRY_LATER) {
         // Could not dump the heap.
         return RETRY;
       }
       long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
+      // 让外层来实现具体的分析：在hprof文件中分析这个无法释放的对象
+      // excludedRefs表示排除这类引用，这个可以在AndroidExcludedRefs中配置
       heapdumpListener.analyze(
           new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
               gcDurationMs, heapDumpDurationMs));
@@ -138,6 +142,8 @@ private void removeWeaklyReachableReferences() {
     // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
     // reachable. This is before finalization or garbage collection has actually happened.
     KeyedWeakReference ref;
+    // 虚引用对象在这个对象处于虚不可达的时候，这个虚引用会被加入到虚引用队列中
+    // 即，处于虚引用队列中的对象都会被随时回收掉，这部分引用不用考虑
     while ((ref = (KeyedWeakReference) queue.poll()) != null) {
       retainedKeys.remove(ref.key);
     }
