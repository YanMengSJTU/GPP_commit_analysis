diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 00000000..d15ea400
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/leakcanary"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  ./gradlew clean uploadArchives
+  echo "Snapshot deployed!"
+fi
diff --git a/.travis.yml b/.travis.yml
index e4452455..ad327f32 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,16 +2,25 @@ language: android
 
 android:
   components:
-    - build-tools-21.1.2
-    - android-21
-  licenses:
-    - android-sdk-license-5be876d5
+    - tools
+    - platform-tools
+    - build-tools-23.0.2
+    - android-23
 
 jdk:
   - oraclejdk7
+  - oraclejdk8
 
 script:
-  - ./gradlew clean build check
+  - ./gradlew clean build
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "aWyY/jCiG/D7hHAprj0rG3xYafxRYjZM5oNqqbDfjUHvqPp7kS3SOhUd3SJMVuSR4kA5TuZQqMXHr10Jz05gcyowQE2XEnKmu1WkfNWz2TCNerF27O0TkuIgYyZxcOb1M4aMxDJPZgySLmsXQ+iuAly+RSFP/CcSP4WPU9YNsGCQZ1C8KfscCWxKR5n1GoOEboOIxE5BL11F4tYjINX45FcIdBJu5XKJhCqUUvjdwxrZ0BykSYpvgpZ0WwAcXUBHHoqcYnNYAhBi60G00OE2Ml1x5lXiC+5Kwpsi0mXoWMyDT7MIIqB+Fk6XzxEzE7+z2nYmssXpvfHDJe+N+osCxvgWL97dMwx6BLv0S2jaoNgtcBB/DpzJAGeQ3yFulK5npr7RpeKpFN60rj8vYaRK9EfAvTfiHOjA/gkfSLBYOk/hOmE6o363nAKqUss+5FMS9c2vgIatbJiYHWScqlMRPxS3IjLp9Y84jB8JN/T8Mexxsw07OmEtaAU5+di/Nv2ok1MIx25NA0XYsMKXReCkicYoXQcSBIj5fTUI6bD09OLS4hs1EacX0hIfF89TJKs6azu0VLJHWKoW2Uo+qqgVMQPXRkNAzCcrJGeUWep8O/DsoNlT40NZCXP5wJN/aWFK0Rrl5n1zM8VVWBPk/0CAS0VUDZZSnqGXo2vZV6+bYEk="
+    - secure: "gdFVL5AOp5DhnaC2vJ5EYglenG3vOcJuMLQrnQsKzt+p2jb9jdu8Lbx3kr8UdKOXOPPQVwg1U8BILe8RPmkaURYgZLE9nPthEcEVfULRPbj7EDHxOQ0/3uWRbkq+GyxDtX4+tdnDQhEijW+hSIQdWHgUAwvvvxrKLVS37lYaj55VVtITljgsd07YYKMrFNFfH/tgDJdZClaiuXdLfrWzVEZKGHBJfyzGOjLmUSbZzXL/ut32mIqbVsxeDvXXxlBluS68UkG3wI5/gp1jAxBIc+NK+CoZMMb5ww6V1P+iZhA176YXm8WDiUHpEx6cH//rtnIJ+1IywBCG+S60JeVpUEu8N9NK/eVd2en5OSef9xqBYfCYHRKvI/S/DiR9CCbim7rnlVgHMrY580Nv/bnJ5E9Q/sQSD9pzKp0P452qU36FXJ+c519inc1+F5fEUApft0UzAVQFT9sY7qGV0d6x6D3BDyXGE4KMYWx4ydkSSCAI2bsvl/8dLUybU1kKBDivY71VU/bGtJ33LobySiSJA/03vTKHEsBuMowu13pnj7c5tp7QFFv3lRO1XXqT4NS39SySDQUT7UbZofsqHTyqMpiL72q1rII6af+XNskmILuwU/oRwR8+IN9LBE9Nz0uL3zOzv8uhzTZT2rUGEhDm+B51UMvK0ZEJDlpvA9Y2GTQ="
 
 notifications:
   email: false
@@ -20,4 +29,4 @@ sudo: false
 
 cache:
   directories:
-    - $HOME/.gradle
\ No newline at end of file
+    - $HOME/.gradle
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 463778ef..064b12c7 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,23 +1,14 @@
 # Change Log
 
+You can watch releases [on Bintray](https://bintray.com/pyricau/maven/com.squareup.leakcanary%3Aleakcanary-android/view?source=watch).
+
 ## Version 1.4-SNAPSHOT
 
-* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This should fix most crashes and improve speed a lot. We can now parse Android M heap dumps, although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
-* A status bar notification is displayed when the trace analysis results in an excluded ref leak [#216](https://github.com/square/leakcanary/pull/216).
-* Added ProGuard configuration for debug library [#132](https://github.com/square/leakcanary/issues/132).
-* 2 new ignored Android SDK leaks: [#26](https://github.com/square/leakcanary/issues/26) [#62](https://github.com/square/leakcanary/issues/62). 1 Android SDK leak updated: [#133](https://github.com/square/leakcanary/issues/133).
-* Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
-* Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
-* Renamed all resources to begin with `leak_canary_` instead of `__leak_canary`[#161](https://github.com/square/leakcanary/pull/161)
-* No crash when heap dump fails [#226](https://github.com/square/leakcanary/issues/226).
+Nothing yet.
 
 ### Public API changes
 
-* AnalysisResult.failure is now a `Throwable` instead of an `Exception`. Main goal is to catch and correctly report OOMs while parsing.
-* Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries.
-* Renamed `ExcludedRefs` fields.
-* Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
-* Added support for ignoring all fields (static and non static) for a given class.
+Nothing yet.
 
 ### Dependencies
 
@@ -41,6 +32,40 @@ Snapshots are available in Sonatype's `snapshots` repository:
 
 [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
 
+
+## Version 1.4-beta1 *(2016-01-08)*
+
+All actual changes are [tracked here](https://github.com/square/leakcanary/pulls?utf8=%E2%9C%93&q=milestone%3A1.4+is%3Apr).
+
+* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This fixes crashes and improves speed a lot.
+* We can now parse Android M heap dumps [#267](https://github.com/square/leakcanary/issues/267), although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
+* Excluded leaks are now reported as well and available in the display leak activity.
+* Added ProGuard configuration for [#132](https://github.com/square/leakcanary/issues/132).
+* Many new ignored Android SDK leaks.
+* Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
+* Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
+* Added CanaryLog API to replace the logger: [#201](https://github.com/square/leakcanary/issues/201).
+* Renamed all resources to begin with `leak_canary_` instead of `__leak_canary`[#161](https://github.com/square/leakcanary/pull/161)
+* No crash when heap dump fails [#226](https://github.com/square/leakcanary/issues/226).
+* Add retained size to leak reports [#162](https://github.com/square/leakcanary/issues/162).
+
+### Public API changes
+
+* AnalysisResult.failure is now a `Throwable` instead of an `Exception`. Main goal is to catch and correctly report OOMs while parsing.
+* Added ARRAY_ENTRY to LeakTraceElement.Type for references through array entries.
+* Renamed `ExcludedRefs` fields.
+* Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
+* Added support for ignoring all fields (static and non static) for a given class.
+
+### Dependencies
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-beta1'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta1'
+ }
+```
+
 ## Version 1.3.1 *(2015-05-16)*
 
 * Heap dumps and analysis results are now saved on the sd card: [#21](https://github.com/square/leakcanary/issues/21).
diff --git a/README.md b/README.md
index e5be50c6..bdd4a7f7 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-#LeakCanary
+# LeakCanary
 
 A memory leak detection library for Android and Java.
 
@@ -12,8 +12,9 @@ In your `build.gradle`:
 
 ```gradle
  dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1' // or 1.4-beta1
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1' // or 1.4-beta1
+   testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1' // or 1.4-beta1
  }
 ```
 
@@ -124,7 +125,7 @@ If you find a new one, please [create an issue](https://github.com/square/leakca
 5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
 6. Create a PR in LeakCanary to update `AndroidExcludedRefs.java`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
 
-This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which benefits the entire Android community. 
+This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which benefits the entire Android community.
 
 ## Beyond the leak trace
 
@@ -215,6 +216,21 @@ res/
 </resources>
 ```
 
+### Watcher delay
+
+*Available in 1.4-SNAPSHOT*.
+
+You can change the delay until a reference is considered a memory leak by providing `R.integer.leak_canary_watch_delay_millis` in your app:
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <integer name="leak_canary_watch_delay_millis">1500</integer>
+</resources>
+```
+
+The default delay is 5 seconds.
+
 ### Uploading to a server
 
 You can change the default behavior to upload the leak trace and heap dump to a server of your choosing.
@@ -235,6 +251,7 @@ public class LeakUploadService extends DisplayLeakService {
 Build a custom `RefWatcher` in your debug Application class:
 
 ```java
+// ExampleApplication is defined in "Customizing and using the no-op dependency"
 public class DebugExampleApplication extends ExampleApplication {
   protected RefWatcher installLeakCanary() {
     return LeakCanary.install(app, LeakUploadService.class, AndroidExcludedRefs.createAppDefaults().build());
@@ -262,6 +279,7 @@ You can also upload the leak traces to Slack or HipChat, [here's an example](htt
 You can create your own version of `ExcludedRefs` to ignore specific references that you know are causing leaks but you still want to ignore:
 
 ```java
+// ExampleApplication is defined in "Customizing and using the no-op dependency"
 public class DebugExampleApplication extends ExampleApplication {
   protected RefWatcher installLeakCanary() {
     ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
@@ -277,15 +295,16 @@ public class DebugExampleApplication extends ExampleApplication {
 `ActivityRefWatcher` is installed by default and watches all activities. You can customize the installation steps to use something different instead:
 
 ```java
+// ExampleApplication is defined in "Customizing and using the no-op dependency"
 public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    if (isInAnalyzerProcess(this)) {
+  @Override protected RefWatcher installLeakCanary() {
+    if (LeakCanary.isInAnalyzerProcess(this)) {
       return RefWatcher.DISABLED;
     } else {
       ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults().build();
-      enableDisplayLeakActivity(application);
-      ServiceHeapDumpListener heapDumpListener = new ServiceHeapDumpListener(application, DisplayLeakService.class);
-      final RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
+      LeakCanary.enableDisplayLeakActivity(this);
+      ServiceHeapDumpListener heapDumpListener = new ServiceHeapDumpListener(this, DisplayLeakService.class);
+      final RefWatcher refWatcher = LeakCanary.androidWatcher(this, heapDumpListener, excludedRefs);
       registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
         public void onActivityDestroyed(Activity activity) {
           if (activity instanceof ThirdPartyActivity) {
@@ -301,16 +320,6 @@ public class DebugExampleApplication extends ExampleApplication {
 }
 ```
 
-### ProGuard
-
-If you use Proguard in your debug builds, make sure to keep the HAHA and LeakCanary classes:
-
-```
-# LeakCanary
--keep class org.eclipse.mat.** { *; }
--keep class com.squareup.leakcanary.** { *; }
-```
-
 ## Snapshots of the development version
 
 See the [CHANGELOG](https://github.com/square/leakcanary/blob/master/CHANGELOG.md).
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
index 5dfdcf84..f15c7586 100644
Binary files a/assets/icon_1024.png and b/assets/icon_1024.png differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
index bb24dbad..0ca6bedf 100644
Binary files a/assets/icon_512.png and b/assets/icon_512.png differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
index f68053b6..8faa278f 100644
Binary files a/assets/screenshot.png and b/assets/screenshot.png differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
index 827e5552..d04aace6 100644
Binary files a/assets/source_icon.png and b/assets/source_icon.png differ
diff --git a/build.gradle b/build.gradle
index 6f0281ca..b0568c40 100644
--- a/build.gradle
+++ b/build.gradle
@@ -13,16 +13,16 @@ subprojects {
       mavenCentral()
     }
     dependencies {
-      classpath 'com.android.tools.build:gradle:1.2.3'
+      classpath 'com.android.tools.build:gradle:1.5.0'
     }
   }
 }
 
 ext {
   minSdkVersion = 8
-  compileSdkVersion = 21
+  compileSdkVersion = 23
   targetSdkVersion = compileSdkVersion
-  buildToolsVersion = '21.1.2'
+  buildToolsVersion = '23.0.2'
   javaVersion = JavaVersion.VERSION_1_7
 
   GROUP = 'com.squareup.leakcanary'
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 01938b95..32763c86 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -16,11 +16,11 @@ def getSnapshotRepositoryUrl() {
 }
 
 def getRepositoryUsername() {
-    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
+    return hasProperty('SONATYPE_NEXUS_USERNAME') ? SONATYPE_NEXUS_USERNAME : ""
 }
 
 def getRepositoryPassword() {
-    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
+    return hasProperty('SONATYPE_NEXUS_PASSWORD') ? SONATYPE_NEXUS_PASSWORD : ""
 }
 
 afterEvaluate { project ->
@@ -93,6 +93,14 @@ afterEvaluate { project ->
         from android.sourceSets.main.java.sourceFiles
     }
 
+    if (JavaVersion.current().isJava8Compatible()) {
+        allprojects {
+            tasks.withType(Javadoc) {
+                options.addStringOption('Xdoclint:none', '-quiet')
+            }
+        }
+    }
+
     artifacts {
         archives androidSourcesJar
         archives androidJavadocsJar
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 80081ab8..63b80488 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,4 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index c12cab76..84c46338 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -38,7 +38,7 @@ task copyTestResources(type: Copy) {
 }
 
 afterEvaluate { project ->
-  testDebug.dependsOn copyTestResources
+  testDebugUnitTest.dependsOn copyTestResources
 }
 
 android {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
index 8376943a..4c8270c1 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
@@ -20,16 +20,17 @@
 public final class AnalysisResult implements Serializable {
 
   public static AnalysisResult noLeak(long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, null, analysisDurationMs);
+    return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
   }
 
   public static AnalysisResult leakDetected(boolean excludedLeak, String className,
-      LeakTrace leakTrace, long analysisDurationMs) {
-    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, analysisDurationMs);
+      LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
+    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, retainedHeapSize,
+        analysisDurationMs);
   }
 
   public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, failure, analysisDurationMs);
+    return new AnalysisResult(false, false, null, null, failure, 0, analysisDurationMs);
   }
 
   /** True if a leak was found in the heap dump. */
@@ -56,16 +57,23 @@ public static AnalysisResult failure(Throwable failure, long analysisDurationMs)
   /** Null unless the analysis failed. */
   public final Throwable failure;
 
+  /**
+   * The number of bytes which would be freed if all references to the leaking object were
+   * released. 0 if {@link #leakFound} is false.
+   */
+  public final long retainedHeapSize;
+
   /** Total time spent analyzing the heap. */
   public final long analysisDurationMs;
 
   private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
-      LeakTrace leakTrace, Throwable failure, long analysisDurationMs) {
+      LeakTrace leakTrace, Throwable failure, long retainedHeapSize, long analysisDurationMs) {
     this.leakFound = leakFound;
     this.excludedLeak = excludedLeak;
     this.className = className;
     this.leakTrace = leakTrace;
     this.failure = failure;
+    this.retainedHeapSize = retainedHeapSize;
     this.analysisDurationMs = analysisDurationMs;
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
index d281056b..fbbf8ba0 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
@@ -78,12 +78,22 @@ static String asString(Object stringObject) {
     ArrayInstance charArray;
     if (isCharArray(value)) {
       charArray = (ArrayInstance) value;
-      offset = fieldValue(values, "offset");
+      offset = 0;
+      // < API 23
+      // As of Marshmallow, substrings no longer share their parent strings' char arrays
+      // eliminating the need for String.offset
+      // https://android-review.googlesource.com/#/c/83611/
+      if (hasField(values, "offset")) {
+        offset = fieldValue(values, "offset");
+      }
     } else {
-      // In M preview 2+, the underlying char buffer resides in the heap with ID equalling the
+      // In M preview 2, the underlying char buffer resides in the heap with ID equaling the
       // String's ID + 16.
       // https://android-review.googlesource.com/#/c/160380/2/android/src/com/android/tools/idea/
       // editors/hprof/descriptors/InstanceFieldDescriptorImpl.java
+      // This workaround is only needed for M preview 2, as it has been fixed on the hprof
+      // generation end by reintroducing a virtual "value" variable.
+      // https://android.googlesource.com/platform/art/+/master/runtime/hprof/hprof.cc#1242
       Heap heap = instance.getHeap();
       Instance inlineInstance = heap.getInstance(instance.getId() + 16);
       if (isCharArray(inlineInstance)) {
@@ -143,6 +153,16 @@ private static boolean isCharArray(Object value) {
     throw new IllegalArgumentException("Field " + fieldName + " does not exists");
   }
 
+  static boolean hasField(List<ClassInstance.FieldValue> values, String fieldName) {
+    for (ClassInstance.FieldValue fieldValue : values) {
+      if (fieldValue.getField().getName().equals(fieldName)) {
+        //noinspection unchecked
+        return true;
+      }
+    }
+    return false;
+  }
+
   private HahaHelper() {
     throw new AssertionError();
   }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index c688bc2c..eb2082f9 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -22,6 +22,7 @@
 import com.squareup.haha.perflib.HprofParser;
 import com.squareup.haha.perflib.Instance;
 import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.RootType;
 import com.squareup.haha.perflib.Snapshot;
 import com.squareup.haha.perflib.Type;
 import com.squareup.haha.perflib.io.HprofBuffer;
@@ -119,14 +120,77 @@ private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapsh
 
     String className = leakingRef.getClassObj().getClassName();
 
-    return leakDetected(result.excludingKnownLeaks, className, leakTrace,
+    // Side effect: computes retained size.
+    snapshot.computeDominators();
+
+    Instance leakingInstance = result.leakingNode.instance;
+
+    long retainedSize = leakingInstance.getTotalRetainedSize();
+
+    retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+
+    return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
         since(analysisStartNanoTime));
   }
 
+  /**
+   * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
+   * in the retained size because their root dominator is a native gc root.
+   * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
+   * add the bitmap size.
+   *
+   * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
+   * accounted for, however bitmaps set in layouts are not.
+   */
+  private int computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
+    int bitmapRetainedSize = 0;
+    ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
+
+    for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
+      if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
+        ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
+        // Native bitmaps have mBuffer set to null. We sadly can't account for them.
+        if (mBufferInstance == null) {
+          continue;
+        }
+        long bufferSize = mBufferInstance.getTotalRetainedSize();
+        long bitmapSize = bitmapInstance.getTotalRetainedSize();
+        // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
+        // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
+        if (bitmapSize < bufferSize) {
+          bitmapSize += bufferSize;
+        }
+        bitmapRetainedSize += bitmapSize;
+      }
+    }
+    return bitmapRetainedSize;
+  }
+
+  private boolean isIgnoredDominator(Instance dominator, Instance instance) {
+    boolean foundNativeRoot = false;
+    while (true) {
+      Instance immediateDominator = instance.getImmediateDominator();
+      if (immediateDominator instanceof RootObj
+          && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
+        // Ignore native roots
+        instance = instance.getNextInstanceToGcRoot();
+        foundNativeRoot = true;
+      } else {
+        instance = immediateDominator;
+      }
+      if (instance == null) {
+        return false;
+      }
+      if (instance == dominator) {
+        return foundNativeRoot;
+      }
+    }
+  }
+
   private LeakTrace buildLeakTrace(LeakNode leakingNode) {
     List<LeakTraceElement> elements = new ArrayList<>();
     // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, leakingNode, null, null);
+    LeakNode node = new LeakNode(null, null, leakingNode, null, null);
     while (node != null) {
       LeakTraceElement element = buildLeakElement(node);
       if (element != null) {
@@ -192,25 +256,31 @@ private LeakTraceElement buildLeakElement(LeakNode node) {
         String parentClassName = classObj.getSuperClassObj().getClassName();
         if (Object.class.getName().equals(parentClassName)) {
           holderType = OBJECT;
-          // This is an anonymous class implementing an interface. The API does not give access
-          // to the interfaces implemented by the class. Let's see if it's in the class path and
-          // use that instead.
           try {
+            // This is an anonymous class implementing an interface. The API does not give access
+            // to the interfaces implemented by the class. We check if it's in the class path and
+            // use that instead.
             Class<?> actualClass = Class.forName(classObj.getClassName());
-            Class<?> implementedInterface = actualClass.getInterfaces()[0];
-            extra = "(anonymous class implements " + implementedInterface.getName() + ")";
+            Class<?>[] interfaces = actualClass.getInterfaces();
+            if (interfaces.length > 0) {
+              Class<?> implementedInterface = interfaces[0];
+              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
+            } else {
+              extra = "(anonymous subclass of java.lang.Object)";
+            }
           } catch (ClassNotFoundException ignored) {
           }
         } else {
           holderType = OBJECT;
           // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous class extends " + parentClassName + ")";
+          extra = "(anonymous subclass of " + parentClassName + ")";
         }
       } else {
         holderType = OBJECT;
       }
     }
-    return new LeakTraceElement(referenceName, type, holderType, className, extra, fields);
+    return new LeakTraceElement(referenceName, type, holderType, className, extra, node.exclusion,
+        fields);
   }
 
   private long since(long analysisStartNanoTime) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
index 69ec8717..b30df278 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
@@ -18,13 +18,16 @@
 import com.squareup.haha.perflib.Instance;
 
 final class LeakNode {
+  /** May be null. */
+  final Exclusion exclusion;
   final Instance instance;
   final LeakNode parent;
   final String referenceName;
   final LeakTraceElement.Type referenceType;
 
-  LeakNode(Instance instance, LeakNode parent, String referenceName,
-      LeakTraceElement.Type referenceType) {
+  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent,
+      String referenceName, LeakTraceElement.Type referenceType) {
+    this.exclusion = exclusion;
     this.instance = instance;
     this.parent = parent;
     this.referenceName = referenceName;
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
index 02f85f64..89ef31e3 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -48,16 +48,20 @@
   /** Additional information, may be null. */
   public final String extra;
 
+  /** If not null, there was no path that could exclude this element. */
+  public final Exclusion exclusion;
+
   /** List of all fields (member and static) for that object. */
   public final List<String> fields;
 
   LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
-      List<String> fields) {
+      Exclusion exclusion, List<String> fields) {
     this.referenceName = referenceName;
     this.type = type;
     this.holder = holder;
     this.className = className;
     this.extra = extra;
+    this.exclusion = exclusion;
     this.fields = unmodifiableList(new ArrayList<>(fields));
   }
 
@@ -83,6 +87,11 @@
     if (extra != null) {
       string += " " + extra;
     }
+
+    if (exclusion != null) {
+      string += " , matching exclusion " + exclusion.matching;
+    }
+
     return string;
   }
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
index 134c5e41..db6100ef 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
@@ -89,6 +89,9 @@ Result findPath(Snapshot snapshot, Instance leakingRef) {
         node = toVisitQueue.poll();
       } else {
         node = toVisitIfNoPathQueue.poll();
+        if (node.exclusion == null) {
+          throw new IllegalStateException("Expected node to have an exclusion " + node);
+        }
         excludingKnownLeaks = true;
       }
 
@@ -131,9 +134,9 @@ private void enqueueGcRoots(Snapshot snapshot) {
         case JAVA_LOCAL:
           Instance thread = HahaSpy.allocatingThread(rootObj);
           String threadName = threadName(thread);
-          Boolean alwaysIgnore = excludedRefs.threadNames.get(threadName);
-          if (alwaysIgnore == null || !alwaysIgnore) {
-            enqueue(alwaysIgnore == null, null, rootObj, null, null);
+          Exclusion params = excludedRefs.threadNames.get(threadName);
+          if (params == null || !params.alwaysExclude) {
+            enqueue(params, null, rootObj, null, null);
           }
           break;
         case INTERNED_STRING:
@@ -160,7 +163,7 @@ private void enqueueGcRoots(Snapshot snapshot) {
           // Input or output parameters in native code.
         case NATIVE_STACK:
         case JAVA_STATIC:
-          enqueue(true, null, rootObj, null, null);
+          enqueue(null, null, rootObj, null, null);
           break;
         default:
           throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
@@ -176,20 +179,48 @@ private void visitRootObj(LeakNode node) {
     RootObj rootObj = (RootObj) node.instance;
     Instance child = rootObj.getReferredInstance();
 
+    Exclusion exclusion = rootSuperClassAlwaysIgnored(child);
+
+    if (exclusion != null && exclusion.alwaysExclude) {
+      return;
+    }
+
     if (rootObj.getRootType() == RootType.JAVA_LOCAL) {
       Instance holder = HahaSpy.allocatingThread(rootObj);
       // We switch the parent node with the thread instance that holds
       // the local reference.
-      LeakNode parent = new LeakNode(holder, null, null, null);
-      enqueue(true, parent, child, "<Java Local>", LOCAL);
+      LeakNode parent = new LeakNode(null, holder, null, null, null);
+      if (node.exclusion != null) {
+        exclusion = node.exclusion;
+      }
+      enqueue(exclusion, parent, child, "<Java Local>", LOCAL);
     } else {
-      enqueue(true, node, child, null, null);
+      enqueue(exclusion, node, child, null, null);
+    }
+  }
+
+  private Exclusion rootSuperClassAlwaysIgnored(Instance child) {
+    if (child == null) {
+      return null;
+    }
+    Exclusion matchingParams = null;
+    ClassObj superClassObj = child.getClassObj();
+    while (superClassObj != null) {
+      Exclusion params = excludedRefs.rootClassNames.get(superClassObj.getClassName());
+      if (params != null) {
+        // true overrides null or false.
+        if (matchingParams == null || !matchingParams.alwaysExclude) {
+          matchingParams = params;
+        }
+      }
+      superClassObj = superClassObj.getSuperClassObj();
     }
+    return matchingParams;
   }
 
   private void visitClassObj(LeakNode node) {
     ClassObj classObj = (ClassObj) node.instance;
-    Map<String, Boolean> ignoredStaticFields =
+    Map<String, Exclusion> ignoredStaticFields =
         excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());
     for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
       Field field = entry.getKey();
@@ -203,72 +234,60 @@ private void visitClassObj(LeakNode node) {
       Instance child = (Instance) entry.getValue();
       boolean visit = true;
       if (ignoredStaticFields != null) {
-        Boolean alwaysIgnore = ignoredStaticFields.get(fieldName);
-        if (alwaysIgnore != null) {
+        Exclusion params = ignoredStaticFields.get(fieldName);
+        if (params != null) {
           visit = false;
-          if (!alwaysIgnore) {
-            enqueue(false, node, child, fieldName, STATIC_FIELD);
+          if (!params.alwaysExclude) {
+            enqueue(params, node, child, fieldName, STATIC_FIELD);
           }
         }
       }
       if (visit) {
-        enqueue(true, node, child, fieldName, STATIC_FIELD);
+        enqueue(null, node, child, fieldName, STATIC_FIELD);
       }
     }
   }
 
   private void visitClassInstance(LeakNode node) {
     ClassInstance classInstance = (ClassInstance) node.instance;
-    Map<String, Boolean> ignoredFields = null;
+    Map<String, Exclusion> ignoredFields = new LinkedHashMap<>();
     ClassObj superClassObj = classInstance.getClassObj();
-    Boolean alwaysIgnoreClassHierarchy = null;
+    Exclusion classExclusion = null;
     while (superClassObj != null) {
-      Boolean alwaysIgnoreClass = excludedRefs.classNames.get(superClassObj.getClassName());
-      if (alwaysIgnoreClass != null) {
+      Exclusion params = excludedRefs.classNames.get(superClassObj.getClassName());
+      if (params != null) {
         // true overrides null or false.
-        if (alwaysIgnoreClassHierarchy == null || !alwaysIgnoreClassHierarchy) {
-          alwaysIgnoreClassHierarchy = alwaysIgnoreClass;
+        if (classExclusion == null || !classExclusion.alwaysExclude) {
+          classExclusion = params;
         }
       }
-      Map<String, Boolean> classIgnoredFields =
+      Map<String, Exclusion> classIgnoredFields =
           excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());
       if (classIgnoredFields != null) {
-        if (ignoredFields == null) {
-          ignoredFields = new LinkedHashMap<>();
-        }
         ignoredFields.putAll(classIgnoredFields);
       }
       superClassObj = superClassObj.getSuperClassObj();
     }
 
-    if (alwaysIgnoreClassHierarchy != null && alwaysIgnoreClassHierarchy) {
+    if (classExclusion != null && classExclusion.alwaysExclude) {
       return;
     }
 
     for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
+      Exclusion fieldExclusion = classExclusion;
       Field field = fieldValue.getField();
       if (field.getType() != Type.OBJECT) {
         continue;
       }
       Instance child = (Instance) fieldValue.getValue();
-      boolean visit = true;
-      boolean visitIfNoPath = false;
-      // We don't even get here if alwaysIgnoreClassHierarchy is false.
-      if (alwaysIgnoreClassHierarchy != null) {
-        visit = false;
-        visitIfNoPath = true;
-      }
       String fieldName = field.getName();
-      if (ignoredFields != null) {
-        Boolean alwaysIgnore = ignoredFields.get(fieldName);
-        if (alwaysIgnore != null) {
-          visit = false;
-          visitIfNoPath = !alwaysIgnore;
-        }
-      }
-      if (visit || visitIfNoPath) {
-        enqueue(visit, node, child, fieldName, INSTANCE_FIELD);
+      Exclusion params = ignoredFields.get(fieldName);
+      // If we found a field exclusion and it's stronger than a class exclusion
+      if (params != null && (fieldExclusion == null || (params.alwaysExclude
+          && !fieldExclusion.alwaysExclude))) {
+        fieldExclusion = params;
       }
+      enqueue(fieldExclusion, node, child, fieldName, INSTANCE_FIELD);
     }
   }
 
@@ -279,12 +298,12 @@ private void visitArrayInstance(LeakNode node) {
       Object[] values = arrayInstance.getValues();
       for (int i = 0; i < values.length; i++) {
         Instance child = (Instance) values[i];
-        enqueue(true, node, child, "[" + i + "]", ARRAY_ENTRY);
+        enqueue(null, node, child, "[" + i + "]", ARRAY_ENTRY);
       }
     }
   }
 
-  private void enqueue(boolean visitNow, LeakNode parent, Instance child, String referenceName,
+  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child, String referenceName,
       LeakTraceElement.Type referenceType) {
     if (child == null) {
       return;
@@ -296,6 +315,7 @@ private void enqueue(boolean visitNow, LeakNode parent, Instance child, String r
     if (toVisitSet.contains(child)) {
       return;
     }
+    boolean visitNow = exclusion == null;
     if (!visitNow && toVisitIfNoPathSet.contains(child)) {
       return;
     }
@@ -305,7 +325,7 @@ private void enqueue(boolean visitNow, LeakNode parent, Instance child, String r
     if (visitedSet.contains(child)) {
       return;
     }
-    LeakNode childNode = new LeakNode(child, parent, referenceName, referenceType);
+    LeakNode childNode = new LeakNode(exclusion, child, parent, referenceName, referenceType);
     if (visitNow) {
       toVisitSet.add(child);
       toVisitQueue.add(childNode);
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
index 0d427886..ad43d493 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
@@ -15,11 +15,9 @@
  */
 package com.squareup.leakcanary;
 
-import java.io.File;
 import java.lang.ref.WeakReference;
-import java.net.URL;
-import java.util.Arrays;
 import java.util.Collection;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,6 +25,11 @@
 
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.analyze;
+import static java.util.Arrays.asList;
 import static org.hamcrest.core.StringContains.containsString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -42,35 +45,29 @@
   static final String EXECUTOR_FIELD_2 = "sDefaultExecutor";
 
   @Parameterized.Parameters public static Collection<Object[]> data() {
-    return Arrays.asList(new Object[][] {
-        { fileFromName("leak_asynctask.hprof"), "dc983a12-d029-4003-8890-7dd644c664c5" },
-        { fileFromName("leak_asynctask_mpreview2.hprof"), "1114018e-e154-435f-9a3d-da63ae9b47fa" },
+    return asList(new Object[][] {
+        { ASYNC_TASK }, //
+        { ASYNC_TASK_MPREVIEW2 }, //
+        { ASYNC_TASK_M_POSTPREVIEW2 } //
     });
   }
 
-  private static File fileFromName(String filename) {
-    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-    URL url = classLoader.getResource(filename);
-    return new File(url.getPath());
-  }
-
-  final File heapDumpFile;
-  final String referenceKey;
+  private final TestUtil.HeapDumpFile heapDumpFile;
+  ExcludedRefs.BuilderWithParams excludedRefs;
 
-  ExcludedRefs.Builder excludedRefs;
-
-  public AsyncTaskLeakTest(File heapDumpFile, String referenceKey) {
+  public AsyncTaskLeakTest(TestUtil.HeapDumpFile heapDumpFile) {
     this.heapDumpFile = heapDumpFile;
-    this.referenceKey = referenceKey;
   }
 
   @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.Builder().clazz(WeakReference.class.getName(), true)
-        .clazz("java.lang.ref.FinalizerReference", true);
+    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude();
   }
 
   @Test public void leakFound() {
-    AnalysisResult result = analyze();
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
     assertTrue(result.leakFound);
     assertFalse(result.excludedLeak);
     LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
@@ -81,7 +78,7 @@ public AsyncTaskLeakTest(File heapDumpFile, String referenceKey) {
 
   @Test public void excludeThread() {
     excludedRefs.thread(ASYNC_TASK_THREAD);
-    AnalysisResult result = analyze();
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
     assertTrue(result.leakFound);
     assertFalse(result.excludedLeak);
     LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
@@ -92,25 +89,17 @@ public AsyncTaskLeakTest(File heapDumpFile, String referenceKey) {
   }
 
   @Test public void excludeStatic() {
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2);
-    AnalysisResult result = analyze();
+    excludedRefs.thread(ASYNC_TASK_THREAD).named(ASYNC_TASK_THREAD);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1).named(EXECUTOR_FIELD_1);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2).named(EXECUTOR_FIELD_2);
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
     assertTrue(result.leakFound);
     assertTrue(result.excludedLeak);
-  }
+    LeakTrace leakTrace = result.leakTrace;
+    List<LeakTraceElement> elements = leakTrace.elements;
+    Exclusion exclusion = elements.get(0).exclusion;
 
-  private AnalysisResult analyze() {
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
-    AnalysisResult result = heapAnalyzer.checkForLeak(heapDumpFile, referenceKey);
-    if (result.failure != null) {
-      result.failure.printStackTrace();
-    }
-    if (result.leakTrace != null) {
-      System.out.println(result.leakTrace);
-    }
-    return result;
+    List<String> expectedExclusions = asList(ASYNC_TASK_THREAD, EXECUTOR_FIELD_1, EXECUTOR_FIELD_2);
+    assertTrue(expectedExclusions.contains(exclusion.name));
   }
-
-
 }
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
new file mode 100644
index 00000000..ba62c2ad
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
@@ -0,0 +1,101 @@
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.io.HprofBuffer;
+
+import java.io.UnsupportedEncodingException;
+import java.util.List;
+
+public final class FakeHprofBuffer implements HprofBuffer {
+  private List<Byte> byteList;
+  private List<byte[]> byteArrayList;
+
+  private int[] intsToRead;
+  private int intIndex = -1;
+  private String[] stringsToRead;
+  private int stringIndex = -1;
+
+  public void setIntsToRead(int... ints) {
+    intsToRead = ints;
+    intIndex = 0;
+  }
+
+  public void setStringsToRead(String... strings) {
+    stringsToRead = strings;
+    stringIndex = 0;
+  }
+
+  @Override
+  public byte readByte() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void read(byte[] bytes) {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void readSubSequence(byte[] bytes, int start, int length) {
+    if (stringsToRead == null || stringIndex < 0 || stringIndex >= stringsToRead.length) {
+      throw new UnsupportedOperationException("no bytes to read");
+    }
+
+    String s = stringsToRead[stringIndex++];
+    try {
+      System.arraycopy(s.getBytes("UTF-16BE"), start, bytes, 0, length);
+    } catch (UnsupportedEncodingException e) {
+      throw new UnsupportedOperationException(e);
+    }
+  }
+
+  @Override
+  public char readChar() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public short readShort() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public int readInt() {
+    if (intsToRead == null || intIndex < 0 || intIndex >= intsToRead.length) {
+      throw new UnsupportedOperationException("no bytes to read");
+    }
+    return intsToRead[intIndex++];
+  }
+
+  @Override
+  public long readLong() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public float readFloat() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public double readDouble() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void setPosition(long l) {}
+
+  @Override
+  public long position() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public boolean hasRemaining() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public long remaining() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
new file mode 100644
index 00000000..03178cbe
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
@@ -0,0 +1,146 @@
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.Snapshot;
+import com.squareup.haha.perflib.Type;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class HahaHelperTest {
+  private static final int STRING_CLASS_ID = 100;
+  private static final int CHAR_ARRAY_CLASS_ID = 101;
+  private static final int STRING_INSTANCE_ID = 102;
+  private static final int VALUE_ARRAY_INSTANCE_ID = 103;
+
+  private static final int VALUE_ARRAY_LENGTH = 6;
+  private static final int COUNT_VALUE = 5;
+  private static final int OFFSET_VALUE = 1;
+
+  private FakeHprofBuffer buffer;
+  private Snapshot snapshot;
+
+  @Before
+  public void setUp() {
+    buffer = new FakeHprofBuffer();
+
+    snapshot = new Snapshot(buffer);
+    // set HPROF identifier size; required for Object instance field lookups
+    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
+    snapshot.setIdSize(4);
+  }
+
+  @Test
+  public void readStringOffsetFromHeapDumpInstance() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.INT, "offset"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createCharArrayValueInstance();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("bcdef"));
+  }
+
+  @Test
+  public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue() {
+    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createCharArrayValueInstance();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("abcde"));
+  }
+
+  @Test
+  public void defaultToZeroStringOffsetWhenReadingMPreview2HeapDump() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.INT, "offset"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createCharArrayValueInstance_M_Preview2();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("abcde"));
+  }
+
+  @Test
+  public void throwExceptionWhenMissingCharArrayValueForStringInMPreview2HeapDump() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.INT, "offset"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createObjectValueInstance_M_Preview2();
+
+    try {
+      HahaHelper.asString(stringInstance);
+      fail("this test should have thrown UnsupportedOperationException");
+    }
+    catch (UnsupportedOperationException uoe) {
+      String message = uoe.getMessage();
+      assertTrue(message.equals("Could not find char array in " + stringInstance));
+    }
+  }
+
+  private void addStringClassToSnapshotWithFields(Snapshot snapshot, Field[] fields) {
+    ClassObj charArrayClass = new ClassObj(0, null, "char[]", 0);
+    snapshot.addClass(CHAR_ARRAY_CLASS_ID, charArrayClass);
+
+    ClassObj stringClass = new ClassObj(0, null, "string", 0);
+    stringClass.setFields(fields);
+    snapshot.addClass(STRING_CLASS_ID, stringClass);
+  }
+
+  private void createCharArrayValueInstance() {
+    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
+  }
+
+  private void createCharArrayValueInstance_M_Preview2() {
+    ArrayInstance valueInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
+    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
+  }
+
+  private void createObjectValueInstance_M_Preview2() {
+    ClassInstance valueInstance = new ClassInstance(0, null, 0);
+    snapshot.addInstance(STRING_INSTANCE_ID + 16, valueInstance);
+  }
+
+  private ClassInstance createStringInstance() {
+    ClassInstance stringInstance = new ClassInstance(STRING_INSTANCE_ID, null, 100);
+    stringInstance.setClassId(STRING_CLASS_ID);
+    snapshot.addInstance(0, stringInstance);
+    return stringInstance;
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
new file mode 100644
index 00000000..a414687d
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
@@ -0,0 +1,55 @@
+package com.squareup.leakcanary;
+
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
+import java.util.Collection;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_MPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M_POSTPREVIEW2;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
+import static com.squareup.leakcanary.TestUtil.analyze;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * This test makes sure there is no regression on the retained size calculation.
+ */
+@RunWith(Parameterized.class) //
+public class RetainedSizeTest {
+
+  @Parameterized.Parameters public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        { ASYNC_TASK, 207_407 }, //
+        { ASYNC_TASK_MPREVIEW2, 1_604 }, //
+        { ASYNC_TASK_M_POSTPREVIEW2, 1_870 }, //
+        { SERVICE_BINDER, 378 }, //
+        { SERVICE_BINDER_IGNORED, 378 }, //
+    });
+  }
+
+  private final TestUtil.HeapDumpFile heapDumpFile;
+  private final long expectedRetainedHeapSize;
+  ExcludedRefs.BuilderWithParams excludedRefs;
+
+  public RetainedSizeTest(TestUtil.HeapDumpFile heapDumpFile, long expectedRetainedHeapSize) {
+    this.heapDumpFile = heapDumpFile;
+    this.expectedRetainedHeapSize = expectedRetainedHeapSize;
+  }
+
+  @Before public void setUp() {
+    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude();
+  }
+
+  @Test public void leakFound() {
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
+    assertEquals(expectedRetainedHeapSize, result.retainedHeapSize);
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
new file mode 100644
index 00000000..a54feeb1
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/ServiceBinderLeakTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.lang.ref.WeakReference;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
+import static com.squareup.leakcanary.LeakTraceElement.Holder.OBJECT;
+import static com.squareup.leakcanary.LeakTraceElement.Type.INSTANCE_FIELD;
+import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.SERVICE_BINDER_IGNORED;
+import static com.squareup.leakcanary.TestUtil.analyze;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * leak_service_binder_ignored.hprof contains a "normal" leak when binding to a service, where
+ * leak_service_binder.hprof contains a leak where a binder is leaked by a static field.
+ */
+public class ServiceBinderLeakTest {
+
+  ExcludedRefs.BuilderWithParams excludedRefs;
+
+  @Before public void setUp() {
+    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude();
+  }
+
+  @Test public void realBinderLeak() {
+    excludedRefs.rootClass("android.os.Binder").alwaysExclude();
+
+    AnalysisResult result = analyze(SERVICE_BINDER, excludedRefs);
+
+    assertTrue(result.leakFound);
+    assertFalse(result.excludedLeak);
+    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
+    assertEquals(STATIC_FIELD, gcRoot.type);
+    assertEquals("com.example.leakcanary.LeakyService", gcRoot.className);
+    assertEquals(CLASS, gcRoot.holder);
+  }
+
+  @Test public void ignorableBinderLeak() {
+    excludedRefs.rootClass("android.os.Binder");
+
+    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
+
+    assertTrue(result.leakFound);
+    assertTrue(result.excludedLeak);
+    LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
+    assertEquals(INSTANCE_FIELD, gcRoot.type);
+    assertEquals("com.example.leakcanary.LeakyService$MyBinder", gcRoot.className);
+    assertEquals(OBJECT, gcRoot.holder);
+  }
+
+  @Test public void alwaysIgnorableBinderLeak() {
+    excludedRefs.rootClass("android.os.Binder").alwaysExclude();
+
+    AnalysisResult result = analyze(SERVICE_BINDER_IGNORED, excludedRefs);
+
+    assertFalse(result.leakFound);
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
new file mode 100644
index 00000000..e3666e5d
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.File;
+import java.net.URL;
+
+final class TestUtil {
+
+  enum HeapDumpFile {
+    ASYNC_TASK("leak_asynctask.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"),
+    ASYNC_TASK_MPREVIEW2("leak_asynctask_mpreview2.hprof", "1114018e-e154-435f-9a3d-da63ae9b47fa"),
+    ASYNC_TASK_M_POSTPREVIEW2("leak_asynctask_m_postpreview2.hprof",
+        "25ae1778-7c1d-4ec7-ac50-5cce55424069"),
+
+    SERVICE_BINDER("leak_service_binder.hprof", "b3abfae6-2c53-42e1-b8c1-96b0558dbeae"),
+    SERVICE_BINDER_IGNORED("leak_service_binder_ignored.hprof",
+        "6e524414-9581-4ce7-8690-e8ddf8b82454"),;
+
+    private final String filename;
+    private final String referenceKey;
+
+    HeapDumpFile(String filename, String referenceKey) {
+      this.filename = filename;
+      this.referenceKey = referenceKey;
+    }
+
+  }
+
+  static File fileFromName(String filename) {
+    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+    URL url = classLoader.getResource(filename);
+    return new File(url.getPath());
+  }
+
+  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.BuilderWithParams excludedRefs) {
+    File file = fileFromName(heapDumpFile.filename);
+    String referenceKey = heapDumpFile.referenceKey;
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
+    AnalysisResult result = heapAnalyzer.checkForLeak(file, referenceKey);
+    if (result.failure != null) {
+      result.failure.printStackTrace();
+    }
+    if (result.leakTrace != null) {
+      System.out.println(result.leakTrace);
+    }
+    return result;
+  }
+
+  private TestUtil() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof
new file mode 100644
index 00000000..6945c82d
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_m_postpreview2.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof
new file mode 100644
index 00000000..af1dab18
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_service_binder.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof b/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof
new file mode 100644
index 00000000..cdb867c4
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_service_binder_ignored.hprof differ
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android/consumer-proguard-rules.pro
index 0a28de9b..48ffcc28 100644
--- a/leakcanary-android/consumer-proguard-rules.pro
+++ b/leakcanary-android/consumer-proguard-rules.pro
@@ -1,2 +1,9 @@
--keep class org.eclipse.mat.** { *; }
+-dontwarn com.squareup.haha.guava.**
+-dontwarn com.squareup.haha.perflib.**
+-dontwarn com.squareup.haha.trove.**
+-dontwarn com.squareup.leakcanary.**
+-keep class com.squareup.haha.** { *; }
 -keep class com.squareup.leakcanary.** { *; }
+
+# Marshmallow removed Notification.setLatestEventInfo()
+-dontwarn android.app.Notification
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index dc0ce58f..b5393171 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -20,6 +20,7 @@
     >
 
   <!-- To store the heap dumps and leak analysis results. -->
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 
   <application>
@@ -45,6 +46,14 @@
         <category android:name="android.intent.category.LAUNCHER"/>
       </intent-filter>
     </activity>
+    <activity
+        android:theme="@style/leak_canary_Theme.Transparent"
+        android:name=".internal.RequestStoragePermissionActivity"
+        android:taskAffinity="com.squareup.leakcanary"
+        android:enabled="false"
+        android:icon="@drawable/leak_canary_icon"
+        android:label="@string/leak_canary_storage_permission_activity_label"
+        />
 
   </application>
 </manifest>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index 605e86dc..236c7160 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -28,6 +28,7 @@
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static android.os.Build.VERSION_CODES.M;
 import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.LOLLIPOP_MR1;
@@ -51,229 +52,246 @@
 
   ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Android AOSP sometimes keeps a reference to a destroyed activity as a "nextIdle" client
-      // record in the android.app.ActivityThread.mActivities map.
-      // Not sure what's going on there, input welcome.
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle");
+      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
+          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
+              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+              + " Not sure what's going on there, input welcome.");
     }
   },
 
   SPAN_CONTROLLER(SDK_INT <= KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Editor inserts a special span, which has a reference to the EditText. That span is a
-      // NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder
-      // from a given CharSequence.
-      // TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle.
-      // Prior to KitKat, that copy was done using the SpannableString constructor, instead of
-      // SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans.
-      // So we end up with a saved state that holds a reference to the textview and therefore the
-      // entire view hierarchy & activity context.
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b
-
-      // Hack: to fix this, you could override TextView.onSaveInstanceState(), and then use
-      // reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0");
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0");
+      String reason =
+          "Editor inserts a special span, which has a reference to the EditText. That span is a"
+              + " NoCopySpan, which makes sure it gets dropped when creating a new"
+              + " SpannableStringBuilder from a given CharSequence."
+              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+              + " reference to the textview and therefore the entire view hierarchy & activity"
+              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
+      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
+          .reason(reason);
+      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
     }
   },
 
   MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // MediaSessionLegacyHelper is a static singleton that is lazily instantiated and keeps a
-      // reference to the context it's given the first time MediaSessionLegacyHelper.getHelper()
-      // is called.
-      // This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by calling
-      // context.getApplicationContext().
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
-
-      // Hack: to fix this, you could call MediaSessionLegacyHelper.getHelper() early in
-      // Application.onCreate() and pass it the application context.
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance");
+      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
+          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+              + " keeps a reference to the context it's given the first time"
+              + " MediaSessionLegacyHelper.getHelper() is called."
+              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+              + " calling context.getApplicationContext()."
+              + " Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+              + " in Application.onCreate() and pass it the application context.");
     }
   },
 
-  TEXT_LINE__SCACHED(SDK_INT < LOLLIPOP_MR1) {
+  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had at least two
-      // bugs that created memory leaks by not correctly clearing the recycled TextLine instances.
-      // The first was fixed in android-5.1.0_r1:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /893d6fe48d37f71e683f722457bea646994a10bf
-
-      // The second was fixed, not released yet:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
-
-      // Hack: to fix this, you could access TextLine.sCached and clear the pool every now and then
-      // (e.g. on activity destroy).
-      excluded.staticField("android.text.TextLine", "sCached");
+      excluded.staticField("android.text.TextLine", "sCached")
+          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+              + " at least two bugs that created memory leaks by not correctly clearing the"
+              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/893d6fe48d37f71e683f722457bea646994a10"
+              + " The second was fixed, not released yet:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+              + " To fix this, you could access TextLine.sCached and clear the pool every now"
+              + " and then (e.g. on activity destroy).");
     }
   },
 
   BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to ART, a thread waiting on a blocking queue will leak the last dequeued object
-      // as a stack local reference.
-      // So when a HandlerThread becomes idle, it keeps a local reference to the last message it
-      // received. That message then gets recycled and can be used again.
-      // As long as all messages are recycled after being used, this won't be a problem, because
-      // there references are cleared when being recycled.
-      // However, dialogs create template Message instances to be copied when a message needs to be
-      // sent. These Message templates holds references to the dialog listeners, which most likely
-      // leads to holding a reference onto the activity in some way. Dialogs never recycle their
-      // template Message, assuming these Message instances will get GCed when the dialog is GCed.
-      // The combination of these two things creates a high potential for memory leaks as soon
-      // as you use dialogs. These memory leaks might be temporary, but some handler threads sleep
-      // for a long time.
-
-      // Hack: to fix this, you could post empty messages to the idle handler threads from time to
-      // time. This won't be easy because you cannot access all handler threads, but a library
-      // that is widely used should consider doing this for its own handler threads.
-      excluded.instanceField("android.os.Message", "obj");
-      excluded.instanceField("android.os.Message", "next");
-      excluded.instanceField("android.os.Message", "target");
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
-    @Override void add(ExcludedRefs.Builder excluded) {
-      // When we detach a view that receives keyboard input, the InputMethodManager leaks a
-      // reference to it until a new view asks for keyboard input.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171190
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView");
+      String reason = "Prior to ART, a thread waiting on a blocking queue will leak the last"
+          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+          + " keeps a local reference to the last message it received. That message then gets"
+          + " recycled and can be used again. As long as all messages are recycled after being"
+          + "used, this won't be a problem, because these references are cleared when being"
+          + "recycled. However, dialogs create template Message instances to be copied when a"
+          + "message needs to be sent. These Message templates holds references to the dialog"
+          + "listeners, which most likely leads to holding a reference onto the activity in some"
+          + "way. Dialogs never recycle their template Message, assuming these Message instances"
+          + " will get GCed when the dialog is GCed."
+          + " The combination of these two things creates a high potential for memory leaks as soon"
+          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+          + " sleep for a long time."
+          + " To fix this, you could post empty messages to the idle handler threads from time to"
+          + " time. This won't be easy because you cannot access all handler threads, but a library"
+          + "that is widely used should consider doing this for its own handler threads.";
+      excluded.instanceField("android.os.Message", "obj").reason(reason);
+      excluded.instanceField("android.os.Message", "next").reason(reason);
+      excluded.instanceField("android.os.Message", "target").reason(reason);
+    }
+  },
+
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
+          + " leaks a reference to it until a new view asks for keyboard input."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
+          .reason(reason);
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
+          .reason(reason);
       excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection");
+          "mServedInputConnection").reason(reason);
     }
   },
 
   INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // The singleton InputMethodManager is holding a reference to mCurRootView long after the
-      // activity has been destroyed.
-      // Observed on ICS MR1: https://github.com/square/leakcanary/issues/1#issuecomment-100579429
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView");
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
+          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
+              + " after the activity has been destroyed."
+              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+              + "#issuecomment-100579429"
+              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
     }
   },
 
   LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // LayoutTransition leaks parent ViewGroup through ViewTreeObserver.OnPreDrawListener
-      // When triggered, this leaks stays until the window is destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171830
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent");
+      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
+          .reason("LayoutTransition leaks parent ViewGroup through"
+              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+              + " window is destroyed. Tracked here:"
+              + " https://code.google.com/p/android/issues/detail?id=171830");
     }
   },
 
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN || SDK_INT <= LOLLIPOP_MR1) {
+  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the
-      // SpellCheckerSession is closed before the service is connected.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=172542
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0");
+      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
+          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+              + " SpellCheckerSession is closed before the service is connected."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
     }
   },
 
   ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // ActivityChooserModel holds a static reference to the last set ActivityChooserModelPolicy
-      // which can be an activity context.
-      // Tracked here : https://code.google.com/p/android/issues/detail?id=172659
-      // Hack : https://gist.github.com/andaag/b05ab66ed0f06167d6e0
-      excluded.staticField("android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy");
-      excluded.staticField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy");
+      String reason = "ActivityChooserModel holds a static reference to the last set"
+          + " ActivityChooserModelPolicy which can be an activity context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
+      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy").reason(reason);
+      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
+          .reason(reason);
     }
   },
 
   SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner class and
-      // leaked the SpeechRecognizer which leaked an activity context.
-      // Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit
-      // /b37866db469e81aca534ff6186bdafd44352329b
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0");
+      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
+          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+              + " class and leaked the SpeechRecognizer which leaked an activity context."
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + " /b37866db469e81aca534ff6186bdafd44352329b");
     }
   },
 
   ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // AccountManager$AmsTask$Response is a stub and is held in memory by native code, probably
-      // because the reference to the response in the other process hasn't been cleared.
-      // AccountManager$AmsTask is holding on to the activity reference to use for launching a new
-      // sub- Activity.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173689
-      // Fix: Pass a null activity reference to the AccountManager methods and then deal with the
-      // returned future to to get the result and correctly start an activity when it's available.
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1");
+      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
+          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
+              + " probably because the reference to the response in the other process hasn't been"
+              + " cleared."
+              + " AccountManager$AmsTask is holding on to the activity reference to use for"
+              + " launching a new sub- Activity."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+              + " with the returned future to to get the result and correctly start an activity"
+              + " when it's available.");
     }
   },
 
   MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // The static method MediaScannerConnection.scanFile() takes an activity context but the
-      // service might not disconnect after the activity has been destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173788
-      // Fix: Create an instance of MediaScannerConnection yourself and pass in the application
-      // context. Call connect() and disconnect() manually.
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext");
+      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
+          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
+              + " but the service might not disconnect after the activity has been destroyed."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+              + " application context. Call connect() and disconnect() manually.");
     }
   },
 
   USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // UserManager has a static sInstance field that creates an instance and caches it the first
-      // time UserManager.get() is called. This instance is created with the outer context (which
-      // is an activity base context).
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173789
-      // Introduced by: https://github.com/android/platform_frameworks_base/commit
-      // /27db46850b708070452c0ce49daf5f79503fbde6
-      // Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the
-      // UserManager instance gets cached with a reference to the application context.
-      excluded.instanceField("android.os.UserManager", "mContext");
+      excluded.instanceField("android.os.UserManager", "mContext")
+          .reason("UserManager has a static sInstance field that creates an instance and caches it"
+              + " the first time UserManager.get() is called. This instance is created with the"
+              + " outer context (which is an activity base context)."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+              + "/27db46850b708070452c0ce49daf5f79503fbde6"
+              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+              + " UserManager instance gets cached with a reference to the application context.");
+    }
+  },
+
+  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
+          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
+              + " code. The reference to the `mContext` was not being cleared, which caused the"
+              + " Callbacks instance to retain this reference"
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
     }
   },
 
   DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
       if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        // DevicePolicyManager keeps a reference to the context it has been created with instead of
-        // extracting the application context. In this Motorola build, DevicePolicyManager has an
-        // inner SettingsObserver class that is a content observer, which is held into memory
-        // by a binder transport object.
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0");
+        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
+            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
+                + " instead of extracting the application context. In this Motorola build,"
+                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                + " observer, which is held into memory by a binder transport object.");
       }
     }
   },
 
   SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // SpenGestureManager has a static mContext field that leaks a reference to the activity.
-      // Yes, a STATIC "mContext" field.
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext");
+      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
+          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
+              + " activity. Yes, a STATIC mContext field.");
     }
   },
 
   CLIPBOARD_UI_MANAGER__SINSTANCE(
       SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // ClipboardUIManager is a static singleton that leaks an activity context.
-      // Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate(), so
-      // that the ClipboardUIManager instance gets cached with a reference to the
-      // application context. Example: https://gist.github.com/pepyakin/8d2221501fd572d4a61c
-      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext");
+      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
+          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
+              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+              + " application context. Example: https://gist.github.com/pepyakin"
+              + "/8d2221501fd572d4a61c");
     }
   },
 
   BUBBLE_POPUP_HELPER__SHELPER(
       LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // A static helper for EditText "bubble popups" leaks a reference to the latest focused view.
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper");
+      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
+          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
+              + "focused view.");
     }
   },
 
@@ -288,65 +306,92 @@
 
   MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Not sure exactly what ControllerMapper is about, but there is an anonymous Handler in
-      // ControllerMapper.MapperClient.ServiceClient, which leaks ControllerMapper.MapperClient
-      // which leaks the activity context.
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0");
+      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
+          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
+              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+              + " ControllerMapper.MapperClient which leaks the activity context.");
     }
   },
 
-  TEXT_VIEW__MLAST_HOVERED_VIEW(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+  TEXT_VIEW__MLAST_HOVERED_VIEW(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // mLastHoveredView is a static field in TextView that leaks the last hovered view.
-      excluded.staticField("android.widget.TextView", "mLastHoveredView");
+      excluded.staticField("android.widget.TextView", "mLastHoveredView")
+          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
+              + " view.");
     }
   },
 
   PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // android.app.LoadedApk.mResources has a reference to
-      // android.content.res.Resources.mPersonaManager which has a reference to
-      // android.os.PersonaManager.mContext which is an activity.
-      excluded.instanceField("android.os.PersonaManager", "mContext");
+      excluded.instanceField("android.os.PersonaManager", "mContext")
+          .reason("android.app.LoadedApk.mResources has a reference to"
+              + " android.content.res.Resources.mPersonaManager which has a reference to"
+              + " android.os.PersonaManager.mContext which is an activity.");
     }
   },
 
   RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // In AOSP the Resources class does not have a context.
-      // Here we have ZygoteInit.mResources (static field) holding on to a Resources instance that
-      // has a context that is the activity.
-      // Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184
-      excluded.instanceField("android.content.res.Resources", "mContext");
+      excluded.instanceField("android.content.res.Resources", "mContext")
+          .reason("In AOSP the Resources class does not have a context."
+              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+              + " instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
     }
   },
 
   VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // In AOSP the ViewConfiguration class does not have a context.
-      // Here we have ViewConfiguration.sConfigurations (static field) holding on to a
-      // ViewConfiguration instance that has a context that is the activity.
-      // Observed here: https://github.com/square/leakcanary/issues/1#issuecomment-100324683
-      excluded.instanceField("android.view.ViewConfiguration", "mContext");
+      excluded.instanceField("android.view.ViewConfiguration", "mContext")
+          .reason("In AOSP the ViewConfiguration class does not have a context."
+              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+              + " ViewConfiguration instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues"
+              + "/1#issuecomment-100324683");
     }
   },
 
   AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Samsung added a static mContext_static field to AudioManager, holds a reference to the
-      // activity.
-      // Observed here: https://github.com/square/leakcanary/issues/32
-      excluded.staticField("android.media.AudioManager", "mContext_static");
+      excluded.staticField("android.media.AudioManager", "mContext_static")
+          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/32");
+    }
+  },
+
+  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.media.AudioManager$1", "this$0")
+          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
+              + " never abandoned it, which leaks the Activity context through the AudioManager."
+              + " The root of the problem is that AudioManager uses whichever"
+              + " context it receives, which in the case of the VideoView example is an Activity,"
+              + " even though it only needs the application's context. The issue is fixed in"
+              + " Android M, and the AudioManager now uses the application's context."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
+    }
+  },
+
+  SERVICE_BINDER {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      // We should ignore leaks where an android.os.Binder is the root of the leak.
+      // When you bind and unbind from a Service, the OS will keep a reference to the Binder
+      // until the client binder has been GC'ed. This means the Binder can be retained after
+      // Service.onDestroy() is called.
+      excluded.rootClass("android.os.Binder").alwaysExclude();
     }
   },
 
   SOFT_REFERENCES {
     @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.clazz(WeakReference.class.getName(), true);
-      excluded.clazz(SoftReference.class.getName(), true);
-      excluded.clazz(PhantomReference.class.getName(), true);
-      excluded.clazz("java.lang.ref.Finalizer", true);
-      excluded.clazz("java.lang.ref.FinalizerReference", true);
+      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
+      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
+      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
+      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
+      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
     }
   },
 
@@ -354,7 +399,7 @@
     @Override void add(ExcludedRefs.Builder excluded) {
       // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
       // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon", true);
+      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
     }
   },
 
@@ -363,13 +408,13 @@
       // The main thread stack is ever changing so local variables aren't likely to hold references
       // for long. If this is on the shortest path, it's probably that there's a longer path with
       // a real leak.
-      excluded.thread("main", true);
+      excluded.thread("main").alwaysExclude();
     }
   },
 
   LEAK_CANARY_THREAD {
     @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(LEAK_CANARY_THREAD_NAME, true);
+      excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
     }
   },
 
@@ -380,7 +425,7 @@
       // The main thread message queue is held on by the main Looper, but that might be a longer
       // path. Let's not confuse people with a shorter path that is less meaningful.
       excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue", true);
+          "mMessageQueue").alwaysExclude();
     }
   };
 
@@ -388,8 +433,9 @@
    * This returns the references in the leak path that should be ignored by all on Android.
    */
   public static ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-        EVENT_RECEIVER__MMESSAGE_QUEUE));
+    return createBuilder(
+        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
+            EVENT_RECEIVER__MMESSAGE_QUEUE, SERVICE_BINDER));
   }
 
   /**
@@ -403,10 +449,11 @@
   }
 
   public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = new ExcludedRefs.Builder();
+    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
     for (AndroidExcludedRefs ref : refs) {
       if (ref.applies) {
         ref.add(excluded);
+        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
       }
     }
     return excluded;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
index 94335561..86a232f0 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -20,37 +20,50 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.MessageQueue;
-import android.util.Log;
 import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.widget.Toast;
 import com.squareup.leakcanary.internal.FutureResult;
 import com.squareup.leakcanary.internal.LeakCanaryInternals;
 import java.io.File;
+import java.io.IOException;
 
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.isExternalStorageWritable;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.storageDirectory;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 public final class AndroidHeapDumper implements HeapDumper {
 
-  private static final String TAG = "AndroidHeapDumper";
+  private static final String HEAPDUMP_FILE = "suspected_leak_heapdump.hprof";
 
-  private final Context context;
+  final Context context;
+  final LeakDirectoryProvider leakDirectoryProvider;
   private final Handler mainHandler;
 
-  public AndroidHeapDumper(Context context) {
+  public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
+    this.leakDirectoryProvider = leakDirectoryProvider;
     this.context = context.getApplicationContext();
     mainHandler = new Handler(Looper.getMainLooper());
   }
 
   @Override public File dumpHeap() {
-    if (!isExternalStorageWritable()) {
-      Log.d(TAG, "Could not dump heap, external storage not mounted.");
+    if (!leakDirectoryProvider.isLeakStorageWritable()) {
+      CanaryLog.d("Could not write to leak storage to dump heap.");
+      leakDirectoryProvider.requestWritePermission();
+      return NO_DUMP;
     }
     File heapDumpFile = getHeapDumpFile();
-    if (heapDumpFile.exists()) {
-      Log.d(TAG, "Could not dump heap, previous analysis still is in progress.");
+    // Atomic way to check for existence & create the file if it doesn't exist.
+    // Prevents several processes in the same app to attempt a heapdump at the same time.
+    boolean fileCreated;
+    try {
+      fileCreated = heapDumpFile.createNewFile();
+    } catch (IOException e) {
+      cleanup();
+      CanaryLog.d(e, "Could not check if heap dump file exists");
+      return NO_DUMP;
+    }
+
+    if (!fileCreated) {
+      CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
       // Heap analysis in progress, let's not put too much pressure on the device.
       return NO_DUMP;
     }
@@ -59,7 +72,7 @@ public AndroidHeapDumper(Context context) {
     showToast(waitingForToast);
 
     if (!waitingForToast.wait(5, SECONDS)) {
-      Log.d(TAG, "Did not dump heap, too much time waiting for Toast.");
+      CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
       return NO_DUMP;
     }
 
@@ -70,7 +83,7 @@ public AndroidHeapDumper(Context context) {
       return heapDumpFile;
     } catch (Exception e) {
       cleanup();
-      Log.e(TAG, "Could not perform heap dump", e);
+      CanaryLog.d(e, "Could not perform heap dump");
       // Abort heap dump
       return NO_DUMP;
     }
@@ -83,20 +96,24 @@ public AndroidHeapDumper(Context context) {
   public void cleanup() {
     LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
       @Override public void run() {
-        if (isExternalStorageWritable()) {
-          Log.d(TAG, "Could not attempt cleanup, external storage not mounted.");
+        if (!leakDirectoryProvider.isLeakStorageWritable()) {
+          CanaryLog.d("Could not attempt cleanup, leak storage not writable.");
+          return;
         }
         File heapDumpFile = getHeapDumpFile();
         if (heapDumpFile.exists()) {
-          Log.d(TAG, "Previous analysis did not complete correctly, cleaning: " + heapDumpFile);
-          heapDumpFile.delete();
+          CanaryLog.d("Previous analysis did not complete correctly, cleaning: %s", heapDumpFile);
+          boolean success = heapDumpFile.delete();
+          if (!success) {
+            CanaryLog.d("Could not delete file %s", heapDumpFile.getPath());
+          }
         }
       }
     });
   }
 
-  private File getHeapDumpFile() {
-    return new File(storageDirectory(), "suspected_leak_heapdump.hprof");
+  File getHeapDumpFile() {
+    return new File(leakDirectoryProvider.leakDirectory(), HEAPDUMP_FILE);
   }
 
   private void showToast(final FutureResult<Toast> waitingForToast) {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index d5d94293..8f8eff4b 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -23,22 +23,22 @@
 
 /**
  * {@link Executor} suitable for watching Android reference leaks. This executor waits for the main
- * thread to be idle then posts to a serial background thread with a delay of {@link
- * #DELAY_MILLIS} milliseconds.
+ * thread to be idle then posts to a serial background thread with a delay of
+ * {@link R.integer#leak_canary_watch_delay_millis} seconds.
  */
 public final class AndroidWatchExecutor implements Executor {
 
   static final String LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump";
-  private static final int DELAY_MILLIS = 5000;
-
   private final Handler mainHandler;
-  private final Handler backgroundHandler;
+  final Handler backgroundHandler;
+  final long delayMillis;
 
-  public AndroidWatchExecutor() {
+  public AndroidWatchExecutor(int delayMillis) {
     mainHandler = new Handler(Looper.getMainLooper());
     HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
     handlerThread.start();
     backgroundHandler = new Handler(handlerThread.getLooper());
+    this.delayMillis = delayMillis;
   }
 
   @Override public void execute(final Runnable command) {
@@ -57,11 +57,11 @@ private boolean isOnMainThread() {
     return Looper.getMainLooper().getThread() == Thread.currentThread();
   }
 
-  private void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
+  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
     // This needs to be called from the main thread.
     Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
       @Override public boolean queueIdle() {
-        backgroundHandler.postDelayed(runnable, DELAY_MILLIS);
+        backgroundHandler.postDelayed(runnable, delayMillis);
         return false;
       }
     });
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
new file mode 100644
index 00000000..b4e288db
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
@@ -0,0 +1,60 @@
+package com.squareup.leakcanary;
+
+import android.util.Log;
+
+public final class CanaryLog {
+
+  private static volatile Logger logger = new DefaultLogger();
+
+  public interface Logger {
+    void d(String message, Object... args);
+
+    void d(Throwable throwable, String message, Object... args);
+  }
+
+  private static class DefaultLogger implements Logger {
+    DefaultLogger() { }
+
+    @Override public void d(String message, Object... args) {
+      String formatted = String.format(message, args);
+      if (formatted.length() < 4000) {
+        Log.d("LeakCanary", formatted);
+      } else {
+        String[] lines = formatted.split("\n");
+        for (String line : lines) {
+          Log.d("LeakCanary", line);
+        }
+      }
+    }
+
+    @Override public void d(Throwable throwable, String message, Object... args) {
+      d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
+    }
+  }
+
+  public static void setLogger(Logger logger) {
+    CanaryLog.logger = logger;
+  }
+
+  public static void d(String message, Object... args) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    Logger logger = CanaryLog.logger;
+    if (logger == null) {
+      return;
+    }
+    logger.d(message, args);
+  }
+
+  public static void d(Throwable throwable, String message, Object... args) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    Logger logger = CanaryLog.logger;
+    if (logger == null) {
+      return;
+    }
+    logger.d(throwable, message, args);
+  }
+
+  private CanaryLog() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
new file mode 100644
index 00000000..988906e3
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.annotation.TargetApi;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.os.Environment;
+import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
+import java.io.File;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.M;
+import static android.os.Environment.DIRECTORY_DOWNLOADS;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
+
+public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
+
+  private final Context context;
+
+  public DefaultLeakDirectoryProvider(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  @Override public File leakDirectory() {
+    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
+    File directory = new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
+    boolean success = directory.mkdirs();
+    if (!success && !directory.exists()) {
+      throw new UnsupportedOperationException(
+          "Could not create leak directory " + directory.getPath());
+    }
+    return directory;
+  }
+
+  @Override public void requestWritePermission() {
+    if (hasStoragePermission()) {
+      return;
+    }
+    PendingIntent pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context);
+    String contentTitle = context.getString(R.string.leak_canary_permission_notification_title);
+    CharSequence packageName = context.getPackageName();
+    String contentText =
+        context.getString(R.string.leak_canary_permission_notification_text, packageName);
+    showNotification(context, contentTitle, contentText, pendingIntent);
+  }
+
+  @Override public boolean isLeakStorageWritable() {
+    if (!hasStoragePermission()) {
+      return false;
+    }
+    String state = Environment.getExternalStorageState();
+    return Environment.MEDIA_MOUNTED.equals(state);
+  }
+
+  @TargetApi(M) private boolean hasStoragePermission() {
+    if (SDK_INT < M) {
+      return true;
+    }
+    return context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index 479b09e0..afdc4e94 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -15,25 +15,24 @@
  */
 package com.squareup.leakcanary;
 
-import android.annotation.TargetApi;
-import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
-import android.content.Context;
-import android.util.Log;
+import android.content.res.Resources;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import java.io.File;
 import java.io.FileOutputStream;
+import java.io.FilenameFilter;
 import java.io.IOException;
 import java.io.ObjectOutputStream;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.Locale;
 
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.HONEYCOMB;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
+import static android.text.format.Formatter.formatShortFileSize;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.findNextAvailableHprofFile;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
 
 /**
  * Logs leak analysis results, and then shows a notification which will start {@link
@@ -44,54 +43,61 @@
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
-  @Override
-  protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
+  @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
     String leakInfo = leakInfo(this, heapDump, result, true);
-    if (leakInfo.length() < 4000) {
-      Log.d("LeakCanary", leakInfo);
-    } else {
-      String[] lines = leakInfo.split("\n");
-      for (String line : lines) {
-        Log.d("LeakCanary", line);
-      }
-    }
+    CanaryLog.d(leakInfo);
 
-    if (result.failure == null && (!result.leakFound || result.excludedLeak)) {
-      if (result.excludedLeak) {
-        PendingIntent pendingIntent = DisplayLeakActivity.createPendingIntent(this);
-        String contentTitle =
-            getString(R.string.leak_canary_class_leak_ignored, classSimpleName(result.className));
-        String contentText = getString(R.string.leak_canary_notification_leak_ignored_message);
-        notify(contentTitle, contentText, pendingIntent);
-      }
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
+    boolean resultSaved = false;
+    boolean shouldSaveResult = result.leakFound || result.failure != null;
+    if (shouldSaveResult) {
+      heapDump = renameHeapdump(heapDump);
+      resultSaved = saveResult(heapDump, result);
     }
 
-    int maxStoredLeaks = getResources().getInteger(R.integer.leak_canary_max_stored_leaks);
-    File renamedFile = findNextAvailableHprofFile(maxStoredLeaks);
+    PendingIntent pendingIntent;
+    String contentTitle;
+    String contentText;
 
-    if (renamedFile == null) {
-      // No file available.
-      Log.e("LeakCanary",
-          "Leak result dropped because we already store " + maxStoredLeaks + " leak traces.");
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
-    }
+    if (!shouldSaveResult) {
+      contentTitle = getString(R.string.leak_canary_no_leak_title);
+      contentText = getString(R.string.leak_canary_no_leak_text);
+      pendingIntent = null;
+    } else if (resultSaved) {
+      pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
-    heapDump = heapDump.renameFile(renamedFile);
+      if (result.failure == null) {
+        String size = formatShortFileSize(this, result.retainedHeapSize);
+        String className = classSimpleName(result.className);
+        if (result.excludedLeak) {
+          contentTitle = getString(R.string.leak_canary_leak_excluded, className, size);
+        } else {
+          contentTitle = getString(R.string.leak_canary_class_has_leaked, className, size);
+        }
+      } else {
+        contentTitle = getString(R.string.leak_canary_analysis_failed);
+      }
+      contentText = getString(R.string.leak_canary_notification_message);
+    } else {
+      contentTitle = getString(R.string.leak_canary_could_not_save_title);
+      contentText = getString(R.string.leak_canary_could_not_save_text);
+      pendingIntent = null;
+    }
+    showNotification(this, contentTitle, contentText, pendingIntent);
+    afterDefaultHandling(heapDump, result, leakInfo);
+  }
 
-    File resultFile = leakResultFile(renamedFile);
+  private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
+    File resultFile = new File(heapDump.heapDumpFile.getParentFile(),
+        heapDump.heapDumpFile.getName() + ".result");
     FileOutputStream fos = null;
     try {
       fos = new FileOutputStream(resultFile);
       ObjectOutputStream oos = new ObjectOutputStream(fos);
       oos.writeObject(heapDump);
       oos.writeObject(result);
+      return true;
     } catch (IOException e) {
-      Log.e("LeakCanary", "Could not save leak analysis result to disk", e);
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
+      CanaryLog.d(e, "Could not save leak analysis result to disk.");
     } finally {
       if (fos != null) {
         try {
@@ -100,51 +106,45 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
         }
       }
     }
+    return false;
+  }
 
-    PendingIntent pendingIntent =
-        DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
+  private HeapDump renameHeapdump(HeapDump heapDump) {
+    String fileName =
+        new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
 
-    String contentTitle;
-    if (result.failure == null) {
-      contentTitle =
-          getString(R.string.leak_canary_class_has_leaked, classSimpleName(result.className));
-    } else {
-      contentTitle = getString(R.string.leak_canary_analysis_failed);
+    File newFile = new File(heapDump.heapDumpFile.getParent(), fileName);
+    boolean renamed = heapDump.heapDumpFile.renameTo(newFile);
+    if (!renamed) {
+      CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
+          newFile.getPath());
     }
-    String contentText = getString(R.string.leak_canary_notification_message);
+    heapDump =
+        new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName, heapDump.excludedRefs,
+            heapDump.watchDurationMs, heapDump.gcDurationMs, heapDump.heapDumpDurationMs);
 
-    notify(contentTitle, contentText, pendingIntent);
-    afterDefaultHandling(heapDump, result, leakInfo);
-  }
-
-  @TargetApi(HONEYCOMB)
-  private void notify(String contentTitle, String contentText,
-      PendingIntent pendingIntent) {
-    NotificationManager notificationManager =
-        (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+    Resources resources = getResources();
+    int maxStoredHeapDumps =
+        Math.max(resources.getInteger(R.integer.leak_canary_max_stored_leaks), 1);
+    File[] hprofFiles = heapDump.heapDumpFile.getParentFile().listFiles(new FilenameFilter() {
+      @Override public boolean accept(File dir, String filename) {
+        return filename.endsWith(".hprof");
+      }
+    });
 
-    Notification notification;
-    if (SDK_INT < HONEYCOMB) {
-      notification = new Notification();
-      notification.icon = R.drawable.leak_canary_notification;
-      notification.when = System.currentTimeMillis();
-      notification.flags |= Notification.FLAG_AUTO_CANCEL;
-      notification.setLatestEventInfo(this, contentTitle, contentText, pendingIntent);
-    } else {
-      Notification.Builder builder = new Notification.Builder(this) //
-          .setSmallIcon(R.drawable.leak_canary_notification)
-          .setWhen(System.currentTimeMillis())
-          .setContentTitle(contentTitle)
-          .setContentText(contentText)
-          .setAutoCancel(true)
-          .setContentIntent(pendingIntent);
-      if (SDK_INT < JELLY_BEAN) {
-        notification = builder.getNotification();
-      } else {
-        notification = builder.build();
+    if (hprofFiles.length > maxStoredHeapDumps) {
+      // Sort with oldest modified first.
+      Arrays.sort(hprofFiles, new Comparator<File>() {
+        @Override public int compare(File lhs, File rhs) {
+          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
+        }
+      });
+      boolean deleted = hprofFiles[0].delete();
+      if (!deleted) {
+        CanaryLog.d("Could not delete old hprof file %s", hprofFiles[0].getPath());
       }
     }
-    notificationManager.notify(0xDEAFBEEF, notification);
+    return heapDump;
   }
 
   /**
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 6c71381d..69f02ba2 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -19,11 +19,13 @@
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
+import android.content.res.Resources;
 import android.os.Build;
 import android.util.Log;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
+import static android.text.format.Formatter.formatShortFileSize;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
@@ -61,17 +63,26 @@ public static RefWatcher install(Application application,
    */
   public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
       ExcludedRefs excludedRefs) {
+    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
     DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context);
+    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);
     heapDumper.cleanup();
-    return new RefWatcher(new AndroidWatchExecutor(), debuggerControl, GcTrigger.DEFAULT,
-        heapDumper, heapDumpListener, excludedRefs);
+    Resources resources = context.getResources();
+    int watchDelayMillis = resources.getInteger(R.integer.leak_canary_watch_delay_millis);
+    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);
+    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,
+        heapDumpListener, excludedRefs);
   }
 
   public static void enableDisplayLeakActivity(Context context) {
     setEnabled(context, DisplayLeakActivity.class, true);
   }
 
+  public static void setDisplayLeakActivityDirectoryProvider(
+      LeakDirectoryProvider leakDirectoryProvider) {
+    DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
+  }
+
   /** Returns a string representation of the result of a heap analysis. */
   public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
       boolean detailed) {
@@ -89,13 +100,14 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
     String detailedString = "";
     if (result.leakFound) {
       if (result.excludedLeak) {
-        info += "* LEAK CAN BE IGNORED.\n";
+        info += "* EXCLUDED LEAK.\n";
       }
       info += "* " + result.className;
       if (!heapDump.referenceName.equals("")) {
         info += " (" + heapDump.referenceName + ")";
       }
       info += " has leaked:\n" + result.leakTrace.toString() + "\n";
+      info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
       if (detailed) {
         detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
       }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
new file mode 100644
index 00000000..6c8cf056
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.File;
+
+/**
+ * Provides the directory in which heap dumps and analysis results will be stored.
+ * When using your own implementation, you may also want to call {@link
+ * LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)}.
+ */
+public interface LeakDirectoryProvider {
+
+  /** Returns a path to an existing directory were leaks can be stored. */
+  File leakDirectory();
+
+  void requestWritePermission();
+
+  /** True if we can currently write to the leak directory. */
+  boolean isLeakStorageWritable();
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index da90fb49..349b933f 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -38,11 +38,12 @@
 import android.widget.ListAdapter;
 import android.widget.ListView;
 import android.widget.TextView;
-
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.CanaryLog;
+import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
 import com.squareup.leakcanary.HeapDump;
+import com.squareup.leakcanary.LeakDirectoryProvider;
 import com.squareup.leakcanary.R;
-
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FilenameFilter;
@@ -53,21 +54,21 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 
 import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
 import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
 import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
+import static android.text.format.Formatter.formatShortFileSize;
 import static android.view.View.GONE;
 import static android.view.View.VISIBLE;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.detectedLeakDirectory;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
 
 @SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
 public final class DisplayLeakActivity extends Activity {
 
-  private static final String TAG = "DisplayLeakActivity";
+  private static LeakDirectoryProvider leakDirectoryProvider = null;
+
   private static final String SHOW_LEAK_EXTRA = "show_latest";
 
   public static PendingIntent createPendingIntent(Context context) {
@@ -81,14 +82,26 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
   }
 
+  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
+    DisplayLeakActivity.leakDirectoryProvider = leakDirectoryProvider;
+  }
+
+  static File getLeakDirectory(Context context) {
+    LeakDirectoryProvider leakDirectoryProvider = DisplayLeakActivity.leakDirectoryProvider;
+    if (leakDirectoryProvider != null) {
+      return leakDirectoryProvider.leakDirectory();
+    } else {
+      return new DefaultLeakDirectoryProvider(context).leakDirectory();
+    }
+  }
+
   // null until it's been first loaded.
-  private List<Leak> leaks;
-  private String visibleLeakRefKey;
+  List<Leak> leaks;
+  String visibleLeakRefKey;
 
   private ListView listView;
   private TextView failureView;
   private Button actionButton;
-  private int maxStoredLeaks;
 
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
@@ -111,8 +124,6 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     failureView = (TextView) findViewById(R.id.__leak_canary_display_leak_failure);
     actionButton = (Button) findViewById(R.id.__leak_canary_action);
 
-    maxStoredLeaks = getResources().getInteger(R.integer.leak_canary_max_stored_leaks);
-
     updateUi();
   }
 
@@ -131,8 +142,7 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     LoadLeaks.load(this);
   }
 
-  @Override
-  public void setTheme(int resid) {
+  @Override public void setTheme(int resid) {
     // We don't want this to be called with an incompatible theme.
     // This could happen if you implement runtime switching of themes
     // using ActivityLifecycleCallbacks.
@@ -148,7 +158,8 @@ public void setTheme(int resid) {
   }
 
   @Override public boolean onCreateOptionsMenu(Menu menu) {
-    if (getVisibleLeak() != null) {
+    Leak visibleLeak = getVisibleLeak();
+    if (visibleLeak != null) {
       menu.add(R.string.leak_canary_share_leak)
           .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
             @Override public boolean onMenuItemClick(MenuItem item) {
@@ -156,13 +167,15 @@ public void setTheme(int resid) {
               return true;
             }
           });
-      menu.add(R.string.leak_canary_share_heap_dump)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareHeapDump();
-              return true;
-            }
-          });
+      if (visibleLeak.heapDump.heapDumpFile.exists()) {
+        menu.add(R.string.leak_canary_share_heap_dump)
+            .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
+              @Override public boolean onMenuItemClick(MenuItem item) {
+                shareHeapDump();
+                return true;
+              }
+            });
+      }
       return true;
     }
     return false;
@@ -185,7 +198,7 @@ public void setTheme(int resid) {
     }
   }
 
-  private void shareLeak() {
+  void shareLeak() {
     Leak visibleLeak = getVisibleLeak();
     String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
     Intent intent = new Intent(Intent.ACTION_SEND);
@@ -194,7 +207,7 @@ private void shareLeak() {
     startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
-  private void shareHeapDump() {
+  void shareHeapDump() {
     Leak visibleLeak = getVisibleLeak();
     File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
     heapDumpFile.setReadable(true, false);
@@ -204,7 +217,7 @@ private void shareHeapDump() {
     startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
-  private void updateUi() {
+  void updateUi() {
     if (leaks == null) {
       setTitle("Loading leaks...");
       return;
@@ -257,9 +270,16 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
           actionButton.setOnClickListener(new View.OnClickListener() {
             @Override public void onClick(View v) {
               Leak visibleLeak = getVisibleLeak();
-              File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
-              resultFile.delete();
-              visibleLeak.heapDump.heapDumpFile.delete();
+              File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
+              File resultFile = visibleLeak.resultFile;
+              boolean resultDeleted = resultFile.delete();
+              if (!resultDeleted) {
+                CanaryLog.d("Could not delete result file %s", resultFile.getPath());
+              }
+              boolean heapDumpDeleted = heapDumpFile.delete();
+              if (!heapDumpDeleted) {
+                CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
+              }
               visibleLeakRefKey = null;
               leaks.remove(visibleLeak);
               updateUi();
@@ -268,8 +288,9 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         }
         HeapDump heapDump = visibleLeak.heapDump;
         adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        setTitle(
-            getString(R.string.leak_canary_class_has_leaked, classSimpleName(result.className)));
+        String size = formatShortFileSize(this, result.retainedHeapSize);
+        String className = classSimpleName(result.className);
+        setTitle(getString(R.string.leak_canary_class_has_leaked, className, size));
       }
     } else {
       if (listAdapter instanceof LeakListAdapter) {
@@ -290,10 +311,14 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         actionButton.setText(R.string.leak_canary_delete_all);
         actionButton.setOnClickListener(new View.OnClickListener() {
           @Override public void onClick(View v) {
-            File[] files = detectedLeakDirectory().listFiles();
+            File leakDirectory = getLeakDirectory(DisplayLeakActivity.this);
+            File[] files = leakDirectory.listFiles();
             if (files != null) {
               for (File file : files) {
-                file.delete();
+                boolean deleted = file.delete();
+                if (!deleted) {
+                  CanaryLog.d("Could not delete file %s", file.getPath());
+                }
               }
             }
             leaks = Collections.emptyList();
@@ -305,7 +330,7 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
     }
   }
 
-  private Leak getVisibleLeak() {
+  Leak getVisibleLeak() {
     if (leaks == null) {
       return null;
     }
@@ -340,17 +365,17 @@ private Leak getVisibleLeak() {
       TextView timeView = (TextView) convertView.findViewById(R.id.__leak_canary_row_time);
       Leak leak = getItem(position);
 
-      String index;
-      if (position == 0 && leaks.size() == maxStoredLeaks) {
-        index = "MAX. ";
-      } else {
-        index = (leaks.size() - position) + ". ";
-      }
+      String index = (leaks.size() - position) + ". ";
 
       String title;
       if (leak.result.failure == null) {
-        title = index + getString(R.string.leak_canary_class_has_leaked,
-            classSimpleName(leak.result.className));
+        String className = classSimpleName(leak.result.className);
+        String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
+        title = getString(R.string.leak_canary_class_has_leaked, className, size);
+        if (leak.result.excludedLeak) {
+          title = getString(R.string.leak_canary_excluded_row, title);
+        }
+        title = index + title;
       } else {
         title = index
             + leak.result.failure.getClass().getSimpleName()
@@ -358,8 +383,9 @@ private Leak getVisibleLeak() {
             + leak.result.failure.getMessage();
       }
       titleView.setText(title);
-      String time = DateUtils.formatDateTime(DisplayLeakActivity.this,
-          leak.heapDump.heapDumpFile.lastModified(), FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
+      String time =
+          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.resultFile.lastModified(),
+              FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
       timeView.setText(time);
       return convertView;
     }
@@ -368,10 +394,12 @@ private Leak getVisibleLeak() {
   static class Leak {
     final HeapDump heapDump;
     final AnalysisResult result;
+    final File resultFile;
 
-    Leak(HeapDump heapDump, AnalysisResult result) {
+    Leak(HeapDump heapDump, AnalysisResult result, File resultFile) {
       this.heapDump = heapDump;
       this.result = result;
+      this.resultFile = resultFile;
     }
   }
 
@@ -379,7 +407,7 @@ private Leak getVisibleLeak() {
 
     static final List<LoadLeaks> inFlight = new ArrayList<>();
 
-    static final Executor backgroundExecutor = Executors.newSingleThreadExecutor();
+    static final Executor backgroundExecutor = newSingleThreadExecutor("LoadLeaks");
 
     static void load(DisplayLeakActivity activity) {
       LoadLeaks loadLeaks = new LoadLeaks(activity);
@@ -394,13 +422,13 @@ static void forgetActivity() {
       inFlight.clear();
     }
 
-    private DisplayLeakActivity activityOrNull;
+    DisplayLeakActivity activityOrNull;
     private final File leakDirectory;
     private final Handler mainHandler;
 
     LoadLeaks(DisplayLeakActivity activity) {
       this.activityOrNull = activity;
-      leakDirectory = detectedLeakDirectory();
+      leakDirectory = getLeakDirectory(activity);
       mainHandler = new Handler(Looper.getMainLooper());
     }
 
@@ -408,26 +436,29 @@ static void forgetActivity() {
       final List<Leak> leaks = new ArrayList<>();
       File[] files = leakDirectory.listFiles(new FilenameFilter() {
         @Override public boolean accept(File dir, String filename) {
-          return filename.endsWith(".hprof");
+          return filename.endsWith(".result");
         }
       });
+
       if (files != null) {
-        for (File heapDumpFile : files) {
-          File resultFile = leakResultFile(heapDumpFile);
+        for (File resultFile : files) {
           FileInputStream fis = null;
           try {
             fis = new FileInputStream(resultFile);
             ObjectInputStream ois = new ObjectInputStream(fis);
             HeapDump heapDump = (HeapDump) ois.readObject();
             AnalysisResult result = (AnalysisResult) ois.readObject();
-            leaks.add(new Leak(heapDump, result));
+            leaks.add(new Leak(heapDump, result, resultFile));
           } catch (IOException | ClassNotFoundException e) {
             // Likely a change in the serializable result class.
             // Let's remove the files, we can't read them anymore.
-            heapDumpFile.delete();
-            resultFile.delete();
-            Log.e(TAG, "Could not read result file, deleted result and heap dump:" + heapDumpFile,
-                e);
+            boolean deleted = resultFile.delete();
+            if (deleted) {
+              CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
+            } else {
+              CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
+                  resultFile);
+            }
           } finally {
             if (fis != null) {
               try {
@@ -439,8 +470,8 @@ static void forgetActivity() {
         }
         Collections.sort(leaks, new Comparator<Leak>() {
           @Override public int compare(Leak lhs, Leak rhs) {
-            return Long.valueOf(rhs.heapDump.heapDumpFile.lastModified())
-                .compareTo(lhs.heapDump.heapDumpFile.lastModified());
+            return Long.valueOf(rhs.resultFile.lastModified())
+                .compareTo(lhs.resultFile.lastModified());
           }
         });
       }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
index cb16c7fe..929e6bad 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
@@ -22,6 +22,7 @@
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.TextView;
+import com.squareup.leakcanary.Exclusion;
 import com.squareup.leakcanary.LeakTrace;
 import com.squareup.leakcanary.LeakTraceElement;
 import com.squareup.leakcanary.R;
@@ -132,6 +133,23 @@ private String elementToHtmlString(LeakTraceElement element, boolean root, boole
     if (opened && element.extra != null) {
       htmlString += " <font color='#919191'>" + element.extra + "</font>";
     }
+
+    Exclusion exclusion = element.exclusion;
+    if (exclusion != null) {
+      if (opened) {
+        htmlString += "<br/><br/>Excluded by rule";
+        if (exclusion.name != null) {
+          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
+        }
+        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
+        if (exclusion.reason != null) {
+          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
+        }
+      } else {
+        htmlString += " (excluded)";
+      }
+    }
+
     return htmlString;
   }
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index 0bcaf9e0..d03dad94 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -18,9 +18,9 @@
 import android.app.IntentService;
 import android.content.Context;
 import android.content.Intent;
-import android.util.Log;
 import com.squareup.leakcanary.AbstractAnalysisResultService;
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.CanaryLog;
 import com.squareup.leakcanary.HeapAnalyzer;
 import com.squareup.leakcanary.HeapDump;
 
@@ -32,7 +32,6 @@
 
   private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
   private static final String HEAPDUMP_EXTRA = "heapdump_extra";
-  public static final String TAG = "HeapAnalyzerService";
 
   public static void runAnalysis(Context context, HeapDump heapDump,
       Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
@@ -48,7 +47,7 @@ public HeapAnalyzerService() {
 
   @Override protected void onHandleIntent(Intent intent) {
     if (intent == null) {
-      Log.d(TAG, "HeapAnalyzerService received a null intent, ignoring.");
+      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
       return;
     }
     String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
index ac8ecba7..b334079f 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -15,16 +15,20 @@
  */
 package com.squareup.leakcanary.internal;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
 import android.app.Service;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ServiceInfo;
-import android.os.Environment;
-import android.util.Log;
-import java.io.File;
+import com.squareup.leakcanary.CanaryLog;
+import com.squareup.leakcanary.R;
+import java.lang.reflect.Method;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 
@@ -32,7 +36,9 @@
 import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
 import static android.content.pm.PackageManager.DONT_KILL_APP;
 import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.os.Environment.DIRECTORY_DOWNLOADS;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.HONEYCOMB;
+import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 
 public final class LeakCanaryInternals {
 
@@ -43,46 +49,12 @@
   public static final String LG = "LGE";
   public static final String NVIDIA = "NVIDIA";
 
-  private static final Executor fileIoExecutor = Executors.newSingleThreadExecutor();
+  private static final Executor fileIoExecutor = newSingleThreadExecutor("File-IO");
 
   public static void executeOnFileIoThread(Runnable runnable) {
     fileIoExecutor.execute(runnable);
   }
 
-  public static File storageDirectory() {
-    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
-    File leakCanaryDirectory = new File(downloadsDirectory, "leakcanary");
-    leakCanaryDirectory.mkdirs();
-    return leakCanaryDirectory;
-  }
-
-  public static File detectedLeakDirectory() {
-    File directory = new File(storageDirectory(), "detected_leaks");
-    directory.mkdirs();
-    return directory;
-  }
-
-  public static File leakResultFile(File heapdumpFile) {
-    return new File(heapdumpFile.getParentFile(), heapdumpFile.getName() + ".result");
-  }
-
-  public static boolean isExternalStorageWritable() {
-    String state = Environment.getExternalStorageState();
-    return Environment.MEDIA_MOUNTED.equals(state);
-  }
-
-  public static File findNextAvailableHprofFile(int maxFiles) {
-    File directory = detectedLeakDirectory();
-    for (int i = 0; i < maxFiles; i++) {
-      String heapDumpName = "heap_dump_" + i + ".hprof";
-      File file = new File(directory, heapDumpName);
-      if (!file.exists()) {
-        return file;
-      }
-    }
-    return null;
-  }
-
   /** Extracts the class simple name out of a string containing a fully qualified class name. */
   public static String classSimpleName(String className) {
     int separator = className.lastIndexOf('.');
@@ -98,22 +70,27 @@ public static void setEnabled(Context context, final Class<?> componentClass,
     final Context appContext = context.getApplicationContext();
     executeOnFileIoThread(new Runnable() {
       @Override public void run() {
-        ComponentName component = new ComponentName(appContext, componentClass);
-        PackageManager packageManager = appContext.getPackageManager();
-        int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-        // Blocks on IPC.
-        packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
+        setEnabledBlocking(appContext, componentClass, enabled);
       }
     });
   }
 
+  public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
+      boolean enabled) {
+    ComponentName component = new ComponentName(appContext, componentClass);
+    PackageManager packageManager = appContext.getPackageManager();
+    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
+    // Blocks on IPC.
+    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
+  }
+
   public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
     PackageManager packageManager = context.getPackageManager();
     PackageInfo packageInfo;
     try {
       packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
     } catch (Exception e) {
-      Log.e("AndroidUtils", "Could not get package info for " + context.getPackageName(), e);
+      CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
       return false;
     }
     String mainProcess = packageInfo.applicationInfo.processName;
@@ -128,8 +105,7 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
     }
 
     if (serviceInfo.processName.equals(mainProcess)) {
-      Log.e("AndroidUtils",
-          "Did not expect service " + serviceClass + " to run in main process " + mainProcess);
+      CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
       // Technically we are in the service process, but we're not in the service dedicated process.
       return false;
     }
@@ -145,13 +121,54 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
       }
     }
     if (myProcess == null) {
-      Log.e("AndroidUtils", "Could not find running process for " + myPid);
+      CanaryLog.d("Could not find running process for %d", myPid);
       return false;
     }
 
     return myProcess.processName.equals(serviceInfo.processName);
   }
 
+  @TargetApi(HONEYCOMB)
+  public static void showNotification(Context context, CharSequence contentTitle,
+      CharSequence contentText, PendingIntent pendingIntent) {
+    NotificationManager notificationManager =
+        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+    Notification notification;
+    if (SDK_INT < HONEYCOMB) {
+      notification = new Notification();
+      notification.icon = R.drawable.leak_canary_notification;
+      notification.when = System.currentTimeMillis();
+      notification.flags |= Notification.FLAG_AUTO_CANCEL;
+      try {
+        Method method =
+            Notification.class.getMethod("setLatestEventInfo", Context.class, CharSequence.class,
+                CharSequence.class, PendingIntent.class);
+        method.invoke(notification, context, contentTitle, contentText, pendingIntent);
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    } else {
+      Notification.Builder builder = new Notification.Builder(context) //
+          .setSmallIcon(R.drawable.leak_canary_notification)
+          .setWhen(System.currentTimeMillis())
+          .setContentTitle(contentTitle)
+          .setContentText(contentText)
+          .setAutoCancel(true)
+          .setContentIntent(pendingIntent);
+      if (SDK_INT < JELLY_BEAN) {
+        notification = builder.getNotification();
+      } else {
+        notification = builder.build();
+      }
+    }
+    notificationManager.notify(0xDEAFBEEF, notification);
+  }
+
+  public static Executor newSingleThreadExecutor(String threadName) {
+    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
+  }
+
   private LeakCanaryInternals() {
     throw new AssertionError();
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
new file mode 100644
index 00000000..4eb3a3a0
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * This is intended to only be used with a single thread executor.
+ */
+final class LeakCanarySingleThreadFactory implements ThreadFactory {
+
+  private final String threadName;
+
+  LeakCanarySingleThreadFactory(String threadName) {
+    this.threadName = "LeakCanary-" + threadName;
+  }
+
+  @Override public Thread newThread(Runnable runnable) {
+    return new Thread(runnable, threadName);
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
new file mode 100644
index 00000000..2d941302
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
+import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
+import static android.os.Build.VERSION_CODES.M;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
+
+@TargetApi(M) //
+public class RequestStoragePermissionActivity extends Activity {
+
+  public static PendingIntent createPendingIntent(Context context) {
+    setEnabledBlocking(context, RequestStoragePermissionActivity.class, true);
+    Intent intent = new Intent(context, RequestStoragePermissionActivity.class);
+    intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TOP);
+    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
+  }
+
+  @Override protected void onResume() {
+    super.onResume();
+    // This won't work well if the user doesn't enable the permission.
+    // Seems ok for a dev tool, especially since you have to click a notification
+    // to get here.
+    if (checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED) {
+      finish();
+    } else {
+      String[] permissions = {
+          WRITE_EXTERNAL_STORAGE
+      };
+      requestPermissions(permissions, 42);
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png
index f1049229..07bb09fc 100755
Binary files a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
index 7e375c54..74348d82 100755
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png
index 09c78cc0..13b33116 100755
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png
index d29b9f1d..9738ad81 100755
Binary files a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
index f354c3f2..37f5057f 100755
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png
index c825fa4a..dc92783b 100755
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png
index d0cdbcd8..538e0214 100755
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
index a5e85b41..56a94f27 100755
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png
index b2978d57..1e1b977f 100755
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png
index 0194b4e1..d3ef4b71 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
index 3d4b76af..34b7d41b 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png
index 22db2020..c652efdd 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png
index 05141619..4713f18d 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
index eb9c0724..855d6052 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png
index 34b76141..bb458f2c 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/values/leak_canary_int.xml b/leakcanary-android/src/main/res/values/leak_canary_int.xml
index 3d2c5ac0..b7197372 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_int.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_int.xml
@@ -16,4 +16,5 @@
   -->
 <resources>
   <integer name="leak_canary_max_stored_leaks">7</integer>
-</resources>
\ No newline at end of file
+  <integer name="leak_canary_watch_delay_millis">5000</integer>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_public.xml b/leakcanary-android/src/main/res/values/leak_canary_public.xml
new file mode 100644
index 00000000..b5f11b97
--- /dev/null
+++ b/leakcanary-android/src/main/res/values/leak_canary_public.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+
+  <public name="leak_canary_display_activity_label" type="string"/>
+  <public name="leak_canary_heap_dump_toast" type="layout"/>
+  <public name="leak_canary_icon" type="drawable"/>
+  <public name="leak_canary_max_stored_leaks" type="integer"/>
+  <public name="leak_canary_watch_delay_millis" type="integer"/>
+
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
index e0600ff2..b53e29ce 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -15,20 +15,25 @@
   ~ limitations under the License.
   -->
 <resources>
-
-  <string name="leak_canary_class_has_leaked">%s has leaked</string>
-  <string name="leak_canary_class_leak_ignored">Ignored %s leak</string>
+  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
+  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
   <string name="leak_canary_analysis_failed">Leak analysis failed</string>
   <string name="leak_canary_leak_list_title">Leaks in %s</string>
-  <string name="leak_canary_notification_leak_ignored_message">Click to see previous leaks</string>
   <string name="leak_canary_notification_message">Click for more details</string>
   <string name="leak_canary_share_leak">Share info</string>
   <string name="leak_canary_share_heap_dump">Share heap dump</string>
   <string name="leak_canary_share_with">Share with…</string>
   <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
   <string name="leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
   <string name="leak_canary_delete">Delete</string>
   <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
   <string name="leak_canary_delete_all">Delete all</string>
-
-</resources>
\ No newline at end of file
+  <string name="leak_canary_could_not_save_title">Could not save result.</string>
+  <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
+  <string name="leak_canary_no_leak_title">No leak found</string>
+  <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
+  <string name="leak_canary_excluded_row">[Excluded] %s</string>
+  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
+  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_themes.xml b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
index 69a56edb..eebd0333 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
@@ -17,4 +17,12 @@
 <resources>
   <style name="leak_canary_LeakCanary.Base" parent="android:Theme">
   </style>
-</resources>
\ No newline at end of file
+
+  <style name="leak_canary_Theme.Transparent" parent="android:Theme">
+    <item name="android:windowIsTranslucent">true</item>
+    <item name="android:windowBackground">@android:color/transparent</item>
+    <item name="android:windowContentOverlay">@null</item>
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:backgroundDimEnabled">false</item>
+  </style>
+</resources>
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
index fefe52ff..870f59b1 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
@@ -35,7 +35,7 @@
     });
   }
 
-  private void startAsyncTask() {
+  void startAsyncTask() {
     // This async task is an anonymous class and therefore has a hidden reference to the outer
     // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation),
     // the activity instance will leak.
diff --git a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
index 099c77d4..65948fa3 100755
Binary files a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
index da2453c6..5d826c42 100755
Binary files a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
index 35a3ec97..c9c7ec58 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
index 6b3f35af..cb8a98ab 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
index 2d77dc1f..3ca3a7f6 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
index 1e112cee..9e5bf782 100644
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ b/leakcanary-sample/src/main/res/values/strings.xml
@@ -20,5 +20,5 @@
   <string name="helper_text">Start the async task, <b>rotate the screen</b> and wait for a bit. A
     wild notification appears.
   </string>
-  <string name="__leak_canary_display_activity_label">Leaks Sample</string>
+  <string name="leak_canary_display_activity_label">Leaks Sample</string>
 </resources>
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
index 9d2dfec4..47662445 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
@@ -23,120 +23,187 @@
 import static java.util.Collections.unmodifiableMap;
 
 /**
- * Prevents specific references from being taken into account when computing the shortest strong
- * reference path from a suspected leaking instance to the GC roots.
+ * Prevents specific references from being taken into account when computing the shortest reference
+ * path from a suspected leaking instance to the GC roots.
  *
- * This class lets you ignore known memory leaks that you known about. If the shortest path
+ * This class lets you ignore known memory leaks that you know about. If the shortest path
  * matches {@link ExcludedRefs}, than the heap analyzer should look for a longer path with nothing
  * matching in {@link ExcludedRefs}.
  */
 public final class ExcludedRefs implements Serializable {
 
-  public final Map<String, Map<String, Boolean>> fieldNameByClassName;
-  public final Map<String, Map<String, Boolean>> staticFieldNameByClassName;
-  public final Map<String, Boolean> threadNames;
-  public final Map<String, Boolean> classNames;
-
-  private ExcludedRefs(Map<String, Map<String, Boolean>> fieldNameByClassName,
-      Map<String, Map<String, Boolean>> staticFieldNameByClassName,
-      Map<String, Boolean> threadNames, Map<String, Boolean> classNames) {
-    // Copy + unmodifiable.
-    this.fieldNameByClassName = unmodifiableMap(new LinkedHashMap<>(fieldNameByClassName));
-    this.staticFieldNameByClassName =
-        unmodifiableMap(new LinkedHashMap<>(staticFieldNameByClassName));
-    this.threadNames = unmodifiableMap(new LinkedHashMap<>(threadNames));
-    this.classNames = unmodifiableMap(new LinkedHashMap<>(classNames));
+  public static Builder builder() {
+    return new BuilderWithParams();
+  }
+
+  public final Map<String, Map<String, Exclusion>> fieldNameByClassName;
+  public final Map<String, Map<String, Exclusion>> staticFieldNameByClassName;
+  public final Map<String, Exclusion> threadNames;
+  public final Map<String, Exclusion> classNames;
+  public final Map<String, Exclusion> rootClassNames;
+
+  ExcludedRefs(BuilderWithParams builder) {
+    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName);
+    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName);
+    this.threadNames = unmodifiableRefMap(builder.threadNames);
+    this.classNames = unmodifiableRefMap(builder.classNames);
+    this.rootClassNames = unmodifiableRefMap(builder.rootClassNames);
+  }
+
+  private Map<String, Map<String, Exclusion>> unmodifiableRefStringMap(
+      Map<String, Map<String, ParamsBuilder>> mapmap) {
+    LinkedHashMap<String, Map<String, Exclusion>> fieldNameByClassName = new LinkedHashMap<>();
+    for (Map.Entry<String, Map<String, ParamsBuilder>> entry : mapmap.entrySet()) {
+      fieldNameByClassName.put(entry.getKey(), unmodifiableRefMap(entry.getValue()));
+    }
+    return unmodifiableMap(fieldNameByClassName);
+  }
+
+  private Map<String, Exclusion> unmodifiableRefMap(Map<String, ParamsBuilder> fieldBuilderMap) {
+    Map<String, Exclusion> fieldMap = new LinkedHashMap<>();
+    for (Map.Entry<String, ParamsBuilder> fieldEntry : fieldBuilderMap.entrySet()) {
+      fieldMap.put(fieldEntry.getKey(), new Exclusion(fieldEntry.getValue()));
+    }
+    return unmodifiableMap(fieldMap);
   }
 
   @Override public String toString() {
     String string = "";
-    for (Map.Entry<String, Map<String, Boolean>> classes : fieldNameByClassName.entrySet()) {
+    for (Map.Entry<String, Map<String, Exclusion>> classes : fieldNameByClassName.entrySet()) {
       String clazz = classes.getKey();
-      for (Map.Entry<String, Boolean> field : classes.getValue().entrySet()) {
-        String always = field.getValue() ? " (always)" : "";
+      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
+        String always = field.getValue().alwaysExclude ? " (always)" : "";
         string += "| Field: " + clazz + "." + field.getKey() + always + "\n";
       }
     }
-    for (Map.Entry<String, Map<String, Boolean>> classes : staticFieldNameByClassName.entrySet()) {
+    for (Map.Entry<String, Map<String, Exclusion>> classes : staticFieldNameByClassName.entrySet()) {
       String clazz = classes.getKey();
-      for (Map.Entry<String, Boolean> field : classes.getValue().entrySet()) {
-        String always = field.getValue() ? " (always)" : "";
+      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
+        String always = field.getValue().alwaysExclude ? " (always)" : "";
         string += "| Static field: " + clazz + "." + field.getKey() + always + "\n";
       }
     }
-    for (Map.Entry<String, Boolean> thread : threadNames.entrySet()) {
-      String always = thread.getValue() ? " (always)" : "";
+    for (Map.Entry<String, Exclusion> thread : threadNames.entrySet()) {
+      String always = thread.getValue().alwaysExclude ? " (always)" : "";
       string += "| Thread:" + thread.getKey() + always + "\n";
     }
-    for (Map.Entry<String, Boolean> clazz : classNames.entrySet()) {
-      String always = clazz.getValue() ? " (always)" : "";
+    for (Map.Entry<String, Exclusion> clazz : classNames.entrySet()) {
+      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
       string += "| Class:" + clazz.getKey() + always + "\n";
     }
+    for (Map.Entry<String, Exclusion> clazz : rootClassNames.entrySet()) {
+      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
+      string += "| Root Class:" + clazz.getKey() + always + "\n";
+    }
     return string;
   }
 
-  public static final class Builder {
-    private final Map<String, Map<String, Boolean>> fieldNameByClassName = new LinkedHashMap<>();
-    private final Map<String, Map<String, Boolean>> staticFieldNameByClassName =
+  static final class ParamsBuilder {
+    String name;
+    String reason;
+    boolean alwaysExclude;
+    final String matching;
+
+    ParamsBuilder(String matching) {
+      this.matching = matching;
+    }
+  }
+
+  public interface Builder {
+    BuilderWithParams instanceField(String className, String fieldName);
+
+    BuilderWithParams staticField(String className, String fieldName);
+
+    BuilderWithParams thread(String threadName);
+
+    BuilderWithParams clazz(String className);
+
+    BuilderWithParams rootClass(String rootSuperClassName);
+
+    ExcludedRefs build();
+  }
+
+  public static final class BuilderWithParams implements Builder {
+
+    private final Map<String, Map<String, ParamsBuilder>> fieldNameByClassName =
+        new LinkedHashMap<>();
+    private final Map<String, Map<String, ParamsBuilder>> staticFieldNameByClassName =
         new LinkedHashMap<>();
-    private final Map<String, Boolean> threadNames = new LinkedHashMap<>();
-    private final Map<String, Boolean> classNames = new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> threadNames = new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> classNames = new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> rootClassNames = new LinkedHashMap<>();
 
-    public Builder instanceField(String className, String fieldName) {
-      return instanceField(className, fieldName, false);
+    private ParamsBuilder lastParams;
+
+    BuilderWithParams() {
     }
 
-    public Builder instanceField(String className, String fieldName, boolean always) {
+    @Override public BuilderWithParams instanceField(String className, String fieldName) {
       checkNotNull(className, "className");
       checkNotNull(fieldName, "fieldName");
-      Map<String, Boolean> excludedFields = fieldNameByClassName.get(className);
+      Map<String, ParamsBuilder> excludedFields = fieldNameByClassName.get(className);
       if (excludedFields == null) {
         excludedFields = new LinkedHashMap<>();
         fieldNameByClassName.put(className, excludedFields);
       }
-      excludedFields.put(fieldName, always);
+      lastParams = new ParamsBuilder("field " + className + "#" + fieldName);
+      excludedFields.put(fieldName, lastParams);
       return this;
     }
 
-    public Builder staticField(String className, String fieldName) {
-      return staticField(className, fieldName, false);
-    }
-
-    public Builder staticField(String className, String fieldName, boolean always) {
+    @Override public BuilderWithParams staticField(String className, String fieldName) {
       checkNotNull(className, "className");
       checkNotNull(fieldName, "fieldName");
-      Map<String, Boolean> excludedFields = staticFieldNameByClassName.get(className);
+      Map<String, ParamsBuilder> excludedFields = staticFieldNameByClassName.get(className);
       if (excludedFields == null) {
         excludedFields = new LinkedHashMap<>();
         staticFieldNameByClassName.put(className, excludedFields);
       }
-      excludedFields.put(fieldName, always);
+      lastParams = new ParamsBuilder("static field " + className + "#" + fieldName);
+      excludedFields.put(fieldName, lastParams);
       return this;
     }
 
-    public Builder thread(String threadName) {
-      return thread(threadName, false);
+    @Override public BuilderWithParams thread(String threadName) {
+      checkNotNull(threadName, "threadName");
+      lastParams = new ParamsBuilder("any threads named " + threadName);
+      threadNames.put(threadName, lastParams);
+      return this;
     }
 
-    public Builder thread(String threadName, boolean always) {
-      checkNotNull(threadName, "threadName");
-      threadNames.put(threadName, always);
+    /** Ignores all fields and static fields of all subclasses of the provided class name. */
+    @Override public BuilderWithParams clazz(String className) {
+      checkNotNull(className, "className");
+      lastParams = new ParamsBuilder("any subclass of " + className);
+      classNames.put(className, lastParams);
       return this;
     }
 
-    public Builder clazz(String className) {
-      return thread(className, false);
+    /** Ignores any GC root that belongs to a subclass of the provided class name. */
+    @Override public BuilderWithParams rootClass(String rootClassName) {
+      checkNotNull(rootClassName, "rootClassName");
+      lastParams = new ParamsBuilder("any GC root subclass of " + rootClassName);
+      rootClassNames.put(rootClassName, lastParams);
+      return this;
     }
 
-    public Builder clazz(String className, boolean always) {
-      checkNotNull(className, "className");
-      classNames.put(className, always);
+    public BuilderWithParams named(String name) {
+      lastParams.name = name;
+      return this;
+    }
+
+    public BuilderWithParams reason(String reason) {
+      lastParams.reason = reason;
+      return this;
+    }
+
+    public BuilderWithParams alwaysExclude() {
+      lastParams.alwaysExclude = true;
       return this;
     }
 
     public ExcludedRefs build() {
-      return new ExcludedRefs(fieldNameByClassName, staticFieldNameByClassName, threadNames,
-          classNames);
+      return new ExcludedRefs(this);
     }
   }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
new file mode 100644
index 00000000..4d87d05e
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
@@ -0,0 +1,17 @@
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+
+public final class Exclusion implements Serializable {
+  public final String name;
+  public final String reason;
+  public final boolean alwaysExclude;
+  public final String matching;
+
+  Exclusion(ExcludedRefs.ParamsBuilder builder) {
+    this.name = builder.name;
+    this.reason = builder.reason;
+    this.alwaysExclude = builder.alwaysExclude;
+    this.matching = builder.matching;
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index 2423dc9b..fe88f38e 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -61,11 +61,4 @@ public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
     this.gcDurationMs = gcDurationMs;
     this.heapDumpDurationMs = heapDumpDurationMs;
   }
-
-  /** Renames the heap dump file and creates a new {@link HeapDump} pointing to it. */
-  public HeapDump renameFile(File newFile) {
-    heapDumpFile.renameTo(newFile);
-    return new HeapDump(newFile, referenceKey, referenceName, excludedRefs, watchDurationMs,
-        gcDurationMs, heapDumpDurationMs);
-  }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 7d2b9fc4..5d124535 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -48,7 +48,7 @@
   }, new HeapDump.Listener() {
     @Override public void analyze(HeapDump heapDump) {
     }
-  }, new ExcludedRefs.Builder().build());
+  }, new ExcludedRefs.BuilderWithParams().build());
 
   private final Executor watchExecutor;
   private final DebuggerControl debuggerControl;
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
index 421ceea0..15b44def 100644
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
@@ -24,7 +24,7 @@
 
 public class RefWatcherTest {
 
-  static final ExcludedRefs NO_REF = new ExcludedRefs.Builder().build();
+  static final ExcludedRefs NO_REF = new ExcludedRefs.BuilderWithParams().build();
 
   static class TestDumper implements HeapDumper {
     boolean called;
@@ -43,7 +43,7 @@
   @SuppressWarnings("FieldCanBeLocal") Object ref;
 
   static class TestExecutor implements Executor {
-    private Runnable command;
+    Runnable command;
 
     @Override public void execute(Runnable command) {
       this.command = command;
