diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
new file mode 100755
index 00000000..d15ea400
--- /dev/null
+++ b/.buildscript/deploy_snapshot.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+#
+# Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
+#
+# Adapted from https://coderwall.com/p/9b_lfq and
+# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+
+SLUG="square/leakcanary"
+JDK="oraclejdk8"
+BRANCH="master"
+
+set -e
+
+if [ "$TRAVIS_REPO_SLUG" != "$SLUG" ]; then
+  echo "Skipping snapshot deployment: wrong repository. Expected '$SLUG' but was '$TRAVIS_REPO_SLUG'."
+elif [ "$TRAVIS_JDK_VERSION" != "$JDK" ]; then
+  echo "Skipping snapshot deployment: wrong JDK. Expected '$JDK' but was '$TRAVIS_JDK_VERSION'."
+elif [ "$TRAVIS_PULL_REQUEST" != "false" ]; then
+  echo "Skipping snapshot deployment: was pull request."
+elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
+  echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
+else
+  echo "Deploying snapshot..."
+  ./gradlew clean uploadArchives
+  echo "Snapshot deployed!"
+fi
diff --git a/CONTRIBUTING.md b/.github/CONTRIBUTING.md
similarity index 100%
rename from CONTRIBUTING.md
rename to .github/CONTRIBUTING.md
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
new file mode 100644
index 00000000..f655ac04
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE.md
@@ -0,0 +1,29 @@
+Welcome and thank you for reporting an issue!
+
+First, verify that your issue hasn't already been reported by searching over all issues: https://github.com/square/leakcanary/issues?q=is%3Aissue.
+
+What kind of issue is this?
+
+ - Question: This issue tracker is not the place for questions. If you want to ask how to do
+   something, or to understand why something isn't working the way you expect it to, use Stack
+   Overflow: https://stackoverflow.com/questions/tagged/leakcanary.
+
+ - Help me fix a leak?: Please do not file an issue.
+   Instead, read here: https://github.com/square/leakcanary/#how-do-i-fix-a-memory-leak
+ 
+ - OOM error: Please provide a heap dump!
+
+ - Bug report: If you’ve found a bug, spend the time to write a failing test. Bugs with tests get fixed. 
+   Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
+   
+ - Feature Request: Start by telling us what problem you’re trying to solve. Don’t send pull requests to implement 
+   new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
+
+^^^^^ DELETE FROM THIS LINE UP ^^^^^
+
+
+```
+
+REPLACE THIS LINE WITH YOUR STACKTRACE OR OUTPUT FROM LEAKCANARY
+
+```
diff --git a/.travis.yml b/.travis.yml
index e4452455..bd5bfe90 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,16 +2,24 @@ language: android
 
 android:
   components:
-    - build-tools-21.1.2
-    - android-21
-  licenses:
-    - android-sdk-license-5be876d5
+    - tools
+    - platform-tools
+    - build-tools-26.0.0
+    - android-26
 
 jdk:
-  - oraclejdk7
+  - oraclejdk8
 
 script:
-  - ./gradlew clean build check
+  - ./gradlew clean build
+
+after_success:
+  - .buildscript/deploy_snapshot.sh
+
+env:
+  global:
+    - secure: "aWyY/jCiG/D7hHAprj0rG3xYafxRYjZM5oNqqbDfjUHvqPp7kS3SOhUd3SJMVuSR4kA5TuZQqMXHr10Jz05gcyowQE2XEnKmu1WkfNWz2TCNerF27O0TkuIgYyZxcOb1M4aMxDJPZgySLmsXQ+iuAly+RSFP/CcSP4WPU9YNsGCQZ1C8KfscCWxKR5n1GoOEboOIxE5BL11F4tYjINX45FcIdBJu5XKJhCqUUvjdwxrZ0BykSYpvgpZ0WwAcXUBHHoqcYnNYAhBi60G00OE2Ml1x5lXiC+5Kwpsi0mXoWMyDT7MIIqB+Fk6XzxEzE7+z2nYmssXpvfHDJe+N+osCxvgWL97dMwx6BLv0S2jaoNgtcBB/DpzJAGeQ3yFulK5npr7RpeKpFN60rj8vYaRK9EfAvTfiHOjA/gkfSLBYOk/hOmE6o363nAKqUss+5FMS9c2vgIatbJiYHWScqlMRPxS3IjLp9Y84jB8JN/T8Mexxsw07OmEtaAU5+di/Nv2ok1MIx25NA0XYsMKXReCkicYoXQcSBIj5fTUI6bD09OLS4hs1EacX0hIfF89TJKs6azu0VLJHWKoW2Uo+qqgVMQPXRkNAzCcrJGeUWep8O/DsoNlT40NZCXP5wJN/aWFK0Rrl5n1zM8VVWBPk/0CAS0VUDZZSnqGXo2vZV6+bYEk="
+    - secure: "gdFVL5AOp5DhnaC2vJ5EYglenG3vOcJuMLQrnQsKzt+p2jb9jdu8Lbx3kr8UdKOXOPPQVwg1U8BILe8RPmkaURYgZLE9nPthEcEVfULRPbj7EDHxOQ0/3uWRbkq+GyxDtX4+tdnDQhEijW+hSIQdWHgUAwvvvxrKLVS37lYaj55VVtITljgsd07YYKMrFNFfH/tgDJdZClaiuXdLfrWzVEZKGHBJfyzGOjLmUSbZzXL/ut32mIqbVsxeDvXXxlBluS68UkG3wI5/gp1jAxBIc+NK+CoZMMb5ww6V1P+iZhA176YXm8WDiUHpEx6cH//rtnIJ+1IywBCG+S60JeVpUEu8N9NK/eVd2en5OSef9xqBYfCYHRKvI/S/DiR9CCbim7rnlVgHMrY580Nv/bnJ5E9Q/sQSD9pzKp0P452qU36FXJ+c519inc1+F5fEUApft0UzAVQFT9sY7qGV0d6x6D3BDyXGE4KMYWx4ydkSSCAI2bsvl/8dLUybU1kKBDivY71VU/bGtJ33LobySiSJA/03vTKHEsBuMowu13pnj7c5tp7QFFv3lRO1XXqT4NS39SySDQUT7UbZofsqHTyqMpiL72q1rII6af+XNskmILuwU/oRwR8+IN9LBE9Nz0uL3zOzv8uhzTZT2rUGEhDm+B51UMvK0ZEJDlpvA9Y2GTQ="
 
 notifications:
   email: false
@@ -20,4 +28,4 @@ sudo: false
 
 cache:
   directories:
-    - $HOME/.gradle
\ No newline at end of file
+    - $HOME/.gradle
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 960268a2..1133354b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,14 +1,87 @@
 # Change Log
 
-## Version 1.4-SNAPSHOT
+## Version 1.5.2 *(2017-08-09)*
 
-* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This should fix most crashes and improve speed a lot. We can now parse Android M heap dumps, although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
-* A status bar notification is displayed when the trace analysis results in an excluded ref leak [#216](https://github.com/square/leakcanary/pull/216).
-* Added ProGuard configuration for debug library [#132](https://github.com/square/leakcanary/issues/132).
-* 2 new ignored Android SDK leaks: [#26](https://github.com/square/leakcanary/issues/26) [#62](https://github.com/square/leakcanary/issues/62).
+* New excluded leaks
+* Move Leakcanary UI into leak analyzer process
+* Ignore computing retained sizes for bitmaps on O+
+* Add notification channel for persistent messages on O+
+* Exclude permission activity from recents menu
+* Updated README and sample for handling Robolectric tests
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5.1...v1.5.2).
+
+## Version 1.5.1 *(2017-04-25)*
+
+* New excluded leaks
+* Fix java.util.MissingFormatArgumentException in DisplayLeakService
+* Separate task affinities for different apps
+* Bump minSdk to 14
+* Fix HahaHelper for O Preview
+  
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.5...v1.5.1).
+
+## Version 1.5 *(2016-09-28)*
+
+* New excluded leaks
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Fixed several file access issues:
+  * No more cleanup on startup, we rotate the heap dump files on every new heap dump.
+  * LeakCanary now falls back to the app directory until it can write to the external storage.
+* Leak notifications now each use a distinct notification instead of erasing each other.
+* If LeakCanary can't perform a heap dump for any reason (e.g. analysis in progress, debugger attached), it retries later with an exponential backoff.
+* Added confirmation dialog when user deletes all leaks.
+* Replace the two LeakCanary configuration methods with a builder that provides more flexibility, see `LeakCanary.refWatcher()`.
+
+For more details, see the [full diff](https://github.com/square/leakcanary/compare/v1.4...v1.5).
+
+### Public API changes
+
+* New `HeapAnalyzer.findTrackedReferences()` method for headless analysis when you have no context on what leaked.
+* Added `LeakCanary.isInAnalyzerProcess()` to the no-op jar
+* Added `LeakCanary.refWatcher()` which returns an `AndroidRefWatcherBuilder` that extends `RefWatcherBuilder` and lets you fully customize the `RefWatcher` instance.
+* Removed `LeakCanary.install(Application, Class)` and `LeakCanary.androidWatcher(Context, HeapDump.Listener, ExcludedRefs)`.
+* Removed `R.integer.leak_canary_max_stored_leaks` and `R.integer.leak_canary_watch_delay_millis`, those can now be set via `LeakCanary.refWatcher()`.
+* Updated the `LeakDirectoryProvider` API to centralize all file related responsibilities.
+* `RefWatcher` is now constructed with a `WatchExecutor` which executes a `Retryable`, instead of an `Executor` that executes a `Runnable`.
+* `HeapDumper.NO_DUMP` was renamed `HeapDumper.RETRY_LATER`
+
+## Version 1.4 *(2016-09-11)*
+
+* Fix false negative where GC root is of type android.os.Binder [#482](https://github.com/square/leakcanary/issues/482)
+* Update HAHA to 2.0.3; clear compiler warnings [#563](https://github.com/square/leakcanary/issues/563) 
+* Correct some mistakes in German translation [#516](https://github.com/square/leakcanary/pull/516)
+* Don't loop when storage permission denied [#422](https://github.com/square/leakcanary/issues/422)
+* Remove old references to "__" prefixed resources [#477](https://github.com/square/leakcanary/pull/477)
+* Fix permission crash for DisplayLeakActivity on M [#382](https://github.com/square/leakcanary/issues/382)
+* Fix NPE when thread name not found in heap dump [#417](https://github.com/square/leakcanary/issues/417)
+* Add version info to stacktrace [#473](https://github.com/square/leakcanary/issues/473)
+
+## Version 1.4-beta2 *(2016-03-23)*
+
+* Add reason for ignoring to analysis result [#365](https://github.com/square/leakcanary/issues/365).
+* Lower memory usage when parsing heap dumps on M [#223](https://github.com/square/leakcanary/issues/223).
+* Fix NPE in LeakCanaryInternals.isInServiceProcess() [#449](https://github.com/square/leakcanary/issues/449).
+* New ignored Android SDK leaks [#297](https://github.com/square/leakcanary/issues/297),[#322](https://github.com/square/leakcanary/issues/322).
+* Use leakcanary-android-no-op in test builds [#143](https://github.com/square/leakcanary/issues/143).
+* Fixes to allow LeakCanary to work with ProGuard [#398](https://github.com/square/leakcanary/pull/398).
+* Optimize png assets [#406](https://github.com/square/leakcanary/pull/406).
+* Fix delete button not working on error views [#408](https://github.com/square/leakcanary/pull/408).
+* Add German translation [#437](https://github.com/square/leakcanary/pull/437).
+
+## Version 1.4-beta1 *(2016-01-08)*
+
+* Switched to [HAHA 2.0.2](https://github.com/square/haha/blob/master/CHANGELOG.md#version-202-2015-07-20) with uses Perflib instead of MAT under the hood [#219](https://github.com/square/leakcanary/pull/219). This fixes crashes and improves speed a lot.
+* We can now parse Android M heap dumps [#267](https://github.com/square/leakcanary/issues/267), although there are still memory issues (see [#223](https://github.com/square/leakcanary/issues/223)).
+* Excluded leaks are now reported as well and available in the display leak activity.
+* Added ProGuard configuration for [#132](https://github.com/square/leakcanary/issues/132).
+* Many new ignored Android SDK leaks.
 * Added excluded leaks to text report [#119](https://github.com/square/leakcanary/issues/119).
 * Added LeakCanary SHA to text report [#120](https://github.com/square/leakcanary/issues/120).
+* Added CanaryLog API to replace the logger: [#201](https://github.com/square/leakcanary/issues/201).
 * Renamed all resources to begin with `leak_canary_` instead of `__leak_canary`[#161](https://github.com/square/leakcanary/pull/161)
+* No crash when heap dump fails [#226](https://github.com/square/leakcanary/issues/226).
+* Add retained size to leak reports [#162](https://github.com/square/leakcanary/issues/162).
 
 ### Public API changes
 
@@ -18,28 +91,6 @@
 * Each `ExcludedRef` entry can now be ignored entirely or "kept only if no other path".
 * Added support for ignoring all fields (static and non static) for a given class.
 
-### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-SNAPSHOT'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-SNAPSHOT'
- }
-```
-
-Snapshots are available in Sonatype's `snapshots` repository:
-
-```
-  repositories {
-    mavenCentral()
-    maven {
-      url 'https://oss.sonatype.org/content/repositories/snapshots/'
-    }
-  }
-```
-
-[![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
-
 ## Version 1.3.1 *(2015-05-16)*
 
 * Heap dumps and analysis results are now saved on the sd card: [#21](https://github.com/square/leakcanary/issues/21).
@@ -67,29 +118,8 @@ Snapshots are available in Sonatype's `snapshots` repository:
 * `AndroidExcludedRefs.createAppDefaults()` & `AndroidExcludedRefs.createAndroidDefaults()` return a `ExcludedRef.Builder`.
 * `ExcludedRef` moved from `leakcanary-analyzer` to `leakcanary-watcher`
 
-### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
- }
-```
-
-### Statistics
-
-* 33 commits to the LeakCanary library code and 11 commits to [HAHA](https://github.com/square/haha).
-* 6 contributors: [Pierre-Yves Ricau](https://github.com/square/leakcanary/commits?author=pyricau), [Sergey Shulepov](https://github.com/square/leakcanary/commits?author=pepyakin), [Romain Guy](https://github.com/square/leakcanary/commits?author=romainguy), [liaohuqiu](https://github.com/square/leakcanary/commits?author=liaohuqiu), [Dario Marcato](https://github.com/square/leakcanary/commits?author=dmarcato), [Anders Aagaard](https://github.com/square/leakcanary/commits?author=andaag).
-
 ## Version 1.3 *(2015-05-08)*
 
 Initial release.
 
 ### Dependencies
-
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'
- }
-```
diff --git a/README.md b/README.md
index e5be50c6..0d255506 100644
--- a/README.md
+++ b/README.md
@@ -1,10 +1,13 @@
-#LeakCanary
+
+# LeakCanary
 
 A memory leak detection library for Android and Java.
 
 *“A small leak will sink a great ship.”* - Benjamin Franklin
 
-![screenshot.png](assets/screenshot.png)
+<p align="center">
+<img src="https://github.com/square/leakcanary/blob/master/assets/screenshot.png"/>
+</p>
 
 ## Getting started
 
@@ -12,8 +15,8 @@ In your `build.gradle`:
 
 ```gradle
  dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
-   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5.2'
+   releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.2'
  }
 ```
 
@@ -24,319 +27,52 @@ public class ExampleApplication extends Application {
 
   @Override public void onCreate() {
     super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
     LeakCanary.install(this);
+    // Normal app init code...
   }
 }
 ```
 
-**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
-
-## Why should I use LeakCanary?
-
-Glad you ask! We wrote a [blog post](http://squ.re/leakcanary) to answer precisely that question.
-
-## How do I use it?
-
-Use a `RefWatcher` to watch references that should be GCed:
-
-```java
-RefWatcher refWatcher = {...};
-
-// We expect schrodingerCat to be gone soon (or not), let's watch it.
-refWatcher.watch(schrodingerCat);
-```
-
-`LeakCanary.install()` returns a pre configured `RefWatcher`.
-It also installs an `ActivityRefWatcher` that automatically detects if an activity is leaking after `Activity.onDestroy()` has been called.
-
-```java
-public class ExampleApplication extends Application {
-
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
-
-  private RefWatcher refWatcher;
-
-  @Override public void onCreate() {
-    super.onCreate();
-    refWatcher = LeakCanary.install(this);
-  }
-}
-```
-
-You could use the `RefWatcher` to watch for fragment leaks:
-
-```java
-public abstract class BaseFragment extends Fragment {
-
-  @Override public void onDestroy() {
-    super.onDestroy();
-    RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());
-    refWatcher.watch(this);
-  }
-}
-```
-
-## How does it work?
-
-1. `RefWatcher.watch()` creates a [KeyedWeakReference](https://github.com/square/leakcanary/blob/master/leakcanary-watcher/src/main/java/com/squareup/leakcanary/KeyedWeakReference.java) to the watched object.
-2. Later, in a background thread, it checks if the reference has been cleared and if not it triggers a GC.
-3. If the reference is still not cleared, it then dumps the heap into a `.hprof` file stored on the app file system.
-4. `HeapAnalyzerService` is started in a separate process and `HeapAnalyzer` parses the heap dump using [HAHA](https://github.com/square/haha).
-5. `HeapAnalyzer` finds the `KeyedWeakReference` in the heap dump thanks to a unique reference key and locates the leaking reference.
-6. `HeapAnalyzer` computes the *shortest strong reference path to the GC Roots* to determine if there is a leak, and then builds the chain of references causing the leak.
-7. The result is passed back to `DisplayLeakService` in the app process, and the leak notification is shown.
-
-## How do I copy the leak trace?
-
-You can see the leak trace in Logcat:
-
-```
-In com.example.leakcanary:1.0:1 com.example.leakcanary.MainActivity has leaked:
-* GC ROOT thread java.lang.Thread.<Java Local> (named 'AsyncTask #1')
-* references com.example.leakcanary.MainActivity$3.this$0 (anonymous class extends android.os.AsyncTask)
-* leaks com.example.leakcanary.MainActivity instance
-
-* Reference Key: e71f3bf5-d786-4145-8539-584afaecad1d
-* Device: Genymotion generic Google Nexus 6 - 5.1.0 - API 22 - 1440x2560 vbox86p
-* Android Version: 5.1 API: 22
-* Durations: watch=5086ms, gc=110ms, heap dump=435ms, analysis=2086ms
-```
-
-You can also share the leak trace and the heap dump file from the **action bar menu**.
-
-## How do I fix a memory leak?
-
-Once you have the leak trace, figure out which reference in the path should not exist. Then figure out why that reference still exists. Often times it's a registered listener that should have been unregistered, a `close()` method that wasn't called, an anonymous class that holds a reference an outer class. If you cannot figure out an issue in your code, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) (using the *leakcanary* tag).
-
-## My leak is caused by the Android SDK implementation!
-
-There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.java](https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java).
-
-If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new) and follow these steps:
-
-1. Provide the entire leak trace information (reference key, device, etc).
-2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
-3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
-4. If it's still happening, build a simple repro case
-5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.java`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
-
-This is especially important for **new releases of Android**. You have the opportunity to help detect new memory leaks early on, which benefits the entire Android community. 
-
-## Beyond the leak trace
-
-Sometimes the leak trace isn't enough and you need to dig into the heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/). Here's how you can find the leaking instance in the head dump:
-
-1. Look for all instances of `com.squareup.leakcanary.KeyedWeakReference`
-2. For each of these, look at the `key` field.
-3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
-4. The `referent` field of that `KeyedWeakReference` is your leaking object.
-5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
-
-## Customizing
-
-### Customizing and using the no-op dependency
-
-The `leakcanary-android-no-op` dependency for release builds only contains the `LeakCanary` and `RefWatcher` class. If you start customizing LeakCanary, you need to make sure that the customization happens only in debug build, since it will likely reference classes that do not exist in the `leakcanary-android-no-op` dependency.
-
-Let's say your release build declares an `ExampleApplication` class in `AndroidManifest.xml`, and your debug build declares a `DebugExampleApplication` that extends `ExampleApplication`.
-
-In your shared sources:
+For Robolectric users:
 
 ```java
 public class ExampleApplication extends Application {
 
-  public static RefWatcher getRefWatcher(Context context) {
-    ExampleApplication application = (ExampleApplication) context.getApplicationContext();
-    return application.refWatcher;
-  }
-
-  private RefWatcher refWatcher;
-
   @Override public void onCreate() {
     super.onCreate();
-    refWatcher = installLeakCanary();
-  }
-
-  protected RefWatcher installLeakCanary() {
-    return RefWatcher.DISABLED;
-  }
-}
-```
-
-In your debug sources:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-	RefWatcher refWatcher = ? // Build a customized RefWatcher
-    return refWatcher;
+    setupLeakCanary();
   }
-}
-```
-That way, your release code will contain no reference to LeakCanary other than the two empty classes that exist in the `leakcanary-android-no-op` dependency.
-
-### Icon and label
-
-`DisplayLeakActivity` comes with a default icon and label, which you can change by providing `R.drawable.__leak_canary_icon` and `R.string.__leak_canary_display_activity_label` in your app:
-
-```
-res/
-  drawable-hdpi/
-    __leak_canary_icon.png
-  drawable-mdpi/
-    __leak_canary_icon.png
-  drawable-xhdpi/
-    __leak_canary_icon.png
-  drawable-xxhdpi/
-    __leak_canary_icon.png
-  drawable-xxxhdpi/
-    __leak_canary_icon.png
-```
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="__leak_canary_display_activity_label">MyLeaks</string>
-</resources>
-```
-
-### Stored leak traces
-
-`DisplayLeakActivity` saves up to 7 heap dumps & leak traces in the app directory. You can change that number by providing `R.integer.__leak_canary_max_stored_leaks` in your app:
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <integer name="__leak_canary_max_stored_leaks">20</integer>
-</resources>
-```
-
-### Uploading to a server
-
-You can change the default behavior to upload the leak trace and heap dump to a server of your choosing.
-
-Create your own `AbstractAnalysisResultService`. The easiest way is to extend `DisplayLeakService` in your debug sources:
-
-```java
-public class LeakUploadService extends DisplayLeakService {
-  @Override protected void afterDefaultHandling(HeapDump heapDump, AnalysisResult result, String leakInfo) {
-    if (!result.leakFound || result.excludedLeak) {
+ 
+  protected RefWatcher setupLeakCanary() {
+    if (LeakCanary.isInAnalyzerProcess(this)) {
       return;
     }
-	myServer.uploadLeakBlocking(heapDump.heapDumpFile, leakInfo);
-  }
-}
-```
-
-Build a custom `RefWatcher` in your debug Application class:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    return LeakCanary.install(app, LeakUploadService.class, AndroidExcludedRefs.createAppDefaults().build());
+    return LeakCanary.install(this);
   }
 }
-```
-
-Don't forget to register the service in your debug `AndroidManifest.xml`:
-
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
-    >
-  <application android:name="com.example.DebugExampleApplication">
-    <service android:name="com.example.LeakUploadService" />
-  </application>
-</manifest>
-```
-
-You can also upload the leak traces to Slack or HipChat, [here's an example](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
-
-### Ignoring specific references
-
-You can create your own version of `ExcludedRefs` to ignore specific references that you know are causing leaks but you still want to ignore:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults()
-        .instanceField("com.example.ExampleClass", "exampleField")
-        .build();
-    return LeakCanary.install(this, DisplayLeakService.class, excludedRefs);
-  }
-}
-```
-
-### Not watching specific activity classes
-
-`ActivityRefWatcher` is installed by default and watches all activities. You can customize the installation steps to use something different instead:
-
-```java
-public class DebugExampleApplication extends ExampleApplication {
-  protected RefWatcher installLeakCanary() {
-    if (isInAnalyzerProcess(this)) {
-      return RefWatcher.DISABLED;
-    } else {
-      ExcludedRefs excludedRefs = AndroidExcludedRefs.createAppDefaults().build();
-      enableDisplayLeakActivity(application);
-      ServiceHeapDumpListener heapDumpListener = new ServiceHeapDumpListener(application, DisplayLeakService.class);
-      final RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
-      registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
-        public void onActivityDestroyed(Activity activity) {
-          if (activity instanceof ThirdPartyActivity) {
-              return;
-          }
-          refWatcher.watch(activity);
-        }
-        // ...
-      });
-      return refWatcher;
-    }
+ 
+// in src/test/java
+public class TestExampleApplication extends ExampleApplication {
+  @Override protected RefWatcher setupLeakCanary() {
+    // No leakcanary in unit tests.
+    return RefWatcher.DISABLED;
   }
 }
-```
-
-### ProGuard
 
-If you use Proguard in your debug builds, make sure to keep the HAHA and LeakCanary classes:
-
-```
-# LeakCanary
--keep class org.eclipse.mat.** { *; }
--keep class com.squareup.leakcanary.** { *; }
 ```
 
-## Snapshots of the development version
-
-See the [CHANGELOG](https://github.com/square/leakcanary/blob/master/CHANGELOG.md).
-
-## Troubleshooting
-
-* if `leakcanary-android` is not in the list of external libraries in Android Studio, but `leakcanary-analyzer` and `leakcanary-watcher` are there: try doing a `Clean Build`. If it's still a problem, try building from the command line.
-* `error: package com.squareup.leakcanary does not exist`: if you have other build types than `debug` and `release`, you need to add a specific dependency for those too (`xxxCompile`).
-
-## Resources
-
-* LeakCanary: Detect all memory leaks! [squ.re/leakcanary](http://squ.re/leakcanary).
-* Wrangling Dalvik series: [Memory management in Android](http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/).
-* Uploading leak traces to a [Slack or HipChat channel](https://gist.github.com/pyricau/06c2c486d24f5f85f7f0).
-* Dump the heap on [OutOfMemoryError crashes](https://gist.github.com/pyricau/4726389fd64f3b7c6f32).
-* StackOverflow: [leakcanary tag](http://stackoverflow.com/questions/tagged/leakcanary).
-
-### Translations
-
-* squ.re/leakcanary [in Chinese](http://www.liaohuqiu.net/cn/posts/leak-canary/).
-* squ.re/leakcanary [in Russian](http://habrahabr.ru/post/257633/).
-* `README.md` in Chinese: [中文版说明](http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/).
+**You're good to go!** LeakCanary will automatically show a notification when an activity memory leak is detected in your debug build.
 
-![icon_512.png](assets/icon_512.png)
+Questions? Check out [the FAQ](https://github.com/square/leakcanary/wiki/FAQ)!
 
-The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+<p align="center">
+<img src="https://github.com/square/leakcanary/blob/master/assets/icon_512.png" width="250"/>
+</p>
 
 ## License
 
diff --git a/assets/icon_1024.png b/assets/icon_1024.png
index 5dfdcf84..f15c7586 100644
Binary files a/assets/icon_1024.png and b/assets/icon_1024.png differ
diff --git a/assets/icon_512.png b/assets/icon_512.png
index bb24dbad..0ca6bedf 100644
Binary files a/assets/icon_512.png and b/assets/icon_512.png differ
diff --git a/assets/screenshot.png b/assets/screenshot.png
index f68053b6..8faa278f 100644
Binary files a/assets/screenshot.png and b/assets/screenshot.png differ
diff --git a/assets/source_icon.png b/assets/source_icon.png
index 827e5552..d04aace6 100644
Binary files a/assets/source_icon.png and b/assets/source_icon.png differ
diff --git a/build.gradle b/build.gradle
index 6f0281ca..cbd24b8f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,32 +1,52 @@
-subprojects {
+buildscript {
+  repositories {
+    jcenter()
+    google()
+    maven { url 'https://plugins.gradle.org/m2/' }
+  }
+  dependencies {
+    classpath 'com.android.tools.build:gradle:3.0.0-alpha9'
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.10'
+  }
+}
 
+subprojects {
   repositories {
-    mavenCentral()
+    jcenter()
 //    maven {
 //      url 'https://oss.sonatype.org/content/repositories/snapshots/'
 //    }
 //    mavenLocal()
   }
 
-  buildscript {
-    repositories {
-      mavenCentral()
-    }
-    dependencies {
-      classpath 'com.android.tools.build:gradle:1.2.3'
+  apply plugin: 'net.ltgt.errorprone'
+
+  tasks.withType(JavaCompile) {
+    options.compilerArgs += ['-Xlint:all',
+                             '-Xlint:-serial',
+                             '-Xlint:-deprecation',
+                             '-Werror']
+  }
+
+  tasks.withType(Test) {
+    testLogging {
+      exceptionFormat 'FULL'
+      showCauses true
+      showExceptions true
+      showStackTraces true
     }
   }
 }
 
 ext {
-  minSdkVersion = 8
-  compileSdkVersion = 21
+  minSdkVersion = 14
+  compileSdkVersion = 26
   targetSdkVersion = compileSdkVersion
-  buildToolsVersion = '21.1.2'
+  buildToolsVersion = '26.0.0'
   javaVersion = JavaVersion.VERSION_1_7
 
   GROUP = 'com.squareup.leakcanary'
-  VERSION_NAME = "1.4-SNAPSHOT"
+  VERSION_NAME = "1.6-SNAPSHOT"
   POM_PACKAGING = "pom"
   POM_DESCRIPTION= "Leak Canary"
 
diff --git a/checkstyle.xml b/checkstyle.xml
index 7fb7ad32..d6b359fe 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -72,7 +72,9 @@
     <module name="AvoidStarImport"/>
     <module name="IllegalImport"/>
     <module name="RedundantImport"/>
-    <module name="UnusedImports"/>
+    <module name="UnusedImports">
+      <property name="processJavadoc" value="true"/>
+    </module>
 
 
     <!-- Checks for Size Violations.                    -->
@@ -145,4 +147,4 @@
     <!--module name="TodoComment"/-->
     <module name="UpperEll"/>
   </module>
-</module>
\ No newline at end of file
+</module>
diff --git a/gradle/gradle-mvn-push.gradle b/gradle/gradle-mvn-push.gradle
index 01938b95..32763c86 100644
--- a/gradle/gradle-mvn-push.gradle
+++ b/gradle/gradle-mvn-push.gradle
@@ -16,11 +16,11 @@ def getSnapshotRepositoryUrl() {
 }
 
 def getRepositoryUsername() {
-    return hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ""
+    return hasProperty('SONATYPE_NEXUS_USERNAME') ? SONATYPE_NEXUS_USERNAME : ""
 }
 
 def getRepositoryPassword() {
-    return hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ""
+    return hasProperty('SONATYPE_NEXUS_PASSWORD') ? SONATYPE_NEXUS_PASSWORD : ""
 }
 
 afterEvaluate { project ->
@@ -93,6 +93,14 @@ afterEvaluate { project ->
         from android.sourceSets.main.java.sourceFiles
     }
 
+    if (JavaVersion.current().isJava8Compatible()) {
+        allprojects {
+            tasks.withType(Javadoc) {
+                options.addStringOption('Xdoclint:none', '-quiet')
+            }
+        }
+    }
+
     artifacts {
         archives androidSourcesJar
         archives androidJavadocsJar
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 58385981..7a3265ee 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 80081ab8..f16d2666 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Wed Feb 04 10:58:17 PST 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-bin.zip
diff --git a/gradlew b/gradlew
index 91a7e269..cccdd3d5 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,31 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# For Cygwin, ensure paths are in UNIX format before anything is touched.
-if $cygwin ; then
-    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
-fi
-
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >&-
-APP_HOME="`pwd -P`"
-cd "$SAVED" >&-
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -90,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -114,6 +113,7 @@ fi
 if $cygwin ; then
     APP_HOME=`cygpath --path --mixed "$APP_HOME"`
     CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
 
     # We build the pattern for arguments to be converted via cygpath
     ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/leakcanary-analyzer/build.gradle b/leakcanary-analyzer/build.gradle
index c12cab76..6cfe8411 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/leakcanary-analyzer/build.gradle
@@ -14,9 +14,10 @@ repositories {
 }
 
 dependencies {
-  compile 'com.squareup.haha:haha:2.0.2'
-  compile project(':leakcanary-watcher')
-  testCompile 'junit:junit:4.12'
+  implementation 'com.squareup.haha:haha:2.0.3'
+  api project(':leakcanary-watcher')
+  testImplementation 'junit:junit:4.12'
+  testImplementation 'org.assertj:assertj-core:3.8.0'
 }
 
 android.libraryVariants.all { variant ->
@@ -30,23 +31,14 @@ android.libraryVariants.all { variant ->
   artifacts.add('archives', task);
 }
 
-
-// See: https://code.google.com/p/android/issues/detail?id=64887#c13
-task copyTestResources(type: Copy) {
-  from "${projectDir}/src/test/resources"
-  into "${buildDir}/classes/test"
-}
-
-afterEvaluate { project ->
-  testDebug.dependsOn copyTestResources
-}
-
 android {
   compileSdkVersion rootProject.ext.compileSdkVersion
   buildToolsVersion rootProject.ext.buildToolsVersion
   defaultConfig {
     minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
   }
 }
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
index 8376943a..4c8270c1 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/AnalysisResult.java
@@ -20,16 +20,17 @@
 public final class AnalysisResult implements Serializable {
 
   public static AnalysisResult noLeak(long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, null, analysisDurationMs);
+    return new AnalysisResult(false, false, null, null, null, 0, analysisDurationMs);
   }
 
   public static AnalysisResult leakDetected(boolean excludedLeak, String className,
-      LeakTrace leakTrace, long analysisDurationMs) {
-    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, analysisDurationMs);
+      LeakTrace leakTrace, long retainedHeapSize, long analysisDurationMs) {
+    return new AnalysisResult(true, excludedLeak, className, leakTrace, null, retainedHeapSize,
+        analysisDurationMs);
   }
 
   public static AnalysisResult failure(Throwable failure, long analysisDurationMs) {
-    return new AnalysisResult(false, false, null, null, failure, analysisDurationMs);
+    return new AnalysisResult(false, false, null, null, failure, 0, analysisDurationMs);
   }
 
   /** True if a leak was found in the heap dump. */
@@ -56,16 +57,23 @@ public static AnalysisResult failure(Throwable failure, long analysisDurationMs)
   /** Null unless the analysis failed. */
   public final Throwable failure;
 
+  /**
+   * The number of bytes which would be freed if all references to the leaking object were
+   * released. 0 if {@link #leakFound} is false.
+   */
+  public final long retainedHeapSize;
+
   /** Total time spent analyzing the heap. */
   public final long analysisDurationMs;
 
   private AnalysisResult(boolean leakFound, boolean excludedLeak, String className,
-      LeakTrace leakTrace, Throwable failure, long analysisDurationMs) {
+      LeakTrace leakTrace, Throwable failure, long retainedHeapSize, long analysisDurationMs) {
     this.leakFound = leakFound;
     this.excludedLeak = excludedLeak;
     this.className = className;
     this.leakTrace = leakTrace;
     this.failure = failure;
+    this.retainedHeapSize = retainedHeapSize;
     this.analysisDurationMs = analysisDurationMs;
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
index d281056b..a651572d 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HahaHelper.java
@@ -19,9 +19,11 @@
 import com.squareup.haha.perflib.ClassInstance;
 import com.squareup.haha.perflib.ClassObj;
 import com.squareup.haha.perflib.Field;
-import com.squareup.haha.perflib.Heap;
 import com.squareup.haha.perflib.Instance;
 import com.squareup.haha.perflib.Type;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.nio.charset.Charset;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -52,6 +54,11 @@ static String fieldToString(Field field, Object value) {
   static String threadName(Instance holder) {
     List<ClassInstance.FieldValue> values = classInstanceValues(holder);
     Object nameField = fieldValue(values, "name");
+    if (nameField == null) {
+      // Sometimes we can't find the String at the expected memory address in the heap dump.
+      // See https://github.com/square/leakcanary/issues/417 .
+      return "Thread name not available";
+    }
     return asString(nameField);
   }
 
@@ -73,37 +80,52 @@ static String asString(Object stringObject) {
     List<ClassInstance.FieldValue> values = classInstanceValues(instance);
 
     Integer count = fieldValue(values, "count");
-    Object value = fieldValue(values, "value");
-    Integer offset;
-    ArrayInstance charArray;
-    if (isCharArray(value)) {
-      charArray = (ArrayInstance) value;
-      offset = fieldValue(values, "offset");
-    } else {
-      // In M preview 2+, the underlying char buffer resides in the heap with ID equalling the
-      // String's ID + 16.
-      // https://android-review.googlesource.com/#/c/160380/2/android/src/com/android/tools/idea/
-      // editors/hprof/descriptors/InstanceFieldDescriptorImpl.java
-      Heap heap = instance.getHeap();
-      Instance inlineInstance = heap.getInstance(instance.getId() + 16);
-      if (isCharArray(inlineInstance)) {
-        charArray = (ArrayInstance) inlineInstance;
-        offset = 0;
-      } else {
-        throw new UnsupportedOperationException("Could not find char array in " + instance);
-      }
-    }
     checkNotNull(count, "count");
-    checkNotNull(charArray, "charArray");
-    checkNotNull(offset, "offset");
-
     if (count == 0) {
       return "";
     }
 
-    char[] chars = charArray.asCharArray(offset, count);
+    Object value = fieldValue(values, "value");
+    checkNotNull(value, "value");
+
+    Integer offset;
+    ArrayInstance array;
+    if (isCharArray(value)) {
+      array = (ArrayInstance) value;
+
+      offset = 0;
+      // < API 23
+      // As of Marshmallow, substrings no longer share their parent strings' char arrays
+      // eliminating the need for String.offset
+      // https://android-review.googlesource.com/#/c/83611/
+      if (hasField(values, "offset")) {
+        offset = fieldValue(values, "offset");
+        checkNotNull(offset, "offset");
+      }
 
-    return new String(chars);
+      char[] chars = array.asCharArray(offset, count);
+      return new String(chars);
+    } else if (isByteArray(value)) {
+      // In API 26, Strings are now internally represented as byte arrays.
+      array = (ArrayInstance) value;
+
+      // HACK - remove when HAHA's perflib is updated to https://goo.gl/Oe7ZwO.
+      try {
+        Method asRawByteArray =
+            ArrayInstance.class.getDeclaredMethod("asRawByteArray", int.class, int.class);
+        asRawByteArray.setAccessible(true);
+        byte[] rawByteArray = (byte[]) asRawByteArray.invoke(array, 0, count);
+        return new String(rawByteArray, Charset.forName("UTF-8"));
+      } catch (NoSuchMethodException e) {
+        throw new RuntimeException(e);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      }
+    } else {
+      throw new UnsupportedOperationException("Could not find char array in " + instance);
+    }
   }
 
   public static boolean isPrimitiveWrapper(Object value) {
@@ -128,21 +150,35 @@ private static boolean isCharArray(Object value) {
     return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.CHAR;
   }
 
+  private static boolean isByteArray(Object value) {
+    return value instanceof ArrayInstance && ((ArrayInstance) value).getArrayType() == Type.BYTE;
+  }
+
   static List<ClassInstance.FieldValue> classInstanceValues(Instance instance) {
     ClassInstance classInstance = (ClassInstance) instance;
     return classInstance.getValues();
   }
 
+  @SuppressWarnings({ "unchecked", "TypeParameterUnusedInFormals" })
   static <T> T fieldValue(List<ClassInstance.FieldValue> values, String fieldName) {
     for (ClassInstance.FieldValue fieldValue : values) {
       if (fieldValue.getField().getName().equals(fieldName)) {
-        //noinspection unchecked
         return (T) fieldValue.getValue();
       }
     }
     throw new IllegalArgumentException("Field " + fieldName + " does not exists");
   }
 
+  static boolean hasField(List<ClassInstance.FieldValue> values, String fieldName) {
+    for (ClassInstance.FieldValue fieldValue : values) {
+      if (fieldValue.getField().getName().equals(fieldName)) {
+        //noinspection unchecked
+        return true;
+      }
+    }
+    return false;
+  }
+
   private HahaHelper() {
     throw new AssertionError();
   }
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
index c688bc2c..74ec6918 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/HeapAnalyzer.java
@@ -22,15 +22,21 @@
 import com.squareup.haha.perflib.HprofParser;
 import com.squareup.haha.perflib.Instance;
 import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.RootType;
 import com.squareup.haha.perflib.Snapshot;
 import com.squareup.haha.perflib.Type;
 import com.squareup.haha.perflib.io.HprofBuffer;
 import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;
+import com.squareup.haha.trove.THashMap;
+import com.squareup.haha.trove.TObjectProcedure;
 import java.io.File;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.N_MR1;
 import static com.squareup.leakcanary.AnalysisResult.failure;
 import static com.squareup.leakcanary.AnalysisResult.leakDetected;
 import static com.squareup.leakcanary.AnalysisResult.noLeak;
@@ -39,6 +45,7 @@
 import static com.squareup.leakcanary.HahaHelper.extendsThread;
 import static com.squareup.leakcanary.HahaHelper.fieldToString;
 import static com.squareup.leakcanary.HahaHelper.fieldValue;
+import static com.squareup.leakcanary.HahaHelper.hasField;
 import static com.squareup.leakcanary.HahaHelper.threadName;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.ARRAY;
 import static com.squareup.leakcanary.LeakTraceElement.Holder.CLASS;
@@ -59,6 +66,36 @@ public HeapAnalyzer(ExcludedRefs excludedRefs) {
     this.excludedRefs = excludedRefs;
   }
 
+  public List<TrackedReference> findTrackedReferences(File heapDumpFile) {
+    if (!heapDumpFile.exists()) {
+      throw new IllegalArgumentException("File does not exist: " + heapDumpFile);
+    }
+    try {
+      HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
+      HprofParser parser = new HprofParser(buffer);
+      Snapshot snapshot = parser.parse();
+      deduplicateGcRoots(snapshot);
+
+      ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
+      List<TrackedReference> references = new ArrayList<>();
+      for (Instance weakRef : refClass.getInstancesList()) {
+        List<ClassInstance.FieldValue> values = classInstanceValues(weakRef);
+        String key = asString(fieldValue(values, "key"));
+        String name =
+            hasField(values, "name") ? asString(fieldValue(values, "name")) : "(No name field)";
+        Instance instance = fieldValue(values, "referent");
+        if (instance != null) {
+          String className = getClassName(instance);
+          List<String> fields = describeFields(instance);
+          references.add(new TrackedReference(key, name, className, fields));
+        }
+      }
+      return references;
+    } catch (Throwable e) {
+      throw new RuntimeException(e);
+    }
+  }
+
   /**
    * Searches the heap dump for a {@link KeyedWeakReference} instance with the corresponding key,
    * and then computes the shortest strong reference path from that instance to the GC roots.
@@ -75,6 +112,7 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
       HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
       HprofParser parser = new HprofParser(buffer);
       Snapshot snapshot = parser.parse();
+      deduplicateGcRoots(snapshot);
 
       Instance leakingRef = findLeakingReference(referenceKey, snapshot);
 
@@ -89,6 +127,34 @@ public AnalysisResult checkForLeak(File heapDumpFile, String referenceKey) {
     }
   }
 
+  /**
+   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
+   */
+  void deduplicateGcRoots(Snapshot snapshot) {
+    // THashMap has a smaller memory footprint than HashMap.
+    final THashMap<String, RootObj> uniqueRootMap = new THashMap<>();
+
+    final Collection<RootObj> gcRoots = snapshot.getGCRoots();
+    for (RootObj root : gcRoots) {
+      String key = generateRootKey(root);
+      if (!uniqueRootMap.containsKey(key)) {
+        uniqueRootMap.put(key, root);
+      }
+    }
+
+    // Repopulate snapshot with unique GC roots.
+    gcRoots.clear();
+    uniqueRootMap.forEach(new TObjectProcedure<String>() {
+      @Override public boolean execute(String key) {
+        return gcRoots.add(uniqueRootMap.get(key));
+      }
+    });
+  }
+
+  private String generateRootKey(RootObj root) {
+    return String.format("%s@0x%08x", root.getRootType().getName(), root.getId());
+  }
+
   private Instance findLeakingReference(String key, Snapshot snapshot) {
     ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());
     List<String> keysFound = new ArrayList<>();
@@ -119,14 +185,80 @@ private AnalysisResult findLeakTrace(long analysisStartNanoTime, Snapshot snapsh
 
     String className = leakingRef.getClassObj().getClassName();
 
-    return leakDetected(result.excludingKnownLeaks, className, leakTrace,
+    // Side effect: computes retained size.
+    snapshot.computeDominators();
+
+    Instance leakingInstance = result.leakingNode.instance;
+
+    long retainedSize = leakingInstance.getTotalRetainedSize();
+
+    // TODO: check O sources and see what happened to android.graphics.Bitmap.mBuffer
+    if (SDK_INT <= N_MR1) {
+      retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);
+    }
+
+    return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
         since(analysisStartNanoTime));
   }
 
+  /**
+   * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
+   * in the retained size because their root dominator is a native gc root.
+   * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
+   * add the bitmap size.
+   *
+   * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
+   * accounted for, however bitmaps set in layouts are not.
+   */
+  private long computeIgnoredBitmapRetainedSize(Snapshot snapshot, Instance leakingInstance) {
+    long bitmapRetainedSize = 0;
+    ClassObj bitmapClass = snapshot.findClass("android.graphics.Bitmap");
+
+    for (Instance bitmapInstance : bitmapClass.getInstancesList()) {
+      if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
+        ArrayInstance mBufferInstance = fieldValue(classInstanceValues(bitmapInstance), "mBuffer");
+        // Native bitmaps have mBuffer set to null. We sadly can't account for them.
+        if (mBufferInstance == null) {
+          continue;
+        }
+        long bufferSize = mBufferInstance.getTotalRetainedSize();
+        long bitmapSize = bitmapInstance.getTotalRetainedSize();
+        // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
+        // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
+        if (bitmapSize < bufferSize) {
+          bitmapSize += bufferSize;
+        }
+        bitmapRetainedSize += bitmapSize;
+      }
+    }
+    return bitmapRetainedSize;
+  }
+
+  private boolean isIgnoredDominator(Instance dominator, Instance instance) {
+    boolean foundNativeRoot = false;
+    while (true) {
+      Instance immediateDominator = instance.getImmediateDominator();
+      if (immediateDominator instanceof RootObj
+          && ((RootObj) immediateDominator).getRootType() == RootType.UNKNOWN) {
+        // Ignore native roots
+        instance = instance.getNextInstanceToGcRoot();
+        foundNativeRoot = true;
+      } else {
+        instance = immediateDominator;
+      }
+      if (instance == null) {
+        return false;
+      }
+      if (instance == dominator) {
+        return foundNativeRoot;
+      }
+    }
+  }
+
   private LeakTrace buildLeakTrace(LeakNode leakingNode) {
     List<LeakTraceElement> elements = new ArrayList<>();
     // We iterate from the leak to the GC root
-    LeakNode node = new LeakNode(null, leakingNode, null, null);
+    LeakNode node = new LeakNode(null, null, leakingNode, null, null);
     while (node != null) {
       LeakTraceElement element = buildLeakElement(node);
       if (element != null) {
@@ -153,37 +285,16 @@ private LeakTraceElement buildLeakElement(LeakNode node) {
     LeakTraceElement.Holder holderType;
     String className;
     String extra = null;
-    List<String> fields = new ArrayList<>();
+    List<String> fields = describeFields(holder);
+
+    className = getClassName(holder);
+
     if (holder instanceof ClassObj) {
-      ClassObj classObj = (ClassObj) holder;
       holderType = CLASS;
-      className = classObj.getClassName();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        Field field = entry.getKey();
-        Object value = entry.getValue();
-        fields.add("static " + field.getName() + " = " + value);
-      }
     } else if (holder instanceof ArrayInstance) {
-      ArrayInstance arrayInstance = (ArrayInstance) holder;
       holderType = ARRAY;
-      className = arrayInstance.getClassObj().getClassName();
-      if (arrayInstance.getArrayType() == Type.OBJECT) {
-        Object[] values = arrayInstance.getValues();
-        for (int i = 0; i < values.length; i++) {
-          fields.add("[" + i + "] = " + values[i]);
-        }
-      }
     } else {
-      ClassInstance classInstance = (ClassInstance) holder;
       ClassObj classObj = holder.getClassObj();
-      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
-        fields.add("static " + fieldToString(entry));
-      }
-      for (ClassInstance.FieldValue field : classInstance.getValues()) {
-        fields.add(fieldToString(field));
-      }
-      className = classObj.getClassName();
-
       if (extendsThread(classObj)) {
         holderType = THREAD;
         String threadName = threadName(holder);
@@ -192,25 +303,77 @@ private LeakTraceElement buildLeakElement(LeakNode node) {
         String parentClassName = classObj.getSuperClassObj().getClassName();
         if (Object.class.getName().equals(parentClassName)) {
           holderType = OBJECT;
-          // This is an anonymous class implementing an interface. The API does not give access
-          // to the interfaces implemented by the class. Let's see if it's in the class path and
-          // use that instead.
           try {
+            // This is an anonymous class implementing an interface. The API does not give access
+            // to the interfaces implemented by the class. We check if it's in the class path and
+            // use that instead.
             Class<?> actualClass = Class.forName(classObj.getClassName());
-            Class<?> implementedInterface = actualClass.getInterfaces()[0];
-            extra = "(anonymous class implements " + implementedInterface.getName() + ")";
+            Class<?>[] interfaces = actualClass.getInterfaces();
+            if (interfaces.length > 0) {
+              Class<?> implementedInterface = interfaces[0];
+              extra = "(anonymous implementation of " + implementedInterface.getName() + ")";
+            } else {
+              extra = "(anonymous subclass of java.lang.Object)";
+            }
           } catch (ClassNotFoundException ignored) {
           }
         } else {
           holderType = OBJECT;
           // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous class extends " + parentClassName + ")";
+          extra = "(anonymous subclass of " + parentClassName + ")";
         }
       } else {
         holderType = OBJECT;
       }
     }
-    return new LeakTraceElement(referenceName, type, holderType, className, extra, fields);
+    return new LeakTraceElement(referenceName, type, holderType, className, extra, node.exclusion,
+        fields);
+  }
+
+  private List<String> describeFields(Instance instance) {
+    List<String> fields = new ArrayList<>();
+
+    if (instance instanceof ClassObj) {
+      ClassObj classObj = (ClassObj) instance;
+      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+        Field field = entry.getKey();
+        Object value = entry.getValue();
+        fields.add("static " + field.getName() + " = " + value);
+      }
+    } else if (instance instanceof ArrayInstance) {
+      ArrayInstance arrayInstance = (ArrayInstance) instance;
+      if (arrayInstance.getArrayType() == Type.OBJECT) {
+        Object[] values = arrayInstance.getValues();
+        for (int i = 0; i < values.length; i++) {
+          fields.add("[" + i + "] = " + values[i]);
+        }
+      }
+    } else {
+      ClassObj classObj = instance.getClassObj();
+      for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
+        fields.add("static " + fieldToString(entry));
+      }
+      ClassInstance classInstance = (ClassInstance) instance;
+      for (ClassInstance.FieldValue field : classInstance.getValues()) {
+        fields.add(fieldToString(field));
+      }
+    }
+    return fields;
+  }
+
+  private String getClassName(Instance instance) {
+    String className;
+    if (instance instanceof ClassObj) {
+      ClassObj classObj = (ClassObj) instance;
+      className = classObj.getClassName();
+    } else if (instance instanceof ArrayInstance) {
+      ArrayInstance arrayInstance = (ArrayInstance) instance;
+      className = arrayInstance.getClassObj().getClassName();
+    } else {
+      ClassObj classObj = instance.getClassObj();
+      className = classObj.getClassName();
+    }
+    return className;
   }
 
   private long since(long analysisStartNanoTime) {
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
index 69ec8717..b30df278 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakNode.java
@@ -18,13 +18,16 @@
 import com.squareup.haha.perflib.Instance;
 
 final class LeakNode {
+  /** May be null. */
+  final Exclusion exclusion;
   final Instance instance;
   final LeakNode parent;
   final String referenceName;
   final LeakTraceElement.Type referenceType;
 
-  LeakNode(Instance instance, LeakNode parent, String referenceName,
-      LeakTraceElement.Type referenceType) {
+  LeakNode(Exclusion exclusion, Instance instance, LeakNode parent,
+      String referenceName, LeakTraceElement.Type referenceType) {
+    this.exclusion = exclusion;
     this.instance = instance;
     this.parent = parent;
     this.referenceName = referenceName;
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
index 02f85f64..89ef31e3 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/LeakTraceElement.java
@@ -48,16 +48,20 @@
   /** Additional information, may be null. */
   public final String extra;
 
+  /** If not null, there was no path that could exclude this element. */
+  public final Exclusion exclusion;
+
   /** List of all fields (member and static) for that object. */
   public final List<String> fields;
 
   LeakTraceElement(String referenceName, Type type, Holder holder, String className, String extra,
-      List<String> fields) {
+      Exclusion exclusion, List<String> fields) {
     this.referenceName = referenceName;
     this.type = type;
     this.holder = holder;
     this.className = className;
     this.extra = extra;
+    this.exclusion = exclusion;
     this.fields = unmodifiableList(new ArrayList<>(fields));
   }
 
@@ -83,6 +87,11 @@
     if (extra != null) {
       string += " " + extra;
     }
+
+    if (exclusion != null) {
+      string += " , matching exclusion " + exclusion.matching;
+    }
+
     return string;
   }
 
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
index 134c5e41..e9c49d43 100644
--- a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/ShortestPathFinder.java
@@ -89,6 +89,9 @@ Result findPath(Snapshot snapshot, Instance leakingRef) {
         node = toVisitQueue.poll();
       } else {
         node = toVisitIfNoPathQueue.poll();
+        if (node.exclusion == null) {
+          throw new IllegalStateException("Expected node to have an exclusion " + node);
+        }
         excludingKnownLeaks = true;
       }
 
@@ -131,9 +134,9 @@ private void enqueueGcRoots(Snapshot snapshot) {
         case JAVA_LOCAL:
           Instance thread = HahaSpy.allocatingThread(rootObj);
           String threadName = threadName(thread);
-          Boolean alwaysIgnore = excludedRefs.threadNames.get(threadName);
-          if (alwaysIgnore == null || !alwaysIgnore) {
-            enqueue(alwaysIgnore == null, null, rootObj, null, null);
+          Exclusion params = excludedRefs.threadNames.get(threadName);
+          if (params == null || !params.alwaysExclude) {
+            enqueue(params, null, rootObj, null, null);
           }
           break;
         case INTERNED_STRING:
@@ -160,7 +163,7 @@ private void enqueueGcRoots(Snapshot snapshot) {
           // Input or output parameters in native code.
         case NATIVE_STACK:
         case JAVA_STATIC:
-          enqueue(true, null, rootObj, null, null);
+          enqueue(null, null, rootObj, null, null);
           break;
         default:
           throw new UnsupportedOperationException("Unknown root type:" + rootObj.getRootType());
@@ -180,16 +183,20 @@ private void visitRootObj(LeakNode node) {
       Instance holder = HahaSpy.allocatingThread(rootObj);
       // We switch the parent node with the thread instance that holds
       // the local reference.
-      LeakNode parent = new LeakNode(holder, null, null, null);
-      enqueue(true, parent, child, "<Java Local>", LOCAL);
+      Exclusion exclusion = null;
+      if (node.exclusion != null) {
+        exclusion = node.exclusion;
+      }
+      LeakNode parent = new LeakNode(null, holder, null, null, null);
+      enqueue(exclusion, parent, child, "<Java Local>", LOCAL);
     } else {
-      enqueue(true, node, child, null, null);
+      enqueue(null, node, child, null, null);
     }
   }
 
   private void visitClassObj(LeakNode node) {
     ClassObj classObj = (ClassObj) node.instance;
-    Map<String, Boolean> ignoredStaticFields =
+    Map<String, Exclusion> ignoredStaticFields =
         excludedRefs.staticFieldNameByClassName.get(classObj.getClassName());
     for (Map.Entry<Field, Object> entry : classObj.getStaticFieldValues().entrySet()) {
       Field field = entry.getKey();
@@ -203,72 +210,60 @@ private void visitClassObj(LeakNode node) {
       Instance child = (Instance) entry.getValue();
       boolean visit = true;
       if (ignoredStaticFields != null) {
-        Boolean alwaysIgnore = ignoredStaticFields.get(fieldName);
-        if (alwaysIgnore != null) {
+        Exclusion params = ignoredStaticFields.get(fieldName);
+        if (params != null) {
           visit = false;
-          if (!alwaysIgnore) {
-            enqueue(false, node, child, fieldName, STATIC_FIELD);
+          if (!params.alwaysExclude) {
+            enqueue(params, node, child, fieldName, STATIC_FIELD);
           }
         }
       }
       if (visit) {
-        enqueue(true, node, child, fieldName, STATIC_FIELD);
+        enqueue(null, node, child, fieldName, STATIC_FIELD);
       }
     }
   }
 
   private void visitClassInstance(LeakNode node) {
     ClassInstance classInstance = (ClassInstance) node.instance;
-    Map<String, Boolean> ignoredFields = null;
+    Map<String, Exclusion> ignoredFields = new LinkedHashMap<>();
     ClassObj superClassObj = classInstance.getClassObj();
-    Boolean alwaysIgnoreClassHierarchy = null;
+    Exclusion classExclusion = null;
     while (superClassObj != null) {
-      Boolean alwaysIgnoreClass = excludedRefs.classNames.get(superClassObj.getClassName());
-      if (alwaysIgnoreClass != null) {
+      Exclusion params = excludedRefs.classNames.get(superClassObj.getClassName());
+      if (params != null) {
         // true overrides null or false.
-        if (alwaysIgnoreClassHierarchy == null || !alwaysIgnoreClassHierarchy) {
-          alwaysIgnoreClassHierarchy = alwaysIgnoreClass;
+        if (classExclusion == null || !classExclusion.alwaysExclude) {
+          classExclusion = params;
         }
       }
-      Map<String, Boolean> classIgnoredFields =
+      Map<String, Exclusion> classIgnoredFields =
           excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());
       if (classIgnoredFields != null) {
-        if (ignoredFields == null) {
-          ignoredFields = new LinkedHashMap<>();
-        }
         ignoredFields.putAll(classIgnoredFields);
       }
       superClassObj = superClassObj.getSuperClassObj();
     }
 
-    if (alwaysIgnoreClassHierarchy != null && alwaysIgnoreClassHierarchy) {
+    if (classExclusion != null && classExclusion.alwaysExclude) {
       return;
     }
 
     for (ClassInstance.FieldValue fieldValue : classInstance.getValues()) {
+      Exclusion fieldExclusion = classExclusion;
       Field field = fieldValue.getField();
       if (field.getType() != Type.OBJECT) {
         continue;
       }
       Instance child = (Instance) fieldValue.getValue();
-      boolean visit = true;
-      boolean visitIfNoPath = false;
-      // We don't even get here if alwaysIgnoreClassHierarchy is false.
-      if (alwaysIgnoreClassHierarchy != null) {
-        visit = false;
-        visitIfNoPath = true;
-      }
       String fieldName = field.getName();
-      if (ignoredFields != null) {
-        Boolean alwaysIgnore = ignoredFields.get(fieldName);
-        if (alwaysIgnore != null) {
-          visit = false;
-          visitIfNoPath = !alwaysIgnore;
-        }
-      }
-      if (visit || visitIfNoPath) {
-        enqueue(visit, node, child, fieldName, INSTANCE_FIELD);
+      Exclusion params = ignoredFields.get(fieldName);
+      // If we found a field exclusion and it's stronger than a class exclusion
+      if (params != null && (fieldExclusion == null || (params.alwaysExclude
+          && !fieldExclusion.alwaysExclude))) {
+        fieldExclusion = params;
       }
+      enqueue(fieldExclusion, node, child, fieldName, INSTANCE_FIELD);
     }
   }
 
@@ -279,12 +274,12 @@ private void visitArrayInstance(LeakNode node) {
       Object[] values = arrayInstance.getValues();
       for (int i = 0; i < values.length; i++) {
         Instance child = (Instance) values[i];
-        enqueue(true, node, child, "[" + i + "]", ARRAY_ENTRY);
+        enqueue(null, node, child, "[" + i + "]", ARRAY_ENTRY);
       }
     }
   }
 
-  private void enqueue(boolean visitNow, LeakNode parent, Instance child, String referenceName,
+  private void enqueue(Exclusion exclusion, LeakNode parent, Instance child, String referenceName,
       LeakTraceElement.Type referenceType) {
     if (child == null) {
       return;
@@ -296,6 +291,7 @@ private void enqueue(boolean visitNow, LeakNode parent, Instance child, String r
     if (toVisitSet.contains(child)) {
       return;
     }
+    boolean visitNow = exclusion == null;
     if (!visitNow && toVisitIfNoPathSet.contains(child)) {
       return;
     }
@@ -305,7 +301,7 @@ private void enqueue(boolean visitNow, LeakNode parent, Instance child, String r
     if (visitedSet.contains(child)) {
       return;
     }
-    LeakNode childNode = new LeakNode(child, parent, referenceName, referenceType);
+    LeakNode childNode = new LeakNode(exclusion, child, parent, referenceName, referenceType);
     if (visitNow) {
       toVisitSet.add(child);
       toVisitQueue.add(childNode);
diff --git a/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
new file mode 100644
index 00000000..61990d16
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/com/squareup/leakcanary/TrackedReference.java
@@ -0,0 +1,31 @@
+package com.squareup.leakcanary;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * An instance tracked by a {@link KeyedWeakReference} that hadn't been cleared when the
+ * heap was dumped. May or may not point to a leaking reference.
+ */
+public class TrackedReference {
+
+  /** Corresponds to {@link KeyedWeakReference#key}. */
+  public final String key;
+
+  /** Corresponds to {@link KeyedWeakReference#name}. */
+  public final String name;
+
+  /** Class of the tracked instance. */
+  public final String className;
+
+  /** List of all fields (member and static) for that instance. */
+  public final List<String> fields;
+
+  public TrackedReference(String key, String name, String className, List<String> fields) {
+    this.key = key;
+    this.name = name;
+    this.className = className;
+    this.fields = Collections.unmodifiableList(new ArrayList<>(fields));
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
index 0d427886..ba071eaa 100644
--- a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/AsyncTaskLeakTest.java
@@ -15,11 +15,10 @@
  */
 package com.squareup.leakcanary;
 
-import java.io.File;
+import java.lang.ref.PhantomReference;
 import java.lang.ref.WeakReference;
-import java.net.URL;
-import java.util.Arrays;
 import java.util.Collection;
+import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -27,6 +26,11 @@
 
 import static com.squareup.leakcanary.LeakTraceElement.Holder.THREAD;
 import static com.squareup.leakcanary.LeakTraceElement.Type.STATIC_FIELD;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_O;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_PRE_M;
+import static com.squareup.leakcanary.TestUtil.analyze;
+import static java.util.Arrays.asList;
 import static org.hamcrest.core.StringContains.containsString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -42,35 +46,32 @@
   static final String EXECUTOR_FIELD_2 = "sDefaultExecutor";
 
   @Parameterized.Parameters public static Collection<Object[]> data() {
-    return Arrays.asList(new Object[][] {
-        { fileFromName("leak_asynctask.hprof"), "dc983a12-d029-4003-8890-7dd644c664c5" },
-        { fileFromName("leak_asynctask_mpreview2.hprof"), "1114018e-e154-435f-9a3d-da63ae9b47fa" },
+    return asList(new Object[][] {
+        { ASYNC_TASK_PRE_M }, //
+        { ASYNC_TASK_M }, //
+        { ASYNC_TASK_O } //
     });
   }
 
-  private static File fileFromName(String filename) {
-    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-    URL url = classLoader.getResource(filename);
-    return new File(url.getPath());
-  }
-
-  final File heapDumpFile;
-  final String referenceKey;
+  private final TestUtil.HeapDumpFile heapDumpFile;
+  ExcludedRefs.BuilderWithParams excludedRefs;
 
-  ExcludedRefs.Builder excludedRefs;
-
-  public AsyncTaskLeakTest(File heapDumpFile, String referenceKey) {
+  public AsyncTaskLeakTest(TestUtil.HeapDumpFile heapDumpFile) {
     this.heapDumpFile = heapDumpFile;
-    this.referenceKey = referenceKey;
   }
 
   @Before public void setUp() {
-    excludedRefs = new ExcludedRefs.Builder().clazz(WeakReference.class.getName(), true)
-        .clazz("java.lang.ref.FinalizerReference", true);
+    excludedRefs = new ExcludedRefs.BuilderWithParams() //
+        .clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude()
+        .clazz(PhantomReference.class.getName())
+        .alwaysExclude();
   }
 
   @Test public void leakFound() {
-    AnalysisResult result = analyze();
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
     assertTrue(result.leakFound);
     assertFalse(result.excludedLeak);
     LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
@@ -81,7 +82,7 @@ public AsyncTaskLeakTest(File heapDumpFile, String referenceKey) {
 
   @Test public void excludeThread() {
     excludedRefs.thread(ASYNC_TASK_THREAD);
-    AnalysisResult result = analyze();
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
     assertTrue(result.leakFound);
     assertFalse(result.excludedLeak);
     LeakTraceElement gcRoot = result.leakTrace.elements.get(0);
@@ -92,25 +93,17 @@ public AsyncTaskLeakTest(File heapDumpFile, String referenceKey) {
   }
 
   @Test public void excludeStatic() {
-    excludedRefs.thread(ASYNC_TASK_THREAD);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1);
-    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2);
-    AnalysisResult result = analyze();
+    excludedRefs.thread(ASYNC_TASK_THREAD).named(ASYNC_TASK_THREAD);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_1).named(EXECUTOR_FIELD_1);
+    excludedRefs.staticField(ASYNC_TASK_CLASS, EXECUTOR_FIELD_2).named(EXECUTOR_FIELD_2);
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
     assertTrue(result.leakFound);
     assertTrue(result.excludedLeak);
-  }
+    LeakTrace leakTrace = result.leakTrace;
+    List<LeakTraceElement> elements = leakTrace.elements;
+    Exclusion exclusion = elements.get(0).exclusion;
 
-  private AnalysisResult analyze() {
-    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
-    AnalysisResult result = heapAnalyzer.checkForLeak(heapDumpFile, referenceKey);
-    if (result.failure != null) {
-      result.failure.printStackTrace();
-    }
-    if (result.leakTrace != null) {
-      System.out.println(result.leakTrace);
-    }
-    return result;
+    List<String> expectedExclusions = asList(ASYNC_TASK_THREAD, EXECUTOR_FIELD_1, EXECUTOR_FIELD_2);
+    assertTrue(expectedExclusions.contains(exclusion.name));
   }
-
-
 }
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
new file mode 100644
index 00000000..614d32d6
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/FakeHprofBuffer.java
@@ -0,0 +1,113 @@
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.io.HprofBuffer;
+
+import java.io.UnsupportedEncodingException;
+import java.util.List;
+
+public final class FakeHprofBuffer implements HprofBuffer {
+  private static final String PRE_O_CHARSET = "UTF-16BE";
+
+  private final String stringCharset;
+
+  private List<Byte> byteList;
+  private List<byte[]> byteArrayList;
+
+  private int[] intsToRead;
+  private int intIndex = -1;
+  private String[] stringsToRead;
+  private int stringIndex = -1;
+
+  FakeHprofBuffer() {
+    this(PRE_O_CHARSET);
+  }
+
+  FakeHprofBuffer(String stringCharset) {
+    this.stringCharset = stringCharset;
+  }
+
+  public void setIntsToRead(int... ints) {
+    intsToRead = ints;
+    intIndex = 0;
+  }
+
+  public void setStringsToRead(String... strings) {
+    stringsToRead = strings;
+    stringIndex = 0;
+  }
+
+  @Override
+  public byte readByte() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void read(byte[] bytes) {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void readSubSequence(byte[] bytes, int start, int length) {
+    if (stringsToRead == null || stringIndex < 0 || stringIndex >= stringsToRead.length) {
+      throw new UnsupportedOperationException("no bytes to read");
+    }
+
+    String s = stringsToRead[stringIndex++];
+    try {
+      System.arraycopy(s.getBytes(stringCharset), start, bytes, 0, length);
+    } catch (UnsupportedEncodingException e) {
+      throw new UnsupportedOperationException(e);
+    }
+  }
+
+  @Override
+  public char readChar() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public short readShort() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public int readInt() {
+    if (intsToRead == null || intIndex < 0 || intIndex >= intsToRead.length) {
+      throw new UnsupportedOperationException("no bytes to read");
+    }
+    return intsToRead[intIndex++];
+  }
+
+  @Override
+  public long readLong() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public float readFloat() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public double readDouble() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public void setPosition(long l) {}
+
+  @Override
+  public long position() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public boolean hasRemaining() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+
+  @Override
+  public long remaining() {
+    throw new UnsupportedOperationException("no bytes to read");
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
new file mode 100644
index 00000000..4f50bb91
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HahaHelperTest.java
@@ -0,0 +1,161 @@
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.ArrayInstance;
+import com.squareup.haha.perflib.ClassInstance;
+import com.squareup.haha.perflib.ClassObj;
+import com.squareup.haha.perflib.Field;
+import com.squareup.haha.perflib.Snapshot;
+import com.squareup.haha.perflib.Type;
+import com.squareup.haha.perflib.io.HprofBuffer;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public class HahaHelperTest {
+  private static final int STRING_CLASS_ID = 100;
+  private static final int CHAR_ARRAY_CLASS_ID = 101;
+  private static final int STRING_INSTANCE_ID = 102;
+  private static final int VALUE_ARRAY_INSTANCE_ID = 103;
+  private static final int BYTE_ARRAY_CLASS_ID = 104;
+
+  private static final int VALUE_ARRAY_LENGTH = 6;
+  private static final int COUNT_VALUE = 5;
+  private static final int OFFSET_VALUE = 1;
+
+  private FakeHprofBuffer buffer;
+  private Snapshot snapshot;
+
+  @Before
+  public void setUp() {
+    buffer = new FakeHprofBuffer();
+    initSnapshot(buffer);
+  }
+
+  private void initSnapshot(HprofBuffer buffer) {
+    snapshot = new Snapshot(buffer);
+    // set HPROF identifier size; required for Object instance field lookups
+    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
+    snapshot.setIdSize(4);
+  }
+
+  @Test public void readStringOffsetFromHeapDumpInstance_pre_O() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.INT, "offset"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createCharArrayValueInstance();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("bcdef"));
+  }
+
+  @Test public void defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue_pre_O() {
+    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createCharArrayValueInstance();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("abcde"));
+  }
+
+  @Test public void readStringAsByteArrayFromHeapDumpInstance_O() {
+    // O uses default charset UTF-8
+    buffer = new FakeHprofBuffer("UTF-8");
+    initSnapshot(buffer);
+
+    buffer.setIntsToRead(COUNT_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields_O(snapshot, new Field[]{
+        new Field(Type.INT, "count"),
+        new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createByteArrayValueInstance();
+
+    String actual = HahaHelper.asString(stringInstance);
+    assertTrue(actual.equals("abcde"));
+  }
+
+  @Test public void throwExceptionWhenNotArrayValueForString() {
+    buffer.setIntsToRead(COUNT_VALUE, OFFSET_VALUE, VALUE_ARRAY_INSTANCE_ID);
+    buffer.setStringsToRead("abcdef");
+
+    addStringClassToSnapshotWithFields(snapshot, new Field[]{
+            new Field(Type.INT, "count"),
+            new Field(Type.INT, "offset"),
+            new Field(Type.OBJECT, "value")
+    });
+
+    ClassInstance stringInstance = createStringInstance();
+    createObjectValueInstance();
+
+    try {
+      HahaHelper.asString(stringInstance);
+      fail("this test should have thrown UnsupportedOperationException");
+    }
+    catch (UnsupportedOperationException uoe) {
+      String message = uoe.getMessage();
+      assertTrue(message.equals("Could not find char array in " + stringInstance));
+    }
+  }
+
+  private void addStringClassToSnapshotWithFields(Snapshot snapshot, Field[] fields) {
+    ClassObj charArrayClass = new ClassObj(0, null, "char[]", 0);
+    snapshot.addClass(CHAR_ARRAY_CLASS_ID, charArrayClass);
+
+    ClassObj stringClass = new ClassObj(0, null, "string", 0);
+    stringClass.setFields(fields);
+    snapshot.addClass(STRING_CLASS_ID, stringClass);
+  }
+
+  private void addStringClassToSnapshotWithFields_O(Snapshot snapshot, Field[] fields) {
+    ClassObj byteArrayClass = new ClassObj(0, null, "byte[]", 0);
+    snapshot.addClass(BYTE_ARRAY_CLASS_ID, byteArrayClass);
+
+    ClassObj stringClass = new ClassObj(0, null, "string", 0);
+    stringClass.setFields(fields);
+    snapshot.addClass(STRING_CLASS_ID, stringClass);
+  }
+
+  private void createCharArrayValueInstance() {
+    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.CHAR, VALUE_ARRAY_LENGTH, 0);
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
+  }
+
+  private void createByteArrayValueInstance() {
+    ArrayInstance valueArrayInstance = new ArrayInstance(0, null, Type.BYTE, VALUE_ARRAY_LENGTH, 0);
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueArrayInstance);
+  }
+
+  private void createObjectValueInstance() {
+    ClassInstance valueInstance = new ClassInstance(0, null, 0);
+    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID, valueInstance);
+  }
+
+  private ClassInstance createStringInstance() {
+    ClassInstance stringInstance = new ClassInstance(STRING_INSTANCE_ID, null, 100);
+    stringInstance.setClassId(STRING_CLASS_ID);
+    snapshot.addInstance(0, stringInstance);
+    return stringInstance;
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
new file mode 100644
index 00000000..0e6937d5
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/HeapAnalyzerTest.java
@@ -0,0 +1,64 @@
+package com.squareup.leakcanary;
+
+import com.squareup.haha.perflib.RootObj;
+import com.squareup.haha.perflib.Snapshot;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.haha.perflib.RootType.NATIVE_STATIC;
+import static com.squareup.haha.perflib.RootType.SYSTEM_CLASS;
+import static com.squareup.leakcanary.TestUtil.NO_EXCLUDED_REFS;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public class HeapAnalyzerTest {
+  private static final List<RootObj> DUP_ROOTS =
+          asList(new RootObj(SYSTEM_CLASS, 6L),
+                  new RootObj(SYSTEM_CLASS, 5L),
+                  new RootObj(SYSTEM_CLASS, 3L),
+                  new RootObj(SYSTEM_CLASS, 5L),
+                  new RootObj(NATIVE_STATIC, 3L));
+
+  private HeapAnalyzer heapAnalyzer;
+
+  @Before
+  public void setUp() {
+    heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+  }
+
+  @Test
+  public void ensureUniqueRoots() {
+    Snapshot snapshot = createSnapshot(DUP_ROOTS);
+
+    heapAnalyzer.deduplicateGcRoots(snapshot);
+
+    Collection<RootObj> uniqueRoots = snapshot.getGCRoots();
+    assertThat(uniqueRoots).hasSize(4);
+
+    List<Long> rootIds = new ArrayList<>();
+    for (RootObj root : uniqueRoots) {
+      rootIds.add(root.getId());
+    }
+    Collections.sort(rootIds);
+
+    // 3 appears twice because even though two RootObjs have the same id, they're different types.
+    assertThat(rootIds).containsExactly(3L, 3L, 5L, 6L);
+  }
+
+  private Snapshot createSnapshot(List<RootObj> gcRoots) {
+    Snapshot snapshot = new Snapshot(null);
+    for (RootObj root : gcRoots) {
+      snapshot.addRoot(root);
+    }
+    return snapshot;
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
new file mode 100644
index 00000000..349cd9c0
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/RetainedSizeTest.java
@@ -0,0 +1,51 @@
+package com.squareup.leakcanary;
+
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
+import java.util.Collection;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_O;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_PRE_M;
+import static com.squareup.leakcanary.TestUtil.analyze;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * This test makes sure there is no regression on the retained size calculation.
+ */
+@RunWith(Parameterized.class) //
+public class RetainedSizeTest {
+
+  @Parameterized.Parameters public static Collection<Object[]> data() {
+    return Arrays.asList(new Object[][] {
+        { ASYNC_TASK_PRE_M, 207_407 }, //
+        { ASYNC_TASK_M, 1_870 }, //
+        { ASYNC_TASK_O, 753 }, //
+    });
+  }
+
+  private final TestUtil.HeapDumpFile heapDumpFile;
+  private final long expectedRetainedHeapSize;
+  ExcludedRefs.BuilderWithParams excludedRefs;
+
+  public RetainedSizeTest(TestUtil.HeapDumpFile heapDumpFile, long expectedRetainedHeapSize) {
+    this.heapDumpFile = heapDumpFile;
+    this.expectedRetainedHeapSize = expectedRetainedHeapSize;
+  }
+
+  @Before public void setUp() {
+    excludedRefs = new ExcludedRefs.BuilderWithParams().clazz(WeakReference.class.getName())
+        .alwaysExclude()
+        .clazz("java.lang.ref.FinalizerReference")
+        .alwaysExclude();
+  }
+
+  @Test public void leakFound() {
+    AnalysisResult result = analyze(heapDumpFile, excludedRefs);
+    assertEquals(expectedRetainedHeapSize, result.retainedHeapSize);
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
new file mode 100644
index 00000000..8c8523c4
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TestUtil.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.File;
+import java.net.URL;
+import java.util.List;
+
+final class TestUtil {
+
+  public static final ExcludedRefs NO_EXCLUDED_REFS = ExcludedRefs.builder().build();
+
+  enum HeapDumpFile {
+    ASYNC_TASK_PRE_M("leak_asynctask_pre_m.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"), //
+    ASYNC_TASK_M("leak_asynctask_m.hprof", "25ae1778-7c1d-4ec7-ac50-5cce55424069"), //
+    ASYNC_TASK_O("leak_asynctask_o.hprof", "0e8d40d7-8302-4493-93d5-962a4c176089");
+
+    public final String filename;
+    public final String referenceKey;
+
+    HeapDumpFile(String filename, String referenceKey) {
+      this.filename = filename;
+      this.referenceKey = referenceKey;
+    }
+
+  }
+
+  static File fileFromName(String filename) {
+    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
+    URL url = classLoader.getResource(filename);
+    return new File(url.getPath());
+  }
+
+  static List<TrackedReference> findTrackedReferences(HeapDumpFile heapDumpFile) {
+    File file = fileFromName(heapDumpFile.filename);
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(NO_EXCLUDED_REFS);
+    return heapAnalyzer.findTrackedReferences(file);
+  }
+
+  static AnalysisResult analyze(HeapDumpFile heapDumpFile, ExcludedRefs.BuilderWithParams excludedRefs) {
+    File file = fileFromName(heapDumpFile.filename);
+    String referenceKey = heapDumpFile.referenceKey;
+    HeapAnalyzer heapAnalyzer = new HeapAnalyzer(excludedRefs.build());
+    AnalysisResult result = heapAnalyzer.checkForLeak(file, referenceKey);
+    if (result.failure != null) {
+      result.failure.printStackTrace();
+    }
+    if (result.leakTrace != null) {
+      System.out.println(result.leakTrace);
+    }
+    return result;
+  }
+
+  private TestUtil() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TrackedReferencesTest.java b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TrackedReferencesTest.java
new file mode 100644
index 00000000..0be0d76f
--- /dev/null
+++ b/leakcanary-analyzer/src/test/java/com/squareup/leakcanary/TrackedReferencesTest.java
@@ -0,0 +1,28 @@
+package com.squareup.leakcanary;
+
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_PRE_M;
+import static com.squareup.leakcanary.TestUtil.HeapDumpFile.ASYNC_TASK_M;
+import static com.squareup.leakcanary.TestUtil.findTrackedReferences;
+import static org.assertj.core.api.Assertions.assertThat;
+
+@RunWith(JUnit4.class)
+public class TrackedReferencesTest {
+
+  @Test public void findsExpectedRef() {
+    List<TrackedReference> trackedReferences = findTrackedReferences(ASYNC_TASK_M);
+    assertThat(trackedReferences).hasSize(1);
+    TrackedReference firstRef = trackedReferences.get(0);
+    assertThat(firstRef.key).isEqualTo(ASYNC_TASK_M.referenceKey);
+    assertThat(firstRef.className).isEqualTo("com.example.leakcanary.MainActivity");
+  }
+
+  @Test public void findsSeveralRefs() {
+    List<TrackedReference> trackedReferences = findTrackedReferences(ASYNC_TASK_PRE_M);
+    assertThat(trackedReferences).hasSize(2);
+  }
+}
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
similarity index 53%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof
rename to leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
index 548f3a2a..6945c82d 100644
Binary files a/leakcanary-analyzer/src/test/resources/leak_asynctask_mpreview2.hprof and b/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof
new file mode 100644
index 00000000..1c62d0e5
Binary files /dev/null and b/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof differ
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask.hprof b/leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask.hprof
rename to leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
diff --git a/leakcanary-android-no-op/build.gradle b/leakcanary-android-no-op/build.gradle
index 5f3dc025..9a787b47 100644
--- a/leakcanary-android-no-op/build.gradle
+++ b/leakcanary-android-no-op/build.gradle
@@ -21,7 +21,6 @@ android {
   buildToolsVersion rootProject.ext.buildToolsVersion
   defaultConfig {
     minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
   }
 }
 
diff --git a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 8fc8a58c..a9784143 100644
--- a/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android-no-op/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -1,6 +1,7 @@
 package com.squareup.leakcanary;
 
 import android.app.Application;
+import android.content.Context;
 
 /**
  * A no-op version of {@link LeakCanary} that can be used in release builds.
@@ -11,6 +12,10 @@ public static RefWatcher install(Application application) {
     return RefWatcher.DISABLED;
   }
 
+  public static boolean isInAnalyzerProcess(Context context) {
+    return false;
+  }
+
   private LeakCanary() {
     throw new AssertionError();
   }
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index beb07063..7a761dc2 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -14,7 +14,7 @@ repositories {
 }
 
 dependencies {
-  compile project(':leakcanary-analyzer')
+  api project(':leakcanary-analyzer')
 }
 
 def gitSha() {
@@ -27,11 +27,14 @@ android {
   buildToolsVersion rootProject.ext.buildToolsVersion
   defaultConfig {
     minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
     buildConfigField "String", "LIBRARY_VERSION", "\"${rootProject.ext.VERSION_NAME}\""
     buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
     consumerProguardFiles 'consumer-proguard-rules.pro'
   }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
+  }
 }
 
 task sourceJar(type: Jar) {
@@ -39,4 +42,4 @@ task sourceJar(type: Jar) {
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android/consumer-proguard-rules.pro b/leakcanary-android/consumer-proguard-rules.pro
index 0a28de9b..48ffcc28 100644
--- a/leakcanary-android/consumer-proguard-rules.pro
+++ b/leakcanary-android/consumer-proguard-rules.pro
@@ -1,2 +1,9 @@
--keep class org.eclipse.mat.** { *; }
+-dontwarn com.squareup.haha.guava.**
+-dontwarn com.squareup.haha.perflib.**
+-dontwarn com.squareup.haha.trove.**
+-dontwarn com.squareup.leakcanary.**
+-keep class com.squareup.haha.** { *; }
 -keep class com.squareup.leakcanary.** { *; }
+
+# Marshmallow removed Notification.setLatestEventInfo()
+-dontwarn android.app.Notification
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index dc0ce58f..5797416b 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -20,6 +20,7 @@
     >
 
   <!-- To store the heap dumps and leak analysis results. -->
+  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
   <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 
   <application>
@@ -30,21 +31,33 @@
         />
     <service
         android:name=".DisplayLeakService"
+        android:process=":leakcanary"
         android:enabled="false"
         />
     <activity
         android:theme="@style/leak_canary_LeakCanary.Base"
         android:name=".internal.DisplayLeakActivity"
+        android:process=":leakcanary"
         android:enabled="false"
         android:label="@string/leak_canary_display_activity_label"
         android:icon="@drawable/leak_canary_icon"
-        android:taskAffinity="com.squareup.leakcanary"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
         >
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
         <category android:name="android.intent.category.LAUNCHER"/>
       </intent-filter>
     </activity>
+    <activity
+        android:theme="@style/leak_canary_Theme.Transparent"
+        android:name=".internal.RequestStoragePermissionActivity"
+        android:process=":leakcanary"
+        android:taskAffinity="com.squareup.leakcanary.${applicationId}"
+        android:enabled="false"
+        android:excludeFromRecents="true"
+        android:icon="@drawable/leak_canary_icon"
+        android:label="@string/leak_canary_storage_permission_activity_label"
+        />
 
   </application>
 </manifest>
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
index 160e840f..efb7762e 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
@@ -15,24 +15,22 @@
  */
 package com.squareup.leakcanary;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.Application;
 import android.os.Bundle;
 
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
 
-@TargetApi(ICE_CREAM_SANDWICH) public final class ActivityRefWatcher {
+public final class ActivityRefWatcher {
 
+  /** @deprecated Use {@link #install(Application, RefWatcher)}. */
+  @Deprecated
   public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
-    if (SDK_INT < ICE_CREAM_SANDWICH) {
-      // If you need to support Android < ICS, override onDestroy() in your base activity.
-      return;
-    }
-    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
-    activityRefWatcher.watchActivities();
+    install(application, refWatcher);
+  }
+
+  public static void install(Application application, RefWatcher refWatcher) {
+    new ActivityRefWatcher(application, refWatcher).watchActivities();
   }
 
   private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
@@ -67,7 +65,7 @@ public static void installOnIcsPlus(Application application, RefWatcher refWatch
    * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
    * after they have been destroyed.
    */
-  public ActivityRefWatcher(Application application, final RefWatcher refWatcher) {
+  public ActivityRefWatcher(Application application, RefWatcher refWatcher) {
     this.application = checkNotNull(application, "application");
     this.refWatcher = checkNotNull(refWatcher, "refWatcher");
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
index 756c383d..836aecae 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java
@@ -22,18 +22,24 @@
 
 import static android.os.Build.MANUFACTURER;
 import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.ECLAIR;
 import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH;
 import static android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.LOLLIPOP;
+import static android.os.Build.VERSION_CODES.LOLLIPOP_MR1;
+import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION_CODES.N;
+import static android.os.Build.VERSION_CODES.N_MR1;
 import static com.squareup.leakcanary.AndroidWatchExecutor.LEAK_CANARY_THREAD_NAME;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.HUAWEI;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.LENOVO;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.LG;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.LOLLIPOP_MR1;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.MEIZU;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.MOTOROLA;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.NVIDIA;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.SAMSUNG;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.VIVO;
 
 /**
  * This class is a work in progress. You can help by reporting leak traces that seem to be caused
@@ -47,230 +53,344 @@
  * leaks you want to ignore by creating an {@link EnumSet} that matches your needs and calling
  * {@link #createBuilder(EnumSet)}
  */
+@SuppressWarnings({ "unused", "WeakerAccess" }) // Public API.
 public enum AndroidExcludedRefs {
 
+  // ######## Android SDK Excluded refs ########
+
   ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Android AOSP sometimes keeps a reference to a destroyed activity as a "nextIdle" client
-      // record in the android.app.ActivityThread.mActivities map.
-      // Not sure what's going on there, input welcome.
-      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle");
+      excluded.instanceField("android.app.ActivityThread$ActivityClientRecord", "nextIdle")
+          .reason("Android AOSP sometimes keeps a reference to a destroyed activity as a"
+              + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+              + " Not sure what's going on there, input welcome.");
     }
   },
 
   SPAN_CONTROLLER(SDK_INT <= KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Editor inserts a special span, which has a reference to the EditText. That span is a
-      // NoCopySpan, which makes sure it gets dropped when creating a new SpannableStringBuilder
-      // from a given CharSequence.
-      // TextView.onSaveInstanceState() does a copy of its mText before saving it in the bundle.
-      // Prior to KitKat, that copy was done using the SpannableString constructor, instead of
-      // SpannableStringBuilder. The SpannableString constructor does not drop NoCopySpan spans.
-      // So we end up with a saved state that holds a reference to the textview and therefore the
-      // entire view hierarchy & activity context.
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b
-
-      // Hack: to fix this, you could override TextView.onSaveInstanceState(), and then use
-      // reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.
-      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0");
-      excluded.instanceField("android.widget.Editor$SpanController", "this$0");
+      String reason =
+          "Editor inserts a special span, which has a reference to the EditText. That span is a"
+              + " NoCopySpan, which makes sure it gets dropped when creating a new"
+              + " SpannableStringBuilder from a given CharSequence."
+              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+              + " reference to the textview and therefore the entire view hierarchy & activity"
+              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.";
+      excluded.instanceField("android.widget.Editor$EasyEditSpanController", "this$0")
+          .reason(reason);
+      excluded.instanceField("android.widget.Editor$SpanController", "this$0").reason(reason);
     }
   },
 
   MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // MediaSessionLegacyHelper is a static singleton that is lazily instantiated and keeps a
-      // reference to the context it's given the first time MediaSessionLegacyHelper.getHelper()
-      // is called.
-      // This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by calling
-      // context.getApplicationContext().
-      // Fix: https://github.com/android/platform_frameworks_base/commit
-      // /9b5257c9c99c4cb541d8e8e78fb04f008b1a9091
-
-      // Hack: to fix this, you could call MediaSessionLegacyHelper.getHelper() early in
-      // Application.onCreate() and pass it the application context.
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance");
+      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
+          .reason("MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+              + " keeps a reference to the context it's given the first time"
+              + " MediaSessionLegacyHelper.getHelper() is called."
+              + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+              + " calling context.getApplicationContext()."
+              + " Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+              + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+              + " in Application.onCreate() and pass it the application context.");
     }
   },
 
-  TEXT_LINE__SCACHED(SDK_INT < LOLLIPOP_MR1) {
+  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had at least two
-      // bugs that created memory leaks by not correctly clearing the recycled TextLine instances.
-      // The first was fixed in android-5.1.0_r1:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /893d6fe48d37f71e683f722457bea646994a10bf
-
-      // The second was fixed, not released yet:
-      // https://github.com/android/platform_frameworks_base/commit
-      // /b3a9bc038d3a218b1dbdf7b5668e3d6c12be5ee4
-
-      // Hack: to fix this, you could access TextLine.sCached and clear the pool every now and then
-      // (e.g. on activity destroy).
-      excluded.staticField("android.text.TextLine", "sCached");
+      excluded.staticField("android.text.TextLine", "sCached")
+          .reason("TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+              + " at least two bugs that created memory leaks by not correctly clearing the"
+              + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/893d6fe48d37f71e683f722457bea646994a10"
+              + " The second was fixed, not released yet:"
+              + " https://github.com/android/platform_frameworks_base/commit"
+              + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+              + " To fix this, you could access TextLine.sCached and clear the pool every now"
+              + " and then (e.g. on activity destroy).");
     }
   },
 
-  BLOCKING_QUEUE(SDK_INT < LOLLIPOP) {
+  BLOCKING_QUEUE(SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to ART, a thread waiting on a blocking queue will leak the last dequeued object
-      // as a stack local reference.
-      // So when a HandlerThread becomes idle, it keeps a local reference to the last message it
-      // received. That message then gets recycled and can be used again.
-      // As long as all messages are recycled after being used, this won't be a problem, because
-      // there references are cleared when being recycled.
-      // However, dialogs create template Message instances to be copied when a message needs to be
-      // sent. These Message templates holds references to the dialog listeners, which most likely
-      // leads to holding a reference onto the activity in some way. Dialogs never recycle their
-      // template Message, assuming these Message instances will get GCed when the dialog is GCed.
-      // The combination of these two things creates a high potential for memory leaks as soon
-      // as you use dialogs. These memory leaks might be temporary, but some handler threads sleep
-      // for a long time.
-
-      // Hack: to fix this, you could post empty messages to the idle handler threads from time to
-      // time. This won't be easy because you cannot access all handler threads, but a library
-      // that is widely used should consider doing this for its own handler threads.
-      excluded.instanceField("android.os.Message", "obj");
-      excluded.instanceField("android.os.Message", "next");
-      excluded.instanceField("android.os.Message", "target");
+      String reason = "Prior to ART, a thread waiting on a blocking queue will leak the last"
+          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+          + " keeps a local reference to the last message it received. That message then gets"
+          + " recycled and can be used again. As long as all messages are recycled after being"
+          + "used, this won't be a problem, because these references are cleared when being"
+          + "recycled. However, dialogs create template Message instances to be copied when a"
+          + "message needs to be sent. These Message templates holds references to the dialog"
+          + "listeners, which most likely leads to holding a reference onto the activity in some"
+          + "way. Dialogs never recycle their template Message, assuming these Message instances"
+          + " will get GCed when the dialog is GCed."
+          + " The combination of these two things creates a high potential for memory leaks as soon"
+          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+          + " sleep for a long time."
+          + " To fix this, you could post empty messages to the idle handler threads from time to"
+          + " time. This won't be easy because you cannot access all handler threads, but a library"
+          + "that is widely used should consider doing this for its own handler threads.";
+      excluded.instanceField("android.os.Message", "obj").reason(reason);
+      excluded.instanceField("android.os.Message", "next").reason(reason);
+      excluded.instanceField("android.os.Message", "target").reason(reason);
     }
   },
 
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= N_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // When we detach a view that receives keyboard input, the InputMethodManager leaks a
-      // reference to it until a new view asks for keyboard input.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171190
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView");
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView");
+      String reason = "When we detach a view that receives keyboard input, the InputMethodManager"
+          + " leaks a reference to it until a new view asks for keyboard input."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414";
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
+          .reason(reason);
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
+          .reason(reason);
       excluded.instanceField("android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection");
+          "mServedInputConnection").reason(reason);
     }
   },
 
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= LOLLIPOP_MR1) {
+  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT >= ICE_CREAM_SANDWICH_MR1 && SDK_INT <= M) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // The singleton InputMethodManager is holding a reference to mCurRootView long after the
-      // activity has been destroyed.
-      // Observed on ICS MR1: https://github.com/square/leakcanary/issues/1#issuecomment-100579429
-      // Hack: https://gist.github.com/pyricau/4df64341cc978a7de414
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView");
+      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
+          .reason("The singleton InputMethodManager is holding a reference to mCurRootView long"
+              + " after the activity has been destroyed."
+              + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+              + "#issuecomment-100579429"
+              + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414");
     }
   },
 
   LAYOUT_TRANSITION(SDK_INT >= ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // LayoutTransition leaks parent ViewGroup through ViewTreeObserver.OnPreDrawListener
-      // When triggered, this leaks stays until the window is destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=171830
-      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent");
+      excluded.instanceField("android.animation.LayoutTransition$1", "val$parent")
+          .reason("LayoutTransition leaks parent ViewGroup through"
+              + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+              + " window is destroyed. Tracked here:"
+              + " https://code.google.com/p/android/issues/detail?id=171830");
     }
   },
 
-  SPELL_CHECKER_SESSION(SDK_INT >= JELLY_BEAN || SDK_INT <= LOLLIPOP_MR1) {
+  SPELL_CHECKER_SESSION((SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) || SDK_INT >= N) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the
-      // SpellCheckerSession is closed before the service is connected.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=172542
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0");
+      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
+          .reason("SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+              + " SpellCheckerSession is closed before the service is connected."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542");
     }
   },
 
   ACTIVITY_CHOOSE_MODEL(SDK_INT > ICE_CREAM_SANDWICH && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // ActivityChooserModel holds a static reference to the last set ActivityChooserModelPolicy
-      // which can be an activity context.
-      // Tracked here : https://code.google.com/p/android/issues/detail?id=172659
-      // Hack : https://gist.github.com/andaag/b05ab66ed0f06167d6e0
-      excluded.staticField("android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy");
-      excluded.staticField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy");
+      String reason = "ActivityChooserModel holds a static reference to the last set"
+          + " ActivityChooserModelPolicy which can be an activity context."
+          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0";
+      excluded.instanceField("android.support.v7.internal.widget.ActivityChooserModel",
+          "mActivityChoserModelPolicy").reason(reason);
+      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
+          .reason(reason);
     }
   },
 
   SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner class and
-      // leaked the SpeechRecognizer which leaked an activity context.
-      // Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit
-      // /b37866db469e81aca534ff6186bdafd44352329b
-      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0");
+      excluded.instanceField("android.speech.SpeechRecognizer$InternalListener", "this$0")
+          .reason("Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+              + " class and leaked the SpeechRecognizer which leaked an activity context."
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + " /b37866db469e81aca534ff6186bdafd44352329b");
     }
   },
 
-  ACCOUNT_MANAGER(SDK_INT > ECLAIR && SDK_INT <= LOLLIPOP_MR1) {
+  ACCOUNT_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // AccountManager$AmsTask$Response is a stub and is held in memory by native code, probably
-      // because the reference to the response in the other process hasn't been cleared.
-      // AccountManager$AmsTask is holding on to the activity reference to use for launching a new
-      // sub- Activity.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173689
-      // Fix: Pass a null activity reference to the AccountManager methods and then deal with the
-      // returned future to to get the result and correctly start an activity when it's available.
-      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1");
+      excluded.instanceField("android.accounts.AccountManager$AmsTask$Response", "this$1")
+          .reason("AccountManager$AmsTask$Response is a stub and is held in memory by native code,"
+              + " probably because the reference to the response in the other process hasn't been"
+              + " cleared."
+              + " AccountManager$AmsTask is holding on to the activity reference to use for"
+              + " launching a new sub- Activity."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+              + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+              + " with the returned future to to get the result and correctly start an activity"
+              + " when it's available.");
     }
   },
 
   MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // The static method MediaScannerConnection.scanFile() takes an activity context but the
-      // service might not disconnect after the activity has been destroyed.
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173788
-      // Fix: Create an instance of MediaScannerConnection yourself and pass in the application
-      // context. Call connect() and disconnect() manually.
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext");
+      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
+          .reason("The static method MediaScannerConnection.scanFile() takes an activity context"
+              + " but the service might not disconnect after the activity has been destroyed."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+              + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+              + " application context. Call connect() and disconnect() manually.");
     }
   },
 
-  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= LOLLIPOP_MR1) {
+  USER_MANAGER__SINSTANCE(SDK_INT >= JELLY_BEAN && SDK_INT <= M) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // UserManager has a static sInstance field that creates an instance and caches it the first
-      // time UserManager.get() is called. This instance is created with the outer context (which
-      // is an activity base context).
-      // Tracked here: https://code.google.com/p/android/issues/detail?id=173789
-      // Introduced by: https://github.com/android/platform_frameworks_base/commit
-      // /27db46850b708070452c0ce49daf5f79503fbde6
-      // Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the
-      // UserManager instance gets cached with a reference to the application context.
-      excluded.instanceField("android.os.UserManager", "mContext");
+      excluded.instanceField("android.os.UserManager", "mContext")
+          .reason("UserManager has a static sInstance field that creates an instance and caches it"
+              + " the first time UserManager.get() is called. This instance is created with the"
+              + " outer context (which is an activity base context)."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+              + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+              + "/27db46850b708070452c0ce49daf5f79503fbde6"
+              + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+              + " UserManager instance gets cached with a reference to the application context.");
     }
   },
 
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.appwidget.AppWidgetHost$Callbacks", "this$0")
+          .reason("android.appwidget.AppWidgetHost$Callbacks is a stub and is held in memory native"
+              + " code. The reference to the `mContext` was not being cleared, which caused the"
+              + " Callbacks instance to retain this reference"
+              + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+              + "/7a96f3c917e0001ee739b65da37b2fadec7d7765");
+    }
+  },
+
+  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.media.AudioManager$1", "this$0")
+          .reason("Prior to Android M, VideoView required audio focus from AudioManager and"
+              + " never abandoned it, which leaks the Activity context through the AudioManager."
+              + " The root of the problem is that AudioManager uses whichever"
+              + " context it receives, which in the case of the VideoView example is an Activity,"
+              + " even though it only needs the application's context. The issue is fixed in"
+              + " Android M, and the AudioManager now uses the application's context."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+              + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2");
+    }
+  },
+
+  EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.widget.Editor$Blink", "this$0")
+          .reason("The EditText Blink of the Cursor is implemented using a callback and Messages,"
+              + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+              + " contains a blinking cursor is detached, a message is posted with a delay after the"
+              + " dialog has been closed and as a result leaks the Activity."
+              + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+              + " dismiss() method of the dialog."
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+              + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+              + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/");
+    }
+  },
+
+  CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("android.net.ConnectivityManager", "sInstance")
+          .reason("ConnectivityManager has a sInstance field that is set when the first"
+              + "ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+              + "When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+              + "ConnectivityManager instance is created with the activity context and stored in"
+              + "sInstance. That activity context then leaks forever."
+              + "Until this is fixed, app developers can prevent this leak by making sure the"
+              + " ConnectivityManager is first created with an App Context. E.g. in some static"
+              + " init do: context.getApplicationContext()"
+              + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+              + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+              + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+              + "e0bef71662d81caaaa0d7214fb0bef5d39996a69");
+    }
+  },
+
+  // ######## Manufacturer specific Excluded refs ########
+
+  INSTRUMENTATION_RECOMMEND_ACTIVITY(MEIZU.equals(MANUFACTURER) && SDK_INT >= LOLLIPOP && SDK_INT <= LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
+              .reason("Instrumentation would leak com.android.internal.app.RecommendActivity (in framework.jar)"
+                  + " in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and above");
+    }
+  },
+
+  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
+      MOTOROLA.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
       if (MOTOROLA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
-        // DevicePolicyManager keeps a reference to the context it has been created with instead of
-        // extracting the application context. In this Motorola build, DevicePolicyManager has an
-        // inner SettingsObserver class that is a content observer, which is held into memory
-        // by a binder transport object.
-        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0");
+        excluded.instanceField("android.app.admin.DevicePolicyManager$SettingsObserver", "this$0")
+            .reason("DevicePolicyManager keeps a reference to the context it has been created with"
+                + " instead of extracting the application context. In this Motorola build,"
+                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                + " observer, which is held into memory by a binder transport object.");
       }
     }
   },
 
   SPEN_GESTURE_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // SpenGestureManager has a static mContext field that leaks a reference to the activity.
-      // Yes, a STATIC "mContext" field.
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext");
+      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
+          .reason("SpenGestureManager has a static mContext field that leaks a reference to the"
+              + " activity. Yes, a STATIC mContext field.");
+    }
+  },
+
+  GESTURE_BOOST_MANAGER(HUAWEI.equals(MANUFACTURER) && SDK_INT >= N && SDK_INT <= N_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
+          .reason("GestureBoostManager is a static singleton that leaks an activity context."
+          + "Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756");
     }
   },
 
   CLIPBOARD_UI_MANAGER__SINSTANCE(
       SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // ClipboardUIManager is a static singleton that leaks an activity context.
-      excluded.staticField("android.sec.clipboard.ClipboardUIManager", "sInstance");
+      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
+          .reason("ClipboardUIManager is a static singleton that leaks an activity context."
+              + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+              + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+              + " application context. Example: https://gist.github.com/cypressious/"
+              + "91c4fb1455470d803a602838dfcd5774");
+    }
+  },
+
+  SEM_CLIPBOARD_MANAGER__MCONTEXT(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("com.samsung.android.content.clipboard.SemClipboardManager",
+          "mContext")
+          .reason("SemClipboardManager is held in memory by an anonymous inner class "
+              + "implementation of android.os.Binder, thereby leaking an activity context.");
+    }
+  },
+
+  SEM_EMERGENCY_MANAGER__MCONTEXT(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= N) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
+          .reason("SemEmergencyManager is a static singleton that leaks a DecorContext.");
     }
   },
 
   BUBBLE_POPUP_HELPER__SHELPER(
       LG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // A static helper for EditText "bubble popups" leaks a reference to the latest focused view.
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper");
+      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
+          .reason("A static helper for EditText bubble popups leaks a reference to the latest"
+              + "focused view.");
+    }
+  },
+
+  LGCONTEXT__MCONTEXT(LG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.instanceField("com.lge.systemservice.core.LGContext", "mContext")
+          .reason("LGContext is a static singleton that leaks an activity context.");
     }
   },
 
@@ -285,65 +405,90 @@
 
   MAPPER_CLIENT(NVIDIA.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Not sure exactly what ControllerMapper is about, but there is an anonymous Handler in
-      // ControllerMapper.MapperClient.ServiceClient, which leaks ControllerMapper.MapperClient
-      // which leaks the activity context.
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0");
+      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient$ServiceClient", "this$0")
+          .reason("Not sure exactly what ControllerMapper is about, but there is an anonymous"
+              + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+              + " ControllerMapper.MapperClient which leaks the activity context.");
     }
   },
 
-  TEXT_VIEW__MLAST_HOVERED_VIEW(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
+  TEXT_VIEW__MLAST_HOVERED_VIEW(
+      SAMSUNG.equals(MANUFACTURER) && SDK_INT >= KITKAT && SDK_INT <= LOLLIPOP_MR1) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // mLastHoveredView is a static field in TextView that leaks the last hovered view.
-      excluded.staticField("android.widget.TextView", "mLastHoveredView");
+      excluded.staticField("android.widget.TextView", "mLastHoveredView")
+          .reason("mLastHoveredView is a static field in TextView that leaks the last hovered"
+              + " view.");
     }
   },
 
   PERSONA_MANAGER(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // android.app.LoadedApk.mResources has a reference to
-      // android.content.res.Resources.mPersonaManager which has a reference to
-      // android.os.PersonaManager.mContext which is an activity.
-      excluded.instanceField("android.os.PersonaManager", "mContext");
+      excluded.instanceField("android.os.PersonaManager", "mContext")
+          .reason("android.app.LoadedApk.mResources has a reference to"
+              + " android.content.res.Resources.mPersonaManager which has a reference to"
+              + " android.os.PersonaManager.mContext which is an activity.");
     }
   },
 
   RESOURCES__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // In AOSP the Resources class does not have a context.
-      // Here we have ZygoteInit.mResources (static field) holding on to a Resources instance that
-      // has a context that is the activity.
-      // Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184
-      excluded.instanceField("android.content.res.Resources", "mContext");
+      excluded.instanceField("android.content.res.Resources", "mContext")
+          .reason("In AOSP the Resources class does not have a context."
+              + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+              + " instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184");
     }
   },
 
   VIEW_CONFIGURATION__MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // In AOSP the ViewConfiguration class does not have a context.
-      // Here we have ViewConfiguration.sConfigurations (static field) holding on to a
-      // ViewConfiguration instance that has a context that is the activity.
-      // Observed here: https://github.com/square/leakcanary/issues/1#issuecomment-100324683
-      excluded.instanceField("android.view.ViewConfiguration", "mContext");
+      excluded.instanceField("android.view.ViewConfiguration", "mContext")
+          .reason("In AOSP the ViewConfiguration class does not have a context."
+              + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+              + " ViewConfiguration instance that has a context that is the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues"
+              + "/1#issuecomment-100324683");
+    }
+  },
+
+  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL((LENOVO.equals(MANUFACTURER) && SDK_INT == KITKAT) //
+      || (VIVO.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1)) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.staticField("android.hardware.SystemSensorManager", "mAppContextImpl")
+          .reason("SystemSensorManager stores a reference to context "
+              + "in a static field in its constructor."
+              + "Fix: use application context to get SensorManager");
     }
   },
 
   AUDIO_MANAGER__MCONTEXT_STATIC(SAMSUNG.equals(MANUFACTURER) && SDK_INT == KITKAT) {
     @Override void add(ExcludedRefs.Builder excluded) {
-      // Samsung added a static mContext_static field to AudioManager, holds a reference to the
-      // activity.
-      // Observed here: https://github.com/square/leakcanary/issues/32
-      excluded.staticField("android.media.AudioManager", "mContext_static");
+      excluded.staticField("android.media.AudioManager", "mContext_static")
+          .reason("Samsung added a static mContext_static field to AudioManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/32");
+    }
+  },
+
+  ACTIVITY_MANAGER_MCONTEXT(SAMSUNG.equals(MANUFACTURER) && SDK_INT == LOLLIPOP_MR1) {
+    @Override void add(ExcludedRefs.Builder excluded) {
+      excluded.staticField("android.app.ActivityManager", "mContext")
+          .reason("Samsung added a static mContext field to ActivityManager, holds a reference"
+              + " to the activity."
+              + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+              + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283");
     }
   },
 
+  // ######## General Excluded refs ########
+
   SOFT_REFERENCES {
     @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.clazz(WeakReference.class.getName(), true);
-      excluded.clazz(SoftReference.class.getName(), true);
-      excluded.clazz(PhantomReference.class.getName(), true);
-      excluded.clazz("java.lang.ref.Finalizer", true);
-      excluded.clazz("java.lang.ref.FinalizerReference", true);
+      excluded.clazz(WeakReference.class.getName()).alwaysExclude();
+      excluded.clazz(SoftReference.class.getName()).alwaysExclude();
+      excluded.clazz(PhantomReference.class.getName()).alwaysExclude();
+      excluded.clazz("java.lang.ref.Finalizer").alwaysExclude();
+      excluded.clazz("java.lang.ref.FinalizerReference").alwaysExclude();
     }
   },
 
@@ -351,7 +496,7 @@
     @Override void add(ExcludedRefs.Builder excluded) {
       // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
       // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon", true);
+      excluded.thread("FinalizerWatchdogDaemon").alwaysExclude();
     }
   },
 
@@ -360,13 +505,13 @@
       // The main thread stack is ever changing so local variables aren't likely to hold references
       // for long. If this is on the shortest path, it's probably that there's a longer path with
       // a real leak.
-      excluded.thread("main", true);
+      excluded.thread("main").alwaysExclude();
     }
   },
 
   LEAK_CANARY_THREAD {
     @Override void add(ExcludedRefs.Builder excluded) {
-      excluded.thread(LEAK_CANARY_THREAD_NAME, true);
+      excluded.thread(LEAK_CANARY_THREAD_NAME).alwaysExclude();
     }
   },
 
@@ -377,7 +522,7 @@
       // The main thread message queue is held on by the main Looper, but that might be a longer
       // path. Let's not confuse people with a shorter path that is less meaningful.
       excluded.instanceField("android.view.Choreographer$FrameDisplayEventReceiver",
-          "mMessageQueue", true);
+          "mMessageQueue").alwaysExclude();
     }
   };
 
@@ -385,8 +530,9 @@
    * This returns the references in the leak path that should be ignored by all on Android.
    */
   public static ExcludedRefs.Builder createAndroidDefaults() {
-    return createBuilder(EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
-        EVENT_RECEIVER__MMESSAGE_QUEUE));
+    return createBuilder(
+        EnumSet.of(SOFT_REFERENCES, FINALIZER_WATCHDOG_DAEMON, MAIN, LEAK_CANARY_THREAD,
+            EVENT_RECEIVER__MMESSAGE_QUEUE));
   }
 
   /**
@@ -400,10 +546,11 @@
   }
 
   public static ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
-    ExcludedRefs.Builder excluded = new ExcludedRefs.Builder();
+    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
     for (AndroidExcludedRefs ref : refs) {
       if (ref.applies) {
         ref.add(excluded);
+        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
       }
     }
     return excluded;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
index 7ab85f9d..9d618059 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidHeapDumper.java
@@ -20,48 +20,41 @@
 import android.os.Handler;
 import android.os.Looper;
 import android.os.MessageQueue;
-import android.util.Log;
 import android.view.Gravity;
 import android.view.LayoutInflater;
 import android.widget.Toast;
 import com.squareup.leakcanary.internal.FutureResult;
-import com.squareup.leakcanary.internal.LeakCanaryInternals;
 import java.io.File;
-import java.io.IOException;
 
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.isExternalStorageWritable;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.storageDirectory;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 public final class AndroidHeapDumper implements HeapDumper {
 
-  private static final String TAG = "AndroidHeapDumper";
-
-  private final Context context;
+  final Context context;
+  private final LeakDirectoryProvider leakDirectoryProvider;
   private final Handler mainHandler;
 
-  public AndroidHeapDumper(Context context) {
+  public AndroidHeapDumper(Context context, LeakDirectoryProvider leakDirectoryProvider) {
+    this.leakDirectoryProvider = leakDirectoryProvider;
     this.context = context.getApplicationContext();
     mainHandler = new Handler(Looper.getMainLooper());
   }
 
+
+  @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
   @Override public File dumpHeap() {
-    if (!isExternalStorageWritable()) {
-      Log.d(TAG, "Could not dump heap, external storage not mounted.");
-    }
-    File heapDumpFile = getHeapDumpFile();
-    if (heapDumpFile.exists()) {
-      Log.d(TAG, "Could not dump heap, previous analysis still is in progress.");
-      // Heap analysis in progress, let's not put too much pressure on the device.
-      return NO_DUMP;
+    File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();
+
+    if (heapDumpFile == RETRY_LATER) {
+      return RETRY_LATER;
     }
 
     FutureResult<Toast> waitingForToast = new FutureResult<>();
     showToast(waitingForToast);
 
     if (!waitingForToast.wait(5, SECONDS)) {
-      Log.d(TAG, "Did not dump heap, too much time waiting for Toast.");
-      return NO_DUMP;
+      CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
+      return RETRY_LATER;
     }
 
     Toast toast = waitingForToast.get();
@@ -69,37 +62,13 @@ public AndroidHeapDumper(Context context) {
       Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
       cancelToast(toast);
       return heapDumpFile;
-    } catch (IOException e) {
-      cleanup();
-      Log.e(TAG, "Could not perform heap dump", e);
+    } catch (Exception e) {
+      CanaryLog.d(e, "Could not dump heap");
       // Abort heap dump
-      return NO_DUMP;
+      return RETRY_LATER;
     }
   }
 
-  /**
-   * Call this on app startup to clean up all heap dump files that had not been handled yet when
-   * the app process was killed.
-   */
-  public void cleanup() {
-    LeakCanaryInternals.executeOnFileIoThread(new Runnable() {
-      @Override public void run() {
-        if (isExternalStorageWritable()) {
-          Log.d(TAG, "Could not attempt cleanup, external storage not mounted.");
-        }
-        File heapDumpFile = getHeapDumpFile();
-        if (heapDumpFile.exists()) {
-          Log.d(TAG, "Previous analysis did not complete correctly, cleaning: " + heapDumpFile);
-          heapDumpFile.delete();
-        }
-      }
-    });
-  }
-
-  private File getHeapDumpFile() {
-    return new File(storageDirectory(), "suspected_leak_heapdump.hprof");
-  }
-
   private void showToast(final FutureResult<Toast> waitingForToast) {
     mainHandler.post(new Runnable() {
       @Override public void run() {
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
new file mode 100644
index 00000000..6673183f
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -0,0 +1,89 @@
+package com.squareup.leakcanary;
+
+import android.app.Application;
+import android.content.Context;
+import java.util.concurrent.TimeUnit;
+
+import static com.squareup.leakcanary.RefWatcher.DISABLED;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/** A {@link RefWatcherBuilder} with appropriate Android defaults. */
+public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRefWatcherBuilder> {
+
+  private static final long DEFAULT_WATCH_DELAY_MILLIS = SECONDS.toMillis(5);
+
+  private final Context context;
+
+  AndroidRefWatcherBuilder(Context context) {
+    this.context = context.getApplicationContext();
+  }
+
+  /**
+   * Sets a custom {@link AbstractAnalysisResultService} to listen to analysis results. This
+   * overrides any call to {@link #heapDumpListener(HeapDump.Listener)}.
+   */
+  public AndroidRefWatcherBuilder listenerServiceClass(
+      Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
+    return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
+  }
+
+  /**
+   * Sets a custom delay for how long the {@link RefWatcher} should wait until it checks if a
+   * tracked object has been garbage collected. This overrides any call to {@link
+   * #watchExecutor(WatchExecutor)}.
+   */
+  public AndroidRefWatcherBuilder watchDelay(long delay, TimeUnit unit) {
+    return watchExecutor(new AndroidWatchExecutor(unit.toMillis(delay)));
+  }
+
+  /**
+   * Sets the maximum number of heap dumps stored. This overrides any call to {@link
+   * #heapDumper(HeapDumper)} as well as any call to
+   * {@link LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)})}
+   *
+   * @throws IllegalArgumentException if maxStoredHeapDumps < 1.
+   */
+  public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
+    LeakDirectoryProvider leakDirectoryProvider =
+        new DefaultLeakDirectoryProvider(context, maxStoredHeapDumps);
+    LeakCanary.setDisplayLeakActivityDirectoryProvider(leakDirectoryProvider);
+    return heapDumper(new AndroidHeapDumper(context, leakDirectoryProvider));
+  }
+
+  /**
+   * Creates a {@link RefWatcher} instance and starts watching activity references (on ICS+).
+   */
+  public RefWatcher buildAndInstall() {
+    RefWatcher refWatcher = build();
+    if (refWatcher != DISABLED) {
+      LeakCanary.enableDisplayLeakActivity(context);
+      ActivityRefWatcher.install((Application) context, refWatcher);
+    }
+    return refWatcher;
+  }
+
+  @Override protected boolean isDisabled() {
+    return LeakCanary.isInAnalyzerProcess(context);
+  }
+
+  @Override protected HeapDumper defaultHeapDumper() {
+    LeakDirectoryProvider leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+    return new AndroidHeapDumper(context, leakDirectoryProvider);
+  }
+
+  @Override protected DebuggerControl defaultDebuggerControl() {
+    return new AndroidDebuggerControl();
+  }
+
+  @Override protected HeapDump.Listener defaultHeapDumpListener() {
+    return new ServiceHeapDumpListener(context, DisplayLeakService.class);
+  }
+
+  @Override protected ExcludedRefs defaultExcludedRefs() {
+    return AndroidExcludedRefs.createAppDefaults().build();
+  }
+
+  @Override protected WatchExecutor defaultWatchExecutor() {
+    return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index d5d94293..585af091 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -19,51 +19,68 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.MessageQueue;
-import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+import static com.squareup.leakcanary.Retryable.Result.RETRY;
 
 /**
- * {@link Executor} suitable for watching Android reference leaks. This executor waits for the main
- * thread to be idle then posts to a serial background thread with a delay of {@link
- * #DELAY_MILLIS} milliseconds.
+ * {@link WatchExecutor} suitable for watching Android reference leaks. This executor waits for the
+ * main thread to be idle then posts to a serial background thread with the delay specified by
+ * {@link AndroidRefWatcherBuilder#watchDelay(long, TimeUnit)}.
  */
-public final class AndroidWatchExecutor implements Executor {
+public final class AndroidWatchExecutor implements WatchExecutor {
 
   static final String LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump";
-  private static final int DELAY_MILLIS = 5000;
-
   private final Handler mainHandler;
   private final Handler backgroundHandler;
+  private final long initialDelayMillis;
+  private final long maxBackoffFactor;
 
-  public AndroidWatchExecutor() {
+  public AndroidWatchExecutor(long initialDelayMillis) {
     mainHandler = new Handler(Looper.getMainLooper());
     HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
     handlerThread.start();
     backgroundHandler = new Handler(handlerThread.getLooper());
+    this.initialDelayMillis = initialDelayMillis;
+    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;
   }
 
-  @Override public void execute(final Runnable command) {
-    if (isOnMainThread()) {
-      executeDelayedAfterIdleUnsafe(command);
+  @Override public void execute(Retryable retryable) {
+    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
+      waitForIdle(retryable, 0);
     } else {
-      mainHandler.post(new Runnable() {
-        @Override public void run() {
-          executeDelayedAfterIdleUnsafe(command);
-        }
-      });
+      postWaitForIdle(retryable, 0);
     }
   }
 
-  private boolean isOnMainThread() {
-    return Looper.getMainLooper().getThread() == Thread.currentThread();
+  void postWaitForIdle(final Retryable retryable, final int failedAttempts) {
+    mainHandler.post(new Runnable() {
+      @Override public void run() {
+        waitForIdle(retryable, failedAttempts);
+      }
+    });
   }
 
-  private void executeDelayedAfterIdleUnsafe(final Runnable runnable) {
+  void waitForIdle(final Retryable retryable, final int failedAttempts) {
     // This needs to be called from the main thread.
     Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
       @Override public boolean queueIdle() {
-        backgroundHandler.postDelayed(runnable, DELAY_MILLIS);
+        postToBackgroundWithDelay(retryable, failedAttempts);
         return false;
       }
     });
   }
+
+  void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {
+    long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor);
+    long delayMillis = initialDelayMillis * exponentialBackoffFactor;
+    backgroundHandler.postDelayed(new Runnable() {
+      @Override public void run() {
+        Retryable.Result result = retryable.run();
+        if (result == RETRY) {
+          postWaitForIdle(retryable, failedAttempts + 1);
+        }
+      }
+    }, delayMillis);
+  }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
new file mode 100644
index 00000000..b4e288db
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/CanaryLog.java
@@ -0,0 +1,60 @@
+package com.squareup.leakcanary;
+
+import android.util.Log;
+
+public final class CanaryLog {
+
+  private static volatile Logger logger = new DefaultLogger();
+
+  public interface Logger {
+    void d(String message, Object... args);
+
+    void d(Throwable throwable, String message, Object... args);
+  }
+
+  private static class DefaultLogger implements Logger {
+    DefaultLogger() { }
+
+    @Override public void d(String message, Object... args) {
+      String formatted = String.format(message, args);
+      if (formatted.length() < 4000) {
+        Log.d("LeakCanary", formatted);
+      } else {
+        String[] lines = formatted.split("\n");
+        for (String line : lines) {
+          Log.d("LeakCanary", line);
+        }
+      }
+    }
+
+    @Override public void d(Throwable throwable, String message, Object... args) {
+      d(String.format(message, args) + '\n' + Log.getStackTraceString(throwable));
+    }
+  }
+
+  public static void setLogger(Logger logger) {
+    CanaryLog.logger = logger;
+  }
+
+  public static void d(String message, Object... args) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    Logger logger = CanaryLog.logger;
+    if (logger == null) {
+      return;
+    }
+    logger.d(message, args);
+  }
+
+  public static void d(Throwable throwable, String message, Object... args) {
+    // Local variable to prevent the ref from becoming null after the null check.
+    Logger logger = CanaryLog.logger;
+    if (logger == null) {
+      return;
+    }
+    logger.d(throwable, message, args);
+  }
+
+  private CanaryLog() {
+    throw new AssertionError();
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
new file mode 100644
index 00000000..94957554
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DefaultLeakDirectoryProvider.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import android.annotation.TargetApi;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.os.Environment;
+import com.squareup.leakcanary.internal.RequestStoragePermissionActivity;
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.UUID;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.M;
+import static android.os.Environment.DIRECTORY_DOWNLOADS;
+import static com.squareup.leakcanary.HeapDumper.RETRY_LATER;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
+
+public final class DefaultLeakDirectoryProvider implements LeakDirectoryProvider {
+
+  private static final int DEFAULT_MAX_STORED_HEAP_DUMPS = 7;
+
+  private static final String HPROF_SUFFIX = ".hprof";
+  private static final String PENDING_HEAPDUMP_SUFFIX = "_pending" + HPROF_SUFFIX;
+
+  /** 10 minutes */
+  private static final int ANALYSIS_MAX_DURATION_MS = 10 * 60 * 1000;
+
+  private final Context context;
+  private final int maxStoredHeapDumps;
+
+  private volatile boolean writeExternalStorageGranted;
+  private volatile boolean permissionNotificationDisplayed;
+
+  public DefaultLeakDirectoryProvider(Context context) {
+    this(context, DEFAULT_MAX_STORED_HEAP_DUMPS);
+  }
+
+  public DefaultLeakDirectoryProvider(Context context, int maxStoredHeapDumps) {
+    if (maxStoredHeapDumps < 1) {
+      throw new IllegalArgumentException("maxStoredHeapDumps must be at least 1");
+    }
+    this.context = context.getApplicationContext();
+    this.maxStoredHeapDumps = maxStoredHeapDumps;
+  }
+
+  @Override public List<File> listFiles(FilenameFilter filter) {
+    if (!hasStoragePermission()) {
+      requestWritePermissionNotification();
+    }
+    List<File> files = new ArrayList<>();
+
+    File[] externalFiles = externalStorageDirectory().listFiles(filter);
+    if (externalFiles != null) {
+      files.addAll(Arrays.asList(externalFiles));
+    }
+
+    File[] appFiles = appStorageDirectory().listFiles(filter);
+    if (appFiles != null) {
+      files.addAll(Arrays.asList(appFiles));
+    }
+    return files;
+  }
+
+  @Override public File newHeapDumpFile() {
+    List<File> pendingHeapDumps = listFiles(new FilenameFilter() {
+      @Override public boolean accept(File dir, String filename) {
+        return filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
+      }
+    });
+
+    // If a new heap dump file has been created recently and hasn't been processed yet, we skip.
+    // Otherwise we move forward and assume that the analyzer process crashes. The file will
+    // eventually be removed with heap dump file rotation.
+    for (File file : pendingHeapDumps) {
+      if (System.currentTimeMillis() - file.lastModified() < ANALYSIS_MAX_DURATION_MS) {
+        CanaryLog.d("Could not dump heap, previous analysis still is in progress.");
+        return RETRY_LATER;
+      }
+    }
+
+    cleanupOldHeapDumps();
+
+    File storageDirectory = externalStorageDirectory();
+    if (!directoryWritableAfterMkdirs(storageDirectory)) {
+      if (!hasStoragePermission()) {
+        CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted");
+        requestWritePermissionNotification();
+      } else {
+        String state = Environment.getExternalStorageState();
+        if (!Environment.MEDIA_MOUNTED.equals(state)) {
+          CanaryLog.d("External storage not mounted, state: %s", state);
+        } else {
+          CanaryLog.d("Could not create heap dump directory in external storage: [%s]",
+              storageDirectory.getAbsolutePath());
+        }
+      }
+      // Fallback to app storage.
+      storageDirectory = appStorageDirectory();
+      if (!directoryWritableAfterMkdirs(storageDirectory)) {
+        CanaryLog.d("Could not create heap dump directory in app storage: [%s]",
+            storageDirectory.getAbsolutePath());
+        return RETRY_LATER;
+      }
+    }
+    // If two processes from the same app get to this step at the same time, they could both
+    // create a heap dump. This is an edge case we ignore.
+    return new File(storageDirectory, UUID.randomUUID().toString() + PENDING_HEAPDUMP_SUFFIX);
+  }
+
+  @Override public void clearLeakDirectory() {
+    List<File> allFilesExceptPending = listFiles(new FilenameFilter() {
+      @Override public boolean accept(File dir, String filename) {
+        return !filename.endsWith(PENDING_HEAPDUMP_SUFFIX);
+      }
+    });
+    for (File file : allFilesExceptPending) {
+      boolean deleted = file.delete();
+      if (!deleted) {
+        CanaryLog.d("Could not delete file %s", file.getPath());
+      }
+    }
+  }
+
+  @TargetApi(M) private boolean hasStoragePermission() {
+    if (SDK_INT < M) {
+      return true;
+    }
+    // Once true, this won't change for the life of the process so we can cache it.
+    if (writeExternalStorageGranted) {
+      return true;
+    }
+    writeExternalStorageGranted =
+        context.checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
+    return writeExternalStorageGranted;
+  }
+
+  private void requestWritePermissionNotification() {
+    if (permissionNotificationDisplayed) {
+      return;
+    }
+    permissionNotificationDisplayed = true;
+
+    PendingIntent pendingIntent = RequestStoragePermissionActivity.createPendingIntent(context);
+    String contentTitle = context.getString(R.string.leak_canary_permission_notification_title);
+    CharSequence packageName = context.getPackageName();
+    String contentText =
+        context.getString(R.string.leak_canary_permission_notification_text, packageName);
+    showNotification(context, contentTitle, contentText, pendingIntent, 0xDEAFBEEF);
+  }
+
+  private File externalStorageDirectory() {
+    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
+    return new File(downloadsDirectory, "leakcanary-" + context.getPackageName());
+  }
+
+  private File appStorageDirectory() {
+    File appFilesDirectory = context.getFilesDir();
+    return new File(appFilesDirectory, "leakcanary");
+  }
+
+  private boolean directoryWritableAfterMkdirs(File directory) {
+    boolean success = directory.mkdirs();
+    return (success || directory.exists()) && directory.canWrite();
+  }
+
+  private void cleanupOldHeapDumps() {
+    List<File> hprofFiles = listFiles(new FilenameFilter() {
+      @Override public boolean accept(File dir, String filename) {
+        return filename.endsWith(HPROF_SUFFIX);
+      }
+    });
+    int filesToRemove = hprofFiles.size() - maxStoredHeapDumps;
+    if (filesToRemove > 0) {
+      CanaryLog.d("Removing %d heap dumps", filesToRemove);
+      // Sort with oldest modified first.
+      Collections.sort(hprofFiles, new Comparator<File>() {
+        @Override public int compare(File lhs, File rhs) {
+          return Long.valueOf(lhs.lastModified()).compareTo(rhs.lastModified());
+        }
+      });
+      for (int i = 0; i < filesToRemove; i++) {
+        boolean deleted = hprofFiles.get(i).delete();
+        if (!deleted) {
+          CanaryLog.d("Could not delete old hprof file %s", hprofFiles.get(i).getPath());
+        }
+      }
+    }
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
index 479b09e0..6bf9450a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/DisplayLeakService.java
@@ -15,25 +15,21 @@
  */
 package com.squareup.leakcanary;
 
-import android.annotation.TargetApi;
-import android.app.Notification;
-import android.app.NotificationManager;
 import android.app.PendingIntent;
-import android.content.Context;
-import android.util.Log;
+import android.os.SystemClock;
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.ObjectOutputStream;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
 
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.HONEYCOMB;
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
+import static android.text.format.Formatter.formatShortFileSize;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.classSimpleName;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.findNextAvailableHprofFile;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.showNotification;
 
 /**
  * Logs leak analysis results, and then shows a notification which will start {@link
@@ -44,54 +40,63 @@
  */
 public class DisplayLeakService extends AbstractAnalysisResultService {
 
-  @Override
-  protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
+  @Override protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
     String leakInfo = leakInfo(this, heapDump, result, true);
-    if (leakInfo.length() < 4000) {
-      Log.d("LeakCanary", leakInfo);
-    } else {
-      String[] lines = leakInfo.split("\n");
-      for (String line : lines) {
-        Log.d("LeakCanary", line);
-      }
-    }
+    CanaryLog.d("%s", leakInfo);
 
-    if (result.failure == null && (!result.leakFound || result.excludedLeak)) {
-      if (result.excludedLeak) {
-        PendingIntent pendingIntent = DisplayLeakActivity.createPendingIntent(this);
-        String contentTitle =
-            getString(R.string.leak_canary_class_leak_ignored, classSimpleName(result.className));
-        String contentText = getString(R.string.leak_canary_notification_leak_ignored_message);
-        notify(contentTitle, contentText, pendingIntent);
-      }
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
+    boolean resultSaved = false;
+    boolean shouldSaveResult = result.leakFound || result.failure != null;
+    if (shouldSaveResult) {
+      heapDump = renameHeapdump(heapDump);
+      resultSaved = saveResult(heapDump, result);
     }
 
-    int maxStoredLeaks = getResources().getInteger(R.integer.leak_canary_max_stored_leaks);
-    File renamedFile = findNextAvailableHprofFile(maxStoredLeaks);
+    PendingIntent pendingIntent;
+    String contentTitle;
+    String contentText;
 
-    if (renamedFile == null) {
-      // No file available.
-      Log.e("LeakCanary",
-          "Leak result dropped because we already store " + maxStoredLeaks + " leak traces.");
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
-    }
+    if (!shouldSaveResult) {
+      contentTitle = getString(R.string.leak_canary_no_leak_title);
+      contentText = getString(R.string.leak_canary_no_leak_text);
+      pendingIntent = null;
+    } else if (resultSaved) {
+      pendingIntent = DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
 
-    heapDump = heapDump.renameFile(renamedFile);
+      if (result.failure == null) {
+        String size = formatShortFileSize(this, result.retainedHeapSize);
+        String className = classSimpleName(result.className);
+        if (result.excludedLeak) {
+          contentTitle = getString(R.string.leak_canary_leak_excluded, className, size);
+        } else {
+          contentTitle = getString(R.string.leak_canary_class_has_leaked, className, size);
+        }
+      } else {
+        contentTitle = getString(R.string.leak_canary_analysis_failed);
+      }
+      contentText = getString(R.string.leak_canary_notification_message);
+    } else {
+      contentTitle = getString(R.string.leak_canary_could_not_save_title);
+      contentText = getString(R.string.leak_canary_could_not_save_text);
+      pendingIntent = null;
+    }
+    // New notification id every second.
+    int notificationId = (int) (SystemClock.uptimeMillis() / 1000);
+    showNotification(this, contentTitle, contentText, pendingIntent, notificationId);
+    afterDefaultHandling(heapDump, result, leakInfo);
+  }
 
-    File resultFile = leakResultFile(renamedFile);
+  private boolean saveResult(HeapDump heapDump, AnalysisResult result) {
+    File resultFile = new File(heapDump.heapDumpFile.getParentFile(),
+        heapDump.heapDumpFile.getName() + ".result");
     FileOutputStream fos = null;
     try {
       fos = new FileOutputStream(resultFile);
       ObjectOutputStream oos = new ObjectOutputStream(fos);
       oos.writeObject(heapDump);
       oos.writeObject(result);
+      return true;
     } catch (IOException e) {
-      Log.e("LeakCanary", "Could not save leak analysis result to disk", e);
-      afterDefaultHandling(heapDump, result, leakInfo);
-      return;
+      CanaryLog.d(e, "Could not save leak analysis result to disk.");
     } finally {
       if (fos != null) {
         try {
@@ -100,51 +105,22 @@ protected final void onHeapAnalyzed(HeapDump heapDump, AnalysisResult result) {
         }
       }
     }
-
-    PendingIntent pendingIntent =
-        DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
-
-    String contentTitle;
-    if (result.failure == null) {
-      contentTitle =
-          getString(R.string.leak_canary_class_has_leaked, classSimpleName(result.className));
-    } else {
-      contentTitle = getString(R.string.leak_canary_analysis_failed);
-    }
-    String contentText = getString(R.string.leak_canary_notification_message);
-
-    notify(contentTitle, contentText, pendingIntent);
-    afterDefaultHandling(heapDump, result, leakInfo);
+    return false;
   }
 
-  @TargetApi(HONEYCOMB)
-  private void notify(String contentTitle, String contentText,
-      PendingIntent pendingIntent) {
-    NotificationManager notificationManager =
-        (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+  private HeapDump renameHeapdump(HeapDump heapDump) {
+    String fileName =
+        new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss_SSS'.hprof'", Locale.US).format(new Date());
 
-    Notification notification;
-    if (SDK_INT < HONEYCOMB) {
-      notification = new Notification();
-      notification.icon = R.drawable.leak_canary_notification;
-      notification.when = System.currentTimeMillis();
-      notification.flags |= Notification.FLAG_AUTO_CANCEL;
-      notification.setLatestEventInfo(this, contentTitle, contentText, pendingIntent);
-    } else {
-      Notification.Builder builder = new Notification.Builder(this) //
-          .setSmallIcon(R.drawable.leak_canary_notification)
-          .setWhen(System.currentTimeMillis())
-          .setContentTitle(contentTitle)
-          .setContentText(contentText)
-          .setAutoCancel(true)
-          .setContentIntent(pendingIntent);
-      if (SDK_INT < JELLY_BEAN) {
-        notification = builder.getNotification();
-      } else {
-        notification = builder.build();
-      }
+    File newFile = new File(heapDump.heapDumpFile.getParent(), fileName);
+    boolean renamed = heapDump.heapDumpFile.renameTo(newFile);
+    if (!renamed) {
+      CanaryLog.d("Could not rename heap dump file %s to %s", heapDump.heapDumpFile.getPath(),
+          newFile.getPath());
     }
-    notificationManager.notify(0xDEAFBEEF, notification);
+    return new HeapDump(newFile, heapDump.referenceKey, heapDump.referenceName,
+        heapDump.excludedRefs, heapDump.watchDurationMs, heapDump.gcDurationMs,
+        heapDump.heapDumpDurationMs);
   }
 
   /**
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 6c71381d..98f8325a 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -24,6 +24,9 @@
 import com.squareup.leakcanary.internal.DisplayLeakActivity;
 import com.squareup.leakcanary.internal.HeapAnalyzerService;
 
+import static android.text.format.Formatter.formatShortFileSize;
+import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
+import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.isInServiceProcess;
 import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabled;
 
@@ -34,44 +37,30 @@
    * references (on ICS+).
    */
   public static RefWatcher install(Application application) {
-    return install(application, DisplayLeakService.class,
-        AndroidExcludedRefs.createAppDefaults().build());
+    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
+        .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
+        .buildAndInstall();
   }
 
-  /**
-   * Creates a {@link RefWatcher} that reports results to the provided service, and starts watching
-   * activity references (on ICS+).
-   */
-  public static RefWatcher install(Application application,
-      Class<? extends AbstractAnalysisResultService> listenerServiceClass,
-      ExcludedRefs excludedRefs) {
-    if (isInAnalyzerProcess(application)) {
-      return RefWatcher.DISABLED;
-    }
-    enableDisplayLeakActivity(application);
-    HeapDump.Listener heapDumpListener =
-        new ServiceHeapDumpListener(application, listenerServiceClass);
-    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);
-    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);
-    return refWatcher;
-  }
-
-  /**
-   * Creates a {@link RefWatcher} with a default configuration suitable for Android.
-   */
-  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,
-      ExcludedRefs excludedRefs) {
-    DebuggerControl debuggerControl = new AndroidDebuggerControl();
-    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context);
-    heapDumper.cleanup();
-    return new RefWatcher(new AndroidWatchExecutor(), debuggerControl, GcTrigger.DEFAULT,
-        heapDumper, heapDumpListener, excludedRefs);
+  /** Builder to create a customized {@link RefWatcher} with appropriate Android defaults. */
+  public static AndroidRefWatcherBuilder refWatcher(Context context) {
+    return new AndroidRefWatcherBuilder(context);
   }
 
   public static void enableDisplayLeakActivity(Context context) {
     setEnabled(context, DisplayLeakActivity.class, true);
   }
 
+  /**
+   * If you build a {@link RefWatcher} with a {@link AndroidHeapDumper} that has a custom {@link
+   * LeakDirectoryProvider}, then you should also call this method to make sure the activity in
+   * charge of displaying leaks can find those on the file system.
+   */
+  public static void setDisplayLeakActivityDirectoryProvider(
+      LeakDirectoryProvider leakDirectoryProvider) {
+    DisplayLeakActivity.setLeakDirectoryProvider(leakDirectoryProvider);
+  }
+
   /** Returns a string representation of the result of a heap analysis. */
   public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult result,
       boolean detailed) {
@@ -89,18 +78,22 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
     String detailedString = "";
     if (result.leakFound) {
       if (result.excludedLeak) {
-        info += "* LEAK CAN BE IGNORED.\n";
+        info += "* EXCLUDED LEAK.\n";
       }
       info += "* " + result.className;
       if (!heapDump.referenceName.equals("")) {
         info += " (" + heapDump.referenceName + ")";
       }
       info += " has leaked:\n" + result.leakTrace.toString() + "\n";
+      info += "* Retaining: " + formatShortFileSize(context, result.retainedHeapSize) + ".\n";
       if (detailed) {
         detailedString = "\n* Details:\n" + result.leakTrace.toDetailedString();
       }
     } else if (result.failure != null) {
-      info += "* FAILURE:\n" + Log.getStackTraceString(result.failure) + "\n";
+      // We duplicate the library version & Sha information because bug reports often only contain
+      // the stacktrace.
+      info += "* FAILURE in " + LIBRARY_VERSION + " " + GIT_SHA + ":" + Log.getStackTraceString(
+          result.failure) + "\n";
     } else {
       info += "* NO LEAK FOUND.\n\n";
     }
@@ -125,9 +118,9 @@ public static String leakInfo(Context context, HeapDump heapDump, AnalysisResult
         + " API: "
         + Build.VERSION.SDK_INT
         + " LeakCanary: "
-        + BuildConfig.LIBRARY_VERSION
+        + LIBRARY_VERSION
         + " "
-        + BuildConfig.GIT_SHA
+        + GIT_SHA
         + "\n"
         + "* Durations: watch="
         + heapDump.watchDurationMs
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
new file mode 100644
index 00000000..1dfa218f
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakDirectoryProvider.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary;
+
+import java.io.File;
+import java.io.FilenameFilter;
+import java.util.List;
+
+/**
+ * Provides access to where heap dumps and analysis results will be stored.
+ * When using your own implementation, you should also call {@link
+ * LeakCanary#setDisplayLeakActivityDirectoryProvider(LeakDirectoryProvider)} to ensure the
+ * provided activity is able to display the leaks.
+ */
+public interface LeakDirectoryProvider {
+
+  List<File> listFiles(FilenameFilter filter);
+
+  /**
+   * @return {@link HeapDumper#RETRY_LATER} if a new heap dump file could not be created.
+   */
+  File newHeapDumpFile();
+
+  /**
+   * Removes all heap dumps and analysis results, except for heap dumps that haven't been
+   * analyzed yet.
+   */
+  void clearLeakDirectory();
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
index d39a8376..49d530f5 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakActivity.java
@@ -15,13 +15,13 @@
  */
 package com.squareup.leakcanary.internal;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
+import android.app.AlertDialog;
 import android.app.PendingIntent;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
 import android.net.Uri;
-import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Looper;
@@ -39,7 +39,10 @@
 import android.widget.ListView;
 import android.widget.TextView;
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.CanaryLog;
+import com.squareup.leakcanary.DefaultLeakDirectoryProvider;
 import com.squareup.leakcanary.HeapDump;
+import com.squareup.leakcanary.LeakDirectoryProvider;
 import com.squareup.leakcanary.R;
 import java.io.File;
 import java.io.FileInputStream;
@@ -51,21 +54,23 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 
 import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
 import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
 import static android.text.format.DateUtils.FORMAT_SHOW_TIME;
+import static android.text.format.Formatter.formatShortFileSize;
 import static android.view.View.GONE;
 import static android.view.View.VISIBLE;
+import static com.squareup.leakcanary.BuildConfig.GIT_SHA;
+import static com.squareup.leakcanary.BuildConfig.LIBRARY_VERSION;
 import static com.squareup.leakcanary.LeakCanary.leakInfo;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.detectedLeakDirectory;
-import static com.squareup.leakcanary.internal.LeakCanaryInternals.leakResultFile;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.newSingleThreadExecutor;
 
-@SuppressWarnings("ConstantConditions") @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+@SuppressWarnings("ConstantConditions")
 public final class DisplayLeakActivity extends Activity {
 
-  private static final String TAG = "DisplayLeakActivity";
+  private static LeakDirectoryProvider leakDirectoryProvider = null;
+
   private static final String SHOW_LEAK_EXTRA = "show_latest";
 
   public static PendingIntent createPendingIntent(Context context) {
@@ -79,15 +84,27 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
   }
 
+  public static void setLeakDirectoryProvider(LeakDirectoryProvider leakDirectoryProvider) {
+    DisplayLeakActivity.leakDirectoryProvider = leakDirectoryProvider;
+  }
+
+  private static LeakDirectoryProvider leakDirectoryProvider(Context context) {
+    LeakDirectoryProvider leakDirectoryProvider = DisplayLeakActivity.leakDirectoryProvider;
+    if (leakDirectoryProvider == null) {
+      leakDirectoryProvider = new DefaultLeakDirectoryProvider(context);
+    }
+    return leakDirectoryProvider;
+  }
+
   // null until it's been first loaded.
-  private List<Leak> leaks;
-  private String visibleLeakRefKey;
+  List<Leak> leaks;
+  String visibleLeakRefKey;
 
   private ListView listView;
   private TextView failureView;
   private Button actionButton;
-  private int maxStoredLeaks;
 
+  @SuppressWarnings("unchecked")
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
 
@@ -100,21 +117,17 @@ public static PendingIntent createPendingIntent(Context context, String referenc
       }
     }
 
-    //noinspection unchecked
     leaks = (List<Leak>) getLastNonConfigurationInstance();
 
     setContentView(R.layout.leak_canary_display_leak);
 
-    listView = (ListView) findViewById(R.id.__leak_canary_display_leak_list);
-    failureView = (TextView) findViewById(R.id.__leak_canary_display_leak_failure);
-    actionButton = (Button) findViewById(R.id.__leak_canary_action);
-
-    maxStoredLeaks = getResources().getInteger(R.integer.leak_canary_max_stored_leaks);
+    listView = (ListView) findViewById(R.id.leak_canary_display_leak_list);
+    failureView = (TextView) findViewById(R.id.leak_canary_display_leak_failure);
+    actionButton = (Button) findViewById(R.id.leak_canary_action);
 
     updateUi();
   }
 
-  // No, it's not deprecated. Android lies.
   @Override public Object onRetainNonConfigurationInstance() {
     return leaks;
   }
@@ -126,7 +139,17 @@ public static PendingIntent createPendingIntent(Context context, String referenc
 
   @Override protected void onResume() {
     super.onResume();
-    LoadLeaks.load(this);
+    LoadLeaks.load(this, leakDirectoryProvider(this));
+  }
+
+  @Override public void setTheme(int resid) {
+    // We don't want this to be called with an incompatible theme.
+    // This could happen if you implement runtime switching of themes
+    // using ActivityLifecycleCallbacks.
+    if (resid != R.style.leak_canary_LeakCanary_Base) {
+      return;
+    }
+    super.setTheme(resid);
   }
 
   @Override protected void onDestroy() {
@@ -135,7 +158,8 @@ public static PendingIntent createPendingIntent(Context context, String referenc
   }
 
   @Override public boolean onCreateOptionsMenu(Menu menu) {
-    if (getVisibleLeak() != null) {
+    Leak visibleLeak = getVisibleLeak();
+    if (visibleLeak != null) {
       menu.add(R.string.leak_canary_share_leak)
           .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
             @Override public boolean onMenuItemClick(MenuItem item) {
@@ -143,13 +167,15 @@ public static PendingIntent createPendingIntent(Context context, String referenc
               return true;
             }
           });
-      menu.add(R.string.leak_canary_share_heap_dump)
-          .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
-            @Override public boolean onMenuItemClick(MenuItem item) {
-              shareHeapDump();
-              return true;
-            }
-          });
+      if (visibleLeak.heapDump.heapDumpFile.exists()) {
+        menu.add(R.string.leak_canary_share_heap_dump)
+            .setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
+              @Override public boolean onMenuItemClick(MenuItem item) {
+                shareHeapDump();
+                return true;
+              }
+            });
+      }
       return true;
     }
     return false;
@@ -172,7 +198,7 @@ public static PendingIntent createPendingIntent(Context context, String referenc
     }
   }
 
-  private void shareLeak() {
+  void shareLeak() {
     Leak visibleLeak = getVisibleLeak();
     String leakInfo = leakInfo(this, visibleLeak.heapDump, visibleLeak.result, true);
     Intent intent = new Intent(Intent.ACTION_SEND);
@@ -181,7 +207,7 @@ private void shareLeak() {
     startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
-  private void shareHeapDump() {
+  void shareHeapDump() {
     Leak visibleLeak = getVisibleLeak();
     File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
     heapDumpFile.setReadable(true, false);
@@ -191,7 +217,30 @@ private void shareHeapDump() {
     startActivity(Intent.createChooser(intent, getString(R.string.leak_canary_share_with)));
   }
 
-  private void updateUi() {
+  void deleteVisibleLeak() {
+    Leak visibleLeak = getVisibleLeak();
+    File heapDumpFile = visibleLeak.heapDump.heapDumpFile;
+    File resultFile = visibleLeak.resultFile;
+    boolean resultDeleted = resultFile.delete();
+    if (!resultDeleted) {
+      CanaryLog.d("Could not delete result file %s", resultFile.getPath());
+    }
+    boolean heapDumpDeleted = heapDumpFile.delete();
+    if (!heapDumpDeleted) {
+      CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.getPath());
+    }
+    visibleLeakRefKey = null;
+    leaks.remove(visibleLeak);
+    updateUi();
+  }
+
+  void deleteAllLeaks() {
+    leakDirectoryProvider(DisplayLeakActivity.this).clearLeakDirectory();
+    leaks = Collections.emptyList();
+    updateUi();
+  }
+
+  void updateUi() {
     if (leaks == null) {
       setTitle("Loading leaks...");
       return;
@@ -215,14 +264,23 @@ private void updateUi() {
       if (result.failure != null) {
         listView.setVisibility(GONE);
         failureView.setVisibility(VISIBLE);
-        failureView.setText(
-            getString(R.string.leak_canary_failure_report) + Log.getStackTraceString(
-                result.failure));
+        String failureMessage = getString(R.string.leak_canary_failure_report)
+            + LIBRARY_VERSION
+            + " "
+            + GIT_SHA
+            + "\n"
+            + Log.getStackTraceString(result.failure);
+        failureView.setText(failureMessage);
         setTitle(R.string.leak_canary_analysis_failed);
         invalidateOptionsMenu();
         getActionBar().setDisplayHomeAsUpEnabled(true);
         actionButton.setVisibility(VISIBLE);
         actionButton.setText(R.string.leak_canary_delete);
+        actionButton.setOnClickListener(new View.OnClickListener() {
+          @Override public void onClick(View v) {
+            deleteVisibleLeak();
+          }
+        });
         listView.setAdapter(null);
       } else {
         final DisplayLeakAdapter adapter;
@@ -243,20 +301,15 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
           actionButton.setText(R.string.leak_canary_delete);
           actionButton.setOnClickListener(new View.OnClickListener() {
             @Override public void onClick(View v) {
-              Leak visibleLeak = getVisibleLeak();
-              File resultFile = leakResultFile(visibleLeak.heapDump.heapDumpFile);
-              resultFile.delete();
-              visibleLeak.heapDump.heapDumpFile.delete();
-              visibleLeakRefKey = null;
-              leaks.remove(visibleLeak);
-              updateUi();
+              deleteVisibleLeak();
             }
           });
         }
         HeapDump heapDump = visibleLeak.heapDump;
         adapter.update(result.leakTrace, heapDump.referenceKey, heapDump.referenceName);
-        setTitle(
-            getString(R.string.leak_canary_class_has_leaked, classSimpleName(result.className)));
+        String size = formatShortFileSize(this, result.retainedHeapSize);
+        String className = classSimpleName(result.className);
+        setTitle(getString(R.string.leak_canary_class_has_leaked, className, size));
       }
     } else {
       if (listAdapter instanceof LeakListAdapter) {
@@ -277,14 +330,17 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
         actionButton.setText(R.string.leak_canary_delete_all);
         actionButton.setOnClickListener(new View.OnClickListener() {
           @Override public void onClick(View v) {
-            File[] files = detectedLeakDirectory().listFiles();
-            if (files != null) {
-              for (File file : files) {
-                file.delete();
-              }
-            }
-            leaks = Collections.emptyList();
-            updateUi();
+            new AlertDialog.Builder(DisplayLeakActivity.this).setIcon(
+                android.R.drawable.ic_dialog_alert)
+                .setTitle(R.string.leak_canary_delete_all)
+                .setMessage(R.string.leak_canary_delete_all_leaks_title)
+                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
+                  @Override public void onClick(DialogInterface dialog, int which) {
+                    deleteAllLeaks();
+                  }
+                })
+                .setNegativeButton(android.R.string.cancel, null)
+                .show();
           }
         });
       }
@@ -292,7 +348,7 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
     }
   }
 
-  private Leak getVisibleLeak() {
+  Leak getVisibleLeak() {
     if (leaks == null) {
       return null;
     }
@@ -323,21 +379,21 @@ private Leak getVisibleLeak() {
         convertView = LayoutInflater.from(DisplayLeakActivity.this)
             .inflate(R.layout.leak_canary_leak_row, parent, false);
       }
-      TextView titleView = (TextView) convertView.findViewById(R.id.__leak_canary_row_text);
-      TextView timeView = (TextView) convertView.findViewById(R.id.__leak_canary_row_time);
+      TextView titleView = (TextView) convertView.findViewById(R.id.leak_canary_row_text);
+      TextView timeView = (TextView) convertView.findViewById(R.id.leak_canary_row_time);
       Leak leak = getItem(position);
 
-      String index;
-      if (position == 0 && leaks.size() == maxStoredLeaks) {
-        index = "MAX. ";
-      } else {
-        index = (leaks.size() - position) + ". ";
-      }
+      String index = (leaks.size() - position) + ". ";
 
       String title;
       if (leak.result.failure == null) {
-        title = index + getString(R.string.leak_canary_class_has_leaked,
-            classSimpleName(leak.result.className));
+        String className = classSimpleName(leak.result.className);
+        String size = formatShortFileSize(DisplayLeakActivity.this, leak.result.retainedHeapSize);
+        title = getString(R.string.leak_canary_class_has_leaked, className, size);
+        if (leak.result.excludedLeak) {
+          title = getString(R.string.leak_canary_excluded_row, title);
+        }
+        title = index + title;
       } else {
         title = index
             + leak.result.failure.getClass().getSimpleName()
@@ -345,8 +401,9 @@ private Leak getVisibleLeak() {
             + leak.result.failure.getMessage();
       }
       titleView.setText(title);
-      String time = DateUtils.formatDateTime(DisplayLeakActivity.this,
-          leak.heapDump.heapDumpFile.lastModified(), FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
+      String time =
+          DateUtils.formatDateTime(DisplayLeakActivity.this, leak.resultFile.lastModified(),
+              FORMAT_SHOW_TIME | FORMAT_SHOW_DATE);
       timeView.setText(time);
       return convertView;
     }
@@ -355,10 +412,12 @@ private Leak getVisibleLeak() {
   static class Leak {
     final HeapDump heapDump;
     final AnalysisResult result;
+    final File resultFile;
 
-    Leak(HeapDump heapDump, AnalysisResult result) {
+    Leak(HeapDump heapDump, AnalysisResult result, File resultFile) {
       this.heapDump = heapDump;
       this.result = result;
+      this.resultFile = resultFile;
     }
   }
 
@@ -366,10 +425,10 @@ private Leak getVisibleLeak() {
 
     static final List<LoadLeaks> inFlight = new ArrayList<>();
 
-    static final Executor backgroundExecutor = Executors.newSingleThreadExecutor();
+    static final Executor backgroundExecutor = newSingleThreadExecutor("LoadLeaks");
 
-    static void load(DisplayLeakActivity activity) {
-      LoadLeaks loadLeaks = new LoadLeaks(activity);
+    static void load(DisplayLeakActivity activity, LeakDirectoryProvider leakDirectoryProvider) {
+      LoadLeaks loadLeaks = new LoadLeaks(activity, leakDirectoryProvider);
       inFlight.add(loadLeaks);
       backgroundExecutor.execute(loadLeaks);
     }
@@ -381,56 +440,56 @@ static void forgetActivity() {
       inFlight.clear();
     }
 
-    private DisplayLeakActivity activityOrNull;
-    private final File leakDirectory;
+    DisplayLeakActivity activityOrNull;
+    private final LeakDirectoryProvider leakDirectoryProvider;
     private final Handler mainHandler;
 
-    LoadLeaks(DisplayLeakActivity activity) {
+    LoadLeaks(DisplayLeakActivity activity, LeakDirectoryProvider leakDirectoryProvider) {
       this.activityOrNull = activity;
-      leakDirectory = detectedLeakDirectory();
+      this.leakDirectoryProvider = leakDirectoryProvider;
       mainHandler = new Handler(Looper.getMainLooper());
     }
 
     @Override public void run() {
       final List<Leak> leaks = new ArrayList<>();
-      File[] files = leakDirectory.listFiles(new FilenameFilter() {
+      List<File> files = leakDirectoryProvider.listFiles(new FilenameFilter() {
         @Override public boolean accept(File dir, String filename) {
-          return filename.endsWith(".hprof");
+          return filename.endsWith(".result");
         }
       });
-      if (files != null) {
-        for (File heapDumpFile : files) {
-          File resultFile = leakResultFile(heapDumpFile);
-          FileInputStream fis = null;
-          try {
-            fis = new FileInputStream(resultFile);
-            ObjectInputStream ois = new ObjectInputStream(fis);
-            HeapDump heapDump = (HeapDump) ois.readObject();
-            AnalysisResult result = (AnalysisResult) ois.readObject();
-            leaks.add(new Leak(heapDump, result));
-          } catch (IOException | ClassNotFoundException e) {
-            // Likely a change in the serializable result class.
-            // Let's remove the files, we can't read them anymore.
-            heapDumpFile.delete();
-            resultFile.delete();
-            Log.e(TAG, "Could not read result file, deleted result and heap dump:" + heapDumpFile,
-                e);
-          } finally {
-            if (fis != null) {
-              try {
-                fis.close();
-              } catch (IOException ignored) {
-              }
+      for (File resultFile : files) {
+        FileInputStream fis = null;
+        try {
+          fis = new FileInputStream(resultFile);
+          ObjectInputStream ois = new ObjectInputStream(fis);
+          HeapDump heapDump = (HeapDump) ois.readObject();
+          AnalysisResult result = (AnalysisResult) ois.readObject();
+          leaks.add(new Leak(heapDump, result, resultFile));
+        } catch (IOException | ClassNotFoundException e) {
+          // Likely a change in the serializable result class.
+          // Let's remove the files, we can't read them anymore.
+          boolean deleted = resultFile.delete();
+          if (deleted) {
+            CanaryLog.d(e, "Could not read result file %s, deleted it.", resultFile);
+          } else {
+            CanaryLog.d(e, "Could not read result file %s, could not delete it either.",
+                resultFile);
+          }
+        } finally {
+          if (fis != null) {
+            try {
+              fis.close();
+            } catch (IOException ignored) {
             }
           }
         }
-        Collections.sort(leaks, new Comparator<Leak>() {
-          @Override public int compare(Leak lhs, Leak rhs) {
-            return Long.valueOf(rhs.heapDump.heapDumpFile.lastModified())
-                .compareTo(lhs.heapDump.heapDumpFile.lastModified());
-          }
-        });
       }
+      Collections.sort(leaks, new Comparator<Leak>() {
+        @Override public int compare(Leak lhs, Leak rhs) {
+          return Long.valueOf(rhs.resultFile.lastModified())
+              .compareTo(lhs.resultFile.lastModified());
+        }
+      });
       mainHandler.post(new Runnable() {
         @Override public void run() {
           inFlight.remove(LoadLeaks.this);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
index cb16c7fe..4e71b4f1 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/DisplayLeakAdapter.java
@@ -22,6 +22,7 @@
 import android.view.ViewGroup;
 import android.widget.BaseAdapter;
 import android.widget.TextView;
+import com.squareup.leakcanary.Exclusion;
 import com.squareup.leakcanary.LeakTrace;
 import com.squareup.leakcanary.LeakTraceElement;
 import com.squareup.leakcanary.R;
@@ -51,14 +52,14 @@
         convertView =
             LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_top_row, parent, false);
       }
-      TextView textView = findById(convertView, R.id.__leak_canary_row_text);
+      TextView textView = findById(convertView, R.id.leak_canary_row_text);
       textView.setText(context.getPackageName());
     } else {
       if (convertView == null) {
         convertView =
             LayoutInflater.from(context).inflate(R.layout.leak_canary_ref_row, parent, false);
       }
-      TextView textView = findById(convertView, R.id.__leak_canary_row_text);
+      TextView textView = findById(convertView, R.id.leak_canary_row_text);
 
       boolean isRoot = position == 1;
       boolean isLeakingInstance = position == getCount() - 1;
@@ -69,7 +70,7 @@
       }
       textView.setText(Html.fromHtml(htmlString));
 
-      DisplayLeakConnectorView connector = findById(convertView, R.id.__leak_canary_row_connector);
+      DisplayLeakConnectorView connector = findById(convertView, R.id.leak_canary_row_connector);
       if (isRoot) {
         connector.setType(DisplayLeakConnectorView.Type.START);
       } else {
@@ -79,7 +80,7 @@
           connector.setType(DisplayLeakConnectorView.Type.NODE);
         }
       }
-      MoreDetailsView moreDetailsView = findById(convertView, R.id.__leak_canary_row_more);
+      MoreDetailsView moreDetailsView = findById(convertView, R.id.leak_canary_row_more);
       moreDetailsView.setOpened(opened[position]);
     }
 
@@ -132,6 +133,23 @@ private String elementToHtmlString(LeakTraceElement element, boolean root, boole
     if (opened && element.extra != null) {
       htmlString += " <font color='#919191'>" + element.extra + "</font>";
     }
+
+    Exclusion exclusion = element.exclusion;
+    if (exclusion != null) {
+      if (opened) {
+        htmlString += "<br/><br/>Excluded by rule";
+        if (exclusion.name != null) {
+          htmlString += " <font color='#ffffff'>" + exclusion.name + "</font>";
+        }
+        htmlString += " matching <font color='#f3cf83'>" + exclusion.matching + "</font>";
+        if (exclusion.reason != null) {
+          htmlString += " because <font color='#f3cf83'>" + exclusion.reason + "</font>";
+        }
+      } else {
+        htmlString += " (excluded)";
+      }
+    }
+
     return htmlString;
   }
 
@@ -178,7 +196,8 @@ public void toggleRow(int position) {
     return position;
   }
 
-  @SuppressWarnings("unchecked") private static <T extends View> T findById(View view, int id) {
+  @SuppressWarnings({ "unchecked", "TypeParameterUnusedInFormals" })
+  private static <T extends View> T findById(View view, int id) {
     return (T) view.findViewById(id);
   }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
index 0bcaf9e0..d03dad94 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/HeapAnalyzerService.java
@@ -18,9 +18,9 @@
 import android.app.IntentService;
 import android.content.Context;
 import android.content.Intent;
-import android.util.Log;
 import com.squareup.leakcanary.AbstractAnalysisResultService;
 import com.squareup.leakcanary.AnalysisResult;
+import com.squareup.leakcanary.CanaryLog;
 import com.squareup.leakcanary.HeapAnalyzer;
 import com.squareup.leakcanary.HeapDump;
 
@@ -32,7 +32,6 @@
 
   private static final String LISTENER_CLASS_EXTRA = "listener_class_extra";
   private static final String HEAPDUMP_EXTRA = "heapdump_extra";
-  public static final String TAG = "HeapAnalyzerService";
 
   public static void runAnalysis(Context context, HeapDump heapDump,
       Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
@@ -48,7 +47,7 @@ public HeapAnalyzerService() {
 
   @Override protected void onHandleIntent(Intent intent) {
     if (intent == null) {
-      Log.d(TAG, "HeapAnalyzerService received a null intent, ignoring.");
+      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
       return;
     }
     String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
index ac8ecba7..8a4ba98f 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanaryInternals.java
@@ -15,16 +15,21 @@
  */
 package com.squareup.leakcanary.internal;
 
+import android.annotation.TargetApi;
 import android.app.ActivityManager;
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
 import android.app.Service;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ServiceInfo;
-import android.os.Environment;
-import android.util.Log;
-import java.io.File;
+import com.squareup.leakcanary.CanaryLog;
+import com.squareup.leakcanary.R;
+import java.util.List;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 
@@ -32,57 +37,29 @@
 import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
 import static android.content.pm.PackageManager.DONT_KILL_APP;
 import static android.content.pm.PackageManager.GET_SERVICES;
-import static android.os.Environment.DIRECTORY_DOWNLOADS;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.JELLY_BEAN;
+import static android.os.Build.VERSION_CODES.O;
 
 public final class LeakCanaryInternals {
 
-  // SDK INT for API 22.
-  public static final int LOLLIPOP_MR1 = 22;
   public static final String SAMSUNG = "samsung";
   public static final String MOTOROLA = "motorola";
+  public static final String LENOVO = "LENOVO";
   public static final String LG = "LGE";
   public static final String NVIDIA = "NVIDIA";
+  public static final String MEIZU = "Meizu";
+  public static final String HUAWEI = "HUAWEI";
+  public static final String VIVO = "vivo";
 
-  private static final Executor fileIoExecutor = Executors.newSingleThreadExecutor();
+  private static final Executor fileIoExecutor = newSingleThreadExecutor("File-IO");
+
+  private static final String NOTIFICATION_CHANNEL_ID = "leakcanary";
 
   public static void executeOnFileIoThread(Runnable runnable) {
     fileIoExecutor.execute(runnable);
   }
 
-  public static File storageDirectory() {
-    File downloadsDirectory = Environment.getExternalStoragePublicDirectory(DIRECTORY_DOWNLOADS);
-    File leakCanaryDirectory = new File(downloadsDirectory, "leakcanary");
-    leakCanaryDirectory.mkdirs();
-    return leakCanaryDirectory;
-  }
-
-  public static File detectedLeakDirectory() {
-    File directory = new File(storageDirectory(), "detected_leaks");
-    directory.mkdirs();
-    return directory;
-  }
-
-  public static File leakResultFile(File heapdumpFile) {
-    return new File(heapdumpFile.getParentFile(), heapdumpFile.getName() + ".result");
-  }
-
-  public static boolean isExternalStorageWritable() {
-    String state = Environment.getExternalStorageState();
-    return Environment.MEDIA_MOUNTED.equals(state);
-  }
-
-  public static File findNextAvailableHprofFile(int maxFiles) {
-    File directory = detectedLeakDirectory();
-    for (int i = 0; i < maxFiles; i++) {
-      String heapDumpName = "heap_dump_" + i + ".hprof";
-      File file = new File(directory, heapDumpName);
-      if (!file.exists()) {
-        return file;
-      }
-    }
-    return null;
-  }
-
   /** Extracts the class simple name out of a string containing a fully qualified class name. */
   public static String classSimpleName(String className) {
     int separator = className.lastIndexOf('.');
@@ -98,22 +75,27 @@ public static void setEnabled(Context context, final Class<?> componentClass,
     final Context appContext = context.getApplicationContext();
     executeOnFileIoThread(new Runnable() {
       @Override public void run() {
-        ComponentName component = new ComponentName(appContext, componentClass);
-        PackageManager packageManager = appContext.getPackageManager();
-        int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
-        // Blocks on IPC.
-        packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
+        setEnabledBlocking(appContext, componentClass, enabled);
       }
     });
   }
 
+  public static void setEnabledBlocking(Context appContext, Class<?> componentClass,
+      boolean enabled) {
+    ComponentName component = new ComponentName(appContext, componentClass);
+    PackageManager packageManager = appContext.getPackageManager();
+    int newState = enabled ? COMPONENT_ENABLED_STATE_ENABLED : COMPONENT_ENABLED_STATE_DISABLED;
+    // Blocks on IPC.
+    packageManager.setComponentEnabledSetting(component, newState, DONT_KILL_APP);
+  }
+
   public static boolean isInServiceProcess(Context context, Class<? extends Service> serviceClass) {
     PackageManager packageManager = context.getPackageManager();
     PackageInfo packageInfo;
     try {
       packageInfo = packageManager.getPackageInfo(context.getPackageName(), GET_SERVICES);
     } catch (Exception e) {
-      Log.e("AndroidUtils", "Could not get package info for " + context.getPackageName(), e);
+      CanaryLog.d(e, "Could not get package info for %s", context.getPackageName());
       return false;
     }
     String mainProcess = packageInfo.applicationInfo.processName;
@@ -128,8 +110,7 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
     }
 
     if (serviceInfo.processName.equals(mainProcess)) {
-      Log.e("AndroidUtils",
-          "Did not expect service " + serviceClass + " to run in main process " + mainProcess);
+      CanaryLog.d("Did not expect service %s to run in main process %s", serviceClass, mainProcess);
       // Technically we are in the service process, but we're not in the service dedicated process.
       return false;
     }
@@ -138,20 +119,65 @@ public static boolean isInServiceProcess(Context context, Class<? extends Servic
     ActivityManager activityManager =
         (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
     ActivityManager.RunningAppProcessInfo myProcess = null;
-    for (ActivityManager.RunningAppProcessInfo process : activityManager.getRunningAppProcesses()) {
-      if (process.pid == myPid) {
-        myProcess = process;
-        break;
+    List<ActivityManager.RunningAppProcessInfo> runningProcesses =
+        activityManager.getRunningAppProcesses();
+    if (runningProcesses != null) {
+      for (ActivityManager.RunningAppProcessInfo process : runningProcesses) {
+        if (process.pid == myPid) {
+          myProcess = process;
+          break;
+        }
       }
     }
     if (myProcess == null) {
-      Log.e("AndroidUtils", "Could not find running process for " + myPid);
+      CanaryLog.d("Could not find running process for %d", myPid);
       return false;
     }
 
     return myProcess.processName.equals(serviceInfo.processName);
   }
 
+  public static void showNotification(Context context, CharSequence contentTitle,
+      CharSequence contentText, PendingIntent pendingIntent, int notificationId) {
+    NotificationManager notificationManager =
+        (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+    Notification notification;
+    Notification.Builder builder = new Notification.Builder(context) //
+        .setSmallIcon(R.drawable.leak_canary_notification)
+        .setWhen(System.currentTimeMillis())
+        .setContentTitle(contentTitle)
+        .setContentText(contentText)
+        .setAutoCancel(true)
+        .setContentIntent(pendingIntent);
+    if (SDK_INT >= O) {
+      String channelName = context.getString(R.string.leak_canary_notification_channel);
+      setupNotificationChannel(channelName, notificationManager, builder);
+    }
+    if (SDK_INT < JELLY_BEAN) {
+      notification = builder.getNotification();
+    } else {
+      notification = builder.build();
+    }
+    notificationManager.notify(notificationId, notification);
+  }
+
+  @TargetApi(O)
+  private static void setupNotificationChannel(String channelName,
+      NotificationManager notificationManager, Notification.Builder builder) {
+    if (notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID) == null) {
+      NotificationChannel notificationChannel =
+          new NotificationChannel(NOTIFICATION_CHANNEL_ID, channelName,
+              NotificationManager.IMPORTANCE_DEFAULT);
+      notificationManager.createNotificationChannel(notificationChannel);
+    }
+    builder.setChannelId(NOTIFICATION_CHANNEL_ID);
+  }
+
+  public static Executor newSingleThreadExecutor(String threadName) {
+    return Executors.newSingleThreadExecutor(new LeakCanarySingleThreadFactory(threadName));
+  }
+
   private LeakCanaryInternals() {
     throw new AssertionError();
   }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
new file mode 100644
index 00000000..4eb3a3a0
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/LeakCanarySingleThreadFactory.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * This is intended to only be used with a single thread executor.
+ */
+final class LeakCanarySingleThreadFactory implements ThreadFactory {
+
+  private final String threadName;
+
+  LeakCanarySingleThreadFactory(String threadName) {
+    this.threadName = "LeakCanary-" + threadName;
+  }
+
+  @Override public Thread newThread(Runnable runnable) {
+    return new Thread(runnable, threadName);
+  }
+}
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
new file mode 100644
index 00000000..1146ac21
--- /dev/null
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/internal/RequestStoragePermissionActivity.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.leakcanary.internal;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import android.widget.Toast;
+import com.squareup.leakcanary.R;
+
+import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
+import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
+import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
+import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
+import static android.os.Build.VERSION_CODES.M;
+import static android.widget.Toast.LENGTH_LONG;
+import static com.squareup.leakcanary.internal.LeakCanaryInternals.setEnabledBlocking;
+
+@TargetApi(M) //
+public class RequestStoragePermissionActivity extends Activity {
+
+  public static PendingIntent createPendingIntent(Context context) {
+    setEnabledBlocking(context, RequestStoragePermissionActivity.class, true);
+    Intent intent = new Intent(context, RequestStoragePermissionActivity.class);
+    intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TOP);
+    return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
+  }
+
+  @Override protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    if (savedInstanceState == null) {
+      if (hasStoragePermission()) {
+        finish();
+        return;
+      }
+      String[] permissions = {
+          WRITE_EXTERNAL_STORAGE
+      };
+      requestPermissions(permissions, 42);
+    }
+  }
+
+  @Override public void onRequestPermissionsResult(int requestCode, String[] permissions,
+      int[] grantResults) {
+    if (!hasStoragePermission()) {
+      Toast.makeText(getApplication(), R.string.leak_canary_permission_not_granted, LENGTH_LONG)
+          .show();
+    }
+    finish();
+  }
+
+  @Override public void finish() {
+    // Reset the animation to avoid flickering.
+    overridePendingTransition(0, 0);
+    super.finish();
+  }
+
+  private boolean hasStoragePermission() {
+    return checkSelfPermission(WRITE_EXTERNAL_STORAGE) == PERMISSION_GRANTED;
+  }
+}
diff --git a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png
deleted file mode 100755
index f1049229..00000000
Binary files a/leakcanary-android/src/main/res/drawable-hdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png
index 7e375c54..74348d82 100755
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png
index 09c78cc0..13b33116 100755
Binary files a/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-hdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png
deleted file mode 100755
index d29b9f1d..00000000
Binary files a/leakcanary-android/src/main/res/drawable-mdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png
index f354c3f2..37f5057f 100755
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png
index c825fa4a..dc92783b 100755
Binary files a/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-mdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index d0cdbcd8..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png
index a5e85b41..56a94f27 100755
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png
index b2978d57..1e1b977f 100755
Binary files a/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 0194b4e1..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png
index 3d4b76af..34b7d41b 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png
index 22db2020..c652efdd 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png
deleted file mode 100755
index 05141619..00000000
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi-v11/leak_canary_notification.png and /dev/null differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png
index eb9c0724..855d6052 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_icon.png differ
diff --git a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png
index 34b76141..bb458f2c 100755
Binary files a/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png and b/leakcanary-android/src/main/res/drawable-xxxhdpi/leak_canary_notification.png differ
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
index d9d312e0..8e56c3d1 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_display_leak.xml
@@ -21,7 +21,7 @@
     android:background="#3c3c3c"
     >
   <ListView
-      android:id="@+id/__leak_canary_display_leak_list"
+      android:id="@+id/leak_canary_display_leak_list"
       android:layout_width="match_parent"
       android:layout_height="0dp"
       android:layout_weight="1"
@@ -29,7 +29,7 @@
       android:divider="@null"
       />
   <TextView
-      android:id="@+id/__leak_canary_display_leak_failure"
+      android:id="@+id/leak_canary_display_leak_failure"
       android:layout_width="match_parent"
       android:layout_height="0dp"
       android:layout_weight="1"
@@ -37,7 +37,7 @@
       android:visibility="gone"
       />
   <Button
-      android:id="@+id/__leak_canary_action"
+      android:id="@+id/leak_canary_action"
       android:layout_width="match_parent"
       android:layout_height="wrap_content"
       android:visibility="gone"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
index 00e291b4..c5c5ac7f 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_leak_row.xml
@@ -23,7 +23,7 @@
     >
 
   <TextView
-      android:id="@+id/__leak_canary_row_text"
+      android:id="@+id/leak_canary_row_text"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="wrap_content"
@@ -32,7 +32,7 @@
       />
 
   <TextView
-      android:id="@+id/__leak_canary_row_time"
+      android:id="@+id/leak_canary_row_time"
       android:layout_width="wrap_content"
       android:layout_height="wrap_content"
       android:layout_gravity="center_vertical"
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
index 7e8721f7..947af46c 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_row.xml
@@ -22,15 +22,15 @@
     >
 
   <com.squareup.leakcanary.internal.DisplayLeakConnectorView
-      android:id="@+id/__leak_canary_row_connector"
+      android:id="@+id/leak_canary_row_connector"
       android:layout_width="16dp"
       android:layout_height="match_parent"
-      android:layout_marginLeft="16dp"
-      android:layout_marginRight="16dp"
+      android:layout_marginStart="16dp"
+      android:layout_marginEnd="16dp"
       />
 
   <TextView
-      android:id="@+id/__leak_canary_row_text"
+      android:id="@+id/leak_canary_row_text"
       android:layout_width="0dp"
       android:layout_weight="1"
       android:layout_height="wrap_content"
@@ -38,12 +38,12 @@
       />
 
   <com.squareup.leakcanary.internal.MoreDetailsView
-      android:id="@+id/__leak_canary_row_more"
+      android:id="@+id/leak_canary_row_more"
       android:layout_width="12dp"
       android:layout_height="12dp"
       android:layout_gravity="center_vertical"
-      android:layout_marginLeft="16dp"
-      android:layout_marginRight="16dp"
+      android:layout_marginStart="16dp"
+      android:layout_marginEnd="16dp"
       />
 
-</LinearLayout>
\ No newline at end of file
+</LinearLayout>
diff --git a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
index 4fc704b5..c4803b76 100644
--- a/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
+++ b/leakcanary-android/src/main/res/layout/leak_canary_ref_top_row.xml
@@ -16,7 +16,7 @@
   -->
 <TextView
     xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/__leak_canary_row_text"
+    android:id="@+id/leak_canary_row_text"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:layout_margin="16dp"
diff --git a/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
new file mode 100644
index 00000000..cecc8527
--- /dev/null
+++ b/leakcanary-android/src/main/res/values-de/leak_canary_strings.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ Copyright (C) 2015 Square, Inc.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<resources>
+    <string name="leak_canary_class_has_leaked">%1$s hat %2$s geleaked</string>
+    <string name="leak_canary_leak_excluded">[Ausgeschlossen] %1$s hat %2$s geleaked</string>
+    <string name="leak_canary_analysis_failed">Leak Analyse fehlgeschlagen</string>
+    <string name="leak_canary_leak_list_title">Leaks in %s</string>
+    <string name="leak_canary_notification_message">Für mehr Details hier klicken</string>
+    <string name="leak_canary_notification_channel">LeakCanary</string>
+    <string name="leak_canary_share_leak">Info teilen</string>
+    <string name="leak_canary_share_heap_dump">Heap Dump teilen</string>
+    <string name="leak_canary_share_with">Teilen mit…</string>
+    <string name="leak_canary_display_activity_label">Leaks</string>
+    <string name="leak_canary_storage_permission_activity_label">Storage Berechtigung</string>
+    <string name="leak_canary_toast_heap_dump">Sichere den Speicher, die App wird einfrieren. Brrr.</string>
+    <string name="leak_canary_delete">Löschen</string>
+    <string name="leak_canary_failure_report">"Bitte sende diesen Fehler an http://github.com/square/leakcanary\n"</string>
+    <string name="leak_canary_delete_all">Alle löschen</string>
+    <string name="leak_canary_delete_all_leaks_title">Are you sure you want to delete all leaks?</string>
+    <string name="leak_canary_could_not_save_title">Konnte Ergebnis nicht speichern.</string>
+    <string name="leak_canary_could_not_save_text">LeakCanary konnte das Ergebnis der Analyse nicht speichern.</string>
+    <string name="leak_canary_no_leak_title">Kein Leak gefunden</string>
+    <string name="leak_canary_no_leak_text">Der GC war untätig.</string>
+    <string name="leak_canary_excluded_row">[Ausgeschlossen] %s</string>
+    <string name="leak_canary_permission_not_granted">Bitte gewähre die Storage Berechtigung, andernfalls werden Memory Leaks nicht erkannt.</string>
+    <string name="leak_canary_permission_notification_title">Leak erkannt, benötige Berechtigung</string>
+    <string name="leak_canary_permission_notification_text">Hier klicken, um Storage Berechtigung für %s zu aktivieren.</string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_int.xml b/leakcanary-android/src/main/res/values/leak_canary_int.xml
deleted file mode 100644
index 3d2c5ac0..00000000
--- a/leakcanary-android/src/main/res/values/leak_canary_int.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-  ~ Copyright (C) 2015 Square, Inc.
-  ~
-  ~ Licensed under the Apache License, Version 2.0 (the "License");
-  ~ you may not use this file except in compliance with the License.
-  ~ You may obtain a copy of the License at
-  ~
-  ~      http://www.apache.org/licenses/LICENSE-2.0
-  ~
-  ~ Unless required by applicable law or agreed to in writing, software
-  ~ distributed under the License is distributed on an "AS IS" BASIS,
-  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  ~ See the License for the specific language governing permissions and
-  ~ limitations under the License.
-  -->
-<resources>
-  <integer name="leak_canary_max_stored_leaks">7</integer>
-</resources>
\ No newline at end of file
diff --git a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml b/leakcanary-android/src/main/res/values/leak_canary_public.xml
similarity index 77%
rename from leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
rename to leakcanary-android/src/main/res/values/leak_canary_public.xml
index 409cb66b..7e90f597 100644
--- a/leakcanary-android/src/main/res/values-v14/leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_public.xml
@@ -15,6 +15,9 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
-  </style>
-</resources>
\ No newline at end of file
+
+  <public name="leak_canary_display_activity_label" type="string"/>
+  <public name="leak_canary_heap_dump_toast" type="layout"/>
+  <public name="leak_canary_icon" type="drawable"/>
+
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_strings.xml b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
index e0600ff2..faef413c 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_strings.xml
@@ -15,20 +15,28 @@
   ~ limitations under the License.
   -->
 <resources>
-
-  <string name="leak_canary_class_has_leaked">%s has leaked</string>
-  <string name="leak_canary_class_leak_ignored">Ignored %s leak</string>
+  <string name="leak_canary_class_has_leaked">%1$s leaked %2$s</string>
+  <string name="leak_canary_leak_excluded">[Excluded] %1$s leaked %2$s</string>
   <string name="leak_canary_analysis_failed">Leak analysis failed</string>
   <string name="leak_canary_leak_list_title">Leaks in %s</string>
-  <string name="leak_canary_notification_leak_ignored_message">Click to see previous leaks</string>
   <string name="leak_canary_notification_message">Click for more details</string>
+  <string name="leak_canary_notification_channel">LeakCanary</string>
   <string name="leak_canary_share_leak">Share info</string>
   <string name="leak_canary_share_heap_dump">Share heap dump</string>
   <string name="leak_canary_share_with">Share with…</string>
   <string name="leak_canary_display_activity_label">Leaks</string>
+  <string name="leak_canary_storage_permission_activity_label">Storage permission</string>
   <string name="leak_canary_toast_heap_dump">Dumping memory, app will freeze. Brrrr.</string>
   <string name="leak_canary_delete">Delete</string>
   <string name="leak_canary_failure_report">"Please report this failure to http://github.com/square/leakcanary\n"</string>
   <string name="leak_canary_delete_all">Delete all</string>
-
-</resources>
\ No newline at end of file
+  <string name="leak_canary_delete_all_leaks_title">Are you sure you want to delete all leaks?</string>
+  <string name="leak_canary_could_not_save_title">Could not save result.</string>
+  <string name="leak_canary_could_not_save_text">LeakCanary was unable to save the analysis result.</string>
+  <string name="leak_canary_no_leak_title">No leak found</string>
+  <string name="leak_canary_no_leak_text">The GC was being lazy.</string>
+  <string name="leak_canary_excluded_row">[Excluded] %s</string>
+  <string name="leak_canary_permission_not_granted">Please grant external storage permission, otherwise memory leaks will not be detected.</string>
+  <string name="leak_canary_permission_notification_title">Leak detected, need permission</string>
+  <string name="leak_canary_permission_notification_text">Click to enable storage permission for %s.</string>
+</resources>
diff --git a/leakcanary-android/src/main/res/values/leak_canary_themes.xml b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
index 69a56edb..2ca041d4 100644
--- a/leakcanary-android/src/main/res/values/leak_canary_themes.xml
+++ b/leakcanary-android/src/main/res/values/leak_canary_themes.xml
@@ -15,6 +15,14 @@
   ~ limitations under the License.
   -->
 <resources>
-  <style name="leak_canary_LeakCanary.Base" parent="android:Theme">
+  <style name="leak_canary_LeakCanary.Base" parent="android:Theme.Holo">
   </style>
-</resources>
\ No newline at end of file
+
+  <style name="leak_canary_Theme.Transparent" parent="android:Theme">
+    <item name="android:windowIsTranslucent">true</item>
+    <item name="android:windowBackground">@android:color/transparent</item>
+    <item name="android:windowContentOverlay">@null</item>
+    <item name="android:windowNoTitle">true</item>
+    <item name="android:backgroundDimEnabled">false</item>
+  </style>
+</resources>
diff --git a/leakcanary-sample/build.gradle b/leakcanary-sample/build.gradle
index d80081b8..f3fff07b 100644
--- a/leakcanary-sample/build.gradle
+++ b/leakcanary-sample/build.gradle
@@ -1,8 +1,11 @@
 apply plugin: 'com.android.application'
 
 dependencies {
-  debugCompile project(':leakcanary-android')
-  releaseCompile project(':leakcanary-android-no-op');
+  debugImplementation project(':leakcanary-android')
+  releaseImplementation project(':leakcanary-android-no-op')
+
+  testImplementation "junit:junit:4.12"
+  testImplementation "org.robolectric:robolectric:3.4.2"
 }
 
 android {
@@ -26,4 +29,18 @@ android {
   buildTypes {
     debug
   }
+
+  dexOptions {
+    dexInProcess false
+  }
+
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+  }
+
+  testOptions {
+    unitTests {
+      includeAndroidResources = true
+    }
+  }
 }
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
index 942be776..08cb841b 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.java
@@ -19,24 +19,27 @@
 import android.os.StrictMode;
 import com.squareup.leakcanary.LeakCanary;
 
-import static android.os.Build.VERSION.SDK_INT;
-import static android.os.Build.VERSION_CODES.GINGERBREAD;
-
 public class ExampleApplication extends Application {
-
   @Override public void onCreate() {
     super.onCreate();
+    setupLeakCanary();
+  }
+
+  protected void setupLeakCanary() {
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
     enabledStrictMode();
     LeakCanary.install(this);
   }
 
-  private void enabledStrictMode() {
-    if (SDK_INT >= GINGERBREAD) {
-      StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
-          .detectAll() //
-          .penaltyLog() //
-          .penaltyDeath() //
-          .build());
-    }
+  private static void enabledStrictMode() {
+    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder() //
+        .detectAll() //
+        .penaltyLog() //
+        .penaltyDeath() //
+        .build());
   }
 }
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
index fefe52ff..e51f5a9a 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.java
@@ -15,6 +15,7 @@
  */
 package com.example.leakcanary;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.os.AsyncTask;
 import android.os.Bundle;
@@ -35,7 +36,8 @@
     });
   }
 
-  private void startAsyncTask() {
+  @SuppressLint("StaticFieldLeak")
+  void startAsyncTask() {
     // This async task is an anonymous class and therefore has a hidden reference to the outer
     // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation),
     // the activity instance will leak.
diff --git a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png
index 099c77d4..65948fa3 100755
Binary files a/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-hdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png
index da2453c6..5d826c42 100755
Binary files a/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-mdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png
index 35a3ec97..c9c7ec58 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png
index 6b3f35af..cb8a98ab 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png
index 2d77dc1f..3ca3a7f6 100755
Binary files a/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png and b/leakcanary-sample/src/main/res/drawable-xxxhdpi/ic_launcher.png differ
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-sample/src/main/res/values/strings.xml
index 1e112cee..8aa73b33 100644
--- a/leakcanary-sample/src/main/res/values/strings.xml
+++ b/leakcanary-sample/src/main/res/values/strings.xml
@@ -14,11 +14,13 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<resources>
+<resources
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:ignore="MissingTranslation" >
   <string name="app_name">LeakCanary Sample</string>
   <string name="start_async_task">Start new AsyncTask</string>
   <string name="helper_text">Start the async task, <b>rotate the screen</b> and wait for a bit. A
     wild notification appears.
   </string>
-  <string name="__leak_canary_display_activity_label">Leaks Sample</string>
+  <string name="leak_canary_display_activity_label">Leaks Sample</string>
 </resources>
\ No newline at end of file
diff --git a/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java b/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java
new file mode 100644
index 00000000..960cfedb
--- /dev/null
+++ b/leakcanary-sample/src/test/java/com/example/leakcanary/SampleTest.java
@@ -0,0 +1,20 @@
+package com.example.leakcanary;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(constants = BuildConfig.class, application = TestExampleApplication.class)
+public class SampleTest {
+  @Test public void testTheThing() throws Exception {
+    ActivityController<MainActivity> controller =
+        Robolectric.buildActivity(MainActivity.class).create().start().resume().visible();
+    controller.get().findViewById(R.id.async_task).performClick();
+    controller.stop();
+    controller.destroy();
+  }
+}
diff --git a/leakcanary-sample/src/test/java/com/example/leakcanary/TestExampleApplication.java b/leakcanary-sample/src/test/java/com/example/leakcanary/TestExampleApplication.java
new file mode 100644
index 00000000..91750c2b
--- /dev/null
+++ b/leakcanary-sample/src/test/java/com/example/leakcanary/TestExampleApplication.java
@@ -0,0 +1,7 @@
+package com.example.leakcanary;
+
+public class TestExampleApplication extends ExampleApplication {
+  @Override protected void setupLeakCanary() {
+    // No leakcanary in unit tests.
+  }
+}
diff --git a/leakcanary-watcher/build.gradle b/leakcanary-watcher/build.gradle
index ac0cac77..97f1db7b 100644
--- a/leakcanary-watcher/build.gradle
+++ b/leakcanary-watcher/build.gradle
@@ -14,7 +14,7 @@ repositories {
 }
 
 dependencies {
-  testCompile 'junit:junit:4.12'
+  testImplementation 'junit:junit:4.12'
 }
 
 android.libraryVariants.all { variant ->
@@ -33,7 +33,13 @@ android {
   buildToolsVersion rootProject.ext.buildToolsVersion
   defaultConfig {
     minSdkVersion rootProject.ext.minSdkVersion
-    targetSdkVersion rootProject.ext.targetSdkVersion
+  }
+  dexOptions {
+    javaMaxHeapSize '2048M'
+  }
+  lintOptions {
+    disable 'GoogleAppIndexingWarning'
+    error 'ObsoleteSdkInt'
   }
 }
 
@@ -42,4 +48,4 @@ task sourceJar(type: Jar) {
 }
 
 apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
index 9d2dfec4..6ac369eb 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/ExcludedRefs.java
@@ -32,111 +32,161 @@
  */
 public final class ExcludedRefs implements Serializable {
 
-  public final Map<String, Map<String, Boolean>> fieldNameByClassName;
-  public final Map<String, Map<String, Boolean>> staticFieldNameByClassName;
-  public final Map<String, Boolean> threadNames;
-  public final Map<String, Boolean> classNames;
-
-  private ExcludedRefs(Map<String, Map<String, Boolean>> fieldNameByClassName,
-      Map<String, Map<String, Boolean>> staticFieldNameByClassName,
-      Map<String, Boolean> threadNames, Map<String, Boolean> classNames) {
-    // Copy + unmodifiable.
-    this.fieldNameByClassName = unmodifiableMap(new LinkedHashMap<>(fieldNameByClassName));
-    this.staticFieldNameByClassName =
-        unmodifiableMap(new LinkedHashMap<>(staticFieldNameByClassName));
-    this.threadNames = unmodifiableMap(new LinkedHashMap<>(threadNames));
-    this.classNames = unmodifiableMap(new LinkedHashMap<>(classNames));
+  public static Builder builder() {
+    return new BuilderWithParams();
+  }
+
+  public final Map<String, Map<String, Exclusion>> fieldNameByClassName;
+  public final Map<String, Map<String, Exclusion>> staticFieldNameByClassName;
+  public final Map<String, Exclusion> threadNames;
+  public final Map<String, Exclusion> classNames;
+
+  ExcludedRefs(BuilderWithParams builder) {
+    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName);
+    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName);
+    this.threadNames = unmodifiableRefMap(builder.threadNames);
+    this.classNames = unmodifiableRefMap(builder.classNames);
+  }
+
+  private Map<String, Map<String, Exclusion>> unmodifiableRefStringMap(
+      Map<String, Map<String, ParamsBuilder>> mapmap) {
+    LinkedHashMap<String, Map<String, Exclusion>> fieldNameByClassName = new LinkedHashMap<>();
+    for (Map.Entry<String, Map<String, ParamsBuilder>> entry : mapmap.entrySet()) {
+      fieldNameByClassName.put(entry.getKey(), unmodifiableRefMap(entry.getValue()));
+    }
+    return unmodifiableMap(fieldNameByClassName);
+  }
+
+  private Map<String, Exclusion> unmodifiableRefMap(Map<String, ParamsBuilder> fieldBuilderMap) {
+    Map<String, Exclusion> fieldMap = new LinkedHashMap<>();
+    for (Map.Entry<String, ParamsBuilder> fieldEntry : fieldBuilderMap.entrySet()) {
+      fieldMap.put(fieldEntry.getKey(), new Exclusion(fieldEntry.getValue()));
+    }
+    return unmodifiableMap(fieldMap);
   }
 
   @Override public String toString() {
     String string = "";
-    for (Map.Entry<String, Map<String, Boolean>> classes : fieldNameByClassName.entrySet()) {
+    for (Map.Entry<String, Map<String, Exclusion>> classes : fieldNameByClassName.entrySet()) {
       String clazz = classes.getKey();
-      for (Map.Entry<String, Boolean> field : classes.getValue().entrySet()) {
-        String always = field.getValue() ? " (always)" : "";
+      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
+        String always = field.getValue().alwaysExclude ? " (always)" : "";
         string += "| Field: " + clazz + "." + field.getKey() + always + "\n";
       }
     }
-    for (Map.Entry<String, Map<String, Boolean>> classes : staticFieldNameByClassName.entrySet()) {
+    for (Map.Entry<String, Map<String, Exclusion>> classes : staticFieldNameByClassName.entrySet()) {
       String clazz = classes.getKey();
-      for (Map.Entry<String, Boolean> field : classes.getValue().entrySet()) {
-        String always = field.getValue() ? " (always)" : "";
+      for (Map.Entry<String, Exclusion> field : classes.getValue().entrySet()) {
+        String always = field.getValue().alwaysExclude ? " (always)" : "";
         string += "| Static field: " + clazz + "." + field.getKey() + always + "\n";
       }
     }
-    for (Map.Entry<String, Boolean> thread : threadNames.entrySet()) {
-      String always = thread.getValue() ? " (always)" : "";
+    for (Map.Entry<String, Exclusion> thread : threadNames.entrySet()) {
+      String always = thread.getValue().alwaysExclude ? " (always)" : "";
       string += "| Thread:" + thread.getKey() + always + "\n";
     }
-    for (Map.Entry<String, Boolean> clazz : classNames.entrySet()) {
-      String always = clazz.getValue() ? " (always)" : "";
+    for (Map.Entry<String, Exclusion> clazz : classNames.entrySet()) {
+      String always = clazz.getValue().alwaysExclude ? " (always)" : "";
       string += "| Class:" + clazz.getKey() + always + "\n";
     }
     return string;
   }
 
-  public static final class Builder {
-    private final Map<String, Map<String, Boolean>> fieldNameByClassName = new LinkedHashMap<>();
-    private final Map<String, Map<String, Boolean>> staticFieldNameByClassName =
+  static final class ParamsBuilder {
+    String name;
+    String reason;
+    boolean alwaysExclude;
+    final String matching;
+
+    ParamsBuilder(String matching) {
+      this.matching = matching;
+    }
+  }
+
+  public interface Builder {
+    BuilderWithParams instanceField(String className, String fieldName);
+
+    BuilderWithParams staticField(String className, String fieldName);
+
+    BuilderWithParams thread(String threadName);
+
+    BuilderWithParams clazz(String className);
+
+    ExcludedRefs build();
+  }
+
+  public static final class BuilderWithParams implements Builder {
+
+    private final Map<String, Map<String, ParamsBuilder>> fieldNameByClassName =
+        new LinkedHashMap<>();
+    private final Map<String, Map<String, ParamsBuilder>> staticFieldNameByClassName =
         new LinkedHashMap<>();
-    private final Map<String, Boolean> threadNames = new LinkedHashMap<>();
-    private final Map<String, Boolean> classNames = new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> threadNames = new LinkedHashMap<>();
+    private final Map<String, ParamsBuilder> classNames = new LinkedHashMap<>();
 
-    public Builder instanceField(String className, String fieldName) {
-      return instanceField(className, fieldName, false);
+    private ParamsBuilder lastParams;
+
+    BuilderWithParams() {
     }
 
-    public Builder instanceField(String className, String fieldName, boolean always) {
+    @Override public BuilderWithParams instanceField(String className, String fieldName) {
       checkNotNull(className, "className");
       checkNotNull(fieldName, "fieldName");
-      Map<String, Boolean> excludedFields = fieldNameByClassName.get(className);
+      Map<String, ParamsBuilder> excludedFields = fieldNameByClassName.get(className);
       if (excludedFields == null) {
         excludedFields = new LinkedHashMap<>();
         fieldNameByClassName.put(className, excludedFields);
       }
-      excludedFields.put(fieldName, always);
+      lastParams = new ParamsBuilder("field " + className + "#" + fieldName);
+      excludedFields.put(fieldName, lastParams);
       return this;
     }
 
-    public Builder staticField(String className, String fieldName) {
-      return staticField(className, fieldName, false);
-    }
-
-    public Builder staticField(String className, String fieldName, boolean always) {
+    @Override public BuilderWithParams staticField(String className, String fieldName) {
       checkNotNull(className, "className");
       checkNotNull(fieldName, "fieldName");
-      Map<String, Boolean> excludedFields = staticFieldNameByClassName.get(className);
+      Map<String, ParamsBuilder> excludedFields = staticFieldNameByClassName.get(className);
       if (excludedFields == null) {
         excludedFields = new LinkedHashMap<>();
         staticFieldNameByClassName.put(className, excludedFields);
       }
-      excludedFields.put(fieldName, always);
+      lastParams = new ParamsBuilder("static field " + className + "#" + fieldName);
+      excludedFields.put(fieldName, lastParams);
+      return this;
+    }
+
+    @Override public BuilderWithParams thread(String threadName) {
+      checkNotNull(threadName, "threadName");
+      lastParams = new ParamsBuilder("any threads named " + threadName);
+      threadNames.put(threadName, lastParams);
       return this;
     }
 
-    public Builder thread(String threadName) {
-      return thread(threadName, false);
+    /** Ignores all fields and static fields of all subclasses of the provided class name. */
+    @Override public BuilderWithParams clazz(String className) {
+      checkNotNull(className, "className");
+      lastParams = new ParamsBuilder("any subclass of " + className);
+      classNames.put(className, lastParams);
+      return this;
     }
 
-    public Builder thread(String threadName, boolean always) {
-      checkNotNull(threadName, "threadName");
-      threadNames.put(threadName, always);
+    public BuilderWithParams named(String name) {
+      lastParams.name = name;
       return this;
     }
 
-    public Builder clazz(String className) {
-      return thread(className, false);
+    public BuilderWithParams reason(String reason) {
+      lastParams.reason = reason;
+      return this;
     }
 
-    public Builder clazz(String className, boolean always) {
-      checkNotNull(className, "className");
-      classNames.put(className, always);
+    public BuilderWithParams alwaysExclude() {
+      lastParams.alwaysExclude = true;
       return this;
     }
 
-    public ExcludedRefs build() {
-      return new ExcludedRefs(fieldNameByClassName, staticFieldNameByClassName, threadNames,
-          classNames);
+    @Override public ExcludedRefs build() {
+      return new ExcludedRefs(this);
     }
   }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
new file mode 100644
index 00000000..4d87d05e
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Exclusion.java
@@ -0,0 +1,17 @@
+package com.squareup.leakcanary;
+
+import java.io.Serializable;
+
+public final class Exclusion implements Serializable {
+  public final String name;
+  public final String reason;
+  public final boolean alwaysExclude;
+  public final String matching;
+
+  Exclusion(ExcludedRefs.ParamsBuilder builder) {
+    this.name = builder.name;
+    this.reason = builder.reason;
+    this.alwaysExclude = builder.alwaysExclude;
+    this.matching = builder.matching;
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
index 2423dc9b..ee201585 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDump.java
@@ -20,9 +20,16 @@
 
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
 
+/** Data structure holding information about a heap dump. */
 public final class HeapDump implements Serializable {
 
+  /** Receives a heap dump to analyze. */
   public interface Listener {
+    Listener NONE = new Listener() {
+      @Override public void analyze(HeapDump heapDump) {
+      }
+    };
+
     void analyze(HeapDump heapDump);
   }
 
@@ -61,11 +68,4 @@ public HeapDump(File heapDumpFile, String referenceKey, String referenceName,
     this.gcDurationMs = gcDurationMs;
     this.heapDumpDurationMs = heapDumpDurationMs;
   }
-
-  /** Renames the heap dump file and creates a new {@link HeapDump} pointing to it. */
-  public HeapDump renameFile(File newFile) {
-    heapDumpFile.renameTo(newFile);
-    return new HeapDump(newFile, referenceKey, referenceName, excludedRefs, watchDurationMs,
-        gcDurationMs, heapDumpDurationMs);
-  }
 }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
index 715d089a..43a9499d 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/HeapDumper.java
@@ -17,13 +17,19 @@
 
 import java.io.File;
 
+/** Dumps the heap into a file. */
 public interface HeapDumper {
+  HeapDumper NONE = new HeapDumper() {
+    @Override public File dumpHeap() {
+      return RETRY_LATER;
+    }
+  };
 
-  File NO_DUMP = null;
+  File RETRY_LATER = null;
 
   /**
-   * @return a {@link File} referencing the heap dump, or {@link #NO_DUMP} if the heap could not be
-   * dumped.
+   * @return a {@link File} referencing the dumped heap, or {@link #RETRY_LATER} if the heap could
+   * not be dumped.
    */
   File dumpHeap();
 }
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 7d2b9fc4..8a01a472 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -20,9 +20,11 @@
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.Executor;
 
+import static com.squareup.leakcanary.HeapDumper.RETRY_LATER;
 import static com.squareup.leakcanary.Preconditions.checkNotNull;
+import static com.squareup.leakcanary.Retryable.Result.DONE;
+import static com.squareup.leakcanary.Retryable.Result.RETRY;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
 /**
@@ -33,24 +35,9 @@
  */
 public final class RefWatcher {
 
-  public static final RefWatcher DISABLED = new RefWatcher(new Executor() {
-    @Override public void execute(Runnable command) {
-    }
-  }, new DebuggerControl() {
-    @Override public boolean isDebuggerAttached() {
-      // Skips watching.
-      return true;
-    }
-  }, GcTrigger.DEFAULT, new HeapDumper() {
-    @Override public File dumpHeap() {
-      return null;
-    }
-  }, new HeapDump.Listener() {
-    @Override public void analyze(HeapDump heapDump) {
-    }
-  }, new ExcludedRefs.Builder().build());
+  public static final RefWatcher DISABLED = new RefWatcherBuilder<>().build();
 
-  private final Executor watchExecutor;
+  private final WatchExecutor watchExecutor;
   private final DebuggerControl debuggerControl;
   private final GcTrigger gcTrigger;
   private final HeapDumper heapDumper;
@@ -59,7 +46,7 @@
   private final HeapDump.Listener heapdumpListener;
   private final ExcludedRefs excludedRefs;
 
-  public RefWatcher(Executor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
+  RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
       HeapDumper heapDumper, HeapDump.Listener heapdumpListener, ExcludedRefs excludedRefs) {
     this.watchExecutor = checkNotNull(watchExecutor, "watchExecutor");
     this.debuggerControl = checkNotNull(debuggerControl, "debuggerControl");
@@ -82,36 +69,47 @@ public void watch(Object watchedReference) {
 
   /**
    * Watches the provided references and checks if it can be GCed. This method is non blocking,
-   * the check is done on the {@link Executor} this {@link RefWatcher} has been constructed with.
+   * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
+   * with.
    *
    * @param referenceName An logical identifier for the watched object.
    */
   public void watch(Object watchedReference, String referenceName) {
-    checkNotNull(watchedReference, "watchedReference");
-    checkNotNull(referenceName, "referenceName");
-    if (debuggerControl.isDebuggerAttached()) {
+    if (this == DISABLED) {
       return;
     }
+    checkNotNull(watchedReference, "watchedReference");
+    checkNotNull(referenceName, "referenceName");
     final long watchStartNanoTime = System.nanoTime();
     String key = UUID.randomUUID().toString();
     retainedKeys.add(key);
     final KeyedWeakReference reference =
         new KeyedWeakReference(watchedReference, key, referenceName, queue);
 
-    watchExecutor.execute(new Runnable() {
-      @Override public void run() {
-        ensureGone(reference, watchStartNanoTime);
+    ensureGoneAsync(watchStartNanoTime, reference);
+  }
+
+  private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
+    watchExecutor.execute(new Retryable() {
+      @Override public Retryable.Result run() {
+        return ensureGone(reference, watchStartNanoTime);
       }
     });
   }
 
-  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
+  @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
+  Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
     long gcStartNanoTime = System.nanoTime();
-
     long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
+
     removeWeaklyReachableReferences();
-    if (gone(reference) || debuggerControl.isDebuggerAttached()) {
-      return;
+
+    if (debuggerControl.isDebuggerAttached()) {
+      // The debugger can create false leaks.
+      return RETRY;
+    }
+    if (gone(reference)) {
+      return DONE;
     }
     gcTrigger.runGc();
     removeWeaklyReachableReferences();
@@ -120,16 +118,16 @@ void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {
       long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
 
       File heapDumpFile = heapDumper.dumpHeap();
-
-      if (heapDumpFile == HeapDumper.NO_DUMP) {
-        // Could not dump the heap, abort.
-        return;
+      if (heapDumpFile == RETRY_LATER) {
+        // Could not dump the heap.
+        return RETRY;
       }
       long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);
       heapdumpListener.analyze(
           new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
               gcDurationMs, heapDumpDurationMs));
     }
+    return DONE;
   }
 
   private boolean gone(KeyedWeakReference reference) {
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
new file mode 100644
index 00000000..b4c9eb33
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -0,0 +1,124 @@
+package com.squareup.leakcanary;
+
+/**
+ * Responsible for building {@link RefWatcher} instances. Subclasses should provide sane defaults
+ * for the platform they support.
+ */
+public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {
+
+  private ExcludedRefs excludedRefs;
+  private HeapDump.Listener heapDumpListener;
+  private DebuggerControl debuggerControl;
+  private HeapDumper heapDumper;
+  private WatchExecutor watchExecutor;
+  private GcTrigger gcTrigger;
+
+  /** @see HeapDump.Listener */
+  public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
+    this.heapDumpListener = heapDumpListener;
+    return self();
+  }
+
+  /** @see ExcludedRefs */
+  public final T excludedRefs(ExcludedRefs excludedRefs) {
+    this.excludedRefs = excludedRefs;
+    return self();
+  }
+
+  /** @see HeapDumper */
+  public final T heapDumper(HeapDumper heapDumper) {
+    this.heapDumper = heapDumper;
+    return self();
+  }
+
+  /** @see DebuggerControl */
+  public final T debuggerControl(DebuggerControl debuggerControl) {
+    this.debuggerControl = debuggerControl;
+    return self();
+  }
+
+  /** @see WatchExecutor */
+  public final T watchExecutor(WatchExecutor watchExecutor) {
+    this.watchExecutor = watchExecutor;
+    return self();
+  }
+
+  /** @see GcTrigger */
+  public final T gcTrigger(GcTrigger gcTrigger) {
+    this.gcTrigger = gcTrigger;
+    return self();
+  }
+
+  /** Creates a {@link RefWatcher}. */
+  public final RefWatcher build() {
+    if (isDisabled()) {
+      return RefWatcher.DISABLED;
+    }
+
+    ExcludedRefs excludedRefs = this.excludedRefs;
+    if (excludedRefs == null) {
+      excludedRefs = defaultExcludedRefs();
+    }
+
+    HeapDump.Listener heapDumpListener = this.heapDumpListener;
+    if (heapDumpListener == null) {
+      heapDumpListener = defaultHeapDumpListener();
+    }
+
+    DebuggerControl debuggerControl = this.debuggerControl;
+    if (debuggerControl == null) {
+      debuggerControl = defaultDebuggerControl();
+    }
+
+    HeapDumper heapDumper = this.heapDumper;
+    if (heapDumper == null) {
+      heapDumper = defaultHeapDumper();
+    }
+
+    WatchExecutor watchExecutor = this.watchExecutor;
+    if (watchExecutor == null) {
+      watchExecutor = defaultWatchExecutor();
+    }
+
+    GcTrigger gcTrigger = this.gcTrigger;
+    if (gcTrigger == null) {
+      gcTrigger = defaultGcTrigger();
+    }
+
+    return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
+        excludedRefs);
+  }
+
+  protected boolean isDisabled() {
+    return false;
+  }
+
+  protected GcTrigger defaultGcTrigger() {
+    return GcTrigger.DEFAULT;
+  }
+
+  protected DebuggerControl defaultDebuggerControl() {
+    return DebuggerControl.NONE;
+  }
+
+  protected ExcludedRefs defaultExcludedRefs() {
+    return ExcludedRefs.builder().build();
+  }
+
+  protected HeapDumper defaultHeapDumper() {
+    return HeapDumper.NONE;
+  }
+
+  protected HeapDump.Listener defaultHeapDumpListener() {
+    return HeapDump.Listener.NONE;
+  }
+
+  protected WatchExecutor defaultWatchExecutor() {
+    return WatchExecutor.NONE;
+  }
+
+  @SuppressWarnings("unchecked")
+  protected final T self() {
+    return (T) this;
+  }
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java
new file mode 100644
index 00000000..d9d19d40
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/Retryable.java
@@ -0,0 +1,11 @@
+package com.squareup.leakcanary;
+
+/** A unit of work that can be retried later. */
+public interface Retryable {
+
+  enum Result {
+    DONE, RETRY
+  }
+
+  Result run();
+}
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java
new file mode 100644
index 00000000..9446877c
--- /dev/null
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/WatchExecutor.java
@@ -0,0 +1,14 @@
+package com.squareup.leakcanary;
+
+/**
+ * A {@link WatchExecutor} is in charge of executing a {@link Retryable} in the future, and retry
+ * later if needed.
+ */
+public interface WatchExecutor {
+  WatchExecutor NONE = new WatchExecutor() {
+    @Override public void execute(Retryable retryable) {
+    }
+  };
+
+  void execute(Retryable retryable);
+}
diff --git a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
index 421ceea0..715d53fc 100644
--- a/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
+++ b/leakcanary-watcher/src/test/java/com/squareup/leakcanary/RefWatcherTest.java
@@ -16,16 +16,16 @@
 package com.squareup.leakcanary;
 
 import java.io.File;
-import java.util.concurrent.Executor;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+@RunWith(JUnit4.class)
 public class RefWatcherTest {
 
-  static final ExcludedRefs NO_REF = new ExcludedRefs.Builder().build();
-
   static class TestDumper implements HeapDumper {
     boolean called;
 
@@ -42,11 +42,11 @@
 
   @SuppressWarnings("FieldCanBeLocal") Object ref;
 
-  static class TestExecutor implements Executor {
-    private Runnable command;
+  static class TestExecutor implements WatchExecutor {
+    Retryable retryable;
 
-    @Override public void execute(Runnable command) {
-      this.command = command;
+    @Override public void execute(Retryable retryable) {
+      this.retryable = retryable;
     }
   }
 
@@ -59,7 +59,7 @@
     TestExecutor executor = new TestExecutor();
     RefWatcher refWatcher = defaultWatcher(dumper, executor);
     refWatcher.watch(new Object());
-    executor.command.run();
+    executor.retryable.run();
     assertFalse(dumper.called);
   }
 
@@ -69,12 +69,14 @@
     RefWatcher refWatcher = defaultWatcher(dumper, executor);
     ref = new Object();
     refWatcher.watch(ref);
-    executor.command.run();
+    executor.retryable.run();
     assertTrue(dumper.called);
   }
 
   private RefWatcher defaultWatcher(TestDumper dumper, TestExecutor executor) {
-    return new RefWatcher(executor, DebuggerControl.NONE, GcTrigger.DEFAULT, dumper,
-        new TestListener(), NO_REF);
+    return new RefWatcherBuilder<>().watchExecutor(executor)
+        .heapDumper(dumper)
+        .heapDumpListener(new TestListener())
+        .build();
   }
 }
