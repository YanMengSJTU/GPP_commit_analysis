diff --git a/build.gradle b/build.gradle
index 7a6154c4..cd06185f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -3,7 +3,7 @@ apply plugin: 'com.github.ben-manes.versions'
 buildscript {
   ext.versions = [
       'minSdk'    : 14,
-      'compileSdk': 28,
+      'compileSdk': 29,
       'errorProne': '2.3.1',
       'kotlin'    : '1.3.21',
   ]
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt
deleted file mode 100644
index edd40ad8..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidExcludedRefs.kt
+++ /dev/null
@@ -1,1220 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import leakcanary.AndroidExcludedRefs.Companion.exclusionsFactory
-import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
-import leakcanary.Exclusion.Status.NEVER_REACHABLE
-import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import java.lang.ref.PhantomReference
-import java.lang.ref.SoftReference
-import java.lang.ref.WeakReference
-import java.util.EnumSet
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- *
- * Most app developers should use [.createAppDefaults]. However, you can also pick the
- * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
- * [exclusionsFactory]
- */
-// Public API.
-enum class AndroidExcludedRefs {
-
-  // ######## Android SDK Excluded refs ########
-
-  ACTIVITY_CLIENT_RECORD__NEXT_IDLE {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt in 19..21) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.app.ActivityThread\$ActivityClientRecord", "nextIdle"
-                ),
-                reason = "Android AOSP sometimes keeps a reference to a destroyed activity as a"
-                    + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-                    + " Not sure what's going on there, input welcome."
-            )
-        )
-      }
-    }
-  },
-
-  SPAN_CONTROLLER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt <= 19) {
-        val reason =
-          ("Editor inserts a special span, which has a reference to the EditText. That span is a"
-              + " NoCopySpan, which makes sure it gets dropped when creating a new"
-              + " SpannableStringBuilder from a given CharSequence."
-              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-              + " reference to the textview and therefore the entire view hierarchy & activity"
-              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.widget.Editor\$SpanController", "this$0"),
-                reason = reason
-            )
-        )
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.widget.Editor\$EasyEditSpanController", "this$0"
-                ),
-                reason = reason
-            )
-        )
-      }
-    }
-  },
-
-  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt == 21) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion(
-                    "android.media.session.MediaSessionLegacyHelper", "sInstance"
-                ),
-                reason = "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-                    + " keeps a reference to the context it's given the first time"
-                    + " MediaSessionLegacyHelper.getHelper() is called."
-                    + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-                    + " calling context.getApplicationContext()."
-                    + " Fix: https://github.com/android/platform_frameworks_base/commit"
-                    + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-                    + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-                    + " in Application.onCreate() and pass it the application context."
-            )
-        )
-      }
-    }
-  },
-
-  TEXT_LINE__SCACHED {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt <= 22) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion("android.text.TextLine", "sCached"),
-                reason = "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-                    + " at least two bugs that created memory leaks by not correctly clearing the"
-                    + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-                    + " https://github.com/android/platform_frameworks_base/commit"
-                    + "/893d6fe48d37f71e683f722457bea646994a10"
-                    + " The second was fixed, not released yet:"
-                    + " https://github.com/android/platform_frameworks_base/commit"
-                    + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-                    + " To fix this, you could access TextLine.sCached and clear the pool every now"
-                    + " and then (e.g. on activity destroy)."
-            )
-        )
-      }
-    }
-  },
-
-  BLOCKING_QUEUE {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      val reason = ("A thread waiting on a blocking queue will leak the last"
-          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-          + " keeps a local reference to the last message it received. That message then gets"
-          + " recycled and can be used again. As long as all messages are recycled after being"
-          + " used, this won't be a problem, because these references are cleared when being"
-          + " recycled. However, dialogs create template Message instances to be copied when a"
-          + " message needs to be sent. These Message templates holds references to the dialog"
-          + " listeners, which most likely leads to holding a reference onto the activity in some"
-          + " way. Dialogs never recycle their template Message, assuming these Message instances"
-          + " will get GCed when the dialog is GCed."
-          + " The combination of these two things creates a high potential for memory leaks as soon"
-          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-          + " sleep for a long time."
-          + " To fix this, you could post empty messages to the idle handler threads from time to"
-          + " time. This won't be easy because you cannot access all handler threads, but a library"
-          + " that is widely used should consider doing this for its own handler threads. This leaks"
-          + " has been shown to happen in both Dalvik and ART.")
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("android.os.Message", "obj"),
-              reason = reason
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("android.os.Message", "next"),
-              reason = reason
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("android.os.Message", "target"),
-              reason = reason
-          )
-      )
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt in 15..27) {
-        val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
-            + " leaks a reference to it until a new view asks for keyboard input."
-            + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-            + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.view.inputmethod.InputMethodManager", "mNextServedView"
-                ),
-                reason = reason
-            )
-        )
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.view.inputmethod.InputMethodManager", "mServedView"
-                ),
-                reason = reason
-            )
-        )
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.view.inputmethod.InputMethodManager", "mServedInputConnection"
-                ),
-                reason = reason
-            )
-        )
-      }
-    }
-  },
-
-  INPUT_METHOD_MANAGER__ROOT_VIEW {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt in 15..28) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.view.inputmethod.InputMethodManager", "mCurRootView"
-                ),
-                reason = "The singleton InputMethodManager is holding a reference to mCurRootView long"
-                    + " after the activity has been destroyed."
-                    + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-                    + "#issuecomment-100579429"
-                    + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
-            )
-        )
-      }
-    }
-  },
-
-  LAYOUT_TRANSITION {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt in 14..22) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.animation.LayoutTransition$1", "val\$parent"
-                ),
-                reason = "LayoutTransition leaks parent ViewGroup through"
-                    + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-                    + " window is destroyed. Tracked here:"
-                    + " https://code.google.com/p/android/issues/detail?id=171830"
-            )
-        )
-      }
-    }
-  },
-
-  SPELL_CHECKER_SESSION {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt in 16..24) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.view.textservice.SpellCheckerSession$1", "this$0"
-                ),
-                reason = "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-                    + " SpellCheckerSession is closed before the service is connected."
-                    + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
-            )
-        )
-      }
-    }
-  },
-
-  SPELL_CHECKER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt == 22) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.widget.SpellChecker$1", "this$0"),
-                reason = "SpellChecker holds on to a detached view that points to a destroyed activity."
-                    + " mSpellRunnable is being enqueued, and that callback should be removed when "
-                    + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
-                    + " called after the view was detached."
-            )
-        )
-      }
-    }
-  },
-
-  ACTIVITY_CHOOSE_MODEL {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      val reason = ("ActivityChooserModel holds a static reference to the last set"
-          + " ActivityChooserModelPolicy which can be an activity context."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
-      if (build.sdkInt in 15..22) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.support.v7.internal.widget.ActivityChooserModel",
-                    "mActivityChoserModelPolicy"
-                ),
-                reason = reason
-            )
-        )
-      }
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion(
-                  "android.widget.ActivityChooserModel", "mActivityChoserModelPolicy"
-              ),
-              reason = reason
-          )
-      )
-    }
-  },
-
-  SPEECH_RECOGNIZER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt < 21) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.speech.SpeechRecognizer\$InternalListener", "this$0"
-                ),
-                reason = "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-                    + " class and leaked the SpeechRecognizer which leaked an activity context."
-                    + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-                    + " /b37866db469e81aca534ff6186bdafd44352329b"
-            )
-        )
-      }
-    }
-  },
-
-  ACCOUNT_MANAGER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt <= 27) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.accounts.AccountManager\$AmsTask\$Response", "this$1"
-                ),
-                reason =
-                "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
-                    + " probably because the reference to the response in the other process hasn't been"
-                    + " cleared."
-                    + " AccountManager\$AmsTask is holding on to the activity reference to use for"
-                    + " launching a new sub- Activity."
-                    + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-                    + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-                    + " with the returned future to to get the result and correctly start an activity"
-                    + " when it's available."
-            )
-        )
-      }
-    }
-  },
-
-  MEDIA_SCANNER_CONNECTION {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt <= 22) exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("android.media.MediaScannerConnection", "mContext"),
-
-              reason =
-              "The static method MediaScannerConnection.scanFile() takes an activity context"
-                  + " but the service might not disconnect after the activity has been destroyed."
-                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-                  + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-                  + " application context. Call connect() and disconnect() manually."
-          )
-      )
-    }
-  },
-
-  USER_MANAGER__SINSTANCE {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt in 18..25) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.os.UserManager", "mContext"),
-                reason =
-                "UserManager has a static sInstance field that creates an instance and caches it"
-                    + " the first time UserManager.get() is called. This instance is created with the"
-                    + " outer context (which is an activity base context)."
-                    + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-                    + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-                    + "/27db46850b708070452c0ce49daf5f79503fbde6"
-                    + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-                    + " UserManager instance gets cached with a reference to the application context."
-            )
-        )
-      }
-    }
-  },
-
-  APP_WIDGET_HOST_CALLBACKS {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt < 22) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.appwidget.AppWidgetHost\$Callbacks", "this$0"
-                ),
-                reason =
-                "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
-                    + " code. The reference to the `mContext` was not being cleared, which caused the"
-                    + " Callbacks instance to retain this reference"
-                    + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-                    + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
-            )
-        )
-      }
-    }
-  },
-
-  AUDIO_MANAGER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt <= 22) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.media.AudioManager$1", "this$0"),
-                reason =
-                "Prior to Android M, VideoView required audio focus from AudioManager and"
-                    + " never abandoned it, which leaks the Activity context through the AudioManager."
-                    + " The root of the problem is that AudioManager uses whichever"
-                    + " context it receives, which in the case of the VideoView example is an Activity,"
-                    + " even though it only needs the application's context. The issue is fixed in"
-                    + " Android M, and the AudioManager now uses the application's context."
-                    + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-                    + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
-            )
-        )
-      }
-    }
-  },
-
-  EDITTEXT_BLINK_MESSAGEQUEUE {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt <= 22) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.widget.Editor\$Blink", "this$0"),
-                reason =
-                "The EditText Blink of the Cursor is implemented using a callback and Messages,"
-                    + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-                    + " contains a blinking cursor is detached, a message is posted with a delay after the"
-                    + " dialog has been closed and as a result leaks the Activity."
-                    + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
-                    + " dismiss() method of the dialog."
-                    + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-                    + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-                    + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
-            )
-        )
-      }
-    }
-  },
-
-  CONNECTIVITY_MANAGER__SINSTANCE {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt <= 23) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.net.ConnectivityManager", "sInstance"),
-                reason =
-                "ConnectivityManager has a sInstance field that is set when the first"
-                    + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
-                    + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
-                    + " ConnectivityManager instance is created with the activity context and stored in"
-                    + " sInstance. That activity context then leaks forever."
-                    + " Until this is fixed, app developers can prevent this leak by making sure the"
-                    + " ConnectivityManager is first created with an App Context. E.g. in some static"
-                    + " init do: context.getApplicationContext()"
-                    + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
-                    + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
-                    + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
-                    + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
-            )
-        )
-      }
-    }
-  },
-
-  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt in 26..27) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.view.accessibility.AccessibilityNodeInfo", "mOriginalText"
-                ),
-                reason =
-                "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
-                    + " AccessibilityNodeInfo instances are released back in the pool,"
-                    + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
-                    + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
-                    + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
-                    + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
-                    + "android/view/accessibility/AccessibilityNodeInfo.java"
-            )
-        )
-      }
-    }
-  },
-
-  BACKDROP_FRAME_RENDERER__MDECORVIEW {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt in 24..26) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "com.android.internal.policy.BackdropFrameRenderer", "mDecorView"
-                ),
-                reason =
-                "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
-                    + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
-                    + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
-                    + " activity"
-            )
-        )
-      }
-    }
-  },
-
-  VIEWLOCATIONHOLDER_ROOT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt == 28) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.view.ViewGroup\$ViewLocationHolder",
-                    "mRoot"
-                ),
-                reason = "In Android P, ViewLocationHolder has an mRoot field that is not cleared " +
-                    "in its clear() method. Introduced in https://github.com/aosp-mirror" +
-                    "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
-                    "report: https://issuetracker.google.com/issues/112792715"
-            )
-        )
-      }
-    }
-  },
-
-  TEXT_TO_SPEECH {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.sdkInt == 24) {
-        val reason =
-          ("TextToSpeech.shutdown() does not release its references to context objects." +
-              " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
-              " keeping the references, resulting the context objects leaked." +
-              " Developers might be able to mitigate the issue by passing application context" +
-              " to TextToSpeech constructor." +
-              " Tracked at: https://github.com/square/leakcanary/issues/1210 and" +
-              " https://issuetracker.google.com/issues/129250419")
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.speech.tts.TextToSpeech", "mContext"),
-                reason = reason
-            )
-        )
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.speech.tts.TtsEngines", "mContext"),
-                reason = reason
-            )
-        )
-      }
-    }
-  },
-
-  // ######## Manufacturer specific Excluded refs ########
-
-  INSTRUMENTATION_RECOMMEND_ACTIVITY {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == MEIZU && build.sdkInt in 21..22) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion("android.app.Instrumentation", "mRecommendActivity"),
-                reason =
-                "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
-                    + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
-                    + " above"
-            )
-        )
-      }
-    }
-  },
-
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == MOTOROLA && build.sdkInt in 19..22) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0"
-                ),
-                reason =
-                "DevicePolicyManager keeps a reference to the context it has been created with"
-                    + " instead of extracting the application context. In this Motorola build,"
-                    + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                    + " observer, which is held into memory by a binder transport object."
-            )
-        )
-      }
-    }
-  },
-
-  SPEN_GESTURE_MANAGER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion(
-                    "com.samsung.android.smartclip.SpenGestureManager", "mContext"
-                ),
-                reason =
-                "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
-            )
-        )
-      }
-    }
-  },
-
-  GESTURE_BOOST_MANAGER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == HUAWEI && build.sdkInt in 24..25) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion("android.gestureboost.GestureBoostManager", "mContext"),
-                reason =
-                "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
-            )
-        )
-      }
-    }
-  },
-
-  INPUT_METHOD_MANAGER__LAST_SERVED_VIEW {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == HUAWEI && build.sdkInt in 23..27) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.view.inputmethod.InputMethodManager", "mLastSrvView"
-                ),
-                reason =
-                "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
-            )
-        )
-      }
-    }
-  },
-
-  CLIPBOARD_UI_MANAGER__SINSTANCE {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt in 19..21) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "android.sec.clipboard.ClipboardUIManager", "mContext"
-                ),
-                reason =
-                "ClipboardUIManager is a static singleton that leaks an activity context."
-                    + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-                    + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-                    + " application context. Example: https://gist.github.com/cypressious/"
-                    + "91c4fb1455470d803a602838dfcd5774"
-            )
-        )
-      }
-    }
-  },
-
-  SEM_CLIPBOARD_MANAGER__MCONTEXT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt in 19..24) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "com.samsung.android.content.clipboard.SemClipboardManager",
-                    "mContext"
-                ),
-                reason =
-                "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
-            )
-        )
-      }
-    }
-  },
-
-  SEM_EMERGENCY_MANAGER__MCONTEXT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt in 19..24) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "com.samsung.android.emergencymode.SemEmergencyManager", "mContext"
-                ),
-                reason =
-                "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
-            )
-        )
-      }
-    }
-  },
-
-  BUBBLE_POPUP_HELPER__SHELPER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == LG && build.sdkInt in 19..21) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion("android.widget.BubblePopupHelper", "sHelper"),
-                reason =
-                "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
-            )
-        )
-      }
-    }
-  },
-
-  LGCONTEXT__MCONTEXT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == LG && build.sdkInt == 21) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("com.lge.systemservice.core.LGContext", "mContext"),
-                reason = "LGContext is a static singleton that leaks an activity context."
-            )
-        )
-      }
-    }
-  },
-
-  AW_RESOURCE__SRESOURCES {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion(
-                    "com.android.org.chromium.android_webview.AwResource", "sResources"
-                )
-            )
-        )
-      }
-    }
-  },
-
-  MAPPER_CLIENT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == NVIDIA && build.sdkInt == 19) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion(
-                    "com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0"
-                ),
-                reason =
-                "Not sure exactly what ControllerMapper is about, but there is an anonymous"
-                    + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-                    + " ControllerMapper.MapperClient which leaks the activity context."
-            )
-        )
-      }
-    }
-  },
-
-  TEXT_VIEW__MLAST_HOVERED_VIEW {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt in 19..26) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion("android.widget.TextView", "mLastHoveredView"),
-                reason =
-                "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
-            )
-        )
-      }
-    }
-  },
-
-  PERSONA_MANAGER {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.os.PersonaManager", "mContext"),
-                reason =
-                "android.app.LoadedApk.mResources has a reference to"
-                    + " android.content.res.Resources.mPersonaManager which has a reference to"
-                    + " android.os.PersonaManager.mContext which is an activity."
-            )
-        )
-      }
-    }
-  },
-
-  RESOURCES__MCONTEXT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.content.res.Resources", "mContext"),
-                reason =
-                "In AOSP the Resources class does not have a context."
-                    + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-                    + " instance that has a context that is the activity."
-                    + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
-            )
-        )
-      }
-    }
-  },
-
-  VIEW_CONFIGURATION__MCONTEXT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
-        exclusions.add(
-            Exclusion(
-                type = InstanceFieldExclusion("android.view.ViewConfiguration", "mContext"),
-                reason =
-                "In AOSP the ViewConfiguration class does not have a context."
-                    + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-                    + " ViewConfiguration instance that has a context that is the activity."
-                    + " Observed here: https://github.com/square/leakcanary/issues"
-                    + "/1#issuecomment-100324683"
-            )
-        )
-      }
-    }
-  },
-
-  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if ((build.manufacturer == LENOVO && build.sdkInt == 19) ||
-          (build.manufacturer == VIVO && build.sdkInt == 22)
-      ) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion(
-                    "android.hardware.SystemSensorManager", "mAppContextImpl"
-                ),
-                reason =
-                "SystemSensorManager stores a reference to context"
-                    + " in a static field in its constructor."
-                    + " Fix: use application context to get SensorManager"
-            )
-        )
-      }
-    }
-  },
-
-  AUDIO_MANAGER__MCONTEXT_STATIC {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == 19) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion("android.media.AudioManager", "mContext_static"),
-                reason =
-                "Samsung added a static mContext_static field to AudioManager, holds a reference"
-                    + " to the activity."
-                    + " Observed here: https://github.com/square/leakcanary/issues/32"
-            )
-        )
-      }
-    }
-  },
-
-  ACTIVITY_MANAGER_MCONTEXT {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      if (build.manufacturer == SAMSUNG && build.sdkInt == 22) {
-        exclusions.add(
-            Exclusion(
-                type = StaticFieldExclusion("android.app.ActivityManager", "mContext"),
-                reason =
-                "Samsung added a static mContext field to ActivityManager, holds a reference"
-                    + " to the activity."
-                    + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
-                    + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
-            )
-        )
-      }
-    }
-  },
-
-  // ######## General exclusions ########
-
-  REFERENCES {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-              status = WEAKLY_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion(
-                  KeyedWeakReference::class.java.name, "referent"
-              ),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion(SoftReference::class.java.name, "referent"),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion(PhantomReference::class.java.name, "referent"),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("java.lang.ref.Finalizer", "prev"),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("java.lang.ref.Finalizer", "element"),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("java.lang.ref.Finalizer", "next"),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "prev"),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "element"),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("java.lang.ref.FinalizerReference", "next"),
-              status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("sun.misc.Cleaner", "prev"), status = NEVER_REACHABLE
-          )
-      )
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion("sun.misc.Cleaner", "next"), status = NEVER_REACHABLE
-          )
-      )
-    }
-  },
-
-  FINALIZER_WATCHDOG_DAEMON {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-      // reference to the object and it was about to be GCed.
-      exclusions.add(
-          Exclusion(
-              type = JavaLocalExclusion("FinalizerWatchdogDaemon"),
-              status = NEVER_REACHABLE
-          )
-      )
-    }
-  },
-
-  MAIN {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      // The main thread stack is ever changing so local variables aren't likely to hold references
-      // for long. If this is on the shortest path, it's probably that there's a longer path with
-      // a real leak.
-      exclusions.add(
-          Exclusion(
-              type = JavaLocalExclusion("main"),
-              status = NEVER_REACHABLE
-          )
-      )
-    }
-  },
-
-  LEAK_CANARY_THREAD {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      exclusions.add(
-          Exclusion(
-              type = JavaLocalExclusion(LEAK_CANARY_THREAD_NAME),
-              status = NEVER_REACHABLE
-          )
-      )
-    }
-  },
-
-  EVENT_RECEIVER__MMESSAGE_QUEUE {
-    override fun add(
-      exclusions: MutableList<Exclusion>,
-      build: BuildMirror
-    ) {
-      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-      // the native peer of the receiver is using them.
-      // The main thread message queue is held on by the main Looper, but that might be a longer
-      // path. Let's not confuse people with a shorter path that is less meaningful.
-      exclusions.add(
-          Exclusion(
-              type = InstanceFieldExclusion(
-                  "android.view.Choreographer\$FrameDisplayEventReceiver",
-                  "mMessageQueue"
-              ),
-              status = NEVER_REACHABLE
-          )
-      )
-    }
-  },
-
-  ;
-
-  protected abstract fun add(
-    exclusions: MutableList<Exclusion>,
-    build: BuildMirror
-  )
-
-  companion object {
-
-    /**
-     * This returns the references in the leak path that should be ignored by all on Android.
-     */
-    val androidDefaults: EnumSet<AndroidExcludedRefs>
-      get() = EnumSet.of(
-          REFERENCES,
-          FINALIZER_WATCHDOG_DAEMON,
-          MAIN,
-          LEAK_CANARY_THREAD,
-          EVENT_RECEIVER__MMESSAGE_QUEUE
-      )
-
-    /**
-     * This returns the references in the leak path that can be ignored for app developers. This
-     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-     */
-    val appDefaults: EnumSet<AndroidExcludedRefs>
-      get() = EnumSet.allOf(
-          AndroidExcludedRefs::class.java
-      )
-
-    fun exclusionsFactory(refs: EnumSet<AndroidExcludedRefs>): ExclusionsFactory =
-      { parser ->
-        val build = BuildMirror.readFromHprof(parser)
-        exclusionsMatchingBuild(refs, build)
-      }
-
-    fun exclusionsMatchingBuild(
-      refs: EnumSet<AndroidExcludedRefs>,
-      build: BuildMirror
-    ): List<Exclusion> {
-      val exclusions = mutableListOf<Exclusion>()
-      refs.forEach { it.add(exclusions, build) }
-      return exclusions
-    }
-
-  }
-}
-
-private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
-private const val SAMSUNG = "samsung"
-private const val MOTOROLA = "motorola"
-private const val LENOVO = "LENOVO"
-private const val LG = "LGE"
-private const val NVIDIA = "NVIDIA"
-private const val MEIZU = "Meizu"
-private const val HUAWEI = "HUAWEI"
-private const val VIVO = "vivo"
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt
new file mode 100644
index 00000000..0e1eb917
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidKnownReference.kt
@@ -0,0 +1,1131 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.Exclusion.ExclusionType
+import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
+import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
+import leakcanary.Exclusion.Status
+import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
+import java.lang.ref.PhantomReference
+import java.lang.ref.SoftReference
+import java.lang.ref.WeakReference
+import java.util.EnumSet
+
+/**
+ * The first parameter is the value of android.os.Build.MANUFACTURER and the second
+ * parameter is the value of android.os.Build.VERSION.SDK_INT. Returns true if the known
+ * reference should be applied on the provided manufacturer / sdk int.
+ */
+typealias BuildFilter = (String, Int) -> Boolean
+
+/**
+ * This class is a work in progress. You can help by reporting leak traces that seem to be caused
+ * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
+ *
+ * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
+ * manufacturer implementation, they usually share their builds across multiple models, and the
+ * leaks eventually get fixed in newer versions.
+ *
+ * Most app developers should use [appDefaults]. However, you can also pick the
+ * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
+ * [buildKnownReferences]
+ */
+class AndroidKnownReference private constructor(
+  val type: ExclusionType,
+  val reason: String?,
+  val status: Status,
+  val filter: BuildFilter
+) {
+
+  companion object {
+    private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+    const val SAMSUNG = "samsung"
+    const val MOTOROLA = "motorola"
+    const val LENOVO = "LENOVO"
+    const val LG = "LGE"
+    const val NVIDIA = "NVIDIA"
+    const val MEIZU = "Meizu"
+    const val HUAWEI = "HUAWEI"
+    const val VIVO = "vivo"
+
+    /**
+     * This returns the references in the leak path that should be ignored by all on Android.
+     */
+    val androidDefaults: Set<AndroidKnownReference>
+      get() = buildKnownReferences(
+          EnumSet.of(
+              Defaults.REFERENCES,
+              Defaults.FINALIZER_WATCHDOG_DAEMON,
+              Defaults.MAIN,
+              Defaults.LEAK_CANARY_THREAD,
+              Defaults.EVENT_RECEIVER__MMESSAGE_QUEUE
+          )
+      )
+
+    /**
+     * This returns the references in the leak path that can be ignored for app developers. This
+     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
+     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
+     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
+     */
+    val appDefaults: Set<AndroidKnownReference>
+      get() = buildKnownReferences(EnumSet.allOf(Defaults::class.java))
+
+    fun buildKnownReferences(defaults: Set<Defaults>): Set<AndroidKnownReference> {
+      val resultSet = mutableSetOf<AndroidKnownReference>()
+      defaults.forEach {
+        it.add(resultSet)
+      }
+      return resultSet
+    }
+
+    private val NO_FILTER: BuildFilter = { _, _ ->
+      true
+    }
+
+    fun staticField(
+      className: String,
+      fieldName: String,
+      reason: String? = null,
+      status: Status = WONT_FIX_LEAK,
+      filter: BuildFilter = NO_FILTER
+    ) = AndroidKnownReference(StaticFieldExclusion(className, fieldName), reason, status, filter)
+
+    fun instanceField(
+      className: String,
+      fieldName: String,
+      reason: String? = null,
+      status: Status = WONT_FIX_LEAK,
+      filter: BuildFilter = NO_FILTER
+    ) = AndroidKnownReference(InstanceFieldExclusion(className, fieldName), reason, status, filter)
+
+    fun javaLocal(
+      threadName: String,
+      reason: String? = null,
+      status: Status = WONT_FIX_LEAK,
+      filter: BuildFilter = NO_FILTER
+    ) = AndroidKnownReference(JavaLocalExclusion(threadName), reason, status, filter)
+
+    /**
+     * Used to transform [AndroidKnownReference] instances to [Exclusion] which is what
+     * the heap analyzer actually uses. The resulting set should only be used
+     * for exactly one analysis, it caches the Android version information.
+     */
+    fun mapToExclusions(knownReferences: Set<AndroidKnownReference>): List<Exclusion> {
+      val buildMirror = BuildMirror()
+      return knownReferences.map { knownReference ->
+        Exclusion(
+            knownReference.type, knownReference.reason, knownReference.status,
+            buildMirror.wrapFilter(knownReference.filter)
+        )
+      }
+    }
+  }
+
+  enum class Defaults {
+    // ######## Android Framework known leaks ########
+
+    ACTIVITY_CLIENT_RECORD__NEXT_IDLE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.app.ActivityThread\$ActivityClientRecord", "nextIdle",
+            reason = "Android AOSP sometimes keeps a reference to a destroyed activity as a"
+                + " nextIdle client record in the android.app.ActivityThread.mActivities map."
+                + " Not sure what's going on there, input welcome."
+        ) { _, sdkInt ->
+          sdkInt in 19..27
+        }
+      }
+    },
+
+    SPAN_CONTROLLER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason =
+          ("Editor inserts a special span, which has a reference to the EditText. That span is a"
+              + " NoCopySpan, which makes sure it gets dropped when creating a new"
+              + " SpannableStringBuilder from a given CharSequence."
+              + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
+              + " bundle. Prior to KitKat, that copy was done using the SpannableString"
+              + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
+              + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
+              + " reference to the textview and therefore the entire view hierarchy & activity"
+              + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
+              + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
+              + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
+              + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
+
+        references += instanceField(
+            "android.widget.Editor\$SpanController", "this$0", reason
+        ) { _, sdkInt ->
+          sdkInt <= 19
+        }
+
+        references += instanceField(
+            "android.widget.Editor\$EasyEditSpanController", "this$0", reason
+        ) { _, sdkInt ->
+          sdkInt <= 19
+        }
+      }
+    },
+
+    MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references +=
+          staticField(
+              "android.media.session.MediaSessionLegacyHelper", "sInstance",
+              reason = "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
+                  + " keeps a reference to the context it's given the first time"
+                  + " MediaSessionLegacyHelper.getHelper() is called."
+                  + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
+                  + " calling context.getApplicationContext()."
+                  + " Fix: https://github.com/android/platform_frameworks_base/commit"
+                  + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
+                  + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
+                  + " in Application.onCreate() and pass it the application context."
+          ) { _, sdkInt ->
+            sdkInt == 21
+          }
+      }
+    },
+
+    TEXT_LINE__SCACHED {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.text.TextLine", "sCached",
+            reason = "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
+                + " at least two bugs that created memory leaks by not correctly clearing the"
+                + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
+                + " https://github.com/android/platform_frameworks_base/commit"
+                + "/893d6fe48d37f71e683f722457bea646994a10"
+                + " The second was fixed, not released yet:"
+                + " https://github.com/android/platform_frameworks_base/commit"
+                + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
+                + " To fix this, you could access TextLine.sCached and clear the pool every now"
+                + " and then (e.g. on activity destroy)."
+        ) { _, sdkInt ->
+          sdkInt <= 22
+        }
+      }
+    },
+
+    BLOCKING_QUEUE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason = ("A thread waiting on a blocking queue will leak the last"
+            + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
+            + " keeps a local reference to the last message it received. That message then gets"
+            + " recycled and can be used again. As long as all messages are recycled after being"
+            + " used, this won't be a problem, because these references are cleared when being"
+            + " recycled. However, dialogs create template Message instances to be copied when a"
+            + " message needs to be sent. These Message templates holds references to the dialog"
+            + " listeners, which most likely leads to holding a reference onto the activity in some"
+            + " way. Dialogs never recycle their template Message, assuming these Message instances"
+            + " will get GCed when the dialog is GCed."
+            + " The combination of these two things creates a high potential for memory leaks as soon"
+            + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
+            + " sleep for a long time."
+            + " To fix this, you could post empty messages to the idle handler threads from time to"
+            + " time. This won't be easy because you cannot access all handler threads, but a library"
+            + " that is widely used should consider doing this for its own handler threads. This leaks"
+            + " has been shown to happen in both Dalvik and ART.")
+
+        references += instanceField("android.os.Message", "obj", reason)
+        references += instanceField("android.os.Message", "next", reason)
+        references += instanceField("android.os.Message", "target", reason)
+      }
+    },
+
+    INPUT_METHOD_MANAGER_IS_TERRIBLE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
+            + " leaks a reference to it until a new view asks for keyboard input."
+            + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
+            + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mNextServedView", reason
+        ) { _, sdkInt ->
+          sdkInt in 15..27
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mServedView", reason
+        ) { _, sdkInt ->
+          sdkInt in 15..27
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mServedInputConnection", reason
+        ) { _, sdkInt ->
+          sdkInt in 15..27
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mLastSrvView"
+            ,
+            reason =
+            "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
+        ) { manufacturer, sdkInt ->
+          manufacturer == HUAWEI && sdkInt in 23..27
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mCurRootView",
+            reason = "The singleton InputMethodManager is holding a reference to mCurRootView long"
+                + " after the activity has been destroyed."
+                + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
+                + "#issuecomment-100579429"
+                + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
+        ) { _, sdkInt ->
+          sdkInt in 15..28
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mImeInsetsConsumer",
+            reason = """
+              Android Q Beta has a leak where InputMethodManager.mImeInsetsConsumer isn't set to
+              null when the activity is destroyed.
+            """.trimIndent()
+        ) { _, sdkInt ->
+          sdkInt == 28
+        }
+
+        references += instanceField(
+            "android.view.inputmethod.InputMethodManager", "mCurrentInputConnection",
+            reason = """
+              In Android Q Beta InputMethodManager keeps its EditableInputConnection after the
+              activity has been destroyed.
+            """.trimIndent()
+        ) { _, sdkInt ->
+          sdkInt == 28
+        }
+      }
+    },
+
+    LAYOUT_TRANSITION {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.animation.LayoutTransition$1", "val\$parent",
+            reason = "LayoutTransition leaks parent ViewGroup through"
+                + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
+                + " window is destroyed. Tracked here:"
+                + " https://code.google.com/p/android/issues/detail?id=171830"
+        ) { _, sdkInt ->
+          sdkInt in 14..22
+        }
+      }
+    },
+
+    SPELL_CHECKER_SESSION {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.view.textservice.SpellCheckerSession$1", "this$0",
+            reason = "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
+                + " SpellCheckerSession is closed before the service is connected."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
+        ) { _, sdkInt ->
+          sdkInt in 16..24
+        }
+      }
+    },
+
+    SPELL_CHECKER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.widget.SpellChecker$1", "this$0",
+            reason = "SpellChecker holds on to a detached view that points to a destroyed activity."
+                + " mSpellRunnable is being enqueued, and that callback should be removed when "
+                + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
+                + " called after the view was detached."
+        ) { _, sdkInt ->
+          sdkInt == 22
+        }
+      }
+    },
+
+    ACTIVITY_CHOOSE_MODEL {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason = ("ActivityChooserModel holds a static reference to the last set"
+            + " ActivityChooserModelPolicy which can be an activity context."
+            + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
+            + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
+
+
+        references += instanceField(
+            "android.support.v7.internal.widget.ActivityChooserModel",
+            "mActivityChoserModelPolicy",
+            reason = reason
+        ) { _, sdkInt ->
+          sdkInt in 15..22
+        }
+
+        references += instanceField(
+            "android.widget.ActivityChooserModel", "mActivityChoserModelPolicy",
+            reason = reason
+        )
+      }
+    },
+
+    MEDIA_PROJECTION_CALLBACK {
+      override fun add(references: MutableSet<AndroidKnownReference>) {
+        references += instanceField("android.media.projection.MediaProjection\$MediaProjectionCallback",
+            "this$0", reason = """
+              MediaProjectionCallback is held by another process, and holds on to MediaProjection
+              which has an activity as its context.
+            """.trimIndent()) { _, sdkInt ->
+          sdkInt in 22..28
+        }
+      }
+
+    },
+
+    SPEECH_RECOGNIZER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.speech.SpeechRecognizer\$InternalListener", "this$0"
+            ,
+            reason = "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
+                + " class and leaked the SpeechRecognizer which leaked an activity context."
+                + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                + " /b37866db469e81aca534ff6186bdafd44352329b"
+        ) { _, sdkInt ->
+          sdkInt < 21
+        }
+      }
+    },
+
+    ACCOUNT_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.accounts.AccountManager\$AmsTask\$Response", "this$1"
+            ,
+            reason =
+            "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
+                + " probably because the reference to the response in the other process hasn't been"
+                + " cleared."
+                + " AccountManager\$AmsTask is holding on to the activity reference to use for"
+                + " launching a new sub- Activity."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
+                + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
+                + " with the returned future to to get the result and correctly start an activity"
+                + " when it's available."
+        ) { _, sdkInt ->
+          sdkInt <= 27
+        }
+      }
+    },
+
+    MEDIA_SCANNER_CONNECTION {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.media.MediaScannerConnection", "mContext",
+
+            reason =
+            "The static method MediaScannerConnection.scanFile() takes an activity context"
+                + " but the service might not disconnect after the activity has been destroyed."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
+                + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
+                + " application context. Call connect() and disconnect() manually."
+        ) { _, sdkInt ->
+          sdkInt <= 22
+        }
+      }
+    },
+
+    USER_MANAGER__SINSTANCE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.os.UserManager", "mContext",
+            reason =
+            "UserManager has a static sInstance field that creates an instance and caches it"
+                + " the first time UserManager.get() is called. This instance is created with the"
+                + " outer context (which is an activity base context)."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
+                + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
+                + "/27db46850b708070452c0ce49daf5f79503fbde6"
+                + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
+                + " UserManager instance gets cached with a reference to the application context."
+        ) { _, sdkInt ->
+          sdkInt in 18..25
+        }
+      }
+    },
+
+    APP_WIDGET_HOST_CALLBACKS {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.appwidget.AppWidgetHost\$Callbacks", "this$0"
+            ,
+            reason =
+            "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
+                + " code. The reference to the `mContext` was not being cleared, which caused the"
+                + " Callbacks instance to retain this reference"
+                + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
+                + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
+        ) { _, sdkInt ->
+          sdkInt < 22
+        }
+      }
+    },
+
+    AUDIO_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.media.AudioManager$1", "this$0",
+            reason =
+            "Prior to Android M, VideoView required audio focus from AudioManager and"
+                + " never abandoned it, which leaks the Activity context through the AudioManager."
+                + " The root of the problem is that AudioManager uses whichever"
+                + " context it receives, which in the case of the VideoView example is an Activity,"
+                + " even though it only needs the application's context. The issue is fixed in"
+                + " Android M, and the AudioManager now uses the application's context."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
+                + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
+        ) { _, sdkInt ->
+          sdkInt <= 22
+        }
+      }
+    },
+
+    EDITTEXT_BLINK_MESSAGEQUEUE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.widget.Editor\$Blink", "this$0",
+            reason =
+            "The EditText Blink of the Cursor is implemented using a callback and Messages,"
+                + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
+                + " contains a blinking cursor is detached, a message is posted with a delay after the"
+                + " dialog has been closed and as a result leaks the Activity."
+                + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
+                + " dismiss() method of the dialog."
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
+                + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
+                + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
+        ) { _, sdkInt ->
+          sdkInt <= 22
+        }
+      }
+    },
+
+    CONNECTIVITY_MANAGER__SINSTANCE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.net.ConnectivityManager", "sInstance",
+            reason =
+            "ConnectivityManager has a sInstance field that is set when the first"
+                + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
+                + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
+                + " ConnectivityManager instance is created with the activity context and stored in"
+                + " sInstance. That activity context then leaks forever."
+                + " Until this is fixed, app developers can prevent this leak by making sure the"
+                + " ConnectivityManager is first created with an App Context. E.g. in some static"
+                + " init do: context.getApplicationContext()"
+                + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
+                + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
+                + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
+                + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
+        ) { _, sdkInt ->
+          sdkInt <= 23
+        }
+      }
+    },
+
+    ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.view.accessibility.AccessibilityNodeInfo", "mOriginalText"
+            ,
+            reason =
+            "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
+                + " AccessibilityNodeInfo instances are released back in the pool,"
+                + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
+                + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
+                + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
+                + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
+                + "android/view/accessibility/AccessibilityNodeInfo.java"
+        ) { _, sdkInt ->
+          sdkInt in 26..27
+        }
+      }
+    },
+
+    BACKDROP_FRAME_RENDERER__MDECORVIEW {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.android.internal.policy.BackdropFrameRenderer", "mDecorView"
+            ,
+            reason =
+            "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
+                + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
+                + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
+                + " activity"
+        ) { _, sdkInt ->
+          sdkInt in 24..26
+        }
+      }
+    },
+
+    VIEWLOCATIONHOLDER_ROOT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.view.ViewGroup\$ViewLocationHolder",
+            "mRoot"
+            ,
+            reason = "In Android P, ViewLocationHolder has an mRoot field that is not cleared " +
+                "in its clear() method. Introduced in https://github.com/aosp-mirror" +
+                "/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug " +
+                "report: https://issuetracker.google.com/issues/112792715"
+        ) { _, sdkInt ->
+          sdkInt == 28
+        }
+      }
+    },
+
+    ACCESSIBILITY_NODE_ID_MANAGER {
+      override fun add(references: MutableSet<AndroidKnownReference>) {
+        references += instanceField(
+            "android.view.accessibility.AccessibilityNodeIdManager", "mIdsToViews"
+            ,
+            reason = """
+              Android Q Beta added AccessibilityNodeIdManager which stores all views from their
+              onAttachedToWindow() call, until detached. Unfortunately it's possible to trigger
+              the view framework to call detach before attach (by having a view removing itself
+              from its parent in onAttach, which then causes AccessibilityNodeIdManager to keep
+              children view forever. Future releases of Q will hold weak references.
+            """.trimIndent()
+        ) { _, sdkInt ->
+          sdkInt == 28
+        }
+      }
+
+    },
+
+    TEXT_TO_SPEECH {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        val reason =
+          ("TextToSpeech.shutdown() does not release its references to context objects." +
+              " Furthermore, TextToSpeech instances cannot be garbage collected due to other process" +
+              " keeping the references, resulting the context objects leaked." +
+              " Developers might be able to mitigate the issue by passing application context" +
+              " to TextToSpeech constructor." +
+              " Tracked at: https://github.com/square/leakcanary/issues/1210 and" +
+              " https://issuetracker.google.com/issues/129250419")
+        references += instanceField(
+            "android.speech.tts.TextToSpeech", "mContext",
+            reason = reason
+        ) { _, sdkInt ->
+          sdkInt == 24
+        }
+
+        references += instanceField(
+            "android.speech.tts.TtsEngines", "mContext",
+            reason = reason
+        ) { _, sdkInt ->
+          sdkInt == 24
+        }
+      }
+    },
+
+    // ######## Manufacturer specific known leaks ########
+
+    // SAMSUNG
+
+    SPEN_GESTURE_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "com.samsung.android.smartclip.SpenGestureManager", "mContext"
+            ,
+            reason =
+            "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    CLIPBOARD_UI_MANAGER__SINSTANCE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.sec.clipboard.ClipboardUIManager", "mContext"
+            ,
+            reason =
+            "ClipboardUIManager is a static singleton that leaks an activity context."
+                + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
+                + " , so that the ClipboardUIManager instance gets cached with a reference to the"
+                + " application context. Example: https://gist.github.com/cypressious/"
+                + "91c4fb1455470d803a602838dfcd5774"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 19..21
+        }
+      }
+    },
+
+    SEM_CLIPBOARD_MANAGER__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.samsung.android.content.clipboard.SemClipboardManager",
+            "mContext"
+            ,
+            reason =
+            "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 19..24
+        }
+        references += instanceField(
+            "com.samsung.android.content.clipboard.SemClipboardManager$3",
+            "this$0"
+            ,
+            reason =
+            "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 22..28
+        }
+      }
+    },
+
+    SEM_EMERGENCY_MANAGER__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.samsung.android.emergencymode.SemEmergencyManager", "mContext"
+            ,
+            reason =
+            "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 19..24
+        }
+      }
+    },
+
+    SEM_PERSONA_MANAGER {
+      override fun add(references: MutableSet<AndroidKnownReference>) {
+        references += instanceField(
+            "com.samsung.android.knox.SemPersonaManager", "mContext"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 24
+        }
+      }
+    },
+
+    SEM_APP_ICON_SOLUTION {
+      override fun add(references: MutableSet<AndroidKnownReference>) {
+        references += instanceField(
+            "android.app.SemAppIconSolution", "mContext"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 28
+        }
+      }
+    },
+
+    AW_RESOURCE__SRESOURCES {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        // AwResource#setResources() is called with resources that hold a reference to the
+        // activity context (instead of the application context) and doesn't clear it.
+        // Not sure what's going on there, input welcome.
+        references += staticField(
+            "com.android.org.chromium.android_webview.AwResource", "sResources"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    TEXT_VIEW__MLAST_HOVERED_VIEW {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.widget.TextView", "mLastHoveredView",
+            reason =
+            "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 19..28
+        }
+      }
+    },
+
+    PERSONA_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.os.PersonaManager", "mContext",
+            reason =
+            "android.app.LoadedApk.mResources has a reference to"
+                + " android.content.res.Resources.mPersonaManager which has a reference to"
+                + " android.os.PersonaManager.mContext which is an activity."
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    RESOURCES__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.content.res.Resources", "mContext",
+            reason =
+            "In AOSP the Resources class does not have a context."
+                + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
+                + " instance that has a context that is the activity."
+                + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    VIEW_CONFIGURATION__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.view.ViewConfiguration", "mContext",
+            reason =
+            "In AOSP the ViewConfiguration class does not have a context."
+                + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
+                + " ViewConfiguration instance that has a context that is the activity."
+                + " Observed here: https://github.com/square/leakcanary/issues"
+                + "/1#issuecomment-100324683"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    AUDIO_MANAGER__MCONTEXT_STATIC {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.media.AudioManager", "mContext_static",
+            reason =
+            "Samsung added a static mContext_static field to AudioManager, holds a reference"
+                + " to the activity."
+                + " Observed here: https://github.com/square/leakcanary/issues/32"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt == 19
+        }
+      }
+    },
+
+    ACTIVITY_MANAGER_MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.app.ActivityManager", "mContext",
+            reason =
+            "Samsung added a static mContext field to ActivityManager, holds a reference"
+                + " to the activity."
+                + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
+                + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
+        ) { manufacturer, sdkInt ->
+          manufacturer == SAMSUNG && sdkInt in 22..23
+        }
+      }
+    },
+
+    // OTHER MANUFACTURERS
+
+    GESTURE_BOOST_MANAGER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.gestureboost.GestureBoostManager", "mContext"
+            ,
+            reason =
+            "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+        ) { manufacturer, sdkInt ->
+          manufacturer == HUAWEI && sdkInt in 24..25
+        }
+      }
+    },
+
+    BUBBLE_POPUP_HELPER__SHELPER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.widget.BubblePopupHelper", "sHelper",
+            reason =
+            "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
+        ) { manufacturer, sdkInt ->
+          manufacturer == LG && sdkInt in 19..22
+        }
+      }
+    },
+
+    LGCONTEXT__MCONTEXT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.lge.systemservice.core.LGContext", "mContext",
+            reason = "LGContext is a static singleton that leaks an activity context."
+        ) { manufacturer, sdkInt ->
+          manufacturer == LG && sdkInt == 21
+        }
+      }
+    },
+
+    MAPPER_CLIENT {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0"
+            ,
+            reason =
+            "Not sure exactly what ControllerMapper is about, but there is an anonymous"
+                + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
+                + " ControllerMapper.MapperClient which leaks the activity context."
+        ) { manufacturer, sdkInt ->
+          manufacturer == NVIDIA && sdkInt == 19
+        }
+      }
+    },
+
+    SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.hardware.SystemSensorManager", "mAppContextImpl"
+            ,
+            reason =
+            "SystemSensorManager stores a reference to context"
+                + " in a static field in its constructor."
+                + " Fix: use application context to get SensorManager"
+        ) { manufacturer, sdkInt ->
+          (manufacturer == LENOVO && sdkInt == 19) || (manufacturer == VIVO && sdkInt == 22)
+        }
+      }
+    },
+
+    INSTRUMENTATION_RECOMMEND_ACTIVITY {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += staticField(
+            "android.app.Instrumentation", "mRecommendActivity",
+            reason =
+            "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
+                + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
+                + " above"
+        ) { manufacturer, sdkInt ->
+          manufacturer == MEIZU && sdkInt in 21..22
+        }
+      }
+    },
+
+    DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            "android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0"
+            ,
+            reason =
+            "DevicePolicyManager keeps a reference to the context it has been created with"
+                + " instead of extracting the application context. In this Motorola build,"
+                + " DevicePolicyManager has an inner SettingsObserver class that is a content"
+                + " observer, which is held into memory by a binder transport object."
+        ) { manufacturer, sdkInt ->
+          manufacturer == MOTOROLA && sdkInt in 19..22
+        }
+      }
+    },
+
+
+    // ######## General known references (not leaks) ########
+
+    REFERENCES {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += instanceField(
+            WeakReference::class.java.name, "referent",
+            status = WEAKLY_REACHABLE
+        )
+        references += instanceField(
+            KeyedWeakReference::class.java.name, "referent"
+            ,
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            SoftReference::class.java.name, "referent",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            PhantomReference::class.java.name, "referent",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.Finalizer", "prev",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.Finalizer", "element",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.Finalizer", "next",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.FinalizerReference", "prev",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.FinalizerReference", "element",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "java.lang.ref.FinalizerReference", "next",
+            status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "sun.misc.Cleaner", "prev", status = NEVER_REACHABLE
+        )
+        references += instanceField(
+            "sun.misc.Cleaner", "next", status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    FINALIZER_WATCHDOG_DAEMON {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
+        // reference to the object and it was about to be GCed.
+        references += javaLocal(
+            "FinalizerWatchdogDaemon",
+            status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    MAIN {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        // The main thread stack is ever changing so local variables aren't likely to hold references
+        // for long. If this is on the shortest path, it's probably that there's a longer path with
+        // a real leak.
+        references += javaLocal(
+            "main",
+            status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    LEAK_CANARY_THREAD {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        references += javaLocal(
+            LEAK_CANARY_THREAD_NAME,
+            status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    EVENT_RECEIVER__MMESSAGE_QUEUE {
+      override fun add(
+        references: MutableSet<AndroidKnownReference>
+      ) {
+        //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
+        // the native peer of the receiver is using them.
+        // The main thread message queue is held on by the main Looper, but that might be a longer
+        // path. Let's not confuse people with a shorter path that is less meaningful.
+        references += instanceField(
+            "android.view.Choreographer\$FrameDisplayEventReceiver",
+            "mMessageQueue"
+            ,
+            status = NEVER_REACHABLE
+        )
+      }
+    },
+
+    ;
+
+    internal abstract fun add(references: MutableSet<AndroidKnownReference>)
+  }
+
+
+}
+
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt
deleted file mode 100644
index 12a3d8c0..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLabelers.kt
+++ /dev/null
@@ -1,31 +0,0 @@
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.HeapValue.ObjectReference
-
-enum class AndroidLabelers : Labeler {
-
-  FRAGMENT_LABELER {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): List<String> {
-      val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
-      val record = heapValue.readObjectRecord()!!
-
-      if (record is GraphInstanceRecord && (
-              record instanceOf "androidx.fragment.app.Fragment" ||
-                  record instanceOf "android.app.Fragment")
-      ) {
-        val mTag = record["mTag"]?.value?.readAsJavaString()
-        if (!mTag.isNullOrEmpty()) {
-          return listOf("Fragment.mTag=$mTag")
-        }
-      }
-
-      return emptyList()
-    }
-  }
-  ;
-
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt
deleted file mode 100644
index c60f35c4..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakInspectors.kt
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.HeapValue.ObjectReference
-import kotlin.reflect.KClass
-
-/**
- * A set of default [LeakInspector]s that knows about common AOSP and library
- * classes.
- *
- * These are heuristics based on our experience and knowledge of AOSP and various library
- * internals. We only make a decision if we're reasonably sure the state of an object is
- * unlikely to be the result of a programmer mistake.
- *
- * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
- * will not be influenced by those mistakes.
- */
-enum class AndroidLeakInspectors : LeakInspector {
-
-  VIEW {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          "android.view.View"
-      ) { instance ->
-        when {
-          // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
-          // next toast view
-          instance["mParent"]!!.value.isNullReference -> LeakNodeStatus.unknown()
-          instance["mAttachInfo"]!!.value.isNullReference -> LeakNodeStatus.leaking(
-              "View detached and has parent"
-          )
-          else -> LeakNodeStatus.notLeaking("View attached")
-        }
-      }
-  },
-
-  ACTIVITY {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          "android.app.Activity"
-      ) { instance ->
-        val field = instance["mDestroyed"]
-        // Activity.mDestroyed was introduced in 17.
-        // https://android.googlesource.com/platform/frameworks/base/+
-        // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
-        if (field == null) {
-          return@instanceOfOrUnknown LeakNodeStatus.unknown()
-        }
-
-        if (field.value.asBoolean!!) {
-          LeakNodeStatus.leaking(field describedWithValue "true")
-        } else {
-          LeakNodeStatus.notLeaking(field describedWithValue "false")
-        }
-      }
-  },
-
-  DIALOG {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          "android.app.Dialog"
-      ) { instance ->
-        val field = instance["mDecor"]!!
-        if (field.value.isNullReference) {
-          LeakNodeStatus.leaking(field describedWithValue "null")
-        } else {
-          LeakNodeStatus.notLeaking(field describedWithValue "not null")
-        }
-      }
-  },
-
-  APPLICATION {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason {
-      val record =
-        GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).readObjectRecord()
-      return if (record?.asInstance?.instanceOf("android.app.Application") == true) {
-        LeakNodeStatus.notLeaking("Application is a singleton")
-      } else {
-        LeakNodeStatus.unknown()
-      }
-    }
-  },
-
-  CLASSLOADER {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason {
-      val record =
-        GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).readObjectRecord()
-      return if (record?.asInstance?.instanceOf(ClassLoader::class) == true) {
-        LeakNodeStatus.notLeaking("A ClassLoader is never leaking")
-      } else {
-        LeakNodeStatus.unknown()
-      }
-    }
-  },
-
-  CLASS {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason {
-      val record =
-        GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).readObjectRecord()
-      return if (record is GraphClassRecord) {
-        LeakNodeStatus.notLeaking("a class is never leaking")
-      } else LeakNodeStatus.unknown()
-    }
-  },
-
-  @Suppress("DEPRECATION")
-  FRAGMENT {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          "android.app.Fragment"
-      ) { instance ->
-        val field = instance["mFragmentManager"]!!
-        if (field.value.isNullReference) {
-          LeakNodeStatus.leaking(field describedWithValue "null")
-        } else {
-          LeakNodeStatus.notLeaking(field describedWithValue "not null")
-        }
-      }
-  },
-
-  SUPPORT_FRAGMENT {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          "android.support.v4.app.Fragment"
-      ) { instance ->
-        val field = instance["mFragmentManager"]!!
-        if (field.value.isNullReference) {
-          LeakNodeStatus.leaking(field describedWithValue "null")
-        } else {
-          LeakNodeStatus.notLeaking(field describedWithValue "not null")
-        }
-      }
-  },
-
-  MESSAGE_QUEUE {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          "android.os.MessageQueue"
-      ) { instance ->
-        // If the queue is not quitting, maybe it should actually have been, we don't know.
-        // However, if it's quitting, it is very likely that's not a bug.
-        val field = instance["mQuitting"]!!
-        if (field.value.asBoolean == true) {
-          LeakNodeStatus.leaking(field describedWithValue "true")
-        } else {
-          LeakNodeStatus.unknown()
-        }
-      }
-  },
-
-  MORTAR_PRESENTER {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          "mortar.Presenter"
-      ) { instance ->
-        // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
-        // should be unreachable, so in that case we don't know their reachability status. However,
-        // when the view is null, we're pretty sure they  never leaking.
-        val field = instance["view"]!!
-        if (field.value.isNullReference) {
-          LeakNodeStatus.leaking(field describedWithValue "null")
-        } else {
-          LeakNodeStatus.unknown()
-        }
-      }
-  },
-
-  MAIN_THEAD {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          Thread::class
-      ) { instance ->
-        if (instance["name"]!!.value.readAsJavaString() == "main") {
-          LeakNodeStatus.notLeaking("the main thread always runs")
-        } else {
-          LeakNodeStatus.unknown()
-        }
-      }
-  },
-
-  WINDOW {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason =
-      GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance)).instanceOfOrUnknown(
-          "android.view.Window"
-      ) { instance ->
-        val field = instance["mDestroyed"]!!
-
-        if (field.value.asBoolean!!) {
-          LeakNodeStatus.leaking(field describedWithValue "true")
-        } else {
-          LeakNodeStatus.notLeaking(field describedWithValue "false")
-        }
-      }
-  },
-
-  TOAST_TN {
-    override fun invoke(
-      parser: HprofParser,
-      node: LeakNode
-    ): LeakNodeStatusAndReason {
-      val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
-
-
-      return if (heapValue.readObjectRecord()?.asInstance?.instanceOf(
-              "android.widget.Toast\$TN"
-          ) == true
-      ) {
-        LeakNodeStatus.notLeaking(
-            "Toast.TN (Transient Notification) is never leaking"
-        )
-      } else LeakNodeStatus.unknown()
-    }
-  };
-
-  companion object {
-
-    fun defaultAndroidInspectors(): List<LeakInspector> {
-      val inspectors = mutableListOf<LeakInspector>()
-      for (enumValue in values()) {
-        inspectors.add(enumValue)
-      }
-      return inspectors
-    }
-  }
-}
-
-fun GraphHeapValue.instanceOfOrUnknown(
-  expectedClass: KClass<out Any>,
-  block: (GraphInstanceRecord) -> LeakNodeStatusAndReason
-): LeakNodeStatusAndReason = instanceOfOrUnknown(expectedClass.java.name, block)
-
-fun GraphHeapValue.instanceOfOrUnknown(
-  expectedClass: String,
-  block: (GraphInstanceRecord) -> LeakNodeStatusAndReason
-): LeakNodeStatusAndReason {
-  val record = readObjectRecord()?.asInstance
-  return if (record != null && record instanceOf expectedClass) {
-    block(record)
-  } else LeakNodeStatus.unknown()
-}
-
-private infix fun GraphField.describedWithValue(valueDescription: String): String {
-  return "${classRecord.simpleName}#$name is $valueDescription"
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
new file mode 100644
index 00000000..d2b4cdd8
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AndroidLeakTraceInspectors.kt
@@ -0,0 +1,453 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import kotlin.reflect.KClass
+
+/**
+ * A set of default [LeakInspector]s that knows about common AOSP and library
+ * classes.
+ *
+ * These are heuristics based on our experience and knowledge of AOSP and various library
+ * internals. We only make a decision if we're reasonably sure the state of an object is
+ * unlikely to be the result of a programmer mistake.
+ *
+ * For example, no matter how many mistakes we make in our code, the value of Activity.mDestroy
+ * will not be influenced by those mistakes.
+ */
+enum class AndroidLeakTraceInspectors : LeakTraceInspector {
+
+  VIEW {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.view.View") { instance ->
+        // This skips edge cases like Toast$TN.mNextView holding on to an unattached and unparented
+        // next toast view
+        val mParentRef = instance["mParent"]!!.value
+        val mParentSet = mParentRef.isNonNullReference
+        val viewDetached = instance["mAttachInfo"]!!.value.isNullReference
+
+        if (mParentSet) {
+          if (viewDetached) {
+            reportLeaking("View detached and has parent")
+          } else {
+            val viewParent = mParentRef.readObjectRecord()!!.asInstance!!
+            if (viewParent instanceOf "android.view.View" && viewParent["mAttachInfo"]!!.value.isNullReference) {
+              reportLeaking("View attached but parent detached (attach disorder)")
+            } else {
+              reportNotLeaking("View attached")
+            }
+          }
+        }
+
+        if (mParentSet) {
+          addLabel("View#mParent is set")
+        } else {
+          addLabel("View#mParent is null")
+        }
+
+        if (viewDetached) {
+          addLabel("View#mAttachInfo is null (view detached)")
+        } else {
+          addLabel("View#mAttachInfo is not null (view attached)")
+        }
+
+        // TODO Add back support for view id labels, see https://github.com/square/leakcanary/issues/1297
+
+        val mWindowAttachCount = instance["mWindowAttachCount"]?.value?.asInt
+
+        if (mWindowAttachCount != null) {
+          addLabel("View.mWindowAttachCount=$mWindowAttachCount")
+        }
+      }
+    }
+  },
+
+  ACTIVITY {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.app.Activity") { instance ->
+        // Activity.mDestroyed was introduced in 17.
+        // https://android.googlesource.com/platform/frameworks/base/+
+        // /6d9dcbccec126d9b87ab6587e686e28b87e5a04d
+        val field = instance["mDestroyed"]
+
+        if (field != null) {
+          if (field.value.asBoolean!!) {
+            reportLeaking(field describedWithValue "true")
+          } else {
+            reportNotLeaking(field describedWithValue "false")
+          }
+        }
+      }
+    }
+  },
+
+  CONTEXT_WRAPPER {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.content.ContextWrapper") { instance ->
+        // Activity is already taken care of
+        if (!(instance instanceOf "android.app.Activity")) {
+          var context = instance
+
+          val visitedInstances = mutableListOf<Long>()
+          var keepUnwrapping = true
+          while (keepUnwrapping) {
+            visitedInstances += context.record.id
+            keepUnwrapping = false
+            val mBase = context["android.content.ContextWrapper", "mBase"]!!.value
+
+            if (mBase.isNonNullReference) {
+              context = mBase.readObjectRecord()!!.asInstance!!
+              if (context instanceOf "android.app.Activity") {
+                val mDestroyed = instance["android.app.Activity", "mDestroyed"]
+                if (mDestroyed != null) {
+                  if (mDestroyed.value.asBoolean!!) {
+                    reportLeaking(
+                        "${instance.simpleClassName} wraps an Activity with Activity.mDestroyed true"
+                    )
+                  } else {
+                    // We can't assume it's not leaking, because this context might have a shorter lifecycle
+                    // than the activity. So we'll just add a label.
+                    addLabel("${instance.simpleClassName} wraps an Activity with Activity.mDestroyed false")
+                  }
+                }
+              } else if (context instanceOf "android.content.ContextWrapper" &&
+                  // Avoids infinite loops
+                  context.record.id !in visitedInstances
+              ) {
+                keepUnwrapping = true
+              }
+            }
+          }
+        }
+      }
+    }
+  },
+
+  DIALOG {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.app.Dialog") { instance ->
+        val mDecor = instance["mDecor"]!!
+        if (mDecor.value.isNullReference) {
+          reportLeaking(mDecor describedWithValue "null")
+        } else {
+          reportNotLeaking(mDecor describedWithValue "not null")
+        }
+      }
+    }
+  },
+
+  APPLICATION {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.app.Application") {
+        reportNotLeaking("Application is a singleton")
+      }
+    }
+  },
+
+  INPUT_METHOD_MANAGER {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.view.inputmethod.InputMethodManager") {
+        reportNotLeaking("InputMethodManager is a singleton")
+      }
+    }
+  },
+
+  CLASSLOADER {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf(ClassLoader::class) {
+        reportNotLeaking("A ClassLoader is never leaking")
+      }
+    }
+  },
+
+  CLASS {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEach { reporter ->
+        if (reporter.objectRecord is GraphClassRecord) {
+          reporter.reportNotLeaking("a class is never leaking")
+        }
+      }
+    }
+  },
+
+  FRAGMENT {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.app.Fragment") { instance ->
+        val fragmentManager = instance["android.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          reportLeaking(fragmentManager describedWithValue "null")
+        } else {
+          reportNotLeaking(fragmentManager describedWithValue "not null")
+        }
+        val mTag = instance["android.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          addLabel("Fragment.mTag=$mTag")
+        }
+      }
+    }
+  },
+
+  SUPPORT_FRAGMENT {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.support.v4.app.Fragment") { instance ->
+        val fragmentManager = instance["android.support.v4.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          reportLeaking(fragmentManager describedWithValue "null")
+        } else {
+          reportNotLeaking(fragmentManager describedWithValue "not null")
+        }
+        val mTag = instance["android.support.v4.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          addLabel("Fragment.mTag=$mTag")
+        }
+      }
+    }
+  },
+
+  ANDROIDX_FRAGMENT {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("androidx.fragment.app.Fragment") { instance ->
+        val fragmentManager = instance["androidx.fragment.app.Fragment", "mFragmentManager"]!!
+        if (fragmentManager.value.isNullReference) {
+          reportLeaking(fragmentManager describedWithValue "null")
+        } else {
+          reportNotLeaking(fragmentManager describedWithValue "not null")
+        }
+        val mTag = instance["androidx.fragment.app.Fragment", "mTag"]?.value?.readAsJavaString()
+        if (!mTag.isNullOrEmpty()) {
+          addLabel("Fragment.mTag=$mTag")
+        }
+      }
+    }
+  },
+
+  MESSAGE_QUEUE {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.os.MessageQueue") { instance ->
+        val mQuitting = instance["mQuitting"]!!
+        if (mQuitting.value.asBoolean!!) {
+          reportLeaking(mQuitting describedWithValue "true")
+        } else {
+          reportNotLeaking(mQuitting describedWithValue "false")
+        }
+      }
+    }
+  },
+
+  MORTAR_PRESENTER {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("mortar.Presenter") { instance ->
+        // Bugs in view code tends to cause Mortar presenters to still have a view when they actually
+        // should be unreachable, so in that case we don't know their reachability status. However,
+        // when the view is null, we're pretty sure they  never leaking.
+        val view = instance["view"]!!
+        if (view.value.isNullReference) {
+          reportLeaking(view describedWithValue "null")
+        }
+      }
+    }
+  },
+
+  COORDINATOR {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
+        val attached = instance["attached"]
+        if (attached!!.value.asBoolean!!) {
+          reportNotLeaking(attached describedWithValue "true")
+        } else {
+          reportLeaking(attached describedWithValue "false")
+        }
+      }
+    }
+  },
+
+  ANONYMOUS_CLASS {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEach { reporter ->
+        if (reporter.objectRecord is GraphInstanceRecord) {
+          val classRecord = reporter.objectRecord.readClass()
+          if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
+            val parentClassRecord = classRecord.readSuperClass()!!
+            if (parentClassRecord.name == "java.lang.Object") {
+              try {
+                // This is an anonymous class implementing an interface. The API does not give access
+                // to the interfaces implemented by the class. We check if it's in the class path and
+                // use that instead.
+                val actualClass = Class.forName(classRecord.name)
+                val interfaces = actualClass.interfaces
+                reporter.addLabel(
+                    if (interfaces.isNotEmpty()) {
+                      val implementedInterface = interfaces[0]
+                      "Anonymous class implementing ${implementedInterface.name}"
+                    } else {
+                      "Anonymous subclass of java.lang.Object"
+                    }
+                )
+              } catch (ignored: ClassNotFoundException) {
+              }
+            } else {
+              // Makes it easier to figure out which anonymous class we're looking at.
+              reporter.addLabel("Anonymous subclass of ${parentClassRecord.name}")
+            }
+          }
+        }
+      }
+    }
+  },
+
+  THREAD {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf(Thread::class) { instance ->
+        val threadName = instance["name"]!!.value.readAsJavaString()
+        if (threadName == "main") {
+          reportNotLeaking("the main thread always runs")
+        }
+        addLabel("Thread name: '$threadName'")
+      }
+    }
+  },
+
+  WINDOW {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.view.Window") { instance ->
+        val mDestroyed = instance["mDestroyed"]!!
+
+        if (mDestroyed.value.asBoolean!!) {
+          reportLeaking(mDestroyed describedWithValue "true")
+        } else {
+          reportNotLeaking(mDestroyed describedWithValue "false")
+        }
+      }
+    }
+  },
+
+  TOAST {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.widget.Toast") { instance ->
+        val tnInstance = instance["mTN"]!!.value.readObjectRecord()!!.asInstance!!
+        // mWM is set in android.widget.Toast.TN#handleShow and never unset, so this toast was never
+        // shown, we don't know if it's leaking.
+        if (tnInstance["mWM"]!!.value.isNonNullReference) {
+          // mView is reset to null in android.widget.Toast.TN#handleHide
+          if (tnInstance["mView"]!!.value.isNullReference) {
+            reportLeaking(
+                "This toast is done showing (Toast.mTN.mWM != null && Toast.mTN.mView == null)"
+            )
+          } else {
+            reportNotLeaking(
+                "This toast is showing (Toast.mTN.mWM != null && Toast.mTN.mView != null)"
+            )
+          }
+        }
+      }
+    }
+  },
+
+  TOAST_TN {
+    override fun inspect(
+      graph: HprofGraph,
+      leakTrace: List<LeakTraceElementReporter>
+    ) {
+      leakTrace.forEachInstanceOf("android.widget.Toast\$TN") {
+        reportNotLeaking("Toast.TN (Transient Notification) is never leaking")
+      }
+    }
+  };
+
+  companion object {
+    fun defaultInspectors(): List<LeakTraceInspector> {
+      return values().toList()
+    }
+  }
+}
+
+private infix fun GraphField.describedWithValue(valueDescription: String): String {
+  return "${classRecord.simpleName}#$name is $valueDescription"
+}
+
+inline fun List<LeakTraceElementReporter>.forEachInstanceOf(
+  expectedClass: KClass<out Any>,
+  action: LeakTraceElementReporter.(GraphInstanceRecord) -> Unit
+) {
+  forEachInstanceOf(expectedClass.java.name, action)
+}
+
+inline fun List<LeakTraceElementReporter>.forEachInstanceOf(
+  className: String,
+  action: LeakTraceElementReporter.(GraphInstanceRecord) -> Unit
+) {
+  for (reporter in this) {
+    if (reporter.objectRecord is GraphInstanceRecord && reporter.objectRecord instanceOf className) {
+      reporter.action(reporter.objectRecord)
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
new file mode 100644
index 00000000..50f30c0d
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+
+/**
+ * Inspector that automatically marks instances of the provided class names as not leaking
+ * because they're app wide singletons.
+ */
+class AppSingletonInspector(private vararg val singletonClasses: String) : LeakTraceInspector {
+  override fun inspect(
+    graph: HprofGraph,
+    leakTrace: List<LeakTraceElementReporter>
+  ) {
+    leakTrace.forEach { reporter ->
+      if (reporter.objectRecord is GraphInstanceRecord) {
+        reporter.objectRecord.readClass()
+            .readClassHierarchy()
+            .forEach { classRecord ->
+              if (classRecord.name in singletonClasses) {
+                reporter.reportNotLeaking("${classRecord.name} is an app singleton")
+              }
+            }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
index 4c3d75aa..bbf4d947 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/BuildMirror.kt
@@ -1,23 +1,24 @@
 package leakcanary
 
-class BuildMirror(
-  val manufacturer: String,
-  val sdkInt: Int
-) {
-  companion object {
-    fun readFromHprof(parser: HprofParser) = with(parser) {
-      val manufacturer = parser.classId("android.os.Build")
-          ?.let {
-            val buildClass = parser.hydrateClassHierarchy(it)[0]
-            buildClass["MANUFACTURER"].reference.stringOrNull
-          } ?: ""
+import kotlin.properties.Delegates.notNull
 
-      val sdkInt = parser.classId("android.os.Build\$VERSION")
-          ?.let {
-            val versionClass = parser.hydrateClassHierarchy(it)[0]
-            versionClass["SDK_INT"].int
-          } ?: 0
-      BuildMirror(manufacturer, sdkInt)
+/**
+ * Turns BuildFilter into exclusion filters that HeapAnalyzer understand. Since retrieving from
+ * the Hprof is not free, [BuildMirror] provides a caching mechanism. Make sure to use different
+ * [BuildMirror] and set of filters for every hprof parsing.
+ */
+class BuildMirror {
+
+  lateinit var manufacturer: String
+  var sdkInt: Int by notNull()
+
+  fun wrapFilter(filter: BuildFilter): (HprofGraph) -> Boolean = { graph ->
+    if (!::manufacturer.isInitialized) {
+      val buildClass = graph.readClass("android.os.Build")!!
+      val versionClass = graph.readClass("android.os.Build\$VERSION")!!
+      manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
+      sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
     }
+    filter(manufacturer, sdkInt)
   }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
index c6ea86bf..d949e1b8 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
@@ -19,7 +19,8 @@ import java.io.Serializable
 data class Exclusion(
   val type: ExclusionType,
   val reason: String? = null,
-  val status: Status = WONT_FIX_LEAK
+  val status: Status = WONT_FIX_LEAK,
+  val filter: (HprofGraph) -> Boolean = {true}
 ) {
   val description
     get() = ExclusionDescription(type.matching, reason)
@@ -79,11 +80,10 @@ data class Exclusion(
         get() = "field $className#$fieldName"
     }
   }
+
 }
 
 class ExclusionDescription(
   val matching: String,
   val reason: String? = null
-) : Serializable
-
-typealias ExclusionsFactory = (HprofParser) -> List<Exclusion>
\ No newline at end of file
+) : Serializable
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index d197003d..efd56bd4 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -31,7 +31,10 @@ import leakcanary.GcRoot.ReferenceCleanup
 import leakcanary.GcRoot.StickyClass
 import leakcanary.GcRoot.ThreadBlock
 import leakcanary.GcRoot.ThreadObject
+import leakcanary.GraphObjectRecord.GraphClassRecord
 import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
 import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNodeStatus.LEAKING
@@ -42,7 +45,6 @@ import leakcanary.LeakTraceElement.Holder.CLASS
 import leakcanary.LeakTraceElement.Holder.OBJECT
 import leakcanary.LeakTraceElement.Holder.THREAD
 import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
@@ -79,10 +81,9 @@ class HeapAnalyzer constructor(
    */
   fun checkForLeaks(
     heapDumpFile: File,
-    exclusionsFactory: ExclusionsFactory = { emptyList() },
+    exclusions: List<Exclusion> = emptyList(),
     computeRetainedHeapSize: Boolean = false,
-    reachabilityInspectors: List<LeakInspector> = emptyList(),
-    labelers: List<Labeler> = emptyList()
+    leakTraceInspectors: List<LeakTraceInspector> = emptyList()
   ): HeapAnalysis {
     val analysisStartNanoTime = System.nanoTime()
 
@@ -102,8 +103,7 @@ class HeapAnalyzer constructor(
             val graph = HprofGraph(parser)
             listener.onProgressUpdate(SCANNING_HEAP_DUMP)
             val (gcRootIds, keyedWeakReferenceInstances, cleaners) = scan(
-                graph,
-                parser, computeRetainedHeapSize
+                parser, graph, computeRetainedHeapSize
             )
             val analysisResults = mutableMapOf<String, RetainedInstance>()
             listener.onProgressUpdate(FINDING_WATCHED_REFERENCES)
@@ -120,18 +120,18 @@ class HeapAnalyzer constructor(
 
             val (pathResults, dominatedInstances) =
               findShortestPaths(
-                  parser, exclusionsFactory, retainedWeakRefs, gcRootIds,
+                  graph, exclusions, retainedWeakRefs, gcRootIds,
                   computeRetainedHeapSize
               )
 
             val retainedSizes = if (computeRetainedHeapSize) {
-              computeRetainedSizes(parser, pathResults, dominatedInstances, cleaners)
+              computeRetainedSizes(graph, pathResults, dominatedInstances, cleaners)
             } else {
               null
             }
 
             buildLeakTraces(
-                reachabilityInspectors, labelers, pathResults, parser,
+                leakTraceInspectors, pathResults, graph,
                 retainedWeakRefs, analysisResults, retainedSizes
             )
 
@@ -157,8 +157,8 @@ class HeapAnalyzer constructor(
   )
 
   private fun scan(
-    graph: HprofGraph,
     parser: HprofParser,
+    graph: HprofGraph,
     computeRetainedSize: Boolean
   ): ScanResult {
     val keyedWeakReferenceInstances = mutableListOf<GraphInstanceRecord>()
@@ -237,20 +237,20 @@ class HeapAnalyzer constructor(
   }
 
   private fun findShortestPaths(
-    parser: HprofParser,
-    exclusionsFactory: ExclusionsFactory,
+    graph: HprofGraph,
+    exclusions: List<Exclusion>,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
     gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean
   ): Results {
     val pathFinder = ShortestPathFinder()
     return pathFinder.findPaths(
-        parser, exclusionsFactory, leakingWeakRefs, gcRootIds, computeDominators, listener
+        graph, exclusions, leakingWeakRefs, gcRootIds, computeDominators, listener
     )
   }
 
   private fun computeRetainedSizes(
-    parser: HprofParser,
+    graph: HprofGraph,
     results: List<Result>,
     dominatedInstances: LongLongScatterMap,
     cleaners: MutableList<Long>
@@ -269,24 +269,24 @@ class HeapAnalyzer constructor(
     // that the CleanerThunk has a pointer to. The native pointer is in the 'nativePtr' field of
     // the CleanerThunk. The hprof does not include the native bytes pointed to.
 
-    with(parser) {
-      cleaners.forEach {
-        val cleaner = it.hydratedInstance
-        val thunkId = cleaner["thunk"].reference
-        val referentId = cleaner["referent"].reference
-        if (thunkId != null && referentId != null) {
-          val thunkRecord = thunkId.objectRecord
-          if (thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
-            val thunkRunnable = thunkRecord.hydratedInstance
-            val allocationRegistryId = thunkRunnable["this\$0"].reference
-            if (allocationRegistryId != null) {
-              val allocationRegistryRecord = allocationRegistryId.objectRecord
-              if (allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
-                val allocationRegistry = allocationRegistryRecord.hydratedInstance
-                var nativeSize = nativeSizes.getValue(referentId)
-                nativeSize += allocationRegistry["size"].long?.toInt() ?: 0
-                nativeSizes[referentId] = nativeSize
-              }
+    cleaners.forEach { objectId ->
+      val cleaner = graph.readGraphObjectRecord(objectId).asInstance!!
+      val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
+      val thunkId = thunkField?.value?.asNonNullObjectIdReference
+      val referentId =
+        cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectIdReference
+      if (thunkId != null && referentId != null) {
+        val thunkRecord = thunkField.value.readObjectRecord()
+        if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
+          val allocationRegistryIdField =
+            thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
+          if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
+            val allocationRegistryRecord = allocationRegistryIdField.value.readObjectRecord()
+            if (allocationRegistryRecord is GraphInstanceRecord && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
+              var nativeSize = nativeSizes.getValue(referentId)
+              nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
+                  ?: 0
+              nativeSizes[referentId] = nativeSize
             }
           }
         }
@@ -302,13 +302,11 @@ class HeapAnalyzer constructor(
     results.forEach { result ->
       val leakingInstanceId = result.weakReference.referent.value
       leakingInstanceIds.add(leakingInstanceId)
-      val instanceRecord =
-        parser.retrieveRecordById(leakingInstanceId) as InstanceDumpRecord
-      val classRecord =
-        parser.retrieveRecordById(instanceRecord.classId) as ClassDumpRecord
+      val instanceRecord = graph.readGraphObjectRecord(leakingInstanceId).asInstance!!
+      val classRecord = instanceRecord.readClass()
       var retainedSize = sizeByDominator.getValue(leakingInstanceId)
 
-      retainedSize += classRecord.instanceSize
+      retainedSize += classRecord.record.instanceSize
       sizeByDominator[leakingInstanceId] = retainedSize
     }
 
@@ -317,27 +315,9 @@ class HeapAnalyzer constructor(
       // Avoid double reporting as those sizes will move up to the root dominator
       if (instanceId !in leakingInstanceIds) {
         val currentSize = sizeByDominator.getValue(dominatorId)
-        val record = parser.retrieveRecordById(instanceId)
         val nativeSize = nativeSizes.getValue(instanceId)
-        val shallowSize = when (record) {
-          is InstanceDumpRecord -> {
-            val classRecord = parser.retrieveRecordById(record.classId) as ClassDumpRecord
-            // Note: instanceSize is the sum of shallow size through the class hierarchy
-            classRecord.instanceSize
-          }
-          is ObjectArrayDumpRecord -> record.elementIds.size * parser.idSize
-          is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
-          is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
-          is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
-          is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
-          is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
-          is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
-          is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
-          is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
-          else -> {
-            throw IllegalStateException("Unexpected record $record")
-          }
-        }
+        val record = graph.readObjectRecord(instanceId)
+        val shallowSize = graph.computeShallowSize(record)
         sizeByDominator[dominatorId] = currentSize + nativeSize + shallowSize
       }
     }
@@ -368,10 +348,9 @@ class HeapAnalyzer constructor(
   }
 
   private fun buildLeakTraces(
-    leakInspectors: List<LeakInspector>,
-    labelers: List<Labeler>,
+    leakTraceInspectors: List<LeakTraceInspector>,
     pathResults: List<Result>,
-    parser: HprofParser,
+    graph: HprofGraph,
     leakingWeakRefs: MutableList<KeyedWeakReferenceMirror>,
     analysisResults: MutableMap<String, RetainedInstance>,
     retainedSizes: List<Int>?
@@ -388,12 +367,12 @@ class HeapAnalyzer constructor(
       }
 
       val leakTrace =
-        buildLeakTrace(parser, leakInspectors, pathResult.leakingNode, labelers)
+        buildLeakTrace(graph, leakTraceInspectors, pathResult.leakingNode)
 
       // We get the class name from the heap dump rather than the weak reference because primitive
       // arrays are more readable that way, e.g. "[C" at runtime vs "char[]" in the heap dump.
       val instanceClassName =
-        recordClassName(parser.retrieveRecordById(pathResult.leakingNode.instance), parser)
+        recordClassName(graph.readGraphObjectRecord(pathResult.leakingNode.instance))
 
       val leakDetected = LeakingInstance(
           referenceKey = weakReference.key,
@@ -425,10 +404,9 @@ class HeapAnalyzer constructor(
   }
 
   private fun buildLeakTrace(
-    parser: HprofParser,
-    leakInspectors: List<LeakInspector>,
-    leakingNode: LeakNode,
-    labelers: List<Labeler>
+    graph: HprofGraph,
+    leakTraceInspectors: List<LeakTraceInspector>,
+    leakingNode: LeakNode
   ): LeakTrace {
     val elements = ArrayList<LeakTraceElement>()
     // We iterate from the leak to the GC root
@@ -438,39 +416,40 @@ class HeapAnalyzer constructor(
 
     var node: LeakNode = leafNode
     val nodes = mutableListOf<LeakNode>()
+    val leakReporters = mutableListOf<LeakTraceElementReporter>()
     while (node is ChildNode) {
       nodes.add(0, node.parent)
+      leakReporters.add(0, LeakTraceElementReporter(graph.readGraphObjectRecord(node.parent.instance)))
       node = node.parent
     }
-    val leakStatuses = computeLeakStatuses(parser, leakInspectors, nodes)
+
+    leakTraceInspectors.forEach { it.inspect(graph, leakReporters) }
+
+    val leakStatuses = computeLeakStatuses(graph, leakReporters)
 
     node = leafNode
     while (node is ChildNode) {
-      val labels = mutableListOf<String>()
-      for (labeler in labelers) {
-        labels.addAll(labeler(parser, node.parent))
-      }
       val index = (nodes.size - elements.size) - 1
+      val leakReporter = leakReporters[index]
       val leakStatus = leakStatuses[index]
-      elements.add(0, buildLeakElement(parser, node, labels, leakStatus))
+      elements.add(0, buildLeakElement(graph, node, leakReporter.labels, leakStatus))
       node = node.parent
     }
     return LeakTrace(elements)
   }
 
   private fun computeLeakStatuses(
-    parser: HprofParser,
-    leakInspectors: List<LeakInspector>,
-    nodes: List<LeakNode>
+    graph: HprofGraph,
+    leakReporters: List<LeakTraceElementReporter>
   ): List<LeakNodeStatusAndReason> {
     var lastNotLeakingElementIndex = 0
-    val lastElementIndex = nodes.size - 1
+    val lastElementIndex = leakReporters.size - 1
     var firstLeakingElementIndex = lastElementIndex
 
     val leakStatuses = ArrayList<LeakNodeStatusAndReason>()
 
-    for ((index, node) in nodes.withIndex()) {
-      val leakStatus = inspectElementLeakStatus(leakInspectors, parser, node)
+    for ((index, reporter) in leakReporters.withIndex()) {
+      val leakStatus = inspectElementLeakStatus(reporter)
       leakStatuses.add(leakStatus)
       if (leakStatus.status == NOT_LEAKING) {
         lastNotLeakingElementIndex = index
@@ -502,8 +481,8 @@ class HeapAnalyzer constructor(
       )
     }
 
-    val simpleClassNames = nodes.map { node ->
-      recordClassName(parser.retrieveRecordById(node.instance), parser).lastSegment('.')
+    val simpleClassNames = leakReporters.map { reporter ->
+      recordClassName(reporter.objectRecord).lastSegment('.')
     }
 
     // First and last are always known.
@@ -537,61 +516,55 @@ class HeapAnalyzer constructor(
   }
 
   private fun inspectElementLeakStatus(
-    leakInspectors: List<LeakInspector>,
-    parser: HprofParser,
-    node: LeakNode
+    reporter: LeakTraceElementReporter
   ): LeakNodeStatusAndReason {
     var current = LeakNodeStatus.unknown()
-    for (leakInspector in leakInspectors) {
-      val statusAndReason = leakInspector(parser, node)
-      if (statusAndReason.status != UNKNOWN) {
-        current = when {
-          current.status == UNKNOWN -> statusAndReason
-          current.status == LEAKING && statusAndReason.status == LEAKING -> {
-            LeakNodeStatus.leaking("${current.reason} and ${statusAndReason.reason}")
-          }
-          current.status == NOT_LEAKING && statusAndReason.status == NOT_LEAKING -> {
-            LeakNodeStatus.notLeaking("${current.reason} and ${statusAndReason.reason}")
-          }
-          current.status == NOT_LEAKING && statusAndReason.status == LEAKING -> {
-            LeakNodeStatus.notLeaking(
-                "${current.reason}. Conflicts with ${statusAndReason.reason}"
-            )
-          }
-          current.status == LEAKING && statusAndReason.status == NOT_LEAKING -> {
-            LeakNodeStatus.notLeaking(
-                "${statusAndReason.reason}. Conflicts with ${current.reason}"
-            )
-          }
-          else -> throw IllegalStateException(
-              "Should never happen ${current.status} ${statusAndReason.reason}"
+    for (statusAndReason in reporter.leakNodeStatuses) {
+      current = when {
+        current.status == UNKNOWN -> statusAndReason
+        current.status == LEAKING && statusAndReason.status == LEAKING -> {
+          LeakNodeStatus.leaking("${current.reason} and ${statusAndReason.reason}")
+        }
+        current.status == NOT_LEAKING && statusAndReason.status == NOT_LEAKING -> {
+          LeakNodeStatus.notLeaking("${current.reason} and ${statusAndReason.reason}")
+        }
+        current.status == NOT_LEAKING && statusAndReason.status == LEAKING -> {
+          LeakNodeStatus.notLeaking(
+              "${current.reason}. Conflicts with ${statusAndReason.reason}"
+          )
+        }
+        current.status == LEAKING && statusAndReason.status == NOT_LEAKING -> {
+          LeakNodeStatus.notLeaking(
+              "${statusAndReason.reason}. Conflicts with ${current.reason}"
           )
         }
+        else -> throw IllegalStateException(
+            "Should never happen ${current.status} ${statusAndReason.reason}"
+        )
       }
     }
     return current
   }
 
   private fun buildLeakElement(
-    parser: HprofParser,
+    graph: HprofGraph,
     node: ChildNode,
     labels: List<String>,
     leakStatus: LeakNodeStatusAndReason
   ): LeakTraceElement {
     val objectId = node.parent.instance
 
-    val record = parser.retrieveRecordById(objectId)
+    val graphRecord = graph.readGraphObjectRecord(objectId)
 
-    val className = recordClassName(record, parser)
+    val className = recordClassName(graphRecord)
 
-    val holderType = if (record is ClassDumpRecord) {
+    val holderType = if (graphRecord.record is ClassDumpRecord) {
       CLASS
-    } else if (record is ObjectArrayDumpRecord || record is PrimitiveArrayDumpRecord) {
+    } else if (graphRecord.record is ObjectArrayDumpRecord || graphRecord.record is PrimitiveArrayDumpRecord) {
       ARRAY
     } else {
-      record as InstanceDumpRecord
-      val classHierarchy = parser.hydrateClassHierarchy(record.classId)
-      if (classHierarchy.any { it.className == Thread::class.java.name }) {
+      val instanceRecord = graphRecord.asInstance!!
+      if (instanceRecord.readClass().readClassHierarchy().any { it.name == Thread::class.java.name }) {
         THREAD
       } else {
         OBJECT
@@ -603,22 +576,22 @@ class HeapAnalyzer constructor(
   }
 
   private fun recordClassName(
-    record: ObjectRecord,
-    parser: HprofParser
+    graphRecord: GraphObjectRecord
   ): String {
-    return when (record) {
-      is ClassDumpRecord -> parser.className(record.id)
-      is InstanceDumpRecord -> parser.className(record.classId)
-      is ObjectArrayDumpRecord -> parser.className(record.arrayClassId)
-      is BooleanArrayDump -> "boolean[]"
-      is CharArrayDump -> "char[]"
-      is FloatArrayDump -> "float[]"
-      is DoubleArrayDump -> "double[]"
-      is ByteArrayDump -> "byte[]"
-      is ShortArrayDump -> "short[]"
-      is IntArrayDump -> "int[]"
-      is LongArrayDump -> "long[]"
-      else -> throw IllegalStateException("Unexpected record type for $record")
+    return when (graphRecord) {
+      is GraphClassRecord -> graphRecord.name
+      is GraphInstanceRecord -> graphRecord.className
+      is GraphObjectArrayRecord -> graphRecord.arrayClassName
+      is GraphPrimitiveArrayRecord -> when (graphRecord.record) {
+        is BooleanArrayDump -> "boolean[]"
+        is CharArrayDump -> "char[]"
+        is FloatArrayDump -> "float[]"
+        is DoubleArrayDump -> "double[]"
+        is ByteArrayDump -> "byte[]"
+        is ShortArrayDump -> "short[]"
+        is IntArrayDump -> "int[]"
+        is LongArrayDump -> "long[]"
+      }
     }
   }
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
deleted file mode 100644
index 093cb90b..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-
-typealias Labeler = (HprofParser, LeakNode) -> List<String>
-
-/**
- * Optional labeler that adds a label for each field of each instance in the leak trace.
- * This can make the leak analysis large, sometimes too big to be deserialized from the Sqlite db,
- * to this labeler is not added by default.
- */
-class AllFieldsLabeler(
-  private val labelStaticFields: Boolean = false
-) : Labeler {
-
-  override fun invoke(
-    parser: HprofParser,
-    node: LeakNode
-  ): List<String> {
-    val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
-    val labels = mutableListOf<String>()
-
-    val record = heapValue.readObjectRecord()
-    if (record is GraphInstanceRecord) {
-      var classRecord = record.readClass()
-
-      val instanceField = record.readFields()
-
-      var classIndex = 0
-      while (classRecord.name != "java.lang.Object") {
-        val fields = instanceField[classIndex]
-
-        labels.add("Class ${classRecord.name}")
-        if (labelStaticFields) {
-
-          for (field in classRecord.staticFields) {
-            val valueString = heapValueAsString(field.value)
-            labels.add("  static ${field.name}=$valueString")
-          }
-        }
-
-        for (field in fields) {
-          labels.add("  ${field.name}=${heapValueAsString(field.value)}")
-        }
-        classIndex++
-        classRecord = classRecord.readSuperClass()!!
-      }
-    }
-    return labels
-  }
-
-  private fun heapValueAsString(heapValue: GraphHeapValue): String {
-    return when (val actualValue = heapValue.actual) {
-      is ObjectReference -> {
-        if (heapValue.isNullReference) {
-          "null"
-        } else {
-          when {
-            heapValue.referencesJavaString -> "\"${heapValue.readAsJavaString()!!}\""
-            heapValue.referencesClass -> heapValue.readObjectRecord()!!.asClass!!.name
-            else -> "@${actualValue.value}"
-          }
-        }
-      }
-      is BooleanValue -> actualValue.value.toString()
-      is CharValue -> actualValue.value.toString()
-      is FloatValue -> actualValue.value.toString()
-      is DoubleValue -> actualValue.value.toString()
-      is ByteValue -> actualValue.value.toString()
-      is ShortValue -> actualValue.value.toString()
-      is IntValue -> actualValue.value.toString()
-      is LongValue -> actualValue.value.toString()
-    }
-  }
-}
-
-object InstanceDefaultLabeler : Labeler {
-  override fun invoke(
-    parser: HprofParser,
-    node: LeakNode
-  ): List<String> {
-    val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
-
-    val record = heapValue.readObjectRecord()!!
-    if (record is GraphInstanceRecord) {
-      val labels = mutableListOf<String>()
-      if (record instanceOf Thread::class) {
-        val threadName = record["name"]!!.value.readAsJavaString()
-        labels.add("Thread name: '$threadName'")
-      } else {
-        val classRecord = record.readClass()
-        if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
-          val parentClassRecord = classRecord.readSuperClass()!!
-          if (parentClassRecord.name == "java.lang.Object") {
-            try {
-              // This is an anonymous class implementing an interface. The API does not give access
-              // to the interfaces implemented by the class. We check if it's in the class path and
-              // use that instead.
-              val actualClass = Class.forName(classRecord.name)
-              val interfaces = actualClass.interfaces
-              labels.add(
-                  if (interfaces.isNotEmpty()) {
-                    val implementedInterface = interfaces[0]
-                    "Anonymous class implementing ${implementedInterface.name}"
-                  } else {
-                    "Anonymous subclass of java.lang.Object"
-                  }
-              )
-            } catch (ignored: ClassNotFoundException) {
-            }
-          } else {
-            // Makes it easier to figure out which anonymous class we're looking at.
-            labels.add("Anonymous subclass of ${parentClassRecord.name}")
-          }
-        }
-      }
-      return labels
-    } else {
-      return emptyList()
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
index 0fcca05f..526ef11f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
@@ -2,18 +2,12 @@ package leakcanary
 
 import java.io.Serializable
 
-/**
- * Evaluates whether a [LeakNode] is leaking or not, and provides a reason for that decision.
- */
-typealias LeakInspector = (HprofParser, LeakNode) -> LeakNodeStatusAndReason
-
 enum class LeakNodeStatus {
   NOT_LEAKING,
   LEAKING,
   UNKNOWN;
 
   companion object {
-
     private val UNKNOWN_REACHABILITY = LeakNodeStatusAndReason(UNKNOWN, "")
 
     /** The instance was needed and therefore expected to be reachable.  */
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt
new file mode 100644
index 00000000..a9344870
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElementReporter.kt
@@ -0,0 +1,26 @@
+package leakcanary
+
+class LeakTraceElementReporter(val objectRecord: GraphObjectRecord) {
+
+  private val mutableLabels = mutableListOf<String>()
+  private val mutableLeakNodeStatuses = mutableListOf<LeakNodeStatusAndReason>()
+
+  val labels: List<String>
+    get() = mutableLabels
+
+  val leakNodeStatuses: List<LeakNodeStatusAndReason>
+    get() = mutableLeakNodeStatuses
+
+  fun addLabel(label: String) {
+    mutableLabels += label
+  }
+
+  fun reportLeaking(reason: String) {
+    mutableLeakNodeStatuses += LeakNodeStatus.leaking(reason)
+  }
+
+  fun reportNotLeaking(reason: String) {
+    mutableLeakNodeStatuses += LeakNodeStatus.notLeaking(reason)
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt
new file mode 100644
index 00000000..786bddb8
--- /dev/null
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceInspector.kt
@@ -0,0 +1,8 @@
+package leakcanary
+
+interface LeakTraceInspector {
+  fun inspect(
+    graph: HprofGraph,
+    leakTrace: List<LeakTraceElementReporter>
+  )
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index 0501a9cb..57877b93 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -25,13 +25,13 @@ import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
 import leakcanary.Exclusion.Status
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.ExclusionsFactory
 import leakcanary.GcRoot
 import leakcanary.GcRoot.JavaFrame
 import leakcanary.GcRoot.ThreadObject
-import leakcanary.HeapValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HprofParser
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.HprofGraph
 import leakcanary.LeakNode
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNode.RootNode
@@ -47,12 +47,10 @@ import leakcanary.ObjectIdMetadata.OBJECT_ARRAY
 import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_ARRAY
 import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
 import leakcanary.ObjectIdMetadata.STRING
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
 import leakcanary.internal.hppc.LongLongScatterMap
 import leakcanary.internal.hppc.LongScatterSet
-import leakcanary.reference
 import java.util.LinkedHashMap
 import java.util.PriorityQueue
 
@@ -109,8 +107,8 @@ internal class ShortestPathFinder {
   )
 
   fun findPaths(
-    parser: HprofParser,
-    exclusionsFactory: ExclusionsFactory,
+    graph: HprofGraph,
+    exclusions: List<Exclusion>,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
     gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean,
@@ -123,9 +121,8 @@ internal class ShortestPathFinder {
     val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
     val threadNames = mutableMapOf<String, Exclusion>()
 
-    exclusionsFactory(parser)
+    exclusions.filter { it.filter(graph) }
         .forEach { exclusion ->
-
           when (exclusion.type) {
             is ExclusionType.JavaLocalExclusion -> {
               threadNames[exclusion.type.threadName] = exclusion
@@ -154,7 +151,7 @@ internal class ShortestPathFinder {
     // Referent object id to weak ref mirror
     referentMap = leakingWeakRefs.associateBy { it.referent.value }
 
-    enqueueGcRoots(parser, gcRootIds, threadNames, computeDominators)
+    enqueueGcRoots(graph, gcRootIds, threadNames, computeDominators)
 
     var lowestPriority = ALWAYS_REACHABLE
     val results = mutableListOf<Result>()
@@ -190,15 +187,15 @@ internal class ShortestPathFinder {
         break@visitingQueue
       }
 
-      when (val record = parser.retrieveRecordById(node.instance)) {
-        is ClassDumpRecord -> visitClassRecord(
-            parser, record, node, staticFieldNameByClassName, computeDominators
+      when (val graphRecord = graph.readGraphObjectRecord(node.instance)) {
+        is GraphClassRecord -> visitClassRecord(
+            graph, graphRecord, node, staticFieldNameByClassName, computeDominators
         )
-        is InstanceDumpRecord -> visitInstanceRecord(
-            parser, record, node, fieldNameByClassName, computeDominators
+        is GraphInstanceRecord -> visitInstanceRecord(
+            graph, graphRecord, node, fieldNameByClassName, computeDominators
         )
-        is ObjectArrayDumpRecord -> visitObjectArrayRecord(
-            parser, record, node, computeDominators
+        is GraphObjectArrayRecord -> visitObjectArrayRecord(
+            graph, graphRecord.record, node, computeDominators
         )
       }
     }
@@ -225,7 +222,7 @@ internal class ShortestPathFinder {
   }
 
   private fun enqueueGcRoots(
-    parser: HprofParser,
+    graph: HprofGraph,
     gcRoots: MutableList<GcRoot>,
     threadNameExclusions: Map<String, Exclusion>,
     computeDominators: Boolean
@@ -236,22 +233,22 @@ internal class ShortestPathFinder {
     // Once sorted all ThreadObject Gc Roots are located before JavaLocalExclusion Gc Roots.
     // This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
     // built before JavaFrames.
-    sortGcRoots(parser, gcRoots)
+    sortGcRoots(graph, gcRoots)
 
     val threadsBySerialNumber = mutableMapOf<Int, ThreadObject>()
     gcRoots.forEach { gcRoot ->
       if (computeDominators) {
-        undominateWithSkips(parser, gcRoot.id)
+        undominateWithSkips(graph, gcRoot.id)
       }
       when (gcRoot) {
         is ThreadObject -> {
           threadsBySerialNumber[gcRoot.threadSerialNumber] = gcRoot
-          enqueue(parser, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
+          enqueue(graph, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
         }
-        is JavaFrame -> with(parser) {
+        is JavaFrame -> {
           val threadRoot = threadsBySerialNumber.getValue(gcRoot.threadSerialNumber)
-          val threadInstance = threadRoot.id.objectRecord.hydratedInstance
-          val threadName = threadInstance["name"].reference.stringOrNull
+          val threadInstance = graph.readGraphObjectRecord(threadRoot.id).asInstance!!
+          val threadName = threadInstance["name"]?.value?.readAsJavaString()
           val exclusion = threadNameExclusions[threadName]
 
           if (exclusion == null || exclusion.status != NEVER_REACHABLE) {
@@ -261,35 +258,35 @@ internal class ShortestPathFinder {
             // We should also add the full stacktrace as a label of thread objects
             val leakReference = LeakReference(LOCAL, "")
             enqueue(
-                parser,
+                graph,
                 ChildNode(gcRoot.id, visitOrder++, exclusion?.description, rootNode, leakReference),
                 exclusionPriority = exclusion?.status
             )
           }
         }
-        else -> enqueue(parser, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
+        else -> enqueue(graph, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
       }
     }
     gcRoots.clear()
   }
 
   private fun sortGcRoots(
-    parser: HprofParser,
+    graph: HprofGraph,
     gcRoots: MutableList<GcRoot>
   ) {
     val rootClassName: (GcRoot) -> String = {
-      when (val metadata = parser.objectIdMetadata(it.id)) {
+      when (val metadata = graph.objectIdMetadata(it.id)) {
         PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY, PRIMITIVE_WRAPPER_ARRAY, EMPTY_INSTANCE -> metadata.name
         STRING -> "java.lang.String"
         OBJECT_ARRAY -> {
-          val record = parser.retrieveRecordById(it.id) as ObjectArrayDumpRecord
-          parser.className(record.arrayClassId)
+          val record = graph.readObjectRecord(it.id) as ObjectArrayDumpRecord
+          graph.className(record.arrayClassId)
         }
         INSTANCE -> {
-          val record = parser.retrieveRecordById(it.id) as InstanceDumpRecord
-          parser.className(record.classId)
+          val record = graph.readObjectRecord(it.id) as InstanceDumpRecord
+          graph.className(record.classId)
         }
-        CLASS -> parser.className(it.id)
+        CLASS -> graph.className(it.id)
         else -> throw IllegalStateException("Unexpected type $metadata")
       }
     }
@@ -305,25 +302,28 @@ internal class ShortestPathFinder {
   }
 
   private fun visitClassRecord(
-    hprofParser: HprofParser,
-    record: ClassDumpRecord,
+    graph: HprofGraph,
+    classRecord: GraphClassRecord,
     node: LeakNode,
     staticFieldNameByClassName: Map<String, Map<String, Exclusion>>,
     computeRetainedHeapSize: Boolean
   ) {
-    val className = hprofParser.className(record.id)
+    val ignoredStaticFields = staticFieldNameByClassName[classRecord.name] ?: emptyMap()
 
-    val ignoredStaticFields = staticFieldNameByClassName[className] ?: emptyMap()
+    for (staticField in classRecord.staticFields) {
+      if (!staticField.value.isNonNullReference) {
+        continue
+      }
 
-    for (staticField in record.staticFields) {
-      val objectId = (staticField.value as? ObjectReference)?.value ?: continue
-      val fieldName = hprofParser.hprofStringById(staticField.nameStringId)
+      val fieldName = staticField.name
       if (fieldName == "\$staticOverhead") {
         continue
       }
 
+      val objectId = staticField.value.asObjectIdReference!!
+
       if (computeRetainedHeapSize) {
-        undominateWithSkips(hprofParser, objectId)
+        undominateWithSkips(graph, objectId)
       }
 
       val leakReference = LeakReference(STATIC_FIELD, fieldName)
@@ -331,7 +331,7 @@ internal class ShortestPathFinder {
       val exclusion = ignoredStaticFields[fieldName]
 
       enqueue(
-          hprofParser,
+          graph,
           ChildNode(objectId, visitOrder++, exclusion?.description, node, leakReference),
           exclusion?.status
       )
@@ -339,18 +339,16 @@ internal class ShortestPathFinder {
   }
 
   private fun visitInstanceRecord(
-    hprofParser: HprofParser,
-    record: InstanceDumpRecord,
+    graph: HprofGraph,
+    instanceRecord: GraphInstanceRecord,
     parent: LeakNode,
     fieldNameByClassName: Map<String, Map<String, Exclusion>>,
     computeRetainedHeapSize: Boolean
   ) {
-    val instance = hprofParser.hydrateInstance(record)
-
     val ignoredFields = LinkedHashMap<String, Exclusion>()
 
-    instance.classHierarchy.forEach {
-      val classExclusions = fieldNameByClassName[it.className]
+    instanceRecord.readClass().readClassHierarchy().forEach {
+      val classExclusions = fieldNameByClassName[it.name]
       if (classExclusions != null) {
         for ((fieldName, exclusion) in classExclusions) {
           if (!ignoredFields.containsKey(fieldName)) {
@@ -360,53 +358,47 @@ internal class ShortestPathFinder {
       }
     }
 
-    val fieldNamesAndValues = mutableListOf<Pair<String, HeapValue>>()
-
-    instance.fieldValues.forEachIndexed { classIndex, classFieldValues ->
-      classFieldValues.forEachIndexed { fieldIndex, fieldValue ->
-        val fieldName = instance.classHierarchy[classIndex].fieldNames[fieldIndex]
-        fieldNamesAndValues.add(fieldName to fieldValue)
-      }
-    }
+    val fieldNamesAndValues = instanceRecord.readFields()
+        .toMutableList()
 
-    fieldNamesAndValues.sortBy { (name, _) -> name }
+    fieldNamesAndValues.sortBy { it.name }
 
-    fieldNamesAndValues.filter { (_, value) -> value is ObjectReference }
-        .map { (name, reference) -> name to (reference as ObjectReference).value }
-        .forEach { (fieldName, objectId) ->
+    fieldNamesAndValues.filter { it.value.isNonNullReference }
+        .forEach { field ->
+          val objectId = field.value.asObjectIdReference!!
           if (computeRetainedHeapSize) {
-            updateDominatorWithSkips(hprofParser, parent.instance, objectId)
+            updateDominatorWithSkips(graph, parent.instance, objectId)
           }
 
-          val exclusion = ignoredFields[fieldName]
+          val exclusion = ignoredFields[field.name]
           enqueue(
-              hprofParser, ChildNode(
+              graph, ChildNode(
               objectId,
               visitOrder++, exclusion?.description, parent,
-              LeakReference(INSTANCE_FIELD, fieldName)
+              LeakReference(INSTANCE_FIELD, field.name)
           ), exclusion?.status
           )
         }
   }
 
   private fun visitObjectArrayRecord(
-    hprofParser: HprofParser,
+    graph: HprofGraph,
     record: ObjectArrayDumpRecord,
     parentNode: LeakNode,
     computeRetainedHeapSize: Boolean
   ) {
     record.elementIds.forEachIndexed { index, elementId ->
       if (computeRetainedHeapSize) {
-        updateDominatorWithSkips(hprofParser, parentNode.instance, elementId)
+        updateDominatorWithSkips(graph, parentNode.instance, elementId)
       }
       val name = Integer.toString(index)
       val reference = LeakReference(ARRAY_ENTRY, name)
-      enqueue(hprofParser, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
+      enqueue(graph, ChildNode(elementId, visitOrder++, null, parentNode, reference), null)
     }
   }
 
   private fun enqueue(
-    parser: HprofParser,
+    graph: HprofGraph,
     node: LeakNode,
     exclusionPriority: Status?
   ) {
@@ -432,7 +424,7 @@ internal class ShortestPathFinder {
 
     val isLeakingInstance = referentMap[node.instance] != null
 
-    val objectIdMetadata = parser.objectIdMetadata(node.instance)
+    val objectIdMetadata = graph.objectIdMetadata(node.instance)
     if (!isLeakingInstance && objectIdMetadata in SKIP_ENQUEUE) {
       return
     }
@@ -445,20 +437,19 @@ internal class ShortestPathFinder {
   }
 
   private fun updateDominatorWithSkips(
-    hprofParser: HprofParser,
+    graph: HprofGraph,
     parentObjectId: Long,
     objectId: Long
   ) {
-    when (hprofParser.objectIdMetadata(objectId)) {
+    when (graph.objectIdMetadata(objectId)) {
       CLASS -> {
         undominate(objectId, false)
       }
       // String internal array is never enqueued
       STRING -> {
         updateDominator(parentObjectId, objectId, true)
-        val stringRecord = hprofParser.retrieveRecordById(objectId) as InstanceDumpRecord
-        val stringInstance = hprofParser.hydrateInstance(stringRecord)
-        val valueId = stringInstance["value"].reference
+        val stringInstance = graph.readGraphObjectRecord(objectId).asInstance!!
+        val valueId = stringInstance["value"]?.value?.asNonNullObjectIdReference
         if (valueId != null) {
           updateDominator(parentObjectId, valueId, true)
         }
@@ -466,7 +457,7 @@ internal class ShortestPathFinder {
       // Primitive wrapper array elements are never enqueued
       PRIMITIVE_WRAPPER_ARRAY -> {
         updateDominator(parentObjectId, objectId, true)
-        val arrayRecord = hprofParser.retrieveRecordById(objectId) as ObjectArrayDumpRecord
+        val arrayRecord = graph.readObjectRecord(objectId) as ObjectArrayDumpRecord
         for (wrapperId in arrayRecord.elementIds) {
           updateDominator(parentObjectId, wrapperId, true)
         }
@@ -541,19 +532,19 @@ internal class ShortestPathFinder {
   }
 
   private fun undominateWithSkips(
-    hprofParser: HprofParser,
+    graph: HprofGraph,
     objectId: Long
   ) {
-    when (hprofParser.objectIdMetadata(objectId)) {
+    when (graph.objectIdMetadata(objectId)) {
       CLASS -> {
         undominate(objectId, false)
       }
       // String internal array is never enqueued
       STRING -> {
         undominate(objectId, true)
-        val stringRecord = hprofParser.retrieveRecordById(objectId) as InstanceDumpRecord
-        val stringInstance = hprofParser.hydrateInstance(stringRecord)
-        val valueId = stringInstance["value"].reference
+        val stringRecord = graph.readGraphObjectRecord(objectId)
+        val stringInstance = stringRecord.asInstance!!
+        val valueId = stringInstance["value"]?.value?.asObjectIdReference
         if (valueId != null) {
           undominate(valueId, true)
         }
@@ -561,7 +552,8 @@ internal class ShortestPathFinder {
       // Primitive wrapper array elements are never enqueued
       PRIMITIVE_WRAPPER_ARRAY -> {
         undominate(objectId, true)
-        val arrayRecord = hprofParser.retrieveRecordById(objectId) as ObjectArrayDumpRecord
+        val arrayRecord =
+          graph.readObjectRecord(objectId) as ObjectArrayDumpRecord
         for (wrapperId in arrayRecord.elementIds) {
           undominate(wrapperId, true)
         }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
index 9690bdbe..f0df046b 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
@@ -33,9 +33,9 @@ class ExclusionTest {
   @Test fun shortestPathExcluded() {
     hprofFile.writeTwoPathsToInstance()
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
-      listOf(Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")))
-    }
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")))
+    )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
     assertThat(leak.leakTrace.elements).hasSize(3)
@@ -49,12 +49,12 @@ class ExclusionTest {
   @Test fun allPathsExcluded_ShortestWins() {
     hprofFile.writeTwoPathsToInstance()
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
-      listOf(
-          Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")),
-          Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"))
-      )
-    }
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(
+            Exclusion(StaticFieldExclusion("GcRoot", "shortestPath")),
+            Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"))
+        )
+    )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
     assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
@@ -67,21 +67,21 @@ class ExclusionTest {
   @Test fun noPathToInstanceNeverReachable() {
     hprofFile.writeTwoPathsToInstance()
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
-      listOf(
-          Exclusion(StaticFieldExclusion("GcRoot", "shortestPath"), status = NEVER_REACHABLE),
-          Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"), status = NEVER_REACHABLE)
-      )
-    }
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(
+            Exclusion(StaticFieldExclusion("GcRoot", "shortestPath"), status = NEVER_REACHABLE),
+            Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"), status = NEVER_REACHABLE)
+        )
+    )
     assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
   }
 
   @Test fun excludedThread() {
     hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
-      listOf(Exclusion(JavaLocalExclusion("kroutine"), status = WONT_FIX_LEAK))
-    }
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(Exclusion(JavaLocalExclusion("kroutine"), status = WONT_FIX_LEAK))
+    )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
     assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
@@ -95,14 +95,14 @@ class ExclusionTest {
       }
     }
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
-      listOf(
-          Exclusion(
-              type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-              status = WEAKLY_REACHABLE
-          )
-      )
-    }
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(
+            Exclusion(
+                type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+                status = WEAKLY_REACHABLE
+            )
+        )
+    )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
     assertThat(leak.exclusionStatus).isEqualTo(WEAKLY_REACHABLE)
@@ -116,17 +116,17 @@ class ExclusionTest {
       }
     }
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
-      listOf(
-          Exclusion(
-              type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
-              status = WEAKLY_REACHABLE
-          ), Exclusion(
-          type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
-          status = NEVER_REACHABLE
-      )
-      )
-    }
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        exclusions = listOf(
+            Exclusion(
+                type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+                status = WEAKLY_REACHABLE
+            ), Exclusion(
+            type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
+            status = NEVER_REACHABLE
+        )
+        )
+    )
     assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
   }
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
index 46350e3c..284f3248 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
@@ -1,12 +1,12 @@
 package leakcanary.internal
 
+import leakcanary.AndroidLeakTraceInspectors
 import leakcanary.HeapAnalysisSuccess
-import leakcanary.HprofParser
-import leakcanary.InstanceDefaultLabeler
-import leakcanary.LeakNode
-import leakcanary.LeakTraceElement.Type.LOCAL
+import leakcanary.HprofGraph
+import leakcanary.LeakTraceElementReporter
+import leakcanary.LeakTraceInspector
 import leakcanary.LeakingInstance
-import leakcanary.ObjectIdMetadata.STRING
+import leakcanary.forEachInstanceOf
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -28,16 +28,18 @@ class LabelerTest {
   @Test fun stringContentAsLabel() {
     hprofFile.writeSinglePathToString("World")
 
-    val labeler = { parser: HprofParser,
-      node: LeakNode
-      ->
-      if (parser.objectIdMetadata(node.instance) == STRING) {
-        listOf("Hello ${parser.retrieveStringById(node.instance)}")
-      } else emptyList()
-
+    val labeler = object : LeakTraceInspector{
+      override fun inspect(
+        graph: HprofGraph,
+        leakTrace: List<LeakTraceElementReporter>
+      ) {
+        leakTrace.forEachInstanceOf("java.lang.String")  { instance ->
+          addLabel("Hello ${instance.readAsJavaString()}")
+        }
+      }
     }
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(labelers = listOf(labeler))
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakTraceInspectors = listOf(labeler))
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
 
@@ -48,7 +50,7 @@ class LabelerTest {
     hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
 
     val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(labelers = listOf(InstanceDefaultLabeler))
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakTraceInspectors = listOf(AndroidLeakTraceInspectors.THREAD))
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
index b71c985b..761db959 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
@@ -1,14 +1,15 @@
 package leakcanary.internal
 
+import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
 import leakcanary.HeapAnalysisSuccess
-import leakcanary.LeakInspector
-import leakcanary.LeakNodeStatus
+import leakcanary.HprofGraph
 import leakcanary.LeakNodeStatus.LEAKING
 import leakcanary.LeakNodeStatus.NOT_LEAKING
 import leakcanary.LeakNodeStatus.UNKNOWN
+import leakcanary.LeakTraceElementReporter
+import leakcanary.LeakTraceInspector
 import leakcanary.LeakingInstance
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -73,7 +74,7 @@ class LeakStatusTest {
     }
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        leakInspectors = listOf(notLeaking("Class1"))
+        leakTraceInspectors = listOf(notLeaking("Class1"))
     )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -91,7 +92,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(leaking("Class1"))
+          leakTraceInspectors = listOf(leaking("Class1"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -109,7 +110,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(leaking("Class1"), unknownInstance())
+          leakTraceInspectors = listOf(leaking("Class1"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -131,7 +132,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(notLeaking("Class3"))
+          leakTraceInspectors = listOf(notLeaking("Class3"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -153,7 +154,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(leaking("Class1"))
+          leakTraceInspectors = listOf(leaking("Class1"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -175,7 +176,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(
+          leakTraceInspectors = listOf(
               notLeaking("Class3"), leaking("Class1")
           )
       )
@@ -212,7 +213,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(
+          leakTraceInspectors = listOf(
               notLeaking("Class1"), leaking("Class3")
           )
       )
@@ -226,7 +227,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(leaking("GcRoot"))
+          leakTraceInspectors = listOf(leaking("GcRoot"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -242,7 +243,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(notLeaking("GcRoot"))
+          leakTraceInspectors = listOf(notLeaking("GcRoot"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -257,7 +258,7 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(notLeaking("Leaking"))
+          leakTraceInspectors = listOf(notLeaking("Leaking"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -271,7 +272,7 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(leaking("Leaking"))
+          leakTraceInspectors = listOf(leaking("Leaking"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -292,7 +293,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(
+          leakTraceInspectors = listOf(
               notLeaking("Class1"), leaking("Class1")
           )
       )
@@ -315,7 +316,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(
+          leakTraceInspectors = listOf(
               notLeaking("Class1"), notLeaking("Class1")
           )
       )
@@ -338,7 +339,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(leaking("Class1"), leaking("Class1"))
+          leakTraceInspectors = listOf(leaking("Class1"), leaking("Class1"))
       )
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
@@ -363,7 +364,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(
+          leakTraceInspectors = listOf(
               notLeaking("Class1"), leaking("Class3")
           )
       )
@@ -460,42 +461,38 @@ class LeakStatusTest {
     assertThat(hash1).isEqualTo(hash2)
   }
 
-  private fun unknownInstance(): LeakInspector {
-    return { _, _ -> LeakNodeStatus.unknown() }
-  }
-
-  private fun notLeaking(className: String): LeakInspector {
-    return { parser, node ->
-      with(parser) result@{
-        val record = node.instance.objectRecord
-        if (record is InstanceDumpRecord) {
-          if (className(record.classId) == className) {
-            return@result LeakNodeStatus.notLeaking("$className is not leaking")
-          }
-        } else if (record is ClassDumpRecord) {
-          if (className(record.id) == className) {
-            return@result LeakNodeStatus.notLeaking("$className is not leaking")
+  private fun notLeaking(className: String): LeakTraceInspector {
+    return object : LeakTraceInspector {
+      override fun inspect(
+        graph: HprofGraph,
+        leakTrace: List<LeakTraceElementReporter>
+      ) {
+        leakTrace.forEach { reporter ->
+          val record = reporter.objectRecord
+          if (record is GraphInstanceRecord && record.className == className) {
+            reporter.reportNotLeaking("$className is not leaking")
+          } else if (record is GraphClassRecord && record.name == className) {
+            reporter.reportNotLeaking("$className is not leaking")
           }
         }
-        return@result LeakNodeStatus.unknown()
       }
     }
   }
 
-  private fun leaking(className: String): LeakInspector {
-    return { parser, node ->
-      with(parser) result@{
-        val record = node.instance.objectRecord
-        if (record is InstanceDumpRecord) {
-          if (className(record.classId) == className) {
-            return@result LeakNodeStatus.leaking("$className is leaking")
-          }
-        } else if (record is ClassDumpRecord) {
-          if (className(record.id) == className) {
-            return@result LeakNodeStatus.leaking("$className is leaking")
+  private fun leaking(className: String): LeakTraceInspector {
+    return object : LeakTraceInspector {
+      override fun inspect(
+        graph: HprofGraph,
+        leakTrace: List<LeakTraceElementReporter>
+      ) {
+        leakTrace.forEach { reporter ->
+          val record = reporter.objectRecord
+          if (record is GraphInstanceRecord && record.className == className) {
+            reporter.reportLeaking("$className is leaking")
+          } else if (record is GraphClassRecord && record.name == className) {
+            reporter.reportLeaking("$className is leaking")
           }
         }
-        return@result LeakNodeStatus.unknown()
       }
     }
   }
@@ -506,7 +503,7 @@ class LeakStatusTest {
   ): String {
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          leakInspectors = listOf(notLeaking(notLeaking), leaking(leaking))
+          leakTraceInspectors = listOf(notLeaking(notLeaking), leaking(leaking))
       )
     val leak = analysis.retainedInstances[0] as LeakingInstance
     return leak.groupHash
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
index 300b054c..0bcdfaeb 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
@@ -3,12 +3,13 @@ package leakcanary.internal
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.HeapAnalysisSuccess
-import leakcanary.LeakNodeStatus
+import leakcanary.HprofGraph
+import leakcanary.LeakTraceElementReporter
+import leakcanary.LeakTraceInspector
 import leakcanary.LeakingInstance
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.forEachInstanceOf
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
-import org.junit.Ignore
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
@@ -57,16 +58,18 @@ class LeakTraceRendererTest {
     }
 
     val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(leakInspectors = listOf { parser, node ->
-        with(parser) {
-          val record = node.instance.objectRecord
-          if (record is InstanceDumpRecord && className(record.classId) == "ClassB") {
-            LeakNodeStatus.leaking("because reasons")
-          } else {
-            LeakNodeStatus.unknown()
-          }
-        }
-      })
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          leakTraceInspectors = listOf(object : LeakTraceInspector {
+            override fun inspect(
+              graph: HprofGraph,
+              leakTrace: List<LeakTraceElementReporter>
+            ) {
+              leakTrace.forEachInstanceOf("ClassB") {
+                reportLeaking("because reasons")
+              }
+            }
+          })
+      )
 
     analysis renders """
     ┬
@@ -93,9 +96,19 @@ class LeakTraceRendererTest {
       }
     }
 
-    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(labelers = listOf { _, _ ->
-      listOf("¯\\_(ツ)_/¯")
-    })
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        leakTraceInspectors = listOf(object : LeakTraceInspector {
+          override fun inspect(
+            graph: HprofGraph,
+            leakTrace: List<LeakTraceElementReporter>
+          ) {
+            leakTrace.forEach { reporter ->
+              reporter.addLabel("¯\\_(ツ)_/¯")
+            }
+          }
+
+        })
+    )
 
     analysis renders """
     ┬
@@ -120,9 +133,9 @@ class LeakTraceRendererTest {
     }
 
     val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(exclusionsFactory = {
-        listOf(Exclusion(type = InstanceFieldExclusion("ClassA", "leak")))
-      })
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+          exclusions = listOf(Exclusion(type = InstanceFieldExclusion("ClassA", "leak")))
+      )
 
     analysis renders """
     ┬
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
index 38accd4d..785e69e9 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
@@ -1,8 +1,7 @@
 package leakcanary.internal
 
-import leakcanary.AndroidExcludedRefs
-import leakcanary.AndroidLabelers
-import leakcanary.AndroidLeakInspectors
+import leakcanary.AndroidKnownReference
+import leakcanary.AndroidLeakTraceInspectors
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
@@ -54,9 +53,8 @@ class LegacyHprofTest {
     val hprofFile = File(url.path)
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
-        labelers = AndroidLabelers.values().toList(),
-        leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors(),
-        exclusionsFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
+        leakTraceInspectors = AndroidLeakTraceInspectors.defaultInspectors(),
+        exclusions = AndroidKnownReference.mapToExclusions(AndroidKnownReference.appDefaults)
     )
     if (analysis is HeapAnalysisFailure) {
       print(analysis)
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
index 7dd0a719..78197952 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
@@ -5,6 +5,7 @@ import leakcanary.HeapAnalysisSuccess
 import leakcanary.HeapValue
 import leakcanary.HeapValue.IntValue
 import leakcanary.HeapValue.LongValue
+import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
 import leakcanary.LeakingInstance
 import org.assertj.core.api.Assertions.assertThat
@@ -281,14 +282,21 @@ class RetainedSizeTest {
         field["mHeight"] = IntValue(height)
       }
 
-      "sun.misc.Cleaner" instance {
-        field["referent"] = bitmap
-        field["thunk"] = "libcore.util.NativeAllocationRegistry\$CleanerThunk" instance {
-          field["this\$0"] = "libcore.util.NativeAllocationRegistry" instance {
-            field["size"] = LongValue(nativeBitmapSize.toLong())
-          }
-        }
-      }
+      val referenceClass =
+        clazz("java.lang.ref.Reference", fields = listOf("referent" to ObjectReference::class))
+      val cleanerClass = clazz(
+          "sun.misc.Cleaner", clazz("java.lang.ref.PhantomReference", referenceClass),
+          fields = listOf("thunk" to ObjectReference::class)
+      )
+
+      instance(
+          cleanerClass,
+          fields = listOf("libcore.util.NativeAllocationRegistry\$CleanerThunk" instance {
+            field["this\$0"] = "libcore.util.NativeAllocationRegistry" instance {
+              field["size"] = LongValue(nativeBitmapSize.toLong())
+            }
+          }, bitmap)
+      )
 
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
index bb2aedab..371ca88e 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -6,12 +6,10 @@ import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
-import leakcanary.ExclusionsFactory
-import leakcanary.LeakInspector
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalyzer
 import leakcanary.KeyedWeakReference
-import leakcanary.Labeler
+import leakcanary.LeakTraceInspector
 import java.io.File
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
@@ -19,18 +17,17 @@ import java.lang.ref.WeakReference
 
 @Suppress("UNCHECKED_CAST")
 fun <T : HeapAnalysis> File.checkForLeaks(
-  labelers: List<Labeler> = emptyList(),
-  leakInspectors: List<LeakInspector> = emptyList(),
+  leakTraceInspectors: List<LeakTraceInspector> = emptyList(),
   computeRetainedHeapSize: Boolean = false,
-  exclusionsFactory: ExclusionsFactory = defaultExclusionsFactory
+  exclusions: List<Exclusion> = defaultExclusionsFactory
 ): T {
   val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
   return heapAnalyzer.checkForLeaks(
-      this, exclusionsFactory, computeRetainedHeapSize, leakInspectors, labelers
+      this, exclusions, computeRetainedHeapSize, leakTraceInspectors
   ) as T
 }
 
-val defaultExclusionsFactory: ExclusionsFactory = {
+val defaultExclusionsFactory: List<Exclusion> =
   listOf(
       Exclusion(
           type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
@@ -99,5 +96,4 @@ val defaultExclusionsFactory: ExclusionsFactory = {
           type = JavaLocalExclusion("main"),
           status = NEVER_REACHABLE
       )
-  )
-}
\ No newline at end of file
+  )
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index aba12f5b..251a6407 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -2,9 +2,7 @@ package leakcanary
 
 import android.app.Application
 import android.content.Intent
-import leakcanary.AndroidExcludedRefs.Companion.exclusionsFactory
 import leakcanary.internal.InternalLeakCanary
-import java.util.ArrayList
 
 typealias AnalysisResultListener = (Application, HeapAnalysis) -> Unit
 
@@ -30,13 +28,11 @@ object LeakCanary {
      * bothering developers as much but it could miss some leaks.
      */
     val retainedVisibleThreshold: Int = 5,
-    val exclusionsFactory: ExclusionsFactory = exclusionsFactory(
-        AndroidExcludedRefs.appDefaults
-    ),
-    val leakInspectors: List<LeakInspector> = AndroidLeakInspectors.defaultAndroidInspectors(),
-    val labelers: List<Labeler> = defaultAndroidLabelers(
-        InternalLeakCanary.application
-    ),
+
+    val knownReferences: Set<AndroidKnownReference> = AndroidKnownReference.appDefaults,
+
+    val leakTraceInspectors: List<LeakTraceInspector> = AndroidLeakTraceInspectors.defaultInspectors(),
+
     /**
      * Called with the heap analysis result from a background thread.
      * The heap dump file will be removed immediately after this function is invoked.
@@ -74,16 +70,4 @@ object LeakCanary {
   /** [Intent] that can be used to programmatically launch the leak display activity. */
   val leakDisplayActivityIntent
     get() = InternalLeakCanary.leakDisplayActivityIntent
-
-  fun defaultAndroidLabelers(application: Application): List<Labeler> {
-    val labelers = ArrayList<Labeler>()
-    labelers.add(InstanceDefaultLabeler)
-    labelers.add(
-        ViewLabeler(
-            application
-        )
-    )
-    labelers.addAll(AndroidLabelers.values())
-    return labelers
-  }
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt b/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt
deleted file mode 100644
index 7ba7ce80..00000000
--- a/leakcanary-android-core/src/main/java/leakcanary/ViewLabeler.kt
+++ /dev/null
@@ -1,61 +0,0 @@
-package leakcanary
-
-import android.app.Application
-import android.content.res.Resources.NotFoundException
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.HeapValue.ObjectReference
-
-class ViewLabeler(
-  private val application: Application
-) : Labeler {
-  override fun invoke(
-    parser: HprofParser,
-    node: LeakNode
-  ): List<String> {
-    val heapValue = GraphHeapValue(HprofGraph(parser), ObjectReference(node.instance))
-    val record = heapValue.readObjectRecord()
-
-    if (record is GraphInstanceRecord && record instanceOf "android.view.View") {
-      val viewLabels = mutableListOf<String>()
-      val mAttachInfo = record["mAttachInfo"]?.value
-      if (mAttachInfo != null) {
-        if (mAttachInfo.isNullReference) {
-          viewLabels.add("View#mAttachInfo is null (view detached)")
-        } else {
-          viewLabels.add("View#mAttachInfo is not null (view attached)")
-        }
-      }
-
-      val mParent = record["mParent"]?.value
-      if (mParent != null) {
-        if (mParent.isNullReference) {
-          viewLabels.add("View#mParent is null")
-        } else {
-          viewLabels.add("View#mParent is set")
-        }
-      }
-
-      val mID = record["mId"]?.value?.asInt
-      if (mID != null) {
-        if (mID != 0) {
-          try {
-            val name = application.resources.getResourceEntryName(mID)
-            viewLabels.add("View.mID=R.id.$name ($mID)")
-          } catch (ignored: NotFoundException) {
-            viewLabels.add("View.mID=$mID (name not found)")
-          }
-        } else {
-          viewLabels.add("View.mID=0")
-        }
-      }
-
-      val mWindowAttachCount = record["mWindowAttachCount"]?.value?.asInt
-
-      if (mWindowAttachCount != null) {
-        viewLabels.add("View.mWindowAttachCount=$mWindowAttachCount")
-      }
-      return viewLabels
-    }
-    return emptyList()
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index 202f85d0..c4d8919b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -115,7 +115,8 @@ internal class AndroidHeapDumper(
       )
       toast.setGravity(Gravity.CENTER_VERTICAL, 0, -iconSize)
       toast.duration = Toast.LENGTH_LONG
-      val inflater = LayoutInflater.from(resumedActivity)
+      // Inflating with application context: https://github.com/square/leakcanary/issues/1385
+      val inflater = LayoutInflater.from(resumedActivity.application)
       toast.view = inflater.inflate(R.layout.leak_canary_heap_dump_toast, null)
       toast.show()
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 8c760955..7d4c5c87 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -131,6 +131,8 @@ internal class DisplayLeakAdapter private constructor(
     moreDetailsView.setDetails(
         when {
           isLeakGroup -> NONE
+          // Learn more row
+          isFirstConnectorRow(position) -> NONE
           opened[position] -> OPENED
           else -> CLOSED
         }
@@ -143,7 +145,7 @@ internal class DisplayLeakAdapter private constructor(
     }
 
     val resources = view.resources
-    if (position == TOP_ROW_COUNT - 1) {
+    if (isFirstConnectorRow(position)) {
       titleView.text = if (isLeakGroup) {
         HtmlCompat.fromHtml(
             """
@@ -163,11 +165,6 @@ internal class DisplayLeakAdapter private constructor(
             HtmlCompat.FROM_HTML_MODE_LEGACY
         )
       }
-      val detailText = HtmlCompat.fromHtml(
-          resources.getString(R.string.leak_canary_help_detail), HtmlCompat.FROM_HTML_MODE_LEGACY
-      ) as SpannableStringBuilder
-      SquigglySpan.replaceUnderlineSpans(detailText, view.context)
-      detailView.text = detailText
     } else {
       val isLast = position == (TOP_ROW_COUNT + leakTrace.elements.size) - 1
 
@@ -290,7 +287,7 @@ internal class DisplayLeakAdapter private constructor(
   }
 
   private fun getConnectorType(position: Int): Type {
-    if (position == TOP_ROW_COUNT - 1) {
+    if (isFirstConnectorRow(position)) {
       return if (isLeakGroup) HELP_LEAK_GROUP else HELP
     } else if (position == TOP_ROW_COUNT) {
       if (leakTrace.elements.size == 1) {
@@ -333,6 +330,10 @@ internal class DisplayLeakAdapter private constructor(
     }
   }
 
+  fun isLearnMoreRow(position: Int) = isFirstConnectorRow(position) && !isLeakGroup
+
+  fun isFirstConnectorRow(position: Int) = position == TOP_ROW_COUNT - 1
+
   fun toggleRow(position: Int) {
     opened[position] = !opened[position]
     notifyDataSetChanged()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index 4a1bc376..263f6946 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -21,6 +21,7 @@ import android.os.Process
 import androidx.core.content.ContextCompat
 import com.squareup.leakcanary.core.R
 import leakcanary.AnalyzerProgressListener
+import leakcanary.AndroidKnownReference
 import leakcanary.CanaryLog
 import leakcanary.HeapAnalyzer
 import leakcanary.LeakCanary
@@ -54,10 +55,12 @@ internal class HeapAnalyzerService : ForegroundService(
 
     val heapAnalyzer = HeapAnalyzer(this)
     val config = LeakCanary.config
+
+    val exclusions = AndroidKnownReference.mapToExclusions(config.knownReferences)
+
     val heapAnalysis =
       heapAnalyzer.checkForLeaks(
-          heapDumpFile, config.exclusionsFactory, config.computeRetainedHeapSize,
-          config.leakInspectors, config.labelers
+          heapDumpFile, exclusions, config.computeRetainedHeapSize, config.leakTraceInspectors
       )
 
     config.analysisResultListener(application, heapAnalysis)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index 6abc37c2..ee54c63d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -36,6 +36,16 @@ internal class HeapDumpTrigger(
   @Volatile
   private var checkScheduled: Boolean = false
 
+  private var lastDisplayedRetainedInstanceCount = 0
+
+  private val scheduleDismissRetainedCountNotification = {
+    dismissRetainedCountNotification()
+  }
+
+  private val scheduleDismissNoRetainedOnTapNotification = {
+    dismissNoRetainedOnTapNotification()
+  }
+
   /**
    * When the app becomes invisible, we don't dump the heap immediately. Instead we wait in case
    * the app came back to the foreground, but also to wait for new leaks that typically occur on
@@ -64,15 +74,21 @@ internal class HeapDumpTrigger(
   }
 
   private fun checkRetainedInstances(reason: String) {
-    CanaryLog.d("Checking retained instances because %s", reason)
     val config = configProvider()
     // A tick will be rescheduled when this is turned back on.
     if (!config.dumpHeap) {
+      CanaryLog.d("No checking for retained instance: LeakCanary.Config.dumpHeap is false")
       return
     }
+    CanaryLog.d("Checking retained instances because %s", reason)
 
     var retainedReferenceCount = refWatcher.retainedInstanceCount
 
+    if (retainedReferenceCount > 0) {
+      gcTrigger.runGc()
+      retainedReferenceCount = refWatcher.retainedInstanceCount
+    }
+
     if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
 
     if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
@@ -85,16 +101,10 @@ internal class HeapDumpTrigger(
       return
     }
 
-    gcTrigger.runGc()
-
-    retainedReferenceCount = refWatcher.retainedInstanceCount
-
-    if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return
-
     CanaryLog.d("Found %d retained references, dumping the heap", retainedReferenceCount)
     val heapDumpUptimeMillis = SystemClock.uptimeMillis()
     KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
-    dismissNotification()
+    dismissRetainedCountNotification()
     val heapDumpFile = heapDumper.dumpHeap()
     if (heapDumpFile == null) {
       CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
@@ -102,7 +112,7 @@ internal class HeapDumpTrigger(
       showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
       return
     }
-
+    lastDisplayedRetainedInstanceCount = 0
     refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
 
     HeapAnalyzerService.runAnalysis(application, heapDumpFile)
@@ -110,6 +120,7 @@ internal class HeapDumpTrigger(
 
   fun onDumpHeapReceived() {
     backgroundHandler.post {
+      dismissNoRetainedOnTapNotification()
       gcTrigger.runGc()
       val retainedReferenceCount = refWatcher.retainedInstanceCount
       if (retainedReferenceCount == 0) {
@@ -127,7 +138,14 @@ internal class HeapDumpTrigger(
             .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
         val notification =
           Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
-        notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+        notificationManager.notify(
+            R.id.leak_canary_notification_no_retained_instance_on_tap, notification
+        )
+        backgroundHandler.postDelayed(
+            scheduleDismissNoRetainedOnTapNotification,
+            DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+        )
+        lastDisplayedRetainedInstanceCount = 0
         return@post
       }
 
@@ -141,7 +159,7 @@ internal class HeapDumpTrigger(
         showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
         return@post
       }
-
+      lastDisplayedRetainedInstanceCount = 0
       refWatcher.removeInstancesRetainedBeforeHeapDump(heapDumpUptimeMillis)
       HeapAnalyzerService.runAnalysis(application, heapDumpFile)
     }
@@ -151,9 +169,13 @@ internal class HeapDumpTrigger(
     retainedKeysCount: Int,
     retainedVisibleThreshold: Int
   ): Boolean {
+    val countChanged = lastDisplayedRetainedInstanceCount != retainedKeysCount
+    lastDisplayedRetainedInstanceCount = retainedKeysCount
     if (retainedKeysCount == 0) {
       CanaryLog.d("No retained instances")
-      dismissNotification()
+      if (countChanged) {
+        showNoMoreRetainedInstanceNotification()
+      }
       return true
     }
 
@@ -176,6 +198,7 @@ internal class HeapDumpTrigger(
 
   private fun scheduleRetainedInstanceCheck(reason: String) {
     if (checkScheduled) {
+      CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
       return
     }
     checkScheduled = true
@@ -190,6 +213,7 @@ internal class HeapDumpTrigger(
     delayMillis: Long
   ) {
     if (checkScheduled) {
+      CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
       return
     }
     checkScheduled = true
@@ -223,10 +247,35 @@ internal class HeapDumpTrigger(
     )
   }
 
+  private fun showNoMoreRetainedInstanceNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
+    if (!Notifications.canShowNotification) {
+      return
+    }
+    val builder = Notification.Builder(application)
+        .setContentTitle(
+            application.getString(R.string.leak_canary_notification_no_retained_instance_title)
+        )
+        .setContentText(
+            application.getString(
+                R.string.leak_canary_notification_no_retained_instance_content
+            )
+        )
+        .setAutoCancel(true)
+        .setContentIntent(NotificationReceiver.pendingIntent(application, CANCEL_NOTIFICATION))
+    val notification =
+      Notifications.buildNotification(application, builder, LEAKCANARY_LOW)
+    notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
+    backgroundHandler.postDelayed(
+        scheduleDismissRetainedCountNotification, DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS
+    )
+  }
+
   private fun showRetainedCountNotification(
     instanceCount: Int,
     contentText: String
   ) {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
     if (!Notifications.canShowNotification) {
       return
     }
@@ -242,14 +291,21 @@ internal class HeapDumpTrigger(
     notificationManager.notify(R.id.leak_canary_notification_retained_instances, notification)
   }
 
-  private fun dismissNotification() {
+  private fun dismissRetainedCountNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissRetainedCountNotification)
     notificationManager.cancel(R.id.leak_canary_notification_retained_instances)
   }
 
+  private fun dismissNoRetainedOnTapNotification() {
+    backgroundHandler.removeCallbacks(scheduleDismissNoRetainedOnTapNotification)
+    notificationManager.cancel(R.id.leak_canary_notification_no_retained_instance_on_tap)
+  }
+
   companion object {
     private const val WAIT_FOR_DEBUG_MILLIS = 20_000L
     private const val WAIT_AFTER_DUMP_FAILED_MILLIS = 5_000L
-    private const val WAIT_FOR_INSTANCE_THRESHOLD_MILLIS = 5_000L
+    private const val WAIT_FOR_INSTANCE_THRESHOLD_MILLIS = 2_000L
+    private const val DISMISS_NO_RETAINED_INSTANCE_NOTIFICATION_MILLIS = 30_000L
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 6dfe9b95..8c71a08b 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -1,6 +1,7 @@
 package leakcanary.internal
 
 import android.app.Application
+import android.app.Instrumentation
 import android.content.ComponentName
 import android.content.Intent
 import android.content.pm.ShortcutInfo.Builder
@@ -17,6 +18,7 @@ import leakcanary.LeakCanary
 import leakcanary.LeakCanary.Config
 import leakcanary.LeakSentry
 import leakcanary.internal.activity.LeakActivity
+import java.util.concurrent.atomic.AtomicReference
 
 internal object InternalLeakCanary : LeakSentryListener {
 
@@ -42,8 +44,7 @@ internal object InternalLeakCanary : LeakSentryListener {
 
   val noInstallConfig: Config
     get() = Config(
-        dumpHeap = false, exclusionsFactory = { emptyList() }, leakInspectors = emptyList(),
-        labelers = emptyList()
+        dumpHeap = false, knownReferences = emptySet(), leakTraceInspectors = emptyList()
     )
 
   override fun onLeakSentryInstalled(application: Application) {
@@ -67,6 +68,36 @@ internal object InternalLeakCanary : LeakSentryListener {
       heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)
     }
     addDynamicShortcut(application)
+
+    disableDumpHeapInInstrumentationTests()
+  }
+
+  private fun disableDumpHeapInInstrumentationTests() {
+    // This is called before Application.onCreate(), so InstrumentationRegistry has no reference to
+    // the instrumentation yet. That happens immediately after the content providers are created,
+    // in the same main thread message, so by posting to the end of the main thread queue we're
+    // guaranteed that the instrumentation will be in place.
+    Handler().post {
+      val runningInInstrumentationTests = try {
+        // This is assuming all UI tests rely on InstrumentationRegistry. Should be mostly true
+        // these days (especially since we force the Android X dependency on consumers).
+        val registryClass = Class.forName("androidx.test.platform.app.InstrumentationRegistry")
+        val instrumentationRefField = registryClass.getDeclaredField("instrumentationRef")
+        instrumentationRefField.isAccessible = true
+        @Suppress("UNCHECKED_CAST")
+        val instrumentationRef = instrumentationRefField.get(
+            null
+        ) as AtomicReference<Instrumentation>
+        instrumentationRef.get() != null
+      } catch (ignored: Throwable) {
+        false
+      }
+
+      if (runningInInstrumentationTests) {
+        CanaryLog.d("Instrumentation test detected, setting LeakCanary.Config.dumpHeap to false")
+        LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+      }
+    }
   }
 
   private fun addDynamicShortcut(application: Application) {
@@ -186,5 +217,5 @@ internal object InternalLeakCanary : LeakSentryListener {
     }
   }
 
-  const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
+  private const val LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump"
 }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
index e454652a..d6e750d7 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -57,7 +57,7 @@ internal fun View.shareToStackOverflow(content: String) {
   }
   Toast.makeText(context, R.string.leak_canary_leak_copied, Toast.LENGTH_LONG)
       .show()
-  val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(STACKOVERFLOW_QUESTION_URL));
+  val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(STACKOVERFLOW_QUESTION_URL))
   activity.startActivity(browserIntent)
 }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
index 673fdfec..fd83040f 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -1,5 +1,7 @@
 package leakcanary.internal.activity.screen
 
+import android.content.Intent
+import android.net.Uri
 import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
@@ -73,7 +75,12 @@ internal class LeakingInstanceScreen private constructor(
     listView.adapter = adapter
 
     listView.setOnItemClickListener { _, _, position, _ ->
-      adapter.toggleRow(position)
+      if (adapter.isLearnMoreRow(position)) {
+        val browserIntent = Intent(Intent.ACTION_VIEW, Uri.parse(LEARN_MORE_URL))
+        activity.startActivity(browserIntent)
+      } else {
+        adapter.toggleRow(position)
+      }
     }
 
     onCreateOptionsMenu { menu ->
@@ -96,4 +103,8 @@ internal class LeakingInstanceScreen private constructor(
           }
     }
   }
+  companion object {
+    private const val LEARN_MORE_URL =
+      "https://square.github.io/leakcanary/fundamentals/"
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
index 59a8ad34..1a9d412c 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/navigation/BackstackFrame.kt
@@ -15,7 +15,7 @@ internal class BackstackFrame : Parcelable {
   ) {
     this.screen = source.readSerializable() as Screen
     @Suppress("UNCHECKED_CAST")
-    this.viewState = source.readSparseArray(javaClass.classLoader) as SparseArray<Parcelable>?
+    this.viewState = source.readSparseArray<Parcelable>(javaClass.classLoader)
   }
 
   constructor(
diff --git a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
index 47782581..b5b1e2c9 100644
--- a/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values-de/leak_canary_strings.xml
@@ -72,24 +72,4 @@
   <string name="leak_canary_options_menu_render_heap_dump">Heap Dump rendern</string>
   <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d erhaltene Instanzen ohne Leaks</string>
   <string name="leak_canary_help_title">Tippe hier, um mehr zu erfahren</string>
-  <string name="leak_canary_help_detail"><![CDATA[Ein Memory-Leak ist ein Programmierfehler der
-    dafür sorgt, dass deine Anwendung eine Referenz auf ein Objekt hält, das nicht länger benötigt
-    wird. Daraus folgt, dass der Speicher der dem Objekt zugewiesen wurde nicht wieder freigegeben
-    wird, was eventuell zu einem OutOfMemoryError-Absturz führt.<br>
-  <br>Eine Instanz einer Android-Activity wird nicht mehr benötigt, nachdem ihre <i>onDestroy()</i>
-  Methode aufgerufen wurde. Würde man eine Referenz auf diese Activity in einem statischen Feld
-  speichern, dann wird der durch die Activity genutzte Speicher nicht mehr durch den Garbage
-  Collector freigegeben.<br>
-  <br>
-  LeakCanary identifiziert ein Objekt, das nicht länger benötigt wird und findet die Kette an
-  <font color=\'#9976a8\'>Referenzen</font> die es davon abhält seinen Speicher freizugeben.<br>
-  <br>
-  Um ein Memory-Leak zu beheben, musst du anhand der Kette herausfinden, welche Referenz für das
-  Leak verantwortlich ist, d.h. welche Referenz beim Auftreten des Leaks bereinigt sein soll.
-  LeakCanary hebt <b><u><font color=\'#9976a8\'>Referenzen</font></u></b> die mögliche Ursachen
-  für das Memory-Leak sein könnten mit einer roten Wellenlinie hervor.<br>
-  <br>
-  Tippe auf eine Zeile mit einer Referenz um mehr Details anzuzeigen, tippe noch einmal um die
-  Details zu schließen.
-]]></string>
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
index 85f0bcd3..d352338b 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_ids.xml
@@ -20,5 +20,5 @@
   <item type="id" name="leak_canary_notification_dumping_heap" />
   <item type="id" name="leak_canary_notification_analyzing_heap" />
   <item type="id" name="leak_canary_notification_retained_instances" />
-  <item type="id" name="leak_canary_notification_no_retained_instance" />
+  <item type="id" name="leak_canary_notification_no_retained_instance_on_tap" />
 </resources>
diff --git a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
index 6b6026cc..314fdf00 100644
--- a/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
+++ b/leakcanary-android-core/src/main/res/values/leak_canary_strings.xml
@@ -32,8 +32,8 @@
   <string name="leak_canary_notification_dumping">Dumping Heap</string>
   <string name="leak_canary_notification_foreground_text">LeakCanary is working.</string>
   <string name="leak_canary_notification_message">Click for more details</string>
-  <string name="leak_canary_notification_no_retained_instance_title">No retained instances</string>
-  <string name="leak_canary_notification_no_retained_instance_content">All instances cleared after LeakCanary ran GC</string>
+  <string name="leak_canary_notification_no_retained_instance_title">All retained instances were garbage collected</string>
+  <string name="leak_canary_notification_no_retained_instance_content">Tap to dismiss</string>
   <string name="leak_canary_notification_retained_debugger_attached">Waiting for debugger to detach</string>
   <string name="leak_canary_notification_retained_dump_failed">Failed to dump heap</string>
   <string name="leak_canary_notification_retained_title">%d retained instances, tap to dump heap</string>
@@ -84,22 +84,4 @@
   <string name="leak_canary_options_menu_render_heap_dump">Render Heap Dump</string>
   <string name="leak_canary_heap_analysis_success_screen_no_path_to_instance_count">%d non leaking retained instances</string>
   <string name="leak_canary_help_title">Tap here to learn more</string>
-  <string name="leak_canary_help_detail"><![CDATA[A memory leak is a programming error that causes
-  your application to keep a reference to an object that is no longer needed. As a result, the
-  memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError
-  crash.<br>
-  <br>For instance, an Android activity instance is no longer needed after its <i>onDestroy()</i>
-  method is called, and storing a reference to that activity in a static field would prevent it from
-  being garbage collected.<br>
-  <br>
-  LeakCanary identifies an object that is no longer needed and finds the chain of
-  <font color=\'#9976a8\'>references</font> that prevents it from being garbage collected.<br>
-  <br>
-  To fix a memory leak, you need to look at that chain and find which reference is causing the
-  leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights
-  with a red underline wave the <b><u><font color=\'#9976a8\'>references</font></u></b> that are the
-  possible causes of the leak.<br>
-  <br>
-  Tap on each reference row for more details, tap again to close.
-]]></string>
 </resources>
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 8d0921a1..3310522f 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -174,8 +174,8 @@ class InstrumentationLeakDetector {
 
     val heapAnalyzer = HeapAnalyzer(listener)
     val heapAnalysis = heapAnalyzer.checkForLeaks(
-        heapDumpFile, config.exclusionsFactory, config.computeRetainedHeapSize,
-        config.leakInspectors, config.labelers
+        heapDumpFile, AndroidKnownReference.mapToExclusions(config.knownReferences), config.computeRetainedHeapSize,
+        config.leakTraceInspectors
     )
 
     CanaryLog.d("Heap Analysis:\n%s", heapAnalysis)
@@ -191,7 +191,6 @@ class InstrumentationLeakDetector {
      * [FailTestOnLeakRunListener] when the tests start running.
      */
     fun updateConfig() {
-      LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
       LeakSentry.config = LeakSentry.config.copy(enabled = true)
     }
   }
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
index ee314480..b9608557 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
@@ -1,9 +1,5 @@
 package leakcanary
 
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
 import leakcanary.HeapValue.BooleanValue
 import leakcanary.HeapValue.ByteValue
 import leakcanary.HeapValue.CharValue
@@ -13,10 +9,6 @@ import leakcanary.HeapValue.IntValue
 import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
 
 class GraphHeapValue(
   private val graph: HprofGraph,
@@ -46,28 +38,31 @@ class GraphHeapValue(
   val asLong: Long?
     get() = if (actual is LongValue) actual.value else null
 
+  val asObjectIdReference: Long?
+    get() = if (actual is ObjectReference) actual.value else null
+
+  val asNonNullObjectIdReference: Long?
+    get() = if (actual is ObjectReference && !actual.isNull) actual.value else null
+
   val isNullReference: Boolean
     get() = actual is ObjectReference && actual.isNull
 
+  val isNonNullReference: Boolean
+    get() = actual is ObjectReference && !actual.isNull
+
   val referencesJavaString: Boolean
     get() = actual is ObjectReference && graph.referencesJavaString(actual)
 
   val referencesClass: Boolean
     get() = actual is ObjectReference && graph.referencesClass(actual)
 
-
   fun readAsJavaString(): String? {
     return readObjectRecord()?.asInstance?.readAsJavaString()
   }
 
   fun readObjectRecord(): GraphObjectRecord? {
     return if (actual is ObjectReference && !actual.isNull) {
-      return when (val objectRecord = graph.readObjectRecord(actual.value)) {
-        is ClassDumpRecord -> GraphClassRecord(graph, objectRecord)
-        is InstanceDumpRecord -> GraphInstanceRecord(graph, objectRecord)
-        is ObjectArrayDumpRecord -> GraphObjectArrayRecord(graph, objectRecord)
-        is PrimitiveArrayDumpRecord -> GraphPrimitiveArrayRecord(objectRecord)
-      }
+      return graph.readGraphObjectRecord(actual.value)
     } else {
       null
     }
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
index 482ab6f0..fde36349 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
@@ -50,6 +50,9 @@ sealed class GraphObjectRecord {
       return GraphClassRecord(graph, superClassRecord)
     }
 
+    fun readClassHierarchy(): Sequence<GraphClassRecord> =
+      generateSequence(this) { it.readSuperClass() }
+
     val staticFields
       get(): List<GraphField> {
         val fields = mutableListOf<GraphField>()
@@ -94,26 +97,15 @@ sealed class GraphObjectRecord {
     infix fun instanceOf(expectedClass: KClass<*>) =
       this instanceOf expectedClass.java.name
 
-    operator fun get(fieldName: String): GraphField? {
-      val fieldReader = graph.createFieldValuesReader(record)
-
-      var currentClassId = record.classId
-
-      do {
-        val classRecord = graph.readObjectRecord(currentClassId) as ClassDumpRecord
-
-        for (fieldRecord in classRecord.fields) {
-          val fieldValue = fieldReader.readValue(fieldRecord)
+    operator fun get(
+      className: String,
+      fieldName: String
+    ): GraphField? {
+      return readFields().firstOrNull { field -> field.classRecord.name == className && field.name == fieldName }
+    }
 
-          if (graph.fieldName(fieldRecord) == fieldName) {
-            return GraphField(
-                GraphClassRecord(graph, classRecord), fieldName, GraphHeapValue(graph, fieldValue)
-            )
-          }
-        }
-        currentClassId = classRecord.superClassId
-      } while (currentClassId != 0L)
-      return null
+    operator fun get(fieldName: String): GraphField? {
+      return readFields().firstOrNull { field -> field.name == fieldName }
     }
 
     val className: String
@@ -135,27 +127,20 @@ sealed class GraphObjectRecord {
       return GraphClassRecord(graph, classRecord)
     }
 
-    fun readFields(): List<List<GraphField>> {
-      val allFields = mutableListOf<List<GraphField>>()
-      val fieldReader = graph.createFieldValuesReader(record)
-
-      var currentClassId = record.classId
-      do {
-        val classFields = mutableListOf<GraphField>()
-        allFields += classFields
-
-        val classRecord = graph.readObjectRecord(currentClassId) as ClassDumpRecord
-
-        for (fieldRecord in classRecord.fields) {
-          val fieldName = graph.fieldName(fieldRecord)
-          val fieldValue = fieldReader.readValue(fieldRecord)
-          classFields += GraphField(
-              GraphClassRecord(graph, classRecord), fieldName, GraphHeapValue(graph, fieldValue)
-          )
-        }
-        currentClassId = classRecord.superClassId
-      } while (currentClassId != 0L)
-      return allFields
+    fun readFields(): Sequence<GraphField> {
+      val fieldReader by lazy {
+        graph.createFieldValuesReader(record)
+      }
+      return readClass().readClassHierarchy()
+          .map { classRecord ->
+            classRecord.record.fields.asSequence()
+                .map { fieldRecord ->
+                  val fieldName = graph.fieldName(fieldRecord)
+                  val fieldValue = fieldReader.readValue(fieldRecord)
+                  GraphField(classRecord, fieldName, GraphHeapValue(graph, fieldValue))
+                }
+          }
+          .flatten()
     }
 
     fun readAsJavaString(): String? {
@@ -195,6 +180,9 @@ sealed class GraphObjectRecord {
     private val graph: HprofGraph,
     override val record: ObjectArrayDumpRecord
   ) : GraphObjectRecord() {
+
+    val arrayClassName: String
+      get() = graph.className(record.arrayClassId)
   }
 
   class GraphPrimitiveArrayRecord(
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
index b55d3033..e3d4c523 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -1,6 +1,9 @@
 package leakcanary
 
 import leakcanary.GraphObjectRecord.GraphClassRecord
+import leakcanary.GraphObjectRecord.GraphInstanceRecord
+import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
+import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.ObjectIdMetadata.CLASS
 import leakcanary.ObjectIdMetadata.STRING
@@ -9,8 +12,21 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
 import okio.Buffer
 
+/**
+ * Enables navigation through the Hprof graph of objects.
+ */
 class HprofGraph(private val parser: HprofParser) {
 
   fun readClass(className: String): GraphClassRecord? {
@@ -26,6 +42,19 @@ class HprofGraph(private val parser: HprofParser) {
     return parser.retrieveRecordById(objectId)
   }
 
+  fun readGraphObjectRecord(objectId: Long): GraphObjectRecord {
+    return wrapObject(parser.retrieveRecordById(objectId))
+  }
+
+  private fun wrapObject(record: ObjectRecord): GraphObjectRecord {
+    return when (record) {
+      is ClassDumpRecord -> GraphClassRecord(this, record)
+      is InstanceDumpRecord -> GraphInstanceRecord(this, record)
+      is ObjectArrayDumpRecord -> GraphObjectArrayRecord(this, record)
+      is PrimitiveArrayDumpRecord -> GraphPrimitiveArrayRecord(record)
+    }
+  }
+
   fun className(classId: Long): String {
     return parser.className(classId)
   }
@@ -62,4 +91,32 @@ class HprofGraph(private val parser: HprofParser) {
   fun referencesClass(reference: ObjectReference): Boolean {
     return !reference.isNull && parser.objectIdMetadata(reference.value) == CLASS
   }
+
+  /**
+   * This API should eventually be removed.
+   */
+  fun objectIdMetadata(objectId: Long): ObjectIdMetadata = parser.objectIdMetadata(objectId)
+
+  fun computeShallowSize(record: ObjectRecord): Int {
+    return when (record) {
+      is InstanceDumpRecord -> {
+        val classRecord = readObjectRecord(record.classId) as ClassDumpRecord
+        // Note: instanceSize is the sum of shallow size through the class hierarchy
+        classRecord.instanceSize
+      }
+      is ObjectArrayDumpRecord -> record.elementIds.size * parser.idSize
+      is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
+      is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
+      is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
+      is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
+      is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
+      is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
+      is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
+      is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
+      else -> {
+        throw IllegalStateException("Unexpected record $record")
+      }
+    }
+  }
+
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
index 002326a6..05633e84 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -684,16 +684,6 @@ class HprofParser private constructor(
         ?.let { stringId -> classNames.getKey(stringId) }
   }
 
-  fun retrieveString(reference: ObjectReference): String {
-    return retrieveStringById(reference.value)
-  }
-
-  fun retrieveStringById(objectId: Long): String {
-    val instanceRecord = retrieveRecordById(objectId) as InstanceDumpRecord
-    val instance = hydrateInstance(instanceRecord)
-    return instanceAsString(instance)
-  }
-
   fun objectIdMetadata(objectId: Long): ObjectIdMetadata {
     val (metadata, _) = ObjectIdMetadata.unpackMetadataAndPosition(objectIndex[objectId])
     if (metadata == INTERNAL_MAYBE_EMPTY_INSTANCE) {
@@ -736,126 +726,6 @@ class HprofParser private constructor(
     return objectRecord
   }
 
-  /**
-   * Note: it's reasonable to call this repeatedly, there will be no disk reads as long as
-   * the classes are in the [objectCache] LruCache
-   */
-  fun hydrateClassHierarchy(classId: Long): List<HydratedClass> {
-    var currentClassId = classId
-    val classHierarchy = mutableListOf<HydratedClass>()
-    do {
-      val classRecord = retrieveRecordById(currentClassId) as ClassDumpRecord
-
-      val staticFieldNames = classRecord.staticFields.map {
-        hprofStringById(it.nameStringId)
-      }
-
-      val fieldNames = classRecord.fields.map {
-        hprofStringById(it.nameStringId)
-      }
-
-      val className = className(currentClassId)
-
-      classHierarchy.add(
-          HydratedClass(
-              classRecord, className, staticFieldNames, fieldNames
-          )
-      )
-      currentClassId = classRecord.superClassId
-    } while (currentClassId != 0L)
-    return classHierarchy
-  }
-
-  /**
-   * Note: it's reasonable to call this repeatedly, there will be no disk reads as long as
-   * the classes are in the [objectCache] LruCache
-   */
-  fun hydrateInstance(instanceRecord: InstanceDumpRecord): HydratedInstance {
-    val classHierarchy = hydrateClassHierarchy(instanceRecord.classId)
-
-    val buffer = Buffer()
-    buffer.write(instanceRecord.fieldValues)
-    val valuesReader = HprofReader(buffer, 0, reader.idSize)
-
-    val allFieldValues = classHierarchy.map { hydratedClass ->
-      hydratedClass.record.fields.map { field -> valuesReader.readValue(field.type) }
-    }
-
-    return HydratedInstance(instanceRecord, classHierarchy, allFieldValues)
-  }
-
-  fun instanceAsString(instance: HydratedInstance): String {
-    val count = instance["count"].int!!
-
-    if (count == 0) {
-      return ""
-    }
-
-    // Prior to API 26 String.value was a char array.
-    // Since API 26 String.value is backed by native code. The vast majority of strings in a
-    // heap dump are backed by a byte array, but we still find a few backed by a char array.
-    when (val valueRecord = instance["value"].reference!!.objectRecord) {
-      is CharArrayDump -> {
-        // < API 23
-        // As of Marshmallow, substrings no longer share their parent strings' char arrays
-        // eliminating the need for String.offset
-        // https://android-review.googlesource.com/#/c/83611/
-        val offset = instance["offset"].int ?: 0
-
-        val chars = valueRecord.array.copyOfRange(offset, offset + count)
-        return String(chars)
-      }
-      is ByteArrayDump -> {
-        return String(valueRecord.array, Charset.forName("UTF-8"))
-      }
-      else -> throw UnsupportedOperationException(
-          "'value' field was expected to be either a char or byte array in string instance with id ${instance.record.id}"
-      )
-    }
-  }
-
-  val Long.objectRecord: ObjectRecord get() = retrieveRecordById(this)
-
-  val ObjectRecord.hydratedInstance: HydratedInstance
-    get() = hydrateInstance(
-        this as InstanceDumpRecord
-    )
-
-  /**
-   * Returns true if [this] is an [InstanceDumpRecord] and its class name is [className].
-   * Note: this does not return true if this is an instance of a subclass of [className].
-   */
-  infix fun ObjectRecord.instanceOf(className: String): Boolean {
-    return this is InstanceDumpRecord && className(this.classId) == className
-  }
-
-  val Long.hydratedInstance: HydratedInstance
-    get() = hydrateInstance(
-        retrieveRecordById(this) as InstanceDumpRecord
-    )
-
-  val Long?.stringOrNull: String?
-    get() = if (this == null) {
-      null
-    } else {
-      val record = retrieveRecordById(this)
-      if (record is InstanceDumpRecord && objectIdMetadata(record.id) == STRING) {
-        val instance = hydrateInstance(record)
-        instanceAsString(instance)
-      } else {
-        null
-      }
-    }
-
-  fun ObjectRecord.isInstanceOf(expectedClass: KClass<out Any>) =
-    isInstanceOf(expectedClass.java.name)
-
-  fun ObjectRecord.isInstanceOf(className: String): Boolean {
-    return if (this is InstanceDumpRecord) {
-      hydrateClassHierarchy(this.classId).any { it.className == className }
-    } else false
-  }
-
   companion object {
     const val STRING_IN_UTF8 = 0x01
     const val LOAD_CLASS = 0x02
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
index bed81ad1..a8715ef2 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
+++ b/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
@@ -30,13 +30,12 @@ class HprofWriterTest {
 
     hprofFile.writeRecords(records)
 
-    hprofFile.readHprof {
-      val treasureChestClass = hydrateClassHierarchy(classId(TREASURE_CHEST_CLASS_NAME)!!)[0]
+    hprofFile.readHprof { graph ->
+      val treasureChestClass = graph.readClass(TREASURE_CHEST_CLASS_NAME)!!
       val baguetteInstance =
-        treasureChestClass[CONTENT_FIELD_NAME].reference!!.hydratedInstance
+        treasureChestClass[CONTENT_FIELD_NAME]!!.value.readObjectRecord()!!.asInstance!!
 
-      assertThat(baguetteInstance[ANSWER_FIELD_NAME].int)
-          .isEqualTo(42)
+      assertThat(baguetteInstance[ANSWER_FIELD_NAME]!!.value.asInt!!).isEqualTo(42)
     }
   }
 
@@ -115,11 +114,11 @@ class HprofWriterTest {
         }
   }
 
-  fun File.readHprof(block: HprofParser.() -> Unit) {
+  fun File.readHprof(block: (HprofGraph) -> Unit) {
     HprofParser.open(this)
         .use { parser ->
           parser.scan(RecordCallbacks())
-          parser.block()
+          block(HprofGraph(parser))
         }
   }
 
