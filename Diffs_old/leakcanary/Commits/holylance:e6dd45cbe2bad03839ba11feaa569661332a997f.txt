diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
index 8eebcbb2..5862b9f6 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Labeler.kt
@@ -9,8 +9,7 @@ import leakcanary.HeapValue.IntValue
 import leakcanary.HeapValue.LongValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HeapValue.ShortValue
-import leakcanary.ObjectIdMetadata.CLASS
-import leakcanary.ObjectIdMetadata.STRING
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
 
 typealias Labeler = (HprofParser, LeakNode) -> List<String>
@@ -26,46 +25,46 @@ class AllFieldsLabeler(
   override fun invoke(
     parser: HprofParser,
     node: LeakNode
-  ): List<String> {
+  ): List<String> = with(HprofGraph(parser)) {
     val labels = mutableListOf<String>()
 
-    val objectId = node.instance
-    val record = parser.retrieveRecordById(objectId)
+    val record = ObjectReference(node.instance).record
     if (record is InstanceDumpRecord) {
-      val instance = parser.hydrateInstance(record)
-      instance.classHierarchy.forEachIndexed { classIndex, hydratedClass ->
-        if (classIndex < instance.classHierarchy.lastIndex) {
-          labels.add("Class ${hydratedClass.className}")
-          if (labelStaticFields) {
-            hydratedClass.staticFieldNames.forEachIndexed { index, name ->
-              val valueString =
-                heapValueAsString(parser, hydratedClass.record.staticFields[index].value)
-              labels.add("  static $name=$valueString")
-            }
-          }
-          hydratedClass.fieldNames.forEachIndexed { index, name ->
-            val heapValue = instance.fieldValues[classIndex][index]
-            val valueString = heapValueAsString(parser, heapValue)
-            labels.add("  $name=$valueString")
+      var classRecord = record.classRecord
+
+      val allFields = record.fields
+
+      var classIndex = 0
+      while (classRecord.name != "java.lang.Object") {
+        val fields = allFields[classIndex]
+
+        labels.add("Class ${classRecord.name}")
+        if (labelStaticFields) {
+          classRecord.staticFieldNames.forEachIndexed { index, name ->
+            val valueString = heapValueAsString(classRecord.staticFields[index].value)
+            labels.add("  static $name=$valueString")
           }
         }
+
+        for ((name, value) in fields) {
+          labels.add("  $name=${heapValueAsString(value)}")
+        }
+        classIndex++
+        classRecord = classRecord.superClassRecord!!
       }
     }
     return labels
   }
 
-  private fun heapValueAsString(
-    parser: HprofParser,
-    heapValue: HeapValue
-  ): String {
+  private fun HprofGraph.heapValueAsString(heapValue: HeapValue): String {
     return when (heapValue) {
       is ObjectReference -> {
         if (heapValue.isNull) {
           "null"
         } else {
-          when (parser.objectIdMetadata(heapValue.value)) {
-            STRING -> "\"${parser.retrieveStringById(heapValue.value)}\""
-            CLASS -> parser.className(heapValue.value)
+          when {
+            heapValue.isString -> "\"${heapValue.record.string}\""
+            heapValue.isClass -> (heapValue.record as ClassDumpRecord).name
             else -> "@${heapValue.value}"
           }
         }
@@ -80,47 +79,46 @@ class AllFieldsLabeler(
       is LongValue -> heapValue.value.toString()
     }
   }
-
 }
 
 object InstanceDefaultLabeler : Labeler {
   override fun invoke(
     parser: HprofParser,
     node: LeakNode
-  ): List<String> = with(parser) {
-    val record = node.instance.objectRecord
+  ): List<String> = with(HprofGraph(parser)) {
+    val record = ObjectReference(node.instance).record
     if (record is InstanceDumpRecord) {
       val labels = mutableListOf<String>()
-      val instance = record.hydratedInstance
-      val className = instance.classHierarchy[0].className
-
-      if (instance.classHierarchy.any { it.className == Thread::class.java.name }) {
+      if (record instanceOf Thread::class) {
         // Sometimes we can't find the String at the expected memory address in the heap dump.
         // See https://github.com/square/leakcanary/issues/417
-        val threadName = instance["name"].reference.stringOrNull ?: "not available"
+        val threadName = record["name"].record.string ?: "not available"
         labels.add("Thread name: '$threadName'")
-      } else if (className.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
-        val parentClassName = instance.classHierarchy[1].className
-        if (parentClassName == "java.lang.Object") {
-          try {
-            // This is an anonymous class implementing an interface. The API does not give access
-            // to the interfaces implemented by the class. We check if it's in the class path and
-            // use that instead.
-            val actualClass = Class.forName(instance.classHierarchy[0].className)
-            val interfaces = actualClass.interfaces
-            labels.add(
-                if (interfaces.isNotEmpty()) {
-                  val implementedInterface = interfaces[0]
-                  "Anonymous class implementing ${implementedInterface.name}"
-                } else {
-                  "Anonymous subclass of java.lang.Object"
-                }
-            )
-          } catch (ignored: ClassNotFoundException) {
+      } else {
+        val classRecord = record.classRecord
+        if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
+          val parentClassRecord = classRecord.superClassRecord!!
+          if (parentClassRecord.name == "java.lang.Object") {
+            try {
+              // This is an anonymous class implementing an interface. The API does not give access
+              // to the interfaces implemented by the class. We check if it's in the class path and
+              // use that instead.
+              val actualClass = Class.forName(classRecord.name)
+              val interfaces = actualClass.interfaces
+              labels.add(
+                  if (interfaces.isNotEmpty()) {
+                    val implementedInterface = interfaces[0]
+                    "Anonymous class implementing ${implementedInterface.name}"
+                  } else {
+                    "Anonymous subclass of java.lang.Object"
+                  }
+              )
+            } catch (ignored: ClassNotFoundException) {
+            }
+          } else {
+            // Makes it easier to figure out which anonymous class we're looking at.
+            labels.add("Anonymous subclass of ${parentClassRecord.name}")
           }
-        } else {
-          // Makes it easier to figure out which anonymous class we're looking at.
-          labels.add("Anonymous subclass of $parentClassName")
         }
       }
       return labels
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt
index 6f7cf993..a8498481 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidLabelers.kt
@@ -14,20 +14,13 @@ enum class AndroidLabelers : Labeler {
     override fun invoke(
       parser: HprofParser,
       node: LeakNode
-    ): List<String> {
-      val objectId = node.instance
-      val record = parser.retrieveRecordById(objectId)
-      if (record is InstanceDumpRecord) {
-        val className = parser.className(record.classId)
-        if (className == "androidx.fragment.app.Fragment" || className == "android.app.Fragment") {
-          val instance = parser.hydrateInstance(record)
-          val mTagId = instance.fieldValueOrNull<HeapValue>("mTag")
-          if (mTagId is ObjectReference && !mTagId.isNull) {
-            val mTag = parser.retrieveString(mTagId)
-            if (mTag.isNotEmpty()) {
-              return listOf("Fragment.mTag=$mTag")
-            }
-          }
+    ): List<String> = with(HprofGraph(parser)) {
+      val record = ObjectReference(node.instance).record
+      if (record instanceOf "androidx.fragment.app.Fragment" || record instanceOf "android.app.Fragment") {
+        record as InstanceDumpRecord
+        val mTag = record["mTag"].record.string
+        if (!mTag.isNullOrEmpty()) {
+          return listOf("Fragment.mTag=$mTag")
         }
       }
       return emptyList()
@@ -40,46 +33,50 @@ enum class AndroidLabelers : Labeler {
     override fun invoke(
       parser: HprofParser,
       node: LeakNode
-    ): List<String> {
-      val objectId = node.instance
-      val record = parser.retrieveRecordById(objectId)
-      if (record is InstanceDumpRecord) {
-        val instance = parser.hydrateInstance(record)
-        if (instance.isInstanceOf(View::class.java.name)) {
-          val viewLabels = mutableListOf<String>()
+    ): List<String> = with(HprofGraph(parser)) {
+      val record = ObjectReference(node.instance).record
 
-          if (instance.hasField("mAttachInfo")) {
-            if (instance["mAttachInfo"].reference == null) {
-              viewLabels.add("View#mAttachInfo is null (view detached)")
-            } else {
-              viewLabels.add("View#mAttachInfo is not null (view attached)")
-            }
+      if (record instanceOf View::class) {
+        val viewLabels = mutableListOf<String>()
+        record as InstanceDumpRecord
+        val mAttachInfo = record["mAttachInfo"]
+        if (mAttachInfo != null) {
+          if (mAttachInfo.isNullReference) {
+            viewLabels.add("View#mAttachInfo is null (view detached)")
+          } else {
+            viewLabels.add("View#mAttachInfo is not null (view attached)")
           }
-          if (instance["mParent"].reference == null) {
+        }
+
+        val mParent = record["mParent"]
+        if (mParent != null) {
+          if (mParent.isNullReference) {
             viewLabels.add("View#mParent is null")
           } else {
             viewLabels.add("View#mParent is set")
           }
+        }
 
-          val mID = instance.fieldValueOrNull<HeapValue>("mID")
-          if (mID is IntValue) {
-            if (mID.value != 0) {
-              try {
-                val name = application.resources.getResourceEntryName(mID.value)
-                viewLabels.add("View.mID=R.id.$name (${mID.value})")
-              } catch (ignored: NotFoundException) {
-                viewLabels.add("View.mID=${mID.value} (name not found)")
-              }
-            } else {
-              viewLabels.add("View.mID=0")
+        val mID = record["mId"]
+        if (mID is IntValue) {
+          if (mID.value != 0) {
+            try {
+              val name = application.resources.getResourceEntryName(mID.value)
+              viewLabels.add("View.mID=R.id.$name (${mID.value})")
+            } catch (ignored: NotFoundException) {
+              viewLabels.add("View.mID=${mID.value} (name not found)")
             }
+          } else {
+            viewLabels.add("View.mID=0")
           }
-          val mWindowAttachCount = instance.fieldValueOrNull<HeapValue>("mWindowAttachCount")
-          if (mWindowAttachCount is IntValue) {
-            viewLabels.add("View.mWindowAttachCount=${mWindowAttachCount.value}")
-          }
-          return viewLabels
         }
+
+        val mWindowAttachCount = record["mWindowAttachCount"]
+
+        if (mWindowAttachCount is IntValue) {
+          viewLabels.add("View.mWindowAttachCount=${mWindowAttachCount.value}")
+        }
+        return viewLabels
       }
       return emptyList()
     }
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
new file mode 100644
index 00000000..d3c0ee79
--- /dev/null
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
@@ -0,0 +1,166 @@
+package leakcanary
+
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.ObjectIdMetadata.CLASS
+import leakcanary.ObjectIdMetadata.INSTANCE
+import leakcanary.ObjectIdMetadata.STRING
+import leakcanary.Record.HeapDumpRecord.ObjectRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import okio.Buffer
+import java.nio.charset.Charset
+import kotlin.reflect.KClass
+
+class HprofGraph(private val parser: HprofParser) {
+
+  val HeapValue?.record: ObjectRecord?
+    get() = if (this is ObjectReference && !isNull) {
+      parser.retrieveRecord(this)
+    } else
+      null
+
+  val ObjectReference.isString: Boolean
+    get() = if (value == 0L) false else parser.objectIdMetadata(value) == STRING
+
+  val ObjectReference.isClass: Boolean
+    get() = if (value == 0L) false else parser.objectIdMetadata(value) == CLASS
+
+  val ObjectReference.isInstance: Boolean
+    get() = if (value == 0L) false else parser.objectIdMetadata(value) == INSTANCE
+
+  infix fun ObjectRecord?.instanceOf(expectedClass: KClass<*>) =
+    this instanceOf expectedClass.java.name
+
+  infix fun ObjectRecord?.instanceOf(className: String): Boolean {
+    if (this !is InstanceDumpRecord) {
+      return false
+    }
+
+    var currentClassId = classId
+    while (currentClassId != 0L) {
+      val wut = parser.className(currentClassId)
+      CanaryLog.d("Found $wut looking for $className: ${wut == className}")
+      if (wut == className) {
+        return true
+      }
+      val currentClassRecord = parser.retrieveRecordById(currentClassId) as ClassDumpRecord
+      currentClassId = currentClassRecord.superClassId
+    }
+    return false
+  }
+
+  val ObjectRecord?.string: String?
+    get() {
+      if (this == null) {
+        return null
+      } else {
+        if (this is InstanceDumpRecord && parser.objectIdMetadata(id) == STRING) {
+          val count = this["count"].int!!
+
+          if (count == 0) {
+            return ""
+          }
+
+          // Prior to API 26 String.value was a char array.
+          // Since API 26 String.value is backed by native code. The vast majority of strings in a
+          // heap dump are backed by a byte array, but we still find a few backed by a char array.
+          when (val valueRecord = this["value"]?.record) {
+            is CharArrayDump -> {
+              // < API 23
+              // As of Marshmallow, substrings no longer share their parent strings' char arrays
+              // eliminating the need for String.offset
+              // https://android-review.googlesource.com/#/c/83611/
+              val offset = this["offset"].int ?: 0
+
+              val chars = valueRecord.array.copyOfRange(offset, offset + count)
+              return String(chars)
+            }
+            is ByteArrayDump -> {
+              return String(valueRecord.array, Charset.forName("UTF-8"))
+            }
+            else -> throw UnsupportedOperationException(
+                "'value' field ${this["value"]} was expected to be either a char or byte array in string instance with id $id"
+            )
+          }
+        } else {
+          return null
+        }
+      }
+    }
+
+  operator fun ObjectArrayDumpRecord.get(index: Int) = ObjectReference(elementIds[index])
+
+  val InstanceDumpRecord.classRecord
+    get() = parser.retrieveRecordById(classId) as ClassDumpRecord
+
+  val ClassDumpRecord.superClassRecord
+    get() = if (superClassId == 0L) null else
+      parser.retrieveRecordById(superClassId) as ClassDumpRecord
+
+  val ClassDumpRecord.name
+    get() = parser.className(id)
+
+  val ClassDumpRecord.staticFieldNames
+    get(): List<String> {
+      val fieldNames = mutableListOf<String>()
+      for (field in staticFields) {
+        fieldNames += parser.hprofStringById(field.nameStringId)
+      }
+      return fieldNames
+    }
+
+  operator fun InstanceDumpRecord.get(fieldName: String): HeapValue? {
+    val buffer = Buffer()
+    buffer.write(fieldValues)
+    val valuesReader = HprofReader(buffer, 0, parser.idSize)
+
+    var currentClassId = classId
+
+    do {
+      val classRecord = parser.retrieveRecordById(currentClassId) as ClassDumpRecord
+
+      for (fieldRecord in classRecord.fields) {
+        val fieldValue = valuesReader.readValue(fieldRecord.type)
+
+        if (parser.hprofStringById(fieldRecord.nameStringId) == fieldName) {
+          return fieldValue
+        }
+      }
+      currentClassId = classRecord.superClassId
+    } while (currentClassId != 0L)
+    return null
+  }
+
+  val InstanceDumpRecord.fields: List<Map<String, HeapValue>>
+    get() {
+      val allFields = mutableListOf<Map<String, HeapValue>>()
+      val buffer = Buffer()
+      buffer.write(fieldValues)
+      val valuesReader = HprofReader(buffer, 0, parser.idSize)
+
+      var currentClassId = classId
+
+      do {
+
+        val classFields = mutableMapOf<String, HeapValue>()
+        allFields += classFields
+
+        val classRecord = parser.retrieveRecordById(currentClassId) as ClassDumpRecord
+
+        for (fieldRecord in classRecord.fields) {
+          val fieldValue = valuesReader.readValue(fieldRecord.type)
+          classFields[parser.hprofStringById(fieldRecord.nameStringId)] = fieldValue
+        }
+        currentClassId = classRecord.superClassId
+      } while (currentClassId != 0L)
+      return allFields
+    }
+
+  infix fun ObjectRecord?.directInstanceOf(className: String): Boolean {
+    return this is InstanceDumpRecord && parser.className(classId) == className
+  }
+
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
index f866a126..f6a02ffa 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -846,7 +846,6 @@ class HprofParser private constructor(
         val instance = hydrateInstance(record)
         instanceAsString(instance)
       } else {
-        record as InstanceDumpRecord
         null
       }
     }
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/leakcanary-haha/src/main/java/leakcanary/Record.kt
index 9f1a420d..a5367788 100644
--- a/leakcanary-haha/src/main/java/leakcanary/Record.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/Record.kt
@@ -1,5 +1,7 @@
 package leakcanary
 
+import leakcanary.HeapValue.ObjectReference
+
 sealed class Record {
   class StringRecord(
     val id: Long,
