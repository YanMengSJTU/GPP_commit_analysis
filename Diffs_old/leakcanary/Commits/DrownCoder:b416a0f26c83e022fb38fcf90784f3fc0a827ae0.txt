diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
index efb7762e..d54716c8 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/ActivityRefWatcher.java
@@ -54,6 +54,7 @@ public static void install(Application application, RefWatcher refWatcher) {
         }
 
         @Override public void onActivityDestroyed(Activity activity) {
+            //onDestroy的时候回调
           ActivityRefWatcher.this.onActivityDestroyed(activity);
         }
       };
@@ -71,12 +72,14 @@ public ActivityRefWatcher(Application application, RefWatcher refWatcher) {
   }
 
   void onActivityDestroyed(Activity activity) {
+      //Activity在onDestroy的时候回调
     refWatcher.watch(activity);
   }
 
   public void watchActivities() {
     // Make sure you don't get installed twice.
     stopWatchingActivities();
+    //注册监听回调
     application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
   }
 
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
index 52fe7c4a..78563f40 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidRefWatcherBuilder.java
@@ -70,13 +70,18 @@ public AndroidRefWatcherBuilder maxStoredHeapDumps(int maxStoredHeapDumps) {
    * @throws UnsupportedOperationException if called more than once per Android process.
    */
   public RefWatcher buildAndInstall() {
+    //只能创建一次
     if (LeakCanaryInternals.installedRefWatcher != null) {
       throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
     }
+    //创建RefWatcher
     RefWatcher refWatcher = build();
     if (refWatcher != DISABLED) {
+
       LeakCanary.enableDisplayLeakActivity(context);
+      //默认为true
       if (watchActivities) {
+        //监听Activity的生命周期
         ActivityRefWatcher.install((Application) context, refWatcher);
       }
     }
@@ -106,6 +111,7 @@ public RefWatcher buildAndInstall() {
   }
 
   @Override protected WatchExecutor defaultWatchExecutor() {
+    //默认线程池
     return new AndroidWatchExecutor(DEFAULT_WATCH_DELAY_MILLIS);
   }
 }
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
index 585af091..ecabddd5 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidWatchExecutor.java
@@ -37,9 +37,12 @@
   private final long maxBackoffFactor;
 
   public AndroidWatchExecutor(long initialDelayMillis) {
+    //主线程Handler
     mainHandler = new Handler(Looper.getMainLooper());
+    //这里new了一个HandlerThread，内部封装好了looper.prepare()等操作
     HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
     handlerThread.start();
+    //handlerThread内部等handler
     backgroundHandler = new Handler(handlerThread.getLooper());
     this.initialDelayMillis = initialDelayMillis;
     maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;
diff --git a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
index 1ae3abd6..3395ac62 100644
--- a/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
+++ b/leakcanary-android/src/main/java/com/squareup/leakcanary/LeakCanary.java
@@ -38,6 +38,7 @@
    * references (on ICS+).
    */
   public static RefWatcher install(Application application) {
+    //创建RefWatcher
     return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
         .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
         .buildAndInstall();
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
index 8beade52..bc259a0e 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/GcTrigger.java
@@ -28,7 +28,9 @@
       // java/lang/ref/FinalizationTester.java
       // System.gc() does not garbage collect every time. Runtime.gc() is
       // more likely to perfom a gc.
+      //这里用的是Runtime.getRuntime().gc()
       Runtime.getRuntime().gc();
+      //等待100毫秒
       enqueueReferences();
       System.runFinalization();
     }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
index 8a01a472..255d9c34 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcher.java
@@ -37,13 +37,21 @@
 
   public static final RefWatcher DISABLED = new RefWatcherBuilder<>().build();
 
+  // 执行内存泄漏检测的 executor
   private final WatchExecutor watchExecutor;
+  // 调试中不会执行内存泄漏检测
   private final DebuggerControl debuggerControl;
+  // 用于在判断内存泄露之前，再给一次GC的机会
   private final GcTrigger gcTrigger;
+  // 内存泄漏的 heap
   private final HeapDumper heapDumper;
+  // 持有那些待检测以及产生内存泄露的引用的key
   private final Set<String> retainedKeys;
+  // 用于判断弱引用所持有的对象是否已被GC,如果被回收，会存在队列中，反之，没有存在队列中则泄漏了
   private final ReferenceQueue<Object> queue;
+  // 用于分析产生的heap文件
   private final HeapDump.Listener heapdumpListener;
+  // 排除一些系统的bug引起的内存泄漏
   private final ExcludedRefs excludedRefs;
 
   RefWatcher(WatchExecutor watchExecutor, DebuggerControl debuggerControl, GcTrigger gcTrigger,
@@ -80,12 +88,16 @@ public void watch(Object watchedReference, String referenceName) {
     }
     checkNotNull(watchedReference, "watchedReference");
     checkNotNull(referenceName, "referenceName");
+    //获得当前时间
     final long watchStartNanoTime = System.nanoTime();
+    //生成一个唯一的key
     String key = UUID.randomUUID().toString();
+    //保存这个key
     retainedKeys.add(key);
+    //将检查内存泄漏的对象保存为一个弱引用，注意queue
     final KeyedWeakReference reference =
         new KeyedWeakReference(watchedReference, key, referenceName, queue);
-
+    //异步开始分析这个弱引用
     ensureGoneAsync(watchStartNanoTime, reference);
   }
 
@@ -98,22 +110,27 @@ private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakRefer
   }
 
   @SuppressWarnings("ReferenceEquality") // Explicitly checking for named null.
+    // 避免因为gc不及时带来的误判，leakcanay会手动进行gc,进行二次确认进行保证
   Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
     long gcStartNanoTime = System.nanoTime();
     long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);
-
+    //第一次判断，移除此时已经被回收的对象
     removeWeaklyReachableReferences();
-
+    //调试的的时候是否开启内存泄漏判断，默认是false
     if (debuggerControl.isDebuggerAttached()) {
       // The debugger can create false leaks.
       return RETRY;
     }
+    //如果此时该对象已经不再retainedKeys中说明第一次判断时该对象已经被回收，不存在内存泄漏
     if (gone(reference)) {
       return DONE;
     }
+    //如果当前检测对象还没有被回收，则手动调用gc
     gcTrigger.runGc();
+    //再次做一次判断，移除被回收的对象
     removeWeaklyReachableReferences();
     if (!gone(reference)) {
+      //如果该对象仍然在retainedKey中，则说明内存泄漏了，进行分析
       long startDumpHeap = System.nanoTime();
       long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);
 
@@ -131,6 +148,7 @@ private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakRefer
   }
 
   private boolean gone(KeyedWeakReference reference) {
+    //retainedKeys不存在该对象的key
     return !retainedKeys.contains(reference.key);
   }
 
@@ -138,7 +156,9 @@ private void removeWeaklyReachableReferences() {
     // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
     // reachable. This is before finalization or garbage collection has actually happened.
     KeyedWeakReference ref;
+    //如果此时已经在queue中，说明已经被回收
     while ((ref = (KeyedWeakReference) queue.poll()) != null) {
+      //则从retainedKeys中移除
       retainedKeys.remove(ref.key);
     }
   }
diff --git a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
index b4c9eb33..ed91d534 100644
--- a/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
+++ b/leakcanary-watcher/src/main/java/com/squareup/leakcanary/RefWatcherBuilder.java
@@ -77,6 +77,7 @@ public final RefWatcher build() {
 
     WatchExecutor watchExecutor = this.watchExecutor;
     if (watchExecutor == null) {
+      //创建默认的监听内存泄漏的线程池
       watchExecutor = defaultWatchExecutor();
     }
 
