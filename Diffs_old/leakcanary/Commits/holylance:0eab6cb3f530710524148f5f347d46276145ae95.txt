diff --git a/shark-cli/src/main/java/shark/Main.kt b/shark-cli/src/main/java/shark/Main.kt
index 11a6868b..2fddb10d 100644
--- a/shark-cli/src/main/java/shark/Main.kt
+++ b/shark-cli/src/main/java/shark/Main.kt
@@ -8,14 +8,41 @@ import java.util.concurrent.TimeUnit.SECONDS
 
 fun main(args: Array<String>) {
   SharkLog.logger = CLILogger()
-  when {
-    args.size == 2 && args[0] == "analyze-process" -> {
-      val heapDumpFile = dumpHeap(args[1])
-      analyze(heapDumpFile)
+  when (args.size) {
+    2 -> {
+      when (args[0]) {
+        "analyze-process" -> {
+          val heapDumpFile = dumpHeap(args[1])
+          analyze(heapDumpFile)
+        }
+        "dump-process" -> dumpHeap(args[1])
+        "analyze-hprof" -> analyze(File(args[1]))
+        "strip-hprof" -> stripHprof(File(args[1]))
+        else -> printHelp()
+      }
+    }
+    4 -> {
+      val heapFile = when (args[0]) {
+        "analyze-process" -> {
+          dumpHeap(args[1])
+        }
+        "analyze-hprof" -> {
+          File(args[1])
+        }
+        else -> {
+          printHelp()
+          null
+        }
+      }
+
+      val mappingFile = if (args[2] == "-proguard-mapping") File(args[3]) else null
+
+      if (heapFile != null && mappingFile != null) {
+        analyze(heapFile, mappingFile)
+      } else {
+        printHelp()
+      }
     }
-    args.size == 2 && args[0] == "dump-process" -> dumpHeap(args[1])
-    args.size == 2 && args[0] == "analyze-hprof" -> analyze(File(args[1]))
-    args.size == 2 && args[0] == "strip-hprof" -> stripHprof(File(args[1]))
     else -> printHelp()
   }
 }
@@ -25,7 +52,7 @@ fun printHelp() {
 
   // ASCII art is a remix of a shark from -David "TAZ" Baltazar- and chick from jgs.
   SharkLog.d {
-      """
+    """
     Shark CLI, running in directory $workingDirectory
 
                      ^`.                 .=""=.
@@ -44,12 +71,14 @@ fun printHelp() {
 
     analyze-process: Dumps the heap for the provided process name, pulls the hprof file and analyzes it.
       USAGE: analyze-process PROCESS_PACKAGE_NAME
+             (optional) -proguard-mapping PROGUARD_MAPPING_FILE_PATH
 
     dump-process: Dumps the heap for the provided process name and pulls the hprof file.
       USAGE: dump-process PROCESS_PACKAGE_NAME
 
     analyze-hprof: Analyzes the provided hprof file.
       USAGE: analyze-hprof HPROF_FILE_PATH
+             (optional) -proguard-mapping PROGUARD_MAPPING_FILE_PATH
 
     strip-hprof: Replaces all primitive arrays from the provided hprof file with arrays of zeroes and generates a new "-stripped" hprof file.
       USAGE: strip-hprof HPROF_FILE_PATH
@@ -81,7 +110,7 @@ private fun dumpHeap(packageName: String): File {
       matchingExactly
     } else {
       SharkLog.d {
-          "More than one process matches \"$packageName\" but none matches exactly: ${matchingProcesses.map { it.first }}"
+        "More than one process matches \"$packageName\" but none matches exactly: ${matchingProcesses.map { it.first }}"
       }
       System.exit(1)
       throw RuntimeException("System exiting with error")
@@ -96,7 +125,7 @@ private fun dumpHeap(packageName: String): File {
   val heapDumpDevicePath = "/data/local/tmp/$heapDumpFileName"
 
   SharkLog.d {
-      "Dumping heap for process \"$processName\" with pid $processId to $heapDumpDevicePath"
+    "Dumping heap for process \"$processName\" with pid $processId to $heapDumpDevicePath"
   }
 
   runCommand(
@@ -136,16 +165,24 @@ private fun runCommand(
       .readText()
 }
 
-private fun analyze(heapDumpFile: File) {
+private fun analyze(
+  heapDumpFile: File,
+  proguardMappingFile: File? = null
+) {
   val listener = OnAnalysisProgressListener { step ->
     SharkLog.d { step.name }
   }
 
+  val proguardMapping = proguardMappingFile?.let {
+    ProguardMappingReader(it.inputStream()).readProguardMapping()
+  }
+
   val heapAnalyzer = HeapAnalyzer(listener)
   SharkLog.d { "Analyzing heap dump $heapDumpFile" }
   val heapAnalysis = heapAnalyzer.analyze(
       heapDumpFile, AndroidReferenceMatchers.appDefaults, true,
-      AndroidObjectInspectors.appDefaults
+      AndroidObjectInspectors.appDefaults,
+      proguardMapping = proguardMapping
   )
 
   SharkLog.d { heapAnalysis.toString() }
@@ -156,5 +193,4 @@ private fun stripHprof(heapDumpFile: File) {
   val stripper = HprofPrimitiveArrayStripper()
   val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
   SharkLog.d { "Stripped primitive arrays to $outputFile" }
-}
-
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapObject.kt b/shark-graph/src/main/java/shark/HeapObject.kt
index 82da8f33..e38c1931 100644
--- a/shark-graph/src/main/java/shark/HeapObject.kt
+++ b/shark-graph/src/main/java/shark/HeapObject.kt
@@ -196,7 +196,7 @@ sealed class HeapObject {
       return readRecord().staticFields.asSequence()
           .map { fieldRecord ->
             HeapField(
-                this, hprofGraph.staticFieldName(fieldRecord),
+                this, hprofGraph.staticFieldName(objectId, fieldRecord),
                 HeapValue(hprofGraph, fieldRecord.value)
             )
           }
@@ -213,9 +213,9 @@ sealed class HeapObject {
      */
     fun readStaticField(fieldName: String): HeapField? {
       for (fieldRecord in readRecord().staticFields) {
-        if (hprofGraph.staticFieldName(fieldRecord) == fieldName) {
+        if (hprofGraph.staticFieldName(objectId, fieldRecord) == fieldName) {
           return HeapField(
-              this, hprofGraph.staticFieldName(fieldRecord),
+              this, hprofGraph.staticFieldName(objectId, fieldRecord),
               HeapValue(hprofGraph, fieldRecord.value)
           )
         }
@@ -362,7 +362,7 @@ sealed class HeapObject {
             heapClass.readRecord()
                 .fields.asSequence()
                 .map { fieldRecord ->
-                  val fieldName = hprofGraph.fieldName(fieldRecord)
+                  val fieldName = hprofGraph.fieldName(heapClass.objectId, fieldRecord)
                   val fieldValue = fieldReader.readValue(fieldRecord)
                   HeapField(heapClass, fieldName, HeapValue(hprofGraph, fieldValue))
                 }
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index 978829de..f49d5168 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -89,12 +89,18 @@ class HprofHeapGraph internal constructor(
     return index.objectIdIsIndexed(objectId)
   }
 
-  internal fun fieldName(fieldRecord: FieldRecord): String {
-    return index.hprofStringById(fieldRecord.nameStringId)
+  internal fun fieldName(
+    classId: Long,
+    fieldRecord: FieldRecord
+  ): String {
+    return index.fieldName(classId, fieldRecord.nameStringId)
   }
 
-  internal fun staticFieldName(fieldRecord: StaticFieldRecord): String {
-    return index.hprofStringById(fieldRecord.nameStringId)
+  internal fun staticFieldName(
+    classId: Long,
+    fieldRecord: StaticFieldRecord
+  ): String {
+    return index.fieldName(classId, fieldRecord.nameStringId)
   }
 
   internal fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
@@ -184,8 +190,11 @@ class HprofHeapGraph internal constructor(
   }
 
   companion object {
-    fun indexHprof(hprof: Hprof): HeapGraph {
-      val index = HprofInMemoryIndex.createReadingHprof(hprof)
+    fun indexHprof(
+      hprof: Hprof,
+      proguardMapping: ProguardMapping? = null
+    ): HeapGraph {
+      val index = HprofInMemoryIndex.createReadingHprof(hprof, proguardMapping)
       return HprofHeapGraph(hprof, index)
     }
   }
diff --git a/shark-graph/src/main/java/shark/ProguardMapping.kt b/shark-graph/src/main/java/shark/ProguardMapping.kt
new file mode 100644
index 00000000..d25d6fbf
--- /dev/null
+++ b/shark-graph/src/main/java/shark/ProguardMapping.kt
@@ -0,0 +1,34 @@
+package shark
+
+class ProguardMapping {
+
+  // Classes can be simply stored as a obfuscatedName -> clearName
+  // For fields it's a bit more complicated since we need to know
+  // the class that a given field belongs to (two different classes
+  // can have a field with the same name). So files are stored as:
+  // obfuscatedClassName.obfuscatedFieldName -> clearFieldName
+  private val obfuscatedToClearNamesMap = linkedMapOf<String, String>()
+
+  /**
+   * Returns deobfuscated class name or original string if there is no
+   * mapping for given obfuscated name.
+   */
+  fun deobfuscateClassName(obfuscatedClassName: String): String {
+    return obfuscatedToClearNamesMap[obfuscatedClassName] ?: obfuscatedClassName
+  }
+
+  /**
+   * Returns deobfuscated field name or original string if there is no
+   * mapping for given obfuscated name.
+   */
+  fun deobfuscateFieldName(obfuscatedClass: String, obfuscatedField: String): String {
+    return obfuscatedToClearNamesMap["$obfuscatedClass.$obfuscatedField"] ?: return obfuscatedField
+  }
+
+  /**
+   * Adds entry to the obfuscatedToClearNamesMap map.
+   */
+  fun addMapping(obfuscatedName: String, clearName: String) {
+    obfuscatedToClearNamesMap[obfuscatedName] = clearName
+  }
+}
diff --git a/shark-graph/src/main/java/shark/ProguardMappingReader.kt b/shark-graph/src/main/java/shark/ProguardMappingReader.kt
new file mode 100644
index 00000000..cfc9bda3
--- /dev/null
+++ b/shark-graph/src/main/java/shark/ProguardMappingReader.kt
@@ -0,0 +1,89 @@
+package shark
+
+import java.io.FileNotFoundException
+import java.io.IOException
+import java.io.InputStream
+import java.text.ParseException
+
+class ProguardMappingReader(
+  private val proguardMappingInputStream: InputStream
+) {
+
+  @Throws(FileNotFoundException::class, IOException::class, ParseException::class)
+  fun readProguardMapping(): ProguardMapping {
+    val proguardMapping = ProguardMapping()
+    proguardMappingInputStream.bufferedReader(Charsets.UTF_8).use { bufferedReader ->
+
+      var currentClassName: String? = null
+      while (true) {
+        val line = bufferedReader.readLine()?.trim() ?: break
+
+        if (line.isEmpty() || line.startsWith(HASH_SYMBOL)) {
+          // empty line or comment
+          continue
+        }
+
+        if (line.endsWith(COLON_SYMBOL)) {
+          currentClassName = parseClassMapping(line, proguardMapping)
+        } else if (currentClassName != null) {
+          val isMethodMapping = line.contains(OPENING_PAREN_SYMBOL)
+          if (!isMethodMapping) {
+            parseClassField(line, currentClassName, proguardMapping)
+          }
+        }
+      }
+    }
+    return proguardMapping
+  }
+
+  // classes are stored as "clearName -> obfuscatedName:"
+  private fun parseClassMapping(line: String, proguardMapping: ProguardMapping): String? {
+    val arrowPosition = line.indexOf(ARROW_SYMBOL)
+    if (arrowPosition == -1) {
+      return null
+    }
+
+    val colonPosition = line.indexOf(COLON_SYMBOL, arrowPosition + ARROW_SYMBOL.length)
+    if (colonPosition == -1) {
+      return null
+    }
+
+    val clearClassName = line.substring(0, arrowPosition).trim()
+    val obfuscatedClassName =
+        line.substring(arrowPosition + ARROW_SYMBOL.length, colonPosition).trim()
+
+    proguardMapping.addMapping(obfuscatedClassName, clearClassName)
+
+    return obfuscatedClassName
+  }
+
+  // fields are stored as "typeName clearFieldName -> obfuscatedFieldName"
+  private fun parseClassField(
+    line: String,
+    currentClassName: String,
+    proguardMapping: ProguardMapping
+  ) {
+    val spacePosition = line.indexOf(SPACE_SYMBOL)
+    if (spacePosition == -1) {
+      return
+    }
+
+    val arrowPosition = line.indexOf(ARROW_SYMBOL, spacePosition + SPACE_SYMBOL.length)
+    if (arrowPosition == -1) {
+      return
+    }
+
+    val clearFieldName = line.substring(spacePosition + SPACE_SYMBOL.length, arrowPosition).trim()
+    val obfuscatedFieldName = line.substring(arrowPosition + ARROW_SYMBOL.length).trim()
+
+    proguardMapping.addMapping("$currentClassName.$obfuscatedFieldName", clearFieldName)
+  }
+
+  companion object {
+    private const val HASH_SYMBOL = "#"
+    private const val ARROW_SYMBOL = "->"
+    private const val COLON_SYMBOL = ":"
+    private const val SPACE_SYMBOL = " "
+    private const val OPENING_PAREN_SYMBOL = "("
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index fdcc0c87..ce3665f7 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -21,6 +21,7 @@ import shark.HprofRecord.LoadClassRecord
 import shark.HprofRecord.StringRecord
 import shark.OnHprofRecordListener
 import shark.PrimitiveType
+import shark.ProguardMapping
 import shark.ValueHolder
 import shark.internal.IndexedObject.IndexedClass
 import shark.internal.IndexedObject.IndexedInstance
@@ -43,18 +44,29 @@ internal class HprofInMemoryIndex private constructor(
   private val objectArrayIndex: SortedBytesMap,
   private val primitiveArrayIndex: SortedBytesMap,
   private val gcRoots: List<GcRoot>,
+  private val proguardMapping: ProguardMapping?,
   val primitiveWrapperTypes: Set<Long>
 ) {
 
-  fun hprofStringById(id: Long): String {
-    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
+  fun fieldName(
+    classId: Long,
+    id: Long
+  ): String {
+    val fieldNameString = hprofStringById(id)
+    return proguardMapping?.let {
+      val classNameStringId =
+        classNames[classId] ?: throw IllegalArgumentException("Unknown class id $classId")
+      val classNameString = hprofStringById(classNameStringId)
+      proguardMapping.deobfuscateFieldName(classNameString, fieldNameString)
+    } ?: fieldNameString
   }
 
   fun className(classId: Long): String {
     // String, primitive types
     val classNameStringId =
       classNames[classId] ?: throw IllegalArgumentException("Unknown class id $classId")
-    return hprofStringById(classNameStringId)
+    val classNameString = hprofStringById(classNameStringId)
+    return proguardMapping?.deobfuscateClassName(classNameString) ?: classNameString
   }
 
   fun classId(className: String): Long? {
@@ -190,6 +202,10 @@ internal class HprofInMemoryIndex private constructor(
     return false
   }
 
+  private fun hprofStringById(id: Long): String {
+    return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
+  }
+
   private class Builder(
     longIdentifiers: Boolean,
     fileLength: Long,
@@ -309,7 +325,9 @@ internal class HprofInMemoryIndex private constructor(
       }
     }
 
-    fun buildIndex(): HprofInMemoryIndex {
+    fun buildIndex(
+      proguardMapping: ProguardMapping?
+    ): HprofInMemoryIndex {
       val sortedInstanceIndex = instanceIndex.moveToSortedMap()
       val sortedObjectArrayIndex = objectArrayIndex.moveToSortedMap()
       val sortedPrimitiveArrayIndex = primitiveArrayIndex.moveToSortedMap()
@@ -320,6 +338,7 @@ internal class HprofInMemoryIndex private constructor(
           hprofStringCache, classNames, sortedClassIndex, sortedInstanceIndex,
           sortedObjectArrayIndex,
           sortedPrimitiveArrayIndex, gcRoots,
+          proguardMapping,
           primitiveWrapperTypes
       )
     }
@@ -346,6 +365,7 @@ internal class HprofInMemoryIndex private constructor(
 
     fun createReadingHprof(
       hprof: Hprof,
+      proguardMapping: ProguardMapping?,
       indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
           JniGlobal::class,
           JavaFrame::class,
@@ -413,7 +433,7 @@ internal class HprofInMemoryIndex private constructor(
 
       reader.readHprofRecords(recordTypes, indexBuilderListener)
 
-      return indexBuilderListener.buildIndex()
+      return indexBuilderListener.buildIndex(proguardMapping)
     }
 
   }
diff --git a/shark-graph/src/test/java/shark/ProguardMappingTest.kt b/shark-graph/src/test/java/shark/ProguardMappingTest.kt
new file mode 100644
index 00000000..c664b67f
--- /dev/null
+++ b/shark-graph/src/test/java/shark/ProguardMappingTest.kt
@@ -0,0 +1,44 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class ProguardMappingTest {
+
+  @Test
+  fun readAndParseMappingFile() {
+    val proguardMappingText = """
+            # comment
+            com.test.ClearClassName1 -> com.test.ObfuscatedClassName1:
+                com.test.FieldType1 clearFieldName1 -> obfuscatedFieldName1
+            com.test.ClearClassName2 -> com.test.ObfuscatedClassName2:
+                com.test.FieldType2 clearFieldName2 -> obfuscatedFieldName2
+        """.trimIndent()
+
+    val proguardMapping =
+        ProguardMappingReader(proguardMappingText.byteInputStream(Charsets.UTF_8))
+            .readProguardMapping()
+
+    assertThat(
+        proguardMapping.deobfuscateClassName("com.test.ObfuscatedClassName1")
+    ).isEqualTo("com.test.ClearClassName1")
+
+    assertThat(
+        proguardMapping.deobfuscateFieldName(
+            "com.test.ObfuscatedClassName1",
+            "obfuscatedFieldName1"
+        )
+    ).isEqualTo("clearFieldName1")
+
+    assertThat(
+        proguardMapping.deobfuscateClassName("com.test.ObfuscatedClassName2")
+    ).isEqualTo("com.test.ClearClassName2")
+
+    assertThat(
+        proguardMapping.deobfuscateFieldName(
+            "com.test.ObfuscatedClassName2",
+            "obfuscatedFieldName2"
+        )
+    ).isEqualTo("clearFieldName2")
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index fa39344a..bfeb6bde 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -81,7 +81,8 @@ class HeapAnalyzer constructor(
     referenceMatchers: List<ReferenceMatcher> = emptyList(),
     computeRetainedHeapSize: Boolean = false,
     objectInspectors: List<ObjectInspector> = emptyList(),
-    leakFinders: List<ObjectInspector> = objectInspectors
+    leakFinders: List<ObjectInspector> = objectInspectors,
+    proguardMapping: ProguardMapping? = null
   ): HeapAnalysis {
     val analysisStartNanoTime = System.nanoTime()
 
@@ -98,7 +99,7 @@ class HeapAnalyzer constructor(
       listener.onAnalysisProgress(PARSING_HEAP_DUMP)
       Hprof.open(heapDumpFile)
           .use { hprof ->
-            val graph = HprofHeapGraph.indexHprof(hprof)
+            val graph = HprofHeapGraph.indexHprof(hprof, proguardMapping)
 
             val findLeakInput = FindLeakInput(
                 graph, leakFinders, referenceMatchers, computeRetainedHeapSize, objectInspectors
diff --git a/shark/src/test/java/shark/LeakTraceRendererTest.kt b/shark/src/test/java/shark/LeakTraceRendererTest.kt
index 9f60e6bf..a946699b 100644
--- a/shark/src/test/java/shark/LeakTraceRendererTest.kt
+++ b/shark/src/test/java/shark/LeakTraceRendererTest.kt
@@ -5,7 +5,6 @@ import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
-import shark.LibraryLeakReferenceMatcher
 import shark.ReferencePattern.InstanceFieldPattern
 import shark.internal.renderToString
 import java.io.File
@@ -45,6 +44,39 @@ class LeakTraceRendererTest {
     """
   }
 
+  @Test fun rendersDeobfuscatedSimplePath() {
+    hprofFile.dump {
+      "a" clazz {
+        staticField["b.c"] = "Leaking" watchedInstance {}
+      }
+    }
+
+    val proguardMappingText = """
+            GcRoot -> a:
+                type leak -> b.c
+        """.trimIndent()
+
+    val reader = ProguardMappingReader(proguardMappingText.byteInputStream(Charsets.UTF_8))
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
+        proguardMapping = reader.readProguardMapping()
+    )
+
+    analysis renders """
+    ┬
+    ├─ GcRoot
+    │    Leaking: UNKNOWN
+    │    GC Root: System class
+    │    ↓ static GcRoot.leak
+    │                    ~~~~
+    ╰→ Leaking
+    ​     Leaking: YES (ObjectWatcher was watching this)
+    ​     key = 39efcc1a-67bf-2040-e7ab-3fc9f94731dc
+    ​     watchDurationMillis = 25000
+    ​     retainedDurationMillis = 10000
+    """
+  }
+
   @Test fun rendersLeakingWithReason() {
     hprofFile.dump {
       "GcRoot" clazz {
@@ -206,12 +238,14 @@ class LeakTraceRendererTest {
   }
 
   private infix fun HeapAnalysisSuccess.renders(expectedString: String) {
-    assertThat(applicationLeaks[0].leakTrace.renderToString()).isEqualTo(expectedString.trimIndent()
+    assertThat(applicationLeaks[0].leakTrace.renderToString()).isEqualTo(
+        expectedString.trimIndent()
     )
   }
 
   private infix fun HeapAnalysisSuccess.rendersLibraryLeak(expectedString: String) {
-    assertThat(libraryLeaks[0].leakTrace.renderToString()).isEqualTo(expectedString.trimIndent()
+    assertThat(libraryLeaks[0].leakTrace.renderToString()).isEqualTo(
+        expectedString.trimIndent()
     )
   }
 }
\ No newline at end of file
diff --git a/shark/src/test/java/shark/TestUtil.kt b/shark/src/test/java/shark/TestUtil.kt
index 60f9bccb..a55b5df5 100644
--- a/shark/src/test/java/shark/TestUtil.kt
+++ b/shark/src/test/java/shark/TestUtil.kt
@@ -11,7 +11,8 @@ import java.lang.ref.WeakReference
 fun <T : HeapAnalysis> File.checkForLeaks(
   objectInspectors: List<ObjectInspector> = emptyList(),
   computeRetainedHeapSize: Boolean = false,
-  referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers
+  referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers,
+  proguardMapping: ProguardMapping? = null
 ): T {
   val inspectors = if (ObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
     objectInspectors + ObjectInspectors.KEYED_WEAK_REFERENCE
@@ -20,7 +21,11 @@ fun <T : HeapAnalysis> File.checkForLeaks(
   }
   val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
   val result = heapAnalyzer.analyze(
-      this, referenceMatchers, computeRetainedHeapSize, inspectors
+      this,
+      referenceMatchers,
+      computeRetainedHeapSize,
+      inspectors,
+      proguardMapping = proguardMapping
   )
   if (result is HeapAnalysisFailure) {
     println(result)
