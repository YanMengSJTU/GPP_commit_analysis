diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 338b931b..7b4fb258 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -5,12 +5,4 @@ forking the repository and sending a pull request.
 
 When submitting code, please make every effort to follow existing conventions
 and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `./gradlew clean build`. Checkstyle failures
-during compilation indicate errors in your style and can be viewed in files
-located at `*/build/report/checkstyle` directories.
-
-Before your code can be accepted into the project you must also sign the
-[Individual Contributor License Agreement (CLA)][1].
-
-
- [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
\ No newline at end of file
+sure your code compiles by running `./gradlew build`.
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
deleted file mode 100644
index 604954df..00000000
--- a/.github/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,32 +0,0 @@
-Welcome and thank you for reporting an issue!
-
-First:
-
-- Confirm that you are using the latest version of LeakCanary (see https://github.com/square/leakcanary/blob/master/CHANGELOG.md)
-- Verify that your issue hasn't already been reported by searching over all issues: https://github.com/square/leakcanary/issues?q=is%3Aissue.
-
-What kind of issue is this?
-
- - *Question*: This issue tracker is not the place for questions. If you want to ask how to do
-   something, or to understand why something isn't working the way you expect it to, use Stack
-   Overflow: https://stackoverflow.com/questions/tagged/leakcanary.
-
- - *Help me fix a leak?*: Please do not file an issue.
-   Instead, read here: https://github.com/square/leakcanary/#how-do-i-fix-a-memory-leak
- 
- - *Leak analysis failed*: if it's an OutOfMemoryError, no need to report it. See https://github.com/square/leakcanary/wiki/Future#low-memory-leak-analysis
-
- - *Bug report*: If you’ve found a bug, spend the time to write a failing test. Bugs with tests get fixed.
-   Here’s an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
-   
- - *Feature Request*: Start by telling us what problem you’re trying to solve. Don’t send pull requests to implement
-   new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
-
-^^^^^ DELETE FROM THIS LINE UP ^^^^^
-
-
-```
-
-{REPLACE THIS LINE WITH YOUR STACKTRACE OR OUTPUT FROM LEAKCANARY}
-
-```
diff --git a/CODE_OF_CONDUCT.md b/CODE_OF_CONDUCT.md
new file mode 100644
index 00000000..a2e9a460
--- /dev/null
+++ b/CODE_OF_CONDUCT.md
@@ -0,0 +1,76 @@
+# Contributor Covenant Code of Conduct
+
+## Our Pledge
+
+In the interest of fostering an open and welcoming environment, we as
+contributors and maintainers pledge to making participation in our project and
+our community a harassment-free experience for everyone, regardless of age, body
+size, disability, ethnicity, sex characteristics, gender identity and expression,
+level of experience, education, socio-economic status, nationality, personal
+appearance, race, religion, or sexual identity and orientation.
+
+## Our Standards
+
+Examples of behavior that contributes to creating a positive environment
+include:
+
+* Using welcoming and inclusive language
+* Being respectful of differing viewpoints and experiences
+* Gracefully accepting constructive criticism
+* Focusing on what is best for the community
+* Showing empathy towards other community members
+
+Examples of unacceptable behavior by participants include:
+
+* The use of sexualized language or imagery and unwelcome sexual attention or
+ advances
+* Trolling, insulting/derogatory comments, and personal or political attacks
+* Public or private harassment
+* Publishing others' private information, such as a physical or electronic
+ address, without explicit permission
+* Other conduct which could reasonably be considered inappropriate in a
+ professional setting
+
+## Our Responsibilities
+
+Project maintainers are responsible for clarifying the standards of acceptable
+behavior and are expected to take appropriate and fair corrective action in
+response to any instances of unacceptable behavior.
+
+Project maintainers have the right and responsibility to remove, edit, or
+reject comments, commits, code, wiki edits, issues, and other contributions
+that are not aligned to this Code of Conduct, or to ban temporarily or
+permanently any contributor for other behaviors that they deem inappropriate,
+threatening, offensive, or harmful.
+
+## Scope
+
+This Code of Conduct applies both within project spaces and in public spaces
+when an individual is representing the project or its community. Examples of
+representing a project or community include using an official project e-mail
+address, posting via an official social media account, or acting as an appointed
+representative at an online or offline event. Representation of a project may be
+further defined and clarified by project maintainers.
+
+## Enforcement
+
+Instances of abusive, harassing, or otherwise unacceptable behavior may be
+reported by contacting the project team at py.ricau+leakcanary-coc@gmail.com. All
+complaints will be reviewed and investigated and will result in a response that
+is deemed necessary and appropriate to the circumstances. The project team is
+obligated to maintain confidentiality with regard to the reporter of an incident.
+Further details of specific enforcement policies may be posted separately.
+
+Project maintainers who do not follow or enforce the Code of Conduct in good
+faith may face temporary or permanent repercussions as determined by other
+members of the project's leadership.
+
+## Attribution
+
+This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
+available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html
+
+[homepage]: https://www.contributor-covenant.org
+
+For answers to common questions about this code of conduct, see
+https://www.contributor-covenant.org/faq
diff --git a/README.md b/README.md
index f6f53dfb..31c48a74 100644
--- a/README.md
+++ b/README.md
@@ -21,10 +21,11 @@ dependencies {
 **That's it, there is no code change needed!** LeakCanary will automatically show a notification when a memory leak is detected in debug builds.
 
 What's next?
-* Read the [Fundamentals](#Fundamentals)
-* Watch recorded [presentations](#Presentations)
-* Try LeakCanary code [recipes](#Recipes)
-* Read the [FAQ](#FAQ)
+* Learn the [Fundamentals](#fundamentals)
+* Try the [code recipes](#code-recipes)
+* Read the [FAQ](#faq)
+* Watch recorded [presentations](#presentations)
+* Read [articles](#articles)
 
 
 Note: **LeakCanary 2 is in alpha**.
@@ -60,13 +61,7 @@ To fix a memory leak, you need to look at the sub chain of possible leak causes
 
 If you cannot figure out a leak, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) using the *leakcanary* tag.
 
-## Presentations
-
-* [LeakCanary 2: Leaner, Better, Faster, Kotliner!](https://www.youtube.com/watch?v=LEX8dn4BLUw)
-* [LeakCanary, then what? Nuking Nasty Memory Leaks](https://www.youtube.com/watch?v=fhE--eTEW84)
-* [Memory Leak Hunt](https://www.youtube.com/watch?v=KwArTJHLq5g), a live investigation.
-
-## Recipes
+## Code Recipes
 
 If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new). Your feedback help us make LeakCanary better for the entire community.
 
@@ -275,6 +270,18 @@ The name **LeakCanary** is a reference to the expression [canary in a coal mine]
 <img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
 </p>
 
+## Presentations
+
+* [LeakCanary 2: Leaner, Better, Faster, Kotliner!](https://www.youtube.com/watch?v=LEX8dn4BLUw)
+* [LeakCanary, then what? Nuking Nasty Memory Leaks](https://www.youtube.com/watch?v=fhE--eTEW84)
+* [Memory Leak Hunt](https://www.youtube.com/watch?v=KwArTJHLq5g), a live investigation.
+
+Your presentation should be here, please update this list! Any technical level welcome.
+
+## Articles
+
+Your article should be here, please update this list! Any technical level welcome.
+
 ## License
 
     Copyright 2015 Square, Inc.
diff --git a/SUPPORT.md b/SUPPORT.md
new file mode 100644
index 00000000..e01f73d8
--- /dev/null
+++ b/SUPPORT.md
@@ -0,0 +1,12 @@
+# LeakCanary Support
+
+If you're looking for support for LeakCanary:
+
+* Learn the [Fundamentals](#fundamentals)
+* Try the [code recipes](#code-recipes)
+* Read the [FAQ](#faq)
+* Watch recorded [presentations](#presentations)
+* Read [articles](#articles)
+* Check out the StackOverflow [LeakCanary tag](http://stackoverflow.com/questions/tagged/leakcanary) and ask a question
+
+Feel free to edit this file to add links to online communities that can help developers investigate LeakCanary leaks.
diff --git a/build.gradle b/build.gradle
index 9f94ef10..ed183988 100644
--- a/build.gradle
+++ b/build.gradle
@@ -25,7 +25,6 @@ buildscript {
           ],
           benchmark : 'androidx.benchmark:benchmark:1.0.0-alpha01'
       ],
-      haha          : 'com.squareup.haha:haha:2.1',
       junit         : 'junit:junit:4.12',
       kotlin        : [
           gradlePlugin: "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}",
diff --git a/leakcanary-analyzer-perflib/build.gradle b/leakcanary-analyzer-perflib/build.gradle
deleted file mode 100644
index 10e229c9..00000000
--- a/leakcanary-analyzer-perflib/build.gradle
+++ /dev/null
@@ -1,20 +0,0 @@
-apply plugin: 'java-library'
-apply plugin: 'kotlin'
-
-sourceCompatibility = JavaVersion.VERSION_1_7
-targetCompatibility = JavaVersion.VERSION_1_7
-
-dependencies {
-  api project(':leakcanary-analyzer')
-  api project(':leakcanary-haha')
-
-  implementation deps.androidx.annotation
-  implementation deps.haha
-  implementation deps.kotlin.stdlib
-
-  testImplementation deps.assertj_core
-  testImplementation deps.junit
-}
-
-apply from: rootProject.file('gradle/checkstyle.gradle')
-apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/gradle.properties b/leakcanary-analyzer-perflib/gradle.properties
deleted file mode 100644
index 441c3190..00000000
--- a/leakcanary-analyzer-perflib/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-perflib-analyzer
-POM_NAME=LeakCanary Perflib Analyzer
-POM_PACKAGING=jar
diff --git a/leakcanary-analyzer-perflib/src/main/java/com/squareup/haha/perflib/HahaSpy.kt b/leakcanary-analyzer-perflib/src/main/java/com/squareup/haha/perflib/HahaSpy.kt
deleted file mode 100644
index 78b1f134..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/com/squareup/haha/perflib/HahaSpy.kt
+++ /dev/null
@@ -1,8 +0,0 @@
-package com.squareup.haha.perflib
-
-internal fun Instance.allocatingThread(): Instance {
-  val snapshot = mHeap.mSnapshot
-  val threadSerialNumber = if (this is RootObj) mThread else mStack.mThreadSerialNumber
-  val thread = snapshot.getThread(threadSerialNumber)
-  return snapshot.findInstance(thread.mId)
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibAnalysisResult.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibAnalysisResult.kt
deleted file mode 100644
index cf15b0cd..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibAnalysisResult.kt
+++ /dev/null
@@ -1,179 +0,0 @@
-package leakcanary
-
-import java.io.Serializable
-import java.util.UUID
-
-/**
- * Used only for tests. We should delete this and move the stacktrace feature
- * (once we have grouping)
- */
-data class PerflibAnalysisResult(
-
-  /**
-   * Key associated to the [leaksentry.KeyedWeakReference] used to detect the memory leak.
-   * When analyzing a heap dump, search for all [leaksentry.KeyedWeakReference] instances, then open
-   * the one that has its "key" field set to this value. Its "referent" field contains the
-   * leaking object. Computing the shortest path to GC roots on that leaking object should enable
-   * you to figure out the cause of the leak.
-   */
-  val referenceKey: String,
-
-  /**
-   * User defined name to help identify the leaking instance.
-   */
-  val referenceName: String,
-
-  /** True if a leak was found in the heap dump.  */
-  val leakFound: Boolean,
-  /**
-   * True if [.leakFound] is true and the only path to the leaking reference is
-   * through excluded references. Usually, that means you can safely ignore this report.
-   */
-  val excludedLeak: Boolean,
-  /**
-   * Class name of the object that leaked, null if [.failure] is not null.
-   * The class name format is the same as what would be returned by [Class.getName].
-   */
-  val className: String?,
-  /**
-   * Shortest path to GC roots for the leaking object if [.leakFound] is true, null
-   * otherwise. This can be used as a unique signature for the leak.
-   */
-  val leakTrace: LeakTrace? = null,
-  /** Null unless the analysis failed.  */
-  val failure: Throwable? = null,
-  /**
-   * The number of bytes which would be freed if all references to the leaking object were
-   * released. [.RETAINED_HEAP_SKIPPED] if the retained heap size was not computed. 0 if
-   * [.leakFound] is false.
-   */
-  val retainedHeapSize: Long,
-  /** Total time spent analyzing the heap.  */
-  val analysisDurationMs: Long,
-
-  /** Time from the request to watch the reference until the GC was triggered.  */
-  val watchDurationMs: Long
-
-) : Serializable {
-
-  /**
-   * <p>Creates a new {@link RuntimeException} with a fake stack trace that maps the leak trace.
-   *
-   * <p>Leak traces uniquely identify memory leaks, much like stack traces uniquely identify
-   * exceptions.
-   *
-   * <p>This method enables you to upload leak traces as stack traces to your preferred
-   * exception reporting tool and benefit from the grouping and counting these tools provide out
-   * of the box. This also means you can track all leaks instead of relying on individuals
-   * reporting them when they happen.
-   *
-   * <p>The following example leak trace:
-   * <pre>
-   * * com.foo.WibbleActivity has leaked:
-   * * GC ROOT static com.foo.Bar.qux
-   * * references com.foo.Quz.context
-   * * leaks com.foo.WibbleActivity instance
-   * </pre>
-   *
-   * <p>Will turn into an exception with the following stacktrace:
-   * <pre>
-   * java.lang.RuntimeException: com.foo.WibbleActivity leak from com.foo.Bar (holder=CLASS,
-   * type=STATIC_FIELD)
-   *         at com.foo.Bar.qux(Bar.java:42)
-   *         at com.foo.Quz.context(Quz.java:42)
-   *         at com.foo.WibbleActivity.leaking(WibbleActivity.java:42)
-   * </pre>
-   */
-  fun leakTraceAsFakeException(): RuntimeException {
-    if (!leakFound) {
-      throw UnsupportedOperationException(
-          "leakTraceAsFakeException() can only be called when leakFound is true"
-      )
-    }
-    val firstElement = leakTrace!!.elements[0]
-    val rootSimpleName = classSimpleName(firstElement.className)
-    val leakSimpleName = classSimpleName(className!!)
-
-    val runtimeException = RuntimeException(
-        "$leakSimpleName leak from $rootSimpleName (holder=${firstElement.holder}, type= ${firstElement.reference!!.type})"
-    )
-    val stackTrace = mutableListOf<StackTraceElement>()
-    leakTrace.elements.onEach { element ->
-      val ref = element.reference
-      val methodName = ref?.name ?: "leaking"
-      val file = classSimpleName(element.className) + ".java"
-      stackTrace.add(StackTraceElement(element.className, methodName, file, 42))
-    }
-    runtimeException.stackTrace = stackTrace.toTypedArray()
-    return runtimeException
-  }
-
-  private fun classSimpleName(className: String): String {
-    val separator = className.lastIndexOf('.')
-    return if (separator == -1) className else className.substring(separator + 1)
-  }
-
-  companion object {
-    const val RETAINED_HEAP_SKIPPED: Long = -1
-
-    fun noLeak(
-      className: String,
-      analysisDurationMs: Long
-    ): PerflibAnalysisResult {
-      return PerflibAnalysisResult(
-          referenceKey = "Fake-${UUID.randomUUID()}",
-          referenceName = "",
-          leakFound = false,
-          excludedLeak = false,
-          className = className,
-          leakTrace = null,
-          failure = null,
-          retainedHeapSize = 0,
-          analysisDurationMs = analysisDurationMs,
-          watchDurationMs = 0
-      )
-    }
-
-    fun leakDetected(
-      referenceKey: String,
-      referenceName: String,
-      excludedLeak: Boolean,
-      className: String,
-      leakTrace: LeakTrace?,
-      retainedHeapSize: Long,
-      analysisDurationMs: Long,
-      watchDurationMs: Long
-    ): PerflibAnalysisResult {
-      return PerflibAnalysisResult(
-          referenceKey = referenceKey,
-          referenceName = referenceName,
-          leakFound = true,
-          excludedLeak = excludedLeak,
-          className = className,
-          leakTrace = leakTrace,
-          failure = null,
-          retainedHeapSize = retainedHeapSize,
-          analysisDurationMs = analysisDurationMs,
-          watchDurationMs = watchDurationMs
-      )
-    }
-
-    fun failure(
-      failure: Throwable,
-      analysisDurationMs: Long
-    ): PerflibAnalysisResult {
-      return PerflibAnalysisResult(
-          referenceKey = "Fake-${UUID.randomUUID()}",
-          referenceName = "",
-          leakFound = false,
-          excludedLeak = false,
-          className = null,
-          leakTrace = null,
-          failure = failure,
-          retainedHeapSize = 0,
-          analysisDurationMs = analysisDurationMs,
-          watchDurationMs = 0
-      )
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibExcludedRefs.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibExcludedRefs.kt
deleted file mode 100644
index 3d9a6bdd..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibExcludedRefs.kt
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import java.io.Serializable
-import java.util.Collections.unmodifiableMap
-import java.util.LinkedHashMap
-
-/**
- * Prevents specific references from being taken into account when computing the shortest strong
- * reference path from a suspected leaking instance to the GC roots.
- *
- * This class lets you ignore known memory leaks that you known about. If the shortest path
- * matches [PerflibExcludedRefs], than the heap analyzer should look for a longer path with nothing
- * matching in [PerflibExcludedRefs].
- */
-class PerflibExcludedRefs internal constructor(builder: BuilderWithParams) : Serializable {
-
-  val fieldNameByClassName: Map<String, Map<String, PerflibExclusion>>
-  val staticFieldNameByClassName: Map<String, Map<String, PerflibExclusion>>
-  val threadNames: Map<String, PerflibExclusion>
-  val classNames: Map<String, PerflibExclusion>
-
-  init {
-    this.fieldNameByClassName = unmodifiableRefStringMap(builder.fieldNameByClassName)
-    this.staticFieldNameByClassName = unmodifiableRefStringMap(builder.staticFieldNameByClassName)
-    this.threadNames = unmodifiableRefMap(builder.threadNames)
-    this.classNames = unmodifiableRefMap(builder.classNames)
-  }
-
-  private fun unmodifiableRefStringMap(
-    mapmap: Map<String, Map<String, ParamsBuilder>>
-  ): Map<String, Map<String, PerflibExclusion>> {
-    val fieldNameByClassName = LinkedHashMap<String, Map<String, PerflibExclusion>>()
-    for ((key, value) in mapmap) {
-      fieldNameByClassName[key] = unmodifiableRefMap(value)
-    }
-    return unmodifiableMap(fieldNameByClassName)
-  }
-
-  private fun unmodifiableRefMap(fieldBuilderMap: Map<String, ParamsBuilder>): Map<String, PerflibExclusion> {
-    val fieldMap = LinkedHashMap<String, PerflibExclusion>()
-    for ((key, value) in fieldBuilderMap) {
-      fieldMap[key] = PerflibExclusion(value)
-    }
-    return unmodifiableMap(fieldMap)
-  }
-
-  override fun toString(): String {
-    var string = ""
-    for ((clazz, value) in fieldNameByClassName) {
-      for ((key, value1) in value) {
-        val always = if (value1.alwaysExclude) " (always)" else ""
-        string += "| Field: $clazz.$key$always\n"
-      }
-    }
-    for ((clazz, value) in staticFieldNameByClassName) {
-      for ((key, value1) in value) {
-        val always = if (value1.alwaysExclude) " (always)" else ""
-        string += "| Static field: $clazz.$key$always\n"
-      }
-    }
-    for ((key, value) in threadNames) {
-      val always = if (value.alwaysExclude) " (always)" else ""
-      string += "| Thread:$key$always\n"
-    }
-    for ((key, value) in classNames) {
-      val always = if (value.alwaysExclude) " (always)" else ""
-      string += "| Class:$key$always\n"
-    }
-    return string
-  }
-
-  @Suppress("unused")
-  internal class ParamsBuilder(val matching: String) {
-    var name: String? = null
-    var reason: String? = null
-    var alwaysExclude: Boolean = false
-  }
-
-  interface Builder {
-    fun instanceField(
-      className: String,
-      fieldName: String
-    ): BuilderWithParams
-
-    fun staticField(
-      className: String,
-      fieldName: String
-    ): BuilderWithParams
-
-    fun thread(threadName: String): BuilderWithParams
-
-    fun clazz(className: String): BuilderWithParams
-
-    fun build(): PerflibExcludedRefs
-  }
-
-  class BuilderWithParams internal constructor() : Builder {
-
-    internal val fieldNameByClassName = LinkedHashMap<String, MutableMap<String, ParamsBuilder>>()
-    internal val staticFieldNameByClassName =
-      LinkedHashMap<String, MutableMap<String, ParamsBuilder>>()
-    internal val threadNames = LinkedHashMap<String, ParamsBuilder>()
-    internal val classNames = LinkedHashMap<String, ParamsBuilder>()
-
-    private var lastParams: ParamsBuilder? = null
-
-    override fun instanceField(
-      className: String,
-      fieldName: String
-    ): BuilderWithParams {
-      var excludedFields: MutableMap<String, ParamsBuilder>? = fieldNameByClassName[className]
-      if (excludedFields == null) {
-        excludedFields = LinkedHashMap()
-        fieldNameByClassName[className] = excludedFields
-      }
-      lastParams = ParamsBuilder("field $className#$fieldName")
-      excludedFields[fieldName] = lastParams!!
-      return this
-    }
-
-    override fun staticField(
-      className: String,
-      fieldName: String
-    ): BuilderWithParams {
-      var excludedFields: MutableMap<String, ParamsBuilder>? = staticFieldNameByClassName[className]
-      if (excludedFields == null) {
-        excludedFields = LinkedHashMap()
-        staticFieldNameByClassName[className] = excludedFields
-      }
-      lastParams =
-        ParamsBuilder("static field $className#$fieldName")
-      excludedFields[fieldName] = lastParams!!
-      return this
-    }
-
-    override fun thread(threadName: String): BuilderWithParams {
-      lastParams = ParamsBuilder("any threads named $threadName")
-      threadNames[threadName] = lastParams!!
-      return this
-    }
-
-    /** Ignores all fields and static fields of all subclasses of the provided class name.  */
-    override fun clazz(className: String): BuilderWithParams {
-      lastParams = ParamsBuilder("any subclass of $className")
-      classNames[className] = lastParams!!
-      return this
-    }
-
-    fun named(name: String): BuilderWithParams {
-      lastParams!!.name = name
-      return this
-    }
-
-    fun reason(reason: String): BuilderWithParams {
-      lastParams!!.reason = reason
-      return this
-    }
-
-    fun alwaysExclude(): BuilderWithParams {
-      lastParams!!.alwaysExclude = true
-      return this
-    }
-
-    override fun build(): PerflibExcludedRefs {
-      return PerflibExcludedRefs(this)
-    }
-  }
-
-  companion object {
-
-    fun builder(): Builder {
-      return BuilderWithParams()
-    }
-  }
-}
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibExclusion.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibExclusion.kt
deleted file mode 100644
index 8fc74e85..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibExclusion.kt
+++ /dev/null
@@ -1,11 +0,0 @@
-package leakcanary
-
-import leakcanary.PerflibExcludedRefs.ParamsBuilder
-import java.io.Serializable
-
-class PerflibExclusion internal constructor(builder: ParamsBuilder) : Serializable {
-  val name: String? = builder.name
-  val reason: String? = builder.reason
-  val alwaysExclude: Boolean = builder.alwaysExclude
-  val matching: String = builder.matching
-}
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibHeapDump.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibHeapDump.kt
deleted file mode 100644
index ef27579b..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/PerflibHeapDump.kt
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import java.io.File
-import java.io.Serializable
-
-/** Data structure holding information about a heap dump.  */
-class PerflibHeapDump internal constructor(builder: Builder) : Serializable {
-
-  /** The heap dump file, which you might want to upload somewhere.  */
-  val heapDumpFile: File
-
-  val gcDurationMs: Long
-  val heapDumpDurationMs: Long
-  val computeRetainedHeapSize: Boolean
-
-  init {
-    this.heapDumpFile = builder.heapDumpFile
-    this.computeRetainedHeapSize = builder.computeRetainedHeapSize
-    this.gcDurationMs = builder.gcDurationMs
-    this.heapDumpDurationMs = builder.heapDumpDurationMs
-  }
-
-  fun buildUpon(): Builder {
-    return Builder(this)
-  }
-
-  class Builder(
-    internal var heapDumpFile: File
-  ) {
-    internal var gcDurationMs: Long = 0
-    internal var heapDumpDurationMs: Long = 0
-    internal var computeRetainedHeapSize: Boolean = false
-
-    internal constructor(heapDump: PerflibHeapDump) : this(heapDump.heapDumpFile) {
-      this.heapDumpFile = heapDump.heapDumpFile
-      this.computeRetainedHeapSize = heapDump.computeRetainedHeapSize
-      this.gcDurationMs = heapDump.gcDurationMs
-      this.heapDumpDurationMs = heapDump.heapDumpDurationMs
-    }
-
-    fun heapDumpFile(heapDumpFile: File): Builder {
-      this.heapDumpFile = heapDumpFile
-      return this
-    }
-
-    fun gcDurationMs(gcDurationMs: Long): Builder {
-      this.gcDurationMs = gcDurationMs
-      return this
-    }
-
-    fun heapDumpDurationMs(heapDumpDurationMs: Long): Builder {
-      this.heapDumpDurationMs = heapDumpDurationMs
-      return this
-    }
-
-    fun computeRetainedHeapSize(computeRetainedHeapSize: Boolean): Builder {
-      this.computeRetainedHeapSize = computeRetainedHeapSize
-      return this
-    }
-
-    fun build(): PerflibHeapDump {
-      return PerflibHeapDump(this)
-    }
-  }
-
-  companion object {
-    fun builder(heapDumpFile: File): Builder {
-      return Builder(heapDumpFile)
-    }
-  }
-}
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/HahaHelper.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/HahaHelper.kt
deleted file mode 100644
index d39685bf..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/HahaHelper.kt
+++ /dev/null
@@ -1,211 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal.perflib
-
-import com.squareup.haha.perflib.ArrayInstance
-import com.squareup.haha.perflib.ClassInstance
-import com.squareup.haha.perflib.ClassObj
-import com.squareup.haha.perflib.Instance
-import com.squareup.haha.perflib.Type
-import java.lang.reflect.InvocationTargetException
-import java.nio.charset.Charset
-import java.util.Arrays.asList
-import java.util.HashSet
-
-internal object HahaHelper {
-
-  private val WRAPPER_TYPES = HashSet(
-      asList(
-          Boolean::class.java.name, Char::class.java.name, Float::class.java.name,
-          Double::class.java.name, Byte::class.java.name, Short::class.java.name,
-          Int::class.java.name, Long::class.java.name
-      )
-  )
-
-  fun threadName(holder: Instance): String {
-    val values = classInstanceValues(holder)
-    val nameField = fieldValue<Any>(values, "name")
-        ?: // Sometimes we can't find the String at the expected memory address in the heap dump.
-        // See https://github.com/square/leakcanary/issues/417 .
-        return "Thread name not available"
-    return asString(nameField)
-  }
-
-  fun extendsThread(clazz: ClassObj): Boolean {
-    var extendsThread = false
-    var parentClass = clazz
-    while (parentClass.superClassObj != null) {
-      if (parentClass.className == Thread::class.java.name) {
-        extendsThread = true
-        break
-      }
-      parentClass = parentClass.superClassObj
-    }
-    return extendsThread
-  }
-
-  /**
-   * This returns a string representation of any object or value passed in.
-   */
-  fun valueAsString(value: Any?): String {
-    val stringValue: String
-    if (value == null) {
-      stringValue = "null"
-    } else if (value is ClassInstance) {
-      val valueClassName = value.classObj.className
-      if (valueClassName == String::class.java.name) {
-        stringValue = '"'.toString() + asString(value) + '"'.toString()
-      } else {
-        stringValue = value.toString()
-      }
-    } else {
-      stringValue = value.toString()
-    }
-    return stringValue
-  }
-
-  fun asStringArray(arrayInstance: ArrayInstance): MutableList<String> {
-    val entries = mutableListOf<String>()
-    for (arrayEntry in arrayInstance.values) {
-      entries.add(asString(arrayEntry))
-    }
-    return entries
-  }
-
-  /** Given a string instance from the heap dump, this returns its actual string value.  */
-  fun asString(stringObject: Any): String {
-    val instance = stringObject as Instance
-    val values = classInstanceValues(instance)
-
-    val count = fieldValue<Int>(values, "count")!!
-    if (count == 0) {
-      return ""
-    }
-
-    val value = fieldValue<Any>(values, "value")!!
-
-    var offset: Int?
-    val array: ArrayInstance
-    if (isCharArray(value)) {
-      array = value as ArrayInstance
-
-      offset = 0
-      // < API 23
-      // As of Marshmallow, substrings no longer share their parent strings' char arrays
-      // eliminating the need for String.offset
-      // https://android-review.googlesource.com/#/c/83611/
-      if (hasField(values, "offset")) {
-        offset = fieldValue<Int>(values, "offset")!!
-      }
-
-      val chars = array.asCharArray(offset, count)
-      return String(chars)
-    } else if (isByteArray(value)) {
-      // In API 26, Strings are now internally represented as byte arrays.
-      array = value as ArrayInstance
-
-      // HACK - remove when HAHA's perflib is updated to https://goo.gl/Oe7ZwO.
-      try {
-        val asRawByteArray = ArrayInstance::class.java.getDeclaredMethod(
-            "asRawByteArray", Int::class.javaPrimitiveType, Int::class.javaPrimitiveType
-        )
-        asRawByteArray.isAccessible = true
-        val rawByteArray = asRawByteArray.invoke(array, 0, count) as ByteArray
-        return String(rawByteArray, Charset.forName("UTF-8"))
-      } catch (e: NoSuchMethodException) {
-        throw RuntimeException(e)
-      } catch (e: IllegalAccessException) {
-        throw RuntimeException(e)
-      } catch (e: InvocationTargetException) {
-        throw RuntimeException(e)
-      }
-
-    } else {
-      throw UnsupportedOperationException("Could not find char array in $instance")
-    }
-  }
-
-  fun isPrimitiveWrapper(value: Any): Boolean {
-    return if (value !is ClassInstance) {
-      false
-    } else WRAPPER_TYPES.contains(
-        value.classObj.className
-    )
-  }
-
-  fun isPrimitiveOrWrapperArray(value: Any): Boolean {
-    if (value !is ArrayInstance) {
-      return false
-    }
-    return if (value.arrayType != Type.OBJECT) {
-      true
-    } else WRAPPER_TYPES.contains(
-        value.classObj.className
-    )
-  }
-
-  private fun isCharArray(value: Any): Boolean {
-    return value is ArrayInstance && value.arrayType == Type.CHAR
-  }
-
-  private fun isByteArray(value: Any): Boolean {
-    return value is ArrayInstance && value.arrayType == Type.BYTE
-  }
-
-  fun classInstanceValues(instance: Instance): List<ClassInstance.FieldValue> {
-    val classInstance = instance as ClassInstance
-    return classInstance.values
-  }
-
-  fun <T> fieldValue(
-    values: List<ClassInstance.FieldValue>,
-    fieldName: String
-  ): T? {
-    for (fieldValue in values) {
-      if (fieldValue.field.name == fieldName) {
-        @Suppress("UNCHECKED_CAST")
-        return fieldValue.value as T
-      }
-    }
-    throw IllegalArgumentException("Field $fieldName does not exists")
-  }
-
-  fun hasField(
-    values: List<ClassInstance.FieldValue>,
-    fieldName: String
-  ): Boolean {
-    for (fieldValue in values) {
-      if (fieldValue.field.name == fieldName) {
-
-        return true
-      }
-    }
-    return false
-  }
-
-  fun <T> staticFieldValue(
-    classObj: ClassObj,
-    fieldName: String
-  ): T {
-    for ((key, value) in classObj.staticFieldValues) {
-      if (key.name == fieldName) {
-        @Suppress("UNCHECKED_CAST")
-        return value as T
-      }
-    }
-    throw IllegalArgumentException("Field $fieldName does not exists")
-  }
-}
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/KeyedWeakReferenceMirror.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/KeyedWeakReferenceMirror.kt
deleted file mode 100644
index b68fb355..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/KeyedWeakReferenceMirror.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-package leakcanary.internal.perflib
-
-import com.squareup.haha.perflib.ClassInstance
-import com.squareup.haha.perflib.Instance
-import leakcanary.internal.perflib.HahaHelper.asString
-import leakcanary.internal.perflib.HahaHelper.classInstanceValues
-import leakcanary.internal.perflib.HahaHelper.fieldValue
-
-/**
- * Represents a [leakcanary.KeyedWeakReference] read from the heap dump.
- */
-internal sealed class KeyedWeakReferenceMirror(
-  fields: List<ClassInstance.FieldValue>,
-  heapDumpUptimeMillis: Long
-) {
-  val key = asString(fieldValue<Any>(fields, "key")!!)
-  val name = asString(fieldValue<Any>(fields, "name")!!)
-  val className = asString(fieldValue<Any>(fields, "className")!!)
-  val watchDurationMillis = heapDumpUptimeMillis - fieldValue<Long>(fields, "watchUptimeMillis")!!
-
-  companion object {
-    fun fromInstance(
-      weakRef: Instance,
-      heapDumpUptimeMillis: Long
-    ): KeyedWeakReferenceMirror {
-      val values = classInstanceValues(weakRef)
-      val referent = fieldValue<Instance>(values, "referent")
-      return if (referent != null) {
-        HasReferent(values, heapDumpUptimeMillis, referent)
-      } else {
-        Cleared(values, heapDumpUptimeMillis)
-      }
-    }
-
-  }
-}
-
-internal class Cleared(
-  fields: List<ClassInstance.FieldValue>,
-  heapDumpUptimeMillis: Long
-) : KeyedWeakReferenceMirror(fields, heapDumpUptimeMillis)
-
-internal class HasReferent(
-  fields: List<ClassInstance.FieldValue>,
-  heapDumpUptimeMillis: Long,
-  val referent: Instance
-) : KeyedWeakReferenceMirror(fields, heapDumpUptimeMillis)
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/LeakNode.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/LeakNode.kt
deleted file mode 100644
index ea177182..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/LeakNode.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-package leakcanary.internal.perflib
-
-import com.squareup.haha.perflib.Instance
-import leakcanary.PerflibExclusion
-import leakcanary.LeakReference
-
-internal data class LeakNode(
-  val exclusion: PerflibExclusion?,
-  val instance: Instance,
-  val parent: LeakNode?,
-  val leakReference: LeakReference?
-)
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
deleted file mode 100644
index 7e03c259..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/PerflibHeapAnalyzer.kt
+++ /dev/null
@@ -1,531 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal.perflib
-
-import com.android.tools.perflib.captures.MemoryMappedFileBuffer
-import com.squareup.haha.perflib.ArrayInstance
-import com.squareup.haha.perflib.ClassObj
-import com.squareup.haha.perflib.Instance
-import com.squareup.haha.perflib.RootObj
-import com.squareup.haha.perflib.Snapshot
-import gnu.trove.THashMap
-import gnu.trove.TObjectProcedure
-import leakcanary.AnalyzerProgressListener
-import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACE
-import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
-import leakcanary.AnalyzerProgressListener.Step.COMPUTING_DOMINATORS
-import leakcanary.AnalyzerProgressListener.Step.DEDUPLICATING_GC_ROOTS
-import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REF
-import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_REFS
-import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATH
-import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
-import leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP
-import leakcanary.AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE
-import leakcanary.AnalyzerProgressListener.Step.SCANNING_HEAP_DUMP
-import leakcanary.Exclusion
-import leakcanary.ExclusionDescription
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisException
-import leakcanary.HeapAnalysisFailure
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HeapDumpMemoryStore
-import leakcanary.KeyedWeakReference
-import leakcanary.LeakNodeStatus
-import leakcanary.LeakNodeStatusAndReason
-import leakcanary.LeakTrace
-import leakcanary.LeakTraceElement
-import leakcanary.LeakTraceElement.Holder
-import leakcanary.LeakTraceElement.Holder.ARRAY
-import leakcanary.LeakTraceElement.Holder.CLASS
-import leakcanary.LeakTraceElement.Holder.OBJECT
-import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.LeakingInstance
-import leakcanary.NoPathToInstance
-import leakcanary.PerflibAnalysisResult
-import leakcanary.PerflibExcludedRefs
-import leakcanary.PerflibHeapDump
-import leakcanary.RetainedInstance
-import leakcanary.WeakReferenceCleared
-import leakcanary.WeakReferenceMissing
-import leakcanary.internal.perflib.HahaHelper.asString
-import leakcanary.internal.perflib.HahaHelper.asStringArray
-import leakcanary.internal.perflib.HahaHelper.classInstanceValues
-import leakcanary.internal.perflib.HahaHelper.extendsThread
-import leakcanary.internal.perflib.HahaHelper.fieldValue
-import leakcanary.internal.perflib.HahaHelper.staticFieldValue
-import leakcanary.internal.perflib.HahaHelper.threadName
-import leakcanary.internal.perflib.ShortestPathFinder.Result
-import org.jetbrains.annotations.TestOnly
-import java.util.ArrayList
-import java.util.concurrent.TimeUnit.NANOSECONDS
-
-/**
- * Analyzes heap dumps to look for leaks.
- */
-class PerflibHeapAnalyzer @TestOnly internal constructor(
-  private val listener: AnalyzerProgressListener,
-  private val keyedWeakReferenceClassName: String,
-  private val heapDumpMemoryStoreClassName: String
-) {
-
-  constructor(listener: AnalyzerProgressListener) : this(
-      listener, KeyedWeakReference::class.java.name, HeapDumpMemoryStore::class.java.name
-  )
-
-  /**
-   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  @TestOnly
-  @Deprecated(
-      "Use {@link #checkForLeaks(File, boolean)} instead. We're keeping this only because\n" +
-          "    our tests currently run with older heapdumps."
-  )
-  internal fun checkForLeak(
-    heapDump: PerflibHeapDump,
-    excludedRefs: PerflibExcludedRefs,
-    referenceKey: String
-  ): PerflibAnalysisResult {
-    val analysisStartNanoTime = System.nanoTime()
-
-    if (!heapDump.heapDumpFile.exists()) {
-      val exception = IllegalArgumentException("File does not exist: $heapDump.heapDumpFile")
-      return PerflibAnalysisResult.failure(exception, since(analysisStartNanoTime))
-    }
-
-    var buffer: MemoryMappedFileBuffer? = null
-    try {
-      listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
-      buffer = MemoryMappedFileBuffer(heapDump.heapDumpFile)
-      listener.onProgressUpdate(PARSING_HEAP_DUMP)
-      val snapshot = Snapshot.createSnapshot(buffer)
-      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS)
-      deduplicateGcRoots(snapshot)
-      listener.onProgressUpdate(FINDING_LEAKING_REF)
-      val leakingRef =
-        findLeakingReference(referenceKey, snapshot) ?: return PerflibAnalysisResult.noLeak(
-            "UnknownNoKeyedWeakReference",
-            since(analysisStartNanoTime)
-        )
-      return findLeakTrace(
-          heapDump,
-          excludedRefs,
-          referenceKey, "NAME_NOT_SUPPORTED", analysisStartNanoTime, snapshot,
-          leakingRef, 0
-      )
-    } catch (e: Throwable) {
-      return PerflibAnalysisResult.failure(e, since(analysisStartNanoTime))
-    } finally {
-      try {
-        buffer?.dispose()
-      } catch (ignored: NoClassDefFoundError) {
-        // DirectBuffer does not exist on older Android versions.
-      }
-    }
-
-  }
-
-  /**
-   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
-   */
-  fun checkForLeaks(
-    heapDump: PerflibHeapDump,
-    excludedRefs: PerflibExcludedRefs
-  ): HeapAnalysis {
-    val analysisStartNanoTime = System.nanoTime()
-
-    if (!heapDump.heapDumpFile.exists()) {
-      val exception = IllegalArgumentException("File does not exist: $heapDump.heapDumpFile")
-      return HeapAnalysisFailure(
-          heapDump.heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-          HeapAnalysisException(exception)
-      )
-    }
-
-    var buffer: MemoryMappedFileBuffer? = null
-    try {
-      listener.onProgressUpdate(READING_HEAP_DUMP_FILE)
-      buffer = MemoryMappedFileBuffer(heapDump.heapDumpFile)
-      listener.onProgressUpdate(SCANNING_HEAP_DUMP)
-      val snapshot = Snapshot.createSnapshot(buffer)
-      listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS)
-      deduplicateGcRoots(snapshot)
-
-      val analysisResults = mutableMapOf<String, RetainedInstance>()
-
-      val (retainedKeys, heapDumpUptimeMillis) = readHeapDumpMemoryStore(snapshot)
-
-      if (retainedKeys.size == 0) {
-        val exception = IllegalStateException("No retained keys found in heap dump")
-        return HeapAnalysisFailure(
-            heapDump.heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-            HeapAnalysisException(exception)
-        )
-      }
-
-      val leakingWeakRefs =
-        findLeakingReferences(snapshot, retainedKeys, analysisResults, heapDumpUptimeMillis)
-
-      val pathResults = findShortestPaths(excludedRefs, snapshot, leakingWeakRefs)
-
-      buildLeakTraces(heapDump, pathResults, snapshot, leakingWeakRefs, analysisResults)
-
-      addRemainingInstancesWithNoPath(leakingWeakRefs, analysisResults)
-
-      return HeapAnalysisSuccess(
-          heapDump.heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-          analysisResults.values.toList()
-      )
-    } catch (exception: Throwable) {
-      return HeapAnalysisFailure(
-          heapDump.heapDumpFile, System.currentTimeMillis(), since(analysisStartNanoTime),
-          HeapAnalysisException(exception)
-      )
-    } finally {
-      try {
-        buffer?.dispose()
-      } catch (ignored: NoClassDefFoundError) {
-        // DirectBuffer does not exist on older Android versions.
-      }
-    }
-  }
-
-  private fun readHeapDumpMemoryStore(snapshot: Snapshot): Pair<MutableList<String>, Long> {
-    val heapDumpMemoryStoreClass = snapshot.findClass(heapDumpMemoryStoreClassName)
-    val retainedKeysArray =
-      staticFieldValue<ArrayInstance>(heapDumpMemoryStoreClass, "retainedKeysForHeapDump")
-    val retainedKeys = asStringArray(retainedKeysArray)
-    val heapDumpUptimeMillis =
-      staticFieldValue<Long>(heapDumpMemoryStoreClass, "heapDumpUptimeMillis")
-    return Pair(retainedKeys, heapDumpUptimeMillis)
-  }
-
-  /**
-   * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
-   */
-  internal fun deduplicateGcRoots(snapshot: Snapshot) {
-    // THashMap has a smaller memory footprint than HashMap.
-    val uniqueRootMap = THashMap<String, RootObj>()
-
-    val gcRoots = snapshot.gcRoots
-    for (root in gcRoots) {
-      val key = generateRootKey(root)
-      if (!uniqueRootMap.containsKey(key)) {
-        uniqueRootMap[key] = root
-      }
-    }
-
-    // Repopulate snapshot with unique GC roots.
-    gcRoots.clear()
-    uniqueRootMap.forEach(TObjectProcedure { key -> gcRoots.add(uniqueRootMap[key]) })
-  }
-
-  private fun generateRootKey(root: RootObj): String {
-    return String.format("%s@0x%08x", root.rootType.getName(), root.id)
-  }
-
-  private fun findLeakingReferences(
-    snapshot: Snapshot,
-    retainedKeys: MutableList<String>,
-    analysisResults: MutableMap<String, RetainedInstance>,
-    heapDumpUptimeMillis: Long
-  ): MutableList<HasReferent> {
-    listener.onProgressUpdate(FINDING_LEAKING_REFS)
-
-    val refClass = snapshot.findClass(keyedWeakReferenceClassName) ?: throw IllegalStateException(
-        "Could not find the "
-            + keyedWeakReferenceClassName
-            + " class in the heap dump."
-    )
-
-    val leakingWeakRefs = mutableListOf<HasReferent>()
-    for (weakRef in refClass.instancesList) {
-      val weakRefMirror = KeyedWeakReferenceMirror.fromInstance(
-          weakRef, heapDumpUptimeMillis
-      )
-
-      val wasRetained = retainedKeys.remove(weakRefMirror.key)
-      if (wasRetained) {
-        if (weakRefMirror is HasReferent) {
-          leakingWeakRefs.add(weakRefMirror)
-        } else {
-          val noLeak = WeakReferenceCleared(
-              weakRefMirror.key, weakRefMirror.name, weakRefMirror.className,
-              weakRefMirror.watchDurationMillis
-          )
-          analysisResults[weakRefMirror.key] = noLeak
-        }
-      }
-    }
-
-    retainedKeys.forEach { referenceKey ->
-      // This could happen if RefWatcher removed weakly reachable references after providing
-      // the set of retained keys
-      val noLeak = WeakReferenceMissing(referenceKey)
-      analysisResults[referenceKey] = noLeak
-    }
-    return leakingWeakRefs
-  }
-
-  private fun findShortestPaths(
-    excludedRefs: PerflibExcludedRefs,
-    snapshot: Snapshot,
-    leakingWeakRefs: MutableList<HasReferent>
-  ): List<Result> {
-    listener.onProgressUpdate(FINDING_SHORTEST_PATHS)
-    val pathFinder =
-      ShortestPathFinder(excludedRefs, ignoreStrings = true)
-    return pathFinder.findPaths(snapshot, leakingWeakRefs)
-  }
-
-  private fun buildLeakTraces(
-    heapDump: PerflibHeapDump,
-    pathResults: List<Result>,
-    snapshot: Snapshot,
-    leakingWeakRefs: MutableList<HasReferent>,
-    analysisResults: MutableMap<String, RetainedInstance>
-  ) {
-    if (heapDump.computeRetainedHeapSize && pathResults.isNotEmpty()) {
-      listener.onProgressUpdate(COMPUTING_DOMINATORS)
-      // Computing dominators has the side effect of computing retained size.
-      snapshot.computeDominators()
-    }
-
-    listener.onProgressUpdate(BUILDING_LEAK_TRACES)
-
-    pathResults.forEach { pathResult ->
-      val weakReference = pathResult.weakReference
-      val removed = leakingWeakRefs.remove(weakReference)
-      if (!removed) {
-        throw IllegalStateException(
-            "ShortestPathFinder found an instance we didn't ask it to find: $pathResult"
-        )
-      }
-
-      val leakTrace = buildLeakTrace(pathResult.leakingNode)
-
-      val retainedSize = if (heapDump.computeRetainedHeapSize) {
-        pathResult.leakingNode.instance.totalRetainedSize.toInt()
-      } else {
-        null
-      }
-      val leakDetected = LeakingInstance(
-          weakReference.key, weakReference.name, weakReference.className,
-          weakReference.watchDurationMillis,
-          if (pathResult.excludingKnownLeaks) Exclusion.Status.WONT_FIX_LEAK else null, leakTrace,
-          retainedSize
-      )
-      analysisResults[weakReference.key] = leakDetected
-    }
-  }
-
-  private fun addRemainingInstancesWithNoPath(
-    leakingWeakRefs: MutableList<HasReferent>,
-    analysisResults: MutableMap<String, RetainedInstance>
-  ) {
-    leakingWeakRefs.forEach { refWithNoPath ->
-      val noLeak = NoPathToInstance(
-          refWithNoPath.key, refWithNoPath.name, refWithNoPath.className,
-          refWithNoPath.watchDurationMillis
-      )
-      analysisResults[refWithNoPath.key] = noLeak
-    }
-  }
-
-  private fun findLeakingReference(
-    key: String,
-    snapshot: Snapshot
-  ): Instance? {
-    val refClass = snapshot.findClass(keyedWeakReferenceClassName) ?: throw IllegalStateException(
-        "Could not find the $keyedWeakReferenceClassName class in the heap dump."
-    )
-    val keysFound = ArrayList<String?>()
-    for (instance in refClass.instancesList) {
-      val values = classInstanceValues(instance)
-      val keyFieldValue = fieldValue<Any>(values, "key")
-      if (keyFieldValue == null) {
-        keysFound.add(null)
-        continue
-      }
-      val keyCandidate = asString(keyFieldValue)
-      if (keyCandidate == key) {
-        return fieldValue<Instance>(values, "referent")
-      }
-      keysFound.add(keyCandidate)
-    }
-    throw IllegalStateException(
-        "Could not find weak reference with key $key in $keysFound"
-    )
-  }
-
-  private fun findLeakTrace(
-    heapDump: PerflibHeapDump,
-    excludedRefs: PerflibExcludedRefs,
-    referenceKey: String,
-    referenceName: String,
-    analysisStartNanoTime: Long,
-    snapshot: Snapshot,
-    leakingRef: Instance,
-    watchDurationMs: Long
-  ): PerflibAnalysisResult {
-
-    listener.onProgressUpdate(FINDING_SHORTEST_PATH)
-    val pathFinder =
-      ShortestPathFinder(excludedRefs, ignoreStrings = true)
-    val result = pathFinder.findPath(snapshot, leakingRef)
-
-    val className = leakingRef.classObj.className
-
-    // False alarm, no strong reference path to GC Roots.
-    if (result.leakingNode == null) {
-      return PerflibAnalysisResult.noLeak(className, since(analysisStartNanoTime))
-    }
-
-    listener.onProgressUpdate(BUILDING_LEAK_TRACE)
-    val leakTrace = buildLeakTrace(result.leakingNode)
-
-    val retainedSize = if (heapDump.computeRetainedHeapSize) {
-      listener.onProgressUpdate(COMPUTING_DOMINATORS)
-      // Side effect: computes retained size.
-      snapshot.computeDominators()
-
-      val leakingInstance = result.leakingNode.instance
-
-      leakingInstance.totalRetainedSize
-    } else {
-      PerflibAnalysisResult.RETAINED_HEAP_SKIPPED
-    }
-
-    return PerflibAnalysisResult.leakDetected(
-        referenceKey, referenceName,
-        result.excludingKnownLeaks, className, leakTrace,
-        retainedSize,
-        since(analysisStartNanoTime), watchDurationMs
-    )
-  }
-
-  private fun buildLeakTrace(
-    leakingNode: LeakNode
-  ): LeakTrace {
-    val elements = ArrayList<LeakTraceElement>()
-    // We iterate from the leak to the GC root
-    val ignored = leakingNode.instance
-    var node: LeakNode? =
-      LeakNode(null, ignored, leakingNode, null)
-    var leakStatusAndReason = LeakNodeStatus.leaking("It's the leaking instance")
-    while (node != null) {
-      val element = buildLeakElement(node, leakStatusAndReason)
-      if (element != null) {
-        elements.add(0, element)
-        leakStatusAndReason = if (node.parent?.parent != null) {
-          LeakNodeStatus.notLeaking("It's the GC root")
-        } else {
-          LeakNodeStatus.unknown()
-        }
-      }
-      node = node.parent
-    }
-    return LeakTrace(elements)
-  }
-
-  private fun buildLeakElement(
-    node: LeakNode,
-    leakStatusAndReason: LeakNodeStatusAndReason
-  ): LeakTraceElement? {
-    if (node.parent == null) {
-      // Ignore any root node.
-      return null
-    }
-    val holder = node.parent.instance
-
-    if (holder is RootObj) {
-      return null
-    }
-    val holderType: Holder
-    val className: String
-    var extra: String? = null
-
-    className = getClassName(holder)
-
-    val rootClassName = Any::class.java.name
-    if (holder is ClassObj) {
-      holderType = CLASS
-    } else if (holder is ArrayInstance) {
-      holderType = ARRAY
-    } else {
-      val classObj = holder.classObj
-      if (extendsThread(classObj)) {
-        holderType = THREAD
-        val threadName = threadName(holder)
-        extra = "(named '$threadName')"
-      } else if (className.matches(
-              ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
-          )
-      ) {
-        val parentClassName = classObj.superClassObj.className
-        if (rootClassName == parentClassName) {
-          holderType = OBJECT
-          try {
-            // This is an anonymous class implementing an interface. The API does not give access
-            // to the interfaces implemented by the class. We check if it's in the class path and
-            // use that instead.
-            val actualClass = Class.forName(classObj.className)
-            val interfaces = actualClass.interfaces
-            extra = if (interfaces.isNotEmpty()) {
-              val implementedInterface = interfaces[0]
-              "(anonymous implementation of " + implementedInterface.name + ")"
-            } else {
-              "(anonymous subclass of java.lang.Object)"
-            }
-          } catch (ignored: ClassNotFoundException) {
-          }
-
-        } else {
-          holderType = OBJECT
-          // Makes it easier to figure out which anonymous class we're looking at.
-          extra = "(anonymous subclass of $parentClassName)"
-        }
-      } else {
-        holderType = OBJECT
-      }
-    }
-    val labels = if (extra == null) emptyList<String>() else mutableListOf(extra)
-
-    val exclusionDescription = node.exclusion?.let {
-      ExclusionDescription(node.exclusion.matching, node.exclusion.reason)
-    }
-
-    return LeakTraceElement(
-        node.leakReference, holderType, className, exclusionDescription, labels, leakStatusAndReason
-    )
-  }
-
-  private fun getClassName(instance: Instance): String = when (instance) {
-    is ClassObj -> instance.className
-    is ArrayInstance -> instance.classObj.className
-    else -> instance.classObj.className
-  }
-
-  private fun since(analysisStartNanoTime: Long): Long {
-    return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
-  }
-
-  companion object {
-
-    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
-  }
-}
diff --git a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt b/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt
deleted file mode 100644
index a8a58e1b..00000000
--- a/leakcanary-analyzer-perflib/src/main/java/leakcanary/internal/perflib/ShortestPathFinder.kt
+++ /dev/null
@@ -1,381 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary.internal.perflib
-
-import com.squareup.haha.perflib.ArrayInstance
-import com.squareup.haha.perflib.ClassInstance
-import com.squareup.haha.perflib.ClassObj
-import com.squareup.haha.perflib.Instance
-import com.squareup.haha.perflib.RootObj
-import com.squareup.haha.perflib.RootType
-import com.squareup.haha.perflib.Snapshot
-import com.squareup.haha.perflib.Type
-import com.squareup.haha.perflib.allocatingThread
-import leakcanary.PerflibExcludedRefs
-import leakcanary.PerflibExclusion
-import leakcanary.LeakReference
-import leakcanary.internal.perflib.HahaHelper.isPrimitiveOrWrapperArray
-import leakcanary.internal.perflib.HahaHelper.isPrimitiveWrapper
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
-import leakcanary.LeakTraceElement.Type.LOCAL
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
-import java.util.ArrayDeque
-import java.util.Deque
-import java.util.LinkedHashMap
-import java.util.LinkedHashSet
-
-/**
- * Not thread safe.
- *
- * Finds the shortest path from a leaking reference to a gc root, ignoring excluded
- * refs first and then including the ones that are not "always ignorable" as needed if no path is
- * found.
- */
-internal class ShortestPathFinder(
-  private val excludedRefs: PerflibExcludedRefs,
-  private val ignoreStrings: Boolean
-) {
-  private val toVisitQueue: Deque<LeakNode>
-  private val toVisitIfNoPathQueue: Deque<LeakNode>
-  private val toVisitSet: LinkedHashSet<Instance>
-  private val toVisitIfNoPathSet: LinkedHashSet<Instance>
-  private val visitedSet: LinkedHashSet<Instance>
-
-  init {
-    toVisitQueue = ArrayDeque()
-    toVisitIfNoPathQueue = ArrayDeque()
-    toVisitSet = LinkedHashSet()
-    toVisitIfNoPathSet = LinkedHashSet()
-    visitedSet = LinkedHashSet()
-  }
-
-  @Deprecated("Kept for tests which still rely on findPath()")
-  internal class OldResult(
-    val leakingNode: LeakNode?,
-    val excludingKnownLeaks: Boolean
-  )
-
-  internal class Result(
-    val leakingNode: LeakNode,
-    val excludingKnownLeaks: Boolean,
-    val weakReference: HasReferent
-  )
-
-  fun findPaths(
-    snapshot: Snapshot,
-    leakingWeakRefs: List<HasReferent>
-  ): List<Result> {
-    clearState()
-
-    val referentMap = leakingWeakRefs.associateBy { it.referent }
-
-    enqueueGcRoots(snapshot)
-
-    var excludingKnownLeaks = false
-    val results = mutableListOf<Result>()
-    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
-      val node: LeakNode
-      if (!toVisitQueue.isEmpty()) {
-        node = toVisitQueue.poll()
-      } else {
-        node = toVisitIfNoPathQueue.poll()
-        if (node.exclusion == null) {
-          throw IllegalStateException("Expected node to have an exclusion $node")
-        }
-        excludingKnownLeaks = true
-      }
-
-      if (checkSeen(node)) {
-        continue
-      }
-
-      val weakReference = referentMap[node.instance]
-      if (weakReference != null) {
-        results.add(
-            Result(
-                node, excludingKnownLeaks, weakReference
-            )
-        )
-        // Found all refs, stop searching.
-        if (results.size == leakingWeakRefs.size) {
-          break
-        }
-      }
-      when (node.instance) {
-        is RootObj -> visitRootObj(node)
-        is ClassObj -> visitClassObj(node)
-        is ClassInstance -> visitClassInstance(node)
-        is ArrayInstance -> visitArrayInstance(node)
-        else -> throw IllegalStateException("Unexpected type for ${node.instance}")
-      }
-    }
-    return results
-  }
-
-  fun findPath(
-    snapshot: Snapshot,
-    leakingRef: Instance
-  ): OldResult {
-    clearState()
-
-    enqueueGcRoots(snapshot)
-
-    var excludingKnownLeaks = false
-    var leakingNode: LeakNode? = null
-    while (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) {
-      val node: LeakNode
-      if (!toVisitQueue.isEmpty()) {
-        node = toVisitQueue.poll()
-      } else {
-        node = toVisitIfNoPathQueue.poll()
-        if (node.exclusion == null) {
-          throw IllegalStateException("Expected node to have an exclusion $node")
-        }
-        excludingKnownLeaks = true
-      }
-
-      // Termination
-      if (node.instance === leakingRef) {
-        leakingNode = node
-        break
-      }
-
-      if (checkSeen(node)) {
-        continue
-      }
-
-      when {
-        node.instance is RootObj -> visitRootObj(node)
-        node.instance is ClassObj -> visitClassObj(node)
-        node.instance is ClassInstance -> visitClassInstance(node)
-        node.instance is ArrayInstance -> visitArrayInstance(node)
-        else -> throw IllegalStateException("Unexpected type for " + node.instance)
-      }
-    }
-    return OldResult(
-        leakingNode, excludingKnownLeaks
-    )
-  }
-
-  private fun clearState() {
-    toVisitQueue.clear()
-    toVisitIfNoPathQueue.clear()
-    toVisitSet.clear()
-    toVisitIfNoPathSet.clear()
-    visitedSet.clear()
-  }
-
-  private fun enqueueGcRoots(snapshot: Snapshot) {
-    val gcRoots = snapshot.gcRoots as MutableList<RootObj>
-    // Sorting GC roots to get stable shortest path
-    gcRoots.sortWith(compareBy({ it.rootType.type }, {
-      val referredInstance = it.referredInstance
-      if (referredInstance == null) {
-        "null"
-      } else {
-        when (referredInstance) {
-          is ClassObj -> referredInstance.className
-          is ClassInstance -> referredInstance.classObj.className
-          is ArrayInstance -> referredInstance.classObj.className
-          else -> throw IllegalStateException("Unexpected type for $referredInstance")
-        }
-      }
-    }))
-    for (rootObj in gcRoots) {
-      when (rootObj.rootType) {
-        RootType.JAVA_LOCAL -> {
-          val thread = rootObj.allocatingThread()
-          val threadName = HahaHelper.threadName(thread)
-          val params = excludedRefs.threadNames[threadName]
-          if (params == null || !params.alwaysExclude) {
-            enqueue(params, null, rootObj, null)
-          }
-        }
-        // Added at https://android.googlesource.com/platform/tools/base/+/c0f0d528c155cab32e372dac77370569a386245c
-        RootType.THREAD_OBJECT, RootType.INTERNED_STRING, RootType.DEBUGGER, RootType.INVALID_TYPE,
-          // An object that is unreachable from any other root, but not a root itself.
-        RootType.UNREACHABLE, RootType.UNKNOWN,
-          // An object that is in a queue, waiting for a finalizer to run.
-        RootType.FINALIZING -> {
-        }
-        RootType.SYSTEM_CLASS, RootType.VM_INTERNAL,
-          // A local variable in native code.
-        RootType.NATIVE_LOCAL,
-          // A global variable in native code.
-        RootType.NATIVE_STATIC,
-          // An object that was referenced from an active thread block.
-        RootType.THREAD_BLOCK,
-          // Everything that called the wait() or notify() methods, or that is synchronized.
-        RootType.BUSY_MONITOR, RootType.NATIVE_MONITOR, RootType.REFERENCE_CLEANUP,
-          // Input or output parameters in native code.
-        RootType.NATIVE_STACK, RootType.JAVA_STATIC -> enqueue(null, null, rootObj, null)
-        else -> throw UnsupportedOperationException("Unknown root type:" + rootObj.rootType)
-      }
-    }
-  }
-
-  private fun checkSeen(node: LeakNode): Boolean {
-    return !visitedSet.add(node.instance)
-  }
-
-  private fun visitRootObj(node: LeakNode) {
-    val rootObj = node.instance as RootObj
-    val child = rootObj.referredInstance
-
-    if (rootObj.rootType == RootType.JAVA_LOCAL) {
-      val holder = rootObj.allocatingThread()
-      // We switch the parent node with the thread instance that holds
-      // the local reference.
-      var exclusion: PerflibExclusion? = null
-      if (node.exclusion != null) {
-        exclusion = node.exclusion
-      }
-      val parent = LeakNode(null, holder, null, null)
-      enqueue(exclusion, parent, child, LeakReference(LOCAL, ""))
-    } else {
-      enqueue(null, node, child, null)
-    }
-  }
-
-  private fun visitClassObj(node: LeakNode) {
-    val classObj = node.instance as ClassObj?
-    val ignoredStaticFields = excludedRefs.staticFieldNameByClassName[classObj!!.className]
-    for ((field, value) in classObj.staticFieldValues) {
-      if (field.type != Type.OBJECT) {
-        continue
-      }
-      val fieldName = field.name
-      if (fieldName == "\$staticOverhead") {
-        continue
-      }
-      val child = value as Instance?
-      var visit = true
-      val leakReference = LeakReference(STATIC_FIELD, fieldName)
-      if (ignoredStaticFields != null) {
-        val params = ignoredStaticFields[fieldName]
-        if (params != null) {
-          visit = false
-          if (!params.alwaysExclude) {
-            enqueue(params, node, child, leakReference)
-          }
-        }
-      }
-      if (visit) {
-        enqueue(null, node, child, leakReference)
-      }
-    }
-  }
-
-  private fun visitClassInstance(node: LeakNode) {
-    val classInstance = node.instance as ClassInstance?
-    val ignoredFields = LinkedHashMap<String, PerflibExclusion>()
-    var superClassObj: ClassObj? = classInstance!!.classObj
-    var classExclusion: PerflibExclusion? = null
-    while (superClassObj != null) {
-      val params = excludedRefs.classNames[superClassObj.className]
-      if (params != null) {
-        // true overrides null or false.
-        if (classExclusion == null || !classExclusion.alwaysExclude) {
-          classExclusion = params
-        }
-      }
-      val classIgnoredFields = excludedRefs.fieldNameByClassName[superClassObj.className]
-      if (classIgnoredFields != null) {
-        ignoredFields.putAll(classIgnoredFields)
-      }
-      superClassObj = superClassObj.superClassObj
-    }
-
-    if (classExclusion != null && classExclusion.alwaysExclude) {
-      return
-    }
-
-    val values = classInstance.values
-    values.sortBy { it.field.name }
-    for (fieldValue in values) {
-      var fieldExclusion = classExclusion
-      val field = fieldValue.field
-      if (field.type != Type.OBJECT) {
-        continue
-      }
-      val child = fieldValue.value as Instance?
-      val fieldName = field.name
-      val params = ignoredFields[fieldName]
-      // If we found a field exclusion and it's stronger than a class exclusion
-      if (params != null && (fieldExclusion == null || params.alwaysExclude && !fieldExclusion.alwaysExclude)) {
-        fieldExclusion = params
-      }
-      enqueue(
-          fieldExclusion, node, child,
-          LeakReference(INSTANCE_FIELD, fieldName)
-      )
-    }
-  }
-
-  private fun visitArrayInstance(node: LeakNode) {
-    val arrayInstance = node.instance as ArrayInstance
-    if (arrayInstance.arrayType == Type.OBJECT) {
-      val values = arrayInstance.values
-      for (i in values.indices) {
-        val child = values[i] as Instance?
-        val name = Integer.toString(i)
-        enqueue(null, node, child, LeakReference(ARRAY_ENTRY, name))
-      }
-    }
-  }
-
-  private fun enqueue(
-    exclusion: PerflibExclusion?,
-    parent: LeakNode?,
-    child: Instance?,
-    leakReference: LeakReference?
-  ) {
-    if (child == null) {
-      return
-    }
-    if (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) {
-      return
-    }
-    if (ignoreStrings && isString(child)) {
-      return
-    }
-    // Whether we want to visit now or later, we should skip if this is already to visit.
-    if (toVisitSet.contains(child)) {
-      return
-    }
-    val visitNow = exclusion == null
-    if (!visitNow && toVisitIfNoPathSet.contains(child)) {
-      return
-    }
-    if (visitedSet.contains(child)) {
-      return
-    }
-    val childNode = LeakNode(exclusion, child, parent, leakReference)
-    if (visitNow) {
-      toVisitSet.add(child)
-      toVisitQueue.add(childNode)
-    } else {
-      toVisitIfNoPathSet.add(child)
-      toVisitIfNoPathQueue.add(childNode)
-    }
-  }
-
-  private fun isString(instance: Instance): Boolean {
-    return instance.classObj != null && instance.classObj
-        .className == String::class.java.name
-  }
-}
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/AsyncTaskLeakTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/AsyncTaskLeakTest.kt
deleted file mode 100644
index 0e2e4b9a..00000000
--- a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/AsyncTaskLeakTest.kt
+++ /dev/null
@@ -1,97 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.PerflibExcludedRefs
-import leakcanary.PerflibExcludedRefs.BuilderWithParams
-import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
-import leakcanary.internal.HeapDumpFile.ASYNC_TASK_M
-import leakcanary.internal.HeapDumpFile.ASYNC_TASK_O
-import leakcanary.internal.HeapDumpFile.ASYNC_TASK_PRE_M
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.junit.runners.Parameterized
-import java.lang.ref.PhantomReference
-import java.lang.ref.WeakReference
-import java.util.Arrays
-
-@RunWith(Parameterized::class)
-internal class AsyncTaskLeakTest(private val heapDumpFile: HeapDumpFile) {
-
-  private lateinit var excludedRefs: BuilderWithParams
-
-  @Before
-  fun setUp() {
-    excludedRefs = PerflibExcludedRefs.builder()
-        .clazz(WeakReference::class.java.name)
-        .alwaysExclude()
-        .clazz("java.lang.ref.FinalizerReference")
-        .alwaysExclude()
-        .clazz(PhantomReference::class.java.name)
-        .alwaysExclude()
-  }
-
-  @Test
-  fun leakFound() {
-    val result = analyze(heapDumpFile, excludedRefs)
-    assertThat(result.leakFound).isTrue()
-    assertThat(result.excludedLeak).isFalse()
-    val gcRoot = result.leakTrace!!.elements[0]
-    assertThat(Thread::class.java.name).isEqualTo(gcRoot.className)
-    assertThat(THREAD).isEqualTo(gcRoot.holder)
-  }
-
-  @Test
-  fun excludeThread() {
-    excludedRefs.thread(ASYNC_TASK_THREAD)
-    val result = analyze(heapDumpFile, excludedRefs)
-    assertThat(result.leakFound).isTrue()
-    assertThat(result.excludedLeak).isFalse()
-    val gcRoot = result.leakTrace!!.elements[0]
-    assertThat(ASYNC_TASK_CLASS).isEqualTo(gcRoot.className)
-    assertThat(STATIC_FIELD).isEqualTo(gcRoot.reference!!.type)
-    assertThat(
-        gcRoot.reference!!.name == EXECUTOR_FIELD_1 || gcRoot.reference!!.name == EXECUTOR_FIELD_2
-    ).isTrue()
-  }
-
-  @Test
-  fun excludeStatic() {
-    excludedRefs.thread(ASYNC_TASK_THREAD)
-    excludedRefs.staticField(
-        ASYNC_TASK_CLASS,
-        EXECUTOR_FIELD_1
-    )
-    excludedRefs.staticField(
-        ASYNC_TASK_CLASS,
-        EXECUTOR_FIELD_2
-    )
-    val result = analyze(heapDumpFile, excludedRefs)
-    assertThat(result.leakFound).isTrue()
-    assertThat(result.excludedLeak).isTrue()
-    val elements = result.leakTrace!!.elements
-    val exclusion = elements[0].exclusion
-
-    val expectedExclusions = Arrays.asList(
-        "any threads named $ASYNC_TASK_THREAD",
-        "static field $ASYNC_TASK_CLASS#$EXECUTOR_FIELD_1",
-        "static field $ASYNC_TASK_CLASS#$EXECUTOR_FIELD_2"
-    )
-    assertThat(expectedExclusions.contains(exclusion!!.matching)).isTrue()
-  }
-
-  companion object {
-    private const val ASYNC_TASK_THREAD = "AsyncTask #1"
-    private const val ASYNC_TASK_CLASS = "android.os.AsyncTask"
-    private const val EXECUTOR_FIELD_1 = "SERIAL_EXECUTOR"
-    private const val EXECUTOR_FIELD_2 = "sDefaultExecutor"
-    @JvmStatic
-    @Parameterized.Parameters
-    fun data() = listOf(
-        arrayOf(ASYNC_TASK_PRE_M),
-        arrayOf(ASYNC_TASK_M),
-        arrayOf(ASYNC_TASK_O)
-    )
-  }
-}
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/FakeDataBuffer.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/FakeDataBuffer.kt
deleted file mode 100644
index 4ab531f2..00000000
--- a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/FakeDataBuffer.kt
+++ /dev/null
@@ -1,94 +0,0 @@
-package leakcanary.internal
-
-import com.android.tools.perflib.captures.DataBuffer
-import java.io.UnsupportedEncodingException
-
-class FakeDataBuffer(private val stringCharset: String = PRE_O_CHARSET) : DataBuffer {
-
-  private var intsToRead: IntArray? = null
-  private var intIndex = -1
-  private var stringsToRead: Array<out String?>? = null
-  private var stringIndex = -1
-
-  fun setIntsToRead(vararg ints: Int) {
-    intsToRead = ints
-    intIndex = 0
-  }
-
-  fun setStringsToRead(vararg strings: String?) {
-    stringsToRead = strings
-    stringIndex = 0
-  }
-
-  override fun readByte(): Byte {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun dispose() {}
-
-  override fun read(bytes: ByteArray) {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun readSubSequence(
-    bytes: ByteArray,
-    start: Int,
-    length: Int
-  ) {
-    if (stringsToRead == null || stringIndex < 0 || stringIndex >= stringsToRead!!.size) {
-      throw UnsupportedOperationException("no bytes to read")
-    }
-
-    val s = stringsToRead!![stringIndex++]
-    try {
-      System.arraycopy(s!!.toByteArray(charset(stringCharset)), start, bytes, 0, length)
-    } catch (e: UnsupportedEncodingException) {
-      throw UnsupportedOperationException(e)
-    }
-  }
-
-  override fun readChar(): Char {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun readShort(): Short {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun readInt(): Int {
-    if (intsToRead == null || intIndex < 0 || intIndex >= intsToRead!!.size) {
-      throw UnsupportedOperationException("no bytes to read")
-    }
-    return intsToRead!![intIndex++]
-  }
-
-  override fun readLong(): Long {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun readFloat(): Float {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun readDouble(): Double {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun setPosition(l: Long) {}
-
-  override fun position(): Long {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun hasRemaining(): Boolean {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  override fun remaining(): Long {
-    throw UnsupportedOperationException("no bytes to read")
-  }
-
-  companion object {
-    private val PRE_O_CHARSET = "UTF-16BE"
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HahaHelperTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HahaHelperTest.kt
deleted file mode 100644
index ae80e771..00000000
--- a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HahaHelperTest.kt
+++ /dev/null
@@ -1,182 +0,0 @@
-package leakcanary.internal
-
-import com.android.tools.perflib.captures.DataBuffer
-import com.squareup.haha.perflib.ArrayInstance
-import com.squareup.haha.perflib.ClassInstance
-import com.squareup.haha.perflib.ClassObj
-import com.squareup.haha.perflib.Field
-import com.squareup.haha.perflib.Snapshot
-import com.squareup.haha.perflib.Type
-import leakcanary.internal.perflib.HahaHelper
-import org.junit.Assert.assertTrue
-import org.junit.Assert.fail
-import org.junit.Before
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.junit.runners.JUnit4
-
-@RunWith(JUnit4::class)
-class HahaHelperTest {
-
-  private lateinit var buffer: FakeDataBuffer
-  private lateinit var snapshot: Snapshot
-
-  @Before
-  fun setUp() {
-    buffer = FakeDataBuffer()
-    initSnapshot(buffer)
-  }
-
-  private fun initSnapshot(buffer: DataBuffer) {
-    snapshot = Snapshot(buffer)
-    // set HPROF identifier size; required for Object instance field lookups
-    // cf. https://java.net/downloads/heap-snapshot/hprof-binary-format.html
-    snapshot.setIdSize(4)
-  }
-
-  @Test fun readStringOffsetFromHeapDumpInstance_pre_O() {
-    buffer.setIntsToRead(
-        COUNT_VALUE,
-        OFFSET_VALUE,
-        VALUE_ARRAY_INSTANCE_ID
-    )
-    buffer.setStringsToRead("abcdef")
-
-    addStringClassToSnapshotWithFields(
-        snapshot,
-        arrayOf(Field(Type.INT, "count"), Field(Type.INT, "offset"), Field(Type.OBJECT, "value"))
-    )
-
-    val stringInstance = createStringInstance()
-    createCharArrayValueInstance()
-
-    val actual = HahaHelper.asString(stringInstance)
-    assertTrue(actual == "bcdef")
-  }
-
-  @Test fun defaultToZeroStringOffsetWhenHeapDumpInstanceIsMissingOffsetValue_pre_O() {
-    buffer.setIntsToRead(
-        COUNT_VALUE,
-        VALUE_ARRAY_INSTANCE_ID
-    )
-    buffer.setStringsToRead("abcdef")
-
-    addStringClassToSnapshotWithFields(
-        snapshot, arrayOf(Field(Type.INT, "count"), Field(Type.OBJECT, "value"))
-    )
-
-    val stringInstance = createStringInstance()
-    createCharArrayValueInstance()
-
-    val actual = HahaHelper.asString(stringInstance)
-    assertTrue(actual == "abcde")
-  }
-
-  @Test fun readStringAsByteArrayFromHeapDumpInstance_O() {
-    // O uses default charset UTF-8
-    buffer = FakeDataBuffer("UTF-8")
-    initSnapshot(buffer)
-
-    buffer.setIntsToRead(
-        COUNT_VALUE,
-        VALUE_ARRAY_INSTANCE_ID
-    )
-    buffer.setStringsToRead("abcdef")
-
-    addStringClassToSnapshotWithFields_O(
-        snapshot, arrayOf(Field(Type.INT, "count"), Field(Type.OBJECT, "value"))
-    )
-
-    val stringInstance = createStringInstance()
-    createByteArrayValueInstance()
-
-    val actual = HahaHelper.asString(stringInstance)
-    assertTrue(actual == "abcde")
-  }
-
-  @Test fun throwExceptionWhenNotArrayValueForString() {
-    buffer.setIntsToRead(
-        COUNT_VALUE,
-        OFFSET_VALUE,
-        VALUE_ARRAY_INSTANCE_ID
-    )
-    buffer.setStringsToRead("abcdef")
-
-    addStringClassToSnapshotWithFields(
-        snapshot,
-        arrayOf(Field(Type.INT, "count"), Field(Type.INT, "offset"), Field(Type.OBJECT, "value"))
-    )
-
-    val stringInstance = createStringInstance()
-    createObjectValueInstance()
-
-    try {
-      HahaHelper.asString(stringInstance)
-      fail("this test should have thrown UnsupportedOperationException")
-    } catch (uoe: UnsupportedOperationException) {
-      val message = uoe.message
-      assertTrue(message == "Could not find char array in $stringInstance")
-    }
-
-  }
-
-  private fun addStringClassToSnapshotWithFields(
-    snapshot: Snapshot,
-    fields: Array<Field>
-  ) {
-    val charArrayClass = ClassObj(0, null, "char[]", 0)
-    snapshot.addClass(CHAR_ARRAY_CLASS_ID.toLong(), charArrayClass)
-
-    val stringClass = ClassObj(0, null, "string", 0)
-    stringClass.fields = fields
-    snapshot.addClass(STRING_CLASS_ID.toLong(), stringClass)
-  }
-
-  private fun addStringClassToSnapshotWithFields_O(
-    snapshot: Snapshot,
-    fields: Array<Field>
-  ) {
-    val byteArrayClass = ClassObj(0, null, "byte[]", 0)
-    snapshot.addClass(BYTE_ARRAY_CLASS_ID.toLong(), byteArrayClass)
-
-    val stringClass = ClassObj(0, null, "string", 0)
-    stringClass.fields = fields
-    snapshot.addClass(STRING_CLASS_ID.toLong(), stringClass)
-  }
-
-  private fun createCharArrayValueInstance() {
-    val valueArrayInstance = ArrayInstance(0, null, Type.CHAR,
-        VALUE_ARRAY_LENGTH, 0)
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueArrayInstance)
-  }
-
-  private fun createByteArrayValueInstance() {
-    val valueArrayInstance = ArrayInstance(0, null, Type.BYTE,
-        VALUE_ARRAY_LENGTH, 0)
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueArrayInstance)
-  }
-
-  private fun createObjectValueInstance() {
-    val valueInstance = ClassInstance(0, null, 0)
-    snapshot.addInstance(VALUE_ARRAY_INSTANCE_ID.toLong(), valueInstance)
-  }
-
-  private fun createStringInstance(): ClassInstance {
-    val stringInstance = ClassInstance(
-        STRING_INSTANCE_ID.toLong(), null, 100)
-    stringInstance.setClassId(STRING_CLASS_ID.toLong())
-    snapshot.addInstance(0, stringInstance)
-    return stringInstance
-  }
-
-  companion object {
-    private const val STRING_CLASS_ID = 100
-    private const val CHAR_ARRAY_CLASS_ID = 101
-    private const val STRING_INSTANCE_ID = 102
-    private const val VALUE_ARRAY_INSTANCE_ID = 103
-    private const val BYTE_ARRAY_CLASS_ID = 104
-    private const val VALUE_ARRAY_LENGTH = 6
-    private const val COUNT_VALUE = 5
-    private const val OFFSET_VALUE = 1
-  }
-}
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt
deleted file mode 100644
index 538657cb..00000000
--- a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/HeapAnalyzerPerflibHeapDumpTest.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.LeakingInstance
-import leakcanary.internal.HeapDumpFile.ASYNC_TASK_P
-import leakcanary.internal.HeapDumpFile.GC_ROOT_IN_NON_PRIMARY_HEAP
-import leakcanary.internal.HeapDumpFile.MISSING_THREAD
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Ignore
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.junit.runners.JUnit4
-
-@RunWith(JUnit4::class)
-class HeapAnalyzerPerflibHeapDumpTest {
-
-  @Test @Ignore("Need new heapdump with className in KeyedWeakReference")
-  fun findsExpectedRef() {
-    val retainedInstance = findLeak(ASYNC_TASK_P)!!
-    assertThat(retainedInstance).isInstanceOf(LeakingInstance::class.java)
-    val leak = retainedInstance as LeakingInstance
-    assertThat(leak.exclusionStatus).isNull()
-    assertThat(leak.instanceClassName).isEqualTo("com.example.leakcanary.MainActivity")
-  }
-
-  @Test @Ignore("Need new heapdump with className in KeyedWeakReference")
-  fun findsSeveralRefs() {
-    val heapAnalysis = findAllLeaks(ASYNC_TASK_P)
-    assertThat(heapAnalysis).isInstanceOf(HeapAnalysisSuccess::class.java)
-    val results = heapAnalysis as HeapAnalysisSuccess
-    assertThat(results.retainedInstances).hasSize(3)
-  }
-
-  @Test
-  fun leakFoundWithGcRootInNonPrimaryHeap() {
-    val result = analyze(GC_ROOT_IN_NON_PRIMARY_HEAP)
-    assertThat(result.leakFound).isTrue()
-  }
-
-  @Test
-  fun heapDumpWithMissingNativeThread() {
-    val result = analyze(MISSING_THREAD)
-    assertThat(result.leakFound).isTrue()
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/PerflibHeapAnalyzerTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/PerflibHeapAnalyzerTest.kt
deleted file mode 100644
index 62d5a85e..00000000
--- a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/PerflibHeapAnalyzerTest.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-package leakcanary.internal
-
-import com.squareup.haha.perflib.RootObj
-import com.squareup.haha.perflib.RootType.NATIVE_STATIC
-import com.squareup.haha.perflib.RootType.SYSTEM_CLASS
-import com.squareup.haha.perflib.Snapshot
-import leakcanary.AnalyzerProgressListener
-import leakcanary.internal.perflib.PerflibHeapAnalyzer
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.junit.runners.JUnit4
-import java.util.Arrays.asList
-
-@RunWith(JUnit4::class)
-class PerflibHeapAnalyzerTest {
-
-  private val heapAnalyzer = PerflibHeapAnalyzer(AnalyzerProgressListener.NONE)
-
-  @Test
-  fun ensureUniqueRoots() {
-    val snapshot = createSnapshot(DUP_ROOTS)
-
-    heapAnalyzer.deduplicateGcRoots(snapshot)
-
-    val uniqueRoots = snapshot.gcRoots
-    assertThat(uniqueRoots).hasSize(4)
-
-    val rootIds = mutableListOf<Long>()
-    uniqueRoots.forEach { root ->
-      rootIds.add(root.id)
-    }
-    rootIds.sort()
-
-    // 3 appears twice because even though two RootObjs have the same id, they're different types.
-    assertThat(rootIds).containsExactly(3L, 3L, 5L, 6L)
-  }
-
-  private fun createSnapshot(gcRoots: List<RootObj>): Snapshot {
-    val snapshot = Snapshot(null)
-    for (root in gcRoots) {
-      snapshot.addRoot(root)
-    }
-    return snapshot
-  }
-
-  companion object {
-    private val DUP_ROOTS = asList<RootObj>(
-        RootObj(SYSTEM_CLASS, 6L),
-        RootObj(SYSTEM_CLASS, 5L),
-        RootObj(SYSTEM_CLASS, 3L),
-        RootObj(SYSTEM_CLASS, 5L),
-        RootObj(NATIVE_STATIC, 3L)
-    )
-  }
-}
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/RetainedSizeTest.kt
deleted file mode 100644
index 41a6f443..00000000
--- a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/RetainedSizeTest.kt
+++ /dev/null
@@ -1,35 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.internal.HeapDumpFile.ASYNC_TASK_M
-import leakcanary.internal.HeapDumpFile.ASYNC_TASK_O
-import leakcanary.internal.HeapDumpFile.ASYNC_TASK_PRE_M
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.junit.runners.Parameterized
-
-/**
- * This test makes sure there is no regression on the retained size calculation.
- */
-@RunWith(Parameterized::class)
-internal class RetainedSizeTest(
-  val heapDumpFile: HeapDumpFile,
-  val expectedRetainedHeapSize: Long
-) {
-
-  @Test
-  fun leakFound() {
-    val result = analyze(heapDumpFile)
-    assertThat(result.retainedHeapSize).isEqualTo(expectedRetainedHeapSize)
-  }
-
-  companion object {
-    @JvmStatic
-    @Parameterized.Parameters
-    fun data() = listOf(
-        arrayOf(ASYNC_TASK_PRE_M, 33367),
-        arrayOf(ASYNC_TASK_M, 49584),
-        arrayOf(ASYNC_TASK_O, 210978)
-    )
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/TestUtilPerflib.kt b/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/TestUtilPerflib.kt
deleted file mode 100644
index c514e8aa..00000000
--- a/leakcanary-analyzer-perflib/src/test/java/leakcanary/internal/TestUtilPerflib.kt
+++ /dev/null
@@ -1,119 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.PerflibAnalysisResult
-import leakcanary.AnalyzerProgressListener
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.LeakingInstance
-import leakcanary.PerflibExcludedRefs
-import leakcanary.PerflibExcludedRefs.BuilderWithParams
-import leakcanary.PerflibHeapDump
-import leakcanary.RetainedInstance
-import leakcanary.internal.perflib.PerflibHeapAnalyzer
-import java.io.File
-import java.lang.ref.PhantomReference
-import java.lang.ref.SoftReference
-import java.lang.ref.WeakReference
-
-const val OLD_KEYED_WEAK_REFERENCE_CLASS_NAME = "com.squareup.leakcanary.KeyedWeakReference"
-const val OLD_HEAP_DUMP_MEMORY_STORE_CLASS_NAME = "com.squareup.leakcanary.HeapDumpMemoryStore"
-
-internal enum class HeapDumpFile constructor(
-  val filename: String,
-  val referenceKey: String
-) {
-  ASYNC_TASK_PRE_M("leak_asynctask_pre_m.hprof", "dc983a12-d029-4003-8890-7dd644c664c5"), //
-  ASYNC_TASK_M("leak_asynctask_m.hprof", "25ae1778-7c1d-4ec7-ac50-5cce55424069"), //
-  ASYNC_TASK_O("leak_asynctask_o.hprof", "0e8d40d7-8302-4493-93d5-962a4c176089"),
-  ASYNC_TASK_P("leak_asynctask_p.hprof", "440d4252-8089-41bd-98b2-d7d050323279"),
-  GC_ROOT_IN_NON_PRIMARY_HEAP(
-      "gc_root_in_non_primary_heap.hprof",
-      "10a5bc66-e9cb-430c-930a-fc1dc4fc0f85"
-  ),
-  MISSING_THREAD("missing_thread.hprof", "c644e537-9abd-42e5-994d-032fc150feef")
-}
-
-internal fun fileFromName(filename: String): File {
-  val classLoader = Thread.currentThread()
-      .contextClassLoader
-  val url = classLoader.getResource(filename)
-  return File(url.path)
-}
-
-internal fun findLeak(heapDumpFile: HeapDumpFile): RetainedInstance? {
-  val heapAnalysis = findAllLeaks(heapDumpFile)
-  if (heapAnalysis is HeapAnalysisSuccess) {
-    heapAnalysis.retainedInstances.forEach { retainedInstance ->
-      if (retainedInstance.referenceKey == heapDumpFile.referenceKey) {
-        return retainedInstance
-      }
-    }
-  }
-  return null
-}
-
-internal fun findAllLeaks(heapDumpFile: HeapDumpFile): HeapAnalysis {
-  val file = fileFromName(heapDumpFile.filename)
-  val heapAnalyzer = PerflibHeapAnalyzer(
-      AnalyzerProgressListener.NONE,
-      OLD_KEYED_WEAK_REFERENCE_CLASS_NAME,
-      OLD_HEAP_DUMP_MEMORY_STORE_CLASS_NAME
-  )
-  val heapAnalysis =
-    heapAnalyzer.checkForLeaks(
-        PerflibHeapDump.builder(file).computeRetainedHeapSize(
-            true
-        ).build(), defaultExcludedRefs.build()
-    )
-
-  when (heapAnalysis) {
-    is HeapAnalysisFailure -> heapAnalysis.exception.printStackTrace()
-    is HeapAnalysisSuccess -> {
-      heapAnalysis.retainedInstances.forEach { retainedInstance ->
-        if (retainedInstance is LeakingInstance) {
-          println(retainedInstance.leakTrace)
-        }
-      }
-    }
-  }
-  return heapAnalysis
-}
-
-internal fun analyze(
-  heapDumpFile: HeapDumpFile,
-  excludedRefs: BuilderWithParams = defaultExcludedRefs
-): PerflibAnalysisResult {
-  val file = fileFromName(heapDumpFile.filename)
-  val referenceKey = heapDumpFile.referenceKey
-  val heapAnalyzer =
-    PerflibHeapAnalyzer(
-        AnalyzerProgressListener.NONE, OLD_KEYED_WEAK_REFERENCE_CLASS_NAME,
-        OLD_HEAP_DUMP_MEMORY_STORE_CLASS_NAME
-    )
-  val heapDump = PerflibHeapDump.builder(file)
-      .computeRetainedHeapSize(true)
-      .build()
-  val result = heapAnalyzer.checkForLeak(heapDump, excludedRefs.build(), referenceKey)
-  result.failure?.printStackTrace()
-  if (result.leakTrace != null) {
-    System.out.println(result.leakTrace)
-  }
-  return result
-}
-
-private val defaultExcludedRefs = PerflibExcludedRefs.builder()
-    .clazz(WeakReference::class.java.name)
-    .alwaysExclude()
-    .clazz(SoftReference::class.java.name)
-    .alwaysExclude()
-    .clazz(PhantomReference::class.java.name)
-    .alwaysExclude()
-    .clazz("java.lang.ref.Finalizer")
-    .alwaysExclude()
-    .clazz("java.lang.ref.FinalizerReference")
-    .alwaysExclude()
-    .thread("FinalizerWatchdogDaemon")
-    .alwaysExclude()
-    .thread("main")
-    .alwaysExclude()
diff --git a/leakcanary-analyzer-perflib/src/test/resources/gc_root_in_non_primary_heap.hprof b/leakcanary-analyzer-perflib/src/test/resources/gc_root_in_non_primary_heap.hprof
deleted file mode 100644
index 7ca6d0bc..00000000
Binary files a/leakcanary-analyzer-perflib/src/test/resources/gc_root_in_non_primary_heap.hprof and /dev/null differ
diff --git a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_m.hprof b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_m.hprof
deleted file mode 100644
index 6945c82d..00000000
Binary files a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_m.hprof and /dev/null differ
diff --git a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_o.hprof b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_o.hprof
deleted file mode 100644
index 1c62d0e5..00000000
Binary files a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_o.hprof and /dev/null differ
diff --git a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_p.hprof b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_p.hprof
deleted file mode 100644
index 651827f5..00000000
Binary files a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_p.hprof and /dev/null differ
diff --git a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_pre_m.hprof b/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_pre_m.hprof
deleted file mode 100644
index a1d60adc..00000000
Binary files a/leakcanary-analyzer-perflib/src/test/resources/leak_asynctask_pre_m.hprof and /dev/null differ
diff --git a/leakcanary-analyzer-perflib/src/test/resources/missing_thread.hprof b/leakcanary-analyzer-perflib/src/test/resources/missing_thread.hprof
deleted file mode 100644
index 4f37b45f..00000000
Binary files a/leakcanary-analyzer-perflib/src/test/resources/missing_thread.hprof and /dev/null differ
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
index 739a5eaf..c6ea86bf 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/Exclusion.kt
@@ -47,11 +47,14 @@ data class Exclusion(
   sealed class ExclusionType {
     abstract val matching: String
 
-    class ThreadExclusion(
+    /**
+     * Local references held in the stack of frames of a given thread.
+     */
+    class JavaLocalExclusion(
       val threadName: String
     ) : ExclusionType() {
       override val matching: String
-        get() = "any threads named $threadName"
+        get() = "local variable on thread $threadName"
     }
 
     class StaticFieldExclusion(
@@ -62,6 +65,12 @@ data class Exclusion(
         get() = "static field $className#$fieldName"
     }
 
+    /**
+     * Excludes a member field of an instance of a class. [fieldName] can belong to a superclass
+     * and will still match for subclasses. This is to support overriding of rules for specific
+     * cases. If two exclusions for the same field name but different classname match in a class
+     * hierarchy, then the closest class in the hierarchy wins.
+     */
     class InstanceFieldExclusion(
       val className: String,
       val fieldName: String
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
index fccdfb44..ca2d78e7 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
@@ -31,6 +31,7 @@ import leakcanary.GcRoot.NativeStack
 import leakcanary.GcRoot.ReferenceCleanup
 import leakcanary.GcRoot.StickyClass
 import leakcanary.GcRoot.ThreadBlock
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HprofParser.RecordCallbacks
 import leakcanary.LeakNode.ChildNode
 import leakcanary.LeakNodeStatus.LEAKING
@@ -153,7 +154,7 @@ class HeapAnalyzer constructor(
   }
 
   private data class ScanResult(
-    val gcRootIds: MutableList<Long>,
+    val gcRootIds: MutableList<GcRoot>,
     val keyedWeakReferenceInstances: List<InstanceDumpRecord>,
     val cleaners: MutableList<Long>
   )
@@ -163,7 +164,7 @@ class HeapAnalyzer constructor(
     computeRetainedSize: Boolean
   ): ScanResult {
     val keyedWeakReferenceInstances = mutableListOf<InstanceDumpRecord>()
-    val gcRootIds = mutableListOf<Long>()
+    val gcRoot = mutableListOf<GcRoot>()
     val cleaners = mutableListOf<Long>()
     val callbacks = RecordCallbacks()
         .on(InstanceDumpRecord::class.java) { record ->
@@ -173,12 +174,14 @@ class HeapAnalyzer constructor(
           }
         }
         .on(GcRootRecord::class.java) {
-          // TODO Why is ThreadObject ignored?
           // TODO Ignoring VmInternal because we've got 150K of it, but is this the right thing
           // to do? What's VmInternal exactly? History does not go further than
           // https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
           // We should log to figure out what objects VmInternal points to.
           when (it.gcRoot) {
+            // ThreadObject points to threads, which we need to find the thread that a JavaLocalExclusion
+            // belongs to
+            is ThreadObject,
             is JniGlobal,
             is JniLocal,
             is JavaFrame,
@@ -190,12 +193,12 @@ class HeapAnalyzer constructor(
             is ReferenceCleanup,
             is JniMonitor
             -> {
-              gcRootIds.add(it.gcRoot.id)
+              gcRoot.add(it.gcRoot)
             }
           }
         }
     parser.scan(callbacks)
-    return ScanResult(gcRootIds, keyedWeakReferenceInstances, cleaners)
+    return ScanResult(gcRoot, keyedWeakReferenceInstances, cleaners)
   }
 
   private fun readHeapDumpMemoryStore(
@@ -252,7 +255,7 @@ class HeapAnalyzer constructor(
     parser: HprofParser,
     exclusionsFactory: ExclusionsFactory,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<Long>,
+    gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean
   ): Results {
     val pathFinder = ShortestPathFinder()
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
index 0a59b875..60ef3694 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/LeakNode.kt
@@ -6,11 +6,9 @@ sealed class LeakNode {
   abstract val visitOrder: Int
 
   class RootNode(
-    override val instance: Long
-  ) : LeakNode() {
-    override val visitOrder
-      get() = 0
-  }
+    override val instance: Long,
+    override val visitOrder: Int
+  ) : LeakNode()
 
   class ChildNode(
     override val instance: Long,
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
index 07343142..8c71ac30 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
@@ -57,7 +57,7 @@ private fun getNextElementString(
   val simpleClassName = element.simpleClassName
   val referenceName = if (element.reference != null) ".${element.reference.displayName}" else ""
   val exclusionString =
-    if (element.exclusion != null) " , matching exclusion ${element.exclusion.matching}" else ""
+    if (element.exclusion != null) ", matching exclusion ${element.exclusion.matching}" else ""
   val requiredSpaces =
     staticString.length + holderString.length + simpleClassName.length + "├─".length
   val leakString = if (maybeLeakCause) {
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
index e5441abc..0501a9cb 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
@@ -19,13 +19,16 @@ import leakcanary.AnalyzerProgressListener
 import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
 import leakcanary.AnalyzerProgressListener.Step.FINDING_SHORTEST_PATHS
 import leakcanary.Exclusion
+import leakcanary.Exclusion.ExclusionType
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.ExclusionType.ThreadExclusion
 import leakcanary.Exclusion.Status
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.ExclusionsFactory
+import leakcanary.GcRoot
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HeapValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofParser
@@ -35,9 +38,12 @@ import leakcanary.LeakNode.RootNode
 import leakcanary.LeakReference
 import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
 import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
+import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import leakcanary.ObjectIdMetadata.CLASS
 import leakcanary.ObjectIdMetadata.EMPTY_INSTANCE
+import leakcanary.ObjectIdMetadata.INSTANCE
+import leakcanary.ObjectIdMetadata.OBJECT_ARRAY
 import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_ARRAY
 import leakcanary.ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
 import leakcanary.ObjectIdMetadata.STRING
@@ -106,7 +112,7 @@ internal class ShortestPathFinder {
     parser: HprofParser,
     exclusionsFactory: ExclusionsFactory,
     leakingWeakRefs: List<KeyedWeakReferenceMirror>,
-    gcRootIds: MutableList<Long>,
+    gcRootIds: MutableList<GcRoot>,
     computeDominators: Boolean,
     listener: AnalyzerProgressListener
   ): Results {
@@ -115,14 +121,13 @@ internal class ShortestPathFinder {
 
     val fieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
     val staticFieldNameByClassName = mutableMapOf<String, MutableMap<String, Exclusion>>()
-    // TODO Use thread name exclusions
     val threadNames = mutableMapOf<String, Exclusion>()
 
     exclusionsFactory(parser)
         .forEach { exclusion ->
 
           when (exclusion.type) {
-            is ThreadExclusion -> {
+            is ExclusionType.JavaLocalExclusion -> {
               threadNames[exclusion.type.threadName] = exclusion
             }
             is StaticFieldExclusion -> {
@@ -149,8 +154,7 @@ internal class ShortestPathFinder {
     // Referent object id to weak ref mirror
     referentMap = leakingWeakRefs.associateBy { it.referent.value }
 
-    enqueueGcRoots(parser, gcRootIds, computeDominators)
-    gcRootIds.clear()
+    enqueueGcRoots(parser, gcRootIds, threadNames, computeDominators)
 
     var lowestPriority = ALWAYS_REACHABLE
     val results = mutableListOf<Result>()
@@ -221,21 +225,83 @@ internal class ShortestPathFinder {
   }
 
   private fun enqueueGcRoots(
-    hprofParser: HprofParser,
-    gcRootIds: List<Long>,
+    parser: HprofParser,
+    gcRoots: MutableList<GcRoot>,
+    threadNameExclusions: Map<String, Exclusion>,
     computeDominators: Boolean
   ) {
-    // TODO sort GC roots based on type and class name (for class / instance / array)
-    // Goal is to get a stable shortest path
-    // TODO Add root type so that for java local we could exclude specific threads.
-    // TODO java local: exclude specific threads,
-    // TODO java local: parent should be set to the allocated thread
-    gcRootIds.forEach {
+    gcRoots.removeAll { it.id == 0L }
+
+    // Sorting GC roots to get stable shortest path
+    // Once sorted all ThreadObject Gc Roots are located before JavaLocalExclusion Gc Roots.
+    // This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
+    // built before JavaFrames.
+    sortGcRoots(parser, gcRoots)
+
+    val threadsBySerialNumber = mutableMapOf<Int, ThreadObject>()
+    gcRoots.forEach { gcRoot ->
       if (computeDominators) {
-        undominateWithSkips(hprofParser, it)
+        undominateWithSkips(parser, gcRoot.id)
+      }
+      when (gcRoot) {
+        is ThreadObject -> {
+          threadsBySerialNumber[gcRoot.threadSerialNumber] = gcRoot
+          enqueue(parser, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
+        }
+        is JavaFrame -> with(parser) {
+          val threadRoot = threadsBySerialNumber.getValue(gcRoot.threadSerialNumber)
+          val threadInstance = threadRoot.id.objectRecord.hydratedInstance
+          val threadName = threadInstance["name"].reference.stringOrNull
+          val exclusion = threadNameExclusions[threadName]
+
+          if (exclusion == null || exclusion.status != NEVER_REACHABLE) {
+            // visitOrder is unused as this root node isn't enqueued.
+            val rootNode = RootNode(threadRoot.id, visitOrder = 0)
+            // TODO #1352 Instead of <Java Local>, it should be <local variable in Foo.bar()>
+            // We should also add the full stacktrace as a label of thread objects
+            val leakReference = LeakReference(LOCAL, "")
+            enqueue(
+                parser,
+                ChildNode(gcRoot.id, visitOrder++, exclusion?.description, rootNode, leakReference),
+                exclusionPriority = exclusion?.status
+            )
+          }
+        }
+        else -> enqueue(parser, RootNode(gcRoot.id, visitOrder++), exclusionPriority = null)
       }
-      enqueue(hprofParser, RootNode(it), exclusionPriority = null)
     }
+    gcRoots.clear()
+  }
+
+  private fun sortGcRoots(
+    parser: HprofParser,
+    gcRoots: MutableList<GcRoot>
+  ) {
+    val rootClassName: (GcRoot) -> String = {
+      when (val metadata = parser.objectIdMetadata(it.id)) {
+        PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY, PRIMITIVE_WRAPPER_ARRAY, EMPTY_INSTANCE -> metadata.name
+        STRING -> "java.lang.String"
+        OBJECT_ARRAY -> {
+          val record = parser.retrieveRecordById(it.id) as ObjectArrayDumpRecord
+          parser.className(record.arrayClassId)
+        }
+        INSTANCE -> {
+          val record = parser.retrieveRecordById(it.id) as InstanceDumpRecord
+          parser.className(record.classId)
+        }
+        CLASS -> parser.className(it.id)
+        else -> throw IllegalStateException("Unexpected type $metadata")
+      }
+    }
+    gcRoots.sortWith(Comparator { root1, root2 ->
+      // Sorting based on type name first. In reverse order so that ThreadObject is before JavaLocalExclusion
+      val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
+      if (gcRootTypeComparison != 0) {
+        gcRootTypeComparison
+      } else {
+        rootClassName(root1).compareTo(rootClassName(root2))
+      }
+    })
   }
 
   private fun visitClassRecord(
@@ -284,7 +350,14 @@ internal class ShortestPathFinder {
     val ignoredFields = LinkedHashMap<String, Exclusion>()
 
     instance.classHierarchy.forEach {
-      ignoredFields.putAll(fieldNameByClassName[it.className] ?: emptyMap())
+      val classExclusions = fieldNameByClassName[it.className]
+      if (classExclusions != null) {
+        for ((fieldName, exclusion) in classExclusions) {
+          if (!ignoredFields.containsKey(fieldName)) {
+            ignoredFields[fieldName] = exclusion
+          }
+        }
+      }
     }
 
     val fieldNamesAndValues = mutableListOf<Pair<String, HeapValue>>()
@@ -333,7 +406,7 @@ internal class ShortestPathFinder {
   }
 
   private fun enqueue(
-    hprofParser: HprofParser,
+    parser: HprofParser,
     node: LeakNode,
     exclusionPriority: Status?
   ) {
@@ -359,7 +432,7 @@ internal class ShortestPathFinder {
 
     val isLeakingInstance = referentMap[node.instance] != null
 
-    val objectIdMetadata = hprofParser.objectIdMetadata(node.instance)
+    val objectIdMetadata = parser.objectIdMetadata(node.instance)
     if (!isLeakingInstance && objectIdMetadata in SKIP_ENQUEUE) {
       return
     }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
index f89e2d80..9690bdbe 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/ExclusionTest.kt
@@ -2,9 +2,13 @@ package leakcanary.internal
 
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
+import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
+import leakcanary.Exclusion.Status.WONT_FIX_LEAK
 import leakcanary.HeapAnalysisSuccess
+import leakcanary.KeyedWeakReference
 import leakcanary.LeakingInstance
 import leakcanary.NoPathToInstance
 import org.assertj.core.api.Assertions.assertThat
@@ -13,6 +17,7 @@ import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import java.io.File
+import java.lang.ref.WeakReference
 
 class ExclusionTest {
 
@@ -52,7 +57,7 @@ class ExclusionTest {
     }
 
     val leak = analysis.retainedInstances[0] as LeakingInstance
-    assertThat(leak.exclusionStatus).isEqualTo(Exclusion.Status.WONT_FIX_LEAK)
+    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
     assertThat(leak.leakTrace.elements).hasSize(2)
     assertThat(leak.leakTrace.elements[0].className).isEqualTo("GcRoot")
     assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("shortestPath")
@@ -68,7 +73,60 @@ class ExclusionTest {
           Exclusion(InstanceFieldExclusion("HasLeaking", "leaking"), status = NEVER_REACHABLE)
       )
     }
+    assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
+  }
+
+  @Test fun excludedThread() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
+      listOf(Exclusion(JavaLocalExclusion("kroutine"), status = WONT_FIX_LEAK))
+    }
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.exclusionStatus).isEqualTo(WONT_FIX_LEAK)
+  }
+
+  @Test fun weaklyReachableExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
+      listOf(
+          Exclusion(
+              type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+              status = WEAKLY_REACHABLE
+          )
+      )
+    }
 
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.exclusionStatus).isEqualTo(WEAKLY_REACHABLE)
+  }
+
+  @Test fun overrideSuperclassExclusion() {
+    hprofFile.dump {
+      "GcRoot" clazz {
+        staticField["ref"] =
+          keyedWeakReference(className = "Leaking", referentInstanceId = "Leaking" instance {})
+      }
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess> {
+      listOf(
+          Exclusion(
+              type = InstanceFieldExclusion(WeakReference::class.java.name, "referent"),
+              status = WEAKLY_REACHABLE
+          ), Exclusion(
+          type = InstanceFieldExclusion(KeyedWeakReference::class.java.name, "referent"),
+          status = NEVER_REACHABLE
+      )
+      )
+    }
     assertThat(analysis.retainedInstances[0]).isInstanceOf(NoPathToInstance::class.java)
   }
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
index e7a0450a..75b9c6d7 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
@@ -1,8 +1,11 @@
 package leakcanary.internal
 
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HeapAnalysis
 import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalysisSuccess
+import leakcanary.HeapValue.ObjectReference
+import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakingInstance
 import leakcanary.NoPathToInstance
 import leakcanary.WeakReferenceCleared
@@ -90,8 +93,7 @@ class HeapAnalyzerTest {
     assertThat(analysis).isInstanceOf(HeapAnalysisFailure::class.java)
   }
 
-  @Test
-  fun findMultipleLeaks() {
+  @Test fun findMultipleLeaks() {
     hprofFile.writeMultipleActivityLeaks(5)
 
     val leaks = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
@@ -99,4 +101,43 @@ class HeapAnalyzerTest {
     assertThat(leaks.retainedInstances).hasSize(5)
         .hasOnlyElementsOfType(LeakingInstance::class.java)
   }
+
+  @Test fun localVariableLeak() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
+    assertThat(leak.leakTrace.elements[0].reference!!.type).isEqualTo(LOCAL)
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
+  @Test fun threadFieldLeak() {
+    hprofFile.dump {
+      val threadClassId =
+        clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
+      val myThreadClassId = clazz(
+          className = "MyThread", superClassId = threadClassId,
+          fields = listOf("leaking" to ObjectReference::class)
+      )
+      val threadInstance =
+        instance(myThreadClassId, listOf("Leaking" watchedInstance {}, string("Thread Name")))
+      gcRoot(
+          ThreadObject(
+              id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+          )
+      )
+    }
+
+    val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>()
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+    assertThat(leak.leakTrace.elements).hasSize(2)
+    assertThat(leak.leakTrace.elements[0].className).isEqualTo("MyThread")
+    assertThat(leak.leakTrace.elements[0].reference!!.name).isEqualTo("leaking")
+    assertThat(leak.leakTrace.elements[1].className).isEqualTo("Leaking")
+  }
+
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
index 17e2a2e4..9d61a1e4 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
@@ -1,10 +1,11 @@
 package leakcanary.internal
 
+import leakcanary.GcRoot.JavaFrame
+import leakcanary.GcRoot.ThreadObject
 import leakcanary.HeapValue.BooleanValue
 import leakcanary.HeapValue.ObjectReference
 import leakcanary.HprofWriter
 import java.io.File
-import kotlin.jvm.internal.Ref.ObjectRef
 
 fun File.writeWeakReferenceCleared() {
   HprofWriter.open(this)
@@ -116,4 +117,24 @@ fun File.writeMultipleActivityLeaks(leakCount: Int) {
           keyedWeakReference("com.example.ExampleActivity", instanceId)
         }
       }
+}
+
+fun File.writeJavaLocalLeak(
+  threadClass: String,
+  threadName: String
+) {
+  dump {
+    val threadClassId =
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
+    val myThreadClassId = clazz(className = threadClass, superClassId = threadClassId)
+    val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
+    gcRoot(
+        ThreadObject(
+            id = threadInstance.value, threadSerialNumber = 42, stackTraceSerialNumber = 0
+        )
+    )
+
+    val leaking = "Leaking" watchedInstance {}
+    gcRoot(JavaFrame(id = leaking.value, threadSerialNumber = 42, frameNumber = 0))
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
index a5097712..bf68c267 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
@@ -1,5 +1,6 @@
 package leakcanary.internal
 
+import leakcanary.GcRoot
 import leakcanary.GcRoot.StickyClass
 import leakcanary.HeapDumpMemoryStore
 import leakcanary.HeapValue
@@ -126,11 +127,16 @@ class HprofWriterHelper constructor(
     )
     classDumps[loadClass.id] = classDump
     writer.write(classDump)
-    val gcRootRecord = GcRootRecord(gcRoot = StickyClass(classDump.id))
-    writer.write(gcRootRecord)
+    val gcRoot = StickyClass(classDump.id)
+    gcRoot(gcRoot)
     return classDump.id
   }
 
+  fun gcRoot(gcRoot: GcRoot) {
+    val gcRootRecord = GcRootRecord(gcRoot = gcRoot)
+    writer.write(gcRootRecord)
+  }
+
   fun arrayClass(className: String): Long {
     return clazz(className = "$className[]")
   }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
similarity index 69%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/LabelTest.kt
rename to leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
index 20922dbc..46350e3c 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelTest.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
@@ -2,7 +2,9 @@ package leakcanary.internal
 
 import leakcanary.HeapAnalysisSuccess
 import leakcanary.HprofParser
+import leakcanary.InstanceDefaultLabeler
 import leakcanary.LeakNode
+import leakcanary.LeakTraceElement.Type.LOCAL
 import leakcanary.LeakingInstance
 import leakcanary.ObjectIdMetadata.STRING
 import org.assertj.core.api.Assertions.assertThat
@@ -12,7 +14,7 @@ import org.junit.Test
 import org.junit.rules.TemporaryFolder
 import java.io.File
 
-class LabelTest {
+class LabelerTest {
 
   @get:Rule
   var testFolder = TemporaryFolder()
@@ -42,4 +44,15 @@ class LabelTest {
     assertThat(leak.leakTrace.elements.last().labels).isEqualTo(listOf("Hello World"))
   }
 
+  @Test fun threadNameLabel() {
+    hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
+
+    val analysis =
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(labelers = listOf(InstanceDefaultLabeler))
+
+    val leak = analysis.retainedInstances[0] as LeakingInstance
+
+    assertThat(leak.leakTrace.elements.first().labels).contains("Thread name: 'kroutine'")
+  }
+
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
index a1a2c24c..bb2aedab 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
@@ -1,18 +1,15 @@
 package leakcanary.internal
 
 import leakcanary.AnalyzerProgressListener
-import leakcanary.CanaryLog
 import leakcanary.Exclusion
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
-import leakcanary.Exclusion.ExclusionType.ThreadExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.ExclusionsFactory
 import leakcanary.LeakInspector
 import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
 import leakcanary.HeapAnalyzer
-import leakcanary.HprofParser
 import leakcanary.KeyedWeakReference
 import leakcanary.Labeler
 import java.io.File
@@ -95,11 +92,11 @@ val defaultExclusionsFactory: ExclusionsFactory = {
       ,
 
       Exclusion(
-          type = ThreadExclusion("FinalizerWatchdogDaemon"),
+          type = JavaLocalExclusion("FinalizerWatchdogDaemon"),
           status = NEVER_REACHABLE
       ),
       Exclusion(
-          type = ThreadExclusion("main"),
+          type = JavaLocalExclusion("main"),
           status = NEVER_REACHABLE
       )
   )
diff --git a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
index 294f2f36..0bab26f7 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt
@@ -31,7 +31,7 @@ import android.os.Build.VERSION_CODES.P
 import leakcanary.AndroidExcludedRefs.Companion.exclusionsFactory
 import leakcanary.Exclusion.ExclusionType.InstanceFieldExclusion
 import leakcanary.Exclusion.ExclusionType.StaticFieldExclusion
-import leakcanary.Exclusion.ExclusionType.ThreadExclusion
+import leakcanary.Exclusion.ExclusionType.JavaLocalExclusion
 import leakcanary.Exclusion.Status.NEVER_REACHABLE
 import leakcanary.Exclusion.Status.WEAKLY_REACHABLE
 import leakcanary.internal.HeapDumpTrigger
@@ -1112,7 +1112,7 @@ enum class AndroidExcludedRefs {
       // reference to the object and it was about to be GCed.
       exclusions.add(
           Exclusion(
-              type = ThreadExclusion("FinalizerWatchdogDaemon"),
+              type = JavaLocalExclusion("FinalizerWatchdogDaemon"),
               status = NEVER_REACHABLE
           )
       )
@@ -1129,7 +1129,7 @@ enum class AndroidExcludedRefs {
       // a real leak.
       exclusions.add(
           Exclusion(
-              type = ThreadExclusion("main"),
+              type = JavaLocalExclusion("main"),
               status = NEVER_REACHABLE
           )
       )
@@ -1143,7 +1143,7 @@ enum class AndroidExcludedRefs {
     ) {
       exclusions.add(
           Exclusion(
-              type = ThreadExclusion(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME),
+              type = JavaLocalExclusion(HeapDumpTrigger.LEAK_CANARY_THREAD_NAME),
               status = NEVER_REACHABLE
           )
       )
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
index 0226a1ae..7e5f37bf 100644
--- a/leakcanary-android-instrumentation/build.gradle
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -2,7 +2,6 @@ apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 
 dependencies {
-  api project(':leakcanary-analyzer-perflib')
   api project(':leakcanary-android-core')
 
   implementation deps.androidx.test.runner
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt
deleted file mode 100644
index e5f11c37..00000000
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/HeapAnalyzerComparisonTest.kt
+++ /dev/null
@@ -1,141 +0,0 @@
-package leakcanary
-
-import android.os.Debug
-import android.os.Handler
-import android.os.Looper
-import android.os.SystemClock
-import androidx.test.platform.app.InstrumentationRegistry
-import leakcanary.AnalyzerProgressListener.Step
-import leakcanary.internal.perflib.PerflibHeapAnalyzer
-import org.junit.Ignore
-import org.junit.Test
-import java.io.File
-import java.util.Date
-import java.util.concurrent.Executor
-
-/**
- * Instrumentation test that runs the two heap analyzer implementations on the same heap
- * dump and logs how they perform. This isn't meant to run as part of the test suite.
- */
-@Ignore
-class HeapAnalyzerComparisonTest {
-
-  @Volatile
-  var firstMaxMemoryUsed = 0L
-
-  @Volatile
-  var secondMaxMemoryUsed = 0L
-
-  @Test fun compareHprofParsers() {
-    leaking = Date()
-
-    val clock = object : Clock {
-      override fun uptimeMillis(): Long {
-        return SystemClock.uptimeMillis()
-      }
-    }
-    val executor = Executor { command -> command.run() }
-    val onReferenceRetained = {}
-    val refWatcher = RefWatcher(clock, executor, onReferenceRetained)
-    refWatcher.watch(leaking)
-
-    val instrumentation = InstrumentationRegistry.getInstrumentation()
-    val context = instrumentation.targetContext
-
-    val heapDumpFile = File(context.filesDir, "HeapAnalyzerComparisonTest.hprof")
-
-    val heapDump = PerflibHeapDump.builder(heapDumpFile)
-        .build()
-
-    SystemClock.sleep(2000)
-
-    val retainedKeys = refWatcher.retainedKeys
-    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
-    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
-
-    Debug.dumpHprofData(heapDumpFile.absolutePath)
-
-    val mainHandler = Handler(Looper.getMainLooper())
-
-    val runtime = Runtime.getRuntime()
-
-    val logMemory: Runnable = object : Runnable {
-      override fun run() {
-        val memoryUsed = runtime.totalMemory() - runtime.freeMemory()
-        CanaryLog.d("Memory: %d Mb", memoryUsed / 1048576L)
-        mainHandler.postDelayed(this, 1000)
-      }
-    }
-    logMemory.run()
-
-    SystemClock.sleep(2000)
-    GcTrigger.Default.runGc()
-    SystemClock.sleep(2000)
-
-    val memoryBeforeFirst = runtime.totalMemory() - runtime.freeMemory()
-
-    val countMemory1: Runnable = object : Runnable {
-      override fun run() {
-        val memoryUsed = runtime.totalMemory() - runtime.freeMemory()
-        firstMaxMemoryUsed = Math.max(firstMaxMemoryUsed, memoryUsed)
-        mainHandler.postDelayed(this, 100)
-      }
-    }
-    countMemory1.run()
-
-    val listener = object : AnalyzerProgressListener {
-      override fun onProgressUpdate(step: Step) {
-        CanaryLog.d("Step %s", step)
-      }
-
-    }
-    CanaryLog.d("Starting first analysis")
-    val firstAnalysis = PerflibHeapAnalyzer(listener).checkForLeaks(
-        heapDump, PerflibAndroidExcludedRefs.createAppDefaults().build()
-    ) as HeapAnalysisSuccess
-    CanaryLog.d("Done with first analysis")
-    val memoryUsedFirstInMb = (firstMaxMemoryUsed - memoryBeforeFirst) / 1048576L
-
-    SystemClock.sleep(2000)
-    GcTrigger.Default.runGc()
-    SystemClock.sleep(2000)
-    val memoryBeforeSecond = runtime.totalMemory() - runtime.freeMemory()
-
-    val countMemory2: Runnable = object : Runnable {
-      override fun run() {
-        val memoryUsed = runtime.totalMemory() - runtime.freeMemory()
-        secondMaxMemoryUsed = Math.max(secondMaxMemoryUsed, memoryUsed)
-        mainHandler.postDelayed(this, 100)
-      }
-    }
-    countMemory2.run()
-
-    val config = LeakCanary.config
-    val secondAnalysis = HeapAnalyzer(listener)
-        .checkForLeaks(
-            heapDumpFile, config.exclusionsFactory, config.computeRetainedHeapSize,
-            config.leakInspectors, config.labelers
-        ) as HeapAnalysisSuccess
-    val memoryUsedSecondInMb = (secondMaxMemoryUsed - memoryBeforeSecond) / 1048576L
-
-    CanaryLog.d(
-        "Perflib analysis used %d Mb took %d ms", memoryUsedFirstInMb,
-        firstAnalysis.analysisDurationMillis
-    )
-    CanaryLog.d(
-        "Random Access analysis used %d Mb took %d ms", memoryUsedSecondInMb,
-        secondAnalysis.analysisDurationMillis
-    )
-
-
-    require(firstAnalysis.retainedInstances.size == 1)
-    require(secondAnalysis.retainedInstances.size == 1)
-
-    firstAnalysis.retainedInstances[0] as LeakingInstance
-    secondAnalysis.retainedInstances[0] as LeakingInstance
-  }
-
-  companion object {
-    private lateinit var leaking: Any
-  }
-}
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/PerflibAndroidExcludedRefs.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/PerflibAndroidExcludedRefs.kt
deleted file mode 100644
index 17c86a1e..00000000
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/PerflibAndroidExcludedRefs.kt
+++ /dev/null
@@ -1,719 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package leakcanary
-
-import android.os.Build.MANUFACTURER
-import android.os.Build.VERSION.SDK_INT
-import android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH
-import android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1
-import android.os.Build.VERSION_CODES.JELLY_BEAN
-import android.os.Build.VERSION_CODES.JELLY_BEAN_MR2
-import android.os.Build.VERSION_CODES.KITKAT
-import android.os.Build.VERSION_CODES.LOLLIPOP
-import android.os.Build.VERSION_CODES.LOLLIPOP_MR1
-import android.os.Build.VERSION_CODES.M
-import android.os.Build.VERSION_CODES.N
-import android.os.Build.VERSION_CODES.N_MR1
-import android.os.Build.VERSION_CODES.O
-import android.os.Build.VERSION_CODES.O_MR1
-import android.os.Build.VERSION_CODES.P
-import java.lang.ref.PhantomReference
-import java.lang.ref.SoftReference
-import java.lang.ref.WeakReference
-import java.util.EnumSet
-
-/**
- * This class is a work in progress. You can help by reporting leak traces that seem to be caused
- * by the Android SDK, here: https://github.com/square/leakcanary/issues/new
- *
- * We filter on SDK versions and Manufacturers because many of those leaks are specific to a given
- * manufacturer implementation, they usually share their builds across multiple models, and the
- * leaks eventually get fixed in newer versions.
- *
- * Most app developers should use [.createAppDefaults]. However, you can also pick the
- * leaks you want to ignore by creating an [EnumSet] that matches your needs and calling
- * [.createBuilder]
- */
-// Public API.
-enum class PerflibAndroidExcludedRefs constructor(internal val applies: Boolean = true) {
-
-  // ######## Android SDK Excluded refs ########
-
-  ACTIVITY_CLIENT_RECORD__NEXT_IDLE(SDK_INT in KITKAT..LOLLIPOP) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.app.ActivityThread\$ActivityClientRecord", "nextIdle")
-          .reason(
-              "Android AOSP sometimes keeps a reference to a destroyed activity as a"
-                  + " nextIdle client record in the android.app.ActivityThread.mActivities map."
-                  + " Not sure what's going on there, input welcome."
-          )
-    }
-  },
-
-  SPAN_CONTROLLER(SDK_INT <= KITKAT) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      val reason =
-        ("Editor inserts a special span, which has a reference to the EditText. That span is a"
-            + " NoCopySpan, which makes sure it gets dropped when creating a new"
-            + " SpannableStringBuilder from a given CharSequence."
-            + " TextView.onSaveInstanceState() does a copy of its mText before saving it in the"
-            + " bundle. Prior to KitKat, that copy was done using the SpannableString"
-            + " constructor, instead of SpannableStringBuilder. The SpannableString constructor"
-            + " does not drop NoCopySpan spans. So we end up with a saved state that holds a"
-            + " reference to the textview and therefore the entire view hierarchy & activity"
-            + " context. Fix: https://github.com/android/platform_frameworks_base/commit"
-            + "/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b ."
-            + " To fix this, you could override TextView.onSaveInstanceState(), and then use"
-            + " reflection to access TextView.SavedState.mText and clear the NoCopySpan spans.")
-      excluded.instanceField("android.widget.Editor\$EasyEditSpanController", "this$0")
-          .reason(reason)
-      excluded.instanceField("android.widget.Editor\$SpanController", "this$0")
-          .reason(reason)
-    }
-  },
-
-  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE(SDK_INT == LOLLIPOP) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.media.session.MediaSessionLegacyHelper", "sInstance")
-          .reason(
-              "MediaSessionLegacyHelper is a static singleton that is lazily instantiated and"
-                  + " keeps a reference to the context it's given the first time"
-                  + " MediaSessionLegacyHelper.getHelper() is called."
-                  + " This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by"
-                  + " calling context.getApplicationContext()."
-                  + " Fix: https://github.com/android/platform_frameworks_base/commit"
-                  + "/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091"
-                  + " To fix this, you could call MediaSessionLegacyHelper.getHelper() early"
-                  + " in Application.onCreate() and pass it the application context."
-          )
-    }
-  },
-
-  TEXT_LINE__SCACHED(SDK_INT <= LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.text.TextLine", "sCached")
-          .reason(
-              "TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had"
-                  + " at least two bugs that created memory leaks by not correctly clearing the"
-                  + " recycled TextLine instances. The first was fixed in android-5.1.0_r1:"
-                  + " https://github.com/android/platform_frameworks_base/commit"
-                  + "/893d6fe48d37f71e683f722457bea646994a10"
-                  + " The second was fixed, not released yet:"
-                  + " https://github.com/android/platform_frameworks_base/commit"
-                  + "/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e"
-                  + " To fix this, you could access TextLine.sCached and clear the pool every now"
-                  + " and then (e.g. on activity destroy)."
-          )
-    }
-  },
-
-  BLOCKING_QUEUE {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      val reason = ("A thread waiting on a blocking queue will leak the last"
-          + " dequeued object as a stack local reference. So when a HandlerThread becomes idle, it"
-          + " keeps a local reference to the last message it received. That message then gets"
-          + " recycled and can be used again. As long as all messages are recycled after being"
-          + " used, this won't be a problem, because these references are cleared when being"
-          + " recycled. However, dialogs create template Message instances to be copied when a"
-          + " message needs to be sent. These Message templates holds references to the dialog"
-          + " listeners, which most likely leads to holding a reference onto the activity in some"
-          + " way. Dialogs never recycle their template Message, assuming these Message instances"
-          + " will get GCed when the dialog is GCed."
-          + " The combination of these two things creates a high potential for memory leaks as soon"
-          + " as you use dialogs. These memory leaks might be temporary, but some handler threads"
-          + " sleep for a long time."
-          + " To fix this, you could post empty messages to the idle handler threads from time to"
-          + " time. This won't be easy because you cannot access all handler threads, but a library"
-          + " that is widely used should consider doing this for its own handler threads. This leaks"
-          + " has been shown to happen in both Dalvik and ART.")
-      excluded.instanceField("android.os.Message", "obj")
-          .reason(reason)
-      excluded.instanceField("android.os.Message", "next")
-          .reason(reason)
-      excluded.instanceField("android.os.Message", "target")
-          .reason(reason)
-    }
-  },
-
-  INPUT_METHOD_MANAGER__SERVED_VIEW(SDK_INT in ICE_CREAM_SANDWICH_MR1..O_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      val reason = ("When we detach a view that receives keyboard input, the InputMethodManager"
-          + " leaks a reference to it until a new view asks for keyboard input."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=171190"
-          + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414")
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mNextServedView")
-          .reason(reason)
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mServedView")
-          .reason(reason)
-      excluded.instanceField(
-          "android.view.inputmethod.InputMethodManager",
-          "mServedInputConnection"
-      )
-          .reason(reason)
-    }
-  },
-
-  INPUT_METHOD_MANAGER__ROOT_VIEW(SDK_INT in ICE_CREAM_SANDWICH_MR1..P) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mCurRootView")
-          .reason(
-              "The singleton InputMethodManager is holding a reference to mCurRootView long"
-                  + " after the activity has been destroyed."
-                  + " Observed on ICS MR1: https://github.com/square/leakcanary/issues/1"
-                  + "#issuecomment-100579429"
-                  + " Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"
-          )
-    }
-  },
-
-  LAYOUT_TRANSITION(SDK_INT in ICE_CREAM_SANDWICH..LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.animation.LayoutTransition$1", "val\$parent")
-          .reason(
-              "LayoutTransition leaks parent ViewGroup through"
-                  + " ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the"
-                  + " window is destroyed. Tracked here:"
-                  + " https://code.google.com/p/android/issues/detail?id=171830"
-          )
-    }
-  },
-
-  SPELL_CHECKER_SESSION(SDK_INT in JELLY_BEAN..N) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.view.textservice.SpellCheckerSession$1", "this$0")
-          .reason(
-              "SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the"
-                  + " SpellCheckerSession is closed before the service is connected."
-                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=172542"
-          )
-    }
-  },
-
-  SPELL_CHECKER(SDK_INT == LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.widget.SpellChecker$1", "this$0")
-          .reason(
-              "SpellChecker holds on to a detached view that points to a destroyed activity."
-                  + " mSpellRunnable is being enqueued, and that callback should be removed when "
-                  + " closeSession() is called. Maybe closeSession() wasn't called, or maybe it was "
-                  + " called after the view was detached."
-          )
-    }
-  },
-
-  ACTIVITY_CHOOSE_MODEL(SDK_INT in ICE_CREAM_SANDWICH_MR1..LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      val reason = ("ActivityChooserModel holds a static reference to the last set"
-          + " ActivityChooserModelPolicy which can be an activity context."
-          + " Tracked here: https://code.google.com/p/android/issues/detail?id=172659"
-          + " Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0")
-      excluded.instanceField(
-          "android.support.v7.internal.widget.ActivityChooserModel",
-          "mActivityChoserModelPolicy"
-      )
-          .reason(reason)
-      excluded.instanceField("android.widget.ActivityChooserModel", "mActivityChoserModelPolicy")
-          .reason(reason)
-    }
-  },
-
-  SPEECH_RECOGNIZER(SDK_INT < LOLLIPOP) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.speech.SpeechRecognizer\$InternalListener", "this$0")
-          .reason(
-              "Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner"
-                  + " class and leaked the SpeechRecognizer which leaked an activity context."
-                  + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-                  + " /b37866db469e81aca534ff6186bdafd44352329b"
-          )
-    }
-  },
-
-  ACCOUNT_MANAGER(SDK_INT <= O_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.accounts.AccountManager\$AmsTask\$Response", "this$1")
-          .reason(
-              "AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,"
-                  + " probably because the reference to the response in the other process hasn't been"
-                  + " cleared."
-                  + " AccountManager\$AmsTask is holding on to the activity reference to use for"
-                  + " launching a new sub- Activity."
-                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173689"
-                  + " Fix: Pass a null activity reference to the AccountManager methods and then deal"
-                  + " with the returned future to to get the result and correctly start an activity"
-                  + " when it's available."
-          )
-    }
-  },
-
-  MEDIA_SCANNER_CONNECTION(SDK_INT <= LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.media.MediaScannerConnection", "mContext")
-          .reason(
-              "The static method MediaScannerConnection.scanFile() takes an activity context"
-                  + " but the service might not disconnect after the activity has been destroyed."
-                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173788"
-                  + " Fix: Create an instance of MediaScannerConnection yourself and pass in the"
-                  + " application context. Call connect() and disconnect() manually."
-          )
-    }
-  },
-
-  USER_MANAGER__SINSTANCE(SDK_INT in JELLY_BEAN_MR2..N_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.os.UserManager", "mContext")
-          .reason(
-              "UserManager has a static sInstance field that creates an instance and caches it"
-                  + " the first time UserManager.get() is called. This instance is created with the"
-                  + " outer context (which is an activity base context)."
-                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=173789"
-                  + " Introduced by: https://github.com/android/platform_frameworks_base/commit"
-                  + "/27db46850b708070452c0ce49daf5f79503fbde6"
-                  + " Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the"
-                  + " UserManager instance gets cached with a reference to the application context."
-          )
-    }
-  },
-
-  APP_WIDGET_HOST_CALLBACKS(SDK_INT < LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.appwidget.AppWidgetHost\$Callbacks", "this$0")
-          .reason(
-              "android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native"
-                  + " code. The reference to the `mContext` was not being cleared, which caused the"
-                  + " Callbacks instance to retain this reference"
-                  + " Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit"
-                  + "/7a96f3c917e0001ee739b65da37b2fadec7d7765"
-          )
-    }
-  },
-
-  AUDIO_MANAGER(SDK_INT <= LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.media.AudioManager$1", "this$0")
-          .reason(
-              "Prior to Android M, VideoView required audio focus from AudioManager and"
-                  + " never abandoned it, which leaks the Activity context through the AudioManager."
-                  + " The root of the problem is that AudioManager uses whichever"
-                  + " context it receives, which in the case of the VideoView example is an Activity,"
-                  + " even though it only needs the application's context. The issue is fixed in"
-                  + " Android M, and the AudioManager now uses the application's context."
-                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=152173"
-                  + " Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2"
-          )
-    }
-  },
-
-  EDITTEXT_BLINK_MESSAGEQUEUE(SDK_INT <= LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.widget.Editor\$Blink", "this$0")
-          .reason(
-              "The EditText Blink of the Cursor is implemented using a callback and Messages,"
-                  + " which trigger the display of the Cursor. If an AlertDialog or DialogFragment that"
-                  + " contains a blinking cursor is detached, a message is posted with a delay after the"
-                  + " dialog has been closed and as a result leaks the Activity."
-                  + " This can be fixed manually by calling TextView.setCursorVisible(false) in the"
-                  + " dismiss() method of the dialog."
-                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=188551"
-                  + " Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+"
-                  + "/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/"
-          )
-    }
-  },
-
-  CONNECTIVITY_MANAGER__SINSTANCE(SDK_INT <= M) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.net.ConnectivityManager", "sInstance")
-          .reason(
-              "ConnectivityManager has a sInstance field that is set when the first"
-                  + " ConnectivityManager instance is created. ConnectivityManager has a mContext field."
-                  + " When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first"
-                  + " ConnectivityManager instance is created with the activity context and stored in"
-                  + " sInstance. That activity context then leaks forever."
-                  + " Until this is fixed, app developers can prevent this leak by making sure the"
-                  + " ConnectivityManager is first created with an App Context. E.g. in some static"
-                  + " init do: context.getApplicationContext()"
-                  + ".getSystemService(Context.CONNECTIVITY_SERVICE)"
-                  + " Tracked here: https://code.google.com/p/android/issues/detail?id=198852"
-                  + " Introduced here: https://github.com/android/platform_frameworks_base/commit/"
-                  + "e0bef71662d81caaaa0d7214fb0bef5d39996a69"
-          )
-    }
-  },
-
-  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT(SDK_INT in O..O_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.view.accessibility.AccessibilityNodeInfo", "mOriginalText")
-          .reason(
-              "AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When"
-                  + " AccessibilityNodeInfo instances are released back in the pool,"
-                  + " AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which"
-                  + " causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the"
-                  + " whole view hierarchy. Introduced here: https://android.googlesource.com/platform/"
-                  + "frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/"
-                  + "android/view/accessibility/AccessibilityNodeInfo.java"
-          )
-    }
-  },
-
-  BACKDROP_FRAME_RENDERER__MDECORVIEW(SDK_INT in N..O) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("com.android.internal.policy.BackdropFrameRenderer", "mDecorView")
-          .reason(
-              "When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case"
-                  + " where mRenderer becomes null but mChoreographer doesn't and the thread doesn't"
-                  + " stop and ends up leaking mDecorView which itself holds on to a destroyed"
-                  + " activity"
-          )
-    }
-  },
-
-  // ######## Manufacturer specific Excluded refs ########
-
-  INSTRUMENTATION_RECOMMEND_ACTIVITY(MEIZU == MANUFACTURER && SDK_INT in LOLLIPOP..LOLLIPOP_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.app.Instrumentation", "mRecommendActivity")
-          .reason(
-              "Instrumentation would leak com.android.internal.app.RecommendActivity (in"
-                  + " framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and "
-                  + " above"
-          )
-    }
-  },
-
-  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER(
-      MOTOROLA == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP_MR1
-  ) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      if (MOTOROLA == MANUFACTURER && SDK_INT == KITKAT) {
-        excluded.instanceField("android.app.admin.DevicePolicyManager\$SettingsObserver", "this$0")
-            .reason(
-                "DevicePolicyManager keeps a reference to the context it has been created with"
-                    + " instead of extracting the application context. In this Motorola build,"
-                    + " DevicePolicyManager has an inner SettingsObserver class that is a content"
-                    + " observer, which is held into memory by a binder transport object."
-            )
-      }
-    }
-  },
-
-  SPEN_GESTURE_MANAGER(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("com.samsung.android.smartclip.SpenGestureManager", "mContext")
-          .reason(
-              "SpenGestureManager has a static mContext field that leaks a reference to the" + " activity. Yes, a STATIC mContext field."
-          )
-    }
-  },
-
-  GESTURE_BOOST_MANAGER(HUAWEI == MANUFACTURER && SDK_INT in N..N_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.gestureboost.GestureBoostManager", "mContext")
-          .reason(
-              "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
-          )
-    }
-  },
-
-  INPUT_METHOD_MANAGER__LAST_SERVED_VIEW(HUAWEI == MANUFACTURER && SDK_INT in M..O_MR1) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      val reason =
-        "HUAWEI added a mLastSrvView field to InputMethodManager" + " that leaks a reference to the last served view."
-      excluded.instanceField("android.view.inputmethod.InputMethodManager", "mLastSrvView")
-          .reason(reason)
-    }
-  },
-
-  CLIPBOARD_UI_MANAGER__SINSTANCE(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.sec.clipboard.ClipboardUIManager", "mContext")
-          .reason(
-              "ClipboardUIManager is a static singleton that leaks an activity context."
-                  + " Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()"
-                  + " , so that the ClipboardUIManager instance gets cached with a reference to the"
-                  + " application context. Example: https://gist.github.com/cypressious/"
-                  + "91c4fb1455470d803a602838dfcd5774"
-          )
-    }
-  },
-
-  SEM_CLIPBOARD_MANAGER__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..N) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField(
-          "com.samsung.android.content.clipboard.SemClipboardManager",
-          "mContext"
-      )
-          .reason(
-              "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
-          )
-    }
-  },
-
-  SEM_EMERGENCY_MANAGER__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..N) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("com.samsung.android.emergencymode.SemEmergencyManager", "mContext")
-          .reason(
-              "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
-          )
-    }
-  },
-
-  BUBBLE_POPUP_HELPER__SHELPER(LG == MANUFACTURER && SDK_INT in KITKAT..LOLLIPOP) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.widget.BubblePopupHelper", "sHelper")
-          .reason(
-              "A static helper for EditText bubble popups leaks a reference to the latest" + " focused view."
-          )
-    }
-  },
-
-  LGCONTEXT__MCONTEXT(LG == MANUFACTURER && SDK_INT == LOLLIPOP) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("com.lge.systemservice.core.LGContext", "mContext")
-          .reason("LGContext is a static singleton that leaks an activity context.")
-    }
-  },
-
-  AW_RESOURCE__SRESOURCES(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      // AwResource#setResources() is called with resources that hold a reference to the
-      // activity context (instead of the application context) and doesn't clear it.
-      // Not sure what's going on there, input welcome.
-      excluded.staticField("com.android.org.chromium.android_webview.AwResource", "sResources")
-    }
-  },
-
-  MAPPER_CLIENT(NVIDIA == MANUFACTURER && SDK_INT == KITKAT) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("com.nvidia.ControllerMapper.MapperClient\$ServiceClient", "this$0")
-          .reason(
-              "Not sure exactly what ControllerMapper is about, but there is an anonymous"
-                  + " Handler in ControllerMapper.MapperClient.ServiceClient, which leaks"
-                  + " ControllerMapper.MapperClient which leaks the activity context."
-          )
-    }
-  },
-
-  TEXT_VIEW__MLAST_HOVERED_VIEW(SAMSUNG == MANUFACTURER && SDK_INT in KITKAT..O) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.widget.TextView", "mLastHoveredView")
-          .reason(
-              "mLastHoveredView is a static field in TextView that leaks the last hovered" + " view."
-          )
-    }
-  },
-
-  PERSONA_MANAGER(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.os.PersonaManager", "mContext")
-          .reason(
-              "android.app.LoadedApk.mResources has a reference to"
-                  + " android.content.res.Resources.mPersonaManager which has a reference to"
-                  + " android.os.PersonaManager.mContext which is an activity."
-          )
-    }
-  },
-
-  RESOURCES__MCONTEXT(SAMSUNG == MANUFACTURER && SDK_INT == KITKAT) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.content.res.Resources", "mContext")
-          .reason(
-              "In AOSP the Resources class does not have a context."
-                  + " Here we have ZygoteInit.mResources (static field) holding on to a Resources"
-                  + " instance that has a context that is the activity."
-                  + " Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184"
-          )
-    }
-  },
-
-  VIEW_CONFIGURATION__MCONTEXT(
-      SAMSUNG == MANUFACTURER && SDK_INT == KITKAT
-  ) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.instanceField("android.view.ViewConfiguration", "mContext")
-          .reason(
-              "In AOSP the ViewConfiguration class does not have a context."
-                  + " Here we have ViewConfiguration.sConfigurations (static field) holding on to a"
-                  + " ViewConfiguration instance that has a context that is the activity."
-                  + " Observed here: https://github.com/square/leakcanary/issues"
-                  + "/1#issuecomment-100324683"
-          )
-    }
-  },
-
-  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL(
-      LENOVO == MANUFACTURER && SDK_INT == KITKAT //
-          || VIVO == MANUFACTURER && SDK_INT == LOLLIPOP_MR1
-  ) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.hardware.SystemSensorManager", "mAppContextImpl")
-          .reason(
-              "SystemSensorManager stores a reference to context"
-                  + " in a static field in its constructor."
-                  + " Fix: use application context to get SensorManager"
-          )
-    }
-  },
-
-  AUDIO_MANAGER__MCONTEXT_STATIC(
-      SAMSUNG == MANUFACTURER && SDK_INT == KITKAT
-  ) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.media.AudioManager", "mContext_static")
-          .reason(
-              "Samsung added a static mContext_static field to AudioManager, holds a reference"
-                  + " to the activity."
-                  + " Observed here: https://github.com/square/leakcanary/issues/32"
-          )
-    }
-  },
-
-  ACTIVITY_MANAGER_MCONTEXT(
-      SAMSUNG == MANUFACTURER && SDK_INT == LOLLIPOP_MR1
-  ) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.staticField("android.app.ActivityManager", "mContext")
-          .reason(
-              "Samsung added a static mContext field to ActivityManager, holds a reference"
-                  + " to the activity."
-                  + " Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:"
-                  + " https://github.com/square/leakcanary/issues/177#issuecomment-222724283"
-          )
-    }
-  },
-
-  // ######## General Excluded refs ########
-
-  SOFT_REFERENCES {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.clazz(WeakReference::class.java.name)
-          .alwaysExclude()
-      excluded.clazz(SoftReference::class.java.name)
-          .alwaysExclude()
-      excluded.clazz(PhantomReference::class.java.name)
-          .alwaysExclude()
-      excluded.clazz("java.lang.ref.Finalizer")
-          .alwaysExclude()
-      excluded.clazz("java.lang.ref.FinalizerReference")
-          .alwaysExclude()
-    }
-  },
-
-  FINALIZER_WATCHDOG_DAEMON {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
-      // reference to the object and it was about to be GCed.
-      excluded.thread("FinalizerWatchdogDaemon")
-          .alwaysExclude()
-    }
-  },
-
-  MAIN {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      // The main thread stack is ever changing so local variables aren't likely to hold references
-      // for long. If this is on the shortest path, it's probably that there's a longer path with
-      // a real leak.
-      excluded.thread("main")
-          .alwaysExclude()
-    }
-  },
-
-  LEAK_CANARY_THREAD {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      excluded.thread("LeakCanary-Heap-Dump")
-          .alwaysExclude()
-    }
-  },
-
-  EVENT_RECEIVER__MMESSAGE_QUEUE {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
-      // the native peer of the receiver is using them.
-      // The main thread message queue is held on by the main Looper, but that might be a longer
-      // path. Let's not confuse people with a shorter path that is less meaningful.
-      excluded.instanceField(
-          "android.view.Choreographer\$FrameDisplayEventReceiver",
-          "mMessageQueue"
-      )
-          .alwaysExclude()
-    }
-  },
-
-  VIEWLOCATIONHOLDER_ROOT(SDK_INT == P) {
-    override fun add(excluded: PerflibExcludedRefs.Builder) {
-      //  In Android P, ViewLocationHolder has an mRoot field that is not cleared in its clear()
-      // method.
-      // Introduced in https://github.com/aosp-mirror/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909de894
-      // Bug report: https://issuetracker.google.com/issues/112792715
-      excluded.instanceField(
-          "android.view.ViewGroup\$ViewLocationHolder",
-          "mRoot"
-      )
-    }
-  };
-
-  internal abstract fun add(excluded: PerflibExcludedRefs.Builder)
-
-  companion object {
-
-    /**
-     * This returns the references in the leak path that should be ignored by all on Android.
-     */
-    fun createAndroidDefaults(): PerflibExcludedRefs.Builder {
-      return createBuilder(
-          EnumSet.of(
-              SOFT_REFERENCES,
-              FINALIZER_WATCHDOG_DAEMON,
-              MAIN,
-              LEAK_CANARY_THREAD,
-              EVENT_RECEIVER__MMESSAGE_QUEUE
-          )
-      )
-    }
-
-    /**
-     * This returns the references in the leak path that can be ignored for app developers. This
-     * doesn't mean there is no memory leak, to the contrary. However, some leaks are caused by bugs
-     * in AOSP or manufacturer forks of AOSP. In such cases, there is very little we can do as app
-     * developers except by resorting to serious hacks, so we remove the noise caused by those leaks.
-     */
-    fun createAppDefaults(): PerflibExcludedRefs.Builder {
-      return createBuilder(
-          EnumSet.allOf(PerflibAndroidExcludedRefs::class.java)
-      )
-    }
-
-    fun createBuilder(refs: EnumSet<PerflibAndroidExcludedRefs>): PerflibExcludedRefs.Builder {
-      val excluded = PerflibExcludedRefs.builder()
-      for (ref in refs) {
-        if (ref.applies) {
-          ref.add(excluded)
-          (excluded as PerflibExcludedRefs.BuilderWithParams).named(ref.name)
-        }
-      }
-      return excluded
-    }
-  }
-}
-
-const val SAMSUNG = "samsung"
-const val MOTOROLA = "motorola"
-const val LENOVO = "LENOVO"
-const val LG = "LGE"
-const val NVIDIA = "NVIDIA"
-const val MEIZU = "Meizu"
-const val HUAWEI = "HUAWEI"
-const val VIVO = "vivo"
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
index 9d64edd1..b8d5daa8 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/HprofParser.kt
@@ -38,6 +38,7 @@ import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
 import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
 import leakcanary.Record.LoadClassRecord
+import leakcanary.Record.StackFrameRecord
 import leakcanary.Record.StackTraceRecord
 import leakcanary.Record.StringRecord
 import leakcanary.internal.LongToIntSparseArray
@@ -232,6 +233,23 @@ class HprofParser private constructor(
             skip(length)
           }
         }
+        STACK_FRAME -> {
+          val callback = callbacks.get<StackFrameRecord>()
+          if (callback != null) {
+            callback(
+                StackFrameRecord(
+                    id = readId(),
+                    methodNameStringId = readId(),
+                    methodSignatureStringId = readId(),
+                    sourceFileNameStringId = readId(),
+                    classSerialNumber = readInt(),
+                    lineNumber = readInt()
+                )
+            )
+          } else {
+            skip(length)
+          }
+        }
         STACK_TRACE -> {
           val callback = callbacks.get<StackTraceRecord>()
           if (callback != null) {
@@ -444,10 +462,10 @@ class HprofParser private constructor(
                       primitiveWrapperTypes.contains(
                           instanceDumpRecord.classId
                       ) -> ObjectIdMetadata.PRIMITIVE_WRAPPER_OR_PRIMITIVE_ARRAY
-                      hprofStringCache[classNames[instanceDumpRecord.classId]] == "java.lang.String" -> ObjectIdMetadata.STRING
+                      hprofStringCache[classNames[instanceDumpRecord.classId]] == "java.lang.String" -> STRING
                       instanceDumpRecord.fieldValues.isEmpty() -> EMPTY_INSTANCE
                       instanceDumpRecord.fieldValues.size <= maybeEmptySize -> INTERNAL_MAYBE_EMPTY_INSTANCE
-                      else -> ObjectIdMetadata.INSTANCE
+                      else -> INSTANCE
                     }
                     objectIndex[id] = metadata.packOrdinalWithFilePosition(recordPosition)
                   }
@@ -840,7 +858,6 @@ class HprofParser private constructor(
     const val STRING_IN_UTF8 = 0x01
     const val LOAD_CLASS = 0x02
     const val UNLOAD_CLASS = 0x03
-    // TODO Maybe parse this?
     const val STACK_FRAME = 0x04
     const val STACK_TRACE = 0x05
     const val ALLOC_SITES = 0x06
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/leakcanary-haha/src/main/java/leakcanary/Record.kt
index 250eb44f..9f1a420d 100644
--- a/leakcanary-haha/src/main/java/leakcanary/Record.kt
+++ b/leakcanary-haha/src/main/java/leakcanary/Record.kt
@@ -15,6 +15,22 @@ sealed class Record {
 
   object HeapDumpEndRecord : Record()
 
+  class StackFrameRecord(
+    val id: Long,
+    val methodNameStringId: Long,
+    val methodSignatureStringId: Long,
+    val sourceFileNameStringId: Long,
+    val classSerialNumber: Int,
+    /**
+     * >0 line number
+     * 0 no line information available
+     * -1 unknown location
+     * -2 compiled method (Not implemented)
+     * -3 native method (Not implemented)
+     */
+    val lineNumber: Int
+  ) : Record()
+
   class StackTraceRecord(
     val stackTraceSerialNumber: Int,
     val threadSerialNumber: Int,
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
index a0602506..6fa5b3fd 100644
--- a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
+++ b/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
@@ -17,7 +17,9 @@ package com.example.leakcanary
 
 import android.app.Activity
 import android.os.Bundle
+import android.os.SystemClock
 import android.view.View
+import java.util.concurrent.atomic.AtomicReference
 import kotlin.random.Random
 
 class MainActivity : Activity() {
@@ -29,10 +31,27 @@ class MainActivity : Activity() {
     val app = application as ExampleApplication
     val leakedView = findViewById<View>(R.id.helper_text)
 
-    when (Random.nextInt(3)) {
-      0 -> app.leakedViews
-      1 -> LeakingSingleton.leakedViews
-      else -> LeakingThread.thread.leakedViews
-    }.add(leakedView)
+    when (Random.nextInt(4)) {
+      // Leak from application class
+      0 -> app.leakedViews.add(leakedView)
+      // Leak from Kotlin object singleton
+      1 -> LeakingSingleton.leakedViews.add(leakedView)
+      2 -> {
+        // Leak from local variable on thread
+        val ref = AtomicReference(this)
+        val thread = Thread {
+          val activity = ref.get()
+          ref.set(null)
+          while (true) {
+            print(activity)
+            SystemClock.sleep(1000)
+          }
+        }
+        thread.name = "Leaking local variables"
+        thread.start()
+      }
+      // Leak from thread fields
+      else -> LeakingThread.thread.leakedViews.add(leakedView)
+    }
   }
 }
diff --git a/settings.gradle b/settings.gradle
index a1305387..ed968aba 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,5 +1,4 @@
 include ':leakcanary-analyzer'
-include ':leakcanary-analyzer-perflib'
 include ':leakcanary-android'
 include ':leakcanary-android-core'
 include ':leakcanary-android-instrumentation'
