diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
index ee991e474..1d8171b52 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
@@ -11832,8 +11832,8 @@ private void hideActionMode() {
         cantDeleteMessagesCount = 0;
         canEditMessagesCount = 0;
         cantForwardMessagesCount = 0;
-        boolean canWriteToChannel = ChatObject.isChannel(currentChat) && (currentChat.creator || currentChat.admin_rights != null && currentChat.admin_rights.post_messages) && !currentChat.megagroup;
-        if (chatActivityEnterView != null && canWriteToChannel) {
+
+        if (chatActivityEnterView != null && ChatObject.canWriteToChat(currentChat)) {
             EditTextCaption editTextCaption = chatActivityEnterView.getEditField();
             editTextCaption.requestFocus();
             editTextCaption.setAllowDrawCursor(true);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
index e3e516476..2870e0946 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
@@ -34,6 +34,7 @@
 import androidx.annotation.Keep;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
+import androidx.core.content.ContextCompat;
 import androidx.core.view.inputmethod.EditorInfoCompat;
 import androidx.core.view.inputmethod.InputConnectionCompat;
 import androidx.core.os.BuildCompat;
@@ -247,6 +248,7 @@ public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfo i
     private Paint dotPaint;
     private Drawable playDrawable;
     private Drawable pauseDrawable;
+    private ReplacableIconDrawable botButtonDrawable;
     private int searchingType;
 
     private boolean destroyed;
@@ -1077,7 +1079,11 @@ public void afterTextChanged(Editable editable) {
 
             botButton = new ImageView(context);
             botButton.setColorFilter(new PorterDuffColorFilter(Theme.getColor(Theme.key_chat_messagePanelIcons), PorterDuff.Mode.MULTIPLY));
-            botButton.setImageResource(R.drawable.input_bot2);
+
+            botButtonDrawable = new ReplacableIconDrawable(context);
+            botButtonDrawable.setIcon(R.drawable.input_bot2, false);
+
+            botButton.setImageDrawable(botButtonDrawable);
             botButton.setScaleType(ImageView.ScaleType.CENTER);
             botButton.setVisibility(GONE);
             attachLayout.addView(botButton, LayoutHelper.createLinear(48, 48));
@@ -3028,14 +3034,14 @@ private void updateBotButton() {
             }
             if (botReplyMarkup != null) {
                 if (isPopupShowing() && currentPopupContentType == 1) {
-                    botButton.setImageResource(R.drawable.input_keyboard);
+                    botButtonDrawable.setIcon(R.drawable.input_keyboard, isAttachedToWindow());
                     botButton.setContentDescription(LocaleController.getString("AccDescrShowKeyboard", R.string.AccDescrShowKeyboard));
                 } else {
-                    botButton.setImageResource(R.drawable.input_bot2);
+                    botButtonDrawable.setIcon(R.drawable.input_bot2, isAttachedToWindow());
                     botButton.setContentDescription(LocaleController.getString("AccDescrBotKeyboard", R.string.AccDescrBotKeyboard));
                 }
             } else {
-                botButton.setImageResource(R.drawable.input_bot1);
+                botButtonDrawable.setIcon(R.drawable.input_bot1, isAttachedToWindow());
                 botButton.setContentDescription(LocaleController.getString("AccDescrBotCommands", R.string.AccDescrBotCommands));
             }
         } else {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ReplacableIconDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ReplacableIconDrawable.java
new file mode 100644
index 000000000..531eda864
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ReplacableIconDrawable.java
@@ -0,0 +1,191 @@
+package org.telegram.ui.Components;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.AnimatorSet;
+import android.animation.ObjectAnimator;
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+import android.widget.ImageView;
+
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.content.ContextCompat;
+
+public class ReplacableIconDrawable extends Drawable implements Animator.AnimatorListener {
+
+    private Context context;
+    private ColorFilter colorFilter;
+    private int currentResId = 0;
+
+    private Drawable currentDrawable;
+    private Drawable outDrawable;
+
+    private ValueAnimator animation;
+    private float progress = 1f;
+
+    public ReplacableIconDrawable(Context context) {
+        this.context = context;
+    }
+
+
+    public void setIcon(@DrawableRes int resId, boolean animated) {
+        if (currentResId == resId) {
+            return;
+        }
+        currentResId = resId;
+        setIcon(ContextCompat.getDrawable(context, resId), animated);
+    }
+
+    public void setIcon(Drawable drawable, boolean animated) {
+        if (drawable == null) {
+            currentDrawable = null;
+            outDrawable = null;
+            invalidateSelf();
+            return;
+        }
+
+        if (drawable == currentDrawable) {
+            return;
+        }
+
+        outDrawable = currentDrawable;
+        currentDrawable = drawable;
+        currentDrawable.setColorFilter(colorFilter);
+
+        updateBounds(currentDrawable, getBounds());
+        updateBounds(outDrawable, getBounds());
+
+
+        if (animation != null) {
+            animation.removeAllListeners();
+            animation.cancel();
+        }
+
+        if (!animated) {
+            outDrawable = null;
+            return;
+        }
+
+
+        animation = ValueAnimator.ofFloat(0, 1f);
+        animation.addUpdateListener(animation -> {
+            progress = (float) animation.getAnimatedValue();
+            invalidateSelf();
+        });
+        animation.addListener(this);
+        animation.setDuration(150);
+        animation.start();
+    }
+
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        updateBounds(currentDrawable, bounds);
+        updateBounds(outDrawable, bounds);
+    }
+
+    private void updateBounds(Drawable d, Rect bounds) {
+        if (d == null) return;
+        int left;
+        int right;
+        int bottom;
+        int top;
+
+        if (d.getIntrinsicHeight() < 0) {
+            top = bounds.top;
+            bottom = bounds.bottom;
+        } else {
+            int offset = (bounds.height() - d.getIntrinsicHeight()) / 2;
+            top = bounds.top + offset;
+            bottom = bounds.top + offset + d.getIntrinsicHeight();
+        }
+
+
+        if (d.getIntrinsicWidth() < 0) {
+            left = bounds.left;
+            right = bounds.right;
+        } else {
+            int offset = (bounds.width() - d.getIntrinsicWidth()) / 2;
+            left = bounds.left + offset;
+            right = bounds.left + offset + d.getIntrinsicWidth();
+        }
+        d.setBounds(left, top, right, bottom);
+    }
+
+    @Override
+    public void draw(@NonNull Canvas canvas) {
+        int cX = getBounds().centerX();
+        int cY = getBounds().centerY();
+
+        if (progress != 1f && currentDrawable != null) {
+            canvas.save();
+            canvas.scale(progress, progress, cX, cY);
+            currentDrawable.setAlpha((int) (255 * progress));
+            currentDrawable.draw(canvas);
+            canvas.restore();
+        } else if (currentDrawable != null) {
+            currentDrawable.setAlpha(255);
+            currentDrawable.draw(canvas);
+        }
+
+        if (progress != 1f && outDrawable != null) {
+            float progressRev = 1f - progress;
+            canvas.save();
+            canvas.scale(progressRev, progressRev, cX, cY);
+            outDrawable.setAlpha((int) (255 * progressRev));
+            outDrawable.draw(canvas);
+            canvas.restore();
+        } else if (outDrawable != null) {
+            outDrawable.setAlpha(255);
+            outDrawable.draw(canvas);
+        }
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(@Nullable ColorFilter colorFilter) {
+        this.colorFilter = colorFilter;
+        if (currentDrawable != null) currentDrawable.setColorFilter(colorFilter);
+        if (outDrawable != null) outDrawable.setColorFilter(colorFilter);
+    }
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSPARENT;
+    }
+
+    @Override
+    public void onAnimationEnd(Animator animation) {
+        outDrawable = null;
+        invalidateSelf();
+    }
+
+    @Override
+    public void onAnimationStart(Animator animation) {
+
+    }
+
+
+    @Override
+    public void onAnimationCancel(Animator animation) {
+
+    }
+
+    @Override
+    public void onAnimationRepeat(Animator animation) {
+
+    }
+}
