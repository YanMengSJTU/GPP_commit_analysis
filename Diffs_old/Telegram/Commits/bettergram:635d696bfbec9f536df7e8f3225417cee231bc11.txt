diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/adapter/BaseAdapter.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/adapter/BaseAdapter.java
new file mode 100644
index 000000000..e1b592f6c
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/adapter/BaseAdapter.java
@@ -0,0 +1,180 @@
+package ru.johnlife.lifetools.adapter;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Created by yanyu on 4/1/2016.
+ */
+public abstract class BaseAdapter<T> extends RecyclerView.Adapter implements Iterable<T> {
+    public static abstract class ViewHolder<T> extends RecyclerView.ViewHolder {
+        private T item = null;
+        public ViewHolder(View itemView) {
+            super(itemView);
+        }
+        protected void assign(T item) {
+            this.item = item;
+            hold(item);
+        }
+
+        protected void onDetached() {}
+
+        protected abstract void hold(T item);
+
+        public T getItem() {
+            return item;
+        }
+    }
+
+
+    private List<T> items;
+    private int itemLayoutId;
+
+    public BaseAdapter(int itemLayoutId, List<T> items) {
+        this.itemLayoutId = itemLayoutId;
+        this.items = items;
+    }
+
+    public BaseAdapter(int itemLayoutId) {
+        this(itemLayoutId, new ArrayList<T>());
+    }
+
+    @Override
+    /**
+     * Override this and return LayoutId if you need different view types
+     * */
+    public int getItemViewType(int position) {
+        return super.getItemViewType(position);
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        int layout = (0 == viewType) ? itemLayoutId : viewType;
+        return createViewHolder(LayoutInflater.from(parent.getContext()).inflate(layout, parent, false));
+    }
+
+    @Override
+    public final void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int position) {
+        ViewHolder<T> holder = (ViewHolder<T>) viewHolder;
+        holder.assign(items.get(position));
+    }
+
+    protected abstract ViewHolder<T> createViewHolder(final View view);
+
+    @Override
+    public void onViewRecycled(RecyclerView.ViewHolder viewHolder) {
+        ViewHolder<T> holder = (ViewHolder<T>) viewHolder;
+        holder.onDetached();
+        super.onViewRecycled(holder);
+    }
+
+    @Override
+    public int getItemCount() {
+        return null == items ? 0 : items.size();
+    }
+
+    public int getCount() {
+        return getItemCount();
+    }
+
+    public T getItem(int position) {
+        if (null == items) throw new IllegalStateException("Internal collection is null");
+        if (position < 0 || position >= items.size()) throw new IllegalArgumentException("size is "+items.size()+", requested position is "+position);
+        return items.get(position);
+    }
+
+    public T remove(int position) {
+        if (null == items) throw new IllegalStateException("Internal collection is null");
+        if (position < 0 || position >= items.size()) throw new IllegalArgumentException("size is "+items.size()+", requested position is "+position);
+        T item = items.remove(position);
+        notifyItemRemoved(position);
+        return item;
+    }
+
+    public void add(T item) {
+        add(item, items.size());
+    }
+
+    public void add(T item, int position) {
+        items.add(position, item);
+        notifyItemInserted(position);
+    }
+
+    public void remove(T item) {
+        int position = items.indexOf(item);
+        if (-1 != position) {
+            items.remove(position);
+            notifyItemRemoved(position);
+        }
+    }
+
+    public void replace(T item) {
+        replace(item, items.indexOf(item));
+    }
+
+    public void replace(T item, int position) {
+        if (-1 == position) {
+            add(item);
+        } else {
+            items.set(position, item);
+            notifyItemChanged(position);
+        }
+    }
+
+    public int indexOf(T item) {
+        return items.indexOf(item);
+    }
+
+    public void clear() {
+        items.clear();
+        notifyDataSetChanged();
+    }
+
+    public void addAll(Collection<? extends T> collection) {
+        for (T item : collection) { //just to trigger proper animation
+            add(item);
+        }
+    }
+
+    /**
+     * Adapts new set into adapter.
+     * Changed items (.equals) are replaced. New ones added to the end
+     * @param collection
+     */
+    public void adapt(Collection<? extends T> collection) {
+        for (T item : collection) {
+            replace(item);
+        }
+    }
+
+    /**
+     * Clears the adapter and adds all items from the new collection.
+     * No animation. Triggers notifyDataSetChanged
+     * @param collection
+     */
+    public void set(Collection<? extends T> collection) {
+        if (collection == null) return;
+        items.clear();
+        items.addAll(collection);
+        notifyDataSetChanged();
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return null == items ? null : items.iterator();
+    }
+
+    public void sort(Comparator<T> comparator) {
+        Collections.sort(items, comparator);
+        notifyDataSetChanged();
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/adapter/BaseSelectableAdapter.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/adapter/BaseSelectableAdapter.java
new file mode 100644
index 000000000..ee487e2e6
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/adapter/BaseSelectableAdapter.java
@@ -0,0 +1,51 @@
+package ru.johnlife.lifetools.adapter;
+
+import android.view.View;
+
+import java.util.List;
+
+/**
+ * Created by yanyu on 5/23/2016.
+ */
+public abstract class BaseSelectableAdapter<T> extends BaseAdapter<T> {
+    private T selected;
+
+    public abstract class ViewHolderSelectable extends BaseAdapter.ViewHolder<T> {
+        public ViewHolderSelectable(View view) {
+            super(view);
+            view.setOnClickListener(v -> select(getItem()));
+        }
+
+        protected boolean isSelected() {
+            return getItem() == selected;
+        }
+    }
+
+
+    public BaseSelectableAdapter(int itemLayoutId) {
+        super(itemLayoutId);
+    }
+
+    public BaseSelectableAdapter(int itemLayoutId, List<T> items) {
+        super(itemLayoutId, items);
+    }
+
+    protected boolean isSelected(T item) {
+        return selected == item;
+    }
+
+    public T getSelected() {
+        return selected;
+    }
+
+    public void select(T item) {
+        if (null == item) return;
+        T oldSelected = selected;
+        selected = item;
+        if (oldSelected != null) {
+            notifyItemChanged(indexOf(oldSelected));
+        }
+        notifyItemChanged(indexOf(item));
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/EndlessColorSource.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/EndlessColorSource.java
new file mode 100644
index 000000000..3c570fc7e
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/EndlessColorSource.java
@@ -0,0 +1,26 @@
+package ru.johnlife.lifetools.data;
+
+import android.graphics.Color;
+
+/**
+ * Created by yanyu on 4/29/2016.
+ */
+public class EndlessColorSource {
+    private int colors[];
+    private int idx;
+
+    public EndlessColorSource(String[] colors) {
+        this.colors = new int[colors.length];
+        for (int i=0; i<colors.length; i++) {
+            String color = colors[i];
+            this.colors[i] = Color.parseColor(color);
+        }
+        idx = 0;
+    }
+
+    public int getNext() {
+        int value = colors[idx++];
+        if (idx >= colors.length) idx = 0;
+        return value;
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Identifiable.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Identifiable.java
new file mode 100644
index 000000000..0cc901b7a
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Identifiable.java
@@ -0,0 +1,5 @@
+package ru.johnlife.lifetools.data;
+
+public interface Identifiable<T> {
+    T getId();
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Pool.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Pool.java
new file mode 100644
index 000000000..00740752e
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Pool.java
@@ -0,0 +1,176 @@
+package ru.johnlife.lifetools.data;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+public class Pool<E> implements Iterable<E>{
+	private E[] pool;
+	private int cursor = 0;
+	private boolean firstCycle = true;
+	
+	public Pool(int capacity) {
+		this(null, capacity);
+	}
+
+	/**
+	 * WARNING: Any add will modify the source array! For instance: 
+	 * The next <code>add()</code> will overwrite the first value in the array!!!
+	 * @param pool - array to be based on. 
+	 * @throws NullPointerException in case <code>pool</code> is <code>null</code>
+	 */
+	public Pool(E[] pool) {
+		this(pool, 0);
+	}
+
+	/**
+	 * Creates a pool with all elements of <code>pool</code> array, but with greater <code>capacity</code>.
+	 * WARNING: In case <code>greaterCapacity</code> is less OR equal to <code>pool.length</code> this constructor will fall back to MODIFYING behavior of <code>Pool(E[] pool)</code>
+	 * @throws NullPointerException in case <code>pool</code> is <code>null</code> and <code>greaterCapacity</code> == 0
+	 */
+	@SuppressWarnings("unchecked")
+	public Pool(E[] pool, int greaterCapacity) {
+		if (null == pool && greaterCapacity == 0) throw new NullPointerException();
+		if (null == pool || pool.length < greaterCapacity) {
+			this.pool = (E[])new Object[greaterCapacity];
+			cursor = 0;
+			firstCycle = true;
+			if (pool != null) {
+				addAll(pool);
+			}
+		} else  {
+			this.pool = pool;
+			cursor = 0;
+			firstCycle = false; //we already have full pool =))) 
+		}
+	}
+
+	@Override
+	public Iterator<E> iterator() {
+		return new Iterator<E>() {
+			private int iCursor = isEmpty() ? -1 : firstCycle ? 0 : cursor;
+			
+			@Override
+			public boolean hasNext() {
+				return iCursor != -1 && pool[iCursor] != null;
+			}
+
+			@Override
+			public E next() {
+				if (iCursor == -1) return null; 
+				E value = pool[iCursor];
+				if ((++iCursor) >= pool.length ) {
+					iCursor = 0; 
+				} 
+				if (iCursor == cursor) {
+					iCursor = -1;
+				}
+				return value;
+			}
+
+			@Override
+			public void remove() {
+				throw new UnsupportedOperationException("You only can add to pool");				
+			}
+		};
+	}
+
+	public boolean isEmpty() {
+		return cursor == 0 && firstCycle;
+	}
+
+	public int size() {
+		return firstCycle ? cursor : pool.length;
+	}
+
+	public int capacity() {
+		return pool.length;
+	}
+
+	public void add(E object) {
+		pool[cursor] = object;
+		if ((++cursor) >= pool.length ) {
+			cursor = 0; 
+			firstCycle = false;
+		}
+	}
+
+	public void addAll(Collection<? extends E> collection) {
+		for (E e : collection) {
+			add(e);
+		}
+	}
+
+	public void addAll(E[] array) {
+		for (E e : array) {
+			add(e);
+		}
+	}
+
+	public void clear() {
+		cursor = 0;
+		firstCycle = true;
+	}
+
+	// TODO implement someday 
+	/*
+	public E get(int location) {
+		return null;
+	}
+	*/
+
+	public boolean contains(Object object) {
+		for (E e : this) {
+			if (e.equals(object)) return true;
+		}
+		return false;
+	}
+
+	public boolean containsAll(Collection<?> collection) {
+		for (Object o : collection) {
+			if (!contains(o)) return false;
+		}
+		return true;
+	}
+
+
+////		List<String> needle = Arrays.asList(new String[]{"value2", "value3"});
+//		Pool<String> pool = new Pool<String>(new String[]{"xxlue1", "xxlue2", "xxlue3", "xxlue4", "xxlue5", "xxlue6", "xxlue7", "xxlue8", "xxlue9"}, 15);
+//		System.out.println(""+pool.isEmpty()+"|"+pool.size());
+//		pool.add("value1");
+//		pool.add("value2");
+//		pool.add("value3");
+//		Pool.<String>dumpPool(pool);
+//		System.out.println("------ after 3 add()");
+//		System.out.println(""+pool.isEmpty()+"|"+pool.size());
+////		pool.add("value4");
+////		pool.add("value5");
+////		Pool.<String>dumpPool(pool);
+////		System.out.println("------ after 5 add()");
+////		System.out.println(""+pool.isEmpty()+"|"+pool.size());
+////		pool.add("value6");
+////		pool.add("value7");
+////		Pool.<String>dumpPool(pool);
+////		System.out.println("------ after 7 add()");
+////		System.out.println(""+pool.isEmpty()+"|"+pool.size());
+////		pool.clear();
+////		Pool.<String>dumpPool(pool);
+////		System.out.println(""+pool.isEmpty()+"|"+pool.size());
+////		System.out.println(pool.containsAll(needle));
+//		
+////		Pool<String> pool = new Pool<String>(new String[]{"xxlue1", "xxlue2", "xxlue3", "xxlue4", "xxlue5", "xxlue6", "xxlue7", "xxlue8", "xxlue9"});
+////		Pool.<String>dumpPool(pool);
+////		System.out.println(""+pool.isEmpty()+"|"+pool.size());
+////		pool.add("value1");
+////		pool.add("value2");
+////		pool.add("value3");
+////		Pool.<String>dumpPool(pool);
+////		System.out.println(""+pool.isEmpty()+"|"+pool.size());
+//	}
+//	
+//	private static <T> void dumpPool(Pool<T> pool) {
+//		for (T s : pool) {
+//			System.out.println(s);
+//		}
+//	}
+	
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Size.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Size.java
new file mode 100644
index 000000000..b57bfd7f7
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/Size.java
@@ -0,0 +1,25 @@
+package ru.johnlife.lifetools.data;
+
+public final class Size {
+    private final int w;
+    private final int h;
+    private final double ratio;
+
+    public Size(int width, int height) {
+        this.w = width;
+        this.h = height;
+        this.ratio = ((double)w)/h;
+    }
+
+    public int getWidth() {
+        return w;
+    }
+
+    public int getHeight() {
+        return h;
+    }
+
+    public double getRatio() {
+        return ratio;
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/SparseList.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/SparseList.java
new file mode 100644
index 000000000..222c3aca6
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/data/SparseList.java
@@ -0,0 +1,115 @@
+package ru.johnlife.lifetools.data;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import android.util.SparseArray;
+
+import ru.johnlife.lifetools.optional.Iffy;
+
+public class SparseList<E> extends SparseArray<E> implements Iterable<E> {
+	
+	private List<E> list;
+	private boolean listIsConsistent = false;
+
+	public SparseList() {
+		super();
+	}
+
+	public SparseList(int initialCapacity) {
+		super(initialCapacity);
+	}
+
+	public static <T extends Identifiable<Integer>> SparseList<T> from(List<T> list) {
+		if (list == null) return new SparseList<>();
+		SparseList<T> value = new SparseList<>(list.size());
+		for (T item : list) {
+			value.put(item.getId(), item);
+		}
+		return value;
+	}
+
+	public List<E> asList() {
+		if (listIsConsistent) {
+			return list;
+		} else {
+			int size = size();
+			if (list == null) {
+				list = new ArrayList<>(size);
+			} else {
+				list.clear();
+			}
+			for (int i = 0; i < size; i++) {
+				list.add(valueAt(i));
+			}
+			listIsConsistent = true;
+			return list;
+		}
+	}
+
+	private void modified() {
+		listIsConsistent = false;
+	}
+
+	@Override
+	public void delete(int key) {
+		modified();
+		super.delete(key);
+	}
+
+	@Override
+	public void remove(int key) {
+		modified();
+		super.remove(key);
+	}
+
+	@Override
+	public void put(int key, E value) {
+		modified();
+		super.put(key, value);
+	}
+
+	@Override
+	public void clear() {
+		modified();
+		super.clear();
+	}
+
+	@Override
+	public void append(int key, E value) {
+		modified();
+		super.append(key, value);
+	}
+
+	public boolean isEmpty() {
+		return 0 == size();
+	}
+
+	@Override
+	public Iterator<E> iterator() {
+		return new Iterator<E>() {
+			int i = 0;
+			@Override
+			public boolean hasNext() {
+				return i < size();
+			}
+
+			@Override
+			public E next() {
+				return valueAt(i++);
+			}
+
+			@Override
+			public void remove() {
+				throw new UnsupportedOperationException();
+			}
+		};
+	}
+
+	public Iffy<E> find(int key) {
+		return new Iffy<>(get(key));
+	}
+
+
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/essentials/Constants.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/essentials/Constants.java
new file mode 100644
index 000000000..33edd92dd
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/essentials/Constants.java
@@ -0,0 +1,20 @@
+package ru.johnlife.lifetools.essentials;
+
+import java.text.SimpleDateFormat;
+import java.util.Locale;
+import java.util.TimeZone;
+
+public interface Constants {
+	String UTF_8 = "UTF-8";
+	Locale RUSSIAN = new Locale("ru");
+	Locale ENGLISH_US = Locale.US;
+	
+	long SECOND = 1000;
+	long MINUTE = 60 * SECOND;
+	long HOUR = 60 * MINUTE;
+	long DAY = 24 * HOUR;
+	long WEEK = 7 * DAY;
+	long MONTH = 30 * DAY;
+	long YEAR = 365 * DAY;
+    int NO_VALUE = Integer.MIN_VALUE+4;
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/event/MissingPermissionsEvent.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/event/MissingPermissionsEvent.java
new file mode 100644
index 000000000..25c0109ff
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/event/MissingPermissionsEvent.java
@@ -0,0 +1,18 @@
+package ru.johnlife.lifetools.event;
+
+/**
+ * Created by Yan Yurkin
+ * 18 November 2017
+ */
+
+public class MissingPermissionsEvent {
+    private String[] permissions;
+
+    public MissingPermissionsEvent(String[] permissions) {
+        this.permissions = permissions;
+    }
+
+    public String[] getPermissions() {
+        return permissions;
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/event/PermissionGrantedEvent.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/event/PermissionGrantedEvent.java
new file mode 100644
index 000000000..a967df5cd
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/event/PermissionGrantedEvent.java
@@ -0,0 +1,20 @@
+package ru.johnlife.lifetools.event;
+
+import java.util.List;
+
+/**
+ * Created by Yan Yurkin
+ * 18 November 2017
+ */
+
+public class PermissionGrantedEvent {
+    private List<String> granted;
+
+    public PermissionGrantedEvent(List<String> granted) {
+        this.granted = granted;
+    }
+
+    public boolean contains(String permission) {
+        return granted.contains(permission);
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Action.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Action.java
new file mode 100644
index 000000000..e702c797a
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Action.java
@@ -0,0 +1,5 @@
+package ru.johnlife.lifetools.optional;
+
+public interface Action<T> {
+    void applyTo(T item);
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/ActionInt.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/ActionInt.java
new file mode 100644
index 000000000..c2d851462
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/ActionInt.java
@@ -0,0 +1,5 @@
+package ru.johnlife.lifetools.optional;
+
+public interface ActionInt {
+    void applyTo(int item);
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Iffy.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Iffy.java
new file mode 100644
index 000000000..cfdf72185
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Iffy.java
@@ -0,0 +1,56 @@
+package ru.johnlife.lifetools.optional;
+
+public class Iffy<V> {
+    public interface ValueProvider<T> {
+        T getValue();
+    }
+
+    public static <V> Iffy<V> from(V value) {
+        return new Iffy<>(value);
+    }
+
+    public interface Action<S> {
+        void apply(S value);
+    }
+
+    private V value;
+
+    public Iffy(V value) {
+        this.value = value;
+    }
+
+    public Iffy<V> defaultValue(V defaultValue) {
+        return value == null ? new Iffy<>(defaultValue) : this;
+    }
+
+    public Iffy<V> defaultValue(ValueProvider<V> provider) {
+        return value == null ? new Iffy<>(provider.getValue()) : this;
+    }
+
+    public MappingResult ifPresent(Action<V> action) {
+        if (null != value) {
+            action.apply(value);
+            return MappingResult.SUCCESS;
+        }
+        return MappingResult.FAIL;
+    }
+
+    public boolean isPresent() {
+        return null != value;
+    }
+
+
+    public V get() {
+        return value;
+    }
+
+    public static <E> Iffy<E> empty() {
+        return new Iffy<>(null);
+    }
+
+    /*@Override
+    public boolean equals(Object obj) {
+        Object a = (obj instanceof Iffy) ? ((Iffy) obj).value : obj;
+        return (null == value && null == a) || (null != value && null != a && value.equals(a));
+    }*/
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Mapper.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Mapper.java
new file mode 100644
index 000000000..f592a4a8c
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/Mapper.java
@@ -0,0 +1,56 @@
+package ru.johnlife.lifetools.optional;
+
+import android.util.SparseArray;
+
+public class Mapper<T> {
+    private SparseArray<T> map = new SparseArray<>();
+    private T defaultValue = null;
+
+    public Mapper<T> add(String key, T value) {
+        return add(key.hashCode(), value);
+    }
+
+    public Mapper<T> add(int key, T value) {
+        map.put(key, value);
+        return this;
+    }
+
+    public Mapper<T> defaultValue(T value) {
+        defaultValue = value;
+        return this;
+    }
+
+    public MappingResult performOn(String key, Action<T> action) {
+        return performOn(key.hashCode(), action);
+    }
+
+    public MappingResult performOn(int key, Action<T> action) {
+        return get(key).ifPresent(action::applyTo);
+    }
+
+    public Iffy<T> get(String key) {
+        return get(key.hashCode());
+    }
+
+    public Iffy<T> get(int key) {
+        T value = map.get(key);
+        if (value == null) {
+            value = defaultValue;
+        }
+        return Iffy.from(value);
+    }
+
+    public Iffy<Integer> findKeyFor(T value) {
+        if (value == null) return Iffy.empty();
+        for (int i = 0; i < map.size(); i++) {
+            if (value.equals(map.valueAt(i))) {
+                return Iffy.from(map.keyAt(i));
+            }
+        }
+        return Iffy.empty();
+    }
+
+    public boolean isEmpty() {
+        return map.size() == 0 || defaultValue != null;
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/MapperInt.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/MapperInt.java
new file mode 100644
index 000000000..a988ab611
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/MapperInt.java
@@ -0,0 +1,77 @@
+package ru.johnlife.lifetools.optional;
+
+import android.util.SparseIntArray;
+
+import static ru.johnlife.lifetools.essentials.Constants.NO_VALUE;
+
+public class MapperInt {
+    private SparseIntArray map = new SparseIntArray();
+    private int defaultValue = NO_VALUE;
+
+    public MapperInt add(String key, int value) {
+        return add(key.hashCode(), value);
+    }
+
+    public MapperInt add(int key, int value) {
+        map.put(key, value);
+        return this;
+    }
+
+    public MapperInt defaultValue(int value) {
+        defaultValue = value;
+        return this;
+    }
+
+    public MappingResult performOn(String key, ActionInt action) {
+        return performOn(key.hashCode(), action);
+    }
+
+    public MappingResult performOn(int key, ActionInt action) {
+        int value = map.get(key, NO_VALUE);
+        if (value == NO_VALUE) {
+            value = defaultValue;
+        }
+        if (value != NO_VALUE) {
+            action.applyTo(value);
+            return MappingResult.SUCCESS;
+        }
+        return MappingResult.FAIL;
+    }
+
+    /**
+     * DON'T USE THIS UNLESS YOU REALLY HAVE TO
+     * It does autoboxing int to Integer, so in intense usage it
+     * will drain all your memory in couple of seconds
+     * */
+    public Iffy<Integer> get(String key) {
+        return get(key.hashCode());
+    }
+    /**
+     * DON'T USE THIS UNLESS YOU REALLY HAVE TO
+     * It does autoboxing int to Integer, so in intense usage it
+     * will drain all your memory in couple of seconds
+     * */
+    public Iffy<Integer> get(int key) {
+        int value = map.get(key);
+        if (value == NO_VALUE) {
+            value = defaultValue;
+        }
+        return Iffy.from(value);
+    }
+
+
+    public Iffy<Integer> findKeyFor(int value) {
+        if (value == NO_VALUE) return Iffy.empty();
+        for (int i = 0; i < map.size(); i++) {
+            if (value == map.valueAt(i)) {
+                return Iffy.from(map.keyAt(i));
+            }
+        }
+        return Iffy.empty();
+    }
+
+    public boolean isEmpty() {
+        return map.size() == 0 || defaultValue != NO_VALUE;
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/MappingResult.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/MappingResult.java
new file mode 100644
index 000000000..3035ee49a
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/optional/MappingResult.java
@@ -0,0 +1,11 @@
+package ru.johnlife.lifetools.optional;
+
+public interface MappingResult {
+    MappingResult SUCCESS = action -> {
+        //do nothing
+    };
+
+    MappingResult FAIL = Runnable::run;
+
+    void orElse(Runnable action);
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/OnCompleteListener.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/OnCompleteListener.java
new file mode 100644
index 000000000..5bfc0da59
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/OnCompleteListener.java
@@ -0,0 +1,5 @@
+package ru.johnlife.lifetools.task;
+
+public interface OnCompleteListener<T> {
+    void onReady(T data);
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/Queue.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/Queue.java
new file mode 100644
index 000000000..66772217e
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/Queue.java
@@ -0,0 +1,32 @@
+package ru.johnlife.lifetools.task;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Queue {
+    private final List<Runnable> queue = new ArrayList<>();
+    private boolean running = false;
+
+    public void add(Runnable action) {
+        synchronized (queue) {
+            queue.add(action);
+        }
+        if (!running) {
+            runNext();
+        }
+    }
+
+    private void runNext() {
+        Runnable action;
+        synchronized (queue) {
+            if (queue.isEmpty()) {
+                running = false;
+                return;
+            }
+            action = queue.remove(0);
+        }
+        running = true;
+        action.run();
+        runNext();
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/QueuedTask.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/QueuedTask.java
new file mode 100644
index 000000000..d322b885d
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/QueuedTask.java
@@ -0,0 +1,27 @@
+package ru.johnlife.lifetools.task;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+public class QueuedTask extends Task {
+    private final static ExecutorService queue = Executors.newSingleThreadExecutor();
+    private Runnable action;
+
+    public QueuedTask(Runnable action) {
+        this.action = action;
+    }
+
+    @Override
+    protected void doInBackground() {
+        action.run();
+    }
+
+    @Override
+    public void execute() {
+        enqueue();
+    }
+
+    public void enqueue() {
+        executeOnExecutor(queue, (Void)null);
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/Task.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/Task.java
new file mode 100644
index 000000000..f1694707f
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/task/Task.java
@@ -0,0 +1,35 @@
+package ru.johnlife.lifetools.task;
+
+import android.annotation.SuppressLint;
+import android.os.AsyncTask;
+
+/**
+ * Created by yanyu on 5/11/2016.
+ */
+public abstract class Task extends AsyncTask<Void, Void, Void> {
+    protected abstract void doInBackground();
+
+    @Override
+    protected Void doInBackground(Void... params) {
+        doInBackground();
+        return null;
+    }
+
+    public void execute() {
+        executeOnExecutor(THREAD_POOL_EXECUTOR, (Void)null);
+    }
+
+    public boolean isRunning() {
+        return getStatus() == Status.RUNNING;
+    }
+
+    @SuppressLint("StaticFieldLeak")
+    public static void run(Runnable action) {
+        new Task(){
+            @Override
+            protected void doInBackground() {
+                action.run();
+            }
+        }.execute();
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Base64Bitmap.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Base64Bitmap.java
new file mode 100644
index 000000000..050e9b173
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Base64Bitmap.java
@@ -0,0 +1,33 @@
+package ru.johnlife.lifetools.tools;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.util.Base64;
+import android.util.LruCache;
+
+import java.io.ByteArrayOutputStream;
+
+/**
+ * Created by yanyu on 4/22/2016.
+ */
+public class Base64Bitmap {
+    private static LruCache<String, Bitmap> cache = new LruCache<>(50);
+
+    public static String encodeToBase64(Bitmap image) {
+        ByteArrayOutputStream byteArrayOS = new ByteArrayOutputStream();
+        image.compress(Bitmap.CompressFormat.JPEG, 75, byteArrayOS);
+        return Base64.encodeToString(byteArrayOS.toByteArray(), Base64.DEFAULT);
+    }
+
+    public static Bitmap decodeBase64(String input) {
+        Bitmap bitmap = cache.get(input);
+        if (bitmap != null) return bitmap;
+        try {
+            byte[] decodedBytes = Base64.decode(input, 0);
+            bitmap = BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.length);
+            return bitmap;
+        } catch (IllegalArgumentException e) {
+            return null;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ColorUtil.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ColorUtil.java
new file mode 100644
index 000000000..263ac6163
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ColorUtil.java
@@ -0,0 +1,24 @@
+package ru.johnlife.lifetools.tools;
+
+import android.graphics.Color;
+
+public class ColorUtil {
+    public static int parse(String color) {
+        String value = color;
+        if (color.startsWith("#") && color.length() < 7) {
+            String valuePart = color.substring(1);
+            char[] chars = valuePart.toCharArray();
+            char[] result = new char[chars.length * 2];
+            for (int i = 0; i < chars.length; i++) {
+                result[2*i] = chars[i];
+                result[2*i+1] = chars[i];
+            }
+            value = "#" + new String(result);
+        }
+        return Color.parseColor(value);
+    }
+
+    public static int alpha(int color, int alpha) {
+        return (0x00ffffff & color) | (alpha << 24);
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Connection.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Connection.java
new file mode 100644
index 000000000..51529c1ed
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Connection.java
@@ -0,0 +1,43 @@
+package ru.johnlife.lifetools.tools;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+
+/**
+ * Created by Yan Yurkin
+ * 15 June 2016
+ */
+public class Connection {
+    private static Connection instance;
+
+    public static Connection of(Context context) {
+        if (null == instance) {
+            instance = new Connection(context);
+        }
+        return instance;
+    }
+
+    private boolean hasWifi = false;
+    private boolean hasMobile = false;
+
+    private Connection(Context context) {
+        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo[] netInfo = cm.getAllNetworkInfo();
+        for (NetworkInfo ni : netInfo) {
+            if (ni.getTypeName().equalsIgnoreCase("WIFI"))
+                if (ni.isConnected())
+                    hasWifi = true;
+            if (ni.getTypeName().equalsIgnoreCase("MOBILE"))
+                if (ni.isConnected())
+                    hasMobile = true;
+        }
+    }
+
+    public boolean hasWifi() {
+        return hasWifi;
+    }
+    public boolean hasMobile() {
+        return hasMobile;
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Constrain.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Constrain.java
new file mode 100644
index 000000000..58d2070db
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Constrain.java
@@ -0,0 +1,35 @@
+package ru.johnlife.lifetools.tools;
+
+/**
+ * Created by User on 12/28/2017.
+ */
+
+public class Constrain {
+    public static int range(int value, int min, int max) {
+        if (value < min) return min;
+        if (value > max) return max;
+        return value;
+    }
+
+    public static int minimum(int value, int min) {
+        return (value < min) ? min : value;
+    }
+
+    public static int maximum(int value, int max) {
+        return (value > max) ? max : value;
+    }
+
+    public static float range(float value, float min, float max) {
+        if (value < min) return min;
+        if (value > max) return max;
+        return value;
+    }
+
+    public static float minimum(float value, float min) {
+        return (value < min) ? min : value;
+    }
+
+    public static float maximum(float value, float max) {
+        return (value > max) ? max : value;
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DateUtil.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DateUtil.java
new file mode 100644
index 000000000..5d2351bcd
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DateUtil.java
@@ -0,0 +1,26 @@
+package ru.johnlife.lifetools.tools;
+
+import java.util.Calendar;
+import java.util.TimeZone;
+
+/**
+ * Created by yanyu on 4/26/2016.
+ */
+public class DateUtil {
+    private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+    private static final Calendar tmp = Calendar.getInstance();
+
+    public static synchronized long getBeginOfTheDay(long timestamp) {
+//        tmp.setTimeZone(GMT);
+        tmp.setTimeInMillis(timestamp);
+        tmp.set(Calendar.HOUR_OF_DAY, 0);
+        tmp.set(Calendar.MINUTE, 0);
+        tmp.set(Calendar.SECOND, 0);
+        tmp.set(Calendar.MILLISECOND,1);
+        return tmp.getTimeInMillis();
+    }
+
+    public static synchronized long getBeginOfTheDay() {
+        return getBeginOfTheDay(System.currentTimeMillis());
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DefaultContext.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DefaultContext.java
new file mode 100644
index 000000000..82ede387d
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DefaultContext.java
@@ -0,0 +1,25 @@
+package ru.johnlife.lifetools.tools;
+
+import android.content.Context;
+import android.util.Log;
+
+/**
+ * Created by Yan Yurkin
+ * 18 November 2017
+ */
+
+public class DefaultContext {
+    /*package*/ static Context get() {
+        try {
+            return (Context) Class.forName("android.app.ActivityThread").getMethod("currentApplication").invoke(null, (Object[]) null);
+        } catch (Exception e) {
+            try {
+                Log.w("DefaultContext", "Reflection failed for ActivityThread", e);
+                return (Context) Class.forName("android.app.AppGlobals").getMethod("getInitialApplication").invoke(null, (Object[]) null);
+            } catch (Exception e1) {
+                Log.w("DefaultContext", "Reflection failed for AppGlobals", e);
+                return null;
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DeviceScreen.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DeviceScreen.java
new file mode 100644
index 000000000..3e849d4b7
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/DeviceScreen.java
@@ -0,0 +1,84 @@
+package ru.johnlife.lifetools.tools;
+
+import android.content.Context;
+import android.util.DisplayMetrics;
+
+public class DeviceScreen {
+
+	private int width;
+	private int height;
+	private int widthDpScaled;
+	private int heightDpScaled;
+	private float widthIn;
+	private float heightIn;
+	private int widthDp;
+	private int heightDp;
+	private float density;
+
+	public DeviceScreen(Context context) {
+		DisplayMetrics m = context.getResources().getDisplayMetrics();
+		width = m.widthPixels;
+		height = m.heightPixels;
+		density = m.density;
+		widthDp = (int)Math.ceil(((float)width)/density);
+		heightDp = (int)Math.ceil(((float)height)/density);
+		density = m.scaledDensity;
+		widthDpScaled = (int)Math.ceil(((float)width)/density);
+		heightDpScaled = (int)Math.ceil(((float)height)/density);
+		widthIn = width / m.xdpi;
+		heightIn = height / m.ydpi;
+	}
+
+	public int getWidth() {
+		return width;
+	}
+
+	public int getHeight() {
+		return height;
+	}
+
+	public int getSmallestWidth() {
+		return Math.min(width, height);
+	}
+	
+	public int getLargestWidth() {
+		return Math.max(width, height);
+	}
+
+	public int getWidthDpScaled() {
+		return widthDpScaled;
+	}
+
+	public int getHeightDpScaled() {
+		return heightDpScaled;
+	}
+
+	public int getWidthDp() {
+		return widthDp;
+	}
+
+	public int getHeightDp() {
+		return heightDp;
+	}
+
+	public float getWidthIn() {
+		return widthIn;
+	}
+
+	public float getHeightIn() {
+		return heightIn;
+	}
+
+	public float getDensity() {
+		return density;
+	}
+
+
+	public boolean isLandscape() {
+		return width > height;
+	}
+
+	public boolean isPortrait() {
+		return width < height;
+	}
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Distance.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Distance.java
new file mode 100644
index 000000000..d333c82c6
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Distance.java
@@ -0,0 +1,19 @@
+package ru.johnlife.lifetools.tools;
+
+import android.location.Location;
+
+public class Distance {
+    public static float between(Location a, Location b) {
+        return between(a.getLatitude(), a.getLongitude(), b.getLatitude(), b.getLongitude());
+    }
+
+    public static float between(Location a, double latB, double lngB) {
+        return between(a.getLatitude(), a.getLongitude(), latB, lngB);
+    }
+
+    public static float between(double lat1, double lng1, double lat2, double lng2) {
+        float[] d = new float[1];
+        Location.distanceBetween(lat1, lng1, lat2, lng2, d);
+        return d[0];
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Downloader.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Downloader.java
new file mode 100644
index 000000000..3f5fec57c
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Downloader.java
@@ -0,0 +1,30 @@
+package ru.johnlife.lifetools.tools;
+
+import android.app.DownloadManager;
+import android.content.Context;
+import android.net.Uri;
+import android.os.Environment;
+
+import java.io.File;
+
+public class Downloader {
+    public static void download(String url, String title, String description, String fileName) {
+        Context context = DefaultContext.get();
+        File dir = new File(Environment.getExternalStorageDirectory(), Environment.DIRECTORY_DOWNLOADS);
+        if (!dir.exists()) {
+            dir.mkdirs();
+        }
+        DownloadManager downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);
+        Uri uri = Uri.parse(url);
+        DownloadManager.Request request = new DownloadManager.Request(uri);
+        request
+            .setAllowedNetworkTypes(DownloadManager.Request.NETWORK_WIFI | DownloadManager.Request.NETWORK_MOBILE)
+            .setAllowedOverRoaming(false)
+            .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
+            .setTitle(title)
+            .setDescription(description)
+            .setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);
+
+        downloadManager.enqueue(request);
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Dp2Px.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Dp2Px.java
new file mode 100644
index 000000000..b00b9085b
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Dp2Px.java
@@ -0,0 +1,20 @@
+package ru.johnlife.lifetools.tools;
+
+import android.content.Context;
+import android.util.TypedValue;
+
+/**
+ * Created by Yan Yurkin
+ * 18 November 2017
+ */
+
+public class Dp2Px {
+    public static int convert(int dp, Context context) {
+        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, context.getResources().getDisplayMetrics());
+    }
+
+    public static int convert(int dp) {
+        return convert(dp, DefaultContext.get());
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/HideKeyboard.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/HideKeyboard.java
new file mode 100644
index 000000000..c471ff1e6
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/HideKeyboard.java
@@ -0,0 +1,17 @@
+package ru.johnlife.lifetools.tools;
+
+import android.content.Context;
+import android.view.View;
+import android.view.inputmethod.InputMethodManager;
+
+/**
+ * Created by Yan Yurkin
+ * 03 May 2017
+ */
+
+public class HideKeyboard {
+    public static void forView(View v) {
+        InputMethodManager imm = (InputMethodManager)v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+        imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/KeyHelper.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/KeyHelper.java
new file mode 100644
index 000000000..41ae8ee51
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/KeyHelper.java
@@ -0,0 +1,51 @@
+package ru.johnlife.lifetools.tools;
+
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.View;
+
+import java.util.Arrays;
+
+/**
+ * Created by Yan Yurkin
+ * 24 July 2016
+ */
+public abstract class KeyHelper {
+    private long[] times = new long[3];
+    private boolean next = true;
+
+    public boolean onKeyDown(int keyCode) {
+        if (KeyEvent.KEYCODE_VOLUME_UP == keyCode) {
+            if (!next) return false;
+            times[0] = times[1];
+            times[1] = times[2];
+            times[2] = System.currentTimeMillis();
+            next = false;
+            Log.i(getClass().getSimpleName(), "onKeyDown: volumeUp, " + Arrays.toString(times));
+        } else if (KeyEvent.KEYCODE_VOLUME_DOWN == keyCode) {
+            Log.i(getClass().getSimpleName(), "onKeyDown: volumeDown, next");
+            next = true;
+            if (System.currentTimeMillis() - times[0] < 5000) {
+                onLaunch();
+            }
+        }
+        return false;
+    }
+
+    protected abstract void onLaunch();
+
+    public KeyHelper attachTo(View view) {
+        view.setFocusableInTouchMode(true);
+        view.requestFocus();
+        view.setOnKeyListener(new View.OnKeyListener() {
+            @Override
+            public boolean onKey(View v, int keyCode, KeyEvent event) {
+                if (event.getAction() != KeyEvent.ACTION_DOWN) return true;
+                Log.i(getClass().getSimpleName(), "Key Down!");
+                onKeyDown(keyCode);
+                return true;
+            }
+        });
+        return this;
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ListUtil.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ListUtil.java
new file mode 100644
index 000000000..41742b493
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ListUtil.java
@@ -0,0 +1,74 @@
+package ru.johnlife.lifetools.tools;
+
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import ru.johnlife.lifetools.data.Identifiable;
+import ru.johnlife.lifetools.optional.Iffy;
+
+public class ListUtil {
+    public interface Collector<T, E> {
+        T collect(E item);
+    }
+    public static  <T, E> List<T> collect(List<E> source, Collector<T, E> collector) {
+        final List<T> value = new ArrayList<>(source.size());
+        for (E e : source) {
+            value.add(collector.collect(e));
+        }
+        return value;
+    }
+    public static  <T, E> List<T> collect(Iterable<E> source, Collector<T, E> collector) {
+        final List<T> value = new ArrayList<T>();
+        for (E e : source) {
+            value.add(collector.collect(e));
+        }
+        return value;
+    }
+
+
+
+    public interface Filter<T> {
+        boolean take(T item);
+    }
+    public static  <T> List<T> filter(List<T> source, Filter<T> filter) {
+        final List<T> value = new ArrayList<>(source.size());
+        for (T t : source) {
+            if (filter.take(t)) value.add(t);
+        }
+        return value;
+    }
+
+    public static <T> Iffy<T> find(Iterable<T> where, Filter<T> filter) {
+        for (T t : where) {
+            if (filter.take(t)) return Iffy.from(t);
+        }
+        return Iffy.empty();
+    }
+
+    public interface IdExtractor<ID, T> {
+        Identifiable<ID> getIdentifiable(T item);
+    }
+
+    public static <T, ID> Iffy<T> find(Iterable<T> where, ID id, IdExtractor<ID, T> extractor) {
+        if (id == null) {
+            return Iffy.empty();
+        }
+        return find(where, t-> id.equals(extractor.getIdentifiable(t).getId()));
+    }
+
+    public static <T> void shift(List<T> list, int from, int to) {
+        if (from == to || from >= list.size() || from < 0) return;
+        int d = from > to ? -1 : 1;
+        T target = list.get(from);
+        try {
+            for (int i = from; i != to; i += d) {
+                list.set(i, list.get(i+d));
+            }
+            list.set(to, target);
+        } catch (ArrayIndexOutOfBoundsException e) {
+            Log.w("ListUtils", "shift: ", e);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/LogTrace.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/LogTrace.java
new file mode 100644
index 000000000..297f4fb9f
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/LogTrace.java
@@ -0,0 +1,43 @@
+package ru.johnlife.lifetools.tools;
+
+import android.support.annotation.NonNull;
+import android.util.Log;
+
+/**
+ * Created by yanyu on 4/23/2016.
+ */
+public class LogTrace {
+    public static void d(String tag, int lastN) {
+        Log.d(tag, build(lastN));
+    }
+
+    public static void i(String tag, int lastN) {
+        Log.i(tag, build(lastN));
+    }
+
+    public static void w(String tag, int lastN) {
+        Log.w(tag, build(lastN));
+    }
+
+    @NonNull
+    private static String build(int lastN) {
+        try {
+            throw new Exception();
+        } catch (Exception e) {
+            int dx = 3;
+            StackTraceElement[] trace = e.getStackTrace();
+            StringBuilder b = new StringBuilder();
+            for (int i=dx; i<lastN+dx; i++) {
+                StackTraceElement entry = trace[i];
+                String s = entry.toString();
+                if (s.contains(".access$")) {
+                    dx++;
+                    continue;
+                }
+                b.append(" - ").append(entry).append('\n');
+            }
+            return b.toString();
+        }
+
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/OnDoneActionListener.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/OnDoneActionListener.java
new file mode 100644
index 000000000..19f00610a
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/OnDoneActionListener.java
@@ -0,0 +1,29 @@
+package ru.johnlife.lifetools.tools;
+
+import android.view.KeyEvent;
+import android.view.inputmethod.EditorInfo;
+import android.widget.TextView;
+
+/**
+ * Created by Yan Yurkin
+ * 03 May 2017
+ */
+
+public abstract class OnDoneActionListener implements TextView.OnEditorActionListener {
+    @Override
+    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+        if (actionId == EditorInfo.IME_ACTION_SEARCH
+            || actionId == EditorInfo.IME_ACTION_DONE
+            || actionId == EditorInfo.IME_ACTION_GO
+            || (null != event &&
+            event.getAction() == KeyEvent.ACTION_DOWN &&
+            event.getKeyCode() == KeyEvent.KEYCODE_ENTER)) {
+            HideKeyboard.forView(v);
+            act(v);
+            return true;
+        }
+        return false;
+    }
+
+    protected abstract void act(TextView v);
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/OpenInBrowser.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/OpenInBrowser.java
new file mode 100644
index 000000000..88049dbc6
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/OpenInBrowser.java
@@ -0,0 +1,31 @@
+package ru.johnlife.lifetools.tools;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+
+/**
+ * Created by yanyu on 5/12/2016.
+ */
+public class OpenInBrowser {
+
+    private static final String MAILTO_PREFIX = "mailto:";
+
+    public static void url(Context context, String url) {
+        if (url.toLowerCase().startsWith(MAILTO_PREFIX)) {
+            mail(context, url);
+            return;
+        }
+        if (!url.startsWith("https://") && !url.startsWith("http://")){
+            url = "http://" + url;
+        }
+        context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
+    }
+
+    private static void mail(Context context, String url) {
+        if (!url.startsWith(MAILTO_PREFIX)) {
+            return;
+        }
+        context.startActivity(new Intent(Intent.ACTION_SENDTO, Uri.parse(url)));
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Restart.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Restart.java
new file mode 100644
index 000000000..4e05089ac
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Restart.java
@@ -0,0 +1,33 @@
+package ru.johnlife.lifetools.tools;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.content.Context;
+import android.content.Intent;
+
+/**
+ * Created by Yan Yurkin on 6/2/2016.
+ */
+public class Restart {
+
+    public static void app(Context context) {
+        scheduleRestart(context);
+        kill();
+    }
+
+    private static void scheduleRestart(Context context) {
+        String name = context.getPackageName();
+        Intent intent = context.getPackageManager().getLaunchIntentForPackage(name);
+        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        PendingIntent mPendingIntent = PendingIntent.getActivity(context, name.hashCode(), intent, PendingIntent.FLAG_CANCEL_CURRENT);
+        AlarmManager am = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
+        am.set(AlarmManager.RTC, System.currentTimeMillis() + 100, mPendingIntent);
+    }
+
+    private static void kill() {
+        //double kill
+        android.os.Process.killProcess(android.os.Process.myPid());
+        System.exit(1);
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ScaleBitmap.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ScaleBitmap.java
new file mode 100644
index 000000000..889197ddb
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ScaleBitmap.java
@@ -0,0 +1,40 @@
+package ru.johnlife.lifetools.tools;
+
+import android.graphics.Bitmap;
+import android.graphics.Matrix;
+import android.graphics.RectF;
+
+import ru.johnlife.lifetools.data.Size;
+
+/**
+ * Created by Yan Yurkin
+ * 19 November 2017
+ */
+
+public class ScaleBitmap {
+
+    public static Bitmap maintainAspect(Bitmap source, int width, int height) {
+        Matrix m = new Matrix();
+        m.setRectToRect(new RectF(0, 0, source.getWidth(), source.getHeight()), new RectF(0, 0, width, height), Matrix.ScaleToFit.CENTER);
+        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), m, true);
+    }
+
+    public static Bitmap toLongest(Bitmap source, int longest) {
+        return maintainAspect(source, longest, longest);
+    }
+
+    public static Bitmap toWidth(Bitmap source, int width) {
+        return maintainAspect(source, width, Integer.MAX_VALUE);
+    }
+
+    public static Bitmap toHeight(Bitmap source, int height) {
+        return maintainAspect(source, Integer.MAX_VALUE, height);
+    }
+
+    public static Size maintainAspect(Size source, int width, int height) {
+        Size target = new Size(width, height);
+        double minRatio = Math.min(source.getRatio(), target.getRatio());
+        double maxRatio = Math.max(source.getRatio(), target.getRatio());
+        return new Size((int)(height * minRatio), (int)(width/maxRatio));
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/StringUtil.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/StringUtil.java
new file mode 100644
index 000000000..9762b0964
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/StringUtil.java
@@ -0,0 +1,58 @@
+package ru.johnlife.lifetools.tools;
+
+import android.util.SparseArray;
+
+import java.util.List;
+
+import ru.johnlife.lifetools.data.SparseList;
+
+/**
+ * Created by yanyu on 5/21/2016.
+ */
+public class StringUtil {
+    public interface Transformer<T> {
+        String transform(T object);
+    }
+
+    public interface SparseArrayTransformer {
+        String transform(int idx);
+    }
+
+    public static <T> String implode(SparseArray<T> what, String delimeter, SparseArrayTransformer transformer) {
+        if (what == null) return "";
+        String[] array = new String[what.size()];
+        for (int i = 0; i < what.size(); i++) {
+            array[i] = transformer.transform(i);
+        }
+        return implode(array, delimeter);
+    }
+
+    public static <T> String implode(List<T> what, String delimeter, Transformer<T> transformer) {
+        if (what == null) return "";
+        String[] array = new String[what.size()];
+        int i = 0;
+        for (T object : what) {
+            array[i++] = transformer.transform(object);
+        }
+        return implode(array, delimeter);
+    }
+
+    public static <T> String implode(Iterable<T> what, String delimeter, Transformer<T> transformer) {
+        return implode(ListUtil.collect(what, v->v), delimeter, transformer);
+    }
+
+    public static String implode(List<String> what, String delimeter) {
+        if (what == null) return "";
+        return implode(what.toArray(new String[]{}), delimeter);
+    }
+
+    public static String implode(String[] what, String delimeter) {
+        if (what == null || what.length == 0) return "";
+        StringBuilder b = new StringBuilder();
+        for (String s : what) {
+            b.append(s).append(delimeter);
+        }
+        b.delete(b.length()-delimeter.length(),b.length());
+        return b.toString();
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/StyledStringBuilder.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/StyledStringBuilder.java
new file mode 100644
index 000000000..fd63762a0
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/StyledStringBuilder.java
@@ -0,0 +1,46 @@
+package ru.johnlife.lifetools.tools;
+
+import android.content.Context;
+import android.support.annotation.StringRes;
+import android.support.annotation.StyleRes;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.style.TextAppearanceSpan;
+
+/**
+ * Created by Yan Yurkin
+ * 15 June 2016
+ */
+public class StyledStringBuilder {
+    private Context context;
+    private SpannableStringBuilder b = new SpannableStringBuilder();
+
+    public StyledStringBuilder(Context context) {
+        this.context = context;
+    }
+
+    public StyledStringBuilder append(@StringRes int s, @StyleRes int style) {
+        return append(context.getResources().getString(s), style);
+    }
+
+    public StyledStringBuilder append(String s, @StyleRes int style) {
+        if (s == null) return this;
+        int start = b.length();
+        b.append(s);
+        int end = b.length();
+        b.setSpan(getStyle(style), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
+        return this;
+    }
+
+    private TextAppearanceSpan getStyle(int style) {
+        return new TextAppearanceSpan(context, style);
+    }
+
+    public Spanned build() {
+        return b;
+    }
+
+    public void clear() {
+        b.clear();
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Timestamp.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Timestamp.java
new file mode 100644
index 000000000..c77df35c2
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/Timestamp.java
@@ -0,0 +1,10 @@
+package ru.johnlife.lifetools.tools;
+
+/**
+ * Created by Yan Yurkin on 5/30/2016.
+ */
+public class Timestamp {
+    public static int toSparseKey(long timestamp) {
+        return (int) ( (timestamp/1000)&Integer.MAX_VALUE );
+    }
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ToString.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ToString.java
new file mode 100644
index 000000000..124294bf4
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ToString.java
@@ -0,0 +1,18 @@
+package ru.johnlife.lifetools.tools;
+
+import android.view.View;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class ToString {
+    private static final Pattern ivPattern = Pattern.compile("[^{]+\\{(\\S+).+");
+
+    public static String view(View v) {
+        if (null == v) return "null";
+        String src = v.toString();
+        Matcher matcher = ivPattern.matcher(src);
+        return matcher.find() ? matcher.group(1) : src;
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/UniqueId.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/UniqueId.java
new file mode 100644
index 000000000..7caadf40e
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/UniqueId.java
@@ -0,0 +1,38 @@
+package ru.johnlife.lifetools.tools;
+
+import java.util.UUID;
+
+import android.content.Context;
+import android.os.Build;
+import android.provider.Settings.Secure;
+
+public class UniqueId {
+	private static String id = null;
+	
+	public static String get(Context context) {
+		if (null == id) {
+			id = generate(context);
+		}
+		return id;
+	}
+	
+	private static String generate(Context context) {
+		String androidId = Secure.getString(context.getContentResolver(), Secure.ANDROID_ID);
+		long buildId = 0;
+		buildId = buildId << 2 | Build.BOARD.hashCode()%100;
+		buildId = buildId << 2 | Build.BRAND.hashCode()%100;
+		buildId = buildId << 2 | Build.CPU_ABI.hashCode()%100;
+		buildId = buildId << 2 | Build.DEVICE.hashCode()%100;
+		buildId = buildId << 2 | Build.DISPLAY.hashCode()%100;
+		buildId = buildId << 2 | Build.HOST.hashCode()%100;
+		buildId = buildId << 2 | Build.ID.hashCode()%100;
+		buildId = buildId << 2 | Build.MANUFACTURER.hashCode()%100;
+		buildId = buildId << 2 | Build.MODEL.hashCode()%100;
+		buildId = buildId << 2 | Build.PRODUCT.hashCode()%100;
+		buildId = buildId << 2 | Build.TAGS.hashCode()%100;
+		buildId = buildId << 2 | Build.TYPE.hashCode()%100;
+		buildId = buildId << 2 | Build.USER.hashCode()%100; 
+	    UUID deviceUuid = new UUID(androidId.hashCode(), buildId);
+	    return deviceUuid.toString();
+	}
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ValidationUtils.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ValidationUtils.java
new file mode 100644
index 000000000..ac7b97017
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ValidationUtils.java
@@ -0,0 +1,94 @@
+package ru.johnlife.lifetools.tools;
+
+import android.view.View;
+import android.widget.Spinner;
+import android.widget.TextView;
+
+import org.w3c.dom.Text;
+
+import java.util.regex.Pattern;
+
+/**
+ * Created by Yan Yurkin
+ * 23 November 2017
+ */
+
+public class ValidationUtils {
+    private static final Pattern namePattern = Pattern.compile("^[A-Za-z ]+$");
+    private static final Pattern phonePattern = Pattern.compile("^\\+855[0-9]{8,9}$");
+    private static final Pattern imeiPattern = Pattern.compile("^[0-9]{14,15}$");
+    private static final Pattern IdNumberPattern = Pattern.compile("^[0-9A-Z\\s]+$");
+    private static final Pattern emailPattern = Pattern.compile("^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$");
+
+    public interface Validator {
+        boolean isValid();
+    }
+
+    public static boolean validate(TextView view, Validator validator, String error) {
+        boolean valid = validator.isValid();
+        if (!valid) {
+            view.setError(error);
+        }
+        return valid;
+    }
+
+    public static boolean validate(Spinner view, Validator validator, String error){
+        boolean valid = validator.isValid();
+        TextView selectedView = (TextView) view.getSelectedView();
+        if (!valid && null != selectedView) {
+            selectedView.setError(error);
+        }
+        return valid;
+    }
+
+    public static boolean validate(Validator validator, Runnable actionOnInvalid) {
+        boolean valid = validator.isValid();
+        if (!valid) {
+            actionOnInvalid.run();
+        }
+        return valid;
+
+    }
+
+    public static boolean validateNonEmpty(TextView view) {
+        if (view.getText().toString().isEmpty()) {
+            view.setError("This field cannot be empty");
+            return false;
+        }
+        return true;
+    }
+
+    public static boolean validateName(TextView view) {
+        return validateWithPattern(view, ValidationUtils.namePattern, "This should be valid name");
+    }
+
+    public static boolean validatePhone(TextView view) {
+        return validateWithPattern(view, phonePattern, "This should be a phone in +85599999999 format");
+    }
+
+    public static boolean validateEmail(TextView view) {
+        return validateWithPattern(view, emailPattern, "This should be a valid email address");
+    }
+
+    public static boolean validateIMEI(TextView view) {
+        return validateWithPattern(view, imeiPattern, "This should be a valid IMEI");
+    }
+
+    public static boolean validateIDNumber(TextView view) {
+        return validateWithPattern(view, IdNumberPattern, "This should be valid ID Number");
+    }
+
+    private static boolean validateWithPattern(TextView view, Pattern pattern, String error) {
+        if (!validateNonEmpty(view)) return false;
+        if (!pattern.matcher(view.getText()).matches()) {
+            view.setError(error);
+            return false;
+        }
+        return true;
+    }
+
+    public static boolean isValidIMEI(String imei) {
+        return imeiPattern.matcher(imei).matches();
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ViewFinder.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ViewFinder.java
new file mode 100644
index 000000000..126d213d4
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/tools/ViewFinder.java
@@ -0,0 +1,52 @@
+package ru.johnlife.lifetools.tools;
+
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+
+import ru.johnlife.lifetools.optional.Iffy;
+
+public class ViewFinder {
+
+    public interface Finder {
+        boolean isFound(View suspect);
+    }
+
+    public static Iffy<View> findChild(View view, Finder finder) {
+        if (null == view) return null;
+        if (finder.isFound(view)) return Iffy.from(view);
+        if (view instanceof ViewGroup) {
+            ViewGroup group = (ViewGroup) view;
+            for (int i=0; i<group.getChildCount(); i++) {
+                Iffy<View> value = findChild(group.getChildAt(i), finder);
+                if (null != value.get()) return value;
+            }
+        }
+        return Iffy.empty();
+    }
+
+    public static Iffy<View> findNearestParent(View view, Finder finder) {
+        if (null == view) return null;
+        if (finder.isFound(view)) return Iffy.from(view);
+        ViewParent parent = view.getParent();
+        if (parent != null) {
+            return findNearestParent((View) parent, finder);
+        }
+        return Iffy.empty();
+    }
+
+    public static Iffy<View> findTopmostParent(View view, Finder finder) {
+        if (null == view) return null;
+        ViewParent parent = view.getParent();
+        if (parent instanceof View) {
+            Iffy<View> value = findTopmostParent((View) parent, finder);
+            if (value.isPresent()) {
+                return value;
+            } else {
+                if (finder.isFound(view)) return Iffy.from(view);
+            }
+        }
+        return Iffy.empty();
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/ui/Performer.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/ui/Performer.java
new file mode 100644
index 000000000..b205f5aa9
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/ui/Performer.java
@@ -0,0 +1,34 @@
+package ru.johnlife.lifetools.ui;
+
+import android.content.Context;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.TextView;
+
+public abstract class Performer implements TextView.OnEditorActionListener, View.OnFocusChangeListener  {
+	public abstract void perform();
+	
+	@Override
+	public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+		if (actionId != EditorInfo.IME_NULL) {
+			perform();
+			if (actionId == EditorInfo.IME_ACTION_DONE) {
+				InputMethodManager imm = (InputMethodManager)v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+				imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
+				return true;
+			} else {
+				return false;
+			}
+		} 
+		return false;
+	}
+
+	@Override
+	public void onFocusChange(View v, boolean hasFocus) {
+		if (!hasFocus) {
+			perform();
+		} 
+	}
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/ru/johnlife/lifetools/ui/ZoomLayout.java b/TMessagesProj/src/main/java/ru/johnlife/lifetools/ui/ZoomLayout.java
new file mode 100644
index 000000000..76712ff49
--- /dev/null
+++ b/TMessagesProj/src/main/java/ru/johnlife/lifetools/ui/ZoomLayout.java
@@ -0,0 +1,199 @@
+package ru.johnlife.lifetools.ui;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.GestureDetector;
+import android.view.MotionEvent;
+import android.view.ScaleGestureDetector;
+import android.view.View;
+import android.view.animation.DecelerateInterpolator;
+import android.widget.FrameLayout;
+
+import ru.johnlife.lifetools.tools.Constrain;
+
+/**
+ * Layout that provides pinch-zooming of content. This view should have exactly one child
+ * view containing the content.
+ */
+public class ZoomLayout extends FrameLayout {
+
+    private ScaleGestureDetector scaleDetector;
+    private boolean animate = false;
+
+    private enum Mode {
+        NONE,
+        DRAG,
+        ZOOM
+    }
+
+    private static final String TAG = "ZoomLayout";
+    private static final float MIN_ZOOM = 1.0f;
+    private static final float MAX_ZOOM = 4.0f;
+
+    private Mode mode = Mode.NONE;
+    private float scale = 1.0f;
+    private float lastScaleFactor = 0f;
+
+    // Where the finger first  touches the screen
+    private float startX = 0f;
+    private float startY = 0f;
+
+    // How much to translate the canvas
+    private float dx = 0f;
+    private float dy = 0f;
+    private float prevDx = 0f;
+    private float prevDy = 0f;
+
+    public ZoomLayout(Context context) {
+        super(context);
+        init(context);
+    }
+
+    public ZoomLayout(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context);
+    }
+
+    public ZoomLayout(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context);
+    }
+
+    @SuppressLint("ClickableViewAccessibility")
+    private void init(Context context) {
+        // added logic to adjust dx and dy for pinch/zoom pivot point
+        scaleDetector = new ScaleGestureDetector(context, new ScaleGestureDetector.OnScaleGestureListener() {
+            @Override
+            public boolean onScaleBegin(ScaleGestureDetector scaleDetector) {
+                Log.i(TAG, "onScaleBegin");
+                return true;
+            }
+
+            @Override
+            public boolean onScale(ScaleGestureDetector scaleDetector) {
+                zoom(scaleDetector.getScaleFactor());
+                return true;
+            }
+
+            @Override
+            public void onScaleEnd(ScaleGestureDetector scaleDetector) {
+                Log.i(TAG, "onScaleEnd");
+            }
+        });
+        GestureDetector detector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener(){
+            @Override
+            public boolean onDoubleTap(MotionEvent e) {
+                animate = true;
+                mode = Mode.ZOOM;
+                zoom(scale > (MAX_ZOOM * .9) ? MIN_ZOOM / MAX_ZOOM : 2f);
+                return super.onDoubleTap(e);
+            }
+        });
+        this.setOnTouchListener((view, motionEvent) -> {
+            animate = false;
+            switch (motionEvent.getAction() & MotionEvent.ACTION_MASK) {
+                case MotionEvent.ACTION_DOWN:
+                    if (scale > MIN_ZOOM) {
+                        mode = Mode.DRAG;
+                        startX = motionEvent.getX() - prevDx;
+                        startY = motionEvent.getY() - prevDy;
+                    }
+                    break;
+                case MotionEvent.ACTION_MOVE:
+                    if (mode == Mode.DRAG) {
+                        dx = motionEvent.getX() - startX;
+                        dy = motionEvent.getY() - startY;
+                    }
+                    break;
+                case MotionEvent.ACTION_POINTER_DOWN:
+                    mode = Mode.ZOOM;
+                    break;
+                case MotionEvent.ACTION_POINTER_UP:
+                    mode = Mode.NONE; // changed from DRAG, was messing up zoom
+                    break;
+                case MotionEvent.ACTION_UP:
+                    mode = Mode.NONE;
+                    prevDx = dx;
+                    prevDy = dy;
+                    break;
+            }
+            scaleDetector.onTouchEvent(motionEvent);
+            detector.onTouchEvent(motionEvent);
+            if ((mode == Mode.DRAG && scale >= MIN_ZOOM) || mode == Mode.ZOOM) {
+                getParent().requestDisallowInterceptTouchEvent(true);
+                applyToChildren(child-> {
+                    float maxDx = child.getWidth() * (scale - 1);  // adjusted for zero pivot
+                    float maxDy = child.getHeight() * (scale - 1);  // adjusted for zero pivot
+                    dx = Math.min(Math.max(dx, -maxDx), 0);  // adjusted for zero pivot
+                    dy = Math.min(Math.max(dy, -maxDy), 0);  // adjusted for zero pivot
+                    child.setPivotX(0f);  // default is to pivot at view center
+                    child.setPivotY(0f);  // default is to pivot at view center
+                    if (animate) {
+                        child.animate().setInterpolator(new DecelerateInterpolator())
+                            .scaleX(scale)
+                            .scaleY(scale)
+                            .translationX(dx)
+                            .translationY(dy)
+                            .start();
+                    } else {
+                        child.setScaleX(scale);
+                        child.setScaleY(scale);
+                        child.setTranslationX(dx);
+                        child.setTranslationY(dy);
+                    }
+                });
+                animate = false;
+            }
+
+            return true;
+        });
+    }
+
+    private void zoom(float scaleFactor) {
+        Log.i(TAG, "onScale(), scaleFactor = " + scaleFactor);
+        if (lastScaleFactor == 0 || (Math.signum(scaleFactor) == Math.signum(lastScaleFactor))) {
+            float prevScale = scale;
+            scale *= scaleFactor;
+            scale = Constrain.range(scale, MIN_ZOOM, MAX_ZOOM);
+            lastScaleFactor = scaleFactor;
+            float adjustedScaleFactor = scale / prevScale;
+            // added logic to adjust dx and dy for pinch/zoom pivot point
+            Log.d(TAG, "onScale, adjustedScaleFactor = " + adjustedScaleFactor);
+            Log.d(TAG, "onScale, BEFORE dx/dy = " + dx + "/" + dy);
+            float focusX = scaleDetector.getFocusX();
+            float focusY = scaleDetector.getFocusY();
+            Log.d(TAG, "onScale, focusX/focusy = " + focusX + "/" + focusY);
+            dx += (dx - focusX) * (adjustedScaleFactor - 1);
+            dy += (dy - focusY) * (adjustedScaleFactor - 1);
+            Log.d(TAG, "onScale, dx/dy = " + dx + "/" + dy);
+        } else {
+            lastScaleFactor = 0;
+        }
+    }
+
+    private interface ChildVisitor {
+        void applyTo(View child);
+    }
+
+    private void applyToChildren(ChildVisitor visitor) {
+        for (int i = 0; i < getChildCount(); i++) {
+            visitor.applyTo(getChildAt(i));
+        }
+    }
+
+    public void resetZoom() {
+        scale = 1f;
+        dx = 0;
+        dy = 0;
+        applyToChildren(child-> {
+            child.setScaleX(scale);
+            child.setScaleY(scale);
+            child.setPivotX(0f);  // default is to pivot at view center
+            child.setPivotY(0f);  // default is to pivot at view center
+            child.setTranslationX(dx);
+            child.setTranslationY(dy);
+        });
+    }
+}
\ No newline at end of file
