diff --git a/TMessagesProj/jni/Android.mk b/TMessagesProj/jni/Android.mk
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/giflib/config.h b/TMessagesProj/jni/giflib/config.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/giflib/dgif_lib.c b/TMessagesProj/jni/giflib/dgif_lib.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/giflib/gif_hash.c b/TMessagesProj/jni/giflib/gif_hash.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/giflib/gif_hash.h b/TMessagesProj/jni/giflib/gif_hash.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/giflib/gif_lib.h b/TMessagesProj/jni/giflib/gif_lib.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/giflib/gif_lib_private.h b/TMessagesProj/jni/giflib/gif_lib_private.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/giflib/gifalloc.c b/TMessagesProj/jni/giflib/gifalloc.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/armv6_idct.S b/TMessagesProj/jni/libjpeg/armv6_idct.S
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcapimin.c b/TMessagesProj/jni/libjpeg/jcapimin.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcapistd.c b/TMessagesProj/jni/libjpeg/jcapistd.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jccoefct.c b/TMessagesProj/jni/libjpeg/jccoefct.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jccolor.c b/TMessagesProj/jni/libjpeg/jccolor.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcdctmgr.c b/TMessagesProj/jni/libjpeg/jcdctmgr.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jchuff.c b/TMessagesProj/jni/libjpeg/jchuff.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jchuff.h b/TMessagesProj/jni/libjpeg/jchuff.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcinit.c b/TMessagesProj/jni/libjpeg/jcinit.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcmainct.c b/TMessagesProj/jni/libjpeg/jcmainct.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcmarker.c b/TMessagesProj/jni/libjpeg/jcmarker.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcmaster.c b/TMessagesProj/jni/libjpeg/jcmaster.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcomapi.c b/TMessagesProj/jni/libjpeg/jcomapi.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jconfig.h b/TMessagesProj/jni/libjpeg/jconfig.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcparam.c b/TMessagesProj/jni/libjpeg/jcparam.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcphuff.c b/TMessagesProj/jni/libjpeg/jcphuff.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcprepct.c b/TMessagesProj/jni/libjpeg/jcprepct.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jcsample.c b/TMessagesProj/jni/libjpeg/jcsample.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jctrans.c b/TMessagesProj/jni/libjpeg/jctrans.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdapimin.c b/TMessagesProj/jni/libjpeg/jdapimin.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdapistd.c b/TMessagesProj/jni/libjpeg/jdapistd.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdatadst.c b/TMessagesProj/jni/libjpeg/jdatadst.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdatasrc.c b/TMessagesProj/jni/libjpeg/jdatasrc.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdcoefct.c b/TMessagesProj/jni/libjpeg/jdcoefct.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdcolor.c b/TMessagesProj/jni/libjpeg/jdcolor.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdct.h b/TMessagesProj/jni/libjpeg/jdct.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jddctmgr.c b/TMessagesProj/jni/libjpeg/jddctmgr.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdhuff.c b/TMessagesProj/jni/libjpeg/jdhuff.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdhuff.h b/TMessagesProj/jni/libjpeg/jdhuff.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdinput.c b/TMessagesProj/jni/libjpeg/jdinput.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdmainct.c b/TMessagesProj/jni/libjpeg/jdmainct.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdmarker.c b/TMessagesProj/jni/libjpeg/jdmarker.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdmaster.c b/TMessagesProj/jni/libjpeg/jdmaster.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdmerge.c b/TMessagesProj/jni/libjpeg/jdmerge.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdphuff.c b/TMessagesProj/jni/libjpeg/jdphuff.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdpostct.c b/TMessagesProj/jni/libjpeg/jdpostct.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdsample.c b/TMessagesProj/jni/libjpeg/jdsample.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jdtrans.c b/TMessagesProj/jni/libjpeg/jdtrans.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jerror.c b/TMessagesProj/jni/libjpeg/jerror.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jerror.h b/TMessagesProj/jni/libjpeg/jerror.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jfdctflt.c b/TMessagesProj/jni/libjpeg/jfdctflt.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jfdctfst.c b/TMessagesProj/jni/libjpeg/jfdctfst.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jfdctint.c b/TMessagesProj/jni/libjpeg/jfdctint.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jidctflt.c b/TMessagesProj/jni/libjpeg/jidctflt.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jidctfst.c b/TMessagesProj/jni/libjpeg/jidctfst.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jidctint.c b/TMessagesProj/jni/libjpeg/jidctint.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jidctred.c b/TMessagesProj/jni/libjpeg/jidctred.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jinclude.h b/TMessagesProj/jni/libjpeg/jinclude.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jmemmgr.c b/TMessagesProj/jni/libjpeg/jmemmgr.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jmemnobs.c b/TMessagesProj/jni/libjpeg/jmemnobs.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jmemsys.h b/TMessagesProj/jni/libjpeg/jmemsys.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jmorecfg.h b/TMessagesProj/jni/libjpeg/jmorecfg.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jpegint.h b/TMessagesProj/jni/libjpeg/jpegint.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jpeglib.h b/TMessagesProj/jni/libjpeg/jpeglib.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jquant1.c b/TMessagesProj/jni/libjpeg/jquant1.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jquant2.c b/TMessagesProj/jni/libjpeg/jquant2.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jutils.c b/TMessagesProj/jni/libjpeg/jutils.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/libjpeg/jversion.h b/TMessagesProj/jni/libjpeg/jversion.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/opus/celt/arm/arm2gnu.pl b/TMessagesProj/jni/opus/celt/arm/arm2gnu.pl
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/sqlite.c b/TMessagesProj/jni/sqlite.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/sqlite.h b/TMessagesProj/jni/sqlite.h
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/sqlite_cursor.c b/TMessagesProj/jni/sqlite_cursor.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/sqlite_database.c b/TMessagesProj/jni/sqlite_database.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/jni/sqlite_statement.c b/TMessagesProj/jni/sqlite_statement.c
old mode 100755
new mode 100644
diff --git a/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so b/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so
new file mode 100644
index 000000000..29c750d68
Binary files /dev/null and b/TMessagesProj/libs/armeabi-v7a/libtmessages.8.so differ
diff --git a/TMessagesProj/libs/armeabi/libtmessages.8.so b/TMessagesProj/libs/armeabi/libtmessages.8.so
new file mode 100644
index 000000000..ae7110a48
Binary files /dev/null and b/TMessagesProj/libs/armeabi/libtmessages.8.so differ
diff --git a/TMessagesProj/libs/x86/libtmessages.8.so b/TMessagesProj/libs/x86/libtmessages.8.so
new file mode 100644
index 000000000..2cf7dc77c
Binary files /dev/null and b/TMessagesProj/libs/x86/libtmessages.8.so differ
diff --git a/TMessagesProj/src/main/assets/countries.txt b/TMessagesProj/src/main/assets/countries.txt
index c336d0620..64f8775fe 100644
--- a/TMessagesProj/src/main/assets/countries.txt
+++ b/TMessagesProj/src/main/assets/countries.txt
@@ -1,232 +1,232 @@
-1876;JM;Jamaica
-1869;KN;Saint Kitts & Nevis
-1868;TT;Trinidad & Tobago
-1784;VC;Saint Vincent & the Grenadines
-1767;DM;Dominica
-1758;LC;Saint Lucia
-1721;SX;Sint Maarten
-1684;AS;American Samoa
-1671;GU;Guam
-1670;MP;Northern Mariana Islands
-1664;MS;Montserrat
-1649;TC;Turks & Caicos Islands
-1473;GD;Grenada
-1441;BM;Bermuda
-1345;KY;Cayman Islands
-1340;VI;US Virgin Islands
-1284;VG;British Virgin Islands
-1268;AG;Antigua & Barbuda
-1264;AI;Anguilla
-1246;BB;Barbados
-1242;BS;Bahamas
-998;UZ;Uzbekistan
-996;KG;Kyrgyzstan
-995;GE;Georgia
-994;AZ;Azerbaijan
-993;TM;Turkmenistan
-992;TJ;Tajikistan
-977;NP;Nepal
-976;MN;Mongolia
-975;BT;Bhutan
-974;QA;Qatar
-973;BH;Bahrain
-972;IL;Israel
-971;AE;United Arab Emirates
-970;PS;Palestine
-968;OM;Oman
-967;YE;Yemen
-966;SA;Saudi Arabia
-965;KW;Kuwait
-964;IQ;Iraq
-963;SY;Syrian Arab Republic
-962;JO;Jordan
-961;LB;Lebanon
-960;MV;Maldives
-886;TW;Taiwan
-880;BD;Bangladesh
-856;LA;Laos
-855;KH;Cambodia
-853;MO;Macau
-852;HK;Hong Kong
-850;KP;North Korea
-692;MH;Marshall Islands
-691;FM;Micronesia
-690;TK;Tokelau
-689;PF;French Polynesia
-688;TV;Tuvalu
-687;NC;New Caledonia
-686;KI;Kiribati
-685;WS;Samoa
-683;NU;Niue
-682;CK;Cook Islands
-681;WF;Wallis & Futuna
-680;PW;Palau
-679;FJ;Fiji
-678;VU;Vanuatu
-677;SB;Solomon Islands
-676;TO;Tonga
-675;PG;Papua New Guinea
-674;NR;Nauru
-673;BN;Brunei Darussalam
-672;NF;Norfolk Island
-670;TL;Timor-Leste
-599;BQ;Bonaire, Sint Eustatius & Saba
-599;CW;Curaçao
-598;UY;Uruguay
-597;SR;Suriname
-596;MQ;Martinique
-595;PY;Paraguay
-594;GF;French Guiana
-593;EC;Ecuador
-592;GY;Guyana
-591;BO;Bolivia
-590;GP;Guadeloupe
-509;HT;Haiti
-508;PM;Saint Pierre & Miquelon
-507;PA;Panama
-506;CR;Costa Rica
-505;NI;Nicaragua
-504;HN;Honduras
-503;SV;El Salvador
-502;GT;Guatemala
-501;BZ;Belize
-500;FK;Falkland Islands
-423;LI;Liechtenstein
-421;SK;Slovakia
-420;CZ;Czech Republic
-389;MK;Macedonia
-387;BA;Bosnia & Herzegovina
-386;SI;Slovenia
-385;HR;Croatia
-382;ME;Montenegro
-381;RS;Serbia
-380;UA;Ukraine
-378;SM;San Marino
-377;MC;Monaco
-376;AD;Andorra
-375;BY;Belarus
-374;AM;Armenia
-373;MD;Moldova
-372;EE;Estonia
-371;LV;Latvia
-370;LT;Lithuania
-359;BG;Bulgaria
-358;FI;Finland
-357;CY;Cyprus
-356;MT;Malta
-355;AL;Albania
-354;IS;Iceland
-353;IE;Ireland
-352;LU;Luxembourg
-351;PT;Portugal
-350;GI;Gibraltar
-299;GL;Greenland
-298;FO;Faroe Islands
-297;AW;Aruba
-291;ER;Eritrea
-290;SH;Saint Helena
-269;KM;Comoros
-268;SZ;Swaziland
-267;BW;Botswana
-266;LS;Lesotho
-265;MW;Malawi
-264;NA;Namibia
-263;ZW;Zimbabwe
-262;RE;Réunion
-261;MG;Madagascar
-260;ZM;Zambia
-258;MZ;Mozambique
-257;BI;Burundi
-256;UG;Uganda
-255;TZ;Tanzania
-254;KE;Kenya
-253;DJ;Djibouti
-252;SO;Somalia
-251;ET;Ethiopia
-250;RW;Rwanda
-249;SD;Sudan
-248;SC;Seychelles
-247;SH;Saint Helena
-246;IO;Diego Garcia
-245;GW;Guinea-Bissau
-244;AO;Angola
-243;CD;Congo (Dem. Rep.)
-242;CG;Congo (Rep.)
-241;GA;Gabon
-240;GQ;Equatorial Guinea
-239;ST;São Tomé & Príncipe
-238;CV;Cape Verde
-237;CM;Cameroon
-236;CF;Central African Rep.
-235;TD;Chad
-234;NG;Nigeria
-233;GH;Ghana
-232;SL;Sierra Leone
-231;LR;Liberia
-230;MU;Mauritius
-229;BJ;Benin
-228;TG;Togo
-227;NE;Niger
-226;BF;Burkina Faso
-225;CI;Côte d`Ivoire
-224;GN;Guinea
-223;ML;Mali
-222;MR;Mauritania
-221;SN;Senegal
-220;GM;Gambia
-218;LY;Libya
-216;TN;Tunisia
-213;DZ;Algeria
-212;MA;Morocco
-211;SS;South Sudan
-98;IR;Iran
-95;MM;Myanmar
-94;LK;Sri Lanka
-93;AF;Afghanistan
-92;PK;Pakistan
-91;IN;India
-90;TR;Turkey
-86;CN;China
-84;VN;Vietnam
-82;KR;South Korea
-81;JP;Japan
-66;TH;Thailand
-65;SG;Singapore
-64;NZ;New Zealand
-63;PH;Philippines
-62;ID;Indonesia
-61;AU;Australia
-60;MY;Malaysia
-58;VE;Venezuela
-57;CO;Colombia
-56;CL;Chile
-55;BR;Brazil
-54;AR;Argentina
-53;CU;Cuba
-52;MX;Mexico
-51;PE;Peru
-49;DE;Germany
-48;PL;Poland
-47;NO;Norway
-46;SE;Sweden
-45;DK;Denmark
-44;GB;United Kingdom
-43;AT;Austria
-42;YL;Y-land
-41;CH;Switzerland
-40;RO;Romania
-39;IT;Italy
-36;HU;Hungary
-34;ES;Spain
-33;FR;France
-32;BE;Belgium
-31;NL;Netherlands
-30;GR;Greece
-27;ZA;South Africa
-20;EG;Egypt
-7;KZ;Kazakhstan
-7;RU;Russian Federation
-1;PR;Puerto Rico
-1;DO;Dominican Rep.
-1;CA;Canada
+1876;JM;Jamaica
+1869;KN;Saint Kitts & Nevis
+1868;TT;Trinidad & Tobago
+1784;VC;Saint Vincent & the Grenadines
+1767;DM;Dominica
+1758;LC;Saint Lucia
+1721;SX;Sint Maarten
+1684;AS;American Samoa
+1671;GU;Guam
+1670;MP;Northern Mariana Islands
+1664;MS;Montserrat
+1649;TC;Turks & Caicos Islands
+1473;GD;Grenada
+1441;BM;Bermuda
+1345;KY;Cayman Islands
+1340;VI;US Virgin Islands
+1284;VG;British Virgin Islands
+1268;AG;Antigua & Barbuda
+1264;AI;Anguilla
+1246;BB;Barbados
+1242;BS;Bahamas
+998;UZ;Uzbekistan
+996;KG;Kyrgyzstan
+995;GE;Georgia
+994;AZ;Azerbaijan
+993;TM;Turkmenistan
+992;TJ;Tajikistan
+977;NP;Nepal
+976;MN;Mongolia
+975;BT;Bhutan
+974;QA;Qatar
+973;BH;Bahrain
+972;IL;Israel
+971;AE;United Arab Emirates
+970;PS;Palestine
+968;OM;Oman
+967;YE;Yemen
+966;SA;Saudi Arabia
+965;KW;Kuwait
+964;IQ;Iraq
+963;SY;Syrian Arab Republic
+962;JO;Jordan
+961;LB;Lebanon
+960;MV;Maldives
+886;TW;Taiwan
+880;BD;Bangladesh
+856;LA;Laos
+855;KH;Cambodia
+853;MO;Macau
+852;HK;Hong Kong
+850;KP;North Korea
+692;MH;Marshall Islands
+691;FM;Micronesia
+690;TK;Tokelau
+689;PF;French Polynesia
+688;TV;Tuvalu
+687;NC;New Caledonia
+686;KI;Kiribati
+685;WS;Samoa
+683;NU;Niue
+682;CK;Cook Islands
+681;WF;Wallis & Futuna
+680;PW;Palau
+679;FJ;Fiji
+678;VU;Vanuatu
+677;SB;Solomon Islands
+676;TO;Tonga
+675;PG;Papua New Guinea
+674;NR;Nauru
+673;BN;Brunei Darussalam
+672;NF;Norfolk Island
+670;TL;Timor-Leste
+599;BQ;Bonaire, Sint Eustatius & Saba
+599;CW;Curaçao
+598;UY;Uruguay
+597;SR;Suriname
+596;MQ;Martinique
+595;PY;Paraguay
+594;GF;French Guiana
+593;EC;Ecuador
+592;GY;Guyana
+591;BO;Bolivia
+590;GP;Guadeloupe
+509;HT;Haiti
+508;PM;Saint Pierre & Miquelon
+507;PA;Panama
+506;CR;Costa Rica
+505;NI;Nicaragua
+504;HN;Honduras
+503;SV;El Salvador
+502;GT;Guatemala
+501;BZ;Belize
+500;FK;Falkland Islands
+423;LI;Liechtenstein
+421;SK;Slovakia
+420;CZ;Czech Republic
+389;MK;Macedonia
+387;BA;Bosnia & Herzegovina
+386;SI;Slovenia
+385;HR;Croatia
+382;ME;Montenegro
+381;RS;Serbia
+380;UA;Ukraine
+378;SM;San Marino
+377;MC;Monaco
+376;AD;Andorra
+375;BY;Belarus
+374;AM;Armenia
+373;MD;Moldova
+372;EE;Estonia
+371;LV;Latvia
+370;LT;Lithuania
+359;BG;Bulgaria
+358;FI;Finland
+357;CY;Cyprus
+356;MT;Malta
+355;AL;Albania
+354;IS;Iceland
+353;IE;Ireland
+352;LU;Luxembourg
+351;PT;Portugal
+350;GI;Gibraltar
+299;GL;Greenland
+298;FO;Faroe Islands
+297;AW;Aruba
+291;ER;Eritrea
+290;SH;Saint Helena
+269;KM;Comoros
+268;SZ;Swaziland
+267;BW;Botswana
+266;LS;Lesotho
+265;MW;Malawi
+264;NA;Namibia
+263;ZW;Zimbabwe
+262;RE;Réunion
+261;MG;Madagascar
+260;ZM;Zambia
+258;MZ;Mozambique
+257;BI;Burundi
+256;UG;Uganda
+255;TZ;Tanzania
+254;KE;Kenya
+253;DJ;Djibouti
+252;SO;Somalia
+251;ET;Ethiopia
+250;RW;Rwanda
+249;SD;Sudan
+248;SC;Seychelles
+247;SH;Saint Helena
+246;IO;Diego Garcia
+245;GW;Guinea-Bissau
+244;AO;Angola
+243;CD;Congo (Dem. Rep.)
+242;CG;Congo (Rep.)
+241;GA;Gabon
+240;GQ;Equatorial Guinea
+239;ST;São Tomé & Príncipe
+238;CV;Cape Verde
+237;CM;Cameroon
+236;CF;Central African Rep.
+235;TD;Chad
+234;NG;Nigeria
+233;GH;Ghana
+232;SL;Sierra Leone
+231;LR;Liberia
+230;MU;Mauritius
+229;BJ;Benin
+228;TG;Togo
+227;NE;Niger
+226;BF;Burkina Faso
+225;CI;Côte d`Ivoire
+224;GN;Guinea
+223;ML;Mali
+222;MR;Mauritania
+221;SN;Senegal
+220;GM;Gambia
+218;LY;Libya
+216;TN;Tunisia
+213;DZ;Algeria
+212;MA;Morocco
+211;SS;South Sudan
+98;IR;Iran
+95;MM;Myanmar
+94;LK;Sri Lanka
+93;AF;Afghanistan
+92;PK;Pakistan
+91;IN;India
+90;TR;Turkey
+86;CN;China
+84;VN;Vietnam
+82;KR;South Korea
+81;JP;Japan
+66;TH;Thailand
+65;SG;Singapore
+64;NZ;New Zealand
+63;PH;Philippines
+62;ID;Indonesia
+61;AU;Australia
+60;MY;Malaysia
+58;VE;Venezuela
+57;CO;Colombia
+56;CL;Chile
+55;BR;Brazil
+54;AR;Argentina
+53;CU;Cuba
+52;MX;Mexico
+51;PE;Peru
+49;DE;Germany
+48;PL;Poland
+47;NO;Norway
+46;SE;Sweden
+45;DK;Denmark
+44;GB;United Kingdom
+43;AT;Austria
+42;YL;Y-land
+41;CH;Switzerland
+40;RO;Romania
+39;IT;Italy
+36;HU;Hungary
+34;ES;Spain
+33;FR;France
+32;BE;Belgium
+31;NL;Netherlands
+30;GR;Greece
+27;ZA;South Africa
+20;EG;Egypt
+7;KZ;Kazakhstan
+7;RU;Russian Federation
+1;PR;Puerto Rico
+1;DO;Dominican Rep.
+1;CA;Canada
 1;US;USA
\ No newline at end of file
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_0.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_0.jpg
new file mode 100644
index 000000000..251747ff3
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_1.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_1.jpg
new file mode 100644
index 000000000..21bc015ea
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_2.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_2.jpg
new file mode 100644
index 000000000..c1c6fd3b7
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_3.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_3.jpg
new file mode 100644
index 000000000..bb398488c
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_4.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_4.jpg
new file mode 100644
index 000000000..a74e170f9
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_4.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_0.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_0.jpg
new file mode 100644
index 000000000..2fe760d04
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_1.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_1.jpg
new file mode 100644
index 000000000..776bf5887
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_2.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_2.jpg
new file mode 100644
index 000000000..43a7aa378
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_3.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_3.jpg
new file mode 100644
index 000000000..95d146fea
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_4.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_4.jpg
new file mode 100644
index 000000000..2be40c476
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_4.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_0.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_0.jpg
new file mode 100644
index 000000000..bc1d03b45
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_1.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_1.jpg
new file mode 100644
index 000000000..8288773c4
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_2.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_2.jpg
new file mode 100644
index 000000000..feea12096
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_3.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_3.jpg
new file mode 100644
index 000000000..0e3bcede0
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_4.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_4.jpg
new file mode 100644
index 000000000..1f74e8359
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_4.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_0.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_0.jpg
new file mode 100644
index 000000000..5218c3ca4
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_1.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_1.jpg
new file mode 100644
index 000000000..e6192101a
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_2.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_2.jpg
new file mode 100644
index 000000000..58476054b
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_3.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_3.jpg
new file mode 100644
index 000000000..7e4ea184c
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_4.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_4.jpg
new file mode 100644
index 000000000..9bb3ea6cd
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_4.jpg differ
diff --git a/TMessagesProj/src/main/java/jawnae/pyronet/ByteStream.java b/TMessagesProj/src/main/java/jawnae/pyronet/ByteStream.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/jawnae/pyronet/PyroClient.java b/TMessagesProj/src/main/java/jawnae/pyronet/PyroClient.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/jawnae/pyronet/PyroClientAdapter.java b/TMessagesProj/src/main/java/jawnae/pyronet/PyroClientAdapter.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/jawnae/pyronet/PyroClientListener.java b/TMessagesProj/src/main/java/jawnae/pyronet/PyroClientListener.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/jawnae/pyronet/PyroException.java b/TMessagesProj/src/main/java/jawnae/pyronet/PyroException.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/jawnae/pyronet/PyroSelector.java b/TMessagesProj/src/main/java/jawnae/pyronet/PyroSelector.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteCursor.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteCursor.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteDatabase.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteDatabase.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteException.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteException.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteNoRowException.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteNoRowException.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLitePreparedStatement.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLitePreparedStatement.java
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/Animator10.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/Animator10.java
new file mode 100644
index 000000000..a4661919f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/Animator10.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import android.view.animation.Interpolator;
+
+import java.util.ArrayList;
+
+public abstract class Animator10 implements Cloneable {
+
+    ArrayList<AnimatorListener> mListeners = null;
+    ArrayList<AnimatorPauseListener> mPauseListeners = null;
+    boolean mPaused = false;
+
+    public abstract long getStartDelay();
+
+    public abstract void setStartDelay(long startDelay);
+
+    public abstract Animator10 setDuration(long duration);
+
+    public abstract long getDuration();
+
+    public abstract void setInterpolator(Interpolator value);
+
+    public abstract boolean isRunning();
+
+    public void start() {
+
+    }
+
+    public void cancel() {
+
+    }
+
+    public void end() {
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void pause() {
+        if (isStarted() && !mPaused) {
+            mPaused = true;
+            if (mPauseListeners != null) {
+                ArrayList<AnimatorPauseListener> tmpListeners = (ArrayList<AnimatorPauseListener>) mPauseListeners.clone();
+                int numListeners = tmpListeners.size();
+                for (AnimatorPauseListener tmpListener : tmpListeners) {
+                    tmpListener.onAnimationPause(this);
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public void resume() {
+        if (mPaused) {
+            mPaused = false;
+            if (mPauseListeners != null) {
+                ArrayList<AnimatorPauseListener> tmpListeners = (ArrayList<AnimatorPauseListener>) mPauseListeners.clone();
+                int numListeners = tmpListeners.size();
+                for (AnimatorPauseListener tmpListener : tmpListeners) {
+                    tmpListener.onAnimationResume(this);
+                }
+            }
+        }
+    }
+
+    public boolean isPaused() {
+        return mPaused;
+    }
+
+    public boolean isStarted() {
+        return isRunning();
+    }
+
+    public Interpolator getInterpolator() {
+        return null;
+    }
+
+    public void addListener(AnimatorListener listener) {
+        if (mListeners == null) {
+            mListeners = new ArrayList<AnimatorListener>();
+        }
+        mListeners.add(listener);
+    }
+
+    public void removeListener(AnimatorListener listener) {
+        if (mListeners == null) {
+            return;
+        }
+        mListeners.remove(listener);
+        if (mListeners.size() == 0) {
+            mListeners = null;
+        }
+    }
+
+    public ArrayList<AnimatorListener> getListeners() {
+        return mListeners;
+    }
+
+    public void addPauseListener(AnimatorPauseListener listener) {
+        if (mPauseListeners == null) {
+            mPauseListeners = new ArrayList<AnimatorPauseListener>();
+        }
+        mPauseListeners.add(listener);
+    }
+
+    public void removePauseListener(AnimatorPauseListener listener) {
+        if (mPauseListeners == null) {
+            return;
+        }
+        mPauseListeners.remove(listener);
+        if (mPauseListeners.size() == 0) {
+            mPauseListeners = null;
+        }
+    }
+
+    public void removeAllListeners() {
+        if (mListeners != null) {
+            mListeners.clear();
+            mListeners = null;
+        }
+        if (mPauseListeners != null) {
+            mPauseListeners.clear();
+            mPauseListeners = null;
+        }
+    }
+
+    @Override
+    public Animator10 clone() {
+        try {
+            final Animator10 anim = (Animator10) super.clone();
+            if (mListeners != null) {
+                ArrayList<AnimatorListener> oldListeners = mListeners;
+                anim.mListeners = new ArrayList<AnimatorListener>();
+                int numListeners = oldListeners.size();
+                for (AnimatorListener oldListener : oldListeners) {
+                    anim.mListeners.add(oldListener);
+                }
+            }
+            if (mPauseListeners != null) {
+                ArrayList<AnimatorPauseListener> oldListeners = mPauseListeners;
+                anim.mPauseListeners = new ArrayList<AnimatorPauseListener>();
+                int numListeners = oldListeners.size();
+                for (AnimatorPauseListener oldListener : oldListeners) {
+                    anim.mPauseListeners.add(oldListener);
+                }
+            }
+            return anim;
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError();
+        }
+    }
+
+    public void setupStartValues() {
+
+    }
+
+    public void setupEndValues() {
+
+    }
+
+    public void setTarget(Object target) {
+
+    }
+
+    public interface AnimatorListener {
+        void onAnimationStart(Animator10 animation);
+        void onAnimationEnd(Animator10 animation);
+        void onAnimationCancel(Animator10 animation);
+        void onAnimationRepeat(Animator10 animation);
+    }
+
+    public interface AnimatorPauseListener {
+        void onAnimationPause(Animator10 animation);
+        void onAnimationResume(Animator10 animation);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/AnimatorListenerAdapter10.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/AnimatorListenerAdapter10.java
new file mode 100644
index 000000000..70b3aec39
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/AnimatorListenerAdapter10.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+public abstract class AnimatorListenerAdapter10 implements Animator10.AnimatorListener, Animator10.AnimatorPauseListener {
+
+    @Override
+    public void onAnimationCancel(Animator10 animation) {
+
+    }
+
+    @Override
+    public void onAnimationEnd(Animator10 animation) {
+
+    }
+
+    @Override
+    public void onAnimationRepeat(Animator10 animation) {
+
+    }
+
+    @Override
+    public void onAnimationStart(Animator10 animation) {
+
+    }
+
+    @Override
+    public void onAnimationPause(Animator10 animation) {
+
+    }
+
+    @Override
+    public void onAnimationResume(Animator10 animation) {
+
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/AnimatorSet10.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/AnimatorSet10.java
new file mode 100644
index 000000000..d9f63ef4b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/AnimatorSet10.java
@@ -0,0 +1,705 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import android.view.animation.Interpolator;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+public final class AnimatorSet10 extends Animator10 {
+
+    private ArrayList<Animator10> mPlayingSet = new ArrayList<>();
+    private HashMap<Animator10, Node> mNodeMap = new HashMap<>();
+    private ArrayList<Node> mNodes = new ArrayList<>();
+    private ArrayList<Node> mSortedNodes = new ArrayList<>();
+    private boolean mNeedsSort = true;
+    private AnimatorSetListener mSetListener = null;
+    boolean mTerminated = false;
+    private boolean mStarted = false;
+    private long mStartDelay = 0;
+    private ValueAnimator mDelayAnim = null;
+    private long mDuration = -1;
+    private Interpolator mInterpolator = null;
+
+    public void playTogether(Animator10... items) {
+        if (items != null) {
+            mNeedsSort = true;
+            Builder builder = play(items[0]);
+            for (int i = 1; i < items.length; ++i) {
+                builder.with(items[i]);
+            }
+        }
+    }
+
+    public void playTogether(Collection<Animator10> items) {
+        if (items != null && items.size() > 0) {
+            mNeedsSort = true;
+            Builder builder = null;
+            for (Animator10 anim : items) {
+                if (builder == null) {
+                    builder = play(anim);
+                } else {
+                    builder.with(anim);
+                }
+            }
+        }
+    }
+
+    public void playSequentially(Animator10... items) {
+        if (items != null) {
+            mNeedsSort = true;
+            if (items.length == 1) {
+                play(items[0]);
+            } else {
+                for (int i = 0; i < items.length - 1; ++i) {
+                    play(items[i]).before(items[i+1]);
+                }
+            }
+        }
+    }
+
+    public void playSequentially(List<Animator10> items) {
+        if (items != null && items.size() > 0) {
+            mNeedsSort = true;
+            if (items.size() == 1) {
+                play(items.get(0));
+            } else {
+                for (int i = 0; i < items.size() - 1; ++i) {
+                    play(items.get(i)).before(items.get(i+1));
+                }
+            }
+        }
+    }
+
+    public ArrayList<Animator10> getChildAnimations() {
+        ArrayList<Animator10> childList = new ArrayList<>();
+        for (Node node : mNodes) {
+            childList.add(node.animation);
+        }
+        return childList;
+    }
+
+    @Override
+    public void setTarget(Object target) {
+        for (Node node : mNodes) {
+            Animator10 animation = node.animation;
+            if (animation instanceof AnimatorSet10) {
+                animation.setTarget(target);
+            } else if (animation instanceof ObjectAnimator10) {
+                animation.setTarget(target);
+            }
+        }
+    }
+
+    @Override
+    public void setInterpolator(Interpolator interpolator) {
+        mInterpolator = interpolator;
+    }
+
+    @Override
+    public Interpolator getInterpolator() {
+        return mInterpolator;
+    }
+
+    public Builder play(Animator10 anim) {
+        if (anim != null) {
+            mNeedsSort = true;
+            return new Builder(anim);
+        }
+        return null;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void cancel() {
+        mTerminated = true;
+        if (isStarted()) {
+            ArrayList<AnimatorListener> tmpListeners = null;
+            if (mListeners != null) {
+                tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
+                for (AnimatorListener listener : tmpListeners) {
+                    listener.onAnimationCancel(this);
+                }
+            }
+            if (mDelayAnim != null && mDelayAnim.isRunning()) {
+                mDelayAnim.cancel();
+            } else  if (mSortedNodes.size() > 0) {
+                for (Node node : mSortedNodes) {
+                    node.animation.cancel();
+                }
+            }
+            if (tmpListeners != null) {
+                for (AnimatorListener listener : tmpListeners) {
+                    listener.onAnimationEnd(this);
+                }
+            }
+            mStarted = false;
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void end() {
+        mTerminated = true;
+        if (isStarted()) {
+            if (mSortedNodes.size() != mNodes.size()) {
+                // hasn't been started yet - sort the nodes now, then end them
+                sortNodes();
+                for (Node node : mSortedNodes) {
+                    if (mSetListener == null) {
+                        mSetListener = new AnimatorSetListener(this);
+                    }
+                    node.animation.addListener(mSetListener);
+                }
+            }
+            if (mDelayAnim != null) {
+                mDelayAnim.cancel();
+            }
+            if (mSortedNodes.size() > 0) {
+                for (Node node : mSortedNodes) {
+                    node.animation.end();
+                }
+            }
+            if (mListeners != null) {
+                ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
+                for (AnimatorListener listener : tmpListeners) {
+                    listener.onAnimationEnd(this);
+                }
+            }
+            mStarted = false;
+        }
+    }
+
+    @Override
+    public boolean isRunning() {
+        for (Node node : mNodes) {
+            if (node.animation.isRunning()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isStarted() {
+        return mStarted;
+    }
+
+    @Override
+    public long getStartDelay() {
+        return mStartDelay;
+    }
+
+    @Override
+    public void setStartDelay(long startDelay) {
+        mStartDelay = startDelay;
+    }
+
+    @Override
+    public long getDuration() {
+        return mDuration;
+    }
+
+    @Override
+    public AnimatorSet10 setDuration(long duration) {
+        if (duration < 0) {
+            throw new IllegalArgumentException("duration must be a value of zero or greater");
+        }
+        mDuration = duration;
+        return this;
+    }
+
+    @Override
+    public void setupStartValues() {
+        for (Node node : mNodes) {
+            node.animation.setupStartValues();
+        }
+    }
+
+    @Override
+    public void setupEndValues() {
+        for (Node node : mNodes) {
+            node.animation.setupEndValues();
+        }
+    }
+
+    @Override
+    public void pause() {
+        boolean previouslyPaused = mPaused;
+        super.pause();
+        if (!previouslyPaused && mPaused) {
+            if (mDelayAnim != null) {
+                mDelayAnim.pause();
+            } else {
+                for (Node node : mNodes) {
+                    node.animation.pause();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void resume() {
+        boolean previouslyPaused = mPaused;
+        super.resume();
+        if (previouslyPaused && !mPaused) {
+            if (mDelayAnim != null) {
+                mDelayAnim.resume();
+            } else {
+                for (Node node : mNodes) {
+                    node.animation.resume();
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void start() {
+        mTerminated = false;
+        mStarted = true;
+        mPaused = false;
+
+        if (mDuration >= 0) {
+            for (Node node : mNodes) {
+                node.animation.setDuration(mDuration);
+            }
+        }
+        if (mInterpolator != null) {
+            for (Node node : mNodes) {
+                node.animation.setInterpolator(mInterpolator);
+            }
+        }
+
+        sortNodes();
+
+        int numSortedNodes = mSortedNodes.size();
+        for (Node node : mSortedNodes) {
+            ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
+            if (oldListeners != null && oldListeners.size() > 0) {
+                final ArrayList<AnimatorListener> clonedListeners = new
+                        ArrayList<>(oldListeners);
+
+                for (AnimatorListener listener : clonedListeners) {
+                    if (listener instanceof DependencyListener ||
+                            listener instanceof AnimatorSetListener) {
+                        node.animation.removeListener(listener);
+                    }
+                }
+            }
+        }
+
+        final ArrayList<Node> nodesToStart = new ArrayList<>();
+        for (Node node : mSortedNodes) {
+            if (mSetListener == null) {
+                mSetListener = new AnimatorSetListener(this);
+            }
+            if (node.dependencies == null || node.dependencies.size() == 0) {
+                nodesToStart.add(node);
+            } else {
+                int numDependencies = node.dependencies.size();
+                for (int j = 0; j < numDependencies; ++j) {
+                    Dependency dependency = node.dependencies.get(j);
+                    dependency.node.animation.addListener(
+                            new DependencyListener(this, node, dependency.rule));
+                }
+                node.tmpDependencies = (ArrayList<Dependency>) node.dependencies.clone();
+            }
+            node.animation.addListener(mSetListener);
+        }
+
+        if (mStartDelay <= 0) {
+            for (Node node : nodesToStart) {
+                node.animation.start();
+                mPlayingSet.add(node.animation);
+            }
+        } else {
+            mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
+            mDelayAnim.setDuration(mStartDelay);
+            mDelayAnim.addListener(new AnimatorListenerAdapter10() {
+                boolean canceled = false;
+                public void onAnimationCancel(Animator10 anim) {
+                    canceled = true;
+                }
+                public void onAnimationEnd(Animator10 anim) {
+                    if (!canceled) {
+                        int numNodes = nodesToStart.size();
+                        for (Node node : nodesToStart) {
+                            node.animation.start();
+                            mPlayingSet.add(node.animation);
+                        }
+                    }
+                    mDelayAnim = null;
+                }
+            });
+            mDelayAnim.start();
+        }
+        if (mListeners != null) {
+            ArrayList<AnimatorListener> tmpListeners =
+                    (ArrayList<AnimatorListener>) mListeners.clone();
+            int numListeners = tmpListeners.size();
+            for (AnimatorListener tmpListener : tmpListeners) {
+                tmpListener.onAnimationStart(this);
+            }
+        }
+        if (mNodes.size() == 0 && mStartDelay == 0) {
+            mStarted = false;
+            if (mListeners != null) {
+                ArrayList<AnimatorListener> tmpListeners =
+                        (ArrayList<AnimatorListener>) mListeners.clone();
+                int numListeners = tmpListeners.size();
+                for (AnimatorListener tmpListener : tmpListeners) {
+                    tmpListener.onAnimationEnd(this);
+                }
+            }
+        }
+    }
+
+    @Override
+    public AnimatorSet10 clone() {
+        final AnimatorSet10 anim = (AnimatorSet10) super.clone();
+
+        anim.mNeedsSort = true;
+        anim.mTerminated = false;
+        anim.mStarted = false;
+        anim.mPlayingSet = new ArrayList<>();
+        anim.mNodeMap = new HashMap<>();
+        anim.mNodes = new ArrayList<>();
+        anim.mSortedNodes = new ArrayList<>();
+
+        HashMap<Node, Node> nodeCloneMap = new HashMap<>();
+        for (Node node : mNodes) {
+            Node nodeClone = node.clone();
+            nodeCloneMap.put(node, nodeClone);
+            anim.mNodes.add(nodeClone);
+            anim.mNodeMap.put(nodeClone.animation, nodeClone);
+            nodeClone.dependencies = null;
+            nodeClone.tmpDependencies = null;
+            nodeClone.nodeDependents = null;
+            nodeClone.nodeDependencies = null;
+            ArrayList<AnimatorListener> cloneListeners = nodeClone.animation.getListeners();
+            if (cloneListeners != null) {
+                ArrayList<AnimatorListener> listenersToRemove = null;
+                for (AnimatorListener listener : cloneListeners) {
+                    if (listener instanceof AnimatorSetListener) {
+                        if (listenersToRemove == null) {
+                            listenersToRemove = new ArrayList<>();
+                        }
+                        listenersToRemove.add(listener);
+                    }
+                }
+                if (listenersToRemove != null) {
+                    for (AnimatorListener listener : listenersToRemove) {
+                        cloneListeners.remove(listener);
+                    }
+                }
+            }
+        }
+        for (Node node : mNodes) {
+            Node nodeClone = nodeCloneMap.get(node);
+            if (node.dependencies != null) {
+                for (Dependency dependency : node.dependencies) {
+                    Node clonedDependencyNode = nodeCloneMap.get(dependency.node);
+                    Dependency cloneDependency = new Dependency(clonedDependencyNode, dependency.rule);
+                    nodeClone.addDependency(cloneDependency);
+                }
+            }
+        }
+        return anim;
+    }
+
+    private static class DependencyListener implements AnimatorListener {
+
+        private AnimatorSet10 mAnimatorSet;
+        private Node mNode;
+        private int mRule;
+
+        public DependencyListener(AnimatorSet10 animatorSet, Node node, int rule) {
+            this.mAnimatorSet = animatorSet;
+            this.mNode = node;
+            this.mRule = rule;
+        }
+
+        public void onAnimationCancel(Animator10 animation) {
+
+        }
+
+        public void onAnimationEnd(Animator10 animation) {
+            if (mRule == Dependency.AFTER) {
+                startIfReady(animation);
+            }
+        }
+
+        public void onAnimationRepeat(Animator10 animation) {
+
+        }
+
+        public void onAnimationStart(Animator10 animation) {
+            if (mRule == Dependency.WITH) {
+                startIfReady(animation);
+            }
+        }
+
+        private void startIfReady(Animator10 dependencyAnimation) {
+            if (mAnimatorSet.mTerminated) {
+                return;
+            }
+            Dependency dependencyToRemove = null;
+            int numDependencies = mNode.tmpDependencies.size();
+            for (int i = 0; i < numDependencies; ++i) {
+                Dependency dependency = mNode.tmpDependencies.get(i);
+                if (dependency.rule == mRule && dependency.node.animation == dependencyAnimation) {
+                    dependencyToRemove = dependency;
+                    dependencyAnimation.removeListener(this);
+                    break;
+                }
+            }
+            mNode.tmpDependencies.remove(dependencyToRemove);
+            if (mNode.tmpDependencies.size() == 0) {
+                mNode.animation.start();
+                mAnimatorSet.mPlayingSet.add(mNode.animation);
+            }
+        }
+    }
+
+    private class AnimatorSetListener implements AnimatorListener {
+
+        private AnimatorSet10 mAnimatorSet;
+
+        AnimatorSetListener(AnimatorSet10 animatorSet) {
+            mAnimatorSet = animatorSet;
+        }
+
+        public void onAnimationCancel(Animator10 animation) {
+            if (!mTerminated) {
+                if (mPlayingSet.size() == 0) {
+                    if (mListeners != null) {
+                        int numListeners = mListeners.size();
+                        for (AnimatorListener mListener : mListeners) {
+                            mListener.onAnimationCancel(mAnimatorSet);
+                        }
+                    }
+                }
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        public void onAnimationEnd(Animator10 animation) {
+            animation.removeListener(this);
+            mPlayingSet.remove(animation);
+            Node animNode = mAnimatorSet.mNodeMap.get(animation);
+            animNode.done = true;
+            if (!mTerminated) {
+                ArrayList<Node> sortedNodes = mAnimatorSet.mSortedNodes;
+                boolean allDone = true;
+                int numSortedNodes = sortedNodes.size();
+                for (Node sortedNode : sortedNodes) {
+                    if (!sortedNode.done) {
+                        allDone = false;
+                        break;
+                    }
+                }
+                if (allDone) {
+                    if (mListeners != null) {
+                        ArrayList<AnimatorListener> tmpListeners =
+                                (ArrayList<AnimatorListener>) mListeners.clone();
+                        int numListeners = tmpListeners.size();
+                        for (AnimatorListener tmpListener : tmpListeners) {
+                            tmpListener.onAnimationEnd(mAnimatorSet);
+                        }
+                    }
+                    mAnimatorSet.mStarted = false;
+                    mAnimatorSet.mPaused = false;
+                }
+            }
+        }
+
+        public void onAnimationRepeat(Animator10 animation) {
+
+        }
+
+        public void onAnimationStart(Animator10 animation) {
+
+        }
+    }
+
+    private void sortNodes() {
+        if (mNeedsSort) {
+            mSortedNodes.clear();
+            ArrayList<Node> roots = new ArrayList<>();
+            int numNodes = mNodes.size();
+            for (Node node : mNodes) {
+                if (node.dependencies == null || node.dependencies.size() == 0) {
+                    roots.add(node);
+                }
+            }
+            ArrayList<Node> tmpRoots = new ArrayList<>();
+            while (roots.size() > 0) {
+                int numRoots = roots.size();
+                for (Node root : roots) {
+                    mSortedNodes.add(root);
+                    if (root.nodeDependents != null) {
+                        int numDependents = root.nodeDependents.size();
+                        for (int j = 0; j < numDependents; ++j) {
+                            Node node = root.nodeDependents.get(j);
+                            node.nodeDependencies.remove(root);
+                            if (node.nodeDependencies.size() == 0) {
+                                tmpRoots.add(node);
+                            }
+                        }
+                    }
+                }
+                roots.clear();
+                roots.addAll(tmpRoots);
+                tmpRoots.clear();
+            }
+            mNeedsSort = false;
+            if (mSortedNodes.size() != mNodes.size()) {
+                throw new IllegalStateException("Circular dependencies cannot exist in AnimatorSet");
+            }
+        } else {
+            int numNodes = mNodes.size();
+            for (Node node : mNodes) {
+                if (node.dependencies != null && node.dependencies.size() > 0) {
+                    int numDependencies = node.dependencies.size();
+                    for (int j = 0; j < numDependencies; ++j) {
+                        Dependency dependency = node.dependencies.get(j);
+                        if (node.nodeDependencies == null) {
+                            node.nodeDependencies = new ArrayList<>();
+                        }
+                        if (!node.nodeDependencies.contains(dependency.node)) {
+                            node.nodeDependencies.add(dependency.node);
+                        }
+                    }
+                }
+                node.done = false;
+            }
+        }
+    }
+
+    private static class Dependency {
+        static final int WITH = 0;
+        static final int AFTER = 1;
+        public Node node;
+        public int rule;
+
+        public Dependency(Node node, int rule) {
+            this.node = node;
+            this.rule = rule;
+        }
+    }
+
+    private static class Node implements Cloneable {
+        public Animator10 animation;
+        public ArrayList<Dependency> dependencies = null;
+        public ArrayList<Dependency> tmpDependencies = null;
+        public ArrayList<Node> nodeDependencies = null;
+        public ArrayList<Node> nodeDependents = null;
+        public boolean done = false;
+
+        public Node(Animator10 animation) {
+            this.animation = animation;
+        }
+
+        public void addDependency(Dependency dependency) {
+            if (dependencies == null) {
+                dependencies = new ArrayList<>();
+                nodeDependencies = new ArrayList<>();
+            }
+            dependencies.add(dependency);
+            if (!nodeDependencies.contains(dependency.node)) {
+                nodeDependencies.add(dependency.node);
+            }
+            Node dependencyNode = dependency.node;
+            if (dependencyNode.nodeDependents == null) {
+                dependencyNode.nodeDependents = new ArrayList<>();
+            }
+            dependencyNode.nodeDependents.add(this);
+        }
+
+        @Override
+        public Node clone() {
+            try {
+                Node node = (Node) super.clone();
+                node.animation = animation.clone();
+                return node;
+            } catch (CloneNotSupportedException e) {
+               throw new AssertionError();
+            }
+        }
+    }
+
+    public class Builder {
+
+        private Node mCurrentNode;
+
+        Builder(Animator10 anim) {
+            mCurrentNode = mNodeMap.get(anim);
+            if (mCurrentNode == null) {
+                mCurrentNode = new Node(anim);
+                mNodeMap.put(anim, mCurrentNode);
+                mNodes.add(mCurrentNode);
+            }
+        }
+
+        public Builder with(Animator10 anim) {
+            Node node = mNodeMap.get(anim);
+            if (node == null) {
+                node = new Node(anim);
+                mNodeMap.put(anim, node);
+                mNodes.add(node);
+            }
+            Dependency dependency = new Dependency(mCurrentNode, Dependency.WITH);
+            node.addDependency(dependency);
+            return this;
+        }
+
+        public Builder before(Animator10 anim) {
+            Node node = mNodeMap.get(anim);
+            if (node == null) {
+                node = new Node(anim);
+                mNodeMap.put(anim, node);
+                mNodes.add(node);
+            }
+            Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
+            node.addDependency(dependency);
+            return this;
+        }
+
+        public Builder after(Animator10 anim) {
+            Node node = mNodeMap.get(anim);
+            if (node == null) {
+                node = new Node(anim);
+                mNodeMap.put(anim, node);
+                mNodes.add(node);
+            }
+            Dependency dependency = new Dependency(node, Dependency.AFTER);
+            mCurrentNode.addDependency(dependency);
+            return this;
+        }
+
+        public Builder after(long delay) {
+            ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f);
+            anim.setDuration(delay);
+            after(anim);
+            return this;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatEvaluator.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatEvaluator.java
new file mode 100644
index 000000000..856f4acd4
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatEvaluator.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+public class FloatEvaluator implements TypeEvaluator<Number> {
+    public Float evaluate(float fraction, Number startValue, Number endValue) {
+        float startFloat = startValue.floatValue();
+        return startFloat + fraction * (endValue.floatValue() - startFloat);
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatKeyframeSet.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatKeyframeSet.java
new file mode 100644
index 000000000..691b44b31
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatKeyframeSet.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import android.view.animation.Interpolator;
+
+import org.telegram.android.Animation.Keyframe.FloatKeyframe;
+
+import java.util.ArrayList;
+
+class FloatKeyframeSet extends KeyframeSet {
+    private float firstValue;
+    private float lastValue;
+    private float deltaValue;
+    private boolean firstTime = true;
+
+    public FloatKeyframeSet(FloatKeyframe... keyframes) {
+        super(keyframes);
+    }
+
+    @Override
+    public Object getValue(float fraction) {
+        return getFloatValue(fraction);
+    }
+
+    @Override
+    public FloatKeyframeSet clone() {
+        ArrayList<Keyframe> keyframes = mKeyframes;
+        int numKeyframes = mKeyframes.size();
+        FloatKeyframe[] newKeyframes = new FloatKeyframe[numKeyframes];
+        for (int i = 0; i < numKeyframes; ++i) {
+            newKeyframes[i] = (FloatKeyframe) keyframes.get(i).clone();
+        }
+        return new FloatKeyframeSet(newKeyframes);
+    }
+
+    @SuppressWarnings("unchecked")
+    public float getFloatValue(float fraction) {
+        if (mNumKeyframes == 2) {
+            if (firstTime) {
+                firstTime = false;
+                firstValue = ((FloatKeyframe) mKeyframes.get(0)).getFloatValue();
+                lastValue = ((FloatKeyframe) mKeyframes.get(1)).getFloatValue();
+                deltaValue = lastValue - firstValue;
+            }
+            if (mInterpolator != null) {
+                fraction = mInterpolator.getInterpolation(fraction);
+            }
+            if (mEvaluator == null) {
+                return firstValue + fraction * deltaValue;
+            } else {
+                return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).floatValue();
+            }
+        }
+        if (fraction <= 0f) {
+            final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
+            final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(1);
+            float prevValue = prevKeyframe.getFloatValue();
+            float nextValue = nextKeyframe.getFloatValue();
+            float prevFraction = prevKeyframe.getFraction();
+            float nextFraction = nextKeyframe.getFraction();
+            final Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null) {
+                fraction = interpolator.getInterpolation(fraction);
+            }
+            float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
+            return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
+        } else if (fraction >= 1f) {
+            final FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 2);
+            final FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(mNumKeyframes - 1);
+            float prevValue = prevKeyframe.getFloatValue();
+            float nextValue = nextKeyframe.getFloatValue();
+            float prevFraction = prevKeyframe.getFraction();
+            float nextFraction = nextKeyframe.getFraction();
+            final Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null) {
+                fraction = interpolator.getInterpolation(fraction);
+            }
+            float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
+            return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
+        }
+        FloatKeyframe prevKeyframe = (FloatKeyframe) mKeyframes.get(0);
+        for (int i = 1; i < mNumKeyframes; ++i) {
+            FloatKeyframe nextKeyframe = (FloatKeyframe) mKeyframes.get(i);
+            if (fraction < nextKeyframe.getFraction()) {
+                final Interpolator interpolator = nextKeyframe.getInterpolator();
+                if (interpolator != null) {
+                    fraction = interpolator.getInterpolation(fraction);
+                }
+                float intervalFraction = (fraction - prevKeyframe.getFraction()) /
+                    (nextKeyframe.getFraction() - prevKeyframe.getFraction());
+                float prevValue = prevKeyframe.getFloatValue();
+                float nextValue = nextKeyframe.getFloatValue();
+                return mEvaluator == null ? prevValue + intervalFraction * (nextValue - prevValue) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).floatValue();
+            }
+            prevKeyframe = nextKeyframe;
+        }
+        return ((Number)mKeyframes.get(mNumKeyframes - 1).getValue()).floatValue();
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatProperty10.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatProperty10.java
new file mode 100644
index 000000000..c02fb0f41
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/FloatProperty10.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.android.Animation;
+
+public abstract class FloatProperty10<T> extends Property<T, Float> {
+
+    public FloatProperty10(String name) {
+        super(Float.class, name);
+    }
+
+    public abstract void setValue(T object, float value);
+
+    @Override
+    final public void set(T object, Float value) {
+        setValue(object, value.floatValue());
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/IntEvaluator.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/IntEvaluator.java
new file mode 100644
index 000000000..3f77f57f8
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/IntEvaluator.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+public class IntEvaluator implements TypeEvaluator<Integer> {
+    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
+        int startInt = startValue;
+        return (int)(startInt + fraction * (endValue - startInt));
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/IntKeyframeSet.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/IntKeyframeSet.java
new file mode 100644
index 000000000..3135614fc
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/IntKeyframeSet.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import android.view.animation.Interpolator;
+
+import org.telegram.android.Animation.Keyframe.IntKeyframe;
+
+import java.util.ArrayList;
+
+class IntKeyframeSet extends KeyframeSet {
+    private int firstValue;
+    private int lastValue;
+    private int deltaValue;
+    private boolean firstTime = true;
+
+    public IntKeyframeSet(IntKeyframe... keyframes) {
+        super(keyframes);
+    }
+
+    @Override
+    public Object getValue(float fraction) {
+        return getIntValue(fraction);
+    }
+
+    @Override
+    public IntKeyframeSet clone() {
+        ArrayList<Keyframe> keyframes = mKeyframes;
+        int numKeyframes = mKeyframes.size();
+        IntKeyframe[] newKeyframes = new IntKeyframe[numKeyframes];
+        for (int i = 0; i < numKeyframes; ++i) {
+            newKeyframes[i] = (IntKeyframe) keyframes.get(i).clone();
+        }
+        return new IntKeyframeSet(newKeyframes);
+    }
+
+    @SuppressWarnings("unchecked")
+    public int getIntValue(float fraction) {
+        if (mNumKeyframes == 2) {
+            if (firstTime) {
+                firstTime = false;
+                firstValue = ((IntKeyframe) mKeyframes.get(0)).getIntValue();
+                lastValue = ((IntKeyframe) mKeyframes.get(1)).getIntValue();
+                deltaValue = lastValue - firstValue;
+            }
+            if (mInterpolator != null) {
+                fraction = mInterpolator.getInterpolation(fraction);
+            }
+            if (mEvaluator == null) {
+                return firstValue + (int)(fraction * deltaValue);
+            } else {
+                return ((Number)mEvaluator.evaluate(fraction, firstValue, lastValue)).intValue();
+            }
+        }
+        if (fraction <= 0f) {
+            final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
+            final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(1);
+            int prevValue = prevKeyframe.getIntValue();
+            int nextValue = nextKeyframe.getIntValue();
+            float prevFraction = prevKeyframe.getFraction();
+            float nextFraction = nextKeyframe.getFraction();
+            final Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null) {
+                fraction = interpolator.getInterpolation(fraction);
+            }
+            float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
+            return mEvaluator == null ? prevValue + (int)(intervalFraction * (nextValue - prevValue)) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
+        } else if (fraction >= 1f) {
+            final IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 2);
+            final IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(mNumKeyframes - 1);
+            int prevValue = prevKeyframe.getIntValue();
+            int nextValue = nextKeyframe.getIntValue();
+            float prevFraction = prevKeyframe.getFraction();
+            float nextFraction = nextKeyframe.getFraction();
+            final Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null) {
+                fraction = interpolator.getInterpolation(fraction);
+            }
+            float intervalFraction = (fraction - prevFraction) / (nextFraction - prevFraction);
+            return mEvaluator == null ? prevValue + (int)(intervalFraction * (nextValue - prevValue)) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
+        }
+        IntKeyframe prevKeyframe = (IntKeyframe) mKeyframes.get(0);
+        for (int i = 1; i < mNumKeyframes; ++i) {
+            IntKeyframe nextKeyframe = (IntKeyframe) mKeyframes.get(i);
+            if (fraction < nextKeyframe.getFraction()) {
+                final Interpolator interpolator = nextKeyframe.getInterpolator();
+                if (interpolator != null) {
+                    fraction = interpolator.getInterpolation(fraction);
+                }
+                float intervalFraction = (fraction - prevKeyframe.getFraction()) / (nextKeyframe.getFraction() - prevKeyframe.getFraction());
+                int prevValue = prevKeyframe.getIntValue();
+                int nextValue = nextKeyframe.getIntValue();
+                return mEvaluator == null ? prevValue + (int)(intervalFraction * (nextValue - prevValue)) : ((Number)mEvaluator.evaluate(intervalFraction, prevValue, nextValue)).intValue();
+            }
+            prevKeyframe = nextKeyframe;
+        }
+        return ((Number)mKeyframes.get(mNumKeyframes - 1).getValue()).intValue();
+    }
+}
+
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/IntProperty.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/IntProperty.java
new file mode 100644
index 000000000..701b88209
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/IntProperty.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.android.Animation;
+
+public abstract class IntProperty<T> extends Property<T, Integer> {
+
+    public IntProperty(String name) {
+        super(Integer.class, name);
+    }
+
+    public abstract void setValue(T object, int value);
+
+    @Override
+    final public void set(T object, Integer value) {
+        setValue(object, value.intValue());
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/Keyframe.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/Keyframe.java
new file mode 100644
index 000000000..2e4027392
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/Keyframe.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import android.view.animation.Interpolator;
+
+public abstract class Keyframe implements Cloneable {
+
+    float mFraction;
+    Class mValueType;
+    private Interpolator mInterpolator = null;
+    boolean mHasValue = false;
+
+    public static Keyframe ofInt(float fraction, int value) {
+        return new IntKeyframe(fraction, value);
+    }
+
+    public static Keyframe ofInt(float fraction) {
+        return new IntKeyframe(fraction);
+    }
+
+    public static Keyframe ofFloat(float fraction, float value) {
+        return new FloatKeyframe(fraction, value);
+    }
+
+    public static Keyframe ofFloat(float fraction) {
+        return new FloatKeyframe(fraction);
+    }
+
+    public static Keyframe ofObject(float fraction, Object value) {
+        return new ObjectKeyframe(fraction, value);
+    }
+
+    public static Keyframe ofObject(float fraction) {
+        return new ObjectKeyframe(fraction, null);
+    }
+
+    public boolean hasValue() {
+        return mHasValue;
+    }
+
+    public abstract Object getValue();
+    public abstract void setValue(Object value);
+
+    public float getFraction() {
+        return mFraction;
+    }
+
+    public void setFraction(float fraction) {
+        mFraction = fraction;
+    }
+
+    public Interpolator getInterpolator() {
+        return mInterpolator;
+    }
+
+    public void setInterpolator(Interpolator interpolator) {
+        mInterpolator = interpolator;
+    }
+
+    public Class getType() {
+        return mValueType;
+    }
+
+    @Override
+    public abstract Keyframe clone();
+
+    static class ObjectKeyframe extends Keyframe {
+
+        Object mValue;
+
+        ObjectKeyframe(float fraction, Object value) {
+            mFraction = fraction;
+            mValue = value;
+            mHasValue = (value != null);
+            mValueType = mHasValue ? value.getClass() : Object.class;
+        }
+
+        public Object getValue() {
+            return mValue;
+        }
+
+        public void setValue(Object value) {
+            mValue = value;
+            mHasValue = (value != null);
+        }
+
+        @Override
+        public ObjectKeyframe clone() {
+            ObjectKeyframe kfClone = new ObjectKeyframe(getFraction(), mHasValue ? mValue : null);
+            kfClone.setInterpolator(getInterpolator());
+            return kfClone;
+        }
+    }
+
+    static class IntKeyframe extends Keyframe {
+
+        int mValue;
+
+        IntKeyframe(float fraction, int value) {
+            mFraction = fraction;
+            mValue = value;
+            mValueType = int.class;
+            mHasValue = true;
+        }
+
+        IntKeyframe(float fraction) {
+            mFraction = fraction;
+            mValueType = int.class;
+        }
+
+        public int getIntValue() {
+            return mValue;
+        }
+
+        public Object getValue() {
+            return mValue;
+        }
+
+        public void setValue(Object value) {
+            if (value != null && value.getClass() == Integer.class) {
+                mValue = (Integer) value;
+                mHasValue = true;
+            }
+        }
+
+        @Override
+        public IntKeyframe clone() {
+            IntKeyframe kfClone = mHasValue ? new IntKeyframe(getFraction(), mValue) : new IntKeyframe(getFraction());
+            kfClone.setInterpolator(getInterpolator());
+            return kfClone;
+        }
+    }
+
+    static class FloatKeyframe extends Keyframe {
+
+        float mValue;
+
+        FloatKeyframe(float fraction, float value) {
+            mFraction = fraction;
+            mValue = value;
+            mValueType = float.class;
+            mHasValue = true;
+        }
+
+        FloatKeyframe(float fraction) {
+            mFraction = fraction;
+            mValueType = float.class;
+        }
+
+        public float getFloatValue() {
+            return mValue;
+        }
+
+        public Object getValue() {
+            return mValue;
+        }
+
+        public void setValue(Object value) {
+            if (value != null && value.getClass() == Float.class) {
+                mValue = (Float) value;
+                mHasValue = true;
+            }
+        }
+
+        @Override
+        public FloatKeyframe clone() {
+            FloatKeyframe kfClone = mHasValue ? new FloatKeyframe(getFraction(), mValue) : new FloatKeyframe(getFraction());
+            kfClone.setInterpolator(getInterpolator());
+            return kfClone;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/KeyframeSet.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/KeyframeSet.java
new file mode 100644
index 000000000..38739e211
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/KeyframeSet.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import android.util.Log;
+import android.view.animation.Interpolator;
+
+import org.telegram.android.Animation.Keyframe.IntKeyframe;
+import org.telegram.android.Animation.Keyframe.FloatKeyframe;
+import org.telegram.android.Animation.Keyframe.ObjectKeyframe;
+
+class KeyframeSet {
+
+    int mNumKeyframes;
+
+    Keyframe mFirstKeyframe;
+    Keyframe mLastKeyframe;
+    Interpolator mInterpolator;
+    ArrayList<Keyframe> mKeyframes;
+    TypeEvaluator mEvaluator;
+
+    public KeyframeSet(Keyframe... keyframes) {
+        mNumKeyframes = keyframes.length;
+        mKeyframes = new ArrayList<Keyframe>();
+        mKeyframes.addAll(Arrays.asList(keyframes));
+        mFirstKeyframe = mKeyframes.get(0);
+        mLastKeyframe = mKeyframes.get(mNumKeyframes - 1);
+        mInterpolator = mLastKeyframe.getInterpolator();
+    }
+
+    public static KeyframeSet ofInt(int... values) {
+        int numKeyframes = values.length;
+        IntKeyframe keyframes[] = new IntKeyframe[Math.max(numKeyframes,2)];
+        if (numKeyframes == 1) {
+            keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f);
+            keyframes[1] = (IntKeyframe) Keyframe.ofInt(1f, values[0]);
+        } else {
+            keyframes[0] = (IntKeyframe) Keyframe.ofInt(0f, values[0]);
+            for (int i = 1; i < numKeyframes; ++i) {
+                keyframes[i] = (IntKeyframe) Keyframe.ofInt((float) i / (numKeyframes - 1), values[i]);
+            }
+        }
+        return new IntKeyframeSet(keyframes);
+    }
+
+    public static KeyframeSet ofFloat(float... values) {
+        boolean badValue = false;
+        int numKeyframes = values.length;
+        FloatKeyframe keyframes[] = new FloatKeyframe[Math.max(numKeyframes,2)];
+        if (numKeyframes == 1) {
+            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
+            keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
+            if (Float.isNaN(values[0])) {
+                badValue = true;
+            }
+        } else {
+            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
+            for (int i = 1; i < numKeyframes; ++i) {
+                keyframes[i] = (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
+                if (Float.isNaN(values[i])) {
+                    badValue = true;
+                }
+            }
+        }
+        if (badValue) {
+            Log.w("Animator", "Bad value (NaN) in float animator");
+        }
+        return new FloatKeyframeSet(keyframes);
+    }
+
+    public static KeyframeSet ofKeyframe(Keyframe... keyframes) {
+        int numKeyframes = keyframes.length;
+        boolean hasFloat = false;
+        boolean hasInt = false;
+        boolean hasOther = false;
+        for (Keyframe keyframe : keyframes) {
+            if (keyframe instanceof FloatKeyframe) {
+                hasFloat = true;
+            } else if (keyframe instanceof IntKeyframe) {
+                hasInt = true;
+            } else {
+                hasOther = true;
+            }
+        }
+        if (hasFloat && !hasInt && !hasOther) {
+            FloatKeyframe floatKeyframes[] = new FloatKeyframe[numKeyframes];
+            for (int i = 0; i < numKeyframes; ++i) {
+                floatKeyframes[i] = (FloatKeyframe) keyframes[i];
+            }
+            return new FloatKeyframeSet(floatKeyframes);
+        } else if (hasInt && !hasFloat && !hasOther) {
+            IntKeyframe intKeyframes[] = new IntKeyframe[numKeyframes];
+            for (int i = 0; i < numKeyframes; ++i) {
+                intKeyframes[i] = (IntKeyframe) keyframes[i];
+            }
+            return new IntKeyframeSet(intKeyframes);
+        } else {
+            return new KeyframeSet(keyframes);
+        }
+    }
+
+    public static KeyframeSet ofObject(Object... values) {
+        int numKeyframes = values.length;
+        ObjectKeyframe keyframes[] = new ObjectKeyframe[Math.max(numKeyframes,2)];
+        if (numKeyframes == 1) {
+            keyframes[0] = (ObjectKeyframe) Keyframe.ofObject(0f);
+            keyframes[1] = (ObjectKeyframe) Keyframe.ofObject(1f, values[0]);
+        } else {
+            keyframes[0] = (ObjectKeyframe) Keyframe.ofObject(0f, values[0]);
+            for (int i = 1; i < numKeyframes; ++i) {
+                keyframes[i] = (ObjectKeyframe) Keyframe.ofObject((float) i / (numKeyframes - 1), values[i]);
+            }
+        }
+        return new KeyframeSet(keyframes);
+    }
+
+    public void setEvaluator(TypeEvaluator evaluator) {
+        mEvaluator = evaluator;
+    }
+
+    @Override
+    public KeyframeSet clone() {
+        ArrayList<Keyframe> keyframes = mKeyframes;
+        int numKeyframes = mKeyframes.size();
+        Keyframe[] newKeyframes = new Keyframe[numKeyframes];
+        for (int i = 0; i < numKeyframes; ++i) {
+            newKeyframes[i] = keyframes.get(i).clone();
+        }
+        return new KeyframeSet(newKeyframes);
+    }
+
+    @SuppressWarnings("unchecked")
+    public Object getValue(float fraction) {
+        if (mNumKeyframes == 2) {
+            if (mInterpolator != null) {
+                fraction = mInterpolator.getInterpolation(fraction);
+            }
+            return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue());
+        }
+        if (fraction <= 0f) {
+            final Keyframe nextKeyframe = mKeyframes.get(1);
+            final Interpolator interpolator = nextKeyframe.getInterpolator();
+            if (interpolator != null) {
+                fraction = interpolator.getInterpolation(fraction);
+            }
+            final float prevFraction = mFirstKeyframe.getFraction();
+            float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
+            return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(), nextKeyframe.getValue());
+        } else if (fraction >= 1f) {
+            final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
+            final Interpolator interpolator = mLastKeyframe.getInterpolator();
+            if (interpolator != null) {
+                fraction = interpolator.getInterpolation(fraction);
+            }
+            final float prevFraction = prevKeyframe.getFraction();
+            float intervalFraction = (fraction - prevFraction) / (mLastKeyframe.getFraction() - prevFraction);
+            return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), mLastKeyframe.getValue());
+        }
+        Keyframe prevKeyframe = mFirstKeyframe;
+        for (int i = 1; i < mNumKeyframes; ++i) {
+            Keyframe nextKeyframe = mKeyframes.get(i);
+            if (fraction < nextKeyframe.getFraction()) {
+                final Interpolator interpolator = nextKeyframe.getInterpolator();
+                if (interpolator != null) {
+                    fraction = interpolator.getInterpolation(fraction);
+                }
+                final float prevFraction = prevKeyframe.getFraction();
+                float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
+                return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), nextKeyframe.getValue());
+            }
+            prevKeyframe = nextKeyframe;
+        }
+        return mLastKeyframe.getValue();
+    }
+
+    @Override
+    public String toString() {
+        String returnVal = " ";
+        for (int i = 0; i < mNumKeyframes; ++i) {
+            returnVal += mKeyframes.get(i).getValue() + "  ";
+        }
+        return returnVal;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/NoSuchPropertyException.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/NoSuchPropertyException.java
new file mode 100644
index 000000000..bc00a4052
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/NoSuchPropertyException.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.android.Animation;
+
+public class NoSuchPropertyException extends RuntimeException {
+
+    public NoSuchPropertyException(String s) {
+        super(s);
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/ObjectAnimator10.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/ObjectAnimator10.java
new file mode 100644
index 000000000..d29f201c2
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/ObjectAnimator10.java
@@ -0,0 +1,488 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import android.view.View;
+
+import java.util.HashMap;
+
+public final class ObjectAnimator10 extends ValueAnimator {
+
+    private static final HashMap<String, Property> PROXY_PROPERTIES = new HashMap<String, Property>();
+
+    static {
+        Property<View, Float> ALPHA = new FloatProperty10<View>("alpha") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setAlpha(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getAlpha();
+            }
+        };
+
+        Property<View, Float> PIVOT_X = new FloatProperty10<View>("pivotX") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setPivotX(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getPivotX();
+            }
+        };
+
+        Property<View, Float> PIVOT_Y = new FloatProperty10<View>("pivotY") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setPivotY(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getPivotY();
+            }
+        };
+
+        Property<View, Float> TRANSLATION_X = new FloatProperty10<View>("translationX") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setTranslationX(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getTranslationX();
+            }
+        };
+
+        Property<View, Float> TRANSLATION_Y = new FloatProperty10<View>("translationY") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setTranslationY(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getTranslationY();
+            }
+        };
+
+        Property<View, Float> ROTATION = new FloatProperty10<View>("rotation") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setRotation(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getRotation();
+            }
+        };
+
+        Property<View, Float> ROTATION_X = new FloatProperty10<View>("rotationX") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setRotationX(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getRotationX();
+            }
+        };
+
+        Property<View, Float> ROTATION_Y = new FloatProperty10<View>("rotationY") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setRotationY(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getRotationY();
+            }
+        };
+
+        Property<View, Float> SCALE_X = new FloatProperty10<View>("scaleX") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setScaleX(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getScaleX();
+            }
+        };
+
+        Property<View, Float> SCALE_Y = new FloatProperty10<View>("scaleY") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setScaleY(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getScaleY();
+            }
+        };
+
+        Property<View, Integer> SCROLL_X = new IntProperty<View>("scrollX") {
+            @Override
+            public void setValue(View object, int value) {
+                View10.wrap(object).setScrollX(value);
+            }
+
+            @Override
+            public Integer get(View object) {
+                return View10.wrap(object).getScrollX();
+            }
+        };
+
+        Property<View, Integer> SCROLL_Y = new IntProperty<View>("scrollY") {
+            @Override
+            public void setValue(View object, int value) {
+                View10.wrap(object).setScrollY(value);
+            }
+
+            @Override
+            public Integer get(View object) {
+                return View10.wrap(object).getScrollY();
+            }
+        };
+
+        Property<View, Float> X = new FloatProperty10<View>("x") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setX(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getX();
+            }
+        };
+
+        Property<View, Float> Y = new FloatProperty10<View>("y") {
+            @Override
+            public void setValue(View object, float value) {
+                View10.wrap(object).setY(value);
+            }
+
+            @Override
+            public Float get(View object) {
+                return View10.wrap(object).getY();
+            }
+        };
+
+        PROXY_PROPERTIES.put("alpha", ALPHA);
+        PROXY_PROPERTIES.put("pivotX", PIVOT_X);
+        PROXY_PROPERTIES.put("pivotY", PIVOT_Y);
+        PROXY_PROPERTIES.put("translationX", TRANSLATION_X);
+        PROXY_PROPERTIES.put("translationY", TRANSLATION_Y);
+        PROXY_PROPERTIES.put("rotation", ROTATION);
+        PROXY_PROPERTIES.put("rotationX", ROTATION_X);
+        PROXY_PROPERTIES.put("rotationY", ROTATION_Y);
+        PROXY_PROPERTIES.put("scaleX", SCALE_X);
+        PROXY_PROPERTIES.put("scaleY", SCALE_Y);
+        PROXY_PROPERTIES.put("scrollX", SCROLL_X);
+        PROXY_PROPERTIES.put("scrollY", SCROLL_Y);
+        PROXY_PROPERTIES.put("x", X);
+        PROXY_PROPERTIES.put("y", Y);
+    }
+
+    private Object mTarget;
+    private String mPropertyName;
+    private Property mProperty;
+    private boolean mAutoCancel = false;
+
+    public void setPropertyName(String propertyName) {
+        if (mValues != null) {
+            PropertyValuesHolder valuesHolder = mValues[0];
+            String oldName = valuesHolder.getPropertyName();
+            valuesHolder.setPropertyName(propertyName);
+            mValuesMap.remove(oldName);
+            mValuesMap.put(propertyName, valuesHolder);
+        }
+        mPropertyName = propertyName;
+        mInitialized = false;
+    }
+
+    public void setProperty(Property property) {
+        if (mValues != null) {
+            PropertyValuesHolder valuesHolder = mValues[0];
+            String oldName = valuesHolder.getPropertyName();
+            valuesHolder.setProperty(property);
+            mValuesMap.remove(oldName);
+            mValuesMap.put(mPropertyName, valuesHolder);
+        }
+        if (mProperty != null) {
+            mPropertyName = property.getName();
+        }
+        mProperty = property;
+        mInitialized = false;
+    }
+
+    public String getPropertyName() {
+        String propertyName = null;
+        if (mPropertyName != null) {
+            propertyName = mPropertyName;
+        } else if (mProperty != null) {
+            propertyName = mProperty.getName();
+        } else if (mValues != null && mValues.length > 0) {
+            for (int i = 0; i < mValues.length; ++i) {
+                if (i == 0) {
+                    propertyName = "";
+                } else {
+                    propertyName += ",";
+                }
+                propertyName += mValues[i].getPropertyName();
+            }
+        }
+        return propertyName;
+    }
+
+    public ObjectAnimator10() {
+
+    }
+
+    private ObjectAnimator10(Object target, String propertyName) {
+        mTarget = target;
+        setPropertyName(propertyName);
+    }
+
+    private <T> ObjectAnimator10(T target, Property<T, ?> property) {
+        mTarget = target;
+        setProperty(property);
+    }
+
+    public static ObjectAnimator10 ofInt(Object target, String propertyName, int... values) {
+        ObjectAnimator10 anim = new ObjectAnimator10(target, propertyName);
+        anim.setIntValues(values);
+        return anim;
+    }
+
+    public static <T> ObjectAnimator10 ofInt(T target, Property<T, Integer> property, int... values) {
+        ObjectAnimator10 anim = new ObjectAnimator10(target, property);
+        anim.setIntValues(values);
+        return anim;
+    }
+
+    public static ObjectAnimator10 ofFloat(Object target, String propertyName, float... values) {
+        ObjectAnimator10 anim = new ObjectAnimator10(target, propertyName);
+        anim.setFloatValues(values);
+        return anim;
+    }
+
+    public static <T> ObjectAnimator10 ofFloat(T target, Property<T, Float> property, float... values) {
+        ObjectAnimator10 anim = new ObjectAnimator10(target, property);
+        anim.setFloatValues(values);
+        return anim;
+    }
+
+    public static ObjectAnimator10 ofObject(Object target, String propertyName, TypeEvaluator evaluator, Object... values) {
+        ObjectAnimator10 anim = new ObjectAnimator10(target, propertyName);
+        anim.setObjectValues(values);
+        anim.setEvaluator(evaluator);
+        return anim;
+    }
+
+    public static <T, V> ObjectAnimator10 ofObject(T target, Property<T, V> property, TypeEvaluator<V> evaluator, V... values) {
+        ObjectAnimator10 anim = new ObjectAnimator10(target, property);
+        anim.setObjectValues(values);
+        anim.setEvaluator(evaluator);
+        return anim;
+    }
+
+    public static ObjectAnimator10 ofPropertyValuesHolder(Object target, PropertyValuesHolder... values) {
+        ObjectAnimator10 anim = new ObjectAnimator10();
+        anim.mTarget = target;
+        anim.setValues(values);
+        return anim;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void setIntValues(int... values) {
+        if (mValues == null || mValues.length == 0) {
+            if (mProperty != null) {
+                setValues(PropertyValuesHolder.ofInt(mProperty, values));
+            } else {
+                setValues(PropertyValuesHolder.ofInt(mPropertyName, values));
+            }
+        } else {
+            super.setIntValues(values);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void setFloatValues(float... values) {
+        if (mValues == null || mValues.length == 0) {
+            if (mProperty != null) {
+                setValues(PropertyValuesHolder.ofFloat(mProperty, values));
+            } else {
+                setValues(PropertyValuesHolder.ofFloat(mPropertyName, values));
+            }
+        } else {
+            super.setFloatValues(values);
+        }
+    }
+
+    @Override
+    public void setObjectValues(Object... values) {
+        if (mValues == null || mValues.length == 0) {
+            if (mProperty != null) {
+                setValues(PropertyValuesHolder.ofObject(mProperty, null, values));
+            } else {
+                setValues(PropertyValuesHolder.ofObject(mPropertyName, null, values));
+            }
+        } else {
+            super.setObjectValues(values);
+        }
+    }
+
+    public void setAutoCancel(boolean cancel) {
+        mAutoCancel = cancel;
+    }
+
+    private boolean hasSameTargetAndProperties(Animator10 anim) {
+        if (anim instanceof ObjectAnimator10) {
+            PropertyValuesHolder[] theirValues = ((ObjectAnimator10) anim).getValues();
+            if (((ObjectAnimator10) anim).getTarget() == mTarget &&
+                    mValues.length == theirValues.length) {
+                for (int i = 0; i < mValues.length; ++i) {
+                    PropertyValuesHolder pvhMine = mValues[i];
+                    PropertyValuesHolder pvhTheirs = theirValues[i];
+                    if (pvhMine.getPropertyName() == null ||
+                            !pvhMine.getPropertyName().equals(pvhTheirs.getPropertyName())) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public void start() {
+        AnimationHandler handler = sAnimationHandler.get();
+        if (handler != null) {
+            int numAnims = handler.mAnimations.size();
+            for (int i = numAnims - 1; i >= 0; i--) {
+                if (handler.mAnimations.get(i) instanceof ObjectAnimator10) {
+                    ObjectAnimator10 anim = (ObjectAnimator10) handler.mAnimations.get(i);
+                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {
+                        anim.cancel();
+                    }
+                }
+            }
+            numAnims = handler.mPendingAnimations.size();
+            for (int i = numAnims - 1; i >= 0; i--) {
+                if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator10) {
+                    ObjectAnimator10 anim = (ObjectAnimator10) handler.mPendingAnimations.get(i);
+                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {
+                        anim.cancel();
+                    }
+                }
+            }
+            numAnims = handler.mDelayedAnims.size();
+            for (int i = numAnims - 1; i >= 0; i--) {
+                if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator10) {
+                    ObjectAnimator10 anim = (ObjectAnimator10) handler.mDelayedAnims.get(i);
+                    if (anim.mAutoCancel && hasSameTargetAndProperties(anim)) {
+                        anim.cancel();
+                    }
+                }
+            }
+        }
+        super.start();
+    }
+
+    @Override
+    void initAnimation() {
+        if (!mInitialized) {
+            if ((mProperty == null) && (mTarget instanceof View) && PROXY_PROPERTIES.containsKey(mPropertyName)) {
+                setProperty(PROXY_PROPERTIES.get(mPropertyName));
+            }
+            int numValues = mValues.length;
+            for (PropertyValuesHolder mValue : mValues) {
+                mValue.setupSetterAndGetter(mTarget);
+            }
+            super.initAnimation();
+        }
+    }
+
+    @Override
+    public ObjectAnimator10 setDuration(long duration) {
+        super.setDuration(duration);
+        return this;
+    }
+
+    public Object getTarget() {
+        return mTarget;
+    }
+
+    @Override
+    public void setTarget(Object target) {
+        if (mTarget != target) {
+            final Object oldTarget = mTarget;
+            mTarget = target;
+            if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass()) {
+                return;
+            }
+            mInitialized = false;
+        }
+    }
+
+    @Override
+    public void setupStartValues() {
+        initAnimation();
+        int numValues = mValues.length;
+        for (PropertyValuesHolder mValue : mValues) {
+            mValue.setupStartValue(mTarget);
+        }
+    }
+
+    @Override
+    public void setupEndValues() {
+        initAnimation();
+        int numValues = mValues.length;
+        for (PropertyValuesHolder mValue : mValues) {
+            mValue.setupEndValue(mTarget);
+        }
+    }
+
+    @Override
+    void animateValue(float fraction) {
+        super.animateValue(fraction);
+        int numValues = mValues.length;
+        for (PropertyValuesHolder mValue : mValues) {
+            mValue.setAnimatedValue(mTarget);
+        }
+    }
+
+    @Override
+    public ObjectAnimator10 clone() {
+        return (ObjectAnimator10) super.clone();
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/Property.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/Property.java
new file mode 100644
index 000000000..cd5248bb6
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/Property.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.android.Animation;
+
+public abstract class Property<T, V> {
+
+    private final String mName;
+    private final Class<V> mType;
+
+    public static <T, V> Property<T, V> of(Class<T> hostType, Class<V> valueType, String name) {
+        return new ReflectiveProperty<T, V>(hostType, valueType, name);
+    }
+
+    public Property(Class<V> type, String name) {
+        mName = name;
+        mType = type;
+    }
+
+    public boolean isReadOnly() {
+        return false;
+    }
+
+    public void set(T object, V value) {
+        throw new UnsupportedOperationException("Property " + getName() +" is read-only");
+    }
+
+    public abstract V get(T object);
+
+    public String getName() {
+        return mName;
+    }
+
+    public Class<V> getType() {
+        return mType;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/PropertyValuesHolder.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/PropertyValuesHolder.java
new file mode 100644
index 000000000..25dfa8385
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/PropertyValuesHolder.java
@@ -0,0 +1,545 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+public class PropertyValuesHolder implements Cloneable {
+
+    String mPropertyName;
+    protected Property mProperty;
+    Method mSetter = null;
+    private Method mGetter = null;
+    Class mValueType;
+    KeyframeSet mKeyframeSet = null;
+
+    private static final TypeEvaluator sIntEvaluator = new IntEvaluator();
+    private static final TypeEvaluator sFloatEvaluator = new FloatEvaluator();
+
+    private static Class[] FLOAT_VARIANTS = {float.class, Float.class, double.class, int.class, Double.class, Integer.class};
+    private static Class[] INTEGER_VARIANTS = {int.class, Integer.class, float.class, double.class, Float.class, Double.class};
+    private static Class[] DOUBLE_VARIANTS = {double.class, Double.class, float.class, int.class, Float.class, Integer.class};
+
+    private static final HashMap<Class, HashMap<String, Method>> sSetterPropertyMap = new HashMap<Class, HashMap<String, Method>>();
+    private static final HashMap<Class, HashMap<String, Method>> sGetterPropertyMap = new HashMap<Class, HashMap<String, Method>>();
+
+    final ReentrantReadWriteLock mPropertyMapLock = new ReentrantReadWriteLock();
+    final Object[] mTmpValueArray = new Object[1];
+
+    private TypeEvaluator mEvaluator;
+
+    private Object mAnimatedValue;
+
+    private PropertyValuesHolder(String propertyName) {
+        mPropertyName = propertyName;
+    }
+
+    private PropertyValuesHolder(Property property) {
+        mProperty = property;
+        if (property != null) {
+            mPropertyName = property.getName();
+        }
+    }
+
+    public static PropertyValuesHolder ofInt(String propertyName, int... values) {
+        return new IntPropertyValuesHolder(propertyName, values);
+    }
+
+    public static PropertyValuesHolder ofInt(Property<?, Integer> property, int... values) {
+        return new IntPropertyValuesHolder(property, values);
+    }
+
+    public static PropertyValuesHolder ofFloat(String propertyName, float... values) {
+        return new FloatPropertyValuesHolder(propertyName, values);
+    }
+
+    public static PropertyValuesHolder ofFloat(Property<?, Float> property, float... values) {
+        return new FloatPropertyValuesHolder(property, values);
+    }
+
+    public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,
+                                                Object... values) {
+        PropertyValuesHolder pvh = new PropertyValuesHolder(propertyName);
+        pvh.setObjectValues(values);
+        pvh.setEvaluator(evaluator);
+        return pvh;
+    }
+
+    public static <V> PropertyValuesHolder ofObject(Property property,
+                                                    TypeEvaluator<V> evaluator, V... values) {
+        PropertyValuesHolder pvh = new PropertyValuesHolder(property);
+        pvh.setObjectValues(values);
+        pvh.setEvaluator(evaluator);
+        return pvh;
+    }
+
+    public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values) {
+        KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
+        if (keyframeSet instanceof IntKeyframeSet) {
+            return new IntPropertyValuesHolder(propertyName, (IntKeyframeSet) keyframeSet);
+        } else if (keyframeSet instanceof FloatKeyframeSet) {
+            return new FloatPropertyValuesHolder(propertyName, (FloatKeyframeSet) keyframeSet);
+        } else {
+            PropertyValuesHolder pvh = new PropertyValuesHolder(propertyName);
+            pvh.mKeyframeSet = keyframeSet;
+            pvh.mValueType = values[0].getType();
+            return pvh;
+        }
+    }
+
+    public static PropertyValuesHolder ofKeyframe(Property property, Keyframe... values) {
+        KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
+        if (keyframeSet instanceof IntKeyframeSet) {
+            return new IntPropertyValuesHolder(property, (IntKeyframeSet) keyframeSet);
+        } else if (keyframeSet instanceof FloatKeyframeSet) {
+            return new FloatPropertyValuesHolder(property, (FloatKeyframeSet) keyframeSet);
+        } else {
+            PropertyValuesHolder pvh = new PropertyValuesHolder(property);
+            pvh.mKeyframeSet = keyframeSet;
+            pvh.mValueType = values[0].getType();
+            return pvh;
+        }
+    }
+
+    public void setIntValues(int... values) {
+        mValueType = int.class;
+        mKeyframeSet = KeyframeSet.ofInt(values);
+    }
+
+    public void setFloatValues(float... values) {
+        mValueType = float.class;
+        mKeyframeSet = KeyframeSet.ofFloat(values);
+    }
+
+    public void setKeyframes(Keyframe... values) {
+        int numKeyframes = values.length;
+        Keyframe keyframes[] = new Keyframe[Math.max(numKeyframes, 2)];
+        mValueType = values[0].getType();
+        System.arraycopy(values, 0, keyframes, 0, numKeyframes);
+        mKeyframeSet = new KeyframeSet(keyframes);
+    }
+
+    public void setObjectValues(Object... values) {
+        mValueType = values[0].getClass();
+        mKeyframeSet = KeyframeSet.ofObject(values);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Method getPropertyFunction(Class targetClass, String prefix, Class valueType) {
+        Method returnVal = null;
+        String methodName = getMethodName(prefix, mPropertyName);
+        Class args[] = null;
+        if (valueType == null) {
+            try {
+                returnVal = targetClass.getMethod(methodName);
+            } catch (Throwable e) {
+                try {
+                    returnVal = targetClass.getDeclaredMethod(methodName);
+                    returnVal.setAccessible(true);
+                } catch (Throwable e2) {
+                    e2.printStackTrace();
+                }
+            }
+        } else {
+            args = new Class[1];
+            Class typeVariants[];
+            if (mValueType.equals(Float.class)) {
+                typeVariants = FLOAT_VARIANTS;
+            } else if (mValueType.equals(Integer.class)) {
+                typeVariants = INTEGER_VARIANTS;
+            } else if (mValueType.equals(Double.class)) {
+                typeVariants = DOUBLE_VARIANTS;
+            } else {
+                typeVariants = new Class[1];
+                typeVariants[0] = mValueType;
+            }
+            for (Class typeVariant : typeVariants) {
+                args[0] = typeVariant;
+                try {
+                    returnVal = targetClass.getMethod(methodName, args);
+                    mValueType = typeVariant;
+                    return returnVal;
+                } catch (Throwable e) {
+                    try {
+                        returnVal = targetClass.getDeclaredMethod(methodName, args);
+                        returnVal.setAccessible(true);
+                        mValueType = typeVariant;
+                        return returnVal;
+                    } catch (Throwable e2) {
+                        // Swallow the error and keep trying other variants
+                    }
+                }
+            }
+        }
+
+        return returnVal;
+    }
+
+    private Method setupSetterOrGetter(Class targetClass, HashMap<Class, HashMap<String, Method>> propertyMapMap, String prefix, Class valueType) {
+        Method setterOrGetter = null;
+        try {
+            mPropertyMapLock.writeLock().lock();
+            HashMap<String, Method> propertyMap = propertyMapMap.get(targetClass);
+            if (propertyMap != null) {
+                setterOrGetter = propertyMap.get(mPropertyName);
+            }
+            if (setterOrGetter == null) {
+                setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
+                if (propertyMap == null) {
+                    propertyMap = new HashMap<String, Method>();
+                    propertyMapMap.put(targetClass, propertyMap);
+                }
+                propertyMap.put(mPropertyName, setterOrGetter);
+            }
+        } finally {
+            mPropertyMapLock.writeLock().unlock();
+        }
+        return setterOrGetter;
+    }
+
+    void setupSetter(Class targetClass) {
+        mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", mValueType);
+    }
+
+    private void setupGetter(Class targetClass) {
+        mGetter = setupSetterOrGetter(targetClass, sGetterPropertyMap, "get", null);
+    }
+
+    @SuppressWarnings("unchecked")
+    void setupSetterAndGetter(Object target) {
+        if (mProperty != null) {
+            try {
+                Object testValue = mProperty.get(target);
+                for (Keyframe kf : mKeyframeSet.mKeyframes) {
+                    if (!kf.hasValue()) {
+                        kf.setValue(mProperty.get(target));
+                    }
+                }
+                return;
+            } catch (Throwable e) {
+                mProperty = null;
+            }
+        }
+        Class targetClass = target.getClass();
+        if (mSetter == null) {
+            setupSetter(targetClass);
+        }
+        for (Keyframe kf : mKeyframeSet.mKeyframes) {
+            if (!kf.hasValue()) {
+                if (mGetter == null) {
+                    setupGetter(targetClass);
+                    if (mGetter == null) {
+                        return;
+                    }
+                }
+                try {
+                    kf.setValue(mGetter.invoke(target));
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private void setupValue(Object target, Keyframe kf) {
+        if (mProperty != null) {
+            kf.setValue(mProperty.get(target));
+        }
+        try {
+            if (mGetter == null) {
+                Class targetClass = target.getClass();
+                setupGetter(targetClass);
+                if (mGetter == null) {
+                    return;
+                }
+            }
+            kf.setValue(mGetter.invoke(target));
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+    }
+
+    void setupStartValue(Object target) {
+        setupValue(target, mKeyframeSet.mKeyframes.get(0));
+    }
+
+    void setupEndValue(Object target) {
+        setupValue(target, mKeyframeSet.mKeyframes.get(mKeyframeSet.mKeyframes.size() - 1));
+    }
+
+    @Override
+    public PropertyValuesHolder clone() {
+        try {
+            PropertyValuesHolder newPVH = (PropertyValuesHolder) super.clone();
+            newPVH.mPropertyName = mPropertyName;
+            newPVH.mProperty = mProperty;
+            newPVH.mKeyframeSet = mKeyframeSet.clone();
+            newPVH.mEvaluator = mEvaluator;
+            return newPVH;
+        } catch (CloneNotSupportedException e) {
+            return null;
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    void setAnimatedValue(Object target) {
+        if (mProperty != null) {
+            mProperty.set(target, getAnimatedValue());
+        }
+        if (mSetter != null) {
+            try {
+                mTmpValueArray[0] = getAnimatedValue();
+                mSetter.invoke(target, mTmpValueArray);
+            } catch (Throwable e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    void init() {
+        if (mEvaluator == null) {
+            mEvaluator = (mValueType == Integer.class) ? sIntEvaluator : (mValueType == Float.class) ? sFloatEvaluator : null;
+        }
+        if (mEvaluator != null) {
+            mKeyframeSet.setEvaluator(mEvaluator);
+        }
+    }
+
+    public void setEvaluator(TypeEvaluator evaluator) {
+        mEvaluator = evaluator;
+        mKeyframeSet.setEvaluator(evaluator);
+    }
+
+    void calculateValue(float fraction) {
+        mAnimatedValue = mKeyframeSet.getValue(fraction);
+    }
+
+    public void setPropertyName(String propertyName) {
+        mPropertyName = propertyName;
+    }
+
+    public void setProperty(Property property) {
+        mProperty = property;
+    }
+
+    public String getPropertyName() {
+        return mPropertyName;
+    }
+
+    Object getAnimatedValue() {
+        return mAnimatedValue;
+    }
+
+    @Override
+    public String toString() {
+        return mPropertyName + ": " + mKeyframeSet.toString();
+    }
+
+    static String getMethodName(String prefix, String propertyName) {
+        if (propertyName == null || propertyName.length() == 0) {
+            return prefix;
+        }
+        char firstLetter = Character.toUpperCase(propertyName.charAt(0));
+        String theRest = propertyName.substring(1);
+        return prefix + firstLetter + theRest;
+    }
+
+    static class IntPropertyValuesHolder extends PropertyValuesHolder {
+        private static final HashMap<Class, HashMap<String, Integer>> sJNISetterPropertyMap = new HashMap<Class, HashMap<String, Integer>>();
+        private IntProperty mIntProperty;
+
+        IntKeyframeSet mIntKeyframeSet;
+        int mIntAnimatedValue;
+
+        public IntPropertyValuesHolder(String propertyName, IntKeyframeSet keyframeSet) {
+            super(propertyName);
+            mValueType = int.class;
+            mKeyframeSet = keyframeSet;
+            mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
+        }
+
+        public IntPropertyValuesHolder(Property property, IntKeyframeSet keyframeSet) {
+            super(property);
+            mValueType = int.class;
+            mKeyframeSet = keyframeSet;
+            mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
+            if (property instanceof IntProperty) {
+                mIntProperty = (IntProperty) mProperty;
+            }
+        }
+
+        public IntPropertyValuesHolder(String propertyName, int... values) {
+            super(propertyName);
+            setIntValues(values);
+        }
+
+        public IntPropertyValuesHolder(Property property, int... values) {
+            super(property);
+            setIntValues(values);
+            if (property instanceof IntProperty) {
+                mIntProperty = (IntProperty) mProperty;
+            }
+        }
+
+        @Override
+        public void setIntValues(int... values) {
+            super.setIntValues(values);
+            mIntKeyframeSet = (IntKeyframeSet) mKeyframeSet;
+        }
+
+        @Override
+        void calculateValue(float fraction) {
+            mIntAnimatedValue = mIntKeyframeSet.getIntValue(fraction);
+        }
+
+        @Override
+        Object getAnimatedValue() {
+            return mIntAnimatedValue;
+        }
+
+        @Override
+        public IntPropertyValuesHolder clone() {
+            IntPropertyValuesHolder newPVH = (IntPropertyValuesHolder) super.clone();
+            newPVH.mIntKeyframeSet = (IntKeyframeSet) newPVH.mKeyframeSet;
+            return newPVH;
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        void setAnimatedValue(Object target) {
+            if (mIntProperty != null) {
+                mIntProperty.setValue(target, mIntAnimatedValue);
+                return;
+            }
+            if (mProperty != null) {
+                mProperty.set(target, mIntAnimatedValue);
+                return;
+            }
+            if (mSetter != null) {
+                try {
+                    mTmpValueArray[0] = mIntAnimatedValue;
+                    mSetter.invoke(target, mTmpValueArray);
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        @Override
+        void setupSetter(Class targetClass) {
+            if (mProperty != null) {
+                return;
+            }
+
+            super.setupSetter(targetClass);
+        }
+    }
+
+    static class FloatPropertyValuesHolder extends PropertyValuesHolder {
+
+        private static final HashMap<Class, HashMap<String, Integer>> sJNISetterPropertyMap = new HashMap<Class, HashMap<String, Integer>>();
+        private FloatProperty10 mFloatProperty;
+
+        FloatKeyframeSet mFloatKeyframeSet;
+        float mFloatAnimatedValue;
+
+        public FloatPropertyValuesHolder(String propertyName, FloatKeyframeSet keyframeSet) {
+            super(propertyName);
+            mValueType = float.class;
+            mKeyframeSet = keyframeSet;
+            mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
+        }
+
+        public FloatPropertyValuesHolder(Property property, FloatKeyframeSet keyframeSet) {
+            super(property);
+            mValueType = float.class;
+            mKeyframeSet = keyframeSet;
+            mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
+            if (property instanceof FloatProperty10) {
+                mFloatProperty = (FloatProperty10) mProperty;
+            }
+        }
+
+        public FloatPropertyValuesHolder(String propertyName, float... values) {
+            super(propertyName);
+            setFloatValues(values);
+        }
+
+        public FloatPropertyValuesHolder(Property property, float... values) {
+            super(property);
+            setFloatValues(values);
+            if (property instanceof FloatProperty10) {
+                mFloatProperty = (FloatProperty10) mProperty;
+            }
+        }
+
+        @Override
+        public void setFloatValues(float... values) {
+            super.setFloatValues(values);
+            mFloatKeyframeSet = (FloatKeyframeSet) mKeyframeSet;
+        }
+
+        @Override
+        void calculateValue(float fraction) {
+            mFloatAnimatedValue = mFloatKeyframeSet.getFloatValue(fraction);
+        }
+
+        @Override
+        Object getAnimatedValue() {
+            return mFloatAnimatedValue;
+        }
+
+        @Override
+        public FloatPropertyValuesHolder clone() {
+            FloatPropertyValuesHolder newPVH = (FloatPropertyValuesHolder) super.clone();
+            newPVH.mFloatKeyframeSet = (FloatKeyframeSet) newPVH.mKeyframeSet;
+            return newPVH;
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        void setAnimatedValue(Object target) {
+            if (mFloatProperty != null) {
+                mFloatProperty.setValue(target, mFloatAnimatedValue);
+                return;
+            }
+            if (mProperty != null) {
+                mProperty.set(target, mFloatAnimatedValue);
+                return;
+            }
+            if (mSetter != null) {
+                try {
+                    mTmpValueArray[0] = mFloatAnimatedValue;
+                    mSetter.invoke(target, mTmpValueArray);
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        @Override
+        void setupSetter(Class targetClass) {
+            if (mProperty != null) {
+                return;
+            }
+            super.setupSetter(targetClass);
+        }
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/ReflectiveProperty.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/ReflectiveProperty.java
new file mode 100644
index 000000000..7b4189822
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/ReflectiveProperty.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.android.Animation;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Internal class to automatically generate a Property for a given class/name pair, given the
+ * specification of {@link Property#of(java.lang.Class, java.lang.Class, java.lang.String)}
+ */
+class ReflectiveProperty<T, V> extends Property<T, V> {
+
+    private static final String PREFIX_GET = "get";
+    private static final String PREFIX_IS = "is";
+    private static final String PREFIX_SET = "set";
+    private Method mSetter;
+    private Method mGetter;
+    private Field mField;
+
+    /**
+     * For given property name 'name', look for getName/isName method or 'name' field.
+     * Also look for setName method (optional - could be readonly). Failing method getters and
+     * field results in throwing NoSuchPropertyException.
+     *
+     * @param propertyHolder The class on which the methods or field are found
+     * @param name The name of the property, where this name is capitalized and appended to
+     * "get" and "is to search for the appropriate methods. If the get/is methods are not found,
+     * the constructor will search for a field with that exact name.
+     */
+    public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String name) {
+         // TODO: cache reflection info for each new class/name pair
+        super(valueType, name);
+        char firstLetter = Character.toUpperCase(name.charAt(0));
+        String theRest = name.substring(1);
+        String capitalizedName = firstLetter + theRest;
+        String getterName = PREFIX_GET + capitalizedName;
+        try {
+            mGetter = propertyHolder.getMethod(getterName, (Class<?>[]) null);
+        } catch (NoSuchMethodException e) {
+            try {
+                /* The native implementation uses JNI to do reflection, which allows access to private methods.
+                 * getDeclaredMethod(..) does not find superclass methods, so it's implemented as a fallback.
+                 */
+                mGetter = propertyHolder.getDeclaredMethod(getterName, (Class<?>[]) null);
+                mGetter.setAccessible(true);
+            } catch (NoSuchMethodException e2) {
+                // getName() not available - try isName() instead
+                getterName = PREFIX_IS + capitalizedName;
+                try {
+                    mGetter = propertyHolder.getMethod(getterName, (Class<?>[]) null);
+                } catch (NoSuchMethodException e3) {
+                    try {
+                        /* The native implementation uses JNI to do reflection, which allows access to private methods.
+                         * getDeclaredMethod(..) does not find superclass methods, so it's implemented as a fallback.
+                         */
+                        mGetter = propertyHolder.getDeclaredMethod(getterName, (Class<?>[]) null);
+                        mGetter.setAccessible(true);
+                    } catch (NoSuchMethodException e4) {
+                        // Try public field instead
+                        try {
+                            mField = propertyHolder.getField(name);
+                            Class fieldType = mField.getType();
+                            if (!typesMatch(valueType, fieldType)) {
+                                throw new NoSuchPropertyException("Underlying type (" + fieldType + ") " +
+                                        "does not match Property type (" + valueType + ")");
+                            }
+                            return;
+                        } catch (NoSuchFieldException e5) {
+                            // no way to access property - throw appropriate exception
+                            throw new NoSuchPropertyException("No accessor method or field found for"
+                                    + " property with name " + name);
+                        }
+                    }
+                }
+            }
+        }
+        Class getterType = mGetter.getReturnType();
+        // Check to make sure our getter type matches our valueType
+        if (!typesMatch(valueType, getterType)) {
+            throw new NoSuchPropertyException("Underlying type (" + getterType + ") " +
+                    "does not match Property type (" + valueType + ")");
+        }
+        String setterName = PREFIX_SET + capitalizedName;
+        try {
+            // mSetter = propertyHolder.getMethod(setterName, getterType);
+            // The native implementation uses JNI to do reflection, which allows access to private methods.
+            mSetter = propertyHolder.getDeclaredMethod(setterName, getterType);
+            mSetter.setAccessible(true);
+        } catch (NoSuchMethodException ignored) {
+            // Okay to not have a setter - just a readonly property
+        }
+    }
+
+    /**
+     * Utility method to check whether the type of the underlying field/method on the target
+     * object matches the type of the Property. The extra checks for primitive types are because
+     * generics will force the Property type to be a class, whereas the type of the underlying
+     * method/field will probably be a primitive type instead. Accept float as matching Float,
+     * etc.
+     */
+    private boolean typesMatch(Class<V> valueType, Class getterType) {
+        if (getterType != valueType) {
+            if (getterType.isPrimitive()) {
+                return (getterType == float.class && valueType == Float.class) ||
+                        (getterType == int.class && valueType == Integer.class) ||
+                        (getterType == boolean.class && valueType == Boolean.class) ||
+                        (getterType == long.class && valueType == Long.class) ||
+                        (getterType == double.class && valueType == Double.class) ||
+                        (getterType == short.class && valueType == Short.class) ||
+                        (getterType == byte.class && valueType == Byte.class) ||
+                        (getterType == char.class && valueType == Character.class);
+            }
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public void set(T object, V value) {
+        if (mSetter != null) {
+            try {
+                mSetter.invoke(object, value);
+            } catch (IllegalAccessException e) {
+                throw new AssertionError();
+            } catch (InvocationTargetException e) {
+                throw new RuntimeException(e.getCause());
+            }
+        } else if (mField != null) {
+            try {
+                mField.set(object, value);
+            } catch (IllegalAccessException e) {
+                throw new AssertionError();
+            }
+        } else {
+            throw new UnsupportedOperationException("Property " + getName() +" is read-only");
+        }
+    }
+
+    @Override
+    public V get(T object) {
+        if (mGetter != null) {
+            try {
+                return (V) mGetter.invoke(object, (Object[])null);
+            } catch (IllegalAccessException e) {
+                throw new AssertionError();
+            } catch (InvocationTargetException e) {
+                throw new RuntimeException(e.getCause());
+            }
+        } else if (mField != null) {
+            try {
+                return (V) mField.get(object);
+            } catch (IllegalAccessException e) {
+                throw new AssertionError();
+            }
+        }
+        // Should not get here: there should always be a non-null getter or field
+        throw new AssertionError();
+    }
+
+    /**
+     * Returns false if there is no setter or public field underlying this Property.
+     */
+    @Override
+    public boolean isReadOnly() {
+        return (mSetter == null && mField == null);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/TypeEvaluator.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/TypeEvaluator.java
new file mode 100644
index 000000000..d70e28400
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/TypeEvaluator.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+public interface TypeEvaluator<T> {
+    T evaluate(float fraction, T startValue, T endValue);
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/ValueAnimator.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/ValueAnimator.java
new file mode 100644
index 000000000..3b0c29130
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/ValueAnimator.java
@@ -0,0 +1,675 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import android.os.Looper;
+import android.util.AndroidRuntimeException;
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.AnimationUtils;
+import android.view.animation.Interpolator;
+import android.view.animation.LinearInterpolator;
+
+import org.telegram.android.AndroidUtilities;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+public class ValueAnimator extends Animator10 {
+
+    private static float sDurationScale = 1.0f;
+    static final int STOPPED    = 0;
+    static final int RUNNING    = 1;
+    static final int SEEKED     = 2;
+
+    long mStartTime;
+    long mSeekTime = -1;
+    private long mPauseTime;
+    private boolean mResumed = false;
+    protected static ThreadLocal<AnimationHandler> sAnimationHandler = new ThreadLocal<AnimationHandler>();
+    private static final Interpolator sDefaultInterpolator = new AccelerateDecelerateInterpolator();
+    private boolean mPlayingBackwards = false;
+    private int mCurrentIteration = 0;
+    private float mCurrentFraction = 0f;
+    private boolean mStartedDelay = false;
+    private long mDelayStartTime;
+    int mPlayingState = STOPPED;
+    private boolean mRunning = false;
+    private boolean mStarted = false;
+    private boolean mStartListenersCalled = false;
+    boolean mInitialized = false;
+
+    private long mDuration = (long)(300 * sDurationScale);
+    private long mUnscaledDuration = 300;
+    private long mStartDelay = 0;
+    private long mUnscaledStartDelay = 0;
+    private int mRepeatCount = 0;
+    private int mRepeatMode = RESTART;
+    private Interpolator mInterpolator = sDefaultInterpolator;
+    private ArrayList<AnimatorUpdateListener> mUpdateListeners = null;
+    PropertyValuesHolder[] mValues;
+    HashMap<String, PropertyValuesHolder> mValuesMap;
+
+    public static final int RESTART = 1;
+    public static final int REVERSE = 2;
+    public static final int INFINITE = -1;
+
+    public static void setDurationScale(float durationScale) {
+        sDurationScale = durationScale;
+    }
+
+    public static float getDurationScale() {
+        return sDurationScale;
+    }
+
+    public ValueAnimator() {
+
+    }
+
+    public static ValueAnimator ofInt(int... values) {
+        ValueAnimator anim = new ValueAnimator();
+        anim.setIntValues(values);
+        return anim;
+    }
+
+    public static ValueAnimator ofFloat(float... values) {
+        ValueAnimator anim = new ValueAnimator();
+        anim.setFloatValues(values);
+        return anim;
+    }
+
+    public static ValueAnimator ofPropertyValuesHolder(PropertyValuesHolder... values) {
+        ValueAnimator anim = new ValueAnimator();
+        anim.setValues(values);
+        return anim;
+    }
+
+    public static ValueAnimator ofObject(TypeEvaluator evaluator, Object... values) {
+        ValueAnimator anim = new ValueAnimator();
+        anim.setObjectValues(values);
+        anim.setEvaluator(evaluator);
+        return anim;
+    }
+
+    public void setIntValues(int... values) {
+        if (values == null || values.length == 0) {
+            return;
+        }
+        if (mValues == null || mValues.length == 0) {
+            setValues(PropertyValuesHolder.ofInt("", values));
+        } else {
+            PropertyValuesHolder valuesHolder = mValues[0];
+            valuesHolder.setIntValues(values);
+        }
+        mInitialized = false;
+    }
+
+    public void setFloatValues(float... values) {
+        if (values == null || values.length == 0) {
+            return;
+        }
+        if (mValues == null || mValues.length == 0) {
+            setValues(PropertyValuesHolder.ofFloat("", values));
+        } else {
+            PropertyValuesHolder valuesHolder = mValues[0];
+            valuesHolder.setFloatValues(values);
+        }
+        mInitialized = false;
+    }
+
+    public void setObjectValues(Object... values) {
+        if (values == null || values.length == 0) {
+            return;
+        }
+        if (mValues == null || mValues.length == 0) {
+            setValues(PropertyValuesHolder.ofObject("", null, values));
+        } else {
+            PropertyValuesHolder valuesHolder = mValues[0];
+            valuesHolder.setObjectValues(values);
+        }
+        mInitialized = false;
+    }
+
+    public void setValues(PropertyValuesHolder... values) {
+        int numValues = values.length;
+        mValues = values;
+        mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
+        for (PropertyValuesHolder valuesHolder : values) {
+            mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);
+        }
+        mInitialized = false;
+    }
+
+    public PropertyValuesHolder[] getValues() {
+        return mValues;
+    }
+
+    void initAnimation() {
+        if (!mInitialized) {
+            int numValues = mValues.length;
+            for (PropertyValuesHolder mValue : mValues) {
+                mValue.init();
+            }
+            mInitialized = true;
+        }
+    }
+
+    public ValueAnimator setDuration(long duration) {
+        if (duration < 0) {
+            throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
+        }
+        mUnscaledDuration = duration;
+        mDuration = (long)(duration * sDurationScale);
+        return this;
+    }
+
+    public long getDuration() {
+        return mUnscaledDuration;
+    }
+
+    public void setCurrentPlayTime(long playTime) {
+        initAnimation();
+        long currentTime = AnimationUtils.currentAnimationTimeMillis();
+        if (mPlayingState != RUNNING) {
+            mSeekTime = playTime;
+            mPlayingState = SEEKED;
+        }
+        mStartTime = currentTime - playTime;
+        doAnimationFrame(currentTime);
+    }
+
+    public long getCurrentPlayTime() {
+        if (!mInitialized || mPlayingState == STOPPED) {
+            return 0;
+        }
+        return AnimationUtils.currentAnimationTimeMillis() - mStartTime;
+    }
+
+    @SuppressWarnings("unchecked")
+    protected static class AnimationHandler implements Runnable {
+
+        protected final ArrayList<ValueAnimator> mAnimations = new ArrayList<ValueAnimator>();
+        private final ArrayList<ValueAnimator> mTmpAnimations = new ArrayList<ValueAnimator>();
+        protected final ArrayList<ValueAnimator> mPendingAnimations = new ArrayList<ValueAnimator>();
+        protected final ArrayList<ValueAnimator> mDelayedAnims = new ArrayList<ValueAnimator>();
+        private final ArrayList<ValueAnimator> mEndingAnims = new ArrayList<ValueAnimator>();
+        private final ArrayList<ValueAnimator> mReadyAnims = new ArrayList<ValueAnimator>();
+
+        private boolean mAnimationScheduled;
+
+        public void start() {
+            scheduleAnimation();
+        }
+
+        private void doAnimationFrame(long frameTime) {
+            while (mPendingAnimations.size() > 0) {
+                ArrayList<ValueAnimator> pendingCopy = (ArrayList<ValueAnimator>) mPendingAnimations.clone();
+                mPendingAnimations.clear();
+                int count = pendingCopy.size();
+                for (ValueAnimator anim : pendingCopy) {
+                    if (anim.mStartDelay == 0) {
+                        anim.startAnimation(this);
+                    } else {
+                        mDelayedAnims.add(anim);
+                    }
+                }
+            }
+
+            int numDelayedAnims = mDelayedAnims.size();
+            for (ValueAnimator anim : mDelayedAnims) {
+                if (anim.delayedAnimationFrame(frameTime)) {
+                    mReadyAnims.add(anim);
+                }
+            }
+            int numReadyAnims = mReadyAnims.size();
+            if (numReadyAnims > 0) {
+                for (ValueAnimator anim : mReadyAnims) {
+                    anim.startAnimation(this);
+                    anim.mRunning = true;
+                    mDelayedAnims.remove(anim);
+                }
+                mReadyAnims.clear();
+            }
+
+            int numAnims = mAnimations.size();
+            for (ValueAnimator mAnimation : mAnimations) {
+                mTmpAnimations.add(mAnimation);
+            }
+            for (int i = 0; i < numAnims; ++i) {
+                ValueAnimator anim = mTmpAnimations.get(i);
+                if (mAnimations.contains(anim) && anim.doAnimationFrame(frameTime)) {
+                    mEndingAnims.add(anim);
+                }
+            }
+            mTmpAnimations.clear();
+            if (mEndingAnims.size() > 0) {
+                for (ValueAnimator mEndingAnim : mEndingAnims) {
+                    mEndingAnim.endAnimation(this);
+                }
+                mEndingAnims.clear();
+            }
+
+            if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) {
+                scheduleAnimation();
+            }
+        }
+
+        @Override
+        public void run() {
+            mAnimationScheduled = false;
+            doAnimationFrame(System.nanoTime() / 1000000);
+        }
+
+        private void scheduleAnimation() {
+            if (!mAnimationScheduled) {
+                AndroidUtilities.runOnUIThread(this);
+                mAnimationScheduled = true;
+            }
+        }
+    }
+
+    public long getStartDelay() {
+        return mUnscaledStartDelay;
+    }
+
+    public void setStartDelay(long startDelay) {
+        this.mStartDelay = (long)(startDelay * sDurationScale);
+        mUnscaledStartDelay = startDelay;
+    }
+
+    public Object getAnimatedValue() {
+        if (mValues != null && mValues.length > 0) {
+            return mValues[0].getAnimatedValue();
+        }
+        return null;
+    }
+
+    public Object getAnimatedValue(String propertyName) {
+        PropertyValuesHolder valuesHolder = mValuesMap.get(propertyName);
+        if (valuesHolder != null) {
+            return valuesHolder.getAnimatedValue();
+        } else {
+            return null;
+        }
+    }
+
+    public void setRepeatCount(int value) {
+        mRepeatCount = value;
+    }
+
+    public int getRepeatCount() {
+        return mRepeatCount;
+    }
+
+    public void setRepeatMode(int value) {
+        mRepeatMode = value;
+    }
+
+    public int getRepeatMode() {
+        return mRepeatMode;
+    }
+
+    public void addUpdateListener(AnimatorUpdateListener listener) {
+        if (mUpdateListeners == null) {
+            mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
+        }
+        mUpdateListeners.add(listener);
+    }
+
+    public void removeAllUpdateListeners() {
+        if (mUpdateListeners == null) {
+            return;
+        }
+        mUpdateListeners.clear();
+        mUpdateListeners = null;
+    }
+
+    public void removeUpdateListener(AnimatorUpdateListener listener) {
+        if (mUpdateListeners == null) {
+            return;
+        }
+        mUpdateListeners.remove(listener);
+        if (mUpdateListeners.size() == 0) {
+            mUpdateListeners = null;
+        }
+    }
+
+    @Override
+    public void setInterpolator(Interpolator value) {
+        if (value != null) {
+            mInterpolator = value;
+        } else {
+            mInterpolator = new LinearInterpolator();
+        }
+    }
+
+    @Override
+    public Interpolator getInterpolator() {
+        return mInterpolator;
+    }
+
+    public void setEvaluator(TypeEvaluator value) {
+        if (value != null && mValues != null && mValues.length > 0) {
+            mValues[0].setEvaluator(value);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private void notifyStartListeners() {
+        if (mListeners != null && !mStartListenersCalled) {
+            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
+            int numListeners = tmpListeners.size();
+            for (AnimatorListener tmpListener : tmpListeners) {
+                tmpListener.onAnimationStart(this);
+            }
+        }
+        mStartListenersCalled = true;
+    }
+
+    private void start(boolean playBackwards) {
+        if (Looper.myLooper() == null) {
+            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
+        }
+        mPlayingBackwards = playBackwards;
+        mCurrentIteration = 0;
+        mPlayingState = STOPPED;
+        mStarted = true;
+        mStartedDelay = false;
+        mPaused = false;
+        AnimationHandler animationHandler = getOrCreateAnimationHandler();
+        animationHandler.mPendingAnimations.add(this);
+        if (mStartDelay == 0) {
+            setCurrentPlayTime(0);
+            mPlayingState = STOPPED;
+            mRunning = true;
+            notifyStartListeners();
+        }
+        animationHandler.start();
+    }
+
+    @Override
+    public void start() {
+        start(false);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void cancel() {
+        AnimationHandler handler = getOrCreateAnimationHandler();
+        if (mPlayingState != STOPPED || handler.mPendingAnimations.contains(this) || handler.mDelayedAnims.contains(this)) {
+            if ((mStarted || mRunning) && mListeners != null) {
+                if (!mRunning) {
+                    notifyStartListeners();
+                }
+                ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
+                for (AnimatorListener listener : tmpListeners) {
+                    listener.onAnimationCancel(this);
+                }
+            }
+            endAnimation(handler);
+        }
+    }
+
+    @Override
+    public void end() {
+        AnimationHandler handler = getOrCreateAnimationHandler();
+        if (!handler.mAnimations.contains(this) && !handler.mPendingAnimations.contains(this)) {
+            mStartedDelay = false;
+            startAnimation(handler);
+            mStarted = true;
+        } else if (!mInitialized) {
+            initAnimation();
+        }
+        animateValue(mPlayingBackwards ? 0f : 1f);
+        endAnimation(handler);
+    }
+
+    @Override
+    public void resume() {
+        if (mPaused) {
+            mResumed = true;
+        }
+        super.resume();
+    }
+
+    @Override
+    public void pause() {
+        boolean previouslyPaused = mPaused;
+        super.pause();
+        if (!previouslyPaused && mPaused) {
+            mPauseTime = -1;
+            mResumed = false;
+        }
+    }
+
+    @Override
+    public boolean isRunning() {
+        return (mPlayingState == RUNNING || mRunning);
+    }
+
+    @Override
+    public boolean isStarted() {
+        return mStarted;
+    }
+
+    public void reverse() {
+        mPlayingBackwards = !mPlayingBackwards;
+        if (mPlayingState == RUNNING) {
+            long currentTime = AnimationUtils.currentAnimationTimeMillis();
+            long currentPlayTime = currentTime - mStartTime;
+            long timeLeft = mDuration - currentPlayTime;
+            mStartTime = currentTime - timeLeft;
+        } else if (mStarted) {
+            end();
+        } else {
+            start(true);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private void endAnimation(AnimationHandler handler) {
+        handler.mAnimations.remove(this);
+        handler.mPendingAnimations.remove(this);
+        handler.mDelayedAnims.remove(this);
+        mPlayingState = STOPPED;
+        mPaused = false;
+        if ((mStarted || mRunning) && mListeners != null) {
+            if (!mRunning) {
+                notifyStartListeners();
+             }
+            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
+            int numListeners = tmpListeners.size();
+            for (AnimatorListener tmpListener : tmpListeners) {
+                tmpListener.onAnimationEnd(this);
+            }
+        }
+        mRunning = false;
+        mStarted = false;
+        mStartListenersCalled = false;
+        mPlayingBackwards = false;
+    }
+
+    private void startAnimation(AnimationHandler handler) {
+        initAnimation();
+        handler.mAnimations.add(this);
+        if (mStartDelay > 0 && mListeners != null) {
+            notifyStartListeners();
+        }
+    }
+
+    private boolean delayedAnimationFrame(long currentTime) {
+        if (!mStartedDelay) {
+            mStartedDelay = true;
+            mDelayStartTime = currentTime;
+        } else {
+            if (mPaused) {
+                if (mPauseTime < 0) {
+                    mPauseTime = currentTime;
+                }
+                return false;
+            } else if (mResumed) {
+                mResumed = false;
+                if (mPauseTime > 0) {
+                    mDelayStartTime += (currentTime - mPauseTime);
+                }
+            }
+            long deltaTime = currentTime - mDelayStartTime;
+            if (deltaTime > mStartDelay) {
+                mStartTime = currentTime - (deltaTime - mStartDelay);
+                mPlayingState = RUNNING;
+                return true;
+            }
+        }
+        return false;
+    }
+
+    boolean animationFrame(long currentTime) {
+        boolean done = false;
+        switch (mPlayingState) {
+        case RUNNING:
+        case SEEKED:
+            float fraction = mDuration > 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;
+            if (fraction >= 1f) {
+                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
+                    if (mListeners != null) {
+                        int numListeners = mListeners.size();
+                        for (AnimatorListener mListener : mListeners) {
+                            mListener.onAnimationRepeat(this);
+                        }
+                    }
+                    if (mRepeatMode == REVERSE) {
+                        mPlayingBackwards = !mPlayingBackwards;
+                    }
+                    mCurrentIteration += (int)fraction;
+                    fraction = fraction % 1f;
+                    mStartTime += mDuration;
+                } else {
+                    done = true;
+                    fraction = Math.min(fraction, 1.0f);
+                }
+            }
+            if (mPlayingBackwards) {
+                fraction = 1f - fraction;
+            }
+            animateValue(fraction);
+            break;
+        }
+
+        return done;
+    }
+
+    final boolean doAnimationFrame(long frameTime) {
+        if (mPlayingState == STOPPED) {
+            mPlayingState = RUNNING;
+            if (mSeekTime < 0) {
+                mStartTime = frameTime;
+            } else {
+                mStartTime = frameTime - mSeekTime;
+                mSeekTime = -1;
+            }
+        }
+        if (mPaused) {
+            if (mPauseTime < 0) {
+                mPauseTime = frameTime;
+            }
+            return false;
+        } else if (mResumed) {
+            mResumed = false;
+            if (mPauseTime > 0) {
+                mStartTime += (frameTime - mPauseTime);
+            }
+        }
+        final long currentTime = Math.max(frameTime, mStartTime);
+        return animationFrame(currentTime);
+    }
+
+    public float getAnimatedFraction() {
+        return mCurrentFraction;
+    }
+
+    void animateValue(float fraction) {
+        fraction = mInterpolator.getInterpolation(fraction);
+        mCurrentFraction = fraction;
+        int numValues = mValues.length;
+        for (PropertyValuesHolder mValue : mValues) {
+            mValue.calculateValue(fraction);
+        }
+        if (mUpdateListeners != null) {
+            int numListeners = mUpdateListeners.size();
+            for (AnimatorUpdateListener mUpdateListener : mUpdateListeners) {
+                mUpdateListener.onAnimationUpdate(this);
+            }
+        }
+    }
+
+    @Override
+    public ValueAnimator clone() {
+        final ValueAnimator anim = (ValueAnimator) super.clone();
+        if (mUpdateListeners != null) {
+            ArrayList<AnimatorUpdateListener> oldListeners = mUpdateListeners;
+            anim.mUpdateListeners = new ArrayList<AnimatorUpdateListener>();
+            int numListeners = oldListeners.size();
+            for (AnimatorUpdateListener oldListener : oldListeners) {
+                anim.mUpdateListeners.add(oldListener);
+            }
+        }
+        anim.mSeekTime = -1;
+        anim.mPlayingBackwards = false;
+        anim.mCurrentIteration = 0;
+        anim.mInitialized = false;
+        anim.mPlayingState = STOPPED;
+        anim.mStartedDelay = false;
+        PropertyValuesHolder[] oldValues = mValues;
+        if (oldValues != null) {
+            int numValues = oldValues.length;
+            anim.mValues = new PropertyValuesHolder[numValues];
+            anim.mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
+            for (int i = 0; i < numValues; ++i) {
+                PropertyValuesHolder newValuesHolder = oldValues[i].clone();
+                anim.mValues[i] = newValuesHolder;
+                anim.mValuesMap.put(newValuesHolder.getPropertyName(), newValuesHolder);
+            }
+        }
+        return anim;
+    }
+
+    public interface AnimatorUpdateListener {
+        void onAnimationUpdate(ValueAnimator animation);
+    }
+
+    public static int getCurrentAnimationsCount() {
+        AnimationHandler handler = sAnimationHandler.get();
+        return handler != null ? handler.mAnimations.size() : 0;
+    }
+
+    public static void clearAllAnimations() {
+        AnimationHandler handler = sAnimationHandler.get();
+        if (handler != null) {
+            handler.mAnimations.clear();
+            handler.mPendingAnimations.clear();
+            handler.mDelayedAnims.clear();
+        }
+    }
+
+    private static AnimationHandler getOrCreateAnimationHandler() {
+        AnimationHandler handler = sAnimationHandler.get();
+        if (handler == null) {
+            handler = new AnimationHandler();
+            sAnimationHandler.set(handler);
+        }
+        return handler;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/Animation/View10.java b/TMessagesProj/src/main/java/org/telegram/android/Animation/View10.java
new file mode 100644
index 000000000..2cd59cb54
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/Animation/View10.java
@@ -0,0 +1,349 @@
+/*
+ Copyright 2012 Jake Wharton
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+ */
+
+package org.telegram.android.Animation;
+
+import android.graphics.Camera;
+import android.graphics.Matrix;
+import android.graphics.RectF;
+import android.os.Build;
+import android.view.View;
+import android.view.animation.Animation;
+import android.view.animation.Transformation;
+
+import java.lang.ref.WeakReference;
+import java.util.WeakHashMap;
+
+public class View10 extends Animation {
+
+    public static boolean NEED_PROXY = Build.VERSION.SDK_INT < 11;
+
+    private static final WeakHashMap<View, View10> PROXIES = new WeakHashMap<>();
+
+    public static View10 wrap(View view) {
+        View10 proxy = PROXIES.get(view);
+        Animation animation = view.getAnimation();
+        if (proxy == null || proxy != animation && animation != null) {
+            proxy = new View10(view);
+            PROXIES.put(view, proxy);
+        } else if (animation == null) {
+            view.setAnimation(proxy);
+        }
+        return proxy;
+    }
+
+    private final WeakReference<View> mView;
+    private final Camera mCamera = new Camera();
+    private boolean mHasPivot;
+
+    private float mAlpha = 1;
+    private float mPivotX;
+    private float mPivotY;
+    private float mRotationX;
+    private float mRotationY;
+    private float mRotationZ;
+    private float mScaleX = 1;
+    private float mScaleY = 1;
+    private float mTranslationX;
+    private float mTranslationY;
+
+    private final RectF mBefore = new RectF();
+    private final RectF mAfter = new RectF();
+    private final Matrix mTempMatrix = new Matrix();
+
+    private View10(View view) {
+        setDuration(0);
+        setFillAfter(true);
+        view.setAnimation(this);
+        mView = new WeakReference<>(view);
+    }
+
+    public float getAlpha() {
+        return mAlpha;
+    }
+
+    public void setAlpha(float alpha) {
+        if (mAlpha != alpha) {
+            mAlpha = alpha;
+            View view = mView.get();
+            if (view != null) {
+                view.invalidate();
+            }
+        }
+    }
+
+    public float getPivotX() {
+        return mPivotX;
+    }
+
+    public void setPivotX(float pivotX) {
+        if (!mHasPivot || mPivotX != pivotX) {
+            prepareForUpdate();
+            mHasPivot = true;
+            mPivotX = pivotX;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public float getPivotY() {
+        return mPivotY;
+    }
+
+    public void setPivotY(float pivotY) {
+        if (!mHasPivot || mPivotY != pivotY) {
+            prepareForUpdate();
+            mHasPivot = true;
+            mPivotY = pivotY;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public float getRotation() {
+        return mRotationZ;
+    }
+
+    public void setRotation(float rotation) {
+        if (mRotationZ != rotation) {
+            prepareForUpdate();
+            mRotationZ = rotation;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public float getRotationX() {
+        return mRotationX;
+    }
+
+    public void setRotationX(float rotationX) {
+        if (mRotationX != rotationX) {
+            prepareForUpdate();
+            mRotationX = rotationX;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public float getRotationY() {
+        return mRotationY;
+    }
+
+    public void setRotationY(float rotationY) {
+        if (mRotationY != rotationY) {
+            prepareForUpdate();
+            mRotationY = rotationY;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public float getScaleX() {
+        return mScaleX;
+    }
+
+    public void setScaleX(float scaleX) {
+        if (mScaleX != scaleX) {
+            prepareForUpdate();
+            mScaleX = scaleX;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public float getScaleY() {
+        return mScaleY;
+    }
+
+    public void setScaleY(float scaleY) {
+        if (mScaleY != scaleY) {
+            prepareForUpdate();
+            mScaleY = scaleY;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public int getScrollX() {
+        View view = mView.get();
+        if (view == null) {
+            return 0;
+        }
+        return view.getScrollX();
+    }
+
+    public void setScrollX(int value) {
+        View view = mView.get();
+        if (view != null) {
+            view.scrollTo(value, view.getScrollY());
+        }
+    }
+
+    public int getScrollY() {
+        View view = mView.get();
+        if (view == null) {
+            return 0;
+        }
+        return view.getScrollY();
+    }
+
+    public void setScrollY(int value) {
+        View view = mView.get();
+        if (view != null) {
+            view.scrollTo(view.getScrollX(), value);
+        }
+    }
+
+    public float getTranslationX() {
+        return mTranslationX;
+    }
+
+    public void setTranslationX(float translationX) {
+        if (mTranslationX != translationX) {
+            prepareForUpdate();
+            mTranslationX = translationX;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public float getTranslationY() {
+        return mTranslationY;
+    }
+
+    public void setTranslationY(float translationY) {
+        if (mTranslationY != translationY) {
+            prepareForUpdate();
+            mTranslationY = translationY;
+            invalidateAfterUpdate();
+        }
+    }
+
+    public float getX() {
+        View view = mView.get();
+        if (view == null) {
+            return 0;
+        }
+        return view.getLeft() + mTranslationX;
+    }
+
+    public void setX(float x) {
+        View view = mView.get();
+        if (view != null) {
+            setTranslationX(x - view.getLeft());
+        }
+    }
+
+    public float getY() {
+        View view = mView.get();
+        if (view == null) {
+            return 0;
+        }
+        return view.getTop() + mTranslationY;
+    }
+
+    public void setY(float y) {
+        View view = mView.get();
+        if (view != null) {
+            setTranslationY(y - view.getTop());
+        }
+    }
+
+    private void prepareForUpdate() {
+        View view = mView.get();
+        if (view != null) {
+            computeRect(mBefore, view);
+        }
+    }
+
+    private void invalidateAfterUpdate() {
+        View view = mView.get();
+        if (view == null || view.getParent() == null) {
+            return;
+        }
+
+        final RectF after = mAfter;
+        computeRect(after, view);
+        after.union(mBefore);
+
+        ((View) view.getParent()).invalidate(
+                (int) Math.floor(after.left),
+                (int) Math.floor(after.top),
+                (int) Math.ceil(after.right),
+                (int) Math.ceil(after.bottom));
+    }
+
+    private void computeRect(final RectF r, View view) {
+        final float w = view.getWidth();
+        final float h = view.getHeight();
+
+        r.set(0, 0, w, h);
+
+        final Matrix m = mTempMatrix;
+        m.reset();
+        transformMatrix(m, view);
+        mTempMatrix.mapRect(r);
+
+        r.offset(view.getLeft(), view.getTop());
+
+        if (r.right < r.left) {
+            final float f = r.right;
+            r.right = r.left;
+            r.left = f;
+        }
+        if (r.bottom < r.top) {
+            final float f = r.top;
+            r.top = r.bottom;
+            r.bottom = f;
+        }
+    }
+
+    private void transformMatrix(Matrix m, View view) {
+        final float w = view.getWidth();
+        final float h = view.getHeight();
+        final boolean hasPivot = mHasPivot;
+        final float pX = hasPivot ? mPivotX : w / 2f;
+        final float pY = hasPivot ? mPivotY : h / 2f;
+
+        final float rX = mRotationX;
+        final float rY = mRotationY;
+        final float rZ = mRotationZ;
+        if ((rX != 0) || (rY != 0) || (rZ != 0)) {
+            final Camera camera = mCamera;
+            camera.save();
+            camera.rotateX(rX);
+            camera.rotateY(rY);
+            camera.rotateZ(-rZ);
+            camera.getMatrix(m);
+            camera.restore();
+            m.preTranslate(-pX, -pY);
+            m.postTranslate(pX, pY);
+        }
+
+        final float sX = mScaleX;
+        final float sY = mScaleY;
+        if ((sX != 1.0f) || (sY != 1.0f)) {
+            m.postScale(sX, sY);
+            final float sPX = -(pX / w) * ((sX * w) - w);
+            final float sPY = -(pY / h) * ((sY * h) - h);
+            m.postTranslate(sPX, sPY);
+        }
+
+        m.postTranslate(mTranslationX, mTranslationY);
+    }
+
+    @Override
+    protected void applyTransformation(float interpolatedTime, Transformation t) {
+        View view = mView.get();
+        if (view != null) {
+            t.setAlpha(mAlpha);
+            transformMatrix(t.getMatrix(), view);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/AnimatorListenerAdapterProxy.java b/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/AnimatorListenerAdapterProxy.java
new file mode 100644
index 000000000..4825db9ea
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/AnimatorListenerAdapterProxy.java
@@ -0,0 +1,112 @@
+/*
+ * This is the source code of Telegram for Android v. 1.7.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.android.AnimationCompat;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+
+import org.telegram.android.Animation.Animator10;
+import org.telegram.android.Animation.AnimatorListenerAdapter10;
+import org.telegram.android.Animation.View10;
+
+public class AnimatorListenerAdapterProxy {
+    protected Object animatorListenerAdapter;
+
+    public AnimatorListenerAdapterProxy() {
+        if (View10.NEED_PROXY) {
+            animatorListenerAdapter = new AnimatorListenerAdapter10() {
+                @Override
+                public void onAnimationCancel(Animator10 animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationCancel(animation);
+                }
+
+                @Override
+                public void onAnimationEnd(Animator10 animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationEnd(animation);
+                }
+
+                @Override
+                public void onAnimationRepeat(Animator10 animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationRepeat(animation);
+                }
+
+                @Override
+                public void onAnimationStart(Animator10 animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationStart(animation);
+                }
+
+                @Override
+                public void onAnimationPause(Animator10 animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationPause(animation);
+                }
+
+                @Override
+                public void onAnimationResume(Animator10 animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationResume(animation);
+                }
+            };
+        } else {
+            animatorListenerAdapter = new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationCancel(Animator animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationCancel(animation);
+                }
+
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationEnd(animation);
+                }
+
+                @Override
+                public void onAnimationRepeat(Animator animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationRepeat(animation);
+                }
+
+                @Override
+                public void onAnimationStart(Animator animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationStart(animation);
+                }
+
+                @Override
+                public void onAnimationPause(Animator animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationPause(animation);
+                }
+
+                @Override
+                public void onAnimationResume(Animator animation) {
+                    AnimatorListenerAdapterProxy.this.onAnimationResume(animation);
+                }
+            };
+        }
+    }
+
+    public void onAnimationCancel(Object animation) {
+
+    }
+
+    public void onAnimationEnd(Object animation) {
+
+    }
+
+    public void onAnimationRepeat(Object animation) {
+
+    }
+
+    public void onAnimationStart(Object animation) {
+
+    }
+
+    public void onAnimationPause(Object animation) {
+
+    }
+
+    public void onAnimationResume(Object animation) {
+
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/AnimatorSetProxy.java b/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/AnimatorSetProxy.java
new file mode 100644
index 000000000..18c6b12da
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/AnimatorSetProxy.java
@@ -0,0 +1,128 @@
+/*
+ * This is the source code of Telegram for Android v. 1.7.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.android.AnimationCompat;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.AnimatorSet;
+import android.view.animation.Interpolator;
+
+import org.telegram.android.Animation.Animator10;
+import org.telegram.android.Animation.AnimatorListenerAdapter10;
+import org.telegram.android.Animation.AnimatorSet10;
+import org.telegram.android.Animation.View10;
+
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+
+public class AnimatorSetProxy {
+
+    private Object animatorSet;
+
+    public static <T, U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
+        return copyOfRange(original, 0, newLength, newType);
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T, U> T[] copyOfRange(U[] original, int start, int end, Class<? extends T[]> newType) {
+        if (start > end) {
+            throw new IllegalArgumentException();
+        }
+        int originalLength = original.length;
+        if (start < 0 || start > originalLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        int resultLength = end - start;
+        int copyLength = Math.min(resultLength, originalLength - start);
+        T[] result = (T[]) Array.newInstance(newType.getComponentType(), resultLength);
+        System.arraycopy(original, start, result, 0, copyLength);
+        return result;
+    }
+
+    public AnimatorSetProxy() {
+        if (View10.NEED_PROXY) {
+            animatorSet = new AnimatorSet10();
+        } else {
+            animatorSet = new AnimatorSet();
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public void playTogether(Object... items) {
+        if (View10.NEED_PROXY) {
+            Animator10[] animators = copyOf(items, items.length, Animator10[].class);
+            ((AnimatorSet10) animatorSet).playTogether(animators);
+        } else {
+            Animator[] animators = copyOf(items, items.length, Animator[].class);
+            ((AnimatorSet) animatorSet).playTogether(animators);
+        }
+    }
+
+    public void playTogether(ArrayList<Object> items) {
+        if (View10.NEED_PROXY) {
+            ArrayList<Animator10> animators = new ArrayList<Animator10>();
+            for (Object obj : items) {
+                animators.add((Animator10)obj);
+            }
+            ((AnimatorSet10) animatorSet).playTogether(animators);
+        } else {
+            ArrayList<Animator> animators = new ArrayList<Animator>();
+            for (Object obj : items) {
+                animators.add((Animator)obj);
+            }
+            ((AnimatorSet) animatorSet).playTogether(animators);
+        }
+    }
+
+    public AnimatorSetProxy setDuration(long duration) {
+        if (View10.NEED_PROXY) {
+            ((AnimatorSet10) animatorSet).setDuration(duration);
+        } else {
+            ((AnimatorSet) animatorSet).setDuration(duration);
+        }
+        return this;
+    }
+
+    public void start() {
+        if (View10.NEED_PROXY) {
+            ((AnimatorSet10) animatorSet).start();
+        } else {
+            ((AnimatorSet) animatorSet).start();
+        }
+    }
+
+    public void cancel() {
+        if (View10.NEED_PROXY) {
+            ((AnimatorSet10) animatorSet).cancel();
+        } else {
+            ((AnimatorSet) animatorSet).cancel();
+        }
+    }
+
+    public void addListener(AnimatorListenerAdapterProxy listener) {
+        if (View10.NEED_PROXY) {
+            ((AnimatorSet10) animatorSet).addListener((AnimatorListenerAdapter10) listener.animatorListenerAdapter);
+        } else {
+            ((AnimatorSet) animatorSet).addListener((AnimatorListenerAdapter) listener.animatorListenerAdapter);
+        }
+    }
+
+    public void setInterpolator(Interpolator interpolator) {
+        if (View10.NEED_PROXY) {
+            ((AnimatorSet10) animatorSet).setInterpolator(interpolator);
+        } else {
+            ((AnimatorSet) animatorSet).setInterpolator(interpolator);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return animatorSet == o;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/ObjectAnimatorProxy.java b/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/ObjectAnimatorProxy.java
new file mode 100644
index 000000000..3210bbff9
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/ObjectAnimatorProxy.java
@@ -0,0 +1,129 @@
+/*
+ * This is the source code of Telegram for Android v. 1.7.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.android.AnimationCompat;
+
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ObjectAnimator;
+import android.view.animation.Interpolator;
+
+import org.telegram.android.Animation.AnimatorListenerAdapter10;
+import org.telegram.android.Animation.ObjectAnimator10;
+import org.telegram.android.Animation.View10;
+
+public class ObjectAnimatorProxy {
+
+    private Object objectAnimator;
+
+    public ObjectAnimatorProxy(Object animator) {
+        objectAnimator = animator;
+    }
+
+    public static Object ofFloat(Object target, String propertyName, float... values) {
+        if (View10.NEED_PROXY) {
+            return ObjectAnimator10.ofFloat(target, propertyName, values);
+        } else {
+            return ObjectAnimator.ofFloat(target, propertyName, values);
+        }
+    }
+
+    public static Object ofInt(Object target, String propertyName, int... values) {
+        if (View10.NEED_PROXY) {
+            return ObjectAnimator10.ofInt(target, propertyName, values);
+        } else {
+            return ObjectAnimator.ofInt(target, propertyName, values);
+        }
+    }
+
+    public static ObjectAnimatorProxy ofFloatProxy(Object target, String propertyName, float... values) {
+        if (View10.NEED_PROXY) {
+            return new ObjectAnimatorProxy(ObjectAnimator10.ofFloat(target, propertyName, values));
+        } else {
+            return new ObjectAnimatorProxy(ObjectAnimator.ofFloat(target, propertyName, values));
+        }
+    }
+
+    public static ObjectAnimatorProxy ofIntProxy(Object target, String propertyName, int... values) {
+        if (View10.NEED_PROXY) {
+            return new ObjectAnimatorProxy(ObjectAnimator10.ofInt(target, propertyName, values));
+        } else {
+            return new ObjectAnimatorProxy(ObjectAnimator.ofInt(target, propertyName, values));
+        }
+    }
+
+    public ObjectAnimatorProxy setDuration(long duration) {
+        if (View10.NEED_PROXY) {
+            ((ObjectAnimator10) objectAnimator).setDuration(duration);
+        } else {
+            ((ObjectAnimator) objectAnimator).setDuration(duration);
+        }
+        return this;
+    }
+
+    public void setInterpolator(Interpolator value) {
+        if (View10.NEED_PROXY) {
+            ((ObjectAnimator10) objectAnimator).setInterpolator(value);
+        } else {
+            ((ObjectAnimator) objectAnimator).setInterpolator(value);
+        }
+    }
+
+    public void start() {
+        if (View10.NEED_PROXY) {
+            ((ObjectAnimator10) objectAnimator).start();
+        } else {
+            ((ObjectAnimator) objectAnimator).start();
+        }
+    }
+
+    public void setAutoCancel(boolean cancel) {
+        if (View10.NEED_PROXY) {
+            ((ObjectAnimator10) objectAnimator).setAutoCancel(cancel);
+        } else {
+            ((ObjectAnimator) objectAnimator).setAutoCancel(cancel);
+        }
+    }
+
+    public boolean isRunning() {
+        if (View10.NEED_PROXY) {
+            return ((ObjectAnimator10) objectAnimator).isRunning();
+        } else {
+            return ((ObjectAnimator) objectAnimator).isRunning();
+        }
+    }
+
+    public void end() {
+        if (View10.NEED_PROXY) {
+            ((ObjectAnimator10) objectAnimator).end();
+        } else {
+            ((ObjectAnimator) objectAnimator).end();
+        }
+    }
+
+    public void cancel() {
+        if (View10.NEED_PROXY) {
+            ((ObjectAnimator10) objectAnimator).cancel();
+        } else {
+            ((ObjectAnimator) objectAnimator).cancel();
+        }
+    }
+
+    public ObjectAnimatorProxy addListener(AnimatorListenerAdapterProxy listener) {
+        if (View10.NEED_PROXY) {
+            ((ObjectAnimator10) objectAnimator).addListener((AnimatorListenerAdapter10) listener.animatorListenerAdapter);
+        } else {
+            ((ObjectAnimator) objectAnimator).addListener((AnimatorListenerAdapter) listener.animatorListenerAdapter);
+        }
+        return this;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return objectAnimator == o;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/ViewProxy.java b/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/ViewProxy.java
new file mode 100644
index 000000000..e8dcf6ce8
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/AnimationCompat/ViewProxy.java
@@ -0,0 +1,248 @@
+/*
+ * This is the source code of Telegram for Android v. 1.7.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.android.AnimationCompat;
+
+import android.view.View;
+
+import org.telegram.android.Animation.View10;
+
+public class ViewProxy {
+
+    public static float getAlpha(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getAlpha();
+        } else {
+            return view.getAlpha();
+        }
+    }
+
+    public static void setAlpha(View view, float alpha) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setAlpha(alpha);
+        } else {
+            view.setAlpha(alpha);
+        }
+    }
+
+    public static float getPivotX(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getPivotX();
+        } else {
+            return view.getPivotX();
+        }
+    }
+
+    public static void setPivotX(View view, float pivotX) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setPivotX(pivotX);
+        } else {
+            view.setPivotX(pivotX);
+        }
+    }
+
+    public static float getPivotY(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getPivotY();
+        } else {
+            return view.getPivotY();
+        }
+    }
+
+    public static void setPivotY(View view, float pivotY) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setPivotY(pivotY);
+        } else {
+            view.setPivotY(pivotY);
+        }
+    }
+
+    public static float getRotation(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getRotation();
+        } else {
+            return view.getRotation();
+        }
+    }
+
+    public static void setRotation(View view, float rotation) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setRotation(rotation);
+        } else {
+            view.setRotation(rotation);
+        }
+    }
+
+    public static float getRotationX(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getRotationX();
+        } else {
+            return view.getRotationX();
+        }
+    }
+
+    public void setRotationX(View view, float rotationX) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setRotationX(rotationX);
+        } else {
+            view.setRotationX(rotationX);
+        }
+    }
+
+    public static float getRotationY(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getRotationY();
+        } else {
+            return view.getRotationY();
+        }
+    }
+
+    public void setRotationY(View view, float rotationY) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setRotationY(rotationY);
+        } else {
+            view.setRotationY(rotationY);
+        }
+    }
+
+    public static float getScaleX(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getScaleX();
+        } else {
+            return view.getScaleX();
+        }
+    }
+
+    public static void setScaleX(View view, float scaleX) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setScaleX(scaleX);
+        } else {
+            view.setScaleX(scaleX);
+        }
+    }
+
+    public static float getScaleY(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getScaleY();
+        } else {
+            return view.getScaleY();
+        }
+    }
+
+    public static void setScaleY(View view, float scaleY) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setScaleY(scaleY);
+        } else {
+            view.setScaleY(scaleY);
+        }
+    }
+
+    public static int getScrollX(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getScrollX();
+        } else {
+            return view.getScrollX();
+        }
+    }
+
+    public static void setScrollX(View view, int value) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setScrollX(value);
+        } else {
+            view.setScrollX(value);
+        }
+    }
+
+    public static int getScrollY(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getScrollY();
+        } else {
+            return view.getScrollY();
+        }
+    }
+
+    public static void setScrollY(View view, int value) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setScrollY(value);
+        } else {
+            view.setScrollY(value);
+        }
+    }
+
+    public static float getTranslationX(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getTranslationX();
+        } else {
+            return view.getTranslationX();
+        }
+    }
+
+    public static void setTranslationX(View view, float translationX) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setTranslationX(translationX);
+        } else {
+            view.setTranslationX(translationX);
+        }
+    }
+
+    public static float getTranslationY(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getTranslationY();
+        } else {
+            return view.getTranslationY();
+        }
+    }
+
+    public static void setTranslationY(View view, float translationY) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setTranslationY(translationY);
+        } else {
+            view.setTranslationY(translationY);
+        }
+    }
+
+    public static float getX(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getX();
+        } else {
+            return view.getX();
+        }
+    }
+
+    public static void setX(View view, float x) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setX(x);
+        } else {
+            view.setX(x);
+        }
+    }
+
+    public static float getY(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view).getY();
+        } else {
+            return view.getY();
+        }
+    }
+
+    public static void setY(View view, float y) {
+        if (View10.NEED_PROXY) {
+            View10.wrap(view).setY(y);
+        } else {
+            view.setY(y);
+        }
+    }
+
+    public static Object wrap(View view) {
+        if (View10.NEED_PROXY) {
+            return View10.wrap(view);
+        } else {
+            return view;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/ModuleContentProvider.java b/TMessagesProj/src/main/java/org/telegram/android/ModuleContentProvider.java
new file mode 100644
index 000000000..9837b8646
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/ModuleContentProvider.java
@@ -0,0 +1,121 @@
+package org.telegram.android;
+
+import android.app.Activity;
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.content.SharedPreferences;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Environment;
+import android.util.Log;
+
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.Utilities;
+
+import java.io.File;
+
+public class ModuleContentProvider extends ContentProvider {
+    private static final String TAG = "ModuleContentProvider";
+
+    private static final String AUTHORITY = "org.telegram.plus.android.provider.content";
+    public static final Uri THEME_URI = Uri.parse("content://" + AUTHORITY + "/theme");
+    public static final Uri GET_NAME = Uri.parse("content://" + AUTHORITY + "/name");
+    public static final Uri SET_NAME = Uri.parse("content://" + AUTHORITY + "/newname");
+
+    private static final UriMatcher sUriMatcher;
+    static {
+        sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+        sUriMatcher.addURI(AUTHORITY, "theme", 1);
+        sUriMatcher.addURI(AUTHORITY, "name", 2);
+    }
+
+    @Override
+    public boolean onCreate() {
+        Log.d(TAG, "onCreate");
+        return true;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String orderBy) {
+        Log.d(TAG, "query with uri: " + uri.toString());
+        return null;
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        if(uri.equals(GET_NAME)){
+            SharedPreferences themePrefs = ApplicationLoader.applicationContext.getSharedPreferences("theme", Activity.MODE_PRIVATE);
+            return themePrefs.getString("themeName","empty");
+        }else{
+            throw new IllegalArgumentException("Unknown URI " + uri);
+        }
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        Log.d(TAG, "insert uri: " + uri.toString());
+        if(uri.toString().contains(SET_NAME.toString())){
+            String sName = uri.toString();
+            sName = sName.substring(sName.lastIndexOf(":")+1, sName.length());
+            SharedPreferences themePrefs = ApplicationLoader.applicationContext.getSharedPreferences("theme", AndroidUtilities.THEME_PREFS_MODE);
+            SharedPreferences.Editor editor = themePrefs.edit();
+            editor.putString("themeName", sName);
+            editor.commit();
+        }else{
+            throw new UnsupportedOperationException();
+        }
+        return uri;
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        //Log.d(TAG, "update uri: " + uri.toString());
+        if(uri.toString().contains(THEME_URI.toString())){
+            String theme = uri.toString();
+            theme = theme.substring(theme.lastIndexOf(":")+1, theme.length());
+            //Log.d(TAG, theme);
+            if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
+                File themeFile = new File(theme);
+                if(themeFile.exists()){
+                    applyTheme(theme);
+                    return 10;
+                }
+                return 20;//theme doesn't exists
+            }
+            return 30;// MEDIA no mounted
+        }else{
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    @Override
+    public int delete(Uri uri, String where, String[] selectionArgs) {
+        //Log.d(TAG, "delete uri: " + uri.toString());
+        throw new UnsupportedOperationException();
+    }
+
+    private void applyTheme(final String xmlFile){
+        String sName = xmlFile.substring(0, xmlFile.lastIndexOf("."));
+        String wName = sName + "_wallpaper.jpg";
+        File wFile = new File(wName);
+        if(wFile.exists()){
+            //Change Stock Background to set Custom Wallpaper
+            SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
+            int selectedBackground = preferences.getInt("selectedBackground", 1000001);
+            if (selectedBackground == 1000001) {
+                //File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper.jpg");
+                //if (!toFile.exists()) {
+                SharedPreferences.Editor editor = preferences.edit();
+                editor.putInt("selectedBackground", 113);
+                editor.putInt("selectedColor", 0);
+                editor.commit();
+                //}
+            }
+        }
+        if(Utilities.loadPrefFromSD(ApplicationLoader.applicationContext, xmlFile) == 4){
+            Utilities.loadWallpaperFromSDPath(ApplicationLoader.applicationContext, wName);
+            AndroidUtilities.needRestart = true;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/query/ReplyMessageQuery.java b/TMessagesProj/src/main/java/org/telegram/android/query/ReplyMessageQuery.java
new file mode 100644
index 000000000..bb01bdd5a
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/query/ReplyMessageQuery.java
@@ -0,0 +1,184 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.android.query;
+
+import android.text.TextUtils;
+
+import org.telegram.SQLite.SQLiteCursor;
+import org.telegram.SQLite.SQLitePreparedStatement;
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.ImageLoader;
+import org.telegram.android.MessageObject;
+import org.telegram.android.MessagesStorage;
+import org.telegram.android.NotificationCenter;
+import org.telegram.messenger.ByteBufferDesc;
+import org.telegram.messenger.ConnectionsManager;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.RPCRequest;
+import org.telegram.messenger.TLObject;
+import org.telegram.messenger.TLRPC;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Locale;
+
+public class ReplyMessageQuery {
+
+    public static void loadReplyMessagesForMessages(final ArrayList<MessageObject> messages, final long dialog_id) {
+        final ArrayList<Integer> replyMessages = new ArrayList<>();
+        final HashMap<Integer, ArrayList<MessageObject>> replyMessageOwners = new HashMap<>();
+        for (MessageObject messageObject : messages) {
+            if (messageObject.getId() > 0 && messageObject.isReply() && messageObject.replyMessageObject == null) {
+                Integer id = messageObject.messageOwner.reply_to_msg_id;
+                ArrayList<MessageObject> messageObjects = replyMessageOwners.get(id);
+                if (messageObjects == null) {
+                    messageObjects = new ArrayList<>();
+                    replyMessageOwners.put(id, messageObjects);
+                }
+                messageObjects.add(messageObject);
+                if (!replyMessages.contains(id)) {
+                    replyMessages.add(id);
+                }
+            }
+        }
+        if (replyMessages.isEmpty()) {
+            return;
+        }
+
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    final ArrayList<TLRPC.Message> result = new ArrayList<>();
+                    final ArrayList<TLRPC.User> users = new ArrayList<>();
+                    ArrayList<Integer> loadedUsers = new ArrayList<>();
+                    ArrayList<Integer> fromUser = new ArrayList<>();
+
+                    SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized(String.format(Locale.US, "SELECT data, mid, date FROM messages WHERE mid IN(%s)", TextUtils.join(",", replyMessages)));
+                    while (cursor.next()) {
+                        ByteBufferDesc data = MessagesStorage.getInstance().getBuffersStorage().getFreeBuffer(cursor.byteArrayLength(0));
+                        if (data != null && cursor.byteBufferValue(0, data.buffer) != 0) {
+                            TLRPC.Message message = TLRPC.Message.TLdeserialize(data, data.readInt32(false), false);
+                            message.id = cursor.intValue(1);
+                            message.date = cursor.intValue(2);
+                            message.dialog_id = dialog_id;
+                            fromUser.add(message.from_id);
+                            if (message.action != null && message.action.user_id != 0) {
+                                fromUser.add(message.action.user_id);
+                            }
+                            if (message.media != null && message.media.user_id != 0) {
+                                fromUser.add(message.media.user_id);
+                            }
+                            if (message.media != null && message.media.audio != null && message.media.audio.user_id != 0) {
+                                fromUser.add(message.media.audio.user_id);
+                            }
+                            if (message.fwd_from_id != 0) {
+                                fromUser.add(message.fwd_from_id);
+                            }
+                            result.add(message);
+                            replyMessages.remove((Integer) message.id);
+                        }
+                        MessagesStorage.getInstance().getBuffersStorage().reuseFreeBuffer(data);
+                    }
+                    cursor.dispose();
+
+                    StringBuilder usersToLoad = new StringBuilder();
+                    for (int uid : fromUser) {
+                        if (!loadedUsers.contains(uid)) {
+                            if (usersToLoad.length() != 0) {
+                                usersToLoad.append(",");
+                            }
+                            usersToLoad.append(uid);
+                            loadedUsers.add(uid);
+                        }
+                    }
+                    if (usersToLoad.length() != 0) {
+                        MessagesStorage.getInstance().getUsersInternal(usersToLoad.toString(), users);
+                    }
+                    broadcastReplyMessages(result, replyMessageOwners, users, dialog_id);
+
+                    if (!replyMessages.isEmpty()) {
+                        TLRPC.TL_messages_getMessages req = new TLRPC.TL_messages_getMessages();
+                        req.id = replyMessages;
+                        ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                            @Override
+                            public void run(TLObject response, TLRPC.TL_error error) {
+                                if (error == null) {
+                                    TLRPC.messages_Messages messagesRes = (TLRPC.messages_Messages) response;
+                                    ImageLoader.saveMessagesThumbs(messagesRes.messages);
+                                    broadcastReplyMessages(messagesRes.messages, replyMessageOwners, messagesRes.users, dialog_id);
+                                    MessagesStorage.getInstance().putUsersAndChats(messagesRes.users, null, true, true);
+                                    saveReplyMessages(replyMessageOwners, messagesRes.messages);
+                                }
+                            }
+                        });
+                    }
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    private static void saveReplyMessages(final HashMap<Integer, ArrayList<MessageObject>> replyMessageOwners, final ArrayList<TLRPC.Message> result) {
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    MessagesStorage.getInstance().getDatabase().beginTransaction();
+                    SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("UPDATE messages SET replydata = ? WHERE mid = ?");
+                    for (TLRPC.Message message : result) {
+                        ArrayList<MessageObject> messageObjects = replyMessageOwners.get(message.id);
+                        if (messageObjects != null) {
+                            ByteBufferDesc data = MessagesStorage.getInstance().getBuffersStorage().getFreeBuffer(message.getObjectSize());
+                            message.serializeToStream(data);
+                            for (MessageObject messageObject : messageObjects) {
+                                state.requery();
+                                state.bindByteBuffer(1, data.buffer);
+                                state.bindInteger(2, messageObject.getId());
+                                state.step();
+                            }
+                            MessagesStorage.getInstance().getBuffersStorage().reuseFreeBuffer(data);
+                        }
+                    }
+                    state.dispose();
+                    MessagesStorage.getInstance().getDatabase().commitTransaction();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    private static void broadcastReplyMessages(final ArrayList<TLRPC.Message> result, final HashMap<Integer, ArrayList<MessageObject>> replyMessageOwners, ArrayList<TLRPC.User> users, final long dialog_id) {
+        final HashMap<Integer, TLRPC.User> usersHashMap = new HashMap<>();
+        for (TLRPC.User user : users) {
+            usersHashMap.put(user.id, user);
+        }
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                boolean changed = false;
+                for (TLRPC.Message message : result) {
+                    ArrayList<MessageObject> arrayList = replyMessageOwners.get(message.id);
+                    if (arrayList != null) {
+                        MessageObject messageObject = new MessageObject(message, usersHashMap, false);
+                        for (MessageObject m : arrayList) {
+                            m.replyMessageObject = messageObject;
+                        }
+                        changed = true;
+                    }
+                }
+                if (changed) {
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.didLoadedReplyMessages, dialog_id);
+                }
+            }
+        });
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/query/StickersQuery.java b/TMessagesProj/src/main/java/org/telegram/android/query/StickersQuery.java
new file mode 100644
index 000000000..6c8c45288
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/query/StickersQuery.java
@@ -0,0 +1,182 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.android.query;
+
+import org.telegram.SQLite.SQLiteCursor;
+import org.telegram.SQLite.SQLitePreparedStatement;
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.MessagesStorage;
+import org.telegram.android.NotificationCenter;
+import org.telegram.messenger.ByteBufferDesc;
+import org.telegram.messenger.ConnectionsManager;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.RPCRequest;
+import org.telegram.messenger.TLObject;
+import org.telegram.messenger.TLRPC;
+import org.telegram.messenger.Utilities;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+public class StickersQuery {
+
+    private static String hash;
+    private static int loadDate;
+    private static ArrayList<TLRPC.Document> stickers = new ArrayList<>();
+    private static HashMap<String, ArrayList<TLRPC.Document>> allStickers = new HashMap<>();
+    private static boolean loadingStickers;
+
+    public static void checkStickers() {
+        if (!loadingStickers && (allStickers.isEmpty() || loadDate < (System.currentTimeMillis() / 1000 - 60 * 60))) {
+            loadStickers(true);
+        }
+    }
+
+    public static ArrayList<TLRPC.Document> getStickers() {
+        return stickers;
+    }
+
+    private static void loadStickers(boolean cache) {
+        if (loadingStickers) {
+            return;
+        }
+        loadingStickers = true;
+        if (cache) {
+            MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+                @Override
+                public void run() {
+                    TLRPC.messages_AllStickers result = null;
+                    int date = 0;
+                    try {
+                        SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT data, date FROM stickers WHERE 1");
+                        ArrayList<TLRPC.User> loadedUsers = new ArrayList<>();
+                        if (cursor.next()) {
+                            ByteBufferDesc data = MessagesStorage.getInstance().getBuffersStorage().getFreeBuffer(cursor.byteArrayLength(0));
+                            if (data != null && cursor.byteBufferValue(0, data.buffer) != 0) {
+                                result = TLRPC.messages_AllStickers.TLdeserialize(data, data.readInt32(false), false);
+                            }
+                            date = cursor.intValue(1);
+                            MessagesStorage.getInstance().getBuffersStorage().reuseFreeBuffer(data);
+                        }
+                        cursor.dispose();
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    processLoadedStickers(result, true, date);
+                }
+            });
+        } else {
+            TLRPC.TL_messages_getAllStickers req = new TLRPC.TL_messages_getAllStickers();
+            req.hash = hash;
+            if (req.hash == null) {
+                req.hash = "";
+            }
+            ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                @Override
+                public void run(final TLObject response, final TLRPC.TL_error error) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            processLoadedStickers((TLRPC.messages_AllStickers) response, false, (int) (System.currentTimeMillis() / 1000));
+                        }
+                    });
+                }
+            });
+        }
+    }
+
+    private static void putStickersToCache(final TLRPC.TL_messages_allStickers stickers) {
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("REPLACE INTO stickers VALUES(?, ?, ?)");
+                    state.requery();
+                    ByteBufferDesc data = MessagesStorage.getInstance().getBuffersStorage().getFreeBuffer(stickers.getObjectSize());
+                    stickers.serializeToStream(data);
+                    state.bindInteger(1, 1);
+                    state.bindByteBuffer(2, data.buffer);
+                    state.bindInteger(3, (int) (System.currentTimeMillis() / 1000));
+                    state.step();
+                    MessagesStorage.getInstance().getBuffersStorage().reuseFreeBuffer(data);
+                    state.dispose();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    private static void processLoadedStickers(final TLRPC.messages_AllStickers res, final boolean cache, final int date) {
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                loadingStickers = false;
+            }
+        });
+        Utilities.stageQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                if ((res == null || date < (int) (System.currentTimeMillis() / 1000 - 60 * 60)) && cache) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            loadStickers(false);
+                        }
+                    });
+                    if (res == null) {
+                        return;
+                    }
+                }
+                if (res instanceof TLRPC.TL_messages_allStickers) {
+                    if (!cache) {
+                        putStickersToCache((TLRPC.TL_messages_allStickers) res);
+                    }
+                    HashMap<Long, TLRPC.Document> documents = new HashMap<>();
+                    for (TLRPC.Document document : res.documents) {
+                        if (document == null) {
+                            continue;
+                        }
+                        documents.put(document.id, document);
+                        if (document.thumb != null && document.thumb.location != null) {
+                            document.thumb.location.ext = "webp";
+                        }
+                    }
+                    final HashMap<String, ArrayList<TLRPC.Document>> result = new HashMap<>();
+                    for (TLRPC.TL_stickerPack stickerPack : res.packs) {
+                        if (stickerPack != null && stickerPack.emoticon != null) {
+                            stickerPack.emoticon = stickerPack.emoticon.replace("\uFE0F", "");
+                            ArrayList<TLRPC.Document> arrayList = result.get(stickerPack.emoticon);
+                            for (Long id : stickerPack.documents) {
+                                TLRPC.Document document = documents.get(id);
+                                if (document != null) {
+                                    if (arrayList == null) {
+                                        arrayList = new ArrayList<>();
+                                        result.put(stickerPack.emoticon, arrayList);
+                                    }
+                                    arrayList.add(document);
+                                }
+                            }
+                        }
+                    }
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            allStickers = result;
+                            stickers = res.documents;
+                            hash = res.hash;
+                            loadDate = date;
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.stickersDidLoaded);
+                        }
+                    });
+                }
+            }
+        });
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/util/SortedList.java b/TMessagesProj/src/main/java/org/telegram/android/support/util/SortedList.java
new file mode 100644
index 000000000..688e032c8
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/util/SortedList.java
@@ -0,0 +1,633 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.support.v7.util;
+
+import java.lang.reflect.Array;
+
+/**
+ * A Sorted list implementation that can keep items in order and also notify for changes in the
+ * list
+ * such that it can be bound to a {@link android.support.v7.widget.RecyclerView.Adapter
+ * RecyclerView.Adapter}.
+ * <p>
+ * It keeps items ordered using the {@link Callback#compare(Object, Object)} method and uses
+ * binary search to retrieve items. If the sorting criteria of your items may change, make sure you
+ * call appropriate methods while editing them to avoid data inconsistencies.
+ * <p>
+ * You can control the order of items and change notifications via the {@link Callback} parameter.
+ */
+@SuppressWarnings("unchecked")
+public class SortedList<T> {
+
+    /**
+     * Used by {@link #indexOf(Object)} when he item cannot be found in the list.
+     */
+    public static final int INVALID_POSITION = -1;
+
+    private static final int MIN_CAPACITY = 10;
+    private static final int CAPACITY_GROWTH = MIN_CAPACITY;
+    private static final int INSERTION = 1;
+    private static final int DELETION = 1 << 1;
+    private static final int LOOKUP = 1 << 2;
+    T[] mData;
+
+    /**
+     * The callback instance that controls the behavior of the SortedList and get notified when
+     * changes happen.
+     */
+    private Callback mCallback;
+
+    private BatchedCallback mBatchedCallback;
+
+    private int mSize;
+    private final Class<T> mTClass;
+
+    /**
+     * Creates a new SortedList of type T.
+     *
+     * @param klass    The class of the contents of the SortedList.
+     * @param callback The callback that controls the behavior of SortedList.
+     */
+    public SortedList(Class<T> klass, Callback<T> callback) {
+        this(klass, callback, MIN_CAPACITY);
+    }
+
+    /**
+     * Creates a new SortedList of type T.
+     *
+     * @param klass           The class of the contents of the SortedList.
+     * @param callback        The callback that controls the behavior of SortedList.
+     * @param initialCapacity The initial capacity to hold items.
+     */
+    public SortedList(Class<T> klass, Callback<T> callback, int initialCapacity) {
+        mTClass = klass;
+        mData = (T[]) Array.newInstance(klass, initialCapacity);
+        mCallback = callback;
+        mSize = 0;
+    }
+
+    /**
+     * The number of items in the list.
+     *
+     * @return The number of items in the list.
+     */
+    public int size() {
+        return mSize;
+    }
+
+    /**
+     * Adds the given item to the list. If this is a new item, SortedList calls
+     * {@link Callback#onInserted(int, int)}.
+     * <p>
+     * If the item already exists in the list and its sorting criteria is not changed, it is
+     * replaced with the existing Item. SortedList uses
+     * {@link Callback#areItemsTheSame(Object, Object)} to check if two items are the same item
+     * and uses {@link Callback#areContentsTheSame(Object, Object)} to decide whether it should
+     * call {@link Callback#onChanged(int, int)} or not. In both cases, it always removes the
+     * reference to the old item and puts the new item into the backing array even if
+     * {@link Callback#areContentsTheSame(Object, Object)} returns false.
+     * <p>
+     * If the sorting criteria of the item is changed, SortedList won't be able to find
+     * its duplicate in the list which will result in having a duplicate of the Item in the list.
+     * If you need to update sorting criteria of an item that already exists in the list,
+     * use {@link #updateItemAt(int, Object)}. You can find the index of the item using
+     * {@link #indexOf(Object)} before you update the object.
+     *
+     * @param item The item to be added into the list.
+     * @return The index of the newly added item.
+     * @see {@link Callback#compare(Object, Object)}
+     * @see {@link Callback#areItemsTheSame(Object, Object)}
+     * @see {@link Callback#areContentsTheSame(Object, Object)}}
+     */
+    public int add(T item) {
+        return add(item, true);
+    }
+
+    /**
+     * Batches adapter updates that happen between calling this method until calling
+     * {@link #endBatchedUpdates()}. For example, if you add multiple items in a loop
+     * and they are placed into consecutive indices, SortedList calls
+     * {@link Callback#onInserted(int, int)} only once with the proper item count. If an event
+     * cannot be merged with the previous event, the previous event is dispatched
+     * to the callback instantly.
+     * <p>
+     * After running your data updates, you <b>must</b> call {@link #endBatchedUpdates()}
+     * which will dispatch any deferred data change event to the current callback.
+     * <p>
+     * A sample implementation may look like this:
+     * <pre>
+     *     mSortedList.beginBatchedUpdates();
+     *     try {
+     *         mSortedList.add(item1)
+     *         mSortedList.add(item2)
+     *         mSortedList.remove(item3)
+     *         ...
+     *     } finally {
+     *         mSortedList.endBatchedUpdates();
+     *     }
+     * </pre>
+     * <p>
+     * Instead of using this method to batch calls, you can use a Callback that extends
+     * {@link BatchedCallback}. In that case, you must make sure that you are manually calling
+     * {@link BatchedCallback#dispatchLastEvent()} right after you complete your data changes.
+     * Failing to do so may create data inconsistencies with the Callback.
+     * <p>
+     * If the current Callback in an instance of {@link BatchedCallback}, calling this method
+     * has no effect.
+     */
+    public void beginBatchedUpdates() {
+        if (mCallback instanceof BatchedCallback) {
+            return;
+        }
+        if (mBatchedCallback == null) {
+            mBatchedCallback = new BatchedCallback(mCallback);
+        }
+        mCallback = mBatchedCallback;
+    }
+
+    /**
+     * Ends the update transaction and dispatches any remaining event to the callback.
+     */
+    public void endBatchedUpdates() {
+        if (mCallback instanceof BatchedCallback) {
+            ((BatchedCallback) mCallback).dispatchLastEvent();
+        }
+        if (mCallback == mBatchedCallback) {
+            mCallback = mBatchedCallback.mWrappedCallback;
+        }
+    }
+
+    private int add(T item, boolean notify) {
+        int index = findIndexOf(item, INSERTION);
+        if (index == INVALID_POSITION) {
+            index = 0;
+        } else if (index < mSize) {
+            T existing = mData[index];
+            if (mCallback.areItemsTheSame(existing, item)) {
+                if (mCallback.areContentsTheSame(existing, item)) {
+                    //no change but still replace the item
+                    mData[index] = item;
+                    return index;
+                } else {
+                    mData[index] = item;
+                    mCallback.onChanged(index, 1);
+                    return index;
+                }
+            }
+        }
+        addToData(index, item);
+        if (notify) {
+            mCallback.onInserted(index, 1);
+        }
+        return index;
+    }
+
+    /**
+     * Removes the provided item from the list and calls {@link Callback#onRemoved(int, int)}.
+     *
+     * @param item The item to be removed from the list.
+     * @return True if item is removed, false if item cannot be found in the list.
+     */
+    public boolean remove(T item) {
+        return remove(item, true);
+    }
+
+    /**
+     * Removes the item at the given index and calls {@link Callback#onRemoved(int, int)}.
+     *
+     * @param index The index of the item to be removed.
+     * @return The removed item.
+     */
+    public T removeItemAt(int index) {
+        T item = get(index);
+        removeItemAtIndex(index, true);
+        return item;
+    }
+
+    private boolean remove(T item, boolean notify) {
+        int index = findIndexOf(item, DELETION);
+        if (index == INVALID_POSITION) {
+            return false;
+        }
+        removeItemAtIndex(index, notify);
+        return true;
+    }
+
+    private void removeItemAtIndex(int index, boolean notify) {
+        System.arraycopy(mData, index + 1, mData, index, mSize - index - 1);
+        mSize--;
+        mData[mSize] = null;
+        if (notify) {
+            mCallback.onRemoved(index, 1);
+        }
+    }
+
+    /**
+     * Updates the item at the given index and calls {@link Callback#onChanged(int, int)} and/or
+     * {@link Callback#onMoved(int, int)} if necessary.
+     * <p>
+     * You can use this method if you need to change an existing Item such that its position in the
+     * list may change.
+     * <p>
+     * If the new object is a different object (<code>get(index) != item</code>) and
+     * {@link Callback#areContentsTheSame(Object, Object)} returns <code>true</code>, SortedList
+     * avoids calling {@link Callback#onChanged(int, int)} otherwise it calls
+     * {@link Callback#onChanged(int, int)}.
+     * <p>
+     * If the new position of the item is different than the provided <code>index</code>,
+     * SortedList
+     * calls {@link Callback#onMoved(int, int)}.
+     *
+     * @param index The index of the item to replace
+     * @param item  The item to replace the item at the given Index.
+     * @see #add(Object)
+     */
+    public void updateItemAt(int index, T item) {
+        final T existing = get(index);
+        // assume changed if the same object is given back
+        boolean contentsChanged = existing == item || !mCallback.areContentsTheSame(existing, item);
+        if (existing != item) {
+            // different items, we can use comparison and may avoid lookup
+            final int cmp = mCallback.compare(existing, item);
+            if (cmp == 0) {
+                mData[index] = item;
+                if (contentsChanged) {
+                    mCallback.onChanged(index, 1);
+                }
+                return;
+            }
+        }
+        if (contentsChanged) {
+            mCallback.onChanged(index, 1);
+        }
+        // TODO this done in 1 pass to avoid shifting twice.
+        removeItemAtIndex(index, false);
+        int newIndex = add(item, false);
+        if (index != newIndex) {
+            mCallback.onMoved(index, newIndex);
+        }
+    }
+
+    /**
+     * This method can be used to recalculate the position of the item at the given index, without
+     * triggering an {@link Callback#onChanged(int, int)} callback.
+     * <p>
+     * If you are editing objects in the list such that their position in the list may change but
+     * you don't want to trigger an onChange animation, you can use this method to re-position it.
+     * If the item changes position, SortedList will call {@link Callback#onMoved(int, int)}
+     * without
+     * calling {@link Callback#onChanged(int, int)}.
+     * <p>
+     * A sample usage may look like:
+     *
+     * <pre>
+     *     final int position = mSortedList.indexOf(item);
+     *     item.incrementPriority(); // assume items are sorted by priority
+     *     mSortedList.recalculatePositionOfItemAt(position);
+     * </pre>
+     * In the example above, because the sorting criteria of the item has been changed,
+     * mSortedList.indexOf(item) will not be able to find the item. This is why the code above
+     * first
+     * gets the position before editing the item, edits it and informs the SortedList that item
+     * should be repositioned.
+     *
+     * @param index The current index of the Item whose position should be re-calculated.
+     * @see #updateItemAt(int, Object)
+     * @see #add(Object)
+     */
+    public void recalculatePositionOfItemAt(int index) {
+        // TODO can be improved
+        final T item = get(index);
+        removeItemAtIndex(index, false);
+        int newIndex = add(item, false);
+        if (index != newIndex) {
+            mCallback.onMoved(index, newIndex);
+        }
+    }
+
+    /**
+     * Returns the item at the given index.
+     *
+     * @param index The index of the item to retrieve.
+     * @return The item at the given index.
+     * @throws java.lang.IndexOutOfBoundsException if provided index is negative or larger than the
+     *                                             size of the list.
+     */
+    public T get(int index) throws IndexOutOfBoundsException {
+        if (index >= mSize || index < 0) {
+            throw new IndexOutOfBoundsException("Asked to get item at " + index + " but size is "
+                    + mSize);
+        }
+        return mData[index];
+    }
+
+    /**
+     * Returns the position of the provided item.
+     *
+     * @param item The item to query for position.
+     * @return The position of the provided item or {@link #INVALID_POSITION} if item is not in the
+     * list.
+     */
+    public int indexOf(T item) {
+        return findIndexOf(item, LOOKUP);
+    }
+
+    private int findIndexOf(T item, int reason) {
+        int left = 0;
+        int right = mSize;
+        while (left < right) {
+            final int middle = (left + right) / 2;
+            T myItem = mData[middle];
+            final int cmp = mCallback.compare(myItem, item);
+            if (cmp < 0) {
+                left = middle + 1;
+            } else if (cmp == 0) {
+                if (mCallback.areItemsTheSame(myItem, item)) {
+                    return middle;
+                } else {
+                    int exact = linearEqualitySearch(item, middle, left, right);
+                    if (reason == INSERTION) {
+                        return exact == INVALID_POSITION ? middle : exact;
+                    } else {
+                        return exact;
+                    }
+                }
+            } else {
+                right = middle;
+            }
+        }
+        return reason == INSERTION ? left : INVALID_POSITION;
+    }
+
+    private int linearEqualitySearch(T item, int middle, int left, int right) {
+        // go left
+        for (int next = middle - 1; next >= left; next--) {
+            T nextItem = mData[next];
+            int cmp = mCallback.compare(nextItem, item);
+            if (cmp != 0) {
+                break;
+            }
+            if (mCallback.areItemsTheSame(nextItem, item)) {
+                return next;
+            }
+        }
+        for (int next = middle + 1; next < right; next++) {
+            T nextItem = mData[next];
+            int cmp = mCallback.compare(nextItem, item);
+            if (cmp != 0) {
+                break;
+            }
+            if (mCallback.areItemsTheSame(nextItem, item)) {
+                return next;
+            }
+        }
+        return INVALID_POSITION;
+    }
+
+    private void addToData(int index, T item) {
+        if (index > mSize) {
+            throw new IndexOutOfBoundsException(
+                    "cannot add item to " + index + " because size is " + mSize);
+        }
+        if (mSize == mData.length) {
+            // we are at the limit enlarge
+            T[] newData = (T[]) Array.newInstance(mTClass, mData.length + CAPACITY_GROWTH);
+            System.arraycopy(mData, 0, newData, 0, index);
+            newData[index] = item;
+            System.arraycopy(mData, index, newData, index + 1, mSize - index);
+            mData = newData;
+        } else {
+            // just shift, we fit
+            System.arraycopy(mData, index, mData, index + 1, mSize - index);
+            mData[index] = item;
+        }
+        mSize++;
+    }
+
+    /**
+     * The class that controls the behavior of the {@link SortedList}.
+     * <p>
+     * It defines how items should be sorted and how duplicates should be handled.
+     * <p>
+     * SortedList calls the callback methods on this class to notify changes about the underlying
+     * data.
+     */
+    public static abstract class Callback<T2> {
+
+        /**
+         * Similar to {@link java.util.Comparator#compare(Object, Object)}, should compare two and
+         * return how they should be ordered.
+         *
+         * @param o1 The first object to compare.
+         * @param o2 The second object to compare.
+         * @return a negative integer, zero, or a positive integer as the
+         * first argument is less than, equal to, or greater than the
+         * second.
+         */
+        abstract public int compare(T2 o1, T2 o2);
+
+        /**
+         * Called by the SortedList when an item is inserted at the given position.
+         *
+         * @param position The position of the new item.
+         * @param count    The number of items that have been added.
+         */
+        abstract public void onInserted(int position, int count);
+
+        /**
+         * Called by the SortedList when an item is removed from the given position.
+         *
+         * @param position The position of the item which has been removed.
+         * @param count    The number of items which have been removed.
+         */
+        abstract public void onRemoved(int position, int count);
+
+        /**
+         * Called by the SortedList when an item changes its position in the list.
+         *
+         * @param fromPosition The previous position of the item before the move.
+         * @param toPosition   The new position of the item.
+         */
+        abstract public void onMoved(int fromPosition, int toPosition);
+
+        /**
+         * Called by the SortedList when the item at the given position is updated.
+         *
+         * @param position The position of the item which has been updated.
+         * @param count    The number of items which has changed.
+         */
+        abstract public void onChanged(int position, int count);
+
+        /**
+         * Called by the SortedList when it wants to check whether two items have the same data
+         * or not. SortedList uses this information to decide whether it should call
+         * {@link #onChanged(int, int)} or not.
+         * <p>
+         * SortedList uses this method to check equality instead of {@link Object#equals(Object)}
+         * so
+         * that you can change its behavior depending on your UI.
+         * <p>
+         * For example, if you are using SortedList with a {@link android.support.v7.widget.RecyclerView.Adapter
+         * RecyclerView.Adapter}, you should
+         * return whether the items' visual representations are the same or not.
+         *
+         * @param oldItem The previous representation of the object.
+         * @param newItem The new object that replaces the previous one.
+         * @return True if the contents of the items are the same or false if they are different.
+         */
+        abstract public boolean areContentsTheSame(T2 oldItem, T2 newItem);
+
+        /**
+         * Called by the SortedList to decide whether two object represent the same Item or not.
+         * <p>
+         * For example, if your items have unique ids, this method should check their equality.
+         *
+         * @param item1 The first item to check.
+         * @param item2 The second item to check.
+         * @return True if the two items represent the same object or false if they are different.
+         */
+        abstract public boolean areItemsTheSame(T2 item1, T2 item2);
+    }
+
+    /**
+     * A callback implementation that can batch notify events dispatched by the SortedList.
+     * <p>
+     * This class can be useful if you want to do multiple operations on a SortedList but don't
+     * want to dispatch each event one by one, which may result in a performance issue.
+     * <p>
+     * For example, if you are going to add multiple items to a SortedList, BatchedCallback call
+     * convert individual <code>onInserted(index, 1)</code> calls into one
+     * <code>onInserted(index, N)</code> if items are added into consecutive indices. This change
+     * can help RecyclerView resolve changes much more easily.
+     * <p>
+     * If consecutive changes in the SortedList are not suitable for batching, BatchingCallback
+     * dispatches them as soon as such case is detected. After your edits on the SortedList is
+     * complete, you <b>must</b> always call {@link BatchedCallback#dispatchLastEvent()} to flush
+     * all changes to the Callback.
+     */
+    public static class BatchedCallback<T2> extends Callback<T2> {
+
+        private final Callback<T2> mWrappedCallback;
+        static final int TYPE_NONE = 0;
+        static final int TYPE_ADD = 1;
+        static final int TYPE_REMOVE = 2;
+        static final int TYPE_CHANGE = 3;
+        static final int TYPE_MOVE = 4;
+
+        int mLastEventType = TYPE_NONE;
+        int mLastEventPosition = -1;
+        int mLastEventCount = -1;
+
+        /**
+         * Creates a new BatchedCallback that wraps the provided Callback.
+         *
+         * @param wrappedCallback The Callback which should received the data change callbacks.
+         *                        Other method calls (e.g. {@link #compare(Object, Object)} from
+         *                        the SortedList are directly forwarded to this Callback.
+         */
+        public BatchedCallback(Callback<T2> wrappedCallback) {
+            mWrappedCallback = wrappedCallback;
+        }
+
+        @Override
+        public int compare(T2 o1, T2 o2) {
+            return mWrappedCallback.compare(o1, o2);
+        }
+
+        @Override
+        public void onInserted(int position, int count) {
+            if (mLastEventType == TYPE_ADD && position >= mLastEventPosition
+                    && position <= mLastEventPosition + mLastEventCount) {
+                mLastEventCount += count;
+                mLastEventPosition = Math.min(position, mLastEventPosition);
+                return;
+            }
+            dispatchLastEvent();
+            mLastEventPosition = position;
+            mLastEventCount = count;
+            mLastEventType = TYPE_ADD;
+        }
+
+        @Override
+        public void onRemoved(int position, int count) {
+            if (mLastEventType == TYPE_REMOVE && mLastEventPosition == position) {
+                mLastEventCount += count;
+                return;
+            }
+            dispatchLastEvent();
+            mLastEventPosition = position;
+            mLastEventCount = count;
+            mLastEventType = TYPE_REMOVE;
+        }
+
+        @Override
+        public void onMoved(int fromPosition, int toPosition) {
+            dispatchLastEvent();//moves are not merged
+            mWrappedCallback.onMoved(fromPosition, toPosition);
+        }
+
+        @Override
+        public void onChanged(int position, int count) {
+            if (mLastEventType == TYPE_CHANGE &&
+                    !(position > mLastEventPosition + mLastEventCount
+                            || position + count < mLastEventPosition)) {
+                // take potential overlap into account
+                int previousEnd = mLastEventPosition + mLastEventCount;
+                mLastEventPosition = Math.min(position, mLastEventPosition);
+                mLastEventCount = Math.max(previousEnd, position + count) - mLastEventPosition;
+                return;
+            }
+            dispatchLastEvent();
+            mLastEventPosition = position;
+            mLastEventCount = count;
+            mLastEventType = TYPE_CHANGE;
+        }
+
+        @Override
+        public boolean areContentsTheSame(T2 oldItem, T2 newItem) {
+            return mWrappedCallback.areContentsTheSame(oldItem, newItem);
+        }
+
+        @Override
+        public boolean areItemsTheSame(T2 item1, T2 item2) {
+            return mWrappedCallback.areItemsTheSame(item1, item2);
+        }
+
+
+        /**
+         * This method dispatches any pending event notifications to the wrapped Callback.
+         * You <b>must</b> always call this method after you are done with editing the SortedList.
+         */
+        public void dispatchLastEvent() {
+            if (mLastEventType == TYPE_NONE) {
+                return;
+            }
+            switch (mLastEventType) {
+                case TYPE_ADD:
+                    mWrappedCallback.onInserted(mLastEventPosition, mLastEventCount);
+                    break;
+                case TYPE_REMOVE:
+                    mWrappedCallback.onRemoved(mLastEventPosition, mLastEventCount);
+                    break;
+                case TYPE_CHANGE:
+                    mWrappedCallback.onChanged(mLastEventPosition, mLastEventCount);
+                    break;
+            }
+            mLastEventType = TYPE_NONE;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/AdapterHelper.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/AdapterHelper.java
new file mode 100644
index 000000000..3b4c28c1a
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/AdapterHelper.java
@@ -0,0 +1,733 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+
+import android.support.v4.util.Pools;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static org.telegram.android.support.widget.RecyclerView.*;
+
+/**
+ * Helper class that can enqueue and process adapter update operations.
+ * <p>
+ * To support animations, RecyclerView presents an older version the Adapter to best represent
+ * previous state of the layout. Sometimes, this is not trivial when items are removed that were
+ * not laid out, in which case, RecyclerView has no way of providing that item's view for
+ * animations.
+ * <p>
+ * AdapterHelper creates an UpdateOp for each adapter data change then pre-processes them. During
+ * pre processing, AdapterHelper finds out which UpdateOps can be deferred to second layout pass
+ * and which cannot. For the UpdateOps that cannot be deferred, AdapterHelper will change them
+ * according to previously deferred operation and dispatch them before the first layout pass. It
+ * also takes care of updating deferred UpdateOps since order of operations is changed by this
+ * process.
+ * <p>
+ * Although operations may be forwarded to LayoutManager in different orders, resulting data set
+ * is guaranteed to be the consistent.
+ */
+class AdapterHelper implements OpReorderer.Callback {
+
+    final static int POSITION_TYPE_INVISIBLE = 0;
+
+    final static int POSITION_TYPE_NEW_OR_LAID_OUT = 1;
+
+    private static final boolean DEBUG = false;
+
+    private static final String TAG = "AHT";
+
+    private Pools.Pool<UpdateOp> mUpdateOpPool = new Pools.SimplePool<UpdateOp>(UpdateOp.POOL_SIZE);
+
+    final ArrayList<UpdateOp> mPendingUpdates = new ArrayList<UpdateOp>();
+
+    final ArrayList<UpdateOp> mPostponedList = new ArrayList<UpdateOp>();
+
+    final Callback mCallback;
+
+    Runnable mOnItemProcessedCallback;
+
+    final boolean mDisableRecycler;
+
+    final OpReorderer mOpReorderer;
+
+    AdapterHelper(Callback callback) {
+        this(callback, false);
+    }
+
+    AdapterHelper(Callback callback, boolean disableRecycler) {
+        mCallback = callback;
+        mDisableRecycler = disableRecycler;
+        mOpReorderer = new OpReorderer(this);
+    }
+
+    AdapterHelper addUpdateOp(UpdateOp... ops) {
+        Collections.addAll(mPendingUpdates, ops);
+        return this;
+    }
+
+    void reset() {
+        recycleUpdateOpsAndClearList(mPendingUpdates);
+        recycleUpdateOpsAndClearList(mPostponedList);
+    }
+
+    void preProcess() {
+        mOpReorderer.reorderOps(mPendingUpdates);
+        final int count = mPendingUpdates.size();
+        for (int i = 0; i < count; i++) {
+            UpdateOp op = mPendingUpdates.get(i);
+            switch (op.cmd) {
+                case UpdateOp.ADD:
+                    applyAdd(op);
+                    break;
+                case UpdateOp.REMOVE:
+                    applyRemove(op);
+                    break;
+                case UpdateOp.UPDATE:
+                    applyUpdate(op);
+                    break;
+                case UpdateOp.MOVE:
+                    applyMove(op);
+                    break;
+            }
+            if (mOnItemProcessedCallback != null) {
+                mOnItemProcessedCallback.run();
+            }
+        }
+        mPendingUpdates.clear();
+    }
+
+    void consumePostponedUpdates() {
+        final int count = mPostponedList.size();
+        for (int i = 0; i < count; i++) {
+            mCallback.onDispatchSecondPass(mPostponedList.get(i));
+        }
+        recycleUpdateOpsAndClearList(mPostponedList);
+    }
+
+    private void applyMove(UpdateOp op) {
+        // MOVE ops are pre-processed so at this point, we know that item is still in the adapter.
+        // otherwise, it would be converted into a REMOVE operation
+        postponeAndUpdateViewHolders(op);
+    }
+
+    private void applyRemove(UpdateOp op) {
+        int tmpStart = op.positionStart;
+        int tmpCount = 0;
+        int tmpEnd = op.positionStart + op.itemCount;
+        int type = -1;
+        for (int position = op.positionStart; position < tmpEnd; position++) {
+            boolean typeChanged = false;
+            ViewHolder vh = mCallback.findViewHolder(position);
+            if (vh != null || canFindInPreLayout(position)) {
+                // If a ViewHolder exists or this is a newly added item, we can defer this update
+                // to post layout stage.
+                // * For existing ViewHolders, we'll fake its existence in the pre-layout phase.
+                // * For items that are added and removed in the same process cycle, they won't
+                // have any effect in pre-layout since their add ops are already deferred to
+                // post-layout pass.
+                if (type == POSITION_TYPE_INVISIBLE) {
+                    // Looks like we have other updates that we cannot merge with this one.
+                    // Create an UpdateOp and dispatch it to LayoutManager.
+                    UpdateOp newOp = obtainUpdateOp(UpdateOp.REMOVE, tmpStart, tmpCount);
+                    dispatchAndUpdateViewHolders(newOp);
+                    typeChanged = true;
+                }
+                type = POSITION_TYPE_NEW_OR_LAID_OUT;
+            } else {
+                // This update cannot be recovered because we don't have a ViewHolder representing
+                // this position. Instead, post it to LayoutManager immediately
+                if (type == POSITION_TYPE_NEW_OR_LAID_OUT) {
+                    // Looks like we have other updates that we cannot merge with this one.
+                    // Create UpdateOp op and dispatch it to LayoutManager.
+                    UpdateOp newOp = obtainUpdateOp(UpdateOp.REMOVE, tmpStart, tmpCount);
+                    postponeAndUpdateViewHolders(newOp);
+                    typeChanged = true;
+                }
+                type = POSITION_TYPE_INVISIBLE;
+            }
+            if (typeChanged) {
+                position -= tmpCount; // also equal to tmpStart
+                tmpEnd -= tmpCount;
+                tmpCount = 1;
+            } else {
+                tmpCount++;
+            }
+        }
+        if (tmpCount != op.itemCount) { // all 1 effect
+            recycleUpdateOp(op);
+            op = obtainUpdateOp(UpdateOp.REMOVE, tmpStart, tmpCount);
+        }
+        if (type == POSITION_TYPE_INVISIBLE) {
+            dispatchAndUpdateViewHolders(op);
+        } else {
+            postponeAndUpdateViewHolders(op);
+        }
+    }
+
+    private void applyUpdate(UpdateOp op) {
+        int tmpStart = op.positionStart;
+        int tmpCount = 0;
+        int tmpEnd = op.positionStart + op.itemCount;
+        int type = -1;
+        for (int position = op.positionStart; position < tmpEnd; position++) {
+            ViewHolder vh = mCallback.findViewHolder(position);
+            if (vh != null || canFindInPreLayout(position)) { // deferred
+                if (type == POSITION_TYPE_INVISIBLE) {
+                    UpdateOp newOp = obtainUpdateOp(UpdateOp.UPDATE, tmpStart, tmpCount);
+                    dispatchAndUpdateViewHolders(newOp);
+                    tmpCount = 0;
+                    tmpStart = position;
+                }
+                type = POSITION_TYPE_NEW_OR_LAID_OUT;
+            } else { // applied
+                if (type == POSITION_TYPE_NEW_OR_LAID_OUT) {
+                    UpdateOp newOp = obtainUpdateOp(UpdateOp.UPDATE, tmpStart, tmpCount);
+                    postponeAndUpdateViewHolders(newOp);
+                    tmpCount = 0;
+                    tmpStart = position;
+                }
+                type = POSITION_TYPE_INVISIBLE;
+            }
+            tmpCount++;
+        }
+        if (tmpCount != op.itemCount) { // all 1 effect
+            recycleUpdateOp(op);
+            op = obtainUpdateOp(UpdateOp.UPDATE, tmpStart, tmpCount);
+        }
+        if (type == POSITION_TYPE_INVISIBLE) {
+            dispatchAndUpdateViewHolders(op);
+        } else {
+            postponeAndUpdateViewHolders(op);
+        }
+    }
+
+    private void dispatchAndUpdateViewHolders(UpdateOp op) {
+        // tricky part.
+        // traverse all postpones and revert their changes on this op if necessary, apply updated
+        // dispatch to them since now they are after this op.
+        if (op.cmd == UpdateOp.ADD || op.cmd == UpdateOp.MOVE) {
+            throw new IllegalArgumentException("should not dispatch add or move for pre layout");
+        }
+        if (DEBUG) {
+            Log.d(TAG, "dispatch (pre)" + op);
+            Log.d(TAG, "postponed state before:");
+            for (UpdateOp updateOp : mPostponedList) {
+                Log.d(TAG, updateOp.toString());
+            }
+            Log.d(TAG, "----");
+        }
+
+        // handle each pos 1 by 1 to ensure continuity. If it breaks, dispatch partial
+        // TODO Since move ops are pushed to end, we should not need this anymore
+        int tmpStart = updatePositionWithPostponed(op.positionStart, op.cmd);
+        if (DEBUG) {
+            Log.d(TAG, "pos:" + op.positionStart + ",updatedPos:" + tmpStart);
+        }
+        int tmpCnt = 1;
+        int offsetPositionForPartial = op.positionStart;
+        final int positionMultiplier;
+        switch (op.cmd) {
+            case UpdateOp.UPDATE:
+                positionMultiplier = 1;
+                break;
+            case UpdateOp.REMOVE:
+                positionMultiplier = 0;
+                break;
+            default:
+                throw new IllegalArgumentException("op should be remove or update." + op);
+        }
+        for (int p = 1; p < op.itemCount; p++) {
+            final int pos = op.positionStart + (positionMultiplier * p);
+            int updatedPos = updatePositionWithPostponed(pos, op.cmd);
+            if (DEBUG) {
+                Log.d(TAG, "pos:" + pos + ",updatedPos:" + updatedPos);
+            }
+            boolean continuous = false;
+            switch (op.cmd) {
+                case UpdateOp.UPDATE:
+                    continuous = updatedPos == tmpStart + 1;
+                    break;
+                case UpdateOp.REMOVE:
+                    continuous = updatedPos == tmpStart;
+                    break;
+            }
+            if (continuous) {
+                tmpCnt++;
+            } else {
+                // need to dispatch this separately
+                UpdateOp tmp = obtainUpdateOp(op.cmd, tmpStart, tmpCnt);
+                if (DEBUG) {
+                    Log.d(TAG, "need to dispatch separately " + tmp);
+                }
+                dispatchFirstPassAndUpdateViewHolders(tmp, offsetPositionForPartial);
+                recycleUpdateOp(tmp);
+                if (op.cmd == UpdateOp.UPDATE) {
+                    offsetPositionForPartial += tmpCnt;
+                }
+                tmpStart = updatedPos;// need to remove previously dispatched
+                tmpCnt = 1;
+            }
+        }
+        recycleUpdateOp(op);
+        if (tmpCnt > 0) {
+            UpdateOp tmp = obtainUpdateOp(op.cmd, tmpStart, tmpCnt);
+            if (DEBUG) {
+                Log.d(TAG, "dispatching:" + tmp);
+            }
+            dispatchFirstPassAndUpdateViewHolders(tmp, offsetPositionForPartial);
+            recycleUpdateOp(tmp);
+        }
+        if (DEBUG) {
+            Log.d(TAG, "post dispatch");
+            Log.d(TAG, "postponed state after:");
+            for (UpdateOp updateOp : mPostponedList) {
+                Log.d(TAG, updateOp.toString());
+            }
+            Log.d(TAG, "----");
+        }
+    }
+
+    void dispatchFirstPassAndUpdateViewHolders(UpdateOp op, int offsetStart) {
+        mCallback.onDispatchFirstPass(op);
+        switch (op.cmd) {
+            case UpdateOp.REMOVE:
+                mCallback.offsetPositionsForRemovingInvisible(offsetStart, op.itemCount);
+                break;
+            case UpdateOp.UPDATE:
+                mCallback.markViewHoldersUpdated(offsetStart, op.itemCount);
+                break;
+            default:
+                throw new IllegalArgumentException("only remove and update ops can be dispatched"
+                        + " in first pass");
+        }
+    }
+
+    private int updatePositionWithPostponed(int pos, int cmd) {
+        final int count = mPostponedList.size();
+        for (int i = count - 1; i >= 0; i--) {
+            UpdateOp postponed = mPostponedList.get(i);
+            if (postponed.cmd == UpdateOp.MOVE) {
+                int start, end;
+                if (postponed.positionStart < postponed.itemCount) {
+                    start = postponed.positionStart;
+                    end = postponed.itemCount;
+                } else {
+                    start = postponed.itemCount;
+                    end = postponed.positionStart;
+                }
+                if (pos >= start && pos <= end) {
+                    //i'm affected
+                    if (start == postponed.positionStart) {
+                        if (cmd == UpdateOp.ADD) {
+                            postponed.itemCount++;
+                        } else if (cmd == UpdateOp.REMOVE) {
+                            postponed.itemCount--;
+                        }
+                        // op moved to left, move it right to revert
+                        pos++;
+                    } else {
+                        if (cmd == UpdateOp.ADD) {
+                            postponed.positionStart++;
+                        } else if (cmd == UpdateOp.REMOVE) {
+                            postponed.positionStart--;
+                        }
+                        // op was moved right, move left to revert
+                        pos--;
+                    }
+                } else if (pos < postponed.positionStart) {
+                    // postponed MV is outside the dispatched OP. if it is before, offset
+                    if (cmd == UpdateOp.ADD) {
+                        postponed.positionStart++;
+                        postponed.itemCount++;
+                    } else if (cmd == UpdateOp.REMOVE) {
+                        postponed.positionStart--;
+                        postponed.itemCount--;
+                    }
+                }
+            } else {
+                if (postponed.positionStart <= pos) {
+                    if (postponed.cmd == UpdateOp.ADD) {
+                        pos -= postponed.itemCount;
+                    } else if (postponed.cmd == UpdateOp.REMOVE) {
+                        pos += postponed.itemCount;
+                    }
+                } else {
+                    if (cmd == UpdateOp.ADD) {
+                        postponed.positionStart++;
+                    } else if (cmd == UpdateOp.REMOVE) {
+                        postponed.positionStart--;
+                    }
+                }
+            }
+            if (DEBUG) {
+                Log.d(TAG, "dispath (step" + i + ")");
+                Log.d(TAG, "postponed state:" + i + ", pos:" + pos);
+                for (UpdateOp updateOp : mPostponedList) {
+                    Log.d(TAG, updateOp.toString());
+                }
+                Log.d(TAG, "----");
+            }
+        }
+        for (int i = mPostponedList.size() - 1; i >= 0; i--) {
+            UpdateOp op = mPostponedList.get(i);
+            if (op.cmd == UpdateOp.MOVE) {
+                if (op.itemCount == op.positionStart || op.itemCount < 0) {
+                    mPostponedList.remove(i);
+                    recycleUpdateOp(op);
+                }
+            } else if (op.itemCount <= 0) {
+                mPostponedList.remove(i);
+                recycleUpdateOp(op);
+            }
+        }
+        return pos;
+    }
+
+    private boolean canFindInPreLayout(int position) {
+        final int count = mPostponedList.size();
+        for (int i = 0; i < count; i++) {
+            UpdateOp op = mPostponedList.get(i);
+            if (op.cmd == UpdateOp.MOVE) {
+                if (findPositionOffset(op.itemCount, i + 1) == position) {
+                    return true;
+                }
+            } else if (op.cmd == UpdateOp.ADD) {
+                // TODO optimize.
+                final int end = op.positionStart + op.itemCount;
+                for (int pos = op.positionStart; pos < end; pos++) {
+                    if (findPositionOffset(pos, i + 1) == position) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    private void applyAdd(UpdateOp op) {
+        postponeAndUpdateViewHolders(op);
+    }
+
+    private void postponeAndUpdateViewHolders(UpdateOp op) {
+        if (DEBUG) {
+            Log.d(TAG, "postponing " + op);
+        }
+        mPostponedList.add(op);
+        switch (op.cmd) {
+            case UpdateOp.ADD:
+                mCallback.offsetPositionsForAdd(op.positionStart, op.itemCount);
+                break;
+            case UpdateOp.MOVE:
+                mCallback.offsetPositionsForMove(op.positionStart, op.itemCount);
+                break;
+            case UpdateOp.REMOVE:
+                mCallback.offsetPositionsForRemovingLaidOutOrNewView(op.positionStart,
+                        op.itemCount);
+                break;
+            case UpdateOp.UPDATE:
+                mCallback.markViewHoldersUpdated(op.positionStart, op.itemCount);
+                break;
+            default:
+                throw new IllegalArgumentException("Unknown update op type for " + op);
+        }
+    }
+
+    boolean hasPendingUpdates() {
+        return mPendingUpdates.size() > 0;
+    }
+
+    int findPositionOffset(int position) {
+        return findPositionOffset(position, 0);
+    }
+
+    int findPositionOffset(int position, int firstPostponedItem) {
+        int count = mPostponedList.size();
+        for (int i = firstPostponedItem; i < count; ++i) {
+            UpdateOp op = mPostponedList.get(i);
+            if (op.cmd == UpdateOp.MOVE) {
+                if (op.positionStart == position) {
+                    position = op.itemCount;
+                } else {
+                    if (op.positionStart < position) {
+                        position--; // like a remove
+                    }
+                    if (op.itemCount <= position) {
+                        position++; // like an add
+                    }
+                }
+            } else if (op.positionStart <= position) {
+                if (op.cmd == UpdateOp.REMOVE) {
+                    if (position < op.positionStart + op.itemCount) {
+                        return -1;
+                    }
+                    position -= op.itemCount;
+                } else if (op.cmd == UpdateOp.ADD) {
+                    position += op.itemCount;
+                }
+            }
+        }
+        return position;
+    }
+
+    /**
+     * @return True if updates should be processed.
+     */
+    boolean onItemRangeChanged(int positionStart, int itemCount) {
+        mPendingUpdates.add(obtainUpdateOp(UpdateOp.UPDATE, positionStart, itemCount));
+        return mPendingUpdates.size() == 1;
+    }
+
+    /**
+     * @return True if updates should be processed.
+     */
+    boolean onItemRangeInserted(int positionStart, int itemCount) {
+        mPendingUpdates.add(obtainUpdateOp(UpdateOp.ADD, positionStart, itemCount));
+        return mPendingUpdates.size() == 1;
+    }
+
+    /**
+     * @return True if updates should be processed.
+     */
+    boolean onItemRangeRemoved(int positionStart, int itemCount) {
+        mPendingUpdates.add(obtainUpdateOp(UpdateOp.REMOVE, positionStart, itemCount));
+        return mPendingUpdates.size() == 1;
+    }
+
+    /**
+     * @return True if updates should be processed.
+     */
+    boolean onItemRangeMoved(int from, int to, int itemCount) {
+        if (from == to) {
+            return false;//no-op
+        }
+        if (itemCount != 1) {
+            throw new IllegalArgumentException("Moving more than 1 item is not supported yet");
+        }
+        mPendingUpdates.add(obtainUpdateOp(UpdateOp.MOVE, from, to));
+        return mPendingUpdates.size() == 1;
+    }
+
+    /**
+     * Skips pre-processing and applies all updates in one pass.
+     */
+    void consumeUpdatesInOnePass() {
+        // we still consume postponed updates (if there is) in case there was a pre-process call
+        // w/o a matching consumePostponedUpdates.
+        consumePostponedUpdates();
+        final int count = mPendingUpdates.size();
+        for (int i = 0; i < count; i++) {
+            UpdateOp op = mPendingUpdates.get(i);
+            switch (op.cmd) {
+                case UpdateOp.ADD:
+                    mCallback.onDispatchSecondPass(op);
+                    mCallback.offsetPositionsForAdd(op.positionStart, op.itemCount);
+                    break;
+                case UpdateOp.REMOVE:
+                    mCallback.onDispatchSecondPass(op);
+                    mCallback.offsetPositionsForRemovingInvisible(op.positionStart, op.itemCount);
+                    break;
+                case UpdateOp.UPDATE:
+                    mCallback.onDispatchSecondPass(op);
+                    mCallback.markViewHoldersUpdated(op.positionStart, op.itemCount);
+                    break;
+                case UpdateOp.MOVE:
+                    mCallback.onDispatchSecondPass(op);
+                    mCallback.offsetPositionsForMove(op.positionStart, op.itemCount);
+                    break;
+            }
+            if (mOnItemProcessedCallback != null) {
+                mOnItemProcessedCallback.run();
+            }
+        }
+        recycleUpdateOpsAndClearList(mPendingUpdates);
+    }
+
+    public int applyPendingUpdatesToPosition(int position) {
+        final int size = mPendingUpdates.size();
+        for (int i = 0; i < size; i ++) {
+            UpdateOp op = mPendingUpdates.get(i);
+            switch (op.cmd) {
+                case UpdateOp.ADD:
+                    if (op.positionStart <= position) {
+                        position += op.itemCount;
+                    }
+                    break;
+                case UpdateOp.REMOVE:
+                    if (op.positionStart <= position) {
+                        final int end = op.positionStart + op.itemCount;
+                        if (end > position) {
+                            return RecyclerView.NO_POSITION;
+                        }
+                        position -= op.itemCount;
+                    }
+                    break;
+                case UpdateOp.MOVE:
+                    if (op.positionStart == position) {
+                        position = op.itemCount;//position end
+                    } else {
+                        if (op.positionStart < position) {
+                            position -= 1;
+                        }
+                        if (op.itemCount <= position) {
+                            position += 1;
+                        }
+                    }
+                    break;
+            }
+        }
+        return position;
+    }
+
+    /**
+     * Queued operation to happen when child views are updated.
+     */
+    static class UpdateOp {
+
+        static final int ADD = 0;
+
+        static final int REMOVE = 1;
+
+        static final int UPDATE = 2;
+
+        static final int MOVE = 3;
+
+        static final int POOL_SIZE = 30;
+
+        int cmd;
+
+        int positionStart;
+
+        // holds the target position if this is a MOVE
+        int itemCount;
+
+        UpdateOp(int cmd, int positionStart, int itemCount) {
+            this.cmd = cmd;
+            this.positionStart = positionStart;
+            this.itemCount = itemCount;
+        }
+
+        String cmdToString() {
+            switch (cmd) {
+                case ADD:
+                    return "add";
+                case REMOVE:
+                    return "rm";
+                case UPDATE:
+                    return "up";
+                case MOVE:
+                    return "mv";
+            }
+            return "??";
+        }
+
+        @Override
+        public String toString() {
+            return "[" + cmdToString() + ",s:" + positionStart + "c:" + itemCount + "]";
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) {
+                return true;
+            }
+            if (o == null || getClass() != o.getClass()) {
+                return false;
+            }
+
+            UpdateOp op = (UpdateOp) o;
+
+            if (cmd != op.cmd) {
+                return false;
+            }
+            if (cmd == MOVE && Math.abs(itemCount - positionStart) == 1) {
+                // reverse of this is also true
+                if (itemCount == op.positionStart && positionStart == op.itemCount) {
+                    return true;
+                }
+            }
+            if (itemCount != op.itemCount) {
+                return false;
+            }
+            if (positionStart != op.positionStart) {
+                return false;
+            }
+
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            int result = cmd;
+            result = 31 * result + positionStart;
+            result = 31 * result + itemCount;
+            return result;
+        }
+    }
+
+    @Override
+    public UpdateOp obtainUpdateOp(int cmd, int positionStart, int itemCount) {
+        UpdateOp op = mUpdateOpPool.acquire();
+        if (op == null) {
+            op = new UpdateOp(cmd, positionStart, itemCount);
+        } else {
+            op.cmd = cmd;
+            op.positionStart = positionStart;
+            op.itemCount = itemCount;
+        }
+        return op;
+    }
+
+    @Override
+    public void recycleUpdateOp(UpdateOp op) {
+        if (!mDisableRecycler) {
+            mUpdateOpPool.release(op);
+        }
+    }
+
+    void recycleUpdateOpsAndClearList(List<UpdateOp> ops) {
+        final int count = ops.size();
+        for (int i = 0; i < count; i++) {
+            recycleUpdateOp(ops.get(i));
+        }
+        ops.clear();
+    }
+
+    /**
+     * Contract between AdapterHelper and RecyclerView.
+     */
+    static interface Callback {
+
+        ViewHolder findViewHolder(int position);
+
+        void offsetPositionsForRemovingInvisible(int positionStart, int itemCount);
+
+        void offsetPositionsForRemovingLaidOutOrNewView(int positionStart, int itemCount);
+
+        void markViewHoldersUpdated(int positionStart, int itemCount);
+
+        void onDispatchFirstPass(UpdateOp updateOp);
+
+        void onDispatchSecondPass(UpdateOp updateOp);
+
+        void offsetPositionsForAdd(int positionStart, int itemCount);
+
+        void offsetPositionsForMove(int from, int to);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/ChildHelper.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/ChildHelper.java
new file mode 100644
index 000000000..838bca966
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/ChildHelper.java
@@ -0,0 +1,487 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Helper class to manage children.
+ * <p>
+ * It wraps a RecyclerView and adds ability to hide some children. There are two sets of methods
+ * provided by this class. <b>Regular</b> methods are the ones that replicate ViewGroup methods
+ * like getChildAt, getChildCount etc. These methods ignore hidden children.
+ * <p>
+ * When RecyclerView needs direct access to the view group children, it can call unfiltered
+ * methods like get getUnfilteredChildCount or getUnfilteredChildAt.
+ */
+class ChildHelper {
+
+    private static final boolean DEBUG = false;
+
+    private static final String TAG = "ChildrenHelper";
+
+    final Callback mCallback;
+
+    final Bucket mBucket;
+
+    final List<View> mHiddenViews;
+
+    ChildHelper(Callback callback) {
+        mCallback = callback;
+        mBucket = new Bucket();
+        mHiddenViews = new ArrayList<View>();
+    }
+
+    /**
+     * Adds a view to the ViewGroup
+     *
+     * @param child  View to add.
+     * @param hidden If set to true, this item will be invisible from regular methods.
+     */
+    void addView(View child, boolean hidden) {
+        addView(child, -1, hidden);
+    }
+
+    /**
+     * Add a view to the ViewGroup at an index
+     *
+     * @param child  View to add.
+     * @param index  Index of the child from the regular perspective (excluding hidden views).
+     *               ChildHelper offsets this index to actual ViewGroup index.
+     * @param hidden If set to true, this item will be invisible from regular methods.
+     */
+    void addView(View child, int index, boolean hidden) {
+        final int offset;
+        if (index < 0) {
+            offset = mCallback.getChildCount();
+        } else {
+            offset = getOffset(index);
+        }
+        mBucket.insert(offset, hidden);
+        if (hidden) {
+            mHiddenViews.add(child);
+        }
+        mCallback.addView(child, offset);
+        if (DEBUG) {
+            Log.d(TAG, "addViewAt " + index + ",h:" + hidden + ", " + this);
+        }
+    }
+
+    private int getOffset(int index) {
+        if (index < 0) {
+            return -1; //anything below 0 won't work as diff will be undefined.
+        }
+        final int limit = mCallback.getChildCount();
+        int offset = index;
+        while (offset < limit) {
+            final int removedBefore = mBucket.countOnesBefore(offset);
+            final int diff = index - (offset - removedBefore);
+            if (diff == 0) {
+                while (mBucket.get(offset)) { // ensure this offset is not hidden
+                    offset ++;
+                }
+                return offset;
+            } else {
+                offset += diff;
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Removes the provided View from underlying RecyclerView.
+     *
+     * @param view The view to remove.
+     */
+    void removeView(View view) {
+        int index = mCallback.indexOfChild(view);
+        if (index < 0) {
+            return;
+        }
+        if (mBucket.remove(index)) {
+            mHiddenViews.remove(view);
+        }
+        mCallback.removeViewAt(index);
+        if (DEBUG) {
+            Log.d(TAG, "remove View off:" + index + "," + this);
+        }
+    }
+
+    /**
+     * Removes the view at the provided index from RecyclerView.
+     *
+     * @param index Index of the child from the regular perspective (excluding hidden views).
+     *              ChildHelper offsets this index to actual ViewGroup index.
+     */
+    void removeViewAt(int index) {
+        final int offset = getOffset(index);
+        final View view = mCallback.getChildAt(offset);
+        if (view == null) {
+            return;
+        }
+        if (mBucket.remove(offset)) {
+            mHiddenViews.remove(view);
+        }
+        mCallback.removeViewAt(offset);
+        if (DEBUG) {
+            Log.d(TAG, "removeViewAt " + index + ", off:" + offset + ", " + this);
+        }
+    }
+
+    /**
+     * Returns the child at provided index.
+     *
+     * @param index Index of the child to return in regular perspective.
+     */
+    View getChildAt(int index) {
+        final int offset = getOffset(index);
+        return mCallback.getChildAt(offset);
+    }
+
+    /**
+     * Removes all views from the ViewGroup including the hidden ones.
+     */
+    void removeAllViewsUnfiltered() {
+        mBucket.reset();
+        mHiddenViews.clear();
+        mCallback.removeAllViews();
+        if (DEBUG) {
+            Log.d(TAG, "removeAllViewsUnfiltered");
+        }
+    }
+
+    /**
+     * This can be used to find a disappearing view by position.
+     *
+     * @param position The adapter position of the item.
+     * @param type     View type, can be {@link RecyclerView#INVALID_TYPE}.
+     * @return         A hidden view with a valid ViewHolder that matches the position and type.
+     */
+    View findHiddenNonRemovedView(int position, int type) {
+        final int count = mHiddenViews.size();
+        for (int i = 0; i < count; i++) {
+            final View view = mHiddenViews.get(i);
+            RecyclerView.ViewHolder holder = mCallback.getChildViewHolder(view);
+            if (holder.getLayoutPosition() == position && !holder.isInvalid() &&
+                    (type == RecyclerView.INVALID_TYPE || holder.getItemViewType() == type)) {
+                return view;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Attaches the provided view to the underlying ViewGroup.
+     *
+     * @param child        Child to attach.
+     * @param index        Index of the child to attach in regular perspective.
+     * @param layoutParams LayoutParams for the child.
+     * @param hidden       If set to true, this item will be invisible to the regular methods.
+     */
+    void attachViewToParent(View child, int index, ViewGroup.LayoutParams layoutParams,
+            boolean hidden) {
+        final int offset;
+        if (index < 0) {
+            offset = mCallback.getChildCount();
+        } else {
+            offset = getOffset(index);
+        }
+        mBucket.insert(offset, hidden);
+        if (hidden) {
+            mHiddenViews.add(child);
+        }
+        mCallback.attachViewToParent(child, offset, layoutParams);
+        if (DEBUG) {
+            Log.d(TAG, "attach view to parent index:" + index + ",off:" + offset + "," +
+                    "h:" + hidden + ", " + this);
+        }
+    }
+
+    /**
+     * Returns the number of children that are not hidden.
+     *
+     * @return Number of children that are not hidden.
+     * @see #getChildAt(int)
+     */
+    int getChildCount() {
+        return mCallback.getChildCount() - mHiddenViews.size();
+    }
+
+    /**
+     * Returns the total number of children.
+     *
+     * @return The total number of children including the hidden views.
+     * @see #getUnfilteredChildAt(int)
+     */
+    int getUnfilteredChildCount() {
+        return mCallback.getChildCount();
+    }
+
+    /**
+     * Returns a child by ViewGroup offset. ChildHelper won't offset this index.
+     *
+     * @param index ViewGroup index of the child to return.
+     * @return The view in the provided index.
+     */
+    View getUnfilteredChildAt(int index) {
+        return mCallback.getChildAt(index);
+    }
+
+    /**
+     * Detaches the view at the provided index.
+     *
+     * @param index Index of the child to return in regular perspective.
+     */
+    void detachViewFromParent(int index) {
+        final int offset = getOffset(index);
+        mBucket.remove(offset);
+        mCallback.detachViewFromParent(offset);
+        if (DEBUG) {
+            Log.d(TAG, "detach view from parent " + index + ", off:" + offset);
+        }
+    }
+
+    /**
+     * Returns the index of the child in regular perspective.
+     *
+     * @param child The child whose index will be returned.
+     * @return The regular perspective index of the child or -1 if it does not exists.
+     */
+    int indexOfChild(View child) {
+        final int index = mCallback.indexOfChild(child);
+        if (index == -1) {
+            return -1;
+        }
+        if (mBucket.get(index)) {
+            if (DEBUG) {
+                throw new IllegalArgumentException("cannot get index of a hidden child");
+            } else {
+                return -1;
+            }
+        }
+        // reverse the index
+        return index - mBucket.countOnesBefore(index);
+    }
+
+    /**
+     * Returns whether a View is visible to LayoutManager or not.
+     *
+     * @param view The child view to check. Should be a child of the Callback.
+     * @return True if the View is not visible to LayoutManager
+     */
+    boolean isHidden(View view) {
+        return mHiddenViews.contains(view);
+    }
+
+    /**
+     * Marks a child view as hidden.
+     *
+     * @param view The view to hide.
+     */
+    void hide(View view) {
+        final int offset = mCallback.indexOfChild(view);
+        if (offset < 0) {
+            throw new IllegalArgumentException("view is not a child, cannot hide " + view);
+        }
+        if (DEBUG && mBucket.get(offset)) {
+            throw new RuntimeException("trying to hide same view twice, how come ? " + view);
+        }
+        mBucket.set(offset);
+        mHiddenViews.add(view);
+        if (DEBUG) {
+            Log.d(TAG, "hiding child " + view + " at offset " + offset+ ", " + this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return mBucket.toString() + ", hidden list:" + mHiddenViews.size();
+    }
+
+    /**
+     * Removes a view from the ViewGroup if it is hidden.
+     *
+     * @param view The view to remove.
+     * @return True if the View is found and it is hidden. False otherwise.
+     */
+    boolean removeViewIfHidden(View view) {
+        final int index = mCallback.indexOfChild(view);
+        if (index == -1) {
+            if (mHiddenViews.remove(view) && DEBUG) {
+                throw new IllegalStateException("view is in hidden list but not in view group");
+            }
+            return true;
+        }
+        if (mBucket.get(index)) {
+            mBucket.remove(index);
+            if (!mHiddenViews.remove(view) && DEBUG) {
+                throw new IllegalStateException(
+                        "removed a hidden view but it is not in hidden views list");
+            }
+            mCallback.removeViewAt(index);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Bitset implementation that provides methods to offset indices.
+     */
+    static class Bucket {
+
+        final static int BITS_PER_WORD = Long.SIZE;
+
+        final static long LAST_BIT = 1L << (Long.SIZE - 1);
+
+        long mData = 0;
+
+        Bucket next;
+
+        void set(int index) {
+            if (index >= BITS_PER_WORD) {
+                ensureNext();
+                next.set(index - BITS_PER_WORD);
+            } else {
+                mData |= 1L << index;
+            }
+        }
+
+        private void ensureNext() {
+            if (next == null) {
+                next = new Bucket();
+            }
+        }
+
+        void clear(int index) {
+            if (index >= BITS_PER_WORD) {
+                if (next != null) {
+                    next.clear(index - BITS_PER_WORD);
+                }
+            } else {
+                mData &= ~(1L << index);
+            }
+
+        }
+
+        boolean get(int index) {
+            if (index >= BITS_PER_WORD) {
+                ensureNext();
+                return next.get(index - BITS_PER_WORD);
+            } else {
+                return (mData & (1L << index)) != 0;
+            }
+        }
+
+        void reset() {
+            mData = 0;
+            if (next != null) {
+                next.reset();
+            }
+        }
+
+        void insert(int index, boolean value) {
+            if (index >= BITS_PER_WORD) {
+                ensureNext();
+                next.insert(index - BITS_PER_WORD, value);
+            } else {
+                final boolean lastBit = (mData & LAST_BIT) != 0;
+                long mask = (1L << index) - 1;
+                final long before = mData & mask;
+                final long after = ((mData & ~mask)) << 1;
+                mData = before | after;
+                if (value) {
+                    set(index);
+                } else {
+                    clear(index);
+                }
+                if (lastBit || next != null) {
+                    ensureNext();
+                    next.insert(0, lastBit);
+                }
+            }
+        }
+
+        boolean remove(int index) {
+            if (index >= BITS_PER_WORD) {
+                ensureNext();
+                return next.remove(index - BITS_PER_WORD);
+            } else {
+                long mask = (1L << index);
+                final boolean value = (mData & mask) != 0;
+                mData &= ~mask;
+                mask = mask - 1;
+                final long before = mData & mask;
+                // cannot use >> because it adds one.
+                final long after = Long.rotateRight(mData & ~mask, 1);
+                mData = before | after;
+                if (next != null) {
+                    if (next.get(0)) {
+                        set(BITS_PER_WORD - 1);
+                    }
+                    next.remove(0);
+                }
+                return value;
+            }
+        }
+
+        int countOnesBefore(int index) {
+            if (next == null) {
+                if (index >= BITS_PER_WORD) {
+                    return Long.bitCount(mData);
+                }
+                return Long.bitCount(mData & ((1L << index) - 1));
+            }
+            if (index < BITS_PER_WORD) {
+                return Long.bitCount(mData & ((1L << index) - 1));
+            } else {
+                return next.countOnesBefore(index - BITS_PER_WORD) + Long.bitCount(mData);
+            }
+        }
+
+        @Override
+        public String toString() {
+            return next == null ? Long.toBinaryString(mData)
+                    : next.toString() + "xx" + Long.toBinaryString(mData);
+        }
+    }
+
+    static interface Callback {
+
+        int getChildCount();
+
+        void addView(View child, int index);
+
+        int indexOfChild(View view);
+
+        void removeViewAt(int index);
+
+        View getChildAt(int offset);
+
+        void removeAllViews();
+
+        RecyclerView.ViewHolder getChildViewHolder(View view);
+
+        void attachViewToParent(View child, int index, ViewGroup.LayoutParams layoutParams);
+
+        void detachViewFromParent(int offset);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/DefaultItemAnimator.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/DefaultItemAnimator.java
new file mode 100644
index 000000000..bbbc20a54
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/DefaultItemAnimator.java
@@ -0,0 +1,631 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.android.support.widget;
+
+import android.support.v4.view.ViewCompat;
+import android.support.v4.view.ViewPropertyAnimatorCompat;
+import android.support.v4.view.ViewPropertyAnimatorListener;
+import org.telegram.android.support.widget.RecyclerView.ViewHolder;
+import android.view.View;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This implementation of {@link RecyclerView.ItemAnimator} provides basic
+ * animations on remove, add, and move events that happen to the items in
+ * a RecyclerView. RecyclerView uses a DefaultItemAnimator by default.
+ *
+ * @see RecyclerView#setItemAnimator(RecyclerView.ItemAnimator)
+ */
+public class DefaultItemAnimator extends RecyclerView.ItemAnimator {
+    private static final boolean DEBUG = false;
+
+    private ArrayList<ViewHolder> mPendingRemovals = new ArrayList<ViewHolder>();
+    private ArrayList<ViewHolder> mPendingAdditions = new ArrayList<ViewHolder>();
+    private ArrayList<MoveInfo> mPendingMoves = new ArrayList<MoveInfo>();
+    private ArrayList<ChangeInfo> mPendingChanges = new ArrayList<ChangeInfo>();
+
+    private ArrayList<ArrayList<ViewHolder>> mAdditionsList =
+            new ArrayList<ArrayList<ViewHolder>>();
+    private ArrayList<ArrayList<MoveInfo>> mMovesList = new ArrayList<ArrayList<MoveInfo>>();
+    private ArrayList<ArrayList<ChangeInfo>> mChangesList = new ArrayList<ArrayList<ChangeInfo>>();
+
+    private ArrayList<ViewHolder> mAddAnimations = new ArrayList<ViewHolder>();
+    private ArrayList<ViewHolder> mMoveAnimations = new ArrayList<ViewHolder>();
+    private ArrayList<ViewHolder> mRemoveAnimations = new ArrayList<ViewHolder>();
+    private ArrayList<ViewHolder> mChangeAnimations = new ArrayList<ViewHolder>();
+
+    private static class MoveInfo {
+        public ViewHolder holder;
+        public int fromX, fromY, toX, toY;
+
+        private MoveInfo(ViewHolder holder, int fromX, int fromY, int toX, int toY) {
+            this.holder = holder;
+            this.fromX = fromX;
+            this.fromY = fromY;
+            this.toX = toX;
+            this.toY = toY;
+        }
+    }
+
+    private static class ChangeInfo {
+        public ViewHolder oldHolder, newHolder;
+        public int fromX, fromY, toX, toY;
+        private ChangeInfo(ViewHolder oldHolder, ViewHolder newHolder) {
+            this.oldHolder = oldHolder;
+            this.newHolder = newHolder;
+        }
+
+        private ChangeInfo(ViewHolder oldHolder, ViewHolder newHolder,
+                int fromX, int fromY, int toX, int toY) {
+            this(oldHolder, newHolder);
+            this.fromX = fromX;
+            this.fromY = fromY;
+            this.toX = toX;
+            this.toY = toY;
+        }
+
+        @Override
+        public String toString() {
+            return "ChangeInfo{" +
+                    "oldHolder=" + oldHolder +
+                    ", newHolder=" + newHolder +
+                    ", fromX=" + fromX +
+                    ", fromY=" + fromY +
+                    ", toX=" + toX +
+                    ", toY=" + toY +
+                    '}';
+        }
+    }
+
+    @Override
+    public void runPendingAnimations() {
+        boolean removalsPending = !mPendingRemovals.isEmpty();
+        boolean movesPending = !mPendingMoves.isEmpty();
+        boolean changesPending = !mPendingChanges.isEmpty();
+        boolean additionsPending = !mPendingAdditions.isEmpty();
+        if (!removalsPending && !movesPending && !additionsPending && !changesPending) {
+            // nothing to animate
+            return;
+        }
+        // First, remove stuff
+        for (ViewHolder holder : mPendingRemovals) {
+            animateRemoveImpl(holder);
+        }
+        mPendingRemovals.clear();
+        // Next, move stuff
+        if (movesPending) {
+            final ArrayList<MoveInfo> moves = new ArrayList<MoveInfo>();
+            moves.addAll(mPendingMoves);
+            mMovesList.add(moves);
+            mPendingMoves.clear();
+            Runnable mover = new Runnable() {
+                @Override
+                public void run() {
+                    for (MoveInfo moveInfo : moves) {
+                        animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY,
+                                moveInfo.toX, moveInfo.toY);
+                    }
+                    moves.clear();
+                    mMovesList.remove(moves);
+                }
+            };
+            if (removalsPending) {
+                View view = moves.get(0).holder.itemView;
+                ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration());
+            } else {
+                mover.run();
+            }
+        }
+        // Next, change stuff, to run in parallel with move animations
+        if (changesPending) {
+            final ArrayList<ChangeInfo> changes = new ArrayList<ChangeInfo>();
+            changes.addAll(mPendingChanges);
+            mChangesList.add(changes);
+            mPendingChanges.clear();
+            Runnable changer = new Runnable() {
+                @Override
+                public void run() {
+                    for (ChangeInfo change : changes) {
+                        animateChangeImpl(change);
+                    }
+                    changes.clear();
+                    mChangesList.remove(changes);
+                }
+            };
+            if (removalsPending) {
+                ViewHolder holder = changes.get(0).oldHolder;
+                ViewCompat.postOnAnimationDelayed(holder.itemView, changer, getRemoveDuration());
+            } else {
+                changer.run();
+            }
+        }
+        // Next, add stuff
+        if (additionsPending) {
+            final ArrayList<ViewHolder> additions = new ArrayList<ViewHolder>();
+            additions.addAll(mPendingAdditions);
+            mAdditionsList.add(additions);
+            mPendingAdditions.clear();
+            Runnable adder = new Runnable() {
+                public void run() {
+                    for (ViewHolder holder : additions) {
+                        animateAddImpl(holder);
+                    }
+                    additions.clear();
+                    mAdditionsList.remove(additions);
+                }
+            };
+            if (removalsPending || movesPending || changesPending) {
+                long removeDuration = removalsPending ? getRemoveDuration() : 0;
+                long moveDuration = movesPending ? getMoveDuration() : 0;
+                long changeDuration = changesPending ? getChangeDuration() : 0;
+                long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);
+                View view = additions.get(0).itemView;
+                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay);
+            } else {
+                adder.run();
+            }
+        }
+    }
+
+    @Override
+    public boolean animateRemove(final ViewHolder holder) {
+        endAnimation(holder);
+        mPendingRemovals.add(holder);
+        return true;
+    }
+
+    private void animateRemoveImpl(final ViewHolder holder) {
+        final View view = holder.itemView;
+        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);
+        mRemoveAnimations.add(holder);
+        animation.setDuration(getRemoveDuration())
+                .alpha(0).setListener(new VpaListenerAdapter() {
+            @Override
+            public void onAnimationStart(View view) {
+                dispatchRemoveStarting(holder);
+            }
+
+            @Override
+            public void onAnimationEnd(View view) {
+                animation.setListener(null);
+                ViewCompat.setAlpha(view, 1);
+                dispatchRemoveFinished(holder);
+                mRemoveAnimations.remove(holder);
+                dispatchFinishedWhenDone();
+            }
+        }).start();
+    }
+
+    @Override
+    public boolean animateAdd(final ViewHolder holder) {
+        endAnimation(holder);
+        ViewCompat.setAlpha(holder.itemView, 0);
+        mPendingAdditions.add(holder);
+        return true;
+    }
+
+    private void animateAddImpl(final ViewHolder holder) {
+        final View view = holder.itemView;
+        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);
+        mAddAnimations.add(holder);
+        animation.alpha(1).setDuration(getAddDuration()).
+                setListener(new VpaListenerAdapter() {
+                    @Override
+                    public void onAnimationStart(View view) {
+                        dispatchAddStarting(holder);
+                    }
+                    @Override
+                    public void onAnimationCancel(View view) {
+                        ViewCompat.setAlpha(view, 1);
+                    }
+
+                    @Override
+                    public void onAnimationEnd(View view) {
+                        animation.setListener(null);
+                        dispatchAddFinished(holder);
+                        mAddAnimations.remove(holder);
+                        dispatchFinishedWhenDone();
+                    }
+                }).start();
+    }
+
+    @Override
+    public boolean animateMove(final ViewHolder holder, int fromX, int fromY,
+            int toX, int toY) {
+        final View view = holder.itemView;
+        fromX += ViewCompat.getTranslationX(holder.itemView);
+        fromY += ViewCompat.getTranslationY(holder.itemView);
+        endAnimation(holder);
+        int deltaX = toX - fromX;
+        int deltaY = toY - fromY;
+        if (deltaX == 0 && deltaY == 0) {
+            dispatchMoveFinished(holder);
+            return false;
+        }
+        if (deltaX != 0) {
+            ViewCompat.setTranslationX(view, -deltaX);
+        }
+        if (deltaY != 0) {
+            ViewCompat.setTranslationY(view, -deltaY);
+        }
+        mPendingMoves.add(new MoveInfo(holder, fromX, fromY, toX, toY));
+        return true;
+    }
+
+    private void animateMoveImpl(final ViewHolder holder, int fromX, int fromY, int toX, int toY) {
+        final View view = holder.itemView;
+        final int deltaX = toX - fromX;
+        final int deltaY = toY - fromY;
+        if (deltaX != 0) {
+            ViewCompat.animate(view).translationX(0);
+        }
+        if (deltaY != 0) {
+            ViewCompat.animate(view).translationY(0);
+        }
+        // TODO: make EndActions end listeners instead, since end actions aren't called when
+        // vpas are canceled (and can't end them. why?)
+        // need listener functionality in VPACompat for this. Ick.
+        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);
+        mMoveAnimations.add(holder);
+        animation.setDuration(getMoveDuration()).setListener(new VpaListenerAdapter() {
+            @Override
+            public void onAnimationStart(View view) {
+                dispatchMoveStarting(holder);
+            }
+            @Override
+            public void onAnimationCancel(View view) {
+                if (deltaX != 0) {
+                    ViewCompat.setTranslationX(view, 0);
+                }
+                if (deltaY != 0) {
+                    ViewCompat.setTranslationY(view, 0);
+                }
+            }
+            @Override
+            public void onAnimationEnd(View view) {
+                animation.setListener(null);
+                dispatchMoveFinished(holder);
+                mMoveAnimations.remove(holder);
+                dispatchFinishedWhenDone();
+            }
+        }).start();
+    }
+
+    @Override
+    public boolean animateChange(ViewHolder oldHolder, ViewHolder newHolder,
+            int fromX, int fromY, int toX, int toY) {
+        final float prevTranslationX = ViewCompat.getTranslationX(oldHolder.itemView);
+        final float prevTranslationY = ViewCompat.getTranslationY(oldHolder.itemView);
+        final float prevAlpha = ViewCompat.getAlpha(oldHolder.itemView);
+        endAnimation(oldHolder);
+        int deltaX = (int) (toX - fromX - prevTranslationX);
+        int deltaY = (int) (toY - fromY - prevTranslationY);
+        // recover prev translation state after ending animation
+        ViewCompat.setTranslationX(oldHolder.itemView, prevTranslationX);
+        ViewCompat.setTranslationY(oldHolder.itemView, prevTranslationY);
+        ViewCompat.setAlpha(oldHolder.itemView, prevAlpha);
+        if (newHolder != null && newHolder.itemView != null) {
+            // carry over translation values
+            endAnimation(newHolder);
+            ViewCompat.setTranslationX(newHolder.itemView, -deltaX);
+            ViewCompat.setTranslationY(newHolder.itemView, -deltaY);
+            ViewCompat.setAlpha(newHolder.itemView, 0);
+        }
+        mPendingChanges.add(new ChangeInfo(oldHolder, newHolder, fromX, fromY, toX, toY));
+        return true;
+    }
+
+    private void animateChangeImpl(final ChangeInfo changeInfo) {
+        final ViewHolder holder = changeInfo.oldHolder;
+        final View view = holder == null ? null : holder.itemView;
+        final ViewHolder newHolder = changeInfo.newHolder;
+        final View newView = newHolder != null ? newHolder.itemView : null;
+        if (view != null) {
+            final ViewPropertyAnimatorCompat oldViewAnim = ViewCompat.animate(view).setDuration(
+                    getChangeDuration());
+            mChangeAnimations.add(changeInfo.oldHolder);
+            oldViewAnim.translationX(changeInfo.toX - changeInfo.fromX);
+            oldViewAnim.translationY(changeInfo.toY - changeInfo.fromY);
+            oldViewAnim.alpha(0).setListener(new VpaListenerAdapter() {
+                @Override
+                public void onAnimationStart(View view) {
+                    dispatchChangeStarting(changeInfo.oldHolder, true);
+                }
+
+                @Override
+                public void onAnimationEnd(View view) {
+                    oldViewAnim.setListener(null);
+                    ViewCompat.setAlpha(view, 1);
+                    ViewCompat.setTranslationX(view, 0);
+                    ViewCompat.setTranslationY(view, 0);
+                    dispatchChangeFinished(changeInfo.oldHolder, true);
+                    mChangeAnimations.remove(changeInfo.oldHolder);
+                    dispatchFinishedWhenDone();
+                }
+            }).start();
+        }
+        if (newView != null) {
+            final ViewPropertyAnimatorCompat newViewAnimation = ViewCompat.animate(newView);
+            mChangeAnimations.add(changeInfo.newHolder);
+            newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration()).
+                    alpha(1).setListener(new VpaListenerAdapter() {
+                @Override
+                public void onAnimationStart(View view) {
+                    dispatchChangeStarting(changeInfo.newHolder, false);
+                }
+                @Override
+                public void onAnimationEnd(View view) {
+                    newViewAnimation.setListener(null);
+                    ViewCompat.setAlpha(newView, 1);
+                    ViewCompat.setTranslationX(newView, 0);
+                    ViewCompat.setTranslationY(newView, 0);
+                    dispatchChangeFinished(changeInfo.newHolder, false);
+                    mChangeAnimations.remove(changeInfo.newHolder);
+                    dispatchFinishedWhenDone();
+                }
+            }).start();
+        }
+    }
+
+    private void endChangeAnimation(List<ChangeInfo> infoList, ViewHolder item) {
+        for (int i = infoList.size() - 1; i >= 0; i--) {
+            ChangeInfo changeInfo = infoList.get(i);
+            if (endChangeAnimationIfNecessary(changeInfo, item)) {
+                if (changeInfo.oldHolder == null && changeInfo.newHolder == null) {
+                    infoList.remove(changeInfo);
+                }
+            }
+        }
+    }
+
+    private void endChangeAnimationIfNecessary(ChangeInfo changeInfo) {
+        if (changeInfo.oldHolder != null) {
+            endChangeAnimationIfNecessary(changeInfo, changeInfo.oldHolder);
+        }
+        if (changeInfo.newHolder != null) {
+            endChangeAnimationIfNecessary(changeInfo, changeInfo.newHolder);
+        }
+    }
+    private boolean endChangeAnimationIfNecessary(ChangeInfo changeInfo, ViewHolder item) {
+        boolean oldItem = false;
+        if (changeInfo.newHolder == item) {
+            changeInfo.newHolder = null;
+        } else if (changeInfo.oldHolder == item) {
+            changeInfo.oldHolder = null;
+            oldItem = true;
+        } else {
+            return false;
+        }
+        ViewCompat.setAlpha(item.itemView, 1);
+        ViewCompat.setTranslationX(item.itemView, 0);
+        ViewCompat.setTranslationY(item.itemView, 0);
+        dispatchChangeFinished(item, oldItem);
+        return true;
+    }
+
+    @Override
+    public void endAnimation(ViewHolder item) {
+        final View view = item.itemView;
+        // this will trigger end callback which should set properties to their target values.
+        ViewCompat.animate(view).cancel();
+        // TODO if some other animations are chained to end, how do we cancel them as well?
+        for (int i = mPendingMoves.size() - 1; i >= 0; i--) {
+            MoveInfo moveInfo = mPendingMoves.get(i);
+            if (moveInfo.holder == item) {
+                ViewCompat.setTranslationY(view, 0);
+                ViewCompat.setTranslationX(view, 0);
+                dispatchMoveFinished(item);
+                mPendingMoves.remove(i);
+            }
+        }
+        endChangeAnimation(mPendingChanges, item);
+        if (mPendingRemovals.remove(item)) {
+            ViewCompat.setAlpha(view, 1);
+            dispatchRemoveFinished(item);
+        }
+        if (mPendingAdditions.remove(item)) {
+            ViewCompat.setAlpha(view, 1);
+            dispatchAddFinished(item);
+        }
+
+        for (int i = mChangesList.size() - 1; i >= 0; i--) {
+            ArrayList<ChangeInfo> changes = mChangesList.get(i);
+            endChangeAnimation(changes, item);
+            if (changes.isEmpty()) {
+                mChangesList.remove(i);
+            }
+        }
+        for (int i = mMovesList.size() - 1; i >= 0; i--) {
+            ArrayList<MoveInfo> moves = mMovesList.get(i);
+            for (int j = moves.size() - 1; j >= 0; j--) {
+                MoveInfo moveInfo = moves.get(j);
+                if (moveInfo.holder == item) {
+                    ViewCompat.setTranslationY(view, 0);
+                    ViewCompat.setTranslationX(view, 0);
+                    dispatchMoveFinished(item);
+                    moves.remove(j);
+                    if (moves.isEmpty()) {
+                        mMovesList.remove(i);
+                    }
+                    break;
+                }
+            }
+        }
+        for (int i = mAdditionsList.size() - 1; i >= 0; i--) {
+            ArrayList<ViewHolder> additions = mAdditionsList.get(i);
+            if (additions.remove(item)) {
+                ViewCompat.setAlpha(view, 1);
+                dispatchAddFinished(item);
+                if (additions.isEmpty()) {
+                    mAdditionsList.remove(i);
+                }
+            }
+        }
+
+        // animations should be ended by the cancel above.
+        if (mRemoveAnimations.remove(item) && DEBUG) {
+            throw new IllegalStateException("after animation is cancelled, item should not be in "
+                    + "mRemoveAnimations list");
+        }
+
+        if (mAddAnimations.remove(item) && DEBUG) {
+            throw new IllegalStateException("after animation is cancelled, item should not be in "
+                    + "mAddAnimations list");
+        }
+
+        if (mChangeAnimations.remove(item) && DEBUG) {
+            throw new IllegalStateException("after animation is cancelled, item should not be in "
+                    + "mChangeAnimations list");
+        }
+
+        if (mMoveAnimations.remove(item) && DEBUG) {
+            throw new IllegalStateException("after animation is cancelled, item should not be in "
+                    + "mMoveAnimations list");
+        }
+        dispatchFinishedWhenDone();
+    }
+
+    @Override
+    public boolean isRunning() {
+        return (!mPendingAdditions.isEmpty() ||
+                !mPendingChanges.isEmpty() ||
+                !mPendingMoves.isEmpty() ||
+                !mPendingRemovals.isEmpty() ||
+                !mMoveAnimations.isEmpty() ||
+                !mRemoveAnimations.isEmpty() ||
+                !mAddAnimations.isEmpty() ||
+                !mChangeAnimations.isEmpty() ||
+                !mMovesList.isEmpty() ||
+                !mAdditionsList.isEmpty() ||
+                !mChangesList.isEmpty());
+    }
+
+    /**
+     * Check the state of currently pending and running animations. If there are none
+     * pending/running, call {@link #dispatchAnimationsFinished()} to notify any
+     * listeners.
+     */
+    private void dispatchFinishedWhenDone() {
+        if (!isRunning()) {
+            dispatchAnimationsFinished();
+        }
+    }
+
+    @Override
+    public void endAnimations() {
+        int count = mPendingMoves.size();
+        for (int i = count - 1; i >= 0; i--) {
+            MoveInfo item = mPendingMoves.get(i);
+            View view = item.holder.itemView;
+            ViewCompat.setTranslationY(view, 0);
+            ViewCompat.setTranslationX(view, 0);
+            dispatchMoveFinished(item.holder);
+            mPendingMoves.remove(i);
+        }
+        count = mPendingRemovals.size();
+        for (int i = count - 1; i >= 0; i--) {
+            ViewHolder item = mPendingRemovals.get(i);
+            dispatchRemoveFinished(item);
+            mPendingRemovals.remove(i);
+        }
+        count = mPendingAdditions.size();
+        for (int i = count - 1; i >= 0; i--) {
+            ViewHolder item = mPendingAdditions.get(i);
+            View view = item.itemView;
+            ViewCompat.setAlpha(view, 1);
+            dispatchAddFinished(item);
+            mPendingAdditions.remove(i);
+        }
+        count = mPendingChanges.size();
+        for (int i = count - 1; i >= 0; i--) {
+            endChangeAnimationIfNecessary(mPendingChanges.get(i));
+        }
+        mPendingChanges.clear();
+        if (!isRunning()) {
+            return;
+        }
+
+        int listCount = mMovesList.size();
+        for (int i = listCount - 1; i >= 0; i--) {
+            ArrayList<MoveInfo> moves = mMovesList.get(i);
+            count = moves.size();
+            for (int j = count - 1; j >= 0; j--) {
+                MoveInfo moveInfo = moves.get(j);
+                ViewHolder item = moveInfo.holder;
+                View view = item.itemView;
+                ViewCompat.setTranslationY(view, 0);
+                ViewCompat.setTranslationX(view, 0);
+                dispatchMoveFinished(moveInfo.holder);
+                moves.remove(j);
+                if (moves.isEmpty()) {
+                    mMovesList.remove(moves);
+                }
+            }
+        }
+        listCount = mAdditionsList.size();
+        for (int i = listCount - 1; i >= 0; i--) {
+            ArrayList<ViewHolder> additions = mAdditionsList.get(i);
+            count = additions.size();
+            for (int j = count - 1; j >= 0; j--) {
+                ViewHolder item = additions.get(j);
+                View view = item.itemView;
+                ViewCompat.setAlpha(view, 1);
+                dispatchAddFinished(item);
+                additions.remove(j);
+                if (additions.isEmpty()) {
+                    mAdditionsList.remove(additions);
+                }
+            }
+        }
+        listCount = mChangesList.size();
+        for (int i = listCount - 1; i >= 0; i--) {
+            ArrayList<ChangeInfo> changes = mChangesList.get(i);
+            count = changes.size();
+            for (int j = count - 1; j >= 0; j--) {
+                endChangeAnimationIfNecessary(changes.get(j));
+                if (changes.isEmpty()) {
+                    mChangesList.remove(changes);
+                }
+            }
+        }
+
+        cancelAll(mRemoveAnimations);
+        cancelAll(mMoveAnimations);
+        cancelAll(mAddAnimations);
+        cancelAll(mChangeAnimations);
+
+        dispatchAnimationsFinished();
+    }
+
+    void cancelAll(List<ViewHolder> viewHolders) {
+        for (int i = viewHolders.size() - 1; i >= 0; i--) {
+            ViewCompat.animate(viewHolders.get(i).itemView).cancel();
+        }
+    }
+
+    private static class VpaListenerAdapter implements ViewPropertyAnimatorListener {
+        @Override
+        public void onAnimationStart(View view) {}
+
+        @Override
+        public void onAnimationEnd(View view) {}
+
+        @Override
+        public void onAnimationCancel(View view) {}
+    };
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/GridLayoutManager.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/GridLayoutManager.java
new file mode 100644
index 000000000..790bf06f8
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/GridLayoutManager.java
@@ -0,0 +1,887 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific languag`e governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.android.support.widget;
+
+import android.content.Context;
+import android.graphics.Rect;
+import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.SparseIntArray;
+import android.view.View;
+import android.view.ViewGroup;
+
+import java.util.Arrays;
+
+/**
+ * A {@link RecyclerView.LayoutManager} implementations that lays out items in a grid.
+ * <p>
+ * By default, each item occupies 1 span. You can change it by providing a custom
+ * {@link SpanSizeLookup} instance via {@link #setSpanSizeLookup(SpanSizeLookup)}.
+ */
+public class GridLayoutManager extends LinearLayoutManager {
+
+    private static final boolean DEBUG = false;
+    private static final String TAG = "GridLayoutManager";
+    public static final int DEFAULT_SPAN_COUNT = -1;
+    /**
+     * The measure spec for the scroll direction.
+     */
+    static final int MAIN_DIR_SPEC =
+            View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+    /**
+     * Span size have been changed but we've not done a new layout calculation.
+     */
+    boolean mPendingSpanCountChange = false;
+    int mSpanCount = DEFAULT_SPAN_COUNT;
+    /**
+     * Right borders for each span.
+     * <p>For <b>i-th</b> item start is {@link #mCachedBorders}[i-1] + 1
+     * and end is {@link #mCachedBorders}[i].
+     */
+    int [] mCachedBorders;
+    /**
+     * Temporary array to keep views in layoutChunk method
+     */
+    View[] mSet;
+    final SparseIntArray mPreLayoutSpanSizeCache = new SparseIntArray();
+    final SparseIntArray mPreLayoutSpanIndexCache = new SparseIntArray();
+    SpanSizeLookup mSpanSizeLookup = new DefaultSpanSizeLookup();
+    // re-used variable to acquire decor insets from RecyclerView
+    final Rect mDecorInsets = new Rect();
+
+    /**
+     * Creates a vertical GridLayoutManager
+     *
+     * @param context Current context, will be used to access resources.
+     * @param spanCount The number of columns in the grid
+     */
+    public GridLayoutManager(Context context, int spanCount) {
+        super(context);
+        setSpanCount(spanCount);
+    }
+
+    /**
+     * @param context Current context, will be used to access resources.
+     * @param spanCount The number of columns or rows in the grid
+     * @param orientation Layout orientation. Should be {@link #HORIZONTAL} or {@link
+     *                      #VERTICAL}.
+     * @param reverseLayout When set to true, layouts from end to start.
+     */
+    public GridLayoutManager(Context context, int spanCount, int orientation,
+            boolean reverseLayout) {
+        super(context, orientation, reverseLayout);
+        setSpanCount(spanCount);
+    }
+
+    /**
+     * stackFromEnd is not supported by GridLayoutManager. Consider using
+     * {@link #setReverseLayout(boolean)}.
+     */
+    @Override
+    public void setStackFromEnd(boolean stackFromEnd) {
+        if (stackFromEnd) {
+            throw new UnsupportedOperationException(
+                    "GridLayoutManager does not support stack from end."
+                            + " Consider using reverse layout");
+        }
+        super.setStackFromEnd(false);
+    }
+
+    @Override
+    public int getRowCountForAccessibility(RecyclerView.Recycler recycler,
+            RecyclerView.State state) {
+        if (mOrientation == HORIZONTAL) {
+            return mSpanCount;
+        }
+        if (state.getItemCount() < 1) {
+            return 0;
+        }
+        return getSpanGroupIndex(recycler, state, state.getItemCount() - 1);
+    }
+
+    @Override
+    public int getColumnCountForAccessibility(RecyclerView.Recycler recycler,
+            RecyclerView.State state) {
+        if (mOrientation == VERTICAL) {
+            return mSpanCount;
+        }
+        if (state.getItemCount() < 1) {
+            return 0;
+        }
+        return getSpanGroupIndex(recycler, state, state.getItemCount() - 1);
+    }
+
+    @Override
+    public void onInitializeAccessibilityNodeInfoForItem(RecyclerView.Recycler recycler,
+            RecyclerView.State state, View host, AccessibilityNodeInfoCompat info) {
+        ViewGroup.LayoutParams lp = host.getLayoutParams();
+        if (!(lp instanceof LayoutParams)) {
+            super.onInitializeAccessibilityNodeInfoForItem(host, info);
+            return;
+        }
+        LayoutParams glp = (LayoutParams) lp;
+        int spanGroupIndex = getSpanGroupIndex(recycler, state, glp.getViewLayoutPosition());
+        if (mOrientation == HORIZONTAL) {
+            info.setCollectionItemInfo(AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(
+                    glp.getSpanIndex(), glp.getSpanSize(),
+                    spanGroupIndex, 1,
+                    mSpanCount > 1 && glp.getSpanSize() == mSpanCount, false));
+        } else { // VERTICAL
+            info.setCollectionItemInfo(AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(
+                    spanGroupIndex , 1,
+                    glp.getSpanIndex(), glp.getSpanSize(),
+                    mSpanCount > 1 && glp.getSpanSize() == mSpanCount, false));
+        }
+    }
+
+    @Override
+    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
+        if (state.isPreLayout()) {
+            cachePreLayoutSpanMapping();
+        }
+        super.onLayoutChildren(recycler, state);
+        if (DEBUG) {
+            validateChildOrder();
+        }
+        clearPreLayoutSpanMappingCache();
+        if (!state.isPreLayout()) {
+            mPendingSpanCountChange = false;
+        }
+    }
+
+    private void clearPreLayoutSpanMappingCache() {
+        mPreLayoutSpanSizeCache.clear();
+        mPreLayoutSpanIndexCache.clear();
+    }
+
+    private void cachePreLayoutSpanMapping() {
+        final int childCount = getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final LayoutParams lp = (LayoutParams) getChildAt(i).getLayoutParams();
+            final int viewPosition = lp.getViewLayoutPosition();
+            mPreLayoutSpanSizeCache.put(viewPosition, lp.getSpanSize());
+            mPreLayoutSpanIndexCache.put(viewPosition, lp.getSpanIndex());
+        }
+    }
+
+    @Override
+    public void onItemsAdded(RecyclerView recyclerView, int positionStart, int itemCount) {
+        mSpanSizeLookup.invalidateSpanIndexCache();
+    }
+
+    @Override
+    public void onItemsChanged(RecyclerView recyclerView) {
+        mSpanSizeLookup.invalidateSpanIndexCache();
+    }
+
+    @Override
+    public void onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount) {
+        mSpanSizeLookup.invalidateSpanIndexCache();
+    }
+
+    @Override
+    public void onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount) {
+        mSpanSizeLookup.invalidateSpanIndexCache();
+    }
+
+    @Override
+    public void onItemsMoved(RecyclerView recyclerView, int from, int to, int itemCount) {
+        mSpanSizeLookup.invalidateSpanIndexCache();
+    }
+
+    @Override
+    public RecyclerView.LayoutParams generateDefaultLayoutParams() {
+        return new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
+                ViewGroup.LayoutParams.WRAP_CONTENT);
+    }
+
+    @Override
+    public RecyclerView.LayoutParams generateLayoutParams(Context c, AttributeSet attrs) {
+        return new LayoutParams(c, attrs);
+    }
+
+    @Override
+    public RecyclerView.LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp) {
+        if (lp instanceof ViewGroup.MarginLayoutParams) {
+            return new LayoutParams((ViewGroup.MarginLayoutParams) lp);
+        } else {
+            return new LayoutParams(lp);
+        }
+    }
+
+    @Override
+    public boolean checkLayoutParams(RecyclerView.LayoutParams lp) {
+        return lp instanceof LayoutParams;
+    }
+
+    /**
+     * Sets the source to get the number of spans occupied by each item in the adapter.
+     *
+     * @param spanSizeLookup {@link SpanSizeLookup} instance to be used to query number of spans
+     *                       occupied by each item
+     */
+    public void setSpanSizeLookup(SpanSizeLookup spanSizeLookup) {
+        mSpanSizeLookup = spanSizeLookup;
+    }
+
+    /**
+     * Returns the current {@link SpanSizeLookup} used by the GridLayoutManager.
+     *
+     * @return The current {@link SpanSizeLookup} used by the GridLayoutManager.
+     */
+    public SpanSizeLookup getSpanSizeLookup() {
+        return mSpanSizeLookup;
+    }
+
+    private void updateMeasurements() {
+        int totalSpace;
+        if (getOrientation() == VERTICAL) {
+            totalSpace = getWidth() - getPaddingRight() - getPaddingLeft();
+        } else {
+            totalSpace = getHeight() - getPaddingBottom() - getPaddingTop();
+        }
+        calculateItemBorders(totalSpace);
+    }
+
+    private void calculateItemBorders(int totalSpace) {
+        if (mCachedBorders == null || mCachedBorders.length != mSpanCount + 1
+                || mCachedBorders[mCachedBorders.length - 1] != totalSpace) {
+            mCachedBorders = new int[mSpanCount + 1];
+        }
+        mCachedBorders[0] = 0;
+        int sizePerSpan = totalSpace / mSpanCount;
+        int sizePerSpanRemainder = totalSpace % mSpanCount;
+        int consumedPixels = 0;
+        int additionalSize = 0;
+        for (int i = 1; i <= mSpanCount; i++) {
+            int itemSize = sizePerSpan;
+            additionalSize += sizePerSpanRemainder;
+            if (additionalSize > 0 && (mSpanCount - additionalSize) < sizePerSpanRemainder) {
+                itemSize += 1;
+                additionalSize -= mSpanCount;
+            }
+            consumedPixels += itemSize;
+            mCachedBorders[i] = consumedPixels;
+        }
+    }
+
+    @Override
+    void onAnchorReady(RecyclerView.State state, AnchorInfo anchorInfo) {
+        super.onAnchorReady(state, anchorInfo);
+        updateMeasurements();
+        if (state.getItemCount() > 0 && !state.isPreLayout()) {
+            ensureAnchorIsInFirstSpan(anchorInfo);
+        }
+        if (mSet == null || mSet.length != mSpanCount) {
+            mSet = new View[mSpanCount];
+        }
+    }
+
+    private void ensureAnchorIsInFirstSpan(AnchorInfo anchorInfo) {
+        int span = mSpanSizeLookup.getCachedSpanIndex(anchorInfo.mPosition, mSpanCount);
+        while (span > 0 && anchorInfo.mPosition > 0) {
+            anchorInfo.mPosition--;
+            span = mSpanSizeLookup.getCachedSpanIndex(anchorInfo.mPosition, mSpanCount);
+        }
+    }
+
+    @Override
+    View findReferenceChild(int start, int end, int itemCount) {
+        ensureLayoutState();
+        View invalidMatch = null;
+        View outOfBoundsMatch = null;
+        final int boundsStart = mOrientationHelper.getStartAfterPadding();
+        final int boundsEnd = mOrientationHelper.getEndAfterPadding();
+        final int diff = end > start ? 1 : -1;
+        for (int i = start; i != end; i += diff) {
+            final View view = getChildAt(i);
+            final int position = getPosition(view);
+            if (position >= 0 && position < itemCount) {
+                final int span = mSpanSizeLookup.getCachedSpanIndex(position, mSpanCount);
+                if (span != 0) {
+                    continue;
+                }
+                if (((RecyclerView.LayoutParams) view.getLayoutParams()).isItemRemoved()) {
+                    if (invalidMatch == null) {
+                        invalidMatch = view; // removed item, least preferred
+                    }
+                } else if (mOrientationHelper.getDecoratedStart(view) >= boundsEnd ||
+                        mOrientationHelper.getDecoratedEnd(view) < boundsStart) {
+                    if (outOfBoundsMatch == null) {
+                        outOfBoundsMatch = view; // item is not visible, less preferred
+                    }
+                } else {
+                    return view;
+                }
+            }
+        }
+        return outOfBoundsMatch != null ? outOfBoundsMatch : invalidMatch;
+    }
+
+    private int getSpanGroupIndex(RecyclerView.Recycler recycler, RecyclerView.State state,
+            int viewPosition) {
+        if (!state.isPreLayout()) {
+            return mSpanSizeLookup.getSpanGroupIndex(viewPosition, mSpanCount);
+        }
+        final int adapterPosition = recycler.convertPreLayoutPositionToPostLayout(viewPosition);
+        if (adapterPosition == -1) {
+            if (DEBUG) {
+                throw new RuntimeException("Cannot find span group index for position "
+                        + viewPosition);
+            }
+            Log.w(TAG, "Cannot find span size for pre layout position. " + viewPosition);
+            return 0;
+        }
+        return mSpanSizeLookup.getSpanGroupIndex(adapterPosition, mSpanCount);
+    }
+
+    private int getSpanIndex(RecyclerView.Recycler recycler, RecyclerView.State state, int pos) {
+        if (!state.isPreLayout()) {
+            return mSpanSizeLookup.getCachedSpanIndex(pos, mSpanCount);
+        }
+        final int cached = mPreLayoutSpanIndexCache.get(pos, -1);
+        if (cached != -1) {
+            return cached;
+        }
+        final int adapterPosition = recycler.convertPreLayoutPositionToPostLayout(pos);
+        if (adapterPosition == -1) {
+            if (DEBUG) {
+                throw new RuntimeException("Cannot find span index for pre layout position. It is"
+                        + " not cached, not in the adapter. Pos:" + pos);
+            }
+            Log.w(TAG, "Cannot find span size for pre layout position. It is"
+                    + " not cached, not in the adapter. Pos:" + pos);
+            return 0;
+        }
+        return mSpanSizeLookup.getCachedSpanIndex(adapterPosition, mSpanCount);
+    }
+
+    private int getSpanSize(RecyclerView.Recycler recycler, RecyclerView.State state, int pos) {
+        if (!state.isPreLayout()) {
+            return mSpanSizeLookup.getSpanSize(pos);
+        }
+        final int cached = mPreLayoutSpanSizeCache.get(pos, -1);
+        if (cached != -1) {
+            return cached;
+        }
+        final int adapterPosition = recycler.convertPreLayoutPositionToPostLayout(pos);
+        if (adapterPosition == -1) {
+            if (DEBUG) {
+                throw new RuntimeException("Cannot find span size for pre layout position. It is"
+                        + " not cached, not in the adapter. Pos:" + pos);
+            }
+            Log.w(TAG, "Cannot find span size for pre layout position. It is"
+                    + " not cached, not in the adapter. Pos:" + pos);
+            return 1;
+        }
+        return mSpanSizeLookup.getSpanSize(adapterPosition);
+    }
+
+    @Override
+    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
+            LayoutState layoutState, LayoutChunkResult result) {
+        final boolean layingOutInPrimaryDirection =
+                layoutState.mItemDirection == LayoutState.ITEM_DIRECTION_TAIL;
+        int count = 0;
+        int consumedSpanCount = 0;
+        int remainingSpan = mSpanCount;
+        if (!layingOutInPrimaryDirection) {
+            int itemSpanIndex = getSpanIndex(recycler, state, layoutState.mCurrentPosition);
+            int itemSpanSize = getSpanSize(recycler, state, layoutState.mCurrentPosition);
+            remainingSpan = itemSpanIndex + itemSpanSize;
+        }
+        while (count < mSpanCount && layoutState.hasMore(state) && remainingSpan > 0) {
+            int pos = layoutState.mCurrentPosition;
+            final int spanSize = getSpanSize(recycler, state, pos);
+            if (spanSize > mSpanCount) {
+                throw new IllegalArgumentException("Item at position " + pos + " requires " +
+                        spanSize + " spans but GridLayoutManager has only " + mSpanCount
+                        + " spans.");
+            }
+            remainingSpan -= spanSize;
+            if (remainingSpan < 0) {
+                break; // item did not fit into this row or column
+            }
+            View view = layoutState.next(recycler);
+            if (view == null) {
+                break;
+            }
+            consumedSpanCount += spanSize;
+            mSet[count] = view;
+            count++;
+        }
+
+        if (count == 0) {
+            result.mFinished = true;
+            return;
+        }
+
+        int maxSize = 0;
+
+        // we should assign spans before item decor offsets are calculated
+        assignSpans(recycler, state, count, consumedSpanCount, layingOutInPrimaryDirection);
+        for (int i = 0; i < count; i++) {
+            View view = mSet[i];
+            if (layoutState.mScrapList == null) {
+                if (layingOutInPrimaryDirection) {
+                    addView(view);
+                } else {
+                    addView(view, 0);
+                }
+            } else {
+                if (layingOutInPrimaryDirection) {
+                    addDisappearingView(view);
+                } else {
+                    addDisappearingView(view, 0);
+                }
+            }
+
+            final LayoutParams lp = (LayoutParams) view.getLayoutParams();
+            final int spec = View.MeasureSpec.makeMeasureSpec(
+                    mCachedBorders[lp.mSpanIndex + lp.mSpanSize] -
+                            mCachedBorders[lp.mSpanIndex],
+                    View.MeasureSpec.EXACTLY);
+            if (mOrientation == VERTICAL) {
+                measureChildWithDecorationsAndMargin(view, spec, getMainDirSpec(lp.height));
+            } else {
+                measureChildWithDecorationsAndMargin(view, getMainDirSpec(lp.width), spec);
+            }
+            final int size = mOrientationHelper.getDecoratedMeasurement(view);
+            if (size > maxSize) {
+                maxSize = size;
+            }
+        }
+
+        // views that did not measure the maxSize has to be re-measured
+        final int maxMeasureSpec = getMainDirSpec(maxSize);
+        for (int i = 0; i < count; i ++) {
+            final View view = mSet[i];
+            if (mOrientationHelper.getDecoratedMeasurement(view) != maxSize) {
+                final LayoutParams lp = (LayoutParams) view.getLayoutParams();
+                final int spec = View.MeasureSpec.makeMeasureSpec(
+                        mCachedBorders[lp.mSpanIndex + lp.mSpanSize] -
+                                mCachedBorders[lp.mSpanIndex],
+                        View.MeasureSpec.EXACTLY);
+                if (mOrientation == VERTICAL) {
+                    measureChildWithDecorationsAndMargin(view, spec, maxMeasureSpec);
+                } else {
+                    measureChildWithDecorationsAndMargin(view, maxMeasureSpec, spec);
+                }
+            }
+        }
+
+        result.mConsumed = maxSize;
+
+        int left = 0, right = 0, top = 0, bottom = 0;
+        if (mOrientation == VERTICAL) {
+            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
+                bottom = layoutState.mOffset;
+                top = bottom - maxSize;
+            } else {
+                top = layoutState.mOffset;
+                bottom = top + maxSize;
+            }
+        } else {
+            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
+                right = layoutState.mOffset;
+                left = right - maxSize;
+            } else {
+                left = layoutState.mOffset;
+                right = left + maxSize;
+            }
+        }
+        for (int i = 0; i < count; i++) {
+            View view = mSet[i];
+            LayoutParams params = (LayoutParams) view.getLayoutParams();
+            if (mOrientation == VERTICAL) {
+                left = getPaddingLeft() + mCachedBorders[params.mSpanIndex];
+                right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);
+            } else {
+                top = getPaddingTop() + mCachedBorders[params.mSpanIndex];
+                bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);
+            }
+            // We calculate everything with View's bounding box (which includes decor and margins)
+            // To calculate correct layout position, we subtract margins.
+            layoutDecorated(view, left + params.leftMargin, top + params.topMargin,
+                    right - params.rightMargin, bottom - params.bottomMargin);
+            if (DEBUG) {
+                Log.d(TAG, "laid out child at position " + getPosition(view) + ", with l:"
+                        + (left + params.leftMargin) + ", t:" + (top + params.topMargin) + ", r:"
+                        + (right - params.rightMargin) + ", b:" + (bottom - params.bottomMargin)
+                        + ", span:" + params.mSpanIndex + ", spanSize:" + params.mSpanSize);
+            }
+            // Consume the available space if the view is not removed OR changed
+            if (params.isItemRemoved() || params.isItemChanged()) {
+                result.mIgnoreConsumed = true;
+            }
+            result.mFocusable |= view.isFocusable();
+        }
+        Arrays.fill(mSet, null);
+    }
+
+    private int getMainDirSpec(int dim) {
+        if (dim < 0) {
+            return MAIN_DIR_SPEC;
+        } else {
+            return View.MeasureSpec.makeMeasureSpec(dim, View.MeasureSpec.EXACTLY);
+        }
+    }
+
+    private void measureChildWithDecorationsAndMargin(View child, int widthSpec, int heightSpec) {
+        calculateItemDecorationsForChild(child, mDecorInsets);
+        RecyclerView.LayoutParams lp = (RecyclerView.LayoutParams) child.getLayoutParams();
+        widthSpec = updateSpecWithExtra(widthSpec, lp.leftMargin + mDecorInsets.left,
+                lp.rightMargin + mDecorInsets.right);
+        heightSpec = updateSpecWithExtra(heightSpec, lp.topMargin + mDecorInsets.top,
+                lp.bottomMargin + mDecorInsets.bottom);
+        child.measure(widthSpec, heightSpec);
+    }
+
+    private int updateSpecWithExtra(int spec, int startInset, int endInset) {
+        if (startInset == 0 && endInset == 0) {
+            return spec;
+        }
+        final int mode = View.MeasureSpec.getMode(spec);
+        if (mode == View.MeasureSpec.AT_MOST || mode == View.MeasureSpec.EXACTLY) {
+            return View.MeasureSpec.makeMeasureSpec(
+                    View.MeasureSpec.getSize(spec) - startInset - endInset, mode);
+        }
+        return spec;
+    }
+
+    private void assignSpans(RecyclerView.Recycler recycler, RecyclerView.State state, int count,
+            int consumedSpanCount, boolean layingOutInPrimaryDirection) {
+        int span, spanDiff, start, end, diff;
+        // make sure we traverse from min position to max position
+        if (layingOutInPrimaryDirection) {
+            start = 0;
+            end = count;
+            diff = 1;
+        } else {
+            start = count - 1;
+            end = -1;
+            diff = -1;
+        }
+        if (mOrientation == VERTICAL && isLayoutRTL()) { // start from last span
+            span = mSpanCount - 1;
+            spanDiff = -1;
+        } else {
+            span = 0;
+            spanDiff = 1;
+        }
+        for (int i = start; i != end; i += diff) {
+            View view = mSet[i];
+            LayoutParams params = (LayoutParams) view.getLayoutParams();
+            params.mSpanSize = getSpanSize(recycler, state, getPosition(view));
+            if (spanDiff == -1 && params.mSpanSize > 1) {
+                params.mSpanIndex = span - (params.mSpanSize - 1);
+            } else {
+                params.mSpanIndex = span;
+            }
+            span += spanDiff * params.mSpanSize;
+        }
+    }
+
+    /**
+     * Returns the number of spans laid out by this grid.
+     *
+     * @return The number of spans
+     * @see #setSpanCount(int)
+     */
+    public int getSpanCount() {
+        return mSpanCount;
+    }
+
+    /**
+     * Sets the number of spans to be laid out.
+     * <p>
+     * If {@link #getOrientation()} is {@link #VERTICAL}, this is the number of columns.
+     * If {@link #getOrientation()} is {@link #HORIZONTAL}, this is the number of rows.
+     *
+     * @param spanCount The total number of spans in the grid
+     * @see #getSpanCount()
+     */
+    public void setSpanCount(int spanCount) {
+        if (spanCount == mSpanCount) {
+            return;
+        }
+        mPendingSpanCountChange = true;
+        if (spanCount < 1) {
+            throw new IllegalArgumentException("Span count should be at least 1. Provided "
+                    + spanCount);
+        }
+        mSpanCount = spanCount;
+        mSpanSizeLookup.invalidateSpanIndexCache();
+    }
+
+    /**
+     * A helper class to provide the number of spans each item occupies.
+     * <p>
+     * Default implementation sets each item to occupy exactly 1 span.
+     *
+     * @see GridLayoutManager#setSpanSizeLookup(SpanSizeLookup)
+     */
+    public static abstract class SpanSizeLookup {
+
+        final SparseIntArray mSpanIndexCache = new SparseIntArray();
+
+        private boolean mCacheSpanIndices = false;
+
+        /**
+         * Returns the number of span occupied by the item at <code>position</code>.
+         *
+         * @param position The adapter position of the item
+         * @return The number of spans occupied by the item at the provided position
+         */
+        abstract public int getSpanSize(int position);
+
+        /**
+         * Sets whether the results of {@link #getSpanIndex(int, int)} method should be cached or
+         * not. By default these values are not cached. If you are not overriding
+         * {@link #getSpanIndex(int, int)}, you should set this to true for better performance.
+         *
+         * @param cacheSpanIndices Whether results of getSpanIndex should be cached or not.
+         */
+        public void setSpanIndexCacheEnabled(boolean cacheSpanIndices) {
+            mCacheSpanIndices = cacheSpanIndices;
+        }
+
+        /**
+         * Clears the span index cache. GridLayoutManager automatically calls this method when
+         * adapter changes occur.
+         */
+        public void invalidateSpanIndexCache() {
+            mSpanIndexCache.clear();
+        }
+
+        /**
+         * Returns whether results of {@link #getSpanIndex(int, int)} method are cached or not.
+         *
+         * @return True if results of {@link #getSpanIndex(int, int)} are cached.
+         */
+        public boolean isSpanIndexCacheEnabled() {
+            return mCacheSpanIndices;
+        }
+
+        int getCachedSpanIndex(int position, int spanCount) {
+            if (!mCacheSpanIndices) {
+                return getSpanIndex(position, spanCount);
+            }
+            final int existing = mSpanIndexCache.get(position, -1);
+            if (existing != -1) {
+                return existing;
+            }
+            final int value = getSpanIndex(position, spanCount);
+            mSpanIndexCache.put(position, value);
+            return value;
+        }
+
+        /**
+         * Returns the final span index of the provided position.
+         * <p>
+         * If you have a faster way to calculate span index for your items, you should override
+         * this method. Otherwise, you should enable span index cache
+         * ({@link #setSpanIndexCacheEnabled(boolean)}) for better performance. When caching is
+         * disabled, default implementation traverses all items from 0 to
+         * <code>position</code>. When caching is enabled, it calculates from the closest cached
+         * value before the <code>position</code>.
+         * <p>
+         * If you override this method, you need to make sure it is consistent with
+         * {@link #getSpanSize(int)}. GridLayoutManager does not call this method for
+         * each item. It is called only for the reference item and rest of the items
+         * are assigned to spans based on the reference item. For example, you cannot assign a
+         * position to span 2 while span 1 is empty.
+         * <p>
+         * Note that span offsets always start with 0 and are not affected by RTL.
+         *
+         * @param position  The position of the item
+         * @param spanCount The total number of spans in the grid
+         * @return The final span position of the item. Should be between 0 (inclusive) and
+         * <code>spanCount</code>(exclusive)
+         */
+        public int getSpanIndex(int position, int spanCount) {
+            int positionSpanSize = getSpanSize(position);
+            if (positionSpanSize == spanCount) {
+                return 0; // quick return for full-span items
+            }
+            int span = 0;
+            int startPos = 0;
+            // If caching is enabled, try to jump
+            if (mCacheSpanIndices && mSpanIndexCache.size() > 0) {
+                int prevKey = findReferenceIndexFromCache(position);
+                if (prevKey >= 0) {
+                    span = mSpanIndexCache.get(prevKey) + getSpanSize(prevKey);
+                    startPos = prevKey + 1;
+                }
+            }
+            for (int i = startPos; i < position; i++) {
+                int size = getSpanSize(i);
+                span += size;
+                if (span == spanCount) {
+                    span = 0;
+                } else if (span > spanCount) {
+                    // did not fit, moving to next row / column
+                    span = size;
+                }
+            }
+            if (span + positionSpanSize <= spanCount) {
+                return span;
+            }
+            return 0;
+        }
+
+        int findReferenceIndexFromCache(int position) {
+            int lo = 0;
+            int hi = mSpanIndexCache.size() - 1;
+
+            while (lo <= hi) {
+                final int mid = (lo + hi) >>> 1;
+                final int midVal = mSpanIndexCache.keyAt(mid);
+                if (midVal < position) {
+                    lo = mid + 1;
+                } else {
+                    hi = mid - 1;
+                }
+            }
+            int index = lo - 1;
+            if (index >= 0 && index < mSpanIndexCache.size()) {
+                return mSpanIndexCache.keyAt(index);
+            }
+            return -1;
+        }
+
+        /**
+         * Returns the index of the group this position belongs.
+         * <p>
+         * For example, if grid has 3 columns and each item occupies 1 span, span group index
+         * for item 1 will be 0, item 5 will be 1.
+         *
+         * @param adapterPosition The position in adapter
+         * @param spanCount The total number of spans in the grid
+         * @return The index of the span group including the item at the given adapter position
+         */
+        public int getSpanGroupIndex(int adapterPosition, int spanCount) {
+            int span = 0;
+            int group = 0;
+            int positionSpanSize = getSpanSize(adapterPosition);
+            for (int i = 0; i < adapterPosition; i++) {
+                int size = getSpanSize(i);
+                span += size;
+                if (span == spanCount) {
+                    span = 0;
+                    group++;
+                } else if (span > spanCount) {
+                    // did not fit, moving to next row / column
+                    span = size;
+                    group++;
+                }
+            }
+            if (span + positionSpanSize > spanCount) {
+                group++;
+            }
+            return group;
+        }
+    }
+
+    @Override
+    public boolean supportsPredictiveItemAnimations() {
+        return mPendingSavedState == null && !mPendingSpanCountChange;
+    }
+
+    /**
+     * Default implementation for {@link SpanSizeLookup}. Each item occupies 1 span.
+     */
+    public static final class DefaultSpanSizeLookup extends SpanSizeLookup {
+
+        @Override
+        public int getSpanSize(int position) {
+            return 1;
+        }
+
+        @Override
+        public int getSpanIndex(int position, int spanCount) {
+            return position % spanCount;
+        }
+    }
+
+    /**
+     * LayoutParams used by GridLayoutManager.
+     * <p>
+     * Note that if the orientation is {@link #VERTICAL}, the width parameter is ignored and if the
+     * orientation is {@link #HORIZONTAL} the height parameter is ignored because child view is
+     * expected to fill all of the space given to it.
+     */
+    public static class LayoutParams extends RecyclerView.LayoutParams {
+
+        /**
+         * Span Id for Views that are not laid out yet.
+         */
+        public static final int INVALID_SPAN_ID = -1;
+
+        private int mSpanIndex = INVALID_SPAN_ID;
+
+        private int mSpanSize = 0;
+
+        public LayoutParams(Context c, AttributeSet attrs) {
+            super(c, attrs);
+        }
+
+        public LayoutParams(int width, int height) {
+            super(width, height);
+        }
+
+        public LayoutParams(ViewGroup.MarginLayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(ViewGroup.LayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(RecyclerView.LayoutParams source) {
+            super(source);
+        }
+
+        /**
+         * Returns the current span index of this View. If the View is not laid out yet, the return
+         * value is <code>undefined</code>.
+         * <p>
+         * Note that span index may change by whether the RecyclerView is RTL or not. For
+         * example, if the number of spans is 3 and layout is RTL, the rightmost item will have
+         * span index of 2. If the layout changes back to LTR, span index for this view will be 0.
+         * If the item was occupying 2 spans, span indices would be 1 and 0 respectively.
+         * <p>
+         * If the View occupies multiple spans, span with the minimum index is returned.
+         *
+         * @return The span index of the View.
+         */
+        public int getSpanIndex() {
+            return mSpanIndex;
+        }
+
+        /**
+         * Returns the number of spans occupied by this View. If the View not laid out yet, the
+         * return value is <code>undefined</code>.
+         *
+         * @return The number of spans occupied by this View.
+         */
+        public int getSpanSize() {
+            return mSpanSize;
+        }
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/LayoutState.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/LayoutState.java
new file mode 100644
index 000000000..c431b6149
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/LayoutState.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific languag`e governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+import android.view.View;
+
+/**
+ * Helper class that keeps temporary state while {LayoutManager} is filling out the empty
+ * space.
+ */
+class LayoutState {
+
+    final static String TAG = "LayoutState";
+
+    final static int LAYOUT_START = -1;
+
+    final static int LAYOUT_END = 1;
+
+    final static int INVALID_LAYOUT = Integer.MIN_VALUE;
+
+    final static int ITEM_DIRECTION_HEAD = -1;
+
+    final static int ITEM_DIRECTION_TAIL = 1;
+
+    final static int SCOLLING_OFFSET_NaN = Integer.MIN_VALUE;
+
+    /**
+     * Number of pixels that we should fill, in the layout direction.
+     */
+    int mAvailable;
+
+    /**
+     * Current position on the adapter to get the next item.
+     */
+    int mCurrentPosition;
+
+    /**
+     * Defines the direction in which the data adapter is traversed.
+     * Should be {@link #ITEM_DIRECTION_HEAD} or {@link #ITEM_DIRECTION_TAIL}
+     */
+    int mItemDirection;
+
+    /**
+     * Defines the direction in which the layout is filled.
+     * Should be {@link #LAYOUT_START} or {@link #LAYOUT_END}
+     */
+    int mLayoutDirection;
+
+    /**
+     * Used if you want to pre-layout items that are not yet visible.
+     * The difference with {@link #mAvailable} is that, when recycling, distance rendered for
+     * {@link #mExtra} is not considered not to recycle visible children.
+     */
+    int mExtra = 0;
+
+    /**
+     * @return true if there are more items in the data adapter
+     */
+    boolean hasMore(RecyclerView.State state) {
+        return mCurrentPosition >= 0 && mCurrentPosition < state.getItemCount();
+    }
+
+    /**
+     * Gets the view for the next element that we should render.
+     * Also updates current item index to the next item, based on {@link #mItemDirection}
+     *
+     * @return The next element that we should render.
+     */
+    View next(RecyclerView.Recycler recycler) {
+        final View view = recycler.getViewForPosition(mCurrentPosition);
+        mCurrentPosition += mItemDirection;
+        return view;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/LinearLayoutManager.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/LinearLayoutManager.java
new file mode 100644
index 000000000..a52bbffe5
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/LinearLayoutManager.java
@@ -0,0 +1,2131 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific languag`e governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+
+import android.content.Context;
+import android.graphics.PointF;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.view.ViewCompat;
+import android.support.v4.view.accessibility.AccessibilityEventCompat;
+import android.support.v4.view.accessibility.AccessibilityRecordCompat;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.accessibility.AccessibilityEvent;
+
+import java.util.List;
+
+import static org.telegram.android.support.widget.RecyclerView.NO_POSITION;
+
+/**
+ * A {@link android.support.v7.widget.RecyclerView.LayoutManager} implementation which provides
+ * similar functionality to {@link android.widget.ListView}.
+ */
+public class LinearLayoutManager extends RecyclerView.LayoutManager {
+
+    private static final String TAG = "LinearLayoutManager";
+
+    private static final boolean DEBUG = false;
+
+    public static final int HORIZONTAL = OrientationHelper.HORIZONTAL;
+
+    public static final int VERTICAL = OrientationHelper.VERTICAL;
+
+    public static final int INVALID_OFFSET = Integer.MIN_VALUE;
+
+
+    /**
+     * While trying to find next view to focus, LayoutManager will not try to scroll more
+     * than this factor times the total space of the list. If layout is vertical, total space is the
+     * height minus padding, if layout is horizontal, total space is the width minus padding.
+     */
+    private static final float MAX_SCROLL_FACTOR = 0.33f;
+
+
+    /**
+     * Current orientation. Either {@link #HORIZONTAL} or {@link #VERTICAL}
+     */
+    int mOrientation;
+
+    /**
+     * Helper class that keeps temporary layout state.
+     * It does not keep state after layout is complete but we still keep a reference to re-use
+     * the same object.
+     */
+    private LayoutState mLayoutState;
+
+    /**
+     * Many calculations are made depending on orientation. To keep it clean, this interface
+     * helps {@link LinearLayoutManager} make those decisions.
+     * Based on {@link #mOrientation}, an implementation is lazily created in
+     * {@link #ensureLayoutState} method.
+     */
+    OrientationHelper mOrientationHelper;
+
+    /**
+     * We need to track this so that we can ignore current position when it changes.
+     */
+    private boolean mLastStackFromEnd;
+
+
+    /**
+     * Defines if layout should be calculated from end to start.
+     *
+     * @see #mShouldReverseLayout
+     */
+    private boolean mReverseLayout = false;
+
+    /**
+     * This keeps the final value for how LayoutManager should start laying out views.
+     * It is calculated by checking {@link #getReverseLayout()} and View's layout direction.
+     * {@link #onLayoutChildren(RecyclerView.Recycler, RecyclerView.State)} is run.
+     */
+    boolean mShouldReverseLayout = false;
+
+    /**
+     * Works the same way as {@link android.widget.AbsListView#setStackFromBottom(boolean)} and
+     * it supports both orientations.
+     * see {@link android.widget.AbsListView#setStackFromBottom(boolean)}
+     */
+    private boolean mStackFromEnd = false;
+
+    /**
+     * Works the same way as {@link android.widget.AbsListView#setSmoothScrollbarEnabled(boolean)}.
+     * see {@link android.widget.AbsListView#setSmoothScrollbarEnabled(boolean)}
+     */
+    private boolean mSmoothScrollbarEnabled = true;
+
+    /**
+     * When LayoutManager needs to scroll to a position, it sets this variable and requests a
+     * layout which will check this variable and re-layout accordingly.
+     */
+    int mPendingScrollPosition = NO_POSITION;
+
+    /**
+     * Used to keep the offset value when {@link #scrollToPositionWithOffset(int, int)} is
+     * called.
+     */
+    int mPendingScrollPositionOffset = INVALID_OFFSET;
+
+    private boolean mRecycleChildrenOnDetach;
+
+    SavedState mPendingSavedState = null;
+
+    /**
+    *  Re-used variable to keep anchor information on re-layout.
+    *  Anchor position and coordinate defines the reference point for LLM while doing a layout.
+    * */
+    final AnchorInfo mAnchorInfo;
+
+    /**
+     * Creates a vertical LinearLayoutManager
+     *
+     * @param context Current context, will be used to access resources.
+     */
+    public LinearLayoutManager(Context context) {
+        this(context, VERTICAL, false);
+    }
+
+    /**
+     * @param context       Current context, will be used to access resources.
+     * @param orientation   Layout orientation. Should be {@link #HORIZONTAL} or {@link
+     *                      #VERTICAL}.
+     * @param reverseLayout When set to true, layouts from end to start.
+     */
+    public LinearLayoutManager(Context context, int orientation, boolean reverseLayout) {
+        mAnchorInfo = new AnchorInfo();
+        setOrientation(orientation);
+        setReverseLayout(reverseLayout);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RecyclerView.LayoutParams generateDefaultLayoutParams() {
+        return new RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
+                ViewGroup.LayoutParams.WRAP_CONTENT);
+    }
+
+    /**
+     * Returns whether LayoutManager will recycle its children when it is detached from
+     * RecyclerView.
+     *
+     * @return true if LayoutManager will recycle its children when it is detached from
+     * RecyclerView.
+     */
+    public boolean getRecycleChildrenOnDetach() {
+        return mRecycleChildrenOnDetach;
+    }
+
+    /**
+     * Set whether LayoutManager will recycle its children when it is detached from
+     * RecyclerView.
+     * <p>
+     * If you are using a {@link RecyclerView.RecycledViewPool}, it might be a good idea to set
+     * this flag to <code>true</code> so that views will be avilable to other RecyclerViews
+     * immediately.
+     * <p>
+     * Note that, setting this flag will result in a performance drop if RecyclerView
+     * is restored.
+     *
+     * @param recycleChildrenOnDetach Whether children should be recycled in detach or not.
+     */
+    public void setRecycleChildrenOnDetach(boolean recycleChildrenOnDetach) {
+        mRecycleChildrenOnDetach = recycleChildrenOnDetach;
+    }
+
+    @Override
+    public void onDetachedFromWindow(RecyclerView view, RecyclerView.Recycler recycler) {
+        super.onDetachedFromWindow(view, recycler);
+        if (mRecycleChildrenOnDetach) {
+            removeAndRecycleAllViews(recycler);
+            recycler.clear();
+        }
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        if (getChildCount() > 0) {
+            final AccessibilityRecordCompat record = AccessibilityEventCompat
+                    .asRecord(event);
+            record.setFromIndex(findFirstVisibleItemPosition());
+            record.setToIndex(findLastVisibleItemPosition());
+        }
+    }
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        if (mPendingSavedState != null) {
+            return new SavedState(mPendingSavedState);
+        }
+        SavedState state = new SavedState();
+        if (getChildCount() > 0) {
+            ensureLayoutState();
+            boolean didLayoutFromEnd = mLastStackFromEnd ^ mShouldReverseLayout;
+            state.mAnchorLayoutFromEnd = didLayoutFromEnd;
+            if (didLayoutFromEnd) {
+                final View refChild = getChildClosestToEnd();
+                state.mAnchorOffset = mOrientationHelper.getEndAfterPadding() -
+                        mOrientationHelper.getDecoratedEnd(refChild);
+                state.mAnchorPosition = getPosition(refChild);
+            } else {
+                final View refChild = getChildClosestToStart();
+                state.mAnchorPosition = getPosition(refChild);
+                state.mAnchorOffset = mOrientationHelper.getDecoratedStart(refChild) -
+                        mOrientationHelper.getStartAfterPadding();
+            }
+        } else {
+            state.invalidateAnchor();
+        }
+        return state;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        if (state instanceof SavedState) {
+            mPendingSavedState = (SavedState) state;
+            requestLayout();
+            if (DEBUG) {
+                Log.d(TAG, "loaded saved state");
+            }
+        } else if (DEBUG) {
+            Log.d(TAG, "invalid saved state class");
+        }
+    }
+
+    /**
+     * @return true if {@link #getOrientation()} is {@link #HORIZONTAL}
+     */
+    @Override
+    public boolean canScrollHorizontally() {
+        return mOrientation == HORIZONTAL;
+    }
+
+    /**
+     * @return true if {@link #getOrientation()} is {@link #VERTICAL}
+     */
+    @Override
+    public boolean canScrollVertically() {
+        return mOrientation == VERTICAL;
+    }
+
+    /**
+     * Compatibility support for {@link android.widget.AbsListView#setStackFromBottom(boolean)}
+     */
+    public void setStackFromEnd(boolean stackFromEnd) {
+        assertNotInLayoutOrScroll(null);
+        if (mStackFromEnd == stackFromEnd) {
+            return;
+        }
+        mStackFromEnd = stackFromEnd;
+        requestLayout();
+    }
+
+    public boolean getStackFromEnd() {
+        return mStackFromEnd;
+    }
+
+    /**
+     * Returns the current orientaion of the layout.
+     *
+     * @return Current orientation.
+     * @see #mOrientation
+     * @see #setOrientation(int)
+     */
+    public int getOrientation() {
+        return mOrientation;
+    }
+
+    /**
+     * Sets the orientation of the layout. {@link android.support.v7.widget.LinearLayoutManager}
+     * will do its best to keep scroll position.
+     *
+     * @param orientation {@link #HORIZONTAL} or {@link #VERTICAL}
+     */
+    public void setOrientation(int orientation) {
+        if (orientation != HORIZONTAL && orientation != VERTICAL) {
+            throw new IllegalArgumentException("invalid orientation:" + orientation);
+        }
+        assertNotInLayoutOrScroll(null);
+        if (orientation == mOrientation) {
+            return;
+        }
+        mOrientation = orientation;
+        mOrientationHelper = null;
+        requestLayout();
+    }
+
+    /**
+     * Calculates the view layout order. (e.g. from end to start or start to end)
+     * RTL layout support is applied automatically. So if layout is RTL and
+     * {@link #getReverseLayout()} is {@code true}, elements will be laid out starting from left.
+     */
+    private void resolveShouldLayoutReverse() {
+        // A == B is the same result, but we rather keep it readable
+        if (mOrientation == VERTICAL || !isLayoutRTL()) {
+            mShouldReverseLayout = mReverseLayout;
+        } else {
+            mShouldReverseLayout = !mReverseLayout;
+        }
+    }
+
+    /**
+     * Returns if views are laid out from the opposite direction of the layout.
+     *
+     * @return If layout is reversed or not.
+     * @see {@link #setReverseLayout(boolean)}
+     */
+    public boolean getReverseLayout() {
+        return mReverseLayout;
+    }
+
+    /**
+     * Used to reverse item traversal and layout order.
+     * This behaves similar to the layout change for RTL views. When set to true, first item is
+     * laid out at the end of the UI, second item is laid out before it etc.
+     *
+     * For horizontal layouts, it depends on the layout direction.
+     * When set to true, If {@link android.support.v7.widget.RecyclerView} is LTR, than it will
+     * layout from RTL, if {@link android.support.v7.widget.RecyclerView}} is RTL, it will layout
+     * from LTR.
+     *
+     * If you are looking for the exact same behavior of
+     * {@link android.widget.AbsListView#setStackFromBottom(boolean)}, use
+     * {@link #setStackFromEnd(boolean)}
+     */
+    public void setReverseLayout(boolean reverseLayout) {
+        assertNotInLayoutOrScroll(null);
+        if (reverseLayout == mReverseLayout) {
+            return;
+        }
+        mReverseLayout = reverseLayout;
+        requestLayout();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public View findViewByPosition(int position) {
+        final int childCount = getChildCount();
+        if (childCount == 0) {
+            return null;
+        }
+        final int firstChild = getPosition(getChildAt(0));
+        final int viewPosition = position - firstChild;
+        if (viewPosition >= 0 && viewPosition < childCount) {
+            return getChildAt(viewPosition);
+        }
+        return null;
+    }
+
+    /**
+     * <p>Returns the amount of extra space that should be laid out by LayoutManager.
+     * By default, {@link android.support.v7.widget.LinearLayoutManager} lays out 1 extra page of
+     * items while smooth scrolling and 0 otherwise. You can override this method to implement your
+     * custom layout pre-cache logic.</p>
+     * <p>Laying out invisible elements will eventually come with performance cost. On the other
+     * hand, in places like smooth scrolling to an unknown location, this extra content helps
+     * LayoutManager to calculate a much smoother scrolling; which improves user experience.</p>
+     * <p>You can also use this if you are trying to pre-layout your upcoming views.</p>
+     *
+     * @return The extra space that should be laid out (in pixels).
+     */
+    protected int getExtraLayoutSpace(RecyclerView.State state) {
+        if (state.hasTargetScrollPosition()) {
+            return mOrientationHelper.getTotalSpace();
+        } else {
+            return 0;
+        }
+    }
+
+    @Override
+    public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,
+            int position) {
+        LinearSmoothScroller linearSmoothScroller =
+                new LinearSmoothScroller(recyclerView.getContext()) {
+                    @Override
+                    public PointF computeScrollVectorForPosition(int targetPosition) {
+                        return LinearLayoutManager.this
+                                .computeScrollVectorForPosition(targetPosition);
+                    }
+                };
+        linearSmoothScroller.setTargetPosition(position);
+        startSmoothScroll(linearSmoothScroller);
+    }
+
+    public PointF computeScrollVectorForPosition(int targetPosition) {
+        if (getChildCount() == 0) {
+            return null;
+        }
+        final int firstChildPos = getPosition(getChildAt(0));
+        final int direction = targetPosition < firstChildPos != mShouldReverseLayout ? -1 : 1;
+        if (mOrientation == HORIZONTAL) {
+            return new PointF(direction, 0);
+        } else {
+            return new PointF(0, direction);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
+        // layout algorithm:
+        // 1) by checking children and other variables, find an anchor coordinate and an anchor
+        //  item position.
+        // 2) fill towards start, stacking from bottom
+        // 3) fill towards end, stacking from top
+        // 4) scroll to fulfill requirements like stack from bottom.
+        // create layout state
+        if (DEBUG) {
+            Log.d(TAG, "is pre layout:" + state.isPreLayout());
+        }
+        if (mPendingSavedState != null && mPendingSavedState.hasValidAnchor()) {
+            mPendingScrollPosition = mPendingSavedState.mAnchorPosition;
+        }
+
+        ensureLayoutState();
+        mLayoutState.mRecycle = false;
+        // resolve layout direction
+        resolveShouldLayoutReverse();
+
+        mAnchorInfo.reset();
+        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
+        // calculate anchor position and coordinate
+        updateAnchorInfoForLayout(state, mAnchorInfo);
+        if (DEBUG) {
+            Log.d(TAG, "Anchor info:" + mAnchorInfo);
+        }
+
+        // LLM may decide to layout items for "extra" pixels to account for scrolling target,
+        // caching or predictive animations.
+        int extraForStart;
+        int extraForEnd;
+        final int extra = getExtraLayoutSpace(state);
+        // If the previous scroll delta was less than zero, the extra space should be laid out
+        // at the start. Otherwise, it should be at the end.
+        if (mLayoutState.mLastScrollDelta >= 0) {
+            extraForEnd = extra;
+            extraForStart = 0;
+        } else {
+            extraForStart = extra;
+            extraForEnd = 0;
+        }
+        extraForStart += mOrientationHelper.getStartAfterPadding();
+        extraForEnd += mOrientationHelper.getEndPadding();
+        if (state.isPreLayout() && mPendingScrollPosition != NO_POSITION &&
+                mPendingScrollPositionOffset != INVALID_OFFSET) {
+            // if the child is visible and we are going to move it around, we should layout
+            // extra items in the opposite direction to make sure new items animate nicely
+            // instead of just fading in
+            final View existing = findViewByPosition(mPendingScrollPosition);
+            if (existing != null) {
+                final int current;
+                final int upcomingOffset;
+                if (mShouldReverseLayout) {
+                    current = mOrientationHelper.getEndAfterPadding() -
+                            mOrientationHelper.getDecoratedEnd(existing);
+                    upcomingOffset = current - mPendingScrollPositionOffset;
+                } else {
+                    current = mOrientationHelper.getDecoratedStart(existing)
+                            - mOrientationHelper.getStartAfterPadding();
+                    upcomingOffset = mPendingScrollPositionOffset - current;
+                }
+                if (upcomingOffset > 0) {
+                    extraForStart += upcomingOffset;
+                } else {
+                    extraForEnd -= upcomingOffset;
+                }
+            }
+        }
+        int startOffset;
+        int endOffset;
+        onAnchorReady(state, mAnchorInfo);
+        detachAndScrapAttachedViews(recycler);
+        mLayoutState.mIsPreLayout = state.isPreLayout();
+        if (mAnchorInfo.mLayoutFromEnd) {
+            // fill towards start
+            updateLayoutStateToFillStart(mAnchorInfo);
+            mLayoutState.mExtra = extraForStart;
+            fill(recycler, mLayoutState, state, false);
+            startOffset = mLayoutState.mOffset;
+            final int firstElement = mLayoutState.mCurrentPosition;
+            if (mLayoutState.mAvailable > 0) {
+                extraForEnd += mLayoutState.mAvailable;
+            }
+            // fill towards end
+            updateLayoutStateToFillEnd(mAnchorInfo);
+            mLayoutState.mExtra = extraForEnd;
+            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
+            fill(recycler, mLayoutState, state, false);
+            endOffset = mLayoutState.mOffset;
+
+            if (mLayoutState.mAvailable > 0) {
+                // end could not consume all. add more items towards start
+                extraForStart = mLayoutState.mAvailable;
+                updateLayoutStateToFillStart(firstElement, startOffset);
+                mLayoutState.mExtra = extraForStart;
+                fill(recycler, mLayoutState, state, false);
+                startOffset = mLayoutState.mOffset;
+            }
+        } else {
+            // fill towards end
+            updateLayoutStateToFillEnd(mAnchorInfo);
+            mLayoutState.mExtra = extraForEnd;
+            fill(recycler, mLayoutState, state, false);
+            endOffset = mLayoutState.mOffset;
+            final int lastElement = mLayoutState.mCurrentPosition;
+            if (mLayoutState.mAvailable > 0) {
+                extraForStart += mLayoutState.mAvailable;
+            }
+            // fill towards start
+            updateLayoutStateToFillStart(mAnchorInfo);
+            mLayoutState.mExtra = extraForStart;
+            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
+            fill(recycler, mLayoutState, state, false);
+            startOffset = mLayoutState.mOffset;
+
+            if (mLayoutState.mAvailable > 0) {
+                extraForEnd = mLayoutState.mAvailable;
+                // start could not consume all it should. add more items towards end
+                updateLayoutStateToFillEnd(lastElement, endOffset);
+                mLayoutState.mExtra = extraForEnd;
+                fill(recycler, mLayoutState, state, false);
+                endOffset = mLayoutState.mOffset;
+            }
+        }
+
+        // changes may cause gaps on the UI, try to fix them.
+        // TODO we can probably avoid this if neither stackFromEnd/reverseLayout/RTL values have
+        // changed
+        if (getChildCount() > 0) {
+            // because layout from end may be changed by scroll to position
+            // we re-calculate it.
+            // find which side we should check for gaps.
+            if (mShouldReverseLayout ^ mStackFromEnd) {
+                int fixOffset = fixLayoutEndGap(endOffset, recycler, state, true);
+                startOffset += fixOffset;
+                endOffset += fixOffset;
+                fixOffset = fixLayoutStartGap(startOffset, recycler, state, false);
+                startOffset += fixOffset;
+                endOffset += fixOffset;
+            } else {
+                int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true);
+                startOffset += fixOffset;
+                endOffset += fixOffset;
+                fixOffset = fixLayoutEndGap(endOffset, recycler, state, false);
+                startOffset += fixOffset;
+                endOffset += fixOffset;
+            }
+        }
+        layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);
+        if (!state.isPreLayout()) {
+            mPendingScrollPosition = NO_POSITION;
+            mPendingScrollPositionOffset = INVALID_OFFSET;
+            mOrientationHelper.onLayoutComplete();
+        }
+        mLastStackFromEnd = mStackFromEnd;
+        mPendingSavedState = null; // we don't need this anymore
+        if (DEBUG) {
+            validateChildOrder();
+        }
+    }
+
+    /**
+     * Method called when Anchor position is decided. Extending class can setup accordingly or
+     * even update anchor info if necessary.
+     *
+     * @param state
+     * @param anchorInfo Simple data structure to keep anchor point information for the next layout
+     */
+    void onAnchorReady(RecyclerView.State state, AnchorInfo anchorInfo) {
+    }
+
+    /**
+     * If necessary, layouts new items for predictive animations
+     */
+    private void layoutForPredictiveAnimations(RecyclerView.Recycler recycler,
+            RecyclerView.State state, int startOffset,  int endOffset) {
+        // If there are scrap children that we did not layout, we need to find where they did go
+        // and layout them accordingly so that animations can work as expected.
+        // This case may happen if new views are added or an existing view expands and pushes
+        // another view out of bounds.
+        if (!state.willRunPredictiveAnimations() ||  getChildCount() == 0 || state.isPreLayout()
+                || !supportsPredictiveItemAnimations()) {
+            return;
+        }
+        // to make the logic simpler, we calculate the size of children and call fill.
+        int scrapExtraStart = 0, scrapExtraEnd = 0;
+        final List<RecyclerView.ViewHolder> scrapList = recycler.getScrapList();
+        final int scrapSize = scrapList.size();
+        final int firstChildPos = getPosition(getChildAt(0));
+        for (int i = 0; i < scrapSize; i++) {
+            RecyclerView.ViewHolder scrap = scrapList.get(i);
+            if (scrap.isRemoved()) {
+                continue;
+            }
+            final int position = scrap.getLayoutPosition();
+            final int direction = position < firstChildPos != mShouldReverseLayout
+                    ? LayoutState.LAYOUT_START : LayoutState.LAYOUT_END;
+            if (direction == LayoutState.LAYOUT_START) {
+                scrapExtraStart += mOrientationHelper.getDecoratedMeasurement(scrap.itemView);
+            } else {
+                scrapExtraEnd += mOrientationHelper.getDecoratedMeasurement(scrap.itemView);
+            }
+        }
+
+        if (DEBUG) {
+            Log.d(TAG, "for unused scrap, decided to add " + scrapExtraStart
+                    + " towards start and " + scrapExtraEnd + " towards end");
+        }
+        mLayoutState.mScrapList = scrapList;
+        if (scrapExtraStart > 0) {
+            View anchor = getChildClosestToStart();
+            updateLayoutStateToFillStart(getPosition(anchor), startOffset);
+            mLayoutState.mExtra = scrapExtraStart;
+            mLayoutState.mAvailable = 0;
+            mLayoutState.assignPositionFromScrapList();
+            fill(recycler, mLayoutState, state, false);
+        }
+
+        if (scrapExtraEnd > 0) {
+            View anchor = getChildClosestToEnd();
+            updateLayoutStateToFillEnd(getPosition(anchor), endOffset);
+            mLayoutState.mExtra = scrapExtraEnd;
+            mLayoutState.mAvailable = 0;
+            mLayoutState.assignPositionFromScrapList();
+            fill(recycler, mLayoutState, state, false);
+        }
+        mLayoutState.mScrapList = null;
+    }
+
+    private void updateAnchorInfoForLayout(RecyclerView.State state, AnchorInfo anchorInfo) {
+        if (updateAnchorFromPendingData(state, anchorInfo)) {
+            if (DEBUG) {
+                Log.d(TAG, "updated anchor info from pending information");
+            }
+            return;
+        }
+
+        if (updateAnchorFromChildren(state, anchorInfo)) {
+            if (DEBUG) {
+                Log.d(TAG, "updated anchor info from existing children");
+            }
+            return;
+        }
+        if (DEBUG) {
+            Log.d(TAG, "deciding anchor info for fresh state");
+        }
+        anchorInfo.assignCoordinateFromPadding();
+        anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - 1 : 0;
+    }
+
+    /**
+     * Finds an anchor child from existing Views. Most of the time, this is the view closest to
+     * start or end that has a valid position (e.g. not removed).
+     * <p>
+     * If a child has focus, it is given priority.
+     */
+    private boolean updateAnchorFromChildren(RecyclerView.State state, AnchorInfo anchorInfo) {
+        if (getChildCount() == 0) {
+            return false;
+        }
+        final View focused = getFocusedChild();
+        if (focused != null && anchorInfo.isViewValidAsAnchor(focused, state)) {
+            anchorInfo.assignFromViewAndKeepVisibleRect(focused);
+            return true;
+        }
+        if (mLastStackFromEnd != mStackFromEnd) {
+            return false;
+        }
+        View referenceChild = anchorInfo.mLayoutFromEnd ? findReferenceChildClosestToEnd(state)
+                : findReferenceChildClosestToStart(state);
+        if (referenceChild != null) {
+            anchorInfo.assignFromView(referenceChild);
+            // If all visible views are removed in 1 pass, reference child might be out of bounds.
+            // If that is the case, offset it back to 0 so that we use these pre-layout children.
+            if (!state.isPreLayout() && supportsPredictiveItemAnimations()) {
+                // validate this child is at least partially visible. if not, offset it to start
+                final boolean notVisible =
+                        mOrientationHelper.getDecoratedStart(referenceChild) >= mOrientationHelper
+                                .getEndAfterPadding()
+                                || mOrientationHelper.getDecoratedEnd(referenceChild)
+                                < mOrientationHelper.getStartAfterPadding();
+                if (notVisible) {
+                    anchorInfo.mCoordinate = anchorInfo.mLayoutFromEnd
+                            ? mOrientationHelper.getEndAfterPadding()
+                            : mOrientationHelper.getStartAfterPadding();
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * If there is a pending scroll position or saved states, updates the anchor info from that
+     * data and returns true
+     */
+    private boolean updateAnchorFromPendingData(RecyclerView.State state, AnchorInfo anchorInfo) {
+        if (state.isPreLayout() || mPendingScrollPosition == NO_POSITION) {
+            return false;
+        }
+        // validate scroll position
+        if (mPendingScrollPosition < 0 || mPendingScrollPosition >= state.getItemCount()) {
+            mPendingScrollPosition = NO_POSITION;
+            mPendingScrollPositionOffset = INVALID_OFFSET;
+            if (DEBUG) {
+                Log.e(TAG, "ignoring invalid scroll position " + mPendingScrollPosition);
+            }
+            return false;
+        }
+
+        // if child is visible, try to make it a reference child and ensure it is fully visible.
+        // if child is not visible, align it depending on its virtual position.
+        anchorInfo.mPosition = mPendingScrollPosition;
+        if (mPendingSavedState != null && mPendingSavedState.hasValidAnchor()) {
+            // Anchor offset depends on how that child was laid out. Here, we update it
+            // according to our current view bounds
+            anchorInfo.mLayoutFromEnd = mPendingSavedState.mAnchorLayoutFromEnd;
+            if (anchorInfo.mLayoutFromEnd) {
+                anchorInfo.mCoordinate = mOrientationHelper.getEndAfterPadding() -
+                        mPendingSavedState.mAnchorOffset;
+            } else {
+                anchorInfo.mCoordinate = mOrientationHelper.getStartAfterPadding() +
+                        mPendingSavedState.mAnchorOffset;
+            }
+            return true;
+        }
+
+        if (mPendingScrollPositionOffset == INVALID_OFFSET) {
+            View child = findViewByPosition(mPendingScrollPosition);
+            if (child != null) {
+                final int childSize = mOrientationHelper.getDecoratedMeasurement(child);
+                if (childSize > mOrientationHelper.getTotalSpace()) {
+                    // item does not fit. fix depending on layout direction
+                    anchorInfo.assignCoordinateFromPadding();
+                    return true;
+                }
+                final int startGap = mOrientationHelper.getDecoratedStart(child)
+                        - mOrientationHelper.getStartAfterPadding();
+                if (startGap < 0) {
+                    anchorInfo.mCoordinate = mOrientationHelper.getStartAfterPadding();
+                    anchorInfo.mLayoutFromEnd = false;
+                    return true;
+                }
+                final int endGap = mOrientationHelper.getEndAfterPadding() -
+                        mOrientationHelper.getDecoratedEnd(child);
+                if (endGap < 0) {
+                    anchorInfo.mCoordinate = mOrientationHelper.getEndAfterPadding();
+                    anchorInfo.mLayoutFromEnd = true;
+                    return true;
+                }
+                anchorInfo.mCoordinate = anchorInfo.mLayoutFromEnd
+                        ? (mOrientationHelper.getDecoratedEnd(child) + mOrientationHelper
+                                .getTotalSpaceChange())
+                        : mOrientationHelper.getDecoratedStart(child);
+            } else { // item is not visible.
+                if (getChildCount() > 0) {
+                    // get position of any child, does not matter
+                    int pos = getPosition(getChildAt(0));
+                    anchorInfo.mLayoutFromEnd = mPendingScrollPosition < pos
+                            == mShouldReverseLayout;
+                }
+                anchorInfo.assignCoordinateFromPadding();
+            }
+            return true;
+        }
+        // override layout from end values for consistency
+        anchorInfo.mLayoutFromEnd = mShouldReverseLayout;
+        if (mShouldReverseLayout) {
+            anchorInfo.mCoordinate = mOrientationHelper.getEndAfterPadding() -
+                    mPendingScrollPositionOffset;
+        } else {
+            anchorInfo.mCoordinate = mOrientationHelper.getStartAfterPadding() +
+                    mPendingScrollPositionOffset;
+        }
+        return true;
+    }
+
+    /**
+     * @return The final offset amount for children
+     */
+    private int fixLayoutEndGap(int endOffset, RecyclerView.Recycler recycler,
+            RecyclerView.State state, boolean canOffsetChildren) {
+        int gap = mOrientationHelper.getEndAfterPadding() - endOffset;
+        int fixOffset = 0;
+        if (gap > 0) {
+            fixOffset = -scrollBy(-gap, recycler, state);
+        } else {
+            return 0; // nothing to fix
+        }
+        // move offset according to scroll amount
+        endOffset += fixOffset;
+        if (canOffsetChildren) {
+            // re-calculate gap, see if we could fix it
+            gap = mOrientationHelper.getEndAfterPadding() - endOffset;
+            if (gap > 0) {
+                mOrientationHelper.offsetChildren(gap);
+                return gap + fixOffset;
+            }
+        }
+        return fixOffset;
+    }
+
+    /**
+     * @return The final offset amount for children
+     */
+    private int fixLayoutStartGap(int startOffset, RecyclerView.Recycler recycler,
+            RecyclerView.State state, boolean canOffsetChildren) {
+        int gap = startOffset - mOrientationHelper.getStartAfterPadding();
+        int fixOffset = 0;
+        if (gap > 0) {
+            // check if we should fix this gap.
+            fixOffset = -scrollBy(gap, recycler, state);
+        } else {
+            return 0; // nothing to fix
+        }
+        startOffset += fixOffset;
+        if (canOffsetChildren) {
+            // re-calculate gap, see if we could fix it
+            gap = startOffset - mOrientationHelper.getStartAfterPadding();
+            if (gap > 0) {
+                mOrientationHelper.offsetChildren(-gap);
+                return fixOffset - gap;
+            }
+        }
+        return fixOffset;
+    }
+
+    private void updateLayoutStateToFillEnd(AnchorInfo anchorInfo) {
+        updateLayoutStateToFillEnd(anchorInfo.mPosition, anchorInfo.mCoordinate);
+    }
+
+    private void updateLayoutStateToFillEnd(int itemPosition, int offset) {
+        mLayoutState.mAvailable = mOrientationHelper.getEndAfterPadding() - offset;
+        mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD :
+                LayoutState.ITEM_DIRECTION_TAIL;
+        mLayoutState.mCurrentPosition = itemPosition;
+        mLayoutState.mLayoutDirection = LayoutState.LAYOUT_END;
+        mLayoutState.mOffset = offset;
+        mLayoutState.mScrollingOffset = LayoutState.SCOLLING_OFFSET_NaN;
+    }
+
+    private void updateLayoutStateToFillStart(AnchorInfo anchorInfo) {
+        updateLayoutStateToFillStart(anchorInfo.mPosition, anchorInfo.mCoordinate);
+    }
+
+    private void updateLayoutStateToFillStart(int itemPosition, int offset) {
+        mLayoutState.mAvailable = offset - mOrientationHelper.getStartAfterPadding();
+        mLayoutState.mCurrentPosition = itemPosition;
+        mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL :
+                LayoutState.ITEM_DIRECTION_HEAD;
+        mLayoutState.mLayoutDirection = LayoutState.LAYOUT_START;
+        mLayoutState.mOffset = offset;
+        mLayoutState.mScrollingOffset = LayoutState.SCOLLING_OFFSET_NaN;
+
+    }
+
+    protected boolean isLayoutRTL() {
+        return getLayoutDirection() == ViewCompat.LAYOUT_DIRECTION_RTL;
+    }
+
+    void ensureLayoutState() {
+        if (mLayoutState == null) {
+            mLayoutState = createLayoutState();
+        }
+        if (mOrientationHelper == null) {
+            mOrientationHelper = OrientationHelper.createOrientationHelper(this, mOrientation);
+        }
+    }
+
+    /**
+     * Test overrides this to plug some tracking and verification.
+     *
+     * @return A new LayoutState
+     */
+    LayoutState createLayoutState() {
+        return new LayoutState();
+    }
+
+    /**
+     * <p>Scroll the RecyclerView to make the position visible.</p>
+     *
+     * <p>RecyclerView will scroll the minimum amount that is necessary to make the
+     * target position visible. If you are looking for a similar behavior to
+     * {@link android.widget.ListView#setSelection(int)} or
+     * {@link android.widget.ListView#setSelectionFromTop(int, int)}, use
+     * {@link #scrollToPositionWithOffset(int, int)}.</p>
+     *
+     * <p>Note that scroll position change will not be reflected until the next layout call.</p>
+     *
+     * @param position Scroll to this adapter position
+     * @see #scrollToPositionWithOffset(int, int)
+     */
+    @Override
+    public void scrollToPosition(int position) {
+        mPendingScrollPosition = position;
+        mPendingScrollPositionOffset = INVALID_OFFSET;
+        if (mPendingSavedState != null) {
+            mPendingSavedState.invalidateAnchor();
+        }
+        requestLayout();
+    }
+
+    /**
+     * Scroll to the specified adapter position with the given offset from resolved layout
+     * start. Resolved layout start depends on {@link #getReverseLayout()},
+     * {@link ViewCompat#getLayoutDirection(android.view.View)} and {@link #getStackFromEnd()}.
+     * <p>
+     * For example, if layout is {@link #VERTICAL} and {@link #getStackFromEnd()} is true, calling
+     * <code>scrollToPositionWithOffset(10, 20)</code> will layout such that
+     * <code>item[10]</code>'s bottom is 20 pixels above the RecyclerView's bottom.
+     * <p>
+     * Note that scroll position change will not be reflected until the next layout call.
+     *
+     * <p>
+     * If you are just trying to make a position visible, use {@link #scrollToPosition(int)}.
+     *
+     * @param position Index (starting at 0) of the reference item.
+     * @param offset   The distance (in pixels) between the start edge of the item view and
+     *                 start edge of the RecyclerView.
+     * @see #setReverseLayout(boolean)
+     * @see #scrollToPosition(int)
+     */
+    public void scrollToPositionWithOffset(int position, int offset) {
+        mPendingScrollPosition = position;
+        mPendingScrollPositionOffset = offset;
+        if (mPendingSavedState != null) {
+            mPendingSavedState.invalidateAnchor();
+        }
+        requestLayout();
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler,
+            RecyclerView.State state) {
+        if (mOrientation == VERTICAL) {
+            return 0;
+        }
+        return scrollBy(dx, recycler, state);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,
+            RecyclerView.State state) {
+        if (mOrientation == HORIZONTAL) {
+            return 0;
+        }
+        return scrollBy(dy, recycler, state);
+    }
+
+    @Override
+    public int computeHorizontalScrollOffset(RecyclerView.State state) {
+        return computeScrollOffset(state);
+    }
+
+    @Override
+    public int computeVerticalScrollOffset(RecyclerView.State state) {
+        return computeScrollOffset(state);
+    }
+
+    @Override
+    public int computeHorizontalScrollExtent(RecyclerView.State state) {
+        return computeScrollExtent(state);
+    }
+
+    @Override
+    public int computeVerticalScrollExtent(RecyclerView.State state) {
+        return computeScrollExtent(state);
+    }
+
+    @Override
+    public int computeHorizontalScrollRange(RecyclerView.State state) {
+        return computeScrollRange(state);
+    }
+
+    @Override
+    public int computeVerticalScrollRange(RecyclerView.State state) {
+        return computeScrollRange(state);
+    }
+
+    private int computeScrollOffset(RecyclerView.State state) {
+        if (getChildCount() == 0) {
+            return 0;
+        }
+        ensureLayoutState();
+        return ScrollbarHelper.computeScrollOffset(state, mOrientationHelper,
+                findFirstVisibleChildClosestToStart(!mSmoothScrollbarEnabled, true),
+                findFirstVisibleChildClosestToEnd(!mSmoothScrollbarEnabled, true),
+                this, mSmoothScrollbarEnabled, mShouldReverseLayout);
+    }
+
+    private int computeScrollExtent(RecyclerView.State state) {
+        if (getChildCount() == 0) {
+            return 0;
+        }
+        ensureLayoutState();
+        return ScrollbarHelper.computeScrollExtent(state, mOrientationHelper,
+                findFirstVisibleChildClosestToStart(!mSmoothScrollbarEnabled, true),
+                findFirstVisibleChildClosestToEnd(!mSmoothScrollbarEnabled, true),
+                this,  mSmoothScrollbarEnabled);
+    }
+
+    private int computeScrollRange(RecyclerView.State state) {
+        if (getChildCount() == 0) {
+            return 0;
+        }
+        ensureLayoutState();
+        return ScrollbarHelper.computeScrollRange(state, mOrientationHelper,
+                findFirstVisibleChildClosestToStart(!mSmoothScrollbarEnabled, true),
+                findFirstVisibleChildClosestToEnd(!mSmoothScrollbarEnabled, true),
+                this, mSmoothScrollbarEnabled);
+    }
+
+    /**
+     * When smooth scrollbar is enabled, the position and size of the scrollbar thumb is computed
+     * based on the number of visible pixels in the visible items. This however assumes that all
+     * list items have similar or equal widths or heights (depending on list orientation).
+     * If you use a list in which items have different dimensions, the scrollbar will change
+     * appearance as the user scrolls through the list. To avoid this issue,  you need to disable
+     * this property.
+     *
+     * When smooth scrollbar is disabled, the position and size of the scrollbar thumb is based
+     * solely on the number of items in the adapter and the position of the visible items inside
+     * the adapter. This provides a stable scrollbar as the user navigates through a list of items
+     * with varying widths / heights.
+     *
+     * @param enabled Whether or not to enable smooth scrollbar.
+     *
+     * @see #setSmoothScrollbarEnabled(boolean)
+     */
+    public void setSmoothScrollbarEnabled(boolean enabled) {
+        mSmoothScrollbarEnabled = enabled;
+    }
+
+    /**
+     * Returns the current state of the smooth scrollbar feature. It is enabled by default.
+     *
+     * @return True if smooth scrollbar is enabled, false otherwise.
+     *
+     * @see #setSmoothScrollbarEnabled(boolean)
+     */
+    public boolean isSmoothScrollbarEnabled() {
+        return mSmoothScrollbarEnabled;
+    }
+
+    private void updateLayoutState(int layoutDirection, int requiredSpace,
+            boolean canUseExistingSpace, RecyclerView.State state) {
+        mLayoutState.mExtra = getExtraLayoutSpace(state);
+        mLayoutState.mLayoutDirection = layoutDirection;
+        int fastScrollSpace;
+        if (layoutDirection == LayoutState.LAYOUT_END) {
+            mLayoutState.mExtra += mOrientationHelper.getEndPadding();
+            // get the first child in the direction we are going
+            final View child = getChildClosestToEnd();
+            // the direction in which we are traversing children
+            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD
+                    : LayoutState.ITEM_DIRECTION_TAIL;
+            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;
+            mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);
+            // calculate how much we can scroll without adding new children (independent of layout)
+            fastScrollSpace = mOrientationHelper.getDecoratedEnd(child)
+                    - mOrientationHelper.getEndAfterPadding();
+
+        } else {
+            final View child = getChildClosestToStart();
+            mLayoutState.mExtra += mOrientationHelper.getStartAfterPadding();
+            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL
+                    : LayoutState.ITEM_DIRECTION_HEAD;
+            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;
+            mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);
+            fastScrollSpace = -mOrientationHelper.getDecoratedStart(child)
+                    + mOrientationHelper.getStartAfterPadding();
+        }
+        mLayoutState.mAvailable = requiredSpace;
+        if (canUseExistingSpace) {
+            mLayoutState.mAvailable -= fastScrollSpace;
+        }
+        mLayoutState.mScrollingOffset = fastScrollSpace;
+    }
+
+    int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {
+        if (getChildCount() == 0 || dy == 0) {
+            return 0;
+        }
+        mLayoutState.mRecycle = true;
+        ensureLayoutState();
+        final int layoutDirection = dy > 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;
+        final int absDy = Math.abs(dy);
+        updateLayoutState(layoutDirection, absDy, true, state);
+        final int freeScroll = mLayoutState.mScrollingOffset;
+        final int consumed = freeScroll + fill(recycler, mLayoutState, state, false);
+        if (consumed < 0) {
+            if (DEBUG) {
+                Log.d(TAG, "Don't have any more elements to scroll");
+            }
+            return 0;
+        }
+        final int scrolled = absDy > consumed ? layoutDirection * consumed : dy;
+        mOrientationHelper.offsetChildren(-scrolled);
+        if (DEBUG) {
+            Log.d(TAG, "scroll req: " + dy + " scrolled: " + scrolled);
+        }
+        mLayoutState.mLastScrollDelta = scrolled;
+        return scrolled;
+    }
+
+    @Override
+    public void assertNotInLayoutOrScroll(String message) {
+        if (mPendingSavedState == null) {
+            super.assertNotInLayoutOrScroll(message);
+        }
+    }
+
+    /**
+     * Recycles children between given indices.
+     *
+     * @param startIndex inclusive
+     * @param endIndex   exclusive
+     */
+    private void recycleChildren(RecyclerView.Recycler recycler, int startIndex, int endIndex) {
+        if (startIndex == endIndex) {
+            return;
+        }
+        if (DEBUG) {
+            Log.d(TAG, "Recycling " + Math.abs(startIndex - endIndex) + " items");
+        }
+        if (endIndex > startIndex) {
+            for (int i = endIndex - 1; i >= startIndex; i--) {
+                removeAndRecycleViewAt(i, recycler);
+            }
+        } else {
+            for (int i = startIndex; i > endIndex; i--) {
+                removeAndRecycleViewAt(i, recycler);
+            }
+        }
+    }
+
+    /**
+     * Recycles views that went out of bounds after scrolling towards the end of the layout.
+     *
+     * @param recycler Recycler instance of {@link android.support.v7.widget.RecyclerView}
+     * @param dt       This can be used to add additional padding to the visible area. This is used
+     *                 to
+     *                 detect children that will go out of bounds after scrolling, without actually
+     *                 moving them.
+     */
+    private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) {
+        if (dt < 0) {
+            if (DEBUG) {
+                Log.d(TAG, "Called recycle from start with a negative value. This might happen"
+                        + " during layout changes but may be sign of a bug");
+            }
+            return;
+        }
+        // ignore padding, ViewGroup may not clip children.
+        final int limit = dt;
+        final int childCount = getChildCount();
+        if (mShouldReverseLayout) {
+            for (int i = childCount - 1; i >= 0; i--) {
+                View child = getChildAt(i);
+                if (mOrientationHelper.getDecoratedEnd(child) > limit) {// stop here
+                    recycleChildren(recycler, childCount - 1, i);
+                    return;
+                }
+            }
+        } else {
+            for (int i = 0; i < childCount; i++) {
+                View child = getChildAt(i);
+                if (mOrientationHelper.getDecoratedEnd(child) > limit) {// stop here
+                    recycleChildren(recycler, 0, i);
+                    return;
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Recycles views that went out of bounds after scrolling towards the start of the layout.
+     *
+     * @param recycler Recycler instance of {@link android.support.v7.widget.RecyclerView}
+     * @param dt       This can be used to add additional padding to the visible area. This is used
+     *                 to detect children that will go out of bounds after scrolling, without
+     *                 actually moving them.
+     */
+    private void recycleViewsFromEnd(RecyclerView.Recycler recycler, int dt) {
+        final int childCount = getChildCount();
+        if (dt < 0) {
+            if (DEBUG) {
+                Log.d(TAG, "Called recycle from end with a negative value. This might happen"
+                        + " during layout changes but may be sign of a bug");
+            }
+            return;
+        }
+        final int limit = mOrientationHelper.getEnd() - dt;
+        if (mShouldReverseLayout) {
+            for (int i = 0; i < childCount; i++) {
+                View child = getChildAt(i);
+                if (mOrientationHelper.getDecoratedStart(child) < limit) {// stop here
+                    recycleChildren(recycler, 0, i);
+                    return;
+                }
+            }
+        } else {
+            for (int i = childCount - 1; i >= 0; i--) {
+                View child = getChildAt(i);
+                if (mOrientationHelper.getDecoratedStart(child) < limit) {// stop here
+                    recycleChildren(recycler, childCount - 1, i);
+                    return;
+                }
+            }
+        }
+
+    }
+
+    /**
+     * Helper method to call appropriate recycle method depending on current layout direction
+     *
+     * @param recycler    Current recycler that is attached to RecyclerView
+     * @param layoutState Current layout state. Right now, this object does not change but
+     *                    we may consider moving it out of this view so passing around as a
+     *                    parameter for now, rather than accessing {@link #mLayoutState}
+     * @see #recycleViewsFromStart(android.support.v7.widget.RecyclerView.Recycler, int)
+     * @see #recycleViewsFromEnd(android.support.v7.widget.RecyclerView.Recycler, int)
+     * @see android.support.v7.widget.LinearLayoutManager.LayoutState#mLayoutDirection
+     */
+    private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {
+        if (!layoutState.mRecycle) {
+            return;
+        }
+        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
+            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);
+        } else {
+            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);
+        }
+    }
+
+    /**
+     * The magic functions :). Fills the given layout, defined by the layoutState. This is fairly
+     * independent from the rest of the {@link android.support.v7.widget.LinearLayoutManager}
+     * and with little change, can be made publicly available as a helper class.
+     *
+     * @param recycler        Current recycler that is attached to RecyclerView
+     * @param layoutState     Configuration on how we should fill out the available space.
+     * @param state           Context passed by the RecyclerView to control scroll steps.
+     * @param stopOnFocusable If true, filling stops in the first focusable new child
+     * @return Number of pixels that it added. Useful for scoll functions.
+     */
+    int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
+            RecyclerView.State state, boolean stopOnFocusable) {
+        // max offset we should set is mFastScroll + available
+        final int start = layoutState.mAvailable;
+        if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) {
+            // TODO ugly bug fix. should not happen
+            if (layoutState.mAvailable < 0) {
+                layoutState.mScrollingOffset += layoutState.mAvailable;
+            }
+            recycleByLayoutState(recycler, layoutState);
+        }
+        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
+        LayoutChunkResult layoutChunkResult = new LayoutChunkResult();
+        while (remainingSpace > 0 && layoutState.hasMore(state)) {
+            layoutChunkResult.resetInternal();
+            layoutChunk(recycler, state, layoutState, layoutChunkResult);
+            if (layoutChunkResult.mFinished) {
+                break;
+            }
+            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;
+            /**
+             * Consume the available space if:
+             * * layoutChunk did not request to be ignored
+             * * OR we are laying out scrap children
+             * * OR we are not doing pre-layout
+             */
+            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null
+                    || !state.isPreLayout()) {
+                layoutState.mAvailable -= layoutChunkResult.mConsumed;
+                // we keep a separate remaining space because mAvailable is important for recycling
+                remainingSpace -= layoutChunkResult.mConsumed;
+            }
+
+            if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) {
+                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;
+                if (layoutState.mAvailable < 0) {
+                    layoutState.mScrollingOffset += layoutState.mAvailable;
+                }
+                recycleByLayoutState(recycler, layoutState);
+            }
+            if (stopOnFocusable && layoutChunkResult.mFocusable) {
+                break;
+            }
+        }
+        if (DEBUG) {
+            validateChildOrder();
+        }
+        return start - layoutState.mAvailable;
+    }
+
+    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
+            LayoutState layoutState, LayoutChunkResult result) {
+        View view = layoutState.next(recycler);
+        if (view == null) {
+            if (DEBUG && layoutState.mScrapList == null) {
+                throw new RuntimeException("received null view when unexpected");
+            }
+            // if we are laying out views in scrap, this may return null which means there is
+            // no more items to layout.
+            result.mFinished = true;
+            return;
+        }
+        RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams();
+        if (layoutState.mScrapList == null) {
+            if (mShouldReverseLayout == (layoutState.mLayoutDirection
+                    == LayoutState.LAYOUT_START)) {
+                addView(view);
+            } else {
+                addView(view, 0);
+            }
+        } else {
+            if (mShouldReverseLayout == (layoutState.mLayoutDirection
+                    == LayoutState.LAYOUT_START)) {
+                addDisappearingView(view);
+            } else {
+                addDisappearingView(view, 0);
+            }
+        }
+        measureChildWithMargins(view, 0, 0);
+        result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);
+        int left, top, right, bottom;
+        if (mOrientation == VERTICAL) {
+            if (isLayoutRTL()) {
+                right = getWidth() - getPaddingRight();
+                left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);
+            } else {
+                left = getPaddingLeft();
+                right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);
+            }
+            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
+                bottom = layoutState.mOffset;
+                top = layoutState.mOffset - result.mConsumed;
+            } else {
+                top = layoutState.mOffset;
+                bottom = layoutState.mOffset + result.mConsumed;
+            }
+        } else {
+            top = getPaddingTop();
+            bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);
+
+            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
+                right = layoutState.mOffset;
+                left = layoutState.mOffset - result.mConsumed;
+            } else {
+                left = layoutState.mOffset;
+                right = layoutState.mOffset + result.mConsumed;
+            }
+        }
+        // We calculate everything with View's bounding box (which includes decor and margins)
+        // To calculate correct layout position, we subtract margins.
+        layoutDecorated(view, left + params.leftMargin, top + params.topMargin,
+                right - params.rightMargin, bottom - params.bottomMargin);
+        if (DEBUG) {
+            Log.d(TAG, "laid out child at position " + getPosition(view) + ", with l:"
+                    + (left + params.leftMargin) + ", t:" + (top + params.topMargin) + ", r:"
+                    + (right - params.rightMargin) + ", b:" + (bottom - params.bottomMargin));
+        }
+        // Consume the available space if the view is not removed OR changed
+        if (params.isItemRemoved() || params.isItemChanged()) {
+            result.mIgnoreConsumed = true;
+        }
+        result.mFocusable = view.isFocusable();
+    }
+
+    /**
+     * Converts a focusDirection to orientation.
+     *
+     * @param focusDirection One of {@link View#FOCUS_UP}, {@link View#FOCUS_DOWN},
+     *                       {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
+     *                       {@link View#FOCUS_BACKWARD}, {@link View#FOCUS_FORWARD}
+     *                       or 0 for not applicable
+     * @return {@link LayoutState#LAYOUT_START} or {@link LayoutState#LAYOUT_END} if focus direction
+     * is applicable to current state, {@link LayoutState#INVALID_LAYOUT} otherwise.
+     */
+    private int convertFocusDirectionToLayoutDirection(int focusDirection) {
+        switch (focusDirection) {
+            case View.FOCUS_BACKWARD:
+                return LayoutState.LAYOUT_START;
+            case View.FOCUS_FORWARD:
+                return LayoutState.LAYOUT_END;
+            case View.FOCUS_UP:
+                return mOrientation == VERTICAL ? LayoutState.LAYOUT_START
+                        : LayoutState.INVALID_LAYOUT;
+            case View.FOCUS_DOWN:
+                return mOrientation == VERTICAL ? LayoutState.LAYOUT_END
+                        : LayoutState.INVALID_LAYOUT;
+            case View.FOCUS_LEFT:
+                return mOrientation == HORIZONTAL ? LayoutState.LAYOUT_START
+                        : LayoutState.INVALID_LAYOUT;
+            case View.FOCUS_RIGHT:
+                return mOrientation == HORIZONTAL ? LayoutState.LAYOUT_END
+                        : LayoutState.INVALID_LAYOUT;
+            default:
+                if (DEBUG) {
+                    Log.d(TAG, "Unknown focus request:" + focusDirection);
+                }
+                return LayoutState.INVALID_LAYOUT;
+        }
+
+    }
+
+    /**
+     * Convenience method to find the child closes to start. Caller should check it has enough
+     * children.
+     *
+     * @return The child closes to start of the layout from user's perspective.
+     */
+    private View getChildClosestToStart() {
+        return getChildAt(mShouldReverseLayout ? getChildCount() - 1 : 0);
+    }
+
+    /**
+     * Convenience method to find the child closes to end. Caller should check it has enough
+     * children.
+     *
+     * @return The child closes to end of the layout from user's perspective.
+     */
+    private View getChildClosestToEnd() {
+        return getChildAt(mShouldReverseLayout ? 0 : getChildCount() - 1);
+    }
+
+    /**
+     * Convenience method to find the visible child closes to start. Caller should check if it has
+     * enough children.
+     *
+     * @param completelyVisible Whether child should be completely visible or not
+     * @return The first visible child closest to start of the layout from user's perspective.
+     */
+    private View findFirstVisibleChildClosestToStart(boolean completelyVisible,
+            boolean acceptPartiallyVisible) {
+        if (mShouldReverseLayout) {
+            return findOneVisibleChild(getChildCount() - 1, -1, completelyVisible,
+                    acceptPartiallyVisible);
+        } else {
+            return findOneVisibleChild(0, getChildCount(), completelyVisible,
+                    acceptPartiallyVisible);
+        }
+    }
+
+    /**
+     * Convenience method to find the visible child closes to end. Caller should check if it has
+     * enough children.
+     *
+     * @param completelyVisible Whether child should be completely visible or not
+     * @return The first visible child closest to end of the layout from user's perspective.
+     */
+    private View findFirstVisibleChildClosestToEnd(boolean completelyVisible,
+            boolean acceptPartiallyVisible) {
+        if (mShouldReverseLayout) {
+            return findOneVisibleChild(0, getChildCount(), completelyVisible,
+                    acceptPartiallyVisible);
+        } else {
+            return findOneVisibleChild(getChildCount() - 1, -1, completelyVisible,
+                    acceptPartiallyVisible);
+        }
+    }
+
+
+    /**
+     * Among the children that are suitable to be considered as an anchor child, returns the one
+     * closest to the end of the layout.
+     * <p>
+     * Due to ambiguous adapter updates or children being removed, some children's positions may be
+     * invalid. This method is a best effort to find a position within adapter bounds if possible.
+     * <p>
+     * It also prioritizes children that are within the visible bounds.
+     * @return A View that can be used an an anchor View.
+     */
+    private View findReferenceChildClosestToEnd(RecyclerView.State state) {
+        return mShouldReverseLayout ? findFirstReferenceChild(state.getItemCount()) :
+                findLastReferenceChild(state.getItemCount());
+    }
+
+    /**
+     * Among the children that are suitable to be considered as an anchor child, returns the one
+     * closest to the start of the layout.
+     * <p>
+     * Due to ambiguous adapter updates or children being removed, some children's positions may be
+     * invalid. This method is a best effort to find a position within adapter bounds if possible.
+     * <p>
+     * It also prioritizes children that are within the visible bounds.
+     *
+     * @return A View that can be used an an anchor View.
+     */
+    private View findReferenceChildClosestToStart(RecyclerView.State state) {
+        return mShouldReverseLayout ? findLastReferenceChild(state.getItemCount()) :
+                findFirstReferenceChild(state.getItemCount());
+    }
+
+    private View findFirstReferenceChild(int itemCount) {
+        return findReferenceChild(0, getChildCount(), itemCount);
+    }
+
+    private View findLastReferenceChild(int itemCount) {
+        return findReferenceChild(getChildCount() - 1, -1, itemCount);
+    }
+
+    // overridden by GridLayoutManager
+    View findReferenceChild(int start, int end, int itemCount) {
+        ensureLayoutState();
+        View invalidMatch = null;
+        View outOfBoundsMatch = null;
+        final int boundsStart = mOrientationHelper.getStartAfterPadding();
+        final int boundsEnd = mOrientationHelper.getEndAfterPadding();
+        final int diff = end > start ? 1 : -1;
+        for (int i = start; i != end; i += diff) {
+            final View view = getChildAt(i);
+            final int position = getPosition(view);
+            if (position >= 0 && position < itemCount) {
+                if (((RecyclerView.LayoutParams) view.getLayoutParams()).isItemRemoved()) {
+                    if (invalidMatch == null) {
+                        invalidMatch = view; // removed item, least preferred
+                    }
+                } else if (mOrientationHelper.getDecoratedStart(view) >= boundsEnd ||
+                        mOrientationHelper.getDecoratedEnd(view) < boundsStart) {
+                    if (outOfBoundsMatch == null) {
+                        outOfBoundsMatch = view; // item is not visible, less preferred
+                    }
+                } else {
+                    return view;
+                }
+            }
+        }
+        return outOfBoundsMatch != null ? outOfBoundsMatch : invalidMatch;
+    }
+
+    /**
+     * Returns the adapter position of the first visible view. This position does not include
+     * adapter changes that were dispatched after the last layout pass.
+     * <p>
+     * Note that, this value is not affected by layout orientation or item order traversal.
+     * ({@link #setReverseLayout(boolean)}). Views are sorted by their positions in the adapter,
+     * not in the layout.
+     * <p>
+     * If RecyclerView has item decorators, they will be considered in calculations as well.
+     * <p>
+     * LayoutManager may pre-cache some views that are not necessarily visible. Those views
+     * are ignored in this method.
+     *
+     * @return The adapter position of the first visible item or {@link RecyclerView#NO_POSITION} if
+     * there aren't any visible items.
+     * @see #findFirstCompletelyVisibleItemPosition()
+     * @see #findLastVisibleItemPosition()
+     */
+    public int findFirstVisibleItemPosition() {
+        final View child = findOneVisibleChild(0, getChildCount(), false, true);
+        return child == null ? NO_POSITION : getPosition(child);
+    }
+
+    /**
+     * Returns the adapter position of the first fully visible view. This position does not include
+     * adapter changes that were dispatched after the last layout pass.
+     * <p>
+     * Note that bounds check is only performed in the current orientation. That means, if
+     * LayoutManager is horizontal, it will only check the view's left and right edges.
+     *
+     * @return The adapter position of the first fully visible item or
+     * {@link RecyclerView#NO_POSITION} if there aren't any visible items.
+     * @see #findFirstVisibleItemPosition()
+     * @see #findLastCompletelyVisibleItemPosition()
+     */
+    public int findFirstCompletelyVisibleItemPosition() {
+        final View child = findOneVisibleChild(0, getChildCount(), true, false);
+        return child == null ? NO_POSITION : getPosition(child);
+    }
+
+    /**
+     * Returns the adapter position of the last visible view. This position does not include
+     * adapter changes that were dispatched after the last layout pass.
+     * <p>
+     * Note that, this value is not affected by layout orientation or item order traversal.
+     * ({@link #setReverseLayout(boolean)}). Views are sorted by their positions in the adapter,
+     * not in the layout.
+     * <p>
+     * If RecyclerView has item decorators, they will be considered in calculations as well.
+     * <p>
+     * LayoutManager may pre-cache some views that are not necessarily visible. Those views
+     * are ignored in this method.
+     *
+     * @return The adapter position of the last visible view or {@link RecyclerView#NO_POSITION} if
+     * there aren't any visible items.
+     * @see #findLastCompletelyVisibleItemPosition()
+     * @see #findFirstVisibleItemPosition()
+     */
+    public int findLastVisibleItemPosition() {
+        final View child = findOneVisibleChild(getChildCount() - 1, -1, false, true);
+        return child == null ? NO_POSITION : getPosition(child);
+    }
+
+    /**
+     * Returns the adapter position of the last fully visible view. This position does not include
+     * adapter changes that were dispatched after the last layout pass.
+     * <p>
+     * Note that bounds check is only performed in the current orientation. That means, if
+     * LayoutManager is horizontal, it will only check the view's left and right edges.
+     *
+     * @return The adapter position of the last fully visible view or
+     * {@link RecyclerView#NO_POSITION} if there aren't any visible items.
+     * @see #findLastVisibleItemPosition()
+     * @see #findFirstCompletelyVisibleItemPosition()
+     */
+    public int findLastCompletelyVisibleItemPosition() {
+        final View child = findOneVisibleChild(getChildCount() - 1, -1, true, false);
+        return child == null ? NO_POSITION : getPosition(child);
+    }
+
+    View findOneVisibleChild(int fromIndex, int toIndex, boolean completelyVisible,
+            boolean acceptPartiallyVisible) {
+        ensureLayoutState();
+        final int start = mOrientationHelper.getStartAfterPadding();
+        final int end = mOrientationHelper.getEndAfterPadding();
+        final int next = toIndex > fromIndex ? 1 : -1;
+        View partiallyVisible = null;
+        for (int i = fromIndex; i != toIndex; i+=next) {
+            final View child = getChildAt(i);
+            final int childStart = mOrientationHelper.getDecoratedStart(child);
+            final int childEnd = mOrientationHelper.getDecoratedEnd(child);
+            if (childStart < end && childEnd > start) {
+                if (completelyVisible) {
+                    if (childStart >= start && childEnd <= end) {
+                        return child;
+                    } else if (acceptPartiallyVisible && partiallyVisible == null) {
+                        partiallyVisible = child;
+                    }
+                } else {
+                    return child;
+                }
+            }
+        }
+        return partiallyVisible;
+    }
+
+    @Override
+    public View onFocusSearchFailed(View focused, int focusDirection,
+            RecyclerView.Recycler recycler, RecyclerView.State state) {
+        resolveShouldLayoutReverse();
+        if (getChildCount() == 0) {
+            return null;
+        }
+
+        final int layoutDir = convertFocusDirectionToLayoutDirection(focusDirection);
+        if (layoutDir == LayoutState.INVALID_LAYOUT) {
+            return null;
+        }
+        ensureLayoutState();
+        final View referenceChild;
+        if (layoutDir == LayoutState.LAYOUT_START) {
+            referenceChild = findReferenceChildClosestToStart(state);
+        } else {
+            referenceChild = findReferenceChildClosestToEnd(state);
+        }
+        if (referenceChild == null) {
+            if (DEBUG) {
+                Log.d(TAG,
+                        "Cannot find a child with a valid position to be used for focus search.");
+            }
+            return null;
+        }
+        ensureLayoutState();
+        final int maxScroll = (int) (MAX_SCROLL_FACTOR * mOrientationHelper.getTotalSpace());
+        updateLayoutState(layoutDir, maxScroll, false, state);
+        mLayoutState.mScrollingOffset = LayoutState.SCOLLING_OFFSET_NaN;
+        mLayoutState.mRecycle = false;
+        fill(recycler, mLayoutState, state, true);
+        final View nextFocus;
+        if (layoutDir == LayoutState.LAYOUT_START) {
+            nextFocus = getChildClosestToStart();
+        } else {
+            nextFocus = getChildClosestToEnd();
+        }
+        if (nextFocus == referenceChild || !nextFocus.isFocusable()) {
+            return null;
+        }
+        return nextFocus;
+    }
+
+    /**
+     * Used for debugging.
+     * Logs the internal representation of children to default logger.
+     */
+    private void logChildren() {
+        Log.d(TAG, "internal representation of views on the screen");
+        for (int i = 0; i < getChildCount(); i++) {
+            View child = getChildAt(i);
+            Log.d(TAG, "item " + getPosition(child) + ", coord:"
+                    + mOrientationHelper.getDecoratedStart(child));
+        }
+        Log.d(TAG, "==============");
+    }
+
+    /**
+     * Used for debugging.
+     * Validates that child views are laid out in correct order. This is important because rest of
+     * the algorithm relies on this constraint.
+     *
+     * In default layout, child 0 should be closest to screen position 0 and last child should be
+     * closest to position WIDTH or HEIGHT.
+     * In reverse layout, last child should be closes to screen position 0 and first child should
+     * be closest to position WIDTH  or HEIGHT
+     */
+    void validateChildOrder() {
+        Log.d(TAG, "validating child count " + getChildCount());
+        if (getChildCount() < 1) {
+            return;
+        }
+        int lastPos = getPosition(getChildAt(0));
+        int lastScreenLoc = mOrientationHelper.getDecoratedStart(getChildAt(0));
+        if (mShouldReverseLayout) {
+            for (int i = 1; i < getChildCount(); i++) {
+                View child = getChildAt(i);
+                int pos = getPosition(child);
+                int screenLoc = mOrientationHelper.getDecoratedStart(child);
+                if (pos < lastPos) {
+                    logChildren();
+                    throw new RuntimeException("detected invalid position. loc invalid? " +
+                            (screenLoc < lastScreenLoc));
+                }
+                if (screenLoc > lastScreenLoc) {
+                    logChildren();
+                    throw new RuntimeException("detected invalid location");
+                }
+            }
+        } else {
+            for (int i = 1; i < getChildCount(); i++) {
+                View child = getChildAt(i);
+                int pos = getPosition(child);
+                int screenLoc = mOrientationHelper.getDecoratedStart(child);
+                if (pos < lastPos) {
+                    logChildren();
+                    throw new RuntimeException("detected invalid position. loc invalid? " +
+                            (screenLoc < lastScreenLoc));
+                }
+                if (screenLoc < lastScreenLoc) {
+                    logChildren();
+                    throw new RuntimeException("detected invalid location");
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean supportsPredictiveItemAnimations() {
+        return mPendingSavedState == null && mLastStackFromEnd == mStackFromEnd;
+    }
+
+    /**
+     * Helper class that keeps temporary state while {LayoutManager} is filling out the empty
+     * space.
+     */
+    static class LayoutState {
+
+        final static String TAG = "LinearLayoutManager#LayoutState";
+
+        final static int LAYOUT_START = -1;
+
+        final static int LAYOUT_END = 1;
+
+        final static int INVALID_LAYOUT = Integer.MIN_VALUE;
+
+        final static int ITEM_DIRECTION_HEAD = -1;
+
+        final static int ITEM_DIRECTION_TAIL = 1;
+
+        final static int SCOLLING_OFFSET_NaN = Integer.MIN_VALUE;
+
+        /**
+         * We may not want to recycle children in some cases (e.g. layout)
+         */
+        boolean mRecycle = true;
+
+        /**
+         * Pixel offset where layout should start
+         */
+        int mOffset;
+
+        /**
+         * Number of pixels that we should fill, in the layout direction.
+         */
+        int mAvailable;
+
+        /**
+         * Current position on the adapter to get the next item.
+         */
+        int mCurrentPosition;
+
+        /**
+         * Defines the direction in which the data adapter is traversed.
+         * Should be {@link #ITEM_DIRECTION_HEAD} or {@link #ITEM_DIRECTION_TAIL}
+         */
+        int mItemDirection;
+
+        /**
+         * Defines the direction in which the layout is filled.
+         * Should be {@link #LAYOUT_START} or {@link #LAYOUT_END}
+         */
+        int mLayoutDirection;
+
+        /**
+         * Used when LayoutState is constructed in a scrolling state.
+         * It should be set the amount of scrolling we can make without creating a new view.
+         * Settings this is required for efficient view recycling.
+         */
+        int mScrollingOffset;
+
+        /**
+         * Used if you want to pre-layout items that are not yet visible.
+         * The difference with {@link #mAvailable} is that, when recycling, distance laid out for
+         * {@link #mExtra} is not considered to avoid recycling visible children.
+         */
+        int mExtra = 0;
+
+        /**
+         * Equal to {@link RecyclerView.State#isPreLayout()}. When consuming scrap, if this value
+         * is set to true, we skip removed views since they should not be laid out in post layout
+         * step.
+         */
+        boolean mIsPreLayout = false;
+
+        /**
+         * The most recent {@link #scrollBy(int, RecyclerView.Recycler, RecyclerView.State)} amount.
+         */
+        int mLastScrollDelta;
+
+        /**
+         * When LLM needs to layout particular views, it sets this list in which case, LayoutState
+         * will only return views from this list and return null if it cannot find an item.
+         */
+        List<RecyclerView.ViewHolder> mScrapList = null;
+
+        /**
+         * @return true if there are more items in the data adapter
+         */
+        boolean hasMore(RecyclerView.State state) {
+            return mCurrentPosition >= 0 && mCurrentPosition < state.getItemCount();
+        }
+
+        /**
+         * Gets the view for the next element that we should layout.
+         * Also updates current item index to the next item, based on {@link #mItemDirection}
+         *
+         * @return The next element that we should layout.
+         */
+        View next(RecyclerView.Recycler recycler) {
+            if (mScrapList != null) {
+                return nextViewFromScrapList();
+            }
+            final View view = recycler.getViewForPosition(mCurrentPosition);
+            mCurrentPosition += mItemDirection;
+            return view;
+        }
+
+        /**
+         * Returns the next item from the scrap list.
+         * <p>
+         * Upon finding a valid VH, sets current item position to VH.itemPosition + mItemDirection
+         *
+         * @return View if an item in the current position or direction exists if not null.
+         */
+        private View nextViewFromScrapList() {
+            final int size = mScrapList.size();
+            for (int i = 0; i < size; i++) {
+                final RecyclerView.ViewHolder viewHolder = mScrapList.get(i);
+                if (viewHolder.isRemoved()) {
+                    continue;
+                }
+                if (mCurrentPosition == viewHolder.getLayoutPosition()) {
+                    assignPositionFromScrapList(viewHolder);
+                    return viewHolder.itemView;
+                }
+            }
+            return null;
+        }
+
+        public void assignPositionFromScrapList() {
+            assignPositionFromScrapList(null);
+        }
+
+        public void assignPositionFromScrapList(RecyclerView.ViewHolder ignore) {
+            RecyclerView.ViewHolder closest = nextViewHolderInLimitedList(ignore);
+            mCurrentPosition = closest == null ? RecyclerView.NO_POSITION :
+                    closest.getLayoutPosition();
+        }
+
+        public RecyclerView.ViewHolder nextViewHolderInLimitedList(RecyclerView.ViewHolder ignore) {
+            int size = mScrapList.size();
+            RecyclerView.ViewHolder closest = null;
+            int closestDistance = Integer.MAX_VALUE;
+            if (DEBUG && mIsPreLayout) {
+                throw new IllegalStateException("Scrap list cannot be used in pre layout");
+            }
+            for (int i = 0; i < size; i++) {
+                RecyclerView.ViewHolder viewHolder = mScrapList.get(i);
+                if (viewHolder == ignore || viewHolder.isRemoved()) {
+                    continue;
+                }
+                final int distance = (viewHolder.getLayoutPosition() - mCurrentPosition) *
+                        mItemDirection;
+                if (distance < 0) {
+                    continue; // item is not in current direction
+                }
+                if (distance < closestDistance) {
+                    closest = viewHolder;
+                    closestDistance = distance;
+                    if (distance == 0) {
+                        break;
+                    }
+                }
+            }
+            return closest;
+        }
+
+        void log() {
+            Log.d(TAG, "avail:" + mAvailable + ", ind:" + mCurrentPosition + ", dir:" +
+                    mItemDirection + ", offset:" + mOffset + ", layoutDir:" + mLayoutDirection);
+        }
+    }
+
+    static class SavedState implements Parcelable {
+
+        int mAnchorPosition;
+
+        int mAnchorOffset;
+
+        boolean mAnchorLayoutFromEnd;
+
+        public SavedState() {
+
+        }
+
+        SavedState(Parcel in) {
+            mAnchorPosition = in.readInt();
+            mAnchorOffset = in.readInt();
+            mAnchorLayoutFromEnd = in.readInt() == 1;
+        }
+
+        public SavedState(SavedState other) {
+            mAnchorPosition = other.mAnchorPosition;
+            mAnchorOffset = other.mAnchorOffset;
+            mAnchorLayoutFromEnd = other.mAnchorLayoutFromEnd;
+        }
+
+        boolean hasValidAnchor() {
+            return mAnchorPosition >= 0;
+        }
+
+        void invalidateAnchor() {
+            mAnchorPosition = NO_POSITION;
+        }
+
+        @Override
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeInt(mAnchorPosition);
+            dest.writeInt(mAnchorOffset);
+            dest.writeInt(mAnchorLayoutFromEnd ? 1 : 0);
+        }
+
+        public static final Parcelable.Creator<SavedState> CREATOR
+                = new Parcelable.Creator<SavedState>() {
+            @Override
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            @Override
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+
+    /**
+     * Simple data class to keep Anchor information
+     */
+    class AnchorInfo {
+        int mPosition;
+        int mCoordinate;
+        boolean mLayoutFromEnd;
+        void reset() {
+            mPosition = NO_POSITION;
+            mCoordinate = INVALID_OFFSET;
+            mLayoutFromEnd = false;
+        }
+
+        /**
+         * assigns anchor coordinate from the RecyclerView's padding depending on current
+         * layoutFromEnd value
+         */
+        void assignCoordinateFromPadding() {
+            mCoordinate = mLayoutFromEnd
+                    ? mOrientationHelper.getEndAfterPadding()
+                    : mOrientationHelper.getStartAfterPadding();
+        }
+
+        @Override
+        public String toString() {
+            return "AnchorInfo{" +
+                    "mPosition=" + mPosition +
+                    ", mCoordinate=" + mCoordinate +
+                    ", mLayoutFromEnd=" + mLayoutFromEnd +
+                    '}';
+        }
+
+        private boolean isViewValidAsAnchor(View child, RecyclerView.State state) {
+            RecyclerView.LayoutParams lp = (RecyclerView.LayoutParams) child.getLayoutParams();
+            return !lp.isItemRemoved() && lp.getViewLayoutPosition() >= 0
+                    && lp.getViewLayoutPosition() < state.getItemCount();
+        }
+
+        public void assignFromViewAndKeepVisibleRect(View child) {
+            final int spaceChange = mOrientationHelper.getTotalSpaceChange();
+            if (spaceChange >= 0) {
+                assignFromView(child);
+                return;
+            }
+            mPosition = getPosition(child);
+            if (mLayoutFromEnd) {
+                final int prevLayoutEnd = mOrientationHelper.getEndAfterPadding() - spaceChange;
+                final int childEnd = mOrientationHelper.getDecoratedEnd(child);
+                final int previousEndMargin = prevLayoutEnd - childEnd;
+                mCoordinate = mOrientationHelper.getEndAfterPadding() - previousEndMargin;
+                // ensure we did not push child's top out of bounds because of this
+                if (previousEndMargin > 0) {// we have room to shift bottom if necessary
+                    final int childSize = mOrientationHelper.getDecoratedMeasurement(child);
+                    final int estimatedChildStart = mCoordinate - childSize;
+                    final int layoutStart = mOrientationHelper.getStartAfterPadding();
+                    final int previousStartMargin = mOrientationHelper.getDecoratedStart(child) -
+                            layoutStart;
+                    final int startReference = layoutStart + Math.min(previousStartMargin, 0);
+                    final int startMargin = estimatedChildStart - startReference;
+                    if (startMargin < 0) {
+                        // offset to make top visible but not too much
+                        mCoordinate += Math.min(previousEndMargin, -startMargin);
+                    }
+                }
+            } else {
+                final int childStart = mOrientationHelper.getDecoratedStart(child);
+                final int startMargin = childStart - mOrientationHelper.getStartAfterPadding();
+                mCoordinate = childStart;
+                if (startMargin > 0) { // we have room to fix end as well
+                    final int estimatedEnd = childStart +
+                            mOrientationHelper.getDecoratedMeasurement(child);
+                    final int previousLayoutEnd = mOrientationHelper.getEndAfterPadding() -
+                            spaceChange;
+                    final int previousEndMargin = previousLayoutEnd -
+                            mOrientationHelper.getDecoratedEnd(child);
+                    final int endReference = mOrientationHelper.getEndAfterPadding() -
+                            Math.min(0, previousEndMargin);
+                    final int endMargin = endReference - estimatedEnd;
+                    if (endMargin < 0) {
+                        mCoordinate -= Math.min(startMargin, -endMargin);
+                    }
+                }
+            }
+        }
+
+        public void assignFromView(View child) {
+            if (mLayoutFromEnd) {
+                mCoordinate = mOrientationHelper.getDecoratedEnd(child) +
+                        mOrientationHelper.getTotalSpaceChange();
+            } else {
+                mCoordinate = mOrientationHelper.getDecoratedStart(child);
+            }
+
+            mPosition = getPosition(child);
+        }
+    }
+
+    protected static class LayoutChunkResult {
+        public int mConsumed;
+        public boolean mFinished;
+        public boolean mIgnoreConsumed;
+        public boolean mFocusable;
+
+        void resetInternal() {
+            mConsumed = 0;
+            mFinished = false;
+            mIgnoreConsumed = false;
+            mFocusable = false;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/LinearSmoothScroller.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/LinearSmoothScroller.java
new file mode 100644
index 000000000..419d9447d
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/LinearSmoothScroller.java
@@ -0,0 +1,338 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+
+import android.content.Context;
+import android.graphics.PointF;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.View;
+import android.view.animation.DecelerateInterpolator;
+import android.view.animation.LinearInterpolator;
+
+/**
+ * {@link RecyclerView.SmoothScroller} implementation which uses
+ * {@link android.view.animation.LinearInterpolator} until the target position becames a child of
+ * the RecyclerView and then uses
+ * {@link android.view.animation.DecelerateInterpolator} to slowly approach to target position.
+ */
+abstract public class LinearSmoothScroller extends RecyclerView.SmoothScroller {
+
+    private static final String TAG = "LinearSmoothScroller";
+
+    private static final boolean DEBUG = false;
+
+    private static final float MILLISECONDS_PER_INCH = 25f;
+
+    private static final int TARGET_SEEK_SCROLL_DISTANCE_PX = 10000;
+
+    /**
+     * Align child view's left or top with parent view's left or top
+     *
+     * @see #calculateDtToFit(int, int, int, int, int)
+     * @see #calculateDxToMakeVisible(android.view.View, int)
+     * @see #calculateDyToMakeVisible(android.view.View, int)
+     */
+    public static final int SNAP_TO_START = -1;
+
+    /**
+     * Align child view's right or bottom with parent view's right or bottom
+     *
+     * @see #calculateDtToFit(int, int, int, int, int)
+     * @see #calculateDxToMakeVisible(android.view.View, int)
+     * @see #calculateDyToMakeVisible(android.view.View, int)
+     */
+    public static final int SNAP_TO_END = 1;
+
+    /**
+     * <p>Decides if the child should be snapped from start or end, depending on where it
+     * currently is in relation to its parent.</p>
+     * <p>For instance, if the view is virtually on the left of RecyclerView, using
+     * {@code SNAP_TO_ANY} is the same as using {@code SNAP_TO_START}</p>
+     *
+     * @see #calculateDtToFit(int, int, int, int, int)
+     * @see #calculateDxToMakeVisible(android.view.View, int)
+     * @see #calculateDyToMakeVisible(android.view.View, int)
+     */
+    public static final int SNAP_TO_ANY = 0;
+
+    // Trigger a scroll to a further distance than TARGET_SEEK_SCROLL_DISTANCE_PX so that if target
+    // view is not laid out until interim target position is reached, we can detect the case before
+    // scrolling slows down and reschedule another interim target scroll
+    private static final float TARGET_SEEK_EXTRA_SCROLL_RATIO = 1.2f;
+
+    protected final LinearInterpolator mLinearInterpolator = new LinearInterpolator();
+
+    protected final DecelerateInterpolator mDecelerateInterpolator = new DecelerateInterpolator();
+
+    protected PointF mTargetVector;
+
+    private final float MILLISECONDS_PER_PX;
+
+    // Temporary variables to keep track of the interim scroll target. These values do not
+    // point to a real item position, rather point to an estimated location pixels.
+    protected int mInterimTargetDx = 0, mInterimTargetDy = 0;
+
+    public LinearSmoothScroller(Context context) {
+        MILLISECONDS_PER_PX = calculateSpeedPerPixel(context.getResources().getDisplayMetrics());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onStart() {
+
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onTargetFound(View targetView, RecyclerView.State state, Action action) {
+        final int dx = calculateDxToMakeVisible(targetView, getHorizontalSnapPreference());
+        final int dy = calculateDyToMakeVisible(targetView, getVerticalSnapPreference());
+        final int distance = (int) Math.sqrt(dx * dx + dy * dy);
+        final int time = calculateTimeForDeceleration(distance);
+        if (time > 0) {
+            action.update(-dx, -dy, time, mDecelerateInterpolator);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onSeekTargetStep(int dx, int dy, RecyclerView.State state, Action action) {
+        if (getChildCount() == 0) {
+            stop();
+            return;
+        }
+        if (DEBUG && mTargetVector != null
+                && ((mTargetVector.x * dx < 0 || mTargetVector.y * dy < 0))) {
+            throw new IllegalStateException("Scroll happened in the opposite direction"
+                    + " of the target. Some calculations are wrong");
+        }
+        mInterimTargetDx = clampApplyScroll(mInterimTargetDx, dx);
+        mInterimTargetDy = clampApplyScroll(mInterimTargetDy, dy);
+
+        if (mInterimTargetDx == 0 && mInterimTargetDy == 0) {
+            updateActionForInterimTarget(action);
+        } // everything is valid, keep going
+
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onStop() {
+        mInterimTargetDx = mInterimTargetDy = 0;
+        mTargetVector = null;
+    }
+
+    /**
+     * Calculates the scroll speed.
+     *
+     * @param displayMetrics DisplayMetrics to be used for real dimension calculations
+     * @return The time (in ms) it should take for each pixel. For instance, if returned value is
+     * 2 ms, it means scrolling 1000 pixels with LinearInterpolation should take 2 seconds.
+     */
+    protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) {
+        return MILLISECONDS_PER_INCH / displayMetrics.densityDpi;
+    }
+
+    /**
+     * <p>Calculates the time for deceleration so that transition from LinearInterpolator to
+     * DecelerateInterpolator looks smooth.</p>
+     *
+     * @param dx Distance to scroll
+     * @return Time for DecelerateInterpolator to smoothly traverse the distance when transitioning
+     * from LinearInterpolation
+     */
+    protected int calculateTimeForDeceleration(int dx) {
+        // we want to cover same area with the linear interpolator for the first 10% of the
+        // interpolation. After that, deceleration will take control.
+        // area under curve (1-(1-x)^2) can be calculated as (1 - x/3) * x * x
+        // which gives 0.100028 when x = .3356
+        // this is why we divide linear scrolling time with .3356
+        return  (int) Math.ceil(calculateTimeForScrolling(dx) / .3356);
+    }
+
+    /**
+     * Calculates the time it should take to scroll the given distance (in pixels)
+     *
+     * @param dx Distance in pixels that we want to scroll
+     * @return Time in milliseconds
+     * @see #calculateSpeedPerPixel(android.util.DisplayMetrics)
+     */
+    protected int calculateTimeForScrolling(int dx) {
+        // In a case where dx is very small, rounding may return 0 although dx > 0.
+        // To avoid that issue, ceil the result so that if dx > 0, we'll always return positive
+        // time.
+        return (int) Math.ceil(Math.abs(dx) * MILLISECONDS_PER_PX);
+    }
+
+    /**
+     * When scrolling towards a child view, this method defines whether we should align the left
+     * or the right edge of the child with the parent RecyclerView.
+     *
+     * @return SNAP_TO_START, SNAP_TO_END or SNAP_TO_ANY; depending on the current target vector
+     * @see #SNAP_TO_START
+     * @see #SNAP_TO_END
+     * @see #SNAP_TO_ANY
+     */
+    protected int getHorizontalSnapPreference() {
+        return mTargetVector == null || mTargetVector.x == 0 ? SNAP_TO_ANY :
+                mTargetVector.x > 0 ? SNAP_TO_END : SNAP_TO_START;
+    }
+
+    /**
+     * When scrolling towards a child view, this method defines whether we should align the top
+     * or the bottom edge of the child with the parent RecyclerView.
+     *
+     * @return SNAP_TO_START, SNAP_TO_END or SNAP_TO_ANY; depending on the current target vector
+     * @see #SNAP_TO_START
+     * @see #SNAP_TO_END
+     * @see #SNAP_TO_ANY
+     */
+    protected int getVerticalSnapPreference() {
+        return mTargetVector == null || mTargetVector.y == 0 ? SNAP_TO_ANY :
+                mTargetVector.y > 0 ? SNAP_TO_END : SNAP_TO_START;
+    }
+
+    /**
+     * When the target scroll position is not a child of the RecyclerView, this method calculates
+     * a direction vector towards that child and triggers a smooth scroll.
+     *
+     * @see #computeScrollVectorForPosition(int)
+     */
+    protected void updateActionForInterimTarget(Action action) {
+        // find an interim target position
+        PointF scrollVector = computeScrollVectorForPosition(getTargetPosition());
+        if (scrollVector == null || (scrollVector.x == 0 && scrollVector.y == 0)) {
+            Log.e(TAG, "To support smooth scrolling, you should override \n"
+                    + "LayoutManager#computeScrollVectorForPosition.\n"
+                    + "Falling back to instant scroll");
+            final int target = getTargetPosition();
+            stop();
+            instantScrollToPosition(target);
+            return;
+        }
+        normalize(scrollVector);
+        mTargetVector = scrollVector;
+
+        mInterimTargetDx = (int) (TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector.x);
+        mInterimTargetDy = (int) (TARGET_SEEK_SCROLL_DISTANCE_PX * scrollVector.y);
+        final int time = calculateTimeForScrolling(TARGET_SEEK_SCROLL_DISTANCE_PX);
+        // To avoid UI hiccups, trigger a smooth scroll to a distance little further than the
+        // interim target. Since we track the distance travelled in onSeekTargetStep callback, it
+        // won't actually scroll more than what we need.
+        action.update((int) (mInterimTargetDx * TARGET_SEEK_EXTRA_SCROLL_RATIO)
+                , (int) (mInterimTargetDy * TARGET_SEEK_EXTRA_SCROLL_RATIO)
+                , (int) (time * TARGET_SEEK_EXTRA_SCROLL_RATIO), mLinearInterpolator);
+    }
+
+    private int clampApplyScroll(int tmpDt, int dt) {
+        final int before = tmpDt;
+        tmpDt -= dt;
+        if (before * tmpDt <= 0) { // changed sign, reached 0 or was 0, reset
+            return 0;
+        }
+        return tmpDt;
+    }
+
+    /**
+     * Helper method for {@link #calculateDxToMakeVisible(android.view.View, int)} and
+     * {@link #calculateDyToMakeVisible(android.view.View, int)}
+     */
+    public int calculateDtToFit(int viewStart, int viewEnd, int boxStart, int boxEnd, int
+            snapPreference) {
+        switch (snapPreference) {
+            case SNAP_TO_START:
+                return boxStart - viewStart;
+            case SNAP_TO_END:
+                return boxEnd - viewEnd;
+            case SNAP_TO_ANY:
+                final int dtStart = boxStart - viewStart;
+                if (dtStart > 0) {
+                    return dtStart;
+                }
+                final int dtEnd = boxEnd - viewEnd;
+                if (dtEnd < 0) {
+                    return dtEnd;
+                }
+                break;
+            default:
+                throw new IllegalArgumentException("snap preference should be one of the"
+                        + " constants defined in SmoothScroller, starting with SNAP_");
+        }
+        return 0;
+    }
+
+    /**
+     * Calculates the vertical scroll amount necessary to make the given view fully visible
+     * inside the RecyclerView.
+     *
+     * @param view           The view which we want to make fully visible
+     * @param snapPreference The edge which the view should snap to when entering the visible
+     *                       area. One of {@link #SNAP_TO_START}, {@link #SNAP_TO_END} or
+     *                       {@link #SNAP_TO_END}.
+     * @return The vertical scroll amount necessary to make the view visible with the given
+     * snap preference.
+     */
+    public int calculateDyToMakeVisible(View view, int snapPreference) {
+        final RecyclerView.LayoutManager layoutManager = getLayoutManager();
+        if (!layoutManager.canScrollVertically()) {
+            return 0;
+        }
+        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                view.getLayoutParams();
+        final int top = layoutManager.getDecoratedTop(view) - params.topMargin;
+        final int bottom = layoutManager.getDecoratedBottom(view) + params.bottomMargin;
+        final int start = layoutManager.getPaddingTop();
+        final int end = layoutManager.getHeight() - layoutManager.getPaddingBottom();
+        return calculateDtToFit(top, bottom, start, end, snapPreference);
+    }
+
+    /**
+     * Calculates the horizontal scroll amount necessary to make the given view fully visible
+     * inside the RecyclerView.
+     *
+     * @param view           The view which we want to make fully visible
+     * @param snapPreference The edge which the view should snap to when entering the visible
+     *                       area. One of {@link #SNAP_TO_START}, {@link #SNAP_TO_END} or
+     *                       {@link #SNAP_TO_END}
+     * @return The vertical scroll amount necessary to make the view visible with the given
+     * snap preference.
+     */
+    public int calculateDxToMakeVisible(View view, int snapPreference) {
+        final RecyclerView.LayoutManager layoutManager = getLayoutManager();
+        if (!layoutManager.canScrollHorizontally()) {
+            return 0;
+        }
+        final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                view.getLayoutParams();
+        final int left = layoutManager.getDecoratedLeft(view) - params.leftMargin;
+        final int right = layoutManager.getDecoratedRight(view) + params.rightMargin;
+        final int start = layoutManager.getPaddingLeft();
+        final int end = layoutManager.getWidth() - layoutManager.getPaddingRight();
+        return calculateDtToFit(left, right, start, end, snapPreference);
+    }
+
+    abstract public PointF computeScrollVectorForPosition(int targetPosition);
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/OpReorderer.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/OpReorderer.java
new file mode 100644
index 000000000..3d56822f7
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/OpReorderer.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+
+import java.util.List;
+
+import org.telegram.android.support.widget.AdapterHelper.UpdateOp;
+import static org.telegram.android.support.widget.AdapterHelper.UpdateOp.ADD;
+import static org.telegram.android.support.widget.AdapterHelper.UpdateOp.MOVE;
+import static org.telegram.android.support.widget.AdapterHelper.UpdateOp.REMOVE;
+import static org.telegram.android.support.widget.AdapterHelper.UpdateOp.UPDATE;
+
+class OpReorderer {
+
+    final Callback mCallback;
+
+    public OpReorderer(Callback callback) {
+        mCallback = callback;
+    }
+
+    void reorderOps(List<UpdateOp> ops) {
+        // since move operations breaks continuity, their effects on ADD/RM are hard to handle.
+        // we push them to the end of the list so that they can be handled easily.
+        int badMove;
+        while ((badMove = getLastMoveOutOfOrder(ops)) != -1) {
+            swapMoveOp(ops, badMove, badMove + 1);
+        }
+    }
+
+    private void swapMoveOp(List<UpdateOp> list, int badMove, int next) {
+        final UpdateOp moveOp = list.get(badMove);
+        final UpdateOp nextOp = list.get(next);
+        switch (nextOp.cmd) {
+            case REMOVE:
+                swapMoveRemove(list, badMove, moveOp, next, nextOp);
+                break;
+            case ADD:
+                swapMoveAdd(list, badMove, moveOp, next, nextOp);
+                break;
+            case UPDATE:
+                swapMoveUpdate(list, badMove, moveOp, next, nextOp);
+                break;
+        }
+    }
+
+    void swapMoveRemove(List<UpdateOp> list, int movePos, UpdateOp moveOp,
+            int removePos, UpdateOp removeOp) {
+        UpdateOp extraRm = null;
+        // check if move is nulled out by remove
+        boolean revertedMove = false;
+        final boolean moveIsBackwards;
+
+        if (moveOp.positionStart < moveOp.itemCount) {
+            moveIsBackwards = false;
+            if (removeOp.positionStart == moveOp.positionStart
+                    && removeOp.itemCount == moveOp.itemCount - moveOp.positionStart) {
+                revertedMove = true;
+            }
+        } else {
+            moveIsBackwards = true;
+            if (removeOp.positionStart == moveOp.itemCount + 1 &&
+                    removeOp.itemCount == moveOp.positionStart - moveOp.itemCount) {
+                revertedMove = true;
+            }
+        }
+
+        // going in reverse, first revert the effect of add
+        if (moveOp.itemCount < removeOp.positionStart) {
+            removeOp.positionStart--;
+        } else if (moveOp.itemCount < removeOp.positionStart + removeOp.itemCount) {
+            // move is removed.
+            removeOp.itemCount --;
+            moveOp.cmd = REMOVE;
+            moveOp.itemCount = 1;
+            if (removeOp.itemCount == 0) {
+                list.remove(removePos);
+                mCallback.recycleUpdateOp(removeOp);
+            }
+            // no need to swap, it is already a remove
+            return;
+        }
+
+        // now affect of add is consumed. now apply effect of first remove
+        if (moveOp.positionStart <= removeOp.positionStart) {
+            removeOp.positionStart++;
+        } else if (moveOp.positionStart < removeOp.positionStart + removeOp.itemCount) {
+            final int remaining = removeOp.positionStart + removeOp.itemCount
+                    - moveOp.positionStart;
+            extraRm = mCallback.obtainUpdateOp(REMOVE, moveOp.positionStart + 1, remaining);
+            removeOp.itemCount = moveOp.positionStart - removeOp.positionStart;
+        }
+
+        // if effects of move is reverted by remove, we are done.
+        if (revertedMove) {
+            list.set(movePos, removeOp);
+            list.remove(removePos);
+            mCallback.recycleUpdateOp(moveOp);
+            return;
+        }
+
+        // now find out the new locations for move actions
+        if (moveIsBackwards) {
+            if (extraRm != null) {
+                if (moveOp.positionStart > extraRm.positionStart) {
+                    moveOp.positionStart -= extraRm.itemCount;
+                }
+                if (moveOp.itemCount > extraRm.positionStart) {
+                    moveOp.itemCount -= extraRm.itemCount;
+                }
+            }
+            if (moveOp.positionStart > removeOp.positionStart) {
+                moveOp.positionStart -= removeOp.itemCount;
+            }
+            if (moveOp.itemCount > removeOp.positionStart) {
+                moveOp.itemCount -= removeOp.itemCount;
+            }
+        } else {
+            if (extraRm != null) {
+                if (moveOp.positionStart >= extraRm.positionStart) {
+                    moveOp.positionStart -= extraRm.itemCount;
+                }
+                if (moveOp.itemCount >= extraRm.positionStart) {
+                    moveOp.itemCount -= extraRm.itemCount;
+                }
+            }
+            if (moveOp.positionStart >= removeOp.positionStart) {
+                moveOp.positionStart -= removeOp.itemCount;
+            }
+            if (moveOp.itemCount >= removeOp.positionStart) {
+                moveOp.itemCount -= removeOp.itemCount;
+            }
+        }
+
+        list.set(movePos, removeOp);
+        if (moveOp.positionStart != moveOp.itemCount) {
+            list.set(removePos, moveOp);
+        } else {
+            list.remove(removePos);
+        }
+        if (extraRm != null) {
+            list.add(movePos, extraRm);
+        }
+    }
+
+    private void swapMoveAdd(List<UpdateOp> list, int move, UpdateOp moveOp, int add,
+            UpdateOp addOp) {
+        int offset = 0;
+        // going in reverse, first revert the effect of add
+        if (moveOp.itemCount < addOp.positionStart) {
+            offset--;
+        }
+        if (moveOp.positionStart < addOp.positionStart) {
+            offset++;
+        }
+        if (addOp.positionStart <= moveOp.positionStart) {
+            moveOp.positionStart += addOp.itemCount;
+        }
+        if (addOp.positionStart <= moveOp.itemCount) {
+            moveOp.itemCount += addOp.itemCount;
+        }
+        addOp.positionStart += offset;
+        list.set(move, addOp);
+        list.set(add, moveOp);
+    }
+
+    void swapMoveUpdate(List<UpdateOp> list, int move, UpdateOp moveOp, int update,
+            UpdateOp updateOp) {
+        UpdateOp extraUp1 = null;
+        UpdateOp extraUp2 = null;
+        // going in reverse, first revert the effect of add
+        if (moveOp.itemCount < updateOp.positionStart) {
+            updateOp.positionStart--;
+        } else if (moveOp.itemCount < updateOp.positionStart + updateOp.itemCount) {
+            // moved item is updated. add an update for it
+            updateOp.itemCount--;
+            extraUp1 = mCallback.obtainUpdateOp(UPDATE, moveOp.positionStart, 1);
+        }
+        // now affect of add is consumed. now apply effect of first remove
+        if (moveOp.positionStart <= updateOp.positionStart) {
+            updateOp.positionStart++;
+        } else if (moveOp.positionStart < updateOp.positionStart + updateOp.itemCount) {
+            final int remaining = updateOp.positionStart + updateOp.itemCount
+                    - moveOp.positionStart;
+            extraUp2 = mCallback.obtainUpdateOp(UPDATE, moveOp.positionStart + 1, remaining);
+            updateOp.itemCount -= remaining;
+        }
+        list.set(update, moveOp);
+        if (updateOp.itemCount > 0) {
+            list.set(move, updateOp);
+        } else {
+            list.remove(move);
+            mCallback.recycleUpdateOp(updateOp);
+        }
+        if (extraUp1 != null) {
+            list.add(move, extraUp1);
+        }
+        if (extraUp2 != null) {
+            list.add(move, extraUp2);
+        }
+    }
+
+    private int getLastMoveOutOfOrder(List<UpdateOp> list) {
+        boolean foundNonMove = false;
+        for (int i = list.size() - 1; i >= 0; i--) {
+            final UpdateOp op1 = list.get(i);
+            if (op1.cmd == MOVE) {
+                if (foundNonMove) {
+                    return i;
+                }
+            } else {
+                foundNonMove = true;
+            }
+        }
+        return -1;
+    }
+
+    static interface Callback {
+
+        UpdateOp obtainUpdateOp(int cmd, int startPosition, int itemCount);
+
+        void recycleUpdateOp(UpdateOp op);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/OrientationHelper.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/OrientationHelper.java
new file mode 100644
index 000000000..bfe380636
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/OrientationHelper.java
@@ -0,0 +1,338 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+
+import android.view.View;
+import android.widget.LinearLayout;
+
+/**
+ * Helper class for LayoutManagers to abstract measurements depending on the View's orientation.
+ * <p>
+ * It is developed to easily support vertical and horizontal orientations in a LayoutManager but
+ * can also be used to abstract calls around view bounds and child measurements with margins and
+ * decorations.
+ *
+ * @see #createHorizontalHelper(RecyclerView.LayoutManager)
+ * @see #createVerticalHelper(RecyclerView.LayoutManager)
+ */
+public abstract class OrientationHelper {
+
+    private static final int INVALID_SIZE = Integer.MIN_VALUE;
+
+    protected final RecyclerView.LayoutManager mLayoutManager;
+
+    public static final int HORIZONTAL = LinearLayout.HORIZONTAL;
+
+    public static final int VERTICAL = LinearLayout.VERTICAL;
+
+    private int mLastTotalSpace = INVALID_SIZE;
+
+    private OrientationHelper(RecyclerView.LayoutManager layoutManager) {
+        mLayoutManager = layoutManager;
+    }
+
+    /**
+     * Call this method after onLayout method is complete if state is NOT pre-layout.
+     * This method records information like layout bounds that might be useful in the next layout
+     * calculations.
+     */
+    public void onLayoutComplete() {
+        mLastTotalSpace = getTotalSpace();
+    }
+
+    /**
+     * Returns the layout space change between the previous layout pass and current layout pass.
+     * <p>
+     * Make sure you call {@link #onLayoutComplete()} at the end of your LayoutManager's
+     * {@link RecyclerView.LayoutManager#onLayoutChildren(RecyclerView.Recycler,
+     * RecyclerView.State)} method.
+     *
+     * @return The difference between the current total space and previous layout's total space.
+     * @see #onLayoutComplete()
+     */
+    public int getTotalSpaceChange() {
+        return INVALID_SIZE == mLastTotalSpace ? 0 : getTotalSpace() - mLastTotalSpace;
+    }
+
+    /**
+     * Returns the start of the view including its decoration and margin.
+     * <p>
+     * For example, for the horizontal helper, if a View's left is at pixel 20, has 2px left
+     * decoration and 3px left margin, returned value will be 15px.
+     *
+     * @param view The view element to check
+     * @return The first pixel of the element
+     * @see #getDecoratedEnd(android.view.View)
+     */
+    public abstract int getDecoratedStart(View view);
+
+    /**
+     * Returns the end of the view including its decoration and margin.
+     * <p>
+     * For example, for the horizontal helper, if a View's right is at pixel 200, has 2px right
+     * decoration and 3px right margin, returned value will be 205.
+     *
+     * @param view The view element to check
+     * @return The last pixel of the element
+     * @see #getDecoratedStart(android.view.View)
+     */
+    public abstract int getDecoratedEnd(View view);
+
+    /**
+     * Returns the space occupied by this View in the current orientation including decorations and
+     * margins.
+     *
+     * @param view The view element to check
+     * @return Total space occupied by this view
+     * @see #getDecoratedMeasurementInOther(View)
+     */
+    public abstract int getDecoratedMeasurement(View view);
+
+    /**
+     * Returns the space occupied by this View in the perpendicular orientation including
+     * decorations and margins.
+     *
+     * @param view The view element to check
+     * @return Total space occupied by this view in the perpendicular orientation to current one
+     * @see #getDecoratedMeasurement(View)
+     */
+    public abstract int getDecoratedMeasurementInOther(View view);
+
+    /**
+     * Returns the start position of the layout after the start padding is added.
+     *
+     * @return The very first pixel we can draw.
+     */
+    public abstract int getStartAfterPadding();
+
+    /**
+     * Returns the end position of the layout after the end padding is removed.
+     *
+     * @return The end boundary for this layout.
+     */
+    public abstract int getEndAfterPadding();
+
+    /**
+     * Returns the end position of the layout without taking padding into account.
+     *
+     * @return The end boundary for this layout without considering padding.
+     */
+    public abstract int getEnd();
+
+    /**
+     * Offsets all children's positions by the given amount.
+     *
+     * @param amount Value to add to each child's layout parameters
+     */
+    public abstract void offsetChildren(int amount);
+
+    /**
+     * Returns the total space to layout. This number is the difference between
+     * {@link #getEndAfterPadding()} and {@link #getStartAfterPadding()}.
+     *
+     * @return Total space to layout children
+     */
+    public abstract int getTotalSpace();
+
+    /**
+     * Offsets the child in this orientation.
+     *
+     * @param view   View to offset
+     * @param offset offset amount
+     */
+    public abstract void offsetChild(View view, int offset);
+
+    /**
+     * Returns the padding at the end of the layout. For horizontal helper, this is the right
+     * padding and for vertical helper, this is the bottom padding. This method does not check
+     * whether the layout is RTL or not.
+     *
+     * @return The padding at the end of the layout.
+     */
+    public abstract int getEndPadding();
+
+    /**
+     * Creates an OrientationHelper for the given LayoutManager and orientation.
+     *
+     * @param layoutManager LayoutManager to attach to
+     * @param orientation   Desired orientation. Should be {@link #HORIZONTAL} or {@link #VERTICAL}
+     * @return A new OrientationHelper
+     */
+    public static OrientationHelper createOrientationHelper(
+            RecyclerView.LayoutManager layoutManager, int orientation) {
+        switch (orientation) {
+            case HORIZONTAL:
+                return createHorizontalHelper(layoutManager);
+            case VERTICAL:
+                return createVerticalHelper(layoutManager);
+        }
+        throw new IllegalArgumentException("invalid orientation");
+    }
+
+    /**
+     * Creates a horizontal OrientationHelper for the given LayoutManager.
+     *
+     * @param layoutManager The LayoutManager to attach to.
+     * @return A new OrientationHelper
+     */
+    public static OrientationHelper createHorizontalHelper(
+            RecyclerView.LayoutManager layoutManager) {
+        return new OrientationHelper(layoutManager) {
+            @Override
+            public int getEndAfterPadding() {
+                return mLayoutManager.getWidth() - mLayoutManager.getPaddingRight();
+            }
+
+            @Override
+            public int getEnd() {
+                return mLayoutManager.getWidth();
+            }
+
+            @Override
+            public void offsetChildren(int amount) {
+                mLayoutManager.offsetChildrenHorizontal(amount);
+            }
+
+            @Override
+            public int getStartAfterPadding() {
+                return mLayoutManager.getPaddingLeft();
+            }
+
+            @Override
+            public int getDecoratedMeasurement(View view) {
+                final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                        view.getLayoutParams();
+                return mLayoutManager.getDecoratedMeasuredWidth(view) + params.leftMargin
+                        + params.rightMargin;
+            }
+
+            @Override
+            public int getDecoratedMeasurementInOther(View view) {
+                final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                        view.getLayoutParams();
+                return mLayoutManager.getDecoratedMeasuredHeight(view) + params.topMargin
+                        + params.bottomMargin;
+            }
+
+            @Override
+            public int getDecoratedEnd(View view) {
+                final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                        view.getLayoutParams();
+                return mLayoutManager.getDecoratedRight(view) + params.rightMargin;
+            }
+
+            @Override
+            public int getDecoratedStart(View view) {
+                final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                        view.getLayoutParams();
+                return mLayoutManager.getDecoratedLeft(view) - params.leftMargin;
+            }
+
+            @Override
+            public int getTotalSpace() {
+                return mLayoutManager.getWidth() - mLayoutManager.getPaddingLeft()
+                        - mLayoutManager.getPaddingRight();
+            }
+
+            @Override
+            public void offsetChild(View view, int offset) {
+                view.offsetLeftAndRight(offset);
+            }
+
+            @Override
+            public int getEndPadding() {
+                return mLayoutManager.getPaddingRight();
+            }
+        };
+    }
+
+    /**
+     * Creates a vertical OrientationHelper for the given LayoutManager.
+     *
+     * @param layoutManager The LayoutManager to attach to.
+     * @return A new OrientationHelper
+     */
+    public static OrientationHelper createVerticalHelper(RecyclerView.LayoutManager layoutManager) {
+        return new OrientationHelper(layoutManager) {
+            @Override
+            public int getEndAfterPadding() {
+                return mLayoutManager.getHeight() - mLayoutManager.getPaddingBottom();
+            }
+
+            @Override
+            public int getEnd() {
+                return mLayoutManager.getHeight();
+            }
+
+            @Override
+            public void offsetChildren(int amount) {
+                mLayoutManager.offsetChildrenVertical(amount);
+            }
+
+            @Override
+            public int getStartAfterPadding() {
+                return mLayoutManager.getPaddingTop();
+            }
+
+            @Override
+            public int getDecoratedMeasurement(View view) {
+                final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                        view.getLayoutParams();
+                return mLayoutManager.getDecoratedMeasuredHeight(view) + params.topMargin
+                        + params.bottomMargin;
+            }
+
+            @Override
+            public int getDecoratedMeasurementInOther(View view) {
+                final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                        view.getLayoutParams();
+                return mLayoutManager.getDecoratedMeasuredWidth(view) + params.leftMargin
+                        + params.rightMargin;
+            }
+
+            @Override
+            public int getDecoratedEnd(View view) {
+                final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                        view.getLayoutParams();
+                return mLayoutManager.getDecoratedBottom(view) + params.bottomMargin;
+            }
+
+            @Override
+            public int getDecoratedStart(View view) {
+                final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams)
+                        view.getLayoutParams();
+                return mLayoutManager.getDecoratedTop(view) - params.topMargin;
+            }
+
+            @Override
+            public int getTotalSpace() {
+                return mLayoutManager.getHeight() - mLayoutManager.getPaddingTop()
+                        - mLayoutManager.getPaddingBottom();
+            }
+
+            @Override
+            public void offsetChild(View view, int offset) {
+                view.offsetTopAndBottom(offset);
+            }
+
+            @Override
+            public int getEndPadding() {
+                return mLayoutManager.getPaddingBottom();
+            }
+        };
+    }
+}
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/PositionMap.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/PositionMap.java
new file mode 100644
index 000000000..b97bd5a65
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/PositionMap.java
@@ -0,0 +1,460 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.telegram.android.support.widget;
+
+import java.util.ArrayList;
+
+/**
+ * Like a SparseArray, but with the ability to offset key ranges for bulk insertions/deletions.
+ */
+class PositionMap<E> implements Cloneable {
+    private static final Object DELETED = new Object();
+    private boolean mGarbage = false;
+
+    private int[] mKeys;
+    private Object[] mValues;
+    private int mSize;
+
+    /**
+     * Creates a new SparseArray containing no mappings.
+     */
+    public PositionMap() {
+        this(10);
+    }
+
+    /**
+     * Creates a new PositionMap containing no mappings that will not
+     * require any additional memory allocation to store the specified
+     * number of mappings.  If you supply an initial capacity of 0, the
+     * sparse array will be initialized with a light-weight representation
+     * not requiring any additional array allocations.
+     */
+    public PositionMap(int initialCapacity) {
+        if (initialCapacity == 0) {
+            mKeys = ContainerHelpers.EMPTY_INTS;
+            mValues = ContainerHelpers.EMPTY_OBJECTS;
+        } else {
+            initialCapacity = idealIntArraySize(initialCapacity);
+            mKeys = new int[initialCapacity];
+            mValues = new Object[initialCapacity];
+        }
+        mSize = 0;
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public PositionMap<E> clone() {
+        PositionMap<E> clone = null;
+        try {
+            clone = (PositionMap<E>) super.clone();
+            clone.mKeys = mKeys.clone();
+            clone.mValues = mValues.clone();
+        } catch (CloneNotSupportedException cnse) {
+            /* ignore */
+        }
+        return clone;
+    }
+
+    /**
+     * Gets the Object mapped from the specified key, or <code>null</code>
+     * if no such mapping has been made.
+     */
+    public E get(int key) {
+        return get(key, null);
+    }
+
+    /**
+     * Gets the Object mapped from the specified key, or the specified Object
+     * if no such mapping has been made.
+     */
+    @SuppressWarnings("unchecked")
+    public E get(int key, E valueIfKeyNotFound) {
+        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
+
+        if (i < 0 || mValues[i] == DELETED) {
+            return valueIfKeyNotFound;
+        } else {
+            return (E) mValues[i];
+        }
+    }
+
+    /**
+     * Removes the mapping from the specified key, if there was any.
+     */
+    public void delete(int key) {
+        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
+
+        if (i >= 0) {
+            if (mValues[i] != DELETED) {
+                mValues[i] = DELETED;
+                mGarbage = true;
+            }
+        }
+    }
+
+    /**
+     * Alias for {@link #delete(int)}.
+     */
+    public void remove(int key) {
+        delete(key);
+    }
+
+    /**
+     * Removes the mapping at the specified index.
+     */
+    public void removeAt(int index) {
+        if (mValues[index] != DELETED) {
+            mValues[index] = DELETED;
+            mGarbage = true;
+        }
+    }
+
+    /**
+     * Remove a range of mappings as a batch.
+     *
+     * @param index Index to begin at
+     * @param size Number of mappings to remove
+     */
+    public void removeAtRange(int index, int size) {
+        final int end = Math.min(mSize, index + size);
+        for (int i = index; i < end; i++) {
+            removeAt(i);
+        }
+    }
+
+    public void insertKeyRange(int keyStart, int count) {
+
+    }
+
+    public void removeKeyRange(ArrayList<E> removedItems, int keyStart, int count) {
+
+    }
+
+    private void gc() {
+        // Log.e("SparseArray", "gc start with " + mSize);
+
+        int n = mSize;
+        int o = 0;
+        int[] keys = mKeys;
+        Object[] values = mValues;
+
+        for (int i = 0; i < n; i++) {
+            Object val = values[i];
+
+            if (val != DELETED) {
+                if (i != o) {
+                    keys[o] = keys[i];
+                    values[o] = val;
+                    values[i] = null;
+                }
+
+                o++;
+            }
+        }
+
+        mGarbage = false;
+        mSize = o;
+
+        // Log.e("SparseArray", "gc end with " + mSize);
+    }
+
+    /**
+     * Adds a mapping from the specified key to the specified value,
+     * replacing the previous mapping from the specified key if there
+     * was one.
+     */
+    public void put(int key, E value) {
+        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
+
+        if (i >= 0) {
+            mValues[i] = value;
+        } else {
+            i = ~i;
+
+            if (i < mSize && mValues[i] == DELETED) {
+                mKeys[i] = key;
+                mValues[i] = value;
+                return;
+            }
+
+            if (mGarbage && mSize >= mKeys.length) {
+                gc();
+
+                // Search again because indices may have changed.
+                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
+            }
+
+            if (mSize >= mKeys.length) {
+                int n = idealIntArraySize(mSize + 1);
+
+                int[] nkeys = new int[n];
+                Object[] nvalues = new Object[n];
+
+                // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
+                System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
+                System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
+
+                mKeys = nkeys;
+                mValues = nvalues;
+            }
+
+            if (mSize - i != 0) {
+                // Log.e("SparseArray", "move " + (mSize - i));
+                System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
+                System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
+            }
+
+            mKeys[i] = key;
+            mValues[i] = value;
+            mSize++;
+        }
+    }
+
+    /**
+     * Returns the number of key-value mappings that this SparseArray
+     * currently stores.
+     */
+    public int size() {
+        if (mGarbage) {
+            gc();
+        }
+
+        return mSize;
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the key from the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    public int keyAt(int index) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return mKeys[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns
+     * the value from the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    @SuppressWarnings("unchecked")
+    public E valueAt(int index) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return (E) mValues[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, sets a new
+     * value for the <code>index</code>th key-value mapping that this
+     * SparseArray stores.
+     */
+    public void setValueAt(int index, E value) {
+        if (mGarbage) {
+            gc();
+        }
+
+        mValues[index] = value;
+    }
+
+    /**
+     * Returns the index for which {@link #keyAt} would return the
+     * specified key, or a negative number if the specified
+     * key is not mapped.
+     */
+    public int indexOfKey(int key) {
+        if (mGarbage) {
+            gc();
+        }
+
+        return ContainerHelpers.binarySearch(mKeys, mSize, key);
+    }
+
+    /**
+     * Returns an index for which {@link #valueAt} would return the
+     * specified key, or a negative number if no keys map to the
+     * specified value.
+     * <p>Beware that this is a linear search, unlike lookups by key,
+     * and that multiple keys can map to the same value and this will
+     * find only one of them.
+     * <p>Note also that unlike most collections' {@code indexOf} methods,
+     * this method compares values using {@code ==} rather than {@code equals}.
+     */
+    public int indexOfValue(E value) {
+        if (mGarbage) {
+            gc();
+        }
+
+        for (int i = 0; i < mSize; i++)
+            if (mValues[i] == value)
+                return i;
+
+        return -1;
+    }
+
+    /**
+     * Removes all key-value mappings from this SparseArray.
+     */
+    public void clear() {
+        int n = mSize;
+        Object[] values = mValues;
+
+        for (int i = 0; i < n; i++) {
+            values[i] = null;
+        }
+
+        mSize = 0;
+        mGarbage = false;
+    }
+
+    /**
+     * Puts a key/value pair into the array, optimizing for the case where
+     * the key is greater than all existing keys in the array.
+     */
+    public void append(int key, E value) {
+        if (mSize != 0 && key <= mKeys[mSize - 1]) {
+            put(key, value);
+            return;
+        }
+
+        if (mGarbage && mSize >= mKeys.length) {
+            gc();
+        }
+
+        int pos = mSize;
+        if (pos >= mKeys.length) {
+            int n = idealIntArraySize(pos + 1);
+
+            int[] nkeys = new int[n];
+            Object[] nvalues = new Object[n];
+
+            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
+            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
+            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
+
+            mKeys = nkeys;
+            mValues = nvalues;
+        }
+
+        mKeys[pos] = key;
+        mValues[pos] = value;
+        mSize = pos + 1;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * <p>This implementation composes a string by iterating over its mappings. If
+     * this map contains itself as a value, the string "(this Map)"
+     * will appear in its place.
+     */
+    @Override
+    public String toString() {
+        if (size() <= 0) {
+            return "{}";
+        }
+
+        StringBuilder buffer = new StringBuilder(mSize * 28);
+        buffer.append('{');
+        for (int i=0; i<mSize; i++) {
+            if (i > 0) {
+                buffer.append(", ");
+            }
+            int key = keyAt(i);
+            buffer.append(key);
+            buffer.append('=');
+            Object value = valueAt(i);
+            if (value != this) {
+                buffer.append(value);
+            } else {
+                buffer.append("(this Map)");
+            }
+        }
+        buffer.append('}');
+        return buffer.toString();
+    }
+
+    static int idealByteArraySize(int need) {
+        for (int i = 4; i < 32; i++)
+            if (need <= (1 << i) - 12)
+                return (1 << i) - 12;
+
+        return need;
+    }
+
+    static int idealBooleanArraySize(int need) {
+        return idealByteArraySize(need);
+    }
+
+    static int idealShortArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    static int idealCharArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    static int idealIntArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    static int idealFloatArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    static int idealObjectArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    static int idealLongArraySize(int need) {
+        return idealByteArraySize(need * 8) / 8;
+    }
+
+    static class ContainerHelpers {
+        static final boolean[] EMPTY_BOOLEANS = new boolean[0];
+        static final int[] EMPTY_INTS = new int[0];
+        static final long[] EMPTY_LONGS = new long[0];
+        static final Object[] EMPTY_OBJECTS = new Object[0];
+
+        // This is Arrays.binarySearch(), but doesn't do any argument validation.
+        static int binarySearch(int[] array, int size, int value) {
+            int lo = 0;
+            int hi = size - 1;
+
+            while (lo <= hi) {
+                final int mid = (lo + hi) >>> 1;
+                final int midVal = array[mid];
+
+                if (midVal < value) {
+                    lo = mid + 1;
+                } else if (midVal > value) {
+                    hi = mid - 1;
+                } else {
+                    return mid;  // value found
+                }
+            }
+            return ~lo;  // value not present
+        }
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerView.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerView.java
new file mode 100644
index 000000000..ebb4e89ba
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerView.java
@@ -0,0 +1,9319 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package org.telegram.android.support.widget;
+
+import android.content.Context;
+import android.database.Observable;
+import android.graphics.Canvas;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.Nullable;
+import android.support.v4.util.ArrayMap;
+import android.support.v4.view.InputDeviceCompat;
+import android.support.v4.view.MotionEventCompat;
+import android.support.v4.view.ScrollingView;
+import android.support.v4.view.VelocityTrackerCompat;
+import android.support.v4.view.ViewCompat;
+import android.support.v4.view.ViewConfigurationCompat;
+import android.support.v4.view.accessibility.AccessibilityEventCompat;
+import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
+import android.support.v4.view.accessibility.AccessibilityRecordCompat;
+import android.support.v4.widget.EdgeEffectCompat;
+import android.support.v4.widget.ScrollerCompat;
+import static org.telegram.android.support.widget.AdapterHelper.UpdateOp;
+import static org.telegram.android.support.widget.AdapterHelper.Callback;
+
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.SparseArray;
+import android.util.SparseIntArray;
+import android.util.TypedValue;
+import android.view.FocusFinder;
+import android.view.MotionEvent;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityManager;
+import android.view.animation.Interpolator;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A flexible view for providing a limited window into a large data set.
+ *
+ * <h3>Glossary of terms:</h3>
+ *
+ * <ul>
+ *     <li><em>Adapter:</em> A subclass of {@link Adapter} responsible for providing views
+ *     that represent items in a data set.</li>
+ *     <li><em>Position:</em> The position of a data item within an <em>Adapter</em>.</li>
+ *     <li><em>Index:</em> The index of an attached child view as used in a call to
+ *     {@link ViewGroup#getChildAt}. Contrast with <em>Position.</em></li>
+ *     <li><em>Binding:</em> The process of preparing a child view to display data corresponding
+ *     to a <em>position</em> within the adapter.</li>
+ *     <li><em>Recycle (view):</em> A view previously used to display data for a specific adapter
+ *     position may be placed in a cache for later reuse to display the same type of data again
+ *     later. This can drastically improve performance by skipping initial layout inflation
+ *     or construction.</li>
+ *     <li><em>Scrap (view):</em> A child view that has entered into a temporarily detached
+ *     state during layout. Scrap views may be reused without becoming fully detached
+ *     from the parent RecyclerView, either unmodified if no rebinding is required or modified
+ *     by the adapter if the view was considered <em>dirty</em>.</li>
+ *     <li><em>Dirty (view):</em> A child view that must be rebound by the adapter before
+ *     being displayed.</li>
+ * </ul>
+ *
+ * <h4>Positions in RecyclerView:</h4>
+ * <p>
+ * RecyclerView introduces an additional level of abstraction between the {@link Adapter} and
+ * {@link LayoutManager} to be able to detect data set changes in batches during a layout
+ * calculation. This saves LayoutManager from tracking adapter changes to calculate animations.
+ * It also helps with performance because all view bindings happen at the same time and unnecessary
+ * bindings are avoided.
+ * <p>
+ * For this reason, there are two types of <code>position</code> related methods in RecyclerView:
+ * <ul>
+ *     <li>layout position: Position of an item in the latest layout calculation. This is the
+ *     position from the LayoutManager's perspective.</li>
+ *     <li>adapter position: Position of an item in the adapter. This is the position from
+ *     the Adapter's perspective.</li>
+ * </ul>
+ * <p>
+ * These two positions are the same except the time between dispatching <code>adapter.notify*
+ * </code> events and calculating the updated layout.
+ * <p>
+ * Methods that return or receive <code>*LayoutPosition*</code> use position as of the latest
+ * layout calculation (e.g. {@link ViewHolder#getLayoutPosition()},
+ * {@link #findViewHolderForLayoutPosition(int)}). These positions include all changes until the
+ * last layout calculation. You can rely on these positions to be consistent with what user is
+ * currently seeing on the screen. For example, if you have a list of items on the screen and user
+ * asks for the 5<sup>th</sup> element, you should use these methods as they'll match what user
+ * is seeing.
+ * <p>
+ * The other set of position related methods are in the form of
+ * <code>*AdapterPosition*</code>. (e.g. {@link ViewHolder#getAdapterPosition()},
+ * {@link #findViewHolderForAdapterPosition(int)}) You should use these methods when you need to
+ * work with up-to-date adapter positions even if they may not have been reflected to layout yet.
+ * For example, if you want to access the item in the adapter on a ViewHolder click, you should use
+ * {@link ViewHolder#getAdapterPosition()}. Beware that these methods may not be able to calculate
+ * adapter positions if {@link Adapter#notifyDataSetChanged()} has been called and new layout has
+ * not yet been calculated. For this reasons, you should carefully handle {@link #NO_POSITION} or
+ * <code>null</code> results from these methods.
+ * <p>
+ * When writing a {@link LayoutManager} you almost always want to use layout positions whereas when
+ * writing an {@link Adapter}, you probably want to use adapter positions.
+ */
+public class RecyclerView extends ViewGroup implements ScrollingView {
+
+    private static final String TAG = "RecyclerView";
+
+    private static final boolean DEBUG = false;
+
+    /**
+     * On Kitkat and JB MR2, there is a bug which prevents DisplayList from being invalidated if
+     * a View is two levels deep(wrt to ViewHolder.itemView). DisplayList can be invalidated by
+     * setting View's visibility to INVISIBLE when View is detached. On Kitkat and JB MR2, Recycler
+     * recursively traverses itemView and invalidates display list for each ViewGroup that matches
+     * this criteria.
+     */
+    private static final boolean FORCE_INVALIDATE_DISPLAY_LIST = Build.VERSION.SDK_INT == 18
+            || Build.VERSION.SDK_INT == 19 || Build.VERSION.SDK_INT == 20;
+
+    private static final boolean DISPATCH_TEMP_DETACH = false;
+    public static final int HORIZONTAL = 0;
+    public static final int VERTICAL = 1;
+
+    public static final int NO_POSITION = -1;
+    public static final long NO_ID = -1;
+    public static final int INVALID_TYPE = -1;
+
+    /**
+     * Constant for use with {@link #setScrollingTouchSlop(int)}. Indicates
+     * that the RecyclerView should use the standard touch slop for smooth,
+     * continuous scrolling.
+     */
+    public static final int TOUCH_SLOP_DEFAULT = 0;
+
+    /**
+     * Constant for use with {@link #setScrollingTouchSlop(int)}. Indicates
+     * that the RecyclerView should use the standard touch slop for scrolling
+     * widgets that snap to a page or other coarse-grained barrier.
+     */
+    public static final int TOUCH_SLOP_PAGING = 1;
+
+    private static final int MAX_SCROLL_DURATION = 2000;
+
+    /**
+     * RecyclerView is calculating a scroll.
+     * If there are too many of these in Systrace, some Views inside RecyclerView might be causing
+     * it. Try to avoid using EditText, focusable views or handle them with care.
+     */
+    private static final String TRACE_SCROLL_TAG = "RV Scroll";
+
+    /**
+     * OnLayout has been called by the View system.
+     * If this shows up too many times in Systrace, make sure the children of RecyclerView do not
+     * update themselves directly. This will cause a full re-layout but when it happens via the
+     * Adapter notifyItemChanged, RecyclerView can avoid full layout calculation.
+     */
+    private static final String TRACE_ON_LAYOUT_TAG = "RV OnLayout";
+
+    /**
+     * NotifyDataSetChanged or equal has been called.
+     * If this is taking a long time, try sending granular notify adapter changes instead of just
+     * calling notifyDataSetChanged or setAdapter / swapAdapter. Adding stable ids to your adapter
+     * might help.
+     */
+    private static final String TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG = "RV FullInvalidate";
+
+    /**
+     * RecyclerView is doing a layout for partial adapter updates (we know what has changed)
+     * If this is taking a long time, you may have dispatched too many Adapter updates causing too
+     * many Views being rebind. Make sure all are necessary and also prefer using notify*Range
+     * methods.
+     */
+    private static final String TRACE_HANDLE_ADAPTER_UPDATES_TAG = "RV PartialInvalidate";
+
+    /**
+     * RecyclerView is rebinding a View.
+     * If this is taking a lot of time, consider optimizing your layout or make sure you are not
+     * doing extra operations in onBindViewHolder call.
+     */
+    private static final String TRACE_BIND_VIEW_TAG = "RV OnBindView";
+
+    /**
+     * RecyclerView is creating a new View.
+     * If too many of these present in Systrace:
+     * - There might be a problem in Recycling (e.g. custom Animations that set transient state and
+     * prevent recycling or ItemAnimator not implementing the contract properly. ({@link
+     * > Adapter#onFailedToRecycleView(ViewHolder)})
+     *
+     * - There might be too many item view types.
+     * > Try merging them
+     *
+     * - There might be too many itemChange animations and not enough space in RecyclerPool.
+     * >Try increasing your pool size and item cache size.
+     */
+    private static final String TRACE_CREATE_VIEW_TAG = "RV CreateView";
+
+    private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver();
+
+    final Recycler mRecycler = new Recycler();
+
+    private SavedState mPendingSavedState;
+
+    AdapterHelper mAdapterHelper;
+
+    ChildHelper mChildHelper;
+
+    /**
+     * Prior to L, there is no way to query this variable which is why we override the setter and
+     * track it here.
+     */
+    private boolean mClipToPadding;
+
+    /**
+     * Note: this Runnable is only ever posted if:
+     * 1) We've been through first layout
+     * 2) We know we have a fixed size (mHasFixedSize)
+     * 3) We're attached
+     */
+    private final Runnable mUpdateChildViewsRunnable = new Runnable() {
+        public void run() {
+            if (!mFirstLayoutComplete) {
+                // a layout request will happen, we should not do layout here.
+                return;
+            }
+            if (mDataSetHasChangedAfterLayout) {
+                dispatchLayout();
+            } else if (mAdapterHelper.hasPendingUpdates()) {
+                eatRequestLayout();
+                mAdapterHelper.preProcess();
+                if (!mLayoutRequestEaten) {
+                    // We run this after pre-processing is complete so that ViewHolders have their
+                    // final adapter positions. No need to run it if a layout is already requested.
+                    rebindUpdatedViewHolders();
+                }
+                resumeRequestLayout(true);
+            }
+        }
+    };
+
+    private final Rect mTempRect = new Rect();
+    private Adapter mAdapter;
+    private LayoutManager mLayout;
+    private RecyclerListener mRecyclerListener;
+    private final ArrayList<ItemDecoration> mItemDecorations = new ArrayList<ItemDecoration>();
+    private final ArrayList<OnItemTouchListener> mOnItemTouchListeners =
+            new ArrayList<OnItemTouchListener>();
+    private OnItemTouchListener mActiveOnItemTouchListener;
+    private boolean mIsAttached;
+    private boolean mHasFixedSize;
+    private boolean mFirstLayoutComplete;
+    private boolean mEatRequestLayout;
+    private boolean mLayoutRequestEaten;
+    // binary OR of change events that were eaten during a layout or scroll.
+    private int mEatenAccessibilityChangeFlags;
+    private boolean mAdapterUpdateDuringMeasure;
+    private final boolean mPostUpdatesOnAnimation;
+    private final AccessibilityManager mAccessibilityManager;
+
+    /**
+     * Set to true when an adapter data set changed notification is received.
+     * In that case, we cannot run any animations since we don't know what happened.
+     */
+    private boolean mDataSetHasChangedAfterLayout = false;
+
+    /**
+     * This variable is incremented during a dispatchLayout and/or scroll.
+     * Some methods should not be called during these periods (e.g. adapter data change).
+     * Doing so will create hard to find bugs so we better check it and throw an exception.
+     *
+     * @see #assertInLayoutOrScroll(String)
+     * @see #assertNotInLayoutOrScroll(String)
+     */
+    private int mLayoutOrScrollCounter = 0;
+
+    private EdgeEffectCompat mLeftGlow, mTopGlow, mRightGlow, mBottomGlow;
+
+    ItemAnimator mItemAnimator = new DefaultItemAnimator();
+
+    private static final int INVALID_POINTER = -1;
+
+    /**
+     * The RecyclerView is not currently scrolling.
+     * @see #getScrollState()
+     */
+    public static final int SCROLL_STATE_IDLE = 0;
+
+    /**
+     * The RecyclerView is currently being dragged by outside input such as user touch input.
+     * @see #getScrollState()
+     */
+    public static final int SCROLL_STATE_DRAGGING = 1;
+
+    /**
+     * The RecyclerView is currently animating to a final position while not under
+     * outside control.
+     * @see #getScrollState()
+     */
+    public static final int SCROLL_STATE_SETTLING = 2;
+
+    // Touch/scrolling handling
+
+    private int mScrollState = SCROLL_STATE_IDLE;
+    private int mScrollPointerId = INVALID_POINTER;
+    private VelocityTracker mVelocityTracker;
+    private int mInitialTouchX;
+    private int mInitialTouchY;
+    private int mLastTouchX;
+    private int mLastTouchY;
+    private int mTouchSlop;
+    private final int mMinFlingVelocity;
+    private final int mMaxFlingVelocity;
+    // This value is used when handling generic motion events.
+    private float mScrollFactor = Float.MIN_VALUE;
+
+    private final ViewFlinger mViewFlinger = new ViewFlinger();
+
+    final State mState = new State();
+
+    private OnScrollListener mScrollListener;
+    private List<OnScrollListener> mScrollListeners;
+
+    // For use in item animations
+    boolean mItemsAddedOrRemoved = false;
+    boolean mItemsChanged = false;
+    private ItemAnimator.ItemAnimatorListener mItemAnimatorListener =
+            new ItemAnimatorRestoreListener();
+    private boolean mPostedAnimatorRunner = false;
+    private RecyclerViewAccessibilityDelegate mAccessibilityDelegate;
+
+    // simple array to keep min and max child position during a layout calculation
+    // preserved not to create a new one in each layout pass
+    private final int[] mMinMaxLayoutPositions = new int[2];
+
+    private Runnable mItemAnimatorRunner = new Runnable() {
+        @Override
+        public void run() {
+            if (mItemAnimator != null) {
+                mItemAnimator.runPendingAnimations();
+            }
+            mPostedAnimatorRunner = false;
+        }
+    };
+
+    private static final Interpolator sQuinticInterpolator = new Interpolator() {
+        public float getInterpolation(float t) {
+            t -= 1.0f;
+            return t * t * t * t * t + 1.0f;
+        }
+    };
+
+    public RecyclerView(Context context) {
+        this(context, null);
+    }
+
+    public RecyclerView(Context context, @Nullable AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        setFocusableInTouchMode(true);
+        final int version = Build.VERSION.SDK_INT;
+        mPostUpdatesOnAnimation = version >= 16;
+
+        final ViewConfiguration vc = ViewConfiguration.get(context);
+        mTouchSlop = vc.getScaledTouchSlop();
+        mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
+        mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
+        setWillNotDraw(ViewCompat.getOverScrollMode(this) == ViewCompat.OVER_SCROLL_NEVER);
+
+        mItemAnimator.setListener(mItemAnimatorListener);
+        initAdapterManager();
+        initChildrenHelper();
+        // If not explicitly specified this view is important for accessibility.
+        if (ViewCompat.getImportantForAccessibility(this)
+                == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
+            ViewCompat.setImportantForAccessibility(this,
+                    ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
+        }
+        mAccessibilityManager = (AccessibilityManager) getContext()
+                .getSystemService(Context.ACCESSIBILITY_SERVICE);
+        setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));
+    }
+
+    /**
+     * Returns the accessibility delegate compatibility implementation used by the RecyclerView.
+     * @return An instance of AccessibilityDelegateCompat used by RecyclerView
+     */
+    public RecyclerViewAccessibilityDelegate getCompatAccessibilityDelegate() {
+        return mAccessibilityDelegate;
+    }
+
+    /**
+     * Sets the accessibility delegate compatibility implementation used by RecyclerView.
+     * @param accessibilityDelegate The accessibility delegate to be used by RecyclerView.
+     */
+    public void setAccessibilityDelegateCompat(
+            RecyclerViewAccessibilityDelegate accessibilityDelegate) {
+        mAccessibilityDelegate = accessibilityDelegate;
+        ViewCompat.setAccessibilityDelegate(this, mAccessibilityDelegate);
+    }
+
+    private void initChildrenHelper() {
+        mChildHelper = new ChildHelper(new ChildHelper.Callback() {
+            @Override
+            public int getChildCount() {
+                return RecyclerView.this.getChildCount();
+            }
+
+            @Override
+            public void addView(View child, int index) {
+                RecyclerView.this.addView(child, index);
+                dispatchChildAttached(child);
+            }
+
+            @Override
+            public int indexOfChild(View view) {
+                return RecyclerView.this.indexOfChild(view);
+            }
+
+            @Override
+            public void removeViewAt(int index) {
+                final View child = RecyclerView.this.getChildAt(index);
+                if (child != null) {
+                    dispatchChildDetached(child);
+                }
+                RecyclerView.this.removeViewAt(index);
+            }
+
+            @Override
+            public View getChildAt(int offset) {
+                return RecyclerView.this.getChildAt(offset);
+            }
+
+            @Override
+            public void removeAllViews() {
+                final int count = getChildCount();
+                for (int i = 0; i < count; i ++) {
+                    dispatchChildDetached(getChildAt(i));
+                }
+                RecyclerView.this.removeAllViews();
+            }
+
+            @Override
+            public ViewHolder getChildViewHolder(View view) {
+                return getChildViewHolderInt(view);
+            }
+
+            @Override
+            public void attachViewToParent(View child, int index,
+                    ViewGroup.LayoutParams layoutParams) {
+                final ViewHolder vh = getChildViewHolderInt(child);
+                if (vh != null) {
+                    if (!vh.isTmpDetached() && !vh.shouldIgnore()) {
+                        throw new IllegalArgumentException("Called attach on a child which is not"
+                                + " detached: " + vh);
+                    }
+                    if (DEBUG) {
+                        Log.d(TAG, "reAttach " + vh);
+                    }
+                    vh.clearTmpDetachFlag();
+                }
+                RecyclerView.this.attachViewToParent(child, index, layoutParams);
+            }
+
+            @Override
+            public void detachViewFromParent(int offset) {
+                final View view = getChildAt(offset);
+                if (view != null) {
+                    final ViewHolder vh = getChildViewHolderInt(view);
+                    if (vh != null) {
+                        if (vh.isTmpDetached() && !vh.shouldIgnore()) {
+                            throw new IllegalArgumentException("called detach on an already"
+                                    + " detached child " + vh);
+                        }
+                        if (DEBUG) {
+                            Log.d(TAG, "tmpDetach " + vh);
+                        }
+                        vh.addFlags(ViewHolder.FLAG_TMP_DETACHED);
+                    }
+                }
+                RecyclerView.this.detachViewFromParent(offset);
+            }
+        });
+    }
+
+    void initAdapterManager() {
+        mAdapterHelper = new AdapterHelper(new Callback() {
+            @Override
+            public ViewHolder findViewHolder(int position) {
+                final ViewHolder vh = findViewHolderForPosition(position, true);
+                if (vh == null) {
+                    return null;
+                }
+                // ensure it is not hidden because for adapter helper, the only thing matter is that
+                // LM thinks view is a child.
+                if (mChildHelper.isHidden(vh.itemView)) {
+                    if (DEBUG) {
+                        Log.d(TAG, "assuming view holder cannot be find because it is hidden");
+                    }
+                    return null;
+                }
+                return vh;
+            }
+
+            @Override
+            public void offsetPositionsForRemovingInvisible(int start, int count) {
+                offsetPositionRecordsForRemove(start, count, true);
+                mItemsAddedOrRemoved = true;
+                mState.mDeletedInvisibleItemCountSincePreviousLayout += count;
+            }
+
+            @Override
+            public void offsetPositionsForRemovingLaidOutOrNewView(int positionStart, int itemCount) {
+                offsetPositionRecordsForRemove(positionStart, itemCount, false);
+                mItemsAddedOrRemoved = true;
+            }
+
+            @Override
+            public void markViewHoldersUpdated(int positionStart, int itemCount) {
+                viewRangeUpdate(positionStart, itemCount);
+                mItemsChanged = true;
+            }
+
+            @Override
+            public void onDispatchFirstPass(UpdateOp op) {
+                dispatchUpdate(op);
+            }
+
+            void dispatchUpdate(UpdateOp op) {
+                switch (op.cmd) {
+                    case UpdateOp.ADD:
+                        mLayout.onItemsAdded(RecyclerView.this, op.positionStart, op.itemCount);
+                        break;
+                    case UpdateOp.REMOVE:
+                        mLayout.onItemsRemoved(RecyclerView.this, op.positionStart, op.itemCount);
+                        break;
+                    case UpdateOp.UPDATE:
+                        mLayout.onItemsUpdated(RecyclerView.this, op.positionStart, op.itemCount);
+                        break;
+                    case UpdateOp.MOVE:
+                        mLayout.onItemsMoved(RecyclerView.this, op.positionStart, op.itemCount, 1);
+                        break;
+                }
+            }
+
+            @Override
+            public void onDispatchSecondPass(UpdateOp op) {
+                dispatchUpdate(op);
+            }
+
+            @Override
+            public void offsetPositionsForAdd(int positionStart, int itemCount) {
+                offsetPositionRecordsForInsert(positionStart, itemCount);
+                mItemsAddedOrRemoved = true;
+            }
+
+            @Override
+            public void offsetPositionsForMove(int from, int to) {
+                offsetPositionRecordsForMove(from, to);
+                // should we create mItemsMoved ?
+                mItemsAddedOrRemoved = true;
+            }
+        });
+    }
+
+    /**
+     * RecyclerView can perform several optimizations if it can know in advance that changes in
+     * adapter content cannot change the size of the RecyclerView itself.
+     * If your use of RecyclerView falls into this category, set this to true.
+     *
+     * @param hasFixedSize true if adapter changes cannot affect the size of the RecyclerView.
+     */
+    public void setHasFixedSize(boolean hasFixedSize) {
+        mHasFixedSize = hasFixedSize;
+    }
+
+    /**
+     * @return true if the app has specified that changes in adapter content cannot change
+     * the size of the RecyclerView itself.
+     */
+    public boolean hasFixedSize() {
+        return mHasFixedSize;
+    }
+
+    @Override
+    public void setClipToPadding(boolean clipToPadding) {
+        if (clipToPadding != mClipToPadding) {
+            invalidateGlows();
+        }
+        mClipToPadding = clipToPadding;
+        super.setClipToPadding(clipToPadding);
+        if (mFirstLayoutComplete) {
+            requestLayout();
+        }
+    }
+
+    /**
+     * Configure the scrolling touch slop for a specific use case.
+     *
+     * Set up the RecyclerView's scrolling motion threshold based on common usages.
+     * Valid arguments are {@link #TOUCH_SLOP_DEFAULT} and {@link #TOUCH_SLOP_PAGING}.
+     *
+     * @param slopConstant One of the <code>TOUCH_SLOP_</code> constants representing
+     *                     the intended usage of this RecyclerView
+     */
+    public void setScrollingTouchSlop(int slopConstant) {
+        final ViewConfiguration vc = ViewConfiguration.get(getContext());
+        switch (slopConstant) {
+            default:
+                Log.w(TAG, "setScrollingTouchSlop(): bad argument constant "
+                      + slopConstant + "; using default value");
+                // fall-through
+            case TOUCH_SLOP_DEFAULT:
+                mTouchSlop = vc.getScaledTouchSlop();
+                break;
+
+            case TOUCH_SLOP_PAGING:
+                mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(vc);
+                break;
+        }
+    }
+
+    /**
+     * Swaps the current adapter with the provided one. It is similar to
+     * {@link #setAdapter(Adapter)} but assumes existing adapter and the new adapter uses the same
+     * {@link ViewHolder} and does not clear the RecycledViewPool.
+     * <p>
+     * Note that it still calls onAdapterChanged callbacks.
+     *
+     * @param adapter The new adapter to set, or null to set no adapter.
+     * @param removeAndRecycleExistingViews If set to true, RecyclerView will recycle all existing
+     *                                      Views. If adapters have stable ids and/or you want to
+     *                                      animate the disappearing views, you may prefer to set
+     *                                      this to false.
+     * @see #setAdapter(Adapter)
+     */
+    public void swapAdapter(Adapter adapter, boolean removeAndRecycleExistingViews) {
+        setAdapterInternal(adapter, true, removeAndRecycleExistingViews);
+        setDataSetChangedAfterLayout();
+        requestLayout();
+    }
+    /**
+     * Set a new adapter to provide child views on demand.
+     * <p>
+     * When adapter is changed, all existing views are recycled back to the pool. If the pool has
+     * only one adapter, it will be cleared.
+     *
+     * @param adapter The new adapter to set, or null to set no adapter.
+     * @see #swapAdapter(Adapter, boolean)
+     */
+    public void setAdapter(Adapter adapter) {
+        setAdapterInternal(adapter, false, true);
+        requestLayout();
+    }
+
+    /**
+     * Replaces the current adapter with the new one and triggers listeners.
+     * @param adapter The new adapter
+     * @param compatibleWithPrevious If true, the new adapter is using the same View Holders and
+     *                               item types with the current adapter (helps us avoid cache
+     *                               invalidation).
+     * @param removeAndRecycleViews  If true, we'll remove and recycle all existing views. If
+     *                               compatibleWithPrevious is false, this parameter is ignored.
+     */
+    private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,
+            boolean removeAndRecycleViews) {
+        if (mAdapter != null) {
+            mAdapter.unregisterAdapterDataObserver(mObserver);
+            mAdapter.onDetachedFromRecyclerView(this);
+        }
+        if (!compatibleWithPrevious || removeAndRecycleViews) {
+            // end all running animations
+            if (mItemAnimator != null) {
+                mItemAnimator.endAnimations();
+            }
+            // Since animations are ended, mLayout.children should be equal to
+            // recyclerView.children. This may not be true if item animator's end does not work as
+            // expected. (e.g. not release children instantly). It is safer to use mLayout's child
+            // count.
+            if (mLayout != null) {
+                mLayout.removeAndRecycleAllViews(mRecycler);
+                mLayout.removeAndRecycleScrapInt(mRecycler);
+            }
+            // we should clear it here before adapters are swapped to ensure correct callbacks.
+            mRecycler.clear();
+        }
+        mAdapterHelper.reset();
+        final Adapter oldAdapter = mAdapter;
+        mAdapter = adapter;
+        if (adapter != null) {
+            adapter.registerAdapterDataObserver(mObserver);
+            adapter.onAttachedToRecyclerView(this);
+        }
+        if (mLayout != null) {
+            mLayout.onAdapterChanged(oldAdapter, mAdapter);
+        }
+        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);
+        mState.mStructureChanged = true;
+        markKnownViewsInvalid();
+    }
+
+    /**
+     * Retrieves the previously set adapter or null if no adapter is set.
+     *
+     * @return The previously set adapter
+     * @see #setAdapter(Adapter)
+     */
+    public Adapter getAdapter() {
+        return mAdapter;
+    }
+
+    /**
+     * Register a listener that will be notified whenever a child view is recycled.
+     *
+     * <p>This listener will be called when a LayoutManager or the RecyclerView decides
+     * that a child view is no longer needed. If an application associates expensive
+     * or heavyweight data with item views, this may be a good place to release
+     * or free those resources.</p>
+     *
+     * @param listener Listener to register, or null to clear
+     */
+    public void setRecyclerListener(RecyclerListener listener) {
+        mRecyclerListener = listener;
+    }
+
+    /**
+     * <p>Return the offset of the RecyclerView's text baseline from the its top
+     * boundary. If the LayoutManager of this RecyclerView does not support baseline alignment,
+     * this method returns -1.</p>
+     *
+     * @return the offset of the baseline within the RecyclerView's bounds or -1
+     *         if baseline alignment is not supported
+     */
+    @Override
+    public int getBaseline() {
+        if (mLayout != null) {
+            return mLayout.getBaseline();
+        } else {
+            return super.getBaseline();
+        }
+    }
+
+    /**
+     * Set the {@link LayoutManager} that this RecyclerView will use.
+     *
+     * <p>In contrast to other adapter-backed views such as {@link android.widget.ListView}
+     * or {@link android.widget.GridView}, RecyclerView allows client code to provide custom
+     * layout arrangements for child views. These arrangements are controlled by the
+     * {@link LayoutManager}. A LayoutManager must be provided for RecyclerView to function.</p>
+     *
+     * <p>Several default strategies are provided for common uses such as lists and grids.</p>
+     *
+     * @param layout LayoutManager to use
+     */
+    public void setLayoutManager(LayoutManager layout) {
+        if (layout == mLayout) {
+            return;
+        }
+        // TODO We should do this switch a dispachLayout pass and animate children. There is a good
+        // chance that LayoutManagers will re-use views.
+        if (mLayout != null) {
+            if (mIsAttached) {
+                mLayout.dispatchDetachedFromWindow(this, mRecycler);
+            }
+            mLayout.setRecyclerView(null);
+        }
+        mRecycler.clear();
+        mChildHelper.removeAllViewsUnfiltered();
+        mLayout = layout;
+        if (layout != null) {
+            if (layout.mRecyclerView != null) {
+                throw new IllegalArgumentException("LayoutManager " + layout +
+                        " is already attached to a RecyclerView: " + layout.mRecyclerView);
+            }
+            mLayout.setRecyclerView(this);
+            if (mIsAttached) {
+                mLayout.dispatchAttachedToWindow(this);
+            }
+        }
+        requestLayout();
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        SavedState state = new SavedState(super.onSaveInstanceState());
+        if (mPendingSavedState != null) {
+            state.copyFrom(mPendingSavedState);
+        } else if (mLayout != null) {
+            state.mLayoutState = mLayout.onSaveInstanceState();
+        } else {
+            state.mLayoutState = null;
+        }
+
+        return state;
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Parcelable state) {
+        mPendingSavedState = (SavedState) state;
+        super.onRestoreInstanceState(mPendingSavedState.getSuperState());
+        if (mLayout != null && mPendingSavedState.mLayoutState != null) {
+            mLayout.onRestoreInstanceState(mPendingSavedState.mLayoutState);
+        }
+    }
+
+    /**
+     * Override to prevent freezing of any views created by the adapter.
+     */
+    @Override
+    protected void dispatchSaveInstanceState(SparseArray<Parcelable> container) {
+        dispatchFreezeSelfOnly(container);
+    }
+
+    /**
+     * Override to prevent thawing of any views created by the adapter.
+     */
+    @Override
+    protected void dispatchRestoreInstanceState(SparseArray<Parcelable> container) {
+        dispatchThawSelfOnly(container);
+    }
+
+    /**
+     * Adds a view to the animatingViews list.
+     * mAnimatingViews holds the child views that are currently being kept around
+     * purely for the purpose of being animated out of view. They are drawn as a regular
+     * part of the child list of the RecyclerView, but they are invisible to the LayoutManager
+     * as they are managed separately from the regular child views.
+     * @param viewHolder The ViewHolder to be removed
+     */
+    private void addAnimatingView(ViewHolder viewHolder) {
+        final View view = viewHolder.itemView;
+        final boolean alreadyParented = view.getParent() == this;
+        mRecycler.unscrapView(getChildViewHolder(view));
+        if (viewHolder.isTmpDetached()) {
+            // re-attach
+            mChildHelper.attachViewToParent(view, -1, view.getLayoutParams(), true);
+        } else if(!alreadyParented) {
+            mChildHelper.addView(view, true);
+        } else {
+            mChildHelper.hide(view);
+        }
+    }
+
+    /**
+     * Removes a view from the animatingViews list.
+     * @param view The view to be removed
+     * @see #addAnimatingView(RecyclerView.ViewHolder)
+     * @return true if an animating view is removed
+     */
+    private boolean removeAnimatingView(View view) {
+        eatRequestLayout();
+        final boolean removed = mChildHelper.removeViewIfHidden(view);
+        if (removed) {
+            final ViewHolder viewHolder = getChildViewHolderInt(view);
+            mRecycler.unscrapView(viewHolder);
+            mRecycler.recycleViewHolderInternal(viewHolder);
+            if (DEBUG) {
+                Log.d(TAG, "after removing animated view: " + view + ", " + this);
+            }
+        }
+        resumeRequestLayout(false);
+        return removed;
+    }
+
+    /**
+     * Return the {@link LayoutManager} currently responsible for
+     * layout policy for this RecyclerView.
+     *
+     * @return The currently bound LayoutManager
+     */
+    public LayoutManager getLayoutManager() {
+        return mLayout;
+    }
+
+    /**
+     * Retrieve this RecyclerView's {@link RecycledViewPool}. This method will never return null;
+     * if no pool is set for this view a new one will be created. See
+     * {@link #setRecycledViewPool(RecycledViewPool) setRecycledViewPool} for more information.
+     *
+     * @return The pool used to store recycled item views for reuse.
+     * @see #setRecycledViewPool(RecycledViewPool)
+     */
+    public RecycledViewPool getRecycledViewPool() {
+        return mRecycler.getRecycledViewPool();
+    }
+
+    /**
+     * Recycled view pools allow multiple RecyclerViews to share a common pool of scrap views.
+     * This can be useful if you have multiple RecyclerViews with adapters that use the same
+     * view types, for example if you have several data sets with the same kinds of item views
+     * displayed by a {@link android.support.v4.view.ViewPager ViewPager}.
+     *
+     * @param pool Pool to set. If this parameter is null a new pool will be created and used.
+     */
+    public void setRecycledViewPool(RecycledViewPool pool) {
+        mRecycler.setRecycledViewPool(pool);
+    }
+
+    /**
+     * Sets a new {@link ViewCacheExtension} to be used by the Recycler.
+     *
+     * @param extension ViewCacheExtension to be used or null if you want to clear the existing one.
+     *
+     * @see {@link ViewCacheExtension#getViewForPositionAndType(Recycler, int, int)}
+     */
+    public void setViewCacheExtension(ViewCacheExtension extension) {
+        mRecycler.setViewCacheExtension(extension);
+    }
+
+    /**
+     * Set the number of offscreen views to retain before adding them to the potentially shared
+     * {@link #getRecycledViewPool() recycled view pool}.
+     *
+     * <p>The offscreen view cache stays aware of changes in the attached adapter, allowing
+     * a LayoutManager to reuse those views unmodified without needing to return to the adapter
+     * to rebind them.</p>
+     *
+     * @param size Number of views to cache offscreen before returning them to the general
+     *             recycled view pool
+     */
+    public void setItemViewCacheSize(int size) {
+        mRecycler.setViewCacheSize(size);
+    }
+
+    /**
+     * Return the current scrolling state of the RecyclerView.
+     *
+     * @return {@link #SCROLL_STATE_IDLE}, {@link #SCROLL_STATE_DRAGGING} or
+     * {@link #SCROLL_STATE_SETTLING}
+     */
+    public int getScrollState() {
+        return mScrollState;
+    }
+
+    private void setScrollState(int state) {
+        if (state == mScrollState) {
+            return;
+        }
+        if (DEBUG) {
+            Log.d(TAG, "setting scroll state to " + state + " from " + mScrollState,
+                    new Exception());
+        }
+        mScrollState = state;
+        if (state != SCROLL_STATE_SETTLING) {
+            stopScrollersInternal();
+        }
+        dispatchOnScrollStateChanged(state);
+    }
+
+    /**
+     * Add an {@link ItemDecoration} to this RecyclerView. Item decorations can
+     * affect both measurement and drawing of individual item views.
+     *
+     * <p>Item decorations are ordered. Decorations placed earlier in the list will
+     * be run/queried/drawn first for their effects on item views. Padding added to views
+     * will be nested; a padding added by an earlier decoration will mean further
+     * item decorations in the list will be asked to draw/pad within the previous decoration's
+     * given area.</p>
+     *
+     * @param decor Decoration to add
+     * @param index Position in the decoration chain to insert this decoration at. If this value
+     *              is negative the decoration will be added at the end.
+     */
+    public void addItemDecoration(ItemDecoration decor, int index) {
+        if (mLayout != null) {
+            mLayout.assertNotInLayoutOrScroll("Cannot add item decoration during a scroll  or"
+                    + " layout");
+        }
+        if (mItemDecorations.isEmpty()) {
+            setWillNotDraw(false);
+        }
+        if (index < 0) {
+            mItemDecorations.add(decor);
+        } else {
+            mItemDecorations.add(index, decor);
+        }
+        markItemDecorInsetsDirty();
+        requestLayout();
+    }
+
+    /**
+     * Add an {@link ItemDecoration} to this RecyclerView. Item decorations can
+     * affect both measurement and drawing of individual item views.
+     *
+     * <p>Item decorations are ordered. Decorations placed earlier in the list will
+     * be run/queried/drawn first for their effects on item views. Padding added to views
+     * will be nested; a padding added by an earlier decoration will mean further
+     * item decorations in the list will be asked to draw/pad within the previous decoration's
+     * given area.</p>
+     *
+     * @param decor Decoration to add
+     */
+    public void addItemDecoration(ItemDecoration decor) {
+        addItemDecoration(decor, -1);
+    }
+
+    /**
+     * Remove an {@link ItemDecoration} from this RecyclerView.
+     *
+     * <p>The given decoration will no longer impact the measurement and drawing of
+     * item views.</p>
+     *
+     * @param decor Decoration to remove
+     * @see #addItemDecoration(ItemDecoration)
+     */
+    public void removeItemDecoration(ItemDecoration decor) {
+        if (mLayout != null) {
+            mLayout.assertNotInLayoutOrScroll("Cannot remove item decoration during a scroll  or"
+                    + " layout");
+        }
+        mItemDecorations.remove(decor);
+        if (mItemDecorations.isEmpty()) {
+            setWillNotDraw(ViewCompat.getOverScrollMode(this) == ViewCompat.OVER_SCROLL_NEVER);
+        }
+        markItemDecorInsetsDirty();
+        requestLayout();
+    }
+
+    /**
+     * Set a listener that will be notified of any changes in scroll state or position.
+     *
+     * @param listener Listener to set or null to clear
+     *
+     * @deprecated Use {@link #addOnScrollListener(OnScrollListener)} and
+     *             {@link #removeOnScrollListener(OnScrollListener)}
+     */
+    @Deprecated
+    public void setOnScrollListener(OnScrollListener listener) {
+        mScrollListener = listener;
+    }
+
+    /**
+     * Add a listener that will be notified of any changes in scroll state or position.
+     *
+     * <p>Components that add a listener should take care to remove it when finished.
+     * Other components that take ownership of a view may call {@link #clearOnScrollListeners()}
+     * to remove all attached listeners.</p>
+     *
+     * @param listener listener to set or null to clear
+     */
+    public void addOnScrollListener(OnScrollListener listener) {
+        if (mScrollListeners == null) {
+            mScrollListeners = new ArrayList<OnScrollListener>();
+        }
+        mScrollListeners.add(listener);
+    }
+
+    /**
+     * Remove a listener that was notified of any changes in scroll state or position.
+     *
+     * @param listener listener to set or null to clear
+     */
+    public void removeOnScrollListener(OnScrollListener listener) {
+        if (mScrollListeners != null) {
+            mScrollListeners.remove(listener);
+        }
+    }
+
+    /**
+     * Remove all secondary listener that were notified of any changes in scroll state or position.
+     */
+    public void clearOnScrollListeners() {
+        if (mScrollListeners != null) {
+            mScrollListeners.clear();
+        }
+    }
+
+    /**
+     * Convenience method to scroll to a certain position.
+     *
+     * RecyclerView does not implement scrolling logic, rather forwards the call to
+     * {@link android.support.v7.widget.RecyclerView.LayoutManager#scrollToPosition(int)}
+     * @param position Scroll to this adapter position
+     * @see android.support.v7.widget.RecyclerView.LayoutManager#scrollToPosition(int)
+     */
+    public void scrollToPosition(int position) {
+        stopScroll();
+        if (mLayout == null) {
+            Log.e(TAG, "Cannot scroll to position a LayoutManager set. " +
+                    "Call setLayoutManager with a non-null argument.");
+            return;
+        }
+        mLayout.scrollToPosition(position);
+        awakenScrollBars();
+    }
+
+    /**
+     * Starts a smooth scroll to an adapter position.
+     * <p>
+     * To support smooth scrolling, you must override
+     * {@link LayoutManager#smoothScrollToPosition(RecyclerView, State, int)} and create a
+     * {@link SmoothScroller}.
+     * <p>
+     * {@link LayoutManager} is responsible for creating the actual scroll action. If you want to
+     * provide a custom smooth scroll logic, override
+     * {@link LayoutManager#smoothScrollToPosition(RecyclerView, State, int)} in your
+     * LayoutManager.
+     *
+     * @param position The adapter position to scroll to
+     * @see LayoutManager#smoothScrollToPosition(RecyclerView, State, int)
+     */
+    public void smoothScrollToPosition(int position) {
+        if (mLayout == null) {
+            Log.e(TAG, "Cannot smooth scroll without a LayoutManager set. " +
+                    "Call setLayoutManager with a non-null argument.");
+            return;
+        }
+        mLayout.smoothScrollToPosition(this, mState, position);
+    }
+
+    @Override
+    public void scrollTo(int x, int y) {
+        throw new UnsupportedOperationException(
+                "RecyclerView does not support scrolling to an absolute position.");
+    }
+
+    @Override
+    public void scrollBy(int x, int y) {
+        if (mLayout == null) {
+            Log.e(TAG, "Cannot scroll without a LayoutManager set. " +
+                    "Call setLayoutManager with a non-null argument.");
+            return;
+        }
+        final boolean canScrollHorizontal = mLayout.canScrollHorizontally();
+        final boolean canScrollVertical = mLayout.canScrollVertically();
+        if (canScrollHorizontal || canScrollVertical) {
+            scrollByInternal(canScrollHorizontal ? x : 0, canScrollVertical ? y : 0, false, 0, 0);
+        }
+    }
+
+    /**
+     * Helper method reflect data changes to the state.
+     * <p>
+     * Adapter changes during a scroll may trigger a crash because scroll assumes no data change
+     * but data actually changed.
+     * <p>
+     * This method consumes all deferred changes to avoid that case.
+     */
+    private void consumePendingUpdateOperations() {
+        mUpdateChildViewsRunnable.run();
+    }
+
+    /**
+     * Does not perform bounds checking. Used by internal methods that have already validated input.
+     * <p>
+     * It also reports any unused scroll request to the related EdgeEffect.
+     *
+     * @param x The amount of horizontal scroll request
+     * @param y The amount of vertical scroll request
+     * @param fromMotionEvent If request is originated from a MotionEvent, this should be set to
+     *                        true and motionX/motionY should be provided, false otherwise.
+     * @param motionX The x coordinate of the MotionEvent which triggered this scroll. Unused if
+     *                fromMotionEvent is false.
+     * @param motionY The y coordinate of the MotionEvent which triggered this scroll. Unused if
+     *                fromMotionEvent is false.
+     *
+     * @return Whether any scroll was consumed in either direction.
+     */
+    boolean scrollByInternal(int x, int y, boolean fromMotionEvent, int motionX, int motionY) {
+        int overscrollX = 0, overscrollY = 0;
+        int hresult = 0, vresult = 0;
+        consumePendingUpdateOperations();
+        if (mAdapter != null) {
+            eatRequestLayout();
+            onEnterLayoutOrScroll();
+            if (x != 0) {
+                hresult = mLayout.scrollHorizontallyBy(x, mRecycler, mState);
+                overscrollX = x - hresult;
+            }
+            if (y != 0) {
+                vresult = mLayout.scrollVerticallyBy(y, mRecycler, mState);
+                overscrollY = y - vresult;
+            }
+            if (supportsChangeAnimations()) {
+                // Fix up shadow views used by changing animations
+                int count = mChildHelper.getChildCount();
+                for (int i = 0; i < count; i++) {
+                    View view = mChildHelper.getChildAt(i);
+                    ViewHolder holder = getChildViewHolder(view);
+                    if (holder != null && holder.mShadowingHolder != null) {
+                        ViewHolder shadowingHolder = holder.mShadowingHolder;
+                        View shadowingView = shadowingHolder != null ? shadowingHolder.itemView : null;
+                        if (shadowingView != null) {
+                            int left = view.getLeft();
+                            int top = view.getTop();
+                            if (left != shadowingView.getLeft() || top != shadowingView.getTop()) {
+                                shadowingView.layout(left, top,
+                                        left + shadowingView.getWidth(),
+                                        top + shadowingView.getHeight());
+                            }
+                        }
+                    }
+                }
+            }
+            onExitLayoutOrScroll();
+            resumeRequestLayout(false);
+        }
+        if (!mItemDecorations.isEmpty()) {
+            invalidate();
+        }
+        if (ViewCompat.getOverScrollMode(this) != ViewCompat.OVER_SCROLL_NEVER) {
+            if (fromMotionEvent) {
+                pullGlows(motionX, overscrollX, motionY, overscrollY);
+            }
+            considerReleasingGlowsOnScroll(x, y);
+        }
+        if (hresult != 0 || vresult != 0) {
+            dispatchOnScrolled(hresult, vresult);
+        }
+        if (!awakenScrollBars()) {
+            invalidate();
+        }
+        return hresult != 0 || vresult != 0;
+    }
+
+    /**
+     * <p>Compute the horizontal offset of the horizontal scrollbar's thumb within the horizontal
+     * range. This value is used to compute the length of the thumb within the scrollbar's track.
+     * </p>
+     *
+     * <p>The range is expressed in arbitrary units that must be the same as the units used by
+     * {@link #computeHorizontalScrollRange()} and {@link #computeHorizontalScrollExtent()}.</p>
+     *
+     * <p>Default implementation returns 0.</p>
+     *
+     * <p>If you want to support scroll bars, override
+     * {@link RecyclerView.LayoutManager#computeHorizontalScrollOffset(RecyclerView.State)} in your
+     * LayoutManager. </p>
+     *
+     * @return The horizontal offset of the scrollbar's thumb
+     * @see android.support.v7.widget.RecyclerView.LayoutManager#computeHorizontalScrollOffset
+     * (RecyclerView.Adapter)
+     */
+    @Override
+    public int computeHorizontalScrollOffset() {
+        return mLayout.canScrollHorizontally() ? mLayout.computeHorizontalScrollOffset(mState)
+                : 0;
+    }
+
+    /**
+     * <p>Compute the horizontal extent of the horizontal scrollbar's thumb within the
+     * horizontal range. This value is used to compute the length of the thumb within the
+     * scrollbar's track.</p>
+     *
+     * <p>The range is expressed in arbitrary units that must be the same as the units used by
+     * {@link #computeHorizontalScrollRange()} and {@link #computeHorizontalScrollOffset()}.</p>
+     *
+     * <p>Default implementation returns 0.</p>
+     *
+     * <p>If you want to support scroll bars, override
+     * {@link RecyclerView.LayoutManager#computeHorizontalScrollExtent(RecyclerView.State)} in your
+     * LayoutManager.</p>
+     *
+     * @return The horizontal extent of the scrollbar's thumb
+     * @see RecyclerView.LayoutManager#computeHorizontalScrollExtent(RecyclerView.State)
+     */
+    @Override
+    public int computeHorizontalScrollExtent() {
+        return mLayout.canScrollHorizontally() ? mLayout.computeHorizontalScrollExtent(mState) : 0;
+    }
+
+    /**
+     * <p>Compute the horizontal range that the horizontal scrollbar represents.</p>
+     *
+     * <p>The range is expressed in arbitrary units that must be the same as the units used by
+     * {@link #computeHorizontalScrollExtent()} and {@link #computeHorizontalScrollOffset()}.</p>
+     *
+     * <p>Default implementation returns 0.</p>
+     *
+     * <p>If you want to support scroll bars, override
+     * {@link RecyclerView.LayoutManager#computeHorizontalScrollRange(RecyclerView.State)} in your
+     * LayoutManager.</p>
+     *
+     * @return The total horizontal range represented by the vertical scrollbar
+     * @see RecyclerView.LayoutManager#computeHorizontalScrollRange(RecyclerView.State)
+     */
+    @Override
+    public int computeHorizontalScrollRange() {
+        return mLayout.canScrollHorizontally() ? mLayout.computeHorizontalScrollRange(mState) : 0;
+    }
+
+    /**
+     * <p>Compute the vertical offset of the vertical scrollbar's thumb within the vertical range.
+     * This value is used to compute the length of the thumb within the scrollbar's track. </p>
+     *
+     * <p>The range is expressed in arbitrary units that must be the same as the units used by
+     * {@link #computeVerticalScrollRange()} and {@link #computeVerticalScrollExtent()}.</p>
+     *
+     * <p>Default implementation returns 0.</p>
+     *
+     * <p>If you want to support scroll bars, override
+     * {@link RecyclerView.LayoutManager#computeVerticalScrollOffset(RecyclerView.State)} in your
+     * LayoutManager.</p>
+     *
+     * @return The vertical offset of the scrollbar's thumb
+     * @see android.support.v7.widget.RecyclerView.LayoutManager#computeVerticalScrollOffset
+     * (RecyclerView.Adapter)
+     */
+    @Override
+    public int computeVerticalScrollOffset() {
+        return mLayout.canScrollVertically() ? mLayout.computeVerticalScrollOffset(mState) : 0;
+    }
+
+    /**
+     * <p>Compute the vertical extent of the vertical scrollbar's thumb within the vertical range.
+     * This value is used to compute the length of the thumb within the scrollbar's track.</p>
+     *
+     * <p>The range is expressed in arbitrary units that must be the same as the units used by
+     * {@link #computeVerticalScrollRange()} and {@link #computeVerticalScrollOffset()}.</p>
+     *
+     * <p>Default implementation returns 0.</p>
+     *
+     * <p>If you want to support scroll bars, override
+     * {@link RecyclerView.LayoutManager#computeVerticalScrollExtent(RecyclerView.State)} in your
+     * LayoutManager.</p>
+     *
+     * @return The vertical extent of the scrollbar's thumb
+     * @see RecyclerView.LayoutManager#computeVerticalScrollExtent(RecyclerView.State)
+     */
+    @Override
+    public int computeVerticalScrollExtent() {
+        return mLayout.canScrollVertically() ? mLayout.computeVerticalScrollExtent(mState) : 0;
+    }
+
+    /**
+     * <p>Compute the vertical range that the vertical scrollbar represents.</p>
+     *
+     * <p>The range is expressed in arbitrary units that must be the same as the units used by
+     * {@link #computeVerticalScrollExtent()} and {@link #computeVerticalScrollOffset()}.</p>
+     *
+     * <p>Default implementation returns 0.</p>
+     *
+     * <p>If you want to support scroll bars, override
+     * {@link RecyclerView.LayoutManager#computeVerticalScrollRange(RecyclerView.State)} in your
+     * LayoutManager.</p>
+     *
+     * @return The total vertical range represented by the vertical scrollbar
+     * @see RecyclerView.LayoutManager#computeVerticalScrollRange(RecyclerView.State)
+     */
+    @Override
+    public int computeVerticalScrollRange() {
+        return mLayout.canScrollVertically() ? mLayout.computeVerticalScrollRange(mState) : 0;
+    }
+
+
+    void eatRequestLayout() {
+        if (!mEatRequestLayout) {
+            mEatRequestLayout = true;
+            mLayoutRequestEaten = false;
+        }
+    }
+
+    void resumeRequestLayout(boolean performLayoutChildren) {
+        if (mEatRequestLayout) {
+            if (performLayoutChildren && mLayoutRequestEaten &&
+                    mLayout != null && mAdapter != null) {
+                dispatchLayout();
+            }
+            mEatRequestLayout = false;
+            mLayoutRequestEaten = false;
+        }
+    }
+
+    /**
+     * Animate a scroll by the given amount of pixels along either axis.
+     *
+     * @param dx Pixels to scroll horizontally
+     * @param dy Pixels to scroll vertically
+     */
+    public void smoothScrollBy(int dx, int dy) {
+        if (mLayout == null) {
+            Log.e(TAG, "Cannot smooth scroll without a LayoutManager set. " +
+                    "Call setLayoutManager with a non-null argument.");
+            return;
+        }
+        if (!mLayout.canScrollHorizontally()) {
+            dx = 0;
+        }
+        if (!mLayout.canScrollVertically()) {
+            dy = 0;
+        }
+        if (dx != 0 || dy != 0) {
+            mViewFlinger.smoothScrollBy(dx, dy);
+        }
+    }
+
+    /**
+     * Begin a standard fling with an initial velocity along each axis in pixels per second.
+     * If the velocity given is below the system-defined minimum this method will return false
+     * and no fling will occur.
+     *
+     * @param velocityX Initial horizontal velocity in pixels per second
+     * @param velocityY Initial vertical velocity in pixels per second
+     * @return true if the fling was started, false if the velocity was too low to fling or
+     * LayoutManager does not support scrolling in the axis fling is issued.
+     *
+     * @see LayoutManager#canScrollVertically()
+     * @see LayoutManager#canScrollHorizontally()
+     */
+    public boolean fling(int velocityX, int velocityY) {
+        if (mLayout == null) {
+            Log.e(TAG, "Cannot fling without a LayoutManager set. " +
+                    "Call setLayoutManager with a non-null argument.");
+            return false;
+        }
+        final boolean canScrollHorizontal = mLayout.canScrollHorizontally();
+        final boolean canScrollVertical = mLayout.canScrollVertically();
+        if (!canScrollHorizontal || Math.abs(velocityX) < mMinFlingVelocity) {
+            velocityX = 0;
+        }
+        if (!canScrollVertical || Math.abs(velocityY) < mMinFlingVelocity) {
+            velocityY = 0;
+        }
+        velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity));
+        velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity));
+        if (velocityX != 0 || velocityY != 0) {
+            mViewFlinger.fling(velocityX, velocityY);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Stop any current scroll in progress, such as one started by
+     * {@link #smoothScrollBy(int, int)}, {@link #fling(int, int)} or a touch-initiated fling.
+     */
+    public void stopScroll() {
+        setScrollState(SCROLL_STATE_IDLE);
+        stopScrollersInternal();
+    }
+
+    /**
+     * Similar to {@link #stopScroll()} but does not set the state.
+     */
+    private void stopScrollersInternal() {
+        mViewFlinger.stop();
+        if (mLayout != null) {
+            mLayout.stopSmoothScroller();
+        }
+    }
+
+    /**
+     * Apply a pull to relevant overscroll glow effects
+     */
+    private void pullGlows(int x, int overscrollX, int y, int overscrollY) {
+        boolean invalidate = false;
+        if (overscrollX < 0) {
+            ensureLeftGlow();
+            invalidate = mLeftGlow.onPull(-overscrollX / (float) getWidth(),
+                    1f - y  / (float) getHeight()) || invalidate;
+        } else if (overscrollX > 0) {
+            ensureRightGlow();
+            invalidate = mRightGlow.onPull(overscrollX / (float) getWidth(),
+                    y / (float) getHeight()) || invalidate;
+        }
+
+        if (overscrollY < 0) {
+            ensureTopGlow();
+            invalidate = mTopGlow.onPull(-overscrollY / (float) getHeight(),
+                    x / (float) getWidth()) || invalidate;
+        } else if (overscrollY > 0) {
+            ensureBottomGlow();
+            invalidate = mBottomGlow.onPull(overscrollY / (float) getHeight(),
+                    1f - x / (float) getWidth()) || invalidate;
+        }
+
+        if (invalidate || overscrollX != 0 || overscrollY != 0) {
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+    }
+
+    private void releaseGlows() {
+        boolean needsInvalidate = false;
+        if (mLeftGlow != null) needsInvalidate = mLeftGlow.onRelease();
+        if (mTopGlow != null) needsInvalidate |= mTopGlow.onRelease();
+        if (mRightGlow != null) needsInvalidate |= mRightGlow.onRelease();
+        if (mBottomGlow != null) needsInvalidate |= mBottomGlow.onRelease();
+        if (needsInvalidate) {
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+    }
+
+    private void considerReleasingGlowsOnScroll(int dx, int dy) {
+        boolean needsInvalidate = false;
+        if (mLeftGlow != null && !mLeftGlow.isFinished() && dx > 0) {
+            needsInvalidate = mLeftGlow.onRelease();
+        }
+        if (mRightGlow != null && !mRightGlow.isFinished() && dx < 0) {
+            needsInvalidate |= mRightGlow.onRelease();
+        }
+        if (mTopGlow != null && !mTopGlow.isFinished() && dy > 0) {
+            needsInvalidate |= mTopGlow.onRelease();
+        }
+        if (mBottomGlow != null && !mBottomGlow.isFinished() && dy < 0) {
+            needsInvalidate |= mBottomGlow.onRelease();
+        }
+        if (needsInvalidate) {
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+    }
+
+    void absorbGlows(int velocityX, int velocityY) {
+        if (velocityX < 0) {
+            ensureLeftGlow();
+            mLeftGlow.onAbsorb(-velocityX);
+        } else if (velocityX > 0) {
+            ensureRightGlow();
+            mRightGlow.onAbsorb(velocityX);
+        }
+
+        if (velocityY < 0) {
+            ensureTopGlow();
+            mTopGlow.onAbsorb(-velocityY);
+        } else if (velocityY > 0) {
+            ensureBottomGlow();
+            mBottomGlow.onAbsorb(velocityY);
+        }
+
+        if (velocityX != 0 || velocityY != 0) {
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+    }
+
+    void ensureLeftGlow() {
+        if (mLeftGlow != null) {
+            return;
+        }
+        mLeftGlow = new EdgeEffectCompat(getContext());
+        if (mClipToPadding) {
+            mLeftGlow.setSize(getMeasuredHeight() - getPaddingTop() - getPaddingBottom(),
+                    getMeasuredWidth() - getPaddingLeft() - getPaddingRight());
+        } else {
+            mLeftGlow.setSize(getMeasuredHeight(), getMeasuredWidth());
+        }
+    }
+
+    void ensureRightGlow() {
+        if (mRightGlow != null) {
+            return;
+        }
+        mRightGlow = new EdgeEffectCompat(getContext());
+        if (mClipToPadding) {
+            mRightGlow.setSize(getMeasuredHeight() - getPaddingTop() - getPaddingBottom(),
+                    getMeasuredWidth() - getPaddingLeft() - getPaddingRight());
+        } else {
+            mRightGlow.setSize(getMeasuredHeight(), getMeasuredWidth());
+        }
+    }
+
+    void ensureTopGlow() {
+        if (mTopGlow != null) {
+            return;
+        }
+        mTopGlow = new EdgeEffectCompat(getContext());
+        if (mClipToPadding) {
+            mTopGlow.setSize(getMeasuredWidth() - getPaddingLeft() - getPaddingRight(),
+                    getMeasuredHeight() - getPaddingTop() - getPaddingBottom());
+        } else {
+            mTopGlow.setSize(getMeasuredWidth(), getMeasuredHeight());
+        }
+
+    }
+
+    void ensureBottomGlow() {
+        if (mBottomGlow != null) {
+            return;
+        }
+        mBottomGlow = new EdgeEffectCompat(getContext());
+        if (mClipToPadding) {
+            mBottomGlow.setSize(getMeasuredWidth() - getPaddingLeft() - getPaddingRight(),
+                    getMeasuredHeight() - getPaddingTop() - getPaddingBottom());
+        } else {
+            mBottomGlow.setSize(getMeasuredWidth(), getMeasuredHeight());
+        }
+    }
+
+    void invalidateGlows() {
+        mLeftGlow = mRightGlow = mTopGlow = mBottomGlow = null;
+    }
+
+    // Focus handling
+
+    @Override
+    public View focusSearch(View focused, int direction) {
+        View result = mLayout.onInterceptFocusSearch(focused, direction);
+        if (result != null) {
+            return result;
+        }
+        final FocusFinder ff = FocusFinder.getInstance();
+        result = ff.findNextFocus(this, focused, direction);
+        if (result == null && mAdapter != null && mLayout != null) {
+            eatRequestLayout();
+            result = mLayout.onFocusSearchFailed(focused, direction, mRecycler, mState);
+            resumeRequestLayout(false);
+        }
+        return result != null ? result : super.focusSearch(focused, direction);
+    }
+
+    @Override
+    public void requestChildFocus(View child, View focused) {
+        if (!mLayout.onRequestChildFocus(this, mState, child, focused) && focused != null) {
+            mTempRect.set(0, 0, focused.getWidth(), focused.getHeight());
+
+            // get item decor offsets w/o refreshing. If they are invalid, there will be another
+            // layout pass to fix them, then it is LayoutManager's responsibility to keep focused
+            // View in viewport.
+            final ViewGroup.LayoutParams focusedLayoutParams = focused.getLayoutParams();
+            if (focusedLayoutParams instanceof LayoutParams) {
+                // if focused child has item decors, use them. Otherwise, ignore.
+                final LayoutParams lp = (LayoutParams) focusedLayoutParams;
+                if (!lp.mInsetsDirty) {
+                    final Rect insets = lp.mDecorInsets;
+                    mTempRect.left -= insets.left;
+                    mTempRect.right += insets.right;
+                    mTempRect.top -= insets.top;
+                    mTempRect.bottom += insets.bottom;
+                }
+            }
+
+            offsetDescendantRectToMyCoords(focused, mTempRect);
+            offsetRectIntoDescendantCoords(child, mTempRect);
+            requestChildRectangleOnScreen(child, mTempRect, !mFirstLayoutComplete);
+        }
+        super.requestChildFocus(child, focused);
+    }
+
+    @Override
+    public boolean requestChildRectangleOnScreen(View child, Rect rect, boolean immediate) {
+        return mLayout.requestChildRectangleOnScreen(this, child, rect, immediate);
+    }
+
+    @Override
+    public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {
+        if (mLayout == null || !mLayout.onAddFocusables(this, views, direction, focusableMode)) {
+            super.addFocusables(views, direction, focusableMode);
+        }
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        mLayoutOrScrollCounter = 0;
+        mIsAttached = true;
+        mFirstLayoutComplete = false;
+        if (mLayout != null) {
+            mLayout.dispatchAttachedToWindow(this);
+        }
+        mPostedAnimatorRunner = false;
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        if (mItemAnimator != null) {
+            mItemAnimator.endAnimations();
+        }
+        mFirstLayoutComplete = false;
+
+        stopScroll();
+        mIsAttached = false;
+        if (mLayout != null) {
+            mLayout.dispatchDetachedFromWindow(this, mRecycler);
+        }
+        removeCallbacks(mItemAnimatorRunner);
+    }
+
+    /**
+     * Checks if RecyclerView is in the middle of a layout or scroll and throws an
+     * {@link IllegalStateException} if it <b>is not</b>.
+     *
+     * @param message The message for the exception. Can be null.
+     * @see #assertNotInLayoutOrScroll(String)
+     */
+    void assertInLayoutOrScroll(String message) {
+        if (!isRunningLayoutOrScroll()) {
+            if (message == null) {
+                throw new IllegalStateException("Cannot call this method unless RecyclerView is "
+                        + "computing a layout or scrolling");
+            }
+            throw new IllegalStateException(message);
+
+        }
+    }
+
+    /**
+     * Checks if RecyclerView is in the middle of a layout or scroll and throws an
+     * {@link IllegalStateException} if it <b>is</b>.
+     *
+     * @param message The message for the exception. Can be null.
+     * @see #assertInLayoutOrScroll(String)
+     */
+    void assertNotInLayoutOrScroll(String message) {
+        if (isRunningLayoutOrScroll()) {
+            if (message == null) {
+                throw new IllegalStateException("Cannot call this method while RecyclerView is "
+                        + "computing a layout or scrolling");
+            }
+            throw new IllegalStateException(message);
+        }
+    }
+
+    /**
+     * Add an {@link OnItemTouchListener} to intercept touch events before they are dispatched
+     * to child views or this view's standard scrolling behavior.
+     *
+     * <p>Client code may use listeners to implement item manipulation behavior. Once a listener
+     * returns true from
+     * {@link OnItemTouchListener#onInterceptTouchEvent(RecyclerView, MotionEvent)} its
+     * {@link OnItemTouchListener#onTouchEvent(RecyclerView, MotionEvent)} method will be called
+     * for each incoming MotionEvent until the end of the gesture.</p>
+     *
+     * @param listener Listener to add
+     */
+    public void addOnItemTouchListener(OnItemTouchListener listener) {
+        mOnItemTouchListeners.add(listener);
+    }
+
+    /**
+     * Remove an {@link OnItemTouchListener}. It will no longer be able to intercept touch events.
+     *
+     * @param listener Listener to remove
+     */
+    public void removeOnItemTouchListener(OnItemTouchListener listener) {
+        mOnItemTouchListeners.remove(listener);
+        if (mActiveOnItemTouchListener == listener) {
+            mActiveOnItemTouchListener = null;
+        }
+    }
+
+    private boolean dispatchOnItemTouchIntercept(MotionEvent e) {
+        final int action = e.getAction();
+        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_DOWN) {
+            mActiveOnItemTouchListener = null;
+        }
+
+        final int listenerCount = mOnItemTouchListeners.size();
+        for (int i = 0; i < listenerCount; i++) {
+            final OnItemTouchListener listener = mOnItemTouchListeners.get(i);
+            if (listener.onInterceptTouchEvent(this, e) && action != MotionEvent.ACTION_CANCEL) {
+                mActiveOnItemTouchListener = listener;
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean dispatchOnItemTouch(MotionEvent e) {
+        final int action = e.getAction();
+        if (mActiveOnItemTouchListener != null) {
+            if (action == MotionEvent.ACTION_DOWN) {
+                // Stale state from a previous gesture, we're starting a new one. Clear it.
+                mActiveOnItemTouchListener = null;
+            } else {
+                mActiveOnItemTouchListener.onTouchEvent(this, e);
+                if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
+                    // Clean up for the next gesture.
+                    mActiveOnItemTouchListener = null;
+                }
+                return true;
+            }
+        }
+
+        // Listeners will have already received the ACTION_DOWN via dispatchOnItemTouchIntercept
+        // as called from onInterceptTouchEvent; skip it.
+        if (action != MotionEvent.ACTION_DOWN) {
+            final int listenerCount = mOnItemTouchListeners.size();
+            for (int i = 0; i < listenerCount; i++) {
+                final OnItemTouchListener listener = mOnItemTouchListeners.get(i);
+                if (listener.onInterceptTouchEvent(this, e)) {
+                    mActiveOnItemTouchListener = listener;
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent e) {
+        if (dispatchOnItemTouchIntercept(e)) {
+            cancelTouch();
+            return true;
+        }
+
+        final boolean canScrollHorizontally = mLayout.canScrollHorizontally();
+        final boolean canScrollVertically = mLayout.canScrollVertically();
+
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(e);
+
+        final int action = MotionEventCompat.getActionMasked(e);
+        final int actionIndex = MotionEventCompat.getActionIndex(e);
+
+        switch (action) {
+            case MotionEvent.ACTION_DOWN:
+                mScrollPointerId = MotionEventCompat.getPointerId(e, 0);
+                mInitialTouchX = mLastTouchX = (int) (e.getX() + 0.5f);
+                mInitialTouchY = mLastTouchY = (int) (e.getY() + 0.5f);
+
+                if (mScrollState == SCROLL_STATE_SETTLING) {
+                    getParent().requestDisallowInterceptTouchEvent(true);
+                    setScrollState(SCROLL_STATE_DRAGGING);
+                }
+                break;
+
+            case MotionEventCompat.ACTION_POINTER_DOWN:
+                mScrollPointerId = MotionEventCompat.getPointerId(e, actionIndex);
+                mInitialTouchX = mLastTouchX = (int) (MotionEventCompat.getX(e, actionIndex) + 0.5f);
+                mInitialTouchY = mLastTouchY = (int) (MotionEventCompat.getY(e, actionIndex) + 0.5f);
+                break;
+
+            case MotionEvent.ACTION_MOVE: {
+                final int index = MotionEventCompat.findPointerIndex(e, mScrollPointerId);
+                if (index < 0) {
+                    Log.e(TAG, "Error processing scroll; pointer index for id " +
+                            mScrollPointerId + " not found. Did any MotionEvents get skipped?");
+                    return false;
+                }
+
+                final int x = (int) (MotionEventCompat.getX(e, index) + 0.5f);
+                final int y = (int) (MotionEventCompat.getY(e, index) + 0.5f);
+                if (mScrollState != SCROLL_STATE_DRAGGING) {
+                    final int dx = x - mInitialTouchX;
+                    final int dy = y - mInitialTouchY;
+                    boolean startScroll = false;
+                    if (canScrollHorizontally && Math.abs(dx) > mTouchSlop) {
+                        mLastTouchX = mInitialTouchX + mTouchSlop * (dx < 0 ? -1 : 1);
+                        startScroll = true;
+                    }
+                    if (canScrollVertically && Math.abs(dy) > mTouchSlop) {
+                        mLastTouchY = mInitialTouchY + mTouchSlop * (dy < 0 ? -1 : 1);
+                        startScroll = true;
+                    }
+                    if (startScroll) {
+                        setScrollState(SCROLL_STATE_DRAGGING);
+                    }
+                }
+            } break;
+
+            case MotionEventCompat.ACTION_POINTER_UP: {
+                onPointerUp(e);
+            } break;
+
+            case MotionEvent.ACTION_UP: {
+                mVelocityTracker.clear();
+            } break;
+
+            case MotionEvent.ACTION_CANCEL: {
+                cancelTouch();
+            }
+        }
+        return mScrollState == SCROLL_STATE_DRAGGING;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent e) {
+        if (dispatchOnItemTouch(e)) {
+            cancelTouch();
+            return true;
+        }
+
+        final boolean canScrollHorizontally = mLayout.canScrollHorizontally();
+        final boolean canScrollVertically = mLayout.canScrollVertically();
+
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(e);
+
+        final int action = MotionEventCompat.getActionMasked(e);
+        final int actionIndex = MotionEventCompat.getActionIndex(e);
+
+        switch (action) {
+            case MotionEvent.ACTION_DOWN: {
+                mScrollPointerId = MotionEventCompat.getPointerId(e, 0);
+                mInitialTouchX = mLastTouchX = (int) (e.getX() + 0.5f);
+                mInitialTouchY = mLastTouchY = (int) (e.getY() + 0.5f);
+            } break;
+
+            case MotionEventCompat.ACTION_POINTER_DOWN: {
+                mScrollPointerId = MotionEventCompat.getPointerId(e, actionIndex);
+                mInitialTouchX = mLastTouchX = (int) (MotionEventCompat.getX(e, actionIndex) + 0.5f);
+                mInitialTouchY = mLastTouchY = (int) (MotionEventCompat.getY(e, actionIndex) + 0.5f);
+            } break;
+
+            case MotionEvent.ACTION_MOVE: {
+                final int index = MotionEventCompat.findPointerIndex(e, mScrollPointerId);
+                if (index < 0) {
+                    Log.e(TAG, "Error processing scroll; pointer index for id " +
+                            mScrollPointerId + " not found. Did any MotionEvents get skipped?");
+                    return false;
+                }
+
+                final int x = (int) (MotionEventCompat.getX(e, index) + 0.5f);
+                final int y = (int) (MotionEventCompat.getY(e, index) + 0.5f);
+                if (mScrollState != SCROLL_STATE_DRAGGING) {
+                    final int dx = x - mInitialTouchX;
+                    final int dy = y - mInitialTouchY;
+                    boolean startScroll = false;
+                    if (canScrollHorizontally && Math.abs(dx) > mTouchSlop) {
+                        mLastTouchX = mInitialTouchX + mTouchSlop * (dx < 0 ? -1 : 1);
+                        startScroll = true;
+                    }
+                    if (canScrollVertically && Math.abs(dy) > mTouchSlop) {
+                        mLastTouchY = mInitialTouchY + mTouchSlop * (dy < 0 ? -1 : 1);
+                        startScroll = true;
+                    }
+                    if (startScroll) {
+                        setScrollState(SCROLL_STATE_DRAGGING);
+                    }
+                }
+                if (mScrollState == SCROLL_STATE_DRAGGING) {
+                    final int dx = x - mLastTouchX;
+                    final int dy = y - mLastTouchY;
+                    if (scrollByInternal(canScrollHorizontally ? -dx : 0,
+                            canScrollVertically ? -dy : 0, true, x, y)) {
+                        getParent().requestDisallowInterceptTouchEvent(true);
+                    }
+                }
+                mLastTouchX = x;
+                mLastTouchY = y;
+            } break;
+
+            case MotionEventCompat.ACTION_POINTER_UP: {
+                onPointerUp(e);
+            } break;
+
+            case MotionEvent.ACTION_UP: {
+                mVelocityTracker.computeCurrentVelocity(1000, mMaxFlingVelocity);
+                final float xvel = canScrollHorizontally ?
+                        -VelocityTrackerCompat.getXVelocity(mVelocityTracker, mScrollPointerId) : 0;
+                final float yvel = canScrollVertically ?
+                        -VelocityTrackerCompat.getYVelocity(mVelocityTracker, mScrollPointerId) : 0;
+                if (!((xvel != 0 || yvel != 0) && fling((int) xvel, (int) yvel))) {
+                    setScrollState(SCROLL_STATE_IDLE);
+                }
+                mVelocityTracker.clear();
+                releaseGlows();
+            } break;
+
+            case MotionEvent.ACTION_CANCEL: {
+                cancelTouch();
+            } break;
+        }
+
+        return true;
+    }
+
+    private void cancelTouch() {
+        if (mVelocityTracker != null) {
+            mVelocityTracker.clear();
+        }
+        releaseGlows();
+        setScrollState(SCROLL_STATE_IDLE);
+    }
+
+    private void onPointerUp(MotionEvent e) {
+        final int actionIndex = MotionEventCompat.getActionIndex(e);
+        if (MotionEventCompat.getPointerId(e, actionIndex) == mScrollPointerId) {
+            // Pick a new pointer to pick up the slack.
+            final int newIndex = actionIndex == 0 ? 1 : 0;
+            mScrollPointerId = MotionEventCompat.getPointerId(e, newIndex);
+            mInitialTouchX = mLastTouchX = (int) (MotionEventCompat.getX(e, newIndex) + 0.5f);
+            mInitialTouchY = mLastTouchY = (int) (MotionEventCompat.getY(e, newIndex) + 0.5f);
+        }
+    }
+
+    // @Override
+    public boolean onGenericMotionEvent(MotionEvent event) {
+        if (mLayout == null) {
+            return false;
+        }
+        if ((MotionEventCompat.getSource(event) & InputDeviceCompat.SOURCE_CLASS_POINTER) != 0) {
+            if (event.getAction() == MotionEventCompat.ACTION_SCROLL) {
+                final float vScroll, hScroll;
+                if (mLayout.canScrollVertically()) {
+                    vScroll = MotionEventCompat
+                            .getAxisValue(event, MotionEventCompat.AXIS_VSCROLL);
+                } else {
+                    vScroll = 0f;
+                }
+                if (mLayout.canScrollHorizontally()) {
+                    hScroll = MotionEventCompat
+                            .getAxisValue(event, MotionEventCompat.AXIS_HSCROLL);
+                } else {
+                    hScroll = 0f;
+                }
+
+                if (vScroll != 0 || hScroll != 0) {
+                    final float scrollFactor = getScrollFactor();
+                    scrollBy((int) (hScroll * scrollFactor), (int) (vScroll * scrollFactor));
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Ported from View.getVerticalScrollFactor.
+     */
+    private float getScrollFactor() {
+        if (mScrollFactor == Float.MIN_VALUE) {
+            TypedValue outValue = new TypedValue();
+            if (getContext().getTheme().resolveAttribute(
+                    android.R.attr.listPreferredItemHeight, outValue, true)) {
+                mScrollFactor = outValue.getDimension(
+                        getContext().getResources().getDisplayMetrics());
+            } else {
+                return 0; //listPreferredItemHeight is not defined, no generic scrolling
+            }
+
+        }
+        return mScrollFactor;
+    }
+
+    @Override
+    protected void onMeasure(int widthSpec, int heightSpec) {
+        if (mAdapterUpdateDuringMeasure) {
+            eatRequestLayout();
+            processAdapterUpdatesAndSetAnimationFlags();
+
+            if (mState.mRunPredictiveAnimations) {
+                // TODO: try to provide a better approach.
+                // When RV decides to run predictive animations, we need to measure in pre-layout
+                // state so that pre-layout pass results in correct layout.
+                // On the other hand, this will prevent the layout manager from resizing properly.
+                mState.mInPreLayout = true;
+            } else {
+                // consume remaining updates to provide a consistent state with the layout pass.
+                mAdapterHelper.consumeUpdatesInOnePass();
+                mState.mInPreLayout = false;
+            }
+            mAdapterUpdateDuringMeasure = false;
+            resumeRequestLayout(false);
+        }
+
+        if (mAdapter != null) {
+            mState.mItemCount = mAdapter.getItemCount();
+        } else {
+            mState.mItemCount = 0;
+        }
+        if (mLayout == null) {
+            defaultOnMeasure(widthSpec, heightSpec);
+        } else {
+            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
+        }
+
+        mState.mInPreLayout = false; // clear
+    }
+
+    /**
+     * Used when onMeasure is called before layout manager is set
+     */
+    private void defaultOnMeasure(int widthSpec, int heightSpec) {
+        final int widthMode = MeasureSpec.getMode(widthSpec);
+        final int heightMode = MeasureSpec.getMode(heightSpec);
+        final int widthSize = MeasureSpec.getSize(widthSpec);
+        final int heightSize = MeasureSpec.getSize(heightSpec);
+
+        int width = 0;
+        int height = 0;
+
+        switch (widthMode) {
+            case MeasureSpec.EXACTLY:
+            case MeasureSpec.AT_MOST:
+                width = widthSize;
+                break;
+            case MeasureSpec.UNSPECIFIED:
+            default:
+                width = ViewCompat.getMinimumWidth(this);
+                break;
+        }
+
+        switch (heightMode) {
+            case MeasureSpec.EXACTLY:
+            case MeasureSpec.AT_MOST:
+                height = heightSize;
+                break;
+            case MeasureSpec.UNSPECIFIED:
+            default:
+                height = ViewCompat.getMinimumHeight(this);
+                break;
+        }
+
+        setMeasuredDimension(width, height);
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        if (w != oldw || h != oldh) {
+            invalidateGlows();
+        }
+    }
+
+    /**
+     * Sets the {@link ItemAnimator} that will handle animations involving changes
+     * to the items in this RecyclerView. By default, RecyclerView instantiates and
+     * uses an instance of {@link DefaultItemAnimator}. Whether item animations are
+     * enabled for the RecyclerView depends on the ItemAnimator and whether
+     * the LayoutManager {@link LayoutManager#supportsPredictiveItemAnimations()
+     * supports item animations}.
+     *
+     * @param animator The ItemAnimator being set. If null, no animations will occur
+     * when changes occur to the items in this RecyclerView.
+     */
+    public void setItemAnimator(ItemAnimator animator) {
+        if (mItemAnimator != null) {
+            mItemAnimator.endAnimations();
+            mItemAnimator.setListener(null);
+        }
+        mItemAnimator = animator;
+        if (mItemAnimator != null) {
+            mItemAnimator.setListener(mItemAnimatorListener);
+        }
+    }
+
+    private void onEnterLayoutOrScroll() {
+        mLayoutOrScrollCounter ++;
+    }
+
+    private void onExitLayoutOrScroll() {
+        mLayoutOrScrollCounter --;
+        if (mLayoutOrScrollCounter < 1) {
+            if (DEBUG && mLayoutOrScrollCounter < 0) {
+                throw new IllegalStateException("layout or scroll counter cannot go below zero."
+                        + "Some calls are not matching");
+            }
+            mLayoutOrScrollCounter = 0;
+            dispatchContentChangedIfNecessary();
+        }
+    }
+
+    private void dispatchContentChangedIfNecessary() {
+        final int flags = mEatenAccessibilityChangeFlags;
+        mEatenAccessibilityChangeFlags = 0;
+        if (flags != 0 && mAccessibilityManager != null && mAccessibilityManager.isEnabled()) {
+            final AccessibilityEvent event = AccessibilityEvent.obtain();
+            event.setEventType(AccessibilityEventCompat.TYPE_WINDOW_CONTENT_CHANGED);
+            AccessibilityEventCompat.setContentChangeTypes(event, flags);
+            sendAccessibilityEventUnchecked(event);
+        }
+    }
+
+    boolean isRunningLayoutOrScroll() {
+        return mLayoutOrScrollCounter > 0;
+    }
+
+    /**
+     * Returns true if an accessibility event should not be dispatched now. This happens when an
+     * accessibility request arrives while RecyclerView does not have a stable state which is very
+     * hard to handle for a LayoutManager. Instead, this method records necessary information about
+     * the event and dispatches a window change event after the critical section is finished.
+     *
+     * @return True if the accessibility event should be postponed.
+     */
+    boolean shouldDeferAccessibilityEvent(AccessibilityEvent event) {
+        if (isRunningLayoutOrScroll()) {
+            int type = 0;
+            if (event != null) {
+                type = AccessibilityEventCompat.getContentChangeTypes(event);
+            }
+            if (type == 0) {
+                type = AccessibilityEventCompat.CONTENT_CHANGE_TYPE_UNDEFINED;
+            }
+            mEatenAccessibilityChangeFlags |= type;
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void sendAccessibilityEventUnchecked(AccessibilityEvent event) {
+        if (shouldDeferAccessibilityEvent(event)) {
+            return;
+        }
+        super.sendAccessibilityEventUnchecked(event);
+    }
+
+    /**
+     * Gets the current ItemAnimator for this RecyclerView. A null return value
+     * indicates that there is no animator and that item changes will happen without
+     * any animations. By default, RecyclerView instantiates and
+     * uses an instance of {@link DefaultItemAnimator}.
+     *
+     * @return ItemAnimator The current ItemAnimator. If null, no animations will occur
+     * when changes occur to the items in this RecyclerView.
+     */
+    public ItemAnimator getItemAnimator() {
+        return mItemAnimator;
+    }
+
+    private boolean supportsChangeAnimations() {
+        return mItemAnimator != null && mItemAnimator.getSupportsChangeAnimations();
+    }
+
+    /**
+     * Post a runnable to the next frame to run pending item animations. Only the first such
+     * request will be posted, governed by the mPostedAnimatorRunner flag.
+     */
+    private void postAnimationRunner() {
+        if (!mPostedAnimatorRunner && mIsAttached) {
+            ViewCompat.postOnAnimation(this, mItemAnimatorRunner);
+            mPostedAnimatorRunner = true;
+        }
+    }
+
+    private boolean predictiveItemAnimationsEnabled() {
+        return (mItemAnimator != null && mLayout.supportsPredictiveItemAnimations());
+    }
+
+    /**
+     * Consumes adapter updates and calculates which type of animations we want to run.
+     * Called in onMeasure and dispatchLayout.
+     * <p>
+     * This method may process only the pre-layout state of updates or all of them.
+     */
+    private void processAdapterUpdatesAndSetAnimationFlags() {
+        if (mDataSetHasChangedAfterLayout) {
+            // Processing these items have no value since data set changed unexpectedly.
+            // Instead, we just reset it.
+            mAdapterHelper.reset();
+            markKnownViewsInvalid();
+            mLayout.onItemsChanged(this);
+        }
+        // simple animations are a subset of advanced animations (which will cause a
+        // pre-layout step)
+        // If layout supports predictive animations, pre-process to decide if we want to run them
+        if (mItemAnimator != null && mLayout.supportsPredictiveItemAnimations()) {
+            mAdapterHelper.preProcess();
+        } else {
+            mAdapterHelper.consumeUpdatesInOnePass();
+        }
+        boolean animationTypeSupported = (mItemsAddedOrRemoved && !mItemsChanged) ||
+                (mItemsAddedOrRemoved || (mItemsChanged && supportsChangeAnimations()));
+        mState.mRunSimpleAnimations = mFirstLayoutComplete && mItemAnimator != null &&
+                (mDataSetHasChangedAfterLayout || animationTypeSupported ||
+                        mLayout.mRequestedSimpleAnimations) &&
+                (!mDataSetHasChangedAfterLayout || mAdapter.hasStableIds());
+        mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations &&
+                animationTypeSupported && !mDataSetHasChangedAfterLayout &&
+                predictiveItemAnimationsEnabled();
+    }
+
+    /**
+     * Wrapper around layoutChildren() that handles animating changes caused by layout.
+     * Animations work on the assumption that there are five different kinds of items
+     * in play:
+     * PERSISTENT: items are visible before and after layout
+     * REMOVED: items were visible before layout and were removed by the app
+     * ADDED: items did not exist before layout and were added by the app
+     * DISAPPEARING: items exist in the data set before/after, but changed from
+     * visible to non-visible in the process of layout (they were moved off
+     * screen as a side-effect of other changes)
+     * APPEARING: items exist in the data set before/after, but changed from
+     * non-visible to visible in the process of layout (they were moved on
+     * screen as a side-effect of other changes)
+     * The overall approach figures out what items exist before/after layout and
+     * infers one of the five above states for each of the items. Then the animations
+     * are set up accordingly:
+     * PERSISTENT views are moved ({@link ItemAnimator#animateMove(ViewHolder, int, int, int, int)})
+     * REMOVED views are removed ({@link ItemAnimator#animateRemove(ViewHolder)})
+     * ADDED views are added ({@link ItemAnimator#animateAdd(ViewHolder)})
+     * DISAPPEARING views are moved off screen
+     * APPEARING views are moved on screen
+     */
+    void dispatchLayout() {
+        if (mAdapter == null) {
+            Log.e(TAG, "No adapter attached; skipping layout");
+            return;
+        }
+        if (mLayout == null) {
+            Log.e(TAG, "No layout manager attached; skipping layout");
+            return;
+        }
+        mState.mDisappearingViewsInLayoutPass.clear();
+        eatRequestLayout();
+        onEnterLayoutOrScroll();
+
+        processAdapterUpdatesAndSetAnimationFlags();
+
+        mState.mOldChangedHolders = mState.mRunSimpleAnimations && mItemsChanged
+                && supportsChangeAnimations() ? new ArrayMap<Long, ViewHolder>() : null;
+        mItemsAddedOrRemoved = mItemsChanged = false;
+        ArrayMap<View, Rect> appearingViewInitialBounds = null;
+        mState.mInPreLayout = mState.mRunPredictiveAnimations;
+        mState.mItemCount = mAdapter.getItemCount();
+        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);
+
+        if (mState.mRunSimpleAnimations) {
+            // Step 0: Find out where all non-removed items are, pre-layout
+            mState.mPreLayoutHolderMap.clear();
+            mState.mPostLayoutHolderMap.clear();
+            int count = mChildHelper.getChildCount();
+            for (int i = 0; i < count; ++i) {
+                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
+                if (holder.shouldIgnore() || (holder.isInvalid() && !mAdapter.hasStableIds())) {
+                    continue;
+                }
+                final View view = holder.itemView;
+                mState.mPreLayoutHolderMap.put(holder, new ItemHolderInfo(holder,
+                        view.getLeft(), view.getTop(), view.getRight(), view.getBottom()));
+            }
+        }
+        if (mState.mRunPredictiveAnimations) {
+            // Step 1: run prelayout: This will use the old positions of items. The layout manager
+            // is expected to layout everything, even removed items (though not to add removed
+            // items back to the container). This gives the pre-layout position of APPEARING views
+            // which come into existence as part of the real layout.
+
+            // Save old positions so that LayoutManager can run its mapping logic.
+            saveOldPositions();
+            // processAdapterUpdatesAndSetAnimationFlags already run pre-layout animations.
+            if (mState.mOldChangedHolders != null) {
+                int count = mChildHelper.getChildCount();
+                for (int i = 0; i < count; ++i) {
+                    final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
+                    if (holder.isChanged() && !holder.isRemoved() && !holder.shouldIgnore()) {
+                        long key = getChangedHolderKey(holder);
+                        mState.mOldChangedHolders.put(key, holder);
+                        mState.mPreLayoutHolderMap.remove(holder);
+                    }
+                }
+            }
+
+            final boolean didStructureChange = mState.mStructureChanged;
+            mState.mStructureChanged = false;
+            // temporarily disable flag because we are asking for previous layout
+            mLayout.onLayoutChildren(mRecycler, mState);
+            mState.mStructureChanged = didStructureChange;
+
+            appearingViewInitialBounds = new ArrayMap<View, Rect>();
+            for (int i = 0; i < mChildHelper.getChildCount(); ++i) {
+                boolean found = false;
+                View child = mChildHelper.getChildAt(i);
+                if (getChildViewHolderInt(child).shouldIgnore()) {
+                    continue;
+                }
+                for (int j = 0; j < mState.mPreLayoutHolderMap.size(); ++j) {
+                    ViewHolder holder = mState.mPreLayoutHolderMap.keyAt(j);
+                    if (holder.itemView == child) {
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found) {
+                    appearingViewInitialBounds.put(child, new Rect(child.getLeft(), child.getTop(),
+                            child.getRight(), child.getBottom()));
+                }
+            }
+            // we don't process disappearing list because they may re-appear in post layout pass.
+            clearOldPositions();
+            mAdapterHelper.consumePostponedUpdates();
+        } else {
+            clearOldPositions();
+            // in case pre layout did run but we decided not to run predictive animations.
+            mAdapterHelper.consumeUpdatesInOnePass();
+            if (mState.mOldChangedHolders != null) {
+                int count = mChildHelper.getChildCount();
+                for (int i = 0; i < count; ++i) {
+                    final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
+                    if (holder.isChanged() && !holder.isRemoved() && !holder.shouldIgnore()) {
+                        long key = getChangedHolderKey(holder);
+                        mState.mOldChangedHolders.put(key, holder);
+                        mState.mPreLayoutHolderMap.remove(holder);
+                    }
+                }
+            }
+        }
+        mState.mItemCount = mAdapter.getItemCount();
+        mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;
+
+        // Step 2: Run layout
+        mState.mInPreLayout = false;
+        mLayout.onLayoutChildren(mRecycler, mState);
+
+        mState.mStructureChanged = false;
+        mPendingSavedState = null;
+
+        // onLayoutChildren may have caused client code to disable item animations; re-check
+        mState.mRunSimpleAnimations = mState.mRunSimpleAnimations && mItemAnimator != null;
+
+        if (mState.mRunSimpleAnimations) {
+            // Step 3: Find out where things are now, post-layout
+            ArrayMap<Long, ViewHolder> newChangedHolders = mState.mOldChangedHolders != null ?
+                    new ArrayMap<Long, ViewHolder>() : null;
+            int count = mChildHelper.getChildCount();
+            for (int i = 0; i < count; ++i) {
+                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
+                if (holder.shouldIgnore()) {
+                    continue;
+                }
+                final View view = holder.itemView;
+                long key = getChangedHolderKey(holder);
+                if (newChangedHolders != null && mState.mOldChangedHolders.get(key) != null) {
+                    newChangedHolders.put(key, holder);
+                } else {
+                    mState.mPostLayoutHolderMap.put(holder, new ItemHolderInfo(holder,
+                            view.getLeft(), view.getTop(), view.getRight(), view.getBottom()));
+                }
+            }
+            processDisappearingList(appearingViewInitialBounds);
+            // Step 4: Animate DISAPPEARING and REMOVED items
+            int preLayoutCount = mState.mPreLayoutHolderMap.size();
+            for (int i = preLayoutCount - 1; i >= 0; i--) {
+                ViewHolder itemHolder = mState.mPreLayoutHolderMap.keyAt(i);
+                if (!mState.mPostLayoutHolderMap.containsKey(itemHolder)) {
+                    ItemHolderInfo disappearingItem = mState.mPreLayoutHolderMap.valueAt(i);
+                    mState.mPreLayoutHolderMap.removeAt(i);
+
+                    View disappearingItemView = disappearingItem.holder.itemView;
+                    mRecycler.unscrapView(disappearingItem.holder);
+                    animateDisappearance(disappearingItem);
+                }
+            }
+            // Step 5: Animate APPEARING and ADDED items
+            int postLayoutCount = mState.mPostLayoutHolderMap.size();
+            if (postLayoutCount > 0) {
+                for (int i = postLayoutCount - 1; i >= 0; i--) {
+                    ViewHolder itemHolder = mState.mPostLayoutHolderMap.keyAt(i);
+                    ItemHolderInfo info = mState.mPostLayoutHolderMap.valueAt(i);
+                    if ((mState.mPreLayoutHolderMap.isEmpty() ||
+                            !mState.mPreLayoutHolderMap.containsKey(itemHolder))) {
+                        mState.mPostLayoutHolderMap.removeAt(i);
+                        Rect initialBounds = (appearingViewInitialBounds != null) ?
+                                appearingViewInitialBounds.get(itemHolder.itemView) : null;
+                        animateAppearance(itemHolder, initialBounds,
+                                info.left, info.top);
+                    }
+                }
+            }
+            // Step 6: Animate PERSISTENT items
+            count = mState.mPostLayoutHolderMap.size();
+            for (int i = 0; i < count; ++i) {
+                ViewHolder postHolder = mState.mPostLayoutHolderMap.keyAt(i);
+                ItemHolderInfo postInfo = mState.mPostLayoutHolderMap.valueAt(i);
+                ItemHolderInfo preInfo = mState.mPreLayoutHolderMap.get(postHolder);
+                if (preInfo != null && postInfo != null) {
+                    if (preInfo.left != postInfo.left || preInfo.top != postInfo.top) {
+                        postHolder.setIsRecyclable(false);
+                        if (DEBUG) {
+                            Log.d(TAG, "PERSISTENT: " + postHolder +
+                                    " with view " + postHolder.itemView);
+                        }
+                        if (mItemAnimator.animateMove(postHolder,
+                                preInfo.left, preInfo.top, postInfo.left, postInfo.top)) {
+                            postAnimationRunner();
+                        }
+                    }
+                }
+            }
+            // Step 7: Animate CHANGING items
+            count = mState.mOldChangedHolders != null ? mState.mOldChangedHolders.size() : 0;
+            // traverse reverse in case view gets recycled while we are traversing the list.
+            for (int i = count - 1; i >= 0; i--) {
+                long key = mState.mOldChangedHolders.keyAt(i);
+                ViewHolder oldHolder = mState.mOldChangedHolders.get(key);
+                View oldView = oldHolder.itemView;
+                if (oldHolder.shouldIgnore()) {
+                    continue;
+                }
+                // We probably don't need this check anymore since these views are removed from
+                // the list if they are recycled.
+                if (mRecycler.mChangedScrap != null &&
+                        mRecycler.mChangedScrap.contains(oldHolder)) {
+                    animateChange(oldHolder, newChangedHolders.get(key));
+                } else if (DEBUG) {
+                    Log.e(TAG, "cannot find old changed holder in changed scrap :/" + oldHolder);
+                }
+            }
+        }
+        resumeRequestLayout(false);
+        mLayout.removeAndRecycleScrapInt(mRecycler);
+        mState.mPreviousLayoutItemCount = mState.mItemCount;
+        mDataSetHasChangedAfterLayout = false;
+        mState.mRunSimpleAnimations = false;
+        mState.mRunPredictiveAnimations = false;
+        onExitLayoutOrScroll();
+        mLayout.mRequestedSimpleAnimations = false;
+        if (mRecycler.mChangedScrap != null) {
+            mRecycler.mChangedScrap.clear();
+        }
+        mState.mOldChangedHolders = null;
+
+        if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) {
+            dispatchOnScrolled(0, 0);
+        }
+    }
+
+    private void findMinMaxChildLayoutPositions(int[] into) {
+        final int count = mChildHelper.getChildCount();
+        if (count == 0) {
+            into[0] = 0;
+            into[1] = 0;
+            return;
+        }
+        int minPositionPreLayout = Integer.MAX_VALUE;
+        int maxPositionPreLayout = Integer.MIN_VALUE;
+        for (int i = 0; i < count; ++i) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
+            if (holder.shouldIgnore()) {
+                continue;
+            }
+            final int pos = holder.getLayoutPosition();
+            if (pos < minPositionPreLayout) {
+                minPositionPreLayout = pos;
+            }
+            if (pos > maxPositionPreLayout) {
+                maxPositionPreLayout = pos;
+            }
+        }
+        into[0] = minPositionPreLayout;
+        into[1] = maxPositionPreLayout;
+    }
+
+    private boolean didChildRangeChange(int minPositionPreLayout, int maxPositionPreLayout) {
+        int count = mChildHelper.getChildCount();
+        if (count == 0) {
+            return minPositionPreLayout != 0 || maxPositionPreLayout != 0;
+        }
+        for (int i = 0; i < count; ++i) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
+            if (holder.shouldIgnore()) {
+                continue;
+            }
+            final int pos = holder.getLayoutPosition();
+            if (pos < minPositionPreLayout || pos > maxPositionPreLayout) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    protected void removeDetachedView(View child, boolean animate) {
+        ViewHolder vh = getChildViewHolderInt(child);
+        if (vh != null) {
+            if (vh.isTmpDetached()) {
+                vh.clearTmpDetachFlag();
+            } else if (!vh.shouldIgnore()) {
+                throw new IllegalArgumentException("Called removeDetachedView with a view which"
+                        + " is not flagged as tmp detached." + vh);
+            }
+        }
+        dispatchChildDetached(child);
+        super.removeDetachedView(child, animate);
+    }
+
+    /**
+     * Returns a unique key to be used while handling change animations.
+     * It might be child's position or stable id depending on the adapter type.
+     */
+    long getChangedHolderKey(ViewHolder holder) {
+        return mAdapter.hasStableIds() ? holder.getItemId() : holder.mPosition;
+    }
+
+    /**
+     * A LayoutManager may want to layout a view just to animate disappearance.
+     * This method handles those views and triggers remove animation on them.
+     */
+    private void processDisappearingList(ArrayMap<View, Rect> appearingViews) {
+        final List<View> disappearingList = mState.mDisappearingViewsInLayoutPass;
+        for (int i = disappearingList.size() - 1; i >= 0; i --) {
+            View view = disappearingList.get(i);
+            ViewHolder vh = getChildViewHolderInt(view);
+            final ItemHolderInfo info = mState.mPreLayoutHolderMap.remove(vh);
+            if (!mState.isPreLayout()) {
+                mState.mPostLayoutHolderMap.remove(vh);
+            }
+            if (appearingViews.remove(view) != null) {
+                mLayout.removeAndRecycleView(view, mRecycler);
+                continue;
+            }
+            if (info != null) {
+                animateDisappearance(info);
+            } else {
+                // let it disappear from the position it becomes visible
+                animateDisappearance(new ItemHolderInfo(vh, view.getLeft(), view.getTop(),
+                        view.getRight(), view.getBottom()));
+            }
+        }
+        disappearingList.clear();
+    }
+
+    private void animateAppearance(ViewHolder itemHolder, Rect beforeBounds, int afterLeft,
+            int afterTop) {
+        View newItemView = itemHolder.itemView;
+        if (beforeBounds != null &&
+                (beforeBounds.left != afterLeft || beforeBounds.top != afterTop)) {
+            // slide items in if before/after locations differ
+            itemHolder.setIsRecyclable(false);
+            if (DEBUG) {
+                Log.d(TAG, "APPEARING: " + itemHolder + " with view " + newItemView);
+            }
+            if (mItemAnimator.animateMove(itemHolder,
+                    beforeBounds.left, beforeBounds.top,
+                    afterLeft, afterTop)) {
+                postAnimationRunner();
+            }
+        } else {
+            if (DEBUG) {
+                Log.d(TAG, "ADDED: " + itemHolder + " with view " + newItemView);
+            }
+            itemHolder.setIsRecyclable(false);
+            if (mItemAnimator.animateAdd(itemHolder)) {
+                postAnimationRunner();
+            }
+        }
+    }
+
+    private void animateDisappearance(ItemHolderInfo disappearingItem) {
+        View disappearingItemView = disappearingItem.holder.itemView;
+        addAnimatingView(disappearingItem.holder);
+        int oldLeft = disappearingItem.left;
+        int oldTop = disappearingItem.top;
+        int newLeft = disappearingItemView.getLeft();
+        int newTop = disappearingItemView.getTop();
+        if (oldLeft != newLeft || oldTop != newTop) {
+            disappearingItem.holder.setIsRecyclable(false);
+            disappearingItemView.layout(newLeft, newTop,
+                    newLeft + disappearingItemView.getWidth(),
+                    newTop + disappearingItemView.getHeight());
+            if (DEBUG) {
+                Log.d(TAG, "DISAPPEARING: " + disappearingItem.holder +
+                        " with view " + disappearingItemView);
+            }
+            if (mItemAnimator.animateMove(disappearingItem.holder, oldLeft, oldTop,
+                    newLeft, newTop)) {
+                postAnimationRunner();
+            }
+        } else {
+            if (DEBUG) {
+                Log.d(TAG, "REMOVED: " + disappearingItem.holder +
+                        " with view " + disappearingItemView);
+            }
+            disappearingItem.holder.setIsRecyclable(false);
+            if (mItemAnimator.animateRemove(disappearingItem.holder)) {
+                postAnimationRunner();
+            }
+        }
+    }
+
+    private void animateChange(ViewHolder oldHolder, ViewHolder newHolder) {
+        oldHolder.setIsRecyclable(false);
+        addAnimatingView(oldHolder);
+        oldHolder.mShadowedHolder = newHolder;
+        mRecycler.unscrapView(oldHolder);
+        if (DEBUG) {
+            Log.d(TAG, "CHANGED: " + oldHolder + " with view " + oldHolder.itemView);
+        }
+        final int fromLeft = oldHolder.itemView.getLeft();
+        final int fromTop = oldHolder.itemView.getTop();
+        final int toLeft, toTop;
+        if (newHolder == null || newHolder.shouldIgnore()) {
+            toLeft = fromLeft;
+            toTop = fromTop;
+        } else {
+            toLeft = newHolder.itemView.getLeft();
+            toTop = newHolder.itemView.getTop();
+            newHolder.setIsRecyclable(false);
+            newHolder.mShadowingHolder = oldHolder;
+        }
+        if(mItemAnimator.animateChange(oldHolder, newHolder,
+                fromLeft, fromTop, toLeft, toTop)) {
+            postAnimationRunner();
+        }
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        eatRequestLayout();
+        dispatchLayout();
+        resumeRequestLayout(false);
+        mFirstLayoutComplete = true;
+    }
+
+    @Override
+    public void requestLayout() {
+        if (!mEatRequestLayout) {
+            super.requestLayout();
+        } else {
+            mLayoutRequestEaten = true;
+        }
+    }
+
+    void markItemDecorInsetsDirty() {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final View child = mChildHelper.getUnfilteredChildAt(i);
+            ((LayoutParams) child.getLayoutParams()).mInsetsDirty = true;
+        }
+        mRecycler.markItemDecorInsetsDirty();
+    }
+
+    @Override
+    public void draw(Canvas c) {
+        super.draw(c);
+
+        final int count = mItemDecorations.size();
+        for (int i = 0; i < count; i++) {
+            mItemDecorations.get(i).onDrawOver(c, this, mState);
+        }
+        // TODO If padding is not 0 and chilChildrenToPadding is false, to draw glows properly, we
+        // need find children closest to edges. Not sure if it is worth the effort.
+        boolean needsInvalidate = false;
+        if (mLeftGlow != null && !mLeftGlow.isFinished()) {
+            final int restore = c.save();
+            final int padding = mClipToPadding ? getPaddingBottom() : 0;
+            c.rotate(270);
+            c.translate(-getHeight() + padding, 0);
+            needsInvalidate = mLeftGlow != null && mLeftGlow.draw(c);
+            c.restoreToCount(restore);
+        }
+        if (mTopGlow != null && !mTopGlow.isFinished()) {
+            final int restore = c.save();
+            if (mClipToPadding) {
+                c.translate(getPaddingLeft(), getPaddingTop());
+            }
+            needsInvalidate |= mTopGlow != null && mTopGlow.draw(c);
+            c.restoreToCount(restore);
+        }
+        if (mRightGlow != null && !mRightGlow.isFinished()) {
+            final int restore = c.save();
+            final int width = getWidth();
+            final int padding = mClipToPadding ? getPaddingTop() : 0;
+            c.rotate(90);
+            c.translate(-padding, -width);
+            needsInvalidate |= mRightGlow != null && mRightGlow.draw(c);
+            c.restoreToCount(restore);
+        }
+        if (mBottomGlow != null && !mBottomGlow.isFinished()) {
+            final int restore = c.save();
+            c.rotate(180);
+            if (mClipToPadding) {
+                c.translate(-getWidth() + getPaddingRight(), -getHeight() + getPaddingBottom());
+            } else {
+                c.translate(-getWidth(), -getHeight());
+            }
+            needsInvalidate |= mBottomGlow != null && mBottomGlow.draw(c);
+            c.restoreToCount(restore);
+        }
+
+        // If some views are animating, ItemDecorators are likely to move/change with them.
+        // Invalidate RecyclerView to re-draw decorators. This is still efficient because children's
+        // display lists are not invalidated.
+        if (!needsInvalidate && mItemAnimator != null && mItemDecorations.size() > 0 &&
+                mItemAnimator.isRunning()) {
+            needsInvalidate = true;
+        }
+
+        if (needsInvalidate) {
+            ViewCompat.postInvalidateOnAnimation(this);
+        }
+    }
+
+    @Override
+    public void onDraw(Canvas c) {
+        super.onDraw(c);
+
+        final int count = mItemDecorations.size();
+        for (int i = 0; i < count; i++) {
+            mItemDecorations.get(i).onDraw(c, this, mState);
+        }
+    }
+
+    @Override
+    protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
+        return p instanceof LayoutParams && mLayout.checkLayoutParams((LayoutParams) p);
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateDefaultLayoutParams() {
+        if (mLayout == null) {
+            throw new IllegalStateException("RecyclerView has no LayoutManager");
+        }
+        return mLayout.generateDefaultLayoutParams();
+    }
+
+    @Override
+    public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
+        if (mLayout == null) {
+            throw new IllegalStateException("RecyclerView has no LayoutManager");
+        }
+        return mLayout.generateLayoutParams(getContext(), attrs);
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
+        if (mLayout == null) {
+            throw new IllegalStateException("RecyclerView has no LayoutManager");
+        }
+        return mLayout.generateLayoutParams(p);
+    }
+
+    void saveOldPositions() {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (DEBUG && holder.mPosition == -1 && !holder.isRemoved()) {
+                throw new IllegalStateException("view holder cannot have position -1 unless it"
+                        + " is removed");
+            }
+            if (!holder.shouldIgnore()) {
+                holder.saveOldPosition();
+            }
+        }
+    }
+
+    void clearOldPositions() {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (!holder.shouldIgnore()) {
+                holder.clearOldPosition();
+            }
+        }
+        mRecycler.clearOldPositions();
+    }
+
+    void offsetPositionRecordsForMove(int from, int to) {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        final int start, end, inBetweenOffset;
+        if (from < to) {
+            start = from;
+            end = to;
+            inBetweenOffset = -1;
+        } else {
+            start = to;
+            end = from;
+            inBetweenOffset = 1;
+        }
+
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (holder == null || holder.mPosition < start || holder.mPosition > end) {
+                continue;
+            }
+            if (DEBUG) {
+                Log.d(TAG, "offsetPositionRecordsForMove attached child " + i + " holder " +
+                        holder);
+            }
+            if (holder.mPosition == from) {
+                holder.offsetPosition(to - from, false);
+            } else {
+                holder.offsetPosition(inBetweenOffset, false);
+            }
+
+            mState.mStructureChanged = true;
+        }
+        mRecycler.offsetPositionRecordsForMove(from, to);
+        requestLayout();
+    }
+
+    void offsetPositionRecordsForInsert(int positionStart, int itemCount) {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (holder != null && !holder.shouldIgnore() && holder.mPosition >= positionStart) {
+                if (DEBUG) {
+                    Log.d(TAG, "offsetPositionRecordsForInsert attached child " + i + " holder " +
+                            holder + " now at position " + (holder.mPosition + itemCount));
+                }
+                holder.offsetPosition(itemCount, false);
+                mState.mStructureChanged = true;
+            }
+        }
+        mRecycler.offsetPositionRecordsForInsert(positionStart, itemCount);
+        requestLayout();
+    }
+
+    void offsetPositionRecordsForRemove(int positionStart, int itemCount,
+            boolean applyToPreLayout) {
+        final int positionEnd = positionStart + itemCount;
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (holder != null && !holder.shouldIgnore()) {
+                if (holder.mPosition >= positionEnd) {
+                    if (DEBUG) {
+                        Log.d(TAG, "offsetPositionRecordsForRemove attached child " + i +
+                                " holder " + holder + " now at position " +
+                                (holder.mPosition - itemCount));
+                    }
+                    holder.offsetPosition(-itemCount, applyToPreLayout);
+                    mState.mStructureChanged = true;
+                } else if (holder.mPosition >= positionStart) {
+                    if (DEBUG) {
+                        Log.d(TAG, "offsetPositionRecordsForRemove attached child " + i +
+                                " holder " + holder + " now REMOVED");
+                    }
+                    holder.flagRemovedAndOffsetPosition(positionStart - 1, -itemCount,
+                            applyToPreLayout);
+                    mState.mStructureChanged = true;
+                }
+            }
+        }
+        mRecycler.offsetPositionRecordsForRemove(positionStart, itemCount, applyToPreLayout);
+        requestLayout();
+    }
+
+    /**
+     * Rebind existing views for the given range, or create as needed.
+     *
+     * @param positionStart Adapter position to start at
+     * @param itemCount Number of views that must explicitly be rebound
+     */
+    void viewRangeUpdate(int positionStart, int itemCount) {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        final int positionEnd = positionStart + itemCount;
+
+        for (int i = 0; i < childCount; i++) {
+            final View child = mChildHelper.getUnfilteredChildAt(i);
+            final ViewHolder holder = getChildViewHolderInt(child);
+            if (holder == null || holder.shouldIgnore()) {
+                continue;
+            }
+            if (holder.mPosition >= positionStart && holder.mPosition < positionEnd) {
+                // We re-bind these view holders after pre-processing is complete so that
+                // ViewHolders have their final positions assigned.
+                holder.addFlags(ViewHolder.FLAG_UPDATE);
+                if (supportsChangeAnimations()) {
+                    holder.addFlags(ViewHolder.FLAG_CHANGED);
+                }
+                // lp cannot be null since we get ViewHolder from it.
+                ((LayoutParams) child.getLayoutParams()).mInsetsDirty = true;
+            }
+        }
+        mRecycler.viewRangeUpdate(positionStart, itemCount);
+    }
+
+    void rebindUpdatedViewHolders() {
+        final int childCount = mChildHelper.getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
+            // validate type is correct
+            if (holder == null || holder.shouldIgnore()) {
+                continue;
+            }
+            if (holder.isRemoved() || holder.isInvalid()) {
+                requestLayout();
+            } else if (holder.needsUpdate()) {
+                final int type = mAdapter.getItemViewType(holder.mPosition);
+                if (holder.getItemViewType() == type) {
+                    // Binding an attached view will request a layout if needed.
+                    if (!holder.isChanged() || !supportsChangeAnimations()) {
+                        mAdapter.bindViewHolder(holder, holder.mPosition);
+                    } else {
+                        // Don't rebind changed holders if change animations are enabled.
+                        // We want the old contents for the animation and will get a new
+                        // holder for the new contents.
+                        requestLayout();
+                    }
+                } else {
+                    // binding to a new view will need re-layout anyways. We can as well trigger
+                    // it here so that it happens during layout
+                    requestLayout();
+                    break;
+                }
+            }
+        }
+    }
+
+    private void setDataSetChangedAfterLayout() {
+        if (mDataSetHasChangedAfterLayout) {
+            return;
+        }
+        mDataSetHasChangedAfterLayout = true;
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (holder != null && !holder.shouldIgnore()) {
+                holder.addFlags(ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);
+            }
+        }
+        mRecycler.setAdapterPositionsAsUnknown();
+    }
+
+    /**
+     * Mark all known views as invalid. Used in response to a, "the whole world might have changed"
+     * data change event.
+     */
+    void markKnownViewsInvalid() {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (holder != null && !holder.shouldIgnore()) {
+                holder.addFlags(ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID);
+            }
+        }
+        markItemDecorInsetsDirty();
+        mRecycler.markKnownViewsInvalid();
+    }
+
+    /**
+     * Invalidates all ItemDecorations. If RecyclerView has item decorations, calling this method
+     * will trigger a {@link #requestLayout()} call.
+     */
+    public void invalidateItemDecorations() {
+        if (mItemDecorations.size() == 0) {
+            return;
+        }
+        if (mLayout != null) {
+            mLayout.assertNotInLayoutOrScroll("Cannot invalidate item decorations during a scroll"
+                    + " or layout");
+        }
+        markItemDecorInsetsDirty();
+        requestLayout();
+    }
+
+    /**
+     * Retrieve the {@link ViewHolder} for the given child view.
+     *
+     * @param child Child of this RecyclerView to query for its ViewHolder
+     * @return The child view's ViewHolder
+     */
+    public ViewHolder getChildViewHolder(View child) {
+        final ViewParent parent = child.getParent();
+        if (parent != null && parent != this) {
+            throw new IllegalArgumentException("View " + child + " is not a direct child of " +
+                    this);
+        }
+        return getChildViewHolderInt(child);
+    }
+
+    static ViewHolder getChildViewHolderInt(View child) {
+        if (child == null) {
+            return null;
+        }
+        return ((LayoutParams) child.getLayoutParams()).mViewHolder;
+    }
+
+    /**
+     * @deprecated use {@link #getChildAdapterPosition(View)} or
+     * {@link #getChildLayoutPosition(View)}.
+     */
+    @Deprecated
+    public int getChildPosition(View child) {
+        return getChildAdapterPosition(child);
+    }
+
+    /**
+     * Return the adapter position that the given child view corresponds to.
+     *
+     * @param child Child View to query
+     * @return Adapter position corresponding to the given view or {@link #NO_POSITION}
+     */
+    public int getChildAdapterPosition(View child) {
+        final ViewHolder holder = getChildViewHolderInt(child);
+        return holder != null ? holder.getAdapterPosition() : NO_POSITION;
+    }
+
+    /**
+     * Return the adapter position of the given child view as of the latest completed layout pass.
+     * <p>
+     * This position may not be equal to Item's adapter position if there are pending changes
+     * in the adapter which have not been reflected to the layout yet.
+     *
+     * @param child Child View to query
+     * @return Adapter position of the given View as of last layout pass or {@link #NO_POSITION} if
+     * the View is representing a removed item.
+     */
+    public int getChildLayoutPosition(View child) {
+        final ViewHolder holder = getChildViewHolderInt(child);
+        return holder != null ? holder.getLayoutPosition() : NO_POSITION;
+    }
+
+    /**
+     * Return the stable item id that the given child view corresponds to.
+     *
+     * @param child Child View to query
+     * @return Item id corresponding to the given view or {@link #NO_ID}
+     */
+    public long getChildItemId(View child) {
+        if (mAdapter == null || !mAdapter.hasStableIds()) {
+            return NO_ID;
+        }
+        final ViewHolder holder = getChildViewHolderInt(child);
+        return holder != null ? holder.getItemId() : NO_ID;
+    }
+
+    /**
+     * @deprecated use {@link #findViewHolderForLayoutPosition(int)} or
+     * {@link #findViewHolderForAdapterPosition(int)}
+     */
+    @Deprecated
+    public ViewHolder findViewHolderForPosition(int position) {
+        return findViewHolderForPosition(position, false);
+    }
+
+    /**
+     * Return the ViewHolder for the item in the given position of the data set as of the latest
+     * layout pass.
+     * <p>
+     * This method checks only the children of RecyclerView. If the item at the given
+     * <code>position</code> is not laid out, it <em>will not</em> create a new one.
+     * <p>
+     * Note that when Adapter contents change, ViewHolder positions are not updated until the
+     * next layout calculation. If there are pending adapter updates, the return value of this
+     * method may not match your adapter contents. You can use
+     * #{@link ViewHolder#getAdapterPosition()} to get the current adapter position of a ViewHolder.
+     *
+     * @param position The position of the item in the data set of the adapter
+     * @return The ViewHolder at <code>position</code> or null if there is no such item
+     */
+    public ViewHolder findViewHolderForLayoutPosition(int position) {
+        return findViewHolderForPosition(position, false);
+    }
+
+    /**
+     * Return the ViewHolder for the item in the given position of the data set. Unlike
+     * {@link #findViewHolderForLayoutPosition(int)} this method takes into account any pending
+     * adapter changes that may not be reflected to the layout yet. On the other hand, if
+     * {@link Adapter#notifyDataSetChanged()} has been called but the new layout has not been
+     * calculated yet, this method will return <code>null</code> since the new positions of views
+     * are unknown until the layout is calculated.
+     * <p>
+     * This method checks only the children of RecyclerView. If the item at the given
+     * <code>position</code> is not laid out, it <em>will not</em> create a new one.
+     *
+     * @param position The position of the item in the data set of the adapter
+     * @return The ViewHolder at <code>position</code> or null if there is no such item
+     */
+    public ViewHolder findViewHolderForAdapterPosition(int position) {
+        if (mDataSetHasChangedAfterLayout) {
+            return null;
+        }
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (holder != null && !holder.isRemoved() && getAdapterPositionFor(holder) == position) {
+                return holder;
+            }
+        }
+        return null;
+    }
+
+    ViewHolder findViewHolderForPosition(int position, boolean checkNewPosition) {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (holder != null && !holder.isRemoved()) {
+                if (checkNewPosition) {
+                    if (holder.mPosition == position) {
+                        return holder;
+                    }
+                } else if (holder.getLayoutPosition() == position) {
+                    return holder;
+                }
+            }
+        }
+        // This method should not query cached views. It creates a problem during adapter updates
+        // when we are dealing with already laid out views. Also, for the public method, it is more
+        // reasonable to return null if position is not laid out.
+        return null;
+    }
+
+    /**
+     * Return the ViewHolder for the item with the given id. The RecyclerView must
+     * use an Adapter with {@link Adapter#setHasStableIds(boolean) stableIds} to
+     * return a non-null value.
+     * <p>
+     * This method checks only the children of RecyclerView. If the item with the given
+     * <code>id</code> is not laid out, it <em>will not</em> create a new one.
+     *
+     * @param id The id for the requested item
+     * @return The ViewHolder with the given <code>id</code> or null if there is no such item
+     */
+    public ViewHolder findViewHolderForItemId(long id) {
+        final int childCount = mChildHelper.getUnfilteredChildCount();
+        for (int i = 0; i < childCount; i++) {
+            final ViewHolder holder = getChildViewHolderInt(mChildHelper.getUnfilteredChildAt(i));
+            if (holder != null && holder.getItemId() == id) {
+                return holder;
+            }
+        }
+        // this method should not query cached views. They are not children so they
+        // should not be returned in this public method
+        return null;
+    }
+
+    /**
+     * Find the topmost view under the given point.
+     *
+     * @param x Horizontal position in pixels to search
+     * @param y Vertical position in pixels to search
+     * @return The child view under (x, y) or null if no matching child is found
+     */
+    public View findChildViewUnder(float x, float y) {
+        final int count = mChildHelper.getChildCount();
+        for (int i = count - 1; i >= 0; i--) {
+            final View child = mChildHelper.getChildAt(i);
+            final float translationX = ViewCompat.getTranslationX(child);
+            final float translationY = ViewCompat.getTranslationY(child);
+            if (x >= child.getLeft() + translationX &&
+                    x <= child.getRight() + translationX &&
+                    y >= child.getTop() + translationY &&
+                    y <= child.getBottom() + translationY) {
+                return child;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Offset the bounds of all child views by <code>dy</code> pixels.
+     * Useful for implementing simple scrolling in {@link LayoutManager LayoutManagers}.
+     *
+     * @param dy Vertical pixel offset to apply to the bounds of all child views
+     */
+    public void offsetChildrenVertical(int dy) {
+        final int childCount = mChildHelper.getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            mChildHelper.getChildAt(i).offsetTopAndBottom(dy);
+        }
+    }
+
+    /**
+     * Called when an item view is attached to this RecyclerView.
+     *
+     * <p>Subclasses of RecyclerView may want to perform extra bookkeeping or modifications
+     * of child views as they become attached. This will be called before a
+     * {@link LayoutManager} measures or lays out the view and is a good time to perform these
+     * changes.</p>
+     *
+     * @param child Child view that is now attached to this RecyclerView and its associated window
+     */
+    public void onChildAttachedToWindow(View child) {
+    }
+
+    /**
+     * Called when an item view is detached from this RecyclerView.
+     *
+     * <p>Subclasses of RecyclerView may want to perform extra bookkeeping or modifications
+     * of child views as they become detached. This will be called as a
+     * {@link LayoutManager} fully detaches the child view from the parent and its window.</p>
+     *
+     * @param child Child view that is now detached from this RecyclerView and its associated window
+     */
+    public void onChildDetachedFromWindow(View child) {
+    }
+
+    /**
+     * Offset the bounds of all child views by <code>dx</code> pixels.
+     * Useful for implementing simple scrolling in {@link LayoutManager LayoutManagers}.
+     *
+     * @param dx Horizontal pixel offset to apply to the bounds of all child views
+     */
+    public void offsetChildrenHorizontal(int dx) {
+        final int childCount = mChildHelper.getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            mChildHelper.getChildAt(i).offsetLeftAndRight(dx);
+        }
+    }
+
+    Rect getItemDecorInsetsForChild(View child) {
+        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+        if (!lp.mInsetsDirty) {
+            return lp.mDecorInsets;
+        }
+
+        final Rect insets = lp.mDecorInsets;
+        insets.set(0, 0, 0, 0);
+        final int decorCount = mItemDecorations.size();
+        for (int i = 0; i < decorCount; i++) {
+            mTempRect.set(0, 0, 0, 0);
+            mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState);
+            insets.left += mTempRect.left;
+            insets.top += mTempRect.top;
+            insets.right += mTempRect.right;
+            insets.bottom += mTempRect.bottom;
+        }
+        lp.mInsetsDirty = false;
+        return insets;
+    }
+
+    /**
+     * Called when the scroll position of this RecyclerView changes. Subclasses should use
+     * this method to respond to scrolling within the adapter's data set instead of an explicit
+     * listener.
+     *
+     * <p>This method will always be invoked before listeners. If a subclass needs to perform
+     * any additional upkeep or bookkeeping after scrolling but before listeners run,
+     * this is a good place to do so.</p>
+     *
+     * <p>This differs from {@link View#onScrollChanged(int, int, int, int)} in that it receives
+     * the distance scrolled in either direction within the adapter's data set instead of absolute
+     * scroll coordinates. Since RecyclerView cannot compute the absolute scroll position from
+     * any arbitrary point in the data set, <code>onScrollChanged</code> will always receive
+     * the current {@link View#getScrollX()} and {@link View#getScrollY()} values which
+     * do not correspond to the data set scroll position. However, some subclasses may choose
+     * to use these fields as special offsets.</p>
+     *
+     * @param dx horizontal distance scrolled in pixels
+     * @param dy vertical distance scrolled in pixels
+     */
+    public void onScrolled(int dx, int dy) {
+        // Do nothing
+    }
+
+    void dispatchOnScrolled(int hresult, int vresult) {
+        // Pass the current scrollX/scrollY values; no actual change in these properties occurred
+        // but some general-purpose code may choose to respond to changes this way.
+        final int scrollX = getScrollX();
+        final int scrollY = getScrollY();
+        onScrollChanged(scrollX, scrollY, scrollX, scrollY);
+
+        // Pass the real deltas to onScrolled, the RecyclerView-specific method.
+        onScrolled(hresult, vresult);
+
+        // Invoke listeners last. Subclassed view methods always handle the event first.
+        // All internal state is consistent by the time listeners are invoked.
+        if (mScrollListener != null) {
+            mScrollListener.onScrolled(this, hresult, vresult);
+        }
+        if (mScrollListeners != null) {
+            for (int i = mScrollListeners.size() - 1; i >= 0; i--) {
+                mScrollListeners.get(i).onScrolled(this, hresult, vresult);
+            }
+        }
+    }
+
+    /**
+     * Called when the scroll state of this RecyclerView changes. Subclasses should use this
+     * method to respond to state changes instead of an explicit listener.
+     *
+     * <p>This method will always be invoked before listeners, but after the LayoutManager
+     * responds to the scroll state change.</p>
+     *
+     * @param state the new scroll state, one of {@link #SCROLL_STATE_IDLE},
+     *              {@link #SCROLL_STATE_DRAGGING} or {@link #SCROLL_STATE_SETTLING}
+     */
+    public void onScrollStateChanged(int state) {
+        // Do nothing
+    }
+
+    void dispatchOnScrollStateChanged(int state) {
+        // Let the LayoutManager go first; this allows it to bring any properties into
+        // a consistent state before the RecyclerView subclass responds.
+        if (mLayout != null) {
+            mLayout.onScrollStateChanged(state);
+        }
+
+        // Let the RecyclerView subclass handle this event next; any LayoutManager property
+        // changes will be reflected by this time.
+        onScrollStateChanged(state);
+
+        // Listeners go last. All other internal state is consistent by this point.
+        if (mScrollListener != null) {
+            mScrollListener.onScrollStateChanged(this, state);
+        }
+        if (mScrollListeners != null) {
+            for (int i = mScrollListeners.size() - 1; i >= 0; i--) {
+                mScrollListeners.get(i).onScrollStateChanged(this, state);
+            }
+        }
+    }
+
+    /**
+     * Returns whether there are pending adapter updates which are not yet applied to the layout.
+     * <p>
+     * If this method returns <code>true</code>, it means that what user is currently seeing may not
+     * reflect them adapter contents (depending on what has changed).
+     * You may use this information to defer or cancel some operations.
+     * <p>
+     * This method returns true if RecyclerView has not yet calculated the first layout after it is
+     * attached to the Window or the Adapter has been replaced.
+     *
+     * @return True if there are some adapter updates which are not yet reflected to layout or false
+     * if layout is up to date.
+     */
+    public boolean hasPendingAdapterUpdates() {
+        return !mFirstLayoutComplete || mDataSetHasChangedAfterLayout
+                || mAdapterHelper.hasPendingUpdates();
+    }
+
+    private class ViewFlinger implements Runnable {
+        private int mLastFlingX;
+        private int mLastFlingY;
+        private ScrollerCompat mScroller;
+        private Interpolator mInterpolator = sQuinticInterpolator;
+
+
+        // When set to true, postOnAnimation callbacks are delayed until the run method completes
+        private boolean mEatRunOnAnimationRequest = false;
+
+        // Tracks if postAnimationCallback should be re-attached when it is done
+        private boolean mReSchedulePostAnimationCallback = false;
+
+        public ViewFlinger() {
+            mScroller = ScrollerCompat.create(getContext(), sQuinticInterpolator);
+        }
+
+        @Override
+        public void run() {
+            disableRunOnAnimationRequests();
+            consumePendingUpdateOperations();
+            // keep a local reference so that if it is changed during onAnimation method, it won't
+            // cause unexpected behaviors
+            final ScrollerCompat scroller = mScroller;
+            final SmoothScroller smoothScroller = mLayout.mSmoothScroller;
+            if (scroller.computeScrollOffset()) {
+                final int x = scroller.getCurrX();
+                final int y = scroller.getCurrY();
+                final int dx = x - mLastFlingX;
+                final int dy = y - mLastFlingY;
+                int hresult = 0;
+                int vresult = 0;
+                mLastFlingX = x;
+                mLastFlingY = y;
+                int overscrollX = 0, overscrollY = 0;
+                if (mAdapter != null) {
+                    eatRequestLayout();
+                    onEnterLayoutOrScroll();
+                    if (dx != 0) {
+                        hresult = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);
+                        overscrollX = dx - hresult;
+                    }
+                    if (dy != 0) {
+                        vresult = mLayout.scrollVerticallyBy(dy, mRecycler, mState);
+                        overscrollY = dy - vresult;
+                    }
+                    if (supportsChangeAnimations()) {
+                        // Fix up shadow views used by changing animations
+                        int count = mChildHelper.getChildCount();
+                        for (int i = 0; i < count; i++) {
+                            View view = mChildHelper.getChildAt(i);
+                            ViewHolder holder = getChildViewHolder(view);
+                            if (holder != null && holder.mShadowingHolder != null) {
+                                View shadowingView = holder.mShadowingHolder.itemView;
+                                int left = view.getLeft();
+                                int top = view.getTop();
+                                if (left != shadowingView.getLeft() ||
+                                        top != shadowingView.getTop()) {
+                                    shadowingView.layout(left, top,
+                                            left + shadowingView.getWidth(),
+                                            top + shadowingView.getHeight());
+                                }
+                            }
+                        }
+                    }
+
+                    if (smoothScroller != null && !smoothScroller.isPendingInitialRun() &&
+                            smoothScroller.isRunning()) {
+                        final int adapterSize = mState.getItemCount();
+                        if (adapterSize == 0) {
+                            smoothScroller.stop();
+                        } else if (smoothScroller.getTargetPosition() >= adapterSize) {
+                            smoothScroller.setTargetPosition(adapterSize - 1);
+                            smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);
+                        } else {
+                            smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);
+                        }
+                    }
+                    onExitLayoutOrScroll();
+                    resumeRequestLayout(false);
+                }
+                if (!mItemDecorations.isEmpty()) {
+                    invalidate();
+                }
+                if (ViewCompat.getOverScrollMode(RecyclerView.this) !=
+                        ViewCompat.OVER_SCROLL_NEVER) {
+                    considerReleasingGlowsOnScroll(dx, dy);
+                }
+                if (overscrollX != 0 || overscrollY != 0) {
+                    final int vel = (int) scroller.getCurrVelocity();
+
+                    int velX = 0;
+                    if (overscrollX != x) {
+                        velX = overscrollX < 0 ? -vel : overscrollX > 0 ? vel : 0;
+                    }
+
+                    int velY = 0;
+                    if (overscrollY != y) {
+                        velY = overscrollY < 0 ? -vel : overscrollY > 0 ? vel : 0;
+                    }
+
+                    if (ViewCompat.getOverScrollMode(RecyclerView.this) !=
+                            ViewCompat.OVER_SCROLL_NEVER) {
+                        absorbGlows(velX, velY);
+                    }
+                    if ((velX != 0 || overscrollX == x || scroller.getFinalX() == 0) &&
+                            (velY != 0 || overscrollY == y || scroller.getFinalY() == 0)) {
+                        scroller.abortAnimation();
+                    }
+                }
+                if (hresult != 0 || vresult != 0) {
+                    dispatchOnScrolled(hresult, vresult);
+                }
+
+                if (!awakenScrollBars()) {
+                    invalidate();
+                }
+
+                final boolean fullyConsumedVertical = dy != 0 && mLayout.canScrollVertically()
+                        && vresult == dy;
+                final boolean fullyConsumedHorizontal = dx != 0 && mLayout.canScrollHorizontally()
+                        && hresult == dx;
+                final boolean fullyConsumedAny = (dx == 0 && dy == 0) || fullyConsumedHorizontal
+                        || fullyConsumedVertical;
+
+                if (scroller.isFinished() || !fullyConsumedAny) {
+                    setScrollState(SCROLL_STATE_IDLE); // setting state to idle will stop this.
+                } else {
+                    postOnAnimation();
+                }
+            }
+            // call this after the onAnimation is complete not to have inconsistent callbacks etc.
+            if (smoothScroller != null && smoothScroller.isPendingInitialRun()) {
+                smoothScroller.onAnimation(0, 0);
+            }
+            enableRunOnAnimationRequests();
+        }
+
+        private void disableRunOnAnimationRequests() {
+            mReSchedulePostAnimationCallback = false;
+            mEatRunOnAnimationRequest = true;
+        }
+
+        private void enableRunOnAnimationRequests() {
+            mEatRunOnAnimationRequest = false;
+            if (mReSchedulePostAnimationCallback) {
+                postOnAnimation();
+            }
+        }
+
+        void postOnAnimation() {
+            if (mEatRunOnAnimationRequest) {
+                mReSchedulePostAnimationCallback = true;
+            } else {
+                removeCallbacks(this);
+                ViewCompat.postOnAnimation(RecyclerView.this, this);
+            }
+        }
+
+        public void fling(int velocityX, int velocityY) {
+            setScrollState(SCROLL_STATE_SETTLING);
+            mLastFlingX = mLastFlingY = 0;
+            mScroller.fling(0, 0, velocityX, velocityY,
+                    Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE);
+            postOnAnimation();
+        }
+
+        public void smoothScrollBy(int dx, int dy) {
+            smoothScrollBy(dx, dy, 0, 0);
+        }
+
+        public void smoothScrollBy(int dx, int dy, int vx, int vy) {
+            smoothScrollBy(dx, dy, computeScrollDuration(dx, dy, vx, vy));
+        }
+
+        private float distanceInfluenceForSnapDuration(float f) {
+            f -= 0.5f; // center the values about 0.
+            f *= 0.3f * Math.PI / 2.0f;
+            return (float) Math.sin(f);
+        }
+
+        private int computeScrollDuration(int dx, int dy, int vx, int vy) {
+            final int absDx = Math.abs(dx);
+            final int absDy = Math.abs(dy);
+            final boolean horizontal = absDx > absDy;
+            final int velocity = (int) Math.sqrt(vx * vx + vy * vy);
+            final int delta = (int) Math.sqrt(dx * dx + dy * dy);
+            final int containerSize = horizontal ? getWidth() : getHeight();
+            final int halfContainerSize = containerSize / 2;
+            final float distanceRatio = Math.min(1.f, 1.f * delta / containerSize);
+            final float distance = halfContainerSize + halfContainerSize *
+                    distanceInfluenceForSnapDuration(distanceRatio);
+
+            final int duration;
+            if (velocity > 0) {
+                duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
+            } else {
+                float absDelta = (float) (horizontal ? absDx : absDy);
+                duration = (int) (((absDelta / containerSize) + 1) * 300);
+            }
+            return Math.min(duration, MAX_SCROLL_DURATION);
+        }
+
+        public void smoothScrollBy(int dx, int dy, int duration) {
+            smoothScrollBy(dx, dy, duration, sQuinticInterpolator);
+        }
+
+        public void smoothScrollBy(int dx, int dy, int duration, Interpolator interpolator) {
+            if (mInterpolator != interpolator) {
+                mInterpolator = interpolator;
+                mScroller = ScrollerCompat.create(getContext(), interpolator);
+            }
+            setScrollState(SCROLL_STATE_SETTLING);
+            mLastFlingX = mLastFlingY = 0;
+            mScroller.startScroll(0, 0, dx, dy, duration);
+            postOnAnimation();
+        }
+
+        public void stop() {
+            removeCallbacks(this);
+            mScroller.abortAnimation();
+        }
+
+    }
+
+    private class RecyclerViewDataObserver extends AdapterDataObserver {
+        @Override
+        public void onChanged() {
+            assertNotInLayoutOrScroll(null);
+            if (mAdapter.hasStableIds()) {
+                // TODO Determine what actually changed.
+                // This is more important to implement now since this callback will disable all
+                // animations because we cannot rely on positions.
+                mState.mStructureChanged = true;
+                setDataSetChangedAfterLayout();
+            } else {
+                mState.mStructureChanged = true;
+                setDataSetChangedAfterLayout();
+            }
+            if (!mAdapterHelper.hasPendingUpdates()) {
+                requestLayout();
+            }
+        }
+
+        @Override
+        public void onItemRangeChanged(int positionStart, int itemCount) {
+            assertNotInLayoutOrScroll(null);
+            if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount)) {
+                triggerUpdateProcessor();
+            }
+        }
+
+        @Override
+        public void onItemRangeInserted(int positionStart, int itemCount) {
+            assertNotInLayoutOrScroll(null);
+            if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) {
+                triggerUpdateProcessor();
+            }
+        }
+
+        @Override
+        public void onItemRangeRemoved(int positionStart, int itemCount) {
+            assertNotInLayoutOrScroll(null);
+            if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) {
+                triggerUpdateProcessor();
+            }
+        }
+
+        @Override
+        public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) {
+            assertNotInLayoutOrScroll(null);
+            if (mAdapterHelper.onItemRangeMoved(fromPosition, toPosition, itemCount)) {
+                triggerUpdateProcessor();
+            }
+        }
+
+        void triggerUpdateProcessor() {
+            if (mPostUpdatesOnAnimation && mHasFixedSize && mIsAttached) {
+                ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);
+            } else {
+                mAdapterUpdateDuringMeasure = true;
+                requestLayout();
+            }
+        }
+    }
+
+    /**
+     * RecycledViewPool lets you share Views between multiple RecyclerViews.
+     * <p>
+     * If you want to recycle views across RecyclerViews, create an instance of RecycledViewPool
+     * and use {@link RecyclerView#setRecycledViewPool(RecycledViewPool)}.
+     * <p>
+     * RecyclerView automatically creates a pool for itself if you don't provide one.
+     *
+     */
+    public static class RecycledViewPool {
+        private SparseArray<ArrayList<ViewHolder>> mScrap =
+                new SparseArray<ArrayList<ViewHolder>>();
+        private SparseIntArray mMaxScrap = new SparseIntArray();
+        private int mAttachCount = 0;
+
+        private static final int DEFAULT_MAX_SCRAP = 5;
+
+        public void clear() {
+            mScrap.clear();
+        }
+
+        public void setMaxRecycledViews(int viewType, int max) {
+            mMaxScrap.put(viewType, max);
+            final ArrayList<ViewHolder> scrapHeap = mScrap.get(viewType);
+            if (scrapHeap != null) {
+                while (scrapHeap.size() > max) {
+                    scrapHeap.remove(scrapHeap.size() - 1);
+                }
+            }
+        }
+
+        public ViewHolder getRecycledView(int viewType) {
+            final ArrayList<ViewHolder> scrapHeap = mScrap.get(viewType);
+            if (scrapHeap != null && !scrapHeap.isEmpty()) {
+                final int index = scrapHeap.size() - 1;
+                final ViewHolder scrap = scrapHeap.get(index);
+                scrapHeap.remove(index);
+                return scrap;
+            }
+            return null;
+        }
+
+        int size() {
+            int count = 0;
+            for (int i = 0; i < mScrap.size(); i ++) {
+                ArrayList<ViewHolder> viewHolders = mScrap.valueAt(i);
+                if (viewHolders != null) {
+                    count += viewHolders.size();
+                }
+            }
+            return count;
+        }
+
+        public void putRecycledView(ViewHolder scrap) {
+            final int viewType = scrap.getItemViewType();
+            final ArrayList scrapHeap = getScrapHeapForType(viewType);
+            if (mMaxScrap.get(viewType) <= scrapHeap.size()) {
+                return;
+            }
+            scrap.resetInternal();
+            scrapHeap.add(scrap);
+        }
+
+        void attach(Adapter adapter) {
+            mAttachCount++;
+        }
+
+        void detach() {
+            mAttachCount--;
+        }
+
+
+        /**
+         * Detaches the old adapter and attaches the new one.
+         * <p>
+         * RecycledViewPool will clear its cache if it has only one adapter attached and the new
+         * adapter uses a different ViewHolder than the oldAdapter.
+         *
+         * @param oldAdapter The previous adapter instance. Will be detached.
+         * @param newAdapter The new adapter instance. Will be attached.
+         * @param compatibleWithPrevious True if both oldAdapter and newAdapter are using the same
+         *                               ViewHolder and view types.
+         */
+        void onAdapterChanged(Adapter oldAdapter, Adapter newAdapter,
+                boolean compatibleWithPrevious) {
+            if (oldAdapter != null) {
+                detach();
+            }
+            if (!compatibleWithPrevious && mAttachCount == 0) {
+                clear();
+            }
+            if (newAdapter != null) {
+                attach(newAdapter);
+            }
+        }
+
+        private ArrayList<ViewHolder> getScrapHeapForType(int viewType) {
+            ArrayList<ViewHolder> scrap = mScrap.get(viewType);
+            if (scrap == null) {
+                scrap = new ArrayList<ViewHolder>();
+                mScrap.put(viewType, scrap);
+                if (mMaxScrap.indexOfKey(viewType) < 0) {
+                    mMaxScrap.put(viewType, DEFAULT_MAX_SCRAP);
+                }
+            }
+            return scrap;
+        }
+    }
+
+    /**
+     * A Recycler is responsible for managing scrapped or detached item views for reuse.
+     *
+     * <p>A "scrapped" view is a view that is still attached to its parent RecyclerView but
+     * that has been marked for removal or reuse.</p>
+     *
+     * <p>Typical use of a Recycler by a {@link LayoutManager} will be to obtain views for
+     * an adapter's data set representing the data at a given position or item ID.
+     * If the view to be reused is considered "dirty" the adapter will be asked to rebind it.
+     * If not, the view can be quickly reused by the LayoutManager with no further work.
+     * Clean views that have not {@link android.view.View#isLayoutRequested() requested layout}
+     * may be repositioned by a LayoutManager without remeasurement.</p>
+     */
+    public final class Recycler {
+        final ArrayList<ViewHolder> mAttachedScrap = new ArrayList<ViewHolder>();
+        private ArrayList<ViewHolder> mChangedScrap = null;
+
+        final ArrayList<ViewHolder> mCachedViews = new ArrayList<ViewHolder>();
+
+        private final List<ViewHolder>
+                mUnmodifiableAttachedScrap = Collections.unmodifiableList(mAttachedScrap);
+
+        private int mViewCacheMax = DEFAULT_CACHE_SIZE;
+
+        private RecycledViewPool mRecyclerPool;
+
+        private ViewCacheExtension mViewCacheExtension;
+
+        private static final int DEFAULT_CACHE_SIZE = 2;
+
+        /**
+         * Clear scrap views out of this recycler. Detached views contained within a
+         * recycled view pool will remain.
+         */
+        public void clear() {
+            mAttachedScrap.clear();
+            recycleAndClearCachedViews();
+        }
+
+        /**
+         * Set the maximum number of detached, valid views we should retain for later use.
+         *
+         * @param viewCount Number of views to keep before sending views to the shared pool
+         */
+        public void setViewCacheSize(int viewCount) {
+            mViewCacheMax = viewCount;
+            // first, try the views that can be recycled
+            for (int i = mCachedViews.size() - 1; i >= 0 && mCachedViews.size() > viewCount; i--) {
+                recycleCachedViewAt(i);
+            }
+        }
+
+        /**
+         * Returns an unmodifiable list of ViewHolders that are currently in the scrap list.
+         *
+         * @return List of ViewHolders in the scrap list.
+         */
+        public List<ViewHolder> getScrapList() {
+            return mUnmodifiableAttachedScrap;
+        }
+
+        /**
+         * Helper method for getViewForPosition.
+         * <p>
+         * Checks whether a given view holder can be used for the provided position.
+         *
+         * @param holder ViewHolder
+         * @return true if ViewHolder matches the provided position, false otherwise
+         */
+        boolean validateViewHolderForOffsetPosition(ViewHolder holder) {
+            // if it is a removed holder, nothing to verify since we cannot ask adapter anymore
+            // if it is not removed, verify the type and id.
+            if (holder.isRemoved()) {
+                return true;
+            }
+            if (holder.mPosition < 0 || holder.mPosition >= mAdapter.getItemCount()) {
+                throw new IndexOutOfBoundsException("Inconsistency detected. Invalid view holder "
+                        + "adapter position" + holder);
+            }
+            if (!mState.isPreLayout()) {
+                // don't check type if it is pre-layout.
+                final int type = mAdapter.getItemViewType(holder.mPosition);
+                if (type != holder.getItemViewType()) {
+                    return false;
+                }
+            }
+            if (mAdapter.hasStableIds()) {
+                return holder.getItemId() == mAdapter.getItemId(holder.mPosition);
+            }
+            return true;
+        }
+
+        /**
+         * Binds the given View to the position. The View can be a View previously retrieved via
+         * {@link #getViewForPosition(int)} or created by
+         * {@link Adapter#onCreateViewHolder(ViewGroup, int)}.
+         * <p>
+         * Generally, a LayoutManager should acquire its views via {@link #getViewForPosition(int)}
+         * and let the RecyclerView handle caching. This is a helper method for LayoutManager who
+         * wants to handle its own recycling logic.
+         * <p>
+         * Note that, {@link #getViewForPosition(int)} already binds the View to the position so
+         * you don't need to call this method unless you want to bind this View to another position.
+         *
+         * @param view The view to update.
+         * @param position The position of the item to bind to this View.
+         */
+        public void bindViewToPosition(View view, int position) {
+            ViewHolder holder = getChildViewHolderInt(view);
+            if (holder == null) {
+                throw new IllegalArgumentException("The view does not have a ViewHolder. You cannot"
+                        + " pass arbitrary views to this method, they should be created by the "
+                        + "Adapter");
+            }
+            final int offsetPosition = mAdapterHelper.findPositionOffset(position);
+            if (offsetPosition < 0 || offsetPosition >= mAdapter.getItemCount()) {
+                throw new IndexOutOfBoundsException("Inconsistency detected. Invalid item "
+                        + "position " + position + "(offset:" + offsetPosition + ")."
+                        + "state:" + mState.getItemCount());
+            }
+            holder.mOwnerRecyclerView = RecyclerView.this;
+            mAdapter.bindViewHolder(holder, offsetPosition);
+            attachAccessibilityDelegate(view);
+            if (mState.isPreLayout()) {
+                holder.mPreLayoutPosition = position;
+            }
+
+            final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();
+            final LayoutParams rvLayoutParams;
+            if (lp == null) {
+                rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();
+                holder.itemView.setLayoutParams(rvLayoutParams);
+            } else if (!checkLayoutParams(lp)) {
+                rvLayoutParams = (LayoutParams) generateLayoutParams(lp);
+                holder.itemView.setLayoutParams(rvLayoutParams);
+            } else {
+                rvLayoutParams = (LayoutParams) lp;
+            }
+
+            rvLayoutParams.mInsetsDirty = true;
+            rvLayoutParams.mViewHolder = holder;
+            rvLayoutParams.mPendingInvalidate = holder.itemView.getParent() == null;
+        }
+
+        /**
+         * RecyclerView provides artificial position range (item count) in pre-layout state and
+         * automatically maps these positions to {@link Adapter} positions when
+         * {@link #getViewForPosition(int)} or {@link #bindViewToPosition(View, int)} is called.
+         * <p>
+         * Usually, LayoutManager does not need to worry about this. However, in some cases, your
+         * LayoutManager may need to call some custom component with item positions in which
+         * case you need the actual adapter position instead of the pre layout position. You
+         * can use this method to convert a pre-layout position to adapter (post layout) position.
+         * <p>
+         * Note that if the provided position belongs to a deleted ViewHolder, this method will
+         * return -1.
+         * <p>
+         * Calling this method in post-layout state returns the same value back.
+         *
+         * @param position The pre-layout position to convert. Must be greater or equal to 0 and
+         *                 less than {@link State#getItemCount()}.
+         */
+        public int convertPreLayoutPositionToPostLayout(int position) {
+            if (position < 0 || position >= mState.getItemCount()) {
+                throw new IndexOutOfBoundsException("invalid position " + position + ". State "
+                        + "item count is " + mState.getItemCount());
+            }
+            if (!mState.isPreLayout()) {
+                return position;
+            }
+            return mAdapterHelper.findPositionOffset(position);
+        }
+
+        /**
+         * Obtain a view initialized for the given position.
+         *
+         * This method should be used by {@link LayoutManager} implementations to obtain
+         * views to represent data from an {@link Adapter}.
+         * <p>
+         * The Recycler may reuse a scrap or detached view from a shared pool if one is
+         * available for the correct view type. If the adapter has not indicated that the
+         * data at the given position has changed, the Recycler will attempt to hand back
+         * a scrap view that was previously initialized for that data without rebinding.
+         *
+         * @param position Position to obtain a view for
+         * @return A view representing the data at <code>position</code> from <code>adapter</code>
+         */
+        public View getViewForPosition(int position) {
+            return getViewForPosition(position, false);
+        }
+
+        View getViewForPosition(int position, boolean dryRun) {
+            if (position < 0 || position >= mState.getItemCount()) {
+                throw new IndexOutOfBoundsException("Invalid item position " + position
+                        + "(" + position + "). Item count:" + mState.getItemCount());
+            }
+            boolean fromScrap = false;
+            ViewHolder holder = null;
+            // 0) If there is a changed scrap, try to find from there
+            if (mState.isPreLayout()) {
+                holder = getChangedScrapViewForPosition(position);
+                fromScrap = holder != null;
+            }
+            // 1) Find from scrap by position
+            if (holder == null) {
+                holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun);
+                if (holder != null) {
+                    if (!validateViewHolderForOffsetPosition(holder)) {
+                        // recycle this scrap
+                        if (!dryRun) {
+                            // we would like to recycle this but need to make sure it is not used by
+                            // animation logic etc.
+                            holder.addFlags(ViewHolder.FLAG_INVALID);
+                            if (holder.isScrap()) {
+                                removeDetachedView(holder.itemView, false);
+                                holder.unScrap();
+                            } else if (holder.wasReturnedFromScrap()) {
+                                holder.clearReturnedFromScrapFlag();
+                            }
+                            recycleViewHolderInternal(holder);
+                        }
+                        holder = null;
+                    } else {
+                        fromScrap = true;
+                    }
+                }
+            }
+            if (holder == null) {
+                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
+                if (offsetPosition < 0 || offsetPosition >= mAdapter.getItemCount()) {
+                    throw new IndexOutOfBoundsException("Inconsistency detected. Invalid item "
+                            + "position " + position + "(offset:" + offsetPosition + ")."
+                            + "state:" + mState.getItemCount());
+                }
+
+                final int type = mAdapter.getItemViewType(offsetPosition);
+                // 2) Find from scrap via stable ids, if exists
+                if (mAdapter.hasStableIds()) {
+                    holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);
+                    if (holder != null) {
+                        // update position
+                        holder.mPosition = offsetPosition;
+                        fromScrap = true;
+                    }
+                }
+                if (holder == null && mViewCacheExtension != null) {
+                    // We are NOT sending the offsetPosition because LayoutManager does not
+                    // know it.
+                    final View view = mViewCacheExtension
+                            .getViewForPositionAndType(this, position, type);
+                    if (view != null) {
+                        holder = getChildViewHolder(view);
+                        if (holder == null) {
+                            throw new IllegalArgumentException("getViewForPositionAndType returned"
+                                    + " a view which does not have a ViewHolder");
+                        } else if (holder.shouldIgnore()) {
+                            throw new IllegalArgumentException("getViewForPositionAndType returned"
+                                    + " a view that is ignored. You must call stopIgnoring before"
+                                    + " returning this view.");
+                        }
+                    }
+                }
+                if (holder == null) { // fallback to recycler
+                    // try recycler.
+                    // Head to the shared pool.
+                    if (DEBUG) {
+                        Log.d(TAG, "getViewForPosition(" + position + ") fetching from shared "
+                                + "pool");
+                    }
+                    holder = getRecycledViewPool().getRecycledView(type);
+                    if (holder != null) {
+                        holder.resetInternal();
+                        if (FORCE_INVALIDATE_DISPLAY_LIST) {
+                            invalidateDisplayListInt(holder);
+                        }
+                    }
+                }
+                if (holder == null) {
+                    holder = mAdapter.createViewHolder(RecyclerView.this, type);
+                    if (DEBUG) {
+                        Log.d(TAG, "getViewForPosition created new ViewHolder");
+                    }
+                }
+            }
+            boolean bound = false;
+            if (mState.isPreLayout() && holder.isBound()) {
+                // do not update unless we absolutely have to.
+                holder.mPreLayoutPosition = position;
+            } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
+                if (DEBUG && holder.isRemoved()) {
+                    throw new IllegalStateException("Removed holder should be bound and it should"
+                            + " come here only in pre-layout. Holder: " + holder);
+                }
+                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
+                holder.mOwnerRecyclerView = RecyclerView.this;
+                mAdapter.bindViewHolder(holder, offsetPosition);
+                attachAccessibilityDelegate(holder.itemView);
+                bound = true;
+                if (mState.isPreLayout()) {
+                    holder.mPreLayoutPosition = position;
+                }
+            }
+
+            final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();
+            final LayoutParams rvLayoutParams;
+            if (lp == null) {
+                rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();
+                holder.itemView.setLayoutParams(rvLayoutParams);
+            } else if (!checkLayoutParams(lp)) {
+                rvLayoutParams = (LayoutParams) generateLayoutParams(lp);
+                holder.itemView.setLayoutParams(rvLayoutParams);
+            } else {
+                rvLayoutParams = (LayoutParams) lp;
+            }
+            rvLayoutParams.mViewHolder = holder;
+            rvLayoutParams.mPendingInvalidate = fromScrap && bound;
+            return holder.itemView;
+        }
+
+        private void attachAccessibilityDelegate(View itemView) {
+            if (mAccessibilityManager != null && mAccessibilityManager.isEnabled()) {
+                if (ViewCompat.getImportantForAccessibility(itemView) ==
+                        ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
+                    ViewCompat.setImportantForAccessibility(itemView,
+                            ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
+                }
+                if (!ViewCompat.hasAccessibilityDelegate(itemView)) {
+                    ViewCompat.setAccessibilityDelegate(itemView,
+                            mAccessibilityDelegate.getItemDelegate());
+                }
+            }
+        }
+
+        private void invalidateDisplayListInt(ViewHolder holder) {
+            if (holder.itemView instanceof ViewGroup) {
+                invalidateDisplayListInt((ViewGroup) holder.itemView, false);
+            }
+        }
+
+        private void invalidateDisplayListInt(ViewGroup viewGroup, boolean invalidateThis) {
+            for (int i = viewGroup.getChildCount() - 1; i >= 0; i--) {
+                final View view = viewGroup.getChildAt(i);
+                if (view instanceof ViewGroup) {
+                    invalidateDisplayListInt((ViewGroup) view, true);
+                }
+            }
+            if (!invalidateThis) {
+                return;
+            }
+            // we need to force it to become invisible
+            if (viewGroup.getVisibility() == View.INVISIBLE) {
+                viewGroup.setVisibility(View.VISIBLE);
+                viewGroup.setVisibility(View.INVISIBLE);
+            } else {
+                final int visibility = viewGroup.getVisibility();
+                viewGroup.setVisibility(View.INVISIBLE);
+                viewGroup.setVisibility(visibility);
+            }
+        }
+
+        /**
+         * Recycle a detached view. The specified view will be added to a pool of views
+         * for later rebinding and reuse.
+         *
+         * <p>A view must be fully detached (removed from parent) before it may be recycled. If the
+         * View is scrapped, it will be removed from scrap list.</p>
+         *
+         * @param view Removed view for recycling
+         * @see LayoutManager#removeAndRecycleView(View, Recycler)
+         */
+        public void recycleView(View view) {
+            // This public recycle method tries to make view recycle-able since layout manager
+            // intended to recycle this view (e.g. even if it is in scrap or change cache)
+            ViewHolder holder = getChildViewHolderInt(view);
+            if (holder.isTmpDetached()) {
+                removeDetachedView(view, false);
+            }
+            if (holder.isScrap()) {
+                holder.unScrap();
+            } else if (holder.wasReturnedFromScrap()){
+                holder.clearReturnedFromScrapFlag();
+            }
+            recycleViewHolderInternal(holder);
+        }
+
+        /**
+         * Internally, use this method instead of {@link #recycleView(android.view.View)} to
+         * catch potential bugs.
+         * @param view
+         */
+        void recycleViewInternal(View view) {
+            recycleViewHolderInternal(getChildViewHolderInt(view));
+        }
+
+        void recycleAndClearCachedViews() {
+            final int count = mCachedViews.size();
+            for (int i = count - 1; i >= 0; i--) {
+                recycleCachedViewAt(i);
+            }
+            mCachedViews.clear();
+        }
+
+        /**
+         * Recycles a cached view and removes the view from the list. Views are added to cache
+         * if and only if they are recyclable, so this method does not check it again.
+         * <p>
+         * A small exception to this rule is when the view does not have an animator reference
+         * but transient state is true (due to animations created outside ItemAnimator). In that
+         * case, adapter may choose to recycle it. From RecyclerView's perspective, the view is
+         * still recyclable since Adapter wants to do so.
+         *
+         * @param cachedViewIndex The index of the view in cached views list
+         */
+        void recycleCachedViewAt(int cachedViewIndex) {
+            if (DEBUG) {
+                Log.d(TAG, "Recycling cached view at index " + cachedViewIndex);
+            }
+            ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);
+            if (DEBUG) {
+                Log.d(TAG, "CachedViewHolder to be recycled: " + viewHolder);
+            }
+            addViewHolderToRecycledViewPool(viewHolder);
+            mCachedViews.remove(cachedViewIndex);
+        }
+
+        /**
+         * internal implementation checks if view is scrapped or attached and throws an exception
+         * if so.
+         * Public version un-scraps before calling recycle.
+         */
+        void recycleViewHolderInternal(ViewHolder holder) {
+            if (holder.isScrap() || holder.itemView.getParent() != null) {
+                throw new IllegalArgumentException(
+                        "Scrapped or attached views may not be recycled. isScrap:"
+                                + holder.isScrap() + " isAttached:"
+                                + (holder.itemView.getParent() != null));
+            }
+
+            if (holder.isTmpDetached()) {
+                throw new IllegalArgumentException("Tmp detached view should be removed "
+                        + "from RecyclerView before it can be recycled: " + holder);
+            }
+
+            if (holder.shouldIgnore()) {
+                throw new IllegalArgumentException("Trying to recycle an ignored view holder. You"
+                        + " should first call stopIgnoringView(view) before calling recycle.");
+            }
+            //noinspection unchecked
+            final boolean transientStatePreventsRecycling = holder
+                    .doesTransientStatePreventRecycling();
+            final boolean forceRecycle = mAdapter != null
+                    && transientStatePreventsRecycling
+                    && mAdapter.onFailedToRecycleView(holder);
+            boolean cached = false;
+            boolean recycled = false;
+            if (forceRecycle || holder.isRecyclable()) {
+                if (!holder.isInvalid() && !holder.isRemoved() && !holder.isChanged()) {
+                    // Retire oldest cached view
+                    final int cachedViewSize = mCachedViews.size();
+                    if (cachedViewSize == mViewCacheMax && cachedViewSize > 0) {
+                        recycleCachedViewAt(0);
+                    }
+                    if (cachedViewSize < mViewCacheMax) {
+                        mCachedViews.add(holder);
+                        cached = true;
+                    }
+                }
+                if (!cached) {
+                    addViewHolderToRecycledViewPool(holder);
+                    recycled = true;
+                }
+            } else if (DEBUG) {
+                Log.d(TAG, "trying to recycle a non-recycleable holder. Hopefully, it will "
+                        + "re-visit here. We are still removing it from animation lists");
+            }
+            // even if the holder is not removed, we still call this method so that it is removed
+            // from view holder lists.
+            mState.onViewRecycled(holder);
+            if (!cached && !recycled && transientStatePreventsRecycling) {
+                holder.mOwnerRecyclerView = null;
+            }
+        }
+
+        void addViewHolderToRecycledViewPool(ViewHolder holder) {
+            ViewCompat.setAccessibilityDelegate(holder.itemView, null);
+            dispatchViewRecycled(holder);
+            holder.mOwnerRecyclerView = null;
+            getRecycledViewPool().putRecycledView(holder);
+        }
+
+        /**
+         * Used as a fast path for unscrapping and recycling a view during a bulk operation.
+         * The caller must call {@link #clearScrap()} when it's done to update the recycler's
+         * internal bookkeeping.
+         */
+        void quickRecycleScrapView(View view) {
+            final ViewHolder holder = getChildViewHolderInt(view);
+            holder.mScrapContainer = null;
+            holder.clearReturnedFromScrapFlag();
+            recycleViewHolderInternal(holder);
+        }
+
+        /**
+         * Mark an attached view as scrap.
+         *
+         * <p>"Scrap" views are still attached to their parent RecyclerView but are eligible
+         * for rebinding and reuse. Requests for a view for a given position may return a
+         * reused or rebound scrap view instance.</p>
+         *
+         * @param view View to scrap
+         */
+        void scrapView(View view) {
+            final ViewHolder holder = getChildViewHolderInt(view);
+            holder.setScrapContainer(this);
+            if (!holder.isChanged() || !supportsChangeAnimations()) {
+                if (holder.isInvalid() && !holder.isRemoved() && !mAdapter.hasStableIds()) {
+                    throw new IllegalArgumentException("Called scrap view with an invalid view."
+                            + " Invalid views cannot be reused from scrap, they should rebound from"
+                            + " recycler pool.");
+                }
+                mAttachedScrap.add(holder);
+            } else {
+                if (mChangedScrap == null) {
+                    mChangedScrap = new ArrayList<ViewHolder>();
+                }
+                mChangedScrap.add(holder);
+            }
+        }
+
+        /**
+         * Remove a previously scrapped view from the pool of eligible scrap.
+         *
+         * <p>This view will no longer be eligible for reuse until re-scrapped or
+         * until it is explicitly removed and recycled.</p>
+         */
+        void unscrapView(ViewHolder holder) {
+            if (!holder.isChanged() || !supportsChangeAnimations() || mChangedScrap == null) {
+                mAttachedScrap.remove(holder);
+            } else {
+                mChangedScrap.remove(holder);
+            }
+            holder.mScrapContainer = null;
+            holder.clearReturnedFromScrapFlag();
+        }
+
+        int getScrapCount() {
+            return mAttachedScrap.size();
+        }
+
+        View getScrapViewAt(int index) {
+            return mAttachedScrap.get(index).itemView;
+        }
+
+        void clearScrap() {
+            mAttachedScrap.clear();
+        }
+
+        ViewHolder getChangedScrapViewForPosition(int position) {
+            // If pre-layout, check the changed scrap for an exact match.
+            final int changedScrapSize;
+            if (mChangedScrap == null || (changedScrapSize = mChangedScrap.size()) == 0) {
+                return null;
+            }
+            // find by position
+            for (int i = 0; i < changedScrapSize; i++) {
+                final ViewHolder holder = mChangedScrap.get(i);
+                if (!holder.wasReturnedFromScrap() && holder.getLayoutPosition() == position) {
+                    holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
+                    return holder;
+                }
+            }
+            // find by id
+            if (mAdapter.hasStableIds()) {
+                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
+                if (offsetPosition > 0 && offsetPosition < mAdapter.getItemCount()) {
+                    final long id = mAdapter.getItemId(offsetPosition);
+                    for (int i = 0; i < changedScrapSize; i++) {
+                        final ViewHolder holder = mChangedScrap.get(i);
+                        if (!holder.wasReturnedFromScrap() && holder.getItemId() == id) {
+                            holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
+                            return holder;
+                        }
+                    }
+                }
+            }
+            return null;
+        }
+
+        /**
+         * Returns a scrap view for the position. If type is not INVALID_TYPE, it also checks if
+         * ViewHolder's type matches the provided type.
+         *
+         * @param position Item position
+         * @param type View type
+         * @param dryRun  Does a dry run, finds the ViewHolder but does not remove
+         * @return a ViewHolder that can be re-used for this position.
+         */
+        ViewHolder getScrapViewForPosition(int position, int type, boolean dryRun) {
+            final int scrapCount = mAttachedScrap.size();
+
+            // Try first for an exact, non-invalid match from scrap.
+            for (int i = 0; i < scrapCount; i++) {
+                final ViewHolder holder = mAttachedScrap.get(i);
+                if (!holder.wasReturnedFromScrap() && holder.getLayoutPosition() == position
+                        && !holder.isInvalid() && (mState.mInPreLayout || !holder.isRemoved())) {
+                    if (type != INVALID_TYPE && holder.getItemViewType() != type) {
+                        Log.e(TAG, "Scrap view for position " + position + " isn't dirty but has" +
+                                " wrong view type! (found " + holder.getItemViewType() +
+                                " but expected " + type + ")");
+                        break;
+                    }
+                    holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
+                    return holder;
+                }
+            }
+
+            if (!dryRun) {
+                View view = mChildHelper.findHiddenNonRemovedView(position, type);
+                if (view != null) {
+                    // ending the animation should cause it to get recycled before we reuse it
+                    mItemAnimator.endAnimation(getChildViewHolder(view));
+                }
+            }
+
+            // Search in our first-level recycled view cache.
+            final int cacheSize = mCachedViews.size();
+            for (int i = 0; i < cacheSize; i++) {
+                final ViewHolder holder = mCachedViews.get(i);
+                // invalid view holders may be in cache if adapter has stable ids as they can be
+                // retrieved via getScrapViewForId
+                if (!holder.isInvalid() && holder.getLayoutPosition() == position) {
+                    if (!dryRun) {
+                        mCachedViews.remove(i);
+                    }
+                    if (DEBUG) {
+                        Log.d(TAG, "getScrapViewForPosition(" + position + ", " + type +
+                                ") found match in cache: " + holder);
+                    }
+                    return holder;
+                }
+            }
+            return null;
+        }
+
+        ViewHolder getScrapViewForId(long id, int type, boolean dryRun) {
+            // Look in our attached views first
+            final int count = mAttachedScrap.size();
+            for (int i = count - 1; i >= 0; i--) {
+                final ViewHolder holder = mAttachedScrap.get(i);
+                if (holder.getItemId() == id && !holder.wasReturnedFromScrap()) {
+                    if (type == holder.getItemViewType()) {
+                        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
+                        if (holder.isRemoved()) {
+                            // this might be valid in two cases:
+                            // > item is removed but we are in pre-layout pass
+                            // >> do nothing. return as is. make sure we don't rebind
+                            // > item is removed then added to another position and we are in
+                            // post layout.
+                            // >> remove removed and invalid flags, add update flag to rebind
+                            // because item was invisible to us and we don't know what happened in
+                            // between.
+                            if (!mState.isPreLayout()) {
+                                holder.setFlags(ViewHolder.FLAG_UPDATE, ViewHolder.FLAG_UPDATE |
+                                        ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED);
+                            }
+                        }
+                        return holder;
+                    } else if (!dryRun) {
+                        // Recycle this scrap. Type mismatch.
+                        mAttachedScrap.remove(i);
+                        removeDetachedView(holder.itemView, false);
+                        quickRecycleScrapView(holder.itemView);
+                    }
+                }
+            }
+
+            // Search the first-level cache
+            final int cacheSize = mCachedViews.size();
+            for (int i = cacheSize - 1; i >= 0; i--) {
+                final ViewHolder holder = mCachedViews.get(i);
+                if (holder.getItemId() == id) {
+                    if (type == holder.getItemViewType()) {
+                        if (!dryRun) {
+                            mCachedViews.remove(i);
+                        }
+                        return holder;
+                    } else if (!dryRun) {
+                        recycleCachedViewAt(i);
+                    }
+                }
+            }
+            return null;
+        }
+
+        void dispatchViewRecycled(ViewHolder holder) {
+            if (mRecyclerListener != null) {
+                mRecyclerListener.onViewRecycled(holder);
+            }
+            if (mAdapter != null) {
+                mAdapter.onViewRecycled(holder);
+            }
+            if (mState != null) {
+                mState.onViewRecycled(holder);
+            }
+            if (DEBUG) Log.d(TAG, "dispatchViewRecycled: " + holder);
+        }
+
+        void onAdapterChanged(Adapter oldAdapter, Adapter newAdapter,
+                boolean compatibleWithPrevious) {
+            clear();
+            getRecycledViewPool().onAdapterChanged(oldAdapter, newAdapter, compatibleWithPrevious);
+        }
+
+        void offsetPositionRecordsForMove(int from, int to) {
+            final int start, end, inBetweenOffset;
+            if (from < to) {
+                start = from;
+                end = to;
+                inBetweenOffset = -1;
+            } else {
+                start = to;
+                end = from;
+                inBetweenOffset = 1;
+            }
+            final int cachedCount = mCachedViews.size();
+            for (int i = 0; i < cachedCount; i++) {
+                final ViewHolder holder = mCachedViews.get(i);
+                if (holder == null || holder.mPosition < start || holder.mPosition > end) {
+                    continue;
+                }
+                if (holder.mPosition == from) {
+                    holder.offsetPosition(to - from, false);
+                } else {
+                    holder.offsetPosition(inBetweenOffset, false);
+                }
+                if (DEBUG) {
+                    Log.d(TAG, "offsetPositionRecordsForMove cached child " + i + " holder " +
+                            holder);
+                }
+            }
+        }
+
+        void offsetPositionRecordsForInsert(int insertedAt, int count) {
+            final int cachedCount = mCachedViews.size();
+            for (int i = 0; i < cachedCount; i++) {
+                final ViewHolder holder = mCachedViews.get(i);
+                if (holder != null && holder.getLayoutPosition() >= insertedAt) {
+                    if (DEBUG) {
+                        Log.d(TAG, "offsetPositionRecordsForInsert cached " + i + " holder " +
+                                holder + " now at position " + (holder.mPosition + count));
+                    }
+                    holder.offsetPosition(count, true);
+                }
+            }
+        }
+
+        /**
+         * @param removedFrom Remove start index
+         * @param count Remove count
+         * @param applyToPreLayout If true, changes will affect ViewHolder's pre-layout position, if
+         *                         false, they'll be applied before the second layout pass
+         */
+        void offsetPositionRecordsForRemove(int removedFrom, int count, boolean applyToPreLayout) {
+            final int removedEnd = removedFrom + count;
+            final int cachedCount = mCachedViews.size();
+            for (int i = cachedCount - 1; i >= 0; i--) {
+                final ViewHolder holder = mCachedViews.get(i);
+                if (holder != null) {
+                    if (holder.getLayoutPosition() >= removedEnd) {
+                        if (DEBUG) {
+                            Log.d(TAG, "offsetPositionRecordsForRemove cached " + i +
+                                    " holder " + holder + " now at position " +
+                                    (holder.mPosition - count));
+                        }
+                        holder.offsetPosition(-count, applyToPreLayout);
+                    } else if (holder.getLayoutPosition() >= removedFrom) {
+                        // Item for this view was removed. Dump it from the cache.
+                        holder.addFlags(ViewHolder.FLAG_REMOVED);
+                        recycleCachedViewAt(i);
+                    }
+                }
+            }
+        }
+
+        void setViewCacheExtension(ViewCacheExtension extension) {
+            mViewCacheExtension = extension;
+        }
+
+        void setRecycledViewPool(RecycledViewPool pool) {
+            if (mRecyclerPool != null) {
+                mRecyclerPool.detach();
+            }
+            mRecyclerPool = pool;
+            if (pool != null) {
+                mRecyclerPool.attach(getAdapter());
+            }
+        }
+
+        RecycledViewPool getRecycledViewPool() {
+            if (mRecyclerPool == null) {
+                mRecyclerPool = new RecycledViewPool();
+            }
+            return mRecyclerPool;
+        }
+
+        void viewRangeUpdate(int positionStart, int itemCount) {
+            final int positionEnd = positionStart + itemCount;
+            final int cachedCount = mCachedViews.size();
+            for (int i = 0; i < cachedCount; i++) {
+                final ViewHolder holder = mCachedViews.get(i);
+                if (holder == null) {
+                    continue;
+                }
+
+                final int pos = holder.getLayoutPosition();
+                if (pos >= positionStart && pos < positionEnd) {
+                    holder.addFlags(ViewHolder.FLAG_UPDATE);
+                    // cached views should not be flagged as changed because this will cause them
+                    // to animate when they are returned from cache.
+                }
+            }
+        }
+
+        void setAdapterPositionsAsUnknown() {
+            final int cachedCount = mCachedViews.size();
+            for (int i = 0; i < cachedCount; i++) {
+                final ViewHolder holder = mCachedViews.get(i);
+                if (holder != null) {
+                    holder.addFlags(ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);
+                }
+            }
+        }
+
+        void markKnownViewsInvalid() {
+            if (mAdapter != null && mAdapter.hasStableIds()) {
+                final int cachedCount = mCachedViews.size();
+                for (int i = 0; i < cachedCount; i++) {
+                    final ViewHolder holder = mCachedViews.get(i);
+                    if (holder != null) {
+                        holder.addFlags(ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID);
+                    }
+                }
+            } else {
+                // we cannot re-use cached views in this case. Recycle them all
+                recycleAndClearCachedViews();
+            }
+        }
+
+        void clearOldPositions() {
+            final int cachedCount = mCachedViews.size();
+            for (int i = 0; i < cachedCount; i++) {
+                final ViewHolder holder = mCachedViews.get(i);
+                holder.clearOldPosition();
+            }
+            final int scrapCount = mAttachedScrap.size();
+            for (int i = 0; i < scrapCount; i++) {
+                mAttachedScrap.get(i).clearOldPosition();
+            }
+            if (mChangedScrap != null) {
+                final int changedScrapCount = mChangedScrap.size();
+                for (int i = 0; i < changedScrapCount; i++) {
+                    mChangedScrap.get(i).clearOldPosition();
+                }
+            }
+        }
+
+        void markItemDecorInsetsDirty() {
+            final int cachedCount = mCachedViews.size();
+            for (int i = 0; i < cachedCount; i++) {
+                final ViewHolder holder = mCachedViews.get(i);
+                LayoutParams layoutParams = (LayoutParams) holder.itemView.getLayoutParams();
+                if (layoutParams != null) {
+                    layoutParams.mInsetsDirty = true;
+                }
+            }
+        }
+    }
+
+    /**
+     * ViewCacheExtension is a helper class to provide an additional layer of view caching that can
+     * ben controlled by the developer.
+     * <p>
+     * When {@link Recycler#getViewForPosition(int)} is called, Recycler checks attached scrap and
+     * first level cache to find a matching View. If it cannot find a suitable View, Recycler will
+     * call the {@link #getViewForPositionAndType(Recycler, int, int)} before checking
+     * {@link RecycledViewPool}.
+     * <p>
+     * Note that, Recycler never sends Views to this method to be cached. It is developers
+     * responsibility to decide whether they want to keep their Views in this custom cache or let
+     * the default recycling policy handle it.
+     */
+    public abstract static class ViewCacheExtension {
+
+        /**
+         * Returns a View that can be binded to the given Adapter position.
+         * <p>
+         * This method should <b>not</b> create a new View. Instead, it is expected to return
+         * an already created View that can be re-used for the given type and position.
+         * If the View is marked as ignored, it should first call
+         * {@link LayoutManager#stopIgnoringView(View)} before returning the View.
+         * <p>
+         * RecyclerView will re-bind the returned View to the position if necessary.
+         *
+         * @param recycler The Recycler that can be used to bind the View
+         * @param position The adapter position
+         * @param type     The type of the View, defined by adapter
+         * @return A View that is bound to the given position or NULL if there is no View to re-use
+         * @see LayoutManager#ignoreView(View)
+         */
+        abstract public View getViewForPositionAndType(Recycler recycler, int position, int type);
+    }
+
+    /**
+     * Base class for an Adapter
+     *
+     * <p>Adapters provide a binding from an app-specific data set to views that are displayed
+     * within a {@link RecyclerView}.</p>
+     */
+    public static abstract class Adapter<VH extends ViewHolder> {
+        private final AdapterDataObservable mObservable = new AdapterDataObservable();
+        private boolean mHasStableIds = false;
+
+        /**
+         * Called when RecyclerView needs a new {@link ViewHolder} of the given type to represent
+         * an item.
+         * <p>
+         * This new ViewHolder should be constructed with a new View that can represent the items
+         * of the given type. You can either create a new View manually or inflate it from an XML
+         * layout file.
+         * <p>
+         * The new ViewHolder will be used to display items of the adapter using
+         * {@link #onBindViewHolder(ViewHolder, int)}. Since it will be re-used to display different
+         * items in the data set, it is a good idea to cache references to sub views of the View to
+         * avoid unnecessary {@link View#findViewById(int)} calls.
+         *
+         * @param parent The ViewGroup into which the new View will be added after it is bound to
+         *               an adapter position.
+         * @param viewType The view type of the new View.
+         *
+         * @return A new ViewHolder that holds a View of the given view type.
+         * @see #getItemViewType(int)
+         * @see #onBindViewHolder(ViewHolder, int)
+         */
+        public abstract VH onCreateViewHolder(ViewGroup parent, int viewType);
+
+        /**
+         * Called by RecyclerView to display the data at the specified position. This method
+         * should update the contents of the {@link ViewHolder#itemView} to reflect the item at
+         * the given position.
+         * <p>
+         * Note that unlike {@link android.widget.ListView}, RecyclerView will not call this
+         * method again if the position of the item changes in the data set unless the item itself
+         * is invalidated or the new position cannot be determined. For this reason, you should only
+         * use the <code>position</code> parameter while acquiring the related data item inside this
+         * method and should not keep a copy of it. If you need the position of an item later on
+         * (e.g. in a click listener), use {@link ViewHolder#getAdapterPosition()} which will have
+         * the updated adapter position.
+         *
+         * @param holder The ViewHolder which should be updated to represent the contents of the
+         *               item at the given position in the data set.
+         * @param position The position of the item within the adapter's data set.
+         */
+        public abstract void onBindViewHolder(VH holder, int position);
+
+        /**
+         * This method calls {@link #onCreateViewHolder(ViewGroup, int)} to create a new
+         * {@link ViewHolder} and initializes some private fields to be used by RecyclerView.
+         *
+         * @see #onCreateViewHolder(ViewGroup, int)
+         */
+        public final VH createViewHolder(ViewGroup parent, int viewType) {
+            final VH holder = onCreateViewHolder(parent, viewType);
+            holder.mItemViewType = viewType;
+            return holder;
+        }
+
+        /**
+         * This method internally calls {@link #onBindViewHolder(ViewHolder, int)} to update the
+         * {@link ViewHolder} contents with the item at the given position and also sets up some
+         * private fields to be used by RecyclerView.
+         *
+         * @see #onBindViewHolder(ViewHolder, int)
+         */
+        public final void bindViewHolder(VH holder, int position) {
+            holder.mPosition = position;
+            if (hasStableIds()) {
+                holder.mItemId = getItemId(position);
+            }
+            holder.setFlags(ViewHolder.FLAG_BOUND,
+                    ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID
+                            | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);
+            onBindViewHolder(holder, position);
+        }
+
+        /**
+         * Return the view type of the item at <code>position</code> for the purposes
+         * of view recycling.
+         *
+         * <p>The default implementation of this method returns 0, making the assumption of
+         * a single view type for the adapter. Unlike ListView adapters, types need not
+         * be contiguous. Consider using id resources to uniquely identify item view types.
+         *
+         * @param position position to query
+         * @return integer value identifying the type of the view needed to represent the item at
+         *                 <code>position</code>. Type codes need not be contiguous.
+         */
+        public int getItemViewType(int position) {
+            return 0;
+        }
+
+        /**
+         * Indicates whether each item in the data set can be represented with a unique identifier
+         * of type {@link java.lang.Long}.
+         *
+         * @param hasStableIds Whether items in data set have unique identifiers or not.
+         * @see #hasStableIds()
+         * @see #getItemId(int)
+         */
+        public void setHasStableIds(boolean hasStableIds) {
+            if (hasObservers()) {
+                throw new IllegalStateException("Cannot change whether this adapter has " +
+                        "stable IDs while the adapter has registered observers.");
+            }
+            mHasStableIds = hasStableIds;
+        }
+
+        /**
+         * Return the stable ID for the item at <code>position</code>. If {@link #hasStableIds()}
+         * would return false this method should return {@link #NO_ID}. The default implementation
+         * of this method returns {@link #NO_ID}.
+         *
+         * @param position Adapter position to query
+         * @return the stable ID of the item at position
+         */
+        public long getItemId(int position) {
+            return NO_ID;
+        }
+
+        /**
+         * Returns the total number of items in the data set hold by the adapter.
+         *
+         * @return The total number of items in this adapter.
+         */
+        public abstract int getItemCount();
+
+        /**
+         * Returns true if this adapter publishes a unique <code>long</code> value that can
+         * act as a key for the item at a given position in the data set. If that item is relocated
+         * in the data set, the ID returned for that item should be the same.
+         *
+         * @return true if this adapter's items have stable IDs
+         */
+        public final boolean hasStableIds() {
+            return mHasStableIds;
+        }
+
+        /**
+         * Called when a view created by this adapter has been recycled.
+         *
+         * <p>A view is recycled when a {@link LayoutManager} decides that it no longer
+         * needs to be attached to its parent {@link RecyclerView}. This can be because it has
+         * fallen out of visibility or a set of cached views represented by views still
+         * attached to the parent RecyclerView. If an item view has large or expensive data
+         * bound to it such as large bitmaps, this may be a good place to release those
+         * resources.</p>
+         * <p>
+         * RecyclerView calls this method right before clearing ViewHolder's internal data and
+         * sending it to RecycledViewPool. This way, if ViewHolder was holding valid information
+         * before being recycled, you can call {@link ViewHolder#getAdapterPosition()} to get
+         * its adapter position.
+         *
+         * @param holder The ViewHolder for the view being recycled
+         */
+        public void onViewRecycled(VH holder) {
+        }
+
+        /**
+         * Called by the RecyclerView if a ViewHolder created by this Adapter cannot be recycled
+         * due to its transient state. Upon receiving this callback, Adapter can clear the
+         * animation(s) that effect the View's transient state and return <code>true</code> so that
+         * the View can be recycled. Keep in mind that the View in question is already removed from
+         * the RecyclerView.
+         * <p>
+         * In some cases, it is acceptable to recycle a View although it has transient state. Most
+         * of the time, this is a case where the transient state will be cleared in
+         * {@link #onBindViewHolder(ViewHolder, int)} call when View is rebound to a new position.
+         * For this reason, RecyclerView leaves the decision to the Adapter and uses the return
+         * value of this method to decide whether the View should be recycled or not.
+         * <p>
+         * Note that when all animations are created by {@link RecyclerView.ItemAnimator}, you
+         * should never receive this callback because RecyclerView keeps those Views as children
+         * until their animations are complete. This callback is useful when children of the item
+         * views create animations which may not be easy to implement using an {@link ItemAnimator}.
+         * <p>
+         * You should <em>never</em> fix this issue by calling
+         * <code>holder.itemView.setHasTransientState(false);</code> unless you've previously called
+         * <code>holder.itemView.setHasTransientState(true);</code>. Each
+         * <code>View.setHasTransientState(true)</code> call must be matched by a
+         * <code>View.setHasTransientState(false)</code> call, otherwise, the state of the View
+         * may become inconsistent. You should always prefer to end or cancel animations that are
+         * triggering the transient state instead of handling it manually.
+         *
+         * @param holder The ViewHolder containing the View that could not be recycled due to its
+         *               transient state.
+         * @return True if the View should be recycled, false otherwise. Note that if this method
+         * returns <code>true</code>, RecyclerView <em>will ignore</em> the transient state of
+         * the View and recycle it regardless. If this method returns <code>false</code>,
+         * RecyclerView will check the View's transient state again before giving a final decision.
+         * Default implementation returns false.
+         */
+        public boolean onFailedToRecycleView(VH holder) {
+            return false;
+        }
+
+        /**
+         * Called when a view created by this adapter has been attached to a window.
+         *
+         * <p>This can be used as a reasonable signal that the view is about to be seen
+         * by the user. If the adapter previously freed any resources in
+         * {@link #onViewDetachedFromWindow(RecyclerView.ViewHolder) onViewDetachedFromWindow}
+         * those resources should be restored here.</p>
+         *
+         * @param holder Holder of the view being attached
+         */
+        public void onViewAttachedToWindow(VH holder) {
+        }
+
+        /**
+         * Called when a view created by this adapter has been detached from its window.
+         *
+         * <p>Becoming detached from the window is not necessarily a permanent condition;
+         * the consumer of an Adapter's views may choose to cache views offscreen while they
+         * are not visible, attaching an detaching them as appropriate.</p>
+         *
+         * @param holder Holder of the view being detached
+         */
+        public void onViewDetachedFromWindow(VH holder) {
+        }
+
+        /**
+         * Returns true if one or more observers are attached to this adapter.
+         *
+         * @return true if this adapter has observers
+         */
+        public final boolean hasObservers() {
+            return mObservable.hasObservers();
+        }
+
+        /**
+         * Register a new observer to listen for data changes.
+         *
+         * <p>The adapter may publish a variety of events describing specific changes.
+         * Not all adapters may support all change types and some may fall back to a generic
+         * {@link android.support.v7.widget.RecyclerView.AdapterDataObserver#onChanged()
+         * "something changed"} event if more specific data is not available.</p>
+         *
+         * <p>Components registering observers with an adapter are responsible for
+         * {@link #unregisterAdapterDataObserver(RecyclerView.AdapterDataObserver)
+         * unregistering} those observers when finished.</p>
+         *
+         * @param observer Observer to register
+         *
+         * @see #unregisterAdapterDataObserver(RecyclerView.AdapterDataObserver)
+         */
+        public void registerAdapterDataObserver(AdapterDataObserver observer) {
+            mObservable.registerObserver(observer);
+        }
+
+        /**
+         * Unregister an observer currently listening for data changes.
+         *
+         * <p>The unregistered observer will no longer receive events about changes
+         * to the adapter.</p>
+         *
+         * @param observer Observer to unregister
+         *
+         * @see #registerAdapterDataObserver(RecyclerView.AdapterDataObserver)
+         */
+        public void unregisterAdapterDataObserver(AdapterDataObserver observer) {
+            mObservable.unregisterObserver(observer);
+        }
+
+        /**
+         * Called by RecyclerView when it starts observing this Adapter.
+         * <p>
+         * Keep in mind that same adapter may be observed by multiple RecyclerViews.
+         *
+         * @param recyclerView The RecyclerView instance which started observing this adapter.
+         * @see #onDetachedFromRecyclerView(RecyclerView)
+         */
+        public void onAttachedToRecyclerView(RecyclerView recyclerView) {
+        }
+
+        /**
+         * Called by RecyclerView when it stops observing this Adapter.
+         *
+         * @param recyclerView The RecyclerView instance which stopped observing this adapter.
+         * @see #onAttachedToRecyclerView(RecyclerView)
+         */
+        public void onDetachedFromRecyclerView(RecyclerView recyclerView) {
+        }
+
+        /**
+         * Notify any registered observers that the data set has changed.
+         *
+         * <p>There are two different classes of data change events, item changes and structural
+         * changes. Item changes are when a single item has its data updated but no positional
+         * changes have occurred. Structural changes are when items are inserted, removed or moved
+         * within the data set.</p>
+         *
+         * <p>This event does not specify what about the data set has changed, forcing
+         * any observers to assume that all existing items and structure may no longer be valid.
+         * LayoutManagers will be forced to fully rebind and relayout all visible views.</p>
+         *
+         * <p><code>RecyclerView</code> will attempt to synthesize visible structural change events
+         * for adapters that report that they have {@link #hasStableIds() stable IDs} when
+         * this method is used. This can help for the purposes of animation and visual
+         * object persistence but individual item views will still need to be rebound
+         * and relaid out.</p>
+         *
+         * <p>If you are writing an adapter it will always be more efficient to use the more
+         * specific change events if you can. Rely on <code>notifyDataSetChanged()</code>
+         * as a last resort.</p>
+         *
+         * @see #notifyItemChanged(int)
+         * @see #notifyItemInserted(int)
+         * @see #notifyItemRemoved(int)
+         * @see #notifyItemRangeChanged(int, int)
+         * @see #notifyItemRangeInserted(int, int)
+         * @see #notifyItemRangeRemoved(int, int)
+         */
+        public final void notifyDataSetChanged() {
+            mObservable.notifyChanged();
+        }
+
+        /**
+         * Notify any registered observers that the item at <code>position</code> has changed.
+         *
+         * <p>This is an item change event, not a structural change event. It indicates that any
+         * reflection of the data at <code>position</code> is out of date and should be updated.
+         * The item at <code>position</code> retains the same identity.</p>
+         *
+         * @param position Position of the item that has changed
+         *
+         * @see #notifyItemRangeChanged(int, int)
+         */
+        public final void notifyItemChanged(int position) {
+            mObservable.notifyItemRangeChanged(position, 1);
+        }
+
+        /**
+         * Notify any registered observers that the <code>itemCount</code> items starting at
+         * position <code>positionStart</code> have changed.
+         *
+         * <p>This is an item change event, not a structural change event. It indicates that
+         * any reflection of the data in the given position range is out of date and should
+         * be updated. The items in the given range retain the same identity.</p>
+         *
+         * @param positionStart Position of the first item that has changed
+         * @param itemCount Number of items that have changed
+         *
+         * @see #notifyItemChanged(int)
+         */
+        public final void notifyItemRangeChanged(int positionStart, int itemCount) {
+            mObservable.notifyItemRangeChanged(positionStart, itemCount);
+        }
+
+        /**
+         * Notify any registered observers that the item reflected at <code>position</code>
+         * has been newly inserted. The item previously at <code>position</code> is now at
+         * position <code>position + 1</code>.
+         *
+         * <p>This is a structural change event. Representations of other existing items in the
+         * data set are still considered up to date and will not be rebound, though their
+         * positions may be altered.</p>
+         *
+         * @param position Position of the newly inserted item in the data set
+         *
+         * @see #notifyItemRangeInserted(int, int)
+         */
+        public final void notifyItemInserted(int position) {
+            mObservable.notifyItemRangeInserted(position, 1);
+        }
+
+        /**
+         * Notify any registered observers that the item reflected at <code>fromPosition</code>
+         * has been moved to <code>toPosition</code>.
+         *
+         * <p>This is a structural change event. Representations of other existing items in the
+         * data set are still considered up to date and will not be rebound, though their
+         * positions may be altered.</p>
+         *
+         * @param fromPosition Previous position of the item.
+         * @param toPosition New position of the item.
+         */
+        public final void notifyItemMoved(int fromPosition, int toPosition) {
+            mObservable.notifyItemMoved(fromPosition, toPosition);
+        }
+
+        /**
+         * Notify any registered observers that the currently reflected <code>itemCount</code>
+         * items starting at <code>positionStart</code> have been newly inserted. The items
+         * previously located at <code>positionStart</code> and beyond can now be found starting
+         * at position <code>positionStart + itemCount</code>.
+         *
+         * <p>This is a structural change event. Representations of other existing items in the
+         * data set are still considered up to date and will not be rebound, though their positions
+         * may be altered.</p>
+         *
+         * @param positionStart Position of the first item that was inserted
+         * @param itemCount Number of items inserted
+         *
+         * @see #notifyItemInserted(int)
+         */
+        public final void notifyItemRangeInserted(int positionStart, int itemCount) {
+            mObservable.notifyItemRangeInserted(positionStart, itemCount);
+        }
+
+        /**
+         * Notify any registered observers that the item previously located at <code>position</code>
+         * has been removed from the data set. The items previously located at and after
+         * <code>position</code> may now be found at <code>oldPosition - 1</code>.
+         *
+         * <p>This is a structural change event. Representations of other existing items in the
+         * data set are still considered up to date and will not be rebound, though their positions
+         * may be altered.</p>
+         *
+         * @param position Position of the item that has now been removed
+         *
+         * @see #notifyItemRangeRemoved(int, int)
+         */
+        public final void notifyItemRemoved(int position) {
+            mObservable.notifyItemRangeRemoved(position, 1);
+        }
+
+        /**
+         * Notify any registered observers that the <code>itemCount</code> items previously
+         * located at <code>positionStart</code> have been removed from the data set. The items
+         * previously located at and after <code>positionStart + itemCount</code> may now be found
+         * at <code>oldPosition - itemCount</code>.
+         *
+         * <p>This is a structural change event. Representations of other existing items in the data
+         * set are still considered up to date and will not be rebound, though their positions
+         * may be altered.</p>
+         *
+         * @param positionStart Previous position of the first item that was removed
+         * @param itemCount Number of items removed from the data set
+         */
+        public final void notifyItemRangeRemoved(int positionStart, int itemCount) {
+            mObservable.notifyItemRangeRemoved(positionStart, itemCount);
+        }
+    }
+
+    private void dispatchChildDetached(View child) {
+        if (mAdapter != null) {
+            mAdapter.onViewDetachedFromWindow(getChildViewHolderInt(child));
+        }
+        onChildDetachedFromWindow(child);
+    }
+
+    private void dispatchChildAttached(View child) {
+        if (mAdapter != null) {
+            mAdapter.onViewAttachedToWindow(getChildViewHolderInt(child));
+        }
+        onChildAttachedToWindow(child);
+    }
+
+    /**
+     * A <code>LayoutManager</code> is responsible for measuring and positioning item views
+     * within a <code>RecyclerView</code> as well as determining the policy for when to recycle
+     * item views that are no longer visible to the user. By changing the <code>LayoutManager</code>
+     * a <code>RecyclerView</code> can be used to implement a standard vertically scrolling list,
+     * a uniform grid, staggered grids, horizontally scrolling collections and more. Several stock
+     * layout managers are provided for general use.
+     */
+    public static abstract class LayoutManager {
+        ChildHelper mChildHelper;
+        RecyclerView mRecyclerView;
+
+        @Nullable
+        SmoothScroller mSmoothScroller;
+
+        private boolean mRequestedSimpleAnimations = false;
+
+        private boolean mIsAttachedToWindow = false;
+
+        void setRecyclerView(RecyclerView recyclerView) {
+            if (recyclerView == null) {
+                mRecyclerView = null;
+                mChildHelper = null;
+            } else {
+                mRecyclerView = recyclerView;
+                mChildHelper = recyclerView.mChildHelper;
+            }
+
+        }
+
+        /**
+         * Calls {@code RecyclerView#requestLayout} on the underlying RecyclerView
+         */
+        public void requestLayout() {
+            if(mRecyclerView != null) {
+                mRecyclerView.requestLayout();
+            }
+        }
+
+        /**
+         * Checks if RecyclerView is in the middle of a layout or scroll and throws an
+         * {@link IllegalStateException} if it <b>is not</b>.
+         *
+         * @param message The message for the exception. Can be null.
+         * @see #assertNotInLayoutOrScroll(String)
+         */
+        public void assertInLayoutOrScroll(String message) {
+            if (mRecyclerView != null) {
+                mRecyclerView.assertInLayoutOrScroll(message);
+            }
+        }
+
+        /**
+         * Checks if RecyclerView is in the middle of a layout or scroll and throws an
+         * {@link IllegalStateException} if it <b>is</b>.
+         *
+         * @param message The message for the exception. Can be null.
+         * @see #assertInLayoutOrScroll(String)
+         */
+        public void assertNotInLayoutOrScroll(String message) {
+            if (mRecyclerView != null) {
+                mRecyclerView.assertNotInLayoutOrScroll(message);
+            }
+        }
+
+        /**
+         * Returns whether this LayoutManager supports automatic item animations.
+         * A LayoutManager wishing to support item animations should obey certain
+         * rules as outlined in {@link #onLayoutChildren(Recycler, State)}.
+         * The default return value is <code>false</code>, so subclasses of LayoutManager
+         * will not get predictive item animations by default.
+         *
+         * <p>Whether item animations are enabled in a RecyclerView is determined both
+         * by the return value from this method and the
+         * {@link RecyclerView#setItemAnimator(ItemAnimator) ItemAnimator} set on the
+         * RecyclerView itself. If the RecyclerView has a non-null ItemAnimator but this
+         * method returns false, then simple item animations will be enabled, in which
+         * views that are moving onto or off of the screen are simply faded in/out. If
+         * the RecyclerView has a non-null ItemAnimator and this method returns true,
+         * then there will be two calls to {@link #onLayoutChildren(Recycler, State)} to
+         * setup up the information needed to more intelligently predict where appearing
+         * and disappearing views should be animated from/to.</p>
+         *
+         * @return true if predictive item animations should be enabled, false otherwise
+         */
+        public boolean supportsPredictiveItemAnimations() {
+            return false;
+        }
+
+        void dispatchAttachedToWindow(RecyclerView view) {
+            mIsAttachedToWindow = true;
+            onAttachedToWindow(view);
+        }
+
+        void dispatchDetachedFromWindow(RecyclerView view, Recycler recycler) {
+            mIsAttachedToWindow = false;
+            onDetachedFromWindow(view, recycler);
+        }
+
+        /**
+         * Returns whether LayoutManager is currently attached to a RecyclerView which is attached
+         * to a window.
+         *
+         * @return True if this LayoutManager is controlling a RecyclerView and the RecyclerView
+         * is attached to window.
+         */
+        public boolean isAttachedToWindow() {
+            return mIsAttachedToWindow;
+        }
+
+        /**
+         * Causes the Runnable to execute on the next animation time step.
+         * The runnable will be run on the user interface thread.
+         * <p>
+         * Calling this method when LayoutManager is not attached to a RecyclerView has no effect.
+         *
+         * @param action The Runnable that will be executed.
+         *
+         * @see #removeCallbacks
+         */
+        public void postOnAnimation(Runnable action) {
+            if (mRecyclerView != null) {
+                ViewCompat.postOnAnimation(mRecyclerView, action);
+            }
+        }
+
+        /**
+         * Removes the specified Runnable from the message queue.
+         * <p>
+         * Calling this method when LayoutManager is not attached to a RecyclerView has no effect.
+         *
+         * @param action The Runnable to remove from the message handling queue
+         *
+         * @return true if RecyclerView could ask the Handler to remove the Runnable,
+         *         false otherwise. When the returned value is true, the Runnable
+         *         may or may not have been actually removed from the message queue
+         *         (for instance, if the Runnable was not in the queue already.)
+         *
+         * @see #postOnAnimation
+         */
+        public boolean removeCallbacks(Runnable action) {
+            if (mRecyclerView != null) {
+                return mRecyclerView.removeCallbacks(action);
+            }
+            return false;
+        }
+        /**
+         * Called when this LayoutManager is both attached to a RecyclerView and that RecyclerView
+         * is attached to a window.
+         *
+         * <p>Subclass implementations should always call through to the superclass implementation.
+         * </p>
+         *
+         * @param view The RecyclerView this LayoutManager is bound to
+         */
+        public void onAttachedToWindow(RecyclerView view) {
+        }
+
+        /**
+         * @deprecated
+         * override {@link #onDetachedFromWindow(RecyclerView, Recycler)}
+         */
+        @Deprecated
+        public void onDetachedFromWindow(RecyclerView view) {
+
+        }
+
+        /**
+         * Called when this LayoutManager is detached from its parent RecyclerView or when
+         * its parent RecyclerView is detached from its window.
+         *
+         * <p>Subclass implementations should always call through to the superclass implementation.
+         * </p>
+         *
+         * @param view The RecyclerView this LayoutManager is bound to
+         * @param recycler The recycler to use if you prefer to recycle your children instead of
+         *                 keeping them around.
+         */
+        public void onDetachedFromWindow(RecyclerView view, Recycler recycler) {
+            onDetachedFromWindow(view);
+        }
+
+        /**
+         * Check if the RecyclerView is configured to clip child views to its padding.
+         *
+         * @return true if this RecyclerView clips children to its padding, false otherwise
+         */
+        public boolean getClipToPadding() {
+            return mRecyclerView != null && mRecyclerView.mClipToPadding;
+        }
+
+        /**
+         * Lay out all relevant child views from the given adapter.
+         *
+         * The LayoutManager is in charge of the behavior of item animations. By default,
+         * RecyclerView has a non-null {@link #getItemAnimator() ItemAnimator}, and simple
+         * item animations are enabled. This means that add/remove operations on the
+         * adapter will result in animations to add new or appearing items, removed or
+         * disappearing items, and moved items. If a LayoutManager returns false from
+         * {@link #supportsPredictiveItemAnimations()}, which is the default, and runs a
+         * normal layout operation during {@link #onLayoutChildren(Recycler, State)}, the
+         * RecyclerView will have enough information to run those animations in a simple
+         * way. For example, the default ItemAnimator, {@link DefaultItemAnimator}, will
+         * simple fade views in and out, whether they are actuall added/removed or whether
+         * they are moved on or off the screen due to other add/remove operations.
+         *
+         * <p>A LayoutManager wanting a better item animation experience, where items can be
+         * animated onto and off of the screen according to where the items exist when they
+         * are not on screen, then the LayoutManager should return true from
+         * {@link #supportsPredictiveItemAnimations()} and add additional logic to
+         * {@link #onLayoutChildren(Recycler, State)}. Supporting predictive animations
+         * means that {@link #onLayoutChildren(Recycler, State)} will be called twice;
+         * once as a "pre" layout step to determine where items would have been prior to
+         * a real layout, and again to do the "real" layout. In the pre-layout phase,
+         * items will remember their pre-layout positions to allow them to be laid out
+         * appropriately. Also, {@link LayoutParams#isItemRemoved() removed} items will
+         * be returned from the scrap to help determine correct placement of other items.
+         * These removed items should not be added to the child list, but should be used
+         * to help calculate correct positioning of other views, including views that
+         * were not previously onscreen (referred to as APPEARING views), but whose
+         * pre-layout offscreen position can be determined given the extra
+         * information about the pre-layout removed views.</p>
+         *
+         * <p>The second layout pass is the real layout in which only non-removed views
+         * will be used. The only additional requirement during this pass is, if
+         * {@link #supportsPredictiveItemAnimations()} returns true, to note which
+         * views exist in the child list prior to layout and which are not there after
+         * layout (referred to as DISAPPEARING views), and to position/layout those views
+         * appropriately, without regard to the actual bounds of the RecyclerView. This allows
+         * the animation system to know the location to which to animate these disappearing
+         * views.</p>
+         *
+         * <p>The default LayoutManager implementations for RecyclerView handle all of these
+         * requirements for animations already. Clients of RecyclerView can either use one
+         * of these layout managers directly or look at their implementations of
+         * onLayoutChildren() to see how they account for the APPEARING and
+         * DISAPPEARING views.</p>
+         *
+         * @param recycler         Recycler to use for fetching potentially cached views for a
+         *                         position
+         * @param state            Transient state of RecyclerView
+         */
+        public void onLayoutChildren(Recycler recycler, State state) {
+            Log.e(TAG, "You must override onLayoutChildren(Recycler recycler, State state) ");
+        }
+
+        /**
+         * Create a default <code>LayoutParams</code> object for a child of the RecyclerView.
+         *
+         * <p>LayoutManagers will often want to use a custom <code>LayoutParams</code> type
+         * to store extra information specific to the layout. Client code should subclass
+         * {@link RecyclerView.LayoutParams} for this purpose.</p>
+         *
+         * <p><em>Important:</em> if you use your own custom <code>LayoutParams</code> type
+         * you must also override
+         * {@link #checkLayoutParams(LayoutParams)},
+         * {@link #generateLayoutParams(android.view.ViewGroup.LayoutParams)} and
+         * {@link #generateLayoutParams(android.content.Context, android.util.AttributeSet)}.</p>
+         *
+         * @return A new LayoutParams for a child view
+         */
+        public abstract LayoutParams generateDefaultLayoutParams();
+
+        /**
+         * Determines the validity of the supplied LayoutParams object.
+         *
+         * <p>This should check to make sure that the object is of the correct type
+         * and all values are within acceptable ranges. The default implementation
+         * returns <code>true</code> for non-null params.</p>
+         *
+         * @param lp LayoutParams object to check
+         * @return true if this LayoutParams object is valid, false otherwise
+         */
+        public boolean checkLayoutParams(LayoutParams lp) {
+            return lp != null;
+        }
+
+        /**
+         * Create a LayoutParams object suitable for this LayoutManager, copying relevant
+         * values from the supplied LayoutParams object if possible.
+         *
+         * <p><em>Important:</em> if you use your own custom <code>LayoutParams</code> type
+         * you must also override
+         * {@link #checkLayoutParams(LayoutParams)},
+         * {@link #generateLayoutParams(android.view.ViewGroup.LayoutParams)} and
+         * {@link #generateLayoutParams(android.content.Context, android.util.AttributeSet)}.</p>
+         *
+         * @param lp Source LayoutParams object to copy values from
+         * @return a new LayoutParams object
+         */
+        public LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp) {
+            if (lp instanceof LayoutParams) {
+                return new LayoutParams((LayoutParams) lp);
+            } else if (lp instanceof MarginLayoutParams) {
+                return new LayoutParams((MarginLayoutParams) lp);
+            } else {
+                return new LayoutParams(lp);
+            }
+        }
+
+        /**
+         * Create a LayoutParams object suitable for this LayoutManager from
+         * an inflated layout resource.
+         *
+         * <p><em>Important:</em> if you use your own custom <code>LayoutParams</code> type
+         * you must also override
+         * {@link #checkLayoutParams(LayoutParams)},
+         * {@link #generateLayoutParams(android.view.ViewGroup.LayoutParams)} and
+         * {@link #generateLayoutParams(android.content.Context, android.util.AttributeSet)}.</p>
+         *
+         * @param c Context for obtaining styled attributes
+         * @param attrs AttributeSet describing the supplied arguments
+         * @return a new LayoutParams object
+         */
+        public LayoutParams generateLayoutParams(Context c, AttributeSet attrs) {
+            return new LayoutParams(c, attrs);
+        }
+
+        /**
+         * Scroll horizontally by dx pixels in screen coordinates and return the distance traveled.
+         * The default implementation does nothing and returns 0.
+         *
+         * @param dx            distance to scroll by in pixels. X increases as scroll position
+         *                      approaches the right.
+         * @param recycler      Recycler to use for fetching potentially cached views for a
+         *                      position
+         * @param state         Transient state of RecyclerView
+         * @return The actual distance scrolled. The return value will be negative if dx was
+         * negative and scrolling proceeeded in that direction.
+         * <code>Math.abs(result)</code> may be less than dx if a boundary was reached.
+         */
+        public int scrollHorizontallyBy(int dx, Recycler recycler, State state) {
+            return 0;
+        }
+
+        /**
+         * Scroll vertically by dy pixels in screen coordinates and return the distance traveled.
+         * The default implementation does nothing and returns 0.
+         *
+         * @param dy            distance to scroll in pixels. Y increases as scroll position
+         *                      approaches the bottom.
+         * @param recycler      Recycler to use for fetching potentially cached views for a
+         *                      position
+         * @param state         Transient state of RecyclerView
+         * @return The actual distance scrolled. The return value will be negative if dy was
+         * negative and scrolling proceeeded in that direction.
+         * <code>Math.abs(result)</code> may be less than dy if a boundary was reached.
+         */
+        public int scrollVerticallyBy(int dy, Recycler recycler, State state) {
+            return 0;
+        }
+
+        /**
+         * Query if horizontal scrolling is currently supported. The default implementation
+         * returns false.
+         *
+         * @return True if this LayoutManager can scroll the current contents horizontally
+         */
+        public boolean canScrollHorizontally() {
+            return false;
+        }
+
+        /**
+         * Query if vertical scrolling is currently supported. The default implementation
+         * returns false.
+         *
+         * @return True if this LayoutManager can scroll the current contents vertically
+         */
+        public boolean canScrollVertically() {
+            return false;
+        }
+
+        /**
+         * Scroll to the specified adapter position.
+         *
+         * Actual position of the item on the screen depends on the LayoutManager implementation.
+         * @param position Scroll to this adapter position.
+         */
+        public void scrollToPosition(int position) {
+            if (DEBUG) {
+                Log.e(TAG, "You MUST implement scrollToPosition. It will soon become abstract");
+            }
+        }
+
+        /**
+         * <p>Smooth scroll to the specified adapter position.</p>
+         * <p>To support smooth scrolling, override this method, create your {@link SmoothScroller}
+         * instance and call {@link #startSmoothScroll(SmoothScroller)}.
+         * </p>
+         * @param recyclerView The RecyclerView to which this layout manager is attached
+         * @param state    Current State of RecyclerView
+         * @param position Scroll to this adapter position.
+         */
+        public void smoothScrollToPosition(RecyclerView recyclerView, State state,
+                int position) {
+            Log.e(TAG, "You must override smoothScrollToPosition to support smooth scrolling");
+        }
+
+        /**
+         * <p>Starts a smooth scroll using the provided SmoothScroller.</p>
+         * <p>Calling this method will cancel any previous smooth scroll request.</p>
+         * @param smoothScroller Unstance which defines how smooth scroll should be animated
+         */
+        public void startSmoothScroll(SmoothScroller smoothScroller) {
+            if (mSmoothScroller != null && smoothScroller != mSmoothScroller
+                    && mSmoothScroller.isRunning()) {
+                mSmoothScroller.stop();
+            }
+            mSmoothScroller = smoothScroller;
+            mSmoothScroller.start(mRecyclerView, this);
+        }
+
+        /**
+         * @return true if RecycylerView is currently in the state of smooth scrolling.
+         */
+        public boolean isSmoothScrolling() {
+            return mSmoothScroller != null && mSmoothScroller.isRunning();
+        }
+
+
+        /**
+         * Returns the resolved layout direction for this RecyclerView.
+         *
+         * @return {@link android.support.v4.view.ViewCompat#LAYOUT_DIRECTION_RTL} if the layout
+         * direction is RTL or returns
+         * {@link android.support.v4.view.ViewCompat#LAYOUT_DIRECTION_LTR} if the layout direction
+         * is not RTL.
+         */
+        public int getLayoutDirection() {
+            return ViewCompat.getLayoutDirection(mRecyclerView);
+        }
+
+        /**
+         * Ends all animations on the view created by the {@link ItemAnimator}.
+         *
+         * @param view The View for which the animations should be ended.
+         * @see RecyclerView.ItemAnimator#endAnimations()
+         */
+        public void endAnimation(View view) {
+            if (mRecyclerView.mItemAnimator != null) {
+                mRecyclerView.mItemAnimator.endAnimation(getChildViewHolderInt(view));
+            }
+        }
+
+        /**
+         * To be called only during {@link #onLayoutChildren(Recycler, State)} to add a view
+         * to the layout that is known to be going away, either because it has been
+         * {@link Adapter#notifyItemRemoved(int) removed} or because it is actually not in the
+         * visible portion of the container but is being laid out in order to inform RecyclerView
+         * in how to animate the item out of view.
+         * <p>
+         * Views added via this method are going to be invisible to LayoutManager after the
+         * dispatchLayout pass is complete. They cannot be retrieved via {@link #getChildAt(int)}
+         * or won't be included in {@link #getChildCount()} method.
+         *
+         * @param child View to add and then remove with animation.
+         */
+        public void addDisappearingView(View child) {
+            addDisappearingView(child, -1);
+        }
+
+        /**
+         * To be called only during {@link #onLayoutChildren(Recycler, State)} to add a view
+         * to the layout that is known to be going away, either because it has been
+         * {@link Adapter#notifyItemRemoved(int) removed} or because it is actually not in the
+         * visible portion of the container but is being laid out in order to inform RecyclerView
+         * in how to animate the item out of view.
+         * <p>
+         * Views added via this method are going to be invisible to LayoutManager after the
+         * dispatchLayout pass is complete. They cannot be retrieved via {@link #getChildAt(int)}
+         * or won't be included in {@link #getChildCount()} method.
+         *
+         * @param child View to add and then remove with animation.
+         * @param index Index of the view.
+         */
+        public void addDisappearingView(View child, int index) {
+            addViewInt(child, index, true);
+        }
+
+        /**
+         * Add a view to the currently attached RecyclerView if needed. LayoutManagers should
+         * use this method to add views obtained from a {@link Recycler} using
+         * {@link Recycler#getViewForPosition(int)}.
+         *
+         * @param child View to add
+         */
+        public void addView(View child) {
+            addView(child, -1);
+        }
+
+        /**
+         * Add a view to the currently attached RecyclerView if needed. LayoutManagers should
+         * use this method to add views obtained from a {@link Recycler} using
+         * {@link Recycler#getViewForPosition(int)}.
+         *
+         * @param child View to add
+         * @param index Index to add child at
+         */
+        public void addView(View child, int index) {
+            addViewInt(child, index, false);
+        }
+
+        private void addViewInt(View child, int index, boolean disappearing) {
+            final ViewHolder holder = getChildViewHolderInt(child);
+            if (disappearing || holder.isRemoved()) {
+                // these views will be hidden at the end of the layout pass.
+                mRecyclerView.mState.addToDisappearingList(child);
+            } else {
+                // This may look like unnecessary but may happen if layout manager supports
+                // predictive layouts and adapter removed then re-added the same item.
+                // In this case, added version will be visible in the post layout (because add is
+                // deferred) but RV will still bind it to the same View.
+                // So if a View re-appears in post layout pass, remove it from disappearing list.
+                mRecyclerView.mState.removeFromDisappearingList(child);
+            }
+            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+            if (holder.wasReturnedFromScrap() || holder.isScrap()) {
+                if (holder.isScrap()) {
+                    holder.unScrap();
+                } else {
+                    holder.clearReturnedFromScrapFlag();
+                }
+                mChildHelper.attachViewToParent(child, index, child.getLayoutParams(), false);
+                if (DISPATCH_TEMP_DETACH) {
+                    ViewCompat.dispatchFinishTemporaryDetach(child);
+                }
+            } else if (child.getParent() == mRecyclerView) { // it was not a scrap but a valid child
+                // ensure in correct position
+                int currentIndex = mChildHelper.indexOfChild(child);
+                if (index == -1) {
+                    index = mChildHelper.getChildCount();
+                }
+                if (currentIndex == -1) {
+                    throw new IllegalStateException("Added View has RecyclerView as parent but"
+                            + " view is not a real child. Unfiltered index:"
+                            + mRecyclerView.indexOfChild(child));
+                }
+                if (currentIndex != index) {
+                    mRecyclerView.mLayout.moveView(currentIndex, index);
+                }
+            } else {
+                mChildHelper.addView(child, index, false);
+                lp.mInsetsDirty = true;
+                if (mSmoothScroller != null && mSmoothScroller.isRunning()) {
+                    mSmoothScroller.onChildAttachedToWindow(child);
+                }
+            }
+            if (lp.mPendingInvalidate) {
+                if (DEBUG) {
+                    Log.d(TAG, "consuming pending invalidate on child " + lp.mViewHolder);
+                }
+                holder.itemView.invalidate();
+                lp.mPendingInvalidate = false;
+            }
+        }
+
+        /**
+         * Remove a view from the currently attached RecyclerView if needed. LayoutManagers should
+         * use this method to completely remove a child view that is no longer needed.
+         * LayoutManagers should strongly consider recycling removed views using
+         * {@link Recycler#recycleView(android.view.View)}.
+         *
+         * @param child View to remove
+         */
+        public void removeView(View child) {
+            mChildHelper.removeView(child);
+        }
+
+        /**
+         * Remove a view from the currently attached RecyclerView if needed. LayoutManagers should
+         * use this method to completely remove a child view that is no longer needed.
+         * LayoutManagers should strongly consider recycling removed views using
+         * {@link Recycler#recycleView(android.view.View)}.
+         *
+         * @param index Index of the child view to remove
+         */
+        public void removeViewAt(int index) {
+            final View child = getChildAt(index);
+            if (child != null) {
+                mChildHelper.removeViewAt(index);
+            }
+        }
+
+        /**
+         * Remove all views from the currently attached RecyclerView. This will not recycle
+         * any of the affected views; the LayoutManager is responsible for doing so if desired.
+         */
+        public void removeAllViews() {
+            // Only remove non-animating views
+            final int childCount = getChildCount();
+            for (int i = childCount - 1; i >= 0; i--) {
+                mChildHelper.removeViewAt(i);
+            }
+        }
+
+        /**
+         * Returns offset of the RecyclerView's text baseline from the its top boundary.
+         *
+         * @return The offset of the RecyclerView's text baseline from the its top boundary; -1 if
+         * there is no baseline.
+         */
+        public int getBaseline() {
+            return -1;
+        }
+
+        /**
+         * Returns the adapter position of the item represented by the given View. This does not
+         * contain any adapter changes that might have happened after the last layout.
+         *
+         * @param view The view to query
+         * @return The adapter position of the item which is rendered by this View.
+         */
+        public int getPosition(View view) {
+            return ((RecyclerView.LayoutParams) view.getLayoutParams()).getViewLayoutPosition();
+        }
+
+        /**
+         * Returns the View type defined by the adapter.
+         *
+         * @param view The view to query
+         * @return The type of the view assigned by the adapter.
+         */
+        public int getItemViewType(View view) {
+            return getChildViewHolderInt(view).getItemViewType();
+        }
+
+        /**
+         * Finds the view which represents the given adapter position.
+         * <p>
+         * This method traverses each child since it has no information about child order.
+         * Override this method to improve performance if your LayoutManager keeps data about
+         * child views.
+         * <p>
+         * If a view is ignored via {@link #ignoreView(View)}, it is also ignored by this method.
+         *
+         * @param position Position of the item in adapter
+         * @return The child view that represents the given position or null if the position is not
+         * laid out
+         */
+        public View findViewByPosition(int position) {
+            final int childCount = getChildCount();
+            for (int i = 0; i < childCount; i++) {
+                View child = getChildAt(i);
+                ViewHolder vh = getChildViewHolderInt(child);
+                if (vh == null) {
+                    continue;
+                }
+                if (vh.getLayoutPosition() == position && !vh.shouldIgnore() &&
+                        (mRecyclerView.mState.isPreLayout() || !vh.isRemoved())) {
+                    return child;
+                }
+            }
+            return null;
+        }
+
+        /**
+         * Temporarily detach a child view.
+         *
+         * <p>LayoutManagers may want to perform a lightweight detach operation to rearrange
+         * views currently attached to the RecyclerView. Generally LayoutManager implementations
+         * will want to use {@link #detachAndScrapView(android.view.View, RecyclerView.Recycler)}
+         * so that the detached view may be rebound and reused.</p>
+         *
+         * <p>If a LayoutManager uses this method to detach a view, it <em>must</em>
+         * {@link #attachView(android.view.View, int, RecyclerView.LayoutParams) reattach}
+         * or {@link #removeDetachedView(android.view.View) fully remove} the detached view
+         * before the LayoutManager entry point method called by RecyclerView returns.</p>
+         *
+         * @param child Child to detach
+         */
+        public void detachView(View child) {
+            final int ind = mChildHelper.indexOfChild(child);
+            if (ind >= 0) {
+                detachViewInternal(ind, child);
+            }
+        }
+
+        /**
+         * Temporarily detach a child view.
+         *
+         * <p>LayoutManagers may want to perform a lightweight detach operation to rearrange
+         * views currently attached to the RecyclerView. Generally LayoutManager implementations
+         * will want to use {@link #detachAndScrapView(android.view.View, RecyclerView.Recycler)}
+         * so that the detached view may be rebound and reused.</p>
+         *
+         * <p>If a LayoutManager uses this method to detach a view, it <em>must</em>
+         * {@link #attachView(android.view.View, int, RecyclerView.LayoutParams) reattach}
+         * or {@link #removeDetachedView(android.view.View) fully remove} the detached view
+         * before the LayoutManager entry point method called by RecyclerView returns.</p>
+         *
+         * @param index Index of the child to detach
+         */
+        public void detachViewAt(int index) {
+            detachViewInternal(index, getChildAt(index));
+        }
+
+        private void detachViewInternal(int index, View view) {
+            if (DISPATCH_TEMP_DETACH) {
+                ViewCompat.dispatchStartTemporaryDetach(view);
+            }
+            mChildHelper.detachViewFromParent(index);
+        }
+
+        /**
+         * Reattach a previously {@link #detachView(android.view.View) detached} view.
+         * This method should not be used to reattach views that were previously
+         * {@link #detachAndScrapView(android.view.View, RecyclerView.Recycler)}  scrapped}.
+         *
+         * @param child Child to reattach
+         * @param index Intended child index for child
+         * @param lp LayoutParams for child
+         */
+        public void attachView(View child, int index, LayoutParams lp) {
+            ViewHolder vh = getChildViewHolderInt(child);
+            if (vh.isRemoved()) {
+                mRecyclerView.mState.addToDisappearingList(child);
+            } else {
+                mRecyclerView.mState.removeFromDisappearingList(child);
+            }
+            mChildHelper.attachViewToParent(child, index, lp, vh.isRemoved());
+            if (DISPATCH_TEMP_DETACH)  {
+                ViewCompat.dispatchFinishTemporaryDetach(child);
+            }
+        }
+
+        /**
+         * Reattach a previously {@link #detachView(android.view.View) detached} view.
+         * This method should not be used to reattach views that were previously
+         * {@link #detachAndScrapView(android.view.View, RecyclerView.Recycler)}  scrapped}.
+         *
+         * @param child Child to reattach
+         * @param index Intended child index for child
+         */
+        public void attachView(View child, int index) {
+            attachView(child, index, (LayoutParams) child.getLayoutParams());
+        }
+
+        /**
+         * Reattach a previously {@link #detachView(android.view.View) detached} view.
+         * This method should not be used to reattach views that were previously
+         * {@link #detachAndScrapView(android.view.View, RecyclerView.Recycler)}  scrapped}.
+         *
+         * @param child Child to reattach
+         */
+        public void attachView(View child) {
+            attachView(child, -1);
+        }
+
+        /**
+         * Finish removing a view that was previously temporarily
+         * {@link #detachView(android.view.View) detached}.
+         *
+         * @param child Detached child to remove
+         */
+        public void removeDetachedView(View child) {
+            mRecyclerView.removeDetachedView(child, false);
+        }
+
+        /**
+         * Moves a View from one position to another.
+         *
+         * @param fromIndex The View's initial index
+         * @param toIndex The View's target index
+         */
+        public void moveView(int fromIndex, int toIndex) {
+            View view = getChildAt(fromIndex);
+            if (view == null) {
+                throw new IllegalArgumentException("Cannot move a child from non-existing index:"
+                        + fromIndex);
+            }
+            detachViewAt(fromIndex);
+            attachView(view, toIndex);
+        }
+
+        /**
+         * Detach a child view and add it to a {@link Recycler Recycler's} scrap heap.
+         *
+         * <p>Scrapping a view allows it to be rebound and reused to show updated or
+         * different data.</p>
+         *
+         * @param child Child to detach and scrap
+         * @param recycler Recycler to deposit the new scrap view into
+         */
+        public void detachAndScrapView(View child, Recycler recycler) {
+            int index = mChildHelper.indexOfChild(child);
+            scrapOrRecycleView(recycler, index, child);
+        }
+
+        /**
+         * Detach a child view and add it to a {@link Recycler Recycler's} scrap heap.
+         *
+         * <p>Scrapping a view allows it to be rebound and reused to show updated or
+         * different data.</p>
+         *
+         * @param index Index of child to detach and scrap
+         * @param recycler Recycler to deposit the new scrap view into
+         */
+        public void detachAndScrapViewAt(int index, Recycler recycler) {
+            final View child = getChildAt(index);
+            scrapOrRecycleView(recycler, index, child);
+        }
+
+        /**
+         * Remove a child view and recycle it using the given Recycler.
+         *
+         * @param child Child to remove and recycle
+         * @param recycler Recycler to use to recycle child
+         */
+        public void removeAndRecycleView(View child, Recycler recycler) {
+            removeView(child);
+            recycler.recycleView(child);
+        }
+
+        /**
+         * Remove a child view and recycle it using the given Recycler.
+         *
+         * @param index Index of child to remove and recycle
+         * @param recycler Recycler to use to recycle child
+         */
+        public void removeAndRecycleViewAt(int index, Recycler recycler) {
+            final View view = getChildAt(index);
+            removeViewAt(index);
+            recycler.recycleView(view);
+        }
+
+        /**
+         * Return the current number of child views attached to the parent RecyclerView.
+         * This does not include child views that were temporarily detached and/or scrapped.
+         *
+         * @return Number of attached children
+         */
+        public int getChildCount() {
+            return mChildHelper != null ? mChildHelper.getChildCount() : 0;
+        }
+
+        /**
+         * Return the child view at the given index
+         * @param index Index of child to return
+         * @return Child view at index
+         */
+        public View getChildAt(int index) {
+            return mChildHelper != null ? mChildHelper.getChildAt(index) : null;
+        }
+
+        /**
+         * Return the width of the parent RecyclerView
+         *
+         * @return Width in pixels
+         */
+        public int getWidth() {
+            return mRecyclerView != null ? mRecyclerView.getWidth() : 0;
+        }
+
+        /**
+         * Return the height of the parent RecyclerView
+         *
+         * @return Height in pixels
+         */
+        public int getHeight() {
+            return mRecyclerView != null ? mRecyclerView.getHeight() : 0;
+        }
+
+        /**
+         * Return the left padding of the parent RecyclerView
+         *
+         * @return Padding in pixels
+         */
+        public int getPaddingLeft() {
+            return mRecyclerView != null ? mRecyclerView.getPaddingLeft() : 0;
+        }
+
+        /**
+         * Return the top padding of the parent RecyclerView
+         *
+         * @return Padding in pixels
+         */
+        public int getPaddingTop() {
+            return mRecyclerView != null ? mRecyclerView.getPaddingTop() : 0;
+        }
+
+        /**
+         * Return the right padding of the parent RecyclerView
+         *
+         * @return Padding in pixels
+         */
+        public int getPaddingRight() {
+            return mRecyclerView != null ? mRecyclerView.getPaddingRight() : 0;
+        }
+
+        /**
+         * Return the bottom padding of the parent RecyclerView
+         *
+         * @return Padding in pixels
+         */
+        public int getPaddingBottom() {
+            return mRecyclerView != null ? mRecyclerView.getPaddingBottom() : 0;
+        }
+
+        /**
+         * Return the start padding of the parent RecyclerView
+         *
+         * @return Padding in pixels
+         */
+        public int getPaddingStart() {
+            return mRecyclerView != null ? ViewCompat.getPaddingStart(mRecyclerView) : 0;
+        }
+
+        /**
+         * Return the end padding of the parent RecyclerView
+         *
+         * @return Padding in pixels
+         */
+        public int getPaddingEnd() {
+            return mRecyclerView != null ? ViewCompat.getPaddingEnd(mRecyclerView) : 0;
+        }
+
+        /**
+         * Returns true if the RecyclerView this LayoutManager is bound to has focus.
+         *
+         * @return True if the RecyclerView has focus, false otherwise.
+         * @see View#isFocused()
+         */
+        public boolean isFocused() {
+            return mRecyclerView != null && mRecyclerView.isFocused();
+        }
+
+        /**
+         * Returns true if the RecyclerView this LayoutManager is bound to has or contains focus.
+         *
+         * @return true if the RecyclerView has or contains focus
+         * @see View#hasFocus()
+         */
+        public boolean hasFocus() {
+            return mRecyclerView != null && mRecyclerView.hasFocus();
+        }
+
+        /**
+         * Returns the item View which has or contains focus.
+         *
+         * @return A direct child of RecyclerView which has focus or contains the focused child.
+         */
+        public View getFocusedChild() {
+            if (mRecyclerView == null) {
+                return null;
+            }
+            final View focused = mRecyclerView.getFocusedChild();
+            if (focused == null || mChildHelper.isHidden(focused)) {
+                return null;
+            }
+            return focused;
+        }
+
+        /**
+         * Returns the number of items in the adapter bound to the parent RecyclerView.
+         * <p>
+         * Note that this number is not necessarily equal to {@link State#getItemCount()}. In
+         * methods where State is available, you should use {@link State#getItemCount()} instead.
+         * For more details, check the documentation for {@link State#getItemCount()}.
+         *
+         * @return The number of items in the bound adapter
+         * @see State#getItemCount()
+         */
+        public int getItemCount() {
+            final Adapter a = mRecyclerView != null ? mRecyclerView.getAdapter() : null;
+            return a != null ? a.getItemCount() : 0;
+        }
+
+        /**
+         * Offset all child views attached to the parent RecyclerView by dx pixels along
+         * the horizontal axis.
+         *
+         * @param dx Pixels to offset by
+         */
+        public void offsetChildrenHorizontal(int dx) {
+            if (mRecyclerView != null) {
+                mRecyclerView.offsetChildrenHorizontal(dx);
+            }
+        }
+
+        /**
+         * Offset all child views attached to the parent RecyclerView by dy pixels along
+         * the vertical axis.
+         *
+         * @param dy Pixels to offset by
+         */
+        public void offsetChildrenVertical(int dy) {
+            if (mRecyclerView != null) {
+                mRecyclerView.offsetChildrenVertical(dy);
+            }
+        }
+
+        /**
+         * Flags a view so that it will not be scrapped or recycled.
+         * <p>
+         * Scope of ignoring a child is strictly restricted to position tracking, scrapping and
+         * recyling. Methods like {@link #removeAndRecycleAllViews(Recycler)} will ignore the child
+         * whereas {@link #removeAllViews()} or {@link #offsetChildrenHorizontal(int)} will not
+         * ignore the child.
+         * <p>
+         * Before this child can be recycled again, you have to call
+         * {@link #stopIgnoringView(View)}.
+         * <p>
+         * You can call this method only if your LayoutManger is in onLayout or onScroll callback.
+         *
+         * @param view View to ignore.
+         * @see #stopIgnoringView(View)
+         */
+        public void ignoreView(View view) {
+            if (view.getParent() != mRecyclerView || mRecyclerView.indexOfChild(view) == -1) {
+                // checking this because calling this method on a recycled or detached view may
+                // cause loss of state.
+                throw new IllegalArgumentException("View should be fully attached to be ignored");
+            }
+            final ViewHolder vh = getChildViewHolderInt(view);
+            vh.addFlags(ViewHolder.FLAG_IGNORE);
+            mRecyclerView.mState.onViewIgnored(vh);
+        }
+
+        /**
+         * View can be scrapped and recycled again.
+         * <p>
+         * Note that calling this method removes all information in the view holder.
+         * <p>
+         * You can call this method only if your LayoutManger is in onLayout or onScroll callback.
+         *
+         * @param view View to ignore.
+         */
+        public void stopIgnoringView(View view) {
+            final ViewHolder vh = getChildViewHolderInt(view);
+            vh.stopIgnoring();
+            vh.resetInternal();
+            vh.addFlags(ViewHolder.FLAG_INVALID);
+        }
+
+        /**
+         * Temporarily detach and scrap all currently attached child views. Views will be scrapped
+         * into the given Recycler. The Recycler may prefer to reuse scrap views before
+         * other views that were previously recycled.
+         *
+         * @param recycler Recycler to scrap views into
+         */
+        public void detachAndScrapAttachedViews(Recycler recycler) {
+            final int childCount = getChildCount();
+            for (int i = childCount - 1; i >= 0; i--) {
+                final View v = getChildAt(i);
+                scrapOrRecycleView(recycler, i, v);
+            }
+        }
+
+        private void scrapOrRecycleView(Recycler recycler, int index, View view) {
+            final ViewHolder viewHolder = getChildViewHolderInt(view);
+            if (viewHolder.shouldIgnore()) {
+                if (DEBUG) {
+                    Log.d(TAG, "ignoring view " + viewHolder);
+                }
+                return;
+            }
+            if (viewHolder.isInvalid() && !viewHolder.isRemoved() && !viewHolder.isChanged() &&
+                    !mRecyclerView.mAdapter.hasStableIds()) {
+                removeViewAt(index);
+                recycler.recycleViewHolderInternal(viewHolder);
+            } else {
+                detachViewAt(index);
+                recycler.scrapView(view);
+            }
+        }
+
+        /**
+         * Recycles the scrapped views.
+         * <p>
+         * When a view is detached and removed, it does not trigger a ViewGroup invalidate. This is
+         * the expected behavior if scrapped views are used for animations. Otherwise, we need to
+         * call remove and invalidate RecyclerView to ensure UI update.
+         *
+         * @param recycler Recycler
+         */
+        void removeAndRecycleScrapInt(Recycler recycler) {
+            final int scrapCount = recycler.getScrapCount();
+            // Loop backward, recycler might be changed by removeDetachedView()
+            for (int i = scrapCount - 1; i >= 0; i--) {
+                final View scrap = recycler.getScrapViewAt(i);
+                final ViewHolder vh = getChildViewHolderInt(scrap);
+                if (vh.shouldIgnore()) {
+                    continue;
+                }
+                if (vh.isTmpDetached()) {
+                    mRecyclerView.removeDetachedView(scrap, false);
+                }
+                recycler.quickRecycleScrapView(scrap);
+            }
+            recycler.clearScrap();
+            if (scrapCount > 0) {
+                mRecyclerView.invalidate();
+            }
+        }
+
+
+        /**
+         * Measure a child view using standard measurement policy, taking the padding
+         * of the parent RecyclerView and any added item decorations into account.
+         *
+         * <p>If the RecyclerView can be scrolled in either dimension the caller may
+         * pass 0 as the widthUsed or heightUsed parameters as they will be irrelevant.</p>
+         *
+         * @param child Child view to measure
+         * @param widthUsed Width in pixels currently consumed by other views, if relevant
+         * @param heightUsed Height in pixels currently consumed by other views, if relevant
+         */
+        public void measureChild(View child, int widthUsed, int heightUsed) {
+            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+
+            final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
+            widthUsed += insets.left + insets.right;
+            heightUsed += insets.top + insets.bottom;
+
+            final int widthSpec = getChildMeasureSpec(getWidth(),
+                    getPaddingLeft() + getPaddingRight() + widthUsed, lp.width,
+                    canScrollHorizontally());
+            final int heightSpec = getChildMeasureSpec(getHeight(),
+                    getPaddingTop() + getPaddingBottom() + heightUsed, lp.height,
+                    canScrollVertically());
+            child.measure(widthSpec, heightSpec);
+        }
+
+        /**
+         * Measure a child view using standard measurement policy, taking the padding
+         * of the parent RecyclerView, any added item decorations and the child margins
+         * into account.
+         *
+         * <p>If the RecyclerView can be scrolled in either dimension the caller may
+         * pass 0 as the widthUsed or heightUsed parameters as they will be irrelevant.</p>
+         *
+         * @param child Child view to measure
+         * @param widthUsed Width in pixels currently consumed by other views, if relevant
+         * @param heightUsed Height in pixels currently consumed by other views, if relevant
+         */
+        public void measureChildWithMargins(View child, int widthUsed, int heightUsed) {
+            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+
+            final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
+            widthUsed += insets.left + insets.right;
+            heightUsed += insets.top + insets.bottom;
+
+            final int widthSpec = getChildMeasureSpec(getWidth(),
+                    getPaddingLeft() + getPaddingRight() +
+                            lp.leftMargin + lp.rightMargin + widthUsed, lp.width,
+                    canScrollHorizontally());
+            final int heightSpec = getChildMeasureSpec(getHeight(),
+                    getPaddingTop() + getPaddingBottom() +
+                            lp.topMargin + lp.bottomMargin + heightUsed, lp.height,
+                    canScrollVertically());
+            child.measure(widthSpec, heightSpec);
+        }
+
+        /**
+         * Calculate a MeasureSpec value for measuring a child view in one dimension.
+         *
+         * @param parentSize Size of the parent view where the child will be placed
+         * @param padding Total space currently consumed by other elements of parent
+         * @param childDimension Desired size of the child view, or MATCH_PARENT/WRAP_CONTENT.
+         *                       Generally obtained from the child view's LayoutParams
+         * @param canScroll true if the parent RecyclerView can scroll in this dimension
+         *
+         * @return a MeasureSpec value for the child view
+         */
+        public static int getChildMeasureSpec(int parentSize, int padding, int childDimension,
+                boolean canScroll) {
+            int size = Math.max(0, parentSize - padding);
+            int resultSize = 0;
+            int resultMode = 0;
+
+            if (canScroll) {
+                if (childDimension >= 0) {
+                    resultSize = childDimension;
+                    resultMode = MeasureSpec.EXACTLY;
+                } else {
+                    // MATCH_PARENT can't be applied since we can scroll in this dimension, wrap
+                    // instead using UNSPECIFIED.
+                    resultSize = 0;
+                    resultMode = MeasureSpec.UNSPECIFIED;
+                }
+            } else {
+                if (childDimension >= 0) {
+                    resultSize = childDimension;
+                    resultMode = MeasureSpec.EXACTLY;
+                } else if (childDimension == LayoutParams.FILL_PARENT) {
+                    resultSize = size;
+                    resultMode = MeasureSpec.EXACTLY;
+                } else if (childDimension == LayoutParams.WRAP_CONTENT) {
+                    resultSize = size;
+                    resultMode = MeasureSpec.AT_MOST;
+                }
+            }
+            return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
+        }
+
+        /**
+         * Returns the measured width of the given child, plus the additional size of
+         * any insets applied by {@link ItemDecoration ItemDecorations}.
+         *
+         * @param child Child view to query
+         * @return child's measured width plus <code>ItemDecoration</code> insets
+         *
+         * @see View#getMeasuredWidth()
+         */
+        public int getDecoratedMeasuredWidth(View child) {
+            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
+            return child.getMeasuredWidth() + insets.left + insets.right;
+        }
+
+        /**
+         * Returns the measured height of the given child, plus the additional size of
+         * any insets applied by {@link ItemDecoration ItemDecorations}.
+         *
+         * @param child Child view to query
+         * @return child's measured height plus <code>ItemDecoration</code> insets
+         *
+         * @see View#getMeasuredHeight()
+         */
+        public int getDecoratedMeasuredHeight(View child) {
+            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
+            return child.getMeasuredHeight() + insets.top + insets.bottom;
+        }
+
+        /**
+         * Lay out the given child view within the RecyclerView using coordinates that
+         * include any current {@link ItemDecoration ItemDecorations}.
+         *
+         * <p>LayoutManagers should prefer working in sizes and coordinates that include
+         * item decoration insets whenever possible. This allows the LayoutManager to effectively
+         * ignore decoration insets within measurement and layout code. See the following
+         * methods:</p>
+         * <ul>
+         *     <li>{@link #measureChild(View, int, int)}</li>
+         *     <li>{@link #measureChildWithMargins(View, int, int)}</li>
+         *     <li>{@link #getDecoratedLeft(View)}</li>
+         *     <li>{@link #getDecoratedTop(View)}</li>
+         *     <li>{@link #getDecoratedRight(View)}</li>
+         *     <li>{@link #getDecoratedBottom(View)}</li>
+         *     <li>{@link #getDecoratedMeasuredWidth(View)}</li>
+         *     <li>{@link #getDecoratedMeasuredHeight(View)}</li>
+         * </ul>
+         *
+         * @param child Child to lay out
+         * @param left Left edge, with item decoration insets included
+         * @param top Top edge, with item decoration insets included
+         * @param right Right edge, with item decoration insets included
+         * @param bottom Bottom edge, with item decoration insets included
+         *
+         * @see View#layout(int, int, int, int)
+         */
+        public void layoutDecorated(View child, int left, int top, int right, int bottom) {
+            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
+            child.layout(left + insets.left, top + insets.top, right - insets.right,
+                    bottom - insets.bottom);
+        }
+
+        /**
+         * Returns the left edge of the given child view within its parent, offset by any applied
+         * {@link ItemDecoration ItemDecorations}.
+         *
+         * @param child Child to query
+         * @return Child left edge with offsets applied
+         * @see #getLeftDecorationWidth(View)
+         */
+        public int getDecoratedLeft(View child) {
+            return child.getLeft() - getLeftDecorationWidth(child);
+        }
+
+        /**
+         * Returns the top edge of the given child view within its parent, offset by any applied
+         * {@link ItemDecoration ItemDecorations}.
+         *
+         * @param child Child to query
+         * @return Child top edge with offsets applied
+         * @see #getTopDecorationHeight(View)
+         */
+        public int getDecoratedTop(View child) {
+            return child.getTop() - getTopDecorationHeight(child);
+        }
+
+        /**
+         * Returns the right edge of the given child view within its parent, offset by any applied
+         * {@link ItemDecoration ItemDecorations}.
+         *
+         * @param child Child to query
+         * @return Child right edge with offsets applied
+         * @see #getRightDecorationWidth(View)
+         */
+        public int getDecoratedRight(View child) {
+            return child.getRight() + getRightDecorationWidth(child);
+        }
+
+        /**
+         * Returns the bottom edge of the given child view within its parent, offset by any applied
+         * {@link ItemDecoration ItemDecorations}.
+         *
+         * @param child Child to query
+         * @return Child bottom edge with offsets applied
+         * @see #getBottomDecorationHeight(View)
+         */
+        public int getDecoratedBottom(View child) {
+            return child.getBottom() + getBottomDecorationHeight(child);
+        }
+
+        /**
+         * Calculates the item decor insets applied to the given child and updates the provided
+         * Rect instance with the inset values.
+         * <ul>
+         *     <li>The Rect's left is set to the total width of left decorations.</li>
+         *     <li>The Rect's top is set to the total height of top decorations.</li>
+         *     <li>The Rect's right is set to the total width of right decorations.</li>
+         *     <li>The Rect's bottom is set to total height of bottom decorations.</li>
+         * </ul>
+         * <p>
+         * Note that item decorations are automatically calculated when one of the LayoutManager's
+         * measure child methods is called. If you need to measure the child with custom specs via
+         * {@link View#measure(int, int)}, you can use this method to get decorations.
+         *
+         * @param child The child view whose decorations should be calculated
+         * @param outRect The Rect to hold result values
+         */
+        public void calculateItemDecorationsForChild(View child, Rect outRect) {
+            if (mRecyclerView == null) {
+                outRect.set(0, 0, 0, 0);
+                return;
+            }
+            Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
+            outRect.set(insets);
+        }
+
+        /**
+         * Returns the total height of item decorations applied to child's top.
+         * <p>
+         * Note that this value is not updated until the View is measured or
+         * {@link #calculateItemDecorationsForChild(View, Rect)} is called.
+         *
+         * @param child Child to query
+         * @return The total height of item decorations applied to the child's top.
+         * @see #getDecoratedTop(View)
+         * @see #calculateItemDecorationsForChild(View, Rect)
+         */
+        public int getTopDecorationHeight(View child) {
+            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.top;
+        }
+
+        /**
+         * Returns the total height of item decorations applied to child's bottom.
+         * <p>
+         * Note that this value is not updated until the View is measured or
+         * {@link #calculateItemDecorationsForChild(View, Rect)} is called.
+         *
+         * @param child Child to query
+         * @return The total height of item decorations applied to the child's bottom.
+         * @see #getDecoratedBottom(View)
+         * @see #calculateItemDecorationsForChild(View, Rect)
+         */
+        public int getBottomDecorationHeight(View child) {
+            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.bottom;
+        }
+
+        /**
+         * Returns the total width of item decorations applied to child's left.
+         * <p>
+         * Note that this value is not updated until the View is measured or
+         * {@link #calculateItemDecorationsForChild(View, Rect)} is called.
+         *
+         * @param child Child to query
+         * @return The total width of item decorations applied to the child's left.
+         * @see #getDecoratedLeft(View)
+         * @see #calculateItemDecorationsForChild(View, Rect)
+         */
+        public int getLeftDecorationWidth(View child) {
+            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.left;
+        }
+
+        /**
+         * Returns the total width of item decorations applied to child's right.
+         * <p>
+         * Note that this value is not updated until the View is measured or
+         * {@link #calculateItemDecorationsForChild(View, Rect)} is called.
+         *
+         * @param child Child to query
+         * @return The total width of item decorations applied to the child's right.
+         * @see #getDecoratedRight(View)
+         * @see #calculateItemDecorationsForChild(View, Rect)
+         */
+        public int getRightDecorationWidth(View child) {
+            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.right;
+        }
+
+        /**
+         * Called when searching for a focusable view in the given direction has failed
+         * for the current content of the RecyclerView.
+         *
+         * <p>This is the LayoutManager's opportunity to populate views in the given direction
+         * to fulfill the request if it can. The LayoutManager should attach and return
+         * the view to be focused. The default implementation returns null.</p>
+         *
+         * @param focused   The currently focused view
+         * @param direction One of {@link View#FOCUS_UP}, {@link View#FOCUS_DOWN},
+         *                  {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
+         *                  {@link View#FOCUS_BACKWARD}, {@link View#FOCUS_FORWARD}
+         *                  or 0 for not applicable
+         * @param recycler  The recycler to use for obtaining views for currently offscreen items
+         * @param state     Transient state of RecyclerView
+         * @return The chosen view to be focused
+         */
+        @Nullable
+        public View onFocusSearchFailed(View focused, int direction, Recycler recycler,
+                State state) {
+            return null;
+        }
+
+        /**
+         * This method gives a LayoutManager an opportunity to intercept the initial focus search
+         * before the default behavior of {@link FocusFinder} is used. If this method returns
+         * null FocusFinder will attempt to find a focusable child view. If it fails
+         * then {@link #onFocusSearchFailed(View, int, RecyclerView.Recycler, RecyclerView.State)}
+         * will be called to give the LayoutManager an opportunity to add new views for items
+         * that did not have attached views representing them. The LayoutManager should not add
+         * or remove views from this method.
+         *
+         * @param focused The currently focused view
+         * @param direction One of {@link View#FOCUS_UP}, {@link View#FOCUS_DOWN},
+         *                  {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
+         *                  {@link View#FOCUS_BACKWARD}, {@link View#FOCUS_FORWARD}
+         * @return A descendant view to focus or null to fall back to default behavior.
+         *         The default implementation returns null.
+         */
+        public View onInterceptFocusSearch(View focused, int direction) {
+            return null;
+        }
+
+        /**
+         * Called when a child of the RecyclerView wants a particular rectangle to be positioned
+         * onto the screen. See {@link ViewParent#requestChildRectangleOnScreen(android.view.View,
+         * android.graphics.Rect, boolean)} for more details.
+         *
+         * <p>The base implementation will attempt to perform a standard programmatic scroll
+         * to bring the given rect into view, within the padded area of the RecyclerView.</p>
+         *
+         * @param child The direct child making the request.
+         * @param rect  The rectangle in the child's coordinates the child
+         *              wishes to be on the screen.
+         * @param immediate True to forbid animated or delayed scrolling,
+         *                  false otherwise
+         * @return Whether the group scrolled to handle the operation
+         */
+        public boolean requestChildRectangleOnScreen(RecyclerView parent, View child, Rect rect,
+                boolean immediate) {
+            final int parentLeft = getPaddingLeft();
+            final int parentTop = getPaddingTop();
+            final int parentRight = getWidth() - getPaddingRight();
+            final int parentBottom = getHeight() - getPaddingBottom();
+            final int childLeft = child.getLeft() + rect.left;
+            final int childTop = child.getTop() + rect.top;
+            final int childRight = childLeft + rect.width();
+            final int childBottom = childTop + rect.height();
+
+            final int offScreenLeft = Math.min(0, childLeft - parentLeft);
+            final int offScreenTop = Math.min(0, childTop - parentTop);
+            final int offScreenRight = Math.max(0, childRight - parentRight);
+            final int offScreenBottom = Math.max(0, childBottom - parentBottom);
+
+            // Favor the "start" layout direction over the end when bringing one side or the other
+            // of a large rect into view. If we decide to bring in end because start is already
+            // visible, limit the scroll such that start won't go out of bounds.
+            final int dx;
+            if (getLayoutDirection() == ViewCompat.LAYOUT_DIRECTION_RTL) {
+                dx = offScreenRight != 0 ? offScreenRight
+                        : Math.max(offScreenLeft, childRight - parentRight);
+            } else {
+                dx = offScreenLeft != 0 ? offScreenLeft
+                        : Math.min(childLeft - parentLeft, offScreenRight);
+            }
+
+            // Favor bringing the top into view over the bottom. If top is already visible and
+            // we should scroll to make bottom visible, make sure top does not go out of bounds.
+            final int dy = offScreenTop != 0 ? offScreenTop
+                    : Math.min(childTop - parentTop, offScreenBottom);
+
+            if (dx != 0 || dy != 0) {
+                if (immediate) {
+                    parent.scrollBy(dx, dy);
+                } else {
+                    parent.smoothScrollBy(dx, dy);
+                }
+                return true;
+            }
+            return false;
+        }
+
+        /**
+         * @deprecated Use {@link #onRequestChildFocus(RecyclerView, State, View, View)}
+         */
+        @Deprecated
+        public boolean onRequestChildFocus(RecyclerView parent, View child, View focused) {
+            // eat the request if we are in the middle of a scroll or layout
+            return isSmoothScrolling() || parent.isRunningLayoutOrScroll();
+        }
+
+        /**
+         * Called when a descendant view of the RecyclerView requests focus.
+         *
+         * <p>A LayoutManager wishing to keep focused views aligned in a specific
+         * portion of the view may implement that behavior in an override of this method.</p>
+         *
+         * <p>If the LayoutManager executes different behavior that should override the default
+         * behavior of scrolling the focused child on screen instead of running alongside it,
+         * this method should return true.</p>
+         *
+         * @param parent  The RecyclerView hosting this LayoutManager
+         * @param state   Current state of RecyclerView
+         * @param child   Direct child of the RecyclerView containing the newly focused view
+         * @param focused The newly focused view. This may be the same view as child or it may be
+         *                null
+         * @return true if the default scroll behavior should be suppressed
+         */
+        public boolean onRequestChildFocus(RecyclerView parent, State state, View child,
+                View focused) {
+            return onRequestChildFocus(parent, child, focused);
+        }
+
+        /**
+         * Called if the RecyclerView this LayoutManager is bound to has a different adapter set.
+         * The LayoutManager may use this opportunity to clear caches and configure state such
+         * that it can relayout appropriately with the new data and potentially new view types.
+         *
+         * <p>The default implementation removes all currently attached views.</p>
+         *
+         * @param oldAdapter The previous adapter instance. Will be null if there was previously no
+         *                   adapter.
+         * @param newAdapter The new adapter instance. Might be null if
+         *                   {@link #setAdapter(RecyclerView.Adapter)} is called with {@code null}.
+         */
+        public void onAdapterChanged(Adapter oldAdapter, Adapter newAdapter) {
+        }
+
+        /**
+         * Called to populate focusable views within the RecyclerView.
+         *
+         * <p>The LayoutManager implementation should return <code>true</code> if the default
+         * behavior of {@link ViewGroup#addFocusables(java.util.ArrayList, int)} should be
+         * suppressed.</p>
+         *
+         * <p>The default implementation returns <code>false</code> to trigger RecyclerView
+         * to fall back to the default ViewGroup behavior.</p>
+         *
+         * @param recyclerView The RecyclerView hosting this LayoutManager
+         * @param views List of output views. This method should add valid focusable views
+         *              to this list.
+         * @param direction One of {@link View#FOCUS_UP}, {@link View#FOCUS_DOWN},
+         *                  {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
+         *                  {@link View#FOCUS_BACKWARD}, {@link View#FOCUS_FORWARD}
+         * @param focusableMode The type of focusables to be added.
+         *
+         * @return true to suppress the default behavior, false to add default focusables after
+         *         this method returns.
+         *
+         * @see #FOCUSABLES_ALL
+         * @see #FOCUSABLES_TOUCH_MODE
+         */
+        public boolean onAddFocusables(RecyclerView recyclerView, ArrayList<View> views,
+                int direction, int focusableMode) {
+            return false;
+        }
+
+        /**
+         * Called when {@link Adapter#notifyDataSetChanged()} is triggered instead of giving
+         * detailed information on what has actually changed.
+         *
+         * @param recyclerView
+         */
+        public void onItemsChanged(RecyclerView recyclerView) {
+        }
+
+        /**
+         * Called when items have been added to the adapter. The LayoutManager may choose to
+         * requestLayout if the inserted items would require refreshing the currently visible set
+         * of child views. (e.g. currently empty space would be filled by appended items, etc.)
+         *
+         * @param recyclerView
+         * @param positionStart
+         * @param itemCount
+         */
+        public void onItemsAdded(RecyclerView recyclerView, int positionStart, int itemCount) {
+        }
+
+        /**
+         * Called when items have been removed from the adapter.
+         *
+         * @param recyclerView
+         * @param positionStart
+         * @param itemCount
+         */
+        public void onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount) {
+        }
+
+        /**
+         * Called when items have been changed in the adapter.
+         *
+         * @param recyclerView
+         * @param positionStart
+         * @param itemCount
+         */
+        public void onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount) {
+        }
+
+        /**
+         * Called when an item is moved withing the adapter.
+         * <p>
+         * Note that, an item may also change position in response to another ADD/REMOVE/MOVE
+         * operation. This callback is only called if and only if {@link Adapter#notifyItemMoved}
+         * is called.
+         *
+         * @param recyclerView
+         * @param from
+         * @param to
+         * @param itemCount
+         */
+        public void onItemsMoved(RecyclerView recyclerView, int from, int to, int itemCount) {
+
+        }
+
+
+        /**
+         * <p>Override this method if you want to support scroll bars.</p>
+         *
+         * <p>Read {@link RecyclerView#computeHorizontalScrollExtent()} for details.</p>
+         *
+         * <p>Default implementation returns 0.</p>
+         *
+         * @param state Current state of RecyclerView
+         * @return The horizontal extent of the scrollbar's thumb
+         * @see RecyclerView#computeHorizontalScrollExtent()
+         */
+        public int computeHorizontalScrollExtent(State state) {
+            return 0;
+        }
+
+        /**
+         * <p>Override this method if you want to support scroll bars.</p>
+         *
+         * <p>Read {@link RecyclerView#computeHorizontalScrollOffset()} for details.</p>
+         *
+         * <p>Default implementation returns 0.</p>
+         *
+         * @param state Current State of RecyclerView where you can find total item count
+         * @return The horizontal offset of the scrollbar's thumb
+         * @see RecyclerView#computeHorizontalScrollOffset()
+         */
+        public int computeHorizontalScrollOffset(State state) {
+            return 0;
+        }
+
+        /**
+         * <p>Override this method if you want to support scroll bars.</p>
+         *
+         * <p>Read {@link RecyclerView#computeHorizontalScrollRange()} for details.</p>
+         *
+         * <p>Default implementation returns 0.</p>
+         *
+         * @param state Current State of RecyclerView where you can find total item count
+         * @return The total horizontal range represented by the vertical scrollbar
+         * @see RecyclerView#computeHorizontalScrollRange()
+         */
+        public int computeHorizontalScrollRange(State state) {
+            return 0;
+        }
+
+        /**
+         * <p>Override this method if you want to support scroll bars.</p>
+         *
+         * <p>Read {@link RecyclerView#computeVerticalScrollExtent()} for details.</p>
+         *
+         * <p>Default implementation returns 0.</p>
+         *
+         * @param state Current state of RecyclerView
+         * @return The vertical extent of the scrollbar's thumb
+         * @see RecyclerView#computeVerticalScrollExtent()
+         */
+        public int computeVerticalScrollExtent(State state) {
+            return 0;
+        }
+
+        /**
+         * <p>Override this method if you want to support scroll bars.</p>
+         *
+         * <p>Read {@link RecyclerView#computeVerticalScrollOffset()} for details.</p>
+         *
+         * <p>Default implementation returns 0.</p>
+         *
+         * @param state Current State of RecyclerView where you can find total item count
+         * @return The vertical offset of the scrollbar's thumb
+         * @see RecyclerView#computeVerticalScrollOffset()
+         */
+        public int computeVerticalScrollOffset(State state) {
+            return 0;
+        }
+
+        /**
+         * <p>Override this method if you want to support scroll bars.</p>
+         *
+         * <p>Read {@link RecyclerView#computeVerticalScrollRange()} for details.</p>
+         *
+         * <p>Default implementation returns 0.</p>
+         *
+         * @param state Current State of RecyclerView where you can find total item count
+         * @return The total vertical range represented by the vertical scrollbar
+         * @see RecyclerView#computeVerticalScrollRange()
+         */
+        public int computeVerticalScrollRange(State state) {
+            return 0;
+        }
+
+        /**
+         * Measure the attached RecyclerView. Implementations must call
+         * {@link #setMeasuredDimension(int, int)} before returning.
+         *
+         * <p>The default implementation will handle EXACTLY measurements and respect
+         * the minimum width and height properties of the host RecyclerView if measured
+         * as UNSPECIFIED. AT_MOST measurements will be treated as EXACTLY and the RecyclerView
+         * will consume all available space.</p>
+         *
+         * @param recycler Recycler
+         * @param state Transient state of RecyclerView
+         * @param widthSpec Width {@link android.view.View.MeasureSpec}
+         * @param heightSpec Height {@link android.view.View.MeasureSpec}
+         */
+        public void onMeasure(Recycler recycler, State state, int widthSpec, int heightSpec) {
+            mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);
+        }
+
+        /**
+         * {@link View#setMeasuredDimension(int, int) Set the measured dimensions} of the
+         * host RecyclerView.
+         *
+         * @param widthSize Measured width
+         * @param heightSize Measured height
+         */
+        public void setMeasuredDimension(int widthSize, int heightSize) {
+            mRecyclerView.setMeasuredDimension(widthSize, heightSize);
+        }
+
+        /**
+         * @return The host RecyclerView's {@link View#getMinimumWidth()}
+         */
+        public int getMinimumWidth() {
+            return ViewCompat.getMinimumWidth(mRecyclerView);
+        }
+
+        /**
+         * @return The host RecyclerView's {@link View#getMinimumHeight()}
+         */
+        public int getMinimumHeight() {
+            return ViewCompat.getMinimumHeight(mRecyclerView);
+        }
+        /**
+         * <p>Called when the LayoutManager should save its state. This is a good time to save your
+         * scroll position, configuration and anything else that may be required to restore the same
+         * layout state if the LayoutManager is recreated.</p>
+         * <p>RecyclerView does NOT verify if the LayoutManager has changed between state save and
+         * restore. This will let you share information between your LayoutManagers but it is also
+         * your responsibility to make sure they use the same parcelable class.</p>
+         *
+         * @return Necessary information for LayoutManager to be able to restore its state
+         */
+        public Parcelable onSaveInstanceState() {
+            return null;
+        }
+
+
+        public void onRestoreInstanceState(Parcelable state) {
+
+        }
+
+        void stopSmoothScroller() {
+            if (mSmoothScroller != null) {
+                mSmoothScroller.stop();
+            }
+        }
+
+        private void onSmoothScrollerStopped(SmoothScroller smoothScroller) {
+            if (mSmoothScroller == smoothScroller) {
+                mSmoothScroller = null;
+            }
+        }
+
+        /**
+         * RecyclerView calls this method to notify LayoutManager that scroll state has changed.
+         *
+         * @param state The new scroll state for RecyclerView
+         */
+        public void onScrollStateChanged(int state) {
+        }
+
+        /**
+         * Removes all views and recycles them using the given recycler.
+         * <p>
+         * If you want to clean cached views as well, you should call {@link Recycler#clear()} too.
+         * <p>
+         * If a View is marked as "ignored", it is not removed nor recycled.
+         *
+         * @param recycler Recycler to use to recycle children
+         * @see #removeAndRecycleView(View, Recycler)
+         * @see #removeAndRecycleViewAt(int, Recycler)
+         * @see #ignoreView(View)
+         */
+        public void removeAndRecycleAllViews(Recycler recycler) {
+            for (int i = getChildCount() - 1; i >= 0; i--) {
+                final View view = getChildAt(i);
+                if (!getChildViewHolderInt(view).shouldIgnore()) {
+                    removeAndRecycleViewAt(i, recycler);
+                }
+            }
+        }
+
+        // called by accessibility delegate
+        void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfoCompat info) {
+            onInitializeAccessibilityNodeInfo(mRecyclerView.mRecycler, mRecyclerView.mState, info);
+        }
+
+        /**
+         * Called by the AccessibilityDelegate when the information about the current layout should
+         * be populated.
+         * <p>
+         * Default implementation adds a {@link
+         * android.support.v4.view.accessibility.AccessibilityNodeInfoCompat.CollectionInfoCompat}.
+         * <p>
+         * You should override
+         * {@link #getRowCountForAccessibility(RecyclerView.Recycler, RecyclerView.State)},
+         * {@link #getColumnCountForAccessibility(RecyclerView.Recycler, RecyclerView.State)},
+         * {@link #isLayoutHierarchical(RecyclerView.Recycler, RecyclerView.State)} and
+         * {@link #getSelectionModeForAccessibility(RecyclerView.Recycler, RecyclerView.State)} for
+         * more accurate accessibility information.
+         *
+         * @param recycler The Recycler that can be used to convert view positions into adapter
+         *                 positions
+         * @param state    The current state of RecyclerView
+         * @param info     The info that should be filled by the LayoutManager
+         * @see View#onInitializeAccessibilityNodeInfo(
+         *android.view.accessibility.AccessibilityNodeInfo)
+         * @see #getRowCountForAccessibility(RecyclerView.Recycler, RecyclerView.State)
+         * @see #getColumnCountForAccessibility(RecyclerView.Recycler, RecyclerView.State)
+         * @see #isLayoutHierarchical(RecyclerView.Recycler, RecyclerView.State)
+         * @see #getSelectionModeForAccessibility(RecyclerView.Recycler, RecyclerView.State)
+         */
+        public void onInitializeAccessibilityNodeInfo(Recycler recycler, State state,
+                AccessibilityNodeInfoCompat info) {
+            if (ViewCompat.canScrollVertically(mRecyclerView, -1) ||
+                    ViewCompat.canScrollHorizontally(mRecyclerView, -1)) {
+                info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD);
+                info.setScrollable(true);
+            }
+            if (ViewCompat.canScrollVertically(mRecyclerView, 1) ||
+                    ViewCompat.canScrollHorizontally(mRecyclerView, 1)) {
+                info.addAction(AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD);
+                info.setScrollable(true);
+            }
+            final AccessibilityNodeInfoCompat.CollectionInfoCompat collectionInfo
+                    = AccessibilityNodeInfoCompat.CollectionInfoCompat
+                    .obtain(getRowCountForAccessibility(recycler, state),
+                            getColumnCountForAccessibility(recycler, state),
+                            isLayoutHierarchical(recycler, state),
+                            getSelectionModeForAccessibility(recycler, state));
+            info.setCollectionInfo(collectionInfo);
+        }
+
+        // called by accessibility delegate
+        public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+            onInitializeAccessibilityEvent(mRecyclerView.mRecycler, mRecyclerView.mState, event);
+        }
+
+        /**
+         * Called by the accessibility delegate to initialize an accessibility event.
+         * <p>
+         * Default implementation adds item count and scroll information to the event.
+         *
+         * @param recycler The Recycler that can be used to convert view positions into adapter
+         *                 positions
+         * @param state    The current state of RecyclerView
+         * @param event    The event instance to initialize
+         * @see View#onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent)
+         */
+        public void onInitializeAccessibilityEvent(Recycler recycler, State state,
+                AccessibilityEvent event) {
+            final AccessibilityRecordCompat record = AccessibilityEventCompat
+                    .asRecord(event);
+            if (mRecyclerView == null || record == null) {
+                return;
+            }
+            record.setScrollable(ViewCompat.canScrollVertically(mRecyclerView, 1)
+                    || ViewCompat.canScrollVertically(mRecyclerView, -1)
+                    || ViewCompat.canScrollHorizontally(mRecyclerView, -1)
+                    || ViewCompat.canScrollHorizontally(mRecyclerView, 1));
+
+            if (mRecyclerView.mAdapter != null) {
+                record.setItemCount(mRecyclerView.mAdapter.getItemCount());
+            }
+        }
+
+        // called by accessibility delegate
+        void onInitializeAccessibilityNodeInfoForItem(View host, AccessibilityNodeInfoCompat info) {
+            final ViewHolder vh = getChildViewHolderInt(host);
+            // avoid trying to create accessibility node info for removed children
+            if (vh != null && !vh.isRemoved()) {
+                onInitializeAccessibilityNodeInfoForItem(mRecyclerView.mRecycler,
+                        mRecyclerView.mState, host, info);
+            }
+        }
+
+        /**
+         * Called by the AccessibilityDelegate when the accessibility information for a specific
+         * item should be populated.
+         * <p>
+         * Default implementation adds basic positioning information about the item.
+         *
+         * @param recycler The Recycler that can be used to convert view positions into adapter
+         *                 positions
+         * @param state    The current state of RecyclerView
+         * @param host     The child for which accessibility node info should be populated
+         * @param info     The info to fill out about the item
+         * @see android.widget.AbsListView#onInitializeAccessibilityNodeInfoForItem(View, int,
+         * android.view.accessibility.AccessibilityNodeInfo)
+         */
+        public void onInitializeAccessibilityNodeInfoForItem(Recycler recycler, State state,
+                View host, AccessibilityNodeInfoCompat info) {
+            int rowIndexGuess = canScrollVertically() ? getPosition(host) : 0;
+            int columnIndexGuess = canScrollHorizontally() ? getPosition(host) : 0;
+            final AccessibilityNodeInfoCompat.CollectionItemInfoCompat itemInfo
+                    = AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(rowIndexGuess, 1,
+                    columnIndexGuess, 1, false, false);
+            info.setCollectionItemInfo(itemInfo);
+        }
+
+        /**
+         * A LayoutManager can call this method to force RecyclerView to run simple animations in
+         * the next layout pass, even if there is not any trigger to do so. (e.g. adapter data
+         * change).
+         * <p>
+         * Note that, calling this method will not guarantee that RecyclerView will run animations
+         * at all. For example, if there is not any {@link ItemAnimator} set, RecyclerView will
+         * not run any animations but will still clear this flag after the layout is complete.
+         *
+         */
+        public void requestSimpleAnimationsInNextLayout() {
+            mRequestedSimpleAnimations = true;
+        }
+
+        /**
+         * Returns the selection mode for accessibility. Should be
+         * {@link AccessibilityNodeInfoCompat.CollectionInfoCompat#SELECTION_MODE_NONE},
+         * {@link AccessibilityNodeInfoCompat.CollectionInfoCompat#SELECTION_MODE_SINGLE} or
+         * {@link AccessibilityNodeInfoCompat.CollectionInfoCompat#SELECTION_MODE_MULTIPLE}.
+         * <p>
+         * Default implementation returns
+         * {@link AccessibilityNodeInfoCompat.CollectionInfoCompat#SELECTION_MODE_NONE}.
+         *
+         * @param recycler The Recycler that can be used to convert view positions into adapter
+         *                 positions
+         * @param state    The current state of RecyclerView
+         * @return Selection mode for accessibility. Default implementation returns
+         * {@link AccessibilityNodeInfoCompat.CollectionInfoCompat#SELECTION_MODE_NONE}.
+         */
+        public int getSelectionModeForAccessibility(Recycler recycler, State state) {
+            return AccessibilityNodeInfoCompat.CollectionInfoCompat.SELECTION_MODE_NONE;
+        }
+
+        /**
+         * Returns the number of rows for accessibility.
+         * <p>
+         * Default implementation returns the number of items in the adapter if LayoutManager
+         * supports vertical scrolling or 1 if LayoutManager does not support vertical
+         * scrolling.
+         *
+         * @param recycler The Recycler that can be used to convert view positions into adapter
+         *                 positions
+         * @param state    The current state of RecyclerView
+         * @return The number of rows in LayoutManager for accessibility.
+         */
+        public int getRowCountForAccessibility(Recycler recycler, State state) {
+            if (mRecyclerView == null || mRecyclerView.mAdapter == null) {
+                return 1;
+            }
+            return canScrollVertically() ? mRecyclerView.mAdapter.getItemCount() : 1;
+        }
+
+        /**
+         * Returns the number of columns for accessibility.
+         * <p>
+         * Default implementation returns the number of items in the adapter if LayoutManager
+         * supports horizontal scrolling or 1 if LayoutManager does not support horizontal
+         * scrolling.
+         *
+         * @param recycler The Recycler that can be used to convert view positions into adapter
+         *                 positions
+         * @param state    The current state of RecyclerView
+         * @return The number of rows in LayoutManager for accessibility.
+         */
+        public int getColumnCountForAccessibility(Recycler recycler, State state) {
+            if (mRecyclerView == null || mRecyclerView.mAdapter == null) {
+                return 1;
+            }
+            return canScrollHorizontally() ? mRecyclerView.mAdapter.getItemCount() : 1;
+        }
+
+        /**
+         * Returns whether layout is hierarchical or not to be used for accessibility.
+         * <p>
+         * Default implementation returns false.
+         *
+         * @param recycler The Recycler that can be used to convert view positions into adapter
+         *                 positions
+         * @param state    The current state of RecyclerView
+         * @return True if layout is hierarchical.
+         */
+        public boolean isLayoutHierarchical(Recycler recycler, State state) {
+            return false;
+        }
+
+        // called by accessibility delegate
+        boolean performAccessibilityAction(int action, Bundle args) {
+            return performAccessibilityAction(mRecyclerView.mRecycler, mRecyclerView.mState,
+                    action, args);
+        }
+
+        /**
+         * Called by AccessibilityDelegate when an action is requested from the RecyclerView.
+         *
+         * @param recycler  The Recycler that can be used to convert view positions into adapter
+         *                  positions
+         * @param state     The current state of RecyclerView
+         * @param action    The action to perform
+         * @param args      Optional action arguments
+         * @see View#performAccessibilityAction(int, android.os.Bundle)
+         */
+        public boolean performAccessibilityAction(Recycler recycler, State state, int action,
+                Bundle args) {
+            if (mRecyclerView == null) {
+                return false;
+            }
+            int vScroll = 0, hScroll = 0;
+            switch (action) {
+                case AccessibilityNodeInfoCompat.ACTION_SCROLL_BACKWARD:
+                    if (ViewCompat.canScrollVertically(mRecyclerView, -1)) {
+                        vScroll = -(getHeight() - getPaddingTop() - getPaddingBottom());
+                    }
+                    if (ViewCompat.canScrollHorizontally(mRecyclerView, -1)) {
+                        hScroll = -(getWidth() - getPaddingLeft() - getPaddingRight());
+                    }
+                    break;
+                case AccessibilityNodeInfoCompat.ACTION_SCROLL_FORWARD:
+                    if (ViewCompat.canScrollVertically(mRecyclerView, 1)) {
+                        vScroll = getHeight() - getPaddingTop() - getPaddingBottom();
+                    }
+                    if (ViewCompat.canScrollHorizontally(mRecyclerView, 1)) {
+                        hScroll = getWidth() - getPaddingLeft() - getPaddingRight();
+                    }
+                    break;
+            }
+            if (vScroll == 0 && hScroll == 0) {
+                return false;
+            }
+            mRecyclerView.scrollBy(hScroll, vScroll);
+            return true;
+        }
+
+        // called by accessibility delegate
+        boolean performAccessibilityActionForItem(View view, int action, Bundle args) {
+            return performAccessibilityActionForItem(mRecyclerView.mRecycler, mRecyclerView.mState,
+                    view, action, args);
+        }
+
+        /**
+         * Called by AccessibilityDelegate when an accessibility action is requested on one of the
+         * children of LayoutManager.
+         * <p>
+         * Default implementation does not do anything.
+         *
+         * @param recycler The Recycler that can be used to convert view positions into adapter
+         *                 positions
+         * @param state    The current state of RecyclerView
+         * @param view     The child view on which the action is performed
+         * @param action   The action to perform
+         * @param args     Optional action arguments
+         * @return true if action is handled
+         * @see View#performAccessibilityAction(int, android.os.Bundle)
+         */
+        public boolean performAccessibilityActionForItem(Recycler recycler, State state, View view,
+                int action, Bundle args) {
+            return false;
+        }
+    }
+
+    /**
+     * An ItemDecoration allows the application to add a special drawing and layout offset
+     * to specific item views from the adapter's data set. This can be useful for drawing dividers
+     * between items, highlights, visual grouping boundaries and more.
+     *
+     * <p>All ItemDecorations are drawn in the order they were added, before the item
+     * views (in {@link ItemDecoration#onDraw(Canvas, RecyclerView, RecyclerView.State) onDraw()}
+     * and after the items (in {@link ItemDecoration#onDrawOver(Canvas, RecyclerView,
+     * RecyclerView.State)}.</p>
+     */
+    public static abstract class ItemDecoration {
+        /**
+         * Draw any appropriate decorations into the Canvas supplied to the RecyclerView.
+         * Any content drawn by this method will be drawn before the item views are drawn,
+         * and will thus appear underneath the views.
+         *
+         * @param c Canvas to draw into
+         * @param parent RecyclerView this ItemDecoration is drawing into
+         * @param state The current state of RecyclerView
+         */
+        public void onDraw(Canvas c, RecyclerView parent, State state) {
+            onDraw(c, parent);
+        }
+
+        /**
+         * @deprecated
+         * Override {@link #onDraw(Canvas, RecyclerView, RecyclerView.State)}
+         */
+        @Deprecated
+        public void onDraw(Canvas c, RecyclerView parent) {
+        }
+
+        /**
+         * Draw any appropriate decorations into the Canvas supplied to the RecyclerView.
+         * Any content drawn by this method will be drawn after the item views are drawn
+         * and will thus appear over the views.
+         *
+         * @param c Canvas to draw into
+         * @param parent RecyclerView this ItemDecoration is drawing into
+         * @param state The current state of RecyclerView.
+         */
+        public void onDrawOver(Canvas c, RecyclerView parent, State state) {
+            onDrawOver(c, parent);
+        }
+
+        /**
+         * @deprecated
+         * Override {@link #onDrawOver(Canvas, RecyclerView, RecyclerView.State)}
+         */
+        @Deprecated
+        public void onDrawOver(Canvas c, RecyclerView parent) {
+        }
+
+
+        /**
+         * @deprecated
+         * Use {@link #getItemOffsets(Rect, View, RecyclerView, State)}
+         */
+        @Deprecated
+        public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) {
+            outRect.set(0, 0, 0, 0);
+        }
+
+        /**
+         * Retrieve any offsets for the given item. Each field of <code>outRect</code> specifies
+         * the number of pixels that the item view should be inset by, similar to padding or margin.
+         * The default implementation sets the bounds of outRect to 0 and returns.
+         *
+         * <p>
+         * If this ItemDecoration does not affect the positioning of item views, it should set
+         * all four fields of <code>outRect</code> (left, top, right, bottom) to zero
+         * before returning.
+         *
+         * <p>
+         * If you need to access Adapter for additional data, you can call
+         * {@link RecyclerView#getChildAdapterPosition(View)} to get the adapter position of the
+         * View.
+         *
+         * @param outRect Rect to receive the output.
+         * @param view    The child view to decorate
+         * @param parent  RecyclerView this ItemDecoration is decorating
+         * @param state   The current state of RecyclerView.
+         */
+        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) {
+            getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),
+                    parent);
+        }
+    }
+
+    /**
+     * An OnItemTouchListener allows the application to intercept touch events in progress at the
+     * view hierarchy level of the RecyclerView before those touch events are considered for
+     * RecyclerView's own scrolling behavior.
+     *
+     * <p>This can be useful for applications that wish to implement various forms of gestural
+     * manipulation of item views within the RecyclerView. OnItemTouchListeners may intercept
+     * a touch interaction already in progress even if the RecyclerView is already handling that
+     * gesture stream itself for the purposes of scrolling.</p>
+     */
+    public interface OnItemTouchListener {
+        /**
+         * Silently observe and/or take over touch events sent to the RecyclerView
+         * before they are handled by either the RecyclerView itself or its child views.
+         *
+         * <p>The onInterceptTouchEvent methods of each attached OnItemTouchListener will be run
+         * in the order in which each listener was added, before any other touch processing
+         * by the RecyclerView itself or child views occurs.</p>
+         *
+         * @param e MotionEvent describing the touch event. All coordinates are in
+         *          the RecyclerView's coordinate system.
+         * @return true if this OnItemTouchListener wishes to begin intercepting touch events, false
+         *         to continue with the current behavior and continue observing future events in
+         *         the gesture.
+         */
+        public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e);
+
+        /**
+         * Process a touch event as part of a gesture that was claimed by returning true from
+         * a previous call to {@link #onInterceptTouchEvent}.
+         *
+         * @param e MotionEvent describing the touch event. All coordinates are in
+         *          the RecyclerView's coordinate system.
+         */
+        public void onTouchEvent(RecyclerView rv, MotionEvent e);
+    }
+
+    /**
+     * An OnScrollListener can be set on a RecyclerView to receive messages
+     * when a scrolling event has occurred on that RecyclerView.
+     *
+     * @see RecyclerView#setOnScrollListener(OnScrollListener) and
+     * RecyclerView#addOnScrollListener(OnScrollListener)
+     *
+     * If you are planning to have several listeners at the same time, use
+     * RecyclerView#addOnScrollListener. If there will be only one listener at the time and you
+     * want your components to be able to easily replace the listener use
+     * RecyclerView#setOnScrollListener.
+     */
+    abstract static public class OnScrollListener {
+        /**
+         * Callback method to be invoked when RecyclerView's scroll state changes.
+         *
+         * @param recyclerView The RecyclerView whose scroll state has changed.
+         * @param newState     The updated scroll state. One of {@link #SCROLL_STATE_IDLE},
+         *                     {@link #SCROLL_STATE_DRAGGING} or {@link #SCROLL_STATE_SETTLING}.
+         */
+        public void onScrollStateChanged(RecyclerView recyclerView, int newState){}
+
+        /**
+         * Callback method to be invoked when the RecyclerView has been scrolled. This will be
+         * called after the scroll has completed.
+         * <p>
+         * This callback will also be called if visible item range changes after a layout
+         * calculation. In that case, dx and dy will be 0.
+         *
+         * @param recyclerView The RecyclerView which scrolled.
+         * @param dx The amount of horizontal scroll.
+         * @param dy The amount of vertical scroll.
+         */
+        public void onScrolled(RecyclerView recyclerView, int dx, int dy){}
+    }
+
+    /**
+     * A RecyclerListener can be set on a RecyclerView to receive messages whenever
+     * a view is recycled.
+     *
+     * @see RecyclerView#setRecyclerListener(RecyclerListener)
+     */
+    public interface RecyclerListener {
+
+        /**
+         * This method is called whenever the view in the ViewHolder is recycled.
+         *
+         * RecyclerView calls this method right before clearing ViewHolder's internal data and
+         * sending it to RecycledViewPool. This way, if ViewHolder was holding valid information
+         * before being recycled, you can call {@link ViewHolder#getAdapterPosition()} to get
+         * its adapter position.
+         *
+         * @param holder The ViewHolder containing the view that was recycled
+         */
+        public void onViewRecycled(ViewHolder holder);
+    }
+
+    /**
+     * A ViewHolder describes an item view and metadata about its place within the RecyclerView.
+     *
+     * <p>{@link Adapter} implementations should subclass ViewHolder and add fields for caching
+     * potentially expensive {@link View#findViewById(int)} results.</p>
+     *
+     * <p>While {@link LayoutParams} belong to the {@link LayoutManager},
+     * {@link ViewHolder ViewHolders} belong to the adapter. Adapters should feel free to use
+     * their own custom ViewHolder implementations to store data that makes binding view contents
+     * easier. Implementations should assume that individual item views will hold strong references
+     * to <code>ViewHolder</code> objects and that <code>RecyclerView</code> instances may hold
+     * strong references to extra off-screen item views for caching purposes</p>
+     */
+    public static abstract class ViewHolder {
+        public final View itemView;
+        int mPosition = NO_POSITION;
+        int mOldPosition = NO_POSITION;
+        long mItemId = NO_ID;
+        int mItemViewType = INVALID_TYPE;
+        int mPreLayoutPosition = NO_POSITION;
+
+        // The item that this holder is shadowing during an item change event/animation
+        ViewHolder mShadowedHolder = null;
+        // The item that is shadowing this holder during an item change event/animation
+        ViewHolder mShadowingHolder = null;
+
+        /**
+         * This ViewHolder has been bound to a position; mPosition, mItemId and mItemViewType
+         * are all valid.
+         */
+        static final int FLAG_BOUND = 1 << 0;
+
+        /**
+         * The data this ViewHolder's view reflects is stale and needs to be rebound
+         * by the adapter. mPosition and mItemId are consistent.
+         */
+        static final int FLAG_UPDATE = 1 << 1;
+
+        /**
+         * This ViewHolder's data is invalid. The identity implied by mPosition and mItemId
+         * are not to be trusted and may no longer match the item view type.
+         * This ViewHolder must be fully rebound to different data.
+         */
+        static final int FLAG_INVALID = 1 << 2;
+
+        /**
+         * This ViewHolder points at data that represents an item previously removed from the
+         * data set. Its view may still be used for things like outgoing animations.
+         */
+        static final int FLAG_REMOVED = 1 << 3;
+
+        /**
+         * This ViewHolder should not be recycled. This flag is set via setIsRecyclable()
+         * and is intended to keep views around during animations.
+         */
+        static final int FLAG_NOT_RECYCLABLE = 1 << 4;
+
+        /**
+         * This ViewHolder is returned from scrap which means we are expecting an addView call
+         * for this itemView. When returned from scrap, ViewHolder stays in the scrap list until
+         * the end of the layout pass and then recycled by RecyclerView if it is not added back to
+         * the RecyclerView.
+         */
+        static final int FLAG_RETURNED_FROM_SCRAP = 1 << 5;
+
+        /**
+         * This ViewHolder's contents have changed. This flag is used as an indication that
+         * change animations may be used, if supported by the ItemAnimator.
+         */
+        static final int FLAG_CHANGED = 1 << 6;
+
+        /**
+         * This ViewHolder is fully managed by the LayoutManager. We do not scrap, recycle or remove
+         * it unless LayoutManager is replaced.
+         * It is still fully visible to the LayoutManager.
+         */
+        static final int FLAG_IGNORE = 1 << 7;
+
+        /**
+         * When the View is detached form the parent, we set this flag so that we can take correct
+         * action when we need to remove it or add it back.
+         */
+        static final int FLAG_TMP_DETACHED = 1 << 8;
+
+        /**
+         * Set when we can no longer determine the adapter position of this ViewHolder until it is
+         * rebound to a new position. It is different than FLAG_INVALID because FLAG_INVALID is
+         * set even when the type does not match. Also, FLAG_ADAPTER_POSITION_UNKNOWN is set as soon
+         * as adapter notification arrives vs FLAG_INVALID is set lazily before layout is
+         * re-calculated.
+         */
+        static final int FLAG_ADAPTER_POSITION_UNKNOWN = 1 << 9;
+
+        private int mFlags;
+
+        private int mIsRecyclableCount = 0;
+
+        // If non-null, view is currently considered scrap and may be reused for other data by the
+        // scrap container.
+        private Recycler mScrapContainer = null;
+
+        /**
+         * Is set when VH is bound from the adapter and cleaned right before it is sent to
+         * {@link RecycledViewPool}.
+         */
+        RecyclerView mOwnerRecyclerView;
+
+        public ViewHolder(View itemView) {
+            if (itemView == null) {
+                throw new IllegalArgumentException("itemView may not be null");
+            }
+            this.itemView = itemView;
+        }
+
+        void flagRemovedAndOffsetPosition(int mNewPosition, int offset, boolean applyToPreLayout) {
+            addFlags(ViewHolder.FLAG_REMOVED);
+            offsetPosition(offset, applyToPreLayout);
+            mPosition = mNewPosition;
+        }
+
+        void offsetPosition(int offset, boolean applyToPreLayout) {
+            if (mOldPosition == NO_POSITION) {
+                mOldPosition = mPosition;
+            }
+            if (mPreLayoutPosition == NO_POSITION) {
+                mPreLayoutPosition = mPosition;
+            }
+            if (applyToPreLayout) {
+                mPreLayoutPosition += offset;
+            }
+            mPosition += offset;
+            if (itemView.getLayoutParams() != null) {
+                ((LayoutParams) itemView.getLayoutParams()).mInsetsDirty = true;
+            }
+        }
+
+        void clearOldPosition() {
+            mOldPosition = NO_POSITION;
+            mPreLayoutPosition = NO_POSITION;
+        }
+
+        void saveOldPosition() {
+            if (mOldPosition == NO_POSITION) {
+                mOldPosition = mPosition;
+            }
+        }
+
+        boolean shouldIgnore() {
+            return (mFlags & FLAG_IGNORE) != 0;
+        }
+
+        /**
+         * @deprecated This method is deprecated because its meaning is ambiguous due to the async
+         * handling of adapter updates. Please use {@link #getLayoutPosition()} or
+         * {@link #getAdapterPosition()} depending on your use case.
+         *
+         * @see #getLayoutPosition()
+         * @see #getAdapterPosition()
+         */
+        @Deprecated
+        public final int getPosition() {
+            return mPreLayoutPosition == NO_POSITION ? mPosition : mPreLayoutPosition;
+        }
+
+        /**
+         * Returns the position of the ViewHolder in terms of the latest layout pass.
+         * <p>
+         * This position is mostly used by RecyclerView components to be consistent while
+         * RecyclerView lazily processes adapter updates.
+         * <p>
+         * For performance and animation reasons, RecyclerView batches all adapter updates until the
+         * next layout pass. This may cause mismatches between the Adapter position of the item and
+         * the position it had in the latest layout calculations.
+         * <p>
+         * LayoutManagers should always call this method while doing calculations based on item
+         * positions. All methods in {@link RecyclerView.LayoutManager}, {@link RecyclerView.State},
+         * {@link RecyclerView.Recycler} that receive a position expect it to be the layout position
+         * of the item.
+         * <p>
+         * If LayoutManager needs to call an external method that requires the adapter position of
+         * the item, it can use {@link #getAdapterPosition()} or
+         * {@link RecyclerView.Recycler#convertPreLayoutPositionToPostLayout(int)}.
+         *
+         * @return Returns the adapter position of the ViewHolder in the latest layout pass.
+         * @see #getAdapterPosition()
+         */
+        public final int getLayoutPosition() {
+            return mPreLayoutPosition == NO_POSITION ? mPosition : mPreLayoutPosition;
+        }
+
+        /**
+         * Returns the Adapter position of the item represented by this ViewHolder.
+         * <p>
+         * Note that this might be different than the {@link #getLayoutPosition()} if there are
+         * pending adapter updates but a new layout pass has not happened yet.
+         * <p>
+         * RecyclerView does not handle any adapter updates until the next layout traversal. This
+         * may create temporary inconsistencies between what user sees on the screen and what
+         * adapter contents have. This inconsistency is not important since it will be less than
+         * 16ms but it might be a problem if you want to use ViewHolder position to access the
+         * adapter. Sometimes, you may need to get the exact adapter position to do
+         * some actions in response to user events. In that case, you should use this method which
+         * will calculate the Adapter position of the ViewHolder.
+         * <p>
+         * Note that if you've called {@link RecyclerView.Adapter#notifyDataSetChanged()}, until the
+         * next layout pass, the return value of this method will be {@link #NO_POSITION}.
+         *
+         * @return The adapter position of the item if it still exists in the adapter.
+         * {@link RecyclerView#NO_POSITION} if item has been removed from the adapter,
+         * {@link RecyclerView.Adapter#notifyDataSetChanged()} has been called after the last
+         * layout pass or the ViewHolder has already been recycled.
+         */
+        public final int getAdapterPosition() {
+            if (mOwnerRecyclerView == null) {
+                return NO_POSITION;
+            }
+            return mOwnerRecyclerView.getAdapterPositionFor(this);
+        }
+
+        /**
+         * When LayoutManager supports animations, RecyclerView tracks 3 positions for ViewHolders
+         * to perform animations.
+         * <p>
+         * If a ViewHolder was laid out in the previous onLayout call, old position will keep its
+         * adapter index in the previous layout.
+         *
+         * @return The previous adapter index of the Item represented by this ViewHolder or
+         * {@link #NO_POSITION} if old position does not exists or cleared (pre-layout is
+         * complete).
+         */
+        public final int getOldPosition() {
+            return mOldPosition;
+        }
+
+        /**
+         * Returns The itemId represented by this ViewHolder.
+         *
+         * @return The the item's id if adapter has stable ids, {@link RecyclerView#NO_ID}
+         * otherwise
+         */
+        public final long getItemId() {
+            return mItemId;
+        }
+
+        /**
+         * @return The view type of this ViewHolder.
+         */
+        public final int getItemViewType() {
+            return mItemViewType;
+        }
+
+        boolean isScrap() {
+            return mScrapContainer != null;
+        }
+
+        void unScrap() {
+            mScrapContainer.unscrapView(this);
+        }
+
+        boolean wasReturnedFromScrap() {
+            return (mFlags & FLAG_RETURNED_FROM_SCRAP) != 0;
+        }
+
+        void clearReturnedFromScrapFlag() {
+            mFlags = mFlags & ~FLAG_RETURNED_FROM_SCRAP;
+        }
+
+        void clearTmpDetachFlag() {
+            mFlags = mFlags & ~FLAG_TMP_DETACHED;
+        }
+
+        void stopIgnoring() {
+            mFlags = mFlags & ~FLAG_IGNORE;
+        }
+
+        void setScrapContainer(Recycler recycler) {
+            mScrapContainer = recycler;
+        }
+
+        boolean isInvalid() {
+            return (mFlags & FLAG_INVALID) != 0;
+        }
+
+        boolean needsUpdate() {
+            return (mFlags & FLAG_UPDATE) != 0;
+        }
+
+        boolean isChanged() {
+            return (mFlags & FLAG_CHANGED) != 0;
+        }
+
+        boolean isBound() {
+            return (mFlags & FLAG_BOUND) != 0;
+        }
+
+        boolean isRemoved() {
+            return (mFlags & FLAG_REMOVED) != 0;
+        }
+
+        boolean hasAnyOfTheFlags(int flags) {
+            return (mFlags & flags) != 0;
+        }
+
+        boolean isTmpDetached() {
+            return (mFlags & FLAG_TMP_DETACHED) != 0;
+        }
+
+        boolean isAdapterPositionUnknown() {
+            return (mFlags & FLAG_ADAPTER_POSITION_UNKNOWN) != 0 || isInvalid();
+        }
+
+        void setFlags(int flags, int mask) {
+            mFlags = (mFlags & ~mask) | (flags & mask);
+        }
+
+        void addFlags(int flags) {
+            mFlags |= flags;
+        }
+
+        void resetInternal() {
+            mFlags = 0;
+            mPosition = NO_POSITION;
+            mOldPosition = NO_POSITION;
+            mItemId = NO_ID;
+            mPreLayoutPosition = NO_POSITION;
+            mIsRecyclableCount = 0;
+            mShadowedHolder = null;
+            mShadowingHolder = null;
+        }
+
+        @Override
+        public String toString() {
+            final StringBuilder sb = new StringBuilder("ViewHolder{" +
+                    Integer.toHexString(hashCode()) + " position=" + mPosition + " id=" + mItemId +
+                    ", oldPos=" + mOldPosition + ", pLpos:" + mPreLayoutPosition);
+            if (isScrap()) sb.append(" scrap");
+            if (isInvalid()) sb.append(" invalid");
+            if (!isBound()) sb.append(" unbound");
+            if (needsUpdate()) sb.append(" update");
+            if (isRemoved()) sb.append(" removed");
+            if (shouldIgnore()) sb.append(" ignored");
+            if (isChanged()) sb.append(" changed");
+            if (isTmpDetached()) sb.append(" tmpDetached");
+            if (!isRecyclable()) sb.append(" not recyclable(" + mIsRecyclableCount + ")");
+            if (isAdapterPositionUnknown()) sb.append("undefined adapter position");
+
+            if (itemView.getParent() == null) sb.append(" no parent");
+            sb.append("}");
+            return sb.toString();
+        }
+
+        /**
+         * Informs the recycler whether this item can be recycled. Views which are not
+         * recyclable will not be reused for other items until setIsRecyclable() is
+         * later set to true. Calls to setIsRecyclable() should always be paired (one
+         * call to setIsRecyclabe(false) should always be matched with a later call to
+         * setIsRecyclable(true)). Pairs of calls may be nested, as the state is internally
+         * reference-counted.
+         *
+         * @param recyclable Whether this item is available to be recycled. Default value
+         * is true.
+         */
+        public final void setIsRecyclable(boolean recyclable) {
+            mIsRecyclableCount = recyclable ? mIsRecyclableCount - 1 : mIsRecyclableCount + 1;
+            if (mIsRecyclableCount < 0) {
+                mIsRecyclableCount = 0;
+                if (DEBUG) {
+                    throw new RuntimeException("isRecyclable decremented below 0: " +
+                            "unmatched pair of setIsRecyable() calls for " + this);
+                }
+                Log.e(VIEW_LOG_TAG, "isRecyclable decremented below 0: " +
+                        "unmatched pair of setIsRecyable() calls for " + this);
+            } else if (!recyclable && mIsRecyclableCount == 1) {
+                mFlags |= FLAG_NOT_RECYCLABLE;
+            } else if (recyclable && mIsRecyclableCount == 0) {
+                mFlags &= ~FLAG_NOT_RECYCLABLE;
+            }
+            if (DEBUG) {
+                Log.d(TAG, "setIsRecyclable val:" + recyclable + ":" + this);
+            }
+        }
+
+        /**
+         * @see {@link #setIsRecyclable(boolean)}
+         *
+         * @return true if this item is available to be recycled, false otherwise.
+         */
+        public final boolean isRecyclable() {
+            return (mFlags & FLAG_NOT_RECYCLABLE) == 0 &&
+                    !ViewCompat.hasTransientState(itemView);
+        }
+
+        /**
+         * Returns whether we have animations referring to this view holder or not.
+         * This is similar to isRecyclable flag but does not check transient state.
+         */
+        private boolean shouldBeKeptAsChild() {
+            return (mFlags & FLAG_NOT_RECYCLABLE) != 0;
+        }
+
+        /**
+         * @return True if ViewHolder is not refenrenced by RecyclerView animations but has
+         * transient state which will prevent it from being recycled.
+         */
+        private boolean doesTransientStatePreventRecycling() {
+            return (mFlags & FLAG_NOT_RECYCLABLE) == 0 && ViewCompat.hasTransientState(itemView);
+        }
+    }
+
+    private int getAdapterPositionFor(ViewHolder viewHolder) {
+        if (viewHolder.hasAnyOfTheFlags( ViewHolder.FLAG_INVALID |
+                ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)
+                || !viewHolder.isBound()) {
+            return RecyclerView.NO_POSITION;
+        }
+        return mAdapterHelper.applyPendingUpdatesToPosition(viewHolder.mPosition);
+    }
+
+    /**
+     * {@link android.view.ViewGroup.MarginLayoutParams LayoutParams} subclass for children of
+     * {@link RecyclerView}. Custom {@link LayoutManager layout managers} are encouraged
+     * to create their own subclass of this <code>LayoutParams</code> class
+     * to store any additional required per-child view metadata about the layout.
+     */
+    public static class LayoutParams extends android.view.ViewGroup.MarginLayoutParams {
+        ViewHolder mViewHolder;
+        final Rect mDecorInsets = new Rect();
+        boolean mInsetsDirty = true;
+        // Flag is set to true if the view is bound while it is detached from RV.
+        // In this case, we need to manually call invalidate after view is added to guarantee that
+        // invalidation is populated through the View hierarchy
+        boolean mPendingInvalidate = false;
+
+        public LayoutParams(Context c, AttributeSet attrs) {
+            super(c, attrs);
+        }
+
+        public LayoutParams(int width, int height) {
+            super(width, height);
+        }
+
+        public LayoutParams(MarginLayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(ViewGroup.LayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(LayoutParams source) {
+            super((ViewGroup.LayoutParams) source);
+        }
+
+        /**
+         * Returns true if the view this LayoutParams is attached to needs to have its content
+         * updated from the corresponding adapter.
+         *
+         * @return true if the view should have its content updated
+         */
+        public boolean viewNeedsUpdate() {
+            return mViewHolder.needsUpdate();
+        }
+
+        /**
+         * Returns true if the view this LayoutParams is attached to is now representing
+         * potentially invalid data. A LayoutManager should scrap/recycle it.
+         *
+         * @return true if the view is invalid
+         */
+        public boolean isViewInvalid() {
+            return mViewHolder.isInvalid();
+        }
+
+        /**
+         * Returns true if the adapter data item corresponding to the view this LayoutParams
+         * is attached to has been removed from the data set. A LayoutManager may choose to
+         * treat it differently in order to animate its outgoing or disappearing state.
+         *
+         * @return true if the item the view corresponds to was removed from the data set
+         */
+        public boolean isItemRemoved() {
+            return mViewHolder.isRemoved();
+        }
+
+        /**
+         * Returns true if the adapter data item corresponding to the view this LayoutParams
+         * is attached to has been changed in the data set. A LayoutManager may choose to
+         * treat it differently in order to animate its changing state.
+         *
+         * @return true if the item the view corresponds to was changed in the data set
+         */
+        public boolean isItemChanged() {
+            return mViewHolder.isChanged();
+        }
+
+        /**
+         * @deprecated use {@link #getViewLayoutPosition()} or {@link #getViewAdapterPosition()}
+         */
+        public int getViewPosition() {
+            return mViewHolder.getPosition();
+        }
+
+        /**
+         * Returns the adapter position that the view this LayoutParams is attached to corresponds
+         * to as of latest layout calculation.
+         *
+         * @return the adapter position this view as of latest layout pass
+         */
+        public int getViewLayoutPosition() {
+            return mViewHolder.getLayoutPosition();
+        }
+
+        /**
+         * Returns the up-to-date adapter position that the view this LayoutParams is attached to
+         * corresponds to.
+         *
+         * @return the up-to-date adapter position this view. It may return
+         * {@link RecyclerView#NO_POSITION} if item represented by this View has been removed or
+         * its up-to-date position cannot be calculated.
+         */
+        public int getViewAdapterPosition() {
+            return mViewHolder.getAdapterPosition();
+        }
+    }
+
+    /**
+     * Observer base class for watching changes to an {@link Adapter}.
+     * See {@link Adapter#registerAdapterDataObserver(AdapterDataObserver)}.
+     */
+    public static abstract class AdapterDataObserver {
+        public void onChanged() {
+            // Do nothing
+        }
+
+        public void onItemRangeChanged(int positionStart, int itemCount) {
+            // do nothing
+        }
+
+        public void onItemRangeInserted(int positionStart, int itemCount) {
+            // do nothing
+        }
+
+        public void onItemRangeRemoved(int positionStart, int itemCount) {
+            // do nothing
+        }
+
+        public void onItemRangeMoved(int fromPosition, int toPosition, int itemCount) {
+            // do nothing
+        }
+    }
+
+    /**
+     * <p>Base class for smooth scrolling. Handles basic tracking of the target view position and
+     * provides methods to trigger a programmatic scroll.</p>
+     *
+     * @see LinearSmoothScroller
+     */
+    public static abstract class SmoothScroller {
+
+        private int mTargetPosition = RecyclerView.NO_POSITION;
+
+        private RecyclerView mRecyclerView;
+
+        private LayoutManager mLayoutManager;
+
+        private boolean mPendingInitialRun;
+
+        private boolean mRunning;
+
+        private View mTargetView;
+
+        private final Action mRecyclingAction;
+
+        public SmoothScroller() {
+            mRecyclingAction = new Action(0, 0);
+        }
+
+        /**
+         * Starts a smooth scroll for the given target position.
+         * <p>In each animation step, {@link RecyclerView} will check
+         * for the target view and call either
+         * {@link #onTargetFound(android.view.View, RecyclerView.State, SmoothScroller.Action)} or
+         * {@link #onSeekTargetStep(int, int, RecyclerView.State, SmoothScroller.Action)} until
+         * SmoothScroller is stopped.</p>
+         *
+         * <p>Note that if RecyclerView finds the target view, it will automatically stop the
+         * SmoothScroller. This <b>does not</b> mean that scroll will stop, it only means it will
+         * stop calling SmoothScroller in each animation step.</p>
+         */
+        void start(RecyclerView recyclerView, LayoutManager layoutManager) {
+            mRecyclerView = recyclerView;
+            mLayoutManager = layoutManager;
+            if (mTargetPosition == RecyclerView.NO_POSITION) {
+                throw new IllegalArgumentException("Invalid target position");
+            }
+            mRecyclerView.mState.mTargetPosition = mTargetPosition;
+            mRunning = true;
+            mPendingInitialRun = true;
+            mTargetView = findViewByPosition(getTargetPosition());
+            onStart();
+            mRecyclerView.mViewFlinger.postOnAnimation();
+        }
+
+        public void setTargetPosition(int targetPosition) {
+            mTargetPosition = targetPosition;
+        }
+
+        /**
+         * @return The LayoutManager to which this SmoothScroller is attached
+         */
+        public LayoutManager getLayoutManager() {
+            return mLayoutManager;
+        }
+
+        /**
+         * Stops running the SmoothScroller in each animation callback. Note that this does not
+         * cancel any existing {@link Action} updated by
+         * {@link #onTargetFound(android.view.View, RecyclerView.State, SmoothScroller.Action)} or
+         * {@link #onSeekTargetStep(int, int, RecyclerView.State, SmoothScroller.Action)}.
+         */
+        final protected void stop() {
+            if (!mRunning) {
+                return;
+            }
+            onStop();
+            mRecyclerView.mState.mTargetPosition = RecyclerView.NO_POSITION;
+            mTargetView = null;
+            mTargetPosition = RecyclerView.NO_POSITION;
+            mPendingInitialRun = false;
+            mRunning = false;
+            // trigger a cleanup
+            mLayoutManager.onSmoothScrollerStopped(this);
+            // clear references to avoid any potential leak by a custom smooth scroller
+            mLayoutManager = null;
+            mRecyclerView = null;
+        }
+
+        /**
+         * Returns true if SmoothScroller has been started but has not received the first
+         * animation
+         * callback yet.
+         *
+         * @return True if this SmoothScroller is waiting to start
+         */
+        public boolean isPendingInitialRun() {
+            return mPendingInitialRun;
+        }
+
+
+        /**
+         * @return True if SmoothScroller is currently active
+         */
+        public boolean isRunning() {
+            return mRunning;
+        }
+
+        /**
+         * Returns the adapter position of the target item
+         *
+         * @return Adapter position of the target item or
+         * {@link RecyclerView#NO_POSITION} if no target view is set.
+         */
+        public int getTargetPosition() {
+            return mTargetPosition;
+        }
+
+        private void onAnimation(int dx, int dy) {
+            if (!mRunning || mTargetPosition == RecyclerView.NO_POSITION) {
+                stop();
+            }
+            mPendingInitialRun = false;
+            if (mTargetView != null) {
+                // verify target position
+                if (getChildPosition(mTargetView) == mTargetPosition) {
+                    onTargetFound(mTargetView, mRecyclerView.mState, mRecyclingAction);
+                    mRecyclingAction.runIfNecessary(mRecyclerView);
+                    stop();
+                } else {
+                    Log.e(TAG, "Passed over target position while smooth scrolling.");
+                    mTargetView = null;
+                }
+            }
+            if (mRunning) {
+                onSeekTargetStep(dx, dy, mRecyclerView.mState, mRecyclingAction);
+                mRecyclingAction.runIfNecessary(mRecyclerView);
+            }
+        }
+
+        /**
+         * @see RecyclerView#getChildLayoutPosition(android.view.View)
+         */
+        public int getChildPosition(View view) {
+            return mRecyclerView.getChildLayoutPosition(view);
+        }
+
+        /**
+         * @see RecyclerView.LayoutManager#getChildCount()
+         */
+        public int getChildCount() {
+            return mRecyclerView.mLayout.getChildCount();
+        }
+
+        /**
+         * @see RecyclerView.LayoutManager#findViewByPosition(int)
+         */
+        public View findViewByPosition(int position) {
+            return mRecyclerView.mLayout.findViewByPosition(position);
+        }
+
+        /**
+         * @see RecyclerView#scrollToPosition(int)
+         */
+        public void instantScrollToPosition(int position) {
+            mRecyclerView.scrollToPosition(position);
+        }
+
+        protected void onChildAttachedToWindow(View child) {
+            if (getChildPosition(child) == getTargetPosition()) {
+                mTargetView = child;
+                if (DEBUG) {
+                    Log.d(TAG, "smooth scroll target view has been attached");
+                }
+            }
+        }
+
+        /**
+         * Normalizes the vector.
+         * @param scrollVector The vector that points to the target scroll position
+         */
+        protected void normalize(PointF scrollVector) {
+            final double magnitute = Math.sqrt(scrollVector.x * scrollVector.x + scrollVector.y *
+                    scrollVector.y);
+            scrollVector.x /= magnitute;
+            scrollVector.y /= magnitute;
+        }
+
+        /**
+         * Called when smooth scroll is started. This might be a good time to do setup.
+         */
+        abstract protected void onStart();
+
+        /**
+         * Called when smooth scroller is stopped. This is a good place to cleanup your state etc.
+         * @see #stop()
+         */
+        abstract protected void onStop();
+
+        /**
+         * <p>RecyclerView will call this method each time it scrolls until it can find the target
+         * position in the layout.</p>
+         * <p>SmoothScroller should check dx, dy and if scroll should be changed, update the
+         * provided {@link Action} to define the next scroll.</p>
+         *
+         * @param dx        Last scroll amount horizontally
+         * @param dy        Last scroll amount verticaully
+         * @param state     Transient state of RecyclerView
+         * @param action    If you want to trigger a new smooth scroll and cancel the previous one,
+         *                  update this object.
+         */
+        abstract protected void onSeekTargetStep(int dx, int dy, State state, Action action);
+
+        /**
+         * Called when the target position is laid out. This is the last callback SmoothScroller
+         * will receive and it should update the provided {@link Action} to define the scroll
+         * details towards the target view.
+         * @param targetView    The view element which render the target position.
+         * @param state         Transient state of RecyclerView
+         * @param action        Action instance that you should update to define final scroll action
+         *                      towards the targetView
+         */
+        abstract protected void onTargetFound(View targetView, State state, Action action);
+
+        /**
+         * Holds information about a smooth scroll request by a {@link SmoothScroller}.
+         */
+        public static class Action {
+
+            public static final int UNDEFINED_DURATION = Integer.MIN_VALUE;
+
+            private int mDx;
+
+            private int mDy;
+
+            private int mDuration;
+
+            private Interpolator mInterpolator;
+
+            private boolean changed = false;
+
+            // we track this variable to inform custom implementer if they are updating the action
+            // in every animation callback
+            private int consecutiveUpdates = 0;
+
+            /**
+             * @param dx Pixels to scroll horizontally
+             * @param dy Pixels to scroll vertically
+             */
+            public Action(int dx, int dy) {
+                this(dx, dy, UNDEFINED_DURATION, null);
+            }
+
+            /**
+             * @param dx       Pixels to scroll horizontally
+             * @param dy       Pixels to scroll vertically
+             * @param duration Duration of the animation in milliseconds
+             */
+            public Action(int dx, int dy, int duration) {
+                this(dx, dy, duration, null);
+            }
+
+            /**
+             * @param dx           Pixels to scroll horizontally
+             * @param dy           Pixels to scroll vertically
+             * @param duration     Duration of the animation in milliseconds
+             * @param interpolator Interpolator to be used when calculating scroll position in each
+             *                     animation step
+             */
+            public Action(int dx, int dy, int duration, Interpolator interpolator) {
+                mDx = dx;
+                mDy = dy;
+                mDuration = duration;
+                mInterpolator = interpolator;
+            }
+            private void runIfNecessary(RecyclerView recyclerView) {
+                if (changed) {
+                    validate();
+                    if (mInterpolator == null) {
+                        if (mDuration == UNDEFINED_DURATION) {
+                            recyclerView.mViewFlinger.smoothScrollBy(mDx, mDy);
+                        } else {
+                            recyclerView.mViewFlinger.smoothScrollBy(mDx, mDy, mDuration);
+                        }
+                    } else {
+                        recyclerView.mViewFlinger.smoothScrollBy(mDx, mDy, mDuration, mInterpolator);
+                    }
+                    consecutiveUpdates ++;
+                    if (consecutiveUpdates > 10) {
+                        // A new action is being set in every animation step. This looks like a bad
+                        // implementation. Inform developer.
+                        Log.e(TAG, "Smooth Scroll action is being updated too frequently. Make sure"
+                                + " you are not changing it unless necessary");
+                    }
+                    changed = false;
+                } else {
+                    consecutiveUpdates = 0;
+                }
+            }
+
+            private void validate() {
+                if (mInterpolator != null && mDuration < 1) {
+                    throw new IllegalStateException("If you provide an interpolator, you must"
+                            + " set a positive duration");
+                } else if (mDuration < 1) {
+                    throw new IllegalStateException("Scroll duration must be a positive number");
+                }
+            }
+
+            public int getDx() {
+                return mDx;
+            }
+
+            public void setDx(int dx) {
+                changed = true;
+                mDx = dx;
+            }
+
+            public int getDy() {
+                return mDy;
+            }
+
+            public void setDy(int dy) {
+                changed = true;
+                mDy = dy;
+            }
+
+            public int getDuration() {
+                return mDuration;
+            }
+
+            public void setDuration(int duration) {
+                changed = true;
+                mDuration = duration;
+            }
+
+            public Interpolator getInterpolator() {
+                return mInterpolator;
+            }
+
+            /**
+             * Sets the interpolator to calculate scroll steps
+             * @param interpolator The interpolator to use. If you specify an interpolator, you must
+             *                     also set the duration.
+             * @see #setDuration(int)
+             */
+            public void setInterpolator(Interpolator interpolator) {
+                changed = true;
+                mInterpolator = interpolator;
+            }
+
+            /**
+             * Updates the action with given parameters.
+             * @param dx Pixels to scroll horizontally
+             * @param dy Pixels to scroll vertically
+             * @param duration Duration of the animation in milliseconds
+             * @param interpolator Interpolator to be used when calculating scroll position in each
+             *                     animation step
+             */
+            public void update(int dx, int dy, int duration, Interpolator interpolator) {
+                mDx = dx;
+                mDy = dy;
+                mDuration = duration;
+                mInterpolator = interpolator;
+                changed = true;
+            }
+        }
+    }
+
+    static class AdapterDataObservable extends Observable<AdapterDataObserver> {
+        public boolean hasObservers() {
+            return !mObservers.isEmpty();
+        }
+
+        public void notifyChanged() {
+            // since onChanged() is implemented by the app, it could do anything, including
+            // removing itself from {@link mObservers} - and that could cause problems if
+            // an iterator is used on the ArrayList {@link mObservers}.
+            // to avoid such problems, just march thru the list in the reverse order.
+            for (int i = mObservers.size() - 1; i >= 0; i--) {
+                mObservers.get(i).onChanged();
+            }
+        }
+
+        public void notifyItemRangeChanged(int positionStart, int itemCount) {
+            // since onItemRangeChanged() is implemented by the app, it could do anything, including
+            // removing itself from {@link mObservers} - and that could cause problems if
+            // an iterator is used on the ArrayList {@link mObservers}.
+            // to avoid such problems, just march thru the list in the reverse order.
+            for (int i = mObservers.size() - 1; i >= 0; i--) {
+                mObservers.get(i).onItemRangeChanged(positionStart, itemCount);
+            }
+        }
+
+        public void notifyItemRangeInserted(int positionStart, int itemCount) {
+            // since onItemRangeInserted() is implemented by the app, it could do anything,
+            // including removing itself from {@link mObservers} - and that could cause problems if
+            // an iterator is used on the ArrayList {@link mObservers}.
+            // to avoid such problems, just march thru the list in the reverse order.
+            for (int i = mObservers.size() - 1; i >= 0; i--) {
+                mObservers.get(i).onItemRangeInserted(positionStart, itemCount);
+            }
+        }
+
+        public void notifyItemRangeRemoved(int positionStart, int itemCount) {
+            // since onItemRangeRemoved() is implemented by the app, it could do anything, including
+            // removing itself from {@link mObservers} - and that could cause problems if
+            // an iterator is used on the ArrayList {@link mObservers}.
+            // to avoid such problems, just march thru the list in the reverse order.
+            for (int i = mObservers.size() - 1; i >= 0; i--) {
+                mObservers.get(i).onItemRangeRemoved(positionStart, itemCount);
+            }
+        }
+
+        public void notifyItemMoved(int fromPosition, int toPosition) {
+            for (int i = mObservers.size() - 1; i >= 0; i--) {
+                mObservers.get(i).onItemRangeMoved(fromPosition, toPosition, 1);
+            }
+        }
+    }
+
+    static class SavedState extends android.view.View.BaseSavedState {
+
+        Parcelable mLayoutState;
+
+        /**
+         * called by CREATOR
+         */
+        SavedState(Parcel in) {
+            super(in);
+            mLayoutState = in.readParcelable(LayoutManager.class.getClassLoader());
+        }
+
+        /**
+         * Called by onSaveInstanceState
+         */
+        SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            super.writeToParcel(dest, flags);
+            dest.writeParcelable(mLayoutState, 0);
+        }
+
+        private void copyFrom(SavedState other) {
+            mLayoutState = other.mLayoutState;
+        }
+
+        public static final Parcelable.Creator<SavedState> CREATOR
+                = new Parcelable.Creator<SavedState>() {
+            @Override
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            @Override
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+    /**
+     * <p>Contains useful information about the current RecyclerView state like target scroll
+     * position or view focus. State object can also keep arbitrary data, identified by resource
+     * ids.</p>
+     * <p>Often times, RecyclerView components will need to pass information between each other.
+     * To provide a well defined data bus between components, RecyclerView passes the same State
+     * object to component callbacks and these components can use it to exchange data.</p>
+     * <p>If you implement custom components, you can use State's put/get/remove methods to pass
+     * data between your components without needing to manage their lifecycles.</p>
+     */
+    public static class State {
+
+        private int mTargetPosition = RecyclerView.NO_POSITION;
+        ArrayMap<ViewHolder, ItemHolderInfo> mPreLayoutHolderMap =
+                new ArrayMap<ViewHolder, ItemHolderInfo>();
+        ArrayMap<ViewHolder, ItemHolderInfo> mPostLayoutHolderMap =
+                new ArrayMap<ViewHolder, ItemHolderInfo>();
+        // nullable
+        ArrayMap<Long, ViewHolder> mOldChangedHolders = new ArrayMap<Long, ViewHolder>();
+
+        // we use this like a set
+        final List<View> mDisappearingViewsInLayoutPass = new ArrayList<View>();
+
+        private SparseArray<Object> mData;
+
+        /**
+         * Number of items adapter has.
+         */
+        int mItemCount = 0;
+
+        /**
+         * Number of items adapter had in the previous layout.
+         */
+        private int mPreviousLayoutItemCount = 0;
+
+        /**
+         * Number of items that were NOT laid out but has been deleted from the adapter after the
+         * previous layout.
+         */
+        private int mDeletedInvisibleItemCountSincePreviousLayout = 0;
+
+        private boolean mStructureChanged = false;
+
+        private boolean mInPreLayout = false;
+
+        private boolean mRunSimpleAnimations = false;
+
+        private boolean mRunPredictiveAnimations = false;
+
+        State reset() {
+            mTargetPosition = RecyclerView.NO_POSITION;
+            if (mData != null) {
+                mData.clear();
+            }
+            mItemCount = 0;
+            mStructureChanged = false;
+            return this;
+        }
+
+        public boolean isPreLayout() {
+            return mInPreLayout;
+        }
+
+        /**
+         * Returns whether RecyclerView will run predictive animations in this layout pass
+         * or not.
+         *
+         * @return true if RecyclerView is calculating predictive animations to be run at the end
+         *         of the layout pass.
+         */
+        public boolean willRunPredictiveAnimations() {
+            return mRunPredictiveAnimations;
+        }
+
+        /**
+         * Returns whether RecyclerView will run simple animations in this layout pass
+         * or not.
+         *
+         * @return true if RecyclerView is calculating simple animations to be run at the end of
+         *         the layout pass.
+         */
+        public boolean willRunSimpleAnimations() {
+            return mRunSimpleAnimations;
+        }
+
+        /**
+         * Removes the mapping from the specified id, if there was any.
+         * @param resourceId Id of the resource you want to remove. It is suggested to use R.id.* to
+         *                   preserve cross functionality and avoid conflicts.
+         */
+        public void remove(int resourceId) {
+            if (mData == null) {
+                return;
+            }
+            mData.remove(resourceId);
+        }
+
+        /**
+         * Gets the Object mapped from the specified id, or <code>null</code>
+         * if no such data exists.
+         *
+         * @param resourceId Id of the resource you want to remove. It is suggested to use R.id.*
+         *                   to
+         *                   preserve cross functionality and avoid conflicts.
+         */
+        public <T> T get(int resourceId) {
+            if (mData == null) {
+                return null;
+            }
+            return (T) mData.get(resourceId);
+        }
+
+        /**
+         * Adds a mapping from the specified id to the specified value, replacing the previous
+         * mapping from the specified key if there was one.
+         *
+         * @param resourceId Id of the resource you want to add. It is suggested to use R.id.* to
+         *                   preserve cross functionality and avoid conflicts.
+         * @param data       The data you want to associate with the resourceId.
+         */
+        public void put(int resourceId, Object data) {
+            if (mData == null) {
+                mData = new SparseArray<Object>();
+            }
+            mData.put(resourceId, data);
+        }
+
+        /**
+         * If scroll is triggered to make a certain item visible, this value will return the
+         * adapter index of that item.
+         * @return Adapter index of the target item or
+         * {@link RecyclerView#NO_POSITION} if there is no target
+         * position.
+         */
+        public int getTargetScrollPosition() {
+            return mTargetPosition;
+        }
+
+        /**
+         * Returns if current scroll has a target position.
+         * @return true if scroll is being triggered to make a certain position visible
+         * @see #getTargetScrollPosition()
+         */
+        public boolean hasTargetScrollPosition() {
+            return mTargetPosition != RecyclerView.NO_POSITION;
+        }
+
+        /**
+         * @return true if the structure of the data set has changed since the last call to
+         *         onLayoutChildren, false otherwise
+         */
+        public boolean didStructureChange() {
+            return mStructureChanged;
+        }
+
+        /**
+         * Returns the total number of items that can be laid out. Note that this number is not
+         * necessarily equal to the number of items in the adapter, so you should always use this
+         * number for your position calculations and never access the adapter directly.
+         * <p>
+         * RecyclerView listens for Adapter's notify events and calculates the effects of adapter
+         * data changes on existing Views. These calculations are used to decide which animations
+         * should be run.
+         * <p>
+         * To support predictive animations, RecyclerView may rewrite or reorder Adapter changes to
+         * present the correct state to LayoutManager in pre-layout pass.
+         * <p>
+         * For example, a newly added item is not included in pre-layout item count because
+         * pre-layout reflects the contents of the adapter before the item is added. Behind the
+         * scenes, RecyclerView offsets {@link Recycler#getViewForPosition(int)} calls such that
+         * LayoutManager does not know about the new item's existence in pre-layout. The item will
+         * be available in second layout pass and will be included in the item count. Similar
+         * adjustments are made for moved and removed items as well.
+         * <p>
+         * You can get the adapter's item count via {@link LayoutManager#getItemCount()} method.
+         *
+         * @return The number of items currently available
+         * @see LayoutManager#getItemCount()
+         */
+        public int getItemCount() {
+            return mInPreLayout ?
+                    (mPreviousLayoutItemCount - mDeletedInvisibleItemCountSincePreviousLayout) :
+                    mItemCount;
+        }
+
+        void onViewRecycled(ViewHolder holder) {
+            mPreLayoutHolderMap.remove(holder);
+            mPostLayoutHolderMap.remove(holder);
+            if (mOldChangedHolders != null) {
+                removeFrom(mOldChangedHolders, holder);
+            }
+            mDisappearingViewsInLayoutPass.remove(holder.itemView);
+            // holder cannot be in new list.
+        }
+
+        public void onViewIgnored(ViewHolder holder) {
+            onViewRecycled(holder);
+        }
+
+        private void removeFrom(ArrayMap<Long, ViewHolder> holderMap, ViewHolder holder) {
+            for (int i = holderMap.size() - 1; i >= 0; i --) {
+                if (holder == holderMap.valueAt(i)) {
+                    holderMap.removeAt(i);
+                    return;
+                }
+            }
+        }
+
+        void removeFromDisappearingList(View child) {
+            mDisappearingViewsInLayoutPass.remove(child);
+        }
+
+        void addToDisappearingList(View child) {
+            if (!mDisappearingViewsInLayoutPass.contains(child)) {
+                mDisappearingViewsInLayoutPass.add(child);
+            }
+        }
+
+        @Override
+        public String toString() {
+            return "State{" +
+                    "mTargetPosition=" + mTargetPosition +
+                    ", mPreLayoutHolderMap=" + mPreLayoutHolderMap +
+                    ", mPostLayoutHolderMap=" + mPostLayoutHolderMap +
+                    ", mData=" + mData +
+                    ", mItemCount=" + mItemCount +
+                    ", mPreviousLayoutItemCount=" + mPreviousLayoutItemCount +
+                    ", mDeletedInvisibleItemCountSincePreviousLayout="
+                    + mDeletedInvisibleItemCountSincePreviousLayout +
+                    ", mStructureChanged=" + mStructureChanged +
+                    ", mInPreLayout=" + mInPreLayout +
+                    ", mRunSimpleAnimations=" + mRunSimpleAnimations +
+                    ", mRunPredictiveAnimations=" + mRunPredictiveAnimations +
+                    '}';
+        }
+    }
+
+    /**
+     * Internal listener that manages items after animations finish. This is how items are
+     * retained (not recycled) during animations, but allowed to be recycled afterwards.
+     * It depends on the contract with the ItemAnimator to call the appropriate dispatch*Finished()
+     * method on the animator's listener when it is done animating any item.
+     */
+    private class ItemAnimatorRestoreListener implements ItemAnimator.ItemAnimatorListener {
+
+        @Override
+        public void onRemoveFinished(ViewHolder item) {
+            item.setIsRecyclable(true);
+            if (!removeAnimatingView(item.itemView) && item.isTmpDetached()) {
+                removeDetachedView(item.itemView, false);
+            }
+        }
+
+        @Override
+        public void onAddFinished(ViewHolder item) {
+            item.setIsRecyclable(true);
+            if (!item.shouldBeKeptAsChild()) {
+                removeAnimatingView(item.itemView);
+            }
+        }
+
+        @Override
+        public void onMoveFinished(ViewHolder item) {
+            item.setIsRecyclable(true);
+            if (!item.shouldBeKeptAsChild()) {
+                removeAnimatingView(item.itemView);
+            }
+        }
+
+        @Override
+        public void onChangeFinished(ViewHolder item) {
+            item.setIsRecyclable(true);
+            /**
+             * We check both shadowed and shadowing because a ViewHolder may get both roles at the
+             * same time.
+             *
+             * Assume this flow:
+             * item X is represented by VH_1. Then itemX changes, so we create VH_2 .
+             * RV sets the following and calls item animator:
+             * VH_1.shadowed = VH_2;
+             * VH_1.mChanged = true;
+             * VH_2.shadowing =VH_1;
+             *
+             * Then, before the first change finishes, item changes again so we create VH_3.
+             * RV sets the following and calls item animator:
+             * VH_2.shadowed = VH_3
+             * VH_2.mChanged = true
+             * VH_3.shadowing = VH_2
+             *
+             * Because VH_2 already has an animation, it will be cancelled. At this point VH_2 has
+             * both shadowing and shadowed fields set. Shadowing information is obsolete now
+             * because the first animation where VH_2 is newViewHolder is not valid anymore.
+             * We ended up in this case because VH_2 played both roles. On the other hand,
+             * we DO NOT want to clear its changed flag.
+             *
+             * If second change was simply reverting first change, we would find VH_1 in
+             * {@link Recycler#getScrapViewForPosition(int, int, boolean)} and recycle it before
+             * re-using
+             */
+            if (item.mShadowedHolder != null && item.mShadowingHolder == null) { // old vh
+                item.mShadowedHolder = null;
+                item.setFlags(~ViewHolder.FLAG_CHANGED, item.mFlags);
+            }
+            // always null this because an OldViewHolder can never become NewViewHolder w/o being
+            // recycled.
+            item.mShadowingHolder = null;
+            if (!item.shouldBeKeptAsChild()) {
+                removeAnimatingView(item.itemView);
+            }
+        }
+    };
+
+    /**
+     * This class defines the animations that take place on items as changes are made
+     * to the adapter.
+     *
+     * Subclasses of ItemAnimator can be used to implement custom animations for actions on
+     * ViewHolder items. The RecyclerView will manage retaining these items while they
+     * are being animated, but implementors must call the appropriate "Starting"
+     * ({@link #dispatchRemoveStarting(ViewHolder)}, {@link #dispatchMoveStarting(ViewHolder)},
+     * {@link #dispatchChangeStarting(ViewHolder, boolean)}, or
+     * {@link #dispatchAddStarting(ViewHolder)})
+     * and "Finished" ({@link #dispatchRemoveFinished(ViewHolder)},
+     * {@link #dispatchMoveFinished(ViewHolder)},
+     * {@link #dispatchChangeFinished(ViewHolder, boolean)},
+     * or {@link #dispatchAddFinished(ViewHolder)}) methods when each item animation is
+     * being started and ended.
+     *
+     * <p>By default, RecyclerView uses {@link DefaultItemAnimator}</p>
+     *
+     * @see #setItemAnimator(ItemAnimator)
+     */
+    public static abstract class ItemAnimator {
+
+        private ItemAnimatorListener mListener = null;
+        private ArrayList<ItemAnimatorFinishedListener> mFinishedListeners =
+                new ArrayList<ItemAnimatorFinishedListener>();
+
+        private long mAddDuration = 120;
+        private long mRemoveDuration = 120;
+        private long mMoveDuration = 250;
+        private long mChangeDuration = 250;
+
+        private boolean mSupportsChangeAnimations = true;
+
+        /**
+         * Gets the current duration for which all move animations will run.
+         *
+         * @return The current move duration
+         */
+        public long getMoveDuration() {
+            return mMoveDuration;
+        }
+
+        /**
+         * Sets the duration for which all move animations will run.
+         *
+         * @param moveDuration The move duration
+         */
+        public void setMoveDuration(long moveDuration) {
+            mMoveDuration = moveDuration;
+        }
+
+        /**
+         * Gets the current duration for which all add animations will run.
+         *
+         * @return The current add duration
+         */
+        public long getAddDuration() {
+            return mAddDuration;
+        }
+
+        /**
+         * Sets the duration for which all add animations will run.
+         *
+         * @param addDuration The add duration
+         */
+        public void setAddDuration(long addDuration) {
+            mAddDuration = addDuration;
+        }
+
+        /**
+         * Gets the current duration for which all remove animations will run.
+         *
+         * @return The current remove duration
+         */
+        public long getRemoveDuration() {
+            return mRemoveDuration;
+        }
+
+        /**
+         * Sets the duration for which all remove animations will run.
+         *
+         * @param removeDuration The remove duration
+         */
+        public void setRemoveDuration(long removeDuration) {
+            mRemoveDuration = removeDuration;
+        }
+
+        /**
+         * Gets the current duration for which all change animations will run.
+         *
+         * @return The current change duration
+         */
+        public long getChangeDuration() {
+            return mChangeDuration;
+        }
+
+        /**
+         * Sets the duration for which all change animations will run.
+         *
+         * @param changeDuration The change duration
+         */
+        public void setChangeDuration(long changeDuration) {
+            mChangeDuration = changeDuration;
+        }
+
+        /**
+         * Returns whether this ItemAnimator supports animations of change events.
+         *
+         * @return true if change animations are supported, false otherwise
+         */
+        public boolean getSupportsChangeAnimations() {
+            return mSupportsChangeAnimations;
+        }
+
+        /**
+         * Sets whether this ItemAnimator supports animations of item change events.
+         * If you set this property to false, actions on the data set which change the
+         * contents of items will not be animated. What those animations are is left
+         * up to the discretion of the ItemAnimator subclass, in its
+         * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)} implementation.
+         * The value of this property is true by default.
+         *
+         * @see Adapter#notifyItemChanged(int)
+         * @see Adapter#notifyItemRangeChanged(int, int)
+         *
+         * @param supportsChangeAnimations true if change animations are supported by
+         * this ItemAnimator, false otherwise. If the property is false, the ItemAnimator
+         * will not receive a call to
+         * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)} when changes occur.
+         */
+        public void setSupportsChangeAnimations(boolean supportsChangeAnimations) {
+            mSupportsChangeAnimations = supportsChangeAnimations;
+        }
+
+        /**
+         * Internal only:
+         * Sets the listener that must be called when the animator is finished
+         * animating the item (or immediately if no animation happens). This is set
+         * internally and is not intended to be set by external code.
+         *
+         * @param listener The listener that must be called.
+         */
+        void setListener(ItemAnimatorListener listener) {
+            mListener = listener;
+        }
+
+        /**
+         * Called when there are pending animations waiting to be started. This state
+         * is governed by the return values from {@link #animateAdd(ViewHolder) animateAdd()},
+         * {@link #animateMove(ViewHolder, int, int, int, int) animateMove()}, and
+         * {@link #animateRemove(ViewHolder) animateRemove()}, which inform the
+         * RecyclerView that the ItemAnimator wants to be called later to start the
+         * associated animations. runPendingAnimations() will be scheduled to be run
+         * on the next frame.
+         */
+        abstract public void runPendingAnimations();
+
+        /**
+         * Called when an item is removed from the RecyclerView. Implementors can choose
+         * whether and how to animate that change, but must always call
+         * {@link #dispatchRemoveFinished(ViewHolder)} when done, either
+         * immediately (if no animation will occur) or after the animation actually finishes.
+         * The return value indicates whether an animation has been set up and whether the
+         * ItemAnimator's {@link #runPendingAnimations()} method should be called at the
+         * next opportunity. This mechanism allows ItemAnimator to set up individual animations
+         * as separate calls to {@link #animateAdd(ViewHolder) animateAdd()},
+         * {@link #animateMove(ViewHolder, int, int, int, int) animateMove()},
+         * {@link #animateRemove(ViewHolder) animateRemove()}, and
+         * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)} come in one by one,
+         * then start the animations together in the later call to {@link #runPendingAnimations()}.
+         *
+         * <p>This method may also be called for disappearing items which continue to exist in the
+         * RecyclerView, but for which the system does not have enough information to animate
+         * them out of view. In that case, the default animation for removing items is run
+         * on those items as well.</p>
+         *
+         * @param holder The item that is being removed.
+         * @return true if a later call to {@link #runPendingAnimations()} is requested,
+         * false otherwise.
+         */
+        abstract public boolean animateRemove(ViewHolder holder);
+
+        /**
+         * Called when an item is added to the RecyclerView. Implementors can choose
+         * whether and how to animate that change, but must always call
+         * {@link #dispatchAddFinished(ViewHolder)} when done, either
+         * immediately (if no animation will occur) or after the animation actually finishes.
+         * The return value indicates whether an animation has been set up and whether the
+         * ItemAnimator's {@link #runPendingAnimations()} method should be called at the
+         * next opportunity. This mechanism allows ItemAnimator to set up individual animations
+         * as separate calls to {@link #animateAdd(ViewHolder) animateAdd()},
+         * {@link #animateMove(ViewHolder, int, int, int, int) animateMove()},
+         * {@link #animateRemove(ViewHolder) animateRemove()}, and
+         * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)} come in one by one,
+         * then start the animations together in the later call to {@link #runPendingAnimations()}.
+         *
+         * <p>This method may also be called for appearing items which were already in the
+         * RecyclerView, but for which the system does not have enough information to animate
+         * them into view. In that case, the default animation for adding items is run
+         * on those items as well.</p>
+         *
+         * @param holder The item that is being added.
+         * @return true if a later call to {@link #runPendingAnimations()} is requested,
+         * false otherwise.
+         */
+        abstract public boolean animateAdd(ViewHolder holder);
+
+        /**
+         * Called when an item is moved in the RecyclerView. Implementors can choose
+         * whether and how to animate that change, but must always call
+         * {@link #dispatchMoveFinished(ViewHolder)} when done, either
+         * immediately (if no animation will occur) or after the animation actually finishes.
+         * The return value indicates whether an animation has been set up and whether the
+         * ItemAnimator's {@link #runPendingAnimations()} method should be called at the
+         * next opportunity. This mechanism allows ItemAnimator to set up individual animations
+         * as separate calls to {@link #animateAdd(ViewHolder) animateAdd()},
+         * {@link #animateMove(ViewHolder, int, int, int, int) animateMove()},
+         * {@link #animateRemove(ViewHolder) animateRemove()}, and
+         * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)} come in one by one,
+         * then start the animations together in the later call to {@link #runPendingAnimations()}.
+         *
+         * @param holder The item that is being moved.
+         * @return true if a later call to {@link #runPendingAnimations()} is requested,
+         * false otherwise.
+         */
+        abstract public boolean animateMove(ViewHolder holder, int fromX, int fromY,
+                int toX, int toY);
+
+        /**
+         * Called when an item is changed in the RecyclerView, as indicated by a call to
+         * {@link Adapter#notifyItemChanged(int)} or
+         * {@link Adapter#notifyItemRangeChanged(int, int)}.
+         * <p>
+         * Implementers can choose whether and how to animate changes, but must always call
+         * {@link #dispatchChangeFinished(ViewHolder, boolean)} for each non-null ViewHolder,
+         * either immediately (if no animation will occur) or after the animation actually finishes.
+         * The return value indicates whether an animation has been set up and whether the
+         * ItemAnimator's {@link #runPendingAnimations()} method should be called at the
+         * next opportunity. This mechanism allows ItemAnimator to set up individual animations
+         * as separate calls to {@link #animateAdd(ViewHolder) animateAdd()},
+         * {@link #animateMove(ViewHolder, int, int, int, int) animateMove()},
+         * {@link #animateRemove(ViewHolder) animateRemove()}, and
+         * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)} come in one by one,
+         * then start the animations together in the later call to {@link #runPendingAnimations()}.
+         *
+         * @param oldHolder The original item that changed.
+         * @param newHolder The new item that was created with the changed content. Might be null
+         * @param fromLeft  Left of the old view holder
+         * @param fromTop   Top of the old view holder
+         * @param toLeft    Left of the new view holder
+         * @param toTop     Top of the new view holder
+         * @return true if a later call to {@link #runPendingAnimations()} is requested,
+         * false otherwise.
+         */
+        abstract public boolean animateChange(ViewHolder oldHolder,
+                ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop);
+
+
+        /**
+         * Method to be called by subclasses when a remove animation is done.
+         *
+         * @param item The item which has been removed
+         */
+        public final void dispatchRemoveFinished(ViewHolder item) {
+            onRemoveFinished(item);
+            if (mListener != null) {
+                mListener.onRemoveFinished(item);
+            }
+        }
+
+        /**
+         * Method to be called by subclasses when a move animation is done.
+         *
+         * @param item The item which has been moved
+         */
+        public final void dispatchMoveFinished(ViewHolder item) {
+            onMoveFinished(item);
+            if (mListener != null) {
+                mListener.onMoveFinished(item);
+            }
+        }
+
+        /**
+         * Method to be called by subclasses when an add animation is done.
+         *
+         * @param item The item which has been added
+         */
+        public final void dispatchAddFinished(ViewHolder item) {
+            onAddFinished(item);
+            if (mListener != null) {
+                mListener.onAddFinished(item);
+            }
+        }
+
+        /**
+         * Method to be called by subclasses when a change animation is done.
+         *
+         * @see #animateChange(ViewHolder, ViewHolder, int, int, int, int)
+         * @param item The item which has been changed (this method must be called for
+         * each non-null ViewHolder passed into
+         * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)}).
+         * @param oldItem true if this is the old item that was changed, false if
+         * it is the new item that replaced the old item.
+         */
+        public final void dispatchChangeFinished(ViewHolder item, boolean oldItem) {
+            onChangeFinished(item, oldItem);
+            if (mListener != null) {
+                mListener.onChangeFinished(item);
+            }
+        }
+
+        /**
+         * Method to be called by subclasses when a remove animation is being started.
+         *
+         * @param item The item being removed
+         */
+        public final void dispatchRemoveStarting(ViewHolder item) {
+            onRemoveStarting(item);
+        }
+
+        /**
+         * Method to be called by subclasses when a move animation is being started.
+         *
+         * @param item The item being moved
+         */
+        public final void dispatchMoveStarting(ViewHolder item) {
+            onMoveStarting(item);
+        }
+
+        /**
+         * Method to be called by subclasses when an add animation is being started.
+         *
+         * @param item The item being added
+         */
+        public final void dispatchAddStarting(ViewHolder item) {
+            onAddStarting(item);
+        }
+
+        /**
+         * Method to be called by subclasses when a change animation is being started.
+         *
+         * @param item The item which has been changed (this method must be called for
+         * each non-null ViewHolder passed into
+         * {@link #animateChange(ViewHolder, ViewHolder, int, int, int, int)}).
+         * @param oldItem true if this is the old item that was changed, false if
+         * it is the new item that replaced the old item.
+         */
+        public final void dispatchChangeStarting(ViewHolder item, boolean oldItem) {
+            onChangeStarting(item, oldItem);
+        }
+
+        /**
+         * Method called when an animation on a view should be ended immediately.
+         * This could happen when other events, like scrolling, occur, so that
+         * animating views can be quickly put into their proper end locations.
+         * Implementations should ensure that any animations running on the item
+         * are canceled and affected properties are set to their end values.
+         * Also, appropriate dispatch methods (e.g., {@link #dispatchAddFinished(ViewHolder)}
+         * should be called since the animations are effectively done when this
+         * method is called.
+         *
+         * @param item The item for which an animation should be stopped.
+         */
+        abstract public void endAnimation(ViewHolder item);
+
+        /**
+         * Method called when all item animations should be ended immediately.
+         * This could happen when other events, like scrolling, occur, so that
+         * animating views can be quickly put into their proper end locations.
+         * Implementations should ensure that any animations running on any items
+         * are canceled and affected properties are set to their end values.
+         * Also, appropriate dispatch methods (e.g., {@link #dispatchAddFinished(ViewHolder)}
+         * should be called since the animations are effectively done when this
+         * method is called.
+         */
+        abstract public void endAnimations();
+
+        /**
+         * Method which returns whether there are any item animations currently running.
+         * This method can be used to determine whether to delay other actions until
+         * animations end.
+         *
+         * @return true if there are any item animations currently running, false otherwise.
+         */
+        abstract public boolean isRunning();
+
+        /**
+         * Like {@link #isRunning()}, this method returns whether there are any item
+         * animations currently running. Addtionally, the listener passed in will be called
+         * when there are no item animations running, either immediately (before the method
+         * returns) if no animations are currently running, or when the currently running
+         * animations are {@link #dispatchAnimationsFinished() finished}.
+         *
+         * <p>Note that the listener is transient - it is either called immediately and not
+         * stored at all, or stored only until it is called when running animations
+         * are finished sometime later.</p>
+         *
+         * @param listener A listener to be called immediately if no animations are running
+         * or later when currently-running animations have finished. A null listener is
+         * equivalent to calling {@link #isRunning()}.
+         * @return true if there are any item animations currently running, false otherwise.
+         */
+        public final boolean isRunning(ItemAnimatorFinishedListener listener) {
+            boolean running = isRunning();
+            if (listener != null) {
+                if (!running) {
+                    listener.onAnimationsFinished();
+                } else {
+                    mFinishedListeners.add(listener);
+                }
+            }
+            return running;
+        }
+
+        /**
+         * The interface to be implemented by listeners to animation events from this
+         * ItemAnimator. This is used internally and is not intended for developers to
+         * create directly.
+         */
+        interface ItemAnimatorListener {
+            void onRemoveFinished(ViewHolder item);
+            void onAddFinished(ViewHolder item);
+            void onMoveFinished(ViewHolder item);
+            void onChangeFinished(ViewHolder item);
+        }
+
+        /**
+         * This method should be called by ItemAnimator implementations to notify
+         * any listeners that all pending and active item animations are finished.
+         */
+        public final void dispatchAnimationsFinished() {
+            final int count = mFinishedListeners.size();
+            for (int i = 0; i < count; ++i) {
+                mFinishedListeners.get(i).onAnimationsFinished();
+            }
+            mFinishedListeners.clear();
+        }
+
+        /**
+         * This interface is used to inform listeners when all pending or running animations
+         * in an ItemAnimator are finished. This can be used, for example, to delay an action
+         * in a data set until currently-running animations are complete.
+         *
+         * @see #isRunning(ItemAnimatorFinishedListener)
+         */
+        public interface ItemAnimatorFinishedListener {
+            void onAnimationsFinished();
+        }
+
+        /**
+         * Called when a remove animation is being started on the given ViewHolder.
+         * The default implementation does nothing. Subclasses may wish to override
+         * this method to handle any ViewHolder-specific operations linked to animation
+         * lifecycles.
+         *
+         * @param item The ViewHolder being animated.
+         */
+        public void onRemoveStarting(ViewHolder item) {}
+
+        /**
+         * Called when a remove animation has ended on the given ViewHolder.
+         * The default implementation does nothing. Subclasses may wish to override
+         * this method to handle any ViewHolder-specific operations linked to animation
+         * lifecycles.
+         *
+         * @param item The ViewHolder being animated.
+         */
+        public void onRemoveFinished(ViewHolder item) {}
+
+        /**
+         * Called when an add animation is being started on the given ViewHolder.
+         * The default implementation does nothing. Subclasses may wish to override
+         * this method to handle any ViewHolder-specific operations linked to animation
+         * lifecycles.
+         *
+         * @param item The ViewHolder being animated.
+         */
+        public void onAddStarting(ViewHolder item) {}
+
+        /**
+         * Called when an add animation has ended on the given ViewHolder.
+         * The default implementation does nothing. Subclasses may wish to override
+         * this method to handle any ViewHolder-specific operations linked to animation
+         * lifecycles.
+         *
+         * @param item The ViewHolder being animated.
+         */
+        public void onAddFinished(ViewHolder item) {}
+
+        /**
+         * Called when a move animation is being started on the given ViewHolder.
+         * The default implementation does nothing. Subclasses may wish to override
+         * this method to handle any ViewHolder-specific operations linked to animation
+         * lifecycles.
+         *
+         * @param item The ViewHolder being animated.
+         */
+        public void onMoveStarting(ViewHolder item) {}
+
+        /**
+         * Called when a move animation has ended on the given ViewHolder.
+         * The default implementation does nothing. Subclasses may wish to override
+         * this method to handle any ViewHolder-specific operations linked to animation
+         * lifecycles.
+         *
+         * @param item The ViewHolder being animated.
+         */
+        public void onMoveFinished(ViewHolder item) {}
+
+        /**
+         * Called when a change animation is being started on the given ViewHolder.
+         * The default implementation does nothing. Subclasses may wish to override
+         * this method to handle any ViewHolder-specific operations linked to animation
+         * lifecycles.
+         *
+         * @param item The ViewHolder being animated.
+         * @param oldItem true if this is the old item that was changed, false if
+         * it is the new item that replaced the old item.
+         */
+        public void onChangeStarting(ViewHolder item, boolean oldItem) {}
+
+        /**
+         * Called when a change animation has ended on the given ViewHolder.
+         * The default implementation does nothing. Subclasses may wish to override
+         * this method to handle any ViewHolder-specific operations linked to animation
+         * lifecycles.
+         *
+         * @param item The ViewHolder being animated.
+         * @param oldItem true if this is the old item that was changed, false if
+         * it is the new item that replaced the old item.
+         */
+        public void onChangeFinished(ViewHolder item, boolean oldItem) {}
+
+    }
+
+    /**
+     * Internal data structure that holds information about an item's bounds.
+     * This information is used in calculating item animations.
+     */
+    private static class ItemHolderInfo {
+        ViewHolder holder;
+        int left, top, right, bottom;
+
+        ItemHolderInfo(ViewHolder holder, int left, int top, int right, int bottom) {
+            this.holder = holder;
+            this.left = left;
+            this.top = top;
+            this.right = right;
+            this.bottom = bottom;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerViewAccessibilityDelegate.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerViewAccessibilityDelegate.java
new file mode 100644
index 000000000..f1cd3b0b2
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/RecyclerViewAccessibilityDelegate.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+
+import android.os.Bundle;
+import android.support.v4.view.AccessibilityDelegateCompat;
+import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
+import android.view.View;
+import android.view.accessibility.AccessibilityEvent;
+
+/**
+ * The AccessibilityDelegate used by RecyclerView.
+ * <p>
+ * This class handles basic accessibility actions and delegates them to LayoutManager.
+ */
+public class RecyclerViewAccessibilityDelegate extends AccessibilityDelegateCompat {
+    final RecyclerView mRecyclerView;
+
+
+    public RecyclerViewAccessibilityDelegate(RecyclerView recyclerView) {
+        mRecyclerView = recyclerView;
+    }
+
+    private boolean shouldIgnore() {
+        return mRecyclerView.hasPendingAdapterUpdates();
+    }
+
+    @Override
+    public boolean performAccessibilityAction(View host, int action, Bundle args) {
+        if (super.performAccessibilityAction(host, action, args)) {
+            return true;
+        }
+        if (!shouldIgnore() && mRecyclerView.getLayoutManager() != null) {
+            return mRecyclerView.getLayoutManager().performAccessibilityAction(action, args);
+        }
+
+        return false;
+    }
+
+    @Override
+    public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfoCompat info) {
+        super.onInitializeAccessibilityNodeInfo(host, info);
+        info.setClassName(RecyclerView.class.getName());
+        if (!shouldIgnore() && mRecyclerView.getLayoutManager() != null) {
+            mRecyclerView.getLayoutManager().onInitializeAccessibilityNodeInfo(info);
+        }
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(View host, AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(host, event);
+        event.setClassName(RecyclerView.class.getName());
+        if (host instanceof RecyclerView && !shouldIgnore()) {
+            RecyclerView rv = (RecyclerView) host;
+            if (rv.getLayoutManager() != null) {
+                rv.getLayoutManager().onInitializeAccessibilityEvent(event);
+            }
+        }
+    }
+
+    AccessibilityDelegateCompat getItemDelegate() {
+        return mItemDelegate;
+    }
+
+    final AccessibilityDelegateCompat mItemDelegate = new AccessibilityDelegateCompat() {
+        @Override
+        public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfoCompat info) {
+            super.onInitializeAccessibilityNodeInfo(host, info);
+            if (!shouldIgnore() && mRecyclerView.getLayoutManager() != null) {
+                mRecyclerView.getLayoutManager().
+                        onInitializeAccessibilityNodeInfoForItem(host, info);
+            }
+        }
+
+        @Override
+        public boolean performAccessibilityAction(View host, int action, Bundle args) {
+            if (super.performAccessibilityAction(host, action, args)) {
+                return true;
+            }
+            if (!shouldIgnore() && mRecyclerView.getLayoutManager() != null) {
+                return mRecyclerView.getLayoutManager().
+                        performAccessibilityActionForItem(host, action, args);
+            }
+            return false;
+        }
+    };
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/ScrollbarHelper.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/ScrollbarHelper.java
new file mode 100644
index 000000000..9df5bba2f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/ScrollbarHelper.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.telegram.android.support.widget;
+
+import android.view.View;
+
+/**
+ * A helper class to do scroll offset calculations.
+ */
+class ScrollbarHelper {
+
+    /**
+     * @param startChild View closest to start of the list. (top or left)
+     * @param endChild   View closest to end of the list (bottom or right)
+     */
+    static int computeScrollOffset(RecyclerView.State state, OrientationHelper orientation,
+            View startChild, View endChild, RecyclerView.LayoutManager lm,
+            boolean smoothScrollbarEnabled, boolean reverseLayout) {
+        if (lm.getChildCount() == 0 || state.getItemCount() == 0 || startChild == null ||
+                endChild == null) {
+            return 0;
+        }
+        final int minPosition = Math.min(lm.getPosition(startChild),
+                lm.getPosition(endChild));
+        final int maxPosition = Math.max(lm.getPosition(startChild),
+                lm.getPosition(endChild));
+        final int itemsBefore = reverseLayout
+                ? Math.max(0, state.getItemCount() - maxPosition - 1)
+                : Math.max(0, minPosition);
+        if (!smoothScrollbarEnabled) {
+            return itemsBefore;
+        }
+        final int laidOutArea = Math.abs(orientation.getDecoratedEnd(endChild) -
+                orientation.getDecoratedStart(startChild));
+        final int itemRange = Math.abs(lm.getPosition(startChild) -
+                lm.getPosition(endChild)) + 1;
+        final float avgSizePerRow = (float) laidOutArea / itemRange;
+
+        return Math.round(itemsBefore * avgSizePerRow + (orientation.getStartAfterPadding()
+                - orientation.getDecoratedStart(startChild)));
+    }
+
+    /**
+     * @param startChild View closest to start of the list. (top or left)
+     * @param endChild   View closest to end of the list (bottom or right)
+     */
+    static int computeScrollExtent(RecyclerView.State state, OrientationHelper orientation,
+            View startChild, View endChild, RecyclerView.LayoutManager lm,
+            boolean smoothScrollbarEnabled) {
+        if (lm.getChildCount() == 0 || state.getItemCount() == 0 || startChild == null ||
+                endChild == null) {
+            return 0;
+        }
+        if (!smoothScrollbarEnabled) {
+            return Math.abs(lm.getPosition(startChild) - lm.getPosition(endChild)) + 1;
+        }
+        final int extend = orientation.getDecoratedEnd(endChild)
+                - orientation.getDecoratedStart(startChild);
+        return Math.min(orientation.getTotalSpace(), extend);
+    }
+
+    /**
+     * @param startChild View closest to start of the list. (top or left)
+     * @param endChild   View closest to end of the list (bottom or right)
+     */
+    static int computeScrollRange(RecyclerView.State state, OrientationHelper orientation,
+            View startChild, View endChild, RecyclerView.LayoutManager lm,
+            boolean smoothScrollbarEnabled) {
+        if (lm.getChildCount() == 0 || state.getItemCount() == 0 || startChild == null ||
+                endChild == null) {
+            return 0;
+        }
+        if (!smoothScrollbarEnabled) {
+            return state.getItemCount();
+        }
+        // smooth scrollbar enabled. try to estimate better.
+        final int laidOutArea = orientation.getDecoratedEnd(endChild) -
+                orientation.getDecoratedStart(startChild);
+        final int laidOutRange = Math.abs(lm.getPosition(startChild) -
+                lm.getPosition(endChild))
+                + 1;
+        // estimate a size for full list.
+        return (int) ((float) laidOutArea / laidOutRange * state.getItemCount());
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/StaggeredGridLayoutManager.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/StaggeredGridLayoutManager.java
new file mode 100644
index 000000000..d28434a60
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/StaggeredGridLayoutManager.java
@@ -0,0 +1,2763 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget;
+
+import android.content.Context;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.v4.view.ViewCompat;
+import android.support.v4.view.accessibility.AccessibilityEventCompat;
+import android.support.v4.view.accessibility.AccessibilityNodeInfoCompat;
+import android.support.v4.view.accessibility.AccessibilityRecordCompat;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.accessibility.AccessibilityEvent;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.List;
+
+import static org.telegram.android.support.widget.LayoutState.LAYOUT_START;
+import static org.telegram.android.support.widget.LayoutState.LAYOUT_END;
+import static org.telegram.android.support.widget.LayoutState.ITEM_DIRECTION_HEAD;
+import static org.telegram.android.support.widget.LayoutState.ITEM_DIRECTION_TAIL;
+import static org.telegram.android.support.widget.RecyclerView.NO_POSITION;
+
+/**
+ * A LayoutManager that lays out children in a staggered grid formation.
+ * It supports horizontal & vertical layout as well as an ability to layout children in reverse.
+ * <p>
+ * Staggered grids are likely to have gaps at the edges of the layout. To avoid these gaps,
+ * StaggeredGridLayoutManager can offset spans independently or move items between spans. You can
+ * control this behavior via {@link #setGapStrategy(int)}.
+ */
+public class StaggeredGridLayoutManager extends RecyclerView.LayoutManager {
+
+    public static final String TAG = "StaggeredGridLayoutManager";
+
+    private static final boolean DEBUG = false;
+
+    public static final int HORIZONTAL = OrientationHelper.HORIZONTAL;
+
+    public static final int VERTICAL = OrientationHelper.VERTICAL;
+
+    /**
+     * Does not do anything to hide gaps.
+     */
+    public static final int GAP_HANDLING_NONE = 0;
+
+    @Deprecated
+    public static final int GAP_HANDLING_LAZY = 1;
+
+    /**
+     * When scroll state is changed to {@link RecyclerView#SCROLL_STATE_IDLE}, StaggeredGrid will
+     * check if there are gaps in the because of full span items. If it finds, it will re-layout
+     * and move items to correct positions with animations.
+     * <p>
+     * For example, if LayoutManager ends up with the following layout due to adapter changes:
+     * <pre>
+     * AAA
+     * _BC
+     * DDD
+     * </pre>
+     * <p>
+     * It will animate to the following state:
+     * <pre>
+     * AAA
+     * BC_
+     * DDD
+     * </pre>
+     */
+    public static final int GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS = 2;
+
+    private static final int INVALID_OFFSET = Integer.MIN_VALUE;
+
+    /**
+     * Number of spans
+     */
+    private int mSpanCount = -1;
+
+    private Span[] mSpans;
+
+    /**
+     * Primary orientation is the layout's orientation, secondary orientation is the orientation
+     * for spans. Having both makes code much cleaner for calculations.
+     */
+    OrientationHelper mPrimaryOrientation;
+    OrientationHelper mSecondaryOrientation;
+
+    private int mOrientation;
+
+    /**
+     * The width or height per span, depending on the orientation.
+     */
+    private int mSizePerSpan;
+
+    private LayoutState mLayoutState;
+
+    private boolean mReverseLayout = false;
+
+    /**
+     * Aggregated reverse layout value that takes RTL into account.
+     */
+    boolean mShouldReverseLayout = false;
+
+    /**
+     * Temporary variable used during fill method to check which spans needs to be filled.
+     */
+    private BitSet mRemainingSpans;
+
+    /**
+     * When LayoutManager needs to scroll to a position, it sets this variable and requests a
+     * layout which will check this variable and re-layout accordingly.
+     */
+    int mPendingScrollPosition = NO_POSITION;
+
+    /**
+     * Used to keep the offset value when {@link #scrollToPositionWithOffset(int, int)} is
+     * called.
+     */
+    int mPendingScrollPositionOffset = INVALID_OFFSET;
+
+    /**
+     * Keeps the mapping between the adapter positions and spans. This is necessary to provide
+     * a consistent experience when user scrolls the list.
+     */
+    LazySpanLookup mLazySpanLookup = new LazySpanLookup();
+
+    /**
+     * how we handle gaps in UI.
+     */
+    private int mGapStrategy = GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS;
+
+    /**
+     * Saved state needs this information to properly layout on restore.
+     */
+    private boolean mLastLayoutFromEnd;
+
+    /**
+     * Saved state and onLayout needs this information to re-layout properly
+     */
+    private boolean mLastLayoutRTL;
+
+    /**
+     * SavedState is not handled until a layout happens. This is where we keep it until next
+     * layout.
+     */
+    private SavedState mPendingSavedState;
+
+    /**
+     * Re-used measurement specs. updated by onLayout.
+     */
+    private int mFullSizeSpec, mWidthSpec, mHeightSpec;
+
+    /**
+     * Re-used rectangle to get child decor offsets.
+     */
+    private final Rect mTmpRect = new Rect();
+
+    /**
+     * Re-used anchor info.
+     */
+    private final AnchorInfo mAnchorInfo = new AnchorInfo();
+
+    /**
+     * If a full span item is invalid / or created in reverse direction; it may create gaps in
+     * the UI. While laying out, if such case is detected, we set this flag.
+     * <p>
+     * After scrolling stops, we check this flag and if it is set, re-layout.
+     */
+    private boolean mLaidOutInvalidFullSpan = false;
+
+    /**
+     * Works the same way as {@link android.widget.AbsListView#setSmoothScrollbarEnabled(boolean)}.
+     * see {@link android.widget.AbsListView#setSmoothScrollbarEnabled(boolean)}
+     */
+    private boolean mSmoothScrollbarEnabled = true;
+
+    private final Runnable mCheckForGapsRunnable = new Runnable() {
+        @Override
+        public void run() {
+            checkForGaps();
+        }
+    };
+
+    /**
+     * Creates a StaggeredGridLayoutManager with given parameters.
+     *
+     * @param spanCount   If orientation is vertical, spanCount is number of columns. If
+     *                    orientation is horizontal, spanCount is number of rows.
+     * @param orientation {@link #VERTICAL} or {@link #HORIZONTAL}
+     */
+    public StaggeredGridLayoutManager(int spanCount, int orientation) {
+        mOrientation = orientation;
+        setSpanCount(spanCount);
+    }
+
+    /**
+     * Checks for gaps in the UI that may be caused by adapter changes.
+     * <p>
+     * When a full span item is laid out in reverse direction, it sets a flag which we check when
+     * scroll is stopped (or re-layout happens) and re-layout after first valid item.
+     */
+    private boolean checkForGaps() {
+        if (getChildCount() == 0 || mGapStrategy == GAP_HANDLING_NONE || !isAttachedToWindow()) {
+            return false;
+        }
+        final int minPos, maxPos;
+        if (mShouldReverseLayout) {
+            minPos = getLastChildPosition();
+            maxPos = getFirstChildPosition();
+        } else {
+            minPos = getFirstChildPosition();
+            maxPos = getLastChildPosition();
+        }
+        if (minPos == 0) {
+            View gapView = hasGapsToFix();
+            if (gapView != null) {
+                mLazySpanLookup.clear();
+                requestSimpleAnimationsInNextLayout();
+                requestLayout();
+                return true;
+            }
+        }
+        if (!mLaidOutInvalidFullSpan) {
+            return false;
+        }
+        int invalidGapDir = mShouldReverseLayout ? LAYOUT_START : LAYOUT_END;
+        final LazySpanLookup.FullSpanItem invalidFsi = mLazySpanLookup
+                .getFirstFullSpanItemInRange(minPos, maxPos + 1, invalidGapDir, true);
+        if (invalidFsi == null) {
+            mLaidOutInvalidFullSpan = false;
+            mLazySpanLookup.forceInvalidateAfter(maxPos + 1);
+            return false;
+        }
+        final LazySpanLookup.FullSpanItem validFsi = mLazySpanLookup
+                .getFirstFullSpanItemInRange(minPos, invalidFsi.mPosition,
+                        invalidGapDir * -1, true);
+        if (validFsi == null) {
+            mLazySpanLookup.forceInvalidateAfter(invalidFsi.mPosition);
+        } else {
+            mLazySpanLookup.forceInvalidateAfter(validFsi.mPosition + 1);
+        }
+        requestSimpleAnimationsInNextLayout();
+        requestLayout();
+        return true;
+    }
+
+    @Override
+    public void onScrollStateChanged(int state) {
+        if (state == RecyclerView.SCROLL_STATE_IDLE) {
+            checkForGaps();
+        }
+    }
+
+    @Override
+    public void onDetachedFromWindow(RecyclerView view, RecyclerView.Recycler recycler) {
+        removeCallbacks(mCheckForGapsRunnable);
+        for (int i = 0; i < mSpanCount; i++) {
+            mSpans[i].clear();
+        }
+    }
+
+    /**
+     * Checks for gaps if we've reached to the top of the list.
+     * <p>
+     * Intermediate gaps created by full span items are tracked via mLaidOutInvalidFullSpan field.
+     */
+    View hasGapsToFix() {
+        int startChildIndex = 0;
+        int endChildIndex = getChildCount() - 1;
+        BitSet mSpansToCheck = new BitSet(mSpanCount);
+        mSpansToCheck.set(0, mSpanCount, true);
+
+        final int firstChildIndex, childLimit;
+        final int preferredSpanDir = mOrientation == VERTICAL && isLayoutRTL() ? 1 : -1;
+
+        if (mShouldReverseLayout) {
+            firstChildIndex = endChildIndex;
+            childLimit = startChildIndex - 1;
+        } else {
+            firstChildIndex = startChildIndex;
+            childLimit = endChildIndex + 1;
+        }
+        final int nextChildDiff = firstChildIndex < childLimit ? 1 : -1;
+        for (int i = firstChildIndex; i != childLimit; i += nextChildDiff) {
+            View child = getChildAt(i);
+            LayoutParams lp = (LayoutParams) child.getLayoutParams();
+            if (mSpansToCheck.get(lp.mSpan.mIndex)) {
+                if (checkSpanForGap(lp.mSpan)) {
+                    return child;
+                }
+                mSpansToCheck.clear(lp.mSpan.mIndex);
+            }
+            if (lp.mFullSpan) {
+                continue; // quick reject
+            }
+
+            if (i + nextChildDiff != childLimit) {
+                View nextChild = getChildAt(i + nextChildDiff);
+                boolean compareSpans = false;
+                if (mShouldReverseLayout) {
+                    // ensure child's end is below nextChild's end
+                    int myEnd = mPrimaryOrientation.getDecoratedEnd(child);
+                    int nextEnd = mPrimaryOrientation.getDecoratedEnd(nextChild);
+                    if (myEnd < nextEnd) {
+                        return child;//i should have a better position
+                    } else if (myEnd == nextEnd) {
+                        compareSpans = true;
+                    }
+                } else {
+                    int myStart = mPrimaryOrientation.getDecoratedStart(child);
+                    int nextStart = mPrimaryOrientation.getDecoratedStart(nextChild);
+                    if (myStart > nextStart) {
+                        return child;//i should have a better position
+                    } else if (myStart == nextStart) {
+                        compareSpans = true;
+                    }
+                }
+                if (compareSpans) {
+                    // equal, check span indices.
+                    LayoutParams nextLp = (LayoutParams) nextChild.getLayoutParams();
+                    if (lp.mSpan.mIndex - nextLp.mSpan.mIndex < 0 != preferredSpanDir < 0) {
+                        return child;
+                    }
+                }
+            }
+        }
+        // everything looks good
+        return null;
+    }
+
+    private boolean checkSpanForGap(Span span) {
+        if (mShouldReverseLayout) {
+            if (span.getEndLine() < mPrimaryOrientation.getEndAfterPadding()) {
+                return true;
+            }
+        } else if (span.getStartLine() > mPrimaryOrientation.getStartAfterPadding()) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Sets the number of spans for the layout. This will invalidate all of the span assignments
+     * for Views.
+     * <p>
+     * Calling this method will automatically result in a new layout request unless the spanCount
+     * parameter is equal to current span count.
+     *
+     * @param spanCount Number of spans to layout
+     */
+    public void setSpanCount(int spanCount) {
+        assertNotInLayoutOrScroll(null);
+        if (spanCount != mSpanCount) {
+            invalidateSpanAssignments();
+            mSpanCount = spanCount;
+            mRemainingSpans = new BitSet(mSpanCount);
+            mSpans = new Span[mSpanCount];
+            for (int i = 0; i < mSpanCount; i++) {
+                mSpans[i] = new Span(i);
+            }
+            requestLayout();
+        }
+    }
+
+    /**
+     * Sets the orientation of the layout. StaggeredGridLayoutManager will do its best to keep
+     * scroll position if this method is called after views are laid out.
+     *
+     * @param orientation {@link #HORIZONTAL} or {@link #VERTICAL}
+     */
+    public void setOrientation(int orientation) {
+        if (orientation != HORIZONTAL && orientation != VERTICAL) {
+            throw new IllegalArgumentException("invalid orientation.");
+        }
+        assertNotInLayoutOrScroll(null);
+        if (orientation == mOrientation) {
+            return;
+        }
+        mOrientation = orientation;
+        if (mPrimaryOrientation != null && mSecondaryOrientation != null) {
+            // swap
+            OrientationHelper tmp = mPrimaryOrientation;
+            mPrimaryOrientation = mSecondaryOrientation;
+            mSecondaryOrientation = tmp;
+        }
+        requestLayout();
+    }
+
+    /**
+     * Sets whether LayoutManager should start laying out items from the end of the UI. The order
+     * items are traversed is not affected by this call.
+     * <p>
+     * For vertical layout, if it is set to <code>true</code>, first item will be at the bottom of
+     * the list.
+     * <p>
+     * For horizontal layouts, it depends on the layout direction.
+     * When set to true, If {@link RecyclerView} is LTR, than it will layout from RTL, if
+     * {@link RecyclerView}} is RTL, it will layout from LTR.
+     *
+     * @param reverseLayout Whether layout should be in reverse or not
+     */
+    public void setReverseLayout(boolean reverseLayout) {
+        assertNotInLayoutOrScroll(null);
+        if (mPendingSavedState != null && mPendingSavedState.mReverseLayout != reverseLayout) {
+            mPendingSavedState.mReverseLayout = reverseLayout;
+        }
+        mReverseLayout = reverseLayout;
+        requestLayout();
+    }
+
+    /**
+     * Returns the current gap handling strategy for StaggeredGridLayoutManager.
+     * <p>
+     * Staggered grid may have gaps in the layout due to changes in the adapter. To avoid gaps,
+     * StaggeredGridLayoutManager provides 2 options. Check {@link #GAP_HANDLING_NONE} and
+     * {@link #GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS} for details.
+     * <p>
+     * By default, StaggeredGridLayoutManager uses {@link #GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS}.
+     *
+     * @return Current gap handling strategy.
+     * @see #setGapStrategy(int)
+     * @see #GAP_HANDLING_NONE
+     * @see #GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS
+     */
+    public int getGapStrategy() {
+        return mGapStrategy;
+    }
+
+    /**
+     * Sets the gap handling strategy for StaggeredGridLayoutManager. If the gapStrategy parameter
+     * is different than the current strategy, calling this method will trigger a layout request.
+     *
+     * @param gapStrategy The new gap handling strategy. Should be
+     *                    {@link #GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS} or {@link
+     *                    #GAP_HANDLING_NONE}.
+     * @see #getGapStrategy()
+     */
+    public void setGapStrategy(int gapStrategy) {
+        assertNotInLayoutOrScroll(null);
+        if (gapStrategy == mGapStrategy) {
+            return;
+        }
+        if (gapStrategy != GAP_HANDLING_NONE &&
+                gapStrategy != GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS) {
+            throw new IllegalArgumentException("invalid gap strategy. Must be GAP_HANDLING_NONE "
+                    + "or GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS");
+        }
+        mGapStrategy = gapStrategy;
+        requestLayout();
+    }
+
+    @Override
+    public void assertNotInLayoutOrScroll(String message) {
+        if (mPendingSavedState == null) {
+            super.assertNotInLayoutOrScroll(message);
+        }
+    }
+
+    /**
+     * Returns the number of spans laid out by StaggeredGridLayoutManager.
+     *
+     * @return Number of spans in the layout
+     */
+    public int getSpanCount() {
+        return mSpanCount;
+    }
+
+    /**
+     * For consistency, StaggeredGridLayoutManager keeps a mapping between spans and items.
+     * <p>
+     * If you need to cancel current assignments, you can call this method which will clear all
+     * assignments and request a new layout.
+     */
+    public void invalidateSpanAssignments() {
+        mLazySpanLookup.clear();
+        requestLayout();
+    }
+
+    private void ensureOrientationHelper() {
+        if (mPrimaryOrientation == null) {
+            mPrimaryOrientation = OrientationHelper.createOrientationHelper(this, mOrientation);
+            mSecondaryOrientation = OrientationHelper
+                    .createOrientationHelper(this, 1 - mOrientation);
+            mLayoutState = new LayoutState();
+        }
+    }
+
+    /**
+     * Calculates the views' layout order. (e.g. from end to start or start to end)
+     * RTL layout support is applied automatically. So if layout is RTL and
+     * {@link #getReverseLayout()} is {@code true}, elements will be laid out starting from left.
+     */
+    private void resolveShouldLayoutReverse() {
+        // A == B is the same result, but we rather keep it readable
+        if (mOrientation == VERTICAL || !isLayoutRTL()) {
+            mShouldReverseLayout = mReverseLayout;
+        } else {
+            mShouldReverseLayout = !mReverseLayout;
+        }
+    }
+
+    boolean isLayoutRTL() {
+        return getLayoutDirection() == ViewCompat.LAYOUT_DIRECTION_RTL;
+    }
+
+    /**
+     * Returns whether views are laid out in reverse order or not.
+     * <p>
+     * Not that this value is not affected by RecyclerView's layout direction.
+     *
+     * @return True if layout is reversed, false otherwise
+     * @see #setReverseLayout(boolean)
+     */
+    public boolean getReverseLayout() {
+        return mReverseLayout;
+    }
+    @Override
+    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
+        ensureOrientationHelper();
+
+        final AnchorInfo anchorInfo = mAnchorInfo;
+        anchorInfo.reset();
+
+        if (mPendingSavedState != null) {
+            applyPendingSavedState(anchorInfo);
+        } else {
+            resolveShouldLayoutReverse();
+            anchorInfo.mLayoutFromEnd = mShouldReverseLayout;
+        }
+
+        updateAnchorInfoForLayout(state, anchorInfo);
+
+        if (mPendingSavedState == null) {
+            if (anchorInfo.mLayoutFromEnd != mLastLayoutFromEnd ||
+                    isLayoutRTL() != mLastLayoutRTL) {
+                mLazySpanLookup.clear();
+                anchorInfo.mInvalidateOffsets = true;
+            }
+        }
+
+        if (getChildCount() > 0 && (mPendingSavedState == null ||
+                mPendingSavedState.mSpanOffsetsSize < 1)) {
+            if (anchorInfo.mInvalidateOffsets) {
+                for (int i = 0; i < mSpanCount; i++) {
+                    // Scroll to position is set, clear.
+                    mSpans[i].clear();
+                    if (anchorInfo.mOffset != INVALID_OFFSET) {
+                        mSpans[i].setLine(anchorInfo.mOffset);
+                    }
+                }
+            } else {
+                for (int i = 0; i < mSpanCount; i++) {
+                    mSpans[i].cacheReferenceLineAndClear(mShouldReverseLayout, anchorInfo.mOffset);
+                }
+            }
+        }
+        detachAndScrapAttachedViews(recycler);
+        mLaidOutInvalidFullSpan = false;
+        updateMeasureSpecs();
+        if (anchorInfo.mLayoutFromEnd) {
+            // Layout start.
+            updateLayoutStateToFillStart(anchorInfo.mPosition, state);
+            fill(recycler, mLayoutState, state);
+            // Layout end.
+            updateLayoutStateToFillEnd(anchorInfo.mPosition, state);
+            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
+            fill(recycler, mLayoutState, state);
+        } else {
+            // Layout end.
+            updateLayoutStateToFillEnd(anchorInfo.mPosition, state);
+            fill(recycler, mLayoutState, state);
+            // Layout start.
+            updateLayoutStateToFillStart(anchorInfo.mPosition, state);
+            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
+            fill(recycler, mLayoutState, state);
+        }
+
+        if (getChildCount() > 0) {
+            if (mShouldReverseLayout) {
+                fixEndGap(recycler, state, true);
+                fixStartGap(recycler, state, false);
+            } else {
+                fixStartGap(recycler, state, true);
+                fixEndGap(recycler, state, false);
+            }
+        }
+
+        if (!state.isPreLayout()) {
+            final boolean needToCheckForGaps = mGapStrategy != GAP_HANDLING_NONE
+                    && getChildCount() > 0
+                    && (mLaidOutInvalidFullSpan || hasGapsToFix() != null);
+            if (needToCheckForGaps) {
+                removeCallbacks(mCheckForGapsRunnable);
+                postOnAnimation(mCheckForGapsRunnable);
+            }
+            mPendingScrollPosition = NO_POSITION;
+            mPendingScrollPositionOffset = INVALID_OFFSET;
+        }
+        mLastLayoutFromEnd = anchorInfo.mLayoutFromEnd;
+        mLastLayoutRTL = isLayoutRTL();
+        mPendingSavedState = null; // we don't need this anymore
+    }
+
+    private void applyPendingSavedState(AnchorInfo anchorInfo) {
+        if (DEBUG) {
+            Log.d(TAG, "found saved state: " + mPendingSavedState);
+        }
+        if (mPendingSavedState.mSpanOffsetsSize > 0) {
+            if (mPendingSavedState.mSpanOffsetsSize == mSpanCount) {
+                for (int i = 0; i < mSpanCount; i++) {
+                    mSpans[i].clear();
+                    int line = mPendingSavedState.mSpanOffsets[i];
+                    if (line != Span.INVALID_LINE) {
+                        if (mPendingSavedState.mAnchorLayoutFromEnd) {
+                            line += mPrimaryOrientation.getEndAfterPadding();
+                        } else {
+                            line += mPrimaryOrientation.getStartAfterPadding();
+                        }
+                    }
+                    mSpans[i].setLine(line);
+                }
+            } else {
+                mPendingSavedState.invalidateSpanInfo();
+                mPendingSavedState.mAnchorPosition = mPendingSavedState.mVisibleAnchorPosition;
+            }
+        }
+        mLastLayoutRTL = mPendingSavedState.mLastLayoutRTL;
+        setReverseLayout(mPendingSavedState.mReverseLayout);
+        resolveShouldLayoutReverse();
+
+        if (mPendingSavedState.mAnchorPosition != NO_POSITION) {
+            mPendingScrollPosition = mPendingSavedState.mAnchorPosition;
+            anchorInfo.mLayoutFromEnd = mPendingSavedState.mAnchorLayoutFromEnd;
+        } else {
+            anchorInfo.mLayoutFromEnd = mShouldReverseLayout;
+        }
+        if (mPendingSavedState.mSpanLookupSize > 1) {
+            mLazySpanLookup.mData = mPendingSavedState.mSpanLookup;
+            mLazySpanLookup.mFullSpanItems = mPendingSavedState.mFullSpanItems;
+        }
+    }
+
+    void updateAnchorInfoForLayout(RecyclerView.State state, AnchorInfo anchorInfo) {
+        if (updateAnchorFromPendingData(state, anchorInfo)) {
+            return;
+        }
+        if (updateAnchorFromChildren(state, anchorInfo)) {
+            return;
+        }
+        if (DEBUG) {
+            Log.d(TAG, "Deciding anchor info from fresh state");
+        }
+        anchorInfo.assignCoordinateFromPadding();
+        anchorInfo.mPosition = 0;
+    }
+
+    private boolean updateAnchorFromChildren(RecyclerView.State state, AnchorInfo anchorInfo) {
+        // We don't recycle views out of adapter order. This way, we can rely on the first or
+        // last child as the anchor position.
+        // Layout direction may change but we should select the child depending on the latest
+        // layout direction. Otherwise, we'll choose the wrong child.
+        anchorInfo.mPosition = mLastLayoutFromEnd
+                ? findLastReferenceChildPosition(state.getItemCount())
+                : findFirstReferenceChildPosition(state.getItemCount());
+        anchorInfo.mOffset = INVALID_OFFSET;
+        return true;
+    }
+
+    boolean updateAnchorFromPendingData(RecyclerView.State state, AnchorInfo anchorInfo) {
+        // Validate scroll position if exists.
+        if (state.isPreLayout() || mPendingScrollPosition == NO_POSITION) {
+            return false;
+        }
+        // Validate it.
+        if (mPendingScrollPosition < 0 || mPendingScrollPosition >= state.getItemCount()) {
+            mPendingScrollPosition = NO_POSITION;
+            mPendingScrollPositionOffset = INVALID_OFFSET;
+            return false;
+        }
+
+        if (mPendingSavedState == null || mPendingSavedState.mAnchorPosition == NO_POSITION
+                || mPendingSavedState.mSpanOffsetsSize < 1) {
+            // If item is visible, make it fully visible.
+            final View child = findViewByPosition(mPendingScrollPosition);
+            if (child != null) {
+                // Use regular anchor position, offset according to pending offset and target
+                // child
+                anchorInfo.mPosition = mShouldReverseLayout ? getLastChildPosition()
+                        : getFirstChildPosition();
+
+                if (mPendingScrollPositionOffset != INVALID_OFFSET) {
+                    if (anchorInfo.mLayoutFromEnd) {
+                        final int target = mPrimaryOrientation.getEndAfterPadding() -
+                                mPendingScrollPositionOffset;
+                        anchorInfo.mOffset = target - mPrimaryOrientation.getDecoratedEnd(child);
+                    } else {
+                        final int target = mPrimaryOrientation.getStartAfterPadding() +
+                                mPendingScrollPositionOffset;
+                        anchorInfo.mOffset = target - mPrimaryOrientation.getDecoratedStart(child);
+                    }
+                    return true;
+                }
+
+                // no offset provided. Decide according to the child location
+                final int childSize = mPrimaryOrientation.getDecoratedMeasurement(child);
+                if (childSize > mPrimaryOrientation.getTotalSpace()) {
+                    // Item does not fit. Fix depending on layout direction.
+                    anchorInfo.mOffset = anchorInfo.mLayoutFromEnd
+                            ? mPrimaryOrientation.getEndAfterPadding()
+                            : mPrimaryOrientation.getStartAfterPadding();
+                    return true;
+                }
+
+                final int startGap = mPrimaryOrientation.getDecoratedStart(child)
+                        - mPrimaryOrientation.getStartAfterPadding();
+                if (startGap < 0) {
+                    anchorInfo.mOffset = -startGap;
+                    return true;
+                }
+                final int endGap = mPrimaryOrientation.getEndAfterPadding() -
+                        mPrimaryOrientation.getDecoratedEnd(child);
+                if (endGap < 0) {
+                    anchorInfo.mOffset = endGap;
+                    return true;
+                }
+                // child already visible. just layout as usual
+                anchorInfo.mOffset = INVALID_OFFSET;
+            } else {
+                // Child is not visible. Set anchor coordinate depending on in which direction
+                // child will be visible.
+                anchorInfo.mPosition = mPendingScrollPosition;
+                if (mPendingScrollPositionOffset == INVALID_OFFSET) {
+                    final int position = calculateScrollDirectionForPosition(
+                            anchorInfo.mPosition);
+                    anchorInfo.mLayoutFromEnd = position == LAYOUT_END;
+                    anchorInfo.assignCoordinateFromPadding();
+                } else {
+                    anchorInfo.assignCoordinateFromPadding(mPendingScrollPositionOffset);
+                }
+                anchorInfo.mInvalidateOffsets = true;
+            }
+        } else {
+            anchorInfo.mOffset = INVALID_OFFSET;
+            anchorInfo.mPosition = mPendingScrollPosition;
+        }
+        return true;
+    }
+
+    void updateMeasureSpecs() {
+        mSizePerSpan = mSecondaryOrientation.getTotalSpace() / mSpanCount;
+        mFullSizeSpec = View.MeasureSpec.makeMeasureSpec(
+                mSecondaryOrientation.getTotalSpace(), View.MeasureSpec.EXACTLY);
+        if (mOrientation == VERTICAL) {
+            mWidthSpec = View.MeasureSpec.makeMeasureSpec(mSizePerSpan, View.MeasureSpec.EXACTLY);
+            mHeightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+        } else {
+            mHeightSpec = View.MeasureSpec.makeMeasureSpec(mSizePerSpan, View.MeasureSpec.EXACTLY);
+            mWidthSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
+        }
+    }
+
+    @Override
+    public boolean supportsPredictiveItemAnimations() {
+        return mPendingSavedState == null;
+    }
+
+    /**
+     * Returns the adapter position of the first visible view for each span.
+     * <p>
+     * Note that, this value is not affected by layout orientation or item order traversal.
+     * ({@link #setReverseLayout(boolean)}). Views are sorted by their positions in the adapter,
+     * not in the layout.
+     * <p>
+     * If RecyclerView has item decorators, they will be considered in calculations as well.
+     * <p>
+     * StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
+     * views are ignored in this method.
+     *
+     * @param into An array to put the results into. If you don't provide any, LayoutManager will
+     *             create a new one.
+     * @return The adapter position of the first visible item in each span. If a span does not have
+     * any items, {@link RecyclerView#NO_POSITION} is returned for that span.
+     * @see #findFirstCompletelyVisibleItemPositions(int[])
+     * @see #findLastVisibleItemPositions(int[])
+     */
+    public int[] findFirstVisibleItemPositions(int[] into) {
+        if (into == null) {
+            into = new int[mSpanCount];
+        } else if (into.length < mSpanCount) {
+            throw new IllegalArgumentException("Provided int[]'s size must be more than or equal"
+                    + " to span count. Expected:" + mSpanCount + ", array size:" + into.length);
+        }
+        for (int i = 0; i < mSpanCount; i++) {
+            into[i] = mSpans[i].findFirstVisibleItemPosition();
+        }
+        return into;
+    }
+
+    /**
+     * Returns the adapter position of the first completely visible view for each span.
+     * <p>
+     * Note that, this value is not affected by layout orientation or item order traversal.
+     * ({@link #setReverseLayout(boolean)}). Views are sorted by their positions in the adapter,
+     * not in the layout.
+     * <p>
+     * If RecyclerView has item decorators, they will be considered in calculations as well.
+     * <p>
+     * StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
+     * views are ignored in this method.
+     *
+     * @param into An array to put the results into. If you don't provide any, LayoutManager will
+     *             create a new one.
+     * @return The adapter position of the first fully visible item in each span. If a span does
+     * not have any items, {@link RecyclerView#NO_POSITION} is returned for that span.
+     * @see #findFirstVisibleItemPositions(int[])
+     * @see #findLastCompletelyVisibleItemPositions(int[])
+     */
+    public int[] findFirstCompletelyVisibleItemPositions(int[] into) {
+        if (into == null) {
+            into = new int[mSpanCount];
+        } else if (into.length < mSpanCount) {
+            throw new IllegalArgumentException("Provided int[]'s size must be more than or equal"
+                    + " to span count. Expected:" + mSpanCount + ", array size:" + into.length);
+        }
+        for (int i = 0; i < mSpanCount; i++) {
+            into[i] = mSpans[i].findFirstCompletelyVisibleItemPosition();
+        }
+        return into;
+    }
+
+    /**
+     * Returns the adapter position of the last visible view for each span.
+     * <p>
+     * Note that, this value is not affected by layout orientation or item order traversal.
+     * ({@link #setReverseLayout(boolean)}). Views are sorted by their positions in the adapter,
+     * not in the layout.
+     * <p>
+     * If RecyclerView has item decorators, they will be considered in calculations as well.
+     * <p>
+     * StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
+     * views are ignored in this method.
+     *
+     * @param into An array to put the results into. If you don't provide any, LayoutManager will
+     *             create a new one.
+     * @return The adapter position of the last visible item in each span. If a span does not have
+     * any items, {@link RecyclerView#NO_POSITION} is returned for that span.
+     * @see #findLastCompletelyVisibleItemPositions(int[])
+     * @see #findFirstVisibleItemPositions(int[])
+     */
+    public int[] findLastVisibleItemPositions(int[] into) {
+        if (into == null) {
+            into = new int[mSpanCount];
+        } else if (into.length < mSpanCount) {
+            throw new IllegalArgumentException("Provided int[]'s size must be more than or equal"
+                    + " to span count. Expected:" + mSpanCount + ", array size:" + into.length);
+        }
+        for (int i = 0; i < mSpanCount; i++) {
+            into[i] = mSpans[i].findLastVisibleItemPosition();
+        }
+        return into;
+    }
+
+    /**
+     * Returns the adapter position of the last completely visible view for each span.
+     * <p>
+     * Note that, this value is not affected by layout orientation or item order traversal.
+     * ({@link #setReverseLayout(boolean)}). Views are sorted by their positions in the adapter,
+     * not in the layout.
+     * <p>
+     * If RecyclerView has item decorators, they will be considered in calculations as well.
+     * <p>
+     * StaggeredGridLayoutManager may pre-cache some views that are not necessarily visible. Those
+     * views are ignored in this method.
+     *
+     * @param into An array to put the results into. If you don't provide any, LayoutManager will
+     *             create a new one.
+     * @return The adapter position of the last fully visible item in each span. If a span does not
+     * have any items, {@link RecyclerView#NO_POSITION} is returned for that span.
+     * @see #findFirstCompletelyVisibleItemPositions(int[])
+     * @see #findLastVisibleItemPositions(int[])
+     */
+    public int[] findLastCompletelyVisibleItemPositions(int[] into) {
+        if (into == null) {
+            into = new int[mSpanCount];
+        } else if (into.length < mSpanCount) {
+            throw new IllegalArgumentException("Provided int[]'s size must be more than or equal"
+                    + " to span count. Expected:" + mSpanCount + ", array size:" + into.length);
+        }
+        for (int i = 0; i < mSpanCount; i++) {
+            into[i] = mSpans[i].findLastCompletelyVisibleItemPosition();
+        }
+        return into;
+    }
+
+    @Override
+    public int computeHorizontalScrollOffset(RecyclerView.State state) {
+        return computeScrollOffset(state);
+    }
+
+    private int computeScrollOffset(RecyclerView.State state) {
+        if (getChildCount() == 0) {
+            return 0;
+        }
+        ensureOrientationHelper();
+        return ScrollbarHelper.computeScrollOffset(state, mPrimaryOrientation,
+                findFirstVisibleItemClosestToStart(!mSmoothScrollbarEnabled, true)
+                , findFirstVisibleItemClosestToEnd(!mSmoothScrollbarEnabled, true),
+                this, mSmoothScrollbarEnabled, mShouldReverseLayout);
+    }
+
+    @Override
+    public int computeVerticalScrollOffset(RecyclerView.State state) {
+        return computeScrollOffset(state);
+    }
+
+    @Override
+    public int computeHorizontalScrollExtent(RecyclerView.State state) {
+        return computeScrollExtent(state);
+    }
+
+    private int computeScrollExtent(RecyclerView.State state) {
+        if (getChildCount() == 0) {
+            return 0;
+        }
+        ensureOrientationHelper();
+        return ScrollbarHelper.computeScrollExtent(state, mPrimaryOrientation,
+                findFirstVisibleItemClosestToStart(!mSmoothScrollbarEnabled, true)
+                , findFirstVisibleItemClosestToEnd(!mSmoothScrollbarEnabled, true),
+                this, mSmoothScrollbarEnabled);
+    }
+
+    @Override
+    public int computeVerticalScrollExtent(RecyclerView.State state) {
+        return computeScrollExtent(state);
+    }
+
+    @Override
+    public int computeHorizontalScrollRange(RecyclerView.State state) {
+        return computeScrollRange(state);
+    }
+
+    private int computeScrollRange(RecyclerView.State state) {
+        if (getChildCount() == 0) {
+            return 0;
+        }
+        ensureOrientationHelper();
+        return ScrollbarHelper.computeScrollRange(state, mPrimaryOrientation,
+                findFirstVisibleItemClosestToStart(!mSmoothScrollbarEnabled, true)
+                , findFirstVisibleItemClosestToEnd(!mSmoothScrollbarEnabled, true),
+                this, mSmoothScrollbarEnabled);
+    }
+
+    @Override
+    public int computeVerticalScrollRange(RecyclerView.State state) {
+        return computeScrollRange(state);
+    }
+
+    private void measureChildWithDecorationsAndMargin(View child, LayoutParams lp) {
+        if (lp.mFullSpan) {
+            if (mOrientation == VERTICAL) {
+                measureChildWithDecorationsAndMargin(child, mFullSizeSpec,
+                        getSpecForDimension(lp.height, mHeightSpec));
+            } else {
+                measureChildWithDecorationsAndMargin(child,
+                        getSpecForDimension(lp.width, mWidthSpec), mFullSizeSpec);
+            }
+        } else {
+            if (mOrientation == VERTICAL) {
+                measureChildWithDecorationsAndMargin(child, mWidthSpec,
+                        getSpecForDimension(lp.height, mHeightSpec));
+            } else {
+                measureChildWithDecorationsAndMargin(child,
+                        getSpecForDimension(lp.width, mWidthSpec), mHeightSpec);
+            }
+        }
+    }
+
+    private int getSpecForDimension(int dim, int defaultSpec) {
+        if (dim < 0) {
+            return defaultSpec;
+        } else {
+            return View.MeasureSpec.makeMeasureSpec(dim, View.MeasureSpec.EXACTLY);
+        }
+    }
+
+    private void measureChildWithDecorationsAndMargin(View child, int widthSpec,
+            int heightSpec) {
+        calculateItemDecorationsForChild(child, mTmpRect);
+        LayoutParams lp = (LayoutParams) child.getLayoutParams();
+        widthSpec = updateSpecWithExtra(widthSpec, lp.leftMargin + mTmpRect.left,
+                lp.rightMargin + mTmpRect.right);
+        heightSpec = updateSpecWithExtra(heightSpec, lp.topMargin + mTmpRect.top,
+                lp.bottomMargin + mTmpRect.bottom);
+        child.measure(widthSpec, heightSpec);
+    }
+
+    private int updateSpecWithExtra(int spec, int startInset, int endInset) {
+        if (startInset == 0 && endInset == 0) {
+            return spec;
+        }
+        final int mode = View.MeasureSpec.getMode(spec);
+        if (mode == View.MeasureSpec.AT_MOST || mode == View.MeasureSpec.EXACTLY) {
+            return View.MeasureSpec.makeMeasureSpec(
+                    View.MeasureSpec.getSize(spec) - startInset - endInset, mode);
+        }
+        return spec;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        if (state instanceof SavedState) {
+            mPendingSavedState = (SavedState) state;
+            requestLayout();
+        } else if (DEBUG) {
+            Log.d(TAG, "invalid saved state class");
+        }
+    }
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        if (mPendingSavedState != null) {
+            return new SavedState(mPendingSavedState);
+        }
+        SavedState state = new SavedState();
+        state.mReverseLayout = mReverseLayout;
+        state.mAnchorLayoutFromEnd = mLastLayoutFromEnd;
+        state.mLastLayoutRTL = mLastLayoutRTL;
+
+        if (mLazySpanLookup != null && mLazySpanLookup.mData != null) {
+            state.mSpanLookup = mLazySpanLookup.mData;
+            state.mSpanLookupSize = state.mSpanLookup.length;
+            state.mFullSpanItems = mLazySpanLookup.mFullSpanItems;
+        } else {
+            state.mSpanLookupSize = 0;
+        }
+
+        if (getChildCount() > 0) {
+            ensureOrientationHelper();
+            state.mAnchorPosition = mLastLayoutFromEnd ? getLastChildPosition()
+                    : getFirstChildPosition();
+            state.mVisibleAnchorPosition = findFirstVisibleItemPositionInt();
+            state.mSpanOffsetsSize = mSpanCount;
+            state.mSpanOffsets = new int[mSpanCount];
+            for (int i = 0; i < mSpanCount; i++) {
+                int line;
+                if (mLastLayoutFromEnd) {
+                    line = mSpans[i].getEndLine(Span.INVALID_LINE);
+                    if (line != Span.INVALID_LINE) {
+                        line -= mPrimaryOrientation.getEndAfterPadding();
+                    }
+                } else {
+                    line = mSpans[i].getStartLine(Span.INVALID_LINE);
+                    if (line != Span.INVALID_LINE) {
+                        line -= mPrimaryOrientation.getStartAfterPadding();
+                    }
+                }
+                state.mSpanOffsets[i] = line;
+            }
+        } else {
+            state.mAnchorPosition = NO_POSITION;
+            state.mVisibleAnchorPosition = NO_POSITION;
+            state.mSpanOffsetsSize = 0;
+        }
+        if (DEBUG) {
+            Log.d(TAG, "saved state:\n" + state);
+        }
+        return state;
+    }
+
+    @Override
+    public void onInitializeAccessibilityNodeInfoForItem(RecyclerView.Recycler recycler,
+            RecyclerView.State state, View host, AccessibilityNodeInfoCompat info) {
+        ViewGroup.LayoutParams lp = host.getLayoutParams();
+        if (!(lp instanceof LayoutParams)) {
+            super.onInitializeAccessibilityNodeInfoForItem(host, info);
+            return;
+        }
+        LayoutParams sglp = (LayoutParams) lp;
+        if (mOrientation == HORIZONTAL) {
+            info.setCollectionItemInfo(AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(
+                    sglp.getSpanIndex(), sglp.mFullSpan ? mSpanCount : 1,
+                    -1, -1,
+                    sglp.mFullSpan, false));
+        } else { // VERTICAL
+            info.setCollectionItemInfo(AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(
+                    -1, -1,
+                    sglp.getSpanIndex(), sglp.mFullSpan ? mSpanCount : 1,
+                    sglp.mFullSpan, false));
+        }
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        if (getChildCount() > 0) {
+            final AccessibilityRecordCompat record = AccessibilityEventCompat
+                    .asRecord(event);
+            final View start = findFirstVisibleItemClosestToStart(false, true);
+            final View end = findFirstVisibleItemClosestToEnd(false, true);
+            if (start == null || end == null) {
+                return;
+            }
+            final int startPos = getPosition(start);
+            final int endPos = getPosition(end);
+            if (startPos < endPos) {
+                record.setFromIndex(startPos);
+                record.setToIndex(endPos);
+            } else {
+                record.setFromIndex(endPos);
+                record.setToIndex(startPos);
+            }
+        }
+    }
+
+    /**
+     * Finds the first fully visible child to be used as an anchor child if span count changes when
+     * state is restored. If no children is fully visible, returns a partially visible child instead
+     * of returning null.
+     */
+    int findFirstVisibleItemPositionInt() {
+        final View first = mShouldReverseLayout ? findFirstVisibleItemClosestToEnd(true, true) :
+                findFirstVisibleItemClosestToStart(true, true);
+        return first == null ? NO_POSITION : getPosition(first);
+    }
+
+    @Override
+    public int getRowCountForAccessibility(RecyclerView.Recycler recycler,
+            RecyclerView.State state) {
+        if (mOrientation == HORIZONTAL) {
+            return mSpanCount;
+        }
+        return super.getRowCountForAccessibility(recycler, state);
+    }
+
+    @Override
+    public int getColumnCountForAccessibility(RecyclerView.Recycler recycler,
+            RecyclerView.State state) {
+        if (mOrientation == VERTICAL) {
+            return mSpanCount;
+        }
+        return super.getColumnCountForAccessibility(recycler, state);
+    }
+
+    /**
+     * This is for internal use. Not necessarily the child closest to start but the first child
+     * we find that matches the criteria.
+     * This method does not do any sorting based on child's start coordinate, instead, it uses
+     * children order.
+     */
+    View findFirstVisibleItemClosestToStart(boolean fullyVisible, boolean acceptPartiallyVisible) {
+        ensureOrientationHelper();
+        final int boundsStart = mPrimaryOrientation.getStartAfterPadding();
+        final int boundsEnd = mPrimaryOrientation.getEndAfterPadding();
+        final int limit = getChildCount();
+        View partiallyVisible = null;
+        for (int i = 0; i < limit; i++) {
+            final View child = getChildAt(i);
+            final int childStart = mPrimaryOrientation.getDecoratedStart(child);
+            final int childEnd = mPrimaryOrientation.getDecoratedEnd(child);
+            if(childEnd <= boundsStart || childStart >= boundsEnd) {
+                continue; // not visible at all
+            }
+            if (childStart >= boundsStart || !fullyVisible) {
+                // when checking for start, it is enough even if part of the child's top is visible
+                // as long as fully visible is not requested.
+                return child;
+            }
+            if (acceptPartiallyVisible && partiallyVisible == null) {
+                partiallyVisible = child;
+            }
+        }
+        return partiallyVisible;
+    }
+
+    /**
+     * This is for internal use. Not necessarily the child closest to bottom but the first child
+     * we find that matches the criteria.
+     * This method does not do any sorting based on child's end coordinate, instead, it uses
+     * children order.
+     */
+    View findFirstVisibleItemClosestToEnd(boolean fullyVisible, boolean acceptPartiallyVisible) {
+        ensureOrientationHelper();
+        final int boundsStart = mPrimaryOrientation.getStartAfterPadding();
+        final int boundsEnd = mPrimaryOrientation.getEndAfterPadding();
+        View partiallyVisible = null;
+        for (int i = getChildCount() - 1; i >= 0; i--) {
+            final View child = getChildAt(i);
+            final int childStart = mPrimaryOrientation.getDecoratedStart(child);
+            final int childEnd = mPrimaryOrientation.getDecoratedEnd(child);
+            if(childEnd <= boundsStart || childStart >= boundsEnd) {
+                continue; // not visible at all
+            }
+            if (childEnd <= boundsEnd || !fullyVisible) {
+                // when checking for end, it is enough even if part of the child's bottom is visible
+                // as long as fully visible is not requested.
+                return child;
+            }
+            if (acceptPartiallyVisible && partiallyVisible == null) {
+                partiallyVisible = child;
+            }
+        }
+        return partiallyVisible;
+    }
+
+    private void fixEndGap(RecyclerView.Recycler recycler, RecyclerView.State state,
+            boolean canOffsetChildren) {
+        final int maxEndLine = getMaxEnd(mPrimaryOrientation.getEndAfterPadding());
+        int gap = mPrimaryOrientation.getEndAfterPadding() - maxEndLine;
+        int fixOffset;
+        if (gap > 0) {
+            fixOffset = -scrollBy(-gap, recycler, state);
+        } else {
+            return; // nothing to fix
+        }
+        gap -= fixOffset;
+        if (canOffsetChildren && gap > 0) {
+            mPrimaryOrientation.offsetChildren(gap);
+        }
+    }
+
+    private void fixStartGap(RecyclerView.Recycler recycler, RecyclerView.State state,
+            boolean canOffsetChildren) {
+        final int minStartLine = getMinStart(mPrimaryOrientation.getStartAfterPadding());
+        int gap = minStartLine - mPrimaryOrientation.getStartAfterPadding();
+        int fixOffset;
+        if (gap > 0) {
+            fixOffset = scrollBy(gap, recycler, state);
+        } else {
+            return; // nothing to fix
+        }
+        gap -= fixOffset;
+        if (canOffsetChildren && gap > 0) {
+            mPrimaryOrientation.offsetChildren(-gap);
+        }
+    }
+
+    private void updateLayoutStateToFillStart(int anchorPosition, RecyclerView.State state) {
+        mLayoutState.mAvailable = 0;
+        mLayoutState.mCurrentPosition = anchorPosition;
+        if (isSmoothScrolling()) {
+            final int targetPos = state.getTargetScrollPosition();
+            if (mShouldReverseLayout == targetPos < anchorPosition) {
+                mLayoutState.mExtra = 0;
+            } else {
+                mLayoutState.mExtra = mPrimaryOrientation.getTotalSpace();
+            }
+        } else {
+            mLayoutState.mExtra = 0;
+        }
+        mLayoutState.mLayoutDirection = LAYOUT_START;
+        mLayoutState.mItemDirection = mShouldReverseLayout ? ITEM_DIRECTION_TAIL
+                : ITEM_DIRECTION_HEAD;
+    }
+
+    private void updateLayoutStateToFillEnd(int anchorPosition, RecyclerView.State state) {
+        mLayoutState.mAvailable = 0;
+        mLayoutState.mCurrentPosition = anchorPosition;
+        if (isSmoothScrolling()) {
+            final int targetPos = state.getTargetScrollPosition();
+            if (mShouldReverseLayout == targetPos > anchorPosition) {
+                mLayoutState.mExtra = 0;
+            } else {
+                mLayoutState.mExtra = mPrimaryOrientation.getTotalSpace();
+            }
+        } else {
+            mLayoutState.mExtra = 0;
+        }
+        mLayoutState.mLayoutDirection = LAYOUT_END;
+        mLayoutState.mItemDirection = mShouldReverseLayout ? ITEM_DIRECTION_HEAD
+                : ITEM_DIRECTION_TAIL;
+    }
+
+    @Override
+    public void offsetChildrenHorizontal(int dx) {
+        super.offsetChildrenHorizontal(dx);
+        for (int i = 0; i < mSpanCount; i++) {
+            mSpans[i].onOffset(dx);
+        }
+    }
+
+    @Override
+    public void offsetChildrenVertical(int dy) {
+        super.offsetChildrenVertical(dy);
+        for (int i = 0; i < mSpanCount; i++) {
+            mSpans[i].onOffset(dy);
+        }
+    }
+
+    @Override
+    public void onItemsRemoved(RecyclerView recyclerView, int positionStart, int itemCount) {
+        handleUpdate(positionStart, itemCount, AdapterHelper.UpdateOp.REMOVE);
+    }
+
+    @Override
+    public void onItemsAdded(RecyclerView recyclerView, int positionStart, int itemCount) {
+        handleUpdate(positionStart, itemCount, AdapterHelper.UpdateOp.ADD);
+    }
+
+    @Override
+    public void onItemsChanged(RecyclerView recyclerView) {
+        mLazySpanLookup.clear();
+        requestLayout();
+    }
+
+    @Override
+    public void onItemsMoved(RecyclerView recyclerView, int from, int to, int itemCount) {
+        handleUpdate(from, to, AdapterHelper.UpdateOp.MOVE);
+    }
+
+    @Override
+    public void onItemsUpdated(RecyclerView recyclerView, int positionStart, int itemCount) {
+        handleUpdate(positionStart, itemCount, AdapterHelper.UpdateOp.UPDATE);
+    }
+
+    /**
+     * Checks whether it should invalidate span assignments in response to an adapter change.
+     */
+    private void handleUpdate(int positionStart, int itemCountOrToPosition, int cmd) {
+        int minPosition = mShouldReverseLayout ? getLastChildPosition() : getFirstChildPosition();
+        final int affectedRangeEnd;// exclusive
+        final int affectedRangeStart;// inclusive
+
+        if (cmd == AdapterHelper.UpdateOp.MOVE) {
+            if (positionStart < itemCountOrToPosition) {
+                affectedRangeEnd = itemCountOrToPosition + 1;
+                affectedRangeStart = positionStart;
+            } else {
+                affectedRangeEnd = positionStart + 1;
+                affectedRangeStart = itemCountOrToPosition;
+            }
+        } else {
+            affectedRangeStart = positionStart;
+            affectedRangeEnd = positionStart + itemCountOrToPosition;
+        }
+
+        mLazySpanLookup.invalidateAfter(affectedRangeStart);
+        switch (cmd) {
+            case AdapterHelper.UpdateOp.ADD:
+                mLazySpanLookup.offsetForAddition(positionStart, itemCountOrToPosition);
+                break;
+            case AdapterHelper.UpdateOp.REMOVE:
+                mLazySpanLookup.offsetForRemoval(positionStart, itemCountOrToPosition);
+                break;
+            case AdapterHelper.UpdateOp.MOVE:
+                // TODO optimize
+                mLazySpanLookup.offsetForRemoval(positionStart, 1);
+                mLazySpanLookup.offsetForAddition(itemCountOrToPosition, 1);
+                break;
+        }
+
+        if (affectedRangeEnd <= minPosition) {
+            return;
+        }
+
+        int maxPosition = mShouldReverseLayout ? getFirstChildPosition() : getLastChildPosition();
+        if (affectedRangeStart <= maxPosition) {
+            requestLayout();
+        }
+    }
+
+    private int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
+            RecyclerView.State state) {
+        mRemainingSpans.set(0, mSpanCount, true);
+        // The target position we are trying to reach.
+        final int targetLine;
+        /*
+        * The line until which we can recycle, as long as we add views.
+        * Keep in mind, it is still the line in layout direction which means; to calculate the
+        * actual recycle line, we should subtract/add the size in orientation.
+        */
+        final int recycleLine;
+        // Line of the furthest row.
+        if (layoutState.mLayoutDirection == LAYOUT_END) {
+            // ignore padding for recycler
+            recycleLine = mPrimaryOrientation.getEndAfterPadding() + mLayoutState.mAvailable;
+            targetLine = recycleLine + mLayoutState.mExtra + mPrimaryOrientation.getEndPadding();
+
+        } else { // LAYOUT_START
+            // ignore padding for recycler
+            recycleLine = mPrimaryOrientation.getStartAfterPadding() - mLayoutState.mAvailable;
+            targetLine = recycleLine - mLayoutState.mExtra -
+                    mPrimaryOrientation.getStartAfterPadding();
+        }
+        updateAllRemainingSpans(layoutState.mLayoutDirection, targetLine);
+
+        // the default coordinate to add new view.
+        final int defaultNewViewLine = mShouldReverseLayout
+                ? mPrimaryOrientation.getEndAfterPadding()
+                : mPrimaryOrientation.getStartAfterPadding();
+
+        while (layoutState.hasMore(state) && !mRemainingSpans.isEmpty()) {
+            View view = layoutState.next(recycler);
+            LayoutParams lp = ((LayoutParams) view.getLayoutParams());
+            final int position = lp.getViewLayoutPosition();
+            final int spanIndex = mLazySpanLookup.getSpan(position);
+            Span currentSpan;
+            final boolean assignSpan = spanIndex == LayoutParams.INVALID_SPAN_ID;
+            if (assignSpan) {
+                currentSpan = lp.mFullSpan ? mSpans[0] : getNextSpan(layoutState);
+                mLazySpanLookup.setSpan(position, currentSpan);
+                if (DEBUG) {
+                    Log.d(TAG, "assigned " + currentSpan.mIndex + " for " + position);
+                }
+            } else {
+                if (DEBUG) {
+                    Log.d(TAG, "using " + spanIndex + " for pos " + position);
+                }
+                currentSpan = mSpans[spanIndex];
+            }
+            // assign span before measuring so that item decorators can get updated span index
+            lp.mSpan = currentSpan;
+            if (layoutState.mLayoutDirection == LAYOUT_END) {
+                addView(view);
+            } else {
+                addView(view, 0);
+            }
+            measureChildWithDecorationsAndMargin(view, lp);
+
+            final int start;
+            final int end;
+            if (layoutState.mLayoutDirection == LAYOUT_END) {
+                start = lp.mFullSpan ? getMaxEnd(defaultNewViewLine)
+                        : currentSpan.getEndLine(defaultNewViewLine);
+                end = start + mPrimaryOrientation.getDecoratedMeasurement(view);
+                if (assignSpan && lp.mFullSpan) {
+                    LazySpanLookup.FullSpanItem fullSpanItem;
+                    fullSpanItem = createFullSpanItemFromEnd(start);
+                    fullSpanItem.mGapDir = LAYOUT_START;
+                    fullSpanItem.mPosition = position;
+                    mLazySpanLookup.addFullSpanItem(fullSpanItem);
+                }
+            } else {
+                end = lp.mFullSpan ? getMinStart(defaultNewViewLine)
+                        : currentSpan.getStartLine(defaultNewViewLine);
+                start = end - mPrimaryOrientation.getDecoratedMeasurement(view);
+                if (assignSpan && lp.mFullSpan) {
+                    LazySpanLookup.FullSpanItem fullSpanItem;
+                    fullSpanItem = createFullSpanItemFromStart(end);
+                    fullSpanItem.mGapDir = LAYOUT_END;
+                    fullSpanItem.mPosition = position;
+                    mLazySpanLookup.addFullSpanItem(fullSpanItem);
+                }
+            }
+
+            // check if this item may create gaps in the future
+            if (lp.mFullSpan && layoutState.mItemDirection == ITEM_DIRECTION_HEAD) {
+                if (assignSpan) {
+                    mLaidOutInvalidFullSpan = true;
+                } else {
+                    final boolean hasInvalidGap;
+                    if (layoutState.mLayoutDirection == LAYOUT_END) {
+                        hasInvalidGap = !areAllEndsEqual();
+                    } else { // layoutState.mLayoutDirection == LAYOUT_START
+                        hasInvalidGap = !areAllStartsEqual();
+                    }
+                    if (hasInvalidGap) {
+                        final LazySpanLookup.FullSpanItem fullSpanItem = mLazySpanLookup
+                                .getFullSpanItem(position);
+                        if (fullSpanItem != null) {
+                            fullSpanItem.mHasUnwantedGapAfter = true;
+                        }
+                        mLaidOutInvalidFullSpan = true;
+                    }
+                }
+
+            }
+            attachViewToSpans(view, lp, layoutState);
+            final int otherStart = lp.mFullSpan ? mSecondaryOrientation.getStartAfterPadding()
+                    : currentSpan.mIndex * mSizePerSpan +
+                            mSecondaryOrientation.getStartAfterPadding();
+            final int otherEnd = otherStart + mSecondaryOrientation.getDecoratedMeasurement(view);
+            if (mOrientation == VERTICAL) {
+                layoutDecoratedWithMargins(view, otherStart, start, otherEnd, end);
+            } else {
+                layoutDecoratedWithMargins(view, start, otherStart, end, otherEnd);
+            }
+
+            if (lp.mFullSpan) {
+                updateAllRemainingSpans(mLayoutState.mLayoutDirection, targetLine);
+            } else {
+                updateRemainingSpans(currentSpan, mLayoutState.mLayoutDirection, targetLine);
+            }
+            recycle(recycler, mLayoutState, currentSpan, recycleLine);
+        }
+        if (DEBUG) {
+            Log.d(TAG, "fill, " + getChildCount());
+        }
+        if (mLayoutState.mLayoutDirection == LAYOUT_START) {
+            final int minStart = getMinStart(mPrimaryOrientation.getStartAfterPadding());
+            return Math.max(0, mLayoutState.mAvailable + (recycleLine - minStart));
+        } else {
+            final int max = getMaxEnd(mPrimaryOrientation.getEndAfterPadding());
+            return Math.max(0, mLayoutState.mAvailable + (max - recycleLine));
+        }
+    }
+
+    private LazySpanLookup.FullSpanItem createFullSpanItemFromEnd(int newItemTop) {
+        LazySpanLookup.FullSpanItem fsi = new LazySpanLookup.FullSpanItem();
+        fsi.mGapPerSpan = new int[mSpanCount];
+        for (int i = 0; i < mSpanCount; i++) {
+            fsi.mGapPerSpan[i] = newItemTop - mSpans[i].getEndLine(newItemTop);
+        }
+        return fsi;
+    }
+
+    private LazySpanLookup.FullSpanItem createFullSpanItemFromStart(int newItemBottom) {
+        LazySpanLookup.FullSpanItem fsi = new LazySpanLookup.FullSpanItem();
+        fsi.mGapPerSpan = new int[mSpanCount];
+        for (int i = 0; i < mSpanCount; i++) {
+            fsi.mGapPerSpan[i] = mSpans[i].getStartLine(newItemBottom) - newItemBottom;
+        }
+        return fsi;
+    }
+
+    private void attachViewToSpans(View view, LayoutParams lp, LayoutState layoutState) {
+        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_END) {
+            if (lp.mFullSpan) {
+                appendViewToAllSpans(view);
+            } else {
+                lp.mSpan.appendToSpan(view);
+            }
+        } else {
+            if (lp.mFullSpan) {
+                prependViewToAllSpans(view);
+            } else {
+                lp.mSpan.prependToSpan(view);
+            }
+        }
+    }
+
+    private void recycle(RecyclerView.Recycler recycler, LayoutState layoutState,
+            Span updatedSpan, int recycleLine) {
+        if (layoutState.mLayoutDirection == LAYOUT_START) {
+            // calculate recycle line
+            int maxStart = getMaxStart(updatedSpan.getStartLine());
+            recycleFromEnd(recycler, Math.max(recycleLine, maxStart) +
+                    (mPrimaryOrientation.getEnd() - mPrimaryOrientation.getStartAfterPadding()));
+        } else {
+            // calculate recycle line
+            int minEnd = getMinEnd(updatedSpan.getEndLine());
+            recycleFromStart(recycler, Math.min(recycleLine, minEnd) -
+                    (mPrimaryOrientation.getEnd() - mPrimaryOrientation.getStartAfterPadding()));
+        }
+    }
+
+    private void appendViewToAllSpans(View view) {
+        // traverse in reverse so that we end up assigning full span items to 0
+        for (int i = mSpanCount - 1; i >= 0; i--) {
+            mSpans[i].appendToSpan(view);
+        }
+    }
+
+    private void prependViewToAllSpans(View view) {
+        // traverse in reverse so that we end up assigning full span items to 0
+        for (int i = mSpanCount - 1; i >= 0; i--) {
+            mSpans[i].prependToSpan(view);
+        }
+    }
+
+    private void layoutDecoratedWithMargins(View child, int left, int top, int right, int bottom) {
+        LayoutParams lp = (LayoutParams) child.getLayoutParams();
+        if (DEBUG) {
+            Log.d(TAG, "layout decorated pos: " + lp.getViewLayoutPosition() + ", span:"
+                    + lp.getSpanIndex() + ", fullspan:" + lp.mFullSpan
+                    + ". l:" + left + ",t:" + top
+                    + ", r:" + right + ", b:" + bottom);
+        }
+        layoutDecorated(child, left + lp.leftMargin, top + lp.topMargin, right - lp.rightMargin
+                , bottom - lp.bottomMargin);
+    }
+
+    private void updateAllRemainingSpans(int layoutDir, int targetLine) {
+        for (int i = 0; i < mSpanCount; i++) {
+            if (mSpans[i].mViews.isEmpty()) {
+                continue;
+            }
+            updateRemainingSpans(mSpans[i], layoutDir, targetLine);
+        }
+    }
+
+    private void updateRemainingSpans(Span span, int layoutDir, int targetLine) {
+        final int deletedSize = span.getDeletedSize();
+        if (layoutDir == LAYOUT_START) {
+            final int line = span.getStartLine();
+            if (line + deletedSize < targetLine) {
+                mRemainingSpans.set(span.mIndex, false);
+            }
+        } else {
+            final int line = span.getEndLine();
+            if (line - deletedSize > targetLine) {
+                mRemainingSpans.set(span.mIndex, false);
+            }
+        }
+    }
+
+    private int getMaxStart(int def) {
+        int maxStart = mSpans[0].getStartLine(def);
+        for (int i = 1; i < mSpanCount; i++) {
+            final int spanStart = mSpans[i].getStartLine(def);
+            if (spanStart > maxStart) {
+                maxStart = spanStart;
+            }
+        }
+        return maxStart;
+    }
+
+    private int getMinStart(int def) {
+        int minStart = mSpans[0].getStartLine(def);
+        for (int i = 1; i < mSpanCount; i++) {
+            final int spanStart = mSpans[i].getStartLine(def);
+            if (spanStart < minStart) {
+                minStart = spanStart;
+            }
+        }
+        return minStart;
+    }
+
+    boolean areAllEndsEqual() {
+        int end = mSpans[0].getEndLine(Span.INVALID_LINE);
+        for (int i = 1; i < mSpanCount; i++) {
+            if (mSpans[i].getEndLine(Span.INVALID_LINE) != end) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    boolean areAllStartsEqual() {
+        int start = mSpans[0].getStartLine(Span.INVALID_LINE);
+        for (int i = 1; i < mSpanCount; i++) {
+            if (mSpans[i].getStartLine(Span.INVALID_LINE) != start) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private int getMaxEnd(int def) {
+        int maxEnd = mSpans[0].getEndLine(def);
+        for (int i = 1; i < mSpanCount; i++) {
+            final int spanEnd = mSpans[i].getEndLine(def);
+            if (spanEnd > maxEnd) {
+                maxEnd = spanEnd;
+            }
+        }
+        return maxEnd;
+    }
+
+    private int getMinEnd(int def) {
+        int minEnd = mSpans[0].getEndLine(def);
+        for (int i = 1; i < mSpanCount; i++) {
+            final int spanEnd = mSpans[i].getEndLine(def);
+            if (spanEnd < minEnd) {
+                minEnd = spanEnd;
+            }
+        }
+        return minEnd;
+    }
+
+    private void recycleFromStart(RecyclerView.Recycler recycler, int line) {
+        if (DEBUG) {
+            Log.d(TAG, "recycling from start for line " + line);
+        }
+        while (getChildCount() > 0) {
+            View child = getChildAt(0);
+            if (mPrimaryOrientation.getDecoratedEnd(child) < line) {
+                LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                if (lp.mFullSpan) {
+                    for (int j = 0; j < mSpanCount; j++) {
+                        mSpans[j].popStart();
+                    }
+                } else {
+                    lp.mSpan.popStart();
+                }
+                removeAndRecycleView(child, recycler);
+            } else {
+                return;// done
+            }
+        }
+    }
+
+    private void recycleFromEnd(RecyclerView.Recycler recycler, int line) {
+        final int childCount = getChildCount();
+        int i;
+        for (i = childCount - 1; i >= 0; i--) {
+            View child = getChildAt(i);
+            if (mPrimaryOrientation.getDecoratedStart(child) > line) {
+                LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                if (lp.mFullSpan) {
+                    for (int j = 0; j < mSpanCount; j++) {
+                        mSpans[j].popEnd();
+                    }
+                } else {
+                    lp.mSpan.popEnd();
+                }
+                removeAndRecycleView(child, recycler);
+            } else {
+                return;// done
+            }
+        }
+    }
+
+    /**
+     * @return True if last span is the first one we want to fill
+     */
+    private boolean preferLastSpan(int layoutDir) {
+        if (mOrientation == HORIZONTAL) {
+            return (layoutDir == LAYOUT_START) != mShouldReverseLayout;
+        }
+        return ((layoutDir == LAYOUT_START) == mShouldReverseLayout) == isLayoutRTL();
+    }
+
+    /**
+     * Finds the span for the next view.
+     */
+    private Span getNextSpan(LayoutState layoutState) {
+        final boolean preferLastSpan = preferLastSpan(layoutState.mLayoutDirection);
+        final int startIndex, endIndex, diff;
+        if (preferLastSpan) {
+            startIndex = mSpanCount - 1;
+            endIndex = -1;
+            diff = -1;
+        } else {
+            startIndex = 0;
+            endIndex = mSpanCount;
+            diff = 1;
+        }
+        if (layoutState.mLayoutDirection == LAYOUT_END) {
+            Span min = null;
+            int minLine = Integer.MAX_VALUE;
+            final int defaultLine = mPrimaryOrientation.getStartAfterPadding();
+            for (int i = startIndex; i != endIndex; i += diff) {
+                final Span other = mSpans[i];
+                int otherLine = other.getEndLine(defaultLine);
+                if (otherLine < minLine) {
+                    min = other;
+                    minLine = otherLine;
+                }
+            }
+            return min;
+        } else {
+            Span max = null;
+            int maxLine = Integer.MIN_VALUE;
+            final int defaultLine = mPrimaryOrientation.getEndAfterPadding();
+            for (int i = startIndex; i != endIndex; i += diff) {
+                final Span other = mSpans[i];
+                int otherLine = other.getStartLine(defaultLine);
+                if (otherLine > maxLine) {
+                    max = other;
+                    maxLine = otherLine;
+                }
+            }
+            return max;
+        }
+    }
+
+    @Override
+    public boolean canScrollVertically() {
+        return mOrientation == VERTICAL;
+    }
+
+    @Override
+    public boolean canScrollHorizontally() {
+        return mOrientation == HORIZONTAL;
+    }
+
+    @Override
+    public int scrollHorizontallyBy(int dx, RecyclerView.Recycler recycler,
+            RecyclerView.State state) {
+        return scrollBy(dx, recycler, state);
+    }
+
+    @Override
+    public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,
+            RecyclerView.State state) {
+        return scrollBy(dy, recycler, state);
+    }
+
+    private int calculateScrollDirectionForPosition(int position) {
+        if (getChildCount() == 0) {
+            return mShouldReverseLayout ? LAYOUT_END : LAYOUT_START;
+        }
+        final int firstChildPos = getFirstChildPosition();
+        return position < firstChildPos != mShouldReverseLayout ? LAYOUT_START : LAYOUT_END;
+    }
+
+    @Override
+    public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,
+            int position) {
+        LinearSmoothScroller scroller = new LinearSmoothScroller(recyclerView.getContext()) {
+            @Override
+            public PointF computeScrollVectorForPosition(int targetPosition) {
+                final int direction = calculateScrollDirectionForPosition(targetPosition);
+                if (direction == 0) {
+                    return null;
+                }
+                if (mOrientation == HORIZONTAL) {
+                    return new PointF(direction, 0);
+                } else {
+                    return new PointF(0, direction);
+                }
+            }
+        };
+        scroller.setTargetPosition(position);
+        startSmoothScroll(scroller);
+    }
+
+    @Override
+    public void scrollToPosition(int position) {
+        if (mPendingSavedState != null && mPendingSavedState.mAnchorPosition != position) {
+            mPendingSavedState.invalidateAnchorPositionInfo();
+        }
+        mPendingScrollPosition = position;
+        mPendingScrollPositionOffset = INVALID_OFFSET;
+        requestLayout();
+    }
+
+    /**
+     * Scroll to the specified adapter position with the given offset from layout start.
+     * <p>
+     * Note that scroll position change will not be reflected until the next layout call.
+     * <p>
+     * If you are just trying to make a position visible, use {@link #scrollToPosition(int)}.
+     *
+     * @param position Index (starting at 0) of the reference item.
+     * @param offset   The distance (in pixels) between the start edge of the item view and
+     *                 start edge of the RecyclerView.
+     * @see #setReverseLayout(boolean)
+     * @see #scrollToPosition(int)
+     */
+    public void scrollToPositionWithOffset(int position, int offset) {
+        if (mPendingSavedState != null) {
+            mPendingSavedState.invalidateAnchorPositionInfo();
+        }
+        mPendingScrollPosition = position;
+        mPendingScrollPositionOffset = offset;
+        requestLayout();
+    }
+
+    int scrollBy(int dt, RecyclerView.Recycler recycler, RecyclerView.State state) {
+        ensureOrientationHelper();
+        final int referenceChildPosition;
+        if (dt > 0) { // layout towards end
+            mLayoutState.mLayoutDirection = LAYOUT_END;
+            mLayoutState.mItemDirection = mShouldReverseLayout ? ITEM_DIRECTION_HEAD
+                    : ITEM_DIRECTION_TAIL;
+            referenceChildPosition = getLastChildPosition();
+        } else {
+            mLayoutState.mLayoutDirection = LAYOUT_START;
+            mLayoutState.mItemDirection = mShouldReverseLayout ? ITEM_DIRECTION_TAIL
+                    : ITEM_DIRECTION_HEAD;
+            referenceChildPosition = getFirstChildPosition();
+        }
+        mLayoutState.mCurrentPosition = referenceChildPosition + mLayoutState.mItemDirection;
+        final int absDt = Math.abs(dt);
+        mLayoutState.mAvailable = absDt;
+        mLayoutState.mExtra = isSmoothScrolling() ? mPrimaryOrientation.getTotalSpace() : 0;
+        int consumed = fill(recycler, mLayoutState, state);
+        final int totalScroll;
+        if (absDt < consumed) {
+            totalScroll = dt;
+        } else if (dt < 0) {
+            totalScroll = -consumed;
+        } else { // dt > 0
+            totalScroll = consumed;
+        }
+        if (DEBUG) {
+            Log.d(TAG, "asked " + dt + " scrolled" + totalScroll);
+        }
+
+        mPrimaryOrientation.offsetChildren(-totalScroll);
+        // always reset this if we scroll for a proper save instance state
+        mLastLayoutFromEnd = mShouldReverseLayout;
+        return totalScroll;
+    }
+
+    private int getLastChildPosition() {
+        final int childCount = getChildCount();
+        return childCount == 0 ? 0 : getPosition(getChildAt(childCount - 1));
+    }
+
+    private int getFirstChildPosition() {
+        final int childCount = getChildCount();
+        return childCount == 0 ? 0 : getPosition(getChildAt(0));
+    }
+
+    /**
+     * Finds the first View that can be used as an anchor View.
+     *
+     * @return Position of the View or 0 if it cannot find any such View.
+     */
+    private int findFirstReferenceChildPosition(int itemCount) {
+        final int limit = getChildCount();
+        for (int i = 0; i < limit; i++) {
+            final View view = getChildAt(i);
+            final int position = getPosition(view);
+            if (position >= 0 && position < itemCount) {
+                return position;
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * Finds the last View that can be used as an anchor View.
+     *
+     * @return Position of the View or 0 if it cannot find any such View.
+     */
+    private int findLastReferenceChildPosition(int itemCount) {
+        for (int i = getChildCount() - 1; i >= 0; i--) {
+            final View view = getChildAt(i);
+            final int position = getPosition(view);
+            if (position >= 0 && position < itemCount) {
+                return position;
+            }
+        }
+        return 0;
+    }
+
+    @Override
+    public RecyclerView.LayoutParams generateDefaultLayoutParams() {
+        return new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
+                ViewGroup.LayoutParams.WRAP_CONTENT);
+    }
+
+    @Override
+    public RecyclerView.LayoutParams generateLayoutParams(Context c, AttributeSet attrs) {
+        return new LayoutParams(c, attrs);
+    }
+
+    @Override
+    public RecyclerView.LayoutParams generateLayoutParams(ViewGroup.LayoutParams lp) {
+        if (lp instanceof ViewGroup.MarginLayoutParams) {
+            return new LayoutParams((ViewGroup.MarginLayoutParams) lp);
+        } else {
+            return new LayoutParams(lp);
+        }
+    }
+
+    @Override
+    public boolean checkLayoutParams(RecyclerView.LayoutParams lp) {
+        return lp instanceof LayoutParams;
+    }
+
+    public int getOrientation() {
+        return mOrientation;
+    }
+
+
+    /**
+     * LayoutParams used by StaggeredGridLayoutManager.
+     * <p>
+     * Note that if the orientation is {@link #VERTICAL}, the width parameter is ignored and if the
+     * orientation is {@link #HORIZONTAL} the height parameter is ignored because child view is
+     * expected to fill all of the space given to it.
+     */
+    public static class LayoutParams extends RecyclerView.LayoutParams {
+
+        /**
+         * Span Id for Views that are not laid out yet.
+         */
+        public static final int INVALID_SPAN_ID = -1;
+
+        // Package scope to be able to access from tests.
+        Span mSpan;
+
+        boolean mFullSpan;
+
+        public LayoutParams(Context c, AttributeSet attrs) {
+            super(c, attrs);
+        }
+
+        public LayoutParams(int width, int height) {
+            super(width, height);
+        }
+
+        public LayoutParams(ViewGroup.MarginLayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(ViewGroup.LayoutParams source) {
+            super(source);
+        }
+
+        public LayoutParams(RecyclerView.LayoutParams source) {
+            super(source);
+        }
+
+        /**
+         * When set to true, the item will layout using all span area. That means, if orientation
+         * is vertical, the view will have full width; if orientation is horizontal, the view will
+         * have full height.
+         *
+         * @param fullSpan True if this item should traverse all spans.
+         * @see #isFullSpan()
+         */
+        public void setFullSpan(boolean fullSpan) {
+            mFullSpan = fullSpan;
+        }
+
+        /**
+         * Returns whether this View occupies all available spans or just one.
+         *
+         * @return True if the View occupies all spans or false otherwise.
+         * @see #setFullSpan(boolean)
+         */
+        public boolean isFullSpan() {
+            return mFullSpan;
+        }
+
+        /**
+         * Returns the Span index to which this View is assigned.
+         *
+         * @return The Span index of the View. If View is not yet assigned to any span, returns
+         * {@link #INVALID_SPAN_ID}.
+         */
+        public final int getSpanIndex() {
+            if (mSpan == null) {
+                return INVALID_SPAN_ID;
+            }
+            return mSpan.mIndex;
+        }
+    }
+
+    // Package scoped to access from tests.
+    class Span {
+
+        static final int INVALID_LINE = Integer.MIN_VALUE;
+        private ArrayList<View> mViews = new ArrayList<View>();
+        int mCachedStart = INVALID_LINE;
+        int mCachedEnd = INVALID_LINE;
+        int mDeletedSize = 0;
+        final int mIndex;
+
+        private Span(int index) {
+            mIndex = index;
+        }
+
+        int getStartLine(int def) {
+            if (mCachedStart != INVALID_LINE) {
+                return mCachedStart;
+            }
+            if (mViews.size() == 0) {
+                return def;
+            }
+            calculateCachedStart();
+            return mCachedStart;
+        }
+
+        void calculateCachedStart() {
+            final View startView = mViews.get(0);
+            final LayoutParams lp = getLayoutParams(startView);
+            mCachedStart = mPrimaryOrientation.getDecoratedStart(startView);
+            if (lp.mFullSpan) {
+                LazySpanLookup.FullSpanItem fsi = mLazySpanLookup
+                        .getFullSpanItem(lp.getViewLayoutPosition());
+                if (fsi != null && fsi.mGapDir == LAYOUT_START) {
+                    mCachedStart -= fsi.getGapForSpan(mIndex);
+                }
+            }
+        }
+
+        // Use this one when default value does not make sense and not having a value means a bug.
+        int getStartLine() {
+            if (mCachedStart != INVALID_LINE) {
+                return mCachedStart;
+            }
+            calculateCachedStart();
+            return mCachedStart;
+        }
+
+        int getEndLine(int def) {
+            if (mCachedEnd != INVALID_LINE) {
+                return mCachedEnd;
+            }
+            final int size = mViews.size();
+            if (size == 0) {
+                return def;
+            }
+            calculateCachedEnd();
+            return mCachedEnd;
+        }
+
+        void calculateCachedEnd() {
+            final View endView = mViews.get(mViews.size() - 1);
+            final LayoutParams lp = getLayoutParams(endView);
+            mCachedEnd = mPrimaryOrientation.getDecoratedEnd(endView);
+            if (lp.mFullSpan) {
+                LazySpanLookup.FullSpanItem fsi = mLazySpanLookup
+                        .getFullSpanItem(lp.getViewLayoutPosition());
+                if (fsi != null && fsi.mGapDir == LAYOUT_END) {
+                    mCachedEnd += fsi.getGapForSpan(mIndex);
+                }
+            }
+        }
+
+        // Use this one when default value does not make sense and not having a value means a bug.
+        int getEndLine() {
+            if (mCachedEnd != INVALID_LINE) {
+                return mCachedEnd;
+            }
+            calculateCachedEnd();
+            return mCachedEnd;
+        }
+
+        void prependToSpan(View view) {
+            LayoutParams lp = getLayoutParams(view);
+            lp.mSpan = this;
+            mViews.add(0, view);
+            mCachedStart = INVALID_LINE;
+            if (mViews.size() == 1) {
+                mCachedEnd = INVALID_LINE;
+            }
+            if (lp.isItemRemoved() || lp.isItemChanged()) {
+                mDeletedSize += mPrimaryOrientation.getDecoratedMeasurement(view);
+            }
+        }
+
+        void appendToSpan(View view) {
+            LayoutParams lp = getLayoutParams(view);
+            lp.mSpan = this;
+            mViews.add(view);
+            mCachedEnd = INVALID_LINE;
+            if (mViews.size() == 1) {
+                mCachedStart = INVALID_LINE;
+            }
+            if (lp.isItemRemoved() || lp.isItemChanged()) {
+                mDeletedSize += mPrimaryOrientation.getDecoratedMeasurement(view);
+            }
+        }
+
+        // Useful method to preserve positions on a re-layout.
+        void cacheReferenceLineAndClear(boolean reverseLayout, int offset) {
+            int reference;
+            if (reverseLayout) {
+                reference = getEndLine(INVALID_LINE);
+            } else {
+                reference = getStartLine(INVALID_LINE);
+            }
+            clear();
+            if (reference == INVALID_LINE) {
+                return;
+            }
+            if ((reverseLayout && reference < mPrimaryOrientation.getEndAfterPadding()) ||
+                    (!reverseLayout && reference > mPrimaryOrientation.getStartAfterPadding())) {
+                return;
+            }
+            if (offset != INVALID_OFFSET) {
+                reference += offset;
+            }
+            mCachedStart = mCachedEnd = reference;
+        }
+
+        void clear() {
+            mViews.clear();
+            invalidateCache();
+            mDeletedSize = 0;
+        }
+
+        void invalidateCache() {
+            mCachedStart = INVALID_LINE;
+            mCachedEnd = INVALID_LINE;
+        }
+
+        void setLine(int line) {
+            mCachedEnd = mCachedStart = line;
+        }
+
+        void popEnd() {
+            final int size = mViews.size();
+            View end = mViews.remove(size - 1);
+            final LayoutParams lp = getLayoutParams(end);
+            lp.mSpan = null;
+            if (lp.isItemRemoved() || lp.isItemChanged()) {
+                mDeletedSize -= mPrimaryOrientation.getDecoratedMeasurement(end);
+            }
+            if (size == 1) {
+                mCachedStart = INVALID_LINE;
+            }
+            mCachedEnd = INVALID_LINE;
+        }
+
+        void popStart() {
+            View start = mViews.remove(0);
+            final LayoutParams lp = getLayoutParams(start);
+            lp.mSpan = null;
+            if (mViews.size() == 0) {
+                mCachedEnd = INVALID_LINE;
+            }
+            if (lp.isItemRemoved() || lp.isItemChanged()) {
+                mDeletedSize -= mPrimaryOrientation.getDecoratedMeasurement(start);
+            }
+            mCachedStart = INVALID_LINE;
+        }
+
+        public int getDeletedSize() {
+            return mDeletedSize;
+        }
+
+        LayoutParams getLayoutParams(View view) {
+            return (LayoutParams) view.getLayoutParams();
+        }
+
+        void onOffset(int dt) {
+            if (mCachedStart != INVALID_LINE) {
+                mCachedStart += dt;
+            }
+            if (mCachedEnd != INVALID_LINE) {
+                mCachedEnd += dt;
+            }
+        }
+
+        // normalized offset is how much this span can scroll
+        int getNormalizedOffset(int dt, int targetStart, int targetEnd) {
+            if (mViews.size() == 0) {
+                return 0;
+            }
+            if (dt < 0) {
+                final int endSpace = getEndLine() - targetEnd;
+                if (endSpace <= 0) {
+                    return 0;
+                }
+                return -dt > endSpace ? -endSpace : dt;
+            } else {
+                final int startSpace = targetStart - getStartLine();
+                if (startSpace <= 0) {
+                    return 0;
+                }
+                return startSpace < dt ? startSpace : dt;
+            }
+        }
+
+        /**
+         * Returns if there is no child between start-end lines
+         *
+         * @param start The start line
+         * @param end   The end line
+         * @return true if a new child can be added between start and end
+         */
+        boolean isEmpty(int start, int end) {
+            final int count = mViews.size();
+            for (int i = 0; i < count; i++) {
+                final View view = mViews.get(i);
+                if (mPrimaryOrientation.getDecoratedStart(view) < end &&
+                        mPrimaryOrientation.getDecoratedEnd(view) > start) {
+                    return false;
+                }
+            }
+            return true;
+        }
+
+        public int findFirstVisibleItemPosition() {
+            return mReverseLayout
+                    ? findOneVisibleChild(mViews.size() - 1, -1, false)
+                    : findOneVisibleChild(0, mViews.size(), false);
+        }
+
+        public int findFirstCompletelyVisibleItemPosition() {
+            return mReverseLayout
+                    ? findOneVisibleChild(mViews.size() - 1, -1, true)
+                    : findOneVisibleChild(0, mViews.size(), true);
+        }
+
+        public int findLastVisibleItemPosition() {
+            return mReverseLayout
+                    ? findOneVisibleChild(0, mViews.size(), false)
+                    : findOneVisibleChild(mViews.size() - 1, -1, false);
+        }
+
+        public int findLastCompletelyVisibleItemPosition() {
+            return mReverseLayout
+                    ? findOneVisibleChild(0, mViews.size(), true)
+                    : findOneVisibleChild(mViews.size() - 1, -1, true);
+        }
+
+        int findOneVisibleChild(int fromIndex, int toIndex, boolean completelyVisible) {
+            final int start = mPrimaryOrientation.getStartAfterPadding();
+            final int end = mPrimaryOrientation.getEndAfterPadding();
+            final int next = toIndex > fromIndex ? 1 : -1;
+            for (int i = fromIndex; i != toIndex; i += next) {
+                final View child = mViews.get(i);
+                final int childStart = mPrimaryOrientation.getDecoratedStart(child);
+                final int childEnd = mPrimaryOrientation.getDecoratedEnd(child);
+                if (childStart < end && childEnd > start) {
+                    if (completelyVisible) {
+                        if (childStart >= start && childEnd <= end) {
+                            return getPosition(child);
+                        }
+                    } else {
+                        return getPosition(child);
+                    }
+                }
+            }
+            return NO_POSITION;
+        }
+    }
+
+    /**
+     * An array of mappings from adapter position to span.
+     * This only grows when a write happens and it grows up to the size of the adapter.
+     */
+    static class LazySpanLookup {
+
+        private static final int MIN_SIZE = 10;
+        int[] mData;
+        List<FullSpanItem> mFullSpanItems;
+
+
+        /**
+         * Invalidates everything after this position, including full span information
+         */
+        int forceInvalidateAfter(int position) {
+            if (mFullSpanItems != null) {
+                for (int i = mFullSpanItems.size() - 1; i >= 0; i--) {
+                    FullSpanItem fsi = mFullSpanItems.get(i);
+                    if (fsi.mPosition >= position) {
+                        mFullSpanItems.remove(i);
+                    }
+                }
+            }
+            return invalidateAfter(position);
+        }
+
+        /**
+         * returns end position for invalidation.
+         */
+        int invalidateAfter(int position) {
+            if (mData == null) {
+                return RecyclerView.NO_POSITION;
+            }
+            if (position >= mData.length) {
+                return RecyclerView.NO_POSITION;
+            }
+            int endPosition = invalidateFullSpansAfter(position);
+            if (endPosition == RecyclerView.NO_POSITION) {
+                Arrays.fill(mData, position, mData.length, LayoutParams.INVALID_SPAN_ID);
+                return mData.length;
+            } else {
+                // just invalidate items in between
+                Arrays.fill(mData, position, endPosition + 1, LayoutParams.INVALID_SPAN_ID);
+                return endPosition + 1;
+            }
+        }
+
+        int getSpan(int position) {
+            if (mData == null || position >= mData.length) {
+                return LayoutParams.INVALID_SPAN_ID;
+            } else {
+                return mData[position];
+            }
+        }
+
+        void setSpan(int position, Span span) {
+            ensureSize(position);
+            mData[position] = span.mIndex;
+        }
+
+        int sizeForPosition(int position) {
+            int len = mData.length;
+            while (len <= position) {
+                len *= 2;
+            }
+            return len;
+        }
+
+        void ensureSize(int position) {
+            if (mData == null) {
+                mData = new int[Math.max(position, MIN_SIZE) + 1];
+                Arrays.fill(mData, LayoutParams.INVALID_SPAN_ID);
+            } else if (position >= mData.length) {
+                int[] old = mData;
+                mData = new int[sizeForPosition(position)];
+                System.arraycopy(old, 0, mData, 0, old.length);
+                Arrays.fill(mData, old.length, mData.length, LayoutParams.INVALID_SPAN_ID);
+            }
+        }
+
+        void clear() {
+            if (mData != null) {
+                Arrays.fill(mData, LayoutParams.INVALID_SPAN_ID);
+            }
+            mFullSpanItems = null;
+        }
+
+        void offsetForRemoval(int positionStart, int itemCount) {
+            if (mData == null || positionStart >= mData.length) {
+                return;
+            }
+            ensureSize(positionStart + itemCount);
+            System.arraycopy(mData, positionStart + itemCount, mData, positionStart,
+                    mData.length - positionStart - itemCount);
+            Arrays.fill(mData, mData.length - itemCount, mData.length,
+                    LayoutParams.INVALID_SPAN_ID);
+            offsetFullSpansForRemoval(positionStart, itemCount);
+        }
+
+        private void offsetFullSpansForRemoval(int positionStart, int itemCount) {
+            if (mFullSpanItems == null) {
+                return;
+            }
+            final int end = positionStart + itemCount;
+            for (int i = mFullSpanItems.size() - 1; i >= 0; i--) {
+                FullSpanItem fsi = mFullSpanItems.get(i);
+                if (fsi.mPosition < positionStart) {
+                    continue;
+                }
+                if (fsi.mPosition < end) {
+                    mFullSpanItems.remove(i);
+                } else {
+                    fsi.mPosition -= itemCount;
+                }
+            }
+        }
+
+        void offsetForAddition(int positionStart, int itemCount) {
+            if (mData == null || positionStart >= mData.length) {
+                return;
+            }
+            ensureSize(positionStart + itemCount);
+            System.arraycopy(mData, positionStart, mData, positionStart + itemCount,
+                    mData.length - positionStart - itemCount);
+            Arrays.fill(mData, positionStart, positionStart + itemCount,
+                    LayoutParams.INVALID_SPAN_ID);
+            offsetFullSpansForAddition(positionStart, itemCount);
+        }
+
+        private void offsetFullSpansForAddition(int positionStart, int itemCount) {
+            if (mFullSpanItems == null) {
+                return;
+            }
+            for (int i = mFullSpanItems.size() - 1; i >= 0; i--) {
+                FullSpanItem fsi = mFullSpanItems.get(i);
+                if (fsi.mPosition < positionStart) {
+                    continue;
+                }
+                fsi.mPosition += itemCount;
+            }
+        }
+
+        /**
+         * Returns when invalidation should end. e.g. hitting a full span position.
+         * Returned position SHOULD BE invalidated.
+         */
+        private int invalidateFullSpansAfter(int position) {
+            if (mFullSpanItems == null) {
+                return RecyclerView.NO_POSITION;
+            }
+            final FullSpanItem item = getFullSpanItem(position);
+            // if there is an fsi at this position, get rid of it.
+            if (item != null) {
+                mFullSpanItems.remove(item);
+            }
+            int nextFsiIndex = -1;
+            final int count = mFullSpanItems.size();
+            for (int i = 0; i < count; i++) {
+                FullSpanItem fsi = mFullSpanItems.get(i);
+                if (fsi.mPosition >= position) {
+                    nextFsiIndex = i;
+                    break;
+                }
+            }
+            if (nextFsiIndex != -1) {
+                FullSpanItem fsi = mFullSpanItems.get(nextFsiIndex);
+                mFullSpanItems.remove(nextFsiIndex);
+                return fsi.mPosition;
+            }
+            return RecyclerView.NO_POSITION;
+        }
+
+        public void addFullSpanItem(FullSpanItem fullSpanItem) {
+            if (mFullSpanItems == null) {
+                mFullSpanItems = new ArrayList<FullSpanItem>();
+            }
+            final int size = mFullSpanItems.size();
+            for (int i = 0; i < size; i++) {
+                FullSpanItem other = mFullSpanItems.get(i);
+                if (other.mPosition == fullSpanItem.mPosition) {
+                    if (DEBUG) {
+                        throw new IllegalStateException("two fsis for same position");
+                    } else {
+                        mFullSpanItems.remove(i);
+                    }
+                }
+                if (other.mPosition >= fullSpanItem.mPosition) {
+                    mFullSpanItems.add(i, fullSpanItem);
+                    return;
+                }
+            }
+            // if it is not added to a position.
+            mFullSpanItems.add(fullSpanItem);
+        }
+
+        public FullSpanItem getFullSpanItem(int position) {
+            if (mFullSpanItems == null) {
+                return null;
+            }
+            for (int i = mFullSpanItems.size() - 1; i >= 0; i--) {
+                final FullSpanItem fsi = mFullSpanItems.get(i);
+                if (fsi.mPosition == position) {
+                    return fsi;
+                }
+            }
+            return null;
+        }
+
+        /**
+         * @param minPos inclusive
+         * @param maxPos exclusive
+         * @param gapDir if not 0, returns FSIs on in that direction
+         * @param hasUnwantedGapAfter If true, when full span item has unwanted gaps, it will be
+         *                        returned even if its gap direction does not match.
+         */
+        public FullSpanItem getFirstFullSpanItemInRange(int minPos, int maxPos, int gapDir,
+                boolean hasUnwantedGapAfter) {
+            if (mFullSpanItems == null) {
+                return null;
+            }
+            final int limit = mFullSpanItems.size();
+            for (int i = 0; i < limit; i++) {
+                FullSpanItem fsi = mFullSpanItems.get(i);
+                if (fsi.mPosition >= maxPos) {
+                    return null;
+                }
+                if (fsi.mPosition >= minPos
+                        && (gapDir == 0 || fsi.mGapDir == gapDir ||
+                        (hasUnwantedGapAfter && fsi.mHasUnwantedGapAfter))) {
+                    return fsi;
+                }
+            }
+            return null;
+        }
+
+        /**
+         * We keep information about full span items because they may create gaps in the UI.
+         */
+        static class FullSpanItem implements Parcelable {
+
+            int mPosition;
+            int mGapDir;
+            int[] mGapPerSpan;
+            // A full span may be laid out in primary direction but may have gaps due to
+            // invalidation of views after it. This is recorded during a reverse scroll and if
+            // view is still on the screen after scroll stops, we have to recalculate layout
+            boolean mHasUnwantedGapAfter;
+
+            public FullSpanItem(Parcel in) {
+                mPosition = in.readInt();
+                mGapDir = in.readInt();
+                mHasUnwantedGapAfter = in.readInt() == 1;
+                int spanCount = in.readInt();
+                if (spanCount > 0) {
+                    mGapPerSpan = new int[spanCount];
+                    in.readIntArray(mGapPerSpan);
+                }
+            }
+
+            public FullSpanItem() {
+            }
+
+            int getGapForSpan(int spanIndex) {
+                return mGapPerSpan == null ? 0 : mGapPerSpan[spanIndex];
+            }
+
+            public void invalidateSpanGaps() {
+                mGapPerSpan = null;
+            }
+
+            @Override
+            public int describeContents() {
+                return 0;
+            }
+
+            @Override
+            public void writeToParcel(Parcel dest, int flags) {
+                dest.writeInt(mPosition);
+                dest.writeInt(mGapDir);
+                dest.writeInt(mHasUnwantedGapAfter ? 1 : 0);
+                if (mGapPerSpan != null && mGapPerSpan.length > 0) {
+                    dest.writeInt(mGapPerSpan.length);
+                    dest.writeIntArray(mGapPerSpan);
+                } else {
+                    dest.writeInt(0);
+                }
+            }
+
+            @Override
+            public String toString() {
+                return "FullSpanItem{" +
+                        "mPosition=" + mPosition +
+                        ", mGapDir=" + mGapDir +
+                        ", mHasUnwantedGapAfter=" + mHasUnwantedGapAfter +
+                        ", mGapPerSpan=" + Arrays.toString(mGapPerSpan) +
+                        '}';
+            }
+
+            public static final Parcelable.Creator<FullSpanItem> CREATOR
+                    = new Parcelable.Creator<FullSpanItem>() {
+                @Override
+                public FullSpanItem createFromParcel(Parcel in) {
+                    return new FullSpanItem(in);
+                }
+
+                @Override
+                public FullSpanItem[] newArray(int size) {
+                    return new FullSpanItem[size];
+                }
+            };
+        }
+    }
+
+    static class SavedState implements Parcelable {
+
+        int mAnchorPosition;
+        int mVisibleAnchorPosition; // Replacement for span info when spans are invalidated
+        int mSpanOffsetsSize;
+        int[] mSpanOffsets;
+        int mSpanLookupSize;
+        int[] mSpanLookup;
+        List<LazySpanLookup.FullSpanItem> mFullSpanItems;
+        boolean mReverseLayout;
+        boolean mAnchorLayoutFromEnd;
+        boolean mLastLayoutRTL;
+
+        public SavedState() {
+        }
+
+        SavedState(Parcel in) {
+            mAnchorPosition = in.readInt();
+            mVisibleAnchorPosition = in.readInt();
+            mSpanOffsetsSize = in.readInt();
+            if (mSpanOffsetsSize > 0) {
+                mSpanOffsets = new int[mSpanOffsetsSize];
+                in.readIntArray(mSpanOffsets);
+            }
+
+            mSpanLookupSize = in.readInt();
+            if (mSpanLookupSize > 0) {
+                mSpanLookup = new int[mSpanLookupSize];
+                in.readIntArray(mSpanLookup);
+            }
+            mReverseLayout = in.readInt() == 1;
+            mAnchorLayoutFromEnd = in.readInt() == 1;
+            mLastLayoutRTL = in.readInt() == 1;
+            mFullSpanItems = in.readArrayList(
+                    LazySpanLookup.FullSpanItem.class.getClassLoader());
+        }
+
+        public SavedState(SavedState other) {
+            mSpanOffsetsSize = other.mSpanOffsetsSize;
+            mAnchorPosition = other.mAnchorPosition;
+            mVisibleAnchorPosition = other.mVisibleAnchorPosition;
+            mSpanOffsets = other.mSpanOffsets;
+            mSpanLookupSize = other.mSpanLookupSize;
+            mSpanLookup = other.mSpanLookup;
+            mReverseLayout = other.mReverseLayout;
+            mAnchorLayoutFromEnd = other.mAnchorLayoutFromEnd;
+            mLastLayoutRTL = other.mLastLayoutRTL;
+            mFullSpanItems = other.mFullSpanItems;
+        }
+
+        void invalidateSpanInfo() {
+            mSpanOffsets = null;
+            mSpanOffsetsSize = 0;
+            mSpanLookupSize = 0;
+            mSpanLookup = null;
+            mFullSpanItems = null;
+        }
+
+        void invalidateAnchorPositionInfo() {
+            mSpanOffsets = null;
+            mSpanOffsetsSize = 0;
+            mAnchorPosition = NO_POSITION;
+            mVisibleAnchorPosition = NO_POSITION;
+        }
+
+        @Override
+        public int describeContents() {
+            return 0;
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeInt(mAnchorPosition);
+            dest.writeInt(mVisibleAnchorPosition);
+            dest.writeInt(mSpanOffsetsSize);
+            if (mSpanOffsetsSize > 0) {
+                dest.writeIntArray(mSpanOffsets);
+            }
+            dest.writeInt(mSpanLookupSize);
+            if (mSpanLookupSize > 0) {
+                dest.writeIntArray(mSpanLookup);
+            }
+            dest.writeInt(mReverseLayout ? 1 : 0);
+            dest.writeInt(mAnchorLayoutFromEnd ? 1 : 0);
+            dest.writeInt(mLastLayoutRTL ? 1 : 0);
+            dest.writeList(mFullSpanItems);
+        }
+
+        public static final Parcelable.Creator<SavedState> CREATOR
+                = new Parcelable.Creator<SavedState>() {
+            @Override
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            @Override
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+
+    /**
+     * Data class to hold the information about an anchor position which is used in onLayout call.
+     */
+    private class AnchorInfo {
+
+        int mPosition;
+        int mOffset;
+        boolean mLayoutFromEnd;
+        boolean mInvalidateOffsets;
+
+        void reset() {
+            mPosition = NO_POSITION;
+            mOffset = INVALID_OFFSET;
+            mLayoutFromEnd = false;
+            mInvalidateOffsets = false;
+        }
+
+        void assignCoordinateFromPadding() {
+            mOffset = mLayoutFromEnd ? mPrimaryOrientation.getEndAfterPadding()
+                    : mPrimaryOrientation.getStartAfterPadding();
+        }
+
+        void assignCoordinateFromPadding(int addedDistance) {
+            if (mLayoutFromEnd) {
+                mOffset = mPrimaryOrientation.getEndAfterPadding() - addedDistance;
+            } else {
+                mOffset = mPrimaryOrientation.getStartAfterPadding() + addedDistance;
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/android/support/widget/util/SortedListAdapterCallback.java b/TMessagesProj/src/main/java/org/telegram/android/support/widget/util/SortedListAdapterCallback.java
new file mode 100644
index 000000000..44ddd667e
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/android/support/widget/util/SortedListAdapterCallback.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.telegram.android.support.widget.util;
+
+import android.support.v7.util.SortedList;
+import org.telegram.android.support.widget.RecyclerView;
+
+/**
+ * A {@link SortedList.Callback} implementation that can bind a {@link SortedList} to a
+ * {@link RecyclerView.Adapter}.
+ */
+public abstract class SortedListAdapterCallback<T2> extends SortedList.Callback<T2> {
+
+    final RecyclerView.Adapter mAdapter;
+
+    /**
+     * Creates a {@link SortedList.Callback} that will forward data change events to the provided
+     * Adapter.
+     *
+     * @param adapter The Adapter instance which should receive events from the SortedList.
+     */
+    public SortedListAdapterCallback(RecyclerView.Adapter adapter) {
+        mAdapter = adapter;
+    }
+
+    @Override
+    public void onInserted(int position, int count) {
+        mAdapter.notifyItemRangeInserted(position, count);
+    }
+
+    @Override
+    public void onRemoved(int position, int count) {
+        mAdapter.notifyItemRangeRemoved(position, count);
+    }
+
+    @Override
+    public void onMoved(int fromPosition, int toPosition) {
+        mAdapter.notifyItemMoved(fromPosition, toPosition);
+    }
+
+    @Override
+    public void onChanged(int position, int count) {
+        mAdapter.notifyItemRangeChanged(position, count);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java b/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
deleted file mode 100644
index 3ccd1a78d..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * This is the source code of Telegram for Android v. 1.3.x.
- * It is licensed under GNU GPL v. 2 or later.
- * You should have received a copy of the license in this archive (see LICENSE).
- *
- * Copyright Nikolai Kudashov, 2013-2014.
- */
-
-package org.telegram.messenger;
-
-public class BuildVars {
-    public static boolean DEBUG_VERSION = false;
-    public static int BUILD_VERSION = 521;
-    public static int APP_ID = 16623; //obtain your own APP_ID at https://core.telegram.org/api/obtaining_api_id
-    public static String APP_HASH = "8c9dbfe58437d1739540f5d53c72ae4b"; //obtain your own APP_HASH at https://core.telegram.org/api/obtaining_api_id
-    public static String HOCKEY_APP_HASH = "9602f502a85552c90543497e91a071f0";//"a5b5c4f551dadedc9918d9766a22ca7c";
-    public static String GCM_SENDER_ID = "326898382893";
-    public static String SEND_LOGS_EMAIL = "androiddeveloperplus@gmail.com";
-    public static String BING_SEARCH_KEY = "dKYt6BjhkmFnJABZI/nWs++mx7owYEKZLcdA3DTOO1s"; //obtain your own KEY at https://www.bing.com/dev/en-us/dev-center
-    public static String FOURSQUARE_API_KEY = "AYVLOEUWYPLCHN113NI41GHUE2NVHO4NHA5XLZWJU152N3ZP"; //obtain your own KEY at https://developer.foursquare.com/
-    public static String FOURSQUARE_API_ID = "CRY3VMYDJYBKQQDCZ4YY3ZAACTIITLVMBUUEDSPRXNZVZZA1"; //obtain your own API_ID at https://developer.foursquare.com/
-    public static String FOURSQUARE_API_VERSION = "20150326";
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ByteArrayOutputStreamExpand.java b/TMessagesProj/src/main/java/org/telegram/messenger/ByteArrayOutputStreamExpand.java
new file mode 100644
index 000000000..b82131fef
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ByteArrayOutputStreamExpand.java
@@ -0,0 +1,81 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.messenger;
+
+import java.io.OutputStream;
+
+public class ByteArrayOutputStreamExpand extends OutputStream {
+
+    protected byte[] buf;
+    protected int count;
+
+    public ByteArrayOutputStreamExpand() {
+        buf = new byte[32];
+    }
+
+    public ByteArrayOutputStreamExpand(int size) {
+        if (size >= 0) {
+            buf = new byte[size];
+        } else {
+            throw new IllegalArgumentException("size < 0");
+        }
+    }
+
+    private void expand(int i) {
+        if (count + i <= buf.length) {
+            return;
+        }
+
+        byte[] newbuf = new byte[count + i];
+        System.arraycopy(buf, 0, newbuf, 0, count);
+        buf = newbuf;
+    }
+
+    public synchronized void reset() {
+        count = 0;
+    }
+
+    public int size() {
+        return count;
+    }
+
+    public byte[] toByteArray() {
+        return buf;
+    }
+
+    @Override
+    public String toString() {
+        return new String(buf, 0, count);
+    }
+
+    @Override
+    public void write(byte[] buffer, int offset, int len) {
+        checkOffsetAndCount(buffer.length, offset, len);
+        if (len == 0) {
+            return;
+        }
+        expand(len);
+        System.arraycopy(buffer, offset, buf, this.count, len);
+        this.count += len;
+    }
+
+    @Override
+    public void write(int oneByte) {
+        if (count == buf.length) {
+            expand(1);
+        }
+        buf[count++] = (byte) oneByte;
+    }
+
+    public void checkOffsetAndCount(int arrayLength, int offset, int count) {
+        if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+            throw new ArrayIndexOutOfBoundsException("length=" + arrayLength + "; regionStart=" + offset + "; regionLength=" + count);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseLocationAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseLocationAdapter.java
new file mode 100644
index 000000000..81d26e865
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseLocationAdapter.java
@@ -0,0 +1,222 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Adapters;
+
+import android.location.Location;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.volley.Request;
+import org.telegram.android.volley.RequestQueue;
+import org.telegram.android.volley.Response;
+import org.telegram.android.volley.VolleyError;
+import org.telegram.android.volley.toolbox.JsonObjectRequest;
+import org.telegram.android.volley.toolbox.Volley;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.BuildVars;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.TLRPC;
+
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.Locale;
+import java.util.Timer;
+import java.util.TimerTask;
+
+public class BaseLocationAdapter extends BaseFragmentAdapter {
+
+    public interface BaseLocationAdapterDelegate {
+        void didLoadedSearchResult(ArrayList<TLRPC.TL_messageMediaVenue> places);
+    }
+
+    private RequestQueue requestQueue;
+    protected boolean searching;
+    protected ArrayList<TLRPC.TL_messageMediaVenue> places = new ArrayList<>();
+    protected ArrayList<String> iconUrls = new ArrayList<>();
+    private Location lastSearchLocation;
+    private BaseLocationAdapterDelegate delegate;
+    private Timer searchTimer;
+
+    public BaseLocationAdapter() {
+        requestQueue = Volley.newRequestQueue(ApplicationLoader.applicationContext);
+    }
+
+    public void destroy() {
+        if (requestQueue != null) {
+            requestQueue.cancelAll("search");
+            requestQueue.stop();
+        }
+    }
+
+    public void setDelegate(BaseLocationAdapterDelegate delegate) {
+        this.delegate = delegate;
+    }
+
+    public void searchDelayed(final String query, final Location coordinate) {
+        if (query == null || query.length() == 0) {
+            places.clear();
+            notifyDataSetChanged();
+        } else {
+            try {
+                if (searchTimer != null) {
+                    searchTimer.cancel();
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+            searchTimer = new Timer();
+            searchTimer.schedule(new TimerTask() {
+                @Override
+                public void run() {
+                    try {
+                        searchTimer.cancel();
+                        searchTimer = null;
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            lastSearchLocation = null;
+                            searchGooglePlacesWithQuery(query, coordinate);
+                        }
+                    });
+                }
+            }, 200, 500);
+        }
+    }
+
+    public void searchGooglePlacesWithQuery(final String query, final Location coordinate) {
+        if (lastSearchLocation != null && coordinate.distanceTo(lastSearchLocation) < 200) {
+            return;
+        }
+        lastSearchLocation = coordinate;
+        if (searching) {
+            searching = false;
+            requestQueue.cancelAll("search");
+        }
+        try {
+            searching = true;
+            String url = String.format(Locale.US, "https://api.foursquare.com/v2/venues/search/?v=%s&locale=en&limit=25&client_id=%s&client_secret=%s&ll=%s", BuildVars.FOURSQUARE_API_VERSION, BuildVars.FOURSQUARE_API_ID, BuildVars.FOURSQUARE_API_KEY,  String.format(Locale.US, "%f,%f", coordinate.getLatitude(), coordinate.getLongitude()));
+            if (query != null && query.length() > 0) {
+                url += "&query=" + URLEncoder.encode(query, "UTF-8");
+            }
+            JsonObjectRequest jsonObjReq = new JsonObjectRequest(Request.Method.GET, url, null,
+                    new Response.Listener<JSONObject>() {
+                        @Override
+                        public void onResponse(JSONObject response) {
+                            try {
+                                places.clear();
+                                iconUrls.clear();
+                                /*
+                                GOOGLE MAPS
+                                JSONArray result = response.getJSONArray("results");
+
+                                for (int a = 0; a < result.length(); a++) {
+                                    try {
+                                        JSONObject object = result.getJSONObject(a);
+                                        JSONObject location = object.getJSONObject("geometry").getJSONObject("location");
+                                        TLRPC.TL_messageMediaVenue venue = new TLRPC.TL_messageMediaVenue();
+                                        venue.geo = new TLRPC.TL_geoPoint();
+                                        venue.geo.lat = location.getDouble("lat");
+                                        venue.geo._long = location.getDouble("lng");
+                                        if (object.has("vicinity")) {
+                                            venue.address = object.getString("vicinity").trim();
+                                        } else {
+                                            venue.address = String.format(Locale.US, "%f,%f", venue.geo.lat, venue.geo._long);
+                                        }
+                                        if (object.has("name")) {
+                                            venue.title = object.getString("name").trim();
+                                        }
+                                        venue.venue_id = object.getString("place_id");
+                                        venue.provider = "google";
+                                        places.add(venue);
+                                    } catch (Exception e) {
+                                        FileLog.e("tmessages", e);
+                                    }
+                                }
+                                 */
+                                JSONArray result = response.getJSONObject("response").getJSONArray("venues");
+
+                                for (int a = 0; a < result.length(); a++) {
+                                    try {
+                                        JSONObject object = result.getJSONObject(a);
+                                        String iconUrl = null;
+                                        if (object.has("categories")) {
+                                            JSONArray categories = object.getJSONArray("categories");
+                                            if (categories.length() > 0) {
+                                                JSONObject category = categories.getJSONObject(0);
+                                                if (category.has("icon")) {
+                                                    JSONObject icon = category.getJSONObject("icon");
+                                                    iconUrl = String.format(Locale.US, "%s64%s", icon.getString("prefix"), icon.getString("suffix"));
+                                                }
+                                            }
+                                        }
+                                        iconUrls.add(iconUrl);
+
+                                        JSONObject location = object.getJSONObject("location");
+                                        TLRPC.TL_messageMediaVenue venue = new TLRPC.TL_messageMediaVenue();
+                                        venue.geo = new TLRPC.TL_geoPoint();
+                                        venue.geo.lat = location.getDouble("lat");
+                                        venue.geo._long = location.getDouble("lng");
+                                        if (location.has("address")) {
+                                            venue.address = location.getString("address");
+                                        } else if (location.has("city")) {
+                                            venue.address = location.getString("city");
+                                        } else if (location.has("state")) {
+                                            venue.address = location.getString("state");
+                                        } else if (location.has("country")) {
+                                            venue.address = location.getString("country");
+                                        } else {
+                                            venue.address = String.format(Locale.US, "%f,%f", venue.geo.lat, venue.geo._long);
+                                        }
+                                        if (object.has("name")) {
+                                            venue.title = object.getString("name");
+                                        }
+                                        venue.venue_id = object.getString("id");
+                                        venue.provider = "foursquare";
+                                        places.add(venue);
+                                    } catch (Exception e) {
+                                        FileLog.e("tmessages", e);
+                                    }
+                                }
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                            searching = false;
+                            notifyDataSetChanged();
+                            if (delegate != null) {
+                                delegate.didLoadedSearchResult(places);
+                            }
+                        }
+                    },
+                    new Response.ErrorListener() {
+                        @Override
+                        public void onErrorResponse(VolleyError error) {
+                            FileLog.e("tmessages", "Error: " + error.getMessage());
+                            searching = false;
+                            notifyDataSetChanged();
+                            if (delegate != null) {
+                                delegate.didLoadedSearchResult(places);
+                            }
+                        }
+                    });
+            jsonObjReq.setTag("search");
+            requestQueue.add(jsonObjReq);
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+            searching = false;
+            if (delegate != null) {
+                delegate.didLoadedSearchResult(places);
+            }
+        }
+        notifyDataSetChanged();
+        }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapter.java
new file mode 100644
index 000000000..66ddd338b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapter.java
@@ -0,0 +1,209 @@
+/*
+ * This is the source code of Telegram for Android v. 1.7.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.ui.Adapters;
+
+import org.telegram.SQLite.SQLiteCursor;
+import org.telegram.SQLite.SQLitePreparedStatement;
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.MessagesStorage;
+import org.telegram.messenger.ConnectionsManager;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.RPCRequest;
+import org.telegram.messenger.TLObject;
+import org.telegram.messenger.TLRPC;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class BaseSearchAdapter extends BaseFragmentAdapter {
+
+    protected static class HashtagObject {
+        String hashtag;
+        int date;
+    }
+
+    protected ArrayList<TLRPC.User> globalSearch = new ArrayList<>();
+    private long reqId = 0;
+    private int lastReqId;
+    protected String lastFoundUsername = null;
+
+    protected ArrayList<HashtagObject> hashtags;
+    protected HashMap<String, HashtagObject> hashtagsByText;
+    protected boolean hashtagsLoadedFromDb = false;
+
+    public void queryServerSearch(final String query) {
+        if (reqId != 0) {
+            ConnectionsManager.getInstance().cancelRpc(reqId, true);
+            reqId = 0;
+        }
+        if (query == null || query.length() < 5) {
+            globalSearch.clear();
+            lastReqId = 0;
+            notifyDataSetChanged();
+            return;
+        }
+        TLRPC.TL_contacts_search req = new TLRPC.TL_contacts_search();
+        req.q = query;
+        req.limit = 50;
+        final int currentReqId = ++lastReqId;
+        reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (currentReqId == lastReqId) {
+                            if (error == null) {
+                                TLRPC.TL_contacts_found res = (TLRPC.TL_contacts_found) response;
+                                globalSearch = res.users;
+                                lastFoundUsername = query;
+                                notifyDataSetChanged();
+                            }
+                        }
+                        reqId = 0;
+                    }
+                });
+            }
+        }, true, RPCRequest.RPCRequestClassGeneric | RPCRequest.RPCRequestClassFailOnServerErrors);
+    }
+
+    public void loadRecentHashtags() {
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT id, date FROM hashtag_recent_v2 WHERE 1");
+                    final ArrayList<HashtagObject> arrayList = new ArrayList<>();
+                    final HashMap<String, HashtagObject> hashMap = new HashMap<>();
+                    while (cursor.next()) {
+                        HashtagObject hashtagObject = new HashtagObject();
+                        hashtagObject.hashtag = cursor.stringValue(0);
+                        hashtagObject.date = cursor.intValue(1);
+                        arrayList.add(hashtagObject);
+                        hashMap.put(hashtagObject.hashtag, hashtagObject);
+                    }
+                    cursor.dispose();
+                    Collections.sort(arrayList, new Comparator<HashtagObject>() {
+                        @Override
+                        public int compare(HashtagObject lhs, HashtagObject rhs) {
+                            if (lhs.date < rhs.date) {
+                                return 1;
+                            } else if (lhs.date > rhs.date) {
+                                return -1;
+                            } else {
+                                return 0;
+                            }
+                        }
+                    });
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            setHashtags(arrayList, hashMap);
+                        }
+                    });
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    public void addHashtagsFromMessage(String message) {
+        if (message == null) {
+            return;
+        }
+        boolean changed = false;
+        Pattern pattern = Pattern.compile("(^|\\s)#[\\w@\\.]+");
+        Matcher matcher = pattern.matcher(message);
+        while (matcher.find()) {
+            int start = matcher.start();
+            int end = matcher.end();
+            if (message.charAt(start) != '@' && message.charAt(start) != '#') {
+                start++;
+            }
+            String hashtag = message.substring(start, end);
+            if (hashtagsByText == null) {
+                hashtagsByText = new HashMap<>();
+                hashtags = new ArrayList<>();
+            }
+            HashtagObject hashtagObject = hashtagsByText.get(hashtag);
+            if (hashtagObject == null) {
+                hashtagObject = new HashtagObject();
+                hashtagObject.hashtag = hashtag;
+                hashtagsByText.put(hashtagObject.hashtag, hashtagObject);
+            } else {
+                hashtags.remove(hashtagObject);
+            }
+            hashtagObject.date = (int) (System.currentTimeMillis() / 1000);
+            hashtags.add(0, hashtagObject);
+            changed = true;
+        }
+        if (changed) {
+            putRecentHashtags(hashtags);
+        }
+    }
+
+    private void putRecentHashtags(final ArrayList<HashtagObject> arrayList) {
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    MessagesStorage.getInstance().getDatabase().beginTransaction();
+                    SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("REPLACE INTO hashtag_recent_v2 VALUES(?, ?)");
+                    for (int a = 0; a < arrayList.size(); a++) {
+                        if (a == 100) {
+                            break;
+                        }
+                        HashtagObject hashtagObject = arrayList.get(a);
+                        state.requery();
+                        state.bindString(1, hashtagObject.hashtag);
+                        state.bindInteger(2, hashtagObject.date);
+                        state.step();
+                    }
+                    state.dispose();
+                    MessagesStorage.getInstance().getDatabase().commitTransaction();
+                    if (arrayList.size() >= 100) {
+                        MessagesStorage.getInstance().getDatabase().beginTransaction();
+                        for (int a = 100; a < arrayList.size(); a++) {
+                            MessagesStorage.getInstance().getDatabase().executeFast("DELETE FROM hashtag_recent_v2 WHERE id = '" + arrayList.get(a).hashtag + "'").stepThis().dispose();
+                        }
+                        MessagesStorage.getInstance().getDatabase().commitTransaction();
+                    }
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    public void clearRecentHashtags() {
+        hashtags = new ArrayList<>();
+        hashtagsByText = new HashMap<>();
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    MessagesStorage.getInstance().getDatabase().executeFast("DELETE FROM hashtag_recent_v2 WHERE 1").stepThis().dispose();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
+    protected void setHashtags(ArrayList<HashtagObject> arrayList, HashMap<String, HashtagObject> hashMap) {
+        hashtags = arrayList;
+        hashtagsByText = hashMap;
+        hashtagsLoadedFromDb = true;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java
new file mode 100644
index 000000000..0fd986614
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java
@@ -0,0 +1,396 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Adapters;
+
+public class ChatActivityAdapter {
+
+    /*private Context mContext;
+
+    public ChatAdapter(Context context) {
+        mContext = context;
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return true;
+    }
+
+    @Override
+    public boolean isEnabled(int i) {
+        return true;
+    }
+
+    @Override
+    public int getCount() {
+        int count = messages.size();
+        if (count != 0) {
+            if (!endReached) {
+                count++;
+            }
+            if (!forward_end_reached) {
+                count++;
+            }
+        }
+        return count;
+    }
+
+    @Override
+    public Object getItem(int i) {
+        return null;
+    }
+
+    @Override
+    public long getItemId(int i) {
+        return i;
+    }
+
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    @Override
+    public View getView(int i, View view, ViewGroup viewGroup) {
+        int offset = 1;
+        if ((!endReached || !forward_end_reached) && messages.size() != 0) {
+            if (!endReached) {
+                offset = 0;
+            }
+            if (i == 0 && !endReached || !forward_end_reached && i == (messages.size() + 1 - offset)) {
+                View progressBar = null;
+                if (view == null) {
+                    LayoutInflater li = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                    view = li.inflate(R.layout.chat_loading_layout, viewGroup, false);
+                    progressBar = view.findViewById(R.id.progressLayout);
+                    if (ApplicationLoader.isCustomTheme()) {
+                        progressBar.setBackgroundResource(R.drawable.system_loader2);
+                    } else {
+                        progressBar.setBackgroundResource(R.drawable.system_loader1);
+                    }
+                } else {
+                    progressBar = view.findViewById(R.id.progressLayout);
+                }
+                progressBar.setVisibility(loadsCount > 1 ? View.VISIBLE : View.INVISIBLE);
+
+                return view;
+            }
+        }
+        final MessageObject message = messages.get(messages.size() - i - offset);
+        int type = message.contentType;
+        if (view == null) {
+            if (type == 0) {
+                view = new ChatMessageCell(mContext);
+            }
+            if (type == 1) {
+                view = new ChatMediaCell(mContext);
+            } else if (type == 2) {
+                view = new ChatAudioCell(mContext);
+            } else if (type == 3) {
+                view = new ChatContactCell(mContext);
+            } else if (type == 6) {
+                LayoutInflater li = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                view = li.inflate(R.layout.chat_unread_layout, viewGroup, false);
+            } else if (type == 4) {
+                view = new ChatActionCell(mContext);
+            }
+
+            if (view instanceof ChatBaseCell) {
+                ((ChatBaseCell) view).setDelegate(new ChatBaseCell.ChatBaseCellDelegate() {
+                    @Override
+                    public void didPressedUserAvatar(ChatBaseCell cell, TLRPC.User user) {
+                        if (actionBar.isActionModeShowed()) {
+                            processRowSelect(cell);
+                            return;
+                        }
+                        if (user != null && user.id != UserConfig.getClientUserId()) {
+                            Bundle args = new Bundle();
+                            args.putInt("user_id", user.id);
+                            presentFragment(new ProfileActivity(args));
+                        }
+                    }
+
+                    @Override
+                    public void didPressedCancelSendButton(ChatBaseCell cell) {
+                        MessageObject message = cell.getMessageObject();
+                        if (message.messageOwner.send_state != 0) {
+                            SendMessagesHelper.getInstance().cancelSendingMessage(message);
+                        }
+                    }
+
+                    @Override
+                    public void didLongPressed(ChatBaseCell cell) {
+                        createMenu(cell, false);
+                    }
+
+                    @Override
+                    public boolean canPerformActions() {
+                        return actionBar != null && !actionBar.isActionModeShowed();
+                    }
+
+                    @Override
+                    public void didPressUrl(String url) {
+                        if (url.startsWith("@")) {
+                            openProfileWithUsername(url.substring(1));
+                        } else if (url.startsWith("#")) {
+                            MessagesActivity fragment = new MessagesActivity(null);
+                            fragment.setSearchString(url);
+                            presentFragment(fragment);
+                        }
+                    }
+
+                    @Override
+                    public void didPressReplyMessage(ChatBaseCell cell, int id) {
+                        scrollToMessageId(id, cell.getMessageObject().getId(), true);
+                    }
+                });
+                if (view instanceof ChatMediaCell) {
+                    ((ChatMediaCell) view).setAllowedToSetPhoto(openAnimationEnded);
+                    ((ChatMediaCell) view).setMediaDelegate(new ChatMediaCell.ChatMediaCellDelegate() {
+                        @Override
+                        public void didClickedImage(ChatMediaCell cell) {
+                            MessageObject message = cell.getMessageObject();
+                            if (message.isSendError()) {
+                                createMenu(cell, false);
+                                return;
+                            } else if (message.isSending()) {
+                                return;
+                            }
+                            if (message.type == 1) {
+                                PhotoViewer.getInstance().setParentActivity(getParentActivity());
+                                PhotoViewer.getInstance().openPhoto(message, ChatActivity.this);
+                            } else if (message.type == 3) {
+                                sendSecretMessageRead(message);
+                                try {
+                                    File f = null;
+                                    if (message.messageOwner.attachPath != null && message.messageOwner.attachPath.length() != 0) {
+                                        f = new File(message.messageOwner.attachPath);
+                                    }
+                                    if (f == null || f != null && !f.exists()) {
+                                        f = FileLoader.getPathToMessage(message.messageOwner);
+                                    }
+                                    Intent intent = new Intent(Intent.ACTION_VIEW);
+                                    intent.setDataAndType(Uri.fromFile(f), "video/mp4");
+                                    getParentActivity().startActivityForResult(intent, 500);
+                                } catch (Exception e) {
+                                    alertUserOpenError(message);
+                                }
+                            } else if (message.type == 4) {
+                                if (!isGoogleMapsInstalled()) {
+                                    return;
+                                }
+                                LocationActivity fragment = new LocationActivity();
+                                fragment.setMessageObject(message);
+                                presentFragment(fragment);
+                            } else if (message.type == 9) {
+                                File f = null;
+                                String fileName = message.getFileName();
+                                if (message.messageOwner.attachPath != null && message.messageOwner.attachPath.length() != 0) {
+                                    f = new File(message.messageOwner.attachPath);
+                                }
+                                if (f == null || f != null && !f.exists()) {
+                                    f = FileLoader.getPathToMessage(message.messageOwner);
+                                }
+                                if (f != null && f.exists()) {
+                                    String realMimeType = null;
+                                    try {
+                                        Intent intent = new Intent(Intent.ACTION_VIEW);
+                                        if (message.type == 8 || message.type == 9) {
+                                            MimeTypeMap myMime = MimeTypeMap.getSingleton();
+                                            int idx = fileName.lastIndexOf(".");
+                                            if (idx != -1) {
+                                                String ext = fileName.substring(idx + 1);
+                                                realMimeType = myMime.getMimeTypeFromExtension(ext.toLowerCase());
+                                                if (realMimeType == null) {
+                                                    realMimeType = message.messageOwner.media.document.mime_type;
+                                                    if (realMimeType == null || realMimeType.length() == 0) {
+                                                        realMimeType = null;
+                                                    }
+                                                }
+                                                if (realMimeType != null) {
+                                                    intent.setDataAndType(Uri.fromFile(f), realMimeType);
+                                                } else {
+                                                    intent.setDataAndType(Uri.fromFile(f), "text/plain");
+                                                }
+                                            } else {
+                                                intent.setDataAndType(Uri.fromFile(f), "text/plain");
+                                            }
+                                        }
+                                        if (realMimeType != null) {
+                                            try {
+                                                getParentActivity().startActivityForResult(intent, 500);
+                                            } catch (Exception e) {
+                                                intent.setDataAndType(Uri.fromFile(f), "text/plain");
+                                                getParentActivity().startActivityForResult(intent, 500);
+                                            }
+                                        } else {
+                                            getParentActivity().startActivityForResult(intent, 500);
+                                        }
+                                    } catch (Exception e) {
+                                        alertUserOpenError(message);
+                                    }
+                                }
+                            }
+                        }
+
+                        @Override
+                        public void didPressedOther(ChatMediaCell cell) {
+                            createMenu(cell, true);
+                        }
+                    });
+                } else if (view instanceof ChatContactCell) {
+                    ((ChatContactCell) view).setContactDelegate(new ChatContactCell.ChatContactCellDelegate() {
+                        @Override
+                        public void didClickAddButton(ChatContactCell cell, TLRPC.User user) {
+                            if (actionBar.isActionModeShowed()) {
+                                processRowSelect(cell);
+                                return;
+                            }
+                            MessageObject messageObject = cell.getMessageObject();
+                            Bundle args = new Bundle();
+                            args.putInt("user_id", messageObject.messageOwner.media.user_id);
+                            args.putString("phone", messageObject.messageOwner.media.phone_number);
+                            args.putBoolean("addContact", true);
+                            presentFragment(new ContactAddActivity(args));
+                        }
+
+                        @Override
+                        public void didClickPhone(ChatContactCell cell) {
+                            if (actionBar.isActionModeShowed()) {
+                                processRowSelect(cell);
+                                return;
+                            }
+                            final MessageObject messageObject = cell.getMessageObject();
+                            if (getParentActivity() == null || messageObject.messageOwner.media.phone_number == null || messageObject.messageOwner.media.phone_number.length() == 0) {
+                                return;
+                            }
+                            AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                            builder.setItems(new CharSequence[]{LocaleController.getString("Copy", R.string.Copy), LocaleController.getString("Call", R.string.Call)}, new DialogInterface.OnClickListener() {
+                                        @Override
+                                        public void onClick(DialogInterface dialogInterface, int i) {
+                                            if (i == 1) {
+                                                try {
+                                                    Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + messageObject.messageOwner.media.phone_number));
+                                                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                                                    getParentActivity().startActivityForResult(intent, 500);
+                                                } catch (Exception e) {
+                                                    FileLog.e("tmessages", e);
+                                                }
+                                            } else if (i == 0) {
+                                                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
+                                                    android.text.ClipboardManager clipboard = (android.text.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                                                    clipboard.setText(messageObject.messageOwner.media.phone_number);
+                                                } else {
+                                                    android.content.ClipboardManager clipboard = (android.content.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                                                    android.content.ClipData clip = android.content.ClipData.newPlainText("label", messageObject.messageOwner.media.phone_number);
+                                                    clipboard.setPrimaryClip(clip);
+                                                }
+                                            }
+                                        }
+                                    }
+                            );
+                            showAlertDialog(builder);
+                        }
+                    });
+                }
+            } else if (view instanceof ChatActionCell) {
+                ((ChatActionCell) view).setDelegate(new ChatActionCell.ChatActionCellDelegate() {
+                    @Override
+                    public void didClickedImage(ChatActionCell cell) {
+                        MessageObject message = cell.getMessageObject();
+                        PhotoViewer.getInstance().setParentActivity(getParentActivity());
+                        PhotoViewer.getInstance().openPhoto(message, ChatActivity.this);
+                    }
+
+                    @Override
+                    public void didLongPressed(ChatActionCell cell) {
+                        createMenu(cell, false);
+                    }
+
+                    @Override
+                    public void needOpenUserProfile(int uid) {
+                        if (uid != UserConfig.getClientUserId()) {
+                            Bundle args = new Bundle();
+                            args.putInt("user_id", uid);
+                            presentFragment(new ProfileActivity(args));
+                        }
+                    }
+                });
+            }
+        }
+
+        boolean selected = false;
+        boolean disableSelection = false;
+        if (actionBar.isActionModeShowed()) {
+            if (selectedMessagesIds.containsKey(message.getId())) {
+                view.setBackgroundColor(0x6633b5e5);
+                selected = true;
+            } else {
+                view.setBackgroundColor(0);
+            }
+            disableSelection = true;
+        } else {
+            view.setBackgroundColor(0);
+        }
+
+        if (view instanceof ChatBaseCell) {
+            ChatBaseCell baseCell = (ChatBaseCell) view;
+            baseCell.isChat = currentChat != null;
+            baseCell.setMessageObject(message);
+            baseCell.setCheckPressed(!disableSelection, disableSelection && selected);
+            if (view instanceof ChatAudioCell && MediaController.getInstance().canDownloadMedia(MediaController.AUTODOWNLOAD_MASK_AUDIO)) {
+                ((ChatAudioCell) view).downloadAudioIfNeed();
+            }
+            baseCell.setHighlighted(highlightMessageId != Integer.MAX_VALUE && message.getId() == highlightMessageId);
+        } else if (view instanceof ChatActionCell) {
+            ChatActionCell actionCell = (ChatActionCell) view;
+            actionCell.setMessageObject(message);
+        }
+        if (type == 6) {
+            TextView messageTextView = (TextView) view.findViewById(R.id.chat_message_text);
+            messageTextView.setText(LocaleController.formatPluralString("NewMessages", unread_to_load));
+        }
+
+        return view;
+    }
+
+    @Override
+    public int getItemViewType(int i) {
+        int offset = 1;
+        if (!endReached && messages.size() != 0) {
+            offset = 0;
+            if (i == 0) {
+                return 5;
+            }
+        }
+        if (!forward_end_reached && i == (messages.size() + 1 - offset)) {
+            return 5;
+        }
+        MessageObject message = messages.get(messages.size() - i - offset);
+        return message.contentType;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return 7;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        int count = messages.size();
+        if (count != 0) {
+            if (!endReached) {
+                count++;
+            }
+            if (!forward_end_reached) {
+                count++;
+            }
+        }
+        return count == 0;
+    }*/
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivityAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivityAdapter.java
new file mode 100644
index 000000000..73d7686c1
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivityAdapter.java
@@ -0,0 +1,167 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Adapters;
+
+import android.content.Context;
+import android.location.Location;
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Cells.EmptyCell;
+import org.telegram.ui.Cells.GreySectionCell;
+import org.telegram.ui.Cells.LocationCell;
+import org.telegram.ui.Cells.LocationLoadingCell;
+import org.telegram.ui.Cells.LocationPoweredCell;
+import org.telegram.ui.Cells.SendLocationCell;
+
+import java.util.Locale;
+
+public class LocationActivityAdapter extends BaseLocationAdapter {
+
+    private Context mContext;
+    private int overScrollHeight;
+    private SendLocationCell sendLocationCell;
+    private Location gpsLocation;
+    private Location customLocation;
+
+    public LocationActivityAdapter(Context context) {
+        super();
+        mContext = context;
+    }
+
+    public void setOverScrollHeight(int value) {
+        overScrollHeight = value;
+    }
+
+    public void setGpsLocation(Location location) {
+        gpsLocation = location;
+        updateCell();
+    }
+
+    public void setCustomLocation(Location location) {
+        customLocation = location;
+        updateCell();
+    }
+
+    private void updateCell() {
+        if (sendLocationCell != null) {
+            if (customLocation != null) {
+                sendLocationCell.setText(LocaleController.getString("SendSelectedLocation", R.string.SendSelectedLocation), String.format(Locale.US, "(%f,%f)", customLocation.getLatitude(), customLocation.getLongitude()));
+            } else {
+                if (gpsLocation != null) {
+                    sendLocationCell.setText(LocaleController.getString("SendLocation", R.string.SendLocation), LocaleController.formatString("AccurateTo", R.string.AccurateTo, LocaleController.formatPluralString("Meters", (int) gpsLocation.getAccuracy())));
+                } else {
+                    sendLocationCell.setText(LocaleController.getString("SendLocation", R.string.SendLocation), LocaleController.getString("Loading", R.string.Loading));
+                }
+            }
+        }
+    }
+
+    @Override
+    public int getCount() {
+        if (searching || !searching && places.isEmpty()) {
+            return 4;
+        }
+        return 3 + places.size() + (places.isEmpty() ? 0 : 1);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return false;
+    }
+
+    @Override
+    public View getView(int i, View view, ViewGroup viewGroup) {
+        if (i == 0) {
+            if (view == null) {
+                view = new EmptyCell(mContext);
+            }
+            ((EmptyCell) view).setHeight(overScrollHeight);
+        } else if (i == 1) {
+            if (view == null) {
+                view = new SendLocationCell(mContext);
+            }
+            sendLocationCell = (SendLocationCell) view;
+            updateCell();
+            return view;
+        } else if (i == 2) {
+            if (view == null) {
+                view = new GreySectionCell(mContext);
+            }
+            ((GreySectionCell) view).setText(LocaleController.getString("NearbyPlaces", R.string.NearbyPlaces));
+        } else if (searching || !searching && places.isEmpty()) {
+            if (view == null) {
+                view = new LocationLoadingCell(mContext);
+            }
+            ((LocationLoadingCell) view).setLoading(searching);
+        } else if (i == places.size() + 3) {
+            if (view == null) {
+                view = new LocationPoweredCell(mContext);
+            }
+        } else {
+            if (view == null) {
+                view = new LocationCell(mContext);
+            }
+            ((LocationCell) view).setLocation(places.get(i - 3), iconUrls.get(i - 3), true);
+        }
+        return view;
+    }
+
+    @Override
+    public TLRPC.TL_messageMediaVenue getItem(int i) {
+        if (i > 2 && i < places.size() + 3) {
+            return places.get(i - 3);
+        }
+        return null;
+    }
+
+    @Override
+    public long getItemId(int i) {
+        return i;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        if (position == 0) {
+            return 0;
+        } else if (position == 1) {
+            return 1;
+        } else if (position == 2) {
+            return 2;
+        } else if (searching || !searching && places.isEmpty()) {
+            return 4;
+        } else if (position == places.size() + 3) {
+            return 5;
+        }
+        return 3;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return 6;
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return false;
+    }
+
+    @Override
+    public boolean isEnabled(int position) {
+        return !(position == 2 || position == 0 || position == 3 && (searching || !searching && places.isEmpty()) || position == places.size() + 3);
+    }
+
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivitySearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivitySearchAdapter.java
new file mode 100644
index 000000000..2da45562e
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivitySearchAdapter.java
@@ -0,0 +1,83 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Adapters;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Cells.LocationCell;
+
+public class LocationActivitySearchAdapter extends BaseLocationAdapter {
+
+    private Context mContext;
+
+    public LocationActivitySearchAdapter(Context context) {
+        super();
+        mContext = context;
+    }
+
+    @Override
+    public int getCount() {
+        return places.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return places.isEmpty();
+    }
+
+    @Override
+    public View getView(int i, View view, ViewGroup viewGroup) {
+        if (view == null) {
+            view = new LocationCell(mContext);
+        }
+        ((LocationCell) view).setLocation(places.get(i), iconUrls.get(i), i != places.size() - 1);
+        return view;
+    }
+
+    @Override
+    public TLRPC.TL_messageMediaVenue getItem(int i) {
+        if (i >= 0 && i < places.size()) {
+            return places.get(i);
+        }
+        return null;
+    }
+
+    @Override
+    public long getItemId(int i) {
+        return i;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        return 0;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return 4;
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return false;
+    }
+
+    @Override
+    public boolean isEnabled(int position) {
+        return true;
+    }
+
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java
new file mode 100644
index 000000000..312038997
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java
@@ -0,0 +1,275 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Adapters;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.telegram.android.MessageObject;
+import org.telegram.android.MessagesController;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Cells.MentionCell;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+
+public class MentionsAdapter extends BaseSearchAdapter {
+
+    public interface MentionsAdapterDelegate {
+        void needChangePanelVisibility(boolean show);
+    }
+
+    private Context mContext;
+    private TLRPC.ChatParticipants info;
+    private ArrayList<TLRPC.User> searchResultUsernames;
+    private ArrayList<String> searchResultHashtags;
+    private MentionsAdapterDelegate delegate;
+    private int resultStartPosition;
+    private int resultLength;
+    private String lastText;
+    private int lastPosition;
+    private ArrayList<MessageObject> messages;
+    private boolean needUsernames = true;
+    private boolean isDarkTheme;
+
+    public MentionsAdapter(Context context, boolean isDarkTheme, MentionsAdapterDelegate delegate) {
+        mContext = context;
+        this.delegate = delegate;
+        this.isDarkTheme = isDarkTheme;
+    }
+
+    public void setChatInfo(TLRPC.ChatParticipants chatParticipants) {
+        info = chatParticipants;
+        if (lastText != null) {
+            searchUsernameOrHashtag(lastText, lastPosition, messages);
+        }
+    }
+
+    public void setNeedUsernames(boolean value) {
+        needUsernames = value;
+    }
+
+    @Override
+    public void clearRecentHashtags() {
+        super.clearRecentHashtags();
+        searchResultHashtags.clear();
+        notifyDataSetChanged();
+        if (delegate != null) {
+            delegate.needChangePanelVisibility(false);
+        }
+    }
+
+    @Override
+    protected void setHashtags(ArrayList<HashtagObject> arrayList, HashMap<String, HashtagObject> hashMap) {
+        super.setHashtags(arrayList, hashMap);
+        if (lastText != null) {
+            searchUsernameOrHashtag(lastText, lastPosition, messages);
+        }
+    }
+
+    public void searchUsernameOrHashtag(String text, int position, ArrayList<MessageObject> messageObjects) {
+        if (text == null || text.length() == 0) {
+            delegate.needChangePanelVisibility(false);
+            lastText = null;
+            return;
+        }
+        int searchPostion = position;
+        if (text.length() > 0) {
+            searchPostion--;
+        }
+        lastText = null;
+        StringBuilder result = new StringBuilder();
+        int foundType = -1;
+        boolean hasIllegalUsernameCharacters = false;
+        for (int a = searchPostion; a >= 0; a--) {
+            if (a >= text.length()) {
+                continue;
+            }
+            char ch = text.charAt(a);
+            if (a == 0 || text.charAt(a - 1) == ' ' || text.charAt(a - 1) == '\n') {
+                if (needUsernames && ch == '@') {
+                    if (hasIllegalUsernameCharacters) {
+                        delegate.needChangePanelVisibility(false);
+                        return;
+                    }
+                    if (info == null) {
+                        lastText = text;
+                        lastPosition = position;
+                        messages = messageObjects;
+                        delegate.needChangePanelVisibility(false);
+                        return;
+                    }
+                    foundType = 0;
+                    resultStartPosition = a;
+                    resultLength = result.length() + 1;
+                    break;
+                } else if (ch == '#') {
+                    if (!hashtagsLoadedFromDb) {
+                        loadRecentHashtags();
+                        lastText = text;
+                        lastPosition = position;
+                        messages = messageObjects;
+                        delegate.needChangePanelVisibility(false);
+                        return;
+                    }
+                    foundType = 1;
+                    resultStartPosition = a;
+                    resultLength = result.length() + 1;
+                    result.insert(0, ch);
+                    break;
+                }
+            }
+            if (!(ch >= '0' && ch <= '9' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch == '_')) {
+                hasIllegalUsernameCharacters = true;
+            }
+            result.insert(0, ch);
+        }
+        if (foundType == -1) {
+            delegate.needChangePanelVisibility(false);
+            return;
+        }
+        if (foundType == 0) {
+            final ArrayList<Integer> users = new ArrayList<>();
+            for (int a = 0; a < Math.min(100, messageObjects.size()); a++) {
+                int from_id = messageObjects.get(a).messageOwner.from_id;
+                if (!users.contains(from_id)) {
+                    users.add(from_id);
+                }
+            }
+            String usernameString = result.toString().toLowerCase();
+            ArrayList<TLRPC.User> newResult = new ArrayList<>();
+            for (TLRPC.TL_chatParticipant chatParticipant : info.participants) {
+                TLRPC.User user = MessagesController.getInstance().getUser(chatParticipant.user_id);
+                if (user == null || user instanceof TLRPC.TL_userSelf) {
+                    continue;
+                }
+                if (user.username != null && user.username.length() > 0 && (usernameString.length() > 0 && user.username.toLowerCase().startsWith(usernameString) || usernameString.length() == 0)) {
+                    newResult.add(user);
+                }
+            }
+            searchResultHashtags = null;
+            searchResultUsernames = newResult;
+            Collections.sort(searchResultUsernames, new Comparator<TLRPC.User>() {
+                @Override
+                public int compare(TLRPC.User lhs, TLRPC.User rhs) {
+                    int lhsNum = users.indexOf(lhs.id);
+                    int rhsNum = users.indexOf(rhs.id);
+                    if (lhsNum != -1 && rhsNum != -1) {
+                        return lhsNum < rhsNum ? -1 : (lhsNum == rhsNum ? 0 : 1);
+                    } else if (lhsNum != -1 && rhsNum == -1) {
+                        return -1;
+                    } else if (lhsNum == -1 && rhsNum != -1) {
+                        return 1;
+                    }
+                    return 0;
+                }
+            });
+            notifyDataSetChanged();
+            delegate.needChangePanelVisibility(!newResult.isEmpty());
+        } else {
+            ArrayList<String> newResult = new ArrayList<>();
+            String hashtagString = result.toString().toLowerCase();
+            for (HashtagObject hashtagObject : hashtags) {
+                if (hashtagString != null && hashtagObject.hashtag != null && hashtagObject.hashtag.startsWith(hashtagString)) {
+                    newResult.add(hashtagObject.hashtag);
+                }
+            }
+            searchResultHashtags = newResult;
+            searchResultUsernames = null;
+            notifyDataSetChanged();
+            delegate.needChangePanelVisibility(!newResult.isEmpty());
+        }
+    }
+
+    public int getResultStartPosition() {
+        return resultStartPosition;
+    }
+
+    public int getResultLength() {
+        return resultLength;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return 1;
+    }
+
+    @Override
+    public int getCount() {
+        if (searchResultUsernames != null) {
+            return searchResultUsernames.size();
+        } else if (searchResultHashtags != null) {
+            return searchResultHashtags.size();
+        }
+        return 0;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        if (searchResultUsernames != null) {
+            return searchResultUsernames.isEmpty();
+        } else if (searchResultHashtags != null) {
+            return searchResultHashtags.isEmpty();
+        }
+        return true;
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        return 0;
+    }
+
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return true;
+    }
+
+    @Override
+    public boolean isEnabled(int position) {
+        return true;
+    }
+
+    @Override
+    public Object getItem(int i) {
+        if (searchResultUsernames != null) {
+            if (i < 0 || i >= searchResultUsernames.size()) {
+                return null;
+            }
+            return searchResultUsernames.get(i);
+        } else if (searchResultHashtags != null) {
+            if (i < 0 || i >= searchResultHashtags.size()) {
+                return null;
+            }
+            return searchResultHashtags.get(i);
+        }
+        return null;
+    }
+
+    @Override
+    public View getView(int i, View view, ViewGroup viewGroup) {
+        if (view == null) {
+            view = new MentionCell(mContext);
+            ((MentionCell) view).setIsDarkTheme(isDarkTheme);
+        }
+        if (searchResultUsernames != null) {
+            ((MentionCell) view).setUser(searchResultUsernames.get(i));
+        } else if (searchResultHashtags != null) {
+            ((MentionCell) view).setText(searchResultHashtags.get(i));
+        }
+        return view;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java
new file mode 100644
index 000000000..cf7ce7c1f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java
@@ -0,0 +1,304 @@
+/*
+ * This is the source code of Telegram for Android v. 1.3.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2014.
+ */
+
+package org.telegram.ui.Adapters;
+
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.android.ContactsController;
+import org.telegram.messenger.FileLog;
+import org.telegram.android.MessagesController;
+import org.telegram.messenger.UserConfig;
+import org.telegram.messenger.Utilities;
+import org.telegram.ui.Cells.GreySectionCell;
+import org.telegram.ui.Cells.ProfileSearchCell;
+import org.telegram.ui.Cells.UserCell;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Timer;
+import java.util.TimerTask;
+
+public class SearchAdapter extends BaseSearchAdapter {
+    private Context mContext;
+    private HashMap<Integer, TLRPC.User> ignoreUsers;
+    private ArrayList<TLRPC.User> searchResult = new ArrayList<>();
+    private ArrayList<CharSequence> searchResultNames = new ArrayList<>();
+    private HashMap<Integer, ?> checkedMap;
+    private Timer searchTimer;
+    private boolean allowUsernameSearch;
+    private boolean useUserCell;
+
+    public SearchAdapter(Context context, HashMap<Integer, TLRPC.User> arg1, boolean usernameSearch) {
+        mContext = context;
+        ignoreUsers = arg1;
+        allowUsernameSearch = usernameSearch;
+    }
+
+    public void setCheckedMap(HashMap<Integer, ?> map) {
+        checkedMap = map;
+    }
+
+    public void setUseUserCell(boolean value) {
+        useUserCell = value;
+    }
+
+    public void searchDialogs(final String query) {
+        try {
+            if (searchTimer != null) {
+                searchTimer.cancel();
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        if (query == null) {
+            searchResult.clear();
+            searchResultNames.clear();
+            if (allowUsernameSearch) {
+                queryServerSearch(null);
+            }
+            notifyDataSetChanged();
+        } else {
+            searchTimer = new Timer();
+            searchTimer.schedule(new TimerTask() {
+                @Override
+                public void run() {
+                    try {
+                        searchTimer.cancel();
+                        searchTimer = null;
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    processSearch(query);
+                }
+            }, 200, 300);
+        }
+    }
+
+    private void processSearch(final String query) {
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                if (allowUsernameSearch) {
+                    queryServerSearch(query);
+                }
+                final ArrayList<TLRPC.TL_contact> contactsCopy = new ArrayList<>();
+                contactsCopy.addAll(ContactsController.getInstance().contacts);
+                Utilities.searchQueue.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        String search1 = query.trim().toLowerCase();
+                        if (search1.length() == 0) {
+                            updateSearchResults(new ArrayList<TLRPC.User>(), new ArrayList<CharSequence>());
+                            return;
+                        }
+                        String search2 = LocaleController.getInstance().getTranslitString(search1);
+                        if (search1.equals(search2) || search2.length() == 0) {
+                            search2 = null;
+                        }
+                        String search[] = new String[1 + (search2 != null ? 1 : 0)];
+                        search[0] = search1;
+                        if (search2 != null) {
+                            search[1] = search2;
+                        }
+
+                        ArrayList<TLRPC.User> resultArray = new ArrayList<>();
+                        ArrayList<CharSequence> resultArrayNames = new ArrayList<>();
+
+                        for (TLRPC.TL_contact contact : contactsCopy) {
+                            TLRPC.User user = MessagesController.getInstance().getUser(contact.user_id);
+                            if (user.id == UserConfig.getClientUserId()) {
+                                continue;
+                            }
+
+                            String name = ContactsController.formatName(user.first_name, user.last_name).toLowerCase();
+                            String tName = LocaleController.getInstance().getTranslitString(name);
+                            if (name.equals(tName)) {
+                                tName = null;
+                            }
+
+                            int found = 0;
+                            for (String q : search) {
+                                if (name.startsWith(q) || name.contains(" " + q) || tName != null && (tName.startsWith(q) || tName.contains(" " + q))) {
+                                    found = 1;
+                                } else if (user.username != null && user.username.startsWith(q)) {
+                                    found = 2;
+                                }
+
+                                if (found != 0) {
+                                    if (found == 1) {
+                                        resultArrayNames.add(Utilities.generateSearchName(user.first_name, user.last_name, q));
+                                    } else {
+                                        resultArrayNames.add(Utilities.generateSearchName("@" + user.username, null, "@" + q));
+                                    }
+                                    resultArray.add(user);
+                                    break;
+                                }
+                            }
+                        }
+
+                        updateSearchResults(resultArray, resultArrayNames);
+                    }
+                });
+            }
+        });
+    }
+
+    private void updateSearchResults(final ArrayList<TLRPC.User> users, final ArrayList<CharSequence> names) {
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                searchResult = users;
+                searchResultNames = names;
+                notifyDataSetChanged();
+            }
+        });
+    }
+
+    @Override
+    public boolean areAllItemsEnabled() {
+        return false;
+    }
+
+    @Override
+    public boolean isEnabled(int i) {
+        return i != searchResult.size();
+    }
+
+    @Override
+    public int getCount() {
+        int count = searchResult.size();
+        int globalCount = globalSearch.size();
+        if (globalCount != 0) {
+            count += globalCount + 1;
+        }
+        return count;
+    }
+
+    public boolean isGlobalSearch(int i) {
+        int localCount = searchResult.size();
+        int globalCount = globalSearch.size();
+        if (i >= 0 && i < localCount) {
+            return false;
+        } else if (i > localCount && i <= globalCount + localCount) {
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public TLRPC.User getItem(int i) {
+        int localCount = searchResult.size();
+        int globalCount = globalSearch.size();
+        if (i >= 0 && i < localCount) {
+            return searchResult.get(i);
+        } else if (i > localCount && i <= globalCount + localCount) {
+            return globalSearch.get(i - localCount - 1);
+        }
+        return null;
+    }
+
+    @Override
+    public long getItemId(int i) {
+        return i;
+    }
+
+    @Override
+    public boolean hasStableIds() {
+        return true;
+    }
+
+    @Override
+    public View getView(int i, View view, ViewGroup viewGroup) {
+        if (i == searchResult.size()) {
+            if (view == null) {
+                view = new GreySectionCell(mContext);
+                ((GreySectionCell) view).setText(LocaleController.getString("GlobalSearch", R.string.GlobalSearch));
+            }
+        } else {
+            if (view == null) {
+                if (useUserCell) {
+                    view = new UserCell(mContext, 1);
+                    if (checkedMap != null) {
+                        ((UserCell) view).setChecked(false, false);
+                    }
+                } else {
+                    view = new ProfileSearchCell(mContext);
+                }
+            }
+
+            TLRPC.User user = getItem(i);
+            if (user != null) {
+                CharSequence username = null;
+                CharSequence name = null;
+                if (i < searchResult.size()) {
+                    name = searchResultNames.get(i);
+                    if (name != null && user != null && user.username != null && user.username.length() > 0) {
+                        if (name.toString().startsWith("@" + user.username)) {
+                            username = name;
+                            name = null;
+                        }
+                    }
+                } else if (i > searchResult.size() && user.username != null) {
+                    String foundUserName = lastFoundUsername;
+                    if (foundUserName.startsWith("@")) {
+                        foundUserName = foundUserName.substring(1);
+                    }
+                    try {
+                        username = AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>@%s</c>%s", user.username.substring(0, foundUserName.length()), user.username.substring(foundUserName.length())));
+                    } catch (Exception e) {
+                        username = user.username;
+                        FileLog.e("tmessages", e);
+                    }
+                }
+
+                if (useUserCell) {
+                    ((UserCell) view).setData(user, name, username, 0);
+                    if (checkedMap != null) {
+                        ((UserCell) view).setChecked(checkedMap.containsKey(user.id), false);
+                    }
+                } else {
+                    ((ProfileSearchCell) view).setData(user, null, null, name, username);
+                    ((ProfileSearchCell) view).useSeparator = (i != getCount() - 1 && i != searchResult.size() - 1);
+                    if (ignoreUsers != null) {
+                        if (ignoreUsers.containsKey(user.id)) {
+                            ((ProfileSearchCell) view).drawAlpha = 0.5f;
+                        } else {
+                            ((ProfileSearchCell) view).drawAlpha = 1.0f;
+                        }
+                    }
+                }
+            }
+        }
+        return view;
+    }
+
+    @Override
+    public int getItemViewType(int i) {
+        if (i == searchResult.size()) {
+            return 1;
+        }
+        return 0;
+    }
+
+    @Override
+    public int getViewTypeCount() {
+        return 2;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return searchResult.isEmpty() && globalSearch.isEmpty();
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/AddMemberCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AddMemberCell.java
new file mode 100644
index 000000000..a4cff7ad0
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AddMemberCell.java
@@ -0,0 +1,44 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.R;
+import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.SimpleTextView;
+
+public class AddMemberCell extends FrameLayout {
+
+    public AddMemberCell(Context context) {
+        super(context);
+
+        ImageView imageView = new ImageView(context);
+        imageView.setImageResource(R.drawable.addmember);
+        imageView.setScaleType(ImageView.ScaleType.CENTER);
+        addView(imageView, LayoutHelper.createFrame(48, 48, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 68, 8, LocaleController.isRTL ? 68 : 0, 0));
+
+        SimpleTextView textView = new SimpleTextView(context);
+        textView.setTextColor(0xff212121);
+        textView.setTextSize(17);
+        textView.setText(LocaleController.getString("AddMember", R.string.AddMember));
+        textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 20, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 28 : 129, 22.5f, LocaleController.isRTL ? 129 : 28, 0));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64), MeasureSpec.EXACTLY));
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java
new file mode 100644
index 000000000..ccb8dbcef
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java
@@ -0,0 +1,53 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+
+public class HashtagSearchCell extends TextView {
+
+    private boolean needDivider;
+    private static Paint paint;
+
+    public HashtagSearchCell(Context context) {
+        super(context);
+        setGravity(Gravity.CENTER_VERTICAL);
+        setPadding(AndroidUtilities.dp(16), 0, AndroidUtilities.dp(16), 0);
+        setTextSize(TypedValue.COMPLEX_UNIT_DIP, 17);
+        setTextColor(0xff000000);
+        if (paint == null) {
+            paint = new Paint();
+            paint.setColor(0xffdcdcdc);
+        }
+    }
+
+    public void setNeedDivider(boolean value) {
+        needDivider = value;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), AndroidUtilities.dp(48) + 1);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        if (needDivider) {
+            canvas.drawLine(0, getHeight() - 1, getWidth(), getHeight() - 1, paint);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationCell.java
new file mode 100644
index 000000000..015083117
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationCell.java
@@ -0,0 +1,91 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffColorFilter;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Components.BackupImageView;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class LocationCell extends FrameLayout {
+
+    private TextView nameTextView;
+    private TextView addressTextView;
+    private BackupImageView imageView;
+    private boolean needDivider;
+    private static Paint paint;
+
+    public LocationCell(Context context) {
+        super(context);
+
+        if (paint == null) {
+            paint = new Paint();
+            paint.setColor(0xffd9d9d9);
+            paint.setStrokeWidth(1);
+        }
+
+        imageView = new BackupImageView(context);
+        imageView.setBackgroundResource(R.drawable.round_grey);
+        imageView.setSize(AndroidUtilities.dp(30), AndroidUtilities.dp(30));
+        imageView.getImageReceiver().setColorFilter(new PorterDuffColorFilter(0xff999999, PorterDuff.Mode.MULTIPLY));
+        addView(imageView, LayoutHelper.createFrame(40, 40, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), LocaleController.isRTL ? 0 : 17, 8, LocaleController.isRTL ? 17 : 0, 0));
+
+        nameTextView = new TextView(context);
+        nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        nameTextView.setMaxLines(1);
+        nameTextView.setEllipsize(TextUtils.TruncateAt.END);
+        nameTextView.setSingleLine(true);
+        nameTextView.setTextColor(0xff212121);
+        nameTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        nameTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
+        addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), (LocaleController.isRTL ? 16 : 72), 5, (LocaleController.isRTL ? 72 : 16), 0));
+
+        addressTextView = new TextView(context);
+        addressTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        addressTextView.setMaxLines(1);
+        addressTextView.setEllipsize(TextUtils.TruncateAt.END);
+        addressTextView.setSingleLine(true);
+        addressTextView.setTextColor(0xff999999);
+        addressTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
+        addView(addressTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), (LocaleController.isRTL ? 16 : 72), 30, (LocaleController.isRTL ? 72 : 16), 0));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(56) + (needDivider ? 1 : 0), MeasureSpec.EXACTLY));
+    }
+
+    public void setLocation(TLRPC.TL_messageMediaVenue location, String icon, boolean divider) {
+        needDivider = divider;
+        nameTextView.setText(location.title);
+        addressTextView.setText(location.address);
+        imageView.setImage(icon, null, null);
+        setWillNotDraw(!divider);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (needDivider) {
+            canvas.drawLine(AndroidUtilities.dp(72), getHeight() - 1, getWidth(), getHeight() - 1, paint);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationLoadingCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationLoadingCell.java
new file mode 100644
index 000000000..0b917d844
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationLoadingCell.java
@@ -0,0 +1,50 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.R;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class LocationLoadingCell extends FrameLayout {
+
+    private ProgressBar progressBar;
+    private TextView textView;
+
+    public LocationLoadingCell(Context context) {
+        super(context);
+
+        progressBar = new ProgressBar(context);
+        addView(progressBar, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
+
+        textView = new TextView(context);
+        textView.setTextColor(0xff999999);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        textView.setText(LocaleController.getString("NoResult", R.string.NoResult));
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec((int) (AndroidUtilities.dp(56) * 2.5f), MeasureSpec.EXACTLY));
+    }
+
+    public void setLoading(boolean value) {
+        progressBar.setVisibility(value ? VISIBLE : INVISIBLE);
+        textView.setVisibility(value ? INVISIBLE : VISIBLE);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationPoweredCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationPoweredCell.java
new file mode 100644
index 000000000..3009f6094
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationPoweredCell.java
@@ -0,0 +1,53 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.messenger.R;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class LocationPoweredCell extends FrameLayout {
+
+    public LocationPoweredCell(Context context) {
+        super(context);
+
+        LinearLayout linearLayout = new LinearLayout(context);
+        addView(linearLayout, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
+
+        TextView textView = new TextView(context);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        textView.setTextColor(0xff999999);
+        textView.setText("Powered by");
+        linearLayout.addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+
+        ImageView imageView = new ImageView(context);
+        imageView.setImageResource(R.drawable.foursquare);
+        imageView.setPadding(0, AndroidUtilities.dp(2), 0, 0);
+        linearLayout.addView(imageView, LayoutHelper.createLinear(35, LayoutHelper.WRAP_CONTENT));
+
+        textView = new TextView(context);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        textView.setTextColor(0xff999999);
+        textView.setText("Foursquare");
+        linearLayout.addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(56), MeasureSpec.EXACTLY));
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java
new file mode 100644
index 000000000..05cd5b6b9
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java
@@ -0,0 +1,118 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.ContactsController;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Components.AvatarDrawable;
+import org.telegram.ui.Components.BackupImageView;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class MentionCell extends LinearLayout {
+
+    private BackupImageView imageView;
+    private TextView nameTextView;
+    private TextView usernameTextView;
+    private AvatarDrawable avatarDrawable;
+
+    public MentionCell(Context context) {
+        super(context);
+
+        setOrientation(HORIZONTAL);
+
+        avatarDrawable = new AvatarDrawable();
+        avatarDrawable.setSmallStyle(true);
+
+        imageView = new BackupImageView(context);
+        imageView.setRoundRadius(AndroidUtilities.dp(14));
+        addView(imageView);
+        LayoutParams layoutParams = (LayoutParams) imageView.getLayoutParams();
+        layoutParams.leftMargin = AndroidUtilities.dp(12);
+        layoutParams.topMargin = AndroidUtilities.dp(4);
+        layoutParams.width = AndroidUtilities.dp(28);
+        layoutParams.height = AndroidUtilities.dp(28);
+        imageView.setLayoutParams(layoutParams);
+
+        nameTextView = new TextView(context);
+        nameTextView.setTextColor(0xff000000);
+        nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15);
+        nameTextView.setSingleLine(true);
+        nameTextView.setGravity(Gravity.LEFT);
+        nameTextView.setEllipsize(TextUtils.TruncateAt.END);
+        addView(nameTextView);
+        layoutParams = (LayoutParams) nameTextView.getLayoutParams();
+        layoutParams.leftMargin = AndroidUtilities.dp(12);
+        layoutParams.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams.gravity = Gravity.CENTER_VERTICAL;
+        nameTextView.setLayoutParams(layoutParams);
+
+        usernameTextView = new TextView(context);
+        usernameTextView.setTextColor(0xff999999);
+        usernameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15);
+        usernameTextView.setSingleLine(true);
+        usernameTextView.setGravity(Gravity.LEFT);
+        usernameTextView.setEllipsize(TextUtils.TruncateAt.END);
+        addView(usernameTextView);
+        layoutParams = (LayoutParams) usernameTextView.getLayoutParams();
+        layoutParams.leftMargin = AndroidUtilities.dp(12);
+        layoutParams.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams.gravity = Gravity.CENTER_VERTICAL;
+        usernameTextView.setLayoutParams(layoutParams);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(36), MeasureSpec.EXACTLY));
+    }
+
+    public void setUser(TLRPC.User user) {
+        if (user == null) {
+            nameTextView.setText("");
+            usernameTextView.setText("");
+            imageView.setImageDrawable(null);
+            return;
+        }
+        avatarDrawable.setInfo(user);
+        if (user.photo != null && user.photo.photo_small != null) {
+            imageView.setImage(user.photo.photo_small, "50_50", avatarDrawable);
+        } else {
+            imageView.setImageDrawable(avatarDrawable);
+        }
+        nameTextView.setText(ContactsController.formatName(user.first_name, user.last_name));
+        usernameTextView.setText("@" + user.username);
+        imageView.setVisibility(VISIBLE);
+        usernameTextView.setVisibility(VISIBLE);
+    }
+
+    public void setText(String text) {
+        imageView.setVisibility(INVISIBLE);
+        usernameTextView.setVisibility(INVISIBLE);
+        nameTextView.setText(text);
+    }
+
+    public void setIsDarkTheme(boolean isDarkTheme) {
+        if (isDarkTheme) {
+            nameTextView.setTextColor(0xffffffff);
+            usernameTextView.setTextColor(0xff999999);
+        } else {
+            nameTextView.setTextColor(0xff000000);
+            usernameTextView.setTextColor(0xff999999);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SendLocationCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SendLocationCell.java
new file mode 100644
index 000000000..46a691978
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SendLocationCell.java
@@ -0,0 +1,57 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.R;
+import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.SimpleTextView;
+
+public class SendLocationCell extends FrameLayout {
+
+    private SimpleTextView accurateTextView;
+    private SimpleTextView titleTextView;
+
+    public SendLocationCell(Context context) {
+        super(context);
+
+        ImageView imageView = new ImageView(context);
+        imageView.setImageResource(R.drawable.pin);
+        addView(imageView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), LocaleController.isRTL ? 0 : 17, 13, LocaleController.isRTL ? 17 : 0, 0));
+
+        titleTextView = new SimpleTextView(context);
+        titleTextView.setTextSize(16);
+        titleTextView.setTextColor(0xff377aae);
+        titleTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
+        titleTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        addView(titleTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 20, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), LocaleController.isRTL ? 16 : 73, 12, LocaleController.isRTL ? 73 : 16, 0));
+
+        accurateTextView = new SimpleTextView(context);
+        accurateTextView.setTextSize(14);
+        accurateTextView.setTextColor(0xff999999);
+        accurateTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
+        addView(accurateTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 20, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), LocaleController.isRTL ? 16 : 73, 37, LocaleController.isRTL ? 73 : 16, 0));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(66), MeasureSpec.EXACTLY));
+    }
+
+    public void setText(String title, String text) {
+        titleTextView.setText(title);
+        accurateTextView.setText(text);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java
new file mode 100644
index 000000000..a76d1e389
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java
@@ -0,0 +1,206 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Components.LayoutHelper;
+
+import java.util.Locale;
+
+public class SessionCell extends FrameLayout {
+
+    private TextView nameTextView;
+    private TextView onlineTextView;
+    private TextView detailTextView;
+    private TextView detailExTextView;
+    boolean needDivider;
+    private static Paint paint;
+
+    public SessionCell(Context context) {
+        super(context);
+
+        if (paint == null) {
+            paint = new Paint();
+            paint.setColor(0xffd9d9d9);
+            paint.setStrokeWidth(1);
+        }
+
+        LinearLayout linearLayout = new LinearLayout(context);
+        linearLayout.setOrientation(LinearLayout.HORIZONTAL);
+        linearLayout.setWeightSum(1);
+        addView(linearLayout);
+        LayoutParams layoutParams = (LayoutParams) linearLayout.getLayoutParams();
+        layoutParams.width = LayoutHelper.MATCH_PARENT;
+        layoutParams.height = AndroidUtilities.dp(30);
+        layoutParams.leftMargin = AndroidUtilities.dp(17);
+        layoutParams.rightMargin = AndroidUtilities.dp(17);
+        layoutParams.topMargin = AndroidUtilities.dp(11);
+        layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
+        linearLayout.setLayoutParams(layoutParams);
+
+        nameTextView = new TextView(context);
+        nameTextView.setTextColor(0xff212121);
+        nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        nameTextView.setLines(1);
+        nameTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        nameTextView.setMaxLines(1);
+        nameTextView.setSingleLine(true);
+        nameTextView.setEllipsize(TextUtils.TruncateAt.END);
+        nameTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP);
+
+        onlineTextView = new TextView(context);
+        onlineTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        onlineTextView.setGravity((LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP);
+
+        if (LocaleController.isRTL) {
+            linearLayout.addView(onlineTextView);
+            linearLayout.addView(nameTextView);
+        } else {
+            linearLayout.addView(nameTextView);
+            linearLayout.addView(onlineTextView);
+        }
+
+        LinearLayout.LayoutParams layoutParams2 = (LinearLayout.LayoutParams) nameTextView.getLayoutParams();
+        layoutParams2.width = 0;
+        layoutParams2.height = LayoutHelper.MATCH_PARENT;
+        layoutParams2.weight = 1;
+        if (LocaleController.isRTL) {
+            layoutParams2.leftMargin = AndroidUtilities.dp(10);
+        } else {
+            layoutParams2.rightMargin = AndroidUtilities.dp(10);
+        }
+        layoutParams2.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
+        nameTextView.setLayoutParams(layoutParams2);
+
+        layoutParams2 = (LinearLayout.LayoutParams) onlineTextView.getLayoutParams();
+        layoutParams2.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams2.height = LayoutHelper.MATCH_PARENT;
+        layoutParams2.topMargin = AndroidUtilities.dp(2);
+        layoutParams2.gravity = (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP;
+        onlineTextView.setLayoutParams(layoutParams2);
+
+        detailTextView = new TextView(context);
+        detailTextView.setTextColor(0xff212121);
+        detailTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        detailTextView.setLines(1);
+        detailTextView.setMaxLines(1);
+        detailTextView.setSingleLine(true);
+        detailTextView.setEllipsize(TextUtils.TruncateAt.END);
+        detailTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP);
+        addView(detailTextView);
+        layoutParams = (LayoutParams) detailTextView.getLayoutParams();
+        layoutParams.width = LayoutHelper.MATCH_PARENT;
+        layoutParams.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams.leftMargin = AndroidUtilities.dp(17);
+        layoutParams.rightMargin = AndroidUtilities.dp(17);
+        layoutParams.topMargin = AndroidUtilities.dp(36);
+        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP;
+        detailTextView.setLayoutParams(layoutParams);
+
+        detailExTextView = new TextView(context);
+        detailExTextView.setTextColor(0xff999999);
+        detailExTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        detailExTextView.setLines(1);
+        detailExTextView.setMaxLines(1);
+        detailExTextView.setSingleLine(true);
+        detailExTextView.setEllipsize(TextUtils.TruncateAt.END);
+        detailExTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP);
+        addView(detailExTextView);
+        layoutParams = (LayoutParams) detailExTextView.getLayoutParams();
+        layoutParams.width = LayoutHelper.MATCH_PARENT;
+        layoutParams.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams.leftMargin = AndroidUtilities.dp(17);
+        layoutParams.rightMargin = AndroidUtilities.dp(17);
+        layoutParams.topMargin = AndroidUtilities.dp(59);
+        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP;
+        detailExTextView.setLayoutParams(layoutParams);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(90) + (needDivider ? 1 : 0), MeasureSpec.EXACTLY));
+    }
+
+    public void setSession(TLRPC.TL_authorization session, boolean divider) {
+        needDivider = divider;
+
+        nameTextView.setText(String.format(Locale.US, "%s %s", session.app_name, session.app_version));
+        if ((session.flags & 1) != 0) {
+            onlineTextView.setText(LocaleController.getString("Online", R.string.Online));
+            onlineTextView.setTextColor(0xff2f8cc9);
+        } else {
+            onlineTextView.setText(LocaleController.stringForMessageListDate(session.date_active));
+            onlineTextView.setTextColor(0xff999999);
+        }
+
+        StringBuilder stringBuilder = new StringBuilder();
+        if (session.ip.length() != 0) {
+            stringBuilder.append(session.ip);
+        }
+        if (session.country.length() != 0) {
+            if (stringBuilder.length() != 0) {
+                stringBuilder.append(" ");
+            }
+            stringBuilder.append("— ");
+            stringBuilder.append(session.country);
+        }
+        detailExTextView.setText(stringBuilder);
+
+        stringBuilder = new StringBuilder();
+        if (session.device_model.length() != 0) {
+            stringBuilder.append(session.device_model);
+        }
+        if (session.system_version.length() != 0 || session.platform.length() != 0) {
+            if (stringBuilder.length() != 0) {
+                stringBuilder.append(", ");
+            }
+            if (session.platform.length() != 0) {
+                stringBuilder.append(session.platform);
+            }
+            if (session.system_version.length() != 0) {
+                if (session.platform.length() != 0) {
+                    stringBuilder.append(" ");
+                }
+                stringBuilder.append(session.system_version);
+            }
+        }
+
+        if ((session.flags & 2) == 0) {
+            if (stringBuilder.length() != 0) {
+                stringBuilder.append(", ");
+            }
+            stringBuilder.append(LocaleController.getString("UnofficialApp", R.string.UnofficialApp));
+            stringBuilder.append(" (ID: ");
+            stringBuilder.append(session.api_id);
+            stringBuilder.append(")");
+        }
+
+        detailTextView.setText(stringBuilder);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (needDivider) {
+            canvas.drawLine(getPaddingLeft(), getHeight() - 1, getWidth() - getPaddingRight(), getHeight() - 1, paint);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java
new file mode 100644
index 000000000..72b8db653
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java
@@ -0,0 +1,53 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.Components.BackupImageView;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class StickerEmojiCell extends FrameLayout {
+
+    private BackupImageView imageView;
+    private TLRPC.Document sticker;
+
+    public StickerEmojiCell(Context context) {
+        super(context);
+
+        imageView = new BackupImageView(context);
+        imageView.setAspectFit(true);
+        addView(imageView, LayoutHelper.createFrame(66, 66, Gravity.CENTER));
+    }
+
+    @Override
+    public void setPressed(boolean pressed) {
+        if (imageView.getImageReceiver().getPressed() != pressed) {
+            imageView.getImageReceiver().setPressed(pressed);
+            imageView.invalidate();
+        }
+        super.setPressed(pressed);
+    }
+
+    public TLRPC.Document getSticker() {
+        return sticker;
+    }
+
+    public void setSticker(TLRPC.Document document) {
+        if (document != null) {
+            sticker = document;
+            document.thumb.location.ext = "webp";
+            imageView.setImage(document.thumb.location, null, (Drawable) null);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextBlockCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextBlockCell.java
new file mode 100644
index 000000000..15f7b3d13
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextBlockCell.java
@@ -0,0 +1,60 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import org.telegram.android.LocaleController;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class TextBlockCell extends FrameLayout {
+
+    private TextView textView;
+    private static Paint paint;
+    private boolean needDivider;
+
+    public TextBlockCell(Context context) {
+        super(context);
+
+        if (paint == null) {
+            paint = new Paint();
+            paint.setColor(0xffd9d9d9);
+            paint.setStrokeWidth(1);
+        }
+
+        textView = new TextView(context);
+        textView.setTextColor(0xff212121);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 8, 17, 8));
+    }
+
+    public void setTextColor(int color) {
+        textView.setTextColor(color);
+    }
+
+    public void setText(String text, boolean divider) {
+        textView.setText(text);
+        needDivider = divider;
+        setWillNotDraw(!divider);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (needDivider) {
+            canvas.drawLine(getPaddingLeft(), getHeight() - 1, getWidth() - getPaddingRight(), getHeight() - 1, paint);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java
new file mode 100644
index 000000000..f449daf27
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java
@@ -0,0 +1,122 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+
+import org.telegram.android.AndroidUtilities;
+
+public class LayoutHelper {
+
+    public static final int MATCH_PARENT = -1;
+    public static final int WRAP_CONTENT = -2;
+    
+    private static int getSize(float size) {
+        return (int) (size < 0 ? size : AndroidUtilities.dp(size));
+    }
+
+    public static FrameLayout.LayoutParams createFrame(int width, int height, int gravity, float leftMargin, float topMargin, float rightMargin, float bottomMargin) {
+        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(getSize(width), getSize(height), gravity);
+        layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
+        return layoutParams;
+    }
+
+    public static FrameLayout.LayoutParams createFrame(int width, int height, int gravity) {
+        return new FrameLayout.LayoutParams(getSize(width), getSize(height), gravity);
+    }
+
+    public static FrameLayout.LayoutParams createFrame(int width, int height) {
+        return new FrameLayout.LayoutParams(getSize(width), getSize(height));
+    }
+
+    public static RelativeLayout.LayoutParams createRelative(float width, float height, int leftMargin, int topMargin, int rightMargin, int bottomMargin, int alignParent, int alignRelative, int anchorRelative) {
+        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(getSize(width), getSize(height));
+        if (alignParent >= 0) {
+            layoutParams.addRule(alignParent);
+        }
+        if (alignRelative >= 0 && anchorRelative >= 0) {
+            layoutParams.addRule(alignRelative, anchorRelative);
+        }
+        layoutParams.leftMargin = AndroidUtilities.dp(leftMargin);
+        layoutParams.topMargin = AndroidUtilities.dp(topMargin);
+        layoutParams.rightMargin = AndroidUtilities.dp(rightMargin);
+        layoutParams.bottomMargin = AndroidUtilities.dp(bottomMargin);
+        return layoutParams;
+    }
+
+    public static RelativeLayout.LayoutParams createRelative(int width, int height, int leftMargin, int topMargin, int rightMargin, int bottomMargin) {
+        return createRelative(width, height, leftMargin, topMargin, rightMargin, bottomMargin, -1, -1, -1);
+    }
+
+    public static RelativeLayout.LayoutParams createRelative(int width, int height, int leftMargin, int topMargin, int rightMargin, int bottomMargin, int alignParent) {
+        return createRelative(width, height, leftMargin, topMargin, rightMargin, bottomMargin, alignParent, -1, -1);
+    }
+
+    public static RelativeLayout.LayoutParams createRelative(float width, float height, int leftMargin, int topMargin, int rightMargin, int bottomMargin, int alignRelative, int anchorRelative) {
+        return createRelative(width, height, leftMargin, topMargin, rightMargin, bottomMargin, -1, alignRelative, anchorRelative);
+    }
+
+    public static RelativeLayout.LayoutParams createRelative(int width, int height, int alignParent, int alignRelative, int anchorRelative) {
+        return createRelative(width, height, 0, 0, 0, 0, alignParent, alignRelative, anchorRelative);
+    }
+
+    public static RelativeLayout.LayoutParams createRelative(int width, int height) {
+        return createRelative(width, height, 0, 0, 0, 0, -1, -1, -1);
+    }
+
+    public static RelativeLayout.LayoutParams createRelative(int width, int height, int alignParent) {
+        return createRelative(width, height, 0, 0, 0, 0, alignParent, -1, -1);
+    }
+
+    public static RelativeLayout.LayoutParams createRelative(int width, int height, int alignRelative, int anchorRelative) {
+        return createRelative(width, height, 0, 0, 0, 0, -1, alignRelative, anchorRelative);
+    }
+
+    public static LinearLayout.LayoutParams createLinear(int width, int height, float weight, int gravity, int leftMargin, int topMargin, int rightMargin, int bottomMargin) {
+        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(getSize(width), getSize(height), weight);
+        layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
+        layoutParams.gravity = gravity;
+        return layoutParams;
+    }
+
+    public static LinearLayout.LayoutParams createLinear(int width, int height, int gravity, int leftMargin, int topMargin, int rightMargin, int bottomMargin) {
+        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(getSize(width), getSize(height));
+        layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
+        layoutParams.gravity = gravity;
+        return layoutParams;
+    }
+
+    public static LinearLayout.LayoutParams createLinear(int width, int height, int leftMargin, int topMargin, int rightMargin, int bottomMargin) {
+        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(getSize(width), getSize(height));
+        layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
+        return layoutParams;
+    }
+
+    public static LinearLayout.LayoutParams createLinear(int width, int height, float weight, int gravity) {
+        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(getSize(width), getSize(height), weight);
+        layoutParams.gravity = gravity;
+        return layoutParams;
+    }
+
+    public static LinearLayout.LayoutParams createLinear(int width, int height, int gravity) {
+        LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(getSize(width), getSize(height));
+        layoutParams.gravity = gravity;
+        return layoutParams;
+    }
+
+    public static LinearLayout.LayoutParams createLinear(int width, int height, float weight) {
+        return new LinearLayout.LayoutParams(getSize(width), getSize(height), weight);
+    }
+
+    public static LinearLayout.LayoutParams createLinear(int width, int height) {
+        return new LinearLayout.LayoutParams(getSize(width), getSize(height));
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/MapPlaceholderDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/MapPlaceholderDrawable.java
new file mode 100644
index 000000000..7611268df
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/MapPlaceholderDrawable.java
@@ -0,0 +1,72 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+
+import org.telegram.android.AndroidUtilities;
+
+public class MapPlaceholderDrawable extends Drawable {
+
+    private Paint paint;
+    private Paint linePaint;
+
+    public MapPlaceholderDrawable() {
+        super();
+        paint = new Paint();
+        paint.setColor(0xffded7d6);
+        linePaint = new Paint();
+        linePaint.setColor(0xffc6bfbe);
+        linePaint.setStrokeWidth(AndroidUtilities.dp(1));
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        canvas.drawRect(getBounds(), paint);
+        int gap = AndroidUtilities.dp(9);
+        int xcount = getBounds().width() / gap;
+        int ycount = getBounds().height() / gap;
+        int x = getBounds().left;
+        int y = getBounds().top;
+        for (int a = 0; a < xcount; a++) {
+            canvas.drawLine(x + gap * (a + 1), y, x + gap * (a + 1), y + getBounds().height(), linePaint);
+        }
+        for (int a = 0; a < ycount; a++) {
+            canvas.drawLine(x, y + gap * (a + 1), x + getBounds().width(), y + gap * (a + 1), linePaint);
+        }
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+
+    }
+
+    @Override
+    public int getOpacity() {
+        return 0;
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return 0;
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return 0;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterBlurControl.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterBlurControl.java
new file mode 100644
index 000000000..8fb291765
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterBlurControl.java
@@ -0,0 +1,499 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.view.MotionEvent;
+import android.widget.FrameLayout;
+
+import org.telegram.android.AndroidUtilities;
+
+public class PhotoFilterBlurControl extends FrameLayout {
+
+    public interface PhotoFilterLinearBlurControlDelegate {
+        void valueChanged(Point centerPoint, float falloff, float size, float angle);
+    }
+
+    private final static float BlurInsetProximity = AndroidUtilities.dp(20);
+    private final static float BlurMinimumFalloff = 0.1f;
+    private final static float BlurMinimumDifference = 0.02f;
+    private final static float BlurViewCenterInset = AndroidUtilities.dp(30.0f);
+    private final static float BlurViewRadiusInset = AndroidUtilities.dp(30.0f);
+
+    private enum BlurViewActiveControl {
+        BlurViewActiveControlNone,
+        BlurViewActiveControlCenter,
+        BlurViewActiveControlInnerRadius,
+        BlurViewActiveControlOuterRadius,
+        BlurViewActiveControlWholeArea,
+        BlurViewActiveControlRotation
+    }
+
+    private final int GestureStateBegan = 1;
+    private final int GestureStateChanged = 2;
+    private final int GestureStateEnded = 3;
+    private final int GestureStateCancelled = 4;
+    private final int GestureStateFailed = 5;
+
+    private BlurViewActiveControl activeControl;
+    private Point startCenterPoint = new Point();
+    private float startDistance;
+    private float startRadius;
+    private Size actualAreaSize = new Size();
+    private Point centerPoint = new Point(0.5f, 0.5f);
+    private float falloff = 0.15f;
+    private float size = 0.35f;
+    private float angle;
+    private RectF arcRect = new RectF();
+
+    private float pointerStartX;
+    private float pointerStartY;
+    private float startPointerDistance;
+    private float pointerScale = 1;
+    private boolean isMoving;
+    private boolean isZooming;
+    private boolean checkForMoving;
+    private boolean checkForZooming;
+
+    private int type;
+
+    private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private Paint arcPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+
+    private PhotoFilterLinearBlurControlDelegate delegate;
+
+    public PhotoFilterBlurControl(Context context) {
+        super(context);
+        setWillNotDraw(false);
+        paint.setColor(0xffffffff);
+        arcPaint.setColor(0xffffffff);
+        arcPaint.setStrokeWidth(AndroidUtilities.dp(2));
+        arcPaint.setStyle(Paint.Style.STROKE);
+    }
+
+    public void setType(int blurType) {
+        type = blurType;
+    }
+
+    public void setDelegate(PhotoFilterLinearBlurControlDelegate delegate) {
+        this.delegate = delegate;
+    }
+
+    private float getDistance(MotionEvent event) {
+        if (event.getPointerCount() != 2) {
+            return 0;
+        }
+        float x1 = event.getX(0);
+        float y1 = event.getY(0);
+        float x2 = event.getX(1);
+        float y2 = event.getY(1);
+        return (float) Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
+    }
+
+    private float degreesToRadians(float degrees) {
+        return degrees * (float) Math.PI / 180.0f;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        int action = event.getActionMasked();
+
+        switch (action) {
+            case MotionEvent.ACTION_POINTER_DOWN:
+            case MotionEvent.ACTION_DOWN: {
+                if (event.getPointerCount() == 1) {
+                    if (checkForMoving && !isMoving) {
+                        float locationX = event.getX();
+                        float locationY = event.getY();
+                        Point centerPoint = getActualCenterPoint();
+                        Point delta = new Point(locationX - centerPoint.x, locationY - centerPoint.y);
+                        float radialDistance = (float) Math.sqrt(delta.x * delta.x + delta.y * delta.y);
+                        float innerRadius = getActualInnerRadius();
+                        float outerRadius = getActualOuterRadius();
+                        boolean close = Math.abs(outerRadius - innerRadius) < BlurInsetProximity;
+                        float innerRadiusOuterInset = close ? 0 : BlurViewRadiusInset;
+                        float outerRadiusInnerInset = close ? 0 : BlurViewRadiusInset;
+
+                        if (type == 0) {
+                            float distance = (float) Math.abs(delta.x * Math.cos(degreesToRadians(angle) + Math.PI / 2) + delta.y * Math.sin(degreesToRadians(angle) + Math.PI / 2));
+                            if (radialDistance < BlurViewCenterInset) {
+                                isMoving = true;
+                            } else if (distance > innerRadius - BlurViewRadiusInset && distance < innerRadius + innerRadiusOuterInset) {
+                                isMoving = true;
+                            } else if (distance > outerRadius - outerRadiusInnerInset && distance < outerRadius + BlurViewRadiusInset) {
+                                isMoving = true;
+                            } else if ((distance <= innerRadius - BlurViewRadiusInset) || distance >= outerRadius + BlurViewRadiusInset) {
+                                isMoving = true;
+                            }
+                        } else if (type == 1) {
+                            if (radialDistance < BlurViewCenterInset) {
+                                isMoving = true;
+                            } else if (radialDistance > innerRadius - BlurViewRadiusInset && radialDistance < innerRadius + innerRadiusOuterInset) {
+                                isMoving = true;
+                            } else if (radialDistance > outerRadius - outerRadiusInnerInset && radialDistance < outerRadius + BlurViewRadiusInset) {
+                                isMoving = true;
+                            }
+                        }
+                        checkForMoving = false;
+                        if (isMoving) {
+                            handlePan(GestureStateBegan, event);
+                        }
+                    }
+                } else {
+                    if (isMoving) {
+                        handlePan(GestureStateEnded, event);
+                        checkForMoving = true;
+                        isMoving = false;
+                    }
+                    if (event.getPointerCount() == 2) {
+                        if (checkForZooming && !isZooming) {
+                            handlePinch(GestureStateBegan, event);
+                            isZooming = true;
+                        }
+                    } else {
+                        handlePinch(GestureStateEnded, event);
+                        checkForZooming = true;
+                        isZooming = false;
+                    }
+                }
+                break;
+            }
+
+            case MotionEvent.ACTION_POINTER_UP:
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP: {
+                if (isMoving) {
+                    handlePan(GestureStateEnded, event);
+                    isMoving = false;
+                } else if (isZooming) {
+                    handlePinch(GestureStateEnded, event);
+                    isZooming = false;
+                }
+                checkForMoving = true;
+                checkForZooming = true;
+                break;
+            }
+
+            case MotionEvent.ACTION_MOVE: {
+                if (isMoving) {
+                    handlePan(GestureStateChanged, event);
+                } else if (isZooming) {
+                    handlePinch(GestureStateChanged, event);
+                }
+            }
+        }
+        return true;
+    }
+
+    private void handlePan(int state, MotionEvent event) {
+        float locationX = event.getX();
+        float locationY = event.getY();
+        Point actualCenterPoint = getActualCenterPoint();
+        Point delta = new Point(locationX - actualCenterPoint.x, locationY - actualCenterPoint.y);
+        float radialDistance = (float) Math.sqrt(delta.x * delta.x + delta.y * delta.y);
+        float shorterSide = (actualAreaSize.width > actualAreaSize.height) ? actualAreaSize.height : actualAreaSize.width;
+        float innerRadius = shorterSide * falloff;
+        float outerRadius = shorterSide * size;
+        float distance = (float) Math.abs(delta.x * Math.cos(degreesToRadians(angle) + Math.PI / 2.0f) + delta.y * Math.sin(degreesToRadians(angle) + Math.PI / 2.0f));
+
+        switch (state) {
+            case GestureStateBegan: {
+                pointerStartX = event.getX();
+                pointerStartY = event.getY();
+
+                boolean close = Math.abs(outerRadius - innerRadius) < BlurInsetProximity;
+                float innerRadiusOuterInset = close ? 0 : BlurViewRadiusInset;
+                float outerRadiusInnerInset = close ? 0 : BlurViewRadiusInset;
+
+                if (type == 0) {
+                    if (radialDistance < BlurViewCenterInset) {
+                        activeControl = BlurViewActiveControl.BlurViewActiveControlCenter;
+                        startCenterPoint = actualCenterPoint;
+                    } else if (distance > innerRadius - BlurViewRadiusInset && distance < innerRadius + innerRadiusOuterInset) {
+                        activeControl = BlurViewActiveControl.BlurViewActiveControlInnerRadius;
+                        startDistance = distance;
+                        startRadius = innerRadius;
+                    } else if (distance > outerRadius - outerRadiusInnerInset && distance < outerRadius + BlurViewRadiusInset) {
+                        activeControl = BlurViewActiveControl.BlurViewActiveControlOuterRadius;
+                        startDistance = distance;
+                        startRadius = outerRadius;
+                    } else if (distance <= innerRadius - BlurViewRadiusInset || distance >= outerRadius + BlurViewRadiusInset) {
+                        activeControl = BlurViewActiveControl.BlurViewActiveControlRotation;
+                    }
+                } else if (type == 1) {
+                    if (radialDistance < BlurViewCenterInset) {
+                        activeControl = BlurViewActiveControl.BlurViewActiveControlCenter;
+                        startCenterPoint = actualCenterPoint;
+                    } else if (radialDistance > innerRadius - BlurViewRadiusInset && radialDistance < innerRadius + innerRadiusOuterInset) {
+                        activeControl = BlurViewActiveControl.BlurViewActiveControlInnerRadius;
+                        startDistance = radialDistance;
+                        startRadius = innerRadius;
+                    } else if (radialDistance > outerRadius - outerRadiusInnerInset && radialDistance < outerRadius + BlurViewRadiusInset) {
+                        activeControl = BlurViewActiveControl.BlurViewActiveControlOuterRadius;
+                        startDistance = radialDistance;
+                        startRadius = outerRadius;
+                    }
+                }
+                setSelected(true, true);
+            }
+            break;
+
+            case GestureStateChanged: {
+                if (type == 0) {
+                    switch (activeControl) {
+                        case BlurViewActiveControlCenter: {
+                            float translationX = locationX - pointerStartX;
+                            float translationY = locationY - pointerStartY;
+                            Rect actualArea = new Rect((getWidth() - actualAreaSize.width) / 2, (getHeight() - actualAreaSize.height) / 2, actualAreaSize.width, actualAreaSize.height);
+                            Point newPoint = new Point(Math.max(actualArea.x, Math.min(actualArea.x + actualArea.width, startCenterPoint.x + translationX)), Math.max(actualArea.y, Math.min(actualArea.y + actualArea.height, startCenterPoint.y + translationY)));
+                            centerPoint = new Point((newPoint.x - actualArea.x) / actualAreaSize.width, ((newPoint.y - actualArea.y) + (actualAreaSize.width - actualAreaSize.height) / 2) / actualAreaSize.width);
+                        }
+                        break;
+
+                        case BlurViewActiveControlInnerRadius: {
+                            float d = distance - startDistance;
+                            falloff = Math.min(Math.max(BlurMinimumFalloff, (startRadius + d) / shorterSide), size - BlurMinimumDifference);
+                        }
+                        break;
+
+                        case BlurViewActiveControlOuterRadius: {
+                            float d = distance - startDistance;
+                            size = Math.max(falloff + BlurMinimumDifference, (startRadius + d) / shorterSide);
+                        }
+                        break;
+
+                        case BlurViewActiveControlRotation: {
+                            float translationX = locationX - pointerStartX;
+                            float translationY = locationY - pointerStartY;
+
+                            boolean clockwise = false;
+
+                            boolean right = locationX > actualCenterPoint.x;
+                            boolean bottom = locationY > actualCenterPoint.y;
+
+                            if (!right && !bottom) {
+                                if (Math.abs(translationY) > Math.abs(translationX)) {
+                                    if (translationY < 0) {
+                                        clockwise = true;
+                                    }
+                                } else {
+                                    if (translationX > 0) {
+                                        clockwise = true;
+                                    }
+                                }
+                            } else if (right && !bottom) {
+                                if (Math.abs(translationY) > Math.abs(translationX)) {
+                                    if (translationY > 0) {
+                                        clockwise = true;
+                                    }
+                                } else {
+                                    if (translationX > 0) {
+                                        clockwise = true;
+                                    }
+                                }
+                            } else if (right && bottom) {
+                                if (Math.abs(translationY) > Math.abs(translationX)) {
+                                    if (translationY > 0) {
+                                        clockwise = true;
+                                    }
+                                } else {
+                                    if (translationX < 0) {
+                                        clockwise = true;
+                                    }
+                                }
+                            } else {
+                                if (Math.abs(translationY) > Math.abs(translationX)) {
+                                    if (translationY < 0) {
+                                        clockwise = true;
+                                    }
+                                } else {
+                                    if (translationX < 0) {
+                                        clockwise = true;
+                                    }
+                                }
+                            }
+
+                            float d = (float) Math.sqrt(translationX * translationX + translationY * translationY);
+                            angle += d * ((clockwise ? 1 : 0) * 2 - 1) / (float) Math.PI / 1.15f;
+
+                            pointerStartX = locationX;
+                            pointerStartY = locationY;
+                        }
+                        break;
+
+                        default:
+                            break;
+                    }
+                } else if (type == 1) {
+                    switch (activeControl) {
+                        case BlurViewActiveControlCenter: {
+                            float translationX = locationX - pointerStartX;
+                            float translationY = locationY - pointerStartY;
+                            Rect actualArea = new Rect((getWidth() - actualAreaSize.width) / 2, (getHeight() - actualAreaSize.height) / 2, actualAreaSize.width, actualAreaSize.height);
+                            Point newPoint = new Point(Math.max(actualArea.x, Math.min(actualArea.x + actualArea.width, startCenterPoint.x + translationX)), Math.max(actualArea.y, Math.min(actualArea.y + actualArea.height, startCenterPoint.y + translationY)));
+                            centerPoint = new Point((newPoint.x - actualArea.x) / actualAreaSize.width, ((newPoint.y - actualArea.y) + (actualAreaSize.width - actualAreaSize.height) / 2) / actualAreaSize.width);
+                        }
+                        break;
+
+                        case BlurViewActiveControlInnerRadius: {
+                            float d = radialDistance - startDistance;
+                            falloff = Math.min(Math.max(BlurMinimumFalloff, (startRadius + d) / shorterSide), size - BlurMinimumDifference);
+                        }
+                        break;
+
+                        case BlurViewActiveControlOuterRadius: {
+                            float d = radialDistance - startDistance;
+                            size = Math.max(falloff + BlurMinimumDifference, (startRadius + d) / shorterSide);
+                        }
+                        break;
+
+                        default:
+                            break;
+                    }
+                }
+                invalidate();
+
+                if (delegate != null) {
+                    delegate.valueChanged(centerPoint, falloff, size, degreesToRadians(angle) + (float) Math.PI / 2.0f);
+                }
+            }
+            break;
+
+            case GestureStateEnded:
+            case GestureStateCancelled:
+            case GestureStateFailed: {
+                activeControl = BlurViewActiveControl.BlurViewActiveControlNone;
+                setSelected(false, true);
+            }
+            break;
+
+            default:
+                break;
+        }
+    }
+
+    private void handlePinch(int state, MotionEvent event) {
+
+        switch (state) {
+            case GestureStateBegan: {
+                startPointerDistance = getDistance(event);
+                pointerScale = 1;
+                activeControl = BlurViewActiveControl.BlurViewActiveControlWholeArea;
+                setSelected(true, true);
+            }
+            case GestureStateChanged: {
+                float newDistance = getDistance(event);
+                pointerScale += (newDistance - startPointerDistance) / AndroidUtilities.density * 0.01f;
+
+                falloff = Math.max(BlurMinimumFalloff, falloff * pointerScale);
+                size = Math.max(falloff + BlurMinimumDifference, size * pointerScale);
+
+                pointerScale = 1;
+                startPointerDistance = newDistance;
+
+                invalidate();
+
+                if (delegate != null) {
+                    delegate.valueChanged(centerPoint, falloff, size, degreesToRadians(angle) + (float) Math.PI / 2.0f);
+                }
+            }
+            break;
+
+            case GestureStateEnded:
+            case GestureStateCancelled:
+            case GestureStateFailed: {
+                activeControl = BlurViewActiveControl.BlurViewActiveControlNone;
+                setSelected(false, true);
+            }
+            break;
+
+            default:
+                break;
+        }
+    }
+
+    private void setSelected(boolean selected, boolean animated) {
+        /*if (animated) {
+            [UIView animateWithDuration:0.16f delay:0.0f options:UIViewAnimationOptionBeginFromCurrentState animations:^
+            {
+                self.alpha = selected ? 0.6f : 1.0f;
+            } completion:nil];
+        } else {
+            self.alpha = selected ? 0.6f : 1.0f;
+        }*/
+    }
+
+    public void setActualAreaSize(float width, float height) {
+        actualAreaSize.width = width;
+        actualAreaSize.height = height;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        Point centerPoint = getActualCenterPoint();
+        float innerRadius = getActualInnerRadius();
+        float outerRadius = getActualOuterRadius();
+        canvas.translate(centerPoint.x, centerPoint.y);
+
+        if (type == 0) {
+            canvas.rotate(angle);
+
+            float space = AndroidUtilities.dp(6.0f);
+            float length = AndroidUtilities.dp(12.0f);
+            float thickness = AndroidUtilities.dp(1.5f);
+            for (int i = 0; i < 30; i++) {
+                canvas.drawRect(i * (length + space), -innerRadius, i * (length + space) + length, thickness - innerRadius, paint);
+                canvas.drawRect(-i * (length + space) - space - length, -innerRadius, -i * (length + space) - space, thickness - innerRadius, paint);
+
+                canvas.drawRect(i * (length + space), innerRadius, length + i * (length + space), thickness + innerRadius, paint);
+                canvas.drawRect(-i * (length + space) - space - length, innerRadius, -i * (length + space) - space, thickness + innerRadius, paint);
+            }
+
+            length = AndroidUtilities.dp(6.0f);
+            for (int i = 0; i < 64; i++) {
+                canvas.drawRect(i * (length + space), -outerRadius, length + i * (length + space), thickness - outerRadius, paint);
+                canvas.drawRect(-i * (length + space) - space - length, -outerRadius, -i * (length + space) - space, thickness - outerRadius, paint);
+
+                canvas.drawRect(i * (length + space), outerRadius, length + i * (length + space), thickness + outerRadius, paint);
+                canvas.drawRect(-i * (length + space) - space - length, outerRadius, -i * (length + space) - space, thickness + outerRadius, paint);
+            }
+        } else if (type == 1) {
+            float radSpace = 6.15f;
+            float radLen = 10.2f;
+            arcRect.set(-innerRadius, -innerRadius, innerRadius, innerRadius);
+            for (int i = 0; i < 22; i++) {
+                canvas.drawArc(arcRect, i * (radSpace + radLen), radLen, false, arcPaint);
+            }
+
+            radSpace = 2.02f;
+            radLen = 3.6f;
+            arcRect.set(-outerRadius, -outerRadius, outerRadius, outerRadius);
+            for (int i = 0; i < 64; i++) {
+                canvas.drawArc(arcRect, i * (radSpace + radLen), radLen, false, arcPaint);
+            }
+        }
+        canvas.drawCircle(0, 0, AndroidUtilities.dp(8), paint);
+    }
+
+    private Point getActualCenterPoint() {
+        return new Point((getWidth() - actualAreaSize.width) / 2 + centerPoint.x * actualAreaSize.width, (getHeight() - actualAreaSize.height) / 2 - (actualAreaSize.width - actualAreaSize.height) / 2 + centerPoint.y * actualAreaSize.width);
+    }
+
+    private float getActualInnerRadius() {
+        return (actualAreaSize.width > actualAreaSize.height ? actualAreaSize.height : actualAreaSize.width) * falloff;
+    }
+
+    private float getActualOuterRadius() {
+        return (actualAreaSize.width > actualAreaSize.height ? actualAreaSize.height : actualAreaSize.width) * size;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoViewerCaptionEnterView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoViewerCaptionEnterView.java
new file mode 100644
index 000000000..0bf595a75
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoViewerCaptionEnterView.java
@@ -0,0 +1,610 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.app.Activity;
+import android.content.Context;
+import android.text.Editable;
+import android.text.InputFilter;
+import android.text.InputType;
+import android.text.TextWatcher;
+import android.text.style.ImageSpan;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
+import android.view.inputmethod.EditorInfo;
+import android.widget.EditText;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.PopupWindow;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.Emoji;
+import org.telegram.android.LocaleController;
+import org.telegram.android.NotificationCenter;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.R;
+import org.telegram.messenger.TLRPC;
+import org.telegram.android.AnimationCompat.AnimatorSetProxy;
+import org.telegram.android.AnimationCompat.ObjectAnimatorProxy;
+
+public class PhotoViewerCaptionEnterView extends FrameLayoutFixed implements NotificationCenter.NotificationCenterDelegate, SizeNotifierRelativeLayoutPhoto.SizeNotifierRelativeLayoutPhotoDelegate {
+
+    public interface PhotoViewerCaptionEnterViewDelegate {
+        void onCaptionEnter();
+        void onTextChanged(CharSequence text, boolean bigChange);
+        void onWindowSizeChanged(int size);
+    }
+
+    private EditText messageEditText;
+    private PopupWindow emojiPopup;
+    private ImageView emojiButton;
+    private EmojiView emojiView;
+    private SizeNotifierRelativeLayoutPhoto sizeNotifierFrameLayout;
+
+    private int framesDroped;
+
+    private int keyboardTransitionState;
+    private boolean showKeyboardOnEmojiButton;
+    private ViewTreeObserver.OnPreDrawListener onPreDrawListener;
+
+    private AnimatorSetProxy runningAnimation;
+    private AnimatorSetProxy runningAnimation2;
+    private ObjectAnimatorProxy runningAnimationAudio;
+    private int runningAnimationType;
+    private int audioInterfaceState;
+
+    private int keyboardHeight;
+    private int keyboardHeightLand;
+    private boolean keyboardVisible;
+
+    private View window;
+    private PhotoViewerCaptionEnterViewDelegate delegate;
+    private boolean wasFocus;
+
+    public PhotoViewerCaptionEnterView(Context context, View windowView, SizeNotifierRelativeLayoutPhoto parent) {
+        super(context);
+        setBackgroundColor(0x7f000000);
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+
+        window = windowView;
+        sizeNotifierFrameLayout = parent;
+
+        LinearLayout textFieldContainer = new LinearLayout(context);
+        textFieldContainer.setOrientation(LinearLayout.HORIZONTAL);
+        addView(textFieldContainer, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP, 2, 0, 0, 0));
+
+        FrameLayoutFixed frameLayout = new FrameLayoutFixed(context);
+        textFieldContainer.addView(frameLayout, LayoutHelper.createLinear(0, LayoutHelper.WRAP_CONTENT, 1.0f));
+
+        emojiButton = new ImageView(context);
+        emojiButton.setImageResource(R.drawable.ic_smile_w);
+        emojiButton.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
+        emojiButton.setPadding(AndroidUtilities.dp(4), AndroidUtilities.dp(1), 0, 0);
+        frameLayout.addView(emojiButton, LayoutHelper.createFrame(48, 48, Gravity.BOTTOM | Gravity.LEFT));
+        emojiButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (showKeyboardOnEmojiButton) {
+                    setKeyboardTransitionState(1);
+                    showEmojiPopup(false, false);
+                    int selection = messageEditText.getSelectionStart();
+                    MotionEvent event = MotionEvent.obtain(0, 0, MotionEvent.ACTION_UP, 0, 0, 0);
+                    messageEditText.onTouchEvent(event);
+                    event.recycle();
+                    messageEditText.setSelection(selection);
+                } else {
+                    boolean show = emojiPopup == null || !emojiPopup.isShowing();
+                    if (show) {
+                        setKeyboardTransitionState(5);
+                        showEmojiPopup(show, true);
+                    } else {
+                        showEmojiPopup(show, true);
+                        setKeyboardTransitionState(1);
+                    }
+                }
+            }
+        });
+
+        messageEditText = new EditText(context);
+        messageEditText.setHint(LocaleController.getString("AddCaption", R.string.AddCaption));
+        messageEditText.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI | EditorInfo.IME_ACTION_DONE);
+        messageEditText.setInputType(EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
+        messageEditText.setSingleLine(false);
+        messageEditText.setMaxLines(4);
+        messageEditText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
+        messageEditText.setGravity(Gravity.BOTTOM);
+        messageEditText.setPadding(0, AndroidUtilities.dp(11), 0, AndroidUtilities.dp(12));
+        messageEditText.setBackgroundDrawable(null);
+        AndroidUtilities.clearCursorDrawable(messageEditText);
+        messageEditText.setTextColor(0xffffffff);
+        messageEditText.setHintTextColor(0xb2ffffff);
+        InputFilter[] inputFilters = new InputFilter[1];
+        inputFilters[0] = new InputFilter.LengthFilter(140);
+        messageEditText.setFilters(inputFilters);
+        frameLayout.addView(messageEditText, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM, 52, 0, 6, 0));
+        messageEditText.setOnKeyListener(new OnKeyListener() {
+            @Override
+            public boolean onKey(View view, int i, KeyEvent keyEvent) {
+                if (i == 4 && !keyboardVisible && emojiPopup != null && emojiPopup.isShowing()) {
+                    if (keyEvent.getAction() == 1) {
+                        showEmojiPopup(false, true);
+                    }
+                    return true;
+                } else if (i == KeyEvent.KEYCODE_ENTER && keyEvent.getAction() == KeyEvent.ACTION_DOWN) {
+                    delegate.onCaptionEnter();
+                    return true;
+                }
+                return false;
+            }
+        });
+        messageEditText.setOnFocusChangeListener(new OnFocusChangeListener() {
+            @Override
+            public void onFocusChange(View v, boolean hasFocus) {
+                if (!wasFocus) {
+                    setKeyboardTransitionState(3);
+                }
+                wasFocus = hasFocus;
+            }
+        });
+        messageEditText.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (emojiPopup != null && emojiPopup.isShowing()) {
+                    setKeyboardTransitionState(1);
+                    showEmojiPopup(false, false);
+                } else {
+                    setKeyboardTransitionState(3);
+                }
+            }
+        });
+        messageEditText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
+            @Override
+            public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
+                if (i == EditorInfo.IME_ACTION_DONE) {
+                    delegate.onCaptionEnter();
+                    return true;
+                } else if (keyEvent != null && i == EditorInfo.IME_NULL && keyEvent.getAction() == KeyEvent.ACTION_DOWN) {
+                    delegate.onCaptionEnter();
+                    return true;
+                }
+                return false;
+            }
+        });
+        messageEditText.addTextChangedListener(new TextWatcher() {
+            @Override
+            public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
+
+            }
+
+            @Override
+            public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
+                String message = getTrimmedString(charSequence.toString());
+
+                if (delegate != null) {
+                    delegate.onTextChanged(charSequence, before > count || count > 2);
+                }
+            }
+
+            @Override
+            public void afterTextChanged(Editable editable) {
+                int i = 0;
+                ImageSpan[] arrayOfImageSpan = editable.getSpans(0, editable.length(), ImageSpan.class);
+                int j = arrayOfImageSpan.length;
+                while (true) {
+                    if (i >= j) {
+                        Emoji.replaceEmoji(editable, messageEditText.getPaint().getFontMetricsInt(), AndroidUtilities.dp(20));
+                        return;
+                    }
+                    editable.removeSpan(arrayOfImageSpan[i]);
+                    i++;
+                }
+            }
+        });
+    }
+
+    private void setKeyboardTransitionState(int state) {
+        if (AndroidUtilities.usingHardwareInput) {
+            if (state == 1) {
+                showEmojiPopup(false, false);
+                RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) getLayoutParams();
+                layoutParams.bottomMargin = 0;//AndroidUtilities.dp(48);
+                setLayoutParams(layoutParams);
+                keyboardTransitionState = 0;
+            } else if (state == 2) {
+                int currentHeight = AndroidUtilities.displaySize.x > AndroidUtilities.displaySize.y ? keyboardHeightLand : keyboardHeight;
+                sizeNotifierFrameLayout.setPadding(0, 0, 0, currentHeight);
+                keyboardTransitionState = 0;
+            } else if (state == 3) {
+                RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) getLayoutParams();
+                layoutParams.bottomMargin = 0;//AndroidUtilities.dp(48);
+                setLayoutParams(layoutParams);
+                keyboardTransitionState = 0;
+            } else if (state == 4) {
+                RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) getLayoutParams();
+                layoutParams.bottomMargin = -AndroidUtilities.dp(400);
+                setLayoutParams(layoutParams);
+                keyboardTransitionState = 0;
+            } else if (state == 5) {
+                RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) getLayoutParams();
+                layoutParams.bottomMargin = 0;
+                setLayoutParams(layoutParams);
+                keyboardTransitionState = 0;
+            }
+        } else {
+            framesDroped = 0;
+            keyboardTransitionState = state;
+            if (state == 1) {
+                sizeNotifierFrameLayout.setPadding(0, 0, 0, 0);
+            }
+        }
+    }
+
+    public int getKeyboardTransitionState() {
+        return keyboardTransitionState;
+    }
+
+    private void onWindowSizeChanged(int size) {
+        if (delegate != null) {
+            delegate.onWindowSizeChanged(size);
+        }
+    }
+
+    public void onCreate() {
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.emojiDidLoaded);
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.hideEmojiKeyboard);
+        sizeNotifierFrameLayout.getViewTreeObserver().addOnPreDrawListener(onPreDrawListener = new ViewTreeObserver.OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                if (keyboardTransitionState == 1) {
+                    if (keyboardVisible || framesDroped >= 60) {
+                        showEmojiPopup(false, false);
+                        keyboardTransitionState = 0;
+                    } else {
+                        if (messageEditText != null) {
+                            messageEditText.requestFocus();
+                            AndroidUtilities.showKeyboard(messageEditText);
+                        }
+                    }
+                    framesDroped++;
+                    return false;
+                } else if (keyboardTransitionState == 2) {
+                    if (!keyboardVisible || framesDroped >= 60) {
+                        int currentHeight = AndroidUtilities.displaySize.x > AndroidUtilities.displaySize.y ? keyboardHeightLand : keyboardHeight;
+                        sizeNotifierFrameLayout.setPadding(0, 0, 0, currentHeight);
+                        keyboardTransitionState = 0;
+                    }
+                    framesDroped++;
+                    return false;
+                } else if (keyboardTransitionState == 3) {
+                    if (keyboardVisible) {
+                        RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) getLayoutParams();
+                        layoutParams.bottomMargin = 0;//AndroidUtilities.usingHardwareInput ? AndroidUtilities.dp(48) : 0;
+                        setLayoutParams(layoutParams);
+                        keyboardTransitionState = 0;
+                    }
+                } else if (keyboardTransitionState == 4) {
+                    if (!keyboardVisible && (emojiPopup == null || !emojiPopup.isShowing())) {
+                        RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) getLayoutParams();
+                        layoutParams.bottomMargin = -AndroidUtilities.dp(400);
+                        setLayoutParams(layoutParams);
+                        keyboardTransitionState = 0;
+                    }
+                } else if (keyboardTransitionState == 5) {
+                    if (emojiPopup != null && emojiPopup.isShowing()) {
+                        RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams) getLayoutParams();
+                        layoutParams.bottomMargin = 0;
+                        setLayoutParams(layoutParams);
+                        keyboardTransitionState = 0;
+                    }
+                }
+                return true;
+            }
+        });
+        sizeNotifierFrameLayout.setDelegate(this);
+    }
+
+    public void onDestroy() {
+        if (isEmojiPopupShowing()) {
+            hideEmojiPopup();
+        }
+        if (isKeyboardVisible()) {
+            closeKeyboard();
+        }
+        keyboardVisible = false;
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.emojiDidLoaded);
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.hideEmojiKeyboard);
+        if (sizeNotifierFrameLayout != null) {
+            sizeNotifierFrameLayout.getViewTreeObserver().removeOnPreDrawListener(onPreDrawListener);
+            sizeNotifierFrameLayout.setDelegate(null);
+        }
+    }
+
+    private String getTrimmedString(String src) {
+        String result = src.trim();
+        if (result.length() == 0) {
+            return result;
+        }
+        while (src.startsWith("\n")) {
+            src = src.substring(1);
+        }
+        while (src.endsWith("\n")) {
+            src = src.substring(0, src.length() - 1);
+        }
+        return src;
+    }
+
+    private void showEmojiPopup(boolean show, boolean post) {
+        if (show) {
+            if (emojiPopup == null) {
+                emojiView = new EmojiView(false, getContext());
+                emojiView.setListener(new EmojiView.Listener() {
+                    public boolean onBackspace() {
+                        if (messageEditText.length() == 0) {
+                            return false;
+                        }
+                        messageEditText.dispatchKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL));
+                        return true;
+                    }
+
+                    public void onEmojiSelected(String symbol) {
+                        int i = messageEditText.getSelectionEnd();
+                        if (i < 0) {
+                            i = 0;
+                        }
+                        try {
+                            CharSequence localCharSequence = Emoji.replaceEmoji(symbol, messageEditText.getPaint().getFontMetricsInt(), AndroidUtilities.dp(20));
+                            messageEditText.setText(messageEditText.getText().insert(i, localCharSequence));
+                            int j = i + localCharSequence.length();
+                            messageEditText.setSelection(j, j);
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+
+                    public void onStickerSelected(TLRPC.Document sticker) {
+
+                    }
+                });
+                emojiPopup = new PopupWindow(emojiView);
+            }
+
+            if (keyboardHeight <= 0) {
+                keyboardHeight = ApplicationLoader.applicationContext.getSharedPreferences("emoji", 0).getInt("kbd_height", AndroidUtilities.dp(200));
+            }
+            if (keyboardHeightLand <= 0) {
+                keyboardHeightLand = ApplicationLoader.applicationContext.getSharedPreferences("emoji", 0).getInt("kbd_height_land3", AndroidUtilities.dp(200));
+            }
+            int currentHeight = AndroidUtilities.displaySize.x > AndroidUtilities.displaySize.y ? keyboardHeightLand : keyboardHeight;
+            FileLog.e("tmessages", "show emoji with height = " + currentHeight);
+            emojiPopup.setHeight(View.MeasureSpec.makeMeasureSpec(currentHeight, View.MeasureSpec.EXACTLY));
+            if (sizeNotifierFrameLayout != null) {
+                emojiPopup.setWidth(View.MeasureSpec.makeMeasureSpec(AndroidUtilities.displaySize.x, View.MeasureSpec.EXACTLY));
+            }
+
+            emojiPopup.showAtLocation(window, Gravity.BOTTOM | Gravity.LEFT, 0, 0);
+
+            if (!keyboardVisible) {
+                if (sizeNotifierFrameLayout != null) {
+                    sizeNotifierFrameLayout.setPadding(0, 0, 0, currentHeight);
+                    emojiButton.setImageResource(R.drawable.arrow_down_w);
+                    showKeyboardOnEmojiButton = false;
+                    onWindowSizeChanged(sizeNotifierFrameLayout.getHeight() - sizeNotifierFrameLayout.getPaddingBottom());
+                }
+                return;
+            } else {
+                setKeyboardTransitionState(2);
+                AndroidUtilities.hideKeyboard(messageEditText);
+            }
+            emojiButton.setImageResource(R.drawable.ic_keyboard_w);
+            showKeyboardOnEmojiButton = true;
+            return;
+        }
+        if (emojiButton != null) {
+            showKeyboardOnEmojiButton = false;
+            emojiButton.setImageResource(R.drawable.ic_smile_w);
+        }
+        if (emojiPopup != null) {
+            try {
+                emojiPopup.dismiss();
+            } catch (Exception e) {
+                //don't promt
+            }
+        }
+        if (keyboardTransitionState == 0) {
+            if (sizeNotifierFrameLayout != null) {
+                if (post) {
+                    sizeNotifierFrameLayout.post(new Runnable() {
+                        public void run() {
+                            if (sizeNotifierFrameLayout != null) {
+                                sizeNotifierFrameLayout.setPadding(0, 0, 0, 0);
+                                onWindowSizeChanged(sizeNotifierFrameLayout.getHeight());
+                            }
+                        }
+                    });
+                } else {
+                    sizeNotifierFrameLayout.setPadding(0, 0, 0, 0);
+                    onWindowSizeChanged(sizeNotifierFrameLayout.getHeight());
+                }
+            }
+        }
+    }
+
+    public void hideEmojiPopup() {
+        if (emojiPopup != null && emojiPopup.isShowing()) {
+            showEmojiPopup(false, true);
+        }
+        setKeyboardTransitionState(4);
+    }
+
+    public void openKeyboard() {
+        setKeyboardTransitionState(3);
+        messageEditText.requestFocus();
+        AndroidUtilities.showKeyboard(messageEditText);
+    }
+
+    public void closeKeyboard() {
+        setKeyboardTransitionState(4);
+        AndroidUtilities.hideKeyboard(messageEditText);
+    }
+
+    public void setDelegate(PhotoViewerCaptionEnterViewDelegate delegate) {
+        this.delegate = delegate;
+    }
+
+    public void setFieldText(CharSequence text) {
+        if (messageEditText == null) {
+            return;
+        }
+        messageEditText.setText(text);
+        messageEditText.setSelection(messageEditText.getText().length());
+        if (delegate != null) {
+            delegate.onTextChanged(messageEditText.getText(), true);
+        }
+    }
+
+    public int getCursorPosition() {
+        if (messageEditText == null) {
+            return 0;
+        }
+        return messageEditText.getSelectionStart();
+    }
+
+    public void replaceWithText(int start, int len, String text) {
+        try {
+            StringBuilder builder = new StringBuilder(messageEditText.getText());
+            builder.replace(start, start + len, text);
+            messageEditText.setText(builder);
+            if (start + text.length() <= messageEditText.length()) {
+                messageEditText.setSelection(start + text.length());
+            } else {
+                messageEditText.setSelection(messageEditText.length());
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    public void setFieldFocused(boolean focus) {
+        if (messageEditText == null) {
+            return;
+        }
+        if (focus) {
+            if (!messageEditText.isFocused()) {
+                messageEditText.postDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (messageEditText != null) {
+                            try {
+                                messageEditText.requestFocus();
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                        }
+                    }
+                }, 600);
+            }
+        } else {
+            if (messageEditText.isFocused() && !keyboardVisible) {
+                messageEditText.clearFocus();
+            }
+        }
+    }
+
+    public boolean hasText() {
+        return messageEditText != null && messageEditText.length() > 0;
+    }
+
+    public String getFieldText() {
+        if (messageEditText != null && messageEditText.length() > 0) {
+            return getTrimmedString(messageEditText.getText().toString());
+        }
+        return null;
+    }
+
+    public CharSequence getFieldCharSequence() {
+        return messageEditText.getText();
+    }
+
+    public boolean isEmojiPopupShowing() {
+        return emojiPopup != null && emojiPopup.isShowing();
+    }
+
+    public boolean isKeyboardVisible() {
+        return AndroidUtilities.usingHardwareInput && getLayoutParams() != null && ((RelativeLayout.LayoutParams) getLayoutParams()).bottomMargin == 0 || keyboardVisible;
+    }
+
+    @Override
+    public void onSizeChanged(int height, boolean isWidthGreater) {
+        if (height > AndroidUtilities.dp(50) && keyboardVisible) {
+            if (isWidthGreater) {
+                keyboardHeightLand = height;
+                ApplicationLoader.applicationContext.getSharedPreferences("emoji", 0).edit().putInt("kbd_height_land3", keyboardHeightLand).commit();
+            } else {
+                keyboardHeight = height;
+                ApplicationLoader.applicationContext.getSharedPreferences("emoji", 0).edit().putInt("kbd_height", keyboardHeight).commit();
+            }
+        }
+
+        if (emojiPopup != null && emojiPopup.isShowing()) {
+            int newHeight = 0;
+            if (isWidthGreater) {
+                newHeight = keyboardHeightLand;
+            } else {
+                newHeight = keyboardHeight;
+            }
+            WindowManager.LayoutParams layoutParams = (WindowManager.LayoutParams) emojiPopup.getContentView().getLayoutParams();
+            if (layoutParams.width != AndroidUtilities.displaySize.x || layoutParams.height != newHeight) {
+                layoutParams.width = AndroidUtilities.displaySize.x;
+                layoutParams.height = newHeight;
+                WindowManager wm = (WindowManager) ApplicationLoader.applicationContext.getSystemService(Activity.WINDOW_SERVICE);
+                if (wm != null) {
+                    wm.updateViewLayout(emojiPopup.getContentView(), layoutParams);
+                    if (!keyboardVisible) {
+                        if (sizeNotifierFrameLayout != null) {
+                            sizeNotifierFrameLayout.setPadding(0, 0, 0, layoutParams.height);
+                            sizeNotifierFrameLayout.requestLayout();
+                            onWindowSizeChanged(sizeNotifierFrameLayout.getHeight() - sizeNotifierFrameLayout.getPaddingBottom());
+                        }
+                    }
+                }
+            }
+        }
+
+        boolean oldValue = keyboardVisible;
+        keyboardVisible = height > 0;
+        if (keyboardVisible && (sizeNotifierFrameLayout.getPaddingBottom() > 0 || keyboardTransitionState == 1)) {
+            setKeyboardTransitionState(1);
+        } else if (keyboardTransitionState != 2 && !keyboardVisible && keyboardVisible != oldValue && emojiPopup != null && emojiPopup.isShowing()) {
+            showEmojiPopup(false, true);
+        }
+        if (keyboardTransitionState == 0) {
+            onWindowSizeChanged(sizeNotifierFrameLayout.getHeight() - sizeNotifierFrameLayout.getPaddingBottom());
+        }
+    }
+
+    @Override
+    public void didReceivedNotification(int id, Object... args) {
+        if (id == NotificationCenter.emojiDidLoaded) {
+            if (emojiView != null) {
+                emojiView.invalidateViews();
+            }
+        } else if (id == NotificationCenter.hideEmojiKeyboard) {
+            hideEmojiPopup();
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/Point.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/Point.java
new file mode 100644
index 000000000..f22dde478
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/Point.java
@@ -0,0 +1,23 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+public class Point {
+    public float x;
+    public float y;
+
+    public Point() {
+
+    }
+
+    public Point(float x, float y) {
+        this.x = x;
+        this.y = y;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecordStatusDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecordStatusDrawable.java
new file mode 100644
index 000000000..b224eb3e5
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecordStatusDrawable.java
@@ -0,0 +1,110 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+
+import org.telegram.android.AndroidUtilities;
+
+public class RecordStatusDrawable extends Drawable {
+
+    private boolean isChat = false;
+    private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private long lastUpdateTime = 0;
+    private boolean started = false;
+    private RectF rect = new RectF();
+    private float progress;
+
+    public RecordStatusDrawable() {
+        super();
+        paint.setColor(0xffd7e8f7);
+        paint.setStyle(Paint.Style.STROKE);
+        paint.setStrokeWidth(AndroidUtilities.dp(2));
+        paint.setStrokeCap(Paint.Cap.ROUND);
+    }
+
+    public void setIsChat(boolean value) {
+        isChat = value;
+    }
+
+    private void update() {
+        long newTime = System.currentTimeMillis();
+        long dt = newTime - lastUpdateTime;
+        lastUpdateTime = newTime;
+        if (dt > 50) {
+            dt = 50;
+        }
+        progress += dt / 300.0f;
+        while (progress > 1.0f) {
+            progress -= 1.0f;
+        }
+        invalidateSelf();
+    }
+
+    public void start() {
+        lastUpdateTime = System.currentTimeMillis();
+        started = true;
+        invalidateSelf();
+    }
+
+    public void stop() {
+        started = false;
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        canvas.save();
+        canvas.translate(0, getIntrinsicHeight() / 2 + AndroidUtilities.dp(isChat ? 1 : 2));
+        for (int a = 0; a < 4; a++) {
+            if (a == 0) {
+                paint.setAlpha((int) (255 * progress));
+            } else if (a == 3) {
+                paint.setAlpha((int) (255 * (1.0f - progress)));
+            } else {
+                paint.setAlpha(255);
+            }
+            float side = AndroidUtilities.dp(4) * a + AndroidUtilities.dp(4) * progress;
+            rect.set(-side, -side, side, side);
+            canvas.drawArc(rect, -15, 30, false, paint);
+        }
+        canvas.restore();
+        if (started) {
+            update();
+        }
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+
+    }
+
+    @Override
+    public int getOpacity() {
+        return 0;
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return AndroidUtilities.dp(18);
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return AndroidUtilities.dp(14);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/Rect.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/Rect.java
new file mode 100644
index 000000000..9dde354b9
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/Rect.java
@@ -0,0 +1,23 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+public class Rect {
+    public float x;
+    public float y;
+    public float width;
+    public float height;
+
+    public Rect(float x, float y, float width, float height) {
+        this.x = x;
+        this.y = y;
+        this.width = width;
+        this.height = height;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerExListView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerExListView.java
new file mode 100644
index 000000000..09e818588
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerExListView.java
@@ -0,0 +1,292 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.GestureDetector;
+import android.view.HapticFeedbackConstants;
+import android.view.MotionEvent;
+import android.view.SoundEffectConstants;
+import android.view.View;
+import android.view.ViewConfiguration;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.support.widget.RecyclerView;
+
+public class RecyclerExListView extends RecyclerView {
+
+    private OnItemClickListener onItemClickListener;
+    private OnItemLongClickListener onItemLongClickListener;
+    private RecyclerView.OnScrollListener onScrollListener;
+    private OnInterceptTouchListener onInterceptTouchListener;
+    private View emptyView;
+    private Runnable selectChildRunnable;
+
+    private GestureDetector mGestureDetector;
+    private View currentChildView;
+    private int currentChildPosition;
+    private boolean interceptedByChild;
+    private boolean wasPressed;
+
+    public interface OnItemClickListener {
+        void onItemClick(View view, int position);
+    }
+
+    public interface OnItemLongClickListener {
+        void onItemClick(View view, int position);
+    }
+
+    public interface OnInterceptTouchListener {
+        boolean onInterceptTouchEvent(MotionEvent event);
+    }
+
+    private class RecyclerListViewItemClickListener implements RecyclerView.OnItemTouchListener {
+
+        public RecyclerListViewItemClickListener(Context context) {
+            mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {
+                @Override
+                public boolean onSingleTapUp(MotionEvent e) {
+                    if (currentChildView != null && onItemClickListener != null) {
+                        currentChildView.playSoundEffect(SoundEffectConstants.CLICK);
+                        onItemClickListener.onItemClick(currentChildView, currentChildPosition);
+                        if (selectChildRunnable != null) {
+                            currentChildView.setPressed(true);
+                            final View view = currentChildView;
+                            AndroidUtilities.runOnUIThread(new Runnable() {
+                                @Override
+                                public void run() {
+                                    if (view != null) {
+                                        view.setPressed(false);
+                                    }
+                                }
+                            }, ViewConfiguration.getPressedStateDuration());
+                            AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
+                            selectChildRunnable = null;
+                            currentChildView = null;
+                            interceptedByChild = false;
+                        }
+                    }
+                    return true;
+                }
+
+                @Override
+                public void onLongPress(MotionEvent e) {
+                    if (currentChildView != null && onItemLongClickListener != null) {
+                        currentChildView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
+                        onItemLongClickListener.onItemClick(currentChildView, currentChildPosition);
+                    }
+                }
+            });
+        }
+
+        @Override
+        public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent e) {
+            int action = e.getActionMasked();
+            boolean isScrollIdle = RecyclerExListView.this.getScrollState() == RecyclerExListView.SCROLL_STATE_IDLE;
+
+            if ((action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) && currentChildView == null && isScrollIdle) {
+                currentChildView = view.findChildViewUnder(e.getX(), e.getY());
+                currentChildPosition = -1;
+                if (currentChildView != null) {
+                    currentChildPosition = view.getChildPosition(currentChildView);
+                    MotionEvent childEvent = MotionEvent.obtain(0, 0, e.getActionMasked(), e.getX() - currentChildView.getLeft(), e.getY() - currentChildView.getTop(), 0);
+                    if (currentChildView.onTouchEvent(childEvent)) {
+                        interceptedByChild = true;
+                    }
+                    childEvent.recycle();
+                }
+            }
+
+            if (currentChildView != null && !interceptedByChild) {
+                mGestureDetector.onTouchEvent(e);
+            }
+
+            if (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) {
+                if (!interceptedByChild && currentChildView != null) {
+                    selectChildRunnable = new Runnable() {
+                        @Override
+                        public void run() {
+                            if (selectChildRunnable != null && currentChildView != null) {
+                                currentChildView.setPressed(true);
+                                selectChildRunnable = null;
+                            }
+                        }
+                    };
+                    AndroidUtilities.runOnUIThread(selectChildRunnable, ViewConfiguration.getTapTimeout());
+                }
+            } else if (currentChildView != null && (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_CANCEL || !isScrollIdle)) {
+                if (selectChildRunnable != null) {
+                    AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
+                    selectChildRunnable = null;
+                }
+                currentChildView.setPressed(false);
+                currentChildView = null;
+                interceptedByChild = false;
+            }
+            return false;
+        }
+
+        @Override
+        public void onTouchEvent(RecyclerView view, MotionEvent e) {
+
+        }
+    }
+
+    private AdapterDataObserver observer = new AdapterDataObserver() {
+        @Override
+        public void onChanged() {
+            checkIfEmpty();
+        }
+
+        @Override
+        public void onItemRangeInserted(int positionStart, int itemCount) {
+            checkIfEmpty();
+        }
+
+        @Override
+        public void onItemRangeRemoved(int positionStart, int itemCount) {
+            checkIfEmpty();
+        }
+    };
+
+    public void init(Context context) {
+        super.setOnScrollListener(new OnScrollListener() {
+            @Override
+            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
+                if (newState != SCROLL_STATE_IDLE && currentChildView != null) {
+                    if (selectChildRunnable != null) {
+                        AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
+                        selectChildRunnable = null;
+                    }
+                    MotionEvent event = MotionEvent.obtain(0, 0, MotionEvent.ACTION_CANCEL, 0, 0, 0);
+                    mGestureDetector.onTouchEvent(event);
+                    currentChildView.onTouchEvent(event);
+                    event.recycle();
+                    currentChildView.setPressed(false);
+                    currentChildView = null;
+                    interceptedByChild = false;
+                }
+                if (onScrollListener != null) {
+                    onScrollListener.onScrollStateChanged(recyclerView, newState);
+                }
+            }
+
+            @Override
+            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+                if (onScrollListener != null) {
+                    onScrollListener.onScrolled(recyclerView, dx, dy);
+                }
+            }
+        });
+        addOnItemTouchListener(new RecyclerListViewItemClickListener(context));
+    }
+
+    public RecyclerExListView(Context context) {
+        super(context);
+
+        /*setVerticalScrollBarEnabled(true);
+        try {
+            TypedArray a = context.getTheme().obtainStyledAttributes(new int[0]);
+            Method initializeScrollbars = android.view.View.class.getDeclaredMethod("initializeScrollbars", TypedArray.class);
+            initializeScrollbars.invoke(this, a);
+            a.recycle();
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }*/
+
+        init(context);
+    }
+
+    public RecyclerExListView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context);
+    }
+
+    public RecyclerExListView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context);
+    }
+
+    public void setOnItemClickListener(OnItemClickListener listener) {
+        onItemClickListener = listener;
+    }
+
+    public void setOnItemLongClickListener(OnItemLongClickListener listener) {
+        onItemLongClickListener = listener;
+    }
+
+    public void setEmptyView(View view) {
+        if (emptyView == view) {
+            return;
+        }
+        emptyView = view;
+        checkIfEmpty();
+    }
+
+    public View getEmptyView() {
+        return emptyView;
+    }
+
+    public void invalidateViews() {
+        int count = getChildCount();
+        for (int a = 0; a < count; a++) {
+            getChildAt(a).invalidate();
+        }
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent e) {
+        return onInterceptTouchListener != null && onInterceptTouchListener.onInterceptTouchEvent(e) || super.onInterceptTouchEvent(e);
+    }
+
+    private void checkIfEmpty() {
+        if (emptyView == null || getAdapter() == null) {
+            return;
+        }
+        boolean emptyViewVisible = getAdapter().getItemCount() == 0;
+        emptyView.setVisibility(emptyViewVisible ? VISIBLE : INVISIBLE);
+        setVisibility(emptyViewVisible ? INVISIBLE : VISIBLE);
+    }
+
+    @Override
+    public void setOnScrollListener(OnScrollListener listener) {
+        onScrollListener = listener;
+    }
+
+    public void setOnInterceptTouchListener(OnInterceptTouchListener listener) {
+        onInterceptTouchListener = listener;
+    }
+
+    @Override
+    public void setAdapter(Adapter adapter) {
+        final Adapter oldAdapter = getAdapter();
+        if (oldAdapter != null) {
+            oldAdapter.unregisterAdapterDataObserver(observer);
+        }
+        super.setAdapter(adapter);
+        if (adapter != null) {
+            adapter.registerAdapterDataObserver(observer);
+        }
+        checkIfEmpty();
+    }
+
+    @Override
+    public void stopScroll() {
+        try {
+            super.stopScroll();
+        } catch (NullPointerException exception) {
+            /**
+             *  The mLayout has been disposed of before the
+             *  RecyclerView and this stops the application
+             *  from crashing.
+             */
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ResourceLoader.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ResourceLoader.java
new file mode 100644
index 000000000..278d937be
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ResourceLoader.java
@@ -0,0 +1,168 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.graphics.drawable.Drawable;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
+import org.telegram.ui.ImageListActivity;
+
+public class ResourceLoader {
+
+    public static Drawable backgroundDrawableIn;
+    public static Drawable backgroundDrawableInSelected;
+    public static Drawable backgroundDrawableOut;
+    public static Drawable backgroundDrawableOutSelected;
+    public static Drawable backgroundMediaDrawableIn;
+    public static Drawable backgroundMediaDrawableInSelected;
+    public static Drawable backgroundMediaDrawableOut;
+    public static Drawable backgroundMediaDrawableOutSelected;
+    public static Drawable checkDrawable;
+    public static Drawable halfCheckDrawable;
+    public static Drawable clockDrawable;
+    public static Drawable broadcastDrawable;
+    public static Drawable checkMediaDrawable;
+    public static Drawable halfCheckMediaDrawable;
+    public static Drawable clockMediaDrawable;
+    public static Drawable broadcastMediaDrawable;
+    public static Drawable errorDrawable;
+    public static Drawable backgroundBlack;
+    public static Drawable backgroundBlue;
+    public static Drawable mediaBackgroundDrawable;
+
+    public static Drawable geoInDrawable;
+    public static Drawable geoOutDrawable;
+
+    public static Drawable[][] audioStatesDrawable = new Drawable[10][2];
+
+    public static Drawable placeholderDocInDrawable;
+    public static Drawable placeholderDocOutDrawable;
+    public static Drawable videoIconDrawable;
+    public static Drawable docMenuInDrawable;
+    public static Drawable docMenuOutDrawable;
+    public static Drawable[] buttonStatesDrawables = new Drawable[8];
+    public static Drawable[][] buttonStatesDrawablesDoc = new Drawable[3][2];
+
+    public static void loadRecources(Context context) {
+        //if (backgroundDrawableIn == null) {
+            //backgroundDrawableIn = context.getResources().getDrawable(R.drawable.msg_in);
+            //backgroundDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_selected);
+            //backgroundDrawableOut = context.getResources().getDrawable(R.drawable.msg_out);
+            //backgroundDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_selected);
+            //backgroundMediaDrawableIn = context.getResources().getDrawable(R.drawable.msg_in_photo);
+            //backgroundMediaDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_photo_selected);
+            //backgroundMediaDrawableOut = context.getResources().getDrawable(R.drawable.msg_out_photo);
+            //backgroundMediaDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_photo_selected);
+            setBubbles(context);
+            checkDrawable = context.getResources().getDrawable(R.drawable.msg_check);
+            halfCheckDrawable = context.getResources().getDrawable(R.drawable.msg_halfcheck);
+            clockDrawable = context.getResources().getDrawable(R.drawable.msg_clock);
+            checkMediaDrawable = context.getResources().getDrawable(R.drawable.msg_check_w);
+            halfCheckMediaDrawable = context.getResources().getDrawable(R.drawable.msg_halfcheck_w);
+            clockMediaDrawable = context.getResources().getDrawable(R.drawable.msg_clock_photo);
+            errorDrawable = context.getResources().getDrawable(R.drawable.msg_warning);
+            mediaBackgroundDrawable = context.getResources().getDrawable(R.drawable.phototime);
+            broadcastDrawable = context.getResources().getDrawable(R.drawable.broadcast3);
+            broadcastMediaDrawable = context.getResources().getDrawable(R.drawable.broadcast4);
+            backgroundBlack = context.getResources().getDrawable(R.drawable.system_black);
+            backgroundBlue = context.getResources().getDrawable(R.drawable.system_blue);
+
+            audioStatesDrawable[0][0] = context.getResources().getDrawable(R.drawable.play_w2);
+            audioStatesDrawable[0][1] = context.getResources().getDrawable(R.drawable.play_w2_pressed);
+            audioStatesDrawable[1][0] = context.getResources().getDrawable(R.drawable.pause_w2);
+            audioStatesDrawable[1][1] = context.getResources().getDrawable(R.drawable.pause_w2_pressed);
+            audioStatesDrawable[2][0] = context.getResources().getDrawable(R.drawable.download_g);
+            audioStatesDrawable[2][1] = context.getResources().getDrawable(R.drawable.download_g_pressed);
+            audioStatesDrawable[3][0] = context.getResources().getDrawable(R.drawable.pause_g);
+            audioStatesDrawable[3][1] = context.getResources().getDrawable(R.drawable.pause_g_pressed);
+            audioStatesDrawable[4][0] = context.getResources().getDrawable(R.drawable.cancel_g);
+            audioStatesDrawable[4][1] = context.getResources().getDrawable(R.drawable.cancel_g_pressed);
+            audioStatesDrawable[5][0] = context.getResources().getDrawable(R.drawable.play_w);
+            audioStatesDrawable[5][1] = context.getResources().getDrawable(R.drawable.play_w_pressed);
+            audioStatesDrawable[6][0] = context.getResources().getDrawable(R.drawable.pause_w);
+            audioStatesDrawable[6][1] = context.getResources().getDrawable(R.drawable.pause_w_pressed);
+            audioStatesDrawable[7][0] = context.getResources().getDrawable(R.drawable.download_b);
+            audioStatesDrawable[7][1] = context.getResources().getDrawable(R.drawable.download_b_pressed);
+            audioStatesDrawable[8][0] = context.getResources().getDrawable(R.drawable.pause_b);
+            audioStatesDrawable[8][1] = context.getResources().getDrawable(R.drawable.pause_b_pressed);
+            audioStatesDrawable[9][0] = context.getResources().getDrawable(R.drawable.cancel_b);
+            audioStatesDrawable[9][1] = context.getResources().getDrawable(R.drawable.cancel_b_pressed);
+
+            placeholderDocInDrawable = context.getResources().getDrawable(R.drawable.doc_blue);
+            placeholderDocOutDrawable = context.getResources().getDrawable(R.drawable.doc_green);
+            buttonStatesDrawables[0] = context.getResources().getDrawable(R.drawable.photoload);
+            buttonStatesDrawables[1] = context.getResources().getDrawable(R.drawable.photocancel);
+            buttonStatesDrawables[2] = context.getResources().getDrawable(R.drawable.photogif);
+            buttonStatesDrawables[3] = context.getResources().getDrawable(R.drawable.playvideo);
+            buttonStatesDrawables[4] = context.getResources().getDrawable(R.drawable.photopause);
+            buttonStatesDrawables[5] = context.getResources().getDrawable(R.drawable.burn);
+            buttonStatesDrawables[6] = context.getResources().getDrawable(R.drawable.circle);
+            buttonStatesDrawables[7] = context.getResources().getDrawable(R.drawable.photocheck);
+            buttonStatesDrawablesDoc[0][0] = context.getResources().getDrawable(R.drawable.docload_b);
+            buttonStatesDrawablesDoc[1][0] = context.getResources().getDrawable(R.drawable.doccancel_b);
+            buttonStatesDrawablesDoc[2][0] = context.getResources().getDrawable(R.drawable.docpause_b);
+            buttonStatesDrawablesDoc[0][1] = context.getResources().getDrawable(R.drawable.docload_g);
+            buttonStatesDrawablesDoc[1][1] = context.getResources().getDrawable(R.drawable.doccancel_g);
+            buttonStatesDrawablesDoc[2][1] = context.getResources().getDrawable(R.drawable.docpause_g);
+            videoIconDrawable = context.getResources().getDrawable(R.drawable.ic_video);
+            docMenuInDrawable = context.getResources().getDrawable(R.drawable.doc_actions_b);
+            docMenuOutDrawable = context.getResources().getDrawable(R.drawable.doc_actions_g);
+
+            geoInDrawable = context.getResources().getDrawable(R.drawable.location_b);
+            geoOutDrawable = context.getResources().getDrawable(R.drawable.location_g);
+
+       // }
+    }
+
+    private static void setBubbles(Context context){
+        SharedPreferences themePrefs = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+        String bubble = themePrefs.getString("chatBubbleStyle", ImageListActivity.getBubbleName(0));
+        if(bubble.equals(ImageListActivity.getBubbleName(0))){
+            backgroundDrawableIn = context.getResources().getDrawable(R.drawable.msg_in);
+            backgroundDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_selected);
+            backgroundDrawableOut = context.getResources().getDrawable(R.drawable.msg_out);
+            backgroundDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_selected);
+            backgroundMediaDrawableIn = context.getResources().getDrawable(R.drawable.msg_in_photo);
+            backgroundMediaDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_photo_selected);
+            backgroundMediaDrawableOut = context.getResources().getDrawable(R.drawable.msg_out_photo);
+            backgroundMediaDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_photo_selected);
+        } else if(bubble.equals(ImageListActivity.getBubbleName(1))){
+            backgroundDrawableIn = context.getResources().getDrawable(R.drawable.msg_in_2);
+            backgroundDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_2_selected);
+            backgroundDrawableOut = context.getResources().getDrawable(R.drawable.msg_out_2);
+            backgroundDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_2_selected);
+            backgroundMediaDrawableIn = context.getResources().getDrawable(R.drawable.msg_in_2_photo);
+            backgroundMediaDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_2_photo_selected);
+            backgroundMediaDrawableOut = context.getResources().getDrawable(R.drawable.msg_out_2_photo);
+            backgroundMediaDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_2_photo_selected);
+        } else if(bubble.equals(ImageListActivity.getBubbleName(2))){
+            backgroundDrawableIn = context.getResources().getDrawable(R.drawable.msg_in_3);
+            backgroundDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_3_selected);
+            backgroundDrawableOut = context.getResources().getDrawable(R.drawable.msg_out_3);
+            backgroundDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_3_selected);
+            backgroundMediaDrawableIn = context.getResources().getDrawable(R.drawable.msg_in_3_photo);
+            backgroundMediaDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_3_photo_selected);
+            backgroundMediaDrawableOut = context.getResources().getDrawable(R.drawable.msg_out_3_photo);
+            backgroundMediaDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_3_photo_selected);
+        } else if(bubble.equals(ImageListActivity.getBubbleName(3))){
+            backgroundDrawableIn = context.getResources().getDrawable(R.drawable.msg_in_4);
+            backgroundDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_4_selected);
+            backgroundDrawableOut = context.getResources().getDrawable(R.drawable.msg_out_4);
+            backgroundDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_4_selected);
+            backgroundMediaDrawableIn = context.getResources().getDrawable(R.drawable.msg_in_4_photo);
+            backgroundMediaDrawableInSelected = context.getResources().getDrawable(R.drawable.msg_in_4_photo_selected);
+            backgroundMediaDrawableOut = context.getResources().getDrawable(R.drawable.msg_out_4_photo);
+            backgroundMediaDrawableOutSelected = context.getResources().getDrawable(R.drawable.msg_out_4_photo_selected);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileDrawable.java
new file mode 100644
index 000000000..103a440af
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileDrawable.java
@@ -0,0 +1,126 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.view.animation.DecelerateInterpolator;
+
+import org.telegram.android.AndroidUtilities;
+
+public class SendingFileDrawable extends Drawable {
+
+    private float radOffset = 0;
+    private float currentProgress = 0;
+    private float animationProgressStart = 0;
+    private long currentProgressTime = 0;
+    private float animatedProgressValue = 0;
+    private RectF cicleRect = new RectF();
+    private boolean isChat = false;
+    private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private long lastUpdateTime = 0;
+    private boolean started = false;
+    private static DecelerateInterpolator decelerateInterpolator = null;
+
+    public SendingFileDrawable() {
+        super();
+        paint.setColor(0xffd7e8f7);
+        paint.setStyle(Paint.Style.STROKE);
+        paint.setStrokeWidth(AndroidUtilities.dp(2));
+        paint.setStrokeCap(Paint.Cap.ROUND);
+        decelerateInterpolator = new DecelerateInterpolator();
+    }
+
+    public void setIsChat(boolean value) {
+        isChat = value;
+    }
+
+    public void setProgress(float value, boolean animated) {
+        if (!animated) {
+            animatedProgressValue = value;
+            animationProgressStart = value;
+        } else {
+            animationProgressStart = animatedProgressValue;
+        }
+        currentProgress = value;
+        currentProgressTime = 0;
+
+        invalidateSelf();
+    }
+
+    private void update() {
+        long newTime = System.currentTimeMillis();
+        long dt = newTime - lastUpdateTime;
+        lastUpdateTime = newTime;
+
+        if (animatedProgressValue != 1) {
+            radOffset += 360 * dt / 1000.0f;
+            float progressDiff = currentProgress - animationProgressStart;
+            if (progressDiff > 0) {
+                currentProgressTime += dt;
+                if (currentProgressTime >= 300) {
+                    animatedProgressValue = currentProgress;
+                    animationProgressStart = currentProgress;
+                    currentProgressTime = 0;
+                } else {
+                    animatedProgressValue = animationProgressStart + progressDiff * decelerateInterpolator.getInterpolation(currentProgressTime / 300.0f);
+                }
+            }
+            invalidateSelf();
+        }
+    }
+
+    public void start() {
+        lastUpdateTime = System.currentTimeMillis();
+        started = true;
+        invalidateSelf();
+    }
+
+    public void stop() {
+        started = false;
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        cicleRect.set(AndroidUtilities.dp(1), AndroidUtilities.dp(isChat ? 3 : 4), AndroidUtilities.dp(10), AndroidUtilities.dp(isChat ? 11 : 12));
+        canvas.drawArc(cicleRect, -90 + radOffset, Math.max(60, 360 * animatedProgressValue), false, paint);
+
+        if (started) {
+            update();
+        }
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+
+    }
+
+    @Override
+    public int getOpacity() {
+        return 0;
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return AndroidUtilities.dp(14);
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return AndroidUtilities.dp(14);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileEx2Drawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileEx2Drawable.java
new file mode 100644
index 000000000..48aae49e3
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileEx2Drawable.java
@@ -0,0 +1,97 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+
+import org.telegram.android.AndroidUtilities;
+
+public class SendingFileEx2Drawable extends Drawable {
+
+    private boolean isChat = false;
+    private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private long lastUpdateTime = 0;
+    private boolean started = false;
+    private float progress;
+
+    public SendingFileEx2Drawable() {
+        super();
+        paint.setColor(0xffd7e8f7);
+        paint.setStyle(Paint.Style.STROKE);
+        paint.setStrokeWidth(AndroidUtilities.dp(3));
+        paint.setStrokeCap(Paint.Cap.ROUND);
+    }
+
+    public void setIsChat(boolean value) {
+        isChat = value;
+    }
+
+    private void update() {
+        long newTime = System.currentTimeMillis();
+        long dt = newTime - lastUpdateTime;
+        lastUpdateTime = newTime;
+        if (dt > 50) {
+            dt = 50;
+        }
+        progress += dt / 1000.0f;
+        while (progress > 1.0f) {
+            progress -= 1.0f;
+        }
+        invalidateSelf();
+    }
+
+    public void start() {
+        lastUpdateTime = System.currentTimeMillis();
+        started = true;
+        invalidateSelf();
+    }
+
+    public void stop() {
+        started = false;
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        int start = (int) (progress <= 0.5f ? AndroidUtilities.dp(1) : AndroidUtilities.dp(11) * (progress - 0.5f) * 2);
+        int end = (int) (progress >= 0.5f ? AndroidUtilities.dp(11) : AndroidUtilities.dp(11) * progress * 2);
+        canvas.drawLine(start, AndroidUtilities.dp(isChat ? 11 : 12), end, AndroidUtilities.dp(isChat ? 11 : 12), paint);
+
+        if (started) {
+            update();
+        }
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+
+    }
+
+    @Override
+    public int getOpacity() {
+        return 0;
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return AndroidUtilities.dp(18);
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return AndroidUtilities.dp(14);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileExDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileExDrawable.java
new file mode 100644
index 000000000..9b5d5069b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileExDrawable.java
@@ -0,0 +1,107 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+
+import org.telegram.android.AndroidUtilities;
+
+public class SendingFileExDrawable extends Drawable {
+
+    private boolean isChat = false;
+    private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private long lastUpdateTime = 0;
+    private boolean started = false;
+    private float progress;
+
+    public SendingFileExDrawable() {
+        super();
+        paint.setColor(0xffd7e8f7);
+        paint.setStyle(Paint.Style.STROKE);
+        paint.setStrokeWidth(AndroidUtilities.dp(2));
+        paint.setStrokeCap(Paint.Cap.ROUND);
+    }
+
+    public void setIsChat(boolean value) {
+        isChat = value;
+    }
+
+    private void update() {
+        long newTime = System.currentTimeMillis();
+        long dt = newTime - lastUpdateTime;
+        lastUpdateTime = newTime;
+        if (dt > 50) {
+            dt = 50;
+        }
+        progress += dt / 500.0f;
+        while (progress > 1.0f) {
+            progress -= 1.0f;
+        }
+        invalidateSelf();
+    }
+
+    public void start() {
+        lastUpdateTime = System.currentTimeMillis();
+        started = true;
+        invalidateSelf();
+    }
+
+    public void stop() {
+        started = false;
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+
+        for (int a = 0; a < 3; a++) {
+            if (a == 0) {
+                paint.setAlpha((int) (255 * progress));
+            } else if (a == 2) {
+                paint.setAlpha((int) (255 * (1.0f - progress)));
+            } else {
+                paint.setAlpha(255);
+            }
+            float side = AndroidUtilities.dp(5) * a + AndroidUtilities.dp(5) * progress;
+            canvas.drawLine(side, AndroidUtilities.dp(isChat ? 3 : 4), side + AndroidUtilities.dp(4), AndroidUtilities.dp(isChat ? 7 : 8), paint);
+            canvas.drawLine(side, AndroidUtilities.dp(isChat ? 11 : 12), side + AndroidUtilities.dp(4), AndroidUtilities.dp(isChat ? 7 : 8), paint);
+        }
+
+        if (started) {
+            update();
+        }
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+
+    }
+
+    @Override
+    public int getOpacity() {
+        return 0;
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return AndroidUtilities.dp(18);
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return AndroidUtilities.dp(14);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SimpleTextView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SimpleTextView.java
new file mode 100644
index 000000000..2bbe59040
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SimpleTextView.java
@@ -0,0 +1,126 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Typeface;
+import android.text.Layout;
+import android.text.SpannableStringBuilder;
+import android.text.StaticLayout;
+import android.text.TextPaint;
+import android.text.TextUtils;
+import android.view.Gravity;
+import android.view.View;
+
+import org.telegram.android.AndroidUtilities;
+
+public class SimpleTextView extends View {
+
+    private Layout layout;
+    private TextPaint textPaint;
+    private int gravity;
+    private CharSequence text;
+    private SpannableStringBuilder spannableStringBuilder;
+
+    private int offsetX;
+    private boolean wasLayout = false;
+
+    public SimpleTextView(Context context) {
+        super(context);
+        textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
+    }
+
+    public void setTextColor(int color) {
+        textPaint.setColor(color);
+    }
+
+    public void setTextSize(int size) {
+        textPaint.setTextSize(AndroidUtilities.dp(size));
+    }
+
+    public void setGravity(int value) {
+        gravity = value;
+    }
+
+    public void setTypeface(Typeface typeface) {
+        textPaint.setTypeface(typeface);
+    }
+
+    private void createLayout(int width) {
+        if (text != null) {
+            try {
+                CharSequence string = TextUtils.ellipsize(text, textPaint, width, TextUtils.TruncateAt.END);
+                layout = new StaticLayout(string, 0, string.length(), textPaint, width, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
+
+                /*if (metrics == null) {
+                    metrics = BoringLayout.isBoring(text, textPaint);
+                }
+                if (layout == null) {
+                    layout = BoringLayout.make(text, textPaint, width, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, metrics, false, TextUtils.TruncateAt.END, width);
+                } else {
+                    layout = ((BoringLayout) layout).replaceOrMake(text, textPaint, width, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, metrics, false, TextUtils.TruncateAt.END, width);
+                }*/
+
+                /*if (spannableStringBuilder == null) {
+                    spannableStringBuilder = new SpannableStringBuilder(text);
+                    layout = new DynamicLayout(text, text, textPaint, width, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false, TextUtils.TruncateAt.END, width);
+                } else {
+                    spannableStringBuilder.replace(0, text.length(), text);
+                }*/
+
+                if (layout.getLineCount() > 0) {
+                    if ((gravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.LEFT) {
+                        offsetX = -(int) layout.getLineLeft(0);
+                    } else if (layout.getLineLeft(0) == 0) {
+                        offsetX = (int) (width - layout.getLineWidth(0));
+                    } else {
+                        offsetX = 0;
+                    }
+                }
+            } catch (Exception e) {
+                //ignore
+            }
+        }
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        if (changed) {
+            createLayout(right - left);
+            invalidate();
+            wasLayout = true;
+        }
+    }
+
+    public void setText(CharSequence value) {
+        text = value;
+        if (wasLayout) {
+            createLayout(getMeasuredWidth());
+            invalidate();
+        } else {
+            requestLayout();
+        }
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (layout != null) {
+            if (offsetX != 0) {
+                canvas.save();
+                canvas.translate(offsetX, 0);
+            }
+            layout.draw(canvas);
+            if (offsetX != 0) {
+                canvas.restore();
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/Size.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/Size.java
new file mode 100644
index 000000000..986c40703
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/Size.java
@@ -0,0 +1,23 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+public class Size {
+    public float width;
+    public float height;
+
+    public Size() {
+
+    }
+
+    public Size(float width, float height) {
+        this.width = width;
+        this.height = height;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierRelativeLayoutPhoto.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierRelativeLayoutPhoto.java
new file mode 100644
index 000000000..ef2d6055e
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierRelativeLayoutPhoto.java
@@ -0,0 +1,58 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.graphics.Rect;
+import android.view.View;
+import android.widget.RelativeLayout;
+
+import org.telegram.android.AndroidUtilities;
+
+public class SizeNotifierRelativeLayoutPhoto extends RelativeLayout {
+
+    public interface SizeNotifierRelativeLayoutPhotoDelegate {
+        void onSizeChanged(int keyboardHeight, boolean isWidthGreater);
+    }
+
+    private Rect rect = new Rect();
+    private int keyboardHeight;
+    private SizeNotifierRelativeLayoutPhotoDelegate delegate;
+
+    public SizeNotifierRelativeLayoutPhoto(Context context) {
+        super(context);
+    }
+
+    public void setDelegate(SizeNotifierRelativeLayoutPhotoDelegate delegate) {
+        this.delegate = delegate;
+    }
+
+    @SuppressLint("DrawAllocation")
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        super.onLayout(changed, l, t, r, b);
+
+        if (delegate != null) {
+            View rootView = this.getRootView();
+            int usableViewHeight = rootView.getHeight() - AndroidUtilities.getViewInset(rootView);
+            this.getWindowVisibleDisplayFrame(rect);
+            keyboardHeight = (rect.bottom - rect.top) - usableViewHeight;
+            final boolean isWidthGreater = AndroidUtilities.displaySize.x > AndroidUtilities.displaySize.y;
+            post(new Runnable() {
+                @Override
+                public void run() {
+                    if (delegate != null) {
+                        delegate.onSizeChanged(keyboardHeight, isWidthGreater);
+                    }
+                }
+            });
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java
new file mode 100644
index 000000000..d904f7c00
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java
@@ -0,0 +1,123 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.os.Build;
+import android.text.Layout;
+import android.text.SpannableStringBuilder;
+import android.text.StaticLayout;
+import android.text.TextDirectionHeuristic;
+import android.text.TextDirectionHeuristics;
+import android.text.TextPaint;
+import android.text.TextUtils;
+
+import org.telegram.messenger.FileLog;
+
+import java.lang.reflect.Constructor;
+
+public class StaticLayoutEx {
+
+    private static final String TEXT_DIR_CLASS = "android.text.TextDirectionHeuristic";
+    private static final String TEXT_DIRS_CLASS = "android.text.TextDirectionHeuristics";
+    private static final String TEXT_DIR_FIRSTSTRONG_LTR = "FIRSTSTRONG_LTR";
+    private static boolean initialized;
+
+    private static Constructor<StaticLayout> sConstructor;
+    private static Object[] sConstructorArgs;
+    private static Object sTextDirection;
+
+    public static void init() {
+        if (initialized) {
+            return;
+        }
+
+        try {
+            final Class<?> textDirClass;
+            if (Build.VERSION.SDK_INT >= 18) {
+                textDirClass = TextDirectionHeuristic.class;
+                sTextDirection = TextDirectionHeuristics.FIRSTSTRONG_LTR;
+            } else {
+                ClassLoader loader = StaticLayoutEx.class.getClassLoader();
+                textDirClass = loader.loadClass(TEXT_DIR_CLASS);
+                Class<?> textDirsClass = loader.loadClass(TEXT_DIRS_CLASS);
+                sTextDirection = textDirsClass.getField(TEXT_DIR_FIRSTSTRONG_LTR).get(textDirsClass);
+            }
+
+            final Class<?>[] signature = new Class[]{
+                    CharSequence.class,
+                    int.class,
+                    int.class,
+                    TextPaint.class,
+                    int.class,
+                    Layout.Alignment.class,
+                    textDirClass,
+                    float.class,
+                    float.class,
+                    boolean.class,
+                    TextUtils.TruncateAt.class,
+                    int.class,
+                    int.class
+            };
+
+            sConstructor = StaticLayout.class.getDeclaredConstructor(signature);
+            sConstructor.setAccessible(true);
+            sConstructorArgs = new Object[signature.length];
+            initialized = true;
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    public static StaticLayout createStaticLayout(CharSequence source, TextPaint paint, int width, Layout.Alignment align, float spacingmult, float spacingadd, boolean includepad, TextUtils.TruncateAt ellipsize, int ellipsisWidth, int maxLines) {
+        return createStaticLayout(source, 0, source.length(), paint, width, align, spacingmult, spacingadd, includepad, ellipsize, ellipsisWidth, maxLines);
+    }
+
+    public static StaticLayout createStaticLayout(CharSequence source, int bufstart, int bufend, TextPaint paint, int outerWidth, Layout.Alignment align, float spacingMult, float spacingAdd, boolean includePad, TextUtils.TruncateAt ellipsize, int ellipsisWidth, int maxLines) {
+        /*if (Build.VERSION.SDK_INT >= 14) {
+            init();
+            try {
+                sConstructorArgs[0] = source;
+                sConstructorArgs[1] = bufstart;
+                sConstructorArgs[2] = bufend;
+                sConstructorArgs[3] = paint;
+                sConstructorArgs[4] = outerWidth;
+                sConstructorArgs[5] = align;
+                sConstructorArgs[6] = sTextDirection;
+                sConstructorArgs[7] = spacingMult;
+                sConstructorArgs[8] = spacingAdd;
+                sConstructorArgs[9] = includePad;
+                sConstructorArgs[10] = ellipsize;
+                sConstructorArgs[11] = ellipsisWidth;
+                sConstructorArgs[12] = maxLines;
+                return sConstructor.newInstance(sConstructorArgs);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+        }*/
+        try {
+            if (maxLines == 1) {
+                CharSequence text = TextUtils.ellipsize(source, paint, ellipsisWidth, TextUtils.TruncateAt.END);
+                return new StaticLayout(text, 0, text.length(), paint, outerWidth, align, spacingMult, spacingAdd, includePad);
+            } else {
+                StaticLayout layout = new StaticLayout(source, paint, outerWidth, align, spacingMult, spacingAdd, includePad);
+                if (layout.getLineCount() <= maxLines) {
+                    return layout;
+                } else {
+                    int off = layout.getOffsetForHorizontal(maxLines - 1, layout.getLineWidth(maxLines - 1));
+                    SpannableStringBuilder stringBuilder = new SpannableStringBuilder(source.subSequence(0, Math.max(0, off - 1)));
+                    stringBuilder.append("\u2026");
+                    return new StaticLayout(stringBuilder, paint, outerWidth, align, spacingMult, spacingAdd, includePad);
+                }
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return null;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java
new file mode 100644
index 000000000..7af61e6a9
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java
@@ -0,0 +1,339 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.os.Build;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import android.widget.ListView;
+import android.widget.ProgressBar;
+import android.widget.Toast;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.android.MessagesController;
+import org.telegram.android.NotificationCenter;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.ConnectionsManager;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.R;
+import org.telegram.messenger.RPCRequest;
+import org.telegram.messenger.TLObject;
+import org.telegram.messenger.TLRPC;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.TextBlockCell;
+import org.telegram.ui.Cells.TextInfoPrivacyCell;
+import org.telegram.ui.Cells.TextSettingsCell;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class GroupInviteActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
+
+    private ListAdapter listAdapter;
+
+    private int chat_id;
+    private boolean loading;
+    private TLRPC.ExportedChatInvite invite;
+
+    private int linkRow;
+    private int linkInfoRow;
+    private int copyLinkRow;
+    private int revokeLinkRow;
+    private int shareLinkRow;
+    private int shadowRow;
+    private int rowCount;
+
+    public GroupInviteActivity(int cid) {
+        super();
+        chat_id = cid;
+    }
+
+    @Override
+    public boolean onFragmentCreate() {
+        super.onFragmentCreate();
+
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.chatInfoDidLoaded);
+        MessagesController.getInstance().loadFullChat(chat_id, classGuid, true);
+        loading = true;
+
+        rowCount = 0;
+        linkRow = rowCount++;
+        linkInfoRow = rowCount++;
+        copyLinkRow = rowCount++;
+        revokeLinkRow = rowCount++;
+        shareLinkRow = rowCount++;
+        shadowRow = rowCount++;
+
+        return true;
+    }
+
+    @Override
+    public void onFragmentDestroy() {
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.chatInfoDidLoaded);
+    }
+
+    @Override
+    public View createView(Context context, LayoutInflater inflater) {
+        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setAllowOverlayTitle(true);
+        actionBar.setTitle(LocaleController.getString("InviteLink", R.string.InviteLink));
+        actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+            @Override
+            public void onItemClick(int id) {
+                if (id == -1) {
+                    finishFragment();
+                }
+            }
+        });
+
+        listAdapter = new ListAdapter(context);
+
+        fragmentView = new FrameLayout(context);
+        FrameLayout frameLayout = (FrameLayout) fragmentView;
+        frameLayout.setBackgroundColor(0xfff0f0f0);
+
+        FrameLayout progressView = new FrameLayout(context);
+        frameLayout.addView(progressView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+
+        ProgressBar progressBar = new ProgressBar(context);
+        progressView.addView(progressBar, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
+
+        ListView listView = new ListView(context);
+        listView.setDivider(null);
+        listView.setDividerHeight(0);
+        listView.setEmptyView(progressView);
+        listView.setVerticalScrollBarEnabled(false);
+        listView.setDrawSelectorOnTop(true);
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT));
+        listView.setAdapter(listAdapter);
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+                if (getParentActivity() == null) {
+                    return;
+                }
+                if (i == copyLinkRow || i == linkRow) {
+                    if (invite == null) {
+                        return;
+                    }
+                    try {
+                        if (Build.VERSION.SDK_INT < 11) {
+                            android.text.ClipboardManager clipboard = (android.text.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                            clipboard.setText(invite.link);
+                        } else {
+                            android.content.ClipboardManager clipboard = (android.content.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                            android.content.ClipData clip = android.content.ClipData.newPlainText("label", invite.link);
+                            clipboard.setPrimaryClip(clip);
+                        }
+                        Toast.makeText(getParentActivity(), LocaleController.getString("LinkCopied", R.string.LinkCopied), Toast.LENGTH_SHORT).show();
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                } else if (i == shareLinkRow) {
+                    if (invite == null) {
+                        return;
+                    }
+                    try {
+                        Intent intent = new Intent(Intent.ACTION_SEND);
+                        intent.setType("text/plain");
+                        intent.putExtra(Intent.EXTRA_TEXT, invite.link);
+                        getParentActivity().startActivityForResult(Intent.createChooser(intent, LocaleController.getString("InviteToGroupByLink", R.string.InviteToGroupByLink)), 500);
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                } else if (i == revokeLinkRow) {
+                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                    builder.setMessage(LocaleController.getString("RevokeAlert", R.string.RevokeAlert));
+                    builder.setTitle(LocaleController.getString("RevokeLink", R.string.RevokeLink));
+                    builder.setPositiveButton(LocaleController.getString("RevokeButton", R.string.RevokeButton), new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            generateLink(true);
+                        }
+                    });
+                    builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                    showAlertDialog(builder);
+                }
+            }
+        });
+
+        return fragmentView;
+    }
+
+    @Override
+    public void didReceivedNotification(int id, Object... args) {
+        if (id == NotificationCenter.chatInfoDidLoaded) {
+            if (args.length != 3) {
+                return;
+            }
+            int cid = (int) args[0];
+            int guid = (int) args[2];
+            if (cid == chat_id && guid == classGuid) {
+                invite = MessagesController.getInstance().getExportedInvite(chat_id);
+                if (!(invite instanceof TLRPC.TL_chatInviteExported)) {
+                    generateLink(false);
+                } else {
+                    loading = false;
+                    if (listAdapter != null) {
+                        listAdapter.notifyDataSetChanged();
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+    }
+
+    private void generateLink(final boolean request) {
+        loading = true;
+        TLRPC.TL_messages_exportChatInvite req = new TLRPC.TL_messages_exportChatInvite();
+        req.chat_id = chat_id;
+        final long reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (error == null) {
+                            invite = (TLRPC.ExportedChatInvite) response;
+                            if (request) {
+                                if (getParentActivity() == null) {
+                                    return;
+                                }
+                                AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                                builder.setMessage(LocaleController.getString("RevokeAlertNewLink", R.string.RevokeAlertNewLink));
+                                builder.setTitle(LocaleController.getString("RevokeLink", R.string.RevokeLink));
+                                builder.setNegativeButton(LocaleController.getString("OK", R.string.OK), null);
+                                showAlertDialog(builder);
+                            }
+                        }
+                        loading = false;
+                        listAdapter.notifyDataSetChanged();
+                    }
+                });
+            }
+        });
+        ConnectionsManager.getInstance().bindRequestToGuid(reqId, classGuid);
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+    }
+
+    private class ListAdapter extends BaseFragmentAdapter {
+        private Context mContext;
+
+        public ListAdapter(Context context) {
+            mContext = context;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            return i == revokeLinkRow || i == copyLinkRow || i == shareLinkRow || i == linkRow;
+        }
+
+        @Override
+        public int getCount() {
+            return loading ? 0 : rowCount;
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return false;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            int type = getItemViewType(i);
+            if (type == 0) {
+                if (view == null) {
+                    view = new TextSettingsCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                TextSettingsCell textCell = (TextSettingsCell) view;
+                if (i == copyLinkRow) {
+                    textCell.setText(LocaleController.getString("CopyLink", R.string.CopyLink), true);
+                } else if (i == shareLinkRow) {
+                    textCell.setText(LocaleController.getString("ShareLink", R.string.ShareLink), false);
+                } else if (i == revokeLinkRow) {
+                    textCell.setText(LocaleController.getString("RevokeLink", R.string.RevokeLink), true);
+                }
+            } else if (type == 1) {
+                if (view == null) {
+                    view = new TextInfoPrivacyCell(mContext);
+                }
+                if (i == shadowRow) {
+                    ((TextInfoPrivacyCell) view).setText("");
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                } else if (i == linkInfoRow) {
+                    ((TextInfoPrivacyCell) view).setText(LocaleController.getString("LinkInfo", R.string.LinkInfo));
+                    view.setBackgroundResource(R.drawable.greydivider);
+                }
+            } else if (type == 2) {
+                if (view == null) {
+                    view = new TextBlockCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                ((TextBlockCell) view).setText(invite != null ? invite.link : "error", false);
+            }
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            if (i == copyLinkRow || i == shareLinkRow || i == revokeLinkRow) {
+                return 0;
+            } else if (i == shadowRow || i == linkInfoRow) {
+                return 1;
+            } else if (i == linkRow) {
+                return 2;
+            }
+            return 0;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 3;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return loading;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ImageListActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ImageListActivity.java
new file mode 100644
index 000000000..26a26d4cb
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ImageListActivity.java
@@ -0,0 +1,131 @@
+package org.telegram.ui;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.graphics.PorterDuff;
+import android.graphics.drawable.Drawable;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.ArrayAdapter;
+import android.widget.ImageView;
+import android.widget.ListView;
+import android.widget.TextView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.BaseFragment;
+
+public class ImageListActivity extends BaseFragment {
+
+    private ListView list;
+    private CustomListAdapter listAdapter;
+
+    private static String[] bubblesNamesArray ={
+            "Telegram",
+            "Lex",
+            "Hangouts",
+            "Notepad"
+    };
+
+    Integer[] imgid ={
+            R.drawable.msg_in,
+            R.drawable.msg_in_2,
+            R.drawable.msg_in_3,
+            R.drawable.msg_in_4,
+            R.drawable.msg_out,
+            R.drawable.msg_out_2,
+            R.drawable.msg_out_3,
+            R.drawable.msg_out_4
+    };
+
+    public static String getBubbleName(int i){
+        return bubblesNamesArray[i];
+    }
+
+    @Override
+    public View createView(Context context, LayoutInflater inflater){
+        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setAllowOverlayTitle(true);
+        actionBar.setTitle(LocaleController.getString("BubbleStyle", R.string.BubbleStyle));
+        actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+            @Override
+            public void onItemClick(int id) {
+                if (id == -1) {
+                    finishFragment();
+                }
+            }
+        });
+
+        fragmentView = inflater.inflate(R.layout.imagelistlayout, null, false);
+
+        listAdapter = new CustomListAdapter(context, bubblesNamesArray, imgid);
+        list=(ListView) fragmentView.findViewById(R.id.list);
+        list.setAdapter(listAdapter);
+        list.setDivider(null);
+
+        list.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view,
+                                    int position, long id) {
+                String Slecteditem = bubblesNamesArray[+position];
+                SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+                SharedPreferences.Editor editor = preferences.edit();
+                editor.putString("chatBubbleStyle", Slecteditem);
+                editor.commit();
+                listAdapter.notifyDataSetChanged();
+                finishFragment();
+            }
+        });
+
+        return fragmentView;
+    }
+
+    private class CustomListAdapter extends ArrayAdapter<String> {
+
+        private final Context mContext;
+        private final String[] itemname;
+        private final Integer[] imgid;
+
+        public CustomListAdapter(Context context, String[] itemname, Integer[] imgid) {
+            super(context, R.layout.imagelist, itemname);
+
+            this.mContext = context;
+            this.itemname = itemname;
+            this.imgid = imgid;
+        }
+
+        public View getView(int position, View view, ViewGroup parent) {
+            LayoutInflater inflater = (LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+            SharedPreferences themePrefs = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+            String name = themePrefs.getString("chatBubbleStyle", itemname[0]);
+            view = inflater.inflate(R.layout.imagelist, parent, false);
+            if(name.equals(itemname[position]) ){
+                view.setBackgroundColor(0xffe6e6e6);
+            }
+
+            TextView txtTitle = (TextView) view.findViewById(R.id.bubble_title);
+            ImageView inImageView = (ImageView) view.findViewById(R.id.bubble_in);
+            ImageView outImageView = (ImageView) view.findViewById(R.id.bubble_out);
+
+            txtTitle.setText(itemname[position]);
+            //Drawable in = mContext.getResources().getDrawable(imgid[position]);
+            //in.setColorFilter(themePrefs.getInt("chatLBubbleColor", 0xffffffff), PorterDuff.Mode.SRC_IN);
+            //inImageView.setImageDrawable(in);
+            inImageView.setImageResource(imgid[position]);
+
+            //Drawable out = mContext.getResources().getDrawable(imgid[position + itemname.length]);
+            //out.setColorFilter(themePrefs.getInt("chatRBubbleColor", themePrefs.getInt("themeColor", AndroidUtilities.defColor)), PorterDuff.Mode.SRC_IN);
+            //outImageView.setImageDrawable(out);
+            outImageView.setImageResource(imgid[position + itemname.length]);
+
+            return view;
+
+        };
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java
new file mode 100644
index 000000000..c27a0a4c4
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java
@@ -0,0 +1,476 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui;
+
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.os.Build;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsListView;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ListView;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.android.MessagesController;
+import org.telegram.android.NotificationCenter;
+import org.telegram.messenger.ConnectionsManager;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.R;
+import org.telegram.messenger.RPCRequest;
+import org.telegram.messenger.TLObject;
+import org.telegram.messenger.TLRPC;
+import org.telegram.messenger.UserConfig;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.HeaderCell;
+import org.telegram.ui.Cells.SessionCell;
+import org.telegram.ui.Cells.TextInfoPrivacyCell;
+import org.telegram.ui.Cells.TextSettingsCell;
+import org.telegram.ui.Components.LayoutHelper;
+
+import java.util.ArrayList;
+
+public class SessionsActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
+
+    private ListAdapter listAdapter;
+    private ArrayList<TLRPC.TL_authorization> sessions = new ArrayList<>();
+    private TLRPC.TL_authorization currentSession = null;
+    private boolean loading;
+    private LinearLayout emptyLayout;
+
+    private int currentSessionSectionRow;
+    private int currentSessionRow;
+    private int terminateAllSessionsRow;
+    private int terminateAllSessionsDetailRow;
+    private int otherSessionsSectionRow;
+    private int otherSessionsStartRow;
+    private int otherSessionsEndRow;
+    private int otherSessionsTerminateDetail;
+    private int noOtherSessionsRow;
+    private int rowCount;
+
+    @Override
+    public boolean onFragmentCreate() {
+        super.onFragmentCreate();
+        updateRows();
+        loadSessions(false);
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.newSessionReceived);
+        return true;
+    }
+
+    @Override
+    public void onFragmentDestroy() {
+        super.onFragmentDestroy();
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.newSessionReceived);
+    }
+
+    @Override
+    public View createView(Context context, LayoutInflater inflater) {
+        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setAllowOverlayTitle(true);
+        actionBar.setTitle(LocaleController.getString("SessionsTitle", R.string.SessionsTitle));
+        actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+            @Override
+            public void onItemClick(int id) {
+                if (id == -1) {
+                    finishFragment();
+                }
+            }
+        });
+
+        listAdapter = new ListAdapter(context);
+
+        fragmentView = new FrameLayout(context);
+        FrameLayout frameLayout = (FrameLayout) fragmentView;
+        frameLayout.setBackgroundColor(0xfff0f0f0);
+
+        emptyLayout = new LinearLayout(context);
+        emptyLayout.setOrientation(LinearLayout.VERTICAL);
+        emptyLayout.setGravity(Gravity.CENTER);
+        emptyLayout.setBackgroundResource(R.drawable.greydivider_bottom);
+        emptyLayout.setLayoutParams(new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT, AndroidUtilities.displaySize.y - AndroidUtilities.getCurrentActionBarHeight()));
+
+        ImageView imageView = new ImageView(context);
+        imageView.setImageResource(R.drawable.devices);
+        emptyLayout.addView(imageView);
+        LinearLayout.LayoutParams layoutParams2 = (LinearLayout.LayoutParams) imageView.getLayoutParams();
+        layoutParams2.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams2.height = LayoutHelper.WRAP_CONTENT;
+        imageView.setLayoutParams(layoutParams2);
+
+        TextView textView = new TextView(context);
+        textView.setTextColor(0xff8a8a8a);
+        textView.setGravity(Gravity.CENTER);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 17);
+        textView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        textView.setText(LocaleController.getString("NoOtherSessions", R.string.NoOtherSessions));
+        emptyLayout.addView(textView);
+        layoutParams2 = (LinearLayout.LayoutParams) textView.getLayoutParams();
+        layoutParams2.topMargin = AndroidUtilities.dp(16);
+        layoutParams2.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams2.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams2.gravity = Gravity.CENTER;
+        textView.setLayoutParams(layoutParams2);
+
+        textView = new TextView(context);
+        textView.setTextColor(0xff8a8a8a);
+        textView.setGravity(Gravity.CENTER);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 17);
+        textView.setPadding(AndroidUtilities.dp(20), 0, AndroidUtilities.dp(20), 0);
+        textView.setText(LocaleController.getString("NoOtherSessionsInfo", R.string.NoOtherSessionsInfo));
+        emptyLayout.addView(textView);
+        layoutParams2 = (LinearLayout.LayoutParams) textView.getLayoutParams();
+        layoutParams2.topMargin = AndroidUtilities.dp(14);
+        layoutParams2.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams2.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams2.gravity = Gravity.CENTER;
+        textView.setLayoutParams(layoutParams2);
+
+        FrameLayout progressView = new FrameLayout(context);
+        frameLayout.addView(progressView);
+        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) progressView.getLayoutParams();
+        layoutParams.width = LayoutHelper.MATCH_PARENT;
+        layoutParams.height = LayoutHelper.MATCH_PARENT;
+        progressView.setLayoutParams(layoutParams);
+        progressView.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+
+        ProgressBar progressBar = new ProgressBar(context);
+        progressView.addView(progressBar);
+        layoutParams = (FrameLayout.LayoutParams) progressView.getLayoutParams();
+        layoutParams.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams.gravity = Gravity.CENTER;
+        progressView.setLayoutParams(layoutParams);
+
+        ListView listView = new ListView(context);
+        listView.setDivider(null);
+        listView.setDividerHeight(0);
+        listView.setVerticalScrollBarEnabled(false);
+        listView.setDrawSelectorOnTop(true);
+        listView.setEmptyView(progressView);
+        frameLayout.addView(listView);
+        layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
+        layoutParams.width = LayoutHelper.MATCH_PARENT;
+        layoutParams.height = LayoutHelper.MATCH_PARENT;
+        layoutParams.gravity = Gravity.TOP;
+        listView.setLayoutParams(layoutParams);
+        listView.setAdapter(listAdapter);
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+                if (i == terminateAllSessionsRow) {
+                    if (getParentActivity() == null) {
+                        return;
+                    }
+                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                    builder.setMessage(LocaleController.getString("AreYouSureSessions", R.string.AreYouSureSessions));
+                    builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                    builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            TLRPC.TL_auth_resetAuthorizations req = new TLRPC.TL_auth_resetAuthorizations();
+                            ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                                @Override
+                                public void run(final TLObject response, final TLRPC.TL_error error) {
+                                    AndroidUtilities.runOnUIThread(new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            if (getParentActivity() == null) {
+                                                return;
+                                            }
+                                            if (error == null && response instanceof TLRPC.TL_boolTrue) {
+                                                Toast toast = Toast.makeText(getParentActivity(), LocaleController.getString("TerminateAllSessions", R.string.TerminateAllSessions), Toast.LENGTH_SHORT);
+                                                toast.show();
+                                            } else {
+                                                Toast toast = Toast.makeText(getParentActivity(), LocaleController.getString("UnknownError", R.string.UnknownError), Toast.LENGTH_SHORT);
+                                                toast.show();
+                                            }
+                                            finishFragment();
+                                        }
+                                    });
+                                    UserConfig.registeredForPush = false;
+                                    UserConfig.registeredForInternalPush = false;
+                                    UserConfig.saveConfig(false);
+                                    MessagesController.getInstance().registerForPush(UserConfig.pushString);
+                                    ConnectionsManager.getInstance().initPushConnection();
+                                }
+                            });
+                        }
+                    });
+                    builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                    showAlertDialog(builder);
+                } else if (i >= otherSessionsStartRow && i < otherSessionsEndRow) {
+                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                    builder.setMessage(LocaleController.getString("TerminateSessionQuestion", R.string.TerminateSessionQuestion));
+                    builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                    builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int option) {
+                            final ProgressDialog progressDialog = new ProgressDialog(getParentActivity());
+                            progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
+                            progressDialog.setCanceledOnTouchOutside(false);
+                            progressDialog.setCancelable(false);
+                            progressDialog.show();
+
+                            final TLRPC.TL_authorization authorization = sessions.get(i - otherSessionsStartRow);
+                            TLRPC.TL_account_resetAuthorization req = new TLRPC.TL_account_resetAuthorization();
+                            req.hash = authorization.hash;
+                            ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                                @Override
+                                public void run(final TLObject response, final TLRPC.TL_error error) {
+                                    AndroidUtilities.runOnUIThread(new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            try {
+                                                progressDialog.dismiss();
+                                            } catch (Exception e) {
+                                                FileLog.e("tmessages", e);
+                                            }
+                                            if (error == null) {
+                                                sessions.remove(authorization);
+                                                updateRows();
+                                                if (listAdapter != null) {
+                                                    listAdapter.notifyDataSetChanged();
+                                                }
+                                            }
+                                        }
+                                    });
+                                }
+                            });
+                        }
+                    });
+                    builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                    showAlertDialog(builder);
+                }
+            }
+        });
+
+        return fragmentView;
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+    }
+
+    @Override
+    public void didReceivedNotification(int id, Object... args) {
+        if (id == NotificationCenter.newSessionReceived) {
+            loadSessions(true);
+        }
+    }
+
+    private void loadSessions(boolean silent) {
+        if (loading) {
+            return;
+        }
+        if (!silent) {
+            loading = true;
+        }
+        TLRPC.TL_account_getAuthorizations req = new TLRPC.TL_account_getAuthorizations();
+        long reqId = ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        loading = false;
+                        if (error == null) {
+                            sessions.clear();
+                            TLRPC.TL_account_authorizations res = (TLRPC.TL_account_authorizations) response;
+                            for (TLRPC.TL_authorization authorization : res.authorizations) {
+                                if ((authorization.flags & 1) != 0) {
+                                    currentSession = authorization;
+                                } else {
+                                    sessions.add(authorization);
+                                }
+                            }
+                            updateRows();
+                        }
+                        if (listAdapter != null) {
+                            listAdapter.notifyDataSetChanged();
+                        }
+                    }
+                });
+            }
+        });
+        ConnectionsManager.getInstance().bindRequestToGuid(reqId, classGuid);
+    }
+
+    private void updateRows() {
+        rowCount = 0;
+        if (currentSession != null) {
+            currentSessionSectionRow = rowCount++;
+            currentSessionRow = rowCount++;
+        } else {
+            currentSessionRow = -1;
+            currentSessionSectionRow = -1;
+        }
+        if (sessions.isEmpty()) {
+            noOtherSessionsRow = -1;
+            terminateAllSessionsRow = -1;
+            terminateAllSessionsDetailRow = -1;
+            otherSessionsSectionRow = -1;
+            otherSessionsStartRow = -1;
+            otherSessionsEndRow = -1;
+            otherSessionsTerminateDetail = -1;
+        } else {
+            noOtherSessionsRow = -1;
+            terminateAllSessionsRow = rowCount++;
+            terminateAllSessionsDetailRow = rowCount++;
+            otherSessionsSectionRow = rowCount++;
+            otherSessionsStartRow = otherSessionsSectionRow + 1;
+            otherSessionsEndRow = otherSessionsStartRow + sessions.size();
+            rowCount += sessions.size();
+            otherSessionsTerminateDetail = rowCount++;
+        }
+    }
+
+    private class ListAdapter extends BaseFragmentAdapter {
+        private Context mContext;
+
+        public ListAdapter(Context context) {
+            mContext = context;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            return i == terminateAllSessionsRow || i >= otherSessionsStartRow && i < otherSessionsEndRow;
+        }
+
+        @Override
+        public int getCount() {
+            return loading ? 0 : rowCount;
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return false;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            int type = getItemViewType(i);
+            if (type == 0) {
+                if (view == null) {
+                    view = new TextSettingsCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                TextSettingsCell textCell = (TextSettingsCell) view;
+                if (i == terminateAllSessionsRow) {
+                    textCell.setTextColor(0xffdb5151);
+                    textCell.setText(LocaleController.getString("TerminateAllSessions", R.string.TerminateAllSessions), false);
+                }
+            } else if (type == 1) {
+                if (view == null) {
+                    view = new TextInfoPrivacyCell(mContext);
+                }
+                if (i == terminateAllSessionsDetailRow) {
+                    ((TextInfoPrivacyCell) view).setText(LocaleController.getString("ClearOtherSessionsHelp", R.string.ClearOtherSessionsHelp));
+                    view.setBackgroundResource(R.drawable.greydivider);
+                } else if (i == otherSessionsTerminateDetail) {
+                    ((TextInfoPrivacyCell) view).setText(LocaleController.getString("TerminateSessionInfo", R.string.TerminateSessionInfo));
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                }
+            } else if (type == 2) {
+                if (view == null) {
+                    view = new HeaderCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                if (i == currentSessionSectionRow) {
+                    ((HeaderCell) view).setText(LocaleController.getString("CurrentSession", R.string.CurrentSession));
+                } else if (i == otherSessionsSectionRow) {
+                    ((HeaderCell) view).setText(LocaleController.getString("OtherSessions", R.string.OtherSessions));
+                }
+            } else if (type == 3) {
+                ViewGroup.LayoutParams layoutParams = emptyLayout.getLayoutParams();
+                if (layoutParams != null) {
+                    layoutParams.height = Math.max(AndroidUtilities.dp(220), AndroidUtilities.displaySize.y - AndroidUtilities.getCurrentActionBarHeight() - AndroidUtilities.dp(128) - (Build.VERSION.SDK_INT >= 21 ? AndroidUtilities.statusBarHeight : 0));
+                    emptyLayout.setLayoutParams(layoutParams);
+                }
+                return emptyLayout;
+            } else if (type == 4) {
+                if (view == null) {
+                    view = new SessionCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                if (i == currentSessionRow) {
+                    ((SessionCell) view).setSession(currentSession, !sessions.isEmpty());
+                } else {
+                    ((SessionCell) view).setSession(sessions.get(i - otherSessionsStartRow), i != otherSessionsEndRow - 1);
+                }
+            }
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            if (i == terminateAllSessionsRow) {
+                return 0;
+            } else if (i == terminateAllSessionsDetailRow || i == otherSessionsTerminateDetail) {
+                return 1;
+            } else if (i == currentSessionSectionRow || i == otherSessionsSectionRow) {
+                return 2;
+            } else if (i == noOtherSessionsRow) {
+                return 3;
+            } else if (i == currentSessionRow || i >= otherSessionsStartRow && i < otherSessionsEndRow) {
+                return 4;
+            }
+            return 0;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 5;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return loading;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ThemingDrawerActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ThemingDrawerActivity.java
new file mode 100644
index 000000000..9ce4115d9
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ThemingDrawerActivity.java
@@ -0,0 +1,647 @@
+/*
+ * This is the source code of Telegram for Android v. 1.3.2.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013.
+ */
+
+package org.telegram.ui;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.SharedPreferences;
+import android.content.res.Configuration;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import android.widget.ListView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.HeaderCell;
+import org.telegram.ui.Cells.ShadowSectionCell;
+import org.telegram.ui.Cells.TextCheckCell;
+import org.telegram.ui.Cells.TextColorCell;
+import org.telegram.ui.Cells.TextSettingsCell;
+import org.telegram.ui.Components.AvatarDrawable;
+import org.telegram.ui.Components.ColorSelectorDialog;
+import org.telegram.ui.Components.NumberPicker;
+
+import static org.telegram.ui.Components.ColorSelectorDialog.OnColorChangedListener;
+
+public class ThemingDrawerActivity extends BaseFragment {
+
+    private ListView listView;
+    private ListAdapter listAdapter;
+
+    private int headerSection2Row;
+    private int headerColorRow;
+    private int headerBackgroundCheckRow;
+    private int rowsSectionRow;
+    private int rowsSection2Row;
+    private int listColorRow;
+    private int avatarColorRow;
+    private int avatarRadiusRow;
+    private int nameColorRow;
+    private int nameSizeRow;
+    private int phoneColorRow;
+    private int phoneSizeRow;
+    private int iconColorRow;
+    private int optionColorRow;
+    private int optionSizeRow;
+    private int versionColorRow;
+    private int versionSizeRow;
+
+    private int rowCount;
+
+    public final static int CENTER = 0;
+
+    @Override
+    public boolean onFragmentCreate() {
+        super.onFragmentCreate();
+
+        rowCount = 0;
+        headerSection2Row = rowCount++;
+        headerBackgroundCheckRow = rowCount++;
+        headerColorRow = rowCount++;
+        avatarColorRow  = rowCount++;
+        avatarRadiusRow  = rowCount++;
+        nameColorRow = rowCount++;
+        nameSizeRow = rowCount++;
+        phoneColorRow = rowCount++;
+        phoneSizeRow = rowCount++;
+
+        rowsSectionRow = rowCount++;
+        rowsSection2Row = rowCount++;
+        listColorRow = rowCount++;
+        iconColorRow = rowCount++;
+        optionColorRow = rowCount++;
+        optionSizeRow = rowCount++;
+        versionColorRow  = rowCount++;
+        versionSizeRow  = rowCount++;
+
+        return true;
+    }
+
+    @Override
+    public void onFragmentDestroy() {
+        super.onFragmentDestroy();
+
+    }
+
+    @Override
+    public View createView(Context context, LayoutInflater inflater) {
+        if (fragmentView == null) {
+
+            actionBar.setItemsBackground(AvatarDrawable.getButtonColorForId(5));
+            actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+
+            if (AndroidUtilities.isTablet()) {
+                actionBar.setOccupyStatusBar(false);
+            }
+            actionBar.setTitle(LocaleController.getString("NavigationDrawer", R.string.NavigationDrawer));
+
+            actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+                @Override
+                public void onItemClick(int id) {
+                    if (id == -1) {
+                        finishFragment();
+                    }
+                }
+            });
+
+            listAdapter = new ListAdapter(context);
+
+            fragmentView = new FrameLayout(context);
+            FrameLayout frameLayout = (FrameLayout) fragmentView;
+
+            listView = new ListView(context);
+            listView.setDivider(null);
+            listView.setDividerHeight(0);
+            listView.setVerticalScrollBarEnabled(false);
+            AndroidUtilities.setListViewEdgeEffectColor(listView, AvatarDrawable.getProfileBackColorForId(5));
+            frameLayout.addView(listView);
+            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
+            layoutParams.width = FrameLayout.LayoutParams.MATCH_PARENT;
+            layoutParams.height = FrameLayout.LayoutParams.MATCH_PARENT;
+            layoutParams.gravity = Gravity.TOP;
+            listView.setLayoutParams(layoutParams);
+            listView.setAdapter(listAdapter);
+
+            listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+                @Override
+                public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+
+                    SharedPreferences themePrefs = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+                    final String key = view.getTag() != null ? view.getTag().toString() : "";
+
+                    if (i == headerColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt("drawerHeaderColor", color);
+                            }
+
+                        },themePrefs.getInt("drawerHeaderColor", AndroidUtilities.getIntColor("themeColor")), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == headerBackgroundCheckRow) {
+                        boolean b = themePrefs.getBoolean( key, true);
+                        SharedPreferences.Editor editor = themePrefs.edit();
+                        editor.putBoolean(key, !b);
+                        editor.commit();
+                        if (view instanceof TextCheckCell) {
+                            ((TextCheckCell) view).setChecked(!b);
+                        }
+                        if (listView != null) {
+                            listView.invalidateViews();
+                        }
+                    } else if (i == listColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt("drawerListColor", color);
+                            }
+
+                        },themePrefs.getInt("drawerListColor", 0xffffffff), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == iconColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt("drawerIconColor", color);
+
+                            }
+
+                        },themePrefs.getInt("drawerIconColor", 0xff737373), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == optionColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt("drawerOptionColor", color);
+                            }
+
+                        },themePrefs.getInt("drawerOptionColor", 0xff444444), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == versionColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt("drawerVersionColor", color);
+                            }
+
+                        },themePrefs.getInt("drawerVersionColor", 0xffa3a3a3), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == avatarColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt("drawerAvatarColor", color);
+                            }
+
+                        },themePrefs.getInt("drawerAvatarColor", AndroidUtilities.getIntDarkerColor("themeColor", 0x15)), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == nameColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt("drawerNameColor", color);
+                            }
+
+                        },themePrefs.getInt("drawerNameColor", 0xffffffff), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == phoneColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt("drawerPhoneColor", color);
+                            }
+
+                        },themePrefs.getInt("drawerPhoneColor", AndroidUtilities.getIntDarkerColor("themeColor",-0x40)), CENTER, 0, false);
+
+                        colorDialog.show();
+                    } else if (i == avatarRadiusRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setTitle(LocaleController.getString("AvatarRadius", R.string.AvatarRadius));
+                        final NumberPicker numberPicker = new NumberPicker(getParentActivity());
+                        final int currentValue = themePrefs.getInt("drawerAvatarRadius", 32);
+                        numberPicker.setMinValue(1);
+                        numberPicker.setMaxValue(32);
+                        numberPicker.setValue(currentValue);
+                        builder.setView(numberPicker);
+                        builder.setNegativeButton(LocaleController.getString("Done", R.string.Done), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                if (numberPicker.getValue() != currentValue) {
+                                    commitInt("drawerAvatarRadius", numberPicker.getValue());
+                                }
+                            }
+                        });
+                        showAlertDialog(builder);
+                    } else if (i == nameSizeRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setTitle(LocaleController.getString("OwnNameSize", R.string.OwnNameSize));
+                        final NumberPicker numberPicker = new NumberPicker(getParentActivity());
+                        final int currentValue = themePrefs.getInt("drawerNameSize", 15);
+                        numberPicker.setMinValue(10);
+                        numberPicker.setMaxValue(20);
+                        numberPicker.setValue(currentValue);
+                        builder.setView(numberPicker);
+                        builder.setNegativeButton(LocaleController.getString("Done", R.string.Done), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                if (numberPicker.getValue() != currentValue) {
+                                    commitInt("drawerNameSize", numberPicker.getValue());
+                                }
+                            }
+                        });
+                        showAlertDialog(builder);
+                    } else if (i == phoneSizeRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setTitle(LocaleController.getString("PhoneSize", R.string.StatusSize));
+                        final NumberPicker numberPicker = new NumberPicker(getParentActivity());
+                        final int currentValue = themePrefs.getInt("drawerPhoneSize", 13);
+                        numberPicker.setMinValue(8);
+                        numberPicker.setMaxValue(18);
+                        numberPicker.setValue(currentValue);
+                        builder.setView(numberPicker);
+                        builder.setNegativeButton(LocaleController.getString("Done", R.string.Done), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                if(numberPicker.getValue() != currentValue){
+                                    commitInt("drawerPhoneSize", numberPicker.getValue());
+                                }
+                            }
+                        });
+                        showAlertDialog(builder);
+                    } else if (i == optionSizeRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setTitle(LocaleController.getString("OptionSize", R.string.OptionSize));
+                        final NumberPicker numberPicker = new NumberPicker(getParentActivity());
+                        final int currentValue = themePrefs.getInt("drawerOptionSize", 15);
+                        numberPicker.setMinValue(10);
+                        numberPicker.setMaxValue(20);
+                        numberPicker.setValue(currentValue);
+                        builder.setView(numberPicker);
+                        builder.setNegativeButton(LocaleController.getString("Done", R.string.Done), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                if(numberPicker.getValue() != currentValue){
+                                    commitInt("drawerOptionSize", numberPicker.getValue());
+                                }
+                            }
+                        });
+                        showAlertDialog(builder);
+                    } else if (i == versionSizeRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setTitle(LocaleController.getString("VersionSize", R.string.VersionSize));
+                        final NumberPicker numberPicker = new NumberPicker(getParentActivity());
+                        final int currentValue = themePrefs.getInt("drawerVersionSize", 13);
+                        numberPicker.setMinValue(10);
+                        numberPicker.setMaxValue(20);
+                        numberPicker.setValue(currentValue);
+                        builder.setView(numberPicker);
+                        builder.setNegativeButton(LocaleController.getString("Done", R.string.Done), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                if(numberPicker.getValue() != currentValue){
+                                    commitInt("drawerVersionSize", numberPicker.getValue());
+                                }
+                            }
+                        });
+                        showAlertDialog(builder);
+                    }
+                }
+            });
+
+            listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
+                @Override
+                public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, long l) {
+                    if (getParentActivity() == null) {
+                        return false;
+                    }
+                    if (i == headerColorRow) {
+                        resetInt("drawerHeaderColor");
+                    } else if (i == listColorRow) {
+                        resetInt("drawerListColor");
+                    } else if (i == avatarColorRow) {
+                        resetInt("drawerAvatarColor");
+                    } else if (i == avatarRadiusRow) {
+                        resetInt("drawerAvatarRadius");
+                    } else if (i == nameColorRow) {
+                        resetInt("drawerNameColor");
+                    } else if (i == nameSizeRow) {
+                        resetInt("drawerNameSize");
+                    } else if (i == phoneColorRow) {
+                        resetInt("drawerPhoneColor");
+                    } else if (i == phoneSizeRow) {
+                        resetInt("drawerPhoneSize");
+                    } else if (i == iconColorRow) {
+                        resetInt("drawerIconColor");
+                    } else if (i == optionColorRow) {
+                        resetInt("drawerOptionColor");
+                    } else if (i == optionSizeRow) {
+                        resetInt("drawerOptionSize");
+                    } else if (i == versionColorRow) {
+                        resetInt("drawerVersionColor");
+                    } else if (i == versionSizeRow) {
+                        resetInt("drawerVersionSize");
+                    } else{
+                        if(view.getTag() != null){
+                            resetPref(view.getTag().toString());
+                        }
+                    }
+                    return true;
+                }
+            });
+
+            frameLayout.addView(actionBar);
+        } else {
+            ViewGroup parent = (ViewGroup)fragmentView.getParent();
+            if (parent != null) {
+                parent.removeView(fragmentView);
+            }
+        }
+        return fragmentView;
+    }
+
+    private void resetPref(String key){
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+        SharedPreferences.Editor editor = preferences.edit();
+        editor.remove(key);
+        editor.commit();
+        if (listView != null) {
+            listView.invalidateViews();
+        }
+    }
+
+    private void resetInt(String key){
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+        SharedPreferences.Editor editor = preferences.edit();
+        editor.remove(key);
+        editor.commit();
+        if (listView != null) {
+            listView.invalidateViews();
+        }
+    }
+
+    private void commitInt(String key, int value){
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+        SharedPreferences.Editor editor = preferences.edit();
+        editor.putInt(key, value);
+        editor.commit();
+        if (listView != null) {
+            listView.invalidateViews();
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+        fixLayout();
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+        fixLayout();
+    }
+
+    private void fixLayout() {
+        if (fragmentView == null) {
+            return;
+        }
+        fragmentView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                if (fragmentView != null) {
+                    //needLayout();
+                    fragmentView.getViewTreeObserver().removeOnPreDrawListener(this);
+                }
+                return false;
+            }
+        });
+        listView.setAdapter(listAdapter);
+        //actionBar.setBackgroundColor(AndroidUtilities.getIntColor("themeColor"));
+    }
+
+    private class ListAdapter extends BaseFragmentAdapter {
+        private Context mContext;
+
+        public ListAdapter(Context context) {
+            mContext = context;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            return  i == headerColorRow || i == headerBackgroundCheckRow || i == listColorRow || i == iconColorRow || i == optionColorRow || i == optionSizeRow || i == avatarColorRow || i == avatarRadiusRow || i == nameColorRow || i == nameSizeRow || i == phoneColorRow || i == phoneSizeRow ||
+                    i == versionColorRow || i == versionSizeRow;
+        }
+
+        @Override
+        public int getCount() {
+            return rowCount;
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return false;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            int type = getItemViewType(i);
+            SharedPreferences themePrefs = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+            if (type == 0) {
+                if (view == null) {
+                    view = new ShadowSectionCell(mContext);
+                }
+            }
+            else if (type == 1) {
+                if (view == null) {
+                    view = new HeaderCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                if (i == headerSection2Row) {
+                    ((HeaderCell) view).setText(LocaleController.getString("Header", R.string.Header));
+                } else if (i == rowsSection2Row) {
+                    ((HeaderCell) view).setText(LocaleController.getString("OptionsList", R.string.OptionsList));
+                }
+            }
+            else if (type == 2) {
+                if (view == null) {
+                    view = new TextSettingsCell(mContext);
+                }
+                TextSettingsCell textCell = (TextSettingsCell) view;
+                if (i == avatarRadiusRow) {
+                    int size = themePrefs.getInt("drawerAvatarRadius", AndroidUtilities.isTablet() ? 35 : 32);
+                    textCell.setTextAndValue(LocaleController.getString("AvatarRadius", R.string.AvatarRadius), String.format("%d", size), true);
+                } else if (i == nameSizeRow) {
+                    int size = themePrefs.getInt("drawerNameSize", AndroidUtilities.isTablet() ? 17 : 15);
+                    textCell.setTextAndValue(LocaleController.getString("OwnNameSize", R.string.OwnNameSize), String.format("%d", size), true);
+                } else if (i == phoneSizeRow) {
+                    int size = themePrefs.getInt("drawerPhoneSize", AndroidUtilities.isTablet() ? 15 : 13);
+                    textCell.setTextAndValue(LocaleController.getString("PhoneSize", R.string.PhoneSize), String.format("%d", size), true);
+                } else if (i == optionSizeRow) {
+                    int size = themePrefs.getInt("drawerOptionSize", AndroidUtilities.isTablet() ? 17 : 15);
+                    textCell.setTextAndValue(LocaleController.getString("OptionSize", R.string.OptionSize), String.format("%d", size), true);
+                } else if (i == versionSizeRow) {
+                    int size = themePrefs.getInt("drawerVersionSize", AndroidUtilities.isTablet() ? 15 : 13);
+                    textCell.setTextAndValue(LocaleController.getString("VersionSize", R.string.VersionSize), String.format("%d", size), true);
+                }
+
+            }
+            else if (type == 3){
+                if (view == null) {
+                    view = new TextColorCell(mContext);
+                }
+
+                TextColorCell textCell = (TextColorCell) view;
+
+                if (i == headerColorRow) {
+                    textCell.setTextAndColor(LocaleController.getString("HeaderColor", R.string.HeaderColor), themePrefs.getInt("drawerHeaderColor", AndroidUtilities.getIntColor("themeColor")), true);
+                } else if (i == listColorRow) {
+                    textCell.setTextAndColor(LocaleController.getString("ListColor", R.string.ListColor), themePrefs.getInt("drawerListColor", 0xffffffff), true);
+                } else if (i == iconColorRow) {
+                    textCell.setTextAndColor(LocaleController.getString("IconColor", R.string.IconColor), themePrefs.getInt("drawerIconColor", 0xff737373), true);
+                } else if (i == optionColorRow) {
+                    textCell.setTextAndColor(LocaleController.getString("OptionColor", R.string.OptionColor), themePrefs.getInt("drawerOptionColor", 0xff444444), true);
+                } else if (i == versionColorRow) {
+                    textCell.setTextAndColor(LocaleController.getString("VersionColor", R.string.VersionColor), themePrefs.getInt("drawerVersionColor", 0xffa3a3a3), true);
+                } else if (i == avatarColorRow) {
+                    textCell.setTextAndColor(LocaleController.getString("AvatarColor", R.string.AvatarColor), themePrefs.getInt("drawerAvatarColor", AndroidUtilities.getIntDarkerColor("themeColor", 0x15)), true);
+                } else if (i == nameColorRow) {
+                    textCell.setTextAndColor(LocaleController.getString("NameColor", R.string.NameColor), themePrefs.getInt("drawerNameColor", 0xffffffff), true);
+                } else if (i == phoneColorRow) {
+                    textCell.setTextAndColor(LocaleController.getString("PhoneColor", R.string.PhoneColor), themePrefs.getInt("drawerPhoneColor", AndroidUtilities.getIntDarkerColor("themeColor",-0x40)), true);
+                }
+            }  else if (type == 4) {
+                if (view == null) {
+                    view = new TextCheckCell(mContext);
+                }
+                TextCheckCell textCell = (TextCheckCell) view;
+                if (i == headerBackgroundCheckRow) {
+                    textCell.setTag("drawerHeaderBGCheck");
+                    textCell.setTextAndCheck(LocaleController.getString("HideBackground", R.string.HideBackground), themePrefs.getBoolean("drawerHeaderBGCheck", false), false);
+                }
+            }
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            if ( i == rowsSectionRow ) {
+                return 0;
+            }
+            else if ( i == headerSection2Row || i == rowsSection2Row ) {
+                return 1;
+            }
+            else if ( i == avatarRadiusRow || i == nameSizeRow ||  i == phoneSizeRow ||  i == optionSizeRow ||  i == versionSizeRow) {
+                return 2;
+            }
+            else if ( i == headerColorRow || i == listColorRow || i == iconColorRow || i == optionColorRow || i == versionColorRow  || i == avatarColorRow  || i == nameColorRow || i == phoneColorRow) {
+                return 3;
+            }
+            else if (i == headerBackgroundCheckRow) {
+                return 4;
+            }
+            else {
+                return 2;
+            }
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 5;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ThemingProfileActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ThemingProfileActivity.java
new file mode 100644
index 000000000..3a6f7eca2
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ThemingProfileActivity.java
@@ -0,0 +1,500 @@
+/*
+ * This is the source code of Telegram for Android v. 1.3.2.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013.
+ */
+
+package org.telegram.ui;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.SharedPreferences;
+import android.content.res.Configuration;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import android.widget.ListView;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.android.MessagesController;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.R;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.HeaderCell;
+import org.telegram.ui.Cells.ShadowSectionCell;
+import org.telegram.ui.Cells.TextCheckCell;
+import org.telegram.ui.Cells.TextColorCell;
+import org.telegram.ui.Cells.TextSettingsCell;
+import org.telegram.ui.Components.AvatarDrawable;
+import org.telegram.ui.Components.ColorSelectorDialog;
+import org.telegram.ui.Components.NumberPicker;
+
+import static org.telegram.ui.Components.ColorSelectorDialog.OnColorChangedListener;
+
+public class ThemingProfileActivity extends BaseFragment {
+
+    private ListView listView;
+    private ListAdapter listAdapter;
+
+    private int headerSection2Row;
+    private int headerColorRow;
+    private int headerIconsColorRow;
+
+    private int rowsSectionRow;
+    private int rowsSection2Row;
+    private int rowColorRow;
+
+    private int nameColorRow;
+    private int nameSizeRow;
+    private int statusColorRow;
+    private int statusSizeRow;
+
+    private int titleColorRow;
+    private int summaryColorRow;
+
+    private int rowCount;
+
+    public final static int CENTER = 0;
+
+    @Override
+    public boolean onFragmentCreate() {
+        super.onFragmentCreate();
+
+        rowCount = 0;
+        headerSection2Row = rowCount++;
+        headerColorRow = rowCount++;
+        headerIconsColorRow = rowCount++;
+
+        nameSizeRow = rowCount++;
+        nameColorRow = rowCount++;
+        statusSizeRow = rowCount++;
+        statusColorRow = rowCount++;
+
+        rowsSectionRow = rowCount++;
+        rowsSection2Row = rowCount++;
+        rowColorRow = rowCount++;
+        titleColorRow = rowCount++;
+        summaryColorRow = rowCount++;
+
+        return true;
+    }
+
+    @Override
+    public void onFragmentDestroy() {
+        super.onFragmentDestroy();
+
+    }
+
+    @Override
+    public View createView(Context context, LayoutInflater inflater) {
+        if (fragmentView == null) {
+
+            actionBar.setItemsBackground(AvatarDrawable.getButtonColorForId(5));
+            actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+
+            if (AndroidUtilities.isTablet()) {
+                actionBar.setOccupyStatusBar(false);
+            }
+            actionBar.setTitle(LocaleController.getString("ProfileScreen", R.string.ProfileScreen));
+
+            actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+                @Override
+                public void onItemClick(int id) {
+                    if (id == -1) {
+                        finishFragment();
+                    }
+                }
+            });
+
+            listAdapter = new ListAdapter(context);
+
+            fragmentView = new FrameLayout(context);
+            FrameLayout frameLayout = (FrameLayout) fragmentView;
+
+            listView = new ListView(context);
+            listView.setDivider(null);
+            listView.setDividerHeight(0);
+            listView.setVerticalScrollBarEnabled(false);
+            AndroidUtilities.setListViewEdgeEffectColor(listView, AvatarDrawable.getProfileBackColorForId(5));
+            frameLayout.addView(listView);
+            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
+            layoutParams.width = FrameLayout.LayoutParams.MATCH_PARENT;
+            layoutParams.height = FrameLayout.LayoutParams.MATCH_PARENT;
+            layoutParams.gravity = Gravity.TOP;
+            listView.setLayoutParams(layoutParams);
+            listView.setAdapter(listAdapter);
+
+            listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+                @Override
+                public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+
+                    SharedPreferences themePrefs = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+                    final String key = view.getTag() != null ? view.getTag().toString() : "";
+
+                    if (i == headerColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt(key, color);
+                            }
+
+                        },themePrefs.getInt(key, AndroidUtilities.getIntColor("themeColor")), CENTER, 0, false);
+
+                        colorDialog.show();
+                    } else if (i == headerIconsColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt( key, color);
+                            }
+                        },themePrefs.getInt( key, 0xffffffff), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == nameColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt(key, color);
+                            }
+                        },themePrefs.getInt(key, 0xffffffff), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == statusColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt(key, color);
+                            }
+
+                        },themePrefs.getInt(key, AndroidUtilities.getIntDarkerColor("themeColor",-0x40)), CENTER, 0, false);
+
+                        colorDialog.show();
+                    }  else if (i == nameSizeRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setTitle(LocaleController.getString("NameSize", R.string.NameSize));
+                        final NumberPicker numberPicker = new NumberPicker(getParentActivity());
+                        final int currentValue = themePrefs.getInt(key, 18);
+                        numberPicker.setMinValue(12);
+                        numberPicker.setMaxValue(30);
+                        numberPicker.setValue(currentValue);
+                        builder.setView(numberPicker);
+                        builder.setNegativeButton(LocaleController.getString("Done", R.string.Done), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                if (numberPicker.getValue() != currentValue) {
+                                    commitInt(key, numberPicker.getValue());
+                                }
+                            }
+                        });
+                        showAlertDialog(builder);
+                    } else if (i == statusSizeRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setTitle(LocaleController.getString("StatusSize", R.string.StatusSize));
+                        final NumberPicker numberPicker = new NumberPicker(getParentActivity());
+                        final int currentValue = themePrefs.getInt(key, 14);
+                        numberPicker.setMinValue(8);
+                        numberPicker.setMaxValue(22);
+                        numberPicker.setValue(currentValue);
+                        builder.setView(numberPicker);
+                        builder.setNegativeButton(LocaleController.getString("Done", R.string.Done), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                if(numberPicker.getValue() != currentValue){
+                                    commitInt(key, numberPicker.getValue());
+                                }
+                            }
+                        });
+                        showAlertDialog(builder);
+                    } else if (i == rowColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt( key, color);
+                            }
+
+                        },themePrefs.getInt( key, 0xffffffff), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == titleColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt(key, color);
+                            }
+                        },themePrefs.getInt(key, 0xff000000), CENTER, 0, false);
+                        colorDialog.show();
+                    } else if (i == summaryColorRow) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        LayoutInflater li = (LayoutInflater)getParentActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+                        li.inflate(R.layout.colordialog, null, false);
+                        ColorSelectorDialog colorDialog = new ColorSelectorDialog(getParentActivity(), new OnColorChangedListener() {
+                            @Override
+                            public void colorChanged(int color) {
+                                commitInt(key, color);
+                            }
+                        },themePrefs.getInt(key, 0xff8a8a8a), CENTER, 0, false);
+                        colorDialog.show();
+                    }
+                }
+            });
+
+            listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
+                @Override
+                public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, long l) {
+                    if (getParentActivity() == null) {
+                        return false;
+                    }
+                    if(view.getTag() != null){
+                        resetPref(view.getTag().toString());
+                    }
+
+                    return true;
+                }
+            });
+
+            frameLayout.addView(actionBar);
+        } else {
+            ViewGroup parent = (ViewGroup)fragmentView.getParent();
+            if (parent != null) {
+                parent.removeView(fragmentView);
+            }
+        }
+        return fragmentView;
+    }
+
+    private void resetPref(String key){
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+        SharedPreferences.Editor editor = preferences.edit();
+        editor.remove(key);
+        editor.commit();
+        if (listView != null) {
+            listView.invalidateViews();
+        }
+    }
+
+    private void commitInt(String key, int value){
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+        SharedPreferences.Editor editor = preferences.edit();
+        editor.putInt(key, value);
+        editor.commit();
+        if (listView != null) {
+            listView.invalidateViews();
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+        fixLayout();
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+        fixLayout();
+    }
+
+    private void fixLayout() {
+        if (fragmentView == null) {
+            return;
+        }
+        fragmentView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                if (fragmentView != null) {
+                    //needLayout();
+                    fragmentView.getViewTreeObserver().removeOnPreDrawListener(this);
+                }
+                return false;
+            }
+        });
+        listView.setAdapter(listAdapter);
+    }
+
+    private class ListAdapter extends BaseFragmentAdapter {
+        private Context mContext;
+
+        public ListAdapter(Context context) {
+            mContext = context;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            return  i == headerColorRow  || i == headerIconsColorRow || i == nameColorRow || i == nameSizeRow || i == statusColorRow || i == statusSizeRow ||
+                    i == rowColorRow || i == titleColorRow || i == summaryColorRow;
+        }
+
+        @Override
+        public int getCount() {
+            return rowCount;
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return false;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            int type = getItemViewType(i);
+            SharedPreferences themePrefs = ApplicationLoader.applicationContext.getSharedPreferences(AndroidUtilities.THEME_PREFS, AndroidUtilities.THEME_PREFS_MODE);
+            if (type == 0) {
+                if (view == null) {
+                    view = new ShadowSectionCell(mContext);
+                }
+            }
+            else if (type == 1) {
+                if (view == null) {
+                    view = new HeaderCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                if (i == headerSection2Row) {
+                    ((HeaderCell) view).setText(LocaleController.getString("Header", R.string.Header));
+                } else if (i == rowsSection2Row) {
+                    ((HeaderCell) view).setText(LocaleController.getString("ChatList", R.string.ChatList));
+                }
+            }
+            else if (type == 2) {
+                if (view == null) {
+                    view = new TextSettingsCell(mContext);
+                }
+                TextSettingsCell textCell = (TextSettingsCell) view;
+                if (i == nameSizeRow) {
+                    textCell.setTag("profileNameSize");
+                    int size = themePrefs.getInt("profileNameSize", AndroidUtilities.isTablet() ? 20 : 18);
+                    textCell.setTextAndValue(LocaleController.getString("NameSize", R.string.NameSize), String.format("%d", size), true);
+                } else if (i == statusSizeRow) {
+                    textCell.setTag("profileStatusSize");
+                    int size = themePrefs.getInt("profileStatusSize", AndroidUtilities.isTablet() ? 16 : 14);
+                    textCell.setTextAndValue(LocaleController.getString("StatusSize", R.string.StatusSize), String.format("%d", size), true);
+                }
+            }
+            else if (type == 3){
+                if (view == null) {
+                    view = new TextColorCell(mContext);
+                }
+
+                TextColorCell textCell = (TextColorCell) view;
+
+                if (i == headerColorRow) {
+                    textCell.setTag("profileHeaderColor");
+                    textCell.setTextAndColor(LocaleController.getString("HeaderColor", R.string.HeaderColor), themePrefs.getInt(textCell.getTag().toString(), AndroidUtilities.getIntColor("themeColor")), true);
+                } else if (i == headerIconsColorRow) {
+                    textCell.setTag("profileHeaderIconsColor");
+                    textCell.setTextAndColor(LocaleController.getString("HeaderIconsColor", R.string.HeaderIconsColor), themePrefs.getInt(textCell.getTag().toString(), 0xffffffff), true);
+                } else if (i == nameColorRow) {
+                    textCell.setTag("profileNameColor");
+                    textCell.setTextAndColor(LocaleController.getString("NameColor", R.string.NameColor), themePrefs.getInt(textCell.getTag().toString(), 0xffffffff), true);
+                } else if (i == statusColorRow) {
+                    textCell.setTag("profileStatusColor");
+                    textCell.setTextAndColor(LocaleController.getString("StatusColor", R.string.StatusColor), themePrefs.getInt(textCell.getTag().toString(), AndroidUtilities.getIntDarkerColor("themeColor",-0x40)), true);
+                } else if (i == rowColorRow) {
+                    textCell.setTag("profileRowColor");
+                    textCell.setTextAndColor(LocaleController.getString("RowColor", R.string.RowColor), themePrefs.getInt(textCell.getTag().toString(), 0xffffffff), true);
+                } else if (i == titleColorRow) {
+                    textCell.setTag("profileTitleColor");
+                    textCell.setTextAndColor(LocaleController.getString("NameColor", R.string.NameColor), themePrefs.getInt(textCell.getTag().toString(), 0xff000000), true);
+                } else if (i == summaryColorRow) {
+                    textCell.setTag("profileSummaryColor");
+                    textCell.setTextAndColor(LocaleController.getString("StatusColor", R.string.StatusColor), themePrefs.getInt(textCell.getTag().toString(), 0xff8a8a8a), true);
+                }
+            }
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            if ( i == rowsSectionRow ) {
+                return 0;
+            }
+            else if ( i == headerSection2Row || i == rowsSection2Row ) {
+                return 1;
+            }
+            else if ( i == nameSizeRow ||  i == statusSizeRow) {
+                return 2;
+            }
+
+            else if ( i == headerColorRow  || i == headerIconsColorRow || i == nameColorRow || i == statusColorRow ||
+                      i == rowColorRow || i == titleColorRow || i == summaryColorRow) {
+                return 3;
+            }
+            else {
+                return 2;
+            }
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 4;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java
new file mode 100644
index 000000000..b9c8aeb5f
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java
@@ -0,0 +1,1086 @@
+/*
+ * This is the source code of Telegram for Android v. 2.x
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui;
+
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.graphics.Typeface;
+import android.os.Vibrator;
+import android.text.InputType;
+import android.text.method.PasswordTransformationMethod;
+import android.util.TypedValue;
+import android.view.ActionMode;
+import android.view.ContextMenu;
+import android.view.Gravity;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.view.inputmethod.EditorInfo;
+import android.widget.AdapterView;
+import android.widget.EditText;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.ListView;
+import android.widget.ProgressBar;
+import android.widget.ScrollView;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import org.telegram.android.AndroidUtilities;
+import org.telegram.android.LocaleController;
+import org.telegram.android.NotificationCenter;
+import org.telegram.messenger.ConnectionsManager;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.R;
+import org.telegram.messenger.RPCRequest;
+import org.telegram.messenger.TLObject;
+import org.telegram.messenger.TLRPC;
+import org.telegram.messenger.Utilities;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.ActionBarMenu;
+import org.telegram.ui.ActionBar.ActionBarMenuItem;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.TextInfoPrivacyCell;
+import org.telegram.ui.Cells.TextSettingsCell;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class TwoStepVerificationActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
+
+    private ListAdapter listAdapter;
+    private ListView listView;
+    private TextView titleTextView;
+    private TextView bottomTextView;
+    private TextView bottomButton;
+    private EditText passwordEditText;
+    private ProgressDialog progressDialog;
+    private FrameLayout progressView;
+    private ActionBarMenuItem doneItem;
+    private ScrollView scrollView;
+
+    private int type;
+    private int passwordSetState;
+    private String firstPassword;
+    private String hint;
+    private String email;
+    private boolean emailOnly;
+    private boolean loading;
+    private boolean destroyed;
+    private boolean waitingForEmail;
+    private TLRPC.account_Password currentPassword;
+    private boolean passwordEntered = true;
+    private byte[] currentPasswordHash = new byte[0];
+    private Runnable shortPollRunnable;
+
+    private int setPasswordRow;
+    private int setPasswordDetailRow;
+    private int changePasswordRow;
+    private int shadowRow;
+    private int turnPasswordOffRow;
+    private int setRecoveryEmailRow;
+    private int changeRecoveryEmailRow;
+    private int abortPasswordRow;
+    private int passwordSetupDetailRow;
+    private int passwordEnabledDetailRow;
+    private int passwordEmailVerifyDetailRow;
+    private int rowCount;
+
+    private final static int done_button = 1;
+
+    public TwoStepVerificationActivity(int type) {
+        super();
+        this.type = type;
+        if (type == 0) {
+            loadPasswordInfo(false);
+        }
+    }
+
+    @Override
+    public boolean onFragmentCreate() {
+        super.onFragmentCreate();
+        updateRows();
+        if (type == 0) {
+            NotificationCenter.getInstance().addObserver(this, NotificationCenter.didSetTwoStepPassword);
+        }
+        return true;
+    }
+
+    @Override
+    public void onFragmentDestroy() {
+        super.onFragmentDestroy();
+        if (type == 0) {
+            NotificationCenter.getInstance().removeObserver(this, NotificationCenter.didSetTwoStepPassword);
+            if (shortPollRunnable != null) {
+                AndroidUtilities.cancelRunOnUIThread(shortPollRunnable);
+                shortPollRunnable = null;
+            }
+            destroyed = true;
+        }
+        if (progressDialog != null) {
+            try {
+                progressDialog.dismiss();
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+            progressDialog = null;
+        }
+        if (!AndroidUtilities.isTablet() && getParentActivity() != null) {
+            getParentActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);
+        }
+    }
+
+    @Override
+    public View createView(Context context, LayoutInflater inflater) {
+        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setAllowOverlayTitle(false);
+        actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+            @Override
+            public void onItemClick(int id) {
+                if (id == -1) {
+                    finishFragment();
+                } else if (id == done_button) {
+                    processDone();
+                }
+            }
+        });
+
+        fragmentView = new FrameLayout(context);
+        FrameLayout frameLayout = (FrameLayout) fragmentView;
+        frameLayout.setBackgroundColor(0xfff0f0f0);
+
+        ActionBarMenu menu = actionBar.createMenu();
+        doneItem = menu.addItemWithWidth(done_button, R.drawable.ic_done, AndroidUtilities.dp(56));
+
+        scrollView = new ScrollView(context);
+        scrollView.setFillViewport(true);
+        frameLayout.addView(scrollView);
+        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) scrollView.getLayoutParams();
+        layoutParams.width = LayoutHelper.MATCH_PARENT;
+        layoutParams.height = LayoutHelper.MATCH_PARENT;
+        scrollView.setLayoutParams(layoutParams);
+
+        LinearLayout linearLayout = new LinearLayout(context);
+        linearLayout.setOrientation(LinearLayout.VERTICAL);
+        scrollView.addView(linearLayout);
+        ScrollView.LayoutParams layoutParams2 = (ScrollView.LayoutParams) linearLayout.getLayoutParams();
+        layoutParams2.width = ScrollView.LayoutParams.MATCH_PARENT;
+        layoutParams2.height = ScrollView.LayoutParams.WRAP_CONTENT;
+        linearLayout.setLayoutParams(layoutParams2);
+
+        titleTextView = new TextView(context);
+        titleTextView.setTextColor(0xff757575);
+        titleTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
+        titleTextView.setGravity(Gravity.CENTER_HORIZONTAL);
+        linearLayout.addView(titleTextView);
+        LinearLayout.LayoutParams layoutParams3 = (LinearLayout.LayoutParams) titleTextView.getLayoutParams();
+        layoutParams3.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams3.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams3.gravity = Gravity.CENTER_HORIZONTAL;
+        layoutParams3.topMargin = AndroidUtilities.dp(38);
+        titleTextView.setLayoutParams(layoutParams3);
+
+        passwordEditText = new EditText(context);
+        passwordEditText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20);
+        passwordEditText.setTextColor(0xff000000);
+        passwordEditText.setMaxLines(1);
+        passwordEditText.setLines(1);
+        passwordEditText.setGravity(Gravity.CENTER_HORIZONTAL);
+        passwordEditText.setSingleLine(true);
+        passwordEditText.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
+        passwordEditText.setTransformationMethod(PasswordTransformationMethod.getInstance());
+        passwordEditText.setTypeface(Typeface.DEFAULT);
+        AndroidUtilities.clearCursorDrawable(passwordEditText);
+        linearLayout.addView(passwordEditText);
+        layoutParams3 = (LinearLayout.LayoutParams) passwordEditText.getLayoutParams();
+        layoutParams3.topMargin = AndroidUtilities.dp(32);
+        layoutParams3.height = AndroidUtilities.dp(36);
+        layoutParams3.leftMargin = AndroidUtilities.dp(40);
+        layoutParams3.rightMargin = AndroidUtilities.dp(40);
+        layoutParams3.gravity = Gravity.TOP | Gravity.LEFT;
+        layoutParams3.width = LayoutHelper.MATCH_PARENT;
+        passwordEditText.setLayoutParams(layoutParams3);
+        passwordEditText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
+            @Override
+            public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
+                if (i == EditorInfo.IME_ACTION_NEXT || i == EditorInfo.IME_ACTION_DONE) {
+                    processDone();
+                    return true;
+                }
+                return false;
+            }
+        });
+        if (android.os.Build.VERSION.SDK_INT < 11) {
+            passwordEditText.setOnCreateContextMenuListener(new View.OnCreateContextMenuListener() {
+                public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
+                    menu.clear();
+                }
+            });
+        } else {
+            passwordEditText.setCustomSelectionActionModeCallback(new ActionMode.Callback() {
+                public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
+                    return false;
+                }
+
+                public void onDestroyActionMode(ActionMode mode) {
+                }
+
+                public boolean onCreateActionMode(ActionMode mode, Menu menu) {
+                    return false;
+                }
+
+                public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
+                    return false;
+                }
+            });
+        }
+
+        bottomTextView = new TextView(context);
+        bottomTextView.setTextColor(0xff757575);
+        bottomTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        bottomTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP);
+        bottomTextView.setText(LocaleController.getString("YourEmailInfo", R.string.YourEmailInfo));
+        linearLayout.addView(bottomTextView);
+        layoutParams3 = (LinearLayout.LayoutParams) bottomTextView.getLayoutParams();
+        layoutParams3.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams3.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams3.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP;
+        layoutParams3.topMargin = AndroidUtilities.dp(30);
+        layoutParams3.leftMargin = AndroidUtilities.dp(40);
+        layoutParams3.rightMargin = AndroidUtilities.dp(40);
+        bottomTextView.setLayoutParams(layoutParams3);
+
+        LinearLayout linearLayout2 = new LinearLayout(context);
+        linearLayout2.setGravity(Gravity.BOTTOM | Gravity.CENTER_VERTICAL);
+        linearLayout.addView(linearLayout2);
+        layoutParams3 = (LinearLayout.LayoutParams) linearLayout2.getLayoutParams();
+        layoutParams3.width = LayoutHelper.MATCH_PARENT;
+        layoutParams3.height = LayoutHelper.MATCH_PARENT;
+        linearLayout2.setLayoutParams(layoutParams3);
+
+        bottomButton = new TextView(context);
+        bottomButton.setTextColor(0xff4d83b3);
+        bottomButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        bottomButton.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM);
+        bottomButton.setText(LocaleController.getString("YourEmailSkip", R.string.YourEmailSkip));
+        bottomButton.setPadding(0, AndroidUtilities.dp(10), 0, 0);
+        linearLayout2.addView(bottomButton);
+        layoutParams3 = (LinearLayout.LayoutParams) bottomButton.getLayoutParams();
+        layoutParams3.width = LayoutHelper.WRAP_CONTENT;
+        layoutParams3.height = LayoutHelper.WRAP_CONTENT;
+        layoutParams3.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM;
+        layoutParams3.bottomMargin = AndroidUtilities.dp(14);
+        layoutParams3.leftMargin = AndroidUtilities.dp(40);
+        layoutParams3.rightMargin = AndroidUtilities.dp(40);
+        bottomButton.setLayoutParams(layoutParams3);
+        bottomButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (type == 0) {
+                    if (currentPassword.has_recovery) {
+                        needShowProgress();
+                        TLRPC.TL_auth_requestPasswordRecovery req = new TLRPC.TL_auth_requestPasswordRecovery();
+                        ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                            @Override
+                            public void run(final TLObject response, final TLRPC.TL_error error) {
+                                AndroidUtilities.runOnUIThread(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        needHideProgress();
+                                        if (error == null) {
+                                            final TLRPC.TL_auth_passwordRecovery res = (TLRPC.TL_auth_passwordRecovery) response;
+                                            AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                                            builder.setMessage(LocaleController.formatString("RestoreEmailSent", R.string.RestoreEmailSent, res.email_pattern));
+                                            builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                                            builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                                                @Override
+                                                public void onClick(DialogInterface dialogInterface, int i) {
+                                                    TwoStepVerificationActivity fragment = new TwoStepVerificationActivity(1);
+                                                    fragment.currentPassword = currentPassword;
+                                                    fragment.currentPassword.email_unconfirmed_pattern = res.email_pattern;
+                                                    fragment.passwordSetState = 4;
+                                                    presentFragment(fragment);
+                                                }
+                                            });
+                                            AlertDialog dialog = showAlertDialog(builder);
+                                            if (dialog != null) {
+                                                dialog.setCanceledOnTouchOutside(false);
+                                                dialog.setCancelable(false);
+                                            }
+                                        } else {
+                                            if (error.text.startsWith("FLOOD_WAIT")) {
+                                                int time = Utilities.parseInt(error.text);
+                                                String timeString;
+                                                if (time < 60) {
+                                                    timeString = LocaleController.formatPluralString("Seconds", time);
+                                                } else {
+                                                    timeString = LocaleController.formatPluralString("Minutes", time / 60);
+                                                }
+                                                showAlertWithText(LocaleController.getString("AppName", R.string.AppName), LocaleController.formatString("FloodWaitTime", R.string.FloodWaitTime, timeString));
+                                            } else {
+                                                showAlertWithText(LocaleController.getString("AppName", R.string.AppName), error.text);
+                                            }
+                                        }
+                                    }
+                                });
+                            }
+                        }, true, RPCRequest.RPCRequestClassGeneric | RPCRequest.RPCRequestClassFailOnServerErrors | RPCRequest.RPCRequestClassWithoutLogin);
+                    } else {
+                        showAlertWithText(LocaleController.getString("RestorePasswordNoEmailTitle", R.string.RestorePasswordNoEmailTitle), LocaleController.getString("RestorePasswordNoEmailText", R.string.RestorePasswordNoEmailText));
+                    }
+                } else {
+                    if (passwordSetState == 4) {
+                        showAlertWithText(LocaleController.getString("RestorePasswordNoEmailTitle", R.string.RestorePasswordNoEmailTitle), LocaleController.getString("RestoreEmailTroubleText", R.string.RestoreEmailTroubleText));
+                    } else {
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setMessage(LocaleController.getString("YourEmailSkipWarningText", R.string.YourEmailSkipWarningText));
+                        builder.setTitle(LocaleController.getString("YourEmailSkipWarning", R.string.YourEmailSkipWarning));
+                        builder.setPositiveButton(LocaleController.getString("YourEmailSkip", R.string.YourEmailSkip), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialogInterface, int i) {
+                                email = "";
+                                setNewPassword(false);
+                            }
+                        });
+                        builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                        showAlertDialog(builder);
+                    }
+                }
+            }
+        });
+
+        if (type == 0) {
+            progressView = new FrameLayout(context);
+            frameLayout.addView(progressView);
+            layoutParams = (FrameLayout.LayoutParams) progressView.getLayoutParams();
+            layoutParams.width = LayoutHelper.MATCH_PARENT;
+            layoutParams.height = LayoutHelper.MATCH_PARENT;
+            progressView.setLayoutParams(layoutParams);
+            progressView.setOnTouchListener(new View.OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    return true;
+                }
+            });
+
+            ProgressBar progressBar = new ProgressBar(context);
+            progressView.addView(progressBar);
+            layoutParams = (FrameLayout.LayoutParams) progressView.getLayoutParams();
+            layoutParams.width = LayoutHelper.WRAP_CONTENT;
+            layoutParams.height = LayoutHelper.WRAP_CONTENT;
+            layoutParams.gravity = Gravity.CENTER;
+            progressView.setLayoutParams(layoutParams);
+
+            listView = new ListView(context);
+            listView.setDivider(null);
+            listView.setEmptyView(progressView);
+            listView.setDividerHeight(0);
+            listView.setVerticalScrollBarEnabled(false);
+            listView.setDrawSelectorOnTop(true);
+            frameLayout.addView(listView);
+            layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
+            layoutParams.width = LayoutHelper.MATCH_PARENT;
+            layoutParams.height = LayoutHelper.MATCH_PARENT;
+            layoutParams.gravity = Gravity.TOP;
+            listView.setLayoutParams(layoutParams);
+            listView.setAdapter(listAdapter = new ListAdapter(context));
+            listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+                @Override
+                public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+                    if (i == setPasswordRow || i == changePasswordRow) {
+                        TwoStepVerificationActivity fragment = new TwoStepVerificationActivity(1);
+                        fragment.currentPasswordHash = currentPasswordHash;
+                        fragment.currentPassword = currentPassword;
+                        presentFragment(fragment);
+                    } else if (i == setRecoveryEmailRow || i == changeRecoveryEmailRow) {
+                        TwoStepVerificationActivity fragment = new TwoStepVerificationActivity(1);
+                        fragment.currentPasswordHash = currentPasswordHash;
+                        fragment.currentPassword = currentPassword;
+                        fragment.emailOnly = true;
+                        fragment.passwordSetState = 3;
+                        presentFragment(fragment);
+                    } else if (i == turnPasswordOffRow || i == abortPasswordRow) {
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setMessage(LocaleController.getString("TurnPasswordOffQuestion", R.string.TurnPasswordOffQuestion));
+                        builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                        builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialogInterface, int i) {
+                                setNewPassword(true);
+                            }
+                        });
+                        builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                        showAlertDialog(builder);
+                    }
+                }
+            });
+
+            updateRows();
+
+            actionBar.setTitle(LocaleController.getString("TwoStepVerification", R.string.TwoStepVerification));
+            titleTextView.setText(LocaleController.getString("PleaseEnterCurrentPassword", R.string.PleaseEnterCurrentPassword));
+        } else if (type == 1) {
+            setPasswordSetState(passwordSetState);
+        }
+
+        return fragmentView;
+    }
+
+    @Override
+    public void didReceivedNotification(int id, Object... args) {
+        if (id == NotificationCenter.didSetTwoStepPassword) {
+            if (args != null && args.length > 0 && args[0] != null) {
+                currentPasswordHash = (byte[]) args[0];
+            }
+            loadPasswordInfo(false);
+            updateRows();
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (type == 1) {
+            AndroidUtilities.runOnUIThread(new Runnable() {
+                @Override
+                public void run() {
+                    if (passwordEditText != null) {
+                        passwordEditText.requestFocus();
+                        AndroidUtilities.showKeyboard(passwordEditText);
+                    }
+                }
+            }, 200);
+        }
+        if (!AndroidUtilities.isTablet()) {
+            getParentActivity().getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
+        }
+    }
+
+    @Override
+    public void onOpenAnimationEnd() {
+        super.onOpenAnimationEnd();
+        if (type == 1) {
+            AndroidUtilities.showKeyboard(passwordEditText);
+        }
+    }
+
+    private void loadPasswordInfo(final boolean silent) {
+        if (!silent) {
+            loading = true;
+        }
+        TLRPC.TL_account_getPassword req = new TLRPC.TL_account_getPassword();
+        ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        loading = false;
+                        if (error == null) {
+                            if (!silent) {
+                                passwordEntered = currentPassword != null || currentPassword == null && response instanceof TLRPC.TL_account_noPassword;
+                            }
+                            currentPassword = (TLRPC.account_Password) response;
+                            waitingForEmail = currentPassword.email_unconfirmed_pattern.length() > 0;
+                            byte[] salt = new byte[currentPassword.new_salt.length + 8];
+                            Utilities.random.nextBytes(salt);
+                            System.arraycopy(currentPassword.new_salt, 0, salt, 0, currentPassword.new_salt.length);
+                            currentPassword.new_salt = salt;
+                        }
+                        if (type == 0 && !destroyed && shortPollRunnable == null) {
+                            shortPollRunnable = new Runnable() {
+                                @Override
+                                public void run() {
+                                    if (shortPollRunnable == null) {
+                                        return;
+                                    }
+                                    loadPasswordInfo(true);
+                                    shortPollRunnable = null;
+                                }
+                            };
+                            AndroidUtilities.runOnUIThread(shortPollRunnable, 5000);
+                        }
+                        updateRows();
+                    }
+                });
+            }
+        }, true, RPCRequest.RPCRequestClassGeneric | RPCRequest.RPCRequestClassFailOnServerErrors | RPCRequest.RPCRequestClassWithoutLogin);
+    }
+
+    private void setPasswordSetState(int state) {
+        if (passwordEditText == null) {
+            return;
+        }
+        passwordSetState = state;
+        if (passwordSetState == 0) {
+            actionBar.setTitle(LocaleController.getString("YourPassword", R.string.YourPassword));
+            if (currentPassword instanceof TLRPC.TL_account_noPassword) {
+                titleTextView.setText(LocaleController.getString("PleaseEnterFirstPassword", R.string.PleaseEnterFirstPassword));
+            } else {
+                titleTextView.setText(LocaleController.getString("PleaseEnterPassword", R.string.PleaseEnterPassword));
+            }
+            passwordEditText.setImeOptions(EditorInfo.IME_ACTION_NEXT);
+            passwordEditText.setTransformationMethod(PasswordTransformationMethod.getInstance());
+            bottomTextView.setVisibility(View.INVISIBLE);
+            bottomButton.setVisibility(View.INVISIBLE);
+        } else if (passwordSetState == 1) {
+            actionBar.setTitle(LocaleController.getString("YourPassword", R.string.YourPassword));
+            titleTextView.setText(LocaleController.getString("PleaseReEnterPassword", R.string.PleaseReEnterPassword));
+            passwordEditText.setImeOptions(EditorInfo.IME_ACTION_NEXT);
+            passwordEditText.setTransformationMethod(PasswordTransformationMethod.getInstance());
+            bottomTextView.setVisibility(View.INVISIBLE);
+            bottomButton.setVisibility(View.INVISIBLE);
+        } else if (passwordSetState == 2) {
+            actionBar.setTitle(LocaleController.getString("PasswordHint", R.string.PasswordHint));
+            titleTextView.setText(LocaleController.getString("PasswordHintText", R.string.PasswordHintText));
+            passwordEditText.setImeOptions(EditorInfo.IME_ACTION_NEXT);
+            passwordEditText.setTransformationMethod(null);
+            bottomTextView.setVisibility(View.INVISIBLE);
+            bottomButton.setVisibility(View.INVISIBLE);
+        } else if (passwordSetState == 3) {
+            actionBar.setTitle(LocaleController.getString("RecoveryEmail", R.string.RecoveryEmail));
+            titleTextView.setText(LocaleController.getString("YourEmail", R.string.YourEmail));
+            passwordEditText.setImeOptions(EditorInfo.IME_ACTION_DONE);
+            passwordEditText.setTransformationMethod(null);
+            passwordEditText.setInputType(EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
+            bottomTextView.setVisibility(View.VISIBLE);
+            bottomButton.setVisibility(emailOnly ? View.INVISIBLE : View.VISIBLE);
+        } else if (passwordSetState == 4) {
+            actionBar.setTitle(LocaleController.getString("PasswordRecovery", R.string.PasswordRecovery));
+            titleTextView.setText(LocaleController.getString("PasswordCode", R.string.PasswordCode));
+            bottomTextView.setText(LocaleController.getString("RestoreEmailSentInfo", R.string.RestoreEmailSentInfo));
+            bottomButton.setText(LocaleController.formatString("RestoreEmailTrouble", R.string.RestoreEmailTrouble, currentPassword.email_unconfirmed_pattern));
+            passwordEditText.setImeOptions(EditorInfo.IME_ACTION_DONE);
+            passwordEditText.setTransformationMethod(null);
+            passwordEditText.setInputType(InputType.TYPE_CLASS_PHONE);
+            bottomTextView.setVisibility(View.VISIBLE);
+            bottomButton.setVisibility(View.VISIBLE);
+        }
+        passwordEditText.setText("");
+    }
+
+    private void updateRows() {
+        rowCount = 0;
+        setPasswordRow = -1;
+        setPasswordDetailRow = -1;
+        changePasswordRow = -1;
+        turnPasswordOffRow = -1;
+        setRecoveryEmailRow = -1;
+        changeRecoveryEmailRow = -1;
+        abortPasswordRow = -1;
+        passwordSetupDetailRow = -1;
+        passwordEnabledDetailRow = -1;
+        passwordEmailVerifyDetailRow = -1;
+        shadowRow = -1;
+        if (!loading && currentPassword != null) {
+            if (currentPassword instanceof TLRPC.TL_account_noPassword) {
+                if (waitingForEmail) {
+                    passwordSetupDetailRow = rowCount++;
+                    abortPasswordRow = rowCount++;
+                    shadowRow = rowCount++;
+                } else {
+                    setPasswordRow = rowCount++;
+                    setPasswordDetailRow = rowCount++;
+                }
+            } else if (currentPassword instanceof TLRPC.TL_account_password) {
+                changePasswordRow = rowCount++;
+                turnPasswordOffRow = rowCount++;
+                if (currentPassword.has_recovery) {
+                    changeRecoveryEmailRow = rowCount++;
+                } else {
+                    setRecoveryEmailRow = rowCount++;
+                }
+                if (waitingForEmail) {
+                    passwordEmailVerifyDetailRow = rowCount++;
+                } else {
+                    passwordEnabledDetailRow = rowCount++;
+                }
+            }
+        }
+
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+        if (passwordEntered) {
+            if (listView != null) {
+                listView.setVisibility(View.VISIBLE);
+                scrollView.setVisibility(View.INVISIBLE);
+                progressView.setVisibility(View.VISIBLE);
+                listView.setEmptyView(progressView);
+            }
+            if (passwordEditText != null) {
+                doneItem.setVisibility(View.GONE);
+                passwordEditText.setVisibility(View.INVISIBLE);
+                titleTextView.setVisibility(View.INVISIBLE);
+                bottomTextView.setVisibility(View.INVISIBLE);
+                bottomButton.setVisibility(View.INVISIBLE);
+            }
+        } else {
+            if (listView != null) {
+                listView.setEmptyView(null);
+                listView.setVisibility(View.INVISIBLE);
+                scrollView.setVisibility(View.VISIBLE);
+                progressView.setVisibility(View.INVISIBLE);
+            }
+            if (passwordEditText != null) {
+                doneItem.setVisibility(View.VISIBLE);
+                passwordEditText.setVisibility(View.VISIBLE);
+                titleTextView.setVisibility(View.VISIBLE);
+                bottomButton.setVisibility(View.VISIBLE);
+                bottomTextView.setVisibility(View.INVISIBLE);
+                bottomButton.setText(LocaleController.getString("ForgotPassword", R.string.ForgotPassword));
+                if (currentPassword.hint != null && currentPassword.hint.length() > 0) {
+                    passwordEditText.setHint(currentPassword.hint);
+                } else {
+                    passwordEditText.setHint("");
+                }
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (passwordEditText != null) {
+                            passwordEditText.requestFocus();
+                            AndroidUtilities.showKeyboard(passwordEditText);
+                        }
+                    }
+                }, 200);
+            }
+        }
+    }
+
+    private void needShowProgress() {
+        if (getParentActivity() == null || getParentActivity().isFinishing() || progressDialog != null) {
+            return;
+        }
+        progressDialog = new ProgressDialog(getParentActivity());
+        progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
+        progressDialog.setCanceledOnTouchOutside(false);
+        progressDialog.setCancelable(false);
+        progressDialog.show();
+    }
+
+    private void needHideProgress() {
+        if (progressDialog == null) {
+            return;
+        }
+        try {
+            progressDialog.dismiss();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        progressDialog = null;
+    }
+
+    private boolean isValidEmail(String text) {
+        if (text == null || text.length() < 3) {
+            return false;
+        }
+        int dot = text.lastIndexOf(".");
+        int dog = text.lastIndexOf("@");
+        return !(dot < 0 || dog < 0 || dot < dog);
+    }
+
+    private void showAlertWithText(String title, String text) {
+        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+        builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
+        builder.setTitle(title);
+        builder.setMessage(text);
+        showAlertDialog(builder);
+    }
+
+    private void setNewPassword(final boolean clear) {
+        final TLRPC.TL_account_updatePasswordSettings req = new TLRPC.TL_account_updatePasswordSettings();
+        req.current_password_hash = currentPasswordHash;
+        req.new_settings = new TLRPC.TL_account_passwordInputSettings();
+        if (clear) {
+            if (waitingForEmail && currentPassword instanceof TLRPC.TL_account_noPassword) {
+                req.new_settings.flags = 2;
+                req.new_settings.email = "";
+            } else {
+                req.new_settings.flags = 3;
+                req.new_settings.hint = "";
+                req.new_settings.new_password_hash = new byte[0];
+                req.new_settings.new_salt = new byte[0];
+                req.new_settings.email = "";
+            }
+        } else {
+            if (firstPassword != null && firstPassword.length() > 0) {
+                byte[] newPasswordBytes = null;
+                try {
+                    newPasswordBytes = firstPassword.getBytes("UTF-8");
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+
+                byte[] new_salt = currentPassword.new_salt;
+                byte[] hash = new byte[new_salt.length * 2 + newPasswordBytes.length];
+                System.arraycopy(new_salt, 0, hash, 0, new_salt.length);
+                System.arraycopy(newPasswordBytes, 0, hash, new_salt.length, newPasswordBytes.length);
+                System.arraycopy(new_salt, 0, hash, hash.length - new_salt.length, new_salt.length);
+                req.new_settings.flags |= 1;
+                req.new_settings.hint = hint;
+                req.new_settings.new_password_hash = Utilities.computeSHA256(hash, 0, hash.length);
+                req.new_settings.new_salt = new_salt;
+            }
+            if (email.length() > 0) {
+                req.new_settings.flags |= 2;
+                req.new_settings.email = email;
+            }
+        }
+        needShowProgress();
+        ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        needHideProgress();
+                        if (error == null && response instanceof TLRPC.TL_boolTrue) {
+                            if (clear) {
+                                currentPassword = null;
+                                currentPasswordHash = new byte[0];
+                                loadPasswordInfo(false);
+                                updateRows();
+                            } else {
+                                if (getParentActivity() == null) {
+                                    return;
+                                }
+                                AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                                builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialogInterface, int i) {
+                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.didSetTwoStepPassword, (Object) req.new_settings.new_password_hash);
+                                        finishFragment();
+                                    }
+                                });
+                                builder.setMessage(LocaleController.getString("YourPasswordSuccessText", R.string.YourPasswordSuccessText));
+                                builder.setTitle(LocaleController.getString("YourPasswordSuccess", R.string.YourPasswordSuccess));
+                                AlertDialog dialog = showAlertDialog(builder);
+                                if (dialog != null) {
+                                    dialog.setCanceledOnTouchOutside(false);
+                                    dialog.setCancelable(false);
+                                }
+                            }
+                        } else {
+                            if (error.text.equals("EMAIL_UNCONFIRMED")) {
+                                AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                                builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialogInterface, int i) {
+                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.didSetTwoStepPassword, (Object) req.new_settings.new_password_hash);
+                                        finishFragment();
+                                    }
+                                });
+                                builder.setMessage(LocaleController.getString("YourEmailAlmostThereText", R.string.YourEmailAlmostThereText));
+                                builder.setTitle(LocaleController.getString("YourEmailAlmostThere", R.string.YourEmailAlmostThere));
+                                AlertDialog dialog = showAlertDialog(builder);
+                                if (dialog != null) {
+                                    dialog.setCanceledOnTouchOutside(false);
+                                    dialog.setCancelable(false);
+                                }
+                            } else {
+                                if (error.text.equals("EMAIL_INVALID")) {
+                                    showAlertWithText(LocaleController.getString("AppName", R.string.AppName), LocaleController.getString("PasswordEmailInvalid", R.string.PasswordEmailInvalid));
+                                } else if (error.text.startsWith("FLOOD_WAIT")) {
+                                    int time = Utilities.parseInt(error.text);
+                                    String timeString;
+                                    if (time < 60) {
+                                        timeString = LocaleController.formatPluralString("Seconds", time);
+                                    } else {
+                                        timeString = LocaleController.formatPluralString("Minutes", time / 60);
+                                    }
+                                    showAlertWithText(LocaleController.getString("AppName", R.string.AppName), LocaleController.formatString("FloodWaitTime", R.string.FloodWaitTime, timeString));
+                                } else {
+                                    showAlertWithText(LocaleController.getString("AppName", R.string.AppName), error.text);
+                                }
+                            }
+                        }
+                    }
+                });
+            }
+        }, true, RPCRequest.RPCRequestClassGeneric | RPCRequest.RPCRequestClassFailOnServerErrors | RPCRequest.RPCRequestClassWithoutLogin);
+    }
+
+    private void processDone() {
+        if (type == 0) {
+            if (!passwordEntered) {
+                String oldPassword = passwordEditText.getText().toString();
+                if (oldPassword.length() == 0) {
+                    onPasscodeError(false);
+                    return;
+                }
+                byte[] oldPasswordBytes = null;
+                try {
+                    oldPasswordBytes = oldPassword.getBytes("UTF-8");
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+
+                needShowProgress();
+                byte[] hash = new byte[currentPassword.current_salt.length * 2 + oldPasswordBytes.length];
+                System.arraycopy(currentPassword.current_salt, 0, hash, 0, currentPassword.current_salt.length);
+                System.arraycopy(oldPasswordBytes, 0, hash, currentPassword.current_salt.length, oldPasswordBytes.length);
+                System.arraycopy(currentPassword.current_salt, 0, hash, hash.length - currentPassword.current_salt.length, currentPassword.current_salt.length);
+
+                final TLRPC.TL_account_getPasswordSettings req = new TLRPC.TL_account_getPasswordSettings();
+                req.current_password_hash = Utilities.computeSHA256(hash, 0, hash.length);
+                ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                    @Override
+                    public void run(final TLObject response, final TLRPC.TL_error error) {
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                needHideProgress();
+                                if (error == null) {
+                                    currentPasswordHash = req.current_password_hash;
+                                    passwordEntered = true;
+                                    AndroidUtilities.hideKeyboard(passwordEditText);
+                                    updateRows();
+                                } else {
+                                    if (error.text.equals("PASSWORD_HASH_INVALID")) {
+                                        onPasscodeError(true);
+                                    } else if (error.text.startsWith("FLOOD_WAIT")) {
+                                        int time = Utilities.parseInt(error.text);
+                                        String timeString;
+                                        if (time < 60) {
+                                            timeString = LocaleController.formatPluralString("Seconds", time);
+                                        } else {
+                                            timeString = LocaleController.formatPluralString("Minutes", time / 60);
+                                        }
+                                        showAlertWithText(LocaleController.getString("AppName", R.string.AppName), LocaleController.formatString("FloodWaitTime", R.string.FloodWaitTime, timeString));
+                                    } else {
+                                        showAlertWithText(LocaleController.getString("AppName", R.string.AppName), error.text);
+                                    }
+                                }
+                            }
+                        });
+                    }
+                }, true, RPCRequest.RPCRequestClassGeneric | RPCRequest.RPCRequestClassFailOnServerErrors | RPCRequest.RPCRequestClassWithoutLogin);
+            }
+        } else if (type == 1) {
+            if (passwordSetState == 0) {
+                if (passwordEditText.getText().length() == 0) {
+                    onPasscodeError(false);
+                    return;
+                }
+                titleTextView.setText(LocaleController.getString("ReEnterYourPasscode", R.string.ReEnterYourPasscode));
+                firstPassword = passwordEditText.getText().toString();
+                setPasswordSetState(1);
+            } else if (passwordSetState == 1) {
+                if (!firstPassword.equals(passwordEditText.getText().toString())) {
+                    try {
+                        Toast.makeText(getParentActivity(), LocaleController.getString("PasswordDoNotMatch", R.string.PasswordDoNotMatch), Toast.LENGTH_SHORT).show();
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    onPasscodeError(true);
+                    return;
+                }
+                setPasswordSetState(2);
+            } else if (passwordSetState == 2) {
+                hint = passwordEditText.getText().toString();
+                if (hint.toLowerCase().equals(firstPassword.toLowerCase())) {
+                    try {
+                        Toast.makeText(getParentActivity(), LocaleController.getString("PasswordAsHintError", R.string.PasswordAsHintError), Toast.LENGTH_SHORT).show();
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    onPasscodeError(false);
+                    return;
+                }
+                if (!currentPassword.has_recovery) {
+                    setPasswordSetState(3);
+                } else {
+                    email = "";
+                    setNewPassword(false);
+                }
+            } else if (passwordSetState == 3) {
+                email = passwordEditText.getText().toString();
+                if (!isValidEmail(email)) {
+                    onPasscodeError(false);
+                    return;
+                }
+                setNewPassword(false);
+            } else if (passwordSetState == 4) {
+                String code = passwordEditText.getText().toString();
+                if (code.length() == 0) {
+                    onPasscodeError(false);
+                    return;
+                }
+                TLRPC.TL_auth_recoverPassword req = new TLRPC.TL_auth_recoverPassword();
+                req.code = code;
+                ConnectionsManager.getInstance().performRpc(req, new RPCRequest.RPCRequestDelegate() {
+                    @Override
+                    public void run(TLObject response, final TLRPC.TL_error error) {
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (error == null) {
+                                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                                    builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                                        @Override
+                                        public void onClick(DialogInterface dialogInterface, int i) {
+                                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.didSetTwoStepPassword);
+                                            finishFragment();
+                                        }
+                                    });
+                                    builder.setMessage(LocaleController.getString("PasswordReset", R.string.PasswordReset));
+                                    builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                                    AlertDialog dialog = showAlertDialog(builder);
+                                    if (dialog != null) {
+                                        dialog.setCanceledOnTouchOutside(false);
+                                        dialog.setCancelable(false);
+                                    }
+                                } else {
+                                    if (error.text.startsWith("CODE_INVALID")) {
+                                        onPasscodeError(true);
+                                    } else if (error.text.startsWith("FLOOD_WAIT")) {
+                                        int time = Utilities.parseInt(error.text);
+                                        String timeString;
+                                        if (time < 60) {
+                                            timeString = LocaleController.formatPluralString("Seconds", time);
+                                        } else {
+                                            timeString = LocaleController.formatPluralString("Minutes", time / 60);
+                                        }
+                                        showAlertWithText(LocaleController.getString("AppName", R.string.AppName), LocaleController.formatString("FloodWaitTime", R.string.FloodWaitTime, timeString));
+                                    } else {
+                                        showAlertWithText(LocaleController.getString("AppName", R.string.AppName), error.text);
+                                    }
+                                }
+                            }
+                        });
+                    }
+                }, true, RPCRequest.RPCRequestClassGeneric | RPCRequest.RPCRequestClassFailOnServerErrors | RPCRequest.RPCRequestClassWithoutLogin);
+            }
+        }
+    }
+
+    private void onPasscodeError(boolean clear) {
+        if (getParentActivity() == null) {
+            return;
+        }
+        Vibrator v = (Vibrator) getParentActivity().getSystemService(Context.VIBRATOR_SERVICE);
+        if (v != null) {
+            v.vibrate(200);
+        }
+        if (clear) {
+            passwordEditText.setText("");
+        }
+        AndroidUtilities.shakeTextView(titleTextView, 2, 0);
+    }
+
+    private class ListAdapter extends BaseFragmentAdapter {
+        private Context mContext;
+
+        public ListAdapter(Context context) {
+            mContext = context;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            return i != setPasswordDetailRow && i != shadowRow && i != passwordSetupDetailRow && i != passwordEmailVerifyDetailRow && i != passwordEnabledDetailRow;
+        }
+
+        @Override
+        public int getCount() {
+            return loading || currentPassword == null ? 0 : rowCount;
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return false;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            int viewType = getItemViewType(i);
+            if (viewType == 0) {
+                if (view == null) {
+                    view = new TextSettingsCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                TextSettingsCell textCell = (TextSettingsCell) view;
+                textCell.setTextColor(0xff212121);
+                if (i == changePasswordRow) {
+                    textCell.setText(LocaleController.getString("ChangePassword", R.string.ChangePassword), true);
+                } else if (i == setPasswordRow) {
+                    textCell.setText(LocaleController.getString("SetAdditionalPassword", R.string.SetAdditionalPassword), true);
+                } else if (i == turnPasswordOffRow) {
+                    textCell.setText(LocaleController.getString("TurnPasswordOff", R.string.TurnPasswordOff), true);
+                } else if (i == changeRecoveryEmailRow) {
+                    textCell.setText(LocaleController.getString("ChangeRecoveryEmail", R.string.ChangeRecoveryEmail), abortPasswordRow != -1);
+                } else if (i == setRecoveryEmailRow) {
+                    textCell.setText(LocaleController.getString("SetRecoveryEmail", R.string.SetRecoveryEmail), false);
+                } else if (i == abortPasswordRow) {
+                    textCell.setTextColor(0xffd24949);
+                    textCell.setText(LocaleController.getString("AbortPassword", R.string.AbortPassword), false);
+                }
+            } else if (viewType == 1) {
+                if (view == null) {
+                    view = new TextInfoPrivacyCell(mContext);
+                }
+                if (i == setPasswordDetailRow) {
+                    ((TextInfoPrivacyCell) view).setText(LocaleController.getString("SetAdditionalPasswordInfo", R.string.SetAdditionalPasswordInfo));
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                } else if (i == shadowRow) {
+                    ((TextInfoPrivacyCell) view).setText("");
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                } else if (i == passwordSetupDetailRow) {
+                    ((TextInfoPrivacyCell) view).setText(LocaleController.formatString("EmailPasswordConfirmText", R.string.EmailPasswordConfirmText, currentPassword.email_unconfirmed_pattern));
+                    view.setBackgroundResource(R.drawable.greydivider_top);
+                } else if (i == passwordEnabledDetailRow) {
+                    ((TextInfoPrivacyCell) view).setText(LocaleController.getString("EnabledPasswordText", R.string.EnabledPasswordText));
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                } else if (i == passwordEmailVerifyDetailRow) {
+                    ((TextInfoPrivacyCell) view).setText(LocaleController.formatString("PendingEmailText", R.string.PendingEmailText, currentPassword.email_unconfirmed_pattern));
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                }
+            }
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            if (i == setPasswordDetailRow || i == shadowRow || i == passwordSetupDetailRow || i == passwordEnabledDetailRow || i == passwordEmailVerifyDetailRow) {
+                return 1;
+            }
+            return 0;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 2;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return loading || currentPassword == null;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/Thumbs.db b/TMessagesProj/src/main/res/drawable-hdpi/Thumbs.db
new file mode 100644
index 000000000..6d61204c7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/Thumbs.db differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/addcontact_blue.png b/TMessagesProj/src/main/res/drawable-hdpi/addcontact_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/addcontact_green.png b/TMessagesProj/src/main/res/drawable-hdpi/addcontact_green.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/addmember.png b/TMessagesProj/src/main/res/drawable-hdpi/addmember.png
new file mode 100644
index 000000000..166473d7b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/addmember.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/arrow_down_w.png b/TMessagesProj/src/main/res/drawable-hdpi/arrow_down_w.png
new file mode 100644
index 000000000..deca1e6e9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/arrow_down_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/blur_linear.png b/TMessagesProj/src/main/res/drawable-hdpi/blur_linear.png
new file mode 100644
index 000000000..7d255cf57
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/blur_linear.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/blur_linear_active.png b/TMessagesProj/src/main/res/drawable-hdpi/blur_linear_active.png
new file mode 100644
index 000000000..9103cc6c2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/blur_linear_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/blur_off.png b/TMessagesProj/src/main/res/drawable-hdpi/blur_off.png
new file mode 100644
index 000000000..172256dca
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/blur_off.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/blur_off_active.png b/TMessagesProj/src/main/res/drawable-hdpi/blur_off_active.png
new file mode 100644
index 000000000..22124bcf4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/blur_off_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/blur_radial.png b/TMessagesProj/src/main/res/drawable-hdpi/blur_radial.png
new file mode 100644
index 000000000..0e4d1b76e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/blur_radial.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/blur_radial_active.png b/TMessagesProj/src/main/res/drawable-hdpi/blur_radial_active.png
new file mode 100644
index 000000000..73725eea9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/blur_radial_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/broadcast_w.png b/TMessagesProj/src/main/res/drawable-hdpi/broadcast_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/btn_send_location_down.9.png b/TMessagesProj/src/main/res/drawable-hdpi/btn_send_location_down.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/btn_send_location_up.9.png b/TMessagesProj/src/main/res/drawable-hdpi/btn_send_location_up.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/burn.png b/TMessagesProj/src/main/res/drawable-hdpi/burn.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/cancel_b.png b/TMessagesProj/src/main/res/drawable-hdpi/cancel_b.png
new file mode 100644
index 000000000..c942d603c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/cancel_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/cancel_b_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/cancel_b_pressed.png
new file mode 100644
index 000000000..58add0c14
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/cancel_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/cancel_big.png b/TMessagesProj/src/main/res/drawable-hdpi/cancel_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/cancel_g.png b/TMessagesProj/src/main/res/drawable-hdpi/cancel_g.png
new file mode 100644
index 000000000..7c9c3decb
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/cancel_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/cancel_g_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/cancel_g_pressed.png
new file mode 100644
index 000000000..2efb6df04
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/cancel_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/check_blue.png b/TMessagesProj/src/main/res/drawable-hdpi/check_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/checkbig.png b/TMessagesProj/src/main/res/drawable-hdpi/checkbig.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/circle.png b/TMessagesProj/src/main/res/drawable-hdpi/circle.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/circle1.png b/TMessagesProj/src/main/res/drawable-hdpi/circle1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/circle_big.png b/TMessagesProj/src/main/res/drawable-hdpi/circle_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/delete_reply.png b/TMessagesProj/src/main/res/drawable-hdpi/delete_reply.png
new file mode 100644
index 000000000..213ff5b50
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/delete_reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/devices.png b/TMessagesProj/src/main/res/drawable-hdpi/devices.png
new file mode 100644
index 000000000..768704968
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/devices.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/dialogs_check.png b/TMessagesProj/src/main/res/drawable-hdpi/dialogs_check.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/dialogs_halfcheck.png b/TMessagesProj/src/main/res/drawable-hdpi/dialogs_halfcheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/dialogs_warning.png b/TMessagesProj/src/main/res/drawable-hdpi/dialogs_warning.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/doc_actions_b.png b/TMessagesProj/src/main/res/drawable-hdpi/doc_actions_b.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/doc_actions_g.png b/TMessagesProj/src/main/res/drawable-hdpi/doc_actions_g.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/doc_actions_w.png b/TMessagesProj/src/main/res/drawable-hdpi/doc_actions_w.png
new file mode 100644
index 000000000..c4690c2b7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/doc_actions_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/doc_white.png b/TMessagesProj/src/main/res/drawable-hdpi/doc_white.png
new file mode 100644
index 000000000..7086f1944
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/doc_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/doccancel_w.png b/TMessagesProj/src/main/res/drawable-hdpi/doccancel_w.png
new file mode 100644
index 000000000..7257eaa89
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/doccancel_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/docload_w.png b/TMessagesProj/src/main/res/drawable-hdpi/docload_w.png
new file mode 100644
index 000000000..b4dd7e5b4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/docload_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/docpause_w.png b/TMessagesProj/src/main/res/drawable-hdpi/docpause_w.png
new file mode 100644
index 000000000..19d7a3bbc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/docpause_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/download_b.png b/TMessagesProj/src/main/res/drawable-hdpi/download_b.png
new file mode 100644
index 000000000..a9f428125
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/download_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/download_b_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/download_b_pressed.png
new file mode 100644
index 000000000..d3a6eb918
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/download_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/download_g.png b/TMessagesProj/src/main/res/drawable-hdpi/download_g.png
new file mode 100644
index 000000000..1c5762132
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/download_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/download_g_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/download_g_pressed.png
new file mode 100644
index 000000000..c4bba83d5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/download_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating.png b/TMessagesProj/src/main/res/drawable-hdpi/floating.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating3_profile.png b/TMessagesProj/src/main/res/drawable-hdpi/floating3_profile.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating3_profile_m.png b/TMessagesProj/src/main/res/drawable-hdpi/floating3_profile_m.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating3_profile_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/floating3_profile_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating_camera.png b/TMessagesProj/src/main/res/drawable-hdpi/floating_camera.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating_m.png b/TMessagesProj/src/main/res/drawable-hdpi/floating_m.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating_message.png b/TMessagesProj/src/main/res/drawable-hdpi/floating_message.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating_pencil.png b/TMessagesProj/src/main/res/drawable-hdpi/floating_pencil.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/floating_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/floating_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/forward_blue.png b/TMessagesProj/src/main/res/drawable-hdpi/forward_blue.png
new file mode 100644
index 000000000..36d5c85d6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/forward_blue.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/foursquare.png b/TMessagesProj/src/main/res/drawable-hdpi/foursquare.png
new file mode 100644
index 000000000..64783f7ec
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/foursquare.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/greydivider_top.9.png b/TMessagesProj/src/main/res/drawable-hdpi/greydivider_top.9.png
new file mode 100644
index 000000000..4523e953c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/greydivider_top.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/header_shadow.png b/TMessagesProj/src/main/res/drawable-hdpi/header_shadow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/header_shadow_reverse.png b/TMessagesProj/src/main/res/drawable-hdpi/header_shadow_reverse.png
new file mode 100644
index 000000000..57ccb3eb2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/header_shadow_reverse.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/header_timer.png b/TMessagesProj/src/main/res/drawable-hdpi/header_timer.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/header_timer2.png b/TMessagesProj/src/main/res/drawable-hdpi/header_timer2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_attach3.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_attach3.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_attach_white.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_attach_white.png
new file mode 100644
index 000000000..60deb7005
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_attach_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_back.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_back.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_back_grey.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_back_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_doc.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_doc.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_done_gray.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_done_gray.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_copy.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_copy.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_delete.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_delete.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_forward.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_forward.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_quoteforward.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_quoteforward.png
new file mode 100644
index 000000000..dcca40094
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_fwd_quoteforward.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_new.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_new.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_other.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_other.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_reply.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_reply.png
new file mode 100644
index 000000000..2d78652e7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_search.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_ab_search.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_arrow_drop_down.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_arrow_drop_down.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_gallery.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_gallery.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_location.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_location.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_photo.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_photo.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_sticker.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_sticker.png
new file mode 100644
index 000000000..0e9e8754d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_sticker.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_video.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_attach_video.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_close_white.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_close_white.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_directory.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_directory.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_done.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_done.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_external_storage.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_external_storage.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_keyboard_w.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_keyboard_w.png
new file mode 100644
index 000000000..f0b6a5da5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_keyboard_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_launcher.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_launcher.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_lock_header.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_lock_header.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_msg_panel_hide.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_msg_panel_hide.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_msg_panel_kb_white.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_msg_panel_kb_white.png
new file mode 100644
index 000000000..4501f44d4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_msg_panel_kb_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_reply_icon.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_reply_icon.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_send.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_send.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_smile_w.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_smile_w.png
new file mode 100644
index 000000000..2f8711cd9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_smile_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_smiles_sticker.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_smiles_sticker.png
new file mode 100644
index 000000000..b6f0f7fa0
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_smiles_sticker.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_smiles_sticker_active.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_smiles_sticker_active.png
new file mode 100644
index 000000000..6fa2547d7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_smiles_sticker_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_storage.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_storage.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_storage_gallery.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_storage_gallery.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/igvideo.png b/TMessagesProj/src/main/res/drawable-hdpi/igvideo.png
new file mode 100644
index 000000000..92c22481f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/igvideo.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/intro1.png b/TMessagesProj/src/main/res/drawable-hdpi/intro1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/intro2.png b/TMessagesProj/src/main/res/drawable-hdpi/intro2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/intro3.png b/TMessagesProj/src/main/res/drawable-hdpi/intro3.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/intro4.png b/TMessagesProj/src/main/res/drawable-hdpi/intro4.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/intro5.png b/TMessagesProj/src/main/res/drawable-hdpi/intro5.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/intro6.png b/TMessagesProj/src/main/res/drawable-hdpi/intro6.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/intro7.png b/TMessagesProj/src/main/res/drawable-hdpi/intro7.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/link.png b/TMessagesProj/src/main/res/drawable-hdpi/link.png
new file mode 100644
index 000000000..5ad1fcb8f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/link.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/list_broadcast.png b/TMessagesProj/src/main/res/drawable-hdpi/list_broadcast.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/list_group.png b/TMessagesProj/src/main/res/drawable-hdpi/list_group.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/list_secret.png b/TMessagesProj/src/main/res/drawable-hdpi/list_secret.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/load_big.png b/TMessagesProj/src/main/res/drawable-hdpi/load_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/location_b.9.png b/TMessagesProj/src/main/res/drawable-hdpi/location_b.9.png
new file mode 100644
index 000000000..84e92b27b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/location_b.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/location_g.9.png b/TMessagesProj/src/main/res/drawable-hdpi/location_g.9.png
new file mode 100644
index 000000000..2c9c70da2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/location_g.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/media_doc_blue.png b/TMessagesProj/src/main/res/drawable-hdpi/media_doc_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/media_doc_green.png b/TMessagesProj/src/main/res/drawable-hdpi/media_doc_green.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/media_doc_load.png b/TMessagesProj/src/main/res/drawable-hdpi/media_doc_load.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/media_doc_pause.png b/TMessagesProj/src/main/res/drawable-hdpi/media_doc_pause.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/media_doc_red.png b/TMessagesProj/src/main/res/drawable-hdpi/media_doc_red.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/media_doc_yellow.png b/TMessagesProj/src/main/res/drawable-hdpi/media_doc_yellow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_broadcast.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_broadcast.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_contacts.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_contacts.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_help.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_help.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_invite.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_invite.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_newgroup.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_newgroup.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_secret.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_secret.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_settings.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_settings.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_shadow.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_shadow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/mic.png b/TMessagesProj/src/main/res/drawable-hdpi/mic.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/mic_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/mic_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/mic_white.png b/TMessagesProj/src/main/res/drawable-hdpi/mic_white.png
new file mode 100644
index 000000000..e2503caaf
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/mic_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_check.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_check.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_check_w.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_check_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_clock.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_clock.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_clock_photo.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_clock_photo.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_halfcheck.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_halfcheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_halfcheck_w.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_halfcheck_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2.9.png
new file mode 100644
index 000000000..be27060c5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_photo.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_photo.9.png
new file mode 100644
index 000000000..e92d7aedb
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_photo_selected.9.png
new file mode 100644
index 000000000..f88932d19
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_selected.9.png
new file mode 100644
index 000000000..8038a6dd7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_2_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3.9.png
new file mode 100644
index 000000000..126da51ca
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_photo.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_photo.9.png
new file mode 100644
index 000000000..ca48cd939
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_photo_selected.9.png
new file mode 100644
index 000000000..1db4febee
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_selected.9.png
new file mode 100644
index 000000000..2ce6d4961
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_3_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4.9.png
new file mode 100644
index 000000000..10a6a5480
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_photo.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_photo.9.png
new file mode 100644
index 000000000..ca48cd939
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_photo_selected.9.png
new file mode 100644
index 000000000..27c8b4b45
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_selected.9.png
new file mode 100644
index 000000000..92b7a7079
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_4_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_photo.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_photo.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_photo_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_in_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_in_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2.9.png
new file mode 100644
index 000000000..040d514aa
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_photo.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_photo.9.png
new file mode 100644
index 000000000..f8f07f7fb
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_photo_selected.9.png
new file mode 100644
index 000000000..3d5b1f9fa
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_selected.9.png
new file mode 100644
index 000000000..949219c33
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_2_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3.9.png
new file mode 100644
index 000000000..8ea4fa144
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_photo.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_photo.9.png
new file mode 100644
index 000000000..ae1558cc3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_photo_selected.9.png
new file mode 100644
index 000000000..8a3841ba2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_selected.9.png
new file mode 100644
index 000000000..2e3e71171
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_3_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4.9.png
new file mode 100644
index 000000000..805c55910
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_photo.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_photo.9.png
new file mode 100644
index 000000000..4053c7696
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_photo_selected.9.png
new file mode 100644
index 000000000..8a3841ba2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_selected.9.png
new file mode 100644
index 000000000..883c1ee9f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_4_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_photo.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_photo.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_photo_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/msg_out_selected.9.png b/TMessagesProj/src/main/res/drawable-hdpi/msg_out_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/mute_blue.png b/TMessagesProj/src/main/res/drawable-hdpi/mute_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/mute_grey.png b/TMessagesProj/src/main/res/drawable-hdpi/mute_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/myloc_on.png b/TMessagesProj/src/main/res/drawable-hdpi/myloc_on.png
new file mode 100644
index 000000000..0e93b8072
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/myloc_on.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/navigate.png b/TMessagesProj/src/main/res/drawable-hdpi/navigate.png
new file mode 100644
index 000000000..5bf5640aa
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/navigate.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/newmsg_divider.png b/TMessagesProj/src/main/res/drawable-hdpi/newmsg_divider.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/notification.png b/TMessagesProj/src/main/res/drawable-hdpi/notification.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pause_b.png b/TMessagesProj/src/main/res/drawable-hdpi/pause_b.png
new file mode 100644
index 000000000..a9ac7a794
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pause_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pause_b_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/pause_b_pressed.png
new file mode 100644
index 000000000..9f4b6e1db
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pause_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pause_g.png b/TMessagesProj/src/main/res/drawable-hdpi/pause_g.png
new file mode 100644
index 000000000..b8bd88ef3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pause_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pause_g_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/pause_g_pressed.png
new file mode 100644
index 000000000..19c76b441
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pause_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pause_w.png b/TMessagesProj/src/main/res/drawable-hdpi/pause_w.png
new file mode 100644
index 000000000..b3ba2dce6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pause_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pause_w2.png b/TMessagesProj/src/main/res/drawable-hdpi/pause_w2.png
new file mode 100644
index 000000000..c673dbc14
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pause_w2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pause_w2_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/pause_w2_pressed.png
new file mode 100644
index 000000000..7fdae4f8a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pause_w2_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pause_w_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/pause_w_pressed.png
new file mode 100644
index 000000000..ca28d541d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pause_w_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/phone_grey.png b/TMessagesProj/src/main/res/drawable-hdpi/phone_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/photo_text.png b/TMessagesProj/src/main/res/drawable-hdpi/photo_text.png
new file mode 100644
index 000000000..1009bbd79
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/photo_text.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/photo_text2.png b/TMessagesProj/src/main/res/drawable-hdpi/photo_text2.png
new file mode 100644
index 000000000..9e0fc848b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/photo_text2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/photo_tools.png b/TMessagesProj/src/main/res/drawable-hdpi/photo_tools.png
new file mode 100644
index 000000000..195c6626f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/photo_tools.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/photo_w.png b/TMessagesProj/src/main/res/drawable-hdpi/photo_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/photocheck.png b/TMessagesProj/src/main/res/drawable-hdpi/photocheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/phototime_white.9.png b/TMessagesProj/src/main/res/drawable-hdpi/phototime_white.9.png
new file mode 100644
index 000000000..399fd54c3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/phototime_white.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/pin.png b/TMessagesProj/src/main/res/drawable-hdpi/pin.png
new file mode 100644
index 000000000..386acb228
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/pin.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/place_x.png b/TMessagesProj/src/main/res/drawable-hdpi/place_x.png
new file mode 100644
index 000000000..c4ee065d3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/place_x.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/play_big.png b/TMessagesProj/src/main/res/drawable-hdpi/play_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/play_w.png b/TMessagesProj/src/main/res/drawable-hdpi/play_w.png
new file mode 100644
index 000000000..3b9bac668
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/play_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/play_w2.png b/TMessagesProj/src/main/res/drawable-hdpi/play_w2.png
new file mode 100644
index 000000000..330da7e1e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/play_w2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/play_w2_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/play_w2_pressed.png
new file mode 100644
index 000000000..7b7018e2a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/play_w2_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/play_w_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/play_w_pressed.png
new file mode 100644
index 000000000..7261585f5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/play_w_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/player1.png b/TMessagesProj/src/main/res/drawable-hdpi/player1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/player1_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/player1_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/player2.png b/TMessagesProj/src/main/res/drawable-hdpi/player2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/player2_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/player2_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/plus.png b/TMessagesProj/src/main/res/drawable-hdpi/plus.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/popup_fixed.9.png b/TMessagesProj/src/main/res/drawable-hdpi/popup_fixed.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/profile_list.png b/TMessagesProj/src/main/res/drawable-hdpi/profile_list.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/rec.png b/TMessagesProj/src/main/res/drawable-hdpi/rec.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/reply.png b/TMessagesProj/src/main/res/drawable-hdpi/reply.png
new file mode 100644
index 000000000..98db79e65
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/round_check2.png b/TMessagesProj/src/main/res/drawable-hdpi/round_check2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/round_grey.png b/TMessagesProj/src/main/res/drawable-hdpi/round_grey.png
new file mode 100644
index 000000000..6f9f3f215
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/round_grey.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/selectphoto_large.png b/TMessagesProj/src/main/res/drawable-hdpi/selectphoto_large.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/slidearrow.png b/TMessagesProj/src/main/res/drawable-hdpi/slidearrow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/system_loader1.png b/TMessagesProj/src/main/res/drawable-hdpi/system_loader1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/system_loader2.png b/TMessagesProj/src/main/res/drawable-hdpi/system_loader2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/system_white_3.9.png b/TMessagesProj/src/main/res/drawable-hdpi/system_white_3.9.png
new file mode 100644
index 000000000..bfc0f1eaf
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/system_white_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/system_white_4.9.png b/TMessagesProj/src/main/res/drawable-hdpi/system_white_4.9.png
new file mode 100644
index 000000000..8804dfd59
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/system_white_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/tip1.png b/TMessagesProj/src/main/res/drawable-hdpi/tip1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/tip2.png b/TMessagesProj/src/main/res/drawable-hdpi/tip2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/tool_blur.png b/TMessagesProj/src/main/res/drawable-hdpi/tool_blur.png
new file mode 100644
index 000000000..c8614ecb9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/tool_blur.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/videolapse.png b/TMessagesProj/src/main/res/drawable-hdpi/videolapse.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/videotrimmer.png b/TMessagesProj/src/main/res/drawable-hdpi/videotrimmer.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/Thumbs.db b/TMessagesProj/src/main/res/drawable-mdpi/Thumbs.db
new file mode 100644
index 000000000..0774feec4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/Thumbs.db differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/addcontact_blue.png b/TMessagesProj/src/main/res/drawable-mdpi/addcontact_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/addcontact_green.png b/TMessagesProj/src/main/res/drawable-mdpi/addcontact_green.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/addmember.png b/TMessagesProj/src/main/res/drawable-mdpi/addmember.png
new file mode 100644
index 000000000..439b82d41
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/addmember.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/arrow_down_w.png b/TMessagesProj/src/main/res/drawable-mdpi/arrow_down_w.png
new file mode 100644
index 000000000..02ad9766d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/arrow_down_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/blur_linear.png b/TMessagesProj/src/main/res/drawable-mdpi/blur_linear.png
new file mode 100644
index 000000000..06d029c46
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/blur_linear.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/blur_linear_active.png b/TMessagesProj/src/main/res/drawable-mdpi/blur_linear_active.png
new file mode 100644
index 000000000..c3ffe1bef
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/blur_linear_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/blur_off.png b/TMessagesProj/src/main/res/drawable-mdpi/blur_off.png
new file mode 100644
index 000000000..424aaa5b4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/blur_off.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/blur_off_active.png b/TMessagesProj/src/main/res/drawable-mdpi/blur_off_active.png
new file mode 100644
index 000000000..5dfc12a2b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/blur_off_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/blur_radial.png b/TMessagesProj/src/main/res/drawable-mdpi/blur_radial.png
new file mode 100644
index 000000000..a30d6619b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/blur_radial.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/blur_radial_active.png b/TMessagesProj/src/main/res/drawable-mdpi/blur_radial_active.png
new file mode 100644
index 000000000..a385ca60a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/blur_radial_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/broadcast_w.png b/TMessagesProj/src/main/res/drawable-mdpi/broadcast_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/btn_send_location_down.9.png b/TMessagesProj/src/main/res/drawable-mdpi/btn_send_location_down.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/btn_send_location_up.9.png b/TMessagesProj/src/main/res/drawable-mdpi/btn_send_location_up.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/burn.png b/TMessagesProj/src/main/res/drawable-mdpi/burn.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/cancel_b.png b/TMessagesProj/src/main/res/drawable-mdpi/cancel_b.png
new file mode 100644
index 000000000..b0dd70ea0
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/cancel_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/cancel_b_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/cancel_b_pressed.png
new file mode 100644
index 000000000..412153274
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/cancel_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/cancel_big.png b/TMessagesProj/src/main/res/drawable-mdpi/cancel_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/cancel_g.png b/TMessagesProj/src/main/res/drawable-mdpi/cancel_g.png
new file mode 100644
index 000000000..43b0a71e4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/cancel_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/cancel_g_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/cancel_g_pressed.png
new file mode 100644
index 000000000..4942c02cb
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/cancel_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/check_blue.png b/TMessagesProj/src/main/res/drawable-mdpi/check_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/checkbig.png b/TMessagesProj/src/main/res/drawable-mdpi/checkbig.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/circle.png b/TMessagesProj/src/main/res/drawable-mdpi/circle.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/circle1.png b/TMessagesProj/src/main/res/drawable-mdpi/circle1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/circle_big.png b/TMessagesProj/src/main/res/drawable-mdpi/circle_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/delete_reply.png b/TMessagesProj/src/main/res/drawable-mdpi/delete_reply.png
new file mode 100644
index 000000000..2fd1c1ac9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/delete_reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/devices.png b/TMessagesProj/src/main/res/drawable-mdpi/devices.png
new file mode 100644
index 000000000..b6bd7a72c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/devices.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/dialogs_check.png b/TMessagesProj/src/main/res/drawable-mdpi/dialogs_check.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/dialogs_halfcheck.png b/TMessagesProj/src/main/res/drawable-mdpi/dialogs_halfcheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/dialogs_warning.png b/TMessagesProj/src/main/res/drawable-mdpi/dialogs_warning.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/doc_actions_b.png b/TMessagesProj/src/main/res/drawable-mdpi/doc_actions_b.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/doc_actions_g.png b/TMessagesProj/src/main/res/drawable-mdpi/doc_actions_g.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/doc_actions_w.png b/TMessagesProj/src/main/res/drawable-mdpi/doc_actions_w.png
new file mode 100644
index 000000000..5a569bfd8
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/doc_actions_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/doc_white.png b/TMessagesProj/src/main/res/drawable-mdpi/doc_white.png
new file mode 100644
index 000000000..fa2a5fed0
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/doc_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/doccancel_w.png b/TMessagesProj/src/main/res/drawable-mdpi/doccancel_w.png
new file mode 100644
index 000000000..148214310
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/doccancel_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/docload_w.png b/TMessagesProj/src/main/res/drawable-mdpi/docload_w.png
new file mode 100644
index 000000000..f57f98acf
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/docload_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/docpause_w.png b/TMessagesProj/src/main/res/drawable-mdpi/docpause_w.png
new file mode 100644
index 000000000..26bc83de9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/docpause_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/download_b.png b/TMessagesProj/src/main/res/drawable-mdpi/download_b.png
new file mode 100644
index 000000000..7c3fb80ce
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/download_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/download_b_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/download_b_pressed.png
new file mode 100644
index 000000000..7e5385dd7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/download_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/download_g.png b/TMessagesProj/src/main/res/drawable-mdpi/download_g.png
new file mode 100644
index 000000000..2b6c9b925
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/download_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/download_g_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/download_g_pressed.png
new file mode 100644
index 000000000..a1270b164
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/download_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating.png b/TMessagesProj/src/main/res/drawable-mdpi/floating.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating3_profile.png b/TMessagesProj/src/main/res/drawable-mdpi/floating3_profile.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating3_profile_m.png b/TMessagesProj/src/main/res/drawable-mdpi/floating3_profile_m.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating3_profile_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/floating3_profile_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating_camera.png b/TMessagesProj/src/main/res/drawable-mdpi/floating_camera.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating_m.png b/TMessagesProj/src/main/res/drawable-mdpi/floating_m.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating_message.png b/TMessagesProj/src/main/res/drawable-mdpi/floating_message.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating_pencil.png b/TMessagesProj/src/main/res/drawable-mdpi/floating_pencil.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/floating_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/floating_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/forward_blue.png b/TMessagesProj/src/main/res/drawable-mdpi/forward_blue.png
new file mode 100644
index 000000000..7f4ec885e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/forward_blue.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/foursquare.png b/TMessagesProj/src/main/res/drawable-mdpi/foursquare.png
new file mode 100644
index 000000000..e13d17641
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/foursquare.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/greydivider_top.9.png b/TMessagesProj/src/main/res/drawable-mdpi/greydivider_top.9.png
new file mode 100644
index 000000000..1faeb2636
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/greydivider_top.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/header_shadow.png b/TMessagesProj/src/main/res/drawable-mdpi/header_shadow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/header_shadow_reverse.png b/TMessagesProj/src/main/res/drawable-mdpi/header_shadow_reverse.png
new file mode 100644
index 000000000..cab866e17
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/header_shadow_reverse.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/header_timer.png b/TMessagesProj/src/main/res/drawable-mdpi/header_timer.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/header_timer2.png b/TMessagesProj/src/main/res/drawable-mdpi/header_timer2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_attach3.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_attach3.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_attach_white.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_attach_white.png
new file mode 100644
index 000000000..45f193dce
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_attach_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_back.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_back.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_back_grey.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_back_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_doc.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_doc.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_done_gray.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_done_gray.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_copy.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_copy.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_delete.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_delete.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_forward.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_forward.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_quoteforward.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_quoteforward.png
new file mode 100644
index 000000000..9ab6408d5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_fwd_quoteforward.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_new.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_new.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_other.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_other.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_reply.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_reply.png
new file mode 100644
index 000000000..a8d829411
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_search.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_ab_search.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_arrow_drop_down.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_arrow_drop_down.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_gallery.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_gallery.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_location.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_location.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_photo.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_photo.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_sticker.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_sticker.png
new file mode 100644
index 000000000..327314d8d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_sticker.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_video.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_attach_video.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_close_white.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_close_white.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_directory.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_directory.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_done.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_done.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_external_storage.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_external_storage.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_keyboard_w.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_keyboard_w.png
new file mode 100644
index 000000000..1f4614aab
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_keyboard_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_launcher.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_launcher.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_lock_header.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_lock_header.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_msg_panel_hide.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_msg_panel_hide.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_msg_panel_kb_white.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_msg_panel_kb_white.png
new file mode 100644
index 000000000..685430df6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_msg_panel_kb_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_msg_panel_smiles.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_msg_panel_smiles.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_reply_icon.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_reply_icon.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_send.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_send.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_smile_w.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_smile_w.png
new file mode 100644
index 000000000..a110abc10
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_smile_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_smiles_sticker.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_smiles_sticker.png
new file mode 100644
index 000000000..b76d05515
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_smiles_sticker.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_smiles_sticker_active.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_smiles_sticker_active.png
new file mode 100644
index 000000000..056a2d0d5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_smiles_sticker_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_storage.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_storage.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_storage_gallery.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_storage_gallery.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/igvideo.png b/TMessagesProj/src/main/res/drawable-mdpi/igvideo.png
new file mode 100644
index 000000000..e7b93b3b7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/igvideo.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/intro1.png b/TMessagesProj/src/main/res/drawable-mdpi/intro1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/intro2.png b/TMessagesProj/src/main/res/drawable-mdpi/intro2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/intro3.png b/TMessagesProj/src/main/res/drawable-mdpi/intro3.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/intro4.png b/TMessagesProj/src/main/res/drawable-mdpi/intro4.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/intro5.png b/TMessagesProj/src/main/res/drawable-mdpi/intro5.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/intro6.png b/TMessagesProj/src/main/res/drawable-mdpi/intro6.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/intro7.png b/TMessagesProj/src/main/res/drawable-mdpi/intro7.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/link.png b/TMessagesProj/src/main/res/drawable-mdpi/link.png
new file mode 100644
index 000000000..24125b57e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/link.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/list_broadcast.png b/TMessagesProj/src/main/res/drawable-mdpi/list_broadcast.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/list_group.png b/TMessagesProj/src/main/res/drawable-mdpi/list_group.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/list_secret.png b/TMessagesProj/src/main/res/drawable-mdpi/list_secret.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/load_big.png b/TMessagesProj/src/main/res/drawable-mdpi/load_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/location_b.9.png b/TMessagesProj/src/main/res/drawable-mdpi/location_b.9.png
new file mode 100644
index 000000000..3f0abf8b4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/location_b.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/location_g.9.png b/TMessagesProj/src/main/res/drawable-mdpi/location_g.9.png
new file mode 100644
index 000000000..d77aa911d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/location_g.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/media_doc_blue.png b/TMessagesProj/src/main/res/drawable-mdpi/media_doc_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/media_doc_green.png b/TMessagesProj/src/main/res/drawable-mdpi/media_doc_green.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/media_doc_load.png b/TMessagesProj/src/main/res/drawable-mdpi/media_doc_load.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/media_doc_pause.png b/TMessagesProj/src/main/res/drawable-mdpi/media_doc_pause.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/media_doc_red.png b/TMessagesProj/src/main/res/drawable-mdpi/media_doc_red.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/media_doc_yellow.png b/TMessagesProj/src/main/res/drawable-mdpi/media_doc_yellow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_broadcast.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_broadcast.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_contacts.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_contacts.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_help.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_help.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_invite.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_invite.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_newgroup.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_newgroup.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_secret.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_secret.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_settings.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_settings.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_shadow.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_shadow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/mic.png b/TMessagesProj/src/main/res/drawable-mdpi/mic.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed_white.png b/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed_white.png
new file mode 100644
index 000000000..6cf907a54
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_check.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_check.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_check_w.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_check_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_clock.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_clock.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_clock_photo.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_clock_photo.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_halfcheck.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_halfcheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_halfcheck_w.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_halfcheck_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2.9.png
new file mode 100644
index 000000000..e4654d7e4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_photo.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_photo.9.png
new file mode 100644
index 000000000..c5c6aa595
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_photo_selected.9.png
new file mode 100644
index 000000000..0658e94ae
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_selected.9.png
new file mode 100644
index 000000000..b953c16a6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_2_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3.9.png
new file mode 100644
index 000000000..6faa43b89
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_photo.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_photo.9.png
new file mode 100644
index 000000000..3d4b033b2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_photo_selected.9.png
new file mode 100644
index 000000000..e0ec507d6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_selected.9.png
new file mode 100644
index 000000000..477f6d431
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_3_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4.9.png
new file mode 100644
index 000000000..f29a906be
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_photo.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_photo.9.png
new file mode 100644
index 000000000..3d4b033b2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_photo_selected.9.png
new file mode 100644
index 000000000..dbb628093
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_selected.9.png
new file mode 100644
index 000000000..6d0783582
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_4_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_photo.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_photo.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_photo_2.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_photo_2.9.png
new file mode 100644
index 000000000..c5c6aa595
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_photo_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_photo_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_in_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_in_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2.9.png
new file mode 100644
index 000000000..0fd13455d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_photo.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_photo.9.png
new file mode 100644
index 000000000..ad4ad9ce2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_photo_selected.9.png
new file mode 100644
index 000000000..734f94360
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_selected.9.png
new file mode 100644
index 000000000..a571ac4c1
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_2_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3.9.png
new file mode 100644
index 000000000..21496a893
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_photo.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_photo.9.png
new file mode 100644
index 000000000..cda4fc770
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_photo_selected.9.png
new file mode 100644
index 000000000..93ba5db27
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_selected.9.png
new file mode 100644
index 000000000..5991d7b60
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_3_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4.9.png
new file mode 100644
index 000000000..1ffbab37f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_photo.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_photo.9.png
new file mode 100644
index 000000000..5cc70b936
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_photo_selected.9.png
new file mode 100644
index 000000000..93ba5db27
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_selected.9.png
new file mode 100644
index 000000000..44f9706bc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_4_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_photo.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_photo.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_photo_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/msg_out_selected.9.png b/TMessagesProj/src/main/res/drawable-mdpi/msg_out_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/mute_blue.png b/TMessagesProj/src/main/res/drawable-mdpi/mute_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/mute_grey.png b/TMessagesProj/src/main/res/drawable-mdpi/mute_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/myloc_on.png b/TMessagesProj/src/main/res/drawable-mdpi/myloc_on.png
new file mode 100644
index 000000000..a86dd1570
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/myloc_on.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/navigate.png b/TMessagesProj/src/main/res/drawable-mdpi/navigate.png
new file mode 100644
index 000000000..872d18fa7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/navigate.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/newmsg_divider.png b/TMessagesProj/src/main/res/drawable-mdpi/newmsg_divider.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/notification.png b/TMessagesProj/src/main/res/drawable-mdpi/notification.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pause_b.png b/TMessagesProj/src/main/res/drawable-mdpi/pause_b.png
new file mode 100644
index 000000000..4d74e901d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pause_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pause_b_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/pause_b_pressed.png
new file mode 100644
index 000000000..e300fbbca
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pause_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pause_g.png b/TMessagesProj/src/main/res/drawable-mdpi/pause_g.png
new file mode 100644
index 000000000..a95855259
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pause_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pause_g_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/pause_g_pressed.png
new file mode 100644
index 000000000..82e15e54d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pause_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pause_w.png b/TMessagesProj/src/main/res/drawable-mdpi/pause_w.png
new file mode 100644
index 000000000..a6416a69e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pause_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pause_w2.png b/TMessagesProj/src/main/res/drawable-mdpi/pause_w2.png
new file mode 100644
index 000000000..a5d419e71
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pause_w2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pause_w2_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/pause_w2_pressed.png
new file mode 100644
index 000000000..03dad7468
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pause_w2_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pause_w_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/pause_w_pressed.png
new file mode 100644
index 000000000..b12e36df9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pause_w_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/phone_grey.png b/TMessagesProj/src/main/res/drawable-mdpi/phone_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/photo_text.png b/TMessagesProj/src/main/res/drawable-mdpi/photo_text.png
new file mode 100644
index 000000000..b1301d532
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/photo_text.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/photo_text2.png b/TMessagesProj/src/main/res/drawable-mdpi/photo_text2.png
new file mode 100644
index 000000000..bbc1835bd
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/photo_text2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/photo_tools.png b/TMessagesProj/src/main/res/drawable-mdpi/photo_tools.png
new file mode 100644
index 000000000..86296a075
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/photo_tools.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/photo_w.png b/TMessagesProj/src/main/res/drawable-mdpi/photo_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/photocheck.png b/TMessagesProj/src/main/res/drawable-mdpi/photocheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/phototime_white.9.png b/TMessagesProj/src/main/res/drawable-mdpi/phototime_white.9.png
new file mode 100644
index 000000000..0763f2482
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/phototime_white.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/pin.png b/TMessagesProj/src/main/res/drawable-mdpi/pin.png
new file mode 100644
index 000000000..ce126ca8c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/pin.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/place_x.png b/TMessagesProj/src/main/res/drawable-mdpi/place_x.png
new file mode 100644
index 000000000..3e4869bf6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/place_x.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/play_big.png b/TMessagesProj/src/main/res/drawable-mdpi/play_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/play_w.png b/TMessagesProj/src/main/res/drawable-mdpi/play_w.png
new file mode 100644
index 000000000..ca0df62f6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/play_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/play_w2.png b/TMessagesProj/src/main/res/drawable-mdpi/play_w2.png
new file mode 100644
index 000000000..5fba3f1b9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/play_w2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/play_w2_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/play_w2_pressed.png
new file mode 100644
index 000000000..7b9fc05b3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/play_w2_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/play_w_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/play_w_pressed.png
new file mode 100644
index 000000000..b8b601b8a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/play_w_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/player1.png b/TMessagesProj/src/main/res/drawable-mdpi/player1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/player1_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/player1_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/player2.png b/TMessagesProj/src/main/res/drawable-mdpi/player2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/player2_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/player2_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/plus.png b/TMessagesProj/src/main/res/drawable-mdpi/plus.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/popup_fixed.9.png b/TMessagesProj/src/main/res/drawable-mdpi/popup_fixed.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/profile_list.png b/TMessagesProj/src/main/res/drawable-mdpi/profile_list.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/rec.png b/TMessagesProj/src/main/res/drawable-mdpi/rec.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/reply.png b/TMessagesProj/src/main/res/drawable-mdpi/reply.png
new file mode 100644
index 000000000..7d71990f7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/round_check2.png b/TMessagesProj/src/main/res/drawable-mdpi/round_check2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/round_grey.png b/TMessagesProj/src/main/res/drawable-mdpi/round_grey.png
new file mode 100644
index 000000000..7753080de
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/round_grey.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/selectphoto_large.png b/TMessagesProj/src/main/res/drawable-mdpi/selectphoto_large.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/slidearrow.png b/TMessagesProj/src/main/res/drawable-mdpi/slidearrow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/system_loader1.png b/TMessagesProj/src/main/res/drawable-mdpi/system_loader1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/system_loader2.png b/TMessagesProj/src/main/res/drawable-mdpi/system_loader2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/system_white_3.9.png b/TMessagesProj/src/main/res/drawable-mdpi/system_white_3.9.png
new file mode 100644
index 000000000..58c70b4b4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/system_white_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/system_white_4.9.png b/TMessagesProj/src/main/res/drawable-mdpi/system_white_4.9.png
new file mode 100644
index 000000000..61c067e91
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/system_white_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/tip1.png b/TMessagesProj/src/main/res/drawable-mdpi/tip1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/tip2.png b/TMessagesProj/src/main/res/drawable-mdpi/tip2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/tool_blur.png b/TMessagesProj/src/main/res/drawable-mdpi/tool_blur.png
new file mode 100644
index 000000000..9c0592331
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/tool_blur.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/videolapse.png b/TMessagesProj/src/main/res/drawable-mdpi/videolapse.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/videotrimmer.png b/TMessagesProj/src/main/res/drawable-mdpi/videotrimmer.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/Thumbs.db b/TMessagesProj/src/main/res/drawable-xhdpi/Thumbs.db
new file mode 100644
index 000000000..7391545ef
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/Thumbs.db differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/addcontact_blue.png b/TMessagesProj/src/main/res/drawable-xhdpi/addcontact_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/addcontact_green.png b/TMessagesProj/src/main/res/drawable-xhdpi/addcontact_green.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/addmember.png b/TMessagesProj/src/main/res/drawable-xhdpi/addmember.png
new file mode 100644
index 000000000..8440ca18f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/addmember.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/arrow_down_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/arrow_down_w.png
new file mode 100644
index 000000000..a94e1d57b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/arrow_down_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/blur_linear.png b/TMessagesProj/src/main/res/drawable-xhdpi/blur_linear.png
new file mode 100644
index 000000000..94ab2c803
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/blur_linear.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/blur_linear_active.png b/TMessagesProj/src/main/res/drawable-xhdpi/blur_linear_active.png
new file mode 100644
index 000000000..a7d39b91c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/blur_linear_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/blur_off.png b/TMessagesProj/src/main/res/drawable-xhdpi/blur_off.png
new file mode 100644
index 000000000..06001a130
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/blur_off.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/blur_off_active.png b/TMessagesProj/src/main/res/drawable-xhdpi/blur_off_active.png
new file mode 100644
index 000000000..c37ef8d8e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/blur_off_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/blur_radial.png b/TMessagesProj/src/main/res/drawable-xhdpi/blur_radial.png
new file mode 100644
index 000000000..10caa4fa4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/blur_radial.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/blur_radial_active.png b/TMessagesProj/src/main/res/drawable-xhdpi/blur_radial_active.png
new file mode 100644
index 000000000..86585c39a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/blur_radial_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/broadcast_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/broadcast_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/btn_send_location_down.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/btn_send_location_down.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/btn_send_location_up.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/btn_send_location_up.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/burn.png b/TMessagesProj/src/main/res/drawable-xhdpi/burn.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/cancel_b.png b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_b.png
new file mode 100644
index 000000000..36c6390ed
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/cancel_b_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_b_pressed.png
new file mode 100644
index 000000000..79f951727
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/cancel_big.png b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/cancel_g.png b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_g.png
new file mode 100644
index 000000000..a77e504f2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/cancel_g_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_g_pressed.png
new file mode 100644
index 000000000..dea2364da
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/cancel_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/check_blue.png b/TMessagesProj/src/main/res/drawable-xhdpi/check_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/checkbig.png b/TMessagesProj/src/main/res/drawable-xhdpi/checkbig.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/circle.png b/TMessagesProj/src/main/res/drawable-xhdpi/circle.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/circle1.png b/TMessagesProj/src/main/res/drawable-xhdpi/circle1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/circle_big.png b/TMessagesProj/src/main/res/drawable-xhdpi/circle_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/delete_reply.png b/TMessagesProj/src/main/res/drawable-xhdpi/delete_reply.png
new file mode 100644
index 000000000..ce9fd147b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/delete_reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/devices.png b/TMessagesProj/src/main/res/drawable-xhdpi/devices.png
new file mode 100644
index 000000000..9b5663ff9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/devices.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_check.png b/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_check.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_halfcheck.png b/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_halfcheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_warning.png b/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_warning.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/doc_actions_b.png b/TMessagesProj/src/main/res/drawable-xhdpi/doc_actions_b.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/doc_actions_g.png b/TMessagesProj/src/main/res/drawable-xhdpi/doc_actions_g.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/doc_actions_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/doc_actions_w.png
new file mode 100644
index 000000000..e2493fb59
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/doc_actions_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/doc_white.png b/TMessagesProj/src/main/res/drawable-xhdpi/doc_white.png
new file mode 100644
index 000000000..056dffe86
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/doc_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/doccancel_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/doccancel_w.png
new file mode 100644
index 000000000..14a6162cc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/doccancel_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/docload_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/docload_w.png
new file mode 100644
index 000000000..9af1ce09d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/docload_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/docpause_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/docpause_w.png
new file mode 100644
index 000000000..8f596c1ad
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/docpause_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/download_b.png b/TMessagesProj/src/main/res/drawable-xhdpi/download_b.png
new file mode 100644
index 000000000..5d114b083
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/download_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/download_b_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/download_b_pressed.png
new file mode 100644
index 000000000..671f591b2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/download_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/download_g.png b/TMessagesProj/src/main/res/drawable-xhdpi/download_g.png
new file mode 100644
index 000000000..1eaf6cfcd
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/download_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/download_g_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/download_g_pressed.png
new file mode 100644
index 000000000..4d785fbbe
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/download_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating3_profile.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating3_profile.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating3_profile_m.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating3_profile_m.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating3_profile_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating3_profile_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating_camera.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating_camera.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating_m.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating_m.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating_message.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating_message.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating_pencil.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating_pencil.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/floating_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/floating_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/forward_blue.png b/TMessagesProj/src/main/res/drawable-xhdpi/forward_blue.png
new file mode 100644
index 000000000..40af0d3dc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/forward_blue.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/foursquare.png b/TMessagesProj/src/main/res/drawable-xhdpi/foursquare.png
new file mode 100644
index 000000000..2b5bb36dc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/foursquare.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/greydivider_top.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/greydivider_top.9.png
new file mode 100644
index 000000000..aeb9cc803
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/greydivider_top.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/header_shadow.png b/TMessagesProj/src/main/res/drawable-xhdpi/header_shadow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/header_shadow_reverse.png b/TMessagesProj/src/main/res/drawable-xhdpi/header_shadow_reverse.png
new file mode 100644
index 000000000..b8ab34806
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/header_shadow_reverse.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/header_timer.png b/TMessagesProj/src/main/res/drawable-xhdpi/header_timer.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/header_timer2.png b/TMessagesProj/src/main/res/drawable-xhdpi/header_timer2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_attach3.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_attach3.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_attach_white.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_attach_white.png
new file mode 100644
index 000000000..04e501f72
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_attach_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_back.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_back.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_back_grey.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_back_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_doc.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_doc.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_done_gray.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_done_gray.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_copy.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_copy.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_delete.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_delete.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_forward.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_forward.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_quoteforward.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_quoteforward.png
new file mode 100644
index 000000000..192835fe6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_fwd_quoteforward.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_new.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_new.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_other.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_other.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_reply.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_reply.png
new file mode 100644
index 000000000..1b6cbc5b4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_search.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_ab_search.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_arrow_drop_down.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_arrow_drop_down.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_gallery.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_gallery.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_location.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_location.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_photo.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_photo.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_sticker.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_sticker.png
new file mode 100644
index 000000000..4d46fea74
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_sticker.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_video.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_attach_video.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_close_white.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_close_white.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_directory.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_directory.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_done.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_done.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_external_storage.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_external_storage.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_keyboard_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_keyboard_w.png
new file mode 100644
index 000000000..4866b74e4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_keyboard_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_launcher.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_launcher.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_lock_header.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_lock_header.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_msg_panel_hide.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_msg_panel_hide.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_msg_panel_kb_white.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_msg_panel_kb_white.png
new file mode 100644
index 000000000..2e2dbeb1e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_msg_panel_kb_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_reply_icon.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_reply_icon.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_send.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_send.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_smile_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_smile_w.png
new file mode 100644
index 000000000..f03eb4053
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_smile_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_smiles_sticker.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_smiles_sticker.png
new file mode 100644
index 000000000..8f423142f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_smiles_sticker.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_smiles_sticker_active.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_smiles_sticker_active.png
new file mode 100644
index 000000000..b2141d6cb
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_smiles_sticker_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_storage.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_storage.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_storage_gallery.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_storage_gallery.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/igvideo.png b/TMessagesProj/src/main/res/drawable-xhdpi/igvideo.png
new file mode 100644
index 000000000..bad393640
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/igvideo.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/intro1.png b/TMessagesProj/src/main/res/drawable-xhdpi/intro1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/intro2.png b/TMessagesProj/src/main/res/drawable-xhdpi/intro2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/intro3.png b/TMessagesProj/src/main/res/drawable-xhdpi/intro3.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/intro4.png b/TMessagesProj/src/main/res/drawable-xhdpi/intro4.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/intro5.png b/TMessagesProj/src/main/res/drawable-xhdpi/intro5.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/intro6.png b/TMessagesProj/src/main/res/drawable-xhdpi/intro6.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/intro7.png b/TMessagesProj/src/main/res/drawable-xhdpi/intro7.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/link.png b/TMessagesProj/src/main/res/drawable-xhdpi/link.png
new file mode 100644
index 000000000..ba82f35b9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/link.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/list_broadcast.png b/TMessagesProj/src/main/res/drawable-xhdpi/list_broadcast.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/list_group.png b/TMessagesProj/src/main/res/drawable-xhdpi/list_group.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/list_secret.png b/TMessagesProj/src/main/res/drawable-xhdpi/list_secret.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/load_big.png b/TMessagesProj/src/main/res/drawable-xhdpi/load_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/location_b.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/location_b.9.png
new file mode 100644
index 000000000..ade7b9ef9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/location_b.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/location_g.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/location_g.9.png
new file mode 100644
index 000000000..bbaeb93c4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/location_g.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_blue.png b/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_green.png b/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_green.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_load.png b/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_load.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_pause.png b/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_pause.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_red.png b/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_red.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_yellow.png b/TMessagesProj/src/main/res/drawable-xhdpi/media_doc_yellow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_broadcast.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_broadcast.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_contacts.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_contacts.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_help.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_help.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_invite.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_invite.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_newgroup.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_newgroup.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_secret.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_secret.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_settings.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_settings.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_shadow.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_shadow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/mic.png b/TMessagesProj/src/main/res/drawable-xhdpi/mic.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/mic_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/mic_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/mic_white.png b/TMessagesProj/src/main/res/drawable-xhdpi/mic_white.png
new file mode 100644
index 000000000..271ace800
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/mic_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_check.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_check.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_check_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_check_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_clock.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_clock.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_clock_photo.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_clock_photo.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_halfcheck.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_halfcheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_halfcheck_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_halfcheck_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2.9.png
new file mode 100644
index 000000000..c5e2544c2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_photo.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_photo.9.png
new file mode 100644
index 000000000..248b9ba2b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_photo_selected.9.png
new file mode 100644
index 000000000..91dabc475
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_selected.9.png
new file mode 100644
index 000000000..86018775b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_2_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3.9.png
new file mode 100644
index 000000000..3ba14c925
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_photo.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_photo.9.png
new file mode 100644
index 000000000..028f02758
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_photo_selected.9.png
new file mode 100644
index 000000000..86d6d825b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_selected.9.png
new file mode 100644
index 000000000..accc1bd88
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_3_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4.9.png
new file mode 100644
index 000000000..e0974209b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_photo.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_photo.9.png
new file mode 100644
index 000000000..028f02758
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_photo_selected.9.png
new file mode 100644
index 000000000..736021487
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_selected.9.png
new file mode 100644
index 000000000..5710145a9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_4_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_photo.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_photo.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_photo_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_in_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2.9.png
new file mode 100644
index 000000000..5f63323c3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_photo.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_photo.9.png
new file mode 100644
index 000000000..c452372f3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_photo_selected.9.png
new file mode 100644
index 000000000..faa2daa55
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_selected.9.png
new file mode 100644
index 000000000..1ce9036c8
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_2_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3.9.png
new file mode 100644
index 000000000..aa727c8c1
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_photo.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_photo.9.png
new file mode 100644
index 000000000..944aecaea
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_photo_selected.9.png
new file mode 100644
index 000000000..de5ebeb3b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_selected.9.png
new file mode 100644
index 000000000..f7d49ce2c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_3_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4.9.png
new file mode 100644
index 000000000..1d3eae5ae
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_photo.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_photo.9.png
new file mode 100644
index 000000000..194000d33
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_photo_selected.9.png
new file mode 100644
index 000000000..de5ebeb3b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_selected.9.png
new file mode 100644
index 000000000..f659bdf17
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_4_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_photo.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_photo.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_photo_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_selected.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/msg_out_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/mute_blue.png b/TMessagesProj/src/main/res/drawable-xhdpi/mute_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/mute_grey.png b/TMessagesProj/src/main/res/drawable-xhdpi/mute_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/myloc_on.png b/TMessagesProj/src/main/res/drawable-xhdpi/myloc_on.png
new file mode 100644
index 000000000..0ec99ef2a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/myloc_on.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/navigate.png b/TMessagesProj/src/main/res/drawable-xhdpi/navigate.png
new file mode 100644
index 000000000..6c7b7e134
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/navigate.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/newmsg_divider.png b/TMessagesProj/src/main/res/drawable-xhdpi/newmsg_divider.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/notification.png b/TMessagesProj/src/main/res/drawable-xhdpi/notification.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pause_b.png b/TMessagesProj/src/main/res/drawable-xhdpi/pause_b.png
new file mode 100644
index 000000000..851500ecd
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pause_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pause_b_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/pause_b_pressed.png
new file mode 100644
index 000000000..ab048657c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pause_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pause_g.png b/TMessagesProj/src/main/res/drawable-xhdpi/pause_g.png
new file mode 100644
index 000000000..0708a5ede
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pause_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pause_g_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/pause_g_pressed.png
new file mode 100644
index 000000000..c6d72f73e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pause_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pause_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/pause_w.png
new file mode 100644
index 000000000..9228d6e52
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pause_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pause_w2.png b/TMessagesProj/src/main/res/drawable-xhdpi/pause_w2.png
new file mode 100644
index 000000000..bcb65abfa
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pause_w2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pause_w2_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/pause_w2_pressed.png
new file mode 100644
index 000000000..7b7e39079
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pause_w2_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pause_w_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/pause_w_pressed.png
new file mode 100644
index 000000000..214572b3e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pause_w_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/phone_grey.png b/TMessagesProj/src/main/res/drawable-xhdpi/phone_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/photo_text.png b/TMessagesProj/src/main/res/drawable-xhdpi/photo_text.png
new file mode 100644
index 000000000..4faf7715a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/photo_text.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/photo_text2.png b/TMessagesProj/src/main/res/drawable-xhdpi/photo_text2.png
new file mode 100644
index 000000000..244a4b355
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/photo_text2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/photo_tools.png b/TMessagesProj/src/main/res/drawable-xhdpi/photo_tools.png
new file mode 100644
index 000000000..c4ff608ae
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/photo_tools.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/photo_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/photo_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/photocheck.png b/TMessagesProj/src/main/res/drawable-xhdpi/photocheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/phototime_white.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/phototime_white.9.png
new file mode 100644
index 000000000..eaf9b7638
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/phototime_white.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/pin.png b/TMessagesProj/src/main/res/drawable-xhdpi/pin.png
new file mode 100644
index 000000000..1fa36f892
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/pin.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/place_x.png b/TMessagesProj/src/main/res/drawable-xhdpi/place_x.png
new file mode 100644
index 000000000..3d95f25f9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/place_x.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/play_big.png b/TMessagesProj/src/main/res/drawable-xhdpi/play_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/play_w.png b/TMessagesProj/src/main/res/drawable-xhdpi/play_w.png
new file mode 100644
index 000000000..77d1a292d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/play_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/play_w2.png b/TMessagesProj/src/main/res/drawable-xhdpi/play_w2.png
new file mode 100644
index 000000000..580da8336
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/play_w2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/play_w2_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/play_w2_pressed.png
new file mode 100644
index 000000000..9bdc7f202
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/play_w2_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/play_w_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/play_w_pressed.png
new file mode 100644
index 000000000..11b12a54c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/play_w_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/player1.png b/TMessagesProj/src/main/res/drawable-xhdpi/player1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/player1_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/player1_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/player2.png b/TMessagesProj/src/main/res/drawable-xhdpi/player2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/player2_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/player2_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/plus.png b/TMessagesProj/src/main/res/drawable-xhdpi/plus.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/popup_fixed.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/popup_fixed.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/profile_list.png b/TMessagesProj/src/main/res/drawable-xhdpi/profile_list.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/rec.png b/TMessagesProj/src/main/res/drawable-xhdpi/rec.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/reply.png b/TMessagesProj/src/main/res/drawable-xhdpi/reply.png
new file mode 100644
index 000000000..ee23fc6b6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/round_check2.png b/TMessagesProj/src/main/res/drawable-xhdpi/round_check2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/round_grey.png b/TMessagesProj/src/main/res/drawable-xhdpi/round_grey.png
new file mode 100644
index 000000000..de6e1f5cc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/round_grey.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/selectphoto_large.png b/TMessagesProj/src/main/res/drawable-xhdpi/selectphoto_large.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/slidearrow.png b/TMessagesProj/src/main/res/drawable-xhdpi/slidearrow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/system_loader1.png b/TMessagesProj/src/main/res/drawable-xhdpi/system_loader1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/system_loader2.png b/TMessagesProj/src/main/res/drawable-xhdpi/system_loader2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/system_white_3.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/system_white_3.9.png
new file mode 100644
index 000000000..88fb8d0d9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/system_white_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/system_white_4.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/system_white_4.9.png
new file mode 100644
index 000000000..82e8af27f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/system_white_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/tip1.png b/TMessagesProj/src/main/res/drawable-xhdpi/tip1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/tip2.png b/TMessagesProj/src/main/res/drawable-xhdpi/tip2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/tool_blur.png b/TMessagesProj/src/main/res/drawable-xhdpi/tool_blur.png
new file mode 100644
index 000000000..81511a35a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/tool_blur.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/videolapse.png b/TMessagesProj/src/main/res/drawable-xhdpi/videolapse.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/videotrimmer.png b/TMessagesProj/src/main/res/drawable-xhdpi/videotrimmer.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/Thumbs.db b/TMessagesProj/src/main/res/drawable-xxhdpi/Thumbs.db
new file mode 100644
index 000000000..41197babe
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/Thumbs.db differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/addcontact_blue.png b/TMessagesProj/src/main/res/drawable-xxhdpi/addcontact_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/addcontact_green.png b/TMessagesProj/src/main/res/drawable-xxhdpi/addcontact_green.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/addmember.png b/TMessagesProj/src/main/res/drawable-xxhdpi/addmember.png
new file mode 100644
index 000000000..b4a262083
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/addmember.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/arrow_down_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/arrow_down_w.png
new file mode 100644
index 000000000..e7710ef9a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/arrow_down_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/blur_linear.png b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_linear.png
new file mode 100644
index 000000000..7a9a7d59d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_linear.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/blur_linear_active.png b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_linear_active.png
new file mode 100644
index 000000000..d6802f74b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_linear_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/blur_off.png b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_off.png
new file mode 100644
index 000000000..954cd8ac5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_off.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/blur_off_active.png b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_off_active.png
new file mode 100644
index 000000000..539299f2d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_off_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/blur_radial.png b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_radial.png
new file mode 100644
index 000000000..d7d8bc1b8
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_radial.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/blur_radial_active.png b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_radial_active.png
new file mode 100644
index 000000000..137912f15
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/blur_radial_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/broadcast_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/broadcast_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/btn_send_location_down.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/btn_send_location_down.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/btn_send_location_up.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/btn_send_location_up.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/burn.png b/TMessagesProj/src/main/res/drawable-xxhdpi/burn.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_b.png b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_b.png
new file mode 100644
index 000000000..2fa1d0c12
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_b_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_b_pressed.png
new file mode 100644
index 000000000..8f3b4c08d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_big.png b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_g.png b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_g.png
new file mode 100644
index 000000000..34c23a830
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_g_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_g_pressed.png
new file mode 100644
index 000000000..a8585f32d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/cancel_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/check_blue.png b/TMessagesProj/src/main/res/drawable-xxhdpi/check_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/checkbig.png b/TMessagesProj/src/main/res/drawable-xxhdpi/checkbig.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/circle.png b/TMessagesProj/src/main/res/drawable-xxhdpi/circle.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/circle1.png b/TMessagesProj/src/main/res/drawable-xxhdpi/circle1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/circle_big.png b/TMessagesProj/src/main/res/drawable-xxhdpi/circle_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/delete_reply.png b/TMessagesProj/src/main/res/drawable-xxhdpi/delete_reply.png
new file mode 100644
index 000000000..3cfc6883e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/delete_reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/devices.png b/TMessagesProj/src/main/res/drawable-xxhdpi/devices.png
new file mode 100644
index 000000000..3afa7788d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/devices.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_check.png b/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_check.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_halfcheck.png b/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_halfcheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_warning.png b/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_warning.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/doc_actions_b.png b/TMessagesProj/src/main/res/drawable-xxhdpi/doc_actions_b.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/doc_actions_g.png b/TMessagesProj/src/main/res/drawable-xxhdpi/doc_actions_g.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/doc_actions_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/doc_actions_w.png
new file mode 100644
index 000000000..d60fd6d38
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/doc_actions_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/doc_white.png b/TMessagesProj/src/main/res/drawable-xxhdpi/doc_white.png
new file mode 100644
index 000000000..92ee934d3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/doc_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/doccancel_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/doccancel_w.png
new file mode 100644
index 000000000..cd457190b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/doccancel_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/docload_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/docload_w.png
new file mode 100644
index 000000000..5da89c783
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/docload_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/docpause_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/docpause_w.png
new file mode 100644
index 000000000..4c86456cf
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/docpause_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/download_b.png b/TMessagesProj/src/main/res/drawable-xxhdpi/download_b.png
new file mode 100644
index 000000000..0199ccc17
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/download_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/download_b_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/download_b_pressed.png
new file mode 100644
index 000000000..ba3e4dab4
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/download_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/download_g.png b/TMessagesProj/src/main/res/drawable-xxhdpi/download_g.png
new file mode 100644
index 000000000..edc1b88e9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/download_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/download_g_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/download_g_pressed.png
new file mode 100644
index 000000000..4a258462a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/download_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating3_profile.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating3_profile.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating3_profile_m.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating3_profile_m.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating3_profile_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating3_profile_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating_camera.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating_camera.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating_m.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating_m.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating_message.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating_message.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating_pencil.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating_pencil.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/floating_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/floating_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/forward_blue.png b/TMessagesProj/src/main/res/drawable-xxhdpi/forward_blue.png
new file mode 100644
index 000000000..075a4f7f7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/forward_blue.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/foursquare.png b/TMessagesProj/src/main/res/drawable-xxhdpi/foursquare.png
new file mode 100644
index 000000000..0104f7dc9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/foursquare.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/greydivider_top.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/greydivider_top.9.png
new file mode 100644
index 000000000..4c3d0b316
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/greydivider_top.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/header_shadow.png b/TMessagesProj/src/main/res/drawable-xxhdpi/header_shadow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/header_shadow_reverse.png b/TMessagesProj/src/main/res/drawable-xxhdpi/header_shadow_reverse.png
new file mode 100644
index 000000000..3d39b80a1
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/header_shadow_reverse.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/header_timer.png b/TMessagesProj/src/main/res/drawable-xxhdpi/header_timer.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/header_timer2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/header_timer2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_attach3.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_attach3.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_back.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_back.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_back_grey.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_back_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_doc.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_doc.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_done_gray.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_done_gray.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_copy.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_copy.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_delete.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_delete.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_forward.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_forward.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_quoteforward.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_quoteforward.png
new file mode 100644
index 000000000..b730e90db
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_fwd_quoteforward.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_new.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_new.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_other.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_other.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_reply.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_reply.png
new file mode 100644
index 000000000..2af3db4e5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_search.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_ab_search.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_arrow_drop_down.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_arrow_drop_down.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_gallery.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_gallery.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_location.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_location.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_photo.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_photo.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_sticker.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_sticker.png
new file mode 100644
index 000000000..77e67a21a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_sticker.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_video.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_attach_video.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_close_white.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_close_white.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_directory.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_directory.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_done.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_done.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_external_storage.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_external_storage.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_keyboard_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_keyboard_w.png
new file mode 100644
index 000000000..f6bb99dc9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_keyboard_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_launcher.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_launcher.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_lock_header.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_lock_header.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_msg_panel_hide.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_msg_panel_hide.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_msg_panel_kb_white.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_msg_panel_kb_white.png
new file mode 100644
index 000000000..2367322d7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_msg_panel_kb_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_send.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_send.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smile_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smile_w.png
new file mode 100644
index 000000000..fd3453ebd
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smile_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smiles_sticker.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smiles_sticker.png
new file mode 100644
index 000000000..91e9a0746
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smiles_sticker.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smiles_sticker_active.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smiles_sticker_active.png
new file mode 100644
index 000000000..c0b2af66c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_smiles_sticker_active.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_storage.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_storage.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_storage_gallery.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_storage_gallery.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/igvideo.png b/TMessagesProj/src/main/res/drawable-xxhdpi/igvideo.png
new file mode 100644
index 000000000..d13eab929
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/igvideo.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/intro1.png b/TMessagesProj/src/main/res/drawable-xxhdpi/intro1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/intro2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/intro2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/intro3.png b/TMessagesProj/src/main/res/drawable-xxhdpi/intro3.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/intro4.png b/TMessagesProj/src/main/res/drawable-xxhdpi/intro4.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/intro5.png b/TMessagesProj/src/main/res/drawable-xxhdpi/intro5.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/intro6.png b/TMessagesProj/src/main/res/drawable-xxhdpi/intro6.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/intro7.png b/TMessagesProj/src/main/res/drawable-xxhdpi/intro7.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/link.png b/TMessagesProj/src/main/res/drawable-xxhdpi/link.png
new file mode 100644
index 000000000..655dc9e9a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/link.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/list_broadcast.png b/TMessagesProj/src/main/res/drawable-xxhdpi/list_broadcast.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/list_group.png b/TMessagesProj/src/main/res/drawable-xxhdpi/list_group.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/list_secret.png b/TMessagesProj/src/main/res/drawable-xxhdpi/list_secret.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/load_big.png b/TMessagesProj/src/main/res/drawable-xxhdpi/load_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/location_b.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/location_b.9.png
new file mode 100644
index 000000000..01ea9f4dd
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/location_b.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/location_g.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/location_g.9.png
new file mode 100644
index 000000000..7343d9636
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/location_g.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_blue.png b/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_green.png b/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_green.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_load.png b/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_load.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_pause.png b/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_pause.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_red.png b/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_red.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_yellow.png b/TMessagesProj/src/main/res/drawable-xxhdpi/media_doc_yellow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_broadcast.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_broadcast.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_contacts.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_contacts.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_help.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_help.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_invite.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_invite.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_newgroup.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_newgroup.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_secret.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_secret.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_settings.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_settings.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_shadow.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_shadow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/mic.png b/TMessagesProj/src/main/res/drawable-xxhdpi/mic.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/mic_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/mic_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/mic_white.png b/TMessagesProj/src/main/res/drawable-xxhdpi/mic_white.png
new file mode 100644
index 000000000..895c37273
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/mic_white.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_check.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_check.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_check_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_check_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_clock.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_clock.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_clock_photo.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_clock_photo.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_halfcheck.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_halfcheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_halfcheck_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_halfcheck_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2.9.png
new file mode 100644
index 000000000..5634d6ea3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_photo.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_photo.9.png
new file mode 100644
index 000000000..388246ec8
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_photo_selected.9.png
new file mode 100644
index 000000000..350b66faf
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_selected.9.png
new file mode 100644
index 000000000..ee188c96c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_2_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3.9.png
new file mode 100644
index 000000000..8d409b06c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_photo.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_photo.9.png
new file mode 100644
index 000000000..e2902e335
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_photo_selected.9.png
new file mode 100644
index 000000000..d7c056acd
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_selected.9.png
new file mode 100644
index 000000000..d0c279108
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_3_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4.9.png
new file mode 100644
index 000000000..0454aeb12
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_photo.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_photo.9.png
new file mode 100644
index 000000000..e2902e335
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_photo_selected.9.png
new file mode 100644
index 000000000..d7c056acd
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_selected.9.png
new file mode 100644
index 000000000..bd27260a3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_4_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_photo.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_photo.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_photo_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_in_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2.9.png
new file mode 100644
index 000000000..f35a6c090
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_photo.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_photo.9.png
new file mode 100644
index 000000000..02e3ad804
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_photo_selected.9.png
new file mode 100644
index 000000000..67713607b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_selected.9.png
new file mode 100644
index 000000000..a4ce6ab8c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_2_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3.9.png
new file mode 100644
index 000000000..e8ee0f717
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_photo.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_photo.9.png
new file mode 100644
index 000000000..3bda506d6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_photo_selected.9.png
new file mode 100644
index 000000000..db25d3214
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_selected.9.png
new file mode 100644
index 000000000..8828c0801
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_3_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4.9.png
new file mode 100644
index 000000000..231b4c6e2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_photo.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_photo.9.png
new file mode 100644
index 000000000..ccc6ced38
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_photo.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_photo_selected.9.png
new file mode 100644
index 000000000..d73c4c660
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_photo_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_selected.9.png
new file mode 100644
index 000000000..faa65b88f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_4_selected.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_photo.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_photo.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_photo_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_photo_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_selected.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/msg_out_selected.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/mute_blue.png b/TMessagesProj/src/main/res/drawable-xxhdpi/mute_blue.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/mute_grey.png b/TMessagesProj/src/main/res/drawable-xxhdpi/mute_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/myloc_on.png b/TMessagesProj/src/main/res/drawable-xxhdpi/myloc_on.png
new file mode 100644
index 000000000..1b40c0f1b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/myloc_on.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/navigate.png b/TMessagesProj/src/main/res/drawable-xxhdpi/navigate.png
new file mode 100644
index 000000000..ffe55f7fe
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/navigate.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/newmsg_divider.png b/TMessagesProj/src/main/res/drawable-xxhdpi/newmsg_divider.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/notification.png b/TMessagesProj/src/main/res/drawable-xxhdpi/notification.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pause_b.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_b.png
new file mode 100644
index 000000000..fa34156e3
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_b.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pause_b_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_b_pressed.png
new file mode 100644
index 000000000..14417454f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_b_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pause_g.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_g.png
new file mode 100644
index 000000000..58230127c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_g.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pause_g_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_g_pressed.png
new file mode 100644
index 000000000..6afeea45e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_g_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w.png
new file mode 100644
index 000000000..31bdd7380
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w2.png
new file mode 100644
index 000000000..d4be9ec78
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w2_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w2_pressed.png
new file mode 100644
index 000000000..94ce677c2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w2_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w_pressed.png
new file mode 100644
index 000000000..0f81862fe
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pause_w_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/phone_grey.png b/TMessagesProj/src/main/res/drawable-xxhdpi/phone_grey.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/photo_text.png b/TMessagesProj/src/main/res/drawable-xxhdpi/photo_text.png
new file mode 100644
index 000000000..41c6315d7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/photo_text.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/photo_text2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/photo_text2.png
new file mode 100644
index 000000000..461b2a3e2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/photo_text2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/photo_tools.png b/TMessagesProj/src/main/res/drawable-xxhdpi/photo_tools.png
new file mode 100644
index 000000000..ab1bb0e95
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/photo_tools.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/photo_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/photo_w.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/photocheck.png b/TMessagesProj/src/main/res/drawable-xxhdpi/photocheck.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/phototime_white.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/phototime_white.9.png
new file mode 100644
index 000000000..d1382b74d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/phototime_white.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/pin.png b/TMessagesProj/src/main/res/drawable-xxhdpi/pin.png
new file mode 100644
index 000000000..8580d9a2f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/pin.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/place_x.png b/TMessagesProj/src/main/res/drawable-xxhdpi/place_x.png
new file mode 100644
index 000000000..aa7aebba0
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/place_x.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/play_big.png b/TMessagesProj/src/main/res/drawable-xxhdpi/play_big.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/play_w.png b/TMessagesProj/src/main/res/drawable-xxhdpi/play_w.png
new file mode 100644
index 000000000..be2cb867f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/play_w.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/play_w2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/play_w2.png
new file mode 100644
index 000000000..263f27db6
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/play_w2.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/play_w2_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/play_w2_pressed.png
new file mode 100644
index 000000000..96e0e1276
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/play_w2_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/play_w_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/play_w_pressed.png
new file mode 100644
index 000000000..48aa6b658
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/play_w_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/player1.png b/TMessagesProj/src/main/res/drawable-xxhdpi/player1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/player1_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/player1_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/player2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/player2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/player2_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/player2_pressed.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/plus.png b/TMessagesProj/src/main/res/drawable-xxhdpi/plus.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/popup_fixed.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/popup_fixed.9.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/profile_list.png b/TMessagesProj/src/main/res/drawable-xxhdpi/profile_list.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/rec.png b/TMessagesProj/src/main/res/drawable-xxhdpi/rec.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/reply.png b/TMessagesProj/src/main/res/drawable-xxhdpi/reply.png
new file mode 100644
index 000000000..d08e72b82
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/reply.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/round_check2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/round_check2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/round_grey.png b/TMessagesProj/src/main/res/drawable-xxhdpi/round_grey.png
new file mode 100644
index 000000000..7b037c623
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/round_grey.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/selectphoto_large.png b/TMessagesProj/src/main/res/drawable-xxhdpi/selectphoto_large.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/slidearrow.png b/TMessagesProj/src/main/res/drawable-xxhdpi/slidearrow.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/system_loader1.png b/TMessagesProj/src/main/res/drawable-xxhdpi/system_loader1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/system_loader2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/system_loader2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/system_white_3.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/system_white_3.9.png
new file mode 100644
index 000000000..3f93dac18
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/system_white_3.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/system_white_4.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/system_white_4.9.png
new file mode 100644
index 000000000..a19de0a71
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/system_white_4.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/tip1.png b/TMessagesProj/src/main/res/drawable-xxhdpi/tip1.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/tip2.png b/TMessagesProj/src/main/res/drawable-xxhdpi/tip2.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/tool_blur.png b/TMessagesProj/src/main/res/drawable-xxhdpi/tool_blur.png
new file mode 100644
index 000000000..b935f2f74
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/tool_blur.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/videolapse.png b/TMessagesProj/src/main/res/drawable-xxhdpi/videolapse.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/videotrimmer.png b/TMessagesProj/src/main/res/drawable-xxhdpi/videotrimmer.png
old mode 100755
new mode 100644
diff --git a/TMessagesProj/src/main/res/drawable-xxxhdpi/Thumbs.db b/TMessagesProj/src/main/res/drawable-xxxhdpi/Thumbs.db
new file mode 100644
index 000000000..0e43c84ec
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxxhdpi/Thumbs.db differ
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_sticker.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_sticker.xml
new file mode 100644
index 000000000..2cb1ecbef
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_sticker.xml
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<selector
+	xmlns:android="http://schemas.android.com/apk/res/android"
+	android:enterFadeDuration="200"
+	android:exitFadeDuration="300">
+	<item android:state_selected="true" android:drawable="@drawable/ic_smiles_sticker_active"/>
+	<item android:drawable="@drawable/ic_smiles_sticker"/>
+</selector>
diff --git a/TMessagesProj/src/main/res/layout/imagelist.xml b/TMessagesProj/src/main/res/layout/imagelist.xml
new file mode 100644
index 000000000..05025b71f
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/imagelist.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="fill_parent"
+    android:layout_height="80dip"
+    android:orientation="horizontal" >
+
+    <ImageView
+        android:id="@+id/bubble_in"
+        android:layout_width="70dip"
+        android:layout_height="70dip"
+        android:gravity="right"
+        android:layout_gravity="center_vertical"
+		android:padding="0dip" />
+
+    <ImageView
+        android:id="@+id/bubble_out"
+        android:layout_width="70dip"
+        android:layout_height="70dip"
+        android:gravity="left"
+        android:layout_gravity="center_vertical"
+        android:padding="0dip" />
+
+    <TextView
+        android:id="@+id/bubble_title"
+        android:layout_width="wrap_content"
+        android:layout_height="fill_parent"
+        android:layout_marginLeft="10dip"
+        android:gravity="center"
+        android:layout_gravity="center"
+        android:textSize="18sp"
+
+        android:padding="2dip" />
+        <!--
+    <TextView
+        android:id="@+id/textView1"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="TextView" 
+        android:layout_marginLeft="10dp"/>-->
+</LinearLayout>
diff --git a/TMessagesProj/src/main/res/layout/imagelistlayout.xml b/TMessagesProj/src/main/res/layout/imagelistlayout.xml
new file mode 100644
index 000000000..3dbb71835
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/imagelistlayout.xml
@@ -0,0 +1,13 @@
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    tools:context="${relativePackage}.${activityClass}" >
+
+    <ListView
+        android:id="@+id/list"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+    </ListView>
+
+</RelativeLayout>
diff --git a/TMessagesProj/src/main/res/layout/recycler_view.xml b/TMessagesProj/src/main/res/layout/recycler_view.xml
new file mode 100644
index 000000000..648ce2b19
--- /dev/null
+++ b/TMessagesProj/src/main/res/layout/recycler_view.xml
@@ -0,0 +1,5 @@
+<org.telegram.ui.Components.RecyclerExListView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:scrollbars="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent" />
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/raw/sound_in.wav b/TMessagesProj/src/main/res/raw/sound_in.wav
new file mode 100644
index 000000000..262201668
Binary files /dev/null and b/TMessagesProj/src/main/res/raw/sound_in.wav differ
diff --git a/TMessagesProj/src/main/res/raw/sound_out.wav b/TMessagesProj/src/main/res/raw/sound_out.wav
new file mode 100644
index 000000000..ccfa86963
Binary files /dev/null and b/TMessagesProj/src/main/res/raw/sound_out.wav differ
diff --git a/TMessagesProj/src/main/res/values-ca/strings.xml b/TMessagesProj/src/main/res/values-ca/strings.xml
new file mode 100644
index 000000000..a93b44979
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-ca/strings.xml
@@ -0,0 +1,714 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<resources>
+  <string name="AppName">Plus Messenger</string>
+  <string name="LanguageName">Català</string>
+  <string name="LanguageNameInEnglish">Catalan</string>
+  <string name="LanguageCode">ca</string>
+  <!--signin view-->
+  <string name="YourPhone">El vostre telèfon</string>
+  <string name="StartText">Confirmeu el codi del país i escriviu el vostre número de telèfon.</string>
+  <string name="ChooseCountry">Trieu un país</string>
+  <string name="WrongCountry">Codi de país erroni</string>
+  <!--code enter view-->
+  <string name="YourCode">El vostre codi</string>
+  <string name="SentSmsCode">Us hem enviat un SMS al vostre telèfon amb un codi d\'activació</string>
+  <string name="CallText">Us trucarem en %1$d:%2$02d</string>
+  <string name="Calling">Us estem trucant...</string>
+  <string name="Code">Codi</string>
+  <string name="WrongNumber">El número no és correcte?</string>
+  <string name="DidNotGetTheCode">No heu rebut el codi?</string>
+  <!--signup view-->
+  <string name="YourName">El vostre nom</string>
+  <string name="RegisterText">Introduïu el nom i cognoms</string>
+  <!--<string name="RegisterText">Set up your name and picture</string>-->
+  <string name="FirstName">Nom (necessari)</string>
+  <string name="LastName">Cognoms (opcional)</string>
+  <string name="CancelRegistration">Cancel·la el registre</string>
+  <!--chats view-->
+  <string name="Settings">Configuració</string>
+  <string name="Contacts">Contactes</string>
+  <string name="NewGroup">Grup nou</string>
+  <string name="Yesterday">ahir</string>
+  <string name="NoResult">Cap resultat</string>
+  <string name="NoChats">No hi ha cap xat...</string>
+  <string name="NoChatsHelp">Comenceu a enviar missatges prement\nel botó «Missatge nou» a la part inferior\ndreta o obriu el menú per a més opcions.</string>
+  <string name="WaitingForNetwork">Esperant una connexió...</string>
+  <string name="Connecting">S\'està connectant...</string>
+  <string name="Updating">S\'està actualitzant...</string>
+  <string name="NewSecretChat">Xat secret nou</string>
+  <string name="AwaitingEncryption">S\'està esperant que %s es connecti...</string>
+  <string name="EncryptionRejected">S\'ha cancel·lat el xat secret</string>
+  <string name="EncryptionProcessing">S\'estan intercanviant les claus de xifratge...</string>
+  <string name="EncryptedChatStartedOutgoing">%s s\'ha unit al xat secret.</string>
+  <string name="EncryptedChatStartedIncoming">Us heu unit al xat secret.</string>
+  <string name="ClearHistory">Esborra l\'historial</string>
+  <string name="DeleteChat">Elimina i surt</string>
+  <string name="DeleteChatUser">Elimina el xat</string>
+  <string name="HiddenName">Compte eliminat</string>
+  <string name="SelectChat">Trieu un xat</string>
+  <string name="PhotoTip">Mantingueu premut per veure-ho</string>
+  <string name="CompatibilityChat">%1$s utilitza una versió antiga del Telegram. Aleshores les fotos secretes es mostren en mode de compatibilitat.\n\nQuan %2$s actualitzi el Telegram, les fotos amb autodestrucció d\'1 minut o menys funcionaran en mode «Mantingueu premut per veure», i rebreu una notificació quan l\'altra persona faci una captura de pantalla.</string>
+  <string name="SearchMessages">MISSATGES</string>
+  <string name="Search">Cerca</string>
+  <string name="MuteNotifications">Silencia les notificacions</string>
+  <string name="MuteFor">Silencia %1$s</string>
+  <string name="UnmuteNotifications">Restaura les notificacions</string>
+  <string name="WillUnmuteIn">D\'aquí %1$s</string>
+  <string name="MuteDisable">Inhabilita</string>
+  <!--broadcasts-->
+  <string name="NewBroadcastList">Llista de difusió nova</string>
+  <string name="EnterListName">Introduïu el nom de la llista</string>
+  <string name="YouCreatedBroadcastList">Heu creat una llista de difusió</string>
+  <string name="AddRecipient">Afegeix un destinatari</string>
+  <string name="KickFromBroadcast">Treu de la llista de difusió</string>
+  <!--documents view-->
+  <string name="SelectFile">Trieu un fitxer</string>
+  <string name="FreeOfTotal">%1$s disponibles de %2$s</string>
+  <string name="UnknownError">Error desconegut</string>
+  <string name="AccessError">Error d\'accés</string>
+  <string name="NoFiles">No hi ha cap fitxer...</string>
+  <string name="FileUploadLimit">La mida del fitxer no hauria de superar els %1$s</string>
+  <string name="NotMounted">No s\'ha muntat l\'emmagatzematge</string>
+  <string name="UsbActive">Transferència USB activa</string>
+  <string name="InternalStorage">Emmagatzematge intern</string>
+  <string name="ExternalStorage">Emmagatzematge extern</string>
+  <string name="SystemRoot">Directori arrel</string>
+  <string name="SdCard">Targeta SD</string>
+  <string name="Folder">Carpeta</string>
+  <string name="GalleryInfo">Per enviar imatges sense comprimir-les</string>
+  <!--chat view-->
+  <string name="Invisible">invisible</string>
+  <string name="Typing">està escrivint...</string>
+  <string name="IsTyping">està escrivint...</string>
+  <string name="AreTyping">estan escrivint...</string>
+  <string name="GotAQuestion">Teniu cap dubte\namb el Telegram?</string>
+  <string name="ChatTakePhoto">Fes una foto</string>
+  <string name="ChatGallery">Galeria</string>
+  <string name="ChatLocation">Ubicació</string>
+  <string name="ChatVideo">Vídeo</string>
+  <string name="ChatDocument">Fitxer</string>
+  <string name="NoMessages">Encara no hi ha cap missatge...</string>
+  <string name="ForwardedMessage">Missatge reenviat</string>
+  <string name="From">De</string>
+  <string name="NoRecent">No n\'hi ha de recents</string>
+  <string name="Message">Missatge</string>
+  <string name="TypeMessage">Missatge</string>
+  <string name="ShareMyContactInfo">Comparteix la meva info</string>
+  <string name="AddToContacts">Afegeix als contactes</string>
+  <string name="EncryptedPlaceholderTitleIncoming">%s us ha convidat a un xat secret.</string>
+  <string name="EncryptedPlaceholderTitleOutgoing">Heu convidat %s a un xat secret.</string>
+  <string name="EncryptedDescriptionTitle">Els xats secrets:</string>
+  <string name="EncryptedDescription1">Utilitzen el xifratge d\'extrem a extrem</string>
+  <string name="EncryptedDescription2">No deixen rastre als nostres servidors</string>
+  <string name="EncryptedDescription3">Permeten definir un temporitzador d\'autodestrucció</string>
+  <string name="EncryptedDescription4">No permeten el reenviament</string>
+  <string name="YouWereKicked">Us han fet fora d\'aquest grup</string>
+  <string name="YouLeft">Heu abandonat el grup</string>
+  <string name="DeleteThisGroup">Elimina aquest grup</string>
+  <string name="DeleteThisChat">Elimina aquest xat</string>
+  <string name="SlideToCancel">LLISQUEU PER CANCEL·LAR</string>
+  <string name="SaveToDownloads">Desa a «Baixades»</string>
+  <string name="ShareFile">Comparteix</string>
+  <string name="ApplyLocalizationFile">Aplica la localització</string>
+  <string name="UnsupportedAttachment">El fitxer adjunt no és compatible</string>
+  <string name="SetTimer">Estableix l\'autodestrucció</string>
+  <string name="ServiceNotifications">Notificacions del servei</string>
+  <!--notification-->
+  <string name="MessageLifetimeChanged">%1$s ha definit l\'autodestrucció en %2$s</string>
+  <string name="MessageLifetimeChangedOutgoing">Heu definit l\'autodestrucció en %1$s</string>
+  <string name="MessageLifetimeRemoved">%1$s ha desactivat l\'autodestrucció</string>
+  <string name="MessageLifetimeYouRemoved">Heu desactivat l\'autodestrucció</string>
+  <string name="YouHaveNewMessage">Teniu un missatge nou</string>
+  <string name="NotificationMessageText">%1$s: %2$s</string>
+  <string name="NotificationMessageNoText">%1$s us ha enviat un missatge</string>
+  <string name="NotificationMessagePhoto">%1$s us ha enviat una foto</string>
+  <string name="NotificationMessageVideo">%1$s us ha enviat un vídeo</string>
+  <string name="NotificationMessageContact">%1$s ha compartit un contacte</string>
+  <string name="NotificationMessageMap">%1$s us ha enviat una ubicació</string>
+  <string name="NotificationMessageDocument">%1$s us ha enviat un fitxer</string>
+  <string name="NotificationMessageAudio">%1$s us ha enviat un fitxer d\'àudio</string>
+  <string name="NotificationMessageSticker">%1$s us ha enviat un adhesiu</string>
+  <string name="NotificationMessageGroupText">%1$s @ %2$s: %3$s</string>
+  <string name="NotificationMessageGroupNoText">%1$s ha enviat un missatge al grup %2$s</string>
+  <string name="NotificationMessageGroupPhoto">%1$s ha enviat una foto al grup %2$s</string>
+  <string name="NotificationMessageGroupVideo">%1$s ha enviat un vídeo al grup %2$s</string>
+  <string name="NotificationMessageGroupContact">%1$s ha compartit un contacte amb el grup %2$s</string>
+  <string name="NotificationMessageGroupMap">%1$s ha enviat una ubicació al grup %2$s</string>
+  <string name="NotificationMessageGroupDocument">%1$s ha enviat un fitxer al grup %2$s</string>
+  <string name="NotificationMessageGroupAudio">%1$s ha enviat un fitxer d\'àudio al grup %2$s</string>
+  <string name="NotificationMessageGroupSticker">%1$s ha enviat un adhesiu al grup %2$s</string>
+  <string name="NotificationInvitedToGroup">%1$s us ha convidat al grup %2$s</string>
+  <string name="NotificationEditedGroupName">%1$s ha editat el nom del grup %2$s</string>
+  <string name="NotificationEditedGroupPhoto">%1$s ha editat la foto del grup %2$s</string>
+  <string name="NotificationGroupAddMember">%1$s ha convidat %3$s al grup %2$s</string>
+  <string name="NotificationGroupAddSelf">%1$s ha tornat al grup %2$s</string>
+  <string name="NotificationGroupKickMember">%1$s ha fet fora %3$s del grup %2$s</string>
+  <string name="NotificationGroupKickYou">%1$s us ha fet fora del grup %2$s</string>
+  <string name="NotificationGroupLeftMember">%1$s ha abandonat el grup %2$s</string>
+  <string name="NotificationContactJoined">%1$s s\'ha unit al Telegram.</string>
+  <string name="NotificationUnrecognizedDevice">%1$s,\nHem detectat un inici de sessió al vostre compte des d\'un nou dispositiu el %2$s\n\nDispositiu: %3$s\nUbicació: %4$s\n\nSi no en sabeu res potser era algú altre! Podeu anar a «Configuració» - «Privadesa i seguretat» - «Tanca les altres sessions».\n\nGràcies,\nL\'equip del Telegram</string>
+  <string name="NotificationContactNewPhoto">%1$s ha actualitzat la foto del perfil</string>
+  <string name="Reply">Respon</string>
+  <string name="ReplyToGroup">Respon a %1$s</string>
+  <string name="ReplyToUser">Respon a %1$s</string>
+  <string name="NotificationMessagesPeopleDisplayOrder">%1$s %2$s</string>
+  <!--contacts view-->
+  <string name="SelectContact">Trieu un contacte</string>
+  <string name="NoContacts">No hi ha cap contacte</string>
+  <string name="InviteText">Ep, canvieu al Telegram: http://goo.gl/jnmjnZ</string>
+  <string name="TodayAt">a les</string>
+  <string name="YesterdayAt">ahir a les</string>
+  <string name="Online">en línia</string>
+  <string name="LastSeen">vist:</string>
+  <string name="LastSeenDate">vist:</string>
+  <string name="InviteFriends">Convida als contactes</string>
+  <string name="GlobalSearch">CERCA GLOBAL</string>
+  <string name="Lately">vist fa poc</string>
+  <string name="WithinAWeek">vist fa uns dies</string>
+  <string name="WithinAMonth">vist fa unes setmanes</string>
+  <string name="ALongTimeAgo">vist fa molt de temps</string>
+  <string name="NewMessageTitle">Missatge nou</string>
+  <!--group create view-->
+  <string name="SendMessageTo">Envia un missatge a...</string>
+  <string name="EnterGroupNamePlaceholder">Introduïu el nom del grup</string>
+  <string name="GroupName">Nom del grup</string>
+  <string name="MembersCount">%1$d/%2$d membres</string>
+  <!--group info view-->
+  <string name="SharedMedia">Fitxers compartits</string>
+  <string name="SETTINGS">Configuració</string>
+  <string name="AddMember">Afegeix un membre</string>
+  <string name="DeleteAndExit">Elimina i surt del grup</string>
+  <string name="Notifications">Notificacions</string>
+  <string name="KickFromGroup">Fes fora del grup</string>
+  <!--contact info view-->
+  <string name="ShareContact">Comparteix</string>
+  <string name="AddContact">Afegeix</string>
+  <string name="AddContactTitle">Afegeix un contacte</string>
+  <string name="BlockContact">Bloca</string>
+  <string name="EditContact">Edita</string>
+  <string name="DeleteContact">Elimina</string>
+  <string name="PhoneHome">Casa</string>
+  <string name="PhoneMobile">Mòbil</string>
+  <string name="PhoneWork">Feina</string>
+  <string name="PhoneOther">Altres</string>
+  <string name="PhoneMain">Principal</string>
+  <string name="StartEncryptedChat">Inicia un xat secret</string>
+  <string name="CreateEncryptedChatError">S\'ha produït un error.</string>
+  <string name="EncryptionKey">Clau de xifratge</string>
+  <string name="MessageLifetime">Autodestrucció</string>
+  <string name="ShortMessageLifetimeForever">Inactiu</string>
+  <string name="EncryptionKeyDescription">Aquesta imatge és una visualització de la clau de xifratge del xat secret amb <![CDATA[<b>]]>%1$s<![CDATA[</b>]]>.<![CDATA[<br><br>]]> Si aquesta imatge es mostra igual al dispositiu de <![CDATA[<b>]]>%2$s<![CDATA[</b>]]>, llavors el vostre xat és segur al 200%%.<![CDATA[<br><br>]]> Més informació a telegram.org</string>
+  <string name="NumberUnknown">Desconegut</string>
+  <string name="Info">Informació</string>
+  <string name="Phone">Telèfon</string>
+  <!--usernames-->
+  <string name="Username">Nom d\'usuari</string>
+  <string name="UsernamePlaceholder">El vostre nom d\'usuari</string>
+  <string name="UsernameInUse">Aquest nom d\'usuari ja es troba en ús.</string>
+  <string name="UsernameInvalid">Aquest nom d\'usuari no és vàlid.</string>
+  <string name="UsernameInvalidShort">El nom d\'usuari ha de tenir com a mínim 5 caràcters.</string>
+  <string name="UsernameInvalidLong">El nom d\'usuari no pot tenir més de 32 caràcters.</string>
+  <string name="UsernameInvalidStartNumber">El nom d\'usuari no pot començar amb un número.</string>
+  <string name="UsernameHelp">Podeu triar un nom d\'usuari al <![CDATA[<b>]]>Plus Messenger<![CDATA[</b>]]>. Si ho feu, altres usuaris us podran trobar per aquest nom i contactar-vos sense que coneguin el vostre número. <![CDATA[<br><br>]]>Podeu usar <![CDATA[<b>]]>a–z<![CDATA[</b>]]>, <![CDATA[<b>]]>0–9<![CDATA[</b>]]> i caràcters de subratllat. Mínim <![CDATA[<b>]]>5<![CDATA[</b>]]> caràcters.</string>
+  <string name="UsernameChecking">S\'està comprovant el nom...</string>
+  <string name="UsernameAvailable">%1$s està disponible.</string>
+  <string name="UsernameEmpty">Cap</string>
+  <string name="ErrorOccurred">S\'ha produït un error.</string>
+  <!--settings view-->
+  <string name="ResetNotificationsText">S\'han reinicialitzat totes les notificacions als valors per defecte</string>
+  <string name="TextSize">Mida del text dels missatges</string>
+  <string name="AskAQuestion">Cap dubte?</string>
+  <string name="EnableAnimations">Activa les animacions</string>
+  <string name="Unblock">Desbloca</string>
+  <string name="UnblockText">Mantingueu premut l\'usuari que voleu desblocar.</string>
+  <string name="NoBlocked">Cap usuari blocat</string>
+  <string name="MessageNotifications">Notificacions de missatges</string>
+  <string name="Alert">Alerta</string>
+  <string name="MessagePreview">Vista prèvia del missatge</string>
+  <string name="GroupNotifications">Notificacions de grups</string>
+  <string name="Sound">So</string>
+  <string name="InAppNotifications">Notificacions dins l\'aplicació</string>
+  <string name="InAppSounds">So</string>
+  <string name="InAppVibrate">Vibració</string>
+  <string name="Vibrate">Vibració</string>
+  <string name="InAppPreview">Vista prèvia</string>
+  <string name="Reset">Reinicialitza</string>
+  <string name="ResetAllNotifications">Reinicialitza totes les notificacions</string>
+  <string name="UndoAllCustom">Desfà la configuració de les notificacions personalitzades per a tots els contactes i grups.</string>
+  <string name="NotificationsAndSounds">Notificacions i sons</string>
+  <string name="BlockedUsers">Usuaris blocats</string>
+  <string name="LogOut">Tanca la sessió</string>
+  <string name="NoSound">Sense so</string>
+  <string name="Default">Per defecte</string>
+  <string name="Support">Ajuda</string>
+  <string name="ChatBackground">Fons de pantalla</string>
+  <string name="MessagesSettings">Missatges</string>
+  <string name="SendByEnter">Envia amb «Retorn»</string>
+  <string name="TerminateAllSessions">Tanca les altres sessions</string>
+  <string name="Events">Esdeveniments</string>
+  <string name="ContactJoined">En unir-se un contacte al Telegram</string>
+  <string name="Pebble">PEBBLE</string>
+  <string name="Language">Llengua</string>
+  <string name="AskAQuestionInfo">Tingueu en compte que l\'assistència del Telegram es basa en voluntariat. Intentem respondre al més ràpid possible, però pot ser que triguem una mica.<![CDATA[<br><br>]]>Doneu un cop d\'ull a les <![CDATA[<a href=\"http://telegram.org/faq#general\">PMF del Telegram</a>]]>; hi trobareu respostes a la majoria de preguntes i consells importants per a la <![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">resolució de problemes</a>]]>.</string>
+  <string name="AskButton">Pregunta-ho a un voluntari</string>
+  <string name="TelegramFaq">PMF del Telegram</string>
+  <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+  <string name="DeleteLocalization">Voleu eliminar la localització?</string>
+  <string name="IncorrectLocalization">El fitxer de localització no és vàlid</string>
+  <string name="Enabled">Activat</string>
+  <string name="Disabled">Desactivat</string>
+  <string name="NotificationsService">Servei de notificacions</string>
+  <string name="NotificationsServiceDisableInfo">Si Google Play Services us és suficient per rebre notificacions, podeu desactivar el Servei de Notificacions aquí. De totes maneres recomanem deixar-lo activat per mantenir l\'app en segon pla i rebre notificacions a l\'instant.</string>
+  <string name="SortBy">Ordena per</string>
+  <string name="ImportContacts">Importa els contactes</string>
+  <string name="SortFirstName">Nom</string>
+  <string name="SortLastName">Cognoms</string>
+  <string name="LedColor">Color del LED</string>
+  <string name="PopupNotification">Notificació emergent</string>
+  <string name="NoPopup">Sense notificació emergent</string>
+  <string name="OnlyWhenScreenOn">Només amb la pantalla encesa</string>
+  <string name="OnlyWhenScreenOff">Només amb la pantalla apagada</string>
+  <string name="AlwaysShowPopup">Mostra sempre la notificació emergent</string>
+  <string name="BadgeNumber">Número sobre la icona</string>
+  <string name="Short">Curta</string>
+  <string name="Long">Llarga</string>
+  <string name="SystemDefault">Definit pel sistema</string>
+  <string name="SettingsDefault">Definit per l\'aplicació</string>
+  <string name="AutomaticMediaDownload">Baixada automàtica de fitxers</string>
+  <string name="WhenUsingMobileData">Amb connexió de dades mòbils</string>
+  <string name="WhenConnectedOnWiFi">Amb connexió Wi-Fi</string>
+  <string name="WhenRoaming">En itinerància</string>
+  <string name="NoMediaAutoDownload">Cap fitxer</string>
+  <string name="SaveToGallerySettings">Desa-ho a la galeria</string>
+  <string name="EditName">Edita el nom</string>
+  <string name="NotificationsPriority">Prioritat</string>
+  <string name="NotificationsPriorityDefault">Per defecte</string>
+  <string name="NotificationsPriorityLow">Baixa</string>
+  <string name="NotificationsPriorityHigh">Alta</string>
+  <string name="NotificationsPriorityMax">Màxima</string>
+  <string name="RepeatNotificationsNever">Mai</string>
+  <string name="RepeatNotifications">Repetició de notificacions</string>
+  <string name="PhoneNumberHelp">Aquí podeu canviar el vostre número del Telegram. El vostre compte i les dades al núvol —missatges, fitxers, contactes, etc.— es mouran al nou número.\n\n<![CDATA[<b>Important:</b>]]> El <![CDATA[<b>número nou</b>]]> s\'afegirà a l\'agenda de tots els vostres contactes del Telegram que tinguin el número vell i que no hàgiu blocat al Telegram.</string>
+  <string name="PhoneNumberAlert">El número nou s\'afegirà a l\'agenda de tots els vostres contactes del Telegram que tinguin el número vell i que no hàgiu blocat al Telegram.</string>
+  <string name="PhoneNumberChange">CANVI DE NÚMERO</string>
+  <string name="ChangePhoneNewNumber">Número nou</string>
+  <string name="ChangePhoneHelp">Us enviarem un SMS amb un codi de verificació al vostre nou número.</string>
+  <string name="ChangePhoneNumberOccupied">El número %1$s ja està connectat a un compte del Telegram. Elimineu aquest compte abans de canviar de número.</string>
+  <string name="NotificationsOther">Altres</string>
+  <string name="NotificationsDisabled">Inhabilitades</string>
+  <string name="VibrationDisabled">Inhabilitada</string>
+  <!--passcode view-->
+  <string name="Passcode">Codi d\'accés</string>
+  <string name="ChangePasscode">Canvia el codi d\'accés</string>
+  <string name="ChangePasscodeInfo">En introduir un codi d\'accés addicional, apareixerà la icona d\'un cadenat a la pàgina de xats. Toqueu-la per blocar i desblocar l\'aplicació.\n\nNota: Si oblideu el codi d\'accés haureu d\'eliminar i reinstal·lar l\'aplicació. Es perdran tots els xats secrets.</string>
+  <string name="ChangePasscodeAlert">Ara es mostrarà la icona d\'un cadenat a la pàgina de xats. Toqueu-la per bloquejar Telegram amb el nou codi d\'accés.</string>
+  <string name="PasscodePIN">PIN</string>
+  <string name="PasscodePassword">Contrasenya</string>
+  <string name="EnterCurrentPasscode">Introduïu el codi d\'accés actual</string>
+  <string name="EnterNewPasscode">Introduïu un nou codi d\'accés</string>
+  <string name="EnterYourPasscode">Introduïu el codi d\'accés</string>
+  <string name="ReEnterYourPasscode">Torneu a introduir el nou codi d\'accés</string>
+  <string name="InvalidPasscode">Codi d\'accés no vàlid</string>
+  <string name="PasscodeDoNotMatch">Els codis d\'accés no coincideixen</string>
+  <string name="AutoLock">Autoblocatge</string>
+  <string name="AutoLockInfo">Demana el codi d\'accés en absentar-me.</string>
+  <string name="AutoLockInTime">a %1$s</string>
+  <string name="AutoLockDisabled">Inhabilitat</string>
+  <!--media view-->
+  <string name="NoMedia">Compartiu fotos i vídeos a aquest xat i accediu-hi des de qualsevol dispositiu.</string>
+  <string name="DocumentsTitle">Documents</string>
+  <string name="SharedMediaTitle">Fitxers compartits</string>
+  <string name="NoSharedFiles">Compartiu fitxers i documents a aquest xat i accediu-hi des de qualsevol dispositiu.</string>
+  <!--map view-->
+  <string name="Map">Mapa</string>
+  <string name="Satellite">Satèl·lit</string>
+  <string name="Hybrid">Híbrid</string>
+  <string name="MetersAway">m lluny</string>
+  <string name="KMetersAway">km lluny</string>
+  <string name="SendLocation">Envia la ubicació</string>
+  <string name="ShareLocation">Comparteix la ubicació</string>
+  <!--photo gallery view-->
+  <string name="ShowAllMedia">Mostra tots els fitxers</string>
+  <string name="SaveToGallery">Desa a la galeria</string>
+  <string name="Of">%1$d de %2$d</string>
+  <string name="Gallery">Galeria</string>
+  <string name="AllPhotos">Totes les fotos</string>
+  <string name="NoPhotos">No hi ha fotos encara</string>
+  <string name="PleaseDownload">Descarregueu els fitxers primer</string>
+  <string name="NoRecentPhotos">Cap foto recent</string>
+  <string name="NoRecentGIFs">No hi ha GIF recents</string>
+  <string name="SearchImages">CERCA IMATGES</string>
+  <string name="SearchImagesInfo">CERCADOR WEB</string>
+  <string name="SearchGifs">CERCA GIF</string>
+  <string name="SearchImagesTitle">Cerca al web</string>
+  <string name="SearchGifsTitle">Cerca GIF</string>
+  <string name="CropImage">Retalla la imatge</string>
+  <string name="EditImage">Edita la imatge</string>
+  <string name="Enhance">Millora</string>
+  <string name="Highlights">Destacades</string>
+  <string name="Contrast">Contrast</string>
+  <string name="Exposure">Exposició</string>
+  <string name="Warmth">Temperatura de color</string>
+  <string name="Saturation">Saturació</string>
+  <string name="Vignette">Vinyeta</string>
+  <string name="Shadows">Ombres</string>
+  <string name="Grain">Gra</string>
+  <string name="Sharpen">Nitidesa</string>
+  <string name="Blur">Difuminat</string>
+  <string name="AreYouSureDeletePhoto">Voleu suprimir aquesta foto?</string>
+  <string name="AreYouSureDeleteVideo">Voleu suprimir aquest vídeo?</string>
+  <string name="DiscardChanges">Voleu descartar els canvis?</string>
+  <!--privacy settings-->
+  <string name="PrivacySettings">Privadesa i seguretat</string>
+  <string name="PrivacyTitle">Privadesa</string>
+  <string name="PrivacyLastSeen">Última connexió</string>
+  <string name="LastSeenEverybody">Tothom</string>
+  <string name="LastSeenContacts">Els meus contactes</string>
+  <string name="LastSeenNobody">Ningú</string>
+  <string name="LastSeenEverybodyMinus">Tothom (-%1$d)</string>
+  <string name="LastSeenContactsPlus">Els meus contactes (+%1$d)</string>
+  <string name="LastSeenContactsMinus">Els meus contactes (-%1$d)</string>
+  <string name="LastSeenContactsMinusPlus">Els meus contactes (-%1$d, +%2$d)</string>
+  <string name="LastSeenNobodyPlus">Ningú (+%1$d)</string>
+  <string name="SecurityTitle">Seguretat</string>
+  <string name="DeleteAccountTitle">El compte s\'autodestrueix</string>
+  <string name="DeleteAccountIfAwayFor">Si no hi sou durant</string>
+  <string name="DeleteAccountHelp">Si no inicieu sessió com a mínim una vegada en aquest període, el vostre compte s\'eliminarà, així com els vostres grups, missatges i contactes.</string>
+  <string name="DeleteAccountNowConfirmation">Voleu suprimir el compte?</string>
+  <string name="LastSeenHelp">Canvieu qui pot veure la vostra última connexió.</string>
+  <string name="LastSeenTitle">Qui pot veure la vostra última connexió?</string>
+  <string name="AddExceptions">Afegeix excepcions</string>
+  <string name="CustomHelp">Important: no podreu veure les connexions dels contactes amb qui no compartiu la vostra. En comptes d\'això, es mostraran connexions aproximades (fa poc, fa uns dies, fa unes setmanes).</string>
+  <string name="AlwaysShareWith">Comparteix-la sempre amb</string>
+  <string name="NeverShareWith">Mai la comparteixis amb</string>
+  <string name="CustomShareSettingsHelp">Aquesta configuració substituirà els valors anteriors.</string>
+  <string name="AlwaysShareWithTitle">Compartiu-la sempre</string>
+  <string name="AlwaysShareWithPlaceholder">Compartiu-la sempre amb els usuaris...</string>
+  <string name="NeverShareWithTitle">Mai la compartiu</string>
+  <string name="NeverShareWithPlaceholder">Mai la compartiu amb els usuaris...</string>
+  <string name="EmpryUsersPlaceholder">Afegeix usuaris</string>
+  <string name="PrivacyFloodControlError">Heu fet massa sol·licituds. Espereu fins que sigui possible canviar els paràmetres de privadesa.</string>
+  <string name="ClearOtherSessionsHelp">Tanca la sessió a tots els dispositius excepte aquest.</string>
+  <string name="RemoveFromListText">Mantingueu premut l\'usuari que voleu eliminar.</string>
+  <!--edit video view-->
+  <string name="EditVideo">Edita el vídeo</string>
+  <string name="OriginalVideo">Vídeo original</string>
+  <string name="EditedVideo">Vídeo editat</string>
+  <string name="SendingVideo">S\'està enviant el vídeo...</string>
+  <string name="CompressVideo">Comprimeix el vídeo</string>
+  <!--button titles-->
+  <string name="Next">Endavant</string>
+  <string name="Back">Enrere</string>
+  <string name="Done">Fet</string>
+  <string name="Open">Obre</string>
+  <string name="Cancel">Cancel·la</string>
+  <string name="Add">Afegeix</string>
+  <string name="Edit">Edita</string>
+  <string name="Send">Envia</string>
+  <string name="Call">Truca</string>
+  <string name="Copy">Copia</string>
+  <string name="Delete">Elimina</string>
+  <string name="Forward">Reenvia</string>
+  <string name="Retry">Reintenta</string>
+  <string name="FromCamera">Des de la càmera</string>
+  <string name="FromGalley">Des de la galeria</string>
+  <string name="DeletePhoto">Elimina la foto</string>
+  <string name="Set">Defineix</string>
+  <string name="OK">D\'acord</string>
+  <string name="Crop">RETALLA</string>
+  <!--messages-->
+  <string name="ActionKickUser">un1 ha fet fora un2</string>
+  <string name="ActionLeftUser">un1 ha abandonat el grup</string>
+  <string name="ActionAddUser">un1 ha afegit un2</string>
+  <string name="ActionRemovedPhoto">un1 ha eliminat la foto del grup</string>
+  <string name="ActionChangedPhoto">un1 ha canviat la foto del grup</string>
+  <string name="ActionChangedTitle">un1 ha canviat el nom del grup a un2</string>
+  <string name="ActionCreateGroup">un1 ha creat el grup</string>
+  <string name="ActionYouKickUser">Heu tret un2</string>
+  <string name="ActionYouLeftUser"> Heu abandonat el grup</string>
+  <string name="ActionYouAddUser">Heu afegit un2</string>
+  <string name="ActionYouRemovedPhoto">Heu eliminat la foto del grup</string>
+  <string name="ActionYouChangedPhoto">Heu canviat la foto del grup</string>
+  <string name="ActionYouChangedTitle">Heu canviat el nom del grup a un2</string>
+  <string name="ActionYouCreateGroup">Heu creat el grup</string>
+  <string name="ActionKickUserYou">un1 us ha fet fora</string>
+  <string name="ActionAddUserYou">un1 us ha afegit</string>
+  <string name="ActionAddUserSelf">un1 ha tornat al grup</string>
+  <string name="UnsuppotedMedia">Aquest missatge no és compatible amb la vostra versió del Telegram. Actualitzeu l\'app per veure\'l: http://telegram.org/update</string>
+  <string name="AttachPhoto">Foto</string>
+  <string name="AttachVideo">Vídeo</string>
+  <string name="AttachLocation">Ubicació</string>
+  <string name="AttachContact">Contacte</string>
+  <string name="AttachDocument">Fitxer</string>
+  <string name="AttachSticker">Adhesiu</string>
+  <string name="AttachAudio">Àudio</string>
+  <string name="FromYou">Usuari</string>
+  <string name="ActionTakeScreenshootYou">Heu fet una captura de pantalla</string>
+  <string name="ActionTakeScreenshoot">un1 ha fet una captura de pantalla</string>
+  <!--Alert messages-->
+  <string name="InvalidPhoneNumber">Número de telèfon no vàlid</string>
+  <string name="CodeExpired">El codi ha vençut. Torneu a iniciar la sessió.</string>
+  <string name="FloodWait">Heu excedit el nombre d\'intents. Torneu-ho a provar més tard.</string>
+  <string name="InvalidCode">Codi no vàlid</string>
+  <string name="InvalidFirstName">Nom no vàlid</string>
+  <string name="InvalidLastName">Cognoms no vàlids</string>
+  <string name="Loading">S\'està carregant...</string>
+  <string name="NoPlayerInstalled">No teniu cap reproductor de vídeo. Instal·leu-ne un per continuar</string>
+  <string name="NoMailInstalled">Envieu un missatge a sms@telegram.org i expliqueu-nos el problema.</string>
+  <string name="NoHandleAppInstalled">No teniu cap aplicació que permeti obrir fitxers de tipus MIME «%1$s». Instal·leu-ne una per continuar</string>
+  <string name="InviteUser">Aquest usuari encara no té el Telegram. Voleu enviar-li una invitació?</string>
+  <string name="AreYouSure">N\'esteu segur?</string>
+  <string name="AddToTheGroup">Voleu afegir %1$s al grup?\n\nNúmero d\'últims missatges a reenviar:</string>
+  <string name="ForwardMessagesTo">Voleu reenviar els missatges a %1$s?</string>
+  <string name="SendMessagesTo">Voleu enviar els missatges a %1$s?</string>
+  <string name="AreYouSureLogout">Esteu segur que voleu sortir?\n\nPodeu utilitzar igualment el Telegram en tots els vostres dispositius alhora.\n\nRecordeu que en tancar la sessió s\'eliminen els Xats Secrets.</string>
+  <string name="AreYouSureSessions">Esteu segur que voleu tancar totes les altres sessions?</string>
+  <string name="AreYouSureDeleteAndExit">Esteu segur que voleu eliminar i abandonar el grup?</string>
+  <string name="AreYouSureDeleteThisChat">Esteu segur que voleu eliminar aquest xat?</string>
+  <string name="AreYouSureShareMyContactInfo">Esteu segur que voleu compartir la vostra informació de contacte?</string>
+  <string name="AreYouSureBlockContact">Esteu segur que voleu blocar aquest contacte?</string>
+  <string name="AreYouSureUnblockContact">Esteu segur que voleu blocar aquest contacte?</string>
+  <string name="AreYouSureDeleteContact">Esteu segur que voleu eliminar aquest contacte?</string>
+  <string name="AreYouSureSecretChat">Esteu segur que voleu iniciar el xat secret?</string>
+  <string name="AreYouSureRegistration">Esteu segur que voleu cancel·lar el registre?</string>
+  <string name="AreYouSureClearHistory">Esteu segur que voleu esborrar l\'historial?</string>
+  <string name="AreYouSureDeleteMessages">Esteu segur que voleu eliminar %1$s?</string>
+  <string name="SendMessagesToGroup">Voleu enviar els missatges a %1$s?</string>
+  <string name="ForwardMessagesToGroup">Voleu reenviar els missatges a %1$s?</string>
+  <string name="FeatureUnavailable">Aquesta característica no es troba disponible al teu país.</string>
+  <!--Intro view-->
+  <string name="Page1Title">Plus Messenger</string>
+  <string name="Page2Title">Ràpid</string>
+  <string name="Page3Title">Gratuït</string>
+  <string name="Page4Title">Segur</string>
+  <string name="Page5Title">Potent</string>
+  <string name="Page6Title">Al núvol</string>
+  <string name="Page7Title">Privat</string>
+  <string name="Page1Message">L\'aplicació de missatgeria <![CDATA[<b>més ràpida</b><br/>]]>del món. És <![CDATA[<b>gratuïta</b>]]> i <![CDATA[<b>segura</b>]]>.</string>
+  <string name="Page2Message">El <![CDATA[<b>Plus Messenger</b>]]> lliura els missatges<![CDATA[<br/>]]>més ràpid que qualsevol altra aplicació.</string>
+  <string name="Page3Message">El <![CDATA[<b>Plus Messenger</b>]]> sempre serà gratuït.<![CDATA[<br/>]]>Sense publicitat. Sense subscripcions.</string>
+  <string name="Page4Message">El <![CDATA[<b>Plus Messenger</b>]]> manté els vostres missatges<![CDATA[<br/>]]>protegits d\'atacs dels hackers.</string>
+  <string name="Page5Message">El <![CDATA[<b>Plus Messenger</b>]]> no posa límits a la mida<![CDATA[<br/>]]>dels vostres fitxers i xats.</string>
+  <string name="Page6Message">El <![CDATA[<b>Plus Messenger</b>]]> us permet accedir als vostres<![CDATA[<br/>]]>missatges des de múltiples dispositius.</string>
+  <string name="Page7Message">El <![CDATA[<b>Plus Messenger</b>]]> xifra de forma molt segura els<![CDATA[<br/>]]>missatges i permet que s\'autodestrueixin.</string>
+  <string name="StartMessaging">Comenceu a enviar missatges</string>
+  <!--plural-->
+  <string name="Online_zero">%1$d en línia </string>
+  <string name="Online_one">%1$d en línia</string>
+  <string name="Online_two">%1$d en línia</string>
+  <string name="Online_few">%1$d en línia</string>
+  <string name="Online_many">%1$d en línia</string>
+  <string name="Online_other">%1$d en línia</string>
+  <string name="Members_zero">No hi ha membres</string>
+  <string name="Members_one">%1$d membre</string>
+  <string name="Members_two">%1$d membres</string>
+  <string name="Members_few">%1$d membres</string>
+  <string name="Members_many">%1$d membres</string>
+  <string name="Members_other">%1$d membres</string>
+  <string name="AndMoreTyping_zero">i %1$d persones més estan escrivint</string>
+  <string name="AndMoreTyping_one">i %1$d persones més estan escrivint</string>
+  <string name="AndMoreTyping_two">i %1$d persones més estan escrivint</string>
+  <string name="AndMoreTyping_few">i %1$d persones més estan escrivint</string>
+  <string name="AndMoreTyping_many">i %1$d persones més estan escrivint</string>
+  <string name="AndMoreTyping_other">i %1$d persones més estan escrivint</string>
+  <string name="NewMessages_zero">no hi ha missatges nous</string>
+  <string name="NewMessages_one">%1$d missatge nou</string>
+  <string name="NewMessages_two">%1$d missatge nou</string>
+  <string name="NewMessages_few">%1$d missatge nou</string>
+  <string name="NewMessages_many">%1$d missatge nou</string>
+  <string name="NewMessages_other">%1$d missatge nou</string>
+  <string name="messages_zero">no hi ha missatges</string>
+  <string name="messages_one">%1$d missatge</string>
+  <string name="messages_two">%1$d missatges</string>
+  <string name="messages_few">%1$d missatges</string>
+  <string name="messages_many">%1$d missatges</string>
+  <string name="messages_other">%1$d missatges</string>
+  <string name="items_zero">cap element</string>
+  <string name="items_one">%1$d element</string>
+  <string name="items_two">%1$d elements</string>
+  <string name="items_few">%1$d elements</string>
+  <string name="items_many">%1$d elements</string>
+  <string name="items_other">%1$d elements</string>
+  <string name="FromChats_zero">de cap xat</string>
+  <string name="FromChats_one">d\'%1$d xat</string>
+  <string name="FromChats_two">de %1$d xats</string>
+  <string name="FromChats_few">de %1$d xats</string>
+  <string name="FromChats_many">de %1$d xats</string>
+  <string name="FromChats_other">de %1$d xats</string>
+  <string name="Seconds_zero">%1$d segons</string>
+  <string name="Seconds_one">%1$d segon</string>
+  <string name="Seconds_two">%1$d segons</string>
+  <string name="Seconds_few">%1$d segons</string>
+  <string name="Seconds_many">%1$d segons</string>
+  <string name="Seconds_other">%1$d segons</string>
+  <string name="Minutes_zero">%1$d minuts</string>
+  <string name="Minutes_one">%1$d minut</string>
+  <string name="Minutes_two">%1$d minuts</string>
+  <string name="Minutes_few">%1$d minuts</string>
+  <string name="Minutes_many">%1$d minuts</string>
+  <string name="Minutes_other">%1$d minuts</string>
+  <string name="Hours_zero">%1$d hores</string>
+  <string name="Hours_one">%1$d hora</string>
+  <string name="Hours_two">%1$d hores</string>
+  <string name="Hours_few">%1$d hores</string>
+  <string name="Hours_many">%1$d hores</string>
+  <string name="Hours_other">%1$d hores</string>
+  <string name="Days_zero">%1$d dies</string>
+  <string name="Days_one">%1$d dia</string>
+  <string name="Days_two">%1$d dies</string>
+  <string name="Days_few">%1$d dies</string>
+  <string name="Days_many">%1$d dies</string>
+  <string name="Days_other">%1$d dies</string>
+  <string name="Weeks_zero">%1$d setmanes</string>
+  <string name="Weeks_one">%1$d setmana</string>
+  <string name="Weeks_two">%1$d setmanes</string>
+  <string name="Weeks_few">%1$d setmanes</string>
+  <string name="Weeks_many">%1$d setmanes</string>
+  <string name="Weeks_other">%1$d setmanes</string>
+  <string name="Months_zero">%1$d mesos</string>
+  <string name="Months_one">%1$d mes</string>
+  <string name="Months_two">%1$d mesos</string>
+  <string name="Months_few">%1$d mesos</string>
+  <string name="Months_many">%1$d mesos</string>
+  <string name="Months_other">%1$d mesos</string>
+  <string name="Years_zero">%1$d anys</string>
+  <string name="Years_one">%1$d any</string>
+  <string name="Years_two">%1$d anys</string>
+  <string name="Years_few">%1$d anys</string>
+  <string name="Years_many">%1$d anys</string>
+  <string name="Years_other">%1$d anys</string>
+  <string name="Users_zero">%1$d usuaris</string>
+  <string name="Users_one">%1$d usuari</string>
+  <string name="Users_two">%1$d usuaris</string>
+  <string name="Users_few">%1$d usuaris</string>
+  <string name="Users_many">%1$d usuaris</string>
+  <string name="Users_other">%1$d usuaris</string>
+  <!--date formatters-->
+  <string name="formatterMonthYear">MMMM \'del\' yyyy</string>
+  <string name="formatterMonth">dd MMM</string>
+  <string name="formatterYear">dd.MM.yy</string>
+  <string name="formatterYearMax">dd.MM.yyyy</string>
+  <string name="chatDate">d MMMM</string>
+  <string name="chatFullDate">d MMMM \'del\' yyyy</string>
+  <string name="formatterWeek">EEE</string>
+  <string name="formatterDay24H">HH:mm</string>
+  <string name="formatterDay12H">h:mm a</string>
+  <string name="formatDateAtTime">%1$s a les %2$s</string>
+    <!--Telegram+ Catalan-->
+    <!--Smart Notifications-->
+    <string name="SmartNotification">Notificació intel·ligent</string>
+    <string name="TimeUnitSeconds">Segon(s)</string>
+    <string name="TimeUnitMinutes">Minut(s)</string>
+    <string name="TimeUnitHours">hora(es)</string>
+    <string name="TimeUnitDays">Dia(es)</string>
+    <string name="settings_smart_notify_begin">Sona com a màxim</string>
+    <string name="settings_smart_notify_mid1">vegades</string>
+    <string name="settings_smart_notify_mid11">vegada</string>
+    <string name="settings_smart_notify_mid2">en</string>
+    <!---->
+    <string name="TelegramForAndroid">Plus Messenger per Android</string>
+  <string name="Theming">Aparença</string>
+  <string name="colorHexInvalid">Codi de color hexadecimal no vàlid.</string>
+  <string name="themeColor">Color del tema</string>
+  <string name="ResetThemeSettings">Restableix la configuració del tema</string>
+  <string name="ResetThemeSettingsSum">Desfés tots els canvis al tema</string>
+  <string name="ResetThemeToastText">S\'ha restablit la configuració per defecte.</string>
+    <string name="General">General</string>
+    <string name="Screens">Pantalles</string>
+    <string name="MainScreen">Pantalla principal</string>
+  <string name="ChatScreen">Pantalla de xats</string>
+  <string name="ContactsScreen">Pantalla de contactes</string>
+    <string name="Header">Capçalera</string>
+    <string name="Rows">Files</string>
+  <string name="ChatList">Llista de xats</string>
+  <string name="ChatsList">Llista de xats</string>
+  <string name="ContactsList">Llista de contactes</string>
+  <string name="HeaderColor">Color de la capçalera</string>
+  <string name="NameColor">Color del nom</string>
+  <string name="NameSize">Mida del nom</string>
+  <string name="MessageColor">Color del missatge</string>
+  <string name="MessageSize">Mida del missatge</string>
+  <string name="TimeDateColor">Color d\'hora i data</string>
+  <string name="TimeDateSize">Mida d\'hora i data</string>
+  <string name="CountColor">Color del comptador</string>
+  <string name="CountSize">Mida del comptador</string>
+  <string name="RowColor">Color de les files</string>
+  <string name="CountBGColor">Color de fons del comptador</string>
+  <string name="StatusColor">Color de l\'estat</string>
+  <string name="StatusSize">Mida de l\'estat</string>
+  <string name="RBubbleColor">Color de la bombolla dreta</string>
+  <string name="LBubbleColor">Color de la bombolla esquerra</string>
+  <string name="DateColor">Color de la data</string>
+  <string name="DateSize">Mida de la data</string>
+  <string name="DateBubbleColor">Color de la bombolla de la data</string>
+  <string name="RTextColor">Color del text dret</string>
+  <string name="LTextColor">Color del text esquerre</string>
+  <string name="RTimeColor">Color de l\'hora dreta</string>
+  <string name="LTimeColor">Color de l\'hora esquerra</string>
+  <string name="TimeSize">Mida  de l\'hora</string>
+  <string name="EditTextColor">Color de l\'entrada de text</string>
+  <string name="EditTextSize">Mida de l\'entrada de text</string>
+  <string name="EditTextBGColor">Color de fons de l\'entrada de text</string>
+  <string name="EmojiViewBGColor">Color de fons dels emoji</string>
+  <string name="EmojiViewTabColor">Color de la pestanya dels emoji</string>
+  <string name="OnlineColor">Color de «en línia»</string>
+    <string name="ChatMusic">Música</string>
+  <string name="SaveTheme">Desa el tema</string>
+  <string name="SaveThemeSum">Desa el tema a la carpeta Telegram/Themes</string>
+  <string name="SaveThemeToastText">S\'ha desat el tema.</string>
+  <string name="SavedTo">%1$s desat a %2$s</string>
+  <string name="SaveErrorMsg0">El tema no s\'ha creat. Feu qualsevol canvi primer.</string>
+  <string name="restoreOkMsg">S\'ha restaurat la configuració des de la SD</string>
+  <string name="restoreErrorMsg">No s\'ha trobat cap fitxer de configuració a %s</string>
+  <string name="NoMediaMessage">No s\'ha trobat cap targeta SD.</string>
+  <string name="EnterName">Introduïu un nom</string>
+    <string name="Themes">Temes</string>
+  <string name="ApplyTheme">Aplica un tema</string>
+  <string name="ApplyThemeSum">Aplica un tema xml des d\'una carpeta local</string>
+  <string name="MemberColor">Color dels membres</string>
+  <string name="ChecksColor">Color dels ticks</string>
+  <string name="MuteColor">Color de l\'icona de silenci</string>
+  <string name="SendLogs">Envia registres</string>
+  <string name="SendLogsEmpty">No hi ha cap registre</string>
+  <string name="SendIcon">Icona d\'enviar</string>
+  <string name="HideMobile">Amaga el número de telèfon al menú</string>
+  <string name="FloatingPencilColor">Color del botó de llapis</string>
+  <string name="FloatingBGColor">Color de fons del botó de llapis</string>
+    <string name="Community">Comunitat G+</string>
+  <string name="TypingColor">Color de «està escrivint...»</string>
+  <string name="EditTextIconsColor">Color de les icones d\'entrada de text</string>
+  <string name="NavigationDrawer">Menú principal</string>
+  <string name="OptionsList">Llista d\'opcions</string>
+  <string name="ListColor">Color de la llista</string>
+  <string name="OwnNameSize">Mida del nom</string>
+  <string name="PhoneColor">Color del telèfon</string>
+  <string name="PhoneSize">Mida del telèfon</string>
+  <string name="AvatarColor">Color de l\'avatar</string>
+  <string name="IconColor">Color de la icona d\'opcions</string>
+  <string name="OptionColor">Color de les opcions</string>
+  <string name="OptionSize">Mida de les opcions</string>
+  <string name="VersionColor">Color de la versió</string>
+  <string name="VersionSize">Mida de la versió</string>
+  <string name="HeaderTitleColor">Color del títol de la capçalera</string>
+  <string name="HeaderIconsColor">Icones de la capçalera</string>
+  <string name="DividerColor">Color del divisor</string>
+  <string name="AvatarRadius">Radi de l\'avatar</string>
+  <string name="SetMemberColor">Estableix el color dels membres</string>
+  <string name="ForwardNameColor">Color del nom al missatge reenviat</string>
+  <string name="HeaderTitle">Títol de capçalera</string>
+  <string name="ForwardNoQuote">Reenvia sense citar</string>
+  <string name="DisableMessageClick">Inhabilita el menú emergent</string>
+  <string name="ProfileScreen">Perfil de contacte/grup</string>
+  <string name="HideBackground">Amaga el fons personalitzat</string>
+  <string name="RLinkColor">Color de l\'enllaç dret</string>
+  <string name="LLinkColor">Color de l\'enllaç esquerre</string>
+  <string name="ThemeApplied">S\'ha aplicat el tema!</string>
+  <string name="ClickOkToRestart">Premeu D\'acord per reiniciar</string>
+  <string name="ShowAndroidEmoji">Mostra les icones del sistema</string>
+  <string name="BubbleStyle">Estil de la bambolla</string>
+  <string name="KeepOriginalFilename">Conserva el nom de fitxer original</string>
+  <string name="KeepOriginalFilenameHelp">En compte de només números, els fitxers es desaran usant el format nom_data</string>
+  <string name="AvatarSize">Mida de l\'avatar</string>
+  <string name="AvatarAlignTop">Alinea l\'avatar a sobre</string>
+  <string name="AvatarMarginLeft">Marge esquerre de l\'avatar</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-fr/strings.xml b/TMessagesProj/src/main/res/values-fr/strings.xml
new file mode 100644
index 000000000..686177b62
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-fr/strings.xml
@@ -0,0 +1,885 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<resources>
+  <string name="AppName">Plus Messenger</string>
+  <string name="LanguageName">Français</string>
+  <string name="LanguageNameInEnglish">French</string>
+  <string name="LanguageCode">fr</string>
+  <!--signin view-->
+  <string name="YourPhone">Votre numéro</string>
+  <string name="StartText">Confirmez votre indicatif national\net entrez votre numéro de téléphone</string>
+  <string name="ChooseCountry">Sélectionnez un pays</string>
+  <string name="WrongCountry">Code pays incorrect</string>
+  <!--code enter view-->
+  <string name="YourCode">Votre code</string>
+  <string name="SentSmsCode">Un code d\'activation vous a été envoyé par SMS</string>
+  <string name="CallText">Nous vous appellerons dans %1$d:%2$02d</string>
+  <string name="Calling">Appel en cours…</string>
+  <string name="Code">Code</string>
+  <string name="WrongNumber">Numéro erroné ?</string>
+  <string name="DidNotGetTheCode">Vous n\'avez pas reçu le code ?</string>
+  <!--signup view-->
+  <string name="YourName">Votre nom</string>
+  <string name="RegisterText">Saisissez vos nom et prénom</string>
+  <!--<string name="RegisterText">Set up your name and picture</string>-->
+  <string name="FirstName">Prénom (requis)</string>
+  <string name="LastName">Nom (facultatif)</string>
+  <string name="CancelRegistration">Annuler l\'enregistrement</string>
+  <!--chats view-->
+  <string name="Settings">Paramètres</string>
+  <string name="Contacts">Contacts</string>
+  <string name="NewGroup">Nouveau groupe</string>
+  <string name="Yesterday">hier</string>
+  <string name="NoResult">Aucun résultat</string>
+  <string name="NoChats">Aucune conversation pour l\'instant…</string>
+  <string name="NoChatsHelp">Démarrez une conversation avec le bouton\nNouveau Message en bas à droite ou \nouvrez le menu pour plus d\'options.</string>
+  <string name="WaitingForNetwork">En attente du réseau…</string>
+  <string name="Connecting">Connexion…</string>
+  <string name="Updating">Mise à jour…</string>
+  <string name="NewSecretChat">Nouvelle conversation secrète</string>
+  <string name="AwaitingEncryption">En attente de la connexion de %s…</string>
+  <string name="EncryptionRejected">Conversation secrète annulée</string>
+  <string name="EncryptionProcessing">Échange des clés de chiffrement…</string>
+  <string name="EncryptedChatStartedOutgoing">%s a rejoint votre conversation secrète.</string>
+  <string name="EncryptedChatStartedIncoming">Vous avez rejoint la conversation secrète.</string>
+  <string name="ClearHistory">Supprimer l\'historique</string>
+  <string name="DeleteChat">Supprimer et quitter</string>
+  <string name="DeleteChatUser">Supprimer la conversation</string>
+  <string name="HiddenName">Compte supprimé</string>
+  <string name="SelectChat">Sélectionnez une conversation</string>
+  <string name="PhotoTip">Touchez et maintenez pour voir</string>
+  <string name="CompatibilityChat">%1$s utilise une version plus ancienne de Telegram, par conséquent les photos secrètes seront affichées en mode compatibilité.\n\Une fois que %2$s aura mis à jour son application, les photos avec compte-à-rebours de 1 minute ou moins seront visibles en mode \"toucher-pour-voir\" et vous serez averti si votre interlocuteur fait une capture d\'écran.</string>
+  <string name="SearchMessages">MESSAGES</string>
+  <string name="Search">Recherche</string>
+  <string name="MuteNotifications">Notifications muettes</string>
+  <string name="MuteFor">Muet pendant %1$s</string>
+  <string name="UnmuteNotifications">Activer les notifications</string>
+  <string name="WillUnmuteIn">Dans %1$s</string>
+  <string name="MuteDisable">Désactiver</string>
+  <string name="Hashtags">HASHTAGS</string>
+  <!--broadcasts-->
+  <string name="NewBroadcastList">Nouvelle liste de diffusion</string>
+  <string name="EnterListName">Saisissez le nom de la liste</string>
+  <string name="YouCreatedBroadcastList">Vous avez créé un liste de diffusion</string>
+  <string name="AddRecipient">Ajouter un destinataire</string>
+  <string name="KickFromBroadcast">Supprimer de la liste de diffusion</string>
+  <!--documents view-->
+  <string name="SelectFile">Sélectionnez un fichier</string>
+  <string name="FreeOfTotal">%1$s sur %2$s disponible</string>
+  <string name="UnknownError">Erreur inconnue</string>
+  <string name="AccessError">Erreur d\'accès</string>
+  <string name="NoFiles">Aucun fichier pour l\'instant…</string>
+  <string name="FileUploadLimit">La taille du fichier ne devrait pas dépasser %1$s</string>
+  <string name="NotMounted">Stockage non-monté</string>
+  <string name="UsbActive">Transfert USB actif</string>
+  <string name="InternalStorage">Stockage interne</string>
+  <string name="ExternalStorage">Stockage externe</string>
+  <string name="SystemRoot">Racine du système</string>
+  <string name="SdCard">Carte SD</string>
+  <string name="Folder">Dossier</string>
+  <string name="GalleryInfo">Envoyer les images sans compression</string>
+  <!--chat view-->
+  <string name="Invisible">invisible</string>
+  <string name="Typing">écrit…</string>
+  <string name="IsTyping">écrit…</string>
+  <string name="AreTyping">écrivent…</string>
+  <string name="IsRecordingAudio">%1$s capture de l\'audio...</string>
+  <string name="IsSendingPhoto">%1$s envoie une photo...</string>
+  <string name="IsSendingVideo">%1$s envoie une vidéo...</string>
+  <string name="IsSendingFile">%1$s envoie un fichier...</string>
+  <string name="RecordingAudio">enregistre du son...</string>
+  <string name="SendingPhoto">envoie une photo...</string>
+  <string name="SendingVideoStatus">envoie une vidéo...</string>
+  <string name="SendingFile">envoie un fichier...</string>
+  <string name="GotAQuestion">Une question\nsur Telegram?</string>
+  <string name="ChatTakePhoto">Prendre une photo</string>
+  <string name="ChatGallery">Galerie</string>
+  <string name="ChatLocation">Localisation</string>
+  <string name="ChatVideo">Vidéo</string>
+  <string name="ChatDocument">Fichier</string>
+  <string name="NoMessages">Aucun message pour l\'instant…</string>
+  <string name="ForwardedMessage">Message transféré</string>
+  <string name="From">De</string>
+  <string name="NoRecent">Aucun récent</string>
+  <string name="Message">Message</string>
+  <string name="TypeMessage">Message</string>
+  <string name="ShareMyContactInfo">Partager mes informations de contact</string>
+  <string name="AddToContacts">Ajouter aux contacts</string>
+  <string name="EncryptedPlaceholderTitleIncoming">%s vous a invité à rejoindre une discussion privée.</string>
+  <string name="EncryptedPlaceholderTitleOutgoing">Vous avez invité %s à rejoindre une discussion privée.</string>
+  <string name="EncryptedDescriptionTitle">Les discussions privées :</string>
+  <string name="EncryptedDescription1">utilisent le chiffrement entre mobiles</string>
+  <string name="EncryptedDescription2">ne laissent aucune trace sur nos serveurs</string>
+  <string name="EncryptedDescription3">ont un délai d\'auto-destruction des messages</string>
+  <string name="EncryptedDescription4">n\'autorisent pas le transfert</string>
+  <string name="YouWereKicked">Vous avez été ejecté du groupe</string>
+  <string name="YouLeft">Vous avez quitté ce groupe</string>
+  <string name="DeleteThisGroup">Supprimer ce groupe</string>
+  <string name="DeleteThisChat">Supprimer cette conversation.</string>
+  <string name="SlideToCancel">GLISSER POUR ANNULER
+</string>
+  <string name="SaveToDownloads">Enregistrer dans les téléchargements</string>
+  <string name="ShareFile">Partager</string>
+  <string name="ApplyLocalizationFile">Appliquer le fichier de localisation</string>
+  <string name="UnsupportedAttachment">Type de pièce-jointe inconnu</string>
+  <string name="SetTimer">Temps avant auto-destruction</string>
+  <string name="ServiceNotifications">Notifications de Service</string>
+  <string name="GettingLinkInfo">Obtention d\'informations sur le lien…</string>
+  <!--notification-->
+  <string name="MessageLifetimeChanged">%1$s a défini l\'auto-destruction des messages à %2$s</string>
+  <string name="MessageLifetimeChangedOutgoing">Vous avez défini l\'auto-destruction des messages à %1$s</string>
+  <string name="MessageLifetimeRemoved">%1$s a désactivé l\'auto-destruction des messages</string>
+  <string name="MessageLifetimeYouRemoved">Vous avez désactivé l\'auto-destruction des messages</string>
+  <string name="YouHaveNewMessage">Vous avez un nouveau message</string>
+  <string name="NotificationMessageText">%1$s : %2$s</string>
+  <string name="NotificationMessageNoText">%1$s vous a envoyé un message</string>
+  <string name="NotificationMessagePhoto">%1$s vous a envoyé une photo</string>
+  <string name="NotificationMessageVideo">%1$s vous a envoyé une vidéo</string>
+  <string name="NotificationMessageContact">%1$s a partagé un contact avec vous</string>
+  <string name="NotificationMessageMap">%1$s vous a envoyé une localisation</string>
+  <string name="NotificationMessageDocument">%1$s vous a envoyé un fichier</string>
+  <string name="NotificationMessageAudio">%1$s vous a envoyé un fichier audio</string>
+  <string name="NotificationMessageSticker">%1$s vous a envoyé un sticker</string>
+  <string name="NotificationMessageGroupText">%1$s @ %2$s : %3$s</string>
+  <string name="NotificationMessageGroupNoText">%1$s a envoyé un message au groupe %2$s</string>
+  <string name="NotificationMessageGroupPhoto">%1$s a envoyé une photo au groupe %2$s</string>
+  <string name="NotificationMessageGroupVideo">%1$s a envoyé une vidéo au groupe %2$s</string>
+  <string name="NotificationMessageGroupContact">%1$s a partagé un contact avec le groupe %2$s</string>
+  <string name="NotificationMessageGroupMap">%1$s a envoyé une localisation au groupe %2$s</string>
+  <string name="NotificationMessageGroupDocument">%1$s a envoyé un fichier au groupe %2$s</string>
+  <string name="NotificationMessageGroupAudio">%1$s a envoyé un fichier audio au groupe %2$s</string>
+  <string name="NotificationMessageGroupSticker">%1$s a envoyé un sticker au groupe %2$s</string>
+  <string name="NotificationInvitedToGroup">%1$s vous a invité dans le groupe %2$s</string>
+  <string name="NotificationEditedGroupName">%1$s a renommé le groupe %2$s</string>
+  <string name="NotificationEditedGroupPhoto">%1$s a changé la photo du groupe %2$s</string>
+  <string name="NotificationGroupAddMember">%1$s a invité %3$s dans le groupe %2$s</string>
+  <string name="NotificationGroupAddSelf">%1$s est revenu dans le groupe %2$s</string>
+  <string name="NotificationGroupKickMember">%1$s a ejecté %3$s du groupe %2$s</string>
+  <string name="NotificationGroupKickYou">%1$s vous a ejecté du groupe %2$s</string>
+  <string name="NotificationGroupLeftMember">%1$s a quitté le groupe %2$s</string>
+  <string name="NotificationContactJoined">%1$s a rejoint Telegram!</string>
+  <string name="NotificationUnrecognizedDevice">%1$s,\nNous avons détecté une connection à votre compte depuis un nouvel appareil le %2$s\n\nAppareil : %3$s\nEmplacement : %4$s\n\nSi ce n\'était pas vous, vous pouvez aller terminer cette session dans Paramètres - Vie privée et Sécurité - Sessions.\n\nSi vous pensez que qu\'une personne indésirable s\'est connectée à votre compte, vous pouvez activer la Vérification en deux étapes dans Paramètres - Vie privée et Sécurité.\n\nCordialement,\nL\'équipe Telegram</string>
+  <string name="NotificationContactNewPhoto">%1$s a actualisé sa photo de profil</string>
+  <string name="NotificationInvitedToGroupByLink">%1$s a rejoint le groupe %2$s avec un lien d\'invitation</string>
+  <string name="Reply">Répondre</string>
+  <string name="ReplyToGroup">Répondre à %1$s</string>
+  <string name="ReplyToUser">Répondre à %1$s</string>
+  <string name="NotificationMessagesPeopleDisplayOrder">%1$s %2$s</string>
+  <!--contacts view-->
+  <string name="SelectContact">Sélectionnez un contact</string>
+  <string name="NoContacts">Aucun contact pour l\'instant</string>
+  <string name="InviteText">Et si on changeait pour Plus Messenger: http://goo.gl/jnmjnZ</string>
+  <string name="TodayAt">à</string>
+  <string name="YesterdayAt">hier à</string>
+  <string name="Online">en ligne</string>
+  <string name="LastSeen">vu</string>
+  <string name="LastSeenDate">vu</string>
+  <string name="InviteFriends">Inviter des amis</string>
+  <string name="GlobalSearch">RECHERCHE GENERALE</string>
+  <string name="Lately">vu récemment</string>
+  <string name="WithinAWeek">vu dans la semaine</string>
+  <string name="WithinAMonth">vu au cours du dernier mois</string>
+  <string name="ALongTimeAgo">vu il y a longtemps</string>
+  <string name="NewMessageTitle">Nouveau message</string>
+  <!--group create view-->
+  <string name="SendMessageTo">Envoyer un message à…</string>
+  <string name="EnterGroupNamePlaceholder">Saisissez le nom du groupe</string>
+  <string name="GroupName">Nom du groupe</string>
+  <string name="MembersCount">%1$d/%2$d membres</string>
+  <string name="JoinToGroup">Voulez-vous rejoindre le groupe \'%1$s\'?</string>
+  <string name="JoinToGroupErrorFull">Désolé, ce groupe est déjà complet.</string>
+  <string name="JoinToGroupErrorNotExist">Désolé, ce groupe n\'a pas l\'air d\'exister.</string>
+  <string name="LinkCopied">Lien copié dans le presse-papier</string>
+  <string name="InviteToGroupByLink">Inviter au groupe par un lien </string>
+  <string name="InviteLink">Lien d\'invitation</string>
+  <string name="RevokeAlert">Êtes vous sûr(e) de vouloir révoquer ce lien? Plus personne ne pourra l\'utiliser pour rejoindre le groupe.</string>
+  <string name="RevokeAlertNewLink">L\'ancien lien d\'invitation a été désactivé. Un nouveau lien a été généré.</string>
+  <string name="RevokeButton">Révoquer</string>
+  <string name="RevokeLink">Révoquer le lien</string>
+  <string name="CopyLink">Copier le lien</string>
+  <string name="ShareLink">Partager le lien</string>
+  <string name="LinkInfo">N\'importe quelle personne utilisant l\'application Telegram pourra rejoindre votre groupe en suivant ce lien.</string>
+  <!--group info view-->
+  <string name="SharedMedia">Médias partagés</string>
+  <string name="SETTINGS">Paramètres</string>
+  <string name="AddMember">Ajouter un membre</string>
+  <string name="DeleteAndExit">Supprimer et quitter le groupe</string>
+  <string name="Notifications">Notifications</string>
+  <string name="KickFromGroup">Ejecté du groupe</string>
+  <!--contact info view-->
+  <string name="ShareContact">Partager</string>
+  <string name="AddContact">Ajouter</string>
+  <string name="AddContactTitle">Ajouter un contact</string>
+  <string name="BlockContact">Bloquer</string>
+  <string name="EditContact">Éditer</string>
+  <string name="DeleteContact">Supprimer</string>
+  <string name="PhoneHome">Accueil</string>
+  <string name="PhoneMobile">Mobile</string>
+  <string name="PhoneWork">Travail</string>
+  <string name="PhoneOther">Autre</string>
+  <string name="PhoneMain">Principal</string>
+  <string name="StartEncryptedChat">Démarrer une conversation secrète</string>
+  <string name="CreateEncryptedChatError">Une erreur s\'est produite.</string>
+  <string name="EncryptionKey">Clé de chiffrement</string>
+  <string name="MessageLifetime">Temps avant auto-destruction</string>
+  <string name="ShortMessageLifetimeForever">Désactivé</string>
+  <string name="EncryptionKeyDescription">Cette image est une visualisation de la clé de chiffrement pour cette conversation secrète avec <![CDATA[<b>]]>%1$s<![CDATA[</b>]]>.<![CDATA[<br><br>]]>Si l\'image semble similaire sur le téléphone de <![CDATA[<b>]]>%2$s<![CDATA[</b>]]>, votre conversation est sécurisée à 200%%.<![CDATA[<br><br>]]>Plus d\'informations sur telegram.org</string>
+  <string name="NumberUnknown">Inconnu</string>
+  <string name="Info">Info</string>
+  <string name="Phone">Téléphone</string>
+  <!--usernames-->
+  <string name="Username">Nom d\'utilisateur</string>
+  <string name="UsernamePlaceholder">Votre nom d\'utilisateur</string>
+  <string name="UsernameInUse">Désolé, ce nom d\'utilisateur est déjà utilisé.</string>
+  <string name="UsernameInvalid">Désolé, ce nom d\'utilisateur est invalide.</string>
+  <string name="UsernameInvalidShort">Un nom d\'utilisateur doit contenir 5 caractères minimum.</string>
+  <string name="UsernameInvalidLong">Le nom d\'utilisateur ne doit pas dépasser 32 caractères.</string>
+  <string name="UsernameInvalidStartNumber">Désolé, un nom d\'utilisateur ne peut pas commencer par un chiffre.</string>
+  <string name="UsernameHelp">Vous pouvez choisir un nom d\'utilisateur sur <![CDATA[<b>]]>Plus Messenger<![CDATA[</b>]]>. Si vous le faites, d\'autres personnes pourront vous trouver à l\'aide de celui-ci, et vous contacter sans connaitre votre numéro de téléphone.<![CDATA[<br><br>]]>Vous pouvez utiliser <![CDATA[<b>]]>a–z<![CDATA[</b>]]>, <![CDATA[<b>]]>0–9<![CDATA[</b>]]> et _. La longueur minimale est de <![CDATA[<b>]]>5<![CDATA[</b>]]> caractères.</string>
+  <string name="UsernameChecking">Vérification du nom d\'utilisateur...</string>
+  <string name="UsernameAvailable">%1$s est disponible.</string>
+  <string name="UsernameEmpty">Vide</string>
+  <string name="ErrorOccurred">Une erreur est survenue.</string>
+  <!--settings view-->
+  <string name="ResetNotificationsText">Rétablir tous les paramètres de notification par défaut</string>
+  <string name="TextSize">Taille de police des messages</string>
+  <string name="AskAQuestion">Poser une question</string>
+  <string name="EnableAnimations">Activer les animations</string>
+  <string name="Unblock">Débloquer</string>
+  <string name="UnblockText">Toucher et maintenir sur un utilisateur pour le débloquer.</string>
+  <string name="NoBlocked">Aucun utilisateur bloqué pour l\'instant</string>
+  <string name="MessageNotifications">Notifications de message</string>
+  <string name="Alert">Alerte</string>
+  <string name="MessagePreview">Prévisualisation du message</string>
+  <string name="GroupNotifications">Notifications de groupe</string>
+  <string name="Sound">Son</string>
+  <string name="InAppNotifications">Notifications internes</string>
+  <string name="InAppSounds">Sons dans l\'app</string>
+  <string name="InAppVibrate">Vibration dans l\'app</string>
+  <string name="Vibrate">Vibrer</string>
+  <string name="InAppPreview">Prévisualisation dans l\'app</string>
+  <string name="Reset">Réinitialiser</string>
+  <string name="ResetAllNotifications">Réinitialiser toutes les notifications</string>
+  <string name="UndoAllCustom">Réinitialiser tous les paramètres de notifications pour tous les contacts et groupes</string>
+  <string name="NotificationsAndSounds">Notifications et sons</string>
+  <string name="BlockedUsers">Utilisateurs bloqués</string>
+  <string name="LogOut">Se déconnecter</string>
+  <string name="NoSound">Pas de son</string>
+  <string name="Default">Par défaut</string>
+  <string name="Support">Support</string>
+  <string name="OnlyIfSilent">Seulement si silencieux</string>
+  <string name="ChatBackground">Arrière-plan de conversation</string>
+  <string name="MessagesSettings">Messages</string>
+  <string name="SendByEnter">Envoyer en pressant la touche entrée</string>
+  <string name="TerminateAllSessions">Terminer toutes les autres sessions</string>
+  <string name="Events">Évènements</string>
+  <string name="ContactJoined">Un contact a rejoint Telegram</string>
+  <string name="Pebble">PEBBLE</string>
+  <string name="Language">Langue</string>
+  <string name="AskAQuestionInfo">Veuillez noter que le support Telegram est assuré par des bénévoles. Nous essayons de répondre aussi vite que possible, mais cela peut prendre un peu de temps. <![CDATA[<br><br>]]>Veuillez consulter la <![CDATA[<a href=\"http://telegram.org/faq#general\">FAQ Telegram</a>]]> : cela répond à la plupart des questions et donne des conseils pour les <![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">problèmes</a>]]>.</string>
+  <string name="AskButton">Demandez à un bénévole</string>
+  <string name="TelegramFaq">FAQ de Telegram</string>
+  <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+  <string name="DeleteLocalization">Supprimer la localisation ?</string>
+  <string name="IncorrectLocalization">Fichier de localisation incorrect</string>
+  <string name="Enabled">Activé</string>
+  <string name="Disabled">Désactivé</string>
+  <string name="NotificationsService">Service de notifications</string>
+  <string name="NotificationsServiceDisableInfo">Si les services de google play vous suffisent pour recevoir les notifications, vous pouvez désactiver le service de notifications. Nous vous conseillons cependant de le laisser activé afin qu\'il puisse fonctionner en arrière-plan. Vous recevrez ainsi les notifications instantanément.</string>
+  <string name="SortBy">Trier par</string>
+  <string name="ImportContacts">Importer des contacts</string>
+  <string name="SortFirstName">Prénom</string>
+  <string name="SortLastName">Nom</string>
+  <string name="LedColor">Couleur de la LED</string>
+  <string name="PopupNotification">Notifications popup</string>
+  <string name="NoPopup">Pas de popup</string>
+  <string name="OnlyWhenScreenOn">Uniquement lorsque l\'écran est allumé</string>
+  <string name="OnlyWhenScreenOff">Uniquement lorsque l\'écran est éteint</string>
+  <string name="AlwaysShowPopup">Toujours afficher les popups</string>
+  <string name="BadgeNumber">Compteur de Badge</string>
+  <string name="Short">Bref</string>
+  <string name="Long">Long</string>
+  <string name="SystemDefault">Paramètres par défaut</string>
+  <string name="SettingsDefault">Réglages par défaut</string>
+  <string name="AutomaticMediaDownload">Téléchargement automatique des médias</string>
+  <string name="WhenUsingMobileData">Lors de la connexion aux données mobiles</string>
+  <string name="WhenConnectedOnWiFi">Lors d\'une connexion WIFI</string>
+  <string name="WhenRoaming">En itinérance</string>
+  <string name="NoMediaAutoDownload">Aucun média</string>
+  <string name="SaveToGallerySettings">Enregistrer dans la galerie</string>
+  <string name="EditName">Éditer le nom</string>
+  <string name="NotificationsPriority">Priorité</string>
+  <string name="NotificationsPriorityDefault">Par défaut</string>
+  <string name="NotificationsPriorityLow">Bas</string>
+  <string name="NotificationsPriorityHigh">Haut</string>
+  <string name="NotificationsPriorityMax">Max</string>
+  <string name="RepeatNotificationsNever">Jamais</string>
+  <string name="RepeatNotifications">Répéter les notifications</string>
+  <string name="PhoneNumberHelp">Vous pouvez changer votre numéro Telegram ici. Votre compte et toutes vos données cloud — messages, médias, contacts, etc. seront déplacés vers votre nouveau numéro.\n\n<![CDATA[<b>Important:</b>]]> tous vos contacts se verront ajouter votre <![CDATA[<b>nouveau numéro</b>]]> à leur carnet d\'adresses, à condition d\'avoir votre ancien numéro et que vous ne les ayez pas bloqués via Telegram.</string>
+  <string name="PhoneNumberAlert">Tous vos contacts Telegram se verront ajouter votre nouveau numéro à leur carnet d\'adresses, à condition d\'avoir votre ancien numéro et que vous ne les ayez pas bloqués dans Telegram.</string>
+  <string name="PhoneNumberChange">CHANGER LE NUMERO</string>
+  <string name="ChangePhoneNewNumber">Nouveau numéro</string>
+  <string name="ChangePhoneHelp">Nous allons envoyer un SMS avec un code de confirmation à votre nouveau numéro.</string>
+  <string name="ChangePhoneNumberOccupied">Le numéro %1$s est déjà lié à un compte Telegram. Prière de supprimer ce compte avant de migrer vers le nouveau numéro.</string>
+  <string name="NotificationsOther">Autre</string>
+  <string name="NotificationsDisabled">Désactivé</string>
+  <string name="VibrationDisabled">Désactivé</string>
+  <string name="LedDisabled">Désactivé</string>
+  <string name="RepeatDisabled">Désactiver</string>
+  <string name="InChatSound">Sons des conversations</string>
+  <string name="SoundDefault">Par défaut</string>
+  <string name="SmartNotifications">Notifications intelligentes</string>
+  <string name="SmartNotificationsDisabled">Désactivé</string>
+  <string name="SmartNotificationsInfo">Ne pas sonner plus de %1$s par %2$s</string>
+  <string name="SmartNotificationsSoundAtMost">Ne pas sonner plus de...</string>
+  <string name="SmartNotificationsTimes">fois</string>
+  <string name="SmartNotificationsWithin">dans</string>
+  <string name="SmartNotificationsMinutes">minutes</string>
+  <!--sessions view-->
+  <string name="SessionsTitle">Sessions actives</string>
+  <string name="CurrentSession">Session actuelle</string>
+  <string name="NoOtherSessions">Aucune autre session active</string>
+  <string name="NoOtherSessionsInfo">Vous pouvez vous connectez depuis d\'autres téléphones, tablettes et ordinateurs avec ce même numéro de téléphone. Vos données seront automatiquement synchronisées.</string>
+  <string name="OtherSessions">Sessions actives</string>
+  <string name="SessionsInfo">Contrôlez vos sessions sur d\'autres appareils.</string>
+  <string name="TerminateSessionInfo">Appuyez sur une session pour la terminer.</string>
+  <string name="TerminateSessionQuestion">Terminer cette session ?</string>
+  <string name="UnofficialApp">App non-officiel</string>
+  <!--passcode view-->
+  <string name="Passcode">Verrouillage par code d\'accès</string>
+  <string name="ChangePasscode">Changer le code d\'accès</string>
+  <string name="ChangePasscodeInfo">Lorsque vous configurez un code d\'accès supplémentaire, une icône de verrouillage s\'affiche sur la page des chats. Touchez-le pour verrouiller et déverrouiller votre application Telegram. \ n \ nNote: si vous oubliez le code d\'accès, vous devrez supprimer et réinstaller l\'application. Tous les chats secrets seront perdues.</string>
+  <string name="ChangePasscodeAlert">Vous allez à présent voir une icône de verrouillage sur la page des chats. Touchez-le pour verrouiller votre application Telegram avec votre nouveau code d\'accès.</string>
+  <string name="PasscodePIN">PIN</string>
+  <string name="PasscodePassword">Mot de passe</string>
+  <string name="EnterCurrentPasscode">Saisissez votre code d\'accès actuel</string>
+  <string name="EnterNewFirstPasscode">Saisissez un code d\'accès</string>
+  <string name="EnterNewPasscode">Saisissez votre nouveau code d\'accès</string>
+  <string name="EnterYourPasscode">Saisissez votre code d\'accès</string>
+  <string name="ReEnterYourPasscode">Saisissez à nouveau votre nouveau code d\'accès</string>
+  <string name="InvalidPasscode">Code invalide</string>
+  <string name="PasscodeDoNotMatch">Les codes d\'accès ne correspondent pas</string>
+  <string name="AutoLock">Verrouillage automatique</string>
+  <string name="AutoLockInfo">Code d\'accès requit en cas d\'absence</string>
+  <string name="AutoLockInTime">dans %1$s</string>
+  <string name="AutoLockDisabled">Verrouillage désactivé</string>
+  <!--media view-->
+  <string name="NoMedia">Partager des photos et des vidéos dans cette conversation et y accéder sur chacun de vos appareils. </string>
+  <string name="DocumentsTitle">Fichiers</string>
+  <string name="SharedMediaTitle">Média partagé</string>
+  <string name="NoSharedFiles">Partager des fichiers et des documents dans cette conversation et y accéder sur chacun de vos appareils. </string>
+  <!--map view-->
+  <string name="Map">Carte</string>
+  <string name="Satellite">Satellite</string>
+  <string name="Hybrid">Hybride</string>
+  <string name="MetersAway">m de distance</string>
+  <string name="KMetersAway">km de distance</string>
+  <string name="SendLocation">envoyer ma localisation actuelle</string>
+  <string name="SendSelectedLocation">Envoyer la localisation selectionnée</string>
+  <string name="ShareLocation">Localisation</string>
+  <string name="AccurateTo">Exact à %1$s</string>
+  <string name="NearbyPlaces">OU CHOISIR UN LIEU</string>
+  <!--photo gallery view-->
+  <string name="ShowAllMedia">Voir tous les médias</string>
+  <string name="SaveToGallery">Enregistrer dans la galerie</string>
+  <string name="Of">%1$d de %2$d</string>
+  <string name="Gallery">Galerie</string>
+  <string name="AllPhotos">Toutes les photos</string>
+  <string name="AllVideo">Toutes les vidéos</string>
+  <string name="NoPhotos">Aucune photo pour l\'instant</string>
+  <string name="NoVideo">Aucune vidéo actuellement</string>
+  <string name="PleaseDownload">Commencez par télécharger le média</string>
+  <string name="NoRecentPhotos">Pas de photos récentes</string>
+  <string name="NoRecentGIFs">Pas de GIFs récents</string>
+  <string name="SearchImages">TROUVER DES IMAGES</string>
+  <string name="SearchImagesInfo">CHERCHER SUR LE WEB</string>
+  <string name="SearchGifs">TROUVER DES GIFS</string>
+  <string name="SearchImagesTitle">Recherche sur le web</string>
+  <string name="SearchGifsTitle">Recherche de GIFs</string>
+  <string name="CropImage">Rogner l\'image</string>
+  <string name="EditImage">Éditer l\'image</string>
+  <string name="Enhance">Améliorer</string>
+  <string name="Highlights">Surlignage</string>
+  <string name="Contrast">Contraste</string>
+  <string name="Exposure">Exposition</string>
+  <string name="Warmth">Température</string>
+  <string name="Saturation">Saturation</string>
+  <string name="Vignette">Vignetage</string>
+  <string name="Shadows">Ombres</string>
+  <string name="Grain">Grain</string>
+  <string name="Sharpen">Netteté</string>
+  <string name="Blur">Flou</string>
+  <string name="BlurOff">Désactiver</string>
+  <string name="BlurLinear">Linéaire</string>
+  <string name="BlurRadial">Radial</string>
+  <string name="AreYouSureDeletePhoto">Êtes-vous sûr de vouloir supprimer cette photo?</string>
+  <string name="AreYouSureDeleteVideo">Êtes-vous sûr de vouloir supprimer cette vidéo?</string>
+  <string name="DiscardChanges">Annuler les modifications?</string>
+  <string name="ClearSearch">Supprimer l\'historique de la recherche ?</string>
+  <string name="ClearButton">Effacer</string>
+  <string name="PickerPhotos">Photos</string>
+  <string name="PickerVideo">Vidéo</string>
+  <string name="AddCaption">Ajouter une légende...</string>
+  <string name="PhotoCaption">Légende photo</string>
+  <string name="VideoCaption">Légende vidéo</string>
+  <!--password view-->
+  <string name="TwoStepVerification">Vérification en deux étapes</string>
+  <string name="SetAdditionalPassword">Ajouter un mot de passe additionnel</string>
+  <string name="SetAdditionalPasswordInfo">Vous pouvez définir un mot de passe qui sera requis à chaque connexion sur un nouvel appareil en plus du code envoyé par SMS.</string>
+  <string name="YourPassword">Votre mot de passe</string>
+  <string name="PleaseEnterCurrentPassword">Veuillez saisir votre mot de passe</string>
+  <string name="PleaseEnterFirstPassword">Saisir un mot de passe</string>
+  <string name="PleaseEnterPassword">Vueillez saiser votre nouveau mot de passe</string>
+  <string name="PleaseReEnterPassword">Vueillez re-saisir votre mot de passe</string>
+  <string name="RecoveryEmail">E-mail de récupération</string>
+  <string name="YourEmail">Votre E-Mail</string>
+  <string name="YourEmailInfo">Veuillez ajouter votre e-mail valide. C\'est la seule manière de retrouver un mot de passe oublié.</string>
+  <string name="YourEmailSkip">Passer</string>
+  <string name="YourEmailSkipWarning">Attention</string>
+  <string name="YourEmailSkipWarningText">Non, sérieusement.
+
+Si vous oubliez votre mot de passe, vous perdrez l\'accès à votre compte Telegram. Il n\'y a aucun moyen de le récupérer.</string>
+  <string name="YourEmailAlmostThere">On y est presque !</string>
+  <string name="YourEmailAlmostThereText">Veuillez vérifier votre e-mail (n\'oubliez pas le dossier spam) pour terminer le paramétrage de la vérification en deux étapes.</string>
+  <string name="YourPasswordSuccess">Succès !</string>
+  <string name="YourPasswordSuccessText">Votre mot de passe pour la vérification en deux étapes est maintenant actif.</string>
+  <string name="ChangePassword">Changer le mot de passe</string>
+  <string name="TurnPasswordOff">Désactiver le mot de passe</string>
+  <string name="SetRecoveryEmail">Activer l\'e-mail de récupération</string>
+  <string name="ChangeRecoveryEmail">Changer l\'e-mail de récupération</string>
+  <string name="TurnPasswordOffQuestion">Êtes-vous sûr(e) de vouloir désactiver le mot de passe ?</string>
+  <string name="PasswordHint">Indice du mot de passe</string>
+  <string name="PasswordHintText">Veuillez créer un indice pour votre mot de passe</string>
+  <string name="PasswordDoNotMatch">Les mots de passe ne correspondent pas</string>
+  <string name="AbortPassword">Interrompre le paramétrage de la vérification en deux étapes</string>
+  <string name="EmailPasswordConfirmText">Afin de terminer la configuration de la vérification en deux étapes, merci d\'effectuer les actions suivantes :\n\n1. Consultez vos e-mails (n\'oubliez pas de regarder dans le spam)\n%1$s\n\n2. Cliquez sur le lien de validation.</string>
+  <string name="PasswordAsHintError">L\'indice doit être différent de votre mot de passe</string>
+  <string name="PasswordEmailInvalid">E-mail invalide</string>
+  <string name="RestorePasswordNoEmailTitle">Désolé</string>
+  <string name="RestorePasswordNoEmailText">Comme vous n\'avez pas fourni un e-mail de récupération lors de la création de votre mot de passe, vos seules options restantes sont de vous rappeler de votre mot de passe ou de réinitialiser votre compte.</string>
+  <string name="RestoreEmailSent">Un code de récupération a été envoyé à votre adresse e-mail : \n\n%1$s</string>
+  <string name="RestoreEmailSentInfo">Veuillez consultez vos e-mails et entrer le code à 6 chiffres qui vous a été envoyé.</string>
+  <string name="RestoreEmailTrouble">Des soucis pour accéder à votre e-mail %1$s?</string>
+  <string name="RestoreEmailTroubleText">Si vous ne pouvez plus accéder à cette adresse e-mail, il vous reste deux options : soit retrouver votre mot de passe, soit réinitialiser votre compte.</string>
+  <string name="ResetMyAccount">REINITIALISER MON COMPTE</string>
+  <string name="ResetMyAccountText">Si vous réinitialisez votre compte, vous perdrez tous vos messages et conversations, ainsi que les fichiers et médias que vous avez partagés.</string>
+  <string name="ResetMyAccountWarning">Attention</string>
+  <string name="ResetMyAccountWarningText">Cette action ne peut pas être annulée.\n\nSi vous réinitialisez votre compte, tous vos messages et conversations seront supprimés.</string>
+  <string name="ResetMyAccountWarningReset">Réinitialiser </string>
+  <string name="LoginPassword">Mot de passe</string>
+  <string name="LoginPasswordText">Vous avez activé la vérification en deux étapes activée,  votre compte est donc protégé avec un mot de passe additionnel.</string>
+  <string name="ForgotPassword">Mot de passe oublié ?</string>
+  <string name="PasswordRecovery">Récupération du mot de passe</string>
+  <string name="PasswordCode">Code</string>
+  <string name="PasswordReset">Mot de passe désactivé</string>
+  <string name="EnabledPasswordText">Vous avez activé la vérification en deux étapes.\nVous devrez fournir le mot de passe défini ici à chaque connexion à votre compte Telegram.</string>
+  <string name="PendingEmailText">Votre e-mail de récupération %1$s est inactive et en attente de confirmation.</string>
+  <!--privacy settings-->
+  <string name="PrivacySettings">Vie privée et Sécurité</string>
+  <string name="PrivacyTitle">Vie privée</string>
+  <string name="PrivacyLastSeen">Vu pour la dernière fois</string>
+  <string name="LastSeenEverybody">Tout le monde</string>
+  <string name="LastSeenContacts">Mes Contacts</string>
+  <string name="LastSeenNobody">Personne</string>
+  <string name="LastSeenEverybodyMinus">Tout le monde (-%1$d)</string>
+  <string name="LastSeenContactsPlus">Mes Contacts (+%1$d)</string>
+  <string name="LastSeenContactsMinus">Mes Contacts (-%1$d)</string>
+  <string name="LastSeenContactsMinusPlus">Mes Contacts (-%1$d, +%2$d)</string>
+  <string name="LastSeenNobodyPlus">Personne (+%1$d)</string>
+  <string name="SecurityTitle">Sécurité</string>
+  <string name="DeleteAccountTitle">Auto-destruction du compte</string>
+  <string name="DeleteAccountIfAwayFor">Si vous êtes absent pour</string>
+  <string name="DeleteAccountHelp">Si vous ne vous connectez pas au moins une fois durant cette période, votre compte sera effacé ainsi que tous vos groupes, messages et contacts.</string>
+  <string name="DeleteAccountNowConfirmation">Supprimer votre compte ?</string>
+  <string name="LastSeenHelp">Choisir qui peut voir la date de votre dernière connexion.</string>
+  <string name="LastSeenTitle">Qui peut voir la date votre dernière connexion ?</string>
+  <string name="AddExceptions">Ajouter des exceptions</string>
+  <string name="CustomHelp">Important: Vous ne pourrez plus voir la date de dernière connexion des utilisateurs qui ne peuvent pas voir la vôtre. À la place, une indication approximative sera affichée (récemment, dans la semaine, dans le dernier mois). </string>
+  <string name="AlwaysShareWith">Toujours Partager Avec</string>
+  <string name="NeverShareWith">Ne Jamais Partager Avec</string>
+  <string name="CustomShareSettingsHelp">Ces paramètres écraseront les valeurs ci-dessus</string>
+  <string name="AlwaysShareWithTitle">Toujours Partager</string>
+  <string name="AlwaysShareWithPlaceholder">Toujours partager avec les utilisateurs...</string>
+  <string name="NeverShareWithTitle">Ne Jamais Partager</string>
+  <string name="NeverShareWithPlaceholder">Ne jamais partager avec les utilisateurs...</string>
+  <string name="EmpryUsersPlaceholder">Ajouter des Utilisateurs</string>
+  <string name="PrivacyFloodControlError">Désolé, requêtes trop nombreuses. Impossible de modifier vos réglages de Vie Privée pour le moment, veuillez patienter.</string>
+  <string name="ClearOtherSessionsHelp">Déconnecte tous les appareils sauf celui-ci.</string>
+  <string name="RemoveFromListText">Presser et maintenir sur un utilisateur pour le supprimer.</string>
+  <!--edit video view-->
+  <string name="EditVideo">Éditer la vidéo</string>
+  <string name="OriginalVideo">Vidéo originale</string>
+  <string name="EditedVideo">Vidéo éditée</string>
+  <string name="SendingVideo">Envoi de la vidéo...</string>
+  <string name="CompressVideo">Compresser la vidéo</string>
+  <!--button titles-->
+  <string name="Next">Suivant</string>
+  <string name="Back">Précédent</string>
+  <string name="Done">Terminé</string>
+  <string name="Open">Ouvrir</string>
+  <string name="Cancel">Annuler</string>
+  <string name="Add">Ajouter</string>
+  <string name="Edit">Éditer</string>
+  <string name="Send">Envoyer</string>
+  <string name="Call">Appeler</string>
+  <string name="Copy">Copier</string>
+  <string name="Delete">Supprimer</string>
+  <string name="Forward">Transférer</string>
+  <string name="Retry">Réessayer</string>
+  <string name="FromCamera">Depuis l\'appareil photo</string>
+  <string name="FromGalley">Depuis la galerie</string>
+  <string name="DeletePhoto">Supprimer la photo</string>
+  <string name="Set">Définir</string>
+  <string name="OK">OK</string>
+  <string name="Crop">DECOUPER</string>
+  <!--messages-->
+  <string name="ActionInviteYou">Vous avez rejoint le groupe avec un lien d\'invitation</string>
+  <string name="ActionInviteUser">un1 a rejoint le groupe avec un lien d\'invitation</string>
+  <string name="ActionKickUser">un1 a ejecté un2</string>
+  <string name="ActionLeftUser">un1 a quitté le groupe</string>
+  <string name="ActionAddUser">un1 a ajouté un2</string>
+  <string name="ActionRemovedPhoto">un1 a supprimé la photo du groupe</string>
+  <string name="ActionChangedPhoto">un1 a modifié la photo du groupe</string>
+  <string name="ActionChangedTitle">un1 a renommé le groupe en un2</string>
+  <string name="ActionCreateGroup">un1 a créé le groupe</string>
+  <string name="ActionYouKickUser">Vous avez ejecté un2</string>
+  <string name="ActionYouLeftUser">Vous avez quitté le groupe</string>
+  <string name="ActionYouAddUser">Vous avez ajouté un2</string>
+  <string name="ActionYouRemovedPhoto">Vous avez supprimé la photo du groupe</string>
+  <string name="ActionYouChangedPhoto">Vous avez modifié la photo du groupe</string>
+  <string name="ActionYouChangedTitle">Vous avez renommé le groupe en un2</string>
+  <string name="ActionYouCreateGroup">Vous avez créé le groupe</string>
+  <string name="ActionKickUserYou">un1 vous a ejecté</string>
+  <string name="ActionAddUserYou">un1 vous a ajouté</string>
+  <string name="ActionAddUserSelf">un1 est revenu dans le groupe</string>
+  <string name="UnsuppotedMedia">Ce message n\'est pas supporté dans votre version de Telegram. Veuillez mettre à jour l\'appli pour le voir: http://telegram.org/update</string>
+  <string name="AttachPhoto">Photo</string>
+  <string name="AttachVideo">Vidéo</string>
+  <string name="AttachLocation">Localisation</string>
+  <string name="AttachContact">Contact</string>
+  <string name="AttachDocument">Fichier</string>
+  <string name="AttachSticker">Sticker</string>
+  <string name="AttachAudio">Audio</string>
+  <string name="FromYou">Vous</string>
+  <string name="ActionTakeScreenshootYou">Capture d\'écran effectuée !</string>
+  <string name="ActionTakeScreenshoot">un1 a effectué une capture d\'écran !</string>
+  <!--Alert messages-->
+  <string name="InvalidPhoneNumber">Numéro de téléphone invalide</string>
+  <string name="CodeExpired">Code expiré. Merci de vous connecter à nouveau.</string>
+  <string name="FloodWait">Trop de tentatives, merci d\'essayer plus tard.</string>
+  <string name="FloodWaitTime">Trop de tentatives, veuillez réessayer dans %1$s</string>
+  <string name="InvalidCode">Code invalide</string>
+  <string name="InvalidFirstName">Prénom invalide</string>
+  <string name="InvalidLastName">Nom invalide</string>
+  <string name="Loading">Chargement…</string>
+  <string name="NoPlayerInstalled">Vous ne disposez pas d\'un lecteur vidéo. Veuillez en installer un pour continuer.</string>
+  <string name="NoMailInstalled">Veuillez envoyer un e-mail à sms@stel.com en nous expliquant votre problème.</string>
+  <string name="NoHandleAppInstalled">Vous ne disposez d\'aucune application compatible avec le type de fichier \'%1$s\'. Veuillez en installer une pour continuer</string>
+  <string name="InviteUser">Cet utilisateur ne dispose pas de Telegram, envoyer une invitation ?</string>
+  <string name="AreYouSure">Êtes-vous sûr ?</string>
+  <string name="AddToTheGroup">Ajouter %1$s au groupe?\n\nNombre des derniers messages à transmettre :</string>
+  <string name="ForwardMessagesTo">Transférer le message à %1$s ?</string>
+  <string name="SendMessagesTo">Envoyer des messages à %1$s ?</string>
+  <string name="AreYouSureLogout">Êtes-vous sûr de vouloir vous déconnecter?\n\nNotez que vous pouvez utiliser Telegram simultanément sur tous vos appareils.\n\nPour rappel, une déconnexion détruit toutes vos Conversations Secrètes.</string>
+  <string name="AreYouSureSessions">Êtes-vous sûr de vouloir fermer toutes les autres sessions ?</string>
+  <string name="AreYouSureDeleteAndExit">Êtes-vous sûr de vouloir supprimer et quitter le groupe ?</string>
+  <string name="AreYouSureDeleteThisChat">Êtes-vous sûr de vouloir supprimer cette conversation ?</string>
+  <string name="AreYouSureShareMyContactInfo">Êtes-vous sûr de vouloir partager vos informations personnelles ?</string>
+  <string name="AreYouSureBlockContact">Êtes-vous sûr de vouloir bloquer ce contact ?</string>
+  <string name="AreYouSureUnblockContact">Êtes-vous sûr de vouloir débloquer ce contact ?</string>
+  <string name="AreYouSureDeleteContact">Êtes-vous sûr de vouloir supprimer ce contact ?</string>
+  <string name="AreYouSureSecretChat">Êtes-vous sûr de vouloir démarrer une discussion secrète ? </string>
+  <string name="AreYouSureRegistration">Êtes-vous sûr de vouloir annuler l\'enregistrement ?</string>
+  <string name="AreYouSureClearHistory">Êtes-vous sûr de vouloir effacer l\'historique ?</string>
+  <string name="AreYouSureDeleteMessages">Êtes-vous sûr de vouloir supprimer %1$s?</string>
+  <string name="SendMessagesToGroup">Envoyer des messages à %1$s ?</string>
+  <string name="ForwardMessagesToGroup">Transférer les messages à %1$s ?</string>
+  <string name="FeatureUnavailable">Désolé, cette option n\'est actuellement pas disponible dans votre pays.</string>
+  <!--Intro view-->
+  <string name="Page1Title">Plus Messenger</string>
+  <string name="Page2Title">Rapide</string>
+  <string name="Page3Title">Gratuit</string>
+  <string name="Page4Title">Sécurisé</string>
+  <string name="Page5Title">Puissant</string>
+  <string name="Page6Title">Basé sur le cloud</string>
+  <string name="Page7Title">Privé</string>
+  <string name="Page1Message">La messagerie la plus <![CDATA[<b>rapide</b>]]> du monde. <![CDATA[<br/>]]>Elle est <![CDATA[<b>gratuite</b>]]> et <![CDATA[<b>sécurisée</b>]]>.</string>
+  <string name="Page2Message"><![CDATA[<b>Plus Messenger</b>]]> délivre vos messages plus <![CDATA[<br/>]]> rapidement qu\'aucune autre application.</string>
+  <string name="Page3Message"><![CDATA[<b>Plus Messenger</b>]]> est gratuit pour toujours.<![CDATA[<br/>]]>Pas de publicité. Pas d\'inscription payante.</string>
+  <string name="Page4Message"><![CDATA[<b>Plus Messenger</b>]]> protège vos messages<![CDATA[<br/>]]>des attaques de pirates.</string>
+  <string name="Page5Message"><![CDATA[<b>Plus Messenger</b>]]> ne limite pas la taille de<![CDATA[<br/>]]>vos médias et conversations.</string>
+  <string name="Page6Message"><![CDATA[<b>Plus Messenger</b>]]> vous permet d\'accéder à vos<![CDATA[<br/>]]>messages depuis plusieurs appareils.</string>
+  <string name="Page7Message"><![CDATA[<b>Plus Messenger</b>]]> vous permet de chiffrer vos<![CDATA[<br/>]]>messages et de les détruire automatiquement.</string>
+  <string name="StartMessaging">Démarrer une conversation</string>
+  <!--plural-->
+  <string name="Online_zero">%1$d en ligne</string>
+  <string name="Online_one">%1$d en ligne</string>
+  <string name="Online_two">%1$d en ligne</string>
+  <string name="Online_few">%1$d en ligne</string>
+  <string name="Online_many">%1$d en ligne</string>
+  <string name="Online_other">%1$d en ligne</string>
+  <string name="Members_zero">aucun membre</string>
+  <string name="Members_one">%1$d membre</string>
+  <string name="Members_two">%1$d membres</string>
+  <string name="Members_few">%1$d membres</string>
+  <string name="Members_many">%1$d membres</string>
+  <string name="Members_other">%1$d membres</string>
+  <string name="AndMoreTyping_zero">et %1$d autres personnes écrivent</string>
+  <string name="AndMoreTyping_one">et %1$d autres personnes écrivent</string>
+  <string name="AndMoreTyping_two">et %1$d autres personnes écrivent</string>
+  <string name="AndMoreTyping_few">et %1$d autres personnes écrivent</string>
+  <string name="AndMoreTyping_many">et %1$d autres personnes écrivent</string>
+  <string name="AndMoreTyping_other">et %1$d autres personnes écrivent</string>
+  <string name="NewMessages_zero">aucun nouveau message</string>
+  <string name="NewMessages_one">%1$d nouveau message</string>
+  <string name="NewMessages_two">%1$d nouveaux messages</string>
+  <string name="NewMessages_few">%1$d nouveaux messages</string>
+  <string name="NewMessages_many">%1$d nouveaux messages</string>
+  <string name="NewMessages_other">%1$d nouveaux messages</string>
+  <string name="messages_zero">aucun message</string>
+  <string name="messages_one">%1$d message</string>
+  <string name="messages_two">%1$d messages</string>
+  <string name="messages_few">%1$d messages</string>
+  <string name="messages_many">%1$d messages</string>
+  <string name="messages_other">%1$d messages</string>
+  <string name="items_zero">Aucun élément</string>
+  <string name="items_one">%1$d  élément</string>
+  <string name="items_two">%1$d éléments</string>
+  <string name="items_few">%1$d éléments</string>
+  <string name="items_many">%1$d éléments</string>
+  <string name="items_other">%1$d éléments</string>
+  <string name="FromChats_zero">d\'aucune discussion</string>
+  <string name="FromChats_one">d\'%1$d discussion</string>
+  <string name="FromChats_two">de %1$d discussions</string>
+  <string name="FromChats_few">de %1$d discussions</string>
+  <string name="FromChats_many">de %1$d discussions</string>
+  <string name="FromChats_other">de %1$d discussions</string>
+  <string name="Seconds_zero">%1$d secondes</string>
+  <string name="Seconds_one">%1$d seconde</string>
+  <string name="Seconds_two">%1$d secondes</string>
+  <string name="Seconds_few">%1$d secondes</string>
+  <string name="Seconds_many">%1$d secondes</string>
+  <string name="Seconds_other">%1$d secondes</string>
+  <string name="Minutes_zero">%1$d minutes</string>
+  <string name="Minutes_one">%1$d minute</string>
+  <string name="Minutes_two">%1$d minutes</string>
+  <string name="Minutes_few">%1$d minutes</string>
+  <string name="Minutes_many">%1$d minutes</string>
+  <string name="Minutes_other">%1$d minutes</string>
+  <string name="Hours_zero">%1$d heures</string>
+  <string name="Hours_one">%1$d heure</string>
+  <string name="Hours_two">%1$d heures</string>
+  <string name="Hours_few">%1$d heures</string>
+  <string name="Hours_many">%1$d heures</string>
+  <string name="Hours_other">%1$d heures</string>
+  <string name="Days_zero">%1$d jours</string>
+  <string name="Days_one">%1$d jour</string>
+  <string name="Days_two">%1$d jours</string>
+  <string name="Days_few">%1$d jours</string>
+  <string name="Days_many">%1$d jours</string>
+  <string name="Days_other">%1$d jours</string>
+  <string name="Weeks_zero">%1$d semaines</string>
+  <string name="Weeks_one">%1$d semaine</string>
+  <string name="Weeks_two">%1$d semaines</string>
+  <string name="Weeks_few">%1$d semaines</string>
+  <string name="Weeks_many">%1$d semaines</string>
+  <string name="Weeks_other">%1$d semaines</string>
+  <string name="Months_zero">%1$d mois</string>
+  <string name="Months_one">%1$d mois</string>
+  <string name="Months_two">%1$d mois</string>
+  <string name="Months_few">%1$d mois</string>
+  <string name="Months_many">%1$d mois</string>
+  <string name="Months_other">%1$d mois</string>
+  <string name="Years_zero">%1$d ans</string>
+  <string name="Years_one">%1$d an</string>
+  <string name="Years_two">%1$d ans</string>
+  <string name="Years_few">%1$d ans</string>
+  <string name="Years_many">%1$d ans</string>
+  <string name="Years_other">%1$d ans</string>
+  <string name="Users_zero">%1$d utilisateurs</string>
+  <string name="Users_one">%1$d utilisateur</string>
+  <string name="Users_two">%1$d utilisateurs</string>
+  <string name="Users_few">%1$d utilisateurs</string>
+  <string name="Users_many">%1$d utilisateurs</string>
+  <string name="Users_other">%1$d utilisateurs</string>
+  <string name="Times_zero">%1$d fois</string>
+  <string name="Times_one">%1$d fois</string>
+  <string name="Times_two">%1$d fois</string>
+  <string name="Times_few">%1$d fois</string>
+  <string name="Times_many">%1$d fois</string>
+  <string name="Times_other">%1$d fois</string>
+  <string name="Meters_zero">%1$d mètres</string>
+  <string name="Meters_one">%1$d mètre</string>
+  <string name="Meters_two">%1$d mètres</string>
+  <string name="Meters_few">%1$d mètres</string>
+  <string name="Meters_many">%1$d mètres</string>
+  <string name="Meters_other">%1$d mètres</string>
+  <!--forwarded messages-->
+  <string name="ForwardedMessage_zero">%1$d messages transférés</string>
+  <string name="ForwardedMessage_one">Message transféré</string>
+  <string name="ForwardedMessage_two">%1$d messages transférés</string>
+  <string name="ForwardedMessage_few">%1$d messages transférés</string>
+  <string name="ForwardedMessage_many">%1$d messages transférés</string>
+  <string name="ForwardedMessage_other">%1$d messages transférés</string>
+  <string name="ForwardedFile_zero">%1$d fichiers transférés</string>
+  <string name="ForwardedFile_one">Fichier transféré</string>
+  <string name="ForwardedFile_two">%1$d fichiers transférés</string>
+  <string name="ForwardedFile_few">%1$d fichiers transférés</string>
+  <string name="ForwardedFile_many">%1$d fichiers transférés</string>
+  <string name="ForwardedFile_other">%1$d fichiers transférés</string>
+  <string name="ForwardedPhoto_zero">%1$d photos transférées</string>
+  <string name="ForwardedPhoto_one">Photo transférée</string>
+  <string name="ForwardedPhoto_two">%1$d photos transférées</string>
+  <string name="ForwardedPhoto_few">%1$d photos transférées</string>
+  <string name="ForwardedPhoto_many">%1$d photos transférées</string>
+  <string name="ForwardedPhoto_other">%1$d photos transférées</string>
+  <string name="ForwardedVideo_zero">%1$d vidéos transférées</string>
+  <string name="ForwardedVideo_one">Vidéo transférée</string>
+  <string name="ForwardedVideo_two">%1$d vidéos transférées</string>
+  <string name="ForwardedVideo_few">%1$d vidéos transférées</string>
+  <string name="ForwardedVideo_many">%1$d vidéos transférées</string>
+  <string name="ForwardedVideo_other">%1$d vidéos transférées</string>
+  <string name="ForwardedAudio_zero">%1$d audios transférés</string>
+  <string name="ForwardedAudio_one">Audio transféré</string>
+  <string name="ForwardedAudio_two">%1$d audios transférés</string>
+  <string name="ForwardedAudio_few">%1$d audios transférés</string>
+  <string name="ForwardedAudio_many">%1$d audios transférés</string>
+  <string name="ForwardedAudio_other">%1$d audios transférés</string>
+  <string name="ForwardedLocation_zero">%1$d localisations transférées</string>
+  <string name="ForwardedLocation_one">Localisation transférée</string>
+  <string name="ForwardedLocation_two">%1$d localisations transférées</string>
+  <string name="ForwardedLocation_few">%1$d localisations transférées</string>
+  <string name="ForwardedLocation_many">%1$d localisations transférées</string>
+  <string name="ForwardedLocation_other">%1$d localisations transférées</string>
+  <string name="ForwardedContact_zero">%1$d contacts transférés</string>
+  <string name="ForwardedContact_one">Contact transféré</string>
+  <string name="ForwardedContact_two">%1$d contacts transférés</string>
+  <string name="ForwardedContact_few">%1$d contacts transférés</string>
+  <string name="ForwardedContact_many">%1$d contacts transférés</string>
+  <string name="ForwardedContact_other">%1$d contacts transférés</string>
+  <string name="ForwardedSticker_zero">%1$d stickers transférés</string>
+  <string name="ForwardedSticker_one">Sticker transféré</string>
+  <string name="ForwardedSticker_two">%1$d stickers transférés</string>
+  <string name="ForwardedSticker_few">%1$d stickers transférés</string>
+  <string name="ForwardedSticker_many">%1$d stickers transférés</string>
+  <string name="ForwardedSticker_other">%1$d stickers transférés</string>
+  <string name="AndOther_zero">et %1$d autres</string>
+  <string name="AndOther_one">et %1$d autre</string>
+  <string name="AndOther_two">et %1$d autres</string>
+  <string name="AndOther_few">et %1$d autres</string>
+  <string name="AndOther_many">et %1$d autres</string>
+  <string name="AndOther_other">et %1$d autres</string>
+  <!--date formatters-->
+  <string name="formatterMonthYear">MMMM yyyy</string>
+  <string name="formatterMonth">dd MMM</string>
+  <string name="formatterYear">dd.MM.yy</string>
+  <string name="formatterYearMax">dd.MM.yyyy</string>
+  <string name="chatDate">d MMMM</string>
+  <string name="chatFullDate">d MMMM, yyyy</string>
+  <string name="formatterWeek">EEE</string>
+  <string name="formatterDay24H">HH:mm</string>
+  <string name="formatterDay12H">h:mm a</string>
+  <string name="formatDateAtTime">%1$s à %2$s</string>
+  <!--update text-->
+  <string name="updateText">Plus Messenger pour Android vient d\'être mis à jour. Nouveautés de la version 2.8:\n\n- Liens d\'invitation pour les conversations en groupe\n- Notifications intelligentes\n- Onglet stickers dans le menu des émoticônes\n- Légendes sur les photos\n- Emplacements et itinéraires dans l\'écran de localisation\n- Statut \'Écouté\' pour les messages vocaux\n- Statut \'écrit\' plus varié : envoie une photo, enregistre un son, etc.\n- Défilement du contenu amélioré et ajout d\'animations pour une expérience fluiiiiiiiide!\n\nPour plus d\'infos (en anglais) :\ntelegram.org/blog/captions-places</string>
+  <string name="updateBuild">523</string>
+    <!--Telegram+ French-->
+    <!--Smart Notifications-->
+    <string name="SmartNotification">Notification intelligente</string>
+    <string name="TimeUnitSeconds">seconde(s)</string>
+    <string name="TimeUnitMinutes">minute(s)</string>
+    <string name="TimeUnitHours">heure(s)</string>
+    <string name="TimeUnitDays">jour(s)</string>
+    <string name="settings_smart_notify_begin">Sonner au maximum</string>
+    <string name="settings_smart_notify_mid1">fois</string>
+    <string name="settings_smart_notify_mid11">fois</string>
+    <string name="settings_smart_notify_mid2">en</string>
+    <!---->
+    <string name="TelegramForAndroid">Plus Messenger pour Android</string>
+    <string name="Theming">Thème</string>
+    <string name="colorHexInvalid">Code couleur hexadécimal incorrect!</string>
+    <string name="themeColor">Couleur du thème</string>
+    <string name="ResetThemeSettings">Réinitialiser les paramètres du thème</string>
+    <string name="ResetThemeSettingsSum">Rétablir tous les paramètres du thème</string>
+    <string name="ResetThemeToastText">Réinitialiser les paramètres du thème par défaut!</string>
+    <string name="General">Général</string>
+    <string name="Screens">Affichages</string>
+    <string name="MainScreen">Affichage principal</string>
+    <string name="ChatScreen">Affichage de conversation</string>
+    <string name="ContactsScreen">Affichage des contacts</string>
+    <string name="Header">Entête</string>
+    <string name="Rows">Lignes</string>
+    <string name="ChatList">Liste de la conversation</string>
+    <string name="ChatsList">Liste des conversations</string>
+    <string name="ContactsList">Liste des contacts</string>
+    <string name="HeaderColor">Couleur de l\'entête</string>
+    <string name="NameColor">Couleur de nom de contact</string>
+    <string name="NameSize">Taille de nom de contact</string>
+    <string name="MessageColor">Couleur de message</string>
+    <string name="MessageSize">Taille de message</string>
+    <string name="TimeDateColor">Couleur de date/heure</string>
+    <string name="TimeDateSize">Taille de date/heure</string>
+    <string name="CountColor">Couleur du compte</string>
+    <string name="CountSize">Taille du compte</string>
+    <string name="RowColor">Couleur d\'une ligne</string>
+    <string name="CountBGColor">Couleur de fond du compte</string>
+    <string name="StatusColor">Couleur du statut</string>
+    <string name="StatusSize">Taille du statut</string>
+    <string name="RBubbleColor">Couleur de la bulle de droite</string>
+    <string name="LBubbleColor">Couleur de la bulle de gauche</string>
+    <string name="DateColor">Couleur de la date</string>
+    <string name="DateSize">Taille de la date</string>
+    <string name="DateBubbleColor">Couleur de la bulle de la date</string>
+    <string name="RTextColor">Couleur du texte de droite</string>
+    <string name="LTextColor">Couleur du texte de gauche</string>
+    <string name="RTimeColor">Couleur de l\'heure de droite</string>
+    <string name="LTimeColor">Couleur de l\'heure de gauche</string>
+    <string name="TimeSize">Taille de l\'heure</string>
+    <string name="EditTextColor">Couleur de la saisie de texte</string>
+    <string name="EditTextSize">Taille de la saisie de texte</string>
+    <string name="EditTextBGColor">Couleur de fond de la saisie de texte</string>
+    <string name="EmojiViewBGColor">Couleur de fond des Emojis</string>
+    <string name="EmojiViewTabColor">Couleur de l\'onglet Emoji</string>
+    <string name="OnlineColor">Couleur du statut En Ligne</string>
+    <string name="ChatMusic">Musique</string>
+    <string name="SaveTheme">Enregistrer le thème</string>
+    <string name="SaveThemeSum">Enregistrer votre thème dans le dossier Telegram/Themes</string>
+    <string name="SavedTo">%1$s enregistré dans %2$s</string>
+    <string name="SaveErrorMsg0">Le thème n\'a pas encore été créé. Veuillez d\'abord appliquer tous mods Plus Messenger</string>
+    <string name="restoreOkMsg">Préférences rétablies à partir de la carte SD</string>
+    <string name="restoreErrorMsg">Aucun fichier de préférences trouvé dans %s</string>
+    <string name="NoMediaMessage">Aucune carte SD détectée.</string>
+    <string name="EnterName">Entrez un nom</string>
+    <string name="Themes">Thèmes</string>
+    <string name="ApplyTheme">Appliquer le thème</string>
+    <string name="ApplyThemeSum">Appliquer le thème xml du dossier local</string>
+    <string name="MemberColor">Couleur des membres</string>
+    <string name="ChecksColor">Couleur des flèches de confirmation</string>
+    <string name="MuteColor">Couleur du bouton Muet</string>
+    <string name="SendLogs">Envoyer les logs</string>
+    <string name="SendLogsEmpty">Il n\'y a aucun log</string>
+    <string name="SendIcon">Icone d\'envoi</string>
+    <string name="HideMobile">Cacher le numéro de mobile</string>
+    <string name="FloatingPencilColor">Couleur du pinceau flottant</string>
+    <string name="FloatingBGColor">Couleur du fond flottant</string>
+    <string name="Community">Communauté G+</string>
+    <string name="TypingColor">Couleur lorsqu\'un message est rédigé</string>
+    <string name="EditTextIconsColor">Couleur des icônes de saisie de texte</string>
+    <string name="NavigationDrawer">Menu de navigation</string>
+    <string name="OptionsList">Liste des options</string>
+    <string name="ListColor">Liste des couleurs</string>
+    <string name="OwnNameSize">Taille du nom</string>
+    <string name="PhoneColor">Couleur du numéro de téléphone</string>
+    <string name="PhoneSize">Taille du numéro de téléphone</string>
+    <string name="AvatarColor">Couleur de l\'avatar</string>
+    <string name="IconColor">Couleur de l\'icône des options</string>
+    <string name="OptionColor">Couleur des options</string>
+    <string name="OptionSize">Taille des options</string>
+    <string name="VersionColor">Couleur du numéro de version</string>
+    <string name="VersionSize">Taille du numéro de version</string>
+    <string name="HeaderTitleColor">Couleur du titre d\'entête</string>
+    <string name="HeaderIconsColor">Couleur des icônes d\'entête</string>
+    <string name="DividerColor">Couleur des séparateurs</string>
+    <string name="AvatarRadius">Rayon de l\'avatar</string>
+    <string name="SetMemberColor">Couleur de membre</string>
+    <string name="ForwardNameColor">Couleur du nom transféré</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-gl/strings.xml b/TMessagesProj/src/main/res/values-gl/strings.xml
new file mode 100644
index 000000000..a447fc5ff
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-gl/strings.xml
@@ -0,0 +1,730 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<resources>
+  <string name="AppName">Plus Messenger</string>
+  <string name="LanguageName">Galego</string>
+  <string name="LanguageNameInEnglish">Galician</string>
+  <string name="LanguageCode">gl</string>
+  <!--signin view-->
+  <string name="YourPhone">O teu teléfono</string>
+  <string name="StartText">Confirma o código do teu país
+e introduce o teu número.</string>
+  <string name="ChooseCountry">Elixe un país</string>
+  <string name="WrongCountry">Código incorrecto</string>
+  <!--code enter view-->
+  <string name="YourCode">O teu código</string>
+  <string name="SentSmsCode">Acabamos de enviarte un SMS co teu código de activación</string>
+  <string name="CallText">Chamámoste en %1$d:%2$02d</string>
+  <string name="Calling">Chamando...</string>
+  <string name="Code">Código</string>
+  <string name="WrongNumber">Número trabucado?</string>
+  <string name="DidNotGetTheCode">Non conseguiches o código?</string>
+  <!--signup view-->
+  <string name="YourName">O teu nome</string>
+  <string name="RegisterText">Pon o teu nome e apelidos</string>
+  <!--<string name="RegisterText">Set up your name and picture</string>-->
+  <string name="FirstName">Nome (requerido)</string>
+  <string name="LastName">Apelidos (opcional)</string>
+  <string name="CancelRegistration">Cancelar o rexistro</string>
+  <!--chats view-->
+  <string name="Settings">Axustes</string>
+  <string name="Contacts">Contactos</string>
+  <string name="NewGroup">Novo grupo</string>
+  <string name="Yesterday">onte</string>
+  <string name="NoResult">Sen resultados</string>
+  <string name="NoChats">Aínda sen conversas...</string>
+  <string name="NoChatsHelp">Escribe unha mensaxe no\nbotón de redactar no recanto inferior\ndereito ou toca no botón do menú para outras opcións.</string>
+  <string name="WaitingForNetwork">Á espera de conexión...</string>
+  <string name="Connecting">Conectando...</string>
+  <string name="Updating">Actualizando...</string>
+  <string name="NewSecretChat">Novo chat secreto</string>
+  <string name="AwaitingEncryption">Agardando a que %s se conecte...</string>
+  <string name="EncryptionRejected">Chat secreto cancelado</string>
+  <string name="EncryptionProcessing">Intercambiando as claves de cifrado...</string>
+  <string name="EncryptedChatStartedOutgoing">%s uníuse á teu chat secreto.</string>
+  <string name="EncryptedChatStartedIncoming">Unícheste ao chat secreto.</string>
+  <string name="ClearHistory">Borrar o historial</string>
+  <string name="DeleteChat">Eliminar e saír</string>
+  <string name="DeleteChatUser">Eliminar a conversa</string>
+  <string name="HiddenName">Eliminouse a conta</string>
+  <string name="SelectChat">Seleccionar conversa</string>
+  <string name="PhotoTip">Mantén o toque para ver</string>
+  <string name="CompatibilityChat">%1$s usa unha versión antiga do Telegram, por iso as fotos secretas mostraranse no modo compatibilidade.\n\nCando %2$s actualice o Telegram, as fotos con temporizador de 1 minuto ou menos traballarán no modo «Mantén o toque para ver» e recibirás unha notificación cando a outra parte faga unha captura da pantalla.</string>
+  <string name="SearchMessages">MENSAXES</string>
+  <string name="Search">Buscar</string>
+  <string name="MuteNotifications">Silenciar notificacións</string>
+  <string name="MuteFor">Silenciar %1$s</string>
+  <string name="UnmuteNotifications">Non silenciar</string>
+  <string name="WillUnmuteIn">En %1$s</string>
+  <string name="MuteDisable">Desactivar</string>
+  <!--broadcasts-->
+  <string name="NewBroadcastList">Nova difusión</string>
+  <string name="EnterListName">Introduce o nome da lista</string>
+  <string name="YouCreatedBroadcastList">Creaches unha lista de difusión</string>
+  <string name="AddRecipient">Engadir destinatario</string>
+  <string name="KickFromBroadcast">Eliminar da lista de difusión</string>
+  <!--documents view-->
+  <string name="SelectFile">Seleccionar un arquivo</string>
+  <string name="FreeOfTotal">%1$s libres de %2$s</string>
+  <string name="UnknownError">Erro descoñecido</string>
+  <string name="AccessError">Erro ao acceder</string>
+  <string name="NoFiles">Aínda non hai ficheiros...</string>
+  <string name="FileUploadLimit">O tamaño do ficheiro non pode ser meirande de %1$s</string>
+  <string name="NotMounted">Almacenamento non montado</string>
+  <string name="UsbActive">A transferencia por USB está activa</string>
+  <string name="InternalStorage">Almacenamento interno</string>
+  <string name="ExternalStorage">Almacenamento externo</string>
+  <string name="SystemRoot">Raíz do sistema</string>
+  <string name="SdCard">Tarxeta SD</string>
+  <string name="Folder">Cartafol</string>
+  <string name="GalleryInfo">Enviar imaxes sen compresión</string>
+  <!--chat view-->
+  <string name="Invisible">invisible</string>
+  <string name="Typing">escribindo...</string>
+  <string name="IsTyping">está a escribir...</string>
+  <string name="AreTyping">están a escribir...</string>
+  <string name="GotAQuestion">Tes algunha pregunta\nsobre Telegram?</string>
+  <string name="ChatTakePhoto">Tira unha foto</string>
+  <string name="ChatGallery">Galería</string>
+  <string name="ChatLocation">Localización</string>
+  <string name="ChatVideo">Vídeo</string>
+  <string name="ChatDocument">Ficheiro</string>
+  <string name="NoMessages">Aínda non hai mensaxes...</string>
+  <string name="ForwardedMessage">Mensaxe reenviada</string>
+  <string name="From">De</string>
+  <string name="NoRecent">Non hai nada recente</string>
+  <string name="Message">Mensaxe</string>
+  <string name="TypeMessage">Mensaxe</string>
+  <string name="ShareMyContactInfo">Compartir contacto</string>
+  <string name="AddToContacts">Engadir a contactos</string>
+  <string name="EncryptedPlaceholderTitleIncoming">%s invitoute a un chat secreto.</string>
+  <string name="EncryptedPlaceholderTitleOutgoing">Invitaches a %s a un chat secreto.</string>
+  <string name="EncryptedDescriptionTitle">Os chats secretos:</string>
+  <string name="EncryptedDescription1">Usan cifrado end-to-end</string>
+  <string name="EncryptedDescription2">Non deixan rastro no servidor</string>
+  <string name="EncryptedDescription3">Teñen autodestrución</string>
+  <string name="EncryptedDescription4">Impiden reenviar mensaxes</string>
+  <string name="YouWereKicked">Elimináronte deste grupo</string>
+  <string name="YouLeft">Abandonaches este grupo</string>
+  <string name="DeleteThisGroup">Eliminar este grupo</string>
+  <string name="DeleteThisChat">Eliminar este chat</string>
+  <string name="SlideToCancel">ARRASTRAR PARA CANCELAR</string>
+  <string name="SaveToDownloads">Gardar en descargas</string>
+  <string name="ShareFile">Compartir</string>
+  <string name="ApplyLocalizationFile">Aplicar tradución</string>
+  <string name="UnsupportedAttachment">Adxunto non soportado</string>
+  <string name="SetTimer">Establecer a autodestrución</string>
+  <string name="ServiceNotifications">Notificacións de servizos</string>
+  <!--notification-->
+  <string name="MessageLifetimeChanged">%1$s puxo o temporizador para a autodestrución en %2$s</string>
+  <string name="MessageLifetimeChangedOutgoing">Puxeches o temporizador para a autodestrución en %1$s</string>
+  <string name="MessageLifetimeRemoved">%1$s desactivou o temporizador para a autodestrución</string>
+  <string name="MessageLifetimeYouRemoved">Desactivaches o temporizador para a autodestrución</string>
+  <string name="YouHaveNewMessage">Tes unha mensaxe nova</string>
+  <string name="NotificationMessageText">%1$s: %2$s</string>
+  <string name="NotificationMessageNoText">%1$s enviouche unha mensaxe</string>
+  <string name="NotificationMessagePhoto">%1$s enviouche unha foto</string>
+  <string name="NotificationMessageVideo">%1$s enviouche un vídeo</string>
+  <string name="NotificationMessageContact">%1$s compartiu un contacto contigo</string>
+  <string name="NotificationMessageMap">%1$s enviouche unha localización</string>
+  <string name="NotificationMessageDocument">%1$s enviouche un ficheiro</string>
+  <string name="NotificationMessageAudio">%1$s enviouche un ficheiro de son</string>
+  <string name="NotificationMessageSticker">%1$s enviouche un sticker</string>
+  <string name="NotificationMessageGroupText">%1$s @ %2$s: %3$s</string>
+  <string name="NotificationMessageGroupNoText">%1$s enviou unha mensaxe ao grupo %2$s</string>
+  <string name="NotificationMessageGroupPhoto">%1$s enviou unha foto ao grupo %2$s</string>
+  <string name="NotificationMessageGroupVideo">%1$s enviou un vídeo ao grupo %2$s</string>
+  <string name="NotificationMessageGroupContact">%1$s compartiu un contacto no grupo %2$s</string>
+  <string name="NotificationMessageGroupMap">%1$s enviou unha localización ao grupo %2$s</string>
+  <string name="NotificationMessageGroupDocument">%1$s enviou un ficheiro ao grupo %2$s</string>
+  <string name="NotificationMessageGroupAudio">%1$s enviou un son ao grupo %2$s</string>
+  <string name="NotificationMessageGroupSticker">%1$s enviou un sticker ao grupo %2$s</string>
+  <string name="NotificationInvitedToGroup">%1$s convidoute ao grupo %2$s</string>
+  <string name="NotificationEditedGroupName">%1$s mudou o nome do grupo: %2$s </string>
+  <string name="NotificationEditedGroupPhoto">%1$s mudou a foto do grupo %2$s </string>
+  <string name="NotificationGroupAddMember">%1$s invitou a %3$s ao grupo %2$s</string>
+  <string name="NotificationGroupAddSelf">%1$s volveu ao grupo %2$s</string>
+  <string name="NotificationGroupKickMember">%1$s eliminou a %3$s do grupo %2$s</string>
+  <string name="NotificationGroupKickYou">%1$s eliminoute do grupo %2$s</string>
+  <string name="NotificationGroupLeftMember">%1$s abandonou o grupo %2$s</string>
+  <string name="NotificationContactJoined">%1$s uniuse ao Telegram!</string>
+  <string name="NotificationUnrecognizedDevice">%1$s,
+Detectamos un acceso á túa conta desde un dispositivo novo o %2$s
+
+Dispositivo: %3$s
+Localización: %4$s
+
+Se non foches ti, podes ir a Axustes - Privacidade e seguridade - Cancelar todos os outros accesos.
+
+Grazas,
+O equipo de Telegram</string>
+  <string name="NotificationContactNewPhoto">%1$s actualizou a foto de perfil</string>
+  <string name="Reply">Responder</string>
+  <string name="ReplyToGroup">Responder a %1$s</string>
+  <string name="ReplyToUser">Responder a %1$s</string>
+  <string name="NotificationMessagesPeopleDisplayOrder">%1$s %2$s</string>
+  <!--contacts view-->
+  <string name="SelectContact">Escolle un contacto</string>
+  <string name="NoContacts">Aínda non hai contactos</string>
+  <string name="InviteText">Ei, cambiemos a Telegram: http://goo.gl/jnmjnZ</string>
+  <string name="TodayAt">ás</string>
+  <string name="YesterdayAt">onte ás</string>
+  <string name="Online">en liña</string>
+  <string name="LastSeen">últ. vez</string>
+  <string name="LastSeenDate">últ. vez</string>
+  <string name="InviteFriends">Invitar amigos</string>
+  <string name="GlobalSearch">BÚSQUEDA GLOBAL</string>
+  <string name="Lately">últ. conexión recentemente</string>
+  <string name="WithinAWeek">últ. vez hai uns días</string>
+  <string name="WithinAMonth">últ. vez hai unhas semanas</string>
+  <string name="ALongTimeAgo">conexión hai moito tempo</string>
+  <string name="NewMessageTitle">Nova mensaxe</string>
+  <!--group create view-->
+  <string name="SendMessageTo">Enviar mensaxe a...</string>
+  <string name="EnterGroupNamePlaceholder">Pon o nome do grupo</string>
+  <string name="GroupName">Nome do grupo</string>
+  <string name="MembersCount">%1$d/%2$d membros</string>
+  <!--group info view-->
+  <string name="SharedMedia">Multimedia compartida</string>
+  <string name="SETTINGS">Axustes</string>
+  <string name="AddMember">Engadir membro</string>
+  <string name="DeleteAndExit">Eliminar e saír</string>
+  <string name="Notifications">Notificacións</string>
+  <string name="KickFromGroup">Eliminar do grupo</string>
+  <!--contact info view-->
+  <string name="ShareContact">Compartir</string>
+  <string name="AddContact">Engadir</string>
+  <string name="AddContactTitle">Engadir contacto</string>
+  <string name="BlockContact">Bloquear</string>
+  <string name="EditContact">Editar</string>
+  <string name="DeleteContact">Eliminar</string>
+  <string name="PhoneHome">Casa</string>
+  <string name="PhoneMobile">Móbil</string>
+  <string name="PhoneWork">Traballo</string>
+  <string name="PhoneOther">Outro</string>
+  <string name="PhoneMain">Principal</string>
+  <string name="StartEncryptedChat">Comezar un chat secreto</string>
+  <string name="CreateEncryptedChatError">Produciuse un erro.</string>
+  <string name="EncryptionKey">Clave de cifrado</string>
+  <string name="MessageLifetime">Temporizador de destrución</string>
+  <string name="ShortMessageLifetimeForever">Desactivado</string>
+  <string name="EncryptionKeyDescription">Esta imaxe é unha visualización da clave de cifrado para a conversa secreta con <![CDATA[<b>]]>%1$s<![CDATA[</b>]]>.<![CDATA[<br><br>]]>Se é a mesma que aparece no teléfono de <![CDATA[<b>]]>%2$s<![CDATA[</b>]]>, a vosa conversa é 200%% segura.<![CDATA[<br><br>]]>Máis información en telegram.org</string>
+  <string name="NumberUnknown">Descoñecido</string>
+  <string name="Info">Información</string>
+  <string name="Phone">Teléfono</string>
+  <!--usernames-->
+  <string name="Username">Alcume</string>
+  <string name="UsernamePlaceholder">O teu alcume</string>
+  <string name="UsernameInUse">Síntoo, este alcume xa está en uso.</string>
+  <string name="UsernameInvalid">Síntoo, este alcume é inválido.</string>
+  <string name="UsernameInvalidShort">Un alcume debe ter polo menos 5 caracteres.</string>
+  <string name="UsernameInvalidLong">O alcume non debe exceder os 32 caracteres.</string>
+  <string name="UsernameInvalidStartNumber">Sentímolo, un alcume non pode comezar cun número.</string>
+  <string name="UsernameHelp">Podes escoller un alcume para o <![CDATA[<b>]]>Plus Messenger<![CDATA[</b>]]>. Se o fas, a xente poderá atoparte por este nome e contactar contigo sen coñecer o teu número de teléfono.<![CDATA[<br><br>]]>Podes usar os caracteres <![CDATA[<b>]]>a–z<![CDATA[</b>]]>, <![CDATA[<b>]]>0–9<![CDATA[</b>]]> e guións baixos. A lonxitude mínima son <![CDATA[<b>]]>5<![CDATA[</b>]]> caracteres.</string>
+  <string name="UsernameChecking">Comprobando alcume...</string>
+  <string name="UsernameAvailable">%1$s está disponible.</string>
+  <string name="UsernameEmpty">Ningún</string>
+  <string name="ErrorOccurred">Produciuse un erro.</string>
+  <!--settings view-->
+  <string name="ResetNotificationsText">Restaurar os axustes de notificacións ás predefinicións</string>
+  <string name="TextSize">Tamaño do texto</string>
+  <string name="AskAQuestion">Facer unha pregunta</string>
+  <string name="EnableAnimations">Activar animacións</string>
+  <string name="Unblock">Desbloquear</string>
+  <string name="UnblockText">Mantén premido sobre o usuario para desbloquealo.</string>
+  <string name="NoBlocked">Non hai usuarios bloqueados</string>
+  <string name="MessageNotifications">Notificacións das nensaxes</string>
+  <string name="Alert">Aviso</string>
+  <string name="MessagePreview">Vista previa da mensaxe</string>
+  <string name="GroupNotifications">Notificacións os grupos</string>
+  <string name="Sound">Son</string>
+  <string name="InAppNotifications">Notificacións na app</string>
+  <string name="InAppSounds">Sons na app</string>
+  <string name="InAppVibrate">Vibración na app</string>
+  <string name="Vibrate">Vibración</string>
+  <string name="InAppPreview">Vista previa na app</string>
+  <string name="Reset">Restablecer</string>
+  <string name="ResetAllNotifications">Restablecer todas as notificacións</string>
+  <string name="UndoAllCustom">Desfacer as notificacións personalizadas para todos os contactos e grupos.</string>
+  <string name="NotificationsAndSounds">Notificacións e sons</string>
+  <string name="BlockedUsers">Usuarios bloqueados</string>
+  <string name="LogOut">Saír</string>
+  <string name="NoSound">Sen son</string>
+  <string name="Default">Predefinicións</string>
+  <string name="Support">Asistencia</string>
+  <string name="ChatBackground">Fondo de chat</string>
+  <string name="MessagesSettings">Mensaxes</string>
+  <string name="SendByEnter">Enviar con INTRO</string>
+  <string name="TerminateAllSessions">Pechas todas as outras conexións</string>
+  <string name="Events">Actividades</string>
+  <string name="ContactJoined">Un contacto uniuse a Telegram</string>
+  <string name="Pebble">PEBBLE</string>
+  <string name="Language">Idioma</string>
+  <string name="AskAQuestionInfo">Por favor, ten en conta que a asistencia técnica do Telegram proporciónana persoas voluntarias. Tentamos responder o antes posíbel, pero pode demorar un tempo. <![CDATA[<br><br>]]>Bótalle un ollo ás <![CDATA[<a href=\"http://telegram.org/faq#general\">Preguntas Frecuentes do Telegram</a>]]>: aparecen respostas ás dúbidas máis habituais e importantes consellos para a <![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">resolución de problemas</a>]]>.</string>
+  <string name="AskButton">Pregunta a un voluntario</string>
+  <string name="TelegramFaq">Preguntas frecuentes</string>
+  <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+  <string name="DeleteLocalization">Queres eliminar a tradución?</string>
+  <string name="IncorrectLocalization">Ficheiro de tradución incorrecto</string>
+  <string name="Enabled">Activado</string>
+  <string name="Disabled">Desactivado</string>
+  <string name="NotificationsService">Servizo de notificacións</string>
+  <string name="NotificationsServiceDisableInfo">Se os servizos de notificacións de Google Play son suficientes para ti, podes desactivar o Servizo de notificacións. Con todo recomendámosche que o deixes activado para manter a aplicación executándose en segundo plano e recibir notificacións ao momento.</string>
+  <string name="SortBy">Ordenar por</string>
+  <string name="ImportContacts">Importar contactos</string>
+  <string name="SortFirstName">Nome</string>
+  <string name="SortLastName">Apelidos</string>
+  <string name="LedColor">Cor LED</string>
+  <string name="PopupNotification">Notificacións emerxentes</string>
+  <string name="NoPopup">Sen notif. emerxentes</string>
+  <string name="OnlyWhenScreenOn">Só coa pantalla «acendida»</string>
+  <string name="OnlyWhenScreenOff">Só coa pantalla «apagada»</string>
+  <string name="AlwaysShowPopup">Mostrar sempre notif. emerxentes</string>
+  <string name="BadgeNumber">Contador</string>
+  <string name="Short">Curto</string>
+  <string name="Long">Longo</string>
+  <string name="SystemDefault">Predeterminado do sistema</string>
+  <string name="SettingsDefault">Predeterminado nos axustes</string>
+  <string name="AutomaticMediaDownload">Auto-descarga de multimedias</string>
+  <string name="WhenUsingMobileData">Coa conexión de datos</string>
+  <string name="WhenConnectedOnWiFi">Coa conexión WIFI</string>
+  <string name="WhenRoaming">En itinerancia</string>
+  <string name="NoMediaAutoDownload">Sen multimedias</string>
+  <string name="SaveToGallerySettings">Gardar na galería</string>
+  <string name="EditName">Editar nome</string>
+  <string name="NotificationsPriority">Prioridade</string>
+  <string name="NotificationsPriorityDefault">Predeterminados</string>
+  <string name="NotificationsPriorityLow">Baixa</string>
+  <string name="NotificationsPriorityHigh">Alta</string>
+  <string name="NotificationsPriorityMax">Máx.</string>
+  <string name="RepeatNotificationsNever">Nunca</string>
+  <string name="RepeatNotifications">Repetir notificacións</string>
+  <string name="PhoneNumberHelp">Podes cambiar aquí o teu número de Telegram. A túa conta e todos os datos da nube (mensaxes, multimedias, contactos, etc.) moveranse ao novo número.\n\n<![CDATA[<b>Importante:</b>]]> todos os teus contactos de Telegram recibirán o <![CDATA[<b>novo número</b>]]> engadido á súa axenda. Esto débese a que eles teñen o número antigo e non os bloqueaches no Telegram.</string>
+  <string name="PhoneNumberAlert">Todos os contactos do Telegram recibirán o teu número novo engadido á súa axenda. O motivo é que eles teñen o teu número antigo e non os bloqueaches no Telegram.</string>
+  <string name="PhoneNumberChange">CAMBIAR NÚMERO</string>
+  <string name="ChangePhoneNewNumber">Novo número</string>
+  <string name="ChangePhoneHelp">Enviaremos un SMS co código de confirmación ao teu novo número.</string>
+  <string name="ChangePhoneNumberOccupied">O número %1$s xa está asociado a unha conta de Telegram. Elimina ese número antes de cambiar ao número novo.</string>
+  <string name="NotificationsOther">Outro</string>
+  <string name="NotificationsDisabled">Desactivadas</string>
+  <string name="VibrationDisabled">Desactivadas</string>
+  <!--passcode view-->
+  <string name="Passcode">Código</string>
+  <string name="ChangePasscode">Cambiar código</string>
+  <string name="ChangePasscodeInfo">Cando configuras un código, aparece un cadeado na pantalla de chats. Touca sobre el para bloquear e desbloquear a aplicación.\n\nNota: se esqueces o código, terás que eliminar e reinstalar a aplicación. Perderás todos os chats secretos.</string>
+  <string name="ChangePasscodeAlert">Agora verás un cadeado na pantalla de chats. Púlsao para bloquear o teu Telegram co teu novo código.</string>
+  <string name="PasscodePIN">PIN</string>
+  <string name="PasscodePassword">Contrasinal</string>
+  <string name="EnterCurrentPasscode">Pon o teu código de acceso</string>
+  <string name="EnterNewPasscode">Pon o teu novo código de acceso</string>
+  <string name="EnterYourPasscode">Introduce o código</string>
+  <string name="ReEnterYourPasscode">Pon, outra vez, o teu novo código</string>
+  <string name="InvalidPasscode">Código inválido</string>
+  <string name="PasscodeDoNotMatch">Os códigos non coindicen</string>
+  <string name="AutoLock">Bloqueo automático</string>
+  <string name="AutoLockInfo">O bloqueo activarase transcorrido este tempo.</string>
+  <string name="AutoLockInTime">en %1$s</string>
+  <string name="AutoLockDisabled">Desactivado</string>
+  <!--media view-->
+  <string name="NoMedia">Comparte fotos e vídeos neste chat e accede a eles dende calquera dos teus dispositivos.</string>
+  <string name="DocumentsTitle">Ficheiros</string>
+  <string name="SharedMediaTitle">Multimedia</string>
+  <string name="NoSharedFiles">Comparte ficheiros e documentos neste chat e accede a eles dende calquera dos teus dispositivos.</string>
+  <!--map view-->
+  <string name="Map">Mapa</string>
+  <string name="Satellite">Satélite</string>
+  <string name="Hybrid">Híbrido</string>
+  <string name="MetersAway">m de distancia</string>
+  <string name="KMetersAway">km de distancia</string>
+  <string name="SendLocation">Enviar a localización</string>
+  <string name="ShareLocation">Compartir a localización</string>
+  <!--photo gallery view-->
+  <string name="ShowAllMedia">Mostrar todas as fotos</string>
+  <string name="SaveToGallery">Gardar na galería</string>
+  <string name="Of">%1$d de %2$d</string>
+  <string name="Gallery">Galería</string>
+  <string name="AllPhotos">Todas as fotos</string>
+  <string name="NoPhotos">Non hai fotos</string>
+  <string name="PleaseDownload">Descargar primeiro o multimedia</string>
+  <string name="NoRecentPhotos">Non hai fotos recentes</string>
+  <string name="NoRecentGIFs">Non hai GIF recentes</string>
+  <string name="SearchImages">BUSCA FOTOS</string>
+  <string name="SearchImagesInfo">BUSCA WEB</string>
+  <string name="SearchGifs">BUSCA GIF</string>
+  <string name="SearchImagesTitle">Buscar imaxes</string>
+  <string name="SearchGifsTitle">Buscar GIF</string>
+  <string name="CropImage">Recortar imaxe</string>
+  <string name="EditImage">Editar imaxe</string>
+  <string name="Enhance">Realzar</string>
+  <string name="Highlights">Iluminación</string>
+  <string name="Contrast">Contraste</string>
+  <string name="Exposure">Exposición</string>
+  <string name="Warmth">Temperatura</string>
+  <string name="Saturation">Saturación</string>
+  <string name="Vignette">Viñeta</string>
+  <string name="Shadows">Sombras</string>
+  <string name="Grain">Grano</string>
+  <string name="Sharpen">Nitidez</string>
+  <string name="Blur">Desenfoque</string>
+  <string name="AreYouSureDeletePhoto">Queres eliminar esta foto?</string>
+  <string name="AreYouSureDeleteVideo">Queres eliminar este vídeo?</string>
+  <string name="DiscardChanges">Descartar cambios?</string>
+  <!--privacy settings-->
+  <string name="PrivacySettings">Privacidade e seguridade</string>
+  <string name="PrivacyTitle">Privacidade</string>
+  <string name="PrivacyLastSeen">Última conexión</string>
+  <string name="LastSeenEverybody">Todos</string>
+  <string name="LastSeenContacts">Os meus contactos</string>
+  <string name="LastSeenNobody">Ninguén</string>
+  <string name="LastSeenEverybodyMinus">Todos (-%1$d)</string>
+  <string name="LastSeenContactsPlus">Contactos (+%1$d)</string>
+  <string name="LastSeenContactsMinus">Contactos (-%1$d)</string>
+  <string name="LastSeenContactsMinusPlus">Contactos (-%1$d, +%2$d)</string>
+  <string name="LastSeenNobodyPlus">Ninguén (+%1$d)</string>
+  <string name="SecurityTitle">Seguridade</string>
+  <string name="DeleteAccountTitle">A conta auto-destrúese</string>
+  <string name="DeleteAccountIfAwayFor">Se estou fóra</string>
+  <string name="DeleteAccountHelp">Se non inicias sesión polo menos unha vez neste tempo, a túa conta eliminarase con todos os grupos, mensaxes e contactos.</string>
+  <string name="DeleteAccountNowConfirmation">Queres eliminar a conta?</string>
+  <string name="LastSeenHelp">Elixe quen pode ver a túa última conexión.</string>
+  <string name="LastSeenTitle">Quen pode ver a última conexión?</string>
+  <string name="AddExceptions">Engadir excepcións</string>
+  <string name="CustomHelp">Importante: Non verása última conexión das persoas coas que non compartes a túa. No seu lugar verás unha aproximación (recentemente, hai uns días, hai unhas semanas).</string>
+  <string name="AlwaysShareWith">Compartir con</string>
+  <string name="NeverShareWith">Non compartir con</string>
+  <string name="CustomShareSettingsHelp">Estes axustes anularán os valores de arriba.</string>
+  <string name="AlwaysShareWithTitle">Compartir sempre</string>
+  <string name="AlwaysShareWithPlaceholder">Compartir sempre con usuarios...</string>
+  <string name="NeverShareWithTitle">Non compartir</string>
+  <string name="NeverShareWithPlaceholder">Non compartir con usuarios</string>
+  <string name="EmpryUsersPlaceholder">Engadir usuarios</string>
+  <string name="PrivacyFloodControlError">Sentímolo, demasiadas peticións. Non é posible cambiar os axustes da privacidade agora. Agarda.</string>
+  <string name="ClearOtherSessionsHelp">Saír de todos os dispositivos, agás este.</string>
+  <string name="RemoveFromListText">Preme sobre o usuario para eliminalo.</string>
+  <!--edit video view-->
+  <string name="EditVideo">Editar vídeo</string>
+  <string name="OriginalVideo">Vídeo orixinal</string>
+  <string name="EditedVideo">Vídeo editado</string>
+  <string name="SendingVideo">Enviando o vídeo...</string>
+  <string name="CompressVideo">Comprimir vídeo</string>
+  <!--button titles-->
+  <string name="Next">Seguinte</string>
+  <string name="Back">Atrás</string>
+  <string name="Done">Feito</string>
+  <string name="Open">Abrir</string>
+  <string name="Cancel">Cancelar</string>
+  <string name="Add">Engadir</string>
+  <string name="Edit">Editar</string>
+  <string name="Send">Enviar</string>
+  <string name="Call">Chamar</string>
+  <string name="Copy">Copiar</string>
+  <string name="Delete">Borrar</string>
+  <string name="Forward">Reenviar</string>
+  <string name="Retry">Reintentar</string>
+  <string name="FromCamera">Dende a cámara</string>
+  <string name="FromGalley">Dende a galería</string>
+  <string name="DeletePhoto">Eliminar a foto</string>
+  <string name="Set">Definir</string>
+  <string name="OK">Aceptar</string>
+  <string name="Crop">CORTAR</string>
+  <!--messages-->
+  <string name="ActionKickUser">un1 eliminou a un2</string>
+  <string name="ActionLeftUser">un1 abandonou o grupo</string>
+  <string name="ActionAddUser">un1 engadiu a un2</string>
+  <string name="ActionRemovedPhoto">un1 eliminou a foto do grupo</string>
+  <string name="ActionChangedPhoto">un1 mudou a foto do grupo</string>
+  <string name="ActionChangedTitle">un1 mudou o nome do grupo a un2</string>
+  <string name="ActionCreateGroup">un1 creou o grupo</string>
+  <string name="ActionYouKickUser">Eliminaches a un2</string>
+  <string name="ActionYouLeftUser">Abandonaches o grupo</string>
+  <string name="ActionYouAddUser">Engadiches a un2</string>
+  <string name="ActionYouRemovedPhoto">Eliminaches a foto do grupo</string>
+  <string name="ActionYouChangedPhoto">Mudaches a foto do grupo</string>
+  <string name="ActionYouChangedTitle">Cambiaches o nome do grupo a un2</string>
+  <string name="ActionYouCreateGroup">Creaches o grupo</string>
+  <string name="ActionKickUserYou">un1 eliminoute</string>
+  <string name="ActionAddUserYou">un1 engadiute</string>
+  <string name="ActionAddUserSelf">un1 volveu ao grupo</string>
+  <string name="UnsuppotedMedia">Esta mensaxe non é compatíbel coa versión do Telegram que utilizas. 
+Actualiza a aplicación para poderes vela:
+http://telegram.org/update</string>
+  <string name="AttachPhoto">Foto</string>
+  <string name="AttachVideo">Vídeo</string>
+  <string name="AttachLocation">Localización</string>
+  <string name="AttachContact">Contacto</string>
+  <string name="AttachDocument">Ficheiro</string>
+  <string name="AttachSticker">Sticker</string>
+  <string name="AttachAudio">Son</string>
+  <string name="FromYou">Ti</string>
+  <string name="ActionTakeScreenshootYou">Fixeches unha captura de pantalla</string>
+  <string name="ActionTakeScreenshoot">un1 fixo unha captura de pantalla</string>
+  <!--Alert messages-->
+  <string name="InvalidPhoneNumber">O número de teléfono non é válido.</string>
+  <string name="CodeExpired">Caducou o código, conéctate de novo</string>
+  <string name="FloodWait">Demasiados intentos, proba máis tarde</string>
+  <string name="InvalidCode">Código non válido</string>
+  <string name="InvalidFirstName">Nome non válido</string>
+  <string name="InvalidLastName">Apelidos non válidos</string>
+  <string name="Loading">Cargando...</string>
+  <string name="NoPlayerInstalled">Non tes reprodutor de vídeo, instala un para continuares</string>
+  <string name="NoMailInstalled">Por favor, envía un correo electrónico a sms@telegram.org e explica o teu problema.</string>
+  <string name="NoHandleAppInstalled">Non tes aplicacións instaladas que poidan manexar o tipo de ficheiro «%1$s», intala unha para continuar</string>
+  <string name="InviteUser">Este usuario aínda non ten Telegram, queres convidalo?</string>
+  <string name="AreYouSure">Estás seguro?</string>
+  <string name="AddToTheGroup">Queres engadir a %1$s ao grupo?\n\nNúmero das últimas mensaxes a reenviar:
+
+
+
+</string>
+  <string name="ForwardMessagesTo">Queres reenviar mensaxes a %1$s?</string>
+  <string name="SendMessagesTo">Desexas enviar as mensaxes a %1$s?</string>
+  <string name="AreYouSureLogout">Estás seguro de saír da sesión?\n\nTen en conta que podes usar o Telegram en todos os dispositivos á vez.\n\nLembra, ao saír da sesión eliminas as conversas secretas.</string>
+  <string name="AreYouSureSessions">Estás seguro de cancelar todos os outros accesos?</string>
+  <string name="AreYouSureDeleteAndExit">Estás seguro de eliminar e abandonar o grupo?</string>
+  <string name="AreYouSureDeleteThisChat">Estás seguro de eliminar esta conversa?</string>
+  <string name="AreYouSureShareMyContactInfo">Estás seguro de compartir a túa información de contacto?</string>
+  <string name="AreYouSureBlockContact">Estás seguro de querer bloquear este contacto?</string>
+  <string name="AreYouSureUnblockContact">Estás seguro de querer desbloquear este contacto?</string>
+  <string name="AreYouSureDeleteContact">Estás seguro de eliminar este contacto?</string>
+  <string name="AreYouSureSecretChat">Estás seguro de querer iniciar un chat secreto?</string>
+  <string name="AreYouSureRegistration">Estás seguro de cancelar o rexistro?</string>
+  <string name="AreYouSureClearHistory">Estás seguro de borrar o historial?</string>
+  <string name="AreYouSureDeleteMessages">Estás seguro de eliminar %1$s?</string>
+  <string name="SendMessagesToGroup">Desexas enviar as mensaxes a %1$s?</string>
+  <string name="ForwardMessagesToGroup">Desexas reenviar as mensaxes a %1$s?</string>
+  <string name="FeatureUnavailable">Sentímolo, esta funcionalidade non está dispoñíbel no teu país.</string>
+  <!--Intro view-->
+  <string name="Page1Title">Plus Messenger</string>
+  <string name="Page2Title">Rápido</string>
+  <string name="Page3Title">De balde</string>
+  <string name="Page4Title">Seguro</string>
+  <string name="Page5Title">Potente</string>
+  <string name="Page6Title">Baseado na nube</string>
+  <string name="Page7Title">Privado</string>
+  <string name="Page1Message">A aplicación de mensaxería <![CDATA[<b>máis rápida</b>]]> do mundo.<![CDATA[<br/>]]>É <![CDATA[<b>gratis</b>]]> e <![CDATA[<b>segura</b>]]>.</string>
+  <string name="Page2Message"><![CDATA[<b>Plus Messenger</b>]]> envía as mensaxes máis rápido que <![CDATA[<br/>]]>ningunha outra aplicación</string>
+  <string name="Page3Message"><![CDATA[<b>Plus Messenger</b>]]> Gratis para sempre. Sen publicidade.<![CDATA[<br/>]]>Sen custos de subscrición.</string>
+  <string name="Page4Message"><![CDATA[<b>Plus Messenger</b>]]> protexe as túas mensaxes <![CDATA[<br/>]]>dos ataques de terceiras persoas.</string>
+  <string name="Page5Message"><![CDATA[<b>Plus Messenger</b>]]> non ten límites de tamaño nos<![CDATA[<br/>]]>ficheiros multimedia e nas conversas.</string>
+  <string name="Page6Message"><![CDATA[<b>Plus Messenger</b>]]> permíteche acceder ás túas mensaxes<![CDATA[<br/>]]>desde múltiples dispositivos.</string>
+  <string name="Page7Message"><![CDATA[<b>Plus Messenger</b>]]> cifra robustamente as mensaxes<![CDATA[<br/>]]>e pode autodestruílas.</string>
+  <string name="StartMessaging">Comeza a enviar mensaxes</string>
+  <!--plural-->
+  <string name="Online_zero">%1$d en liña</string>
+  <string name="Online_one">%1$d en liña</string>
+  <string name="Online_two">%1$d en liña</string>
+  <string name="Online_few">%1$d en liña</string>
+  <string name="Online_many">%1$d en liña</string>
+  <string name="Online_other">%1$d  en liña</string>
+  <string name="Members_zero">non hai membros</string>
+  <string name="Members_one">%1$d membro</string>
+  <string name="Members_two">%1$d membros</string>
+  <string name="Members_few">%1$d membros</string>
+  <string name="Members_many">%1$d membros</string>
+  <string name="Members_other">%1$d membros</string>
+  <string name="AndMoreTyping_zero">e %1$d persoas máis están escribindo</string>
+  <string name="AndMoreTyping_one">e %1$d persoas máis están escribindo</string>
+  <string name="AndMoreTyping_two">e %1$d persoas máis están escribindo</string>
+  <string name="AndMoreTyping_few">e %1$d persoas máis están escribindo</string>
+  <string name="AndMoreTyping_many">e %1$d persoas máis están escribindo</string>
+  <string name="AndMoreTyping_other">e %1$d persoas máis están escribindo</string>
+  <string name="NewMessages_zero">non hai mensaxes novas</string>
+  <string name="NewMessages_one">%1$d mensaxe nova</string>
+  <string name="NewMessages_two">%1$d mensaxes novas</string>
+  <string name="NewMessages_few">%1$d mensaxes novas</string>
+  <string name="NewMessages_many">%1$d mensaxes novas</string>
+  <string name="NewMessages_other">%1$d mensaxes novas</string>
+  <string name="messages_zero">non hai mensaxes</string>
+  <string name="messages_one">%1$d mensaxe</string>
+  <string name="messages_two">%1$d mensaxes</string>
+  <string name="messages_few">%1$d mensaxes</string>
+  <string name="messages_many">%1$d mensaxes</string>
+  <string name="messages_other">%1$d mensaxes</string>
+  <string name="items_zero">Sen ítems</string>
+  <string name="items_one">%1$d item</string>
+  <string name="items_two">%1$d ítems</string>
+  <string name="items_few">%1$d ítems</string>
+  <string name="items_many">%1$d ítems</string>
+  <string name="items_other">%1$d ítems</string>
+  <string name="FromChats_zero">dende ningún chat</string>
+  <string name="FromChats_one">desde %1$d chat</string>
+  <string name="FromChats_two">desde %1$d chats</string>
+  <string name="FromChats_few">desde %1$d chats</string>
+  <string name="FromChats_many">desde %1$d chats</string>
+  <string name="FromChats_other">desde %1$d chats</string>
+  <string name="Seconds_zero">%1$d segundos</string>
+  <string name="Seconds_one">%1$d segundo</string>
+  <string name="Seconds_two">%1$d segundos</string>
+  <string name="Seconds_few">%1$d segundos</string>
+  <string name="Seconds_many">%1$d segundos</string>
+  <string name="Seconds_other">%1$d segundos</string>
+  <string name="Minutes_zero">%1$d minutos</string>
+  <string name="Minutes_one">%1$d minuto</string>
+  <string name="Minutes_two">%1$d minutos</string>
+  <string name="Minutes_few">%1$d minutos</string>
+  <string name="Minutes_many">%1$d minutos</string>
+  <string name="Minutes_other">%1$d minutos</string>
+  <string name="Hours_zero">%1$d horas</string>
+  <string name="Hours_one">%1$d hora</string>
+  <string name="Hours_two">%1$d horas</string>
+  <string name="Hours_few">%1$d horas</string>
+  <string name="Hours_many">%1$d horas</string>
+  <string name="Hours_other">%1$d horas</string>
+  <string name="Days_zero">%1$d días</string>
+  <string name="Days_one">%1$d día</string>
+  <string name="Days_two">%1$d días</string>
+  <string name="Days_few">%1$d días</string>
+  <string name="Days_many">%1$d días</string>
+  <string name="Days_other">%1$d días</string>
+  <string name="Weeks_zero">%1$d semanas</string>
+  <string name="Weeks_one">%1$d semana</string>
+  <string name="Weeks_two">%1$d semanas</string>
+  <string name="Weeks_few">%1$d semanas</string>
+  <string name="Weeks_many">%1$d semanas</string>
+  <string name="Weeks_other">%1$d semanas</string>
+  <string name="Months_zero">%1$d meses</string>
+  <string name="Months_one">%1$d mes</string>
+  <string name="Months_two">%1$d meses</string>
+  <string name="Months_few">%1$d meses</string>
+  <string name="Months_many">%1$d meses</string>
+  <string name="Months_other">%1$d meses</string>
+  <string name="Years_zero">%1$d anos</string>
+  <string name="Years_one">%1$d ano</string>
+  <string name="Years_two">%1$d anos</string>
+  <string name="Years_few">%1$d anos</string>
+  <string name="Years_many">%1$d anos</string>
+  <string name="Years_other">%1$d anos</string>
+  <string name="Users_zero">%1$d usuarios</string>
+  <string name="Users_one">%1$d usuario</string>
+  <string name="Users_two">%1$d usuarios</string>
+  <string name="Users_few">%1$d usuarios</string>
+  <string name="Users_many">%1$d usuarios</string>
+  <string name="Users_other">%1$d usuarios</string>
+  <!--date formatters-->
+  <string name="formatterMonthYear">MMMM de yyyy</string>
+  <string name="formatterMonth">dd \'de\' MMM</string>
+  <string name="formatterYear">dd.MM.yy</string>
+  <string name="formatterYearMax">dd.MM.yyyy</string>
+  <string name="chatDate">d \'de\' MMMM</string>
+  <string name="chatFullDate">d \'de\' MMMM, yyyy</string>
+  <string name="formatterWeek">EEE</string>
+  <string name="formatterDay24H">HH:mm</string>
+  <string name="formatterDay12H">h:mm a</string>
+  <string name="formatDateAtTime">%1$s en %2$s</string>
+  <!--Telegram+ Galician-->
+    <!--Smart Notifications-->
+    <string name="SmartNotification">Notificación intelixente</string>
+    <string name="TimeUnitSeconds">segundo(s)</string>
+    <string name="TimeUnitMinutes">minuto(s)</string>
+    <string name="TimeUnitHours">hora(s)</string>
+    <string name="TimeUnitDays">día(s)</string>
+    <string name="settings_smart_notify_begin">Soa máximo</string>
+    <string name="settings_smart_notify_mid1">veces</string>
+    <string name="settings_smart_notify_mid11">vez</string>
+    <string name="settings_smart_notify_mid2">cada</string>
+    <!---->
+    <string name="TelegramForAndroid">Plus Messenger para Android</string>
+    <string name="Theming">Tematización</string>
+    <string name="colorHexInvalid">Cor hexadecimal inválida!</string>
+    <string name="themeColor">Cor de tema</string>
+    <string name="ResetThemeSettings">Restablecer axustes do tema</string>
+    <string name="ResetThemeSettingsSum">Desfai todos os cambios do tema actual</string>
+  <string name="ResetThemeToastText">Tema restablecido a valores por defecto!</string>
+    <string name="General">Xeral</string>
+    <string name="Screens">Pantallas</string>
+    <string name="MainScreen">Pantalla principal</string>
+    <string name="ChatScreen">Pantalla de chat</string>
+    <string name="ContactsScreen">Pantalla de contactos</string>
+    <string name="Header">Cabeceira</string>
+    <string name="Rows">Lista</string>
+    <string name="ChatList">Lista de chat</string>
+    <string name="ChatsList">Lista de chats</string>
+    <string name="ContactsList">Lista de contactos</string>
+    <string name="HeaderColor">Cor de cabeceira</string>
+  <string name="NameColor">Cor de nome</string>
+    <string name="NameSize">Tamaño de nome</string>
+    <string name="MessageColor">Cor de mensaxe</string>
+    <string name="MessageSize">Tamaño de mensaxe</string>
+  <string name="TimeDateColor">Cor de hora/data</string>
+  <string name="TimeDateSize">Tamaño de hora/data</string>
+    <string name="CountColor">Cor de contador</string>
+    <string name="CountSize">Tamaño de contador</string>
+    <string name="RowColor">Cor de panel</string>
+    <string name="CountBGColor">Cor de fondo de contador</string>
+    <string name="StatusColor">Cor de estado</string>
+    <string name="StatusSize">Tamaño de estado</string>
+  <string name="RBubbleColor">Cor de burbulla dereita</string>
+  <string name="LBubbleColor">Cor de burbulla esquerda</string>
+  <string name="DateColor">Cor de data</string>
+  <string name="DateSize">Tamaño de data</string>
+  <string name="DateBubbleColor">Cor de data de burbulla</string>
+  <string name="RTextColor">Cor de texto dereito</string>
+    <string name="LTextColor">Cor de texto esquerdo</string>
+    <string name="RTimeColor">Cor de hora dereita</string>
+    <string name="LTimeColor">Cor de hora esquerda</string>
+    <string name="TimeSize">Tamaño de hora</string>
+    <string name="EditTextColor">Cor de entrada de texto</string>
+    <string name="EditTextSize">Tamaño de entrada de texto</string>
+    <string name="EditTextBGColor">Cor de fondo da entrada de texto</string>
+  <string name="EmojiViewBGColor">Cor de fondo de emoticonas</string>
+  <string name="EmojiViewTabColor">Cor de lapela de emoticonas</string>
+    <string name="OnlineColor">Cor de en liña</string>
+    <string name="ChatMusic">Música</string>
+    <string name="SaveTheme">Gardar tema</string>
+    <string name="SaveThemeSum">Garda o teu tema na carpeta Telegram/Themes</string>
+  <string name="SaveThemeToastText">Tema gardado!</string>
+    <string name="SavedTo">%1$s gardado en %2$s</string>
+    <string name="SaveErrorMsg0">Tema non creado aínda. Aplica primeiro algún MOD</string>
+    <string name="restoreOkMsg">Tema cargado dende a SD</string>
+  <string name="restoreErrorMsg">Non se encontrou ningún ficheiro de preferencias en %s</string>
+    <string name="NoMediaMessage">Non se encontrou tarxeta SD</string>
+    <string name="EnterName">Introduce nome</string>
+    <string name="Themes">Temas</string>
+    <string name="ApplyTheme">Aplicar tema</string>
+    <string name="ApplyThemeSum">Aplicar tema dende carpeta local</string>
+    <string name="MemberColor">Cor de membro</string>
+    <string name="ChecksColor">Cor de ticks</string>
+    <string name="MuteColor">Cor de silencio</string>
+    <string name="SendLogs">Enviar logs</string>
+    <string name="SendLogsEmpty">Non hai logs</string>
+    <string name="SendIcon">Icona enviar</string>
+  <string name="HideMobile">Ocultar número de móbil do menú</string>
+    <string name="FloatingPencilColor">Cor de botón lapis flotante</string>
+    <string name="FloatingBGColor">Cor de fondo de botón flotante</string>
+    <string name="Community">Comunidade G+</string>
+  <string name="TypingColor">Cor \'escribindo\'</string>
+  <string name="EditTextIconsColor">Cor de iconas de entrada de texto</string>
+  <string name="NavigationDrawer">Menú de navegación</string>
+  <string name="OptionsList">Lista de opcións</string>
+  <string name="ListColor">Cor de lista</string>
+  <string name="OwnNameSize">Tamaño de nome</string>
+  <string name="PhoneColor">Cor de teléfono</string>
+  <string name="PhoneSize">Tamaño de teléfono</string>
+  <string name="AvatarColor">Cor de avatar</string>
+  <string name="IconColor">Cor de icona de opción</string>
+  <string name="OptionColor">Cor de opción</string>
+  <string name="OptionSize">Tamaño de opción</string>
+  <string name="VersionColor">Cor de versión</string>
+  <string name="VersionSize">Tamaño de versión</string>
+  <string name="HeaderTitleColor">Cor de título de cabeceira</string>
+  <string name="HeaderIconsColor">Cor de iconas de cabeceira</string>
+  <string name="DividerColor">Cor de divisor</string>
+  <string name="AvatarRadius">Raio de avatar</string>
+  <string name="SetMemberColor">Cambiar cor de membro</string>
+  <string name="ForwardNameColor">Cor de nome de reenvío</string>
+  <string name="HeaderTitle">Título de cabeceira</string>
+  <string name="ForwardNoQuote">Reenviar sin citar</string>
+  <string name="DisableMessageClick">Desactivar pop-up ao tocar</string>
+  <string name="ProfileScreen">Perfil de grupo/contacto</string>
+  <string name="HideBackground">Ocultar fondo personalizado</string>
+  <string name="RLinkColor">Cor de enlace dereito</string>
+  <string name="LLinkColor">Cor de enlace esquerdo</string>
+  <string name="ThemeApplied">Tema aplicado!</string>
+  <string name="ClickOkToRestart">Preme OK para reiniciar a app</string>
+  <string name="ShowAndroidEmoji">Mostrar emoticona do teléfono</string>
+  <string name="BubbleStyle">Estilo de burbulla</string>
+  <string name="KeepOriginalFilename">Manter o nome orixinal do ficheiro</string>
+  <string name="KeepOriginalFilenameHelp">No canto de só números, os ficheiros gardaranse usando o formato nome_data</string>
+  <string name="AvatarSize">Tamaño do avatar</string>
+  <string name="AvatarAlignTop">Aliñar o avatar arriba</string>
+  <string name="AvatarMarginLeft">Marxe esquerdo do avatar</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-hi/strings.xml b/TMessagesProj/src/main/res/values-hi/strings.xml
new file mode 100644
index 000000000..efe424d82
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-hi/strings.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="auth_client_needs_enabling_title">एप्लिकेशन के लिए Google Play सेवाओं को सक्षम किए जाने की आवश्यकता है.</string>
+    <string name="auth_client_needs_installation_title">एप्लिकेशन के लिए Google Play सेवाओं के इंस्टॉलेशन की आवश्यकता है.</string>
+    <string name="auth_client_needs_update_title">एप्लिकेशन के लिए Google Play सेवाओं में अपडेट की आवश्यकता है.</string>
+    <string name="auth_client_play_services_err_notification_msg">Google Play सेवाएं त्रुटि</string>
+    <string name="auth_client_requested_by_msg">%1$s द्वारा अनुरोधित</string>
+    <string name="auth_client_using_bad_version_title">एप्लि. ने Google Play सेवाओं के खराब संस्करण के उपयोग का प्रयास किया.</string>
+    <string name="common_google_play_services_enable_button">Google Play सेवाएं सक्षम करें</string>
+    <string name="common_google_play_services_enable_text">जब तक आप Google Play सेवाएं सक्षम नहीं करते, तब तक यह एप्लिकेशन कार्य नहीं करेगा.</string>
+    <string name="common_google_play_services_enable_title">Google Play सेवाएं सक्षम करें</string>
+    <string name="common_google_play_services_install_button">Google Play सेवाएं पाएं</string>
+    <string name="common_google_play_services_install_text_phone">यह एप्लिकेशन Google Play सेवाओं के बिना नहीं चलेगा, जो आपके फ़ोन में नहीं हैं.</string>
+    <string name="common_google_play_services_install_text_tablet">यह एप्लिकेशन Google Play सेवाओं के बिना नहीं चलेगा, जो आपके टेबलेट में नहीं हैं.</string>
+    <string name="common_google_play_services_install_title">Google Play सेवाएं पाएं</string>
+    <string name="common_google_play_services_invalid_account_text">निर्दिष्ट खाता इस उपकरण पर मौजूद नहीं है. कृपया कोई भिन्न खाता चुनें.</string>
+    <string name="common_google_play_services_invalid_account_title">अमान्य खाता</string>
+    <string name="common_google_play_services_network_error_text">Google Play सेवाओं से कनेक्ट करने के लिए डेटा कनेक्शन की आवश्यकता है.</string>
+    <string name="common_google_play_services_network_error_title">नेटवर्क त्रुटि</string>
+    <string name="common_google_play_services_unknown_issue">Google Play सेवाओं के साथ अज्ञात समस्या.</string>
+    <string name="common_google_play_services_unsupported_text">Google Play सेवाएं, जिन पर आपके कुछ एप्लिकेशन निर्भर करते हैं, आपके उपकरण द्वारा समर्थित नहीं हैं. कृपया सहायता के लिए निर्माता से संपर्क करें.</string>
+    <string name="common_google_play_services_unsupported_title">Google Play सेवाएं</string>
+    <string name="common_google_play_services_update_button">अपडेट करें</string>
+    <string name="common_google_play_services_update_text">जब तक आप Google Play सेवाओं को अपडेट नहीं करते, तब तक यह एप्लिकेशन नहीं चलेगा.</string>
+    <string name="common_google_play_services_update_title">Google Play सेवाएं अपडेट करें</string>
+    <string name="common_signin_button_text">प्रवेश करें</string>
+    <string name="common_signin_button_text_long">Google से प्रवेश करें</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-hr/strings.xml b/TMessagesProj/src/main/res/values-hr/strings.xml
new file mode 100644
index 000000000..3ccedd929
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-hr/strings.xml
@@ -0,0 +1,708 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="AppName">Plus Messenger</string>
+    <string name="LanguageName">Hrvatski</string>
+    <string name="LanguageNameInEnglish">Croatian</string>
+    <string name="LanguageCode">hr</string>
+    <!--signin view-->
+    <string name="YourPhone">Vaš telefonski broj</string>
+    <string name="StartText">Potvrdite kôd države i upišite vaš telefonski broj.</string>
+    <string name="ChooseCountry">Odaberite državu</string>
+    <string name="WrongCountry">Neispravan kôd države</string>
+    <!--code enter view-->
+    <string name="YourCode">Vaš kôd</string>
+    <string name="SentSmsCode">Poslali smo vam SMS s aktivacijskim kodom na vaš telefonski broj</string>
+    <string name="CallText">Nazvat ćemo vas za %1$d:%2$02d</string>
+    <string name="Calling">Pozivamo vas...</string>
+    <string name="Code">Kôd</string>
+    <string name="WrongNumber">Krivi broj?</string>
+    <string name="DidNotGetTheCode">Niste dobili kôd?</string>
+    <!--signup view-->
+    <string name="YourName">Vaše ime</string>
+    <string name="RegisterText">Podesite svoje ime i prezime</string>
+    <!--<string name="RegisterText">Set up your name and picture</string>-->
+    <string name="FirstName">Ime (obavezno)</string>
+    <string name="LastName">Prezime (neobavezno)</string>
+    <string name="CancelRegistration">Otkažite registraciju</string>
+    <!--chats view-->
+    <string name="Settings">Postavke</string>
+    <string name="Contacts">Kontakti</string>
+    <string name="NewGroup">Nova grupa</string>
+    <string name="Yesterday">jučer</string>
+    <string name="NoResult">Nema rezultata</string>
+    <string name="NoChats">Trenutno nema dopisivanja..</string>
+    <string name="NoChatsHelp">Počnite s dopisivanjem pritiskom na\n\'Nova poruka\' dugme u donjem desnom kutu\nili pritisnite \'Meni\' dugme za više opcija.</string>
+    <string name="WaitingForNetwork">Čekanje na mrežu...</string>
+    <string name="Connecting">Spajanje...</string>
+    <string name="Updating">Nadogradnja...</string>
+    <string name="NewSecretChat">Novo tajno dopisivanje</string>
+    <string name="AwaitingEncryption">Čekanje da se %s pojavi na mreži...</string>
+    <string name="EncryptionRejected">Tajno dopisivanje otkazano</string>
+    <string name="EncryptionProcessing">Razmjena enkripcijskih ključeva...</string>
+    <string name="EncryptedChatStartedOutgoing">%s se pridružio/la tajnom dopisivanju.</string>
+    <string name="EncryptedChatStartedIncoming">Pridružili ste se tajnom dopisivanju.</string>
+    <string name="ClearHistory">Obriši povijest</string>
+    <string name="DeleteChat">Obriši i napusti</string>
+    <string name="DeleteChatUser">Izbriši dopisivanje</string>
+    <string name="HiddenName">Korisnički račun izbrisan</string>
+    <string name="SelectChat">Odaberi dopisivanje</string>
+    <string name="PhotoTip">Dodirni i zadrži prst za pregledati</string>
+    <string name="CompatibilityChat">%1$s koristi stariju verziju Telegrama, zbog toga će tajne slike biti prikazane u načinu za kompatibilnost.\n\nKada %2$s nadogradi Telegram, slike s brojačem od 1 minute ili manje će početi raditi u \'Dodirni i zadrži prst za pregledati\' načinu, a ti ćeš biti obaviješten/a uvijek kada druga strana napravi snimku zaslona.</string>
+    <string name="SearchMessages">PORUKE</string>
+    <string name="Search">Pretraži</string>
+    <string name="MuteNotifications">Isključi obavijesti</string>
+    <string name="MuteFor">Isključi na %1$s</string>
+    <string name="UnmuteNotifications">Uključiti</string>
+    <string name="WillUnmuteIn">Za %1$s</string>
+    <string name="MuteDisable">Onemogućeno</string>
+    <!--broadcasts-->
+    <string name="NewBroadcastList">Nova distribucijska lista</string>
+    <string name="EnterListName">Upiši naziv liste</string>
+    <string name="YouCreatedBroadcastList">Napravili ste distribucijsku listu</string>
+    <string name="AddRecipient">Dodaj primatelja</string>
+    <string name="KickFromBroadcast">Ukloni iz distribucijske liste</string>
+    <!--documents view-->
+    <string name="SelectFile">Odaberite datoteku</string>
+    <string name="FreeOfTotal">Slobodno %1$s od %2$s</string>
+    <string name="UnknownError">Nepoznata greška</string>
+    <string name="AccessError">Greška s pristupom</string>
+    <string name="NoFiles">Trenutno nema datoteka...</string>
+    <string name="FileUploadLimit">Veličina datoteke ne smije prelaziti %1$s</string>
+    <string name="NotMounted">Pohrana nije učitana</string>
+    <string name="UsbActive">USB prijenos je aktivan</string>
+    <string name="InternalStorage">Unutarnja pohrana</string>
+    <string name="ExternalStorage">Vanjska pohrana</string>
+    <string name="SystemRoot">Sustav</string>
+    <string name="SdCard">SD kartica</string>
+    <string name="Folder">Mapa</string>
+    <string name="GalleryInfo">Slanje slika bez kompresije</string>
+    <!--chat view-->
+    <string name="Invisible">nevidljiv</string>
+    <string name="Typing">piše...</string>
+    <string name="IsTyping">piše...</string>
+    <string name="AreTyping">pišu...</string>
+    <string name="GotAQuestion">Imaš pitanje o Telegramu?</string>
+    <string name="ChatTakePhoto">Uslikaj</string>
+    <string name="ChatGallery">Galerija</string>
+    <string name="ChatLocation">Lokacija</string>
+    <string name="ChatVideo">Video</string>
+    <string name="ChatDocument">Datoteka</string>
+    <string name="NoMessages">Trenutno ovdje nema poruka...</string>
+    <string name="ForwardedMessage">Proslijeđene poruke</string>
+    <string name="From">Od</string>
+    <string name="NoRecent">Nema nedavnih</string>
+    <string name="Message">Poruka</string>
+    <string name="TypeMessage">Poruka</string>
+    <string name="ShareMyContactInfo">Podijeliti moj broj</string>
+    <string name="AddToContacts">Dodati u kontakte</string>
+    <string name="EncryptedPlaceholderTitleIncoming">%s vas poziva na tajno dopisivanje.</string>
+    <string name="EncryptedPlaceholderTitleOutgoing">Pozvali ste %s na tajno dopisivanje.</string>
+    <string name="EncryptedDescriptionTitle">Tajna dopisivanja:</string>
+    <string name="EncryptedDescription1">Koriste end-to-end enkripciju</string>
+    <string name="EncryptedDescription2">Bez tragova na našem serveru</string>
+    <string name="EncryptedDescription3">Moguće podesiti samouništenje</string>
+    <string name="EncryptedDescription4">Ne dopuštaju prosljeđivanje</string>
+    <string name="YouWereKicked">Uklonjen iz ove grupe</string>
+    <string name="YouLeft">Napustio si ovu grupu</string>
+    <string name="DeleteThisGroup">Izbriši grupu</string>
+    <string name="DeleteThisChat">Izbriši ovo dopisivanje</string>
+    <string name="SlideToCancel">POVUCITE ZA PREKID</string>
+    <string name="SaveToDownloads">Spremi u preuzimanja</string>
+    <string name="ShareFile">Dijeli</string>
+    <string name="ApplyLocalizationFile">Koristiti prijevod</string>
+    <string name="UnsupportedAttachment">Privitak nije podržan</string>
+    <string name="SetTimer">Postavi samouništenje</string>
+    <string name="ServiceNotifications">Usluga obavijesti</string>
+    <!--notification-->
+    <string name="MessageLifetimeChanged">%1$s postavlja odbrojavanje samouništenja za %2$s</string>
+    <string name="MessageLifetimeChangedOutgoing">Odbrojavanje za samouništenje je postavljeno na %1$s</string>
+    <string name="MessageLifetimeRemoved">%1$s onemogućava odbrojavanje za samouništenje</string>
+    <string name="MessageLifetimeYouRemoved">Odbrojavanje za samouništenje je onemogućeno</string>
+    <string name="YouHaveNewMessage">Imaš novu poruku</string>
+    <string name="NotificationMessageText">%1$s: %2$s</string>
+    <string name="NotificationMessageNoText">%1$s vam šalje poruku</string>
+    <string name="NotificationMessagePhoto">%1$s vam šalje sliku</string>
+    <string name="NotificationMessageVideo">%1$s vam šalje videozapis</string>
+    <string name="NotificationMessageContact">%1$s dijeli kontakt s tobom</string>
+    <string name="NotificationMessageMap">%1$s vam šalje lokaciju</string>
+    <string name="NotificationMessageDocument">%1$s vam šalje datoteku</string>
+    <string name="NotificationMessageAudio">%1$s vam šalje zvučni zapis</string>
+    <string name="NotificationMessageSticker">%1$s vam šalje naljepnicu</string>
+    <string name="NotificationMessageGroupText">%1$s @ %2$s: %3$s</string>
+    <string name="NotificationMessageGroupNoText">%1$s šalje poruku u grupi %2$s</string>
+    <string name="NotificationMessageGroupPhoto">%1$s šalje sliku u grupi %2$s</string>
+    <string name="NotificationMessageGroupVideo">%1$s šalje videozapis u grupi %2$s</string>
+    <string name="NotificationMessageGroupContact">%1$s dijeli kontakt s grupom %2$s</string>
+    <string name="NotificationMessageGroupMap">%1$s šalje lokaciju u grupi %2$s</string>
+    <string name="NotificationMessageGroupDocument">%1$s šalje datoteku u grupi %2$s</string>
+    <string name="NotificationMessageGroupAudio">%1$s šalje zvučni zapis u grupi %2$s</string>
+    <string name="NotificationMessageGroupSticker">%1$s šalje naljepnicu u grupi %2$s</string>
+    <string name="NotificationInvitedToGroup">%1$s te poziva u grupu %2$s</string>
+    <string name="NotificationEditedGroupName">%1$s uređuje naziv grupe %2$s</string>
+    <string name="NotificationEditedGroupPhoto">%1$s uređuje sliku grupe %2$s</string>
+    <string name="NotificationGroupAddMember">%1$s poziva %3$s u grupu %2$s</string>
+    <string name="NotificationGroupAddSelf">%1$s se vraća u grupu %2$s</string>
+    <string name="NotificationGroupKickMember">%1$s uklanja %3$s iz grupe %2$s</string>
+    <string name="NotificationGroupKickYou">%1$s te ukonio/la iz grupe %2$s</string>
+    <string name="NotificationGroupLeftMember">%1$s napušta grupu %2$s</string>
+    <string name="NotificationContactJoined">%1$s se pridružio/la Telegramu!</string>
+    <string name="NotificationUnrecognizedDevice">%1$s,\nOtkrili smo prijavu na vaš račun s novog uređaja - %2$s\n\nUređaj: %3$s\nLokacija: %4$s\n\nAko to niste vi, odabrate Postavke - Privatnost i sigurnost - Ugasi sve ostale sesije.\n\nHvala,\nTelegram tim</string>
+    <string name="NotificationContactNewPhoto">%1$s je obnovio/la profilnu sliku</string>
+    <string name="Reply">Odgovori</string>
+    <string name="ReplyToGroup">Odgovoriti grupi %1$s</string>
+    <string name="ReplyToUser">Odgovoriti kontaktu %1$s</string>
+    <string name="NotificationMessagesPeopleDisplayOrder">%1$s %2$s</string>
+    <!--contacts view-->
+    <string name="SelectContact">Odaberite kontakt</string>
+    <string name="NoContacts">Nijedan kontakt za sada</string>
+    <string name="InviteText">Hej, prebacimo se na Telegram: http://goo.gl/jnmjnZ</string>
+    <string name="TodayAt">u</string>
+    <string name="YesterdayAt">jučer u</string>
+    <string name="Online">na mreži</string>
+    <string name="LastSeen">zadnja posjeta</string>
+    <string name="LastSeenDate">zadnja posjeta</string>
+    <string name="InviteFriends">Pozovite prijatelje</string>
+    <string name="GlobalSearch">GLOBALNO PRETRAŽIVANJE</string>
+    <string name="Lately">zadnja posjeta nedavno</string>
+    <string name="WithinAWeek">zadnja posjeta unutar tjedan dana</string>
+    <string name="WithinAMonth">zadnja posjeta unutar mjesec dana</string>
+    <string name="ALongTimeAgo">zadnja posjeta veoma davno</string>
+    <string name="NewMessageTitle">Nova poruka</string>
+    <!--group create view-->
+    <string name="SendMessageTo">Pošaljite poruku...</string>
+    <string name="EnterGroupNamePlaceholder">Upišite naziv grupe</string>
+    <string name="GroupName">Naziv grupe</string>
+    <string name="MembersCount">%1$d/%2$d članova</string>
+    <!--group info view-->
+    <string name="SharedMedia">Dijeljene datoteke</string>
+    <string name="SETTINGS">Postavke</string>
+    <string name="AddMember">Dodajte člana</string>
+    <string name="DeleteAndExit">Brisanje i izlaz iz grupe</string>
+    <string name="Notifications">Obavijesti</string>
+    <string name="KickFromGroup">Ukloni iz grupe</string>
+    <!--contact info view-->
+    <string name="ShareContact">Dijeli</string>
+    <string name="AddContact">Dodaj</string>
+    <string name="AddContactTitle">Dodati kontakt</string>
+    <string name="BlockContact">Blokiraj</string>
+    <string name="EditContact">Uredi</string>
+    <string name="DeleteContact">Izbriši</string>
+    <string name="PhoneHome">Kuća</string>
+    <string name="PhoneMobile">Mobitel</string>
+    <string name="PhoneWork">Posao</string>
+    <string name="PhoneOther">Ostalo</string>
+    <string name="PhoneMain">Glavni</string>
+    <string name="StartEncryptedChat">Pokreni tajno dopisivanje</string>
+    <string name="CreateEncryptedChatError">Došlo je do greške.</string>
+    <string name="EncryptionKey">Enkripcijski ključ</string>
+    <string name="MessageLifetime">Odbrojavanje za samouništenje</string>
+    <string name="ShortMessageLifetimeForever">Isk.</string>
+    <string name="EncryptionKeyDescription">Ova slika je vizualizacija enkripcijskog ključa za tajno dopisivanje s kontaktom <![CDATA[<b>]]>%1$s<![CDATA[</b>]]>.<![CDATA[<br><br>]]>Ako ova slika izgleda jednako i na telefonu od kontakta <![CDATA[<b>]]>%2$s<![CDATA[</b>]]>, vaše dopisivanje je 200%% sigurno.<![CDATA[<br><br>]]>Vidi više na telegram.org</string>
+    <string name="NumberUnknown">Nepoznato</string>
+    <string name="Info">Info</string>
+    <string name="Phone">Telefonski broj</string>
+    <!--usernames-->
+    <string name="Username">Korisničko ime</string>
+    <string name="UsernamePlaceholder">Vaše korisničko ime</string>
+    <string name="UsernameInUse">Žao nam je, ovo korisničko ime je već zauzeto.</string>
+    <string name="UsernameInvalid">Žao nam je, ovo korisničko ime je nevažeće.</string>
+    <string name="UsernameInvalidShort">Korisničko ime mora imati barem 5 znakova.</string>
+    <string name="UsernameInvalidLong">Korisničko ime nesmije imati više od 32 znaka.</string>
+    <string name="UsernameInvalidStartNumber">Žao nam je, korisničko ime ne smije započimati s brojem.</string>
+    <string name="UsernameHelp">Odaberite svoje korisničko ime na <![CDATA[<b>]]>Telegramu<![CDATA[</b>]]>. Ako to učinite drugi ljudi će imati mogućnost pronaći vas preko odabranog korisničkog imena i kontaktirati vas bez da znaju vaš telefonski broj.<![CDATA[<br><br>]]>U imenu možete koristiti <![CDATA[<b>]]>a–z<![CDATA[</b>]]>, <![CDATA[<b>]]>0–9<![CDATA[</b>]]> i podcrte. Minimalna duljina je <![CDATA[<b>]]>5<![CDATA[</b>]]> znakova.</string>
+    <string name="UsernameChecking">Provjera korisničkog imena...</string>
+    <string name="UsernameAvailable">%1$s je dostupno.</string>
+    <string name="UsernameEmpty">Nije postavljeno</string>
+    <string name="ErrorOccurred">Došlo je do greške.</string>
+    <!--settings view-->
+    <string name="ResetNotificationsText">Postavi sve postavke obavijesti na početne vrijednosti</string>
+    <string name="TextSize">Veličina teksta poruke</string>
+    <string name="AskAQuestion">Postavi pitanje</string>
+    <string name="EnableAnimations">Omogući animacije</string>
+    <string name="Unblock">Odblokiraj</string>
+    <string name="UnblockText">Za odblokiranje dodirni i zadrži prst na nazivu korisnika.</string>
+    <string name="NoBlocked">Nema blokiranih korisnika</string>
+    <string name="MessageNotifications">Obavijesti poruka</string>
+    <string name="Alert">Obavijest</string>
+    <string name="MessagePreview">Pregled poruke</string>
+    <string name="GroupNotifications">Obavijesti grupe</string>
+    <string name="Sound">Zvuk</string>
+    <string name="InAppNotifications">Obavijesti kod pokrenute aplikacije</string>
+    <string name="InAppSounds">Zvuk</string>
+    <string name="InAppVibrate">Vibracija</string>
+    <string name="Vibrate">Vibracija</string>
+    <string name="InAppPreview">Pregled poruke</string>
+    <string name="Reset">Ponovno postavi</string>
+    <string name="ResetAllNotifications">Poništi sve obavijesti</string>
+    <string name="UndoAllCustom">Poništi sve prilagođene postavke obavijesti za sve kontakte i grupe</string>
+    <string name="NotificationsAndSounds">Obavijesti i zvukovi</string>
+    <string name="BlockedUsers">Blokirani korisnici</string>
+    <string name="LogOut">Odjavi se</string>
+    <string name="NoSound">Bez zvuka</string>
+    <string name="Default">Zadano</string>
+    <string name="Support">Podrška</string>
+    <string name="ChatBackground">Pozadina dopisivanja</string>
+    <string name="MessagesSettings">Poruke</string>
+    <string name="SendByEnter">Enter šalje poruku</string>
+    <string name="TerminateAllSessions">Ugasi sve ostale sesije</string>
+    <string name="Events">Događaji</string>
+    <string name="ContactJoined">Kontakt se pridružio Telegramu</string>
+    <string name="Pebble">PEBBLE</string>
+    <string name="Language">Jezik</string>
+    <string name="AskAQuestionInfo">Molimo da se obrati pozornost kako Telegram podršku daju dobrovoljci. Trudimo se odgovoriti što je brže moguće, ali ponekad može potrajati.<![CDATA[<br><br>]]>Pogledaj <![CDATA[<a href=\"http://telegram.org/faq#general\">često postavljana pitanja</a>]]>: tu su odgovori na većinu pitanja i važni savjeti za <![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">rješavanje problema</a>]]>.</string>
+    <string name="AskButton">Pitaj dobrovoljca</string>
+    <string name="TelegramFaq">Često postavljana pitanja</string>
+    <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+    <string name="DeleteLocalization">Izbrisati prijevod?</string>
+    <string name="IncorrectLocalization">Netočna datoteka s prijevodom</string>
+    <string name="Enabled">Omogućeno</string>
+    <string name="Disabled">Onemogućeno</string>
+    <string name="NotificationsService">Usluga obavijesti</string>
+    <string name="NotificationsServiceDisableInfo">Ako su usluge google play dovoljne za Vas da primate obavijesti, možete onemogućiti uslugu obavijesti. Ipak Vam preporučamo da ostavite omogućeno kako bi aplikacija bila pokrenuta u pozadini i istovremene primala obavijesti.</string>
+    <string name="SortBy">Sortiraj po</string>
+    <string name="ImportContacts">Uvezi kontakte</string>
+    <string name="SortFirstName">Ime</string>
+    <string name="SortLastName">Prezime</string>
+    <string name="LedColor">Boja LED</string>
+    <string name="PopupNotification">Popup obavijesti</string>
+    <string name="NoPopup">Bez popupa</string>
+    <string name="OnlyWhenScreenOn">Samo kad je ekran uključen</string>
+    <string name="OnlyWhenScreenOff">Samo kad je ekran isključen</string>
+    <string name="AlwaysShowPopup">Uvijek pokaži popup</string>
+    <string name="BadgeNumber">Značka s brojem</string>
+    <string name="Short">Kratko</string>
+    <string name="Long">Dugo</string>
+    <string name="SystemDefault">Osnovne sustavne postavke</string>
+    <string name="SettingsDefault">Osnovne postavke</string>
+    <string name="AutomaticMediaDownload">Automatsko preuzimanje medija</string>
+    <string name="WhenUsingMobileData">Pri korištenju podatkovne veze</string>
+    <string name="WhenConnectedOnWiFi">Kad ste spojeni na Wi-Fi</string>
+    <string name="WhenRoaming">U roamingu</string>
+    <string name="NoMediaAutoDownload">Bez medija</string>
+    <string name="SaveToGallerySettings">Spremi u galeriju</string>
+    <string name="EditName">Uredi ime</string>
+    <string name="NotificationsPriority">Prioritet</string>
+    <string name="NotificationsPriorityDefault">Zadano</string>
+    <string name="NotificationsPriorityLow">Nizak</string>
+    <string name="NotificationsPriorityHigh">Visok</string>
+    <string name="NotificationsPriorityMax">Maksimalan</string>
+    <string name="RepeatNotificationsNever">Nikad</string>
+    <string name="RepeatNotifications">Ponovi obavijesti</string>
+    <string name="PhoneNumberHelp">Ovdje možete promjeniti vaš Telegram broj. Vaš račun i svi vaši podaci u oblaku — poruke, mediji, kontakti itd. će biti premješteni na novi broj.\n\n<![CDATA[<b>Važno:</b>]]> svi vaši Telegram kontakti će dobiti vaš <![CDATA[<b>novi broj</b>]]> i bit će dodan njihovom imeniku, pod uvjetom da imaju vaš stari broj, a niste ih blokirali u Telegramu.</string>
+    <string name="PhoneNumberAlert">Svi vaši Telegram kontakti će dobiti vaš novi broj i bit će dodan njihovom imeniku, pod uvjetom da imaju vaš stari broj, a niste ih blokirali u Telegramu.</string>
+    <string name="PhoneNumberChange">PROMIJENI BROJ</string>
+    <string name="ChangePhoneNewNumber">Novi broj</string>
+    <string name="ChangePhoneHelp">Poslat ćemo vam SMS sa kodom za potvrdu na vaš novi broj.</string>
+    <string name="ChangePhoneNumberOccupied">Broj %1$s je već spojen s Telegram računom. Molimo vas obrišite postojeći račun prije selidbe na novi broj.</string>
+    <string name="NotificationsOther">Ostalo</string>
+    <string name="NotificationsDisabled">Onemogućeno</string>
+    <string name="VibrationDisabled">Onemogućeno</string>
+    <!--passcode view-->
+    <string name="Passcode">Šifra</string>
+    <string name="ChangePasscode">Promijeni šifru</string>
+    <string name="ChangePasscodeInfo">Kada podesite dodatnu šifru, ikona sa lokotom će se pojaviti na stranici sa dopisivanjima. Pritisnite je da bi otključali vašu Telegram aplikaciju.\n\nPodsjetnik: ako zaboravite šifru, morate obrisati i reinstalirati aplikaciju. Sva tajna dopisivanja biti će obrisana.</string>
+    <string name="ChangePasscodeAlert">Ikona s lokotom će se pojaviti na stranci sa dopisivanjima. Pritisnite je da bi zaključali Telegram sa novom šifrom.</string>
+    <string name="PasscodePIN">PIN</string>
+    <string name="PasscodePassword">Lozinka</string>
+    <string name="EnterCurrentPasscode">Unesite trenutnu šifru</string>
+    <string name="EnterNewPasscode">Unesite novu šifru</string>
+    <string name="EnterYourPasscode">Unesite vašu šifru</string>
+    <string name="ReEnterYourPasscode">Ponovno unesite novu šifru</string>
+    <string name="InvalidPasscode">Neispravna šifra</string>
+    <string name="PasscodeDoNotMatch">Šifra se ne poklapaju</string>
+    <string name="AutoLock">Automatsko zaključavanje</string>
+    <string name="AutoLockInfo">Zahtjevaj šifru ako sam odsutan.</string>
+    <string name="AutoLockInTime">za %1$s</string>
+    <string name="AutoLockDisabled">Onemogućeno</string>
+    <!--media view-->
+    <string name="NoMedia">Dijelite slike i video u ovom dopisivanju pa pristupite njima s bilo kojeg vašeg uređaja.</string>
+    <string name="DocumentsTitle">Datoteke</string>
+    <string name="SharedMediaTitle">Multimedija</string>
+    <string name="NoSharedFiles">Dijelite datoteke i dokumente u ovom dopisivanju pa pristupite njima s bilo kojeg vašeg uređaja.</string>
+    <!--map view-->
+    <string name="Map">Karta</string>
+    <string name="Satellite">Satelit</string>
+    <string name="Hybrid">Hibridni prikaz</string>
+    <string name="MetersAway">m udaljen</string>
+    <string name="KMetersAway">km udaljen</string>
+    <string name="SendLocation">Pošalji lokaciju</string>
+    <string name="ShareLocation">Dijeli lokaciju</string>
+    <!--photo gallery view-->
+    <string name="ShowAllMedia">Svi medijski zapisi</string>
+    <string name="SaveToGallery">Spremi u galeriju</string>
+    <string name="Of">%1$d od %2$d</string>
+    <string name="Gallery">Galerija</string>
+    <string name="AllPhotos">Sve slike</string>
+    <string name="NoPhotos">Još nema slika</string>
+    <string name="PleaseDownload">Molimo te prvo preuzmi medijsku datoteku</string>
+    <string name="NoRecentPhotos">Nema nedavnih slika</string>
+    <string name="NoRecentGIFs">Nema nedavnih GIFova</string>
+    <string name="SearchImages">PRETRAŽI SLIKE</string>
+    <string name="SearchImagesInfo">PRETRAŽI INTERNET</string>
+    <string name="SearchGifs">PRETRAŽI GIFove</string>
+    <string name="SearchImagesTitle">Pretraži internet</string>
+    <string name="SearchGifsTitle">Pretraži GIFove</string>
+    <string name="CropImage">Izreži sliku</string>
+    <string name="EditImage">Uredi sliku</string>
+    <string name="Enhance">Poboljšaj</string>
+    <string name="Highlights">Osvjetljenje</string>
+    <string name="Contrast">Kontras</string>
+    <string name="Exposure">Ekspozicija</string>
+    <string name="Warmth">Toplina</string>
+    <string name="Saturation">Zasićenje</string>
+    <string name="Vignette">Vinjeta</string>
+    <string name="Shadows">Sjene</string>
+    <string name="Grain">Zrnato</string>
+    <string name="Sharpen">Oštrina</string>
+    <string name="Blur">Zamutiti</string>
+    <string name="AreYouSureDeletePhoto">Jeste li sigurni da želite obrisat ovu sliku?</string>
+    <string name="AreYouSureDeleteVideo">Jeste li sigurni da želite obrisat ovaj video?</string>
+    <string name="DiscardChanges">Odbaciti izmjene?</string>
+    <!--privacy settings-->
+    <string name="PrivacySettings">Privatnost i sigurnost</string>
+    <string name="PrivacyTitle">Privatnost</string>
+    <string name="PrivacyLastSeen">Zadnja posjeta</string>
+    <string name="LastSeenEverybody">Svi</string>
+    <string name="LastSeenContacts">Moji kontakti</string>
+    <string name="LastSeenNobody">Nitko</string>
+    <string name="LastSeenEverybodyMinus">Svi (-%1$d)</string>
+    <string name="LastSeenContactsPlus">Moji kontakti (+%1$d)</string>
+    <string name="LastSeenContactsMinus">Moji kontakti (-%1$d)</string>
+    <string name="LastSeenContactsMinusPlus">Moji kontakti (-%1$d, +%2$d)</string>
+    <string name="LastSeenNobodyPlus">Nitko (+%1$d)</string>
+    <string name="SecurityTitle">Sigurnost</string>
+    <string name="DeleteAccountTitle">Samouništenje korisničkog računa</string>
+    <string name="DeleteAccountIfAwayFor">Ako sam odsutan</string>
+    <string name="DeleteAccountHelp">Ako se ne prijavite barem jednom u ovom periodu vaš korisniči račun će biti obrisan skupa sa svim grupama, porukama i kontaktima.</string>
+    <string name="DeleteAccountNowConfirmation">Izbrisati korisnički račun?</string>
+    <string name="LastSeenHelp">Promijenite tko može vidjeti vaše vrijeme zadnjeg posjeta.</string>
+    <string name="LastSeenTitle">Tko može vidjeti vaše vrijeme zadnjeg posjeta?</string>
+    <string name="AddExceptions">Dodaj iznimke</string>
+    <string name="CustomHelp">Važno: nećete moći vidjeti Vrijeme zadnjeg posjeta za ljude s kojima ne dijelit vaše Vrijeme zadnjeg posjeta. Umjesto toga bit će prikazano približno vrijeme zadnjeg posjeta (nedavno, unutar tjedan dana, unutar mjesec dana).</string>
+    <string name="AlwaysShareWith">Uvijek dijeli sa</string>
+    <string name="NeverShareWith">Nikad ne dijeli sa</string>
+    <string name="CustomShareSettingsHelp">Ove postavke će nadglasati gornje vrijednosti.</string>
+    <string name="AlwaysShareWithTitle">Uvijek dijeli</string>
+    <string name="AlwaysShareWithPlaceholder">Uvijek dijeli sa korisnicima...</string>
+    <string name="NeverShareWithTitle">Nikad ne dijeli</string>
+    <string name="NeverShareWithPlaceholder">Nikad ne dijeli sa korisnicima...</string>
+    <string name="EmpryUsersPlaceholder">Dodaj korisnike</string>
+    <string name="PrivacyFloodControlError">Žao nam je, previše zahtjeva. Nismo u mogućnosti sada promijeniti vaše postavke, molimo vas pričekajte.</string>
+    <string name="ClearOtherSessionsHelp">Odjavi sve uređaje osim ovoga.</string>
+    <string name="RemoveFromListText">Dodirni i zadrži prst na korisniku za brisanje.</string>
+    <!--edit video view-->
+    <string name="EditVideo">Uredi video</string>
+    <string name="OriginalVideo">Originalni video</string>
+    <string name="EditedVideo">Uređeni video</string>
+    <string name="SendingVideo">Šaljem video...</string>
+    <string name="CompressVideo">Kompresiraj video</string>
+    <!--button titles-->
+    <string name="Next">Sljedeće</string>
+    <string name="Back">Natrag</string>
+    <string name="Done">Gotovo</string>
+    <string name="Open">Otvori</string>
+    <string name="Cancel">Odustani</string>
+    <string name="Add">Dodaj</string>
+    <string name="Edit">Uredi</string>
+    <string name="Send">Šalji</string>
+    <string name="Call">Zovi</string>
+    <string name="Copy">Kopiraj</string>
+    <string name="Delete">Izbriši</string>
+    <string name="Forward">Proslijedi</string>
+    <string name="Retry">Pokušaj ponovo</string>
+    <string name="FromCamera">Uslikaj</string>
+    <string name="FromGalley">Iz galerije</string>
+    <string name="DeletePhoto">Izbriši sliku</string>
+    <string name="Set">Postavi</string>
+    <string name="OK">U redu</string>
+    <string name="Crop">IZREŽI</string>
+    <!--messages-->
+    <string name="ActionKickUser">un1 je uklonio un2</string>
+    <string name="ActionLeftUser">un1 je napustio grupu</string>
+    <string name="ActionAddUser">un1 je dodao un2</string>
+    <string name="ActionRemovedPhoto">un1 je uklonio sliku grupe</string>
+    <string name="ActionChangedPhoto">un1 je promijenio sliku grupe</string>
+    <string name="ActionChangedTitle">un1 je promijenio naziv grupe u un2</string>
+    <string name="ActionCreateGroup">un1 je napravio grupu</string>
+    <string name="ActionYouKickUser">Uklonio si un2</string>
+    <string name="ActionYouLeftUser">Napostio si grupu</string>
+    <string name="ActionYouAddUser">Dodao si un2</string>
+    <string name="ActionYouRemovedPhoto">Uklonio si sliku grupe</string>
+    <string name="ActionYouChangedPhoto">Promijenio si sliku grupe</string>
+    <string name="ActionYouChangedTitle">Promijenio si naziv grupe u un2</string>
+    <string name="ActionYouCreateGroup">Napravio si grupu</string>
+    <string name="ActionKickUserYou">un1 te uklonio</string>
+    <string name="ActionAddUserYou">un1 te dodao</string>
+    <string name="ActionAddUserSelf">un1 se vratio grupi</string>
+  <string name="UnsuppotedMedia">Tvoja verzija Telegrama ne podržava ovu poruku. Obnovi aplikaciju za nastavak:
+http://telegram.org/update</string>
+    <string name="AttachPhoto">Slika</string>
+    <string name="AttachVideo">Videozapis</string>
+    <string name="AttachLocation">Lokacija</string>
+    <string name="AttachContact">Kontakt</string>
+    <string name="AttachDocument">Datoteka</string>
+    <string name="AttachSticker">Naljepnica</string>
+    <string name="AttachAudio">Zvučni zapis</string>
+    <string name="FromYou">Ti</string>
+    <string name="ActionTakeScreenshootYou">Napravili ste snimku zaslona!</string>
+    <string name="ActionTakeScreenshoot">un1 je napravio/la snimku zaslona!</string>
+    <!--Alert messages-->
+    <string name="InvalidPhoneNumber">Neispravni telefonski broj</string>
+    <string name="CodeExpired">Kod je istekao, ponovo se ulogiraj</string>
+    <string name="FloodWait">Previše pokušaja, probajte ponovo kasnije</string>
+    <string name="InvalidCode">Neispravan kod</string>
+    <string name="InvalidFirstName">Neispravno ime</string>
+    <string name="InvalidLastName">Neispravno prezime</string>
+    <string name="Loading">Učitavanje...</string>
+    <string name="NoPlayerInstalled">Nemaš video player, instaliraj neki za nastavak</string>
+    <string name="NoMailInstalled">Molimo Vas, pošaljite mail na sms@telegram.org i objasnite Vaš problem.</string>
+    <string name="NoHandleAppInstalled">Nemaš aplikaciju zaduženu za tip datoteke \'%1$s\', instaliraj neku za nastavak</string>
+    <string name="InviteUser">Ovaj korisnik još nema Telegram, poslati pozivnicu?</string>
+    <string name="AreYouSure">Sigurno?</string>
+    <string name="AddToTheGroup">Dodati %1$s u grupu?\n\nBroj poruka za proslijediti: </string>
+    <string name="ForwardMessagesTo">Proslijediti kontaktu %1$s?</string>
+    <string name="SendMessagesTo">Poslati poruke za %1$s?</string>
+    <string name="AreYouSureLogout">Jeste li ste sigurni da se želite odjaviti?\n\nNapominjemo da Telegram možete koristiti neprimjetno na svim vašim uređajima odjednom.\n\nUpamtite, odjavljivanjem brišete sva vaša Tajna dopisivanja.</string>
+    <string name="AreYouSureSessions">Jeste li sigurni da želite ugasiti sve ostale sesije?</string>
+    <string name="AreYouSureDeleteAndExit">Jeste li sigurni da želite obrisat i napustiti grupu?</string>
+    <string name="AreYouSureDeleteThisChat">Jeste li sigurni da želite obrisat ovo dopisivanje?</string>
+    <string name="AreYouSureShareMyContactInfo">Jeste li sigurni da želite podijeliti vaš telefonski broj s odabranim kontaktom?</string>
+    <string name="AreYouSureBlockContact">Jeste li sigurni da želite blokirati ovaj kontakt?</string>
+    <string name="AreYouSureUnblockContact">Jeste li sigurni da želite odblokirati ovaj kontakt?</string>
+    <string name="AreYouSureDeleteContact">Jeste li sigurni da želite obrisat ovaj kontakt?</string>
+    <string name="AreYouSureSecretChat">Jeste li sigurni da želite pokrenuti tajno dopisivanje?</string>
+    <string name="AreYouSureRegistration">Jeste li sigurni da želite obustaviti registraciju?</string>
+    <string name="AreYouSureClearHistory">Jeste li sigurni da želite obrisat povijest?</string>
+    <string name="AreYouSureDeleteMessages">Jeste li sigurni da želite obrisat %1$s?</string>
+    <string name="SendMessagesToGroup">Poslati poruke za %1$s?</string>
+    <string name="ForwardMessagesToGroup">Proslijediti grupi %1$s?</string>
+    <string name="FeatureUnavailable">Žao nam je, ova opcija trenutno nije dostupna u vašoj državi.</string>
+    <!--Intro view-->
+    <string name="Page1Title">Plus Messenger</string>
+    <string name="Page2Title">Brzo</string>
+    <string name="Page3Title">Besplatno</string>
+    <string name="Page4Title">Sigurno</string>
+    <string name="Page5Title">Moćno</string>
+    <string name="Page6Title">U oblaku</string>
+    <string name="Page7Title">Privatno</string>
+    <string name="Page1Message"><![CDATA[<b>Najbrža</b>]]> aplikacija za dopisivanje.<![CDATA[<br/><b>Besplatna</b>]]> i <![CDATA[<b>sigurna</b>]]>.</string>
+    <string name="Page2Message"><![CDATA[<b>Plus Messenger</b>]]> dostavlja poruke brže<![CDATA[<br/>]]>nego bilo koja druga aplikacija.</string>
+    <string name="Page3Message"><![CDATA[<b>Plus Messenger</b>]]> će zauvijek biti besplatan.<![CDATA[<br/>]]>Bez oglasa. Bez pretplate.</string>
+    <string name="Page4Message"><![CDATA[<b>Plus Messenger</b>]]> čuva vaše poruke<![CDATA[<br/>]]>od hakerskih napada.</string>
+    <string name="Page5Message"><![CDATA[<b>Plus Messenger</b>]]> nema ograničenje za veličinu<![CDATA[<br/>]]>medijskih datoteka i dopisivanja.</string>
+    <string name="Page6Message"><![CDATA[<b>Plus Messenger</b>]]> vam omogućuje pristup<![CDATA[<br/>]]>porukama s više uređaja.</string>
+    <string name="Page7Message"><![CDATA[<b>Plus Messenger</b>]]> poruke su snažno enkriptirane<![CDATA[<br/>]]>i mogu se same uništiti.</string>
+    <string name="StartMessaging">Počni dopisivanje</string>
+    <!--plural-->
+    <string name="Online_zero">%1$d osoba na mreži</string>
+    <string name="Online_one">%1$d osoba na mreži</string>
+    <string name="Online_two">%1$d osobe na mreži</string>
+    <string name="Online_few">%1$d osobe na mreži</string>
+    <string name="Online_many">%1$d osoba na mreži</string>
+    <string name="Online_other">%1$d osoba na mreži</string>
+    <string name="Members_zero">Nema članova.</string>
+    <string name="Members_one">%1$d član</string>
+    <string name="Members_two">%1$d člana</string>
+    <string name="Members_few">%1$d člana</string>
+    <string name="Members_many">%1$d članova</string>
+    <string name="Members_other">%1$d članova</string>
+    <string name="AndMoreTyping_zero">i još %1$d osoba piše</string>
+    <string name="AndMoreTyping_one">i još %1$d osoba piše</string>
+    <string name="AndMoreTyping_two">i još %1$d osobe pišu</string>
+    <string name="AndMoreTyping_few">i još %1$d osobe pišu</string>
+    <string name="AndMoreTyping_many">i još %1$d osoba piše</string>
+    <string name="AndMoreTyping_other">i još %1$d osoba piše</string>
+    <string name="NewMessages_zero">Nema novih poruka</string>
+    <string name="NewMessages_one">%1$d nova poruka</string>
+    <string name="NewMessages_two">%1$d nove poruke</string>
+    <string name="NewMessages_few">%1$d nove poruke</string>
+    <string name="NewMessages_many">%1$d novih poruka</string>
+    <string name="NewMessages_other">%1$d novih poruka</string>
+    <string name="messages_zero">Nema poruka</string>
+    <string name="messages_one">%1$d poruku</string>
+    <string name="messages_two">%1$d poruke</string>
+    <string name="messages_few">%1$d poruke</string>
+    <string name="messages_many">%1$d poruka</string>
+    <string name="messages_other">%1$d poruka</string>
+    <string name="items_zero">nema predmeta</string>
+    <string name="items_one">%1$d predmet</string>
+    <string name="items_two">%1$d predmeta</string>
+    <string name="items_few">%1$d predmeta</string>
+    <string name="items_many">%1$d predmeta</string>
+    <string name="items_other">%1$d predmeta</string>
+    <string name="FromChats_zero">nije iz dopisivanja</string>
+    <string name="FromChats_one">iz %1$d dopisivanja</string>
+    <string name="FromChats_two">iz %1$d dopisivanja</string>
+    <string name="FromChats_few">iz %1$d dopisivanja</string>
+    <string name="FromChats_many">iz %1$d dopisivanja</string>
+    <string name="FromChats_other">iz %1$d dopisivanja</string>
+    <string name="Seconds_zero">%1$d sekundi</string>
+    <string name="Seconds_one">%1$d sekunda</string>
+    <string name="Seconds_two">%1$d sekunde</string>
+    <string name="Seconds_few">%1$d sekunde</string>
+    <string name="Seconds_many">%1$d sekundi</string>
+    <string name="Seconds_other">%1$d sekundi</string>
+    <string name="Minutes_zero">%1$d minuta</string>
+    <string name="Minutes_one">%1$d minutu</string>
+    <string name="Minutes_two">%1$d minute</string>
+    <string name="Minutes_few">%1$d minute</string>
+    <string name="Minutes_many">%1$d minuta</string>
+    <string name="Minutes_other">%1$d minuta</string>
+    <string name="Hours_zero">%1$d sati</string>
+    <string name="Hours_one">%1$d sat</string>
+    <string name="Hours_two">%1$d sata</string>
+    <string name="Hours_few">%1$d sata</string>
+    <string name="Hours_many">%1$d sati</string>
+    <string name="Hours_other">%1$d sati</string>
+    <string name="Days_zero">%1$d dana</string>
+    <string name="Days_one">%1$d dan</string>
+    <string name="Days_two">%1$d dana</string>
+    <string name="Days_few">%1$d dana</string>
+    <string name="Days_many">%1$d dani</string>
+    <string name="Days_other">%1$d dani</string>
+    <string name="Weeks_zero">%1$d tjedana</string>
+    <string name="Weeks_one">%1$d tjedan</string>
+    <string name="Weeks_two">%1$d tjedna</string>
+    <string name="Weeks_few">%1$d tjedna</string>
+    <string name="Weeks_many">%1$d tjedana</string>
+    <string name="Weeks_other">%1$d tjedana</string>
+    <string name="Months_zero">%1$d mjeseci</string>
+    <string name="Months_one">%1$d mjesec</string>
+    <string name="Months_two">%1$d mjeseca</string>
+    <string name="Months_few">%1$d mjeseca</string>
+    <string name="Months_many">%1$d mjeseci</string>
+    <string name="Months_other">%1$d mjeseci</string>
+    <string name="Years_zero">%1$d godina</string>
+    <string name="Years_one">%1$d godina</string>
+    <string name="Years_two">%1$d godine</string>
+    <string name="Years_few">%1$d godine</string>
+    <string name="Years_many">%1$d godina</string>
+    <string name="Years_other">%1$d godina</string>
+    <string name="Users_zero">%1$d korisnika</string>
+    <string name="Users_one">%1$d korisnik</string>
+    <string name="Users_two">%1$d korisnika</string>
+    <string name="Users_few">%1$d korisnika</string>
+    <string name="Users_many">%1$d korisnika</string>
+    <string name="Users_other">%1$d korisnika</string>
+    <!--date formatters-->
+    <string name="formatterMonthYear">MMM yyyy</string>
+    <string name="formatterMonth">dd.MM.yyy</string>
+    <string name="formatterYear">dd.MM.yy</string>
+    <string name="formatterYearMax">dd.MM.yyyy</string>
+    <string name="chatDate">d. MMMM</string>
+    <string name="chatFullDate">d. MMMM yyyy.</string>
+    <string name="formatterWeek">EEE</string>
+    <string name="formatterDay24H">HH:mm</string>
+    <string name="formatterDay12H">h:mm a</string>
+    <string name="formatDateAtTime">%1$s u %2$s</string>
+    <!--Telegram+ Croatian-->
+    <!--Smart Notifications-->
+    <string name="SmartNotification">Pametne obavijesti</string>
+    <string name="TimeUnitSeconds">sekunda(e)</string>
+    <string name="TimeUnitMinutes">minuta(e)</string>
+    <string name="TimeUnitHours">sat(i)</string>
+    <string name="TimeUnitDays">dan(a)</string>
+    <string name="settings_smart_notify_begin">Zasviraj najviše</string>
+    <string name="settings_smart_notify_mid1">puta</string>
+    <string name="settings_smart_notify_mid11">put</string>
+    <string name="settings_smart_notify_mid2">tijekom</string>
+    <!---->
+  <string name="TelegramForAndroid">Plus Messenger za Android</string>
+  <string name="Theming">Izrada teme</string>
+  <string name="colorHexInvalid">Neispravan hex kod za boju!</string>
+  <string name="themeColor">Boja teme</string>
+  <string name="ResetThemeSettings">Ponovno postaviti postavke teme</string>
+  <string name="ResetThemeSettingsSum">Poništitava sve postavke teme</string>
+  <string name="ResetThemeToastText">Postavke teme postavljene na osnovne vrijednosti!</string>
+  <string name="General">Općenito</string>
+  <string name="Screens">Zasloni</string>
+  <string name="MainScreen">Glavni zaslon</string>
+  <string name="ChatScreen">Zaslon dopisivanja</string>
+  <string name="ContactsScreen">Zaslon kontakata</string>
+  <string name="Header">Zaglavlje</string>
+  <string name="Rows">Redci</string>
+  <string name="ChatList">Lista dopisivanja</string>
+  <string name="ChatsList">Liste dopisivanja</string>
+  <string name="ContactsList">Liste kontakata</string>
+  <string name="HeaderColor">Boja zaglavlja</string>
+  <string name="NameColor">Boja imena</string>
+  <string name="NameSize">Veličina imena</string>
+  <string name="MessageColor">Boja poruke</string>
+  <string name="MessageSize">Veličina poruke</string>
+  <string name="TimeDateColor">Boja vremena/datuma</string>
+  <string name="TimeDateSize">Veličina vremena/datuma</string>
+  <string name="CountColor">Boja brojača</string>
+  <string name="CountSize">Veličina brojača</string>
+  <string name="RowColor">Boja redaka</string>
+  <string name="CountBGColor">Boja pozadine brojača</string>
+  <string name="StatusColor">Boja statusa</string>
+  <string name="StatusSize">Veličina statusa</string>
+  <string name="RBubbleColor">Boja desnog oblaka</string>
+  <string name="LBubbleColor">Boja lijevog oblaka</string>
+  <string name="DateColor">Boja datuma</string>
+  <string name="DateSize">Veličina datuma</string>
+  <string name="DateBubbleColor">Boja datuma oblaka</string>
+  <string name="RTextColor">Boja desnog teksta</string>
+  <string name="LTextColor">Boja lijevog teksta</string>
+  <string name="RTimeColor">Boja desnog vremena</string>
+  <string name="LTimeColor">Boja lijevog vremena</string>
+  <string name="TimeSize">Veličina vremena</string>
+  <string name="EditTextColor">Boja teksta tipkanja</string>
+  <string name="EditTextSize">Veličina teksta tipkanja</string>
+  <string name="EditTextBGColor">Boja pozadine teksta tipkanja</string>
+  <string name="EmojiViewBGColor">Boja pozadine emoji</string>
+  <string name="EmojiViewTabColor">Boja emoji tab</string>
+  <string name="OnlineColor">Boja status na mreži</string>
+  <string name="ChatMusic">Glazba</string>
+  <string name="SaveTheme">Spremi temu</string>
+  <string name="SaveThemeSum">Spremi svoju temu u Telegram/Themes folder</string>
+  <string name="SaveThemeToastText">Tema spremljena!</string>
+  <string name="SavedTo">%1$s spremljeno u %2$s</string>
+  <string name="SaveErrorMsg0">Tema još nije napravljena. Molimo vas prvo primijenite bilo koji MOD</string>
+  <string name="restoreOkMsg">Postavke vraćene sa SD kartice</string>
+  <string name="restoreErrorMsg">Postavke nisu pronađene u %s</string>
+  <string name="NoMediaMessage">SD kartica nije pronađena.</string>
+  <string name="EnterName">Unesite ime</string>
+  <string name="Themes">Teme</string>
+  <string name="ApplyTheme">Primjeni temu</string>
+  <string name="ApplyThemeSum">Primjeni xml temu iz lokalne mape</string>
+  <string name="MemberColor">Boja člana</string>
+  <string name="ChecksColor">Boja kvačica</string>
+  <string name="MuteColor">Boja isključivanja obavijesti</string>
+  <string name="SendLogs">Pošalji log-ove</string>
+  <string name="SendLogsEmpty">Nema log-ova</string>
+  <string name="SendIcon">Pošalji ikonu</string>
+  <string name="HideMobile">Sakrij broj mobitela iz izbornika</string>
+  <string name="FloatingPencilColor">Boja olovke u krugu</string>
+  <string name="FloatingBGColor">Boja pozadine kruga</string>
+  <string name="Community">G+ zajednica</string>
+  <string name="TypingColor">Boja statusa piše</string>
+  <string name="EditTextIconsColor">Boja ikoni pokraj teksta tipkanja</string>
+  <string name="NavigationDrawer">Glavni izbornik</string>
+  <string name="OptionsList">Opcije liste</string>
+  <string name="ListColor">Boja liste</string>
+  <string name="OwnNameSize">Ime liste</string>
+  <string name="PhoneColor">Boja telefona</string>
+  <string name="PhoneSize">Veličina telefona</string>
+  <string name="AvatarColor">Boja avatara</string>
+  <string name="IconColor">Boja ikone za postavke</string>
+  <string name="OptionColor">Boja postavki</string>
+  <string name="OptionSize">Veličina postavki</string>
+  <string name="VersionColor">Boja verzije</string>
+  <string name="VersionSize">Veličina verzije</string>
+  <string name="HeaderTitleColor">Boja naslova u zaglavlju</string>
+  <string name="HeaderIconsColor">Boja ikoni u zaglavlju</string>
+  <string name="DividerColor">Boja crte razdjeljivanja</string>
+  <string name="AvatarRadius">Radijus avatara</string>
+  <string name="SetMemberColor">Postavite boju člana</string>
+  <string name="ForwardNameColor">Proslijedite ime boje</string>
+  <string name="HeaderTitle">Naslov u zaglavlju</string>
+  <string name="ForwardNoQuote">Proslijedi bez citiranja</string>
+  <string name="DisableMessageClick">Onemogući popup pritiskom</string>
+  <string name="ProfileScreen">Zaslon profila grupe/kontakta</string>
+  <string name="HideBackground">Sakriti odabranu pozdanu</string>
+    <string name="RLinkColor">Boja desnog linka</string>
+    <string name="LLinkColor">Boja lijevog linka</string>
+  <string name="ThemeApplied">Tema primijenjena!</string>
+  <string name="ClickOkToRestart">Pritisnite \"U redu\" za resetirati aplikaciju</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-ms/strings.xml b/TMessagesProj/src/main/res/values-ms/strings.xml
new file mode 100644
index 000000000..a67ebc1c4
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-ms/strings.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="auth_client_needs_enabling_title">Perkhidmatan Google Play perlu didayakan untuk menggunakan aplikasi.</string>
+    <string name="auth_client_needs_installation_title">Perkhidmatan Google Play perlu dipasang untuk mengguankan aplikasi.</string>
+    <string name="auth_client_needs_update_title">Perkhidmatan Google Play perlu dikemas kini untuk menggunakan aplikasi.</string>
+    <string name="auth_client_play_services_err_notification_msg">Ralat perkhidmatan Google Play</string>
+    <string name="auth_client_requested_by_msg">Diminta oleh %1$s</string>
+    <string name="auth_client_using_bad_version_title">Aplikasi cuba menggunakan versi Perkhidmatan Google Play yang rosak.</string>
+    <string name="common_google_play_services_enable_button">Dayakan perkhidmatan Google Play</string>
+    <string name="common_google_play_services_enable_text">Apl ini tidak akan berfungsi kecuali anda mendayakan perkhidmatan Google Play.</string>
+    <string name="common_google_play_services_enable_title">Dayakan perkhidmatan Google Play</string>
+    <string name="common_google_play_services_install_button">Dapatkan perkhidmatan Google Play</string>
+    <string name="common_google_play_services_install_text_phone">Apl ini tidak akan berfungsi tanpa perkhidmatan Google Play dan apl ini tiada pada telefon anda.</string>
+    <string name="common_google_play_services_install_text_tablet">Apl ini tidak akan berfungsi tanpa perkhidmatan Google Play dan apl ini tiada pada tablet anda.</string>
+    <string name="common_google_play_services_install_title">Dapatkan perkhidmatan Google Play</string>
+    <string name="common_google_play_services_invalid_account_text">Akaun yang dinyatakan tidak wujud pada peranti ini. Sila pilih akaun yang lain.</string>
+    <string name="common_google_play_services_invalid_account_title">Akaun Tidak Sah</string>
+    <string name="common_google_play_services_network_error_text">Sambungan data diperlukan untuk menyambung ke perkhidmatan Google Play.</string>
+    <string name="common_google_play_services_network_error_title">Ralat Rangkaian</string>
+    <string name="common_google_play_services_unknown_issue">Isu tidak diketahui dengan perkhidmatan Google Play.</string>
+    <string name="common_google_play_services_unsupported_text">Peranti anda tidak menyokong perkhidmatan Google Play, sedangkan sesetengah aplikasi anda memerlukannya. Sila hubungi pengilang untuk bantuan.</string>
+    <string name="common_google_play_services_unsupported_title">Perkhidmatan Google Play</string>
+    <string name="common_google_play_services_update_button">Kemas kini</string>
+    <string name="common_google_play_services_update_text">Apl ini tidak akan berfungsi kecuali anda mengemas kini perkhidmatan Google Play.</string>
+    <string name="common_google_play_services_update_title">Kemas kini perkhidmatan Google Play</string>
+    <string name="common_signin_button_text">Log masuk</string>
+    <string name="common_signin_button_text_long">Log masuk dengan Google</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-pl/strings.xml b/TMessagesProj/src/main/res/values-pl/strings.xml
new file mode 100644
index 000000000..79b073a7d
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-pl/strings.xml
@@ -0,0 +1,704 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="AppName">Plus Messenger</string>
+    <string name="LanguageName">Polski</string>
+    <string name="LanguageNameInEnglish">Polish</string>
+    <string name="LanguageCode">pl</string>
+    <!--signin view-->
+    <string name="YourPhone">Twój numer</string>
+    <string name="StartText">Proszę potwierdzić kodu kraju i podać swój numer telefonu</string>
+    <string name="ChooseCountry">Wybierz kraj</string>
+    <string name="WrongCountry">Nieprawidłowy numer kierunkowy kraju</string>
+    <!--code enter view-->
+    <string name="YourCode">Twój kod</string>
+    <string name="SentSmsCode">Wysłaliśmy do Ciebie wiadomość z kodem aktywacyjnym</string>
+    <string name="CallText">Zadzwonimy do Ciebie za %1$d:%2$02d</string>
+    <string name="Calling">Dzwonimy...</string>
+    <string name="Code">Kod</string>
+    <string name="WrongNumber">Nieprawidłowy numer?</string>
+    <string name="DidNotGetTheCode">Nie otrzymałeś kodu?</string>
+    <!--signup view-->
+    <string name="YourName">Imię</string>
+    <string name="RegisterText">Wpisz imię i nazwisko</string>
+    <!--<string name="RegisterText">Set up your name and picture</string>-->
+    <string name="FirstName">Imię (wymagane)</string>
+    <string name="LastName"> Nazwisko (opcjonalnie)</string>
+    <string name="CancelRegistration">Anuluj rejestracje</string>
+    <!--chats view-->
+    <string name="Settings">Ustawienia</string>
+    <string name="Contacts">Kontakty</string>
+    <string name="NewGroup">Nowa grupa</string>
+    <string name="Yesterday">wczoraj</string>
+    <string name="NoResult">Brak wyników</string>
+    <string name="NoChats">Brak rozmów...</string>
+    <string name="NoChatsHelp">Zacznij pisać naciskając \nw prawym dolnym rogu\nNowa wiadomość \nalbo naciskając menu aby wyświetlić więcej opcji.</string>
+    <string name="WaitingForNetwork">Oczekiwanie na połączenie...</string>
+    <string name="Connecting">Łączenie...</string>
+    <string name="Updating">Aktualizuje...</string>
+    <string name="NewSecretChat">Nowa sekretna rozmowa</string>
+    <string name="AwaitingEncryption">Oczekiwanie na %s </string>
+    <string name="EncryptionRejected">Sekretna rozmowa anulowana</string>
+    <string name="EncryptionProcessing">Pobieram klucze szyfrowania...</string>
+    <string name="EncryptedChatStartedOutgoing">%s dołączył/a do tajnej rozmowy</string>
+    <string name="EncryptedChatStartedIncoming">Dołączyłeś do tajnej rozmowy</string>
+    <string name="ClearHistory">Wyczyść historię</string>
+    <string name="DeleteChat">Usuń i wyjdź</string>
+    <string name="DeleteChatUser">Skasuj rozmowę</string>
+    <string name="HiddenName">Skasowane konto</string>
+    <string name="SelectChat">Wybierz rozmowe</string>
+    <string name="PhotoTip">Naciśnij i przytrzymaj, aby zobaczyć</string>
+    <string name="CompatibilityChat">%1$s używa starszej wersji komunikatora, tajne zdjęcia będą przekazywane w trybie zgodności. .\n\nOnce %2$s uaktualni Telegram, zdjęcia z czasem 1 minuty lub mniej pozwolą na włączenie opcji \"Naciśnij i przytrzymaj, aby zobaczyć\" i będziesz powiadomiony jeśli ktoś zrobi zrzut ekranu.</string>
+    <string name="SearchMessages">WIADOMOŚCI</string>
+    <string name="Search">Szukaj</string>
+    <string name="MuteNotifications">Wycisz powiadomienia</string>
+    <string name="MuteFor">Wycisz na %1$s</string>
+    <string name="UnmuteNotifications">Włącz dźwięki</string>
+    <string name="WillUnmuteIn">W %1$s</string>
+    <string name="MuteDisable">Wyłącz</string>
+    <!--broadcasts-->
+    <string name="NewBroadcastList">Nowe ogłoszenie</string>
+    <string name="EnterListName">Wprowadź nazwę listy</string>
+    <string name="YouCreatedBroadcastList">Utworzyłeś listę transmisji</string>
+    <string name="AddRecipient">Dodaj odbiorcę</string>
+    <string name="KickFromBroadcast">Usuń z listy transmisji</string>
+    <!--documents view-->
+    <string name="SelectFile">Wybierz plik</string>
+    <string name="FreeOfTotal">Wolne %1$s z %2$s</string>
+    <string name="UnknownError">Nieznany błąd</string>
+    <string name="AccessError">Błąd dostępu</string>
+    <string name="NoFiles">Brak plików...</string>
+    <string name="FileUploadLimit">Plik nie może być większy niż %1$s</string>
+    <string name="NotMounted">Pamięć nie zainstalowana</string>
+    <string name="UsbActive">Transfer USB aktywny</string>
+    <string name="InternalStorage">Pamięć wewnętrzna</string>
+    <string name="ExternalStorage">Pamięć zewnętrzna</string>
+    <string name="SystemRoot">Główny system plików</string>
+    <string name="SdCard">Karta SD</string>
+    <string name="Folder">Katalog</string>
+    <string name="GalleryInfo">Wyślij zdjęcia bez kompresji</string>
+    <!--chat view-->
+    <string name="Invisible">niewidoczny</string>
+    <string name="Typing">pisze...</string>
+    <string name="IsTyping">pisze...</string>
+    <string name="AreTyping">piszą...</string>
+    <string name="GotAQuestion">Masz pytania/sugestie odnoście Telegram?</string>
+    <string name="ChatTakePhoto">Zrób zdjęcie</string>
+    <string name="ChatGallery">Galeria</string>
+    <string name="ChatLocation">Lokalizacja</string>
+    <string name="ChatVideo">Wideo</string>
+    <string name="ChatDocument">Plik</string>
+    <string name="NoMessages">Brak wiadomości...</string>
+    <string name="ForwardedMessage">Przekazana wiadomość</string>
+    <string name="From">Od</string>
+    <string name="NoRecent">Brak ostatnich</string>
+    <string name="Message">Wiadomość</string>
+    <string name="TypeMessage">Wiadomość</string>
+    <string name="ShareMyContactInfo">Udostępnij kontakt</string>
+    <string name="AddToContacts">Dodaj kontakt</string>
+    <string name="EncryptedPlaceholderTitleIncoming">%s zaprosił/a Cię do tajnej rozmowy</string>
+    <string name="EncryptedPlaceholderTitleOutgoing">Zaprosiłeś %s do tajnej rozmowy</string>
+    <string name="EncryptedDescriptionTitle">Tajne rozmowy:</string>
+    <string name="EncryptedDescription1">Użyj szyfrowanej rozmowy</string>
+    <string name="EncryptedDescription2">Nie zostawiaj śladów na serwerze</string>
+    <string name="EncryptedDescription3">Posiada licznik autodestrukcji</string>
+    <string name="EncryptedDescription4">Zablokuj odpisywanie</string>
+    <string name="YouWereKicked">Zostałeś usunięty z tej grupy</string>
+    <string name="YouLeft">Opuściłeś tą grupę</string>
+    <string name="DeleteThisGroup">Usuń grupę</string>
+    <string name="DeleteThisChat">Usuń  czat</string>
+    <string name="SlideToCancel">Przeciągnij aby anulować</string>
+    <string name="SaveToDownloads">Zapisz do pobranych</string>
+    <string name="ShareFile">Udostępnij</string>
+    <string name="ApplyLocalizationFile">Zastosuj plik lokalizacyjny</string>
+    <string name="UnsupportedAttachment">Nieobsługiwany załącznik</string>
+    <string name="SetTimer">Ustaw zegar autodestrukcji</string>
+    <string name="ServiceNotifications">Powiadomienia serwisowe</string>
+    <!--notification-->
+    <string name="MessageLifetimeChanged">%1$s ustawił/a licznik autodestrukcji na %2$s</string>
+    <string name="MessageLifetimeChangedOutgoing">Ustawiłeś licznik autodestrukcji na %1$s</string>
+    <string name="MessageLifetimeRemoved">Licznik autodestrukcji usunięty przez %1$s </string>
+    <string name="MessageLifetimeYouRemoved">Wyłączyłeś autodestrukcje wiadomości</string>
+    <string name="YouHaveNewMessage">Masz nową wiadomość</string>
+    <string name="NotificationMessageText">%1$s: %2$s</string>
+    <string name="NotificationMessageNoText">%1$s wysłał/a Ci wiadomość</string>
+    <string name="NotificationMessagePhoto">%1$s wysłał/a Ci obraz</string>
+    <string name="NotificationMessageVideo">%1$s wysłał/a Ci wideo</string>
+    <string name="NotificationMessageContact">%1$s wysłał Ci wizytówke</string>
+    <string name="NotificationMessageMap">%1$s wysłał/a Ci lokalizacje</string>
+    <string name="NotificationMessageDocument">%1$s wysłał/a Ci wideo</string>
+    <string name="NotificationMessageAudio">%1$s wysłał(a) Ci plik audio</string>
+    <string name="NotificationMessageSticker">%1$s wysłał ci wlepę</string>
+    <string name="NotificationMessageGroupText">%1$s @ %2$s: %3$s</string>
+    <string name="NotificationMessageGroupNoText">%1$s wysłał wiadomość w grupie %2$s</string>
+    <string name="NotificationMessageGroupPhoto">%1$s wysłał/a zdjęcie do grupy %2$s</string>
+    <string name="NotificationMessageGroupVideo">%1$s wysłał/a wideo do grupy %2$s</string>
+    <string name="NotificationMessageGroupContact">%1$s udostępnił/a kontakt w grupie %2$s</string>
+    <string name="NotificationMessageGroupMap">%1$s wysłał/a lokalizację do grupy %2$s</string>
+    <string name="NotificationMessageGroupDocument">%1$s wysłał/a wideo do grupy %2$s</string>
+    <string name="NotificationMessageGroupAudio">%1$s wysłał/a audio do grupy %2$s</string>
+    <string name="NotificationMessageGroupSticker">%1$s wysłał wlepę do grupy %2$s</string>
+    <string name="NotificationInvitedToGroup">%1$s zaprosił/a cię do grupy %2$s</string>
+    <string name="NotificationEditedGroupName">%1$s zmienił/a nazwę grupy na %2$s</string>
+    <string name="NotificationEditedGroupPhoto">%1$s zmienił/a zdjęcie grupy %2$s</string>
+    <string name="NotificationGroupAddMember">%1$s zaprosił/a %3$s do grupy %2$s</string>
+    <string name="NotificationGroupAddSelf">%1$s wrócił/a do grupy %2$s</string>
+    <string name="NotificationGroupKickMember">%3$s usunięty/a z grupy %2$s przez %1$s</string>
+    <string name="NotificationGroupKickYou">%1$s usunął cię z grupy %2$s</string>
+    <string name="NotificationGroupLeftMember">%1$s opuścił grupe %2$s</string>
+    <string name="NotificationContactJoined">%1$s dołączył do Telegram-a!</string>
+    <string name="NotificationUnrecognizedDevice">%1$s,\nZarejestrowalismy logowanie do Twojego konta z nowego urządzenia%2$s\n\nUrządzenie: %3$s\nLokalizacja: %4$s\n\nJeżeli to nie ty, idź do Ustawienia - Prywatność i Bezpieczeństwo - Zakończ wszystkie inne sesje.\n\nPozdrawiamy,\nZespół Telegram</string>
+    <string name="NotificationContactNewPhoto">%1$s zaktualizował/a swoje zdjęcie profilowe</string>
+    <string name="Reply">Odpowiedz</string>
+    <string name="ReplyToGroup">Odpowiedz %1$s</string>
+    <string name="ReplyToUser">Odpowiedz %1$s</string>
+    <string name="NotificationMessagesPeopleDisplayOrder">%1$s %2$s</string>
+    <!--contacts view-->
+    <string name="SelectContact">Wybierz Kontakt</string>
+    <string name="NoContacts">Brak kontaktów</string>
+    <string name="InviteText">Hej, przełącz sie na Telegram: http://goo.gl/jnmjnZ</string>
+    <string name="TodayAt">przy</string>
+    <string name="YesterdayAt">wczoraj o </string>
+    <string name="Online">Dostępny(a)</string>
+    <string name="LastSeen">widziano o</string>
+    <string name="LastSeenDate">ostatnio widziano</string>
+    <string name="InviteFriends">Zaproś znajomych</string>
+    <string name="GlobalSearch">Wyszukiwanie we wszystkich kategoriach </string>
+    <string name="Lately">ostatnio widziano</string>
+    <string name="WithinAWeek">ostatnio widziano w ciągu tygodnia</string>
+    <string name="WithinAMonth">ostatnio widziano w ciągu miesiąca</string>
+    <string name="ALongTimeAgo">ostatnio widziano bardzo dawno</string>
+    <string name="NewMessageTitle">Nowe wiadomości</string>
+    <!--group create view-->
+    <string name="SendMessageTo">Wyślij wiadomość do...</string>
+    <string name="EnterGroupNamePlaceholder">Wpisz nazwę grupy</string>
+    <string name="GroupName">Nazwa grupy</string>
+    <string name="MembersCount">%1$d/%2$d użytkownicy </string>
+    <!--group info view-->
+    <string name="SharedMedia">Współdzielone pliki</string>
+    <string name="SETTINGS">Ustawienia</string>
+    <string name="AddMember">Dodaj członka</string>
+    <string name="DeleteAndExit">Usuń i opuść grupę</string>
+    <string name="Notifications">Powiadomienia</string>
+    <string name="KickFromGroup">Usuń z grupy</string>
+    <!--contact info view-->
+    <string name="ShareContact">Wyślij kontakt</string>
+    <string name="AddContact">Dodaj</string>
+    <string name="AddContactTitle">Dodaj kontakt</string>
+    <string name="BlockContact">Blokuj</string>
+    <string name="EditContact">Edytuj</string>
+    <string name="DeleteContact">Usuń</string>
+    <string name="PhoneHome">Dom</string>
+    <string name="PhoneMobile">Komórka</string>
+    <string name="PhoneWork">Praca</string>
+    <string name="PhoneOther">Inny</string>
+    <string name="PhoneMain">Główny</string>
+    <string name="StartEncryptedChat">Rozpocznij sekretną rozmowe</string>
+    <string name="CreateEncryptedChatError">Błąd</string>
+    <string name="EncryptionKey">Klucz szyfrowania</string>
+    <string name="MessageLifetime">Licznik autodestrukcji</string>
+    <string name="ShortMessageLifetimeForever">Wyłącz</string>
+  <string name="EncryptionKeyDescription">Ten obraz to wizualizacja klucza szyfrującego dla bezpiecznego czata z <![CDATA[<b>]]>%1$s<![CDATA[</b>]]>.
+<![CDATA[<br><br>]]>Jeśli ten obraz wygląda tak samo na telefonie <![CDATA[<b>]]>%2$s<![CDATA[</b>]]>, to twój czat jest bezpieczny na 200%%.<![CDATA[<br><br>]]>Wiecej informacji na telegram.org</string>
+    <string name="NumberUnknown">Nieznany</string>
+    <string name="Info">Informacje</string>
+    <string name="Phone">Telefon</string>
+    <!--usernames-->
+    <string name="Username">Nazwa użytkownika</string>
+    <string name="UsernamePlaceholder">Twoja nazwa użytkownika </string>
+    <string name="UsernameInUse">Przepraszamy, ale ta nazwa jest już zajęta</string>
+    <string name="UsernameInvalid">Przepraszamy, nazwa użytkownika jest nie poprawna</string>
+    <string name="UsernameInvalidShort">Nazwa musi mieć przynajmniej 5 znaków</string>
+    <string name="UsernameInvalidLong">Twoja nazwa nie może przekroczyć 32 znaków.</string>
+    <string name="UsernameInvalidStartNumber">Nazwa nie może zaczynać się od numeru.</string>
+    <string name="UsernameHelp">Możesz wybrać nazwę użytkownika w  <![CDATA[<b>]]>Plus Messenger<![CDATA[</b>]]>. Robiąc to umożliwiasz znalezienie innym osobom Ciebie bez podawania im Twojego numeru telefonu.<![CDATA[<br><br>]]>Możesz użyć <![CDATA[<b>]]>a–z<![CDATA[</b>]]>, <![CDATA[<b>]]>0–9<![CDATA[</b>]]> i podkreśla. Minimalna długość wynosi <![CDATA[<b>]]>5<![CDATA[</b>]]> znaków.</string>
+    <string name="UsernameChecking">Sprawdzanie nazwy użytkownika...</string>
+    <string name="UsernameAvailable">%1$s jest dostępny. </string>
+    <string name="UsernameEmpty">Nic</string>
+    <string name="ErrorOccurred">Wystąpił błąd.</string>
+    <!--settings view-->
+    <string name="ResetNotificationsText">Przywróć wszystkie domyślne powiadomienia</string>
+    <string name="TextSize">Rozmiar czcionki w wiadomościach</string>
+    <string name="AskAQuestion">Zadaj pytanie</string>
+    <string name="EnableAnimations">Włącz animacje</string>
+    <string name="Unblock">Odblokuj</string>
+    <string name="UnblockText">Przytrzymaj konakt żeby odblokować</string>
+    <string name="NoBlocked">Brak zablokowanych kontaktów</string>
+    <string name="MessageNotifications">Powiadomienia wiadomości</string>
+    <string name="Alert">Alert</string>
+    <string name="MessagePreview">Podgląd wiadomości</string>
+    <string name="GroupNotifications">Powiadomienia grup</string>
+    <string name="Sound">Dźwięk</string>
+    <string name="InAppNotifications">Powiadomienia aplikacji</string>
+    <string name="InAppSounds">Dzwiękowe</string>
+    <string name="InAppVibrate">Wibracja</string>
+    <string name="Vibrate">Wibracja</string>
+    <string name="InAppPreview">Podgląd</string>
+    <string name="Reset">Resetuj</string>
+    <string name="ResetAllNotifications">Przywróć wszystkie powiadomienia</string>
+    <string name="UndoAllCustom">Cofnij wszystkie niestandardowe ustawienia powiadomień dla kontaktów i grup</string>
+    <string name="NotificationsAndSounds">Powiadomienia i dźwięki</string>
+    <string name="BlockedUsers">Zablokowane kontakty</string>
+    <string name="LogOut">Wyloguj się</string>
+    <string name="NoSound">Bez dźwięków</string>
+    <string name="Default">Domyślny</string>
+    <string name="Support">Wsparcie</string>
+    <string name="ChatBackground">Tło czatu</string>
+    <string name="MessagesSettings">Wiadomości</string>
+    <string name="SendByEnter">Wyślij przez Enter</string>
+    <string name="TerminateAllSessions">Zakończ wszystkie inne sesje</string>
+    <string name="Events">Wydarzenia</string>
+    <string name="ContactJoined">Kontakt dołączył do Telegram</string>
+    <string name="Pebble">PEBBLE</string>
+    <string name="Language">Język</string>
+    <string name="AskAQuestionInfo">Wsparcie techniczne Telegram tworzone jest przez ochotników. Staramy się odpowiedzieć jak najszybciej, lecz to zajmuje troszkę czasu.<![CDATA[<br><br>]]>Proszę sprawdzić<![CDATA[<a href=\"http://telegram.org/faq#general\">Telegram FAQ</a>]]>: tam znajdziesz większość odpowiedzi na swoje pytania oraz cenne wzkazówki <![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">troubleshooting</a>]]>.</string>
+    <string name="AskButton">Zapytaj ochotnika</string>
+    <string name="TelegramFaq">Telegram FAQ</string>
+    <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+    <string name="DeleteLocalization">Usunąć lokalizacje?</string>
+    <string name="IncorrectLocalization">Niepoprawna lokalizacja pliku</string>
+    <string name="Enabled">Włączone</string>
+    <string name="Disabled">Wyłączone</string>
+    <string name="NotificationsService">Usługa Powiadomień</string>
+    <string name="NotificationsServiceDisableInfo">Jeśli usługo Google Play są dal Ciebie wystarczające do pokazywania powiadomień to możesz wyłączyć system powiadomień. Jednak zalecamy pozostawienie włączonego systemu powiadomień, aby aplikacja mogła być uruchomiona w tle i przekazywać szybko powiadomienia.. </string>
+    <string name="SortBy">Sortuj Według</string>
+    <string name="ImportContacts">Importuj kKontakty</string>
+    <string name="SortFirstName">Imię</string>
+    <string name="SortLastName">Nazwisko</string>
+    <string name="LedColor">Kolor LED</string>
+    <string name="PopupNotification">Wyskakujące Powiadomienia</string>
+    <string name="NoPopup">Brak wyskakujących okienek. </string>
+    <string name="OnlyWhenScreenOn">Tylko jeśli ekran jest \"włączony\"</string>
+    <string name="OnlyWhenScreenOff">Tylko jeśli ekran jest \"wyłączony\" </string>
+    <string name="AlwaysShowPopup">Zawsze pokazuj wyskakujące okienka</string>
+    <string name="BadgeNumber">Odznaka</string>
+    <string name="Short">Krótki</string>
+    <string name="Long">Długi</string>
+    <string name="SystemDefault">Domyślne Systemowe</string>
+    <string name="SettingsDefault">Domyślne Ustawienia</string>
+    <string name="AutomaticMediaDownload">Automatycznie pobieraj media</string>
+    <string name="WhenUsingMobileData">W przypadku korzystania z danych mobilnych</string>
+    <string name="WhenConnectedOnWiFi">W przypadku połączenia Wi-Fi</string>
+    <string name="WhenRoaming">W przypadku korzystania z Roamingu</string>
+    <string name="NoMediaAutoDownload">Bez multimediów </string>
+    <string name="SaveToGallerySettings">Zapisz do galerii</string>
+    <string name="EditName">Edytuj imię</string>
+    <string name="NotificationsPriority">Priorytet</string>
+    <string name="NotificationsPriorityDefault">Domyślny</string>
+    <string name="NotificationsPriorityLow">Niski</string>
+    <string name="NotificationsPriorityHigh">Wysoki</string>
+    <string name="NotificationsPriorityMax">Maksymalny</string>
+    <string name="RepeatNotificationsNever">Nigdy</string>
+    <string name="RepeatNotifications">Powtórzanie powiadomień</string>
+    <string name="PhoneNumberHelp">Możesz zmienić numer Telegram tutaj. Twoje konto i wszystkie dane w chmurze — Wiadomości, media, kontakty, etc. zostaną przesuniete do nowego numeru.\n\n<![CDATA[<b>Ważne:</b>]]> wszystkie twoje kontaty Telegram zostaną poinformowane o  <![CDATA[<b>Twoim nowym numerze</b>]]> i zostanie dodany do kontaktów, tych osób które posiadały twój stary numer i nie zostały zablokowane w Telegram.</string>
+    <string name="PhoneNumberAlert">Wszystkie twoje kontatky Telegram otrzymaja twój nowy numer i zostanie dodany do kontaktów tych osób które posiadały twój stary numer a nie zostały zablokowane w Telegram.</string>
+    <string name="PhoneNumberChange">ZMIEŃ NUMER</string>
+    <string name="ChangePhoneNewNumber">Nowy numer</string>
+    <string name="ChangePhoneHelp">Wyślemy SMS z kodem potwierdzającym na twój nowy numer</string>
+    <string name="ChangePhoneNumberOccupied">Numer %1$s jest już połączony z kontem Telegram. Proszę skasować to konto przed migracją do nowego numeru.</string>
+    <string name="NotificationsOther">Inny</string>
+    <string name="NotificationsDisabled">Wyłączone</string>
+    <string name="VibrationDisabled">Wyłączone</string>
+    <!--passcode view-->
+    <string name="Passcode">Kod dostępu</string>
+    <string name="ChangePasscode">Zmień kod dostępu</string>
+    <string name="ChangePasscodeInfo">Gdy przypiszesz dodatkowy pin, na stronach czatów pojawi się ikona blokady. Kliknij w nią, aby zablokować lub odblokować aplikacje Telegram.\n\nUwaga: jeżeli zapomnisz swojego pinu, będzies musiał usunąć i ponownie zainstalować aplikację. Wszystkie sekretne chaty zostaną utracone.</string>
+    <string name="ChangePasscodeAlert">Zobaczysz teraz ikonę blokady na stronach czatów. Kliknij w nią, aby zablokować aplikację Telegram swoim nowym pinem.</string>
+    <string name="PasscodePIN">PIN</string>
+    <string name="PasscodePassword">Hasło</string>
+    <string name="EnterCurrentPasscode">Podaj swój obecny kod dostępu</string>
+    <string name="EnterNewPasscode">Podaj swój nowy kod dostępu</string>
+    <string name="EnterYourPasscode">Podaj twój kod dostępu</string>
+    <string name="ReEnterYourPasscode">Podaj ponownie nowy kod dostępu</string>
+    <string name="InvalidPasscode">Nieprawidłowy kod dostępu</string>
+    <string name="PasscodeDoNotMatch">Kod dostępu nie pasuje</string>
+    <string name="AutoLock">Automatyczna blokada</string>
+    <string name="AutoLockInfo">Wymaga pinu przy dłuższej nieaktywności</string>
+    <string name="AutoLockInTime">w %1$s</string>
+    <string name="AutoLockDisabled">Wyłączone</string>
+    <!--media view-->
+    <string name="NoMedia">Udostępnij zdjęcia i video na tym czacie z opcją dostępu do nich na dowolnych urządzeniach.</string>
+    <string name="DocumentsTitle">Pliki</string>
+    <string name="SharedMediaTitle">Współdzielone pliki</string>
+    <string name="NoSharedFiles">Udostępnij pliki i dokumenty na tym czacie z opcją dostępu do nich na dowolnych urządzeniach</string>
+    <!--map view-->
+    <string name="Map">Mapa</string>
+    <string name="Satellite">Satelitarna</string>
+    <string name="Hybrid">Hybrydowa</string>
+    <string name="MetersAway">m od</string>
+    <string name="KMetersAway">km od</string>
+    <string name="SendLocation">Wyślij lokalizację</string>
+    <string name="ShareLocation">Udostępnij lokalizację</string>
+    <!--photo gallery view-->
+    <string name="ShowAllMedia">Pokaż wszystkie media</string>
+    <string name="SaveToGallery">Zapisz do galerii</string>
+    <string name="Of">%1$d z %2$d</string>
+    <string name="Gallery">Galeria</string>
+    <string name="AllPhotos">Wszystkie zdjęcia</string>
+    <string name="NoPhotos">Brak zdjęć</string>
+    <string name="PleaseDownload">Najpierw pobierz dane </string>
+    <string name="NoRecentPhotos">Brak zdjęć ostatnio</string>
+    <string name="NoRecentGIFs">Brak ostatnich GIFów</string>
+    <string name="SearchImages">WYSZUKAJ OBRAZY</string>
+    <string name="SearchImagesInfo">WYSZUKAJ PRZEZ WEB</string>
+    <string name="SearchGifs">WYSZUKAJ GIFY</string>
+    <string name="SearchImagesTitle">Szukaj przez web</string>
+    <string name="SearchGifsTitle">Szukaj GIF\'ów</string>
+    <string name="CropImage">Kadruj zdjęcie</string>
+    <string name="EditImage">Kadruj zdjęcie</string>
+    <string name="Enhance">Zwiększenie</string>
+    <string name="Highlights">Zalety</string>
+    <string name="Contrast">Kontrast</string>
+    <string name="Exposure">Ekspozycja</string>
+    <string name="Warmth">Ciepło</string>
+    <string name="Saturation">Nasycenie</string>
+    <string name="Vignette">Winieta</string>
+    <string name="Shadows">Cienie</string>
+    <string name="Grain">Ziarno</string>
+    <string name="Sharpen">Ostrość</string>
+    <string name="Blur">Rozmycie</string>
+    <string name="AreYouSureDeletePhoto">Czy na pewno chcesz usunąć to zdjęcie?</string>
+    <string name="AreYouSureDeleteVideo">Czy na pewno chcesz usunąć to video?</string>
+    <string name="DiscardChanges">Czy chcesz porzucić zmiany? </string>
+    <!--privacy settings-->
+    <string name="PrivacySettings">Prywatność i bezpieczeństwo</string>
+    <string name="PrivacyTitle">Prywatność</string>
+    <string name="PrivacyLastSeen">Ostatnio widziano</string>
+    <string name="LastSeenEverybody">Wszyscy</string>
+    <string name="LastSeenContacts">Kontakty</string>
+    <string name="LastSeenNobody">Nikt</string>
+    <string name="LastSeenEverybodyMinus">Wszyscy (-%1$d)</string>
+    <string name="LastSeenContactsPlus">Moje kontakty (+%1$d)</string>
+    <string name="LastSeenContactsMinus">Moje kontakty (+%1$d)</string>
+    <string name="LastSeenContactsMinusPlus">Moje kontakty (-%1$d, +%2$d)</string>
+    <string name="LastSeenNobodyPlus">Nikt (+%1$d)</string>
+    <string name="SecurityTitle">Bezpieczeństwo</string>
+    <string name="DeleteAccountTitle">Autodestrukcja konta</string>
+    <string name="DeleteAccountIfAwayFor">Jeśli jesteś poza </string>
+    <string name="DeleteAccountHelp">Jeśli nie zalogujesz się co najmniej raz w ciągu tego okresu, konto zostanie usunięte wraz ze wszystkimi grupami, wiadomościami i kontaktami.</string>
+    <string name="DeleteAccountNowConfirmation">Skasować konto?</string>
+    <string name="LastSeenHelp">Zmień kto widzi twoją ostatnią aktywność.</string>
+    <string name="LastSeenTitle">Kto może widzieć twoją ostatnią aktywność?</string>
+    <string name="AddExceptions">Dodaj wyjątek</string>
+    <string name="CustomHelp">Ważne: nie będziesz w stanie zobaczyć czasu ostatniej aktywności ludzi, którym nie udostepniasz swojej. Przybliżony czas ostatniej aktywości będzie dostępny w danym okresie, (ostatnio, w ciągu tygodnia, w ciągu miesiąca).</string>
+    <string name="AlwaysShareWith">Zawsze udostępnij przez </string>
+    <string name="NeverShareWith">Nigdy nie udostępniaj przez</string>
+    <string name="CustomShareSettingsHelp">Te ustawienia te nadpiszą wartości powyżej.</string>
+    <string name="AlwaysShareWithTitle">Zawsze udostępniaj</string>
+    <string name="AlwaysShareWithPlaceholder">Zawsze udostępniaj z użytkownikami</string>
+    <string name="NeverShareWithTitle">Nigdy nie udostępniaj</string>
+    <string name="NeverShareWithPlaceholder">Nigdy nie udostępniaj z użytkownikami</string>
+    <string name="EmpryUsersPlaceholder">Dodaj użytkownika</string>
+    <string name="PrivacyFloodControlError">Niestety, zbyt wiele prób. Nie można zmienić ustawienia prywatności teraz, proszę sprobować później.</string>
+    <string name="ClearOtherSessionsHelp">Wyloguj wszystkie urządzenia z wyjątkiem tego jednego.</string>
+    <string name="RemoveFromListText">Dotknij i przytrzymaj, aby usunąć użytkownika.</string>
+    <!--edit video view-->
+    <string name="EditVideo">Edytuj wideo</string>
+    <string name="OriginalVideo">Oryginalne wideo</string>
+    <string name="EditedVideo">Edytowane wideo</string>
+    <string name="SendingVideo">Wysyłanie wideo...</string>
+    <string name="CompressVideo">Kompresuj Wideo</string>
+    <!--button titles-->
+    <string name="Next">Następne</string>
+    <string name="Back">Wróć</string>
+    <string name="Done">Gotowe</string>
+    <string name="Open">Otwórz</string>
+    <string name="Cancel">Anuluj</string>
+    <string name="Add">Dodaj</string>
+    <string name="Edit">Edycja</string>
+    <string name="Send">Wyślij</string>
+    <string name="Call">Dzwoń</string>
+    <string name="Copy">Kopiuj</string>
+    <string name="Delete">Usuń</string>
+    <string name="Forward">Przekaż</string>
+    <string name="Retry">Ponów</string>
+    <string name="FromCamera">Z aparatu</string>
+    <string name="FromGalley">Z galerii</string>
+    <string name="DeletePhoto">Usuń zdjęcie</string>
+    <string name="Set">Ustaw</string>
+    <string name="OK">OK</string>
+    <string name="Crop">Kadruj</string>
+    <!--messages-->
+    <string name="ActionKickUser">un1 usunięty/a przez un2</string>
+    <string name="ActionLeftUser">un1 opuścił/a grupę</string>
+    <string name="ActionAddUser">un1 dodał/a un2</string>
+    <string name="ActionRemovedPhoto">Zdjęcie grupy usunietę przez un1</string>
+    <string name="ActionChangedPhoto">un1 zmienił/a zdjęcie grupy</string>
+    <string name="ActionChangedTitle">un1 zmienił/a nazwę grupy na un2</string>
+    <string name="ActionCreateGroup">un1 stworzył/a grupę</string>
+    <string name="ActionYouKickUser">Usunięto un2</string>
+    <string name="ActionYouLeftUser">Grupa opuszczona</string>
+    <string name="ActionYouAddUser">Dodany un2</string>
+    <string name="ActionYouRemovedPhoto">Zdjęcie grupy usunięte</string>
+    <string name="ActionYouChangedPhoto">Zdjęcie grupy zmienione</string>
+    <string name="ActionYouChangedTitle">Nazwa grupy zmieniona na un2</string>
+    <string name="ActionYouCreateGroup">Utworzono grupę</string>
+    <string name="ActionKickUserYou">un1 usunął cię</string>
+    <string name="ActionAddUserYou">un1 dodał cię</string>
+    <string name="ActionAddUserSelf">un1 wrócił/a do grupy</string>
+    <string name="UnsuppotedMedia">Ta wiadomość nie jest wspierana przez twoją wersję Telegram. Aktualizuj aplikację na: http://telegram.org/update</string>
+    <string name="AttachPhoto">Zdjęcie</string>
+    <string name="AttachVideo">Wideo</string>
+    <string name="AttachLocation">Lokalizacja</string>
+    <string name="AttachContact">Kontakt</string>
+    <string name="AttachDocument">Plik</string>
+    <string name="AttachSticker">Wlepa</string>
+    <string name="AttachAudio">Audio</string>
+    <string name="FromYou">Ty</string>
+    <string name="ActionTakeScreenshootYou">Zrobiłeś/aś zrzut ekranu!</string>
+    <string name="ActionTakeScreenshoot">un1 zrobił(a) zrzut ekranu!</string>
+    <!--Alert messages-->
+    <string name="InvalidPhoneNumber">Błędny numer telefonu</string>
+    <string name="CodeExpired">Kod przedawniony, proszę zalogować się ponownie</string>
+    <string name="FloodWait">Zbyt wiele prób, proszę spróbować ponownie później</string>
+    <string name="InvalidCode">Błędny kod</string>
+    <string name="InvalidFirstName">Nieprawidłowe imię</string>
+    <string name="InvalidLastName">Nieprawidłowe nazwisko</string>
+    <string name="Loading">Wczytywanie ...</string>
+    <string name="NoPlayerInstalled">Nie masz odtwarzacza wideo, zainstaluj jakiś aby kontynuować</string>
+    <string name="NoMailInstalled">Proszę wyślij email na adres sms@telegram.org i opisz nam swój problem.</string>
+    <string name="NoHandleAppInstalled">Nie posiadasz aplikacji, aby otworzyć ten typ pliku\'%1$s\'. Zainstaluj jedną z nich, aby otworzyć ten plik</string>
+    <string name="InviteUser">Ten kontakt nie używa Telegramu, wysłać mu zaproszenie ?</string>
+    <string name="AreYouSure">Na pewno ?</string>
+    <string name="AddToTheGroup">Dadać %1$s do grupy?\n\nLIczba ostanich wiadomości do przodu:</string>
+    <string name="ForwardMessagesTo">Przekazać wiadomości do %1$s?</string>
+    <string name="SendMessagesTo">Wysłać wiadomość do %1$s?</string>
+    <string name="AreYouSureLogout">Czy na pewno chcesz się wylogować?\n\nZauważ że można bezproblemowo używać Telegram wszystkich urządzeń na raz.\nPamiętaj, wylogowanie się zniszczy wszystkie twoje tajne rozmowy.</string>
+    <string name="AreYouSureSessions">Jesteś pewien, że chcesz zakończyć wszystkie inne sesje? </string>
+    <string name="AreYouSureDeleteAndExit">Czy na pewno chcesz usunąć i opuścić grupę?</string>
+    <string name="AreYouSureDeleteThisChat">Czy na pewno chcesz usunąć ten czat?</string>
+    <string name="AreYouSureShareMyContactInfo">Czy jesteś pewien, że chcesz wysłać swoje szczegółowe dane. </string>
+    <string name="AreYouSureBlockContact">Czy na pewno chcesz zablokować ten kontakt?</string>
+    <string name="AreYouSureUnblockContact">Czy na pewno chcesz odblokować ten kontakt?</string>
+    <string name="AreYouSureDeleteContact">Czy na pewno chcesz usunąć ten kontakt?</string>
+    <string name="AreYouSureSecretChat">Czy na pewno chcesz utworzyć sekretny czat?</string>
+    <string name="AreYouSureRegistration">Czy na pewno chcesz anulować rejestrację?</string>
+    <string name="AreYouSureClearHistory">Czy na pewno chcesz wyczyścić historię?</string>
+    <string name="AreYouSureDeleteMessages">Czy na pewno chcesz usunąć %1$s?</string>
+    <string name="SendMessagesToGroup">Wysłać wiadomość do %1$s?</string>
+    <string name="ForwardMessagesToGroup">Przekazać wiadomości do %1$s?</string>
+    <string name="FeatureUnavailable">Ta usługa nie jest aktualnie dostępna w Twoim kraju.</string>
+    <!--Intro view-->
+    <string name="Page1Title">Plus Messenger</string>
+    <string name="Page2Title">Szybki</string>
+    <string name="Page3Title">Bezpłatny</string>
+    <string name="Page4Title">Bezpieczny</string>
+    <string name="Page5Title">Potężny</string>
+    <string name="Page6Title">Oparty na chmurze</string>
+    <string name="Page7Title">Prywatny</string>
+    <string name="Page1Message">Najszybszy <![CDATA[<b>komunikator</b>]]> na świecie.<![CDATA[<br/>]]>To jest <![CDATA[<b>za darmo</b>]]> i <![CDATA[<b>bezpieczne</b>]]>.</string>
+    <string name="Page2Message"><![CDATA[<b>Plus Messenger</b>]]> dostarcza wiadomości szybciej<![CDATA[<br/>]]>niż inne aplikacje</string>
+    <string name="Page3Message"><![CDATA[<b>Plus Messenger</b>]]> jest za damo na zawsze. Brak reklam. <![CDATA[<br/>]]> Brak subskrypcji.</string>
+    <string name="Page4Message"><![CDATA[<b>Plus Messenger</b>]]> zabezpiecza twoje wiadomości<![CDATA[<br/>]]>przed atakami hakerów</string>
+    <string name="Page5Message"><![CDATA[<b>Plus Messenger</b>]]> nie ogranicza rozmiaru twoich<![CDATA[<br/>]]>mediów i czatów</string>
+    <string name="Page6Message"><![CDATA[<b>Plus Messenger</b>]]> miej dostęp do twoich wiadomości<![CDATA[<br/>]]>z wielu różnych urządzeń..</string>
+    <string name="Page7Message"><![CDATA[<b>Plus Messenger</b>]]> zabezpiecza wiadomości na wysokim poziomie <![CDATA[<br/>]]>i mogą ulec samozniszczeniu.</string>
+    <string name="StartMessaging">Zacznij się komunikować</string>
+    <!--plural-->
+    <string name="Online_zero">%1$d Dostępny</string>
+    <string name="Online_one">%1$d Dostępny</string>
+    <string name="Online_two">%1$d Dostępny</string>
+    <string name="Online_few">%1$d Dostępny</string>
+    <string name="Online_many">%1$d Dostępny</string>
+    <string name="Online_other">%1$d Dostępny</string>
+    <string name="Members_zero">brak członków</string>
+    <string name="Members_one">%1$d członek</string>
+    <string name="Members_two">%1$d członków</string>
+    <string name="Members_few">%1$d członków</string>
+    <string name="Members_many">%1$d członków</string>
+    <string name="Members_other">%1$d członków</string>
+    <string name="AndMoreTyping_zero">i %1$d więcej osób pisze </string>
+    <string name="AndMoreTyping_one">i %1$d więcej osób pisze </string>
+    <string name="AndMoreTyping_two">i %1$d więcej osób pisze </string>
+    <string name="AndMoreTyping_few">i %1$d więcej osób pisze </string>
+    <string name="AndMoreTyping_many">i %1$d więcej osób pisze </string>
+    <string name="AndMoreTyping_other">i %1$d więcej osób pisze </string>
+    <string name="NewMessages_zero">brak nowych wiadomości</string>
+    <string name="NewMessages_one">%1$d nowa wiadomość</string>
+    <string name="NewMessages_two">%1$d nowe wiadomości</string>
+    <string name="NewMessages_few">%1$d nowe wiadomości</string>
+    <string name="NewMessages_many">%1$d nowe wiadomości</string>
+    <string name="NewMessages_other">%1$d nowe wiadomości</string>
+    <string name="messages_zero">brak wiadomości</string>
+    <string name="messages_one">%1$d wiadomość</string>
+    <string name="messages_two">%1$d wiadomości</string>
+    <string name="messages_few">%1$d wiadomości</string>
+    <string name="messages_many">%1$d wiadomości</string>
+    <string name="messages_other">%1$d wiadomości</string>
+    <string name="items_zero">brak elementów</string>
+    <string name="items_one">%1$d element</string>
+    <string name="items_two">%1$d elementy</string>
+    <string name="items_few">%1$d elementy</string>
+    <string name="items_many">%1$d elementy</string>
+    <string name="items_other">%1$d elementy</string>
+    <string name="FromChats_zero">Od braku czatów</string>
+    <string name="FromChats_one">z %1$d czatu</string>
+    <string name="FromChats_two">z %1$d czatów</string>
+    <string name="FromChats_few">z %1$d czatów</string>
+    <string name="FromChats_many">z %1$d czatów</string>
+    <string name="FromChats_other">z %1$d czatów</string>
+    <string name="Seconds_zero">%1$d sekund</string>
+    <string name="Seconds_one">%1$d sekund</string>
+    <string name="Seconds_two">%1$d sekund</string>
+    <string name="Seconds_few">%1$d sekund</string>
+    <string name="Seconds_many">%1$d sekund</string>
+    <string name="Seconds_other">%1$d sekund</string>
+    <string name="Minutes_zero">%1$d minut</string>
+    <string name="Minutes_one">%1$d minut</string>
+    <string name="Minutes_two">%1$d minut</string>
+    <string name="Minutes_few">%1$d minut</string>
+    <string name="Minutes_many">%1$d minut</string>
+    <string name="Minutes_other">%1$d minut</string>
+    <string name="Hours_zero">%1$d godzin</string>
+    <string name="Hours_one">%1$d godzina</string>
+    <string name="Hours_two">%1$d godzin</string>
+    <string name="Hours_few">%1$d godzin</string>
+    <string name="Hours_many">%1$d godzin</string>
+    <string name="Hours_other">%1$d godzin</string>
+    <string name="Days_zero">%1$d dni</string>
+    <string name="Days_one">%1$d dni</string>
+    <string name="Days_two">%1$d dni</string>
+    <string name="Days_few">%1$d dni</string>
+    <string name="Days_many">%1$d dni</string>
+    <string name="Days_other">%1$d dni</string>
+    <string name="Weeks_zero">%1$d tygodni</string>
+    <string name="Weeks_one">%1$d tydzień</string>
+    <string name="Weeks_two">%1$d tygodni</string>
+    <string name="Weeks_few">%1$d tygodni</string>
+    <string name="Weeks_many">%1$d tygodni</string>
+    <string name="Weeks_other">%1$d tygodni</string>
+    <string name="Months_zero">%1$d miesięcy</string>
+    <string name="Months_one">%1$d miesiąc</string>
+    <string name="Months_two">%1$d miesięcy</string>
+    <string name="Months_few">%1$d miesięcy</string>
+    <string name="Months_many">%1$d miesięcy</string>
+    <string name="Months_other">%1$d miesięcy</string>
+    <string name="Years_zero">%1$d lat</string>
+    <string name="Years_one">%1$d rok</string>
+    <string name="Years_two">%1$d lat</string>
+    <string name="Years_few">%1$d lat</string>
+    <string name="Years_many">%1$d lat</string>
+    <string name="Years_other">%1$d lat</string>
+    <string name="Users_zero">%1$d użytkowników</string>
+    <string name="Users_one">%1$d użytkowników</string>
+    <string name="Users_two">%1$d użytkowników</string>
+    <string name="Users_few">%1$d użytkowników</string>
+    <string name="Users_many">%1$d użytkowników</string>
+    <string name="Users_other">%1$d użytkowników</string>
+    <!--date formatters-->
+    <string name="formatterMonthYear">MMMM yyyy</string>
+    <string name="formatterMonth">MMM dd</string>
+    <string name="formatterYear">dd.MM.rr</string>
+    <string name="formatterYearMax">dd.MM.rrrr</string>
+    <string name="chatDate">MMMM d</string>
+    <string name="chatFullDate">MMMM d, rrrr</string>
+    <string name="formatterWeek">EEE</string>
+    <string name="formatterDay24H">HH:mm</string>
+    <string name="formatterDay12H">h:mm a</string>
+    <string name="formatDateAtTime">%1$s podczas %2$s</string>
+    <!--Telegram+ Polish-->
+    <!--Smart Notifications-->
+    <string name="SmartNotification">Inteligentne powiadomienia</string>
+    <string name="TimeUnitSeconds">sekunda(y)</string>
+    <string name="TimeUnitMinutes">minuta(y)</string>
+    <string name="TimeUnitHours">Godzina(y)</string>
+    <string name="TimeUnitDays">dzień(dni)</string>
+    <string name="settings_smart_notify_begin">Najgłośniej</string>
+    <string name="settings_smart_notify_mid1">czasy</string>
+    <string name="settings_smart_notify_mid11">czas</string>
+    <string name="settings_smart_notify_mid2">w ciągu</string>
+    <!---->
+  <string name="TelegramForAndroid">Plus Messenger dla Androida</string>
+  <string name="Theming">Motywy</string>
+  <string name="colorHexInvalid">Zły kod hex</string>
+  <string name="themeColor">Kolor motywu</string>
+  <string name="ResetThemeSettings">Resetuj motywy</string>
+  <string name="ResetThemeSettingsSum">Cofnij wszystkie wszystkie zmiany wyglądu</string>
+  <string name="ResetThemeToastText">Przywróć domyślne ustawienia motywów.</string>
+  <string name="General">Ogólne</string>
+  <string name="Screens">Okna programu</string>
+  <string name="MainScreen">Główne menu</string>
+  <string name="ChatScreen">Okno rozmowy</string>
+  <string name="ContactsScreen">Lista kontaktów</string>
+  <string name="Header">Nagłówek</string>
+  <string name="Rows">Wiersz</string>
+  <string name="ChatList">Lista rozmów</string>
+  <string name="ChatsList">Lista rozmów</string>
+  <string name="ContactsList">Kontakty</string>
+  <string name="HeaderColor">Kolor nagłówka</string>
+  <string name="NameColor">Kolor nazwy kontaktu</string>
+  <string name="NameSize">Wielkość czcionki nazwy kontaktu</string>
+  <string name="MessageColor">Kolor wiadomości</string>
+  <string name="MessageSize">Wielkość wiadomości</string>
+  <string name="TimeDateColor">Kolor czasu/daty</string>
+  <string name="TimeDateSize">Rozmiar czcionki czasu/daty</string>
+  <string name="CountColor">Kolor obliczeń</string>
+  <string name="CountSize">Rozmiar obliczeń</string>
+  <string name="RowColor">Kolor wiersza</string>
+  <string name="CountBGColor">Kolor obliczeń w tle</string>
+  <string name="StatusColor">Kolor statusu</string>
+  <string name="StatusSize">Rozmiar czcionki statusu</string>
+  <string name="RBubbleColor">Kolor prawej banki</string>
+  <string name="LBubbleColor">Rozmiar lewej bańki</string>
+  <string name="DateColor">Kolor daty</string>
+  <string name="DateSize">Rozmiar daty</string>
+  <string name="DateBubbleColor">Kolor daty w bańce</string>
+  <string name="RTextColor">Kolor tekstu po prawej stronie</string>
+  <string name="LTextColor">Kolor tekstu po lewej stronie</string>
+  <string name="RTimeColor">Kolor czasu po prawej stronie</string>
+  <string name="LTimeColor">Kolor czasu po lewej stronie</string>
+  <string name="TimeSize">Rozmiar czcionki czasu</string>
+  <string name="EditTextColor">Kolor wprowadzanego tekstu</string>
+  <string name="EditTextSize">Rozmiar wpisywanego tekstu</string>
+  <string name="EditTextBGColor">Kolor tła wprowadzanego tesktu</string>
+  <string name="EmojiViewBGColor">Kolor tła emotikonek</string>
+  <string name="EmojiViewTabColor">Kolor karty emotikonek</string>
+  <string name="OnlineColor">Kolor dostepności</string>
+  <string name="ChatMusic">Muzyka</string>
+  <string name="SaveTheme">Zapisz motyw</string>
+  <string name="SaveThemeSum">Zapisz swój motyw w folderze Telegram/Motywów</string>
+  <string name="SaveThemeToastText">Motyw zapisany!</string>
+  <string name="SavedTo">%1$s zapisano do %2$s</string>
+  <string name="SaveErrorMsg0">Motyw nie został jeszcze stworzony. Załaduj dowolny motyw</string>
+  <string name="restoreOkMsg">Ustawienia zostały przywrócone z karty SD</string>
+  <string name="restoreErrorMsg">Nie znaleziono pliku ustawień w %s</string>
+  <string name="NoMediaMessage">Nie znaleziono karty SD</string>
+  <string name="EnterName">Wpisz nazwę</string>
+  <string name="Themes">Motywy</string>
+  <string name="ApplyTheme">Załaduj motyw</string>
+  <string name="ApplyThemeSum">Załaduj motyw z pliku xml w folderze na urządzeniu</string>
+  <string name="MemberColor">Kolor użytkownika</string>
+  <string name="ChecksColor">Kolor oznaczenia dostarczonej wiadomości</string>
+  <string name="MuteColor">Kolor wyciszenia</string>
+  <string name="SendLogs">Wysili logi</string>
+  <string name="SendLogsEmpty">Brak logów</string>
+  <string name="SendIcon">Wyślij ikony</string>
+  <string name="HideMobile">Ukryj numer telefonu w menu</string>
+  <string name="FloatingPencilColor">Latający kolor ołówka</string>
+  <string name="FloatingBGColor">Latający kolor tła</string>
+  <string name="Community">Społeczność Google+</string>
+  <string name="TypingColor">Wybierz kolor</string>
+  <string name="EditTextIconsColor">Kolor wprowadzania ikon tesktu</string>
+  <string name="NavigationDrawer">Menu powiadomień</string>
+  <string name="OptionsList">Opcje</string>
+  <string name="ListColor">Kolor listy</string>
+  <string name="OwnNameSize">Rozmiar nazwy</string>
+  <string name="PhoneColor">Kolor numeru</string>
+  <string name="PhoneSize">Rozmiar numeru</string>
+  <string name="AvatarColor">Kolor zdjęcia</string>
+  <string name="IconColor">Opcja koloru ikony</string>
+  <string name="OptionColor">Kolor opcji</string>
+  <string name="OptionSize">Rozmiar opcji</string>
+  <string name="VersionColor">Kolor wersji</string>
+  <string name="VersionSize">Rozmiar wersji</string>
+  <string name="HeaderTitleColor">Kolor tytułu</string>
+  <string name="HeaderIconsColor">Kolor ikon</string>
+  <string name="DividerColor">Kolor podziałki</string>
+  <string name="AvatarRadius">Promień zdjęcia</string>
+  <string name="SetMemberColor">Ustaw kolor użytkownika</string>
+  <string name="ForwardNameColor">Najpierw nazwa koloru</string>
+  <string name="HeaderTitle">Tytuł nagłówka</string>
+  <string name="ForwardNoQuote">Przekaż bez cytowania</string>
+  <string name="DisableMessageClick">Wyłącz kliknięciem wyskakujące okienka</string>
+  <string name="ProfileScreen">Lista grup/kontaktów</string>
+  <string name="HideBackground">Ukryj niestandardowe tło</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-ru/strings.xml b/TMessagesProj/src/main/res/values-ru/strings.xml
new file mode 100644
index 000000000..8b0e46c6a
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-ru/strings.xml
@@ -0,0 +1,717 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<resources>
+  <string name="AppName">Plus Messenger</string>
+  <string name="LanguageName">Русский</string>
+  <string name="LanguageNameInEnglish">Russian</string>
+  <string name="LanguageCode">ru</string>
+  <!--signin view-->
+  <string name="YourPhone">Ваш телефон</string>
+  <string name="StartText">Подтвердите код вашей страны\nи введите ваш номер телефона.</string>
+  <string name="ChooseCountry">Выберите страну</string>
+  <string name="WrongCountry">Неправильный код страны</string>
+  <!--code enter view-->
+  <string name="YourCode">Ваш код</string>
+  <string name="SentSmsCode">Мы отправили SMS с кодом активации на ваш телефон</string>
+  <string name="CallText">Мы позвоним вам через %1$d:%2$02d</string>
+  <string name="Calling">Звоним вам...</string>
+  <string name="Code">Код</string>
+  <string name="WrongNumber">Неправильный номер?</string>
+  <string name="DidNotGetTheCode">Не получили код?</string>
+  <!--signup view-->
+  <string name="YourName">Ваше имя</string>
+  <string name="RegisterText">Укажите ваше имя и фамилию</string>
+  <!--<string name="RegisterText">Set up your name and picture</string>-->
+  <string name="FirstName">Имя (обязательно)</string>
+  <string name="LastName">Фамилия (не обязательно)</string>
+  <string name="CancelRegistration">Отменить регистрацию</string>
+  <!--chats view-->
+  <string name="Settings">Настройки</string>
+  <string name="Contacts">Контакты</string>
+  <string name="NewGroup">Новая группа</string>
+  <string name="Yesterday">вчера</string>
+  <string name="NoResult">Нет результатов</string>
+  <string name="NoChats">Чатов пока нет...</string>
+  <string name="NoChatsHelp">Нажмите кнопку создания нового чата\nв нижнем правом углу или кнопку меню\nдля дополнительных опций.</string>
+  <string name="WaitingForNetwork">Ожидание сети...</string>
+  <string name="Connecting">Соединение...</string>
+  <string name="Updating">Обновление...</string>
+  <string name="NewSecretChat">Новый секретный чат</string>
+  <string name="AwaitingEncryption">Ждём, когда %s появится в сети...</string>
+  <string name="EncryptionRejected">Секретный чат отменён</string>
+  <string name="EncryptionProcessing">Обмен ключами шифрования...</string>
+  <string name="EncryptedChatStartedOutgoing">Теперь вы и %s в секретном чате.</string>
+  <string name="EncryptedChatStartedIncoming">Вы присоединились к секретному чату.</string>
+  <string name="ClearHistory">Очистить историю</string>
+  <string name="DeleteChat">Удалить и выйти</string>
+  <string name="DeleteChatUser">Удалить чат</string>
+  <string name="HiddenName">Удалённый аккаунт</string>
+  <string name="SelectChat">Выберите чат</string>
+  <string name="PhotoTip">Нажмите и удерживайте для просмотра</string>
+  <string name="CompatibilityChat">%1$s использует устаревшую версию Telegram, поэтому секретные фотографии будут отображаться в режиме совместимости.\n\nПосле того, как %2$s обновит Telegram, фотографии с минутным или менее таймером начнут работать в режиме \'Нажмите и удерживайте для просмотра\', также вы будете уведомлены всякий раз, когда ваш собеседник делает снимок экрана.</string>
+  <string name="SearchMessages">СООБЩЕНИЯ</string>
+  <string name="Search">Поиск</string>
+  <string name="MuteNotifications">Отключить уведомления</string>
+  <string name="MuteFor">Отключить на %1$s</string>
+  <string name="UnmuteNotifications">Включить уведомления</string>
+  <string name="WillUnmuteIn">Через %1$s</string>
+  <string name="MuteDisable">Отключить</string>
+  <!--broadcasts-->
+  <string name="NewBroadcastList">Новый список рассылки</string>
+  <string name="EnterListName">Введите имя списка</string>
+  <string name="YouCreatedBroadcastList">Вы создали список рассылки</string>
+  <string name="AddRecipient">Добавить получателя</string>
+  <string name="KickFromBroadcast">Исключить из списка рассылки</string>
+  <!--documents view-->
+  <string name="SelectFile">Выберите файл</string>
+  <string name="FreeOfTotal">Свободно %1$s из %2$s</string>
+  <string name="UnknownError">Неизвестная ошибка</string>
+  <string name="AccessError">Ошибка доступа</string>
+  <string name="NoFiles">Файлов пока нет...</string>
+  <string name="FileUploadLimit">Размер файла не может превышать %1$s</string>
+  <string name="NotMounted">Хранилище не подключено</string>
+  <string name="UsbActive">Передача по USB активна</string>
+  <string name="InternalStorage">Внутреннее хранилище</string>
+  <string name="ExternalStorage">Внешнее хранилище</string>
+  <string name="SystemRoot">Корень системы</string>
+  <string name="SdCard">Карта памяти</string>
+  <string name="Folder">Папка</string>
+  <string name="GalleryInfo">Для отправки изображений без сжатия</string>
+  <!--chat view-->
+  <string name="Invisible">невидимый</string>
+  <string name="Typing">набирает…</string>
+  <string name="IsTyping">набирает…</string>
+  <string name="AreTyping">набирают…</string>
+  <string name="GotAQuestion">Есть вопрос\nо Telegram?</string>
+  <string name="ChatTakePhoto">Сделать снимок</string>
+  <string name="ChatGallery">Галерея</string>
+  <string name="ChatLocation">Место</string>
+  <string name="ChatVideo">Видео</string>
+  <string name="ChatDocument">Файл</string>
+  <string name="NoMessages">Здесь пока ничего нет…</string>
+  <string name="ForwardedMessage">Пересланное сообщение</string>
+  <string name="From">От пользователя</string>
+  <string name="NoRecent">Нет недавних</string>
+  <string name="Message">Сообщение</string>
+  <string name="TypeMessage">Сообщение</string>
+  <string name="ShareMyContactInfo">Поделиться своими контактными данными</string>
+  <string name="AddToContacts">Добавить в контакты</string>
+  <string name="EncryptedPlaceholderTitleIncoming">%s приглашает вас в секретный чат.</string>
+  <string name="EncryptedPlaceholderTitleOutgoing">Вы пригласили пользователя %s в секретный чат.</string>
+  <string name="EncryptedDescriptionTitle">Секретные чаты — это:</string>
+  <string name="EncryptedDescription1">Сквозное шифрование</string>
+  <string name="EncryptedDescription2">Никаких следов на серверах</string>
+  <string name="EncryptedDescription3">Таймер самоуничтожения</string>
+  <string name="EncryptedDescription4">Запрет пересылки</string>
+  <string name="YouWereKicked">Вас исключили из этой группы</string>
+  <string name="YouLeft">Вы покинули эту группу</string>
+  <string name="DeleteThisGroup">Удалить эту группу</string>
+  <string name="DeleteThisChat">Удалить этот чат</string>
+  <string name="SlideToCancel">ПРОВЕДИТЕ ДЛЯ ОТМЕНЫ</string>
+  <string name="SaveToDownloads">Сохранить в загрузки</string>
+  <string name="ShareFile">Поделиться</string>
+  <string name="ApplyLocalizationFile">Применить файл локализации</string>
+  <string name="UnsupportedAttachment">Неподдерживаемое вложение</string>
+  <string name="SetTimer">Установить таймер самоуничтожения</string>
+  <string name="ServiceNotifications">Служебные уведомления</string>
+  <!--notification-->
+  <string name="MessageLifetimeChanged">%1$s поставил(а) таймер самоуничтожения на %2$s</string>
+  <string name="MessageLifetimeChangedOutgoing">Вы поставили таймер самоуничтожения на %1$s</string>
+  <string name="MessageLifetimeRemoved">%1$s отключил(а) таймер самоуничтожения</string>
+  <string name="MessageLifetimeYouRemoved">Вы отключили таймер самоуничтожения</string>
+  <string name="YouHaveNewMessage">У вас новое сообщение</string>
+  <string name="NotificationMessageText">%1$s: %2$s</string>
+  <string name="NotificationMessageNoText">%1$s отправил(а) вам сообщение</string>
+  <string name="NotificationMessagePhoto">%1$s отправил(а) вам фото</string>
+  <string name="NotificationMessageVideo">%1$s отправил(а) вам видео</string>
+  <string name="NotificationMessageContact">%1$s поделился(-лась) с вами контактом</string>
+  <string name="NotificationMessageMap">%1$s отправил(а) вам место</string>
+  <string name="NotificationMessageDocument">%1$s отправил(а) вам файл</string>
+  <string name="NotificationMessageAudio">%1$s отправил(а) вам аудио</string>
+  <string name="NotificationMessageSticker">%1$s отправил(а) вам стикер</string>
+  <string name="NotificationMessageGroupText">%1$s @ %2$s: %3$s</string>
+  <string name="NotificationMessageGroupNoText">%1$s отправил(а) сообщение группе %2$s</string>
+  <string name="NotificationMessageGroupPhoto">%1$s отправил(а) фото группе %2$s</string>
+  <string name="NotificationMessageGroupVideo">%1$s отправил(а) видео группе %2$s</string>
+  <string name="NotificationMessageGroupContact">%1$s поделился(-лась) контактом в группе %2$s</string>
+  <string name="NotificationMessageGroupMap">%1$s отправил(а) место группе %2$s</string>
+  <string name="NotificationMessageGroupDocument">%1$s отправил(а) файл группе %2$s</string>
+  <string name="NotificationMessageGroupAudio">%1$s отправил(а) аудио группе %2$s</string>
+  <string name="NotificationMessageGroupSticker">%1$s отправил(а) стикер группе %2$s</string>
+  <string name="NotificationInvitedToGroup">%1$s пригласил(а) вас в группу %2$s</string>
+  <string name="NotificationEditedGroupName">%1$s отредактировал(а) имя группы %2$s</string>
+  <string name="NotificationEditedGroupPhoto">%1$s отредактировал(а) фото группы %2$s</string>
+  <string name="NotificationGroupAddMember">%1$s пригласил(а) пользователя %3$s в группу %2$s</string>
+  <string name="NotificationGroupAddSelf">%1$s вернулся(-лась) в группу %2$s</string>
+  <string name="NotificationGroupKickMember">%1$s исключил(а) пользователя %3$s из группы %2$s</string>
+  <string name="NotificationGroupKickYou">%1$s исключил(а) вас из группы %2$s</string>
+  <string name="NotificationGroupLeftMember">%1$s покинул(а) группу %2$s</string>
+  <string name="NotificationContactJoined">%1$s присоединился(-лась) к Telegram!</string>
+  <string name="NotificationUnrecognizedDevice">%1$s, мы обнаружили вход под вашим аккаунтом на новом устройстве.\n\nДата: %2$s\nУстройство: %3$s\nМестоположение: %4$s\n\nЕсли это были не вы, можете перейти в Настройки — Приватность и безопасность — Завершить все другие сеансы.\n\nИскренне ваша, команда Telegram.</string>
+  <string name="NotificationContactNewPhoto">%1$s обновил(а) фото профиля</string>
+  <string name="Reply">Ответить</string>
+  <string name="ReplyToGroup">Ответить группе %1$s</string>
+  <string name="ReplyToUser">Ответить пользователю %1$s</string>
+  <string name="NotificationMessagesPeopleDisplayOrder">%1$s %2$s</string>
+  <!--contacts view-->
+  <string name="SelectContact">Выберите контакт</string>
+  <string name="NoContacts">Контактов пока нет</string>
+  <string name="InviteText">Эй, давай переключимся на Telegram: http://goo.gl/jnmjnZ</string>
+  <string name="TodayAt">в</string>
+  <string name="YesterdayAt">вчера в</string>
+  <string name="Online">в сети</string>
+  <string name="LastSeen">заходил(а)</string>
+  <string name="LastSeenDate">заходил(а)</string>
+  <string name="InviteFriends">Пригласить друзей</string>
+  <string name="GlobalSearch">ГЛОБАЛЬНЫЙ ПОИСК</string>
+  <string name="Lately">заходил(а) недавно</string>
+  <string name="WithinAWeek">заходил(а) в течение недели</string>
+  <string name="WithinAMonth">заходил(а) в течение месяца</string>
+  <string name="ALongTimeAgo">заходил(а) давно</string>
+  <string name="NewMessageTitle">Новое сообщение</string>
+  <!--group create view-->
+  <string name="SendMessageTo">Отправить сообщение...</string>
+  <string name="EnterGroupNamePlaceholder">Введите имя группы</string>
+  <string name="GroupName">Имя группы</string>
+  <string name="MembersCount">%1$d/%2$d участников</string>
+  <!--group info view-->
+  <string name="SharedMedia">Общие медиа</string>
+  <string name="SETTINGS">Настройки</string>
+  <string name="AddMember">Добавить участника</string>
+  <string name="DeleteAndExit">Удалить и покинуть группу</string>
+  <string name="Notifications">Уведомления</string>
+  <string name="KickFromGroup">Исключить из группы</string>
+  <!--contact info view-->
+  <string name="ShareContact">Поделиться</string>
+  <string name="AddContact">Добавить</string>
+  <string name="AddContactTitle">Добавить контакт</string>
+  <string name="BlockContact">Заблокировать</string>
+  <string name="EditContact">Редактировать</string>
+  <string name="DeleteContact">Удалить</string>
+  <string name="PhoneHome">Дом</string>
+  <string name="PhoneMobile">Мобильный</string>
+  <string name="PhoneWork">Работа</string>
+  <string name="PhoneOther">Другое</string>
+  <string name="PhoneMain">Основной</string>
+  <string name="StartEncryptedChat">Начать секретный чат</string>
+  <string name="CreateEncryptedChatError">Произошла ошибка.</string>
+  <string name="EncryptionKey">Ключ шифрования</string>
+  <string name="MessageLifetime">Таймер самоуничтожения</string>
+  <string name="ShortMessageLifetimeForever">Отключён</string>
+  <string name="EncryptionKeyDescription">Это изображение — визуализация ключа шифрования для этого секретного чата c пользователем <![CDATA[<b>]]>%1$s<![CDATA[</b>]]>.<![CDATA[<br><br>]]>Если это изображение идентично изображению на устройстве пользователя <![CDATA[<b>]]>%2$s<![CDATA[</b>]]>,  то ваше общение безопасно на 200%%.<![CDATA[<br><br>]]>Узнайте больше на telegram.org</string>
+  <string name="NumberUnknown">Неизвестен</string>
+  <string name="Info">Информация</string>
+  <string name="Phone">Номер телефона</string>
+  <!--usernames-->
+  <string name="Username">Имя пользователя</string>
+  <string name="UsernamePlaceholder">Ваше имя пользователя</string>
+  <string name="UsernameInUse">К сожалению, данное имя пользователя уже занято.</string>
+  <string name="UsernameInvalid">К сожалению, данное имя пользователя недопустимо.</string>
+  <string name="UsernameInvalidShort">Имя пользователя должно содержать минимум 5 символов.</string>
+  <string name="UsernameInvalidLong">Имя пользователя не должно содержать более 32 символов.</string>
+  <string name="UsernameInvalidStartNumber">К сожалению, имя пользователя не может начинаться с цифры.</string>
+  <string name="UsernameHelp">Вы можете выбрать себе имя пользователя в <![CDATA[<b>]]>Plus Messenger<![CDATA[</b>]]>. Когда вы сделаете это, другие люди смогут находить вас с его помощью и связываться с вами, не зная номера вашего телефона.<![CDATA[<br><br>]]>Имя пользователя может содержать только латинские буквы <![CDATA[<b>]]>(a–z)<![CDATA[</b>]]>, цифры <![CDATA[<b>]]>(0–9)<![CDATA[</b>]]> и символы подчёркивания. Минимальная допустимая длина —  <![CDATA[<b>]]>5<![CDATA[</b>]]> символов.</string>
+  <string name="UsernameChecking">Проверка имени пользователя…</string>
+  <string name="UsernameAvailable">Имя пользователя %1$s доступно.</string>
+  <string name="UsernameEmpty">Не задано</string>
+  <string name="ErrorOccurred">Произошла ошибка.</string>
+  <!--settings view-->
+  <string name="ResetNotificationsText">Сброс всех настроек уведомлений на стандартные</string>
+  <string name="TextSize">Размер текста сообщений</string>
+  <string name="AskAQuestion">Задать вопрос</string>
+  <string name="EnableAnimations">Анимация</string>
+  <string name="Unblock">Разблокировать</string>
+  <string name="UnblockText">Нажмите и удерживайте имя пользователя для разблокировки</string>
+  <string name="NoBlocked">Чёрный список пока пуст</string>
+  <string name="MessageNotifications">Сообщения</string>
+  <string name="Alert">Сигнал</string>
+  <string name="MessagePreview">Предпросмотр</string>
+  <string name="GroupNotifications">Группы</string>
+  <string name="Sound">Звук</string>
+  <string name="InAppNotifications">В приложении</string>
+  <string name="InAppSounds">Звук</string>
+  <string name="InAppVibrate">Вибросигнал</string>
+  <string name="Vibrate">Вибросигнал</string>
+  <string name="InAppPreview">Предпросмотр</string>
+  <string name="Reset">Сброс</string>
+  <string name="ResetAllNotifications">Сбросить все уведомления</string>
+  <string name="UndoAllCustom">Отменить все пользовательские настройки уведомлений для всех ваших контактов и групп</string>
+  <string name="NotificationsAndSounds">Уведомления и звук</string>
+  <string name="BlockedUsers">Чёрный список</string>
+  <string name="LogOut">Выход</string>
+  <string name="NoSound">Без звука</string>
+  <string name="Default">По умолчанию</string>
+  <string name="Support">Поддержка</string>
+  <string name="ChatBackground">Фон чата</string>
+  <string name="MessagesSettings">Сообщения</string>
+  <string name="SendByEnter">Отправка по Enter</string>
+  <string name="TerminateAllSessions">Завершить все другие сеансы</string>
+  <string name="Events">События</string>
+  <string name="ContactJoined">Контакт присоединился к Telegram</string>
+  <string name="Pebble">PEBBLE</string>
+  <string name="Language">Язык</string>
+  <string name="AskAQuestionInfo">Обратите внимание, что поддержка Telegram осуществляется добровольцами. Мы постараемся ответить как можно быстрее, но на это может потребоваться некоторое время.<![CDATA[<br><br>]]>Пожалуйста, ознакомьтесь с <![CDATA[<a href=\"http://telegram.org/faq#general\">вопросами и ответами о Telegram</a>]]>: там есть ответы на большинство вопросов и важные советы по <![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">устранению неполадок</a>]]>.</string>
+  <string name="AskButton">Спросить добровольца</string>
+  <string name="TelegramFaq">Вопросы и ответы о Telegram</string>
+  <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+  <string name="DeleteLocalization">Удалить локализацию?</string>
+  <string name="IncorrectLocalization">Некорректный файл локализации</string>
+  <string name="Enabled">Включено</string>
+  <string name="Disabled">Отключён</string>
+  <string name="NotificationsService">Служба уведомлений</string>
+  <string name="NotificationsServiceDisableInfo">Если сервисов Google Play вам достаточно для получения уведомлений, вы можете отключить Службу уведомлений. Однако мы рекомендуем вам оставить её включённой для работы приложения в фоновом режиме и получения мгновенных уведомлений.</string>
+  <string name="SortBy">Сортировать по</string>
+  <string name="ImportContacts">Импорт контактов</string>
+  <string name="SortFirstName">Имя</string>
+  <string name="SortLastName">Фамилия</string>
+  <string name="LedColor">Цвет светодиода</string>
+  <string name="PopupNotification">Всплывающие уведомления</string>
+  <string name="NoPopup">Не показывать</string>
+  <string name="OnlyWhenScreenOn">Только когда экран включён</string>
+  <string name="OnlyWhenScreenOff">Только когда экран выключен</string>
+  <string name="AlwaysShowPopup">Показывать всегда</string>
+  <string name="BadgeNumber">Счётчик значков</string>
+  <string name="Short">Короткий</string>
+  <string name="Long">Долгий</string>
+  <string name="SystemDefault">Язык системы</string>
+  <string name="SettingsDefault">Настройки по умолчанию</string>
+  <string name="AutomaticMediaDownload">Автозагрузка медиа</string>
+  <string name="WhenUsingMobileData">По мобильной сети</string>
+  <string name="WhenConnectedOnWiFi">По Wi-Fi</string>
+  <string name="WhenRoaming">В роуминге</string>
+  <string name="NoMediaAutoDownload">Не загружать</string>
+  <string name="SaveToGallerySettings">Сохранять в галерее</string>
+  <string name="EditName">Редактировать имя</string>
+  <string name="NotificationsPriority">Приоритет</string>
+  <string name="NotificationsPriorityDefault">По умолчанию</string>
+  <string name="NotificationsPriorityLow">Низкий</string>
+  <string name="NotificationsPriorityHigh">Высокий</string>
+  <string name="NotificationsPriorityMax">Максимальный</string>
+  <string name="RepeatNotificationsNever">Никогда</string>
+  <string name="RepeatNotifications">Повтор уведомлений</string>
+  <string name="PhoneNumberHelp">Здесь вы можете сменить ваш номер Telegram. Ваш аккаунт и все ваши данные (сообщения, медиа, контакты и т. д.) будут перенесены на новый номер.\n\n<![CDATA[<b>Важно:</b>]]> всем вашим контактам Telegram будет автоматически добавлен в адресную книгу ваш <![CDATA[<b>новый номер</b>]]>, при условии, что у них был ваш старый номер и вы не блокировали их.</string>
+  <string name="PhoneNumberAlert">Всем вашим контактам Telegram будет автоматически добавлен в адресную книгу ваш новый номер, при условии, что у них был ваш старый номер и вы не блокировали их.</string>
+  <string name="PhoneNumberChange">СМЕНИТЬ НОМЕР</string>
+  <string name="ChangePhoneNewNumber">Новый номер</string>
+  <string name="ChangePhoneHelp">Мы отправим SMS с кодом подтверждения на ваш новый номер.</string>
+  <string name="ChangePhoneNumberOccupied">Номер %1$s уже привязан к аккаунту Telegram. Удалите этот аккаунт, прежде чем перейти на новый номер.</string>
+  <string name="NotificationsOther">Другое</string>
+  <string name="NotificationsDisabled">Отключены</string>
+  <string name="VibrationDisabled">Отключён</string>
+  <!--passcode view-->
+  <string name="Passcode">Код доступа</string>
+  <string name="ChangePasscode">Изменить код доступа</string>
+  <string name="ChangePasscodeInfo">После установки дополнительного кода блокировки на странице чатов появится значок замка. Нажимайте на него для блокировки и разблокировки приложения Telegram.\n\nВнимание: если вы забудете код доступа, вам нужно будет удалить и переустановить это приложение. Все секретные чаты будут утрачены.</string>
+  <string name="ChangePasscodeAlert">Теперь вы будете видеть значок замка на странице чатов. Нажмите на него, чтобы заблокировать приложение Telegram с помощью вашего нового кода доступа.</string>
+  <string name="PasscodePIN">ПИН-код</string>
+  <string name="PasscodePassword">Пароль</string>
+  <string name="EnterCurrentPasscode">Введите ваш текущий код доступа</string>
+  <string name="EnterNewPasscode">Введите ваш новый код доступа</string>
+  <string name="EnterYourPasscode">Введите ваш код доступа</string>
+  <string name="ReEnterYourPasscode">Повторите ваш новый код доступа</string>
+  <string name="InvalidPasscode">Неверный код доступа</string>
+  <string name="PasscodeDoNotMatch">Коды доступа не совпадают</string>
+  <string name="AutoLock">Автоблокировка</string>
+  <string name="AutoLockInfo">Запрашивать код доступа при отсутствии в течение определённого времени.</string>
+  <string name="AutoLockInTime">через %1$s</string>
+  <string name="AutoLockDisabled">Отключена</string>
+  <!--media view-->
+  <string name="NoMedia">Поделитесь фото и видео в этом чате и получите доступ к ним на любом из ваших устройств.</string>
+  <string name="DocumentsTitle">Файлы</string>
+  <string name="SharedMediaTitle">Общие медиа</string>
+  <string name="NoSharedFiles">Поделитесь файлами и документами в этом чате и получите доступ к ним на любом из ваших устройств.</string>
+  <!--map view-->
+  <string name="Map">Карта</string>
+  <string name="Satellite">Спутник</string>
+  <string name="Hybrid">Гибрид</string>
+  <string name="MetersAway">м отсюда</string>
+  <string name="KMetersAway">км отсюда</string>
+  <string name="SendLocation">Отправить место</string>
+  <string name="ShareLocation">Поделиться местом</string>
+  <!--photo gallery view-->
+  <string name="ShowAllMedia">Показать все медиа</string>
+  <string name="SaveToGallery">Сохранить в галерею</string>
+  <string name="Of">%1$d из %2$d</string>
+  <string name="Gallery">Галерея</string>
+  <string name="AllPhotos">Все фото</string>
+  <string name="NoPhotos">Фото пока нет</string>
+  <string name="PleaseDownload">Сначала загрузите медиа</string>
+  <string name="NoRecentPhotos">Нет недавних фото</string>
+  <string name="NoRecentGIFs">Нет недавних GIF</string>
+  <string name="SearchImages">НАЙТИ ИЗОБРАЖЕНИЯ</string>
+  <string name="SearchImagesInfo">ПОИСК В СЕТИ</string>
+  <string name="SearchGifs">НАЙТИ GIF</string>
+  <string name="SearchImagesTitle">Поиск в сети</string>
+  <string name="SearchGifsTitle">Поиск GIF</string>
+  <string name="CropImage">Кадрировать изображение</string>
+  <string name="EditImage">Редактировать изображение</string>
+  <string name="Enhance">Автоулучшение</string>
+  <string name="Highlights">Блики</string>
+  <string name="Contrast">Контраст</string>
+  <string name="Exposure">Экспозиция</string>
+  <string name="Warmth">Тепло</string>
+  <string name="Saturation">Насыщенность</string>
+  <string name="Vignette">Виньетирование</string>
+  <string name="Shadows">Тени</string>
+  <string name="Grain">Зернистость</string>
+  <string name="Sharpen">Резкость</string>
+  <string name="Blur">Размытие</string>
+  <string name="AreYouSureDeletePhoto">Уверены, что хотите удалить это фото?</string>
+  <string name="AreYouSureDeleteVideo">Уверены, что хотите удалить это видео?</string>
+  <string name="DiscardChanges">Отменить изменения?</string>
+  <!--privacy settings-->
+  <string name="PrivacySettings">Приватность и безопасность</string>
+  <string name="PrivacyTitle">Приватность</string>
+  <string name="PrivacyLastSeen">Последняя активность</string>
+  <string name="LastSeenEverybody">Все</string>
+  <string name="LastSeenContacts">Мои контакты</string>
+  <string name="LastSeenNobody">Никто</string>
+  <string name="LastSeenEverybodyMinus">Все (-%1$d)</string>
+  <string name="LastSeenContactsPlus">Мои контакты (+%1$d)</string>
+  <string name="LastSeenContactsMinus">Мои контакты (-%1$d)</string>
+  <string name="LastSeenContactsMinusPlus">Мои контакты (-%1$d, +%2$d)</string>
+  <string name="LastSeenNobodyPlus">Никто (+%1$d)</string>
+  <string name="SecurityTitle">Безопасность</string>
+  <string name="DeleteAccountTitle">Самоуничтожение аккаунта</string>
+  <string name="DeleteAccountIfAwayFor">Если вас не было</string>
+  <string name="DeleteAccountHelp">Если вы не войдёте хотя бы раз в свой аккаунт в течение этого периода, он будет удалён со всеми группами, сообщениями и контактами.</string>
+  <string name="DeleteAccountNowConfirmation">Удалить ваш аккаунт?</string>
+  <string name="LastSeenHelp">Изменить список тех, кто может видеть время вашей последней активности.</string>
+  <string name="LastSeenTitle">Кто видит время моей последней активности?</string>
+  <string name="AddExceptions">Добавить исключения</string>
+  <string name="CustomHelp">Важно: вы не сможете увидеть время последней активности людей, с которыми вы не поделились своим временем последней активности. Вместо этого будет отображаться приблизительное время последней активности (недавно, в течение недели, в течение месяца).</string>
+  <string name="AlwaysShareWith">Всегда делиться с</string>
+  <string name="NeverShareWith">Всегда скрывать от</string>
+  <string name="CustomShareSettingsHelp">Эти настройки переопределят значения выше.</string>
+  <string name="AlwaysShareWithTitle">Всегда делиться</string>
+  <string name="AlwaysShareWithPlaceholder">Всегда делиться с пользователями...</string>
+  <string name="NeverShareWithTitle">Всегда скрывать</string>
+  <string name="NeverShareWithPlaceholder">Всегда скрывать от пользователей...</string>
+  <string name="EmpryUsersPlaceholder">Добавить</string>
+  <string name="PrivacyFloodControlError">Извините, слишком много запросов. Невозможно изменить настройки приватности прямо сейчас, пожалуйста, подождите.</string>
+  <string name="ClearOtherSessionsHelp">Выйти на всех устройствах, кроме этого.</string>
+  <string name="RemoveFromListText">Нажмите и удерживайте на пользователя для удаления.</string>
+  <!--edit video view-->
+  <string name="EditVideo">Редактировать видео</string>
+  <string name="OriginalVideo">Оригинальное видео</string>
+  <string name="EditedVideo">Отредактированное видео</string>
+  <string name="SendingVideo">Отправка видео...</string>
+  <string name="CompressVideo">Сжать видео</string>
+  <!--button titles-->
+  <string name="Next">Далее</string>
+  <string name="Back">Назад</string>
+  <string name="Done">Готово</string>
+  <string name="Open">Открыть</string>
+  <string name="Cancel">Отменить</string>
+  <string name="Add">Добавить</string>
+  <string name="Edit">Редактировать</string>
+  <string name="Send">Отправить</string>
+  <string name="Call">Позвонить</string>
+  <string name="Copy">Копировать</string>
+  <string name="Delete">Удалить</string>
+  <string name="Forward">Переслать</string>
+  <string name="Retry">Повторить</string>
+  <string name="FromCamera">С камеры</string>
+  <string name="FromGalley">Из галереи</string>
+  <string name="DeletePhoto">Удалить фото</string>
+  <string name="Set">Установить</string>
+  <string name="OK">OK</string>
+  <string name="Crop">КАДРИРОВАНИЕ</string>
+  <!--messages-->
+  <string name="ActionKickUser">un1 исключил(а) пользователя un2</string>
+  <string name="ActionLeftUser">un1 покинул(а) группу</string>
+  <string name="ActionAddUser">un1 добавил(а) пользователя un2</string>
+  <string name="ActionRemovedPhoto">un1 удалил(а) фото группы</string>
+  <string name="ActionChangedPhoto">un1 изменил(а) фото группы</string>
+  <string name="ActionChangedTitle">un1 изменил(а) имя группы на un2</string>
+  <string name="ActionCreateGroup">un1 создал(а) группу</string>
+  <string name="ActionYouKickUser">Вы исключили пользователя un2</string>
+  <string name="ActionYouLeftUser">Вы покинули группу</string>
+  <string name="ActionYouAddUser">Вы добавили пользователя un2</string>
+  <string name="ActionYouRemovedPhoto">Вы удалили фото группы</string>
+  <string name="ActionYouChangedPhoto">Вы изменили фото группы</string>
+  <string name="ActionYouChangedTitle">Вы изменили имя группы на un2</string>
+  <string name="ActionYouCreateGroup">Вы создали группу</string>
+  <string name="ActionKickUserYou">un1 исключил(а) вас</string>
+  <string name="ActionAddUserYou">un1 добавил(а) вас</string>
+  <string name="ActionAddUserSelf">un1 вернулся(-лась) в группу</string>
+  <string name="UnsuppotedMedia">Это сообщение не поддерживается в вашей версии Telegram. Обновите приложение для просмотра: http://telegram.org/update</string>
+  <string name="AttachPhoto">Фото</string>
+  <string name="AttachVideo">Видео</string>
+  <string name="AttachLocation">Место</string>
+  <string name="AttachContact">Контакт</string>
+  <string name="AttachDocument">Файл</string>
+  <string name="AttachSticker">Стикер</string>
+  <string name="AttachAudio">Аудио</string>
+  <string name="FromYou">Вы</string>
+  <string name="ActionTakeScreenshootYou">Вы сделали скриншот!</string>
+  <string name="ActionTakeScreenshoot">un1 сделал(а) скриншот!</string>
+  <!--Alert messages-->
+  <string name="InvalidPhoneNumber">Неверный номер телефона</string>
+  <string name="CodeExpired">Срок действия кода истёк, пожалуйста, войдите снова</string>
+  <string name="FloodWait">Слишком много попыток, пожалуйста, попробуйте снова позже</string>
+  <string name="InvalidCode">Неверный код</string>
+  <string name="InvalidFirstName">Неверное имя</string>
+  <string name="InvalidLastName">Неверная фамилия</string>
+  <string name="Loading">Загрузка...</string>
+  <string name="NoPlayerInstalled">У вас нет видеоплеера, пожалуйста, установите его для продолжения</string>
+  <string name="NoMailInstalled">Пожалуйста, отправьте письмо на sms@telegram.org и сообщите нам о вашей проблеме.</string>
+  <string name="NoHandleAppInstalled">У вас нет приложений, которые могут обрабатывать файлы типа «%1$s», пожалуйста, установите одно для продолжения.</string>
+  <string name="InviteUser">У этого пользователя пока нет Telegram, отправить приглашение?</string>
+  <string name="AreYouSure">Уверены?</string>
+  <string name="AddToTheGroup">Добавить %1$s в группу?\n\nКоличество последних сообщений для пересылки:</string>
+  <string name="ForwardMessagesTo">Переслать сообщения пользователю %1$s?</string>
+  <string name="SendMessagesTo">Отправить сообщения %1$s?</string>
+  <string name="AreYouSureLogout">Уверены, что хотите выйти?\n\nОбратите внимание на то, что вы можете с лёгкостью пользоваться Telegram на всех ваших устройствах одновременно.\n\nПомните, выход уничтожает все ваши секретные чаты.</string>
+  <string name="AreYouSureSessions">Уверены, что хотите завершить все другие сеансы?</string>
+  <string name="AreYouSureDeleteAndExit">Уверены, что хотите удалить и покинуть эту группу?</string>
+  <string name="AreYouSureDeleteThisChat">Уверены, что хотите удалить этот чат?</string>
+  <string name="AreYouSureShareMyContactInfo">Уверены, что хотите поделиться своей контактной информацией?</string>
+  <string name="AreYouSureBlockContact">Уверены, что хотите заблокировать этот контакт?</string>
+  <string name="AreYouSureUnblockContact">Уверены, что хотите разблокировать этот контакт?</string>
+  <string name="AreYouSureDeleteContact">Уверены, что хотите удалить этот контакт?</string>
+  <string name="AreYouSureSecretChat">Уверены, что хотите начать секретный чат?</string>
+  <string name="AreYouSureRegistration">Уверены, что хотите прервать регистрацию?</string>
+  <string name="AreYouSureClearHistory">Уверены, что хотите очистить историю?</string>
+  <string name="AreYouSureDeleteMessages">Уверены, что хотите удалить %1$s?</string>
+  <string name="SendMessagesToGroup">Отправить сообщения %1$s?</string>
+  <string name="ForwardMessagesToGroup">Переслать сообщения %1$s?</string>
+  <string name="FeatureUnavailable">Извините, эта возможность пока не доступна в вашей стране.</string>
+  <!--Intro view-->
+  <string name="Page1Title">Plus Messenger</string>
+  <string name="Page2Title">Быстрый</string>
+  <string name="Page3Title">Бесплатный</string>
+  <string name="Page4Title">Безопасный</string>
+  <string name="Page5Title">Мощный</string>
+  <string name="Page6Title">Облачный</string>
+  <string name="Page7Title">Приватный</string>
+  <string name="Page1Message">Самый <![CDATA[<b>быстрый</b>]]> мессенджер в мире.<![CDATA[<br/>]]>А ещё <![CDATA[<b>бесплатный</b>]]> и <![CDATA[<b>безопасный</b>]]>.</string>
+  <string name="Page2Message"><![CDATA[<b>Plus Messenger</b>]]> доставляет сообщения быстрее, чем<![CDATA[<br/>]]>любое другое приложение.</string>
+  <string name="Page3Message"><![CDATA[<b>Plus Messenger</b>]]> бесплатный навсегда. Без рекламы.<![CDATA[<br/>]]>Без абонентской платы.</string>
+  <string name="Page4Message"><![CDATA[<b>Plus Messenger</b>]]> хранит ваши сообщения в безопасности<![CDATA[<br/>]]>от хакерских атак.</string>
+  <string name="Page5Message"><![CDATA[<b>Plus Messenger</b>]]> не имеет ограничений на размер<![CDATA[<br/>]]>ваших медиа и чатов.</string>
+  <string name="Page6Message"><![CDATA[<b>Plus Messenger</b>]]> позволяет вам получать доступ к вашим сообщениям<![CDATA[<br/>]]>на множестве устройств.</string>
+  <string name="Page7Message"><![CDATA[<b>Plus Messenger</b>]]>-сообщения надёжно зашифрованы<![CDATA[<br/>]]>и могут самоуничтожаться.</string>
+  <string name="StartMessaging">Начать общение</string>
+  <!--plural-->
+  <string name="Online_zero">%1$d в сети</string>
+  <string name="Online_one">%1$d в сети</string>
+  <string name="Online_two">%1$d в сети</string>
+  <string name="Online_few">%1$d в сети</string>
+  <string name="Online_many">%1$d в сети</string>
+  <string name="Online_other">%1$d в сети</string>
+  <string name="Members_zero">нет участников</string>
+  <string name="Members_one">%1$d участник</string>
+  <string name="Members_two">%1$d участника</string>
+  <string name="Members_few">%1$d участника</string>
+  <string name="Members_many">%1$d участников</string>
+  <string name="Members_other">%1$d участников</string>
+  <string name="AndMoreTyping_zero">и ещё %1$d набирают</string>
+  <string name="AndMoreTyping_one">и ещё %1$d набирает</string>
+  <string name="AndMoreTyping_two">и ещё %1$d набирают</string>
+  <string name="AndMoreTyping_few">и ещё %1$d набирают</string>
+  <string name="AndMoreTyping_many">и ещё %1$d набирают</string>
+  <string name="AndMoreTyping_other">и ещё %1$d набирают</string>
+  <string name="NewMessages_zero">нет новых сообщений</string>
+  <string name="NewMessages_one">%1$d новое сообщение</string>
+  <string name="NewMessages_two">%1$d новых сообщения</string>
+  <string name="NewMessages_few">%1$d новых сообщения</string>
+  <string name="NewMessages_many">%1$d новых сообщений</string>
+  <string name="NewMessages_other">%1$d новых сообщений</string>
+  <string name="messages_zero">нет сообщений</string>
+  <string name="messages_one">%1$d сообщение</string>
+  <string name="messages_two">%1$d сообщения</string>
+  <string name="messages_few">%1$d сообщения</string>
+  <string name="messages_many">%1$d сообщений</string>
+  <string name="messages_other">%1$d сообщений</string>
+  <string name="items_zero">нет элементов</string>
+  <string name="items_one">%1$d элемент</string>
+  <string name="items_two">%1$d элемента</string>
+  <string name="items_few">%1$d элемента</string>
+  <string name="items_many">%1$d элементов</string>
+  <string name="items_other">%1$d элементов</string>
+  <string name="FromChats_zero">из 0 чатов</string>
+  <string name="FromChats_one">из %1$d чата</string>
+  <string name="FromChats_two">из %1$d чатов</string>
+  <string name="FromChats_few">из %1$d чатов</string>
+  <string name="FromChats_many">из %1$d чатов</string>
+  <string name="FromChats_other">из %1$d чатов</string>
+  <string name="Seconds_zero">%1$d секунд</string>
+  <string name="Seconds_one">%1$d секунда</string>
+  <string name="Seconds_two">%1$d секунды</string>
+  <string name="Seconds_few">%1$d секунды</string>
+  <string name="Seconds_many">%1$d секунд</string>
+  <string name="Seconds_other">%1$d секунд</string>
+  <string name="Minutes_zero">%1$d минут</string>
+  <string name="Minutes_one">%1$d минута</string>
+  <string name="Minutes_two">%1$d минуты</string>
+  <string name="Minutes_few">%1$d минуты</string>
+  <string name="Minutes_many">%1$d минут</string>
+  <string name="Minutes_other">%1$d минут</string>
+  <string name="Hours_zero">%1$d часов</string>
+  <string name="Hours_one">%1$d час</string>
+  <string name="Hours_two">%1$d часа</string>
+  <string name="Hours_few">%1$d часа</string>
+  <string name="Hours_many">%1$d часов</string>
+  <string name="Hours_other">%1$d часов</string>
+  <string name="Days_zero">%1$d дней</string>
+  <string name="Days_one">%1$d день</string>
+  <string name="Days_two">%1$d дня</string>
+  <string name="Days_few">%1$d дня</string>
+  <string name="Days_many">%1$d дней</string>
+  <string name="Days_other">%1$d дней</string>
+  <string name="Weeks_zero">%1$d недель</string>
+  <string name="Weeks_one">%1$d неделя</string>
+  <string name="Weeks_two">%1$d недели</string>
+  <string name="Weeks_few">%1$d недели</string>
+  <string name="Weeks_many">%1$d недель</string>
+  <string name="Weeks_other">%1$d недель</string>
+  <string name="Months_zero">%1$d месяцев</string>
+  <string name="Months_one">%1$d месяц</string>
+  <string name="Months_two">%1$d месяца</string>
+  <string name="Months_few">%1$d месяца</string>
+  <string name="Months_many">%1$d месяцев</string>
+  <string name="Months_other">%1$d месяцев</string>
+  <string name="Years_zero">%1$d лет</string>
+  <string name="Years_one">%1$d год</string>
+  <string name="Years_two">%1$d года</string>
+  <string name="Years_few">%1$d года</string>
+  <string name="Years_many">%1$d лет</string>
+  <string name="Years_other">%1$d лет</string>
+  <string name="Users_zero">%1$d пользователей</string>
+  <string name="Users_one">%1$d пользователь</string>
+  <string name="Users_two">%1$d пользователя</string>
+  <string name="Users_few">%1$d пользователя</string>
+  <string name="Users_many">%1$d пользователей</string>
+  <string name="Users_other">%1$d пользователей</string>
+  <!--date formatters-->
+  <string name="formatterMonthYear">MMMM yyyy</string>
+  <string name="formatterMonth">MMM dd</string>
+  <string name="formatterYear">dd.MM.yy</string>
+  <string name="formatterYearMax">dd.MM.yyyy</string>
+  <string name="chatDate">MMMM d</string>
+  <string name="chatFullDate">MMMM d, yyyy</string>
+  <string name="formatterWeek">EEE</string>
+  <string name="formatterDay24H">HH:mm</string>
+  <string name="formatterDay12H">h:mm a</string>
+  <string name="formatDateAtTime">%1$s в %2$s</string>
+    <!--Telegram+ Russian-->
+    <!--Smart Notifications-->
+    <string name="SmartNotification">Умные уведомления</string>
+  <string name="TimeUnitSeconds">Секунд</string>
+  <string name="TimeUnitMinutes">Минут</string>
+  <string name="TimeUnitHours">Часов</string>
+  <string name="TimeUnitDays">Дней</string>
+  <string name="settings_smart_notify_begin">Звук чаще</string>
+  <string name="settings_smart_notify_mid1">раз</string>
+    <string name="settings_smart_notify_mid11">time</string>
+  <string name="settings_smart_notify_mid2">в течение</string>
+    <!---->
+  <string name="TelegramForAndroid">Plus Messenger для Android</string>
+  <string name="Theming">Кастомизация</string>
+  <string name="colorHexInvalid">Неверный hex-код цвета!</string>
+  <string name="themeColor">Цвет темы</string>
+  <string name="ResetThemeSettings">Сброс настроек темы</string>
+  <string name="ResetThemeSettingsSum">Отменить все изменения в теме</string>
+  <string name="ResetThemeToastText">Сбросить настройки на тему по умолчанию</string>
+  <string name="General">Основные</string>
+  <string name="Screens">Дополнительные</string>
+  <string name="MainScreen">Основной экран</string>
+  <string name="ChatScreen">Настройки экрана чата</string>
+  <string name="ContactsScreen">Настройки экрана контактов</string>
+  <string name="Header">Заголовок</string>
+  <string name="Rows">Колонки</string>
+  <string name="ChatList">Экран чата</string>
+  <string name="ChatsList">Список чатов</string>
+  <string name="ContactsList">Список контактов</string>
+  <string name="HeaderColor">Цвет заголовка</string>
+  <string name="NameColor">Цвет имени</string>
+  <string name="NameSize">Размер имени</string>
+  <string name="MessageColor">Цвет сообщения</string>
+  <string name="MessageSize">Размер сообщения</string>
+  <string name="TimeDateColor">Цвет времени/даты</string>
+  <string name="TimeDateSize">Размер времени/даты</string>
+  <string name="CountColor">Цвет счётчика сообщений</string>
+  <string name="CountSize">Размер счётчика сообщений</string>
+  <string name="RowColor">Цвет колонки</string>
+  <string name="CountBGColor">Цвет фона счётчика сообщений</string>
+  <string name="StatusColor">Цвет статуса</string>
+  <string name="StatusSize">Размер статуса</string>
+  <string name="RBubbleColor">Цвет правого пузырька сообщений</string>
+  <string name="LBubbleColor">Цвет левого пузырька сообщений</string>
+  <string name="DateColor">Цвет даты</string>
+  <string name="DateSize">Размер даты</string>
+  <string name="DateBubbleColor">Цвет пузырька даты</string>
+  <string name="RTextColor">Цвет текста cправа</string>
+  <string name="LTextColor">Цвет текста слева</string>
+  <string name="RTimeColor">Цвет времени справа</string>
+  <string name="LTimeColor">Цвет времени слева</string>
+  <string name="TimeSize">Размер времени</string>
+  <string name="EditTextColor">Цвет вводимого текста</string>
+  <string name="EditTextSize">Размер вводимого текста</string>
+  <string name="EditTextBGColor">Цвет окна ввода текста</string>
+  <string name="EmojiViewBGColor">Цвет фона Emoji</string>
+  <string name="EmojiViewTabColor">Цвет вкладок Emoji</string>
+  <string name="OnlineColor">Цвет надписи \"онлайн\"</string>
+  <string name="ChatMusic">Музыка</string>
+  <string name="SaveTheme">Сохранить тему</string>
+  <string name="SaveThemeSum">Сохраните свою тему в папку Telegram/Themes</string>
+  <string name="SaveThemeToastText">Тема сохранена!</string>
+  <string name="SavedTo">%1$s сохранено в %2$s</string>
+  <string name="SaveErrorMsg0">Тема ещё не создана. Для начала используйте любой мод</string>
+  <string name="restoreOkMsg">Настройки восстановлены с SD-карты</string>
+  <string name="restoreErrorMsg">Файл настройки не найден в %s</string>
+  <string name="NoMediaMessage">SD-карта не найдена.</string>
+  <string name="EnterName">Введите имя</string>
+  <string name="Themes">Темы</string>
+  <string name="ApplyTheme">Применить тему</string>
+  <string name="ApplyThemeSum">Установить ранее сохранённую тему</string>
+  <string name="MemberColor">Цвет ника отправителя</string>
+  <string name="ChecksColor">Цвет галочки отправлено/доставлено</string>
+  <string name="MuteColor">Цвет беззвучного режима</string>
+  <string name="SendLogs">Отправлять логи</string>
+  <string name="SendLogsEmpty">Нет логов</string>
+  <string name="SendIcon">Цвет иконки отправить</string>
+  <string name="HideMobile">Скрыть номер телефона из меню</string>
+  <string name="FloatingPencilColor">Цвет плавающего карандаша</string>
+  <string name="FloatingBGColor">Плавающий цвет фона</string>
+  <string name="Community">Сообщество Google+</string>
+  <string name="TypingColor">Цвет набирающего текст</string>
+  <string name="EditTextIconsColor">Цвет иконок в нижней панели</string>
+  <string name="NavigationDrawer">Настройки бокового меню</string>
+  <string name="OptionsList">Список дополнительных настроек меню</string>
+  <string name="ListColor">Цвет заливки бокового меню</string>
+  <string name="OwnNameSize">Размер имени</string>
+  <string name="PhoneColor">Цвет номера телефона</string>
+  <string name="PhoneSize">Размер номера телефона</string>
+  <string name="AvatarColor">Цвет аватара</string>
+  <string name="IconColor">Цвет иконок меню</string>
+  <string name="OptionColor">Цвет текста меню</string>
+  <string name="OptionSize">Размер текста меню</string>
+  <string name="VersionColor">Цвет версии приложения</string>
+  <string name="VersionSize">Размер версии приложения</string>
+  <string name="HeaderTitleColor">Цвет текста заголовка</string>
+  <string name="HeaderIconsColor">Цвет значков в заголовке</string>
+  <string name="DividerColor">Цвет разделительной линии</string>
+  <string name="AvatarRadius">Сглаживание аватара</string>
+  <string name="SetMemberColor">Установить цвет контакта</string>
+  <string name="ForwardNameColor">Цвет пересланного сообщения</string>
+  <string name="HeaderTitle">Цвет заголовка</string>
+  <string name="ForwardNoQuote">Переслать без кавычек</string>
+  <string name="DisableMessageClick">Отменить всплывающее окно при касании</string>
+  <string name="ProfileScreen">Экран Профиля Группы/Контакта</string>
+  <string name="HideBackground">Спрятать пользовательский фон</string>
+  <string name="RLinkColor">Цвет ссылки справа</string>
+  <string name="LLinkColor">Цвет ссылки слева</string>
+  <string name="ThemeApplied">Тема применена</string>
+  <string name="ClickOkToRestart">Перезагрузить приложение</string>
+  <string name="ShowAndroidEmoji">Скрыть телефонные emoji</string>
+  <string name="BubbleStyle">Bubble стиль</string>
+  <string name="KeepOriginalFilename">Оригинальные имена файлов</string>
+  <string name="KeepOriginalFilenameHelp">Сохранять файлы  \"имя отправителя_дата\"</string>
+  <string name="AvatarSize">Размер аватара</string>
+  <string name="AvatarAlignTop">Выровнять аватар по центру</string>
+  <string name="AvatarMarginLeft">Аватар с лева</string>
+  <string name="GroupNameColor">Цвет имени групп</string>
+  <string name="GroupNameSize">Размер имени групп</string>
+  <string name="UnknownNameColor">Цвет имени </string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-tr/strings.xml b/TMessagesProj/src/main/res/values-tr/strings.xml
new file mode 100644
index 000000000..1edd5a629
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-tr/strings.xml
@@ -0,0 +1,508 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<resources>
+  <string name="AppName">Plus Messenger</string>
+  <string name="LanguageName">Türkçe</string>
+  <string name="LanguageNameInEnglish">Türkçe</string>
+  <string name="LanguageCode">tr</string>
+  <!--signin view-->
+  <string name="YourPhone">Telefonunuz</string>
+  <string name="ChooseCountry">Bir ülke seçin</string>
+  <string name="WrongCountry">Yanlış ülke kodu</string>
+  <!--code enter view-->
+  <string name="YourCode">Kodunuz</string>
+  <string name="SentSmsCode">Telefonunuza bir etkinleştirme mesajı gönderdik</string>
+  <string name="Calling">Sizi arıyoruz...</string>
+  <string name="Code">Kod</string>
+  <string name="WrongNumber">Numara yanlış mı?</string>
+  <string name="DidNotGetTheCode">Kodu almadınız mı?</string>
+  <!--signup view-->
+  <string name="YourName">Adınız</string>
+  <string name="RegisterText">Adınızı ve soyadınızı ayarlayın</string>
+  <!--<string name="RegisterText">Set up your name and picture</string>-->
+  <string name="FirstName">Adınız (gerekli)</string>
+  <string name="LastName">Soyadınız (isteğe bağlı)</string>
+  <string name="CancelRegistration">Kaydı iptal et</string>
+  <!--chats view-->
+  <string name="Settings">Ayarlar</string>
+  <string name="Contacts">Kişiler</string>
+  <string name="NewGroup">Yeni Grup</string>
+  <string name="Yesterday">dün</string>
+  <string name="NoResult">Sonuç yok</string>
+  <string name="NoChats">Henüz sohbet yok...</string>
+  <string name="WaitingForNetwork">Bağlantı bekleniyor...</string>
+  <string name="Connecting">Bağlanılıyor...</string>
+  <string name="Updating">Güncelleniyor...</string>
+  <string name="NewSecretChat">Yeni Gizli Sohbet</string>
+  <string name="AwaitingEncryption">%s kişisinin çevrimiçi olması bekleniyor...</string>
+  <string name="EncryptionRejected">Gizli sohbet iptal edildi</string>
+  <string name="EncryptionProcessing">Şifreleme anahtarı değiştiriliyor...</string>
+  <string name="EncryptedChatStartedOutgoing">%s gizli sohbetinize katıldı.</string>
+  <string name="EncryptedChatStartedIncoming">Gizli sohbete katıldınız.</string>
+  <string name="ClearHistory">Geçmişi temizle</string>
+  <string name="DeleteChat">Sil ve çık</string>
+  <string name="DeleteChatUser">Sohbeti sil</string>
+  <string name="SelectChat">Sohbet Seç</string>
+  <string name="SearchMessages">MESAJLAR</string>
+  <string name="Search">Ara</string>
+  <!--broadcasts-->
+  <string name="NewBroadcastList">Yeni Yayın Listesi</string>
+  <string name="EnterListName">Liste adı girin</string>
+  <string name="YouCreatedBroadcastList">Bir yayın listesi oluşturdunuz</string>
+  <string name="AddRecipient">Alıcı ekle</string>
+  <string name="KickFromBroadcast">Yayın listesinden kaldır</string>
+  <!--documents view-->
+  <string name="SelectFile">Dosya Seç</string>
+  <string name="FreeOfTotal">%1$s - %2$s</string>
+  <string name="UnknownError">Bilinmeyen hata</string>
+  <string name="AccessError">Erişim hatası</string>
+  <string name="NoFiles">Henüz dosya yok...</string>
+  <string name="FileUploadLimit">Dosya boyutu %1$s değerinden büyük olmamalıdır</string>
+  <string name="NotMounted">Depolama bağlı değil</string>
+  <string name="UsbActive">Usb bağlantısı etkin</string>
+  <string name="InternalStorage">Dahili Hafıza</string>
+  <string name="ExternalStorage">Harici Hafıza</string>
+  <string name="SystemRoot">Sistem Dizini</string>
+  <string name="SdCard">SD Kart</string>
+  <string name="Folder">Klasör</string>
+  <!--chat view-->
+  <string name="Invisible">görünmez</string>
+  <string name="Typing">yazıyor...</string>
+  <string name="IsTyping">yazıyor...</string>
+  <string name="AreTyping">yazıyorlar...</string>
+  <string name="ChatTakePhoto">Fotoğraf çek</string>
+  <string name="ChatGallery">Galeri</string>
+  <string name="ChatLocation">Konum</string>
+  <string name="ChatVideo">Video</string>
+  <string name="NoMessages">Henüz mesaj gönderilmemiş...</string>
+  <string name="ForwardedMessage">Mesaj iletildi</string>
+  <string name="From">Kimden</string>
+  <string name="NoRecent">Yeni yok</string>
+  <string name="Message">Mesaj</string>
+  <string name="TypeMessage">Mesaj</string>
+  <string name="EncryptedPlaceholderTitleIncoming">%s sizi gizli sohbete katılmaya davet etti.</string>
+  <string name="EncryptedPlaceholderTitleOutgoing">%s gizli sohbete katılmaya davet ettiniz.</string>
+  <string name="EncryptedDescriptionTitle">Gizli sohbetler:</string>
+  <string name="EncryptedDescription1">Şifreleme kullan</string>
+  <string name="EncryptedDescription2">Sunucularda iz bırakma</string>
+  <string name="EncryptedDescription3">Kendini yok etme zamanlayıcısı kur</string>
+  <string name="EncryptedDescription4">İletmeye izin verme</string>
+  <string name="YouWereKicked">Bu gruptan atıldınız</string>
+  <string name="YouLeft">Gruptan ayrıldınız</string>
+  <string name="DeleteThisGroup">Bu grubu sil</string>
+  <string name="DeleteThisChat">Bu sohbeti sil</string>
+  <string name="SlideToCancel">İPTAL ETMEK İÇİN KAYDIRIN</string>
+  <string name="SaveToDownloads">İndirilenleri kaydet</string>
+  <string name="ApplyLocalizationFile">Dosya yerleştirmeyi uygula</string>
+  <string name="UnsupportedAttachment">Desteklenmeyen eklenti</string>
+  <!--notification-->
+  <string name="MessageLifetimeChanged">%1$s kendini yok etme zamanlayıcısı %2$s olarak belirledi</string>
+  <string name="MessageLifetimeChangedOutgoing">Kendini yok etme zamanlayıcısını %1$s olarak belirlediniz</string>
+  <string name="MessageLifetimeRemoved">%1$s kendini yok etme zamanlayıcısını kapattı</string>
+  <string name="MessageLifetimeYouRemoved">Kendini yok etme zamanlayıcısını kapattınız</string>
+  <string name="YouHaveNewMessage">Yeni bir mesajınız var</string>
+  <string name="NotificationMessageText">%1$s: %2$s</string>
+  <string name="NotificationMessageNoText">%1$s size bir mesaj gönderdi</string>
+  <string name="NotificationMessagePhoto">%1$s size bir fotoğraf gönderdi</string>
+  <string name="NotificationMessageVideo">%1$s size bir video gönderdi</string>
+  <string name="NotificationMessageContact">%1$s sizinle bir kişi paylaştı</string>
+  <string name="NotificationMessageMap">%1$s size bir konum gönderdi</string>
+  <string name="NotificationMessageAudio">%1$s size bir ses gönderdi</string>
+  <string name="NotificationMessageGroupText">%1$s @ %2$s: %3$s</string>
+  <string name="NotificationMessageGroupNoText">%1$s, %2$s grubuna bir mesaj gönderdi</string>
+  <string name="NotificationMessageGroupPhoto">%1$s, %2$s grubuna bir fotoğraf gönderdi</string>
+  <string name="NotificationMessageGroupVideo">%1$s, %2$s grubuna bir video gönderdi</string>
+  <string name="NotificationMessageGroupContact">%1$s, %2$s grubunda bir kişi paylaştı</string>
+  <string name="NotificationMessageGroupMap">%1$s %2$s grubuna bir konum gönderdi</string>
+  <string name="NotificationMessageGroupAudio">%1$s, %2$s grubuna bir ses gönderdi</string>
+  <string name="NotificationInvitedToGroup">%1$s, sizi %2$s grubuna davet etti</string>
+  <string name="NotificationEditedGroupName">%1$s grubun adını %2$s olarak değiştirdi</string>
+  <string name="NotificationEditedGroupPhoto">%1$s grubun fotoğrafını %2$s olarak değiştirdi</string>
+  <string name="NotificationGroupAddMember">%1$s, %3$s kişisini %2$s grubuna davet etti</string>
+  <string name="NotificationGroupKickMember">%1$s %3$s kişisini %2$s grubundan attı</string>
+  <string name="NotificationGroupKickYou">%1$s sizi %2$s grubundan attı</string>
+  <string name="NotificationGroupLeftMember">%1$s, %2$s grubundan ayrıldı</string>
+  <string name="NotificationContactJoined">%1$s Telegram\'a katıldı!</string>
+  <string name="NotificationContactNewPhoto">%1$s profil fotoğrafını güncelledi</string>
+  <string name="Reply">Cevap</string>
+  <!--contacts view-->
+  <string name="SelectContact">Kişi Seç</string>
+  <string name="NoContacts">Henüz kişi yok</string>
+  <string name="YesterdayAt">dün</string>
+  <string name="Online">çevrimiçi</string>
+  <string name="LastSeen">son görülme</string>
+  <string name="LastSeenDate">son görülme</string>
+  <string name="InviteFriends">Arkadaşlarını Davet Et</string>
+  <string name="GlobalSearch">EVRENSEL ARAMA</string>
+  <!--group create view-->
+  <string name="SendMessageTo">Mesaj gönder...</string>
+  <string name="EnterGroupNamePlaceholder">Grup adını girin</string>
+  <string name="GroupName">Grup adı</string>
+  <string name="MembersCount">%1$d/%2$d üye</string>
+  <!--group info view-->
+  <string name="SharedMedia">Paylaşılan İçerik</string>
+  <string name="AddMember">Üye ekle</string>
+  <string name="DeleteAndExit">Sil ve gruptan ayrıl</string>
+  <string name="Notifications">Bildirimler</string>
+  <string name="KickFromGroup">Gruptan kaldır</string>
+  <!--contact info view-->
+  <string name="ShareContact">Paylaş</string>
+  <string name="AddContact">Ekle</string>
+  <string name="BlockContact">Engelle</string>
+  <string name="EditContact">Düzenle</string>
+  <string name="DeleteContact">Sil</string>
+  <string name="StartEncryptedChat">Gizli Sohbet Başlat</string>
+  <string name="CreateEncryptedChatError">Bir hata oluştu.</string>
+  <string name="EncryptionKey">Şifreleme Anahtarı</string>
+  <string name="MessageLifetime">Kendini yok etme zamanlayıcı</string>
+  <string name="ShortMessageLifetimeForever">Kapalı</string>
+  <string name="EncryptionKeyDescription">Bu resim <![CDATA[<b>]]>%1$s<![CDATA[</b>]]> ile yapılan bu gizli konuşmanın şifreleme anahtarının bir görselleştirmesidir.<![CDATA[<br><br>]]>Eğer resim <![CDATA[<b>]]>%2$s<![CDATA[</b>]]> kişisinin cihazında da tamamen aynı görünüyorsa, sohbetiniz %%200 güvenli demektir.<![CDATA[<br><br>]]>Daha fazla bilgi için telegram.org</string>
+  <string name="NumberUnknown">Bilinmeyen</string>
+  <string name="Phone">Telefon</string>
+  <!--usernames-->
+  <string name="Username">Kullanıcı adı</string>
+  <string name="UsernamePlaceholder">Kullanıcı Adınız</string>
+  <!--settings view-->
+  <string name="ResetNotificationsText">Tüm bildirim ayarlarını varsayılana sıfırla</string>
+  <string name="TextSize">Mesaj Yazı Boyutu</string>
+  <string name="AskAQuestion">Bir Soru Sor</string>
+  <string name="EnableAnimations">Animasyonları Etkinleştir</string>
+  <string name="Unblock">Engeli kaldır</string>
+  <string name="UnblockText">Engeli kaldırmak için kullanıcıya dokunun ve bekleyin.</string>
+  <string name="NoBlocked">Henüz engelli kullanıcı yok</string>
+  <string name="Alert">Uyarı</string>
+  <string name="MessagePreview">Mesaj Ön İzlemesi</string>
+  <string name="Sound">Ses</string>
+  <string name="InAppSounds">Sesler</string>
+  <string name="InAppVibrate">Titreşim</string>
+  <string name="Vibrate">Titreşim</string>
+  <string name="InAppPreview">Uygulama İçi Ön İzleme</string>
+  <string name="Reset">Sıfırla</string>
+  <string name="ResetAllNotifications">Tüm Bildirimleri Sıfırla</string>
+  <string name="UndoAllCustom">Tüm kişi ve gruplarınız için yapılan bildirim ayarlarını geri alın</string>
+  <string name="NotificationsAndSounds">Bildirimler ve Sesler</string>
+  <string name="BlockedUsers">Engellenen Kullanıcılar</string>
+  <string name="NoSound">Ses yok</string>
+  <string name="Default">Varsayılan</string>
+  <string name="Support">Destek</string>
+  <string name="ChatBackground">Sohbet Arka Planı</string>
+  <string name="SendByEnter">Giriş (Enter) Tuşu ile Gönderir</string>
+  <string name="TerminateAllSessions">Diğer tüm oturumları kapat</string>
+  <string name="ContactJoined"> Kişi Telegram\'a katıldı!</string>
+  <string name="Pebble">PEBBLE</string>
+  <string name="Language">Dil</string>
+  <string name="AskAQuestionInfo">Lütfen unutmayın ki Telegram Desteği gönüllüler tarafında yapılır. Olabildiğince hızlı cevap çalışıyoruz, ama biraz zaman alabilir.<![CDATA[<br><br>]]>Lütfen bir göz atın <![CDATA[<a href=\"http://telegram.org/faq#general\">Telegram Sık Srulan Sorular</a>]]>: bir çok sorunun cevapları ve önemli ipuçları için vardır <![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">sorun giderme</a>]]>.</string>
+  <string name="AskButton">Bir gönüllü sor</string>
+  <string name="TelegramFaq">Telegram Sık Sorulan Sorular</string>
+  <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+  <string name="DeleteLocalization">Yerelleştirme silinsin mi?</string>
+  <string name="IncorrectLocalization">Yanlış yerelleştirme dosyası</string>
+  <string name="Enabled">Etkin</string>
+  <string name="Disabled">Devre dışı</string>
+  <string name="NotificationsService">Bildirim Servisi</string>
+  <string name="NotificationsServiceDisableInfo">Eğer Google Play Hizmetleri bildirim almanız için yeterliyse, Bildirim Servisi\'ni devredışı bırakabilirsiniz. Yine de, uygulamanın arka planda çalışması ve anlık bildirim almanız için etkin bırakmanızı öneririz.</string>
+  <string name="SortBy">Sırala</string>
+  <string name="ImportContacts">Kişileri Aktar</string>
+  <string name="SortFirstName">Adınız</string>
+  <string name="SortLastName">Soyadınız</string>
+  <string name="LedColor">LED Rengi</string>
+  <string name="PopupNotification">Açılır Pencere Bildirimleri</string>
+  <string name="NoPopup">Açılır pencere yok</string>
+  <string name="OnlyWhenScreenOn">Yalnızca ekran \"açık\" olduğunda</string>
+  <string name="OnlyWhenScreenOff">Yalnızca ekran \"kapalı\" olduğunda</string>
+  <string name="AlwaysShowPopup">Açılır pencereleri her zaman göster</string>
+  <string name="BadgeNumber">Rozet Sayacı</string>
+  <string name="Short">Kısa</string>
+  <string name="Long">Uzun</string>
+  <string name="SystemDefault">Varsyılan</string>
+  <string name="SettingsDefault">Varsayılan ayarlar</string>
+  <string name="WhenUsingMobileData">Mobil veri kullanıldığında</string>
+  <string name="WhenConnectedOnWiFi">Wi-Fi kullanıldığında</string>
+  <string name="WhenRoaming">Dolaşımdayken</string>
+  <string name="NoMediaAutoDownload">Medya Yok</string>
+  <string name="SaveToGallerySettings">Galeriye kaydet</string>
+  <string name="NotificationsPriorityDefault">Varsayılan</string>
+  <string name="RepeatNotificationsNever">Asla</string>
+  <string name="ChangePhoneNewNumber">Yeni numara</string>
+  <string name="NotificationsOther">Diğer</string>
+  <!--passcode view-->
+  <!--media view-->
+  <!--map view-->
+  <string name="Map">Harita</string>
+  <string name="Satellite">Uydu</string>
+  <string name="Hybrid">Hibrit (Uydu + Harita)</string>
+  <string name="MetersAway">m uzak</string>
+  <string name="KMetersAway">km uzak</string>
+  <string name="SendLocation">Konumu Gönder</string>
+  <string name="ShareLocation">Konumu Paylaş</string>
+  <!--photo gallery view-->
+  <string name="ShowAllMedia">Tüm içeriği göster</string>
+  <string name="SaveToGallery">Galeriye kaydet</string>
+  <string name="Of">%1$d - %2$d</string>
+  <string name="Gallery">Galeri</string>
+  <string name="AllPhotos">Tüm Fotoğraflar</string>
+  <string name="NoPhotos">Henüz fotoğraf yok</string>
+  <!--privacy settings-->
+  <string name="PrivacyTitle">Gizlilik</string>
+  <string name="PrivacyLastSeen">Son Görülme</string>
+  <string name="LastSeenEverybody">Herkes</string>
+  <string name="LastSeenContacts">Kişilerim</string>
+  <string name="LastSeenNobody">Hiç kimse</string>
+  <string name="SecurityTitle">Güvenlik</string>
+  <string name="DeleteAccountNowConfirmation">Hesabınız silinsin mi?</string>
+  <!--edit video view-->
+  <string name="EditVideo">Videoyu Düzenle</string>
+  <string name="OriginalVideo">Orijinal Video</string>
+  <string name="EditedVideo">Düzenlenmiş Video</string>
+  <!--button titles-->
+  <string name="Next">İleri</string>
+  <string name="Back">Geri</string>
+  <string name="Done">Bitti</string>
+  <string name="Open">Aç</string>
+  <string name="Cancel">İptal</string>
+  <string name="Add">Ekle</string>
+  <string name="Edit">Düzenle</string>
+  <string name="Send">Gönder</string>
+  <string name="Call">Ara</string>
+  <string name="Copy">Kopyala</string>
+  <string name="Delete">Sil</string>
+  <string name="Forward">İlet</string>
+  <string name="Retry">Tekrar dene</string>
+  <string name="FromCamera">Kameradan</string>
+  <string name="FromGalley">Galeriden</string>
+  <string name="DeletePhoto">Fotoğrafı sil</string>
+  <string name="Set">Ayarla</string>
+  <string name="OK">Tamam</string>
+  <!--messages-->
+  <string name="ActionKickUser">un1, un2 kaldırdı</string>
+  <string name="ActionLeftUser">un1 gruptan ayrıldı</string>
+  <string name="ActionAddUser">un1, un2 kişisini ekledi</string>
+  <string name="ActionRemovedPhoto">un1 grup resmi kaldırıldı</string>
+  <string name="ActionChangedPhoto">un1 grup resmini değiştirdi</string>
+  <string name="ActionChangedTitle">un1 grup adını un2 olarak değiştirdi</string>
+  <string name="ActionCreateGroup">un1 grubu oluşturdu</string>
+  <string name="ActionYouKickUser">un2 kaldırıldı</string>
+  <string name="ActionYouLeftUser">Gruptan ayrıldınız</string>
+  <string name="ActionYouAddUser">un2 kişisini eklediniz</string>
+  <string name="ActionYouRemovedPhoto">Grup resmi kaldırıldı</string>
+  <string name="ActionYouChangedPhoto">Grup resmi değiştirildi</string>
+  <string name="ActionYouChangedTitle">Grup adı un2 olarak değiştirildi</string>
+  <string name="ActionYouCreateGroup">Grubu oluşturdunuz</string>
+  <string name="ActionKickUserYou">un1 kaldırıldı</string>
+  <string name="ActionAddUserYou">un1 sizi ekledi</string>
+  <string name="UnsuppotedMedia">Bu mesaj Telegram sürümünüz tarafından desteklenmiyor. Uyg. güncellemelerini görmek için: http://telegram.org/update</string>
+  <string name="AttachPhoto">Fotoğraf</string>
+  <string name="AttachVideo">Video</string>
+  <string name="AttachLocation">Konum</string>
+  <string name="AttachContact">Kişi</string>
+  <string name="AttachAudio">Ses</string>
+  <string name="FromYou">Siz</string>
+  <string name="ActionTakeScreenshootYou">Ekran görüntüsü aldınız!</string>
+  <string name="ActionTakeScreenshoot">un1 bir ekran görüntüsü aldı!</string>
+  <!--Alert messages-->
+  <string name="InvalidPhoneNumber">Geçersiz telefon numarası</string>
+  <string name="CodeExpired">Kodun süresi doldu, lütfen tekrar oturum açın</string>
+  <string name="FloodWait">Çok fazla giriş yaptınız, lütfen daha sonra tekrar deneyin</string>
+  <string name="InvalidCode">Geçersiz kod</string>
+  <string name="InvalidFirstName">Geçersiz ad</string>
+  <string name="InvalidLastName">Geçersiz soyad</string>
+  <string name="Loading">Yükleniyor...</string>
+  <string name="NoPlayerInstalled">Video oynatıcı yok, lütfen devam etmek için bir tane yükleyin</string>
+  <string name="NoMailInstalled">Lütfen sms@telegram.org adresine bir posta gönderin ve bize sorununuzu anlatın.</string>
+  <string name="NoHandleAppInstalled">\'%1$s\' dosya türünü destekleyen uygulamanız yok, devam etmek için lütfen bir yane yükleyin</string>
+  <string name="InviteUser">Bu kullanıcı henüz Telegram kullanmıyor, davet gönderilsin mi?</string>
+  <string name="AreYouSure">Emin misiniz?</string>
+  <string name="ForwardMessagesTo">Mesajlar %1$s kişisine iletilsin mi?</string>
+  <string name="SendMessagesTo">%1$s kişisine mesajlar gönderilsin mi?</string>
+  <string name="AreYouSureSessions">Diğer tüm oturumları sonlandırmak istediğinizden emin misiniz?</string>
+  <string name="AreYouSureDeleteAndExit">Grubu silmek ve gruptan ayrılmak istediğinize emin misiniz?</string>
+  <string name="AreYouSureDeleteThisChat">Bu sohbeti silmek istediğinizden emin misiniz?</string>
+  <string name="AreYouSureShareMyContactInfo">İletişim bilgilerinizi paylaşmak istediğinize emin misiniz?</string>
+  <string name="AreYouSureBlockContact">Bu kişiyi engellemek istediğinizden emin misiniz?</string>
+  <string name="AreYouSureUnblockContact">Bu kişinin engelini kaldırmak istediğinizden emin misiniz?</string>
+  <string name="AreYouSureDeleteContact">Bu kişiyi silmek istediğinizden emin misiniz?</string>
+  <string name="AreYouSureSecretChat">Bir gizli sohbet başlatmak istediğinizden emin misiniz?</string>
+  <!--Intro view-->
+  <string name="Page1Title">Plus Messenger</string>
+  <string name="Page2Title">Hızlı</string>
+  <string name="Page3Title">Ücretsiz</string>
+  <string name="Page4Title">Güvenli</string>
+  <string name="Page5Title">Güçlü</string>
+  <string name="Page6Title">Bulut Tabanlı</string>
+  <string name="Page7Title">Özel</string>
+  <string name="StartMessaging">Mesajlaşmaya Başlayın</string>
+  <!--plural-->
+  <string name="Online_zero">%1$d çevrimiçi</string>
+  <string name="Online_one">%1$d çevrimiçi</string>
+  <string name="Online_two">%1$d çevrimiçi</string>
+  <string name="Online_few">%1$d çevrimiçi</string>
+  <string name="Online_many">%1$d çevrimiçi</string>
+  <string name="Online_other">%1$d çevrimiçi</string>
+  <string name="Members_zero">üye yok</string>
+  <string name="Members_one">%1$d üye</string>
+  <string name="Members_two">%1$d üye</string>
+  <string name="Members_few">%1$d üye</string>
+  <string name="Members_many">%1$d üye</string>
+  <string name="Members_other">%1$d üye</string>
+  <string name="AndMoreTyping_zero">ve %1$d\'den fazla insan yazıyor</string>
+  <string name="AndMoreTyping_one">ve %1$d\'den fazla insan yazıyor</string>
+  <string name="AndMoreTyping_two">ve %1$d\'den fazla insan yazıyor</string>
+  <string name="AndMoreTyping_few">ve %1$d\'den fazla insan yazıyor</string>
+  <string name="AndMoreTyping_many">ve %1$d\'den fazla insan yazıyor</string>
+  <string name="AndMoreTyping_other">ve %1$d\'den fazla insan yazıyor</string>
+  <string name="NewMessages_zero">yeni mesaj yok</string>
+  <string name="NewMessages_one">%1$d yeni mesaj</string>
+  <string name="NewMessages_two">%1$d yeni mesaj</string>
+  <string name="NewMessages_few">%1$d yeni mesaj</string>
+  <string name="NewMessages_many">%1$d yeni mesaj</string>
+  <string name="NewMessages_other">%1$d yeni mesaj</string>
+  <string name="messages_zero">mesaj yok</string>
+  <string name="messages_one">%1$d mesaj</string>
+  <string name="messages_two">%1$d mesaj</string>
+  <string name="messages_few">%1$d mesaj</string>
+  <string name="messages_many">%1$d mesaj</string>
+  <string name="messages_other">%1$d mesaj</string>
+  <string name="Seconds_zero">%1$d saniye</string>
+  <string name="Seconds_one">%1$d saniye</string>
+  <string name="Seconds_two">%1$d saniye</string>
+  <string name="Seconds_few">%1$d saniye</string>
+  <string name="Seconds_many">%1$d saniye</string>
+  <string name="Seconds_other">%1$d saniye</string>
+  <string name="Minutes_zero">%1$d dakika</string>
+  <string name="Minutes_one">%1$d dakika</string>
+  <string name="Minutes_two">%1$d dakika</string>
+  <string name="Minutes_few">%1$d dakika</string>
+  <string name="Minutes_many">%1$d dakika</string>
+  <string name="Minutes_other">%1$d dakika</string>
+  <string name="Hours_zero">%1$d saat</string>
+  <string name="Hours_one">%1$d saat</string>
+  <string name="Hours_two">%1$d saat</string>
+  <string name="Hours_few">%1$d saat</string>
+  <string name="Hours_many">%1$d saat</string>
+  <string name="Hours_other">%1$d saat</string>
+  <string name="Days_zero">%1$d gün</string>
+  <string name="Days_one">%1$d gün</string>
+  <string name="Days_two">%1$d gün</string>
+  <string name="Days_few">%1$d gün</string>
+  <string name="Days_many">%1$d gün</string>
+  <string name="Days_other">%1$d gün</string>
+  <string name="Weeks_zero">%1$d hafta</string>
+  <string name="Weeks_one">%1$d hafta</string>
+  <string name="Weeks_two">%1$d hafta</string>
+  <string name="Weeks_few">%1$d hafta</string>
+  <string name="Weeks_many">%1$d hafta</string>
+  <string name="Weeks_other">%1$d hafta</string>
+  <!--date formatters-->
+  <string name="formatterDay24H">SS:dd</string>
+  <!--Telegram+ Turkish-->
+      <!--update-->
+  <string name="updatePlusText">\n\n2.8.1.3\'deki Yenilikler:\n\n- Baloncuk tarzını değiştirmek için yeni MOD eklendi\n- Ayarlara kaydedilen dosyaların orijinal dosya adını kullanma opsiyonu eklendi\n- Sohbete galeriden sticker gönderme opsiyonu eklendi\n- Ana ekranda ve sohbet ekranında avatar boyutunu değiştirmek için yeni MOD eklendi \n- Ana ekranda ve sohbet ekranında sol avatar boşluğunu değiştirmek için MOD eklendi\n- Sohbet ekranında avatarı üste veya alta hizalama opsiyonu eklendi\n- Ana ekranda grup ismini ve boyutunu değiştirmek için yeni MOD eklendi\n- Bilinmeyen numaraların rengini değiştirmek için yeni MOD eklendi\n- Hata düzeltmeleri</string>
+  <!--update-->
+  <string name="TelegramForAndroid">Android için Plus Messenger</string>
+  <string name="Theming">Tema</string>
+  <string name="colorHexInvalid">Geçersiz renk hex kodu!</string>
+  <string name="themeColor">Tema Rengi</string>
+  <string name="ResetThemeSettings">Tema Ayarlarını Sıfırla</string>
+  <string name="ResetThemeSettingsSum">Tüm tema ayarlarını sıfırla</string>
+  <string name="ResetThemeToastText">Tüm tema ayarları sıfırlandı!</string>
+  <string name="General">Genel</string>
+  <string name="Screens">Ekranlar</string>
+  <string name="MainScreen">Ana Ekran</string>
+  <string name="ChatScreen">Sohbet Ekranı</string>
+  <string name="ContactsScreen">Kişiler Ekranı</string>
+  <string name="Header">Başlık</string>
+  <string name="Rows">Satırlar</string>
+  <string name="ChatList">Sohbet Listesi</string>
+  <string name="ChatsList">Sohbet Listesi</string>
+  <string name="ContactsList">Kişiler Listesi</string>
+  <string name="HeaderColor">Başlık Rengi</string>
+  <string name="NameColor">İsim Rengi</string>
+  <string name="NameSize">İsim Boyutu</string>
+  <string name="MessageColor">Mesaj Rengi</string>
+  <string name="MessageSize">Mesaj Boyutu</string>
+  <string name="TimeDateColor">Saat/Tarih Rengi</string>
+  <string name="TimeDateSize">Saat/Tarih Boyutu</string>
+  <string name="CountColor">Sayaç Rengi</string>
+  <string name="CountSize">Sayaç Boyutu</string>
+  <string name="RowColor">Satır Rengi</string>
+  <string name="CountBGColor">Sayaç Arkaplan Rengi</string>
+  <string name="StatusColor">Durum Rengi</string>
+  <string name="StatusSize">Durum Boyutu</string>
+  <string name="RBubbleColor">Sağ Baloncuk Rengi</string>
+  <string name="LBubbleColor">Sol Baloncuk Rengi</string>
+  <string name="DateColor">Tarih Rengi</string>
+  <string name="DateSize">Tarih Boyutu</string>
+  <string name="DateBubbleColor">Tarih Baloncuğu Rengi</string>
+  <string name="RTextColor">Sağ yazı rengi</string>
+  <string name="LTextColor">Sol Yazı Rengi</string>
+  <string name="RTimeColor">Sağ Saat Rengi</string>
+  <string name="LTimeColor">Sol Saat Rengi</string>
+  <string name="TimeSize">Saat Boyutu</string>
+  <string name="EditTextColor">Yazı Giriş Rengi</string>
+  <string name="EditTextSize">Yazı Giriş Boyutu</string>
+  <string name="EditTextBGColor">Yazı Giriş Arkaplan Rengi</string>
+  <string name="EmojiViewBGColor">Emoji Arkaplan Rengi</string>
+  <string name="EmojiViewTabColor">Emoji Sekme Rengi</string>
+  <string name="OnlineColor">Çevrimiçi Rengi</string>
+  <string name="ChatMusic">Müzik</string>
+  <string name="SaveTheme">Temayı Kaydet</string>
+  <string name="SaveThemeSum">Temayı Telegram/Themes klasörüne kaydet</string>
+  <string name="SaveThemeToastText">Tema Kaydedildi!</string>
+  <string name="SavedTo">%1$s dosyası %2$s klasörüne kaydedildi </string>
+  <string name="SaveErrorMsg0">Tema henüz oluşturulmadı. Lütfen önce herhangi bir modu uygulayın.</string>
+  <string name="restoreOkMsg">Tercihler SD karttan geri yüklendi</string>
+  <string name="restoreErrorMsg">%s klasöründe tercih dosyası bulunamadı</string>
+  <string name="NoMediaMessage">SD kart bulunamadı.</string>
+  <string name="EnterName">İsim Giriniz</string>
+  <string name="Themes">Temalar</string>
+  <string name="ApplyTheme">Temayı Uygula</string>
+  <string name="ApplyThemeSum">Yerel klasörden xml temayı uygula</string>
+  <string name="MemberColor">Üye rengi</string>
+  <string name="ChecksColor">Tik Rengi</string>
+  <string name="MuteColor">Sessiz Rengi</string>
+  <string name="SendLogs">Logları Gönder</string>
+  <string name="SendLogsEmpty">Log bulunmamakta</string>
+  <string name="SendIcon">Simge Gönder</string>
+  <string name="HideMobile">Telefon Numaranı Gizle</string>
+  <string name="FloatingPencilColor">Float Buton Kalem Rengi</string>
+  <string name="FloatingBGColor">Float Buton Arkaplan Rengi</string>
+  <string name="Community">G+ Topluluğu</string>
+  <string name="TypingColor">Yazıyor...  rengi</string>
+  <string name="EditTextIconsColor">Yazı giriş simgeleri rengi</string>
+  <string name="NavigationDrawer">Sol Menü</string>
+  <string name="OptionsList">Seçenekler listesi</string>
+  <string name="ListColor">Liste rengi</string>
+  <string name="OwnNameSize">İsim Boyutu</string>
+  <string name="PhoneColor">Telefon numarası rengi</string>
+  <string name="PhoneSize">Telefon numarası boyutu</string>
+  <string name="AvatarColor">Avatar rengi</string>
+  <string name="IconColor">Seçenek simge rengi</string>
+  <string name="OptionColor">Seçenek rengi</string>
+  <string name="OptionSize">Seçenek boyutu</string>
+  <string name="VersionColor">Versiyon rengi</string>
+  <string name="VersionSize">Versiyon Boyutu</string>
+  <string name="HeaderTitleColor">Başlık yazısı rengi</string>
+  <string name="HeaderIconsColor">Başlık simgesi rengi</string>
+  <string name="DividerColor">Ayırıcı rengi</string>
+  <string name="AvatarRadius">Avatar köşeleri keskinliği</string>
+  <string name="SetMemberColor">Üye rengini ayarla</string>
+  <string name="ForwardNameColor">İletilen mesaj sahibi rengi</string>
+  <string name="HeaderTitle">Başlık yazısı</string>
+  <string name="ForwardNoQuote">Alıntı yapmadan ilet</string>
+  <string name="DisableMessageClick">Tıklayınca pop-up penceresi gelmesin</string>
+  <string name="ProfileScreen">Grup/Kişi Profili</string>
+  <string name="HideBackground">Özelleştirilmiş arkaplanı gizle</string>
+  <string name="RLinkColor">Sağ Link Rengi</string>
+  <string name="LLinkColor">Sol Link Rengi</string>
+  <string name="ThemeApplied">Tema uygulandı!</string>
+  <string name="ClickOkToRestart">Uygulamayı yeniden başlatmak için Tamam\'a tıklayın</string>
+  <string name="ShowAndroidEmoji">Telefon emojilerini göster</string>
+  <string name="BubbleStyle">Baloncuk stili</string>
+  <string name="KeepOriginalFilename">Orijinal dosya ismini tut</string>
+  <string name="KeepOriginalFilenameHelp">Dosyalar sadece sayısal değer yerine isim_tarih şeklinde isimlendirilerek kaydedilecek</string>
+  <string name="AvatarSize">Avatar Boyutu</string>
+  <string name="AvatarAlignTop">Avatarı Üste Hizala</string>
+  <string name="AvatarMarginLeft">Avatar Sol Kenar Boşluğu</string>
+  <string name="GroupNameColor">Grup İsim Rengi</string>
+  <string name="GroupNameSize">Grup İsim Boyutu</string>
+  <string name="UnknownNameColor">İsim Rengi (Bilinmeyen Numara)</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-zh-rCN/strings.xml b/TMessagesProj/src/main/res/values-zh-rCN/strings.xml
new file mode 100644
index 000000000..06aa14968
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-zh-rCN/strings.xml
@@ -0,0 +1,685 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<resources>
+        <string name="AppName">Plus Messenger</string>
+        <string name="LanguageName">简体中文</string>
+        <string name="LanguageNameInEnglish">Simplified Chinese</string>
+        <string name="LanguageCode">zh_CN</string>
+        <!--signin view-->
+        <string name="YourPhone">您的手机号</string>
+        <string name="StartText">请确认您的国家码并输入您的手机号</string>
+        <string name="ChooseCountry">选择您的国家</string>
+        <string name="WrongCountry">国家代码错误</string>
+        <!--code enter view-->
+        <string name="YourCode">验证码</string>
+        <string name="SentSmsCode">我们已通过短信将验证码发送至您的手机</string>
+        <string name="CallText">我们将会在 %1$d:%2$02d 后呼叫您的号码</string>
+        <string name="Calling">正在呼叫您的号码...</string>
+        <string name="Code">验证码</string>
+        <string name="WrongNumber">号码错了?</string>
+        <string name="DidNotGetTheCode">没收到验证码?</string>
+        <!--signup view-->
+        <string name="YourName">您的姓名</string>
+        <string name="RegisterText">设置您的姓名</string>
+        <!--<string name="RegisterText">Set up your name and picture</string>-->
+        <string name="FirstName">名 (必填)</string>
+        <string name="LastName">姓 (选填)</string>
+        <string name="CancelRegistration">取消注册</string>
+        <!--chats view-->
+        <string name="Settings">设置</string>
+        <string name="Contacts">联系人</string>
+        <string name="NewGroup">新的群聊</string>
+        <string name="Yesterday">昨天</string>
+        <string name="NoResult">没有结果</string>
+        <string name="NoChats">还没有会话...</string>
+        <string name="NoChatsHelp">要发起会话可点击右下角的新消息按钮\n或者点击菜单按钮查看更多选项。</string>
+        <string name="WaitingForNetwork">等待网络连接...</string>
+        <string name="Connecting">正在连接...</string>
+        <string name="Updating">更新中...</string>
+        <string name="NewSecretChat">新的私密会话</string>
+        <string name="AwaitingEncryption">等待 %s 上线...</string>
+        <string name="EncryptionRejected">私密会话已取消</string>
+        <string name="EncryptionProcessing">正在交换加密密钥...</string>
+        <string name="EncryptedChatStartedOutgoing">%s 加入了您的私密会话。</string>
+        <string name="EncryptedChatStartedIncoming">您加入了私密会话。</string>
+        <string name="ClearHistory">清除历史记录</string>
+        <string name="DeleteChat">删除并退出</string>
+        <string name="DeleteChatUser">删除会话</string>
+        <string name="HiddenName">账户已删除</string>
+        <string name="SelectChat">选择会话</string>
+        <string name="PhotoTip">长按来查看</string>
+        <string name="CompatibilityChat">%1$s 正在使用旧版的 Telegram，所以私密图片会以兼容模式显示。\n\n当 %2$s 升级 Telegram 后，有时限的图片将可以在 \'长按来查看\' 模式下运行，同时在其他成员进行屏幕截图时您也会得到通知。</string>
+        <string name="SearchMessages">消息</string>
+        <string name="Search">搜索</string>
+        <string name="MuteNotifications">屏蔽通知</string>
+        <string name="MuteFor">屏蔽 %1$s</string>
+        <string name="UnmuteNotifications">解除屏蔽</string>
+        <string name="WillUnmuteIn">在 %1$s 之后</string>
+        <!--broadcasts-->
+        <string name="NewBroadcastList">新的广播列表</string>
+        <string name="EnterListName">输入列表名称</string>
+        <string name="YouCreatedBroadcastList">您创建了一个广播列表</string>
+        <string name="AddRecipient">添加收听者</string>
+        <string name="KickFromBroadcast">从广播列表中移除</string>
+        <!--documents view-->
+        <string name="SelectFile">选择文件</string>
+        <string name="FreeOfTotal">剩余 %1$s ，共 %2$s</string>
+        <string name="UnknownError">未知错误</string>
+        <string name="AccessError">无法访问</string>
+        <string name="NoFiles">还没有文件...</string>
+        <string name="FileUploadLimit">文件大小不能超过 %1$s</string>
+        <string name="NotMounted">储存设备未挂载</string>
+        <string name="UsbActive">激活 USB 传输</string>
+        <string name="InternalStorage">内部储存</string>
+        <string name="ExternalStorage">外置储存</string>
+        <string name="SystemRoot">系统根目录</string>
+        <string name="SdCard">SD 卡</string>
+        <string name="Folder">文件夹</string>
+        <string name="GalleryInfo">发送完整图片</string>
+        <!--chat view-->
+        <string name="Invisible">隐身</string>
+        <string name="Typing">正在输入...</string>
+        <string name="IsTyping">正在输入...</string>
+        <string name="AreTyping">正在输入...</string>
+        <string name="GotAQuestion">对 Telegram\n有疑问?</string>
+        <string name="ChatTakePhoto">拍照</string>
+        <string name="ChatGallery">从相册选择</string>
+        <string name="ChatLocation">发送地理位置</string>
+        <string name="ChatVideo">发送视频</string>
+        <string name="ChatDocument">发送文件</string>
+        <string name="NoMessages">还没有消息...</string>
+        <string name="ForwardedMessage">转发消息</string>
+        <string name="From">从</string>
+        <string name="NoRecent">没有最近的联系人</string>
+        <string name="Message">消息</string>
+        <string name="TypeMessage">消息</string>
+        <string name="ShareMyContactInfo">分享我的联系方式</string>
+        <string name="AddToContacts">添加至通讯录</string>
+        <string name="EncryptedPlaceholderTitleIncoming">%s 邀请您加入私密会话。</string>
+        <string name="EncryptedPlaceholderTitleOutgoing">您邀请了 %s 加入私密会话。</string>
+        <string name="EncryptedDescriptionTitle">私密会话:</string>
+        <string name="EncryptedDescription1">使用端对端加密</string>
+        <string name="EncryptedDescription2">不会在我们的服务器上留下记录</string>
+        <string name="EncryptedDescription3">定时自毁</string>
+        <string name="EncryptedDescription4">不允许转发</string>
+        <string name="YouWereKicked">您被从群聊中踢出</string>
+        <string name="YouLeft">您离开了群聊</string>
+        <string name="DeleteThisGroup">删除此群聊</string>
+        <string name="DeleteThisChat">删除这个会话</string>
+        <string name="SlideToCancel">滑动取消</string>
+        <string name="SaveToDownloads">保存到“下载”文件夹</string>
+        <string name="ShareFile">分享文件</string>
+        <string name="ApplyLocalizationFile">应用本地化文件</string>
+        <string name="UnsupportedAttachment">不支持的附件</string>
+        <string name="SetTimer">设置自毁定时器</string>
+        <string name="ServiceNotifications">服务通知</string>
+        <!--notification-->
+        <string name="MessageLifetimeChanged">%1$s 设置了时间为 %2$s 的自毁定时器</string>
+        <string name="MessageLifetimeChangedOutgoing">您设置了时间为 %1$s 的自毁定时器</string>
+        <string name="MessageLifetimeRemoved">%1$s 取消了自毁定时器</string>
+        <string name="MessageLifetimeYouRemoved">您取消了自毁定时器</string>
+        <string name="YouHaveNewMessage">您有新消息</string>
+        <string name="NotificationMessageText">%1$s: %2$s</string>
+        <string name="NotificationMessageNoText">%1$s 发送了一条消息</string>
+        <string name="NotificationMessagePhoto">%1$s 发送了一张图片</string>
+        <string name="NotificationMessageVideo">%1$s 发送了一段视频</string>
+        <string name="NotificationMessageContact">%1$s 发送了一张联系人名片</string>
+        <string name="NotificationMessageMap">%1$s 发送了一个地理位置</string>
+        <string name="NotificationMessageDocument">%1$s 发送了一个文件</string>
+        <string name="NotificationMessageAudio">%1$s 发送了一段音频</string>
+        <string name="NotificationMessageSticker">%1$s 发送了一个表情</string>
+        <string name="NotificationMessageGroupText">%1$s @ %2$s: %3$s</string>
+        <string name="NotificationMessageGroupNoText">%1$s 在群中发送了一条消息 %2$s</string>
+        <string name="NotificationMessageGroupPhoto">%1$s 在群中发送了一张图片 %2$s</string>
+        <string name="NotificationMessageGroupVideo">%1$s 在群中发送了一段视频 %2$s</string>
+        <string name="NotificationMessageGroupContact">%1$s 在群聊共享了一张联系人名片 %2$s</string>
+        <string name="NotificationMessageGroupMap">%1$s 在群中发送了一个地理位置 %2$s</string>
+        <string name="NotificationMessageGroupDocument">%1$s 在群中共享了一份文件 %2$s</string>
+        <string name="NotificationMessageGroupAudio">%1$s 在群中发送了一段音频 %2$s</string>
+        <string name="NotificationMessageGroupSticker">%1$s 在群中发送了一个表情 %2$s</string>
+        <string name="NotificationInvitedToGroup">%1$s 邀请你加入群 %2$s</string>
+        <string name="NotificationEditedGroupName">%1$s 编辑了群 %2$s 的昵称</string>
+        <string name="NotificationEditedGroupPhoto">%1$s 编辑了群 %2$s 的头像</string>
+        <string name="NotificationGroupAddMember">%1$s 被 %3$s 邀请加入群 %2$s</string>
+        <string name="NotificationGroupKickMember">%1$s 被 %3$s 从本群移除 %2$s</string>
+        <string name="NotificationGroupKickYou">%1$s 将你从群 %2$s 移除</string>
+        <string name="NotificationGroupLeftMember">%1$s 退出本群 %2$s</string>
+        <string name="NotificationContactJoined">%1$s 加入了 Telegram!</string>
+        <string name="NotificationUnrecognizedDevice">%1$s,\n我们检测到你的账号尝试在一部新设备 %2$s 上登录\n\n设备：%3$s\n地点：%4$s\n\n若非本人登陆，可在设置－隐私与安全 - 终止所有对话。\n\nTelegram团队\n敬上！</string>
+        <string name="NotificationContactNewPhoto">%1$s 上传了文件图片</string>
+        <string name="Reply">回复</string>
+        <string name="ReplyToGroup">回复 %1$s</string>
+        <string name="ReplyToUser">回复 %1$s</string>
+        <string name="NotificationMessagesPeopleDisplayOrder">%1$s %2$s</string>
+        <!--contacts view-->
+        <string name="SelectContact">选择联系人</string>
+        <string name="NoContacts">通讯录为空</string>
+        <string name="InviteText">你好，一起加入 Plus Messenger 吧！ http://goo.gl/jnmjnZ</string>
+        <string name="TodayAt">在</string>
+        <string name="YesterdayAt">昨天在</string>
+        <string name="Online">在线</string>
+        <string name="LastSeen">最后上线</string>
+        <string name="LastSeenDate">最后上线</string>
+        <string name="InviteFriends">邀请朋友</string>
+        <string name="GlobalSearch">全球搜索</string>
+        <string name="Lately">近期最后上线</string>
+        <string name="WithinAWeek">最后上线一周内</string>
+        <string name="WithinAMonth">最后上线一月内</string>
+        <string name="ALongTimeAgo">最后上线很久以前</string>
+        <string name="NewMessageTitle">新的消息</string>
+        <!--group create view-->
+        <string name="SendMessageTo">发送信息给...</string>
+        <string name="EnterGroupNamePlaceholder">输入群名称</string>
+        <string name="GroupName">群名称</string>
+        <string name="MembersCount">%1$d/%2$d 成员</string>
+        <!--group info view-->
+        <string name="SharedMedia">分享媒体</string>
+        <string name="SETTINGS">设置</string>
+        <string name="AddMember">添加成员</string>
+        <string name="DeleteAndExit">删除并离开该群</string>
+        <string name="Notifications">通知</string>
+        <string name="KickFromGroup">从群中移除</string>
+        <!--contact info view-->
+        <string name="ShareContact">分享</string>
+        <string name="AddContact">添加</string>
+        <string name="AddContactTitle">添加联系人</string>
+        <string name="BlockContact">屏蔽联系人</string>
+        <string name="EditContact">编辑</string>
+        <string name="DeleteContact">删除</string>
+        <string name="PhoneHome">主页</string>
+        <string name="PhoneMobile">移动</string>
+        <string name="PhoneWork">工作</string>
+        <string name="PhoneOther">其他</string>
+        <string name="PhoneMain">主要</string>
+        <string name="StartEncryptedChat">开始私密会话。</string>
+        <string name="CreateEncryptedChatError">发生错误。</string>
+        <string name="EncryptionKey">加密密钥</string>
+        <string name="MessageLifetime">自毁定时器</string>
+        <string name="ShortMessageLifetimeForever">关闭</string>
+        <string name="EncryptionKeyDescription">这张图片是与 <![CDATA[<b>]]>%1$s<![CDATA[</b>]]> 私密会话密钥的可视化图标。<![CDATA[<br><br>]]>如果这张图片与 <![CDATA[<b>]]>%2$s\'s<![CDATA[</b>]]> 电话上显示的一样，你的会话 200%% 安全。<![CDATA[<br><br>]]>更多尽在 telegram.org</string>
+        <string name="NumberUnknown">未知</string>
+        <string name="Info">信息</string>
+        <string name="Phone">电话</string>
+        <!--usernames-->
+        <string name="Username">用户名</string>
+        <string name="UsernamePlaceholder">你的用户名</string>
+        <string name="UsernameInUse">抱歉，该用户名已被占用。</string>
+        <string name="UsernameInvalid">抱歉，该用户名无效。</string>
+        <string name="UsernameInvalidShort">用户名必须至少 5 个字符以上。</string>
+        <string name="UsernameInvalidLong">用户名不能超出32个字符。</string>
+        <string name="UsernameInvalidStartNumber">抱歉，用户名不能以数字开头。</string>
+        <string name="UsernameHelp">你可以在<![CDATA[<b>]]>Plus Messenger<![CDATA[</b>]]>上选择一个用户名。用户名可使他人找到你，并不通过你的手机号码就能与你联系。<![CDATA[<br><br>]]>你可以使用 <![CDATA[<b>]]>a–z<![CDATA[</b>]]>, <![CDATA[<b>]]>0–9<![CDATA[</b>]]>和下划线。 最短长度为 <![CDATA[<b>]]>5<![CDATA[</b>]]> 个字符。</string>
+        <string name="UsernameChecking">查对用户名中...</string>
+        <string name="UsernameAvailable">%1$s 可以使用。</string>
+        <string name="UsernameEmpty">用户名为空。</string>
+        <string name="ErrorOccurred">发生错误。</string>
+        <!--settings view-->
+        <string name="ResetNotificationsText">将所有通知设置为默认值。</string>
+        <string name="TextSize">字号</string>
+        <string name="AskAQuestion">提出一个问题</string>
+        <string name="EnableAnimations">启用动画</string>
+        <string name="Unblock">解除屏蔽</string>
+        <string name="UnblockText">长按用户名以解除屏蔽</string>
+        <string name="NoBlocked">没有被屏蔽用户</string>
+        <string name="MessageNotifications">消息通知</string>
+        <string name="Alert">提醒</string>
+        <string name="MessagePreview">消息预览</string>
+        <string name="GroupNotifications">群提醒</string>
+        <string name="Sound">声音</string>
+        <string name="InAppNotifications">应用内提醒</string>
+        <string name="InAppSounds">应用内声音</string>
+        <string name="InAppVibrate">应用内振动</string>
+        <string name="Vibrate">振动</string>
+        <string name="InAppPreview">应用内预览</string>
+        <string name="Reset">重置</string>
+        <string name="ResetAllNotifications">重置所有提醒</string>
+        <string name="UndoAllCustom">取消所有联系人及群习惯通知设置</string>
+        <string name="NotificationsAndSounds">通知与声音</string>
+        <string name="BlockedUsers">屏蔽的用户</string>
+        <string name="LogOut">登出</string>
+        <string name="NoSound">静音</string>
+        <string name="Default">默认</string>
+        <string name="Support">支持</string>
+        <string name="ChatBackground">会话背景</string>
+        <string name="MessagesSettings">消息</string>
+        <string name="SendByEnter">按回车键发送</string>
+        <string name="TerminateAllSessions">终止所有会话</string>
+        <string name="Events">事件</string>
+        <string name="ContactJoined">已加入 Telegram 的联系人</string>
+        <string name="Pebble">PEBBLE</string>
+        <string name="Language">语言</string>
+        <string name="AskAQuestionInfo">请注意 Telegram 由志愿者支持维护。我们会尽快回复，请耐心等待。<![CDATA[<br><br>]]>请查看 <![CDATA[<a href=\"http://telegram.org/faq#general\">Telegram FAQ</a>]]>：已经解答了大部分疑难问题，还有重要提示 <![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">troubleshooting</a>]]>。</string>
+        <string name="AskButton">询问志愿者</string>
+        <string name="TelegramFaq">Telegram FAQ</string>
+        <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+        <string name="DeleteLocalization">删除定位？</string>
+        <string name="IncorrectLocalization">错误的定位文件</string>
+        <string name="Enabled">启用</string>
+        <string name="Disabled">禁用</string>
+        <string name="NotificationsService">通知服务</string>
+        <string name="NotificationsServiceDisableInfo">如果 Google Play 服务已满足你接收信息的要求，可以禁用此通知服务。 但是我们建议你将其设置为开启状态，这样当应用在后台运行时仍能收到即时通知。</string>
+        <string name="SortBy">分类</string>
+        <string name="ImportContacts">重要联系人</string>
+        <string name="SortFirstName">名</string>
+        <string name="SortLastName">姓</string>
+        <string name="LedColor">LED 颜色</string>
+        <string name="PopupNotification">弹出通知</string>
+        <string name="NoPopup">不弹出</string>
+        <string name="OnlyWhenScreenOn">仅在屏幕“开启”</string>
+        <string name="OnlyWhenScreenOff">仅在屏幕“关闭”</string>
+        <string name="AlwaysShowPopup">总是弹出</string>
+        <string name="BadgeNumber">计数</string>
+        <string name="Short">短</string>
+        <string name="Long">长</string>
+        <string name="SystemDefault">系统默认</string>
+        <string name="SettingsDefault">设置默认</string>
+        <string name="AutomaticMediaDownload">自动媒体下载</string>
+        <string name="WhenUsingMobileData">使用移动数据时</string>
+        <string name="WhenConnectedOnWiFi">连接到 Wi-Fi 时</string>
+        <string name="WhenRoaming">漫游时</string>
+        <string name="NoMediaAutoDownload">无媒体</string>
+        <string name="SaveToGallerySettings">保存到相册</string>
+        <string name="EditName">编辑姓名</string>
+        <string name="NotificationsPriority">优先</string>
+        <string name="NotificationsPriorityDefault">默认</string>
+        <string name="NotificationsPriorityLow">低</string>
+        <string name="NotificationsPriorityHigh">高</string>
+        <string name="NotificationsPriorityMax">最大</string>
+        <string name="RepeatNotificationsNever">永不</string>
+        <string name="RepeatNotifications">重复通知</string>
+        <string name="PhoneNumberHelp">你可在此修改 Plus Messenger 绑定的号码。你的用户名和云数据 — 消息，媒体，联系人等将被移动到新的号码中。\n\n<![CDATA[<b>注意：</b>]]> 所有联系人都会将你的新号码 <![CDATA[<b>new number</b>]]> 添加至通讯录中，只要他们有旧号码并未被你屏蔽。</string>
+        <string name="PhoneNumberAlert">所有联系人都会将你的新号码添加至通讯录中，只要他们有旧号码并未被你屏蔽。</string>
+        <string name="PhoneNumberChange">改变号码</string>
+        <string name="ChangePhoneNewNumber">新号码</string>
+        <string name="ChangePhoneHelp">我们将向你的新号码发送一条附有验证码的短信。</string>
+        <string name="ChangePhoneNumberOccupied">号码为 %1$s 已被连接到新用户。请在启用新号码前删除原用户。</string>
+        <string name="NotificationsOther">其他</string>
+        <!--media view-->
+        <string name="NoMedia">在此会话中分享的照片和视频也可以在其他设备上访问。</string>
+        <string name="DocumentsTitle">文件</string>
+        <string name="NoSharedFiles">此会话中分享的文件和文档可在其他任何设备上访问。</string>
+        <!--map view-->
+        <string name="Map">地图</string>
+        <string name="Satellite">卫星</string>
+        <string name="Hybrid">混合</string>
+        <string name="MetersAway">米远</string>
+        <string name="KMetersAway">千米远</string>
+        <string name="SendLocation">发送地理位置</string>
+        <string name="ShareLocation">分享地理位置</string>
+        <!--photo gallery view-->
+        <string name="ShowAllMedia">显示所有媒体</string>
+        <string name="SaveToGallery">保存到相册</string>
+        <string name="Of">%1$d of %2$d</string>
+        <string name="Gallery">相册</string>
+        <string name="AllPhotos">所有照片</string>
+        <string name="NoPhotos">没有照片</string>
+        <string name="PleaseDownload">请先下载媒体</string>
+    <string name="NoRecentPhotos">没有近期照片</string>
+    <string name="NoRecentGIFs">没有近期动画</string>
+    <string name="SearchImages">查找图片</string>
+    <string name="SearchGifs">查找动画</string>
+    <string name="SearchImagesTitle">查找图片</string>
+    <string name="SearchGifsTitle">查找动画</string>
+    <string name="CropImage">裁剪图片</string>
+    <string name="EditImage">编辑图片</string>
+    <!--password view-->
+    <string name="Password">密码</string>
+    <string name="ChangePassword">更改密码</string>
+    <string name="OldPassword">原密码</string>
+    <string name="EnterOldPassword">输入原密码</string>
+    <string name="NewPassword">新密码</string>
+    <string name="EnterNewPassword">输入新密码</string>
+    <string name="VerifyNewPassword">验证新密码</string>
+    <string name="EnterYourPassword">输入密码</string>
+    <string name="PasswordHint">提示</string>
+    <string name="EnterHint">输入提示</string>
+    <string name="PasswordImportant">注意：如果你忘记密码，所有会话，消息和媒体都将被删除。</string>
+    <string name="PasswordDoNotMatch">密码与用户名不符</string>
+    <string name="PasswordOldIncorrect">原密码错误</string>
+    <string name="PasswordIncorrect">错误密码</string>
+    <string name="PasswordNewIncorrect">新密码错误</string>
+    <string name="HintIncorrect">提示不能包含密码</string>
+    <string name="EnterPassword">输入密码</string>
+    <string name="DeleteAccountImportant">注意：你将丢失所有会话，消息和媒体。</string>
+    <string name="PasswordDeleteAccountTitle">删除账户</string>
+    <string name="PasswordDeleteAccount">删除我的账户</string>
+    <string name="PasswordHintDetail">提示：%1$s</string>
+    <string name="AreYouSureDeleteAccount">确定要删除账户吗？</string>
+    <string name="AreYouSureDeleteAccount2">我们要特别阐明，所有会话，消息和媒体都将被删除。你确定吗？</string>
+    <!--privacy settings-->
+    <string name="PrivacySettings">隐私与安全</string>
+    <string name="PrivacyTitle">隐私</string>
+    <string name="PrivacyLastSeen">最后上线</string>
+    <string name="LastSeenEverybody">所有人</string>
+    <string name="LastSeenContacts">我的联系人</string>
+    <string name="LastSeenNobody">没有人</string>
+    <string name="LastSeenEverybodyMinus">所有人 (-%1$d)</string>
+    <string name="LastSeenContactsPlus">我的联系人 (+%1$d)</string>
+    <string name="LastSeenContactsMinus">我的联系人(-%1$d)</string>
+    <string name="LastSeenContactsMinusPlus">我的联系人 (-%1$d, +%2$d)</string>
+    <string name="LastSeenNobodyPlus">没有人 (+%1$d)</string>
+    <string name="SecurityTitle">安全</string>
+    <string name="DeleteAccountTitle">账户自毁</string>
+    <string name="DeleteAccountIfAwayFor">如果你离开</string>
+    <string name="DeleteAccountHelp">如果在这段时间内你一次都没有登陆，你的账户将被删除，包括所有群，消息和联系人。</string>
+    <string name="DeleteAccountNowConfirmation">删除账户吗？</string>
+    <string name="LastSeenHelp">修改看到你最后登陆的人。</string>
+    <string name="LastSeenTitle">谁能看到你最后登陆时间？</string>
+    <string name="AddExceptions">增加例外</string>
+    <string name="CustomHelp">注意：你不能看到未分享最后登陆的人的最后登陆时间。只会显示最后登陆的大致时间（最近，一周内，一个月内）。</string>
+    <string name="AlwaysShareWith">永远分享给</string>
+<string name="NeverShareWith">从不分享给</string>
+<string name="CustomShareSettingsHelp">这些设置将覆盖上面的值。</string>
+<string name="AlwaysShareWithTitle">永远分享</string>
+<string name="AlwaysShareWithPlaceholder">永远分享给这些用户...</string>
+<string name="NeverShareWithTitle">从不分享</string>
+<string name="NeverShareWithPlaceholder">从不分享给这些用户...</string>
+<string name="EmpryUsersPlaceholder">添加用户</string>
+<string name="PrivacyFloodControlError">抱歉，请求过多。 现不能更改隐私设置，请稍候。</string>
+<string name="ClearOtherSessionsHelp">除此设备外将其他设备登出。</string>
+<string name="RemoveFromListText">长按用户以删除。</string>
+    <!--edit video view-->
+<string name="EditVideo">编辑视频</string>
+<string name="OriginalVideo">原始视频</string>
+<string name="EditedVideo">编辑过的视频</string>
+<string name="SendingVideo">正在发送视频...</string>
+<string name="CompressVideo">压缩视频</string>
+    <!--button titles-->
+<string name="Next">下一个</string>
+<string name="Back">返回</string>
+<string name="Done">完成</string>
+<string name="Open">打开</string>
+<string name="Cancel">取消</string>
+<string name="Add">添加</string>
+<string name="Edit">编辑</string>
+<string name="Send">发送</string>
+<string name="Call">呼叫</string>
+<string name="Copy">复制</string>
+<string name="Delete">删除</string>
+<string name="Forward">转发</string>
+<string name="Retry">重试</string>
+<string name="FromCamera">来自相机</string>
+<string name="FromGalley">来自相册</string>
+<string name="DeletePhoto">删除照片</string>
+<string name="Set">设置</string>
+<string name="OK">OK</string>
+    <!--messages-->
+<string name="ActionKickUser">un1 移除了 un2</string>
+<string name="ActionLeftUser">un1 退出群聊</string>
+<string name="ActionAddUser">un1 添加 un2</string>
+<string name="ActionRemovedPhoto">un1 移除群照片</string>
+<string name="ActionChangedPhoto">un1 更改群照片</string>
+<string name="ActionChangedTitle">un1 更改 un2 群名称</string>
+<string name="ActionCreateGroup">un1 创立群</string>
+<string name="ActionYouKickUser">你移除了 un2</string>
+<string name="ActionYouLeftUser">你退出了群</string>
+<string name="ActionYouAddUser">你添加了 un2</string>
+<string name="ActionYouRemovedPhoto">你移除了群照片</string>
+<string name="ActionYouChangedPhoto">你更改了群照片</string>
+<string name="ActionYouChangedTitle">你更改了un2的群名称</string>
+<string name="ActionYouCreateGroup">你创立了群</string>
+<string name="ActionKickUserYou">un1 移除了你</string>
+<string name="ActionAddUserYou">un1 添加了你</string>
+<string name="UnsuppotedMedia">你的 Telegram 版本不支持这条消息。 请前往：http://telegram.org/update 升级。</string>
+<string name="AttachPhoto">照片</string>
+<string name="AttachVideo">视频</string>
+<string name="AttachLocation">地理位置</string>
+<string name="AttachContact">联系人</string>
+<string name="AttachDocument">文件</string>
+<string name="AttachSticker">表情</string>
+<string name="AttachAudio">音频</string>
+<string name="FromYou">你</string>
+<string name="ActionTakeScreenshootYou">已截屏</string>
+<string name="ActionTakeScreenshoot">un1 已截屏!</string>
+    <!--Alert messages-->
+<string name="InvalidPhoneNumber">无效电话号码</string>
+<string name="CodeExpired">密码过期，请重新输入</string>
+<string name="FloodWait">请求过多，请稍候重试</string>
+<string name="InvalidCode">密码无效</string>
+<string name="InvalidFirstName">无效的名</string>
+<string name="InvalidLastName">无效的姓</string>
+<string name="Loading">加载中...</string>
+<string name="NoPlayerInstalled">缺少视频播放器，请安装视频播放器后继续</string>
+<string name="NoMailInstalled">请发送邮件到 sms@telegram.org 并告诉我们你的问题。</string>
+<string name="NoHandleAppInstalled">没有可以打开文件\'%1$s\'的应用，请安装之后继续</string>
+<string name="InviteUser">该用户还未加入 Telegram，发送一封邀请？</string>
+<string name="AreYouSure">你确定吗？</string>
+<string name="AddToTheGroup">添加 %1$s 到群吗？\n\n最近的消息转发数:</string>
+<string name="ForwardMessagesTo">转发给 %1$s 吗？</string>
+<string name="SendMessagesTo">发送信息给 %1$s 吗？</string>
+<string name="AreYouSureLogout">你确定登出吗？\n\n注意：你可以立即在所有设备上无缝使用 Telegram。\n\n登出后所有私密会话都将被删除。</string>
+<string name="AreYouSureSessions">你确定终止其他所有会话吗？</string>
+<string name="AreYouSureDeleteAndExit">你确定删除并离开群吗？</string>
+<string name="AreYouSureDeleteThisChat">你确定删除这个会话吗？</string>
+<string name="AreYouSureShareMyContactInfo">你确定共享你的联系人信息吗？</string>
+<string name="AreYouSureBlockContact">你确定屏蔽该联系人吗？</string>
+<string name="AreYouSureUnblockContact">对该联系人解除屏蔽吗？</string>
+<string name="AreYouSureDeleteContact">你确定删除这个联系人吗？</string>
+<string name="AreYouSureSecretChat">你确定开始私密会话吗？</string>
+<string name="AreYouSureRegistration">你确定要取消登录吗？</string>
+<string name="AreYouSureClearHistory">你确定要清除历史吗？</string>
+<string name="AreYouSureDeleteMessages">你确定要删除 %1$s ？</string>
+<string name="SendMessagesToGroup">发送消息给 %1$s 吗？</string>
+<string name="ForwardMessagesToGroup">转发消息给 %1$s ？</string>
+<string name="FeatureUnavailable">抱歉，该功能在你所在国家尚未启用。</string>
+    <!--Intro view-->
+<string name="Page1Title">Plus Messenger</string>
+<string name="Page2Title">快速</string>
+<string name="Page3Title">免费</string>
+<string name="Page4Title">安全</string>
+<string name="Page5Title">强大</string>
+<string name="Page6Title">基于云</string>
+<string name="Page7Title">私密的</string>
+<string name="Page1Message">世界上 <![CDATA[<b>最快的</b>]]> 即时通讯应用。<![CDATA[<br/>]]>它 <![CDATA[<b>免费</b>]]> 并且 <![CDATA[<b>安全</b>]]>。</string>
+<string name="Page2Message"><![CDATA[<b>Plus Messenger</b>]]> 消息发送快于<![CDATA[<br/>]]>其他任何应用。</string>
+<string name="Page3Message"><![CDATA[<b>Plus Messenger</b>]]> 永久免费。没有广告。<![CDATA[<br/>]]>没有订阅费。</string>
+<string name="Page4Message"><![CDATA[<b>Plus Messenger</b>]]> 确保信息安全，<![CDATA[<br/>]]>防止黑客攻击。</string>
+<string name="Page5Message"><![CDATA[<b>Plus Messenger</b>]]> 对<![CDATA[<br/>]]>你的媒体和会话没有容量限制。</string>
+<string name="Page6Message"><![CDATA[<b>Plus Messenger</b>]]> 使你<![CDATA[<br/>]]>可从多部设备上查看消息。</string>
+<string name="Page7Message"><![CDATA[<b>Plus Messenger</b>]]> 消息高度加密<![CDATA[<br/>]]>支持自毁。</string>
+<string name="StartMessaging">开始发送消息</string>
+    <!--plural-->
+<string name="Online_zero">%1$d 在线</string>
+<string name="Online_one">%1$d 在线</string>
+<string name="Online_two">%1$d 在线</string>
+<string name="Online_few">%1$d 在线</string>
+<string name="Online_many">%1$d 在线</string>
+<string name="Online_other">%1$d 在线</string>
+<string name="Members_zero">没有成员</string>
+<string name="Members_one">%1$d 成员</string>
+<string name="Members_two">%1$d 成员</string>
+<string name="Members_few">%1$d 成员</string>
+<string name="Members_many">%1$d 成员</string>
+<string name="Members_other">%1$d 成员</string>
+<string name="AndMoreTyping_zero">和其他 %1$d 个成员都在输入</string>
+<string name="AndMoreTyping_one">和其他 %1$d 个成员都在输入</string>
+<string name="AndMoreTyping_two">和其他 %1$d 个成员都在输入</string>
+<string name="AndMoreTyping_few">和其他 %1$d 个成员都在输入</string>
+<string name="AndMoreTyping_many">和其他 %1$d 个成员都在输入</string>
+<string name="AndMoreTyping_other">和其他 %1$d 个成员都在输入</string>
+<string name="NewMessages_zero">没有新消息</string>
+<string name="NewMessages_one">%1$d 条新消息</string>
+<string name="NewMessages_two">%1$d 条新消息</string>
+<string name="NewMessages_few">%1$d 条新消息</string>
+<string name="NewMessages_many">%1$d 条新消息</string>
+<string name="NewMessages_other">%1$d 条新消息</string>
+<string name="messages_zero">没有消息</string>
+<string name="messages_one">%1$d 条消息</string>
+<string name="messages_two">%1$d 条消息</string>
+<string name="messages_few">%1$d 条消息</string>
+<string name="messages_many">%1$d 条消息</string>
+<string name="messages_other">%1$d 条消息</string>
+<string name="files_zero">没有文件</string>
+<string name="files_one">%1$d 份文件</string>
+<string name="files_two">%1$d 份文件</string>
+<string name="files_few">%1$d 份文件</string>
+<string name="files_many">%1$d 份文件</string>
+<string name="files_other">%1$d 份文件</string>
+<string name="FromContacts_zero">来自0个联系人</string>
+<string name="FromContacts_one">来自 %1$d 个联系人</string>
+<string name="FromContacts_two">来自 %1$d 个联系人</string>
+<string name="FromContacts_few">来自 %1$d 个联系人</string>
+<string name="FromContacts_many">来自 %1$d 个联系人</string>
+<string name="FromContacts_other">来自 %1$d 个联系人</string>
+<string name="Seconds_zero">%1$d 秒</string>
+<string name="Seconds_one">%1$d 秒</string>
+<string name="Seconds_two">%1$d 秒</string>
+<string name="Seconds_few">%1$d 秒</string>
+<string name="Seconds_many">%1$d 秒</string>
+<string name="Seconds_other">%1$d 秒</string>
+<string name="Minutes_zero">%1$d 分钟</string>
+<string name="Minutes_one">%1$d 分钟</string>
+<string name="Minutes_two">%1$d 分钟</string>
+<string name="Minutes_few">%1$d 分钟</string>
+<string name="Minutes_many">%1$d 分钟</string>
+<string name="Minutes_other">%1$d 分钟</string>
+<string name="Hours_zero">%1$d 小时</string>
+<string name="Hours_one">%1$d 小时</string>
+<string name="Hours_two">%1$d 小时</string>
+<string name="Hours_few">%1$d 小时</string>
+<string name="Hours_many">%1$d 小时</string>
+<string name="Hours_other">%1$d 小时</string>
+<string name="Days_zero">%1$d 天</string>
+<string name="Days_one">%1$d 天</string>
+<string name="Days_two">%1$d 天</string>
+<string name="Days_few">%1$d 天</string>
+<string name="Days_many">%1$d 天</string>
+<string name="Days_other">%1$d 天</string>
+<string name="Weeks_zero">%1$d 周</string>
+<string name="Weeks_one">%1$d 周</string>
+<string name="Weeks_two">%1$d 周</string>
+<string name="Weeks_few">%1$d 周</string>
+<string name="Weeks_many">%1$d 周</string>
+<string name="Weeks_other">%1$d 周</string>
+<string name="Months_zero">%1$d 月</string>
+<string name="Months_one">%1$d 月</string>
+<string name="Months_two">%1$d 月</string>
+<string name="Months_few">%1$d 月</string>
+<string name="Months_many">%1$d 月</string>
+<string name="Months_other">%1$d 月</string>
+<string name="Years_zero">%1$d 年</string>
+<string name="Years_one">%1$d 年</string>
+<string name="Years_two">%1$d 年</string>
+<string name="Years_few">%1$d 年</string>
+<string name="Years_many">%1$d 年</string>
+<string name="Years_other">%1$d 年</string>
+<string name="Users_zero">%1$d 个用户</string>
+<string name="Users_one">%1$d 个用户</string>
+<string name="Users_two">%1$d 个用户</string>
+<string name="Users_few">%1$d 个用户</string>
+<string name="Users_many">%1$d 个用户</string>
+<string name="Users_other">%1$d 个用户</string>
+    <!--date formatters-->
+<string name="formatterMonth">月 日</string>
+<string name="formatterYear">日 月 年</string>
+<string name="formatterYearMax">日.月.年</string>
+<string name="chatDate">月 日</string>
+<string name="chatFullDate">月 日，年</string>
+<string name="formatterWeek">周</string>
+<string name="formatterDay24H">小时：分</string>
+<string name="formatterDay12H">小时：分 a</string>
+<string name="formatDateAtTime">%1$s 在 %2$s</string>
+  <!--Plus Messenger-->
+  <!--Smart Notifications-->
+  <string name="SmartNotification">智能通知</string>
+  <string name="TimeUnitSeconds">秒</string>
+  <string name="TimeUnitMinutes">分</string>
+  <string name="TimeUnitHours">时</string>
+  <string name="TimeUnitDays">天</string>
+  <string name="settings_smart_notify_begin">声音最多</string>
+  <string name="settings_smart_notify_mid1">次</string>
+  <string name="settings_smart_notify_mid11">次</string>
+  <string name="settings_smart_notify_mid2">在</string>
+  <!---->
+  <string name="TelegramForAndroid">Plus Messenger for Android</string>
+  <string name="Theming">主题</string>
+  <string name="colorHexInvalid">无效的颜色代码！</string>
+  <string name="themeColor">主题颜色</string>
+  <string name="ResetThemeSettings">重置主题设置</string>
+  <string name="ResetThemeSettingsSum">撤销所有主题设置</string>
+  <string name="ResetThemeToastText">重置为默认主题设置</string>
+  <string name="General">通用</string>
+  <string name="Screens">屏幕</string>
+  <string name="MainScreen">主屏幕</string>
+  <string name="ChatScreen">聊天屏幕</string>
+  <string name="ContactsScreen">联系人屏幕</string>
+  <string name="Header">标题</string>
+  <string name="Rows">行</string>
+  <string name="ChatList">聊天列表</string>
+  <string name="ChatsList">聊天列表</string>
+  <string name="ContactsList">联系人列表</string>
+  <string name="HeaderColor">标题颜色</string>
+  <string name="MessageColor">信息颜色</string>
+  <string name="MessageSize">信息大小</string>
+  <string name="TimeDateColor">时间/日期颜色</string>
+  <string name="TimeDateSize">时间/日期大小</string>
+  <string name="CountColor">信息数目字体颜色</string>
+  <string name="CountSize">信息数目字体大小</string>
+  <string name="RowColor">行颜色</string>
+  <string name="CountBGColor">信息数目背景颜色</string>
+  <string name="StatusColor">状态颜色</string>
+  <string name="StatusSize">状态大小</string>
+  <string name="RBubbleColor">右侧气球颜色</string>
+  <string name="LBubbleColor">左侧气球颜色</string>
+  <string name="DateColor">日期颜色</string>
+  <string name="DateSize">日期大小</string>
+  <string name="DateBubbleColor">日期气球颜色</string>
+  <string name="RTextColor">右侧信息颜色</string>
+  <string name="LTextColor">左侧信息颜色</string>
+  <string name="RTimeColor">右侧时间颜色</string>
+  <string name="LTimeColor">左侧时间颜色</string>
+  <string name="TimeSize">时间大小</string>
+  <string name="EditTextColor">输入栏字体颜色</string>
+  <string name="EditTextSize">输入栏字体大小</string>
+  <string name="EditTextBGColor">输入栏背景颜色</string>
+  <string name="EmojiViewBGColor">表情背景颜色</string>
+  <string name="EmojiViewTabColor">表情标签颜色</string>
+  <string name="OnlineColor">在线中颜色</string>
+  <string name="ChatMusic">音乐</string>
+  <string name="SaveTheme">保存主题</string>
+  <string name="SaveThemeSum">保存您的主题到 Telegram/Themes 文件夹</string>
+  <string name="SaveThemeToastText">主题已保存！</string>
+  <string name="SavedTo">%1$s 被存储到 %2$s</string>
+  <string name="SaveErrorMsg0">没能创建主题，请先更改主题设定。</string>
+  <string name="restoreOkMsg">从SD卡恢复主题设置</string>
+  <string name="restoreErrorMsg">没有在 %s 找到主题设置文件</string>
+  <string name="NoMediaMessage">没有找到SD卡。</string>
+  <string name="EnterName">输入名称</string>
+  <string name="Themes">主题</string>
+  <string name="ApplyTheme">应用主题</string>
+  <string name="ApplyThemeSum">从本地文件夹应用xml主题</string>
+  <string name="MemberColor">成员颜色</string>
+  <string name="ChecksColor">对勾颜色</string>
+  <string name="MuteColor">静音图标颜色</string>
+  <string name="SendLogs">发送日志</string>
+  <string name="SendLogsEmpty">没有找到日志</string>
+  <string name="SendIcon">发送图标</string>
+  <string name="HideMobile">菜单中隐藏电话号码</string>
+  <string name="FloatingPencilColor">浮动图标颜色</string>
+  <string name="FloatingBGColor">浮动图标背景颜色</string>
+  <string name="Community">G+社区</string>
+  <string name="TypingColor">输入字体颜色</string>
+  <string name="EditTextIconsColor">输入栏图标颜色</string>
+  <string name="NavigationDrawer">导航栏抽屉</string>
+  <string name="OptionsList">选项列表</string>
+  <string name="ListColor">列表颜色</string>
+  <string name="OwnNameSize">名字大小</string>
+  <string name="PhoneColor">电话号码颜色</string>
+  <string name="PhoneSize">电话号码大小</string>
+  <string name="AvatarColor">头像颜色</string>
+  <string name="IconColor">选项图标颜色</string>
+  <string name="OptionColor">选项字体颜色</string>
+  <string name="OptionSize">选项字体大小</string>
+  <string name="VersionColor">版本号字体颜色</string>
+  <string name="VersionSize">版本号字体大小</string>
+  <string name="HeaderTitleColor">标题颜色</string>
+  <string name="HeaderIconsColor">标题图标颜色</string>
+  <string name="DividerColor">分隔线颜色</string>
+  <string name="AvatarRadius">头像半径</string>
+  <string name="SetMemberColor">设置成员颜色</string>
+  <string name="ForwardNameColor">转发名字颜色</string>
+  <string name="HeaderTitle">标题文字</string>
+  <string name="ForwardNoQuote">转发不带引用</string>
+  <string name="DisableMessageClick">禁用点击弹出框</string>
+  <string name="ProfileScreen">群组/联系人资料屏幕</string>
+  <string name="HideBackground">隐藏自定义背景图</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values-zh-rTW/strings.xml b/TMessagesProj/src/main/res/values-zh-rTW/strings.xml
new file mode 100644
index 000000000..439648f70
--- /dev/null
+++ b/TMessagesProj/src/main/res/values-zh-rTW/strings.xml
@@ -0,0 +1,899 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<resources>
+    <string name="AppName">Plus Messenger</string>
+    <string name="LanguageName">正體中文（台灣）</string>
+    <string name="LanguageNameInEnglish">Chinese Traditional (Taiwan)</string>
+    <string name="LanguageCode">zh_TW</string>
+    <!--signin view-->
+    <string name="YourPhone">您的電話</string>
+  <string name="StartText">請確認您的國碼並輸入您的電話號碼。</string>
+    <string name="ChooseCountry">選擇國家</string>
+    <string name="WrongCountry">錯誤的國碼</string>
+    <!--code enter view-->
+    <string name="YourCode">您的驗證碼</string>
+  <string name="SentSmsCode">我們已經傳送一則包含啟用碼的簡訊到您的電話</string>
+    <string name="CallText">在 %1$d:%2$02d 後，改用電話語音報驗證碼</string>
+    <string name="Calling">正在撥打給您...</string>
+    <string name="Code">驗證碼</string>
+    <string name="WrongNumber">號碼不對嗎？</string>
+    <string name="DidNotGetTheCode">仍未收到驗證碼？</string>
+    <!--signup view-->
+    <string name="YourName">您的名字</string>
+    <string name="RegisterText">設定您的姓名</string>
+    <!--<string name="RegisterText">Set up your name and picture</string>-->
+    <string name="FirstName">名字 (必填)</string>
+    <string name="LastName">姓氏 (選填)</string>
+    <string name="CancelRegistration">取消註冊</string>
+    <!--chats view-->
+    <string name="Settings">設定</string>
+    <string name="Contacts">聯絡人</string>
+    <string name="NewGroup">新增群組</string>
+    <string name="Yesterday">昨天</string>
+    <string name="NoResult">查無結果</string>
+    <string name="NoChats">還未曾聊過...</string>
+    <string name="NoChatsHelp">通過按下在右上角的新訊息按鈕開始傳訊\n，或點擊選單按鈕以獲得更多選項。</string>
+    <string name="WaitingForNetwork">等候可用網路...</string>
+    <string name="Connecting">連接中...</string>
+    <string name="Updating">更新中...</string>
+    <string name="NewSecretChat">新增私密聊天</string>
+    <string name="AwaitingEncryption">等待 %s 上線...</string>
+    <string name="EncryptionRejected">私密聊天已取消</string>
+    <string name="EncryptionProcessing">正在交換加密金鑰...</string>
+    <string name="EncryptedChatStartedOutgoing">%s 加入了您的私密聊天。</string>
+    <string name="EncryptedChatStartedIncoming">您加入了私密聊天。</string>
+    <string name="ClearHistory">清除聊天紀錄</string>
+    <string name="DeleteChat">刪除並離開</string>
+    <string name="DeleteChatUser">刪除聊天</string>
+    <string name="HiddenName">刪除帳號</string>
+    <string name="SelectChat">選擇聊天</string>
+    <string name="PhotoTip">點擊不放以檢視</string>
+    <string name="CompatibilityChat">%1$s 正在使用舊版的 Telegram，因此私密照片會以相容模式顯示。\n\n當 %2$s 更新了 Telegram 之後，自毀計時器設在 1 分鐘以內時，照片將開始以「點擊不放以檢視」模式運作，而對方執行螢幕快照時，您也將收到通知。</string>
+    <string name="SearchMessages">訊息</string>
+    <string name="Search">搜尋</string>
+    <string name="MuteNotifications">關閉訊息通知</string>
+    <string name="MuteFor">關閉通知 %1$s</string>
+    <string name="UnmuteNotifications">恢復訊息通知</string>
+    <string name="WillUnmuteIn">%1$s 後</string>
+    <string name="MuteDisable">停用</string>
+  <string name="Hashtags">主題標籤</string>
+    <!--broadcasts-->
+    <string name="NewBroadcastList">新增廣播名單</string>
+    <string name="EnterListName">輸入名單名稱</string>
+    <string name="YouCreatedBroadcastList">您建立了一份廣播名單</string>
+    <string name="AddRecipient">新增接收者</string>
+  <string name="KickFromBroadcast">從廣播名單中刪除</string>
+    <!--documents view-->
+    <string name="SelectFile">選擇檔案</string>
+    <string name="FreeOfTotal">剩餘 %1$s，共 %2$s</string>
+    <string name="UnknownError">不明錯誤</string>
+    <string name="AccessError">無法存取</string>
+    <string name="NoFiles">還沒有檔案...</string>
+    <string name="FileUploadLimit">檔案大小不應該超過 %1$s</string>
+    <string name="NotMounted">未掛載儲存空間</string>
+    <string name="UsbActive">已啟用 USB 傳輸</string>
+    <string name="InternalStorage">內部儲存空間</string>
+    <string name="ExternalStorage">外部儲存空間</string>
+    <string name="SystemRoot">系統根目錄</string>
+    <string name="SdCard">SD 卡</string>
+    <string name="Folder">資料夾</string>
+    <string name="GalleryInfo">傳送未壓縮的照片</string>
+    <!--chat view-->
+    <string name="Invisible">隱身</string>
+    <string name="Typing">正在輸入...</string>
+    <string name="IsTyping">正在輸入...</string>
+    <string name="AreTyping">都在輸入...</string>
+  <string name="IsRecordingAudio">%1$s 正在錄製音訊...</string>
+  <string name="IsSendingPhoto">%1$s 正在傳送照片...</string>
+  <string name="IsSendingVideo">%1$s 正在傳送影片...</string>
+  <string name="IsSendingFile">%1$s 正在傳送檔案...</string>
+  <string name="RecordingAudio">正在錄音...</string>
+  <string name="SendingPhoto">正在傳送照片...</string>
+  <string name="SendingVideoStatus">正在傳送影片...</string>
+  <string name="SendingFile">正在傳送檔案...</string>
+    <string name="GotAQuestion">對 Telegram 有疑問？</string>
+    <string name="ChatTakePhoto">拍攝照片</string>
+    <string name="ChatGallery">相簿</string>
+    <string name="ChatLocation">位置</string>
+    <string name="ChatVideo">影片</string>
+    <string name="ChatDocument">檔案</string>
+    <string name="NoMessages">這裡還沒有訊息...</string>
+    <string name="ForwardedMessage">轉寄的訊息</string>
+    <string name="From">來自</string>
+    <string name="NoRecent">沒有最近的</string>
+    <string name="Message">訊息</string>
+    <string name="TypeMessage">訊息</string>
+    <string name="ShareMyContactInfo">分享我的聯絡人</string>
+    <string name="AddToContacts">加入至聯絡人</string>
+    <string name="EncryptedPlaceholderTitleIncoming">%s 已邀請您加入私密聊天。</string>
+    <string name="EncryptedPlaceholderTitleOutgoing">您已邀請 %s 加入私密聊天。</string>
+    <string name="EncryptedDescriptionTitle">私密聊天：</string>
+    <string name="EncryptedDescription1">使用點對點加密</string>
+    <string name="EncryptedDescription2">不會在我們伺服器上留下紀錄</string>
+    <string name="EncryptedDescription3">使用自動銷毀計時器</string>
+    <string name="EncryptedDescription4">不允許轉寄</string>
+  <string name="YouWereKicked">您已從此群組中被刪除</string>
+    <string name="YouLeft">您離開了此群組</string>
+    <string name="DeleteThisGroup">刪除此群組</string>
+  <string name="DeleteThisChat">刪除這個聊天</string>
+    <string name="SlideToCancel">滑動以取消</string>
+    <string name="SaveToDownloads">儲存至下載</string>
+    <string name="ShareFile">分享</string>
+    <string name="ApplyLocalizationFile">套用在地化語系檔</string>
+    <string name="UnsupportedAttachment">不支援的附件</string>
+    <string name="SetTimer">設定自動銷毀計時器</string>
+    <string name="ServiceNotifications">服務通知</string>
+  <string name="GettingLinkInfo">正在取得連結資訊...</string>
+    <!--notification-->
+    <string name="MessageLifetimeChanged">%1$s 將自毀計時器設定為 %2$s</string>
+    <string name="MessageLifetimeChangedOutgoing">您將自毀計時器設定為 %1$s</string>
+    <string name="MessageLifetimeRemoved">%1$s 停用了自毀計時器</string>
+    <string name="MessageLifetimeYouRemoved">您停用了自毀計時器</string>
+    <string name="YouHaveNewMessage">您有一則新訊息</string>
+    <string name="NotificationMessageText">%1$s: %2$s</string>
+    <string name="NotificationMessageNoText">%1$s 傳送了新訊息給您</string>
+    <string name="NotificationMessagePhoto">%1$s 傳送了照片給您</string>
+    <string name="NotificationMessageVideo">%1$s 傳送了影片給您</string>
+    <string name="NotificationMessageContact">%1$s 分享了聯絡人給您</string>
+    <string name="NotificationMessageMap">%1$s 傳送了位置資訊給您</string>
+    <string name="NotificationMessageDocument">%1$s 傳給您一個檔案</string>
+    <string name="NotificationMessageAudio">%1$s 傳送了音訊給您</string>
+    <string name="NotificationMessageSticker">%1$s 傳送貼圖給您</string>
+    <string name="NotificationMessageGroupText">%1$s @ %2$s: %3$s</string>
+    <string name="NotificationMessageGroupNoText">%1$s 傳送了訊息到 %2$s 群組</string>
+    <string name="NotificationMessageGroupPhoto">%1$s 傳送了照片到 %2$s 群組</string>
+    <string name="NotificationMessageGroupVideo">%1$s 傳送了影片到 %2$s 群組</string>
+    <string name="NotificationMessageGroupContact">%1$s 分享了聯絡人資訊到 %2$s 群組</string>
+    <string name="NotificationMessageGroupMap">%1$s 傳送了位置資訊到 %2$s 群組</string>
+    <string name="NotificationMessageGroupDocument">%1$s 傳送一個檔案給 %2$s 群組</string>
+    <string name="NotificationMessageGroupAudio">%1$s 傳送了音訊到 %2$s 群組</string>
+    <string name="NotificationMessageGroupSticker">%1$s 傳送貼圖給 %2$s 群組</string>
+    <string name="NotificationInvitedToGroup">%1$s 已邀請您加入 %2$s 群組</string>
+    <string name="NotificationEditedGroupName">%1$s 編輯了 %2$s 群組的名稱</string>
+    <string name="NotificationEditedGroupPhoto">%1$s 編輯了 %2$s 群組的照片</string>
+    <string name="NotificationGroupAddMember">%1$s 已邀請 %3$s 加入 %2$s 群組</string>
+    <string name="NotificationGroupAddSelf">%1$s 返回到 %2$s 群組</string>
+  <string name="NotificationGroupKickMember">%1$s 將 %3$s 從 %2$s 群組中刪除</string>
+  <string name="NotificationGroupKickYou">%1$s 將您從 %2$s 群組中刪除</string>
+    <string name="NotificationGroupLeftMember">%1$s 已離開了 %2$s 群組</string>
+    <string name="NotificationContactJoined">%1$s 加入了 Telegram！</string>
+  <string name="NotificationUnrecognizedDevice">%1$s，\n我們偵測到有新裝置 %2$s 使用您的帳號登入\n\n裝置類型：%3$s\n位置：%4$s\n\n如果這不是您，您可以到「設定」&gt;「隱私和安全」&gt;「作用中的連線」裡，中斷該連線。\n\n如果您懷疑有人未經您的同意登入您的帳號，請在「隱私和安全」的設定中，啟用「兩步驟驗證」。\n\n感謝您！\nTelegram 團隊</string>
+    <string name="NotificationContactNewPhoto">%1$s 更新了個人照片</string>
+  <string name="NotificationInvitedToGroupByLink">%1$s 透過邀請連結加入了%2$s群組</string>
+    <string name="Reply">回覆</string>
+    <string name="ReplyToGroup">回覆%1$s</string>
+    <string name="ReplyToUser">回覆%1$s</string>
+    <string name="NotificationMessagesPeopleDisplayOrder">%1$s %2$s</string>
+    <!--contacts view-->
+    <string name="SelectContact">選擇聯絡人</string>
+    <string name="NoContacts">還沒有任何聯絡人</string>
+    <string name="InviteText">嗨，我們來改用 Plus Messenger 吧：http://goo.gl/jnmjnZ</string>
+    <string name="TodayAt">於</string>
+    <string name="YesterdayAt">於昨天</string>
+    <string name="Online">在線上</string>
+    <string name="LastSeen">最後上線</string>
+    <string name="LastSeenDate">最後上線</string>
+    <string name="InviteFriends">邀請朋友</string>
+    <string name="GlobalSearch">全域搜尋</string>
+    <string name="Lately">最後上線於不久前</string>
+    <string name="WithinAWeek">最後上線於一週內</string>
+    <string name="WithinAMonth">最後上線於一個月內</string>
+    <string name="ALongTimeAgo">最後上線於很久以前</string>
+    <string name="NewMessageTitle">新訊息</string>
+    <!--group create view-->
+    <string name="SendMessageTo">傳送訊息給...</string>
+    <string name="EnterGroupNamePlaceholder">輸入群組名稱</string>
+    <string name="GroupName">群組名稱</string>
+    <string name="MembersCount">%1$d/%2$d 為成員</string>
+  <string name="JoinToGroup">您是否想要加入群組 \'%1$s\'？</string>
+  <string name="JoinToGroupErrorFull">不好意思，但這個群組已經滿額了。</string>
+  <string name="JoinToGroupErrorNotExist">很抱歉，這個群組似乎並不存在。</string>
+  <string name="LinkCopied">「連結」已複製到剪貼簿</string>
+  <string name="InviteToGroupByLink">透過連結邀請到群組</string>
+  <string name="InviteLink">邀請連結</string>
+  <string name="RevokeAlert">您確定要撤銷此連結？一旦您這樣做，沒有人能夠使用它加入群組。</string>
+  <string name="RevokeAlertNewLink">先前的邀請連結現在已經沒有作用。而一個新的連結已經產生了。</string>
+  <string name="RevokeButton">撤銷</string>
+  <string name="RevokeLink">撤銷連結</string>
+  <string name="CopyLink">複製連結</string>
+  <string name="ShareLink">分享連結</string>
+  <string name="LinkInfo">任何已安裝 Telegram 的人可以透過遵循此連結加入到您的群組。</string>
+    <!--group info view-->
+    <string name="SharedMedia">共享的媒體</string>
+    <string name="SETTINGS">設定</string>
+    <string name="AddMember">新增成員</string>
+    <string name="DeleteAndExit">刪除並離開群組</string>
+    <string name="Notifications">通知</string>
+  <string name="KickFromGroup">從群組中刪除</string>
+    <!--contact info view-->
+    <string name="ShareContact">分享</string>
+    <string name="AddContact">加入</string>
+    <string name="AddContactTitle">新增聯絡人</string>
+    <string name="BlockContact">封鎖</string>
+    <string name="EditContact">編輯</string>
+    <string name="DeleteContact">刪除</string>
+    <string name="PhoneHome">住家</string>
+    <string name="PhoneMobile">手機</string>
+    <string name="PhoneWork">工作</string>
+    <string name="PhoneOther">其他</string>
+    <string name="PhoneMain">主要</string>
+    <string name="StartEncryptedChat">開始私密聊天</string>
+    <string name="CreateEncryptedChatError">發生錯誤。</string>
+    <string name="EncryptionKey">加密金鑰</string>
+    <string name="MessageLifetime">自動銷毀計時器</string>
+    <string name="ShortMessageLifetimeForever">關閉</string>
+    <string name="EncryptionKeyDescription">這張圖片是您與 <![CDATA[<b>]]>%1$s<![CDATA[</b>]]> 私密聊天的視覺化加密金鑰。<![CDATA[<br><br>]]>若此圖片與 <![CDATA[<b>]]>%2$s 的<![CDATA[</b>]]> 手機上的圖片看起來一樣，則您與對方的聊天是 200%% 安全的。<![CDATA[<br><br>]]>到 telegram.org 了解更多資訊</string>
+    <string name="NumberUnknown">未知</string>
+    <string name="Info">資訊</string>
+    <string name="Phone">電話</string>
+    <!--usernames-->
+    <string name="Username">用戶名稱</string>
+    <string name="UsernamePlaceholder">您的用戶名稱</string>
+    <string name="UsernameInUse">很抱歉，此用戶名稱已被他人使用。</string>
+    <string name="UsernameInvalid">很抱歉，此用戶名稱無效。</string>
+    <string name="UsernameInvalidShort">用戶名稱必須至少有5個字母。 </string>
+    <string name="UsernameInvalidLong">用戶名稱不能超過32個字元。</string>
+    <string name="UsernameInvalidStartNumber">很抱歉，用戶名稱不能以數字開頭。</string>
+    <string name="UsernameHelp">您可以在 <![CDATA[<b>]]>Plus Messenger<![CDATA[</b>]]> 上選擇用戶名稱。如果您這樣做，別人就可以藉由此用戶名稱找到您及與您聯絡，而不需要知道您的手機號碼。<![CDATA[<br><br>]]>您可以使用 <![CDATA[<b>]]>a–z<![CDATA[</b>]]>，<![CDATA[<b>]]>0–9<![CDATA[</b>]]> 及底線。最小長度是 <![CDATA[<b>]]>5<![CDATA[</b>]]> 個字元。</string>
+    <string name="UsernameChecking">正在檢查用戶名稱...</string>
+    <string name="UsernameAvailable">%1$s 是可用的。</string>
+    <string name="UsernameEmpty">無</string>
+    <string name="ErrorOccurred">發生錯誤。</string>
+    <!--settings view-->
+    <string name="ResetNotificationsText">重設所有通知設定為預設值</string>
+    <string name="TextSize">訊息的字體大小</string>
+    <string name="AskAQuestion">提出疑問</string>
+    <string name="EnableAnimations">使用動畫效果</string>
+    <string name="Unblock">解除封鎖</string>
+    <string name="UnblockText">點擊不放用戶以解除封鎖。</string>
+    <string name="NoBlocked">還沒有被封鎖的用戶</string>
+    <string name="MessageNotifications">訊息通知</string>
+    <string name="Alert">提醒</string>
+    <string name="MessagePreview">訊息預覽</string>
+    <string name="GroupNotifications">群組通知</string>
+    <string name="Sound">音效</string>
+    <string name="InAppNotifications">應用程式內通知</string>
+    <string name="InAppSounds">應用程式內音效</string>
+    <string name="InAppVibrate">應用程式內震動</string>
+    <string name="Vibrate">震動</string>
+    <string name="InAppPreview">應用程式內預覽</string>
+    <string name="Reset">重置</string>
+    <string name="ResetAllNotifications">重設所有通知</string>
+    <string name="UndoAllCustom">重設您對所有聯絡人與群組調整的自訂通知設定</string>
+    <string name="NotificationsAndSounds">通知與音效</string>
+    <string name="BlockedUsers">被封鎖的用戶</string>
+    <string name="LogOut">登出</string>
+    <string name="NoSound">無音效</string>
+    <string name="Default">預設</string>
+    <string name="Support">支援</string>
+  <string name="OnlyIfSilent">只在若是沉默</string>
+    <string name="ChatBackground">聊天室背景</string>
+    <string name="MessagesSettings">訊息</string>
+    <string name="SendByEnter">按下 Enter 就送出訊息</string>
+    <string name="TerminateAllSessions">中斷其他連線</string>
+    <string name="Events">事件</string>
+    <string name="ContactJoined">聯絡人加入 Telegram</string>
+    <string name="Pebble">PEBBLE</string>
+    <string name="Language">語言</string>
+    <string name="AskAQuestionInfo">請注意，Telegram 的技術支援是由志工提供，我們會試著盡快回覆但還是可能需要一點時間。<![CDATA[<br><br>]]>請見 <![CDATA[<a href=\"http://telegram.org/faq#general\">Telegram FAQ</a>]]>: 當中包含了大多數問題的答案與<![CDATA[<a href=\"http://telegram.org/faq#troubleshooting\">疑難排解</a>]]>時的重要方式。</string>
+    <string name="AskButton">詢問志工</string>
+    <string name="TelegramFaq">Telegram FAQ</string>
+    <string name="TelegramFaqUrl">https://telegram.org/faq</string>
+    <string name="DeleteLocalization">刪除在地化語系檔？</string>
+    <string name="IncorrectLocalization">語系檔不正確</string>
+    <string name="Enabled">啟用</string>
+  <string name="Disabled">停用</string>
+    <string name="NotificationsService">通知服務</string>
+    <string name="NotificationsServiceDisableInfo">如 Google Play 服務能夠讓你收到通知，您可以停用通知服務。但是我們建議您把它啟用，以保持應用程式於背景運作及接收即時通知。</string>
+    <string name="SortBy">排序</string>
+    <string name="ImportContacts">匯入聯絡人</string>
+    <string name="SortFirstName">名字</string>
+    <string name="SortLastName">姓氏</string>
+    <string name="LedColor">LED 色彩</string>
+    <string name="PopupNotification">彈出通知</string>
+    <string name="NoPopup">不彈出</string>
+    <string name="OnlyWhenScreenOn">只在螢幕開啟時</string>
+    <string name="OnlyWhenScreenOff">只在螢幕關閉時</string>
+    <string name="AlwaysShowPopup">總是彈出</string>
+    <string name="BadgeNumber">徽章計數器</string>
+    <string name="Short">短</string>
+    <string name="Long">長</string>
+    <string name="SystemDefault">系統預設</string>
+    <string name="SettingsDefault">本程式預設</string>
+    <string name="AutomaticMediaDownload">自動下載媒體</string>
+    <string name="WhenUsingMobileData">使用行動數據時</string>
+    <string name="WhenConnectedOnWiFi">使用 Wi-Fi 時</string>
+    <string name="WhenRoaming">漫遊時</string>
+    <string name="NoMediaAutoDownload">沒有媒體</string>
+    <string name="SaveToGallerySettings">另存到相簿／圖片庫</string>
+    <string name="EditName">編輯名稱</string>
+    <string name="NotificationsPriority">優先程度</string>
+    <string name="NotificationsPriorityDefault">預設</string>
+    <string name="NotificationsPriorityLow">低</string>
+    <string name="NotificationsPriorityHigh">高</string>
+    <string name="NotificationsPriorityMax">最大</string>
+    <string name="RepeatNotificationsNever">從未</string>
+    <string name="RepeatNotifications">重複通知</string>
+    <string name="PhoneNumberHelp">您可以在這裡改變 Telegram 所綁定的電話號碼。您的帳號和所有您的雲端資料 — 訊息、媒體、聯絡人...等，將被移動到新的號碼。\n\n<![CDATA[<b>重要提示：</b>]]> 您的所有 Telegram 聯絡人將取得您的 <![CDATA[<b>新號碼</b>]]> ，並加入到他們的手機通訊錄中，條件是他們有您的舊號碼，且您沒有在 Telegram 中封鎖他們。</string>
+    <string name="PhoneNumberAlert">您的所有 Telegram 聯絡人將取得您的新號碼，並加入到他們的手機通訊錄中，條件是他們有您的舊號碼，且您沒有在 Telegram 中封鎖他們。</string>
+    <string name="PhoneNumberChange">變更號碼</string>
+    <string name="ChangePhoneNewNumber">新號碼</string>
+    <string name="ChangePhoneHelp">我們將傳送包含驗證碼的簡訊到您的新電話號碼。</string>
+    <string name="ChangePhoneNumberOccupied">號碼 %1$s 已經連接到一個 Telegram 帳號。遷移到新號碼之前，請刪除該帳號。</string>
+    <string name="NotificationsOther">其他</string>
+  <string name="NotificationsDisabled">停用</string>
+  <string name="VibrationDisabled">停用</string>
+  <string name="LedDisabled">停用</string>
+    <string name="RepeatDisabled">關閉</string>
+  <string name="InChatSound">聊天音效</string>
+  <string name="SoundDefault">預設</string>
+  <string name="SmartNotifications">智慧型通知</string>
+  <string name="SmartNotificationsDisabled">停用</string>
+  <string name="SmartNotificationsInfo">最大聲 %1$s 不超過 %2$s</string>
+  <string name="SmartNotificationsSoundAtMost">最大聲</string>
+  <string name="SmartNotificationsTimes">次數</string>
+  <string name="SmartNotificationsWithin">不超過</string>
+  <string name="SmartNotificationsMinutes">分鐘</string>
+  <!--sessions view-->
+  <string name="SessionsTitle">作用中的連線</string>
+  <string name="CurrentSession">目前的連線</string>
+  <string name="NoOtherSessions">沒有其他作用中的連線</string>
+  <string name="NoOtherSessionsInfo">您可以透過使用同一組電話號碼，在其他手提電話、平板電腦及桌面裝置上登入 Telegram。您的所有數據均會立即同步。</string>
+  <string name="OtherSessions">作用中的連線</string>
+  <string name="SessionsInfo">控制您在其他裝置上的連線。</string>
+  <string name="TerminateSessionInfo">請點擊要中斷的連線。</string>
+  <string name="TerminateSessionQuestion">要中斷這個連線嗎？</string>
+  <string name="UnofficialApp">非官方應用程式</string>
+    <!--passcode view-->
+  <string name="Passcode">通行密碼鎖</string>
+    <string name="ChangePasscode">變更通行密碼</string>
+    <string name="ChangePasscodeInfo">當您設置了一個額外的通行密碼，一個鎖形圖示將出現在聊天頁面上。點擊它來鎖定和解鎖您的 Telegram 程式。\n\n注意：如果您忘記了通行密碼，您將需要刪除並重新安裝應用程式。而所有的私密聊天紀錄都將遺失。</string>
+    <string name="ChangePasscodeAlert">現在，您將看到聊天紀錄頁面上的鎖形圖示。點擊它，用您的新通行密碼鎖定您的 Telegram 應用程式。</string>
+    <string name="PasscodePIN">PIN碼</string>
+    <string name="PasscodePassword">密碼</string>
+    <string name="EnterCurrentPasscode">輸入您目前使用的通行密碼</string>
+  <string name="EnterNewFirstPasscode">輸入一組通行密碼</string>
+    <string name="EnterNewPasscode">輸入您的新通行密碼</string>
+    <string name="EnterYourPasscode">輸入您的通行密碼</string>
+    <string name="ReEnterYourPasscode">再次輸入您的新通行密碼</string>
+  <string name="InvalidPasscode">無效的通行密碼</string>
+    <string name="PasscodeDoNotMatch">通行密碼不一致</string>
+    <string name="AutoLock">自動鎖定</string>
+  <string name="AutoLockInfo">要求通行密碼，如果您離開了一段時間。</string>
+    <string name="AutoLockInTime">於 %1$s</string>
+  <string name="AutoLockDisabled">停用</string>
+    <!--media view-->
+  <string name="NoMedia">在此對話群組內分享照片與影片，且只能透過您已登入的裝置來存取。</string>
+    <string name="DocumentsTitle">多個檔案</string>
+    <string name="SharedMediaTitle">共享的媒體</string>
+  <string name="NoSharedFiles">在此對話群組內分享檔案與文件，且只能透過您已登入的裝置來存取。</string>
+    <!--map view-->
+    <string name="Map">地圖</string>
+    <string name="Satellite">衛星</string>
+    <string name="Hybrid">混合</string>
+    <string name="MetersAway">公尺遠</string>
+    <string name="KMetersAway">公里遠</string>
+  <string name="SendLocation">傳送您目前的位置</string>
+  <string name="SendSelectedLocation">傳送選擇的位置</string>
+  <string name="ShareLocation">位置</string>
+  <string name="AccurateTo">精確到 %1$s</string>
+  <string name="NearbyPlaces">或者選擇一個地方</string>
+    <!--photo gallery view-->
+    <string name="ShowAllMedia">顯示所有媒體</string>
+    <string name="SaveToGallery">儲存至相簿</string>
+    <string name="Of">第 %1$d 張，共 %2$d 張</string>
+    <string name="Gallery">相簿</string>
+    <string name="AllPhotos">所有照片</string>
+  <string name="AllVideo">所有影片</string>
+    <string name="NoPhotos">還沒有照片</string>
+  <string name="NoVideo">尚無影片</string>
+    <string name="PleaseDownload">請先下載媒體</string>
+    <string name="NoRecentPhotos">沒有最近的照片</string>
+  <string name="NoRecentGIFs">沒有最近的 GIF 圖檔</string>
+    <string name="SearchImages">尋找圖片</string>
+    <string name="SearchImagesInfo">網頁搜尋</string>
+    <string name="SearchGifs">尋找 GIF 圖檔 </string>
+    <string name="SearchImagesTitle">搜尋網頁</string>
+  <string name="SearchGifsTitle">搜尋 GIF 圖檔</string>
+    <string name="CropImage">裁切影像</string>
+    <string name="EditImage">編輯影像</string>
+    <string name="Enhance">補強</string>
+    <string name="Highlights">強調</string>
+    <string name="Contrast">對比</string>
+    <string name="Exposure">曝光</string>
+    <string name="Warmth">色溫</string>
+    <string name="Saturation">飽和度</string>
+    <string name="Vignette">暗角</string>
+    <string name="Shadows">陰影</string>
+    <string name="Grain">增益</string>
+    <string name="Sharpen">銳利化</string>
+    <string name="Blur">模糊化</string>
+    <string name="BlurOff">關閉</string>
+    <string name="BlurLinear">直線的</string>
+    <string name="BlurRadial">放射狀的</string>
+    <string name="AreYouSureDeletePhoto">您確定要刪除此照片？</string>
+    <string name="AreYouSureDeleteVideo">您確定要刪除此影片？</string>
+    <string name="DiscardChanges">放棄變更？</string>
+  <string name="ClearSearch">清除搜尋紀錄</string>
+  <string name="ClearButton">清除</string>
+  <string name="PickerPhotos">照片</string>
+  <string name="PickerVideo">影片</string>
+  <string name="AddCaption">加入一標題...</string>
+  <string name="PhotoCaption">照片標題</string>
+  <string name="VideoCaption">影片標題</string>
+  <!--password view-->
+  <string name="TwoStepVerification">兩步驟驗證</string>
+  <string name="SetAdditionalPassword">設定額外的密碼</string>
+  <string name="SetAdditionalPasswordInfo">您可以設定當您登入到一個新裝置上時，除了輸入透過簡訊取得的驗證碼外，另外要輸入的密碼。</string>
+  <string name="YourPassword">您的密碼</string>
+  <string name="PleaseEnterCurrentPassword">請輸入您的密碼</string>
+  <string name="PleaseEnterFirstPassword">輸入密碼</string>
+  <string name="PleaseEnterPassword">請輸入您的新密碼</string>
+  <string name="PleaseReEnterPassword">請再次輸入您的密碼</string>
+  <string name="RecoveryEmail">恢復用的電子郵件</string>
+  <string name="YourEmail">您的電子郵件</string>
+  <string name="YourEmailInfo">請添加您的有效電子郵件。這是找回忘記的密碼唯一的途徑。</string>
+  <string name="YourEmailSkip">跳過</string>
+  <string name="YourEmailSkipWarning">警告</string>
+  <string name="YourEmailSkipWarningText">糟糕，那是很嚴重的。\n\n如果您忘記密碼，您將無法存取您的 Telegram 帳號。也就沒有辦法恢復它了。</string>
+  <string name="YourEmailAlmostThere">差不多了！</string>
+  <string name="YourEmailAlmostThereText">請檢查您的電子郵件 (別忘了垃圾郵件資料夾)，以完成兩步驟驗證設定。</string>
+  <string name="YourPasswordSuccess">成功了！</string>
+  <string name="YourPasswordSuccessText">您用於兩步驟驗證的密碼現在起作用了。</string>
+  <string name="ChangePassword">變更密碼</string>
+  <string name="TurnPasswordOff">關閉密碼</string>
+  <string name="SetRecoveryEmail">設定恢復用的電子郵件</string>
+  <string name="ChangeRecoveryEmail">變更恢復用的電子郵件</string>
+  <string name="TurnPasswordOffQuestion">您確定要停用密碼？</string>
+  <string name="PasswordHint">密碼提示</string>
+  <string name="PasswordHintText">請為您的密碼建立一個提示</string>
+  <string name="PasswordDoNotMatch">密碼並不相符</string>
+  <string name="AbortPassword">終止兩步驟驗證設定</string>
+  <string name="EmailPasswordConfirmText">請按照以下步驟來完成兩步驟驗證設定：\n\n1. 檢查您的電子郵件 (別忘了垃圾郵件資料夾) \n%1$s\n\n2. 點擊驗證連結。</string>
+  <string name="PasswordAsHintError">提示必須跟您的密碼不同</string>
+  <string name="PasswordEmailInvalid">無效的電子郵件</string>
+  <string name="RestorePasswordNoEmailTitle">很抱歉</string>
+  <string name="RestorePasswordNoEmailText">由於您在設定密碼時沒有提供恢復用的電子郵件，您剩餘的選項就是要記住您的密碼，或是重設您的帳號。</string>
+  <string name="RestoreEmailSent">我們已經傳送一組恢復用的驗證碼到您所提供的電子郵件：\n\n%1$s</string>
+  <string name="RestoreEmailSentInfo">請檢查您的電子郵件，並輸入我們在這裡傳送的6位數驗證碼。</string>
+  <string name="RestoreEmailTrouble">無法存取您的電子郵件 %1$s？</string>
+  <string name="RestoreEmailTroubleText">如果無法恢復存取您的電子郵件，您剩下的選項就是要記住您的密碼或重設您的帳號。</string>
+  <string name="ResetMyAccount">重置我的帳號</string>
+  <string name="ResetMyAccountText">如果您繼續重設您的帳號，您將失去所有的聊天紀錄和訊息，連同您所分享過的任何媒體和檔案。</string>
+  <string name="ResetMyAccountWarning">警告</string>
+  <string name="ResetMyAccountWarningText">這動作無法還原。\n\n如果您重設您的帳號，您的所有訊息和聊天紀錄都將被刪除。</string>
+  <string name="ResetMyAccountWarningReset">重置</string>
+  <string name="LoginPassword">密碼</string>
+  <string name="LoginPasswordText">您已經啟用了「兩步驟驗證」，因此您的帳號被一個額外的密碼所保護。</string>
+  <string name="ForgotPassword">忘記密碼了嗎？</string>
+  <string name="PasswordRecovery">密碼恢復</string>
+  <string name="PasswordCode">驗證碼</string>
+  <string name="PasswordReset">密碼不再有效</string>
+  <string name="EnabledPasswordText">您已啟動了「兩步驟驗證」。\n您需要提供您先前設立的密碼，才可以登入您的 Telegram 帳號。</string>
+  <string name="PendingEmailText">您的恢復用電子郵件 %1$s 還沒有起作用，正等候確認。</string>
+    <!--privacy settings-->
+    <string name="PrivacySettings">隱私和安全</string>
+    <string name="PrivacyTitle">隱私</string>
+    <string name="PrivacyLastSeen">最後上線</string>
+    <string name="LastSeenEverybody">每個人</string>
+    <string name="LastSeenContacts">我的聯絡人</string>
+    <string name="LastSeenNobody">沒有人</string>
+    <string name="LastSeenEverybodyMinus">每個人 (-%1$d)</string>
+    <string name="LastSeenContactsPlus">我的聯絡人 (+%1$d)</string>
+    <string name="LastSeenContactsMinus">我的聯絡人 (-%1$d)</string>
+    <string name="LastSeenContactsMinusPlus">我的聯絡人 (-%1$d, +%2$d)</string>
+    <string name="LastSeenNobodyPlus">沒有人 (+%1$d)</string>
+    <string name="SecurityTitle">安全</string>
+    <string name="DeleteAccountTitle">帳號自動銷毀</string>
+    <string name="DeleteAccountIfAwayFor">如果您離開</string>
+    <string name="DeleteAccountHelp">如果您在此期間內不至少登入一次，您的帳號將與您所有的群組、訊息和聯絡人一並刪除。</string>
+    <string name="DeleteAccountNowConfirmation">刪除您的帳號嗎？</string>
+    <string name="LastSeenHelp">變更誰可以看見您最後上線的時間。</string>
+    <string name="LastSeenTitle">誰可以看見您的最後上線時間？</string>
+    <string name="AddExceptions">新增例外</string>
+    <string name="CustomHelp">重要提示：您不分享您最後上線時間的對象，他們的最後上線時間，您也將無法看見。取而代之的是大概的最後上線時間 ( 最近，一週之內，一個月之內 )。</string>
+    <string name="AlwaysShareWith">總是分享與</string>
+    <string name="NeverShareWith">永不分享與</string>
+    <string name="CustomShareSettingsHelp">這些設定將覆蓋上述值。</string>
+    <string name="AlwaysShareWithTitle">總是分享</string>
+    <string name="AlwaysShareWithPlaceholder">總是與用戶分享...</string>
+    <string name="NeverShareWithTitle">永不分享</string>
+    <string name="NeverShareWithPlaceholder">永不與用戶分享...</string>
+    <string name="EmpryUsersPlaceholder">加入用戶</string>
+    <string name="PrivacyFloodControlError">很抱歉，太多的請求。現在無法變更隱私設定，請稍候。</string>
+    <string name="ClearOtherSessionsHelp">登出所有其他裝置，只保留這個。</string>
+    <string name="RemoveFromListText">點擊不放用戶以刪除。</string>
+    <!--edit video view-->
+    <string name="EditVideo">編輯影片</string>
+    <string name="OriginalVideo">原始影片</string>
+    <string name="EditedVideo">編輯的影片</string>
+    <string name="SendingVideo">傳送影片中…</string>
+  <string name="CompressVideo">壓縮影片</string>
+    <!--button titles-->
+    <string name="Next">下一步</string>
+    <string name="Back">上一步</string>
+    <string name="Done">完成</string>
+    <string name="Open">開啟</string>
+    <string name="Cancel">取消</string>
+    <string name="Add">加入</string>
+    <string name="Edit">編輯</string>
+    <string name="Send">傳送</string>
+    <string name="Call">撥打</string>
+    <string name="Copy">複製</string>
+    <string name="Delete">刪除</string>
+    <string name="Forward">轉寄</string>
+    <string name="Retry">重試</string>
+    <string name="FromCamera">來自相機</string>
+    <string name="FromGalley">來自相簿</string>
+    <string name="DeletePhoto">刪除照片</string>
+    <string name="Set">設定</string>
+    <string name="OK">確定</string>
+    <string name="Crop">裁切</string>
+    <!--messages-->
+  <string name="ActionInviteYou">您透過邀請連結加入了群組</string>
+  <string name="ActionInviteUser">un1 透過邀請連結加入了群組</string>
+  <string name="ActionKickUser">un1 刪除了 un2</string>
+    <string name="ActionLeftUser">un1 離開了群組</string>
+    <string name="ActionAddUser">un1 加入了 un2</string>
+  <string name="ActionRemovedPhoto">un1 刪除了群組照片</string>
+    <string name="ActionChangedPhoto">un1 變更了群組照片</string>
+    <string name="ActionChangedTitle">un1 將群組名稱變更為 un2</string>
+    <string name="ActionCreateGroup">un1 建立了群組</string>
+  <string name="ActionYouKickUser">您刪除了 un2</string>
+    <string name="ActionYouLeftUser">您離開了群組</string>
+    <string name="ActionYouAddUser">您加入了 un2</string>
+  <string name="ActionYouRemovedPhoto">您刪除了群組照片</string>
+    <string name="ActionYouChangedPhoto">您變更了群組照片</string>
+    <string name="ActionYouChangedTitle">您將群組名稱變更為 un2</string>
+    <string name="ActionYouCreateGroup">您建立了群組</string>
+  <string name="ActionKickUserYou">un1 刪除了您</string>
+    <string name="ActionAddUserYou">un1 已將您加入</string>
+    <string name="ActionAddUserSelf">un1 返回到群組</string>
+    <string name="UnsuppotedMedia">您使用的 Telegram 版本無法顯示此訊息。請更新應用程式: http://telegram.org/update</string>
+    <string name="AttachPhoto">照片</string>
+    <string name="AttachVideo">影片</string>
+    <string name="AttachLocation">位置</string>
+    <string name="AttachContact">聯絡人</string>
+    <string name="AttachDocument">檔案</string>
+    <string name="AttachSticker">貼圖</string>
+    <string name="AttachAudio">音訊</string>
+    <string name="FromYou">您</string>
+    <string name="ActionTakeScreenshootYou">您拍攝了螢幕快照！</string>
+    <string name="ActionTakeScreenshoot">un1 拍攝了螢幕快照！</string>
+    <!--Alert messages-->
+    <string name="InvalidPhoneNumber">手機號碼無效</string>
+    <string name="CodeExpired">驗證碼已過期，請重新登入</string>
+    <string name="FloodWait">嘗試太多次了，請稍後再試</string>
+  <string name="FloodWaitTime">嘗試太多次了，請於 %1$s 後再試</string>
+    <string name="InvalidCode">驗證碼無效</string>
+    <string name="InvalidFirstName">姓氏無效</string>
+    <string name="InvalidLastName">名字無效</string>
+    <string name="Loading">載入中……</string>
+    <string name="NoPlayerInstalled">您沒有影片播放器，請安裝一套</string>
+  <string name="NoMailInstalled">請以電子郵件說明您的問題並寄送到 sms@stel.com。</string>
+    <string name="NoHandleAppInstalled">您沒有任何應用程式可處理 \'%1$s\' 的檔案類型，請先安裝一個以繼續</string>
+    <string name="InviteUser">這位聯絡人尚未使用 Telegram，要傳送邀請訊息嗎？</string>
+    <string name="AreYouSure">您確定嗎？</string>
+    <string name="AddToTheGroup">將 %1$s 加入群組？\n\n最後要轉寄的訊息數目：</string>
+    <string name="ForwardMessagesTo">轉寄訊息給 %1$s？</string>
+    <string name="SendMessagesTo">傳送訊息給 %1$s？</string>
+    <string name="AreYouSureLogout">您確定要登出？\n\n請注意，您可以無縫地在所有裝置上同時使用 Telegram。 請記住，登出會讓您所有的私密聊天內容丟失。</string>
+    <string name="AreYouSureSessions">您確定要中斷其他連線？</string>
+    <string name="AreYouSureDeleteAndExit">您確定想要刪除並離開群組？</string>
+    <string name="AreYouSureDeleteThisChat">您確定要刪除此聊天？</string>
+    <string name="AreYouSureShareMyContactInfo">確定要分享您的聯絡資料？</string>
+    <string name="AreYouSureBlockContact">您確定要封鎖此聯絡人？</string>
+    <string name="AreYouSureUnblockContact">您確定要解除封鎖此聯絡人？</string>
+    <string name="AreYouSureDeleteContact">您確定要刪除此聯絡人？</string>
+    <string name="AreYouSureSecretChat">確定要建立新的私密聊天？</string>
+    <string name="AreYouSureRegistration">您確定要取消註冊？</string>
+    <string name="AreYouSureClearHistory">您確定要清除聊天紀錄？</string>
+    <string name="AreYouSureDeleteMessages">您確定要刪除 %1$s？</string>
+    <string name="SendMessagesToGroup">傳送訊息給 %1$s？</string>
+    <string name="ForwardMessagesToGroup">轉寄訊息給 %1$s？</string>
+    <string name="FeatureUnavailable">很抱歉，此功能目前無法在您的國家使用。</string>
+   <!--Intro view-->
+    <string name="Page1Title">Plus Messenger</string>
+    <string name="Page2Title">快速</string>
+    <string name="Page3Title">免費</string>
+    <string name="Page4Title">安全</string>
+    <string name="Page5Title">強大</string>
+    <string name="Page6Title">以雲端為基礎</string>
+    <string name="Page7Title">私密</string>
+    <string name="Page1Message"><![CDATA[<b>Plus Messenger</b>]]> 傳訊應用軟體。<![CDATA[<br/>]]>它是<![CDATA[<b>免費</b>]]> 而 <![CDATA[<b>安全</b>]]>的。</string>
+    <string name="Page2Message"><![CDATA[<b>Plus Messenger</b>]]> 傳遞訊息的速度<![CDATA[<br/>]]>比其他任何軟體都快。</string>
+    <string name="Page3Message"><![CDATA[<b>Plus Messenger</b>]]> 永遠免費，沒有廣告，<![CDATA[<br/>]]>更不用年費。</string>
+    <string name="Page4Message"><![CDATA[<b>Plus Messenger</b>]]> 讓您的訊息保持安全<![CDATA[<br/>]]>免於被駭客攻擊。</string>
+    <string name="Page5Message"><![CDATA[<b>Plus Messenger</b>]]> 沒有流量的限制，<![CDATA[<br/>]]>不論媒體檔案與聊天訊息。</string>
+    <string name="Page6Message"><![CDATA[<b>Plus Messenger</b>]]> 讓您可以<![CDATA[<br/>]]>在多個不同裝置中收發訊息。</string>
+    <string name="Page7Message"><![CDATA[<b>Plus Messenger</b>]]> 針對訊息的收發都採高度加密，<![CDATA[<br/>]]>且還能自動銷毀。</string>
+    <string name="StartMessaging">開始傳訊</string>
+    <!--plural-->
+    <string name="Online_zero">%1$d 在線上</string>
+    <string name="Online_one">%1$d 在線上</string>
+    <string name="Online_two">%1$d 在線上</string>
+    <string name="Online_few">%1$d 在線上</string>
+    <string name="Online_many">%1$d 在線上</string>
+    <string name="Online_other">%1$d 在線上</string>
+    <string name="Members_zero">無成員</string>
+    <string name="Members_one">%1$d 位成員</string>
+    <string name="Members_two">%1$d 位成員</string>
+    <string name="Members_few">%1$d 位成員</string>
+    <string name="Members_many">%1$d 位成員</string>
+    <string name="Members_other">%1$d 位成員</string>
+    <string name="AndMoreTyping_zero">還有 %1$d 個人在輸入中</string>
+    <string name="AndMoreTyping_one">還有 %1$d 個人在輸入中</string>
+    <string name="AndMoreTyping_two">還有 %1$d 個人在輸入中</string>
+    <string name="AndMoreTyping_few">還有 %1$d 個人在輸入中</string>
+    <string name="AndMoreTyping_many">還有 %1$d 個人在輸入中</string>
+    <string name="AndMoreTyping_other">還有 %1$d 個人在輸入中</string>
+    <string name="NewMessages_zero">沒有新訊息</string>
+    <string name="NewMessages_one">%1$d 則新訊息</string>
+    <string name="NewMessages_two">%1$d 則新訊息</string>
+    <string name="NewMessages_few">%1$d 則新訊息</string>
+    <string name="NewMessages_many">%1$d 則新訊息</string>
+    <string name="NewMessages_other">%1$d 則新訊息</string>
+    <string name="messages_zero">沒有訊息</string>
+    <string name="messages_one">%1$d 則訊息</string>
+    <string name="messages_two">%1$d 則訊息</string>
+    <string name="messages_few">%1$d 則訊息</string>
+    <string name="messages_many">%1$d 則訊息</string>
+    <string name="messages_other">%1$d 則訊息</string>
+    <string name="items_zero">沒有項目</string>
+    <string name="items_one">%1$d 項目</string>
+    <string name="items_two">%1$d 項目</string>
+    <string name="items_few">%1$d 項目</string>
+    <string name="items_many">%1$d 項目</string>
+    <string name="items_other">%1$d 項目</string>
+    <string name="FromChats_zero">來自沒有任何聊天紀錄</string>
+    <string name="FromChats_one">來自 %1$d 聊天紀錄</string>
+    <string name="FromChats_two">來自 %1$d 聊天紀錄</string>
+    <string name="FromChats_few">來自 %1$d 聊天紀錄</string>
+    <string name="FromChats_many">來自 %1$d 聊天紀錄</string>
+    <string name="FromChats_other">來自 %1$d 聊天紀錄</string>
+    <string name="Seconds_zero">%1$d 秒鐘</string>
+    <string name="Seconds_one">%1$d 秒鐘</string>
+    <string name="Seconds_two">%1$d 秒鐘</string>
+    <string name="Seconds_few">%1$d 秒鐘</string>
+    <string name="Seconds_many">%1$d 秒鐘</string>
+    <string name="Seconds_other">%1$d 秒鐘</string>
+    <string name="Minutes_zero">%1$d 分鐘</string>
+    <string name="Minutes_one">%1$d 分鐘</string>
+    <string name="Minutes_two">%1$d 分鐘</string>
+    <string name="Minutes_few">%1$d 分鐘</string>
+    <string name="Minutes_many">%1$d 分鐘</string>
+    <string name="Minutes_other">%1$d 分鐘</string>
+    <string name="Hours_zero">%1$d 小時</string>
+    <string name="Hours_one">%1$d 小時</string>
+    <string name="Hours_two">%1$d 小時</string>
+    <string name="Hours_few">%1$d 小時</string>
+    <string name="Hours_many">%1$d 小時</string>
+    <string name="Hours_other">%1$d 小時</string>
+    <string name="Days_zero">%1$d 天</string>
+    <string name="Days_one">%1$d 天</string>
+    <string name="Days_two">%1$d 天</string>
+    <string name="Days_few">%1$d 天</string>
+    <string name="Days_many">%1$d 天</string>
+    <string name="Days_other">%1$d 天</string>
+    <string name="Weeks_zero">%1$d 週</string>
+    <string name="Weeks_one">%1$d 週</string>
+    <string name="Weeks_two">%1$d 週</string>
+    <string name="Weeks_few">%1$d 週</string>
+    <string name="Weeks_many">%1$d 週</string>
+    <string name="Weeks_other">%1$d 週</string>
+    <string name="Months_zero">%1$d 個月</string>
+    <string name="Months_one">%1$d 個月</string>
+    <string name="Months_two">%1$d 個月</string>
+    <string name="Months_few">%1$d 個月</string>
+    <string name="Months_many">%1$d 個月</string>
+    <string name="Months_other">%1$d 個月</string>
+    <string name="Years_zero">%1$d 年</string>
+    <string name="Years_one">%1$d 年</string>
+    <string name="Years_two">%1$d 年</string>
+    <string name="Years_few">%1$d 年</string>
+    <string name="Years_many">%1$d 年</string>
+    <string name="Years_other">%1$d 年</string>
+    <string name="Users_zero">%1$d 個用戶</string>
+    <string name="Users_one">%1$d 個用戶</string>
+    <string name="Users_two">%1$d 個用戶</string>
+    <string name="Users_few">%1$d 個用戶</string>
+    <string name="Users_many">%1$d 個用戶</string>
+    <string name="Users_other">%1$d 個用戶</string>
+  <string name="Times_zero">%1$d 次</string>
+  <string name="Times_one">%1$d 次</string>
+  <string name="Times_two">%1$d 次</string>
+  <string name="Times_few">%1$d 次</string>
+  <string name="Times_many">%1$d 次</string>
+  <string name="Times_other">%1$d 次</string>
+  <string name="Meters_zero">%1$d 公尺</string>
+  <string name="Meters_one">%1$d 公尺</string>
+  <string name="Meters_two">%1$d 公尺</string>
+  <string name="Meters_few">%1$d 公尺</string>
+  <string name="Meters_many">%1$d 公尺</string>
+  <string name="Meters_other">%1$d 公尺</string>
+    <!--forwarded messages-->
+  <string name="ForwardedMessage_zero">%1$d 則轉寄的訊息</string>
+    <string name="ForwardedMessage_one">轉寄的訊息</string>
+  <string name="ForwardedMessage_two">%1$d 則轉寄的訊息</string>
+  <string name="ForwardedMessage_few">%1$d 則轉寄的訊息</string>
+  <string name="ForwardedMessage_many">%1$d 則轉寄的訊息</string>
+  <string name="ForwardedMessage_other">%1$d 則轉寄的訊息</string>
+  <string name="ForwardedFile_zero">%1$d 個轉寄的檔案</string>
+    <string name="ForwardedFile_one">轉寄的檔案</string>
+  <string name="ForwardedFile_two">%1$d 個轉寄的檔案</string>
+  <string name="ForwardedFile_few">%1$d 個轉寄的檔案</string>
+  <string name="ForwardedFile_many">%1$d 個轉寄的檔案</string>
+  <string name="ForwardedFile_other">%1$d 個轉寄的檔案</string>
+  <string name="ForwardedPhoto_zero">%1$d 張轉寄的照片</string>
+  <string name="ForwardedPhoto_one">轉寄的照片</string>
+  <string name="ForwardedPhoto_two">%1$d 張轉寄的照片</string>
+  <string name="ForwardedPhoto_few">%1$d 張轉寄的照片</string>
+  <string name="ForwardedPhoto_many">%1$d 張轉寄的照片</string>
+  <string name="ForwardedPhoto_other">%1$d 張轉寄的照片</string>
+  <string name="ForwardedVideo_zero">%1$d 部轉寄的影片</string>
+    <string name="ForwardedVideo_one">轉寄的影片</string>
+  <string name="ForwardedVideo_two">%1$d 部轉寄的影片</string>
+  <string name="ForwardedVideo_few">%1$d 部轉寄的影片</string>
+  <string name="ForwardedVideo_many">%1$d 部轉寄的影片</string>
+  <string name="ForwardedVideo_other">%1$d 部轉寄的影片</string>
+  <string name="ForwardedAudio_zero">%1$d 則轉寄的音訊</string>
+    <string name="ForwardedAudio_one"> 轉寄的音訊</string>
+  <string name="ForwardedAudio_two">%1$d  則轉寄的音訊</string>
+  <string name="ForwardedAudio_few">%1$d  則轉寄的音訊</string>
+  <string name="ForwardedAudio_many">%1$d  則轉寄的音訊</string>
+  <string name="ForwardedAudio_other">%1$d  則轉寄的音訊</string>
+  <string name="ForwardedLocation_zero">%1$d 個轉寄的位置</string>
+    <string name="ForwardedLocation_one">轉寄的位置</string>
+  <string name="ForwardedLocation_two">%1$d 個轉寄的位置</string>
+  <string name="ForwardedLocation_few">%1$d 個轉寄的位置</string>
+  <string name="ForwardedLocation_many">%1$d 個轉寄的位置</string>
+  <string name="ForwardedLocation_other">%1$d 個轉寄的位置</string>
+  <string name="ForwardedContact_zero">%1$d 個轉寄的聯絡人</string>
+    <string name="ForwardedContact_one">轉寄的聯絡人</string>
+  <string name="ForwardedContact_two">%1$d 個轉寄的聯絡人</string>
+  <string name="ForwardedContact_few">%1$d 個轉寄的聯絡人</string>
+  <string name="ForwardedContact_many">%1$d 個轉寄的聯絡人</string>
+  <string name="ForwardedContact_other">%1$d 個轉寄的聯絡人</string>
+  <string name="ForwardedSticker_zero">%1$d 張轉寄的貼圖</string>
+    <string name="ForwardedSticker_one">轉寄的貼圖</string>
+  <string name="ForwardedSticker_two">%1$d 張轉寄的貼圖</string>
+  <string name="ForwardedSticker_few">%1$d 張轉寄的貼圖</string>
+  <string name="ForwardedSticker_many">%1$d 張轉寄的貼圖</string>
+  <string name="ForwardedSticker_other">%1$d 張轉寄的貼圖</string>
+    <string name="AndOther_zero">及其他 %1$d</string>
+    <string name="AndOther_one">及其他 %1$d</string>
+    <string name="AndOther_two">及其他 %1$d</string>
+    <string name="AndOther_few">及其他 %1$d</string>
+    <string name="AndOther_many">及其他 %1$d</string>
+    <string name="AndOther_other">及其他 %1$d</string>
+    <!--date formatters-->
+  <string name="formatterMonthYear">yyyy\'年\'MM\'月\'</string>
+  <string name="formatterMonth">MM\'月\'dd\'日\'</string>
+    <string name="formatterYear">yy.MM.dd</string>
+    <string name="formatterYearMax">yyyy.MM.dd</string>
+  <string name="chatDate">MM\'月\'dd\'日\'</string>
+  <string name="chatFullDate">yyyy\'年\'MM\'月\'dd\'日\'</string>
+    <string name="formatterWeek">EEE</string>
+    <string name="formatterDay24H">HH:mm</string>
+    <string name="formatterDay12H">a h:mm</string>
+    <string name="formatDateAtTime">%1$s 於時間 %2$s</string>
+  <!--update text-->
+  <string name="updateText">Android 版的 Plus Messenger 已經更新了。在 2.8 版的新功能：\n\n- 群組聊天室的邀請連結\n- 智慧通知\n- 表情符號選單裡的貼圖分頁\n- 照片的說明文字\n- 位置功能中的地點與方向\n- 語音訊息的「已聽」狀態\n- 進階「輸入」狀態：正在傳送照片、正在錄音等等。\n- 改善的頁面捲動及動畫的超平滑體驗\n\更多關於此次更新的詳情:\ntelegram.org/blog/captions-places</string>
+  <string name="updateBuild">523</string>
+  <!--Telegram+-->
+  <!--Smart Notifications-->
+  <string name="SmartNotification">智能通知</string>
+  <string name="TimeUnitSeconds">秒</string>
+  <string name="TimeUnitMinutes">分</string>
+  <string name="TimeUnitHours">小時</string>
+  <string name="TimeUnitDays">日</string>
+  <string name="settings_smart_notify_begin">最大音量</string>
+  <string name="settings_smart_notify_mid1">時間</string>
+  <string name="settings_smart_notify_mid11">時間</string>
+  <string name="settings_smart_notify_mid2">在</string>
+  -->
+  <string name="TelegramForAndroid">Plus Messenger Android版</string>
+  <string name="Theming">佈景主題</string>
+  <string name="colorHexInvalid">無效的十六進位顏色代碼！</string>
+  <string name="themeColor">主題顏色</string>
+  <string name="ResetThemeSettings">重置主題設定</string>
+  <string name="ResetThemeSettingsSum">撤消所有主題設定</string>
+  <string name="ResetThemeToastText">重置為預設主題！</string>
+  <string name="General">一般</string>
+  <string name="Screens">螢幕畫面</string>
+  <string name="MainScreen">主螢幕</string>
+  <string name="ChatScreen">聊天螢幕</string>
+  <string name="ContactsScreen">聯絡人螢幕</string>
+  <string name="Header">標題</string>
+  <string name="Rows">行</string>
+  <string name="ChatList">聊天清單</string>
+  <string name="ChatsList">聊天清單</string>
+  <string name="ContactsList">聯絡人清單</string>
+  <string name="HeaderColor">標題背景顏色</string>
+  <string name="NameColor">名稱顏色</string>
+  <string name="NameSize">名稱字體大小</string>
+  <string name="MessageColor">訊息顏色</string>
+  <string name="MessageSize">訊息字體大小</string>
+  <string name="TimeDateColor">時間/日期顏色</string>
+  <string name="TimeDateSize">時間/日期字體大小</string>
+  <string name="CountColor">訊息數量顏色</string>
+  <string name="CountSize">訊息數量字體大小</string>
+  <string name="RowColor">行背景顏色</string>
+  <string name="CountBGColor">訊息數量背景顏色</string>
+  <string name="StatusColor">狀態顏色</string>
+  <string name="StatusSize">狀態大小</string>
+  <string name="RBubbleColor">右邊聊天氣球顏色</string>
+  <string name="LBubbleColor">左邊聊天氣球顏色</string>
+  <string name="DateColor">日期顏色</string>
+  <string name="DateSize">日期大小</string>
+  <string name="DateBubbleColor">日期氣球顏色</string>
+  <string name="RTextColor">右邊信息顏色</string>
+  <string name="LTextColor">左邊信息顏色</string>
+  <string name="RTimeColor">右邊時間戳顏色</string>
+  <string name="LTimeColor">左邊時間戳顏色</string>
+  <string name="TimeSize">時間大小</string>
+  <string name="EditTextColor">輸入欄字體顏色</string>
+  <string name="EditTextSize">輸入欄字體大小</string>
+  <string name="EditTextBGColor">輸入欄背景顏色</string>
+  <string name="EmojiViewBGColor">表情背景顏色</string>
+  <string name="EmojiViewTabColor">表情頁顏色</string>
+  <string name="OnlineColor">在線上的顏色</string>
+  <string name="ChatMusic">音樂</string>
+  <string name="SaveTheme">儲存主題</string>
+  <string name="SaveThemeSum">儲存您的主題到 Telegram/Themes 資料夾</string>
+  <string name="SaveThemeToastText">主題已儲存！</string>
+  <string name="SavedTo">%1$s 已儲存至 %2$s</string>
+  <string name="SaveErrorMsg0">主題尚未建立。請先套用任何一個模組</string>
+  <string name="restoreOkMsg">已從儲存卡恢復主題</string>
+  <string name="restoreErrorMsg">在 %s 裡找不到設定檔</string>
+  <string name="NoMediaMessage">找不到儲存卡</string>
+  <string name="EnterName">輸入名稱</string>
+  <string name="Themes">主題</string>
+  <string name="ApplyTheme">套用主題</string>
+  <string name="ApplyThemeSum">從本地資料夾套用xml格式主題</string>
+  <string name="MemberColor">成員顏色</string>
+  <string name="ChecksColor">勾的顏色</string>
+  <string name="MuteColor">靜音圖示顏色</string>
+  <string name="SendLogs">傳送日誌</string>
+  <string name="SendLogsEmpty">空白日誌</string>
+  <string name="SendIcon">傳送圖示</string>
+  <string name="HideMobile">於菜單隱藏電話號碼</string>
+  <string name="FloatingPencilColor">浮動圖標顏色</string>
+  <string name="FloatingBGColor">浮動圖標背景顏色</string>
+  <string name="Community">G+社區</string>
+  <string name="TypingColor">輸入中 顏色</string>
+  <string name="EditTextIconsColor">輸入欄圖標顏色</string>
+  <string name="NavigationDrawer">導航欄抽屜</string>
+  <string name="OptionsList">選項列表</string>
+  <string name="ListColor">列表顏色</string>
+  <string name="OwnNameSize">名字大小</string>
+  <string name="PhoneColor">電話號碼顏色</string>
+  <string name="PhoneSize">電話號碼大小</string>
+  <string name="AvatarColor">頭像顏色</string>
+  <string name="IconColor">選擇圖標顏色</string>
+  <string name="OptionColor">選擇字體顏色</string>
+  <string name="OptionSize">選擇字體大小</string>
+  <string name="VersionColor">版本號字體顏色</string>
+  <string name="VersionSize">版本號字體大小</string>
+  <string name="HeaderTitleColor">標題顏色</string>
+  <string name="HeaderIconsColor">標題圖標顏色</string>
+  <string name="DividerColor">分隔線顏色</string>
+  <string name="AvatarRadius">頭像半徑</string>
+  <string name="SetMemberColor">設定成員顏色</string>
+  <string name="ForwardNameColor">轉發名字顏色</string>
+  <string name="HeaderTitle">標題文字</string>
+  <string name="ForwardNoQuote">不包含來源的轉發</string>
+  <string name="DisableMessageClick">點擊禁用彈出視窗</string>
+  <string name="ProfileScreen">群組/聯絡人屏幕</string>
+  <string name="HideBackground">隱藏自定義背景</string>
+  <string name="RLinkColor">右邊連結顏色</string>
+  <string name="LLinkColor">左邊連結顏色</string>
+  <string name="ThemeApplied">主題已套用!</string>
+  <string name="ClickOkToRestart">點擊確定來重啟應用程式</string>
+  <string name="ShowAndroidEmoji">顯示手機 emoji 表情符號</string>
+  <string name="BubbleStyle">對話氣泡風格</string>
+  <string name="KeepOriginalFilename">保留原始檔名</string>
+  <string name="KeepOriginalFilenameHelp">取代僅僅是數字的方式，檔案將被儲存為「名稱_日期」的格式</string>
+  <string name="AvatarSize">頭像大小</string>
+  <string name="AvatarAlignTop">對齊頭像到頂部</string>
+  <string name="AvatarMarginLeft">頭像左邊距</string>
+</resources>
diff --git a/TMessagesProj/src/main/res/values/colors.xml b/TMessagesProj/src/main/res/values/colors.xml
old mode 100755
new mode 100644
diff --git a/gradle.properties b/gradle.properties
deleted file mode 100644
index 01520498d..000000000
--- a/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-RELEASE_STORE_PASSWORD=password
-RELEASE_KEY_ALIAS=alias
-RELEASE_KEY_PASSWORD=password
\ No newline at end of file
diff --git a/gradlew b/gradlew
old mode 100755
new mode 100644
