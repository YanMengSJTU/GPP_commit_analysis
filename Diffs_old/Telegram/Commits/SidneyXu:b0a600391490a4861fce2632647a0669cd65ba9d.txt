diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index 165f3ce06..0fccd29b3 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -5,21 +5,17 @@ repositories {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:23.0.+'
+    compile 'com.android.support:support-v4:23.1.+'
     compile 'com.google.android.gms:play-services:3.2.+'
-    compile 'net.hockeyapp.android:HockeySDK:3.5.+'
+    compile 'net.hockeyapp.android:HockeySDK:3.6.+'
     compile 'com.googlecode.mp4parser:isoparser:1.0.+'
-    compile 'org.apache.httpcomponents:httpmime:4.2.1'
 }
 
 android {
-    compileSdkVersion 22
-    buildToolsVersion '23.0.1'
+    compileSdkVersion 23
+    buildToolsVersion '23.0.2'
 
-    packagingOptions {
-        exclude 'META-INF/NOTICE.txt'
-        exclude 'META-INF/LICENSE.txt'
-    }
+    useLibrary 'org.apache.http.legacy'
 
     compileOptions {
         sourceCompatibility JavaVersion.VERSION_1_7
@@ -28,7 +24,10 @@ android {
 
     signingConfigs {
         debug {
-            storeFile file("config/debug.keystore")
+            storeFile file("config/release.keystore")
+            storePassword RELEASE_STORE_PASSWORD
+            keyAlias RELEASE_KEY_ALIAS
+            keyPassword RELEASE_KEY_PASSWORD
         }
 
         release {
@@ -44,6 +43,7 @@ android {
             debuggable true
             jniDebuggable true
             signingConfig signingConfigs.debug
+            applicationIdSuffix ".beta"
         }
 
         release {
@@ -78,8 +78,8 @@ android {
 
     defaultConfig {
         minSdkVersion 8
-        targetSdkVersion 22
-        versionCode 627
-        versionName "3.2.2"
+        targetSdkVersion 23
+        versionCode 695
+        versionName "3.3.2"
     }
 }
diff --git a/TMessagesProj/config/debug/AndroidManifest.xml b/TMessagesProj/config/debug/AndroidManifest.xml
index d194a973e..e902ed135 100644
--- a/TMessagesProj/config/debug/AndroidManifest.xml
+++ b/TMessagesProj/config/debug/AndroidManifest.xml
@@ -21,13 +21,13 @@
     <application
         android:allowBackup="false"
         android:icon="@drawable/ic_launcher"
-        android:label="@string/AppName"
+        android:label="@string/AppNameBeta"
         android:theme="@style/Theme.TMessages.Start"
         android:name=".ApplicationLoader"
         android:hardwareAccelerated="@bool/useHardwareAcceleration"
         android:largeHeap="true">
 
-        <meta-data android:name="com.google.android.maps.v2.API_KEY" android:value="AIzaSyCTNmNqbWovP9ETcAob98YlrfOQEAC0CJ4" />
+        <meta-data android:name="com.google.android.maps.v2.API_KEY" android:value="AIzaSyA-t0jLPjUt2FxrA8VPK2EiYHcYcboIR6k" />
 
         <activity android:name="net.hockeyapp.android.UpdateActivity" />
 
diff --git a/TMessagesProj/jni/Android.mk b/TMessagesProj/jni/Android.mk
index bd054413d..6bcfa754d 100755
--- a/TMessagesProj/jni/Android.mk
+++ b/TMessagesProj/jni/Android.mk
@@ -187,7 +187,7 @@ include $(CLEAR_VARS)
 LOCAL_PRELINK_MODULE := false
 LOCAL_STATIC_LIBRARIES := webp sqlite tgnet breakpad
 
-LOCAL_MODULE 	:= tmessages.12
+LOCAL_MODULE 	:= tmessages.15
 LOCAL_CFLAGS 	:= -w -std=c11 -Os -DNULL=0 -DSOCKLEN_T=socklen_t -DLOCALE_NOT_USED -D_LARGEFILE_SOURCE=1 -D_FILE_OFFSET_BITS=64
 LOCAL_CFLAGS 	+= -Drestrict='' -D__EMX__ -DOPUS_BUILD -DFIXED_POINT -DUSE_ALLOCA -DHAVE_LRINT -DHAVE_LRINTF -fno-math-errno
 LOCAL_CFLAGS 	+= -DANDROID_NDK -DDISABLE_IMPORTGL -fno-strict-aliasing -fprefetch-loop-arrays -DAVOID_TABLES -DANDROID_TILE_BASED_DECODE -DANDROID_ARMV6_IDCT -ffast-math
diff --git a/TMessagesProj/jni/NativeLoader.cpp b/TMessagesProj/jni/NativeLoader.cpp
index 546fe1379..d18f4912e 100644
--- a/TMessagesProj/jni/NativeLoader.cpp
+++ b/TMessagesProj/jni/NativeLoader.cpp
@@ -12,6 +12,7 @@ bool callback(const google_breakpad::MinidumpDescriptor &descriptor, void *conte
 
 extern "C" {
     void Java_org_telegram_messenger_NativeLoader_init(JNIEnv* env, jobject obj, jstring filepath, bool enable) {
+        return;
         if (enable) {
             const char *path = env->GetStringUTFChars(filepath, 0);
             google_breakpad::MinidumpDescriptor descriptor(path);
diff --git a/TMessagesProj/jni/TgNetWrapper.cpp b/TMessagesProj/jni/TgNetWrapper.cpp
index 84304c4a6..a83920bf4 100644
--- a/TMessagesProj/jni/TgNetWrapper.cpp
+++ b/TMessagesProj/jni/TgNetWrapper.cpp
@@ -96,7 +96,7 @@ void sendRequest(JNIEnv *env, jclass c, jint object, jobject onComplete, jobject
         if (onQuickAck != nullptr) {
             jniEnv->CallVoidMethod(onQuickAck, jclass_QuickAckDelegate_run);
         }
-    }), flags, datacenterId, (ConnectionType) connetionType, immediate, onComplete, onQuickAck);
+    }), flags, datacenterId, (ConnectionType) connetionType, immediate, token, onComplete, onQuickAck);
 }
 
 void cancelRequest(JNIEnv *env, jclass c, jint token, jboolean notifyServer) {
@@ -194,17 +194,15 @@ class Delegate : public ConnectiosManagerDelegate {
     }
 };
 
-void init(JNIEnv *env, jclass c, jint version, jint layer, jint apiId, jstring deviceModel, jstring systemVersion, jstring appVersion, jstring langCode, jstring configPath, jint userId) {
-
-
-    
+void init(JNIEnv *env, jclass c, jint version, jint layer, jint apiId, jstring deviceModel, jstring systemVersion, jstring appVersion, jstring langCode, jstring configPath, jstring logPath, jint userId) {
     const char *deviceModelStr = env->GetStringUTFChars(deviceModel, 0);
     const char *systemVersionStr = env->GetStringUTFChars(systemVersion, 0);
     const char *appVersionStr = env->GetStringUTFChars(appVersion, 0);
     const char *langCodeStr = env->GetStringUTFChars(langCode, 0);
     const char *configPathStr = env->GetStringUTFChars(configPath, 0);
+    const char *logPathStr = env->GetStringUTFChars(logPath, 0);
 
-    ConnectionsManager::getInstance().init(version, layer, apiId, std::string(deviceModelStr), std::string(systemVersionStr), std::string(appVersionStr), std::string(langCodeStr), std::string(configPathStr), userId, true);
+    ConnectionsManager::getInstance().init(version, layer, apiId, std::string(deviceModelStr), std::string(systemVersionStr), std::string(appVersionStr), std::string(langCodeStr), std::string(configPathStr), std::string(logPathStr), userId, true);
 
     if (deviceModelStr != 0) {
         env->ReleaseStringUTFChars(deviceModel, deviceModelStr);
@@ -221,6 +219,9 @@ void init(JNIEnv *env, jclass c, jint version, jint layer, jint apiId, jstring d
     if (configPathStr != 0) {
         env->ReleaseStringUTFChars(configPath, configPathStr);
     }
+    if (logPathStr != 0) {
+        env->ReleaseStringUTFChars(logPath, logPathStr);
+    }
 }
 
 void setJava(JNIEnv *env, jclass c, jboolean useJavaByteBuffers) {
@@ -241,7 +242,7 @@ static JNINativeMethod ConnectionsManagerMethods[] = {
         {"native_applyDatacenterAddress", "(ILjava/lang/String;I)V", (void *) applyDatacenterAddress},
         {"native_getConnectionState", "()I", (void *) getConnectionState},
         {"native_setUserId", "(I)V", (void *) setUserId},
-        {"native_init", "(IIILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V", (void *) init},
+        {"native_init", "(IIILjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V", (void *) init},
         {"native_switchBackend", "()V", (void *) switchBackend},
         {"native_pauseNetwork", "()V", (void *) pauseNetwork},
         {"native_resumeNetwork", "(Z)V", (void *) resumeNetwork},
diff --git a/TMessagesProj/jni/boringssl/crypto/.gitignore b/TMessagesProj/jni/boringssl/crypto/.gitignore
new file mode 100644
index 000000000..086334327
--- /dev/null
+++ b/TMessagesProj/jni/boringssl/crypto/.gitignore
@@ -0,0 +1 @@
+*.txt~
diff --git a/TMessagesProj/jni/breakpad/LICENSE b/TMessagesProj/jni/breakpad/LICENSE
new file mode 100644
index 000000000..95207bdf6
--- /dev/null
+++ b/TMessagesProj/jni/breakpad/LICENSE
@@ -0,0 +1,50 @@
+Copyright (c) 2006, Google Inc.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+    * Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+copyright notice, this list of conditions and the following disclaimer
+in the documentation and/or other materials provided with the
+distribution.
+    * Neither the name of Google Inc. nor the names of its
+contributors may be used to endorse or promote products derived from
+this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+--------------------------------------------------------------------
+
+Copyright 2001-2004 Unicode, Inc.
+
+Disclaimer
+
+This source code is provided as is by Unicode, Inc. No claims are
+made as to fitness for any particular purpose. No warranties of any
+kind are expressed or implied. The recipient agrees to determine
+applicability of information provided. If this file has been
+purchased on magnetic or optical media from Unicode, Inc., the
+sole remedy for any claim will be exchange of defective media
+within 90 days of receipt.
+
+Limitations on Rights to Redistribute This Code
+
+Unicode, Inc. hereby grants the right to freely use the information
+supplied in this file in the creation of products supporting the
+Unicode Standard, and to make copies of this file in any form
+for internal or external distribution as long as this notice
+remains attached.
diff --git a/TMessagesProj/jni/giflib/COPYING b/TMessagesProj/jni/giflib/COPYING
new file mode 100644
index 000000000..b9c0b5012
--- /dev/null
+++ b/TMessagesProj/jni/giflib/COPYING
@@ -0,0 +1,19 @@
+The GIFLIB distribution is Copyright (c) 1997  Eric S. Raymond
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/TMessagesProj/jni/image.c b/TMessagesProj/jni/image.c
index a2cc1dfb8..5445075b7 100644
--- a/TMessagesProj/jni/image.c
+++ b/TMessagesProj/jni/image.c
@@ -16,11 +16,6 @@ jfieldID jclass_Options_inJustDecodeBounds;
 jfieldID jclass_Options_outHeight;
 jfieldID jclass_Options_outWidth;
 
-jclass jclass_Bitmap;
-jmethodID jclass_Bitmap_createBitmap;
-jclass jclass_Config;
-jfieldID jclass_Config_ARGB_8888;
-
 const uint32_t PGPhotoEnhanceHistogramBins = 256;
 const uint32_t PGPhotoEnhanceSegments = 4;
 
@@ -58,24 +53,6 @@ jint imageOnJNILoad(JavaVM *vm, void *reserved, JNIEnv *env) {
         return -1;
     }
     
-    jclass_Bitmap = createGlobarRef(env, (*env)->FindClass(env, "android/graphics/Bitmap"));
-    if (jclass_Bitmap == 0) {
-        return -1;
-    }
-    jclass_Bitmap_createBitmap = (*env)->GetStaticMethodID(env, jclass_Bitmap, "createBitmap", "(IILandroid/graphics/Bitmap$Config;)Landroid/graphics/Bitmap;");
-    if (jclass_Bitmap_createBitmap == 0) {
-        return -1;
-    }
-    
-    jclass_Config = createGlobarRef(env, (*env)->FindClass(env, "android/graphics/Bitmap$Config"));
-    if (jclass_Config == 0) {
-        return -1;
-    }
-    jclass_Config_ARGB_8888 = (*env)->GetStaticFieldID(env, jclass_Config, "ARGB_8888", "Landroid/graphics/Bitmap$Config;");
-    if (jclass_Config_ARGB_8888 == 0) {
-        return -1;
-    }
-    
     return JNI_VERSION_1_6;
 }
 
@@ -511,7 +488,7 @@ JNIEXPORT void Java_org_telegram_messenger_Utilities_loadBitmap(JNIEnv *env, jcl
     }
 }
 
-JNIEXPORT jobject Java_org_telegram_messenger_Utilities_loadWebpImage(JNIEnv *env, jclass class, jobject buffer, int len, jobject options) {
+JNIEXPORT jboolean Java_org_telegram_messenger_Utilities_loadWebpImage(JNIEnv *env, jclass class, jobject outputBitmap, jobject buffer, jint len, jobject options, jboolean unpin) {
     if (!buffer) {
         (*env)->ThrowNew(env, jclass_NullPointerException, "Input buffer can not be null");
         return 0;
@@ -529,43 +506,36 @@ JNIEXPORT jobject Java_org_telegram_messenger_Utilities_loadWebpImage(JNIEnv *en
     if (options && (*env)->GetBooleanField(env, options, jclass_Options_inJustDecodeBounds) == JNI_TRUE) {
         (*env)->SetIntField(env, options, jclass_Options_outWidth, bitmapWidth);
         (*env)->SetIntField(env, options, jclass_Options_outHeight, bitmapHeight);
-        return 0;
+        return 1;
     }
-
-    jobject value__ARGB_8888 = (*env)->GetStaticObjectField(env, jclass_Config, jclass_Config_ARGB_8888);
-    jobject outputBitmap = (*env)->CallStaticObjectMethod(env, jclass_Bitmap, jclass_Bitmap_createBitmap, (jint)bitmapWidth, (jint)bitmapHeight, value__ARGB_8888);
+    
     if (!outputBitmap) {
-        (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to allocate Bitmap");
+        (*env)->ThrowNew(env, jclass_NullPointerException, "output bitmap can not be null");
         return 0;
     }
-    outputBitmap = (*env)->NewLocalRef(env, outputBitmap);
     
     AndroidBitmapInfo bitmapInfo;
     if (AndroidBitmap_getInfo(env, outputBitmap, &bitmapInfo) != ANDROID_BITMAP_RESUT_SUCCESS) {
-        (*env)->DeleteLocalRef(env, outputBitmap);
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to get Bitmap information");
         return 0;
     }
     
     void *bitmapPixels = 0;
     if (AndroidBitmap_lockPixels(env, outputBitmap, &bitmapPixels) != ANDROID_BITMAP_RESUT_SUCCESS) {
-        (*env)->DeleteLocalRef(env, outputBitmap);
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to lock Bitmap pixels");
         return 0;
     }
     
     if (!WebPDecodeRGBAInto((uint8_t*)inputBuffer, len, (uint8_t*)bitmapPixels, bitmapInfo.height * bitmapInfo.stride, bitmapInfo.stride)) {
         AndroidBitmap_unlockPixels(env, outputBitmap);
-        (*env)->DeleteLocalRef(env, outputBitmap);
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to decode webp image");
         return 0;
     }
     
-    if (AndroidBitmap_unlockPixels(env, outputBitmap) != ANDROID_BITMAP_RESUT_SUCCESS) {
-        (*env)->DeleteLocalRef(env, outputBitmap);
+    if (unpin && AndroidBitmap_unlockPixels(env, outputBitmap) != ANDROID_BITMAP_RESUT_SUCCESS) {
         (*env)->ThrowNew(env, jclass_RuntimeException, "Failed to unlock Bitmap pixels");
         return 0;
     }
     
-    return outputBitmap;
+    return 1;
 }
diff --git a/TMessagesProj/jni/libjpeg/NOTICE b/TMessagesProj/jni/libjpeg/NOTICE
new file mode 100644
index 000000000..70e356f72
--- /dev/null
+++ b/TMessagesProj/jni/libjpeg/NOTICE
@@ -0,0 +1,94 @@
+This software is based in part on the work of the Independent JPEG Group.
+
+----------------------
+
+The authors make NO WARRANTY or representation, either express or implied,
+with respect to this software, its quality, accuracy, merchantability, or
+fitness for a particular purpose.  This software is provided "AS IS", and you,
+its user, assume the entire risk as to its quality and accuracy.
+
+This software is copyright (C) 1991-1998, Thomas G. Lane.
+All Rights Reserved except as specified below.
+
+Permission is hereby granted to use, copy, modify, and distribute this
+software (or portions thereof) for any purpose, without fee, subject to these
+conditions:
+(1) If any part of the source code for this software is distributed, then this
+README file must be included, with this copyright and no-warranty notice
+unaltered; and any additions, deletions, or changes to the original files
+must be clearly indicated in accompanying documentation.
+(2) If only executable code is distributed, then the accompanying
+documentation must state that "this software is based in part on the work of
+the Independent JPEG Group".
+(3) Permission for use of this software is granted only if the user accepts
+full responsibility for any undesirable consequences; the authors accept
+NO LIABILITY for damages of any kind.
+
+These conditions apply to any software derived from or based on the IJG code,
+not just to the unmodified library.  If you use our work, you ought to
+acknowledge us.
+
+Permission is NOT granted for the use of any IJG author's name or company name
+in advertising or publicity relating to this software or products derived from
+it.  This software may be referred to only as "the Independent JPEG Group's
+software".
+
+We specifically permit and encourage the use of this software as the basis of
+commercial products, provided that all warranty or liability claims are
+assumed by the product vendor.
+
+
+----------------------
+
+
+ ARM NEON optimizations for libjpeg-turbo
+
+ Copyright (C) 2009-2011 Nokia Corporation and/or its subsidiary(-ies).
+ All rights reserved.
+ Contact: Alexander Bokovoy <alexander.bokovoy@nokia.com>
+
+ This software is provided 'as-is', without any express or implied
+ warranty.  In no event will the authors be held liable for any damages
+ arising from the use of this software.
+
+ Permission is granted to anyone to use this software for any purpose,
+ including commercial applications, and to alter it and redistribute it
+ freely, subject to the following restrictions:
+
+ 1. The origin of this software must not be misrepresented; you must not
+    claim that you wrote the original software. If you use this software
+    in a product, an acknowledgment in the product documentation would be
+    appreciated but is not required.
+ 2. Altered source versions must be plainly marked as such, and must not be
+    misrepresented as being the original software.
+ 3. This notice may not be removed or altered from any source distribution.
+
+
+ ----------------------
+
+
+ Copyright (c) 2011,  NVIDIA CORPORATION. All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+
+  * Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+  * Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+  * Neither the name of the NVIDIA CORPORATION nor the names of its
+    contributors may be used to endorse or promote products derived
+    from this software without specific prior written permission.
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/TMessagesProj/jni/libwebp/AUTHORS b/TMessagesProj/jni/libwebp/AUTHORS
new file mode 100644
index 000000000..f0a85f9b9
--- /dev/null
+++ b/TMessagesProj/jni/libwebp/AUTHORS
@@ -0,0 +1,24 @@
+Contributors:
+- Charles Munger (clm at google dot com)
+- Christian Duvivier (cduvivier at google dot com)
+- Djordje Pesut (djordje dot pesut at imgtec dot com)
+- James Zern (jzern at google dot com)
+- Jan Engelhardt (jengelh at medozas dot de)
+- Johann (johann dot koenig at duck dot com)
+- Jovan Zelincevic (jovan dot zelincevic at imgtec dot com)
+- Jyrki Alakuijala (jyrki at google dot com)
+- levytamar82 (tamar dot levy at intel dot com)
+- Lou Quillio (louquillio at google dot com)
+- Mans Rullgard (mans at mansr dot com)
+- Martin Olsson (mnemo at minimum dot se)
+- Mikołaj Zalewski (mikolajz at google dot com)
+- Noel Chromium (noel at chromium dot org)
+- Pascal Massimino (pascal dot massimino at gmail dot com)
+- Paweł Hajdan, Jr (phajdan dot jr at chromium dot org)
+- Pierre Joye (pierre dot php at gmail dot com)
+- Scott LaVarnway (slavarnway at google dot com)
+- Scott Talbot (s at chikachow dot org)
+- Slobodan Prijic (slobodan dot prijic at imgtec dot com)
+- Somnath Banerjee (somnath dot banerjee at gmail dot com)
+- Urvang Joshi (urvang at google dot com)
+- Vikas Arora (vikasa at google dot com)
diff --git a/TMessagesProj/jni/libwebp/COPYING b/TMessagesProj/jni/libwebp/COPYING
new file mode 100644
index 000000000..7a6f99547
--- /dev/null
+++ b/TMessagesProj/jni/libwebp/COPYING
@@ -0,0 +1,30 @@
+Copyright (c) 2010, Google Inc. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+  * Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+
+  * Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in
+    the documentation and/or other materials provided with the
+    distribution.
+
+  * Neither the name of Google nor the names of its contributors may
+    be used to endorse or promote products derived from this software
+    without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
diff --git a/TMessagesProj/jni/libwebp/PATENTS b/TMessagesProj/jni/libwebp/PATENTS
new file mode 100644
index 000000000..caedf607e
--- /dev/null
+++ b/TMessagesProj/jni/libwebp/PATENTS
@@ -0,0 +1,23 @@
+Additional IP Rights Grant (Patents)
+------------------------------------
+
+"These implementations" means the copyrightable works that implement the WebM
+codecs distributed by Google as part of the WebM Project.
+
+Google hereby grants to you a perpetual, worldwide, non-exclusive, no-charge,
+royalty-free, irrevocable (except as stated in this section) patent license to
+make, have made, use, offer to sell, sell, import, transfer, and otherwise
+run, modify and propagate the contents of these implementations of WebM, where
+such license applies only to those patent claims, both currently owned by
+Google and acquired in the future, licensable by Google that are necessarily
+infringed by these implementations of WebM. This grant does not include claims
+that would be infringed only as a consequence of further modification of these
+implementations. If you or your agent or exclusive licensee institute or order
+or agree to the institution of patent litigation or any other patent
+enforcement activity against any entity (including a cross-claim or
+counterclaim in a lawsuit) alleging that any of these implementations of WebM
+or any code incorporated within any of these implementations of WebM
+constitute direct or contributory patent infringement, or inducement of
+patent infringement, then any patent rights granted to you under this License
+for these implementations of WebM shall terminate as of the date such
+litigation is filed.
diff --git a/TMessagesProj/jni/libyuv/AUTHORS b/TMessagesProj/jni/libyuv/AUTHORS
new file mode 100644
index 000000000..9686ac13e
--- /dev/null
+++ b/TMessagesProj/jni/libyuv/AUTHORS
@@ -0,0 +1,4 @@
+# Names should be added to this file like so:
+# Name or Organization <email address>
+
+Google Inc.
diff --git a/TMessagesProj/jni/libyuv/LICENSE b/TMessagesProj/jni/libyuv/LICENSE
new file mode 100644
index 000000000..c911747a6
--- /dev/null
+++ b/TMessagesProj/jni/libyuv/LICENSE
@@ -0,0 +1,29 @@
+Copyright 2011 The LibYuv Project Authors. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+  * Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+
+  * Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in
+    the documentation and/or other materials provided with the
+    distribution.
+
+  * Neither the name of Google nor the names of its contributors may
+    be used to endorse or promote products derived from this software
+    without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/TMessagesProj/jni/libyuv/LICENSE_THIRD_PARTY b/TMessagesProj/jni/libyuv/LICENSE_THIRD_PARTY
new file mode 100644
index 000000000..a71591e77
--- /dev/null
+++ b/TMessagesProj/jni/libyuv/LICENSE_THIRD_PARTY
@@ -0,0 +1,8 @@
+This source tree contains third party source code which is governed by third
+party licenses. This file contains references to files which are under other
+licenses than the one provided in the LICENSE file in the root of the source
+tree.
+
+Files governed by third party licenses:
+source/x86inc.asm
+
diff --git a/TMessagesProj/jni/libyuv/PATENTS b/TMessagesProj/jni/libyuv/PATENTS
new file mode 100644
index 000000000..64aa5c90d
--- /dev/null
+++ b/TMessagesProj/jni/libyuv/PATENTS
@@ -0,0 +1,24 @@
+Additional IP Rights Grant (Patents)
+
+"This implementation" means the copyrightable works distributed by
+Google as part of the LibYuv code package.
+
+Google hereby grants to you a perpetual, worldwide, non-exclusive,
+no-charge, irrevocable (except as stated in this section) patent
+license to make, have made, use, offer to sell, sell, import,
+transfer, and otherwise run, modify and propagate the contents of this
+implementation of the LibYuv code package, where such license applies
+only to those patent claims, both currently owned by Google and
+acquired in the future, licensable by Google that are necessarily
+infringed by this implementation of the LibYuv code package. This
+grant does not include claims that would be infringed only as a
+consequence of further modification of this implementation. If you or
+your agent or exclusive licensee institute or order or agree to the
+institution of patent litigation against any entity (including a
+cross-claim or counterclaim in a lawsuit) alleging that this
+implementation of the LibYuv code package or any code incorporated
+within this implementation of the LibYuv code package constitutes
+direct or contributory patent infringement, or inducement of patent
+infringement, then any patent rights granted to you under this License
+for this implementation of the LibYuv code package shall terminate as
+of the date such litigation is filed.
\ No newline at end of file
diff --git a/TMessagesProj/jni/opus/AUTHORS b/TMessagesProj/jni/opus/AUTHORS
new file mode 100644
index 000000000..b3d22a20c
--- /dev/null
+++ b/TMessagesProj/jni/opus/AUTHORS
@@ -0,0 +1,6 @@
+Jean-Marc Valin (jmvalin@jmvalin.ca)
+Koen Vos (koenvos74@gmail.com)
+Timothy Terriberry (tterribe@xiph.org)
+Karsten Vandborg Sorensen (karsten.vandborg.sorensen@skype.net)
+Soren Skak Jensen (ssjensen@gn.com)
+Gregory Maxwell (greg@xiph.org)
diff --git a/TMessagesProj/jni/opus/COPYING b/TMessagesProj/jni/opus/COPYING
new file mode 100644
index 000000000..9c739c34a
--- /dev/null
+++ b/TMessagesProj/jni/opus/COPYING
@@ -0,0 +1,44 @@
+Copyright 2001-2011 Xiph.Org, Skype Limited, Octasic,
+                    Jean-Marc Valin, Timothy B. Terriberry,
+                    CSIRO, Gregory Maxwell, Mark Borgerding,
+                    Erik de Castro Lopo
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+- Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+
+- Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+- Neither the name of Internet Society, IETF or IETF Trust, nor the
+names of specific contributors, may be used to endorse or promote
+products derived from this software without specific prior written
+permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Opus is subject to the royalty-free patent licenses which are
+specified at:
+
+Xiph.Org Foundation:
+https://datatracker.ietf.org/ipr/1524/
+
+Microsoft Corporation:
+https://datatracker.ietf.org/ipr/1914/
+
+Broadcom Corporation:
+https://datatracker.ietf.org/ipr/1526/
diff --git a/TMessagesProj/jni/sqlite/sqlite3.c b/TMessagesProj/jni/sqlite/sqlite3.c
index 134493887..486eefee4 100644
--- a/TMessagesProj/jni/sqlite/sqlite3.c
+++ b/TMessagesProj/jni/sqlite/sqlite3.c
@@ -1,6 +1,6 @@
 /******************************************************************************
 ** This file is an amalgamation of many separate C source files from SQLite
-** version 3.8.11.1.  By combining all the individual C code files into this 
+** version 3.9.2.  By combining all the individual C code files into this 
 ** single large file, the entire code can be compiled as a single translation
 ** unit.  This allows many compilers to do optimizations that would not be
 ** possible if the files were compiled separately.  Performance improvements
@@ -17,6 +17,7 @@
 ** language. The code for the "sqlite3" command-line shell is also in a
 ** separate file. This file contains only code for the core SQLite library.
 */
+#define SQLITE_THREADSAFE 0
 #define SQLITE_CORE 1
 #define SQLITE_AMALGAMATION 1
 #ifndef SQLITE_PRIVATE
@@ -37,7 +38,7 @@
 ** Internal interface definitions for SQLite.
 **
 */
-#ifndef _SQLITEINT_H_
+#ifndef _SQLITEINT_H_ 
 #define _SQLITEINT_H_
 
 /*
@@ -325,9 +326,9 @@ extern "C" {
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.8.11.1"
-#define SQLITE_VERSION_NUMBER 3008011
-#define SQLITE_SOURCE_ID      "2015-07-29 20:00:57 cf538e2783e468bbc25e7cb2a9ee64d3e0e80b2f"
+#define SQLITE_VERSION        "3.9.2"
+#define SQLITE_VERSION_NUMBER 3009002
+#define SQLITE_SOURCE_ID      "2015-11-02 18:31:45 bda77dda9697c463c3d0704014d51627fceee328"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -338,7 +339,7 @@ extern "C" {
 ** but are associated with the library instead of the header file.  ^(Cautious
 ** programmers might include assert() statements in their application to
 ** verify that values returned by these interfaces match the macros in
-** the header, and thus insure that the application is
+** the header, and thus ensure that the application is
 ** compiled with matching library and header files.
 **
 ** <blockquote><pre>
@@ -588,7 +589,7 @@ typedef int (*sqlite3_callback)(void*,int,char**, char**);
 ** Restrictions:
 **
 ** <ul>
-** <li> The application must insure that the 1st parameter to sqlite3_exec()
+** <li> The application must ensure that the 1st parameter to sqlite3_exec()
 **      is a valid and open [database connection].
 ** <li> The application must not close the [database connection] specified by
 **      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.
@@ -691,6 +692,7 @@ SQLITE_API int SQLITE_STDCALL sqlite3_exec(
 #define SQLITE_IOERR_MMAP              (SQLITE_IOERR | (24<<8))
 #define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25<<8))
 #define SQLITE_IOERR_CONVPATH          (SQLITE_IOERR | (26<<8))
+#define SQLITE_IOERR_VNODE             (SQLITE_IOERR | (27<<8))
 #define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1<<8))
 #define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1<<8))
 #define SQLITE_BUSY_SNAPSHOT           (SQLITE_BUSY   |  (2<<8))
@@ -1580,9 +1582,11 @@ SQLITE_API int SQLITE_STDCALL sqlite3_os_end(void);
 ** applications and so this routine is usually not necessary.  It is
 ** provided to support rare applications with unusual needs.
 **
-** The sqlite3_config() interface is not threadsafe.  The application
-** must insure that no other SQLite interfaces are invoked by other
-** threads while sqlite3_config() is running.  Furthermore, sqlite3_config()
+** <b>The sqlite3_config() interface is not threadsafe. The application
+** must ensure that no other SQLite interfaces are invoked by other
+** threads while sqlite3_config() is running.</b>
+**
+** The sqlite3_config() interface
 ** may only be invoked prior to library initialization using
 ** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].
 ** ^If sqlite3_config() is called after [sqlite3_initialize()] and before
@@ -3587,7 +3591,8 @@ SQLITE_API int SQLITE_STDCALL sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
 **
 ** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if the
 ** [prepared statement] S has been stepped at least once using 
-** [sqlite3_step(S)] but has not run to completion and/or has not 
+** [sqlite3_step(S)] but has neither run to completion (returned
+** [SQLITE_DONE] from [sqlite3_step(S)]) nor
 ** been reset using [sqlite3_reset(S)].  ^The sqlite3_stmt_busy(S)
 ** interface returns false if S is a NULL pointer.  If S is not a 
 ** NULL pointer and is not a pointer to a valid [prepared statement]
@@ -3840,7 +3845,7 @@ SQLITE_API const char *SQLITE_STDCALL sqlite3_bind_parameter_name(sqlite3_stmt*,
 **
 ** See also: [sqlite3_bind_blob|sqlite3_bind()],
 ** [sqlite3_bind_parameter_count()], and
-** [sqlite3_bind_parameter_index()].
+** [sqlite3_bind_parameter_name()].
 */
 SQLITE_API int SQLITE_STDCALL sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
 
@@ -4569,6 +4574,22 @@ SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16be(sqlite3_value*);
 SQLITE_API int SQLITE_STDCALL sqlite3_value_type(sqlite3_value*);
 SQLITE_API int SQLITE_STDCALL sqlite3_value_numeric_type(sqlite3_value*);
 
+/*
+** CAPI3REF: Finding The Subtype Of SQL Values
+** METHOD: sqlite3_value
+**
+** The sqlite3_value_subtype(V) function returns the subtype for
+** an [application-defined SQL function] argument V.  The subtype
+** information can be used to pass a limited amount of context from
+** one SQL function to another.  Use the [sqlite3_result_subtype()]
+** routine to set the subtype for the return value of an SQL function.
+**
+** SQLite makes no use of subtype itself.  It merely passes the subtype
+** from the result of one [application-defined SQL function] into the
+** input of another.
+*/
+SQLITE_API unsigned int SQLITE_STDCALL sqlite3_value_subtype(sqlite3_value*);
+
 /*
 ** CAPI3REF: Copy And Free SQL Values
 ** METHOD: sqlite3_value
@@ -4868,6 +4889,21 @@ SQLITE_API void SQLITE_STDCALL sqlite3_result_value(sqlite3_context*, sqlite3_va
 SQLITE_API void SQLITE_STDCALL sqlite3_result_zeroblob(sqlite3_context*, int n);
 SQLITE_API int SQLITE_STDCALL sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
 
+
+/*
+** CAPI3REF: Setting The Subtype Of An SQL Function
+** METHOD: sqlite3_context
+**
+** The sqlite3_result_subtype(C,T) function causes the subtype of
+** the result from the [application-defined SQL function] with 
+** [sqlite3_context] C to be the value T.  Only the lower 8 bits 
+** of the subtype T are preserved in current versions of SQLite;
+** higher order bits are discarded.
+** The number of subtype bytes preserved by SQLite might increase
+** in future releases of SQLite.
+*/
+SQLITE_API void SQLITE_STDCALL sqlite3_result_subtype(sqlite3_context*,unsigned int);
+
 /*
 ** CAPI3REF: Define New Collating Sequences
 ** METHOD: sqlite3
@@ -5813,13 +5849,31 @@ struct sqlite3_module {
 ** ^The estimatedRows value is an estimate of the number of rows that
 ** will be returned by the strategy.
 **
+** The xBestIndex method may optionally populate the idxFlags field with a 
+** mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
+** SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
+** assumes that the strategy may visit at most one row. 
+**
+** Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
+** SQLite also assumes that if a call to the xUpdate() method is made as
+** part of the same statement to delete or update a virtual table row and the
+** implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
+** any database changes. In other words, if the xUpdate() returns
+** SQLITE_CONSTRAINT, the database contents must be exactly as they were
+** before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
+** set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
+** the xUpdate method are automatically rolled back by SQLite.
+**
 ** IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
 ** structure for SQLite version 3.8.2. If a virtual table extension is
 ** used with an SQLite version earlier than 3.8.2, the results of attempting 
 ** to read or write the estimatedRows field are undefined (but are likely 
 ** to included crashing the application). The estimatedRows field should
 ** therefore only be used if [sqlite3_libversion_number()] returns a
-** value greater than or equal to 3008002.
+** value greater than or equal to 3008002. Similarly, the idxFlags field
+** was added for version 3.9.0. It may therefore only be used if
+** sqlite3_libversion_number() returns a value greater than or equal to
+** 3009000.
 */
 struct sqlite3_index_info {
   /* Inputs */
@@ -5847,8 +5901,15 @@ struct sqlite3_index_info {
   double estimatedCost;           /* Estimated cost of using this index */
   /* Fields below are only available in SQLite 3.8.2 and later */
   sqlite3_int64 estimatedRows;    /* Estimated number of rows returned */
+  /* Fields below are only available in SQLite 3.9.0 and later */
+  int idxFlags;              /* Mask of SQLITE_INDEX_SCAN_* flags */
 };
 
+/*
+** CAPI3REF: Virtual Table Scan Flags
+*/
+#define SQLITE_INDEX_SCAN_UNIQUE      1     /* Scan visits at most 1 row */
+
 /*
 ** CAPI3REF: Virtual Table Constraint Operator Codes
 **
@@ -6306,6 +6367,9 @@ SQLITE_API int SQLITE_STDCALL sqlite3_vfs_unregister(sqlite3_vfs*);
 ** <li>  SQLITE_MUTEX_STATIC_APP1
 ** <li>  SQLITE_MUTEX_STATIC_APP2
 ** <li>  SQLITE_MUTEX_STATIC_APP3
+** <li>  SQLITE_MUTEX_STATIC_VFS1
+** <li>  SQLITE_MUTEX_STATIC_VFS2
+** <li>  SQLITE_MUTEX_STATIC_VFS3
 ** </ul>
 **
 ** ^The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE)
@@ -8072,6 +8136,526 @@ struct sqlite3_rtree_query_info {
 
 #endif  /* ifndef _SQLITE3RTREE_H_ */
 
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** Interfaces to extend FTS5. Using the interfaces defined in this file, 
+** FTS5 may be extended with:
+**
+**     * custom tokenizers, and
+**     * custom auxiliary functions.
+*/
+
+
+#ifndef _FTS5_H
+#define _FTS5_H
+
+
+#if 0
+extern "C" {
+#endif
+
+/*************************************************************************
+** CUSTOM AUXILIARY FUNCTIONS
+**
+** Virtual table implementations may overload SQL functions by implementing
+** the sqlite3_module.xFindFunction() method.
+*/
+
+typedef struct Fts5ExtensionApi Fts5ExtensionApi;
+typedef struct Fts5Context Fts5Context;
+typedef struct Fts5PhraseIter Fts5PhraseIter;
+
+typedef void (*fts5_extension_function)(
+  const Fts5ExtensionApi *pApi,   /* API offered by current FTS version */
+  Fts5Context *pFts,              /* First arg to pass to pApi functions */
+  sqlite3_context *pCtx,          /* Context for returning result/error */
+  int nVal,                       /* Number of values in apVal[] array */
+  sqlite3_value **apVal           /* Array of trailing arguments */
+);
+
+struct Fts5PhraseIter {
+  const unsigned char *a;
+  const unsigned char *b;
+};
+
+/*
+** EXTENSION API FUNCTIONS
+**
+** xUserData(pFts):
+**   Return a copy of the context pointer the extension function was 
+**   registered with.
+**
+** xColumnTotalSize(pFts, iCol, pnToken):
+**   If parameter iCol is less than zero, set output variable *pnToken
+**   to the total number of tokens in the FTS5 table. Or, if iCol is
+**   non-negative but less than the number of columns in the table, return
+**   the total number of tokens in column iCol, considering all rows in 
+**   the FTS5 table.
+**
+**   If parameter iCol is greater than or equal to the number of columns
+**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
+**   an OOM condition or IO error), an appropriate SQLite error code is 
+**   returned.
+**
+** xColumnCount(pFts):
+**   Return the number of columns in the table.
+**
+** xColumnSize(pFts, iCol, pnToken):
+**   If parameter iCol is less than zero, set output variable *pnToken
+**   to the total number of tokens in the current row. Or, if iCol is
+**   non-negative but less than the number of columns in the table, set
+**   *pnToken to the number of tokens in column iCol of the current row.
+**
+**   If parameter iCol is greater than or equal to the number of columns
+**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
+**   an OOM condition or IO error), an appropriate SQLite error code is 
+**   returned.
+**
+** xColumnText:
+**   This function attempts to retrieve the text of column iCol of the
+**   current document. If successful, (*pz) is set to point to a buffer
+**   containing the text in utf-8 encoding, (*pn) is set to the size in bytes
+**   (not characters) of the buffer and SQLITE_OK is returned. Otherwise,
+**   if an error occurs, an SQLite error code is returned and the final values
+**   of (*pz) and (*pn) are undefined.
+**
+** xPhraseCount:
+**   Returns the number of phrases in the current query expression.
+**
+** xPhraseSize:
+**   Returns the number of tokens in phrase iPhrase of the query. Phrases
+**   are numbered starting from zero.
+**
+** xInstCount:
+**   Set *pnInst to the total number of occurrences of all phrases within
+**   the query within the current row. Return SQLITE_OK if successful, or
+**   an error code (i.e. SQLITE_NOMEM) if an error occurs.
+**
+** xInst:
+**   Query for the details of phrase match iIdx within the current row.
+**   Phrase matches are numbered starting from zero, so the iIdx argument
+**   should be greater than or equal to zero and smaller than the value
+**   output by xInstCount().
+**
+**   Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) 
+**   if an error occurs.
+**
+** xRowid:
+**   Returns the rowid of the current row.
+**
+** xTokenize:
+**   Tokenize text using the tokenizer belonging to the FTS5 table.
+**
+** xQueryPhrase(pFts5, iPhrase, pUserData, xCallback):
+**   This API function is used to query the FTS table for phrase iPhrase
+**   of the current query. Specifically, a query equivalent to:
+**
+**       ... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid
+**
+**   with $p set to a phrase equivalent to the phrase iPhrase of the
+**   current query is executed. For each row visited, the callback function
+**   passed as the fourth argument is invoked. The context and API objects 
+**   passed to the callback function may be used to access the properties of
+**   each matched row. Invoking Api.xUserData() returns a copy of the pointer
+**   passed as the third argument to pUserData.
+**
+**   If the callback function returns any value other than SQLITE_OK, the
+**   query is abandoned and the xQueryPhrase function returns immediately.
+**   If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK.
+**   Otherwise, the error code is propagated upwards.
+**
+**   If the query runs to completion without incident, SQLITE_OK is returned.
+**   Or, if some error occurs before the query completes or is aborted by
+**   the callback, an SQLite error code is returned.
+**
+**
+** xSetAuxdata(pFts5, pAux, xDelete)
+**
+**   Save the pointer passed as the second argument as the extension functions 
+**   "auxiliary data". The pointer may then be retrieved by the current or any
+**   future invocation of the same fts5 extension function made as part of
+**   of the same MATCH query using the xGetAuxdata() API.
+**
+**   Each extension function is allocated a single auxiliary data slot for
+**   each FTS query (MATCH expression). If the extension function is invoked 
+**   more than once for a single FTS query, then all invocations share a 
+**   single auxiliary data context.
+**
+**   If there is already an auxiliary data pointer when this function is
+**   invoked, then it is replaced by the new pointer. If an xDelete callback
+**   was specified along with the original pointer, it is invoked at this
+**   point.
+**
+**   The xDelete callback, if one is specified, is also invoked on the
+**   auxiliary data pointer after the FTS5 query has finished.
+**
+**   If an error (e.g. an OOM condition) occurs within this function, an
+**   the auxiliary data is set to NULL and an error code returned. If the
+**   xDelete parameter was not NULL, it is invoked on the auxiliary data
+**   pointer before returning.
+**
+**
+** xGetAuxdata(pFts5, bClear)
+**
+**   Returns the current auxiliary data pointer for the fts5 extension 
+**   function. See the xSetAuxdata() method for details.
+**
+**   If the bClear argument is non-zero, then the auxiliary data is cleared
+**   (set to NULL) before this function returns. In this case the xDelete,
+**   if any, is not invoked.
+**
+**
+** xRowCount(pFts5, pnRow)
+**
+**   This function is used to retrieve the total number of rows in the table.
+**   In other words, the same value that would be returned by:
+**
+**        SELECT count(*) FROM ftstable;
+**
+** xPhraseFirst()
+**   This function is used, along with type Fts5PhraseIter and the xPhraseNext
+**   method, to iterate through all instances of a single query phrase within
+**   the current row. This is the same information as is accessible via the
+**   xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient
+**   to use, this API may be faster under some circumstances. To iterate 
+**   through instances of phrase iPhrase, use the following code:
+**
+**       Fts5PhraseIter iter;
+**       int iCol, iOff;
+**       for(pApi->xPhraseFirst(pFts, iPhrase, &iter, &iCol, &iOff);
+**           iOff>=0;
+**           pApi->xPhraseNext(pFts, &iter, &iCol, &iOff)
+**       ){
+**         // An instance of phrase iPhrase at offset iOff of column iCol
+**       }
+**
+**   The Fts5PhraseIter structure is defined above. Applications should not
+**   modify this structure directly - it should only be used as shown above
+**   with the xPhraseFirst() and xPhraseNext() API methods.
+**
+** xPhraseNext()
+**   See xPhraseFirst above.
+*/
+struct Fts5ExtensionApi {
+  int iVersion;                   /* Currently always set to 1 */
+
+  void *(*xUserData)(Fts5Context*);
+
+  int (*xColumnCount)(Fts5Context*);
+  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
+  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);
+
+  int (*xTokenize)(Fts5Context*, 
+    const char *pText, int nText, /* Text to tokenize */
+    void *pCtx,                   /* Context passed to xToken() */
+    int (*xToken)(void*, int, const char*, int, int, int)       /* Callback */
+  );
+
+  int (*xPhraseCount)(Fts5Context*);
+  int (*xPhraseSize)(Fts5Context*, int iPhrase);
+
+  int (*xInstCount)(Fts5Context*, int *pnInst);
+  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);
+
+  sqlite3_int64 (*xRowid)(Fts5Context*);
+  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
+  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);
+
+  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
+    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
+  );
+  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
+  void *(*xGetAuxdata)(Fts5Context*, int bClear);
+
+  void (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
+  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);
+};
+
+/* 
+** CUSTOM AUXILIARY FUNCTIONS
+*************************************************************************/
+
+/*************************************************************************
+** CUSTOM TOKENIZERS
+**
+** Applications may also register custom tokenizer types. A tokenizer 
+** is registered by providing fts5 with a populated instance of the 
+** following structure. All structure methods must be defined, setting
+** any member of the fts5_tokenizer struct to NULL leads to undefined
+** behaviour. The structure methods are expected to function as follows:
+**
+** xCreate:
+**   This function is used to allocate and inititalize a tokenizer instance.
+**   A tokenizer instance is required to actually tokenize text.
+**
+**   The first argument passed to this function is a copy of the (void*)
+**   pointer provided by the application when the fts5_tokenizer object
+**   was registered with FTS5 (the third argument to xCreateTokenizer()). 
+**   The second and third arguments are an array of nul-terminated strings
+**   containing the tokenizer arguments, if any, specified following the
+**   tokenizer name as part of the CREATE VIRTUAL TABLE statement used
+**   to create the FTS5 table.
+**
+**   The final argument is an output variable. If successful, (*ppOut) 
+**   should be set to point to the new tokenizer handle and SQLITE_OK
+**   returned. If an error occurs, some value other than SQLITE_OK should
+**   be returned. In this case, fts5 assumes that the final value of *ppOut 
+**   is undefined.
+**
+** xDelete:
+**   This function is invoked to delete a tokenizer handle previously
+**   allocated using xCreate(). Fts5 guarantees that this function will
+**   be invoked exactly once for each successful call to xCreate().
+**
+** xTokenize:
+**   This function is expected to tokenize the nText byte string indicated 
+**   by argument pText. pText may or may not be nul-terminated. The first
+**   argument passed to this function is a pointer to an Fts5Tokenizer object
+**   returned by an earlier call to xCreate().
+**
+**   The second argument indicates the reason that FTS5 is requesting
+**   tokenization of the supplied text. This is always one of the following
+**   four values:
+**
+**   <ul><li> <b>FTS5_TOKENIZE_DOCUMENT</b> - A document is being inserted into
+**            or removed from the FTS table. The tokenizer is being invoked to
+**            determine the set of tokens to add to (or delete from) the
+**            FTS index.
+**
+**       <li> <b>FTS5_TOKENIZE_QUERY</b> - A MATCH query is being executed 
+**            against the FTS index. The tokenizer is being called to tokenize 
+**            a bareword or quoted string specified as part of the query.
+**
+**       <li> <b>(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)</b> - Same as
+**            FTS5_TOKENIZE_QUERY, except that the bareword or quoted string is
+**            followed by a "*" character, indicating that the last token
+**            returned by the tokenizer will be treated as a token prefix.
+**
+**       <li> <b>FTS5_TOKENIZE_AUX</b> - The tokenizer is being invoked to 
+**            satisfy an fts5_api.xTokenize() request made by an auxiliary
+**            function. Or an fts5_api.xColumnSize() request made by the same
+**            on a columnsize=0 database.  
+**   </ul>
+**
+**   For each token in the input string, the supplied callback xToken() must
+**   be invoked. The first argument to it should be a copy of the pointer
+**   passed as the second argument to xTokenize(). The third and fourth
+**   arguments are a pointer to a buffer containing the token text, and the
+**   size of the token in bytes. The 4th and 5th arguments are the byte offsets
+**   of the first byte of and first byte immediately following the text from
+**   which the token is derived within the input.
+**
+**   The second argument passed to the xToken() callback ("tflags") should
+**   normally be set to 0. The exception is if the tokenizer supports 
+**   synonyms. In this case see the discussion below for details.
+**
+**   FTS5 assumes the xToken() callback is invoked for each token in the 
+**   order that they occur within the input text.
+**
+**   If an xToken() callback returns any value other than SQLITE_OK, then
+**   the tokenization should be abandoned and the xTokenize() method should
+**   immediately return a copy of the xToken() return value. Or, if the
+**   input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally,
+**   if an error occurs with the xTokenize() implementation itself, it
+**   may abandon the tokenization and return any error code other than
+**   SQLITE_OK or SQLITE_DONE.
+**
+** SYNONYM SUPPORT
+**
+**   Custom tokenizers may also support synonyms. Consider a case in which a
+**   user wishes to query for a phrase such as "first place". Using the 
+**   built-in tokenizers, the FTS5 query 'first + place' will match instances
+**   of "first place" within the document set, but not alternative forms
+**   such as "1st place". In some applications, it would be better to match
+**   all instances of "first place" or "1st place" regardless of which form
+**   the user specified in the MATCH query text.
+**
+**   There are several ways to approach this in FTS5:
+**
+**   <ol><li> By mapping all synonyms to a single token. In this case, the 
+**            In the above example, this means that the tokenizer returns the
+**            same token for inputs "first" and "1st". Say that token is in
+**            fact "first", so that when the user inserts the document "I won
+**            1st place" entries are added to the index for tokens "i", "won",
+**            "first" and "place". If the user then queries for '1st + place',
+**            the tokenizer substitutes "first" for "1st" and the query works
+**            as expected.
+**
+**       <li> By adding multiple synonyms for a single term to the FTS index.
+**            In this case, when tokenizing query text, the tokenizer may 
+**            provide multiple synonyms for a single term within the document.
+**            FTS5 then queries the index for each synonym individually. For
+**            example, faced with the query:
+**
+**   <codeblock>
+**     ... MATCH 'first place'</codeblock>
+**
+**            the tokenizer offers both "1st" and "first" as synonyms for the
+**            first token in the MATCH query and FTS5 effectively runs a query 
+**            similar to:
+**
+**   <codeblock>
+**     ... MATCH '(first OR 1st) place'</codeblock>
+**
+**            except that, for the purposes of auxiliary functions, the query
+**            still appears to contain just two phrases - "(first OR 1st)" 
+**            being treated as a single phrase.
+**
+**       <li> By adding multiple synonyms for a single term to the FTS index.
+**            Using this method, when tokenizing document text, the tokenizer
+**            provides multiple synonyms for each token. So that when a 
+**            document such as "I won first place" is tokenized, entries are
+**            added to the FTS index for "i", "won", "first", "1st" and
+**            "place".
+**
+**            This way, even if the tokenizer does not provide synonyms
+**            when tokenizing query text (it should not - to do would be
+**            inefficient), it doesn't matter if the user queries for 
+**            'first + place' or '1st + place', as there are entires in the
+**            FTS index corresponding to both forms of the first token.
+**   </ol>
+**
+**   Whether it is parsing document or query text, any call to xToken that
+**   specifies a <i>tflags</i> argument with the FTS5_TOKEN_COLOCATED bit
+**   is considered to supply a synonym for the previous token. For example,
+**   when parsing the document "I won first place", a tokenizer that supports
+**   synonyms would call xToken() 5 times, as follows:
+**
+**   <codeblock>
+**       xToken(pCtx, 0, "i",                      1,  0,  1);
+**       xToken(pCtx, 0, "won",                    3,  2,  5);
+**       xToken(pCtx, 0, "first",                  5,  6, 11);
+**       xToken(pCtx, FTS5_TOKEN_COLOCATED, "1st", 3,  6, 11);
+**       xToken(pCtx, 0, "place",                  5, 12, 17);
+**</codeblock>
+**
+**   It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time
+**   xToken() is called. Multiple synonyms may be specified for a single token
+**   by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. 
+**   There is no limit to the number of synonyms that may be provided for a
+**   single token.
+**
+**   In many cases, method (1) above is the best approach. It does not add 
+**   extra data to the FTS index or require FTS5 to query for multiple terms,
+**   so it is efficient in terms of disk space and query speed. However, it
+**   does not support prefix queries very well. If, as suggested above, the
+**   token "first" is subsituted for "1st" by the tokenizer, then the query:
+**
+**   <codeblock>
+**     ... MATCH '1s*'</codeblock>
+**
+**   will not match documents that contain the token "1st" (as the tokenizer
+**   will probably not map "1s" to any prefix of "first").
+**
+**   For full prefix support, method (3) may be preferred. In this case, 
+**   because the index contains entries for both "first" and "1st", prefix
+**   queries such as 'fi*' or '1s*' will match correctly. However, because
+**   extra entries are added to the FTS index, this method uses more space
+**   within the database.
+**
+**   Method (2) offers a midpoint between (1) and (3). Using this method,
+**   a query such as '1s*' will match documents that contain the literal 
+**   token "1st", but not "first" (assuming the tokenizer is not able to
+**   provide synonyms for prefixes). However, a non-prefix query like '1st'
+**   will match against "1st" and "first". This method does not require
+**   extra disk space, as no extra entries are added to the FTS index. 
+**   On the other hand, it may require more CPU cycles to run MATCH queries,
+**   as separate queries of the FTS index are required for each synonym.
+**
+**   When using methods (2) or (3), it is important that the tokenizer only
+**   provide synonyms when tokenizing document text (method (2)) or query
+**   text (method (3)), not both. Doing so will not cause any errors, but is
+**   inefficient.
+*/
+typedef struct Fts5Tokenizer Fts5Tokenizer;
+typedef struct fts5_tokenizer fts5_tokenizer;
+struct fts5_tokenizer {
+  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
+  void (*xDelete)(Fts5Tokenizer*);
+  int (*xTokenize)(Fts5Tokenizer*, 
+      void *pCtx,
+      int flags,            /* Mask of FTS5_TOKENIZE_* flags */
+      const char *pText, int nText, 
+      int (*xToken)(
+        void *pCtx,         /* Copy of 2nd argument to xTokenize() */
+        int tflags,         /* Mask of FTS5_TOKEN_* flags */
+        const char *pToken, /* Pointer to buffer containing token */
+        int nToken,         /* Size of token in bytes */
+        int iStart,         /* Byte offset of token within input text */
+        int iEnd            /* Byte offset of end of token within input text */
+      )
+  );
+};
+
+/* Flags that may be passed as the third argument to xTokenize() */
+#define FTS5_TOKENIZE_QUERY     0x0001
+#define FTS5_TOKENIZE_PREFIX    0x0002
+#define FTS5_TOKENIZE_DOCUMENT  0x0004
+#define FTS5_TOKENIZE_AUX       0x0008
+
+/* Flags that may be passed by the tokenizer implementation back to FTS5
+** as the third argument to the supplied xToken callback. */
+#define FTS5_TOKEN_COLOCATED    0x0001      /* Same position as prev. token */
+
+/*
+** END OF CUSTOM TOKENIZERS
+*************************************************************************/
+
+/*************************************************************************
+** FTS5 EXTENSION REGISTRATION API
+*/
+typedef struct fts5_api fts5_api;
+struct fts5_api {
+  int iVersion;                   /* Currently always set to 2 */
+
+  /* Create a new tokenizer */
+  int (*xCreateTokenizer)(
+    fts5_api *pApi,
+    const char *zName,
+    void *pContext,
+    fts5_tokenizer *pTokenizer,
+    void (*xDestroy)(void*)
+  );
+
+  /* Find an existing tokenizer */
+  int (*xFindTokenizer)(
+    fts5_api *pApi,
+    const char *zName,
+    void **ppContext,
+    fts5_tokenizer *pTokenizer
+  );
+
+  /* Create a new auxiliary function */
+  int (*xCreateFunction)(
+    fts5_api *pApi,
+    const char *zName,
+    void *pContext,
+    fts5_extension_function xFunction,
+    void (*xDestroy)(void*)
+  );
+};
+
+/*
+** END OF REGISTRATION API
+*************************************************************************/
+
+#if 0
+}  /* end of the 'extern "C"' block */
+#endif
+
+#endif /* _FTS5_H */
+
+
 
 /************** End of sqlite3.h *********************************************/
 /************** Continuing where we left off in sqliteInt.h ******************/
@@ -8363,15 +8947,19 @@ struct sqlite3_rtree_query_info {
 
 /*
 ** Make sure that the compiler intrinsics we desire are enabled when
-** compiling with an appropriate version of MSVC.
-*/
-#if defined(_MSC_VER) && _MSC_VER>=1300
-#  if !defined(_WIN32_WCE)
-#    include <intrin.h>
-#    pragma intrinsic(_byteswap_ushort)
-#    pragma intrinsic(_byteswap_ulong)
-#  else
-#    include <cmnintrin.h>
+** compiling with an appropriate version of MSVC unless prevented by
+** the SQLITE_DISABLE_INTRINSIC define.
+*/
+#if !defined(SQLITE_DISABLE_INTRINSIC)
+#  if defined(_MSC_VER) && _MSC_VER>=1300
+#    if !defined(_WIN32_WCE)
+#      include <intrin.h>
+#      pragma intrinsic(_byteswap_ushort)
+#      pragma intrinsic(_byteswap_ulong)
+#      pragma intrinsic(_ReadWriteBarrier)
+#    else
+#      include <cmnintrin.h>
+#    endif
 #  endif
 #endif
 
@@ -9589,7 +10177,7 @@ SQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(
 );
 SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor*);
 SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor*, int*);
-SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor*);
+SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor*, int);
 SQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const void *pKey, i64 nKey,
                                   const void *pData, int nData,
                                   int nZero, int bias, int seekResult);
@@ -9983,9 +10571,9 @@ typedef struct VdbeOpList VdbeOpList;
 #define OP_FkCounter     135 /* synopsis: fkctr[P1]+=P2                    */
 #define OP_FkIfZero      136 /* synopsis: if fkctr[P1]==0 goto P2          */
 #define OP_MemMax        137 /* synopsis: r[P1]=max(r[P1],r[P2])           */
-#define OP_IfPos         138 /* synopsis: if r[P1]>0 goto P2               */
-#define OP_IfNeg         139 /* synopsis: r[P1]+=P3, if r[P1]<0 goto P2    */
-#define OP_IfNotZero     140 /* synopsis: if r[P1]!=0 then r[P1]+=P3, goto P2 */
+#define OP_IfPos         138 /* synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 */
+#define OP_SetIfNotPos   139 /* synopsis: if r[P1]<=0 then r[P2]=P3        */
+#define OP_IfNotZero     140 /* synopsis: if r[P1]!=0 then r[P1]-=P3, goto P2 */
 #define OP_DecrJumpZero  141 /* synopsis: if (--r[P1])==0 goto P2          */
 #define OP_JumpZeroIncr  142 /* synopsis: if (r[P1]++)==0 ) goto P2        */
 #define OP_AggStep0      143 /* synopsis: accum=r[P3] step(r[P2@P5])       */
@@ -10036,7 +10624,7 @@ typedef struct VdbeOpList VdbeOpList;
 /* 112 */ 0x00, 0x10, 0x01, 0x01, 0x01, 0x01, 0x10, 0x00,\
 /* 120 */ 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,\
 /* 128 */ 0x00, 0x06, 0x23, 0x0b, 0x01, 0x10, 0x10, 0x00,\
-/* 136 */ 0x01, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00,\
+/* 136 */ 0x01, 0x04, 0x03, 0x06, 0x03, 0x03, 0x03, 0x00,\
 /* 144 */ 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\
 /* 152 */ 0x00, 0x00, 0x01, 0x00, 0x10, 0x10, 0x01, 0x00,\
 /* 160 */ 0x00,}
@@ -10052,12 +10640,16 @@ SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(Parse*);
 SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe*,int);
 SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe*,int,int);
 SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe*,int,int,int);
+SQLITE_PRIVATE int sqlite3VdbeGoto(Vdbe*,int);
+SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe*,int,const char*);
+SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe*,int,const char*,...);
 SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);
 SQLITE_PRIVATE int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);
 SQLITE_PRIVATE int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);
 SQLITE_PRIVATE int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);
 SQLITE_PRIVATE int sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp, int iLineno);
 SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe*,int,char*);
+SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe*, u32 addr, u8);
 SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, u32 addr, int P1);
 SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, u32 addr, int P2);
 SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, u32 addr, int P3);
@@ -10301,6 +10893,9 @@ SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);
 /* Functions used to configure a Pager object. */
 SQLITE_PRIVATE void sqlite3PagerSetBusyhandler(Pager*, int(*)(void *), void *);
 SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);
+#ifdef SQLITE_HAS_CODEC
+SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager*,Pager*);
+#endif
 SQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager*, int);
 SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int);
 SQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);
@@ -11335,18 +11930,20 @@ struct FuncDestructor {
 ** values must correspond to OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG.  There
 ** are assert() statements in the code to verify this.
 */
-#define SQLITE_FUNC_ENCMASK  0x003 /* SQLITE_UTF8, SQLITE_UTF16BE or UTF16LE */
-#define SQLITE_FUNC_LIKE     0x004 /* Candidate for the LIKE optimization */
-#define SQLITE_FUNC_CASE     0x008 /* Case-sensitive LIKE-type function */
-#define SQLITE_FUNC_EPHEM    0x010 /* Ephemeral.  Delete with VDBE */
-#define SQLITE_FUNC_NEEDCOLL 0x020 /* sqlite3GetFuncCollSeq() might be called */
-#define SQLITE_FUNC_LENGTH   0x040 /* Built-in length() function */
-#define SQLITE_FUNC_TYPEOF   0x080 /* Built-in typeof() function */
-#define SQLITE_FUNC_COUNT    0x100 /* Built-in count(*) aggregate */
-#define SQLITE_FUNC_COALESCE 0x200 /* Built-in coalesce() or ifnull() */
-#define SQLITE_FUNC_UNLIKELY 0x400 /* Built-in unlikely() function */
-#define SQLITE_FUNC_CONSTANT 0x800 /* Constant inputs give a constant output */
-#define SQLITE_FUNC_MINMAX  0x1000 /* True for min() and max() aggregates */
+#define SQLITE_FUNC_ENCMASK  0x0003 /* SQLITE_UTF8, SQLITE_UTF16BE or UTF16LE */
+#define SQLITE_FUNC_LIKE     0x0004 /* Candidate for the LIKE optimization */
+#define SQLITE_FUNC_CASE     0x0008 /* Case-sensitive LIKE-type function */
+#define SQLITE_FUNC_EPHEM    0x0010 /* Ephemeral.  Delete with VDBE */
+#define SQLITE_FUNC_NEEDCOLL 0x0020 /* sqlite3GetFuncCollSeq() might be called*/
+#define SQLITE_FUNC_LENGTH   0x0040 /* Built-in length() function */
+#define SQLITE_FUNC_TYPEOF   0x0080 /* Built-in typeof() function */
+#define SQLITE_FUNC_COUNT    0x0100 /* Built-in count(*) aggregate */
+#define SQLITE_FUNC_COALESCE 0x0200 /* Built-in coalesce() or ifnull() */
+#define SQLITE_FUNC_UNLIKELY 0x0400 /* Built-in unlikely() function */
+#define SQLITE_FUNC_CONSTANT 0x0800 /* Constant inputs give a constant output */
+#define SQLITE_FUNC_MINMAX   0x1000 /* True for min() and max() aggregates */
+#define SQLITE_FUNC_SLOCHNG  0x2000 /* "Slow Change". Value constant during a
+                                    ** single query - might change over time */
 
 /*
 ** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() are
@@ -11362,6 +11959,12 @@ struct FuncDestructor {
 **   VFUNCTION(zName, nArg, iArg, bNC, xFunc)
 **     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag.
 **
+**   DFUNCTION(zName, nArg, iArg, bNC, xFunc)
+**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag and
+**     adds the SQLITE_FUNC_SLOCHNG flag.  Used for date & time functions
+**     and functions like sqlite_version() that can change, but not during
+**     a single query.
+**
 **   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)
 **     Used to create an aggregate function definition implemented by
 **     the C functions xStep and xFinal. The first four parameters
@@ -11382,11 +11985,14 @@ struct FuncDestructor {
 #define VFUNCTION(zName, nArg, iArg, bNC, xFunc) \
   {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
    SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, #zName, 0, 0}
+#define DFUNCTION(zName, nArg, iArg, bNC, xFunc) \
+  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
+   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, #zName, 0, 0}
 #define FUNCTION2(zName, nArg, iArg, bNC, xFunc, extraFlags) \
   {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\
    SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, #zName, 0, 0}
 #define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) \
-  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
+  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \
    pArg, 0, xFunc, 0, 0, #zName, 0, 0}
 #define LIKEFUNC(zName, nArg, arg, flags) \
   {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, \
@@ -11430,6 +12036,7 @@ struct Module {
   const char *zName;                   /* Name passed to create_module() */
   void *pAux;                          /* pAux passed to create_module() */
   void (*xDestroy)(void *);            /* Module destructor function */
+  Table *pEpoTab;                      /* Eponymous table for this module */
 };
 
 /*
@@ -11475,6 +12082,7 @@ struct CollSeq {
 */
 #define SQLITE_SO_ASC       0  /* Sort in ascending order */
 #define SQLITE_SO_DESC      1  /* Sort in ascending order */
+#define SQLITE_SO_UNDEFINED -1 /* No sort order specified */
 
 /*
 ** Column affinity types.
@@ -11581,9 +12189,8 @@ struct Table {
   Select *pSelect;     /* NULL for tables.  Points to definition if a view. */
   FKey *pFKey;         /* Linked list of all foreign keys in this table */
   char *zColAff;       /* String defining the affinity of each column */
-#ifndef SQLITE_OMIT_CHECK
   ExprList *pCheck;    /* All CHECK constraints */
-#endif
+                       /*   ... also used as column name list in a VIEW */
   int tnum;            /* Root BTree page for this table */
   i16 iPKey;           /* If not negative, use aCol[iPKey] as the rowid */
   i16 nCol;            /* Number of columns in this table */
@@ -11600,7 +12207,7 @@ struct Table {
 #endif
 #ifndef SQLITE_OMIT_VIRTUALTABLE
   int nModuleArg;      /* Number of arguments to the module */
-  char **azModuleArg;  /* Text of all module args. [0] is module name */
+  char **azModuleArg;  /* 0: module 1: schema 2: vtab name 3...: args */
   VTable *pVTable;     /* List of VTable objects. */
 #endif
   Trigger *pTrigger;   /* List of triggers stored in pSchema */
@@ -11821,6 +12428,7 @@ struct Index {
   u8 *aSortOrder;          /* for each column: True==DESC, False==ASC */
   char **azColl;           /* Array of collation sequence names for index */
   Expr *pPartIdxWhere;     /* WHERE clause for partial indices */
+  ExprList *aColExpr;      /* Column expressions */
   int tnum;                /* DB Page containing root of this index */
   LogEst szIdxRow;         /* Estimated average row size in bytes */
   u16 nKeyCol;             /* Number of columns forming the key */
@@ -11855,6 +12463,12 @@ struct Index {
 /* Return true if index X is a UNIQUE index */
 #define IsUniqueIndex(X)      ((X)->onError!=OE_None)
 
+/* The Index.aiColumn[] values are normally positive integer.  But
+** there are some negative values that have special meaning:
+*/
+#define XN_ROWID     (-1)     /* Indexed column is the rowid */
+#define XN_EXPR      (-2)     /* Indexed column is an expression */
+
 /*
 ** Each sample stored in the sqlite_stat3 table is represented in memory 
 ** using a structure of this type.  See documentation at the top of the
@@ -12070,9 +12684,10 @@ struct Expr {
 #define EP_MemToken  0x010000 /* Need to sqlite3DbFree() Expr.zToken */
 #define EP_NoReduce  0x020000 /* Cannot EXPRDUP_REDUCE this Expr */
 #define EP_Unlikely  0x040000 /* unlikely() or likelihood() function */
-#define EP_ConstFunc 0x080000 /* Node is a SQLITE_FUNC_CONSTANT function */
+#define EP_ConstFunc 0x080000 /* A SQLITE_FUNC_CONSTANT or _SLOCHNG function */
 #define EP_CanBeNull 0x100000 /* Can be null despite NOT NULL constraint */
 #define EP_Subquery  0x200000 /* Tree contains a TK_SELECT operator */
+#define EP_Alias     0x400000 /* Is an alias for a result set column */
 
 /*
 ** Combinations of two or more EP_* flags
@@ -12235,11 +12850,15 @@ struct SrcList {
     int addrFillSub;  /* Address of subroutine to manifest a subquery */
     int regReturn;    /* Register holding return address of addrFillSub */
     int regResult;    /* Registers holding results of a co-routine */
-    u8 jointype;      /* Type of join between this able and the previous */
-    unsigned notIndexed :1;    /* True if there is a NOT INDEXED clause */
-    unsigned isCorrelated :1;  /* True if sub-query is correlated */
-    unsigned viaCoroutine :1;  /* Implemented as a co-routine */
-    unsigned isRecursive :1;   /* True for recursive reference in WITH */
+    struct {
+      u8 jointype;      /* Type of join between this able and the previous */
+      unsigned notIndexed :1;    /* True if there is a NOT INDEXED clause */
+      unsigned isIndexedBy :1;   /* True if there is an INDEXED BY clause */
+      unsigned isTabFunc :1;     /* True if table-valued-function syntax */
+      unsigned isCorrelated :1;  /* True if sub-query is correlated */
+      unsigned viaCoroutine :1;  /* Implemented as a co-routine */
+      unsigned isRecursive :1;   /* True for recursive reference in WITH */
+    } fg;
 #ifndef SQLITE_OMIT_EXPLAIN
     u8 iSelectId;     /* If pSelect!=0, the id of the sub-select in EQP */
 #endif
@@ -12247,8 +12866,11 @@ struct SrcList {
     Expr *pOn;        /* The ON clause of a join */
     IdList *pUsing;   /* The USING clause of a join */
     Bitmask colUsed;  /* Bit N (1<<N) set if column N of pTab is used */
-    char *zIndexedBy; /* Identifier from "INDEXED BY <zIndex>" clause */
-    Index *pIndex;    /* Index structure corresponding to zIndex, if any */
+    union {
+      char *zIndexedBy;    /* Identifier from "INDEXED BY <zIndex>" clause */
+      ExprList *pFuncArg;  /* Arguments to table-valued-function */
+    } u1;
+    Index *pIBIndex;  /* Index structure corresponding to u1.zIndexedBy */
   } a[1];             /* One entry for each identifier on the list */
 };
 
@@ -12282,6 +12904,7 @@ struct SrcList {
 #define WHERE_WANT_DISTINCT    0x0400 /* All output needs to be distinct */
 #define WHERE_SORTBYGROUP      0x0800 /* Support sqlite3WhereIsSorted() */
 #define WHERE_REOPEN_IDX       0x1000 /* Try to use OP_ReopenIdx */
+#define WHERE_ONEPASS_MULTIROW 0x2000 /* ONEPASS is ok with multiple rows */
 
 /* Allowed return values from sqlite3WhereIsDistinct()
 */
@@ -12334,6 +12957,7 @@ struct NameContext {
 #define NC_IsCheck   0x0004  /* True if resolving names in a CHECK constraint */
 #define NC_InAggFunc 0x0008  /* True if analyzing arguments to an agg func */
 #define NC_PartIdx   0x0010  /* True if resolving a partial index WHERE */
+#define NC_IdxExpr   0x0020  /* True if resolving columns of CREATE INDEX */
 #define NC_MinMaxAgg 0x1000  /* min/max aggregates seen.  See note above */
 
 /*
@@ -12603,7 +13227,7 @@ struct Parse {
   int nOpAlloc;        /* Number of slots allocated for Vdbe.aOp[] */
   int iFixedOp;        /* Never back out opcodes iFixedOp-1 or earlier */
   int ckBase;          /* Base register of data during check constraints */
-  int iPartIdxTab;     /* Table corresponding to a partial index */
+  int iSelfTab;        /* Table of an index whose exprs are being coded */
   int iCacheLevel;     /* ColCache valid when aColCache[].iLevel<=iCacheLevel */
   int iCacheCnt;       /* Counter used to generate aColCache[].lru values */
   int nLabel;          /* Number of labels used */
@@ -12973,7 +13597,7 @@ struct With {
     char *zName;                    /* Name of this CTE */
     ExprList *pCols;                /* List of explicit column names, or NULL */
     Select *pSelect;                /* The definition of this CTE */
-    const char *zErr;               /* Error message for circular references */
+    const char *zCteErr;            /* Error message for circular references */
   } a[1];
 };
 
@@ -13121,6 +13745,11 @@ SQLITE_PRIVATE   sqlite3_mutex *sqlite3MutexAlloc(int);
 SQLITE_PRIVATE   int sqlite3MutexInit(void);
 SQLITE_PRIVATE   int sqlite3MutexEnd(void);
 #endif
+#if !defined(SQLITE_MUTEX_OMIT) && !defined(SQLITE_MUTEX_NOOP)
+SQLITE_PRIVATE   void sqlite3MemoryBarrier(void);
+#else
+# define sqlite3MemoryBarrier()
+#endif
 
 SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int);
 SQLITE_PRIVATE void sqlite3StatusUp(int, int);
@@ -13187,6 +13816,7 @@ SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*);
 SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse*, Expr*);
 SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3*, Expr*);
 SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);
+SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList*,int);
 SQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);
 SQLITE_PRIVATE void sqlite3ExprListSetSpan(Parse*,ExprList*,ExprSpan*);
 SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*);
@@ -13199,6 +13829,8 @@ SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3*,int);
 SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3*);
 SQLITE_PRIVATE void sqlite3BeginParse(Parse*,int);
 SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3*);
+SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3*,Table*);
+SQLITE_PRIVATE int sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**);
 SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*,Select*);
 SQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *, int);
 SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table*);
@@ -13240,7 +13872,7 @@ SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet*, i64);
 SQLITE_PRIVATE int sqlite3RowSetTest(RowSet*, int iBatch, i64);
 SQLITE_PRIVATE int sqlite3RowSetNext(RowSet*, i64*);
 
-SQLITE_PRIVATE void sqlite3CreateView(Parse*,Token*,Token*,Token*,Select*,int,int);
+SQLITE_PRIVATE void sqlite3CreateView(Parse*,Token*,Token*,Token*,ExprList*,Select*,int,int);
 
 #if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
 SQLITE_PRIVATE   int sqlite3ViewGetColumnNames(Parse*,Table*);
@@ -13270,6 +13902,7 @@ SQLITE_PRIVATE SrcList *sqlite3SrcListAppend(sqlite3*, SrcList*, Token*, Token*)
 SQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,
                                       Token*, Select*, Expr*, IdList*);
 SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);
+SQLITE_PRIVATE void sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*);
 SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);
 SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList*);
 SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse*, SrcList*);
@@ -13300,6 +13933,10 @@ SQLITE_PRIVATE int sqlite3WhereIsSorted(WhereInfo*);
 SQLITE_PRIVATE int sqlite3WhereContinueLabel(WhereInfo*);
 SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo*);
 SQLITE_PRIVATE int sqlite3WhereOkOnePass(WhereInfo*, int*);
+#define ONEPASS_OFF      0        /* Use of ONEPASS not allowed */
+#define ONEPASS_SINGLE   1        /* ONEPASS valid for a single row update */
+#define ONEPASS_MULTI    2        /* ONEPASS is valid for multiple rows */
+SQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int);
 SQLITE_PRIVATE int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8);
 SQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);
 SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse*, int, int, int);
@@ -13315,9 +13952,10 @@ SQLITE_PRIVATE void sqlite3ExprCodeAtInit(Parse*, Expr*, int, u8);
 SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse*, Expr*, int*);
 SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse*, Expr*, int);
 SQLITE_PRIVATE void sqlite3ExprCodeAndCache(Parse*, Expr*, int);
-SQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, u8);
+SQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);
 #define SQLITE_ECEL_DUP      0x01  /* Deep, not shallow copies */
 #define SQLITE_ECEL_FACTOR   0x02  /* Factor out constant terms */
+#define SQLITE_ECEL_REF      0x04  /* Use ExprList.u.x.iOrderByCol */
 SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse*, Expr*, int, int);
 SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse*, Expr*, int, int);
 SQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse*, Expr*, int, int);
@@ -13358,8 +13996,9 @@ SQLITE_PRIVATE int sqlite3ExprIsInteger(Expr*, int*);
 SQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr*);
 SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr*, char);
 SQLITE_PRIVATE int sqlite3IsRowid(const char*);
-SQLITE_PRIVATE void sqlite3GenerateRowDelete(Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8);
-SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*);
+SQLITE_PRIVATE void sqlite3GenerateRowDelete(
+    Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8,int);
+SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int);
 SQLITE_PRIVATE int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*,Index*,int);
 SQLITE_PRIVATE void sqlite3ResolvePartIdxLabel(Parse*,int);
 SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(Parse*,Table*,int*,int,int,int,int,
@@ -13417,6 +14056,7 @@ SQLITE_PRIVATE   void sqlite3DeleteTrigger(sqlite3*, Trigger*);
 SQLITE_PRIVATE   void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);
 SQLITE_PRIVATE   u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);
 # define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))
+# define sqlite3IsToplevel(p) ((p)->pToplevel==0)
 #else
 # define sqlite3TriggersExist(B,C,D,E,F) 0
 # define sqlite3DeleteTrigger(A,B)
@@ -13426,6 +14066,7 @@ SQLITE_PRIVATE   u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Tab
 # define sqlite3CodeRowTriggerDirect(A,B,C,D,E,F)
 # define sqlite3TriggerList(X, Y) 0
 # define sqlite3ParseToplevel(p) p
+# define sqlite3IsToplevel(p) 1
 # define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0
 #endif
 
@@ -13489,7 +14130,7 @@ SQLITE_PRIVATE int sqlite3VarintLen(u64 v);
 #define putVarint    sqlite3PutVarint
 
 
-SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(Vdbe *, Index *);
+SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3*, Index*);
 SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe*, Table*, int);
 SQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2);
 SQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);
@@ -13561,6 +14202,7 @@ SQLITE_PRIVATE void sqlite3SelectPrep(Parse*, Select*, NameContext*);
 SQLITE_PRIVATE void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);
 SQLITE_PRIVATE int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);
 SQLITE_PRIVATE int sqlite3ResolveExprNames(NameContext*, Expr*);
+SQLITE_PRIVATE int sqlite3ResolveExprListNames(NameContext*, ExprList*);
 SQLITE_PRIVATE void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);
 SQLITE_PRIVATE void sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);
 SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);
@@ -13669,6 +14311,8 @@ SQLITE_PRIVATE    void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);
 SQLITE_PRIVATE    VTable *sqlite3GetVTable(sqlite3*, Table*);
 #  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)
 #endif
+SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse*,Module*);
+SQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3*,Module*);
 SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse*,Table*);
 SQLITE_PRIVATE void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);
 SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse*, Token*);
@@ -14242,12 +14886,18 @@ static const char * const azCompileOpt[] = {
 #if SQLITE_ENABLE_FTS4
   "ENABLE_FTS4",
 #endif
+#if SQLITE_ENABLE_FTS5
+  "ENABLE_FTS5",
+#endif
 #if SQLITE_ENABLE_ICU
   "ENABLE_ICU",
 #endif
 #if SQLITE_ENABLE_IOTRACE
   "ENABLE_IOTRACE",
 #endif
+#if SQLITE_ENABLE_JSON1
+  "ENABLE_JSON1",
+#endif
 #if SQLITE_ENABLE_LOAD_EXTENSION
   "ENABLE_LOAD_EXTENSION",
 #endif
@@ -14772,6 +15422,7 @@ struct Mem {
   } u;
   u16 flags;          /* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. */
   u8  enc;            /* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE */
+  u8  eSubtype;       /* Subtype for this value */
   int n;              /* Number of characters in string value, excluding '\0' */
   char *z;            /* String or BLOB value */
   /* ShallowCopy only needs to copy the information above */
@@ -16548,14 +17199,14 @@ static void currentTimeFunc(
 SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void){
   static SQLITE_WSD FuncDef aDateTimeFuncs[] = {
 #ifndef SQLITE_OMIT_DATETIME_FUNCS
-    FUNCTION(julianday,        -1, 0, 0, juliandayFunc ),
-    FUNCTION(date,             -1, 0, 0, dateFunc      ),
-    FUNCTION(time,             -1, 0, 0, timeFunc      ),
-    FUNCTION(datetime,         -1, 0, 0, datetimeFunc  ),
-    FUNCTION(strftime,         -1, 0, 0, strftimeFunc  ),
-    FUNCTION(current_time,      0, 0, 0, ctimeFunc     ),
-    FUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc),
-    FUNCTION(current_date,      0, 0, 0, cdateFunc     ),
+    DFUNCTION(julianday,        -1, 0, 0, juliandayFunc ),
+    DFUNCTION(date,             -1, 0, 0, dateFunc      ),
+    DFUNCTION(time,             -1, 0, 0, timeFunc      ),
+    DFUNCTION(datetime,         -1, 0, 0, datetimeFunc  ),
+    DFUNCTION(strftime,         -1, 0, 0, strftimeFunc  ),
+    DFUNCTION(current_time,      0, 0, 0, ctimeFunc     ),
+    DFUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc),
+    DFUNCTION(current_date,      0, 0, 0, cdateFunc     ),
 #else
     STR_FUNCTION(current_time,      0, "%H:%M:%S",          0, currentTimeFunc),
     STR_FUNCTION(current_date,      0, "%Y-%m-%d",          0, currentTimeFunc),
@@ -19244,7 +19895,7 @@ SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void){
 ** allocate a mutex while the system is uninitialized.
 */
 static SQLITE_WSD int mutexIsInit = 0;
-#endif /* SQLITE_DEBUG */
+#endif /* SQLITE_DEBUG && !defined(SQLITE_MUTEX_OMIT) */
 
 
 #ifndef SQLITE_MUTEX_OMIT
@@ -19275,8 +19926,10 @@ SQLITE_PRIVATE int sqlite3MutexInit(void){
     pTo->xMutexLeave = pFrom->xMutexLeave;
     pTo->xMutexHeld = pFrom->xMutexHeld;
     pTo->xMutexNotheld = pFrom->xMutexNotheld;
+    sqlite3MemoryBarrier();
     pTo->xMutexAlloc = pFrom->xMutexAlloc;
   }
+  assert( sqlite3GlobalConfig.mutex.xMutexInit );
   rc = sqlite3GlobalConfig.mutex.xMutexInit();
 
 #ifdef SQLITE_DEBUG
@@ -19311,6 +19964,7 @@ SQLITE_API sqlite3_mutex *SQLITE_STDCALL sqlite3_mutex_alloc(int id){
   if( id<=SQLITE_MUTEX_RECURSIVE && sqlite3_initialize() ) return 0;
   if( id>SQLITE_MUTEX_RECURSIVE && sqlite3MutexInit() ) return 0;
 #endif
+  assert( sqlite3GlobalConfig.mutex.xMutexAlloc );
   return sqlite3GlobalConfig.mutex.xMutexAlloc(id);
 }
 
@@ -19319,6 +19973,7 @@ SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id){
     return 0;
   }
   assert( GLOBAL(int, mutexIsInit) );
+  assert( sqlite3GlobalConfig.mutex.xMutexAlloc );
   return sqlite3GlobalConfig.mutex.xMutexAlloc(id);
 }
 
@@ -19327,6 +19982,7 @@ SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id){
 */
 SQLITE_API void SQLITE_STDCALL sqlite3_mutex_free(sqlite3_mutex *p){
   if( p ){
+    assert( sqlite3GlobalConfig.mutex.xMutexFree );
     sqlite3GlobalConfig.mutex.xMutexFree(p);
   }
 }
@@ -19337,6 +19993,7 @@ SQLITE_API void SQLITE_STDCALL sqlite3_mutex_free(sqlite3_mutex *p){
 */
 SQLITE_API void SQLITE_STDCALL sqlite3_mutex_enter(sqlite3_mutex *p){
   if( p ){
+    assert( sqlite3GlobalConfig.mutex.xMutexEnter );
     sqlite3GlobalConfig.mutex.xMutexEnter(p);
   }
 }
@@ -19348,6 +20005,7 @@ SQLITE_API void SQLITE_STDCALL sqlite3_mutex_enter(sqlite3_mutex *p){
 SQLITE_API int SQLITE_STDCALL sqlite3_mutex_try(sqlite3_mutex *p){
   int rc = SQLITE_OK;
   if( p ){
+    assert( sqlite3GlobalConfig.mutex.xMutexTry );
     return sqlite3GlobalConfig.mutex.xMutexTry(p);
   }
   return rc;
@@ -19361,6 +20019,7 @@ SQLITE_API int SQLITE_STDCALL sqlite3_mutex_try(sqlite3_mutex *p){
 */
 SQLITE_API void SQLITE_STDCALL sqlite3_mutex_leave(sqlite3_mutex *p){
   if( p ){
+    assert( sqlite3GlobalConfig.mutex.xMutexLeave );
     sqlite3GlobalConfig.mutex.xMutexLeave(p);
   }
 }
@@ -19371,9 +20030,11 @@ SQLITE_API void SQLITE_STDCALL sqlite3_mutex_leave(sqlite3_mutex *p){
 ** intended for use inside assert() statements.
 */
 SQLITE_API int SQLITE_STDCALL sqlite3_mutex_held(sqlite3_mutex *p){
+  assert( p==0 || sqlite3GlobalConfig.mutex.xMutexHeld );
   return p==0 || sqlite3GlobalConfig.mutex.xMutexHeld(p);
 }
 SQLITE_API int SQLITE_STDCALL sqlite3_mutex_notheld(sqlite3_mutex *p){
+  assert( p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld );
   return p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld(p);
 }
 #endif
@@ -19682,6 +20343,19 @@ static int pthreadMutexNotheld(sqlite3_mutex *p){
 }
 #endif
 
+/*
+** Try to provide a memory barrier operation, needed for initialization
+** and also for the implementation of xShmBarrier in the VFS in cases
+** where SQLite is compiled without mutexes.
+*/
+SQLITE_PRIVATE void sqlite3MemoryBarrier(void){
+#if defined(SQLITE_MEMORY_BARRIER)
+  SQLITE_MEMORY_BARRIER;
+#elif defined(__GNUC__) && GCC_VERSION>=4001000
+  __sync_synchronize();
+#endif
+}
+
 /*
 ** Initialize and deinitialize the mutex subsystem.
 */
@@ -20344,6 +21018,24 @@ static int winMutexNotheld(sqlite3_mutex *p){
 }
 #endif
 
+/*
+** Try to provide a memory barrier operation, needed for initialization
+** and also for the xShmBarrier method of the VFS in cases when SQLite is
+** compiled without mutexes (SQLITE_THREADSAFE=0).
+*/
+SQLITE_PRIVATE void sqlite3MemoryBarrier(void){
+#if defined(SQLITE_MEMORY_BARRIER)
+  SQLITE_MEMORY_BARRIER;
+#elif defined(__GNUC__)
+  __sync_synchronize();
+#elif !defined(SQLITE_DISABLE_INTRINSIC) && \
+      defined(_MSC_VER) && _MSC_VER>=1300
+  _ReadWriteBarrier();
+#elif defined(MemoryBarrier)
+  MemoryBarrier();
+#endif
+}
+
 /*
 ** Initialize and deinitialize the mutex subsystem.
 */
@@ -20697,16 +21389,7 @@ typedef struct ScratchFreeslot {
 */
 static SQLITE_WSD struct Mem0Global {
   sqlite3_mutex *mutex;         /* Mutex to serialize access */
-
-  /*
-  ** The alarm callback and its arguments.  The mem0.mutex lock will
-  ** be held while the callback is running.  Recursive calls into
-  ** the memory subsystem are allowed, but no new callbacks will be
-  ** issued.
-  */
-  sqlite3_int64 alarmThreshold;
-  void (*alarmCallback)(void*, sqlite3_int64,int);
-  void *alarmArg;
+  sqlite3_int64 alarmThreshold; /* The soft heap limit */
 
   /*
   ** Pointers to the end of sqlite3GlobalConfig.pScratch memory
@@ -20723,7 +21406,7 @@ static SQLITE_WSD struct Mem0Global {
   ** sqlite3_soft_heap_limit() setting.
   */
   int nearlyFull;
-} mem0 = { 0, 0, 0, 0, 0, 0, 0, 0 };
+} mem0 = { 0, 0, 0, 0, 0, 0 };
 
 #define mem0 GLOBAL(struct Mem0Global, mem0)
 
@@ -20734,50 +21417,21 @@ SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void){
   return mem0.mutex;
 }
 
-/*
-** This routine runs when the memory allocator sees that the
-** total memory allocation is about to exceed the soft heap
-** limit.
-*/
-static void softHeapLimitEnforcer(
-  void *NotUsed, 
-  sqlite3_int64 NotUsed2,
-  int allocSize
-){
-  UNUSED_PARAMETER2(NotUsed, NotUsed2);
-  sqlite3_release_memory(allocSize);
-}
-
-/*
-** Change the alarm callback
-*/
-static int sqlite3MemoryAlarm(
-  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
-  void *pArg,
-  sqlite3_int64 iThreshold
-){
-  sqlite3_int64 nUsed;
-  sqlite3_mutex_enter(mem0.mutex);
-  mem0.alarmCallback = xCallback;
-  mem0.alarmArg = pArg;
-  mem0.alarmThreshold = iThreshold;
-  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
-  mem0.nearlyFull = (iThreshold>0 && iThreshold<=nUsed);
-  sqlite3_mutex_leave(mem0.mutex);
-  return SQLITE_OK;
-}
-
 #ifndef SQLITE_OMIT_DEPRECATED
 /*
-** Deprecated external interface.  Internal/core SQLite code
-** should call sqlite3MemoryAlarm.
+** Deprecated external interface.  It used to set an alarm callback
+** that was invoked when memory usage grew too large.  Now it is a
+** no-op.
 */
 SQLITE_API int SQLITE_STDCALL sqlite3_memory_alarm(
   void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
   void *pArg,
   sqlite3_int64 iThreshold
 ){
-  return sqlite3MemoryAlarm(xCallback, pArg, iThreshold);
+  (void)xCallback;
+  (void)pArg;
+  (void)iThreshold;
+  return SQLITE_OK;
 }
 #endif
 
@@ -20788,19 +21442,21 @@ SQLITE_API int SQLITE_STDCALL sqlite3_memory_alarm(
 SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_soft_heap_limit64(sqlite3_int64 n){
   sqlite3_int64 priorLimit;
   sqlite3_int64 excess;
+  sqlite3_int64 nUsed;
 #ifndef SQLITE_OMIT_AUTOINIT
   int rc = sqlite3_initialize();
   if( rc ) return -1;
 #endif
   sqlite3_mutex_enter(mem0.mutex);
   priorLimit = mem0.alarmThreshold;
-  sqlite3_mutex_leave(mem0.mutex);
-  if( n<0 ) return priorLimit;
-  if( n>0 ){
-    sqlite3MemoryAlarm(softHeapLimitEnforcer, 0, n);
-  }else{
-    sqlite3MemoryAlarm(0, 0, 0);
+  if( n<0 ){
+    sqlite3_mutex_leave(mem0.mutex);
+    return priorLimit;
   }
+  mem0.alarmThreshold = n;
+  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
+  mem0.nearlyFull = (n>0 && n<=nUsed);
+  sqlite3_mutex_leave(mem0.mutex);
   excess = sqlite3_memory_used() - n;
   if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));
   return priorLimit;
@@ -20897,19 +21553,10 @@ SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3_memory_highwater(int resetFlag){
 ** Trigger the alarm 
 */
 static void sqlite3MallocAlarm(int nByte){
-  void (*xCallback)(void*,sqlite3_int64,int);
-  sqlite3_int64 nowUsed;
-  void *pArg;
-  if( mem0.alarmCallback==0 ) return;
-  xCallback = mem0.alarmCallback;
-  nowUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
-  pArg = mem0.alarmArg;
-  mem0.alarmCallback = 0;
+  if( mem0.alarmThreshold<=0 ) return;
   sqlite3_mutex_leave(mem0.mutex);
-  xCallback(pArg, nowUsed, nByte);
+  sqlite3_release_memory(nByte);
   sqlite3_mutex_enter(mem0.mutex);
-  mem0.alarmCallback = xCallback;
-  mem0.alarmArg = pArg;
 }
 
 /*
@@ -20922,7 +21569,7 @@ static int mallocWithAlarm(int n, void **pp){
   assert( sqlite3_mutex_held(mem0.mutex) );
   nFull = sqlite3GlobalConfig.m.xRoundup(n);
   sqlite3StatusSet(SQLITE_STATUS_MALLOC_SIZE, n);
-  if( mem0.alarmCallback!=0 ){
+  if( mem0.alarmThreshold>0 ){
     sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
     if( nUsed >= mem0.alarmThreshold - nFull ){
       mem0.nearlyFull = 1;
@@ -20933,7 +21580,7 @@ static int mallocWithAlarm(int n, void **pp){
   }
   p = sqlite3GlobalConfig.m.xMalloc(nFull);
 #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
-  if( p==0 && mem0.alarmCallback ){
+  if( p==0 && mem0.alarmThreshold>0 ){
     sqlite3MallocAlarm(nFull);
     p = sqlite3GlobalConfig.m.xMalloc(nFull);
   }
@@ -21108,19 +21755,20 @@ SQLITE_PRIVATE int sqlite3MallocSize(void *p){
   return sqlite3GlobalConfig.m.xSize(p);
 }
 SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p){
-  if( db==0 ){
-    assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
-    assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
-    return sqlite3MallocSize(p);
-  }else{
-    assert( sqlite3_mutex_held(db->mutex) );
-    if( isLookaside(db, p) ){
-      return db->lookaside.sz;
+  if( db==0 || !isLookaside(db,p) ){
+#if SQLITE_DEBUG
+    if( db==0 ){
+      assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
+      assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
     }else{
       assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
       assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
-      return sqlite3GlobalConfig.m.xSize(p);
     }
+#endif
+    return sqlite3GlobalConfig.m.xSize(p);
+  }else{
+    assert( sqlite3_mutex_held(db->mutex) );
+    return db->lookaside.sz;
   }
 }
 SQLITE_API sqlite3_uint64 SQLITE_STDCALL sqlite3_msize(void *p){
@@ -21221,7 +21869,7 @@ SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){
       sqlite3MallocAlarm(nDiff);
     }
     pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
-    if( pNew==0 && mem0.alarmCallback ){
+    if( pNew==0 && mem0.alarmThreshold>0 ){
       sqlite3MallocAlarm((int)nBytes);
       pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
     }
@@ -21935,21 +22583,16 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
         if( realvalue>0.0 ){
           LONGDOUBLE_TYPE scale = 1.0;
           while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}
-          while( realvalue>=1e64*scale && exp<=350 ){ scale *= 1e64; exp+=64; }
-          while( realvalue>=1e8*scale && exp<=350 ){ scale *= 1e8; exp+=8; }
+          while( realvalue>=1e10*scale && exp<=350 ){ scale *= 1e10; exp+=10; }
           while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }
           realvalue /= scale;
           while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }
           while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }
           if( exp>350 ){
-            if( prefix=='-' ){
-              bufpt = "-Inf";
-            }else if( prefix=='+' ){
-              bufpt = "+Inf";
-            }else{
-              bufpt = "Inf";
-            }
-            length = sqlite3Strlen30(bufpt);
+            bufpt = buf;
+            buf[0] = prefix;
+            memcpy(buf+(prefix!=0),"Inf",4);
+            length = 3+(prefix!=0);
             break;
           }
         }
@@ -22098,12 +22741,13 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
       case etDYNSTRING:
         if( bArgList ){
           bufpt = getTextArg(pArgList);
+          xtype = etSTRING;
         }else{
           bufpt = va_arg(ap,char*);
         }
         if( bufpt==0 ){
           bufpt = "";
-        }else if( xtype==etDYNSTRING && !bArgList ){
+        }else if( xtype==etDYNSTRING ){
           zExtra = bufpt;
         }
         if( precision>=0 ){
@@ -22112,9 +22756,9 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
           length = sqlite3Strlen30(bufpt);
         }
         break;
-      case etSQLESCAPE:
-      case etSQLESCAPE2:
-      case etSQLESCAPE3: {
+      case etSQLESCAPE:           /* Escape ' characters */
+      case etSQLESCAPE2:          /* Escape ' and enclose in '...' */
+      case etSQLESCAPE3: {        /* Escape " characters */
         int i, j, k, n, isnull;
         int needQuote;
         char ch;
@@ -22133,7 +22777,7 @@ SQLITE_PRIVATE void sqlite3VXPrintf(
           if( ch==q )  n++;
         }
         needQuote = !isnull && xtype==etSQLESCAPE2;
-        n += i + 1 + needQuote*2;
+        n += i + 3;
         if( n>etBUFSIZE ){
           bufpt = zExtra = sqlite3Malloc( n );
           if( bufpt==0 ){
@@ -22529,7 +23173,8 @@ SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){
 
 
 /*
-** variable-argument wrapper around sqlite3VXPrintf().
+** variable-argument wrapper around sqlite3VXPrintf().  The bFlags argument
+** can contain the bit SQLITE_PRINTF_INTERNAL enable internal formats.
 */
 SQLITE_PRIVATE void sqlite3XPrintf(StrAccum *p, u32 bFlags, const char *zFormat, ...){
   va_list ap;
@@ -22627,90 +23272,100 @@ static void sqlite3TreeViewItem(TreeView *p, const char *zLabel,u8 moreFollows){
 */
 SQLITE_PRIVATE void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 moreToFollow){
   int n = 0;
+  int cnt = 0;
   pView = sqlite3TreeViewPush(pView, moreToFollow);
-  sqlite3TreeViewLine(pView, "SELECT%s%s (0x%p) selFlags=0x%x",
-    ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),
-    ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""), p, p->selFlags
-  );
-  if( p->pSrc && p->pSrc->nSrc ) n++;
-  if( p->pWhere ) n++;
-  if( p->pGroupBy ) n++;
-  if( p->pHaving ) n++;
-  if( p->pOrderBy ) n++;
-  if( p->pLimit ) n++;
-  if( p->pOffset ) n++;
-  if( p->pPrior ) n++;
-  sqlite3TreeViewExprList(pView, p->pEList, (n--)>0, "result-set");
-  if( p->pSrc && p->pSrc->nSrc ){
-    int i;
-    pView = sqlite3TreeViewPush(pView, (n--)>0);
-    sqlite3TreeViewLine(pView, "FROM");
-    for(i=0; i<p->pSrc->nSrc; i++){
-      struct SrcList_item *pItem = &p->pSrc->a[i];
-      StrAccum x;
-      char zLine[100];
-      sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);
-      sqlite3XPrintf(&x, 0, "{%d,*}", pItem->iCursor);
-      if( pItem->zDatabase ){
-        sqlite3XPrintf(&x, 0, " %s.%s", pItem->zDatabase, pItem->zName);
-      }else if( pItem->zName ){
-        sqlite3XPrintf(&x, 0, " %s", pItem->zName);
-      }
-      if( pItem->pTab ){
-        sqlite3XPrintf(&x, 0, " tabname=%Q", pItem->pTab->zName);
-      }
-      if( pItem->zAlias ){
-        sqlite3XPrintf(&x, 0, " (AS %s)", pItem->zAlias);
-      }
-      if( pItem->jointype & JT_LEFT ){
-        sqlite3XPrintf(&x, 0, " LEFT-JOIN");
-      }
-      sqlite3StrAccumFinish(&x);
-      sqlite3TreeViewItem(pView, zLine, i<p->pSrc->nSrc-1); 
-      if( pItem->pSelect ){
-        sqlite3TreeViewSelect(pView, pItem->pSelect, 0);
+  do{
+    sqlite3TreeViewLine(pView, "SELECT%s%s (0x%p) selFlags=0x%x",
+      ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),
+      ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""), p, p->selFlags
+    );
+    if( cnt++ ) sqlite3TreeViewPop(pView);
+    if( p->pPrior ){
+      n = 1000;
+    }else{
+      n = 0;
+      if( p->pSrc && p->pSrc->nSrc ) n++;
+      if( p->pWhere ) n++;
+      if( p->pGroupBy ) n++;
+      if( p->pHaving ) n++;
+      if( p->pOrderBy ) n++;
+      if( p->pLimit ) n++;
+      if( p->pOffset ) n++;
+    }
+    sqlite3TreeViewExprList(pView, p->pEList, (n--)>0, "result-set");
+    if( p->pSrc && p->pSrc->nSrc ){
+      int i;
+      pView = sqlite3TreeViewPush(pView, (n--)>0);
+      sqlite3TreeViewLine(pView, "FROM");
+      for(i=0; i<p->pSrc->nSrc; i++){
+        struct SrcList_item *pItem = &p->pSrc->a[i];
+        StrAccum x;
+        char zLine[100];
+        sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);
+        sqlite3XPrintf(&x, 0, "{%d,*}", pItem->iCursor);
+        if( pItem->zDatabase ){
+          sqlite3XPrintf(&x, 0, " %s.%s", pItem->zDatabase, pItem->zName);
+        }else if( pItem->zName ){
+          sqlite3XPrintf(&x, 0, " %s", pItem->zName);
+        }
+        if( pItem->pTab ){
+          sqlite3XPrintf(&x, 0, " tabname=%Q", pItem->pTab->zName);
+        }
+        if( pItem->zAlias ){
+          sqlite3XPrintf(&x, 0, " (AS %s)", pItem->zAlias);
+        }
+        if( pItem->fg.jointype & JT_LEFT ){
+          sqlite3XPrintf(&x, 0, " LEFT-JOIN");
+        }
+        sqlite3StrAccumFinish(&x);
+        sqlite3TreeViewItem(pView, zLine, i<p->pSrc->nSrc-1); 
+        if( pItem->pSelect ){
+          sqlite3TreeViewSelect(pView, pItem->pSelect, 0);
+        }
+        if( pItem->fg.isTabFunc ){
+          sqlite3TreeViewExprList(pView, pItem->u1.pFuncArg, 0, "func-args:");
+        }
+        sqlite3TreeViewPop(pView);
       }
       sqlite3TreeViewPop(pView);
     }
-    sqlite3TreeViewPop(pView);
-  }
-  if( p->pWhere ){
-    sqlite3TreeViewItem(pView, "WHERE", (n--)>0);
-    sqlite3TreeViewExpr(pView, p->pWhere, 0);
-    sqlite3TreeViewPop(pView);
-  }
-  if( p->pGroupBy ){
-    sqlite3TreeViewExprList(pView, p->pGroupBy, (n--)>0, "GROUPBY");
-  }
-  if( p->pHaving ){
-    sqlite3TreeViewItem(pView, "HAVING", (n--)>0);
-    sqlite3TreeViewExpr(pView, p->pHaving, 0);
-    sqlite3TreeViewPop(pView);
-  }
-  if( p->pOrderBy ){
-    sqlite3TreeViewExprList(pView, p->pOrderBy, (n--)>0, "ORDERBY");
-  }
-  if( p->pLimit ){
-    sqlite3TreeViewItem(pView, "LIMIT", (n--)>0);
-    sqlite3TreeViewExpr(pView, p->pLimit, 0);
-    sqlite3TreeViewPop(pView);
-  }
-  if( p->pOffset ){
-    sqlite3TreeViewItem(pView, "OFFSET", (n--)>0);
-    sqlite3TreeViewExpr(pView, p->pOffset, 0);
-    sqlite3TreeViewPop(pView);
-  }
-  if( p->pPrior ){
-    const char *zOp = "UNION";
-    switch( p->op ){
-      case TK_ALL:         zOp = "UNION ALL";  break;
-      case TK_INTERSECT:   zOp = "INTERSECT";  break;
-      case TK_EXCEPT:      zOp = "EXCEPT";     break;
-    }
-    sqlite3TreeViewItem(pView, zOp, (n--)>0);
-    sqlite3TreeViewSelect(pView, p->pPrior, 0);
-    sqlite3TreeViewPop(pView);
-  }
+    if( p->pWhere ){
+      sqlite3TreeViewItem(pView, "WHERE", (n--)>0);
+      sqlite3TreeViewExpr(pView, p->pWhere, 0);
+      sqlite3TreeViewPop(pView);
+    }
+    if( p->pGroupBy ){
+      sqlite3TreeViewExprList(pView, p->pGroupBy, (n--)>0, "GROUPBY");
+    }
+    if( p->pHaving ){
+      sqlite3TreeViewItem(pView, "HAVING", (n--)>0);
+      sqlite3TreeViewExpr(pView, p->pHaving, 0);
+      sqlite3TreeViewPop(pView);
+    }
+    if( p->pOrderBy ){
+      sqlite3TreeViewExprList(pView, p->pOrderBy, (n--)>0, "ORDERBY");
+    }
+    if( p->pLimit ){
+      sqlite3TreeViewItem(pView, "LIMIT", (n--)>0);
+      sqlite3TreeViewExpr(pView, p->pLimit, 0);
+      sqlite3TreeViewPop(pView);
+    }
+    if( p->pOffset ){
+      sqlite3TreeViewItem(pView, "OFFSET", (n--)>0);
+      sqlite3TreeViewExpr(pView, p->pOffset, 0);
+      sqlite3TreeViewPop(pView);
+    }
+    if( p->pPrior ){
+      const char *zOp = "UNION";
+      switch( p->op ){
+        case TK_ALL:         zOp = "UNION ALL";  break;
+        case TK_INTERSECT:   zOp = "INTERSECT";  break;
+        case TK_EXCEPT:      zOp = "EXCEPT";     break;
+      }
+      sqlite3TreeViewItem(pView, zOp, 1);
+    }
+    p = p->pPrior;
+  }while( p!=0 );
   sqlite3TreeViewPop(pView);
 }
 
@@ -22785,11 +23440,6 @@ SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 m
       sqlite3TreeViewLine(pView,"REGISTER(%d)", pExpr->iTable);
       break;
     }
-    case TK_AS: {
-      sqlite3TreeViewLine(pView,"AS %Q", pExpr->u.zToken);
-      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
-      break;
-    }
     case TK_ID: {
       sqlite3TreeViewLine(pView,"ID \"%w\"", pExpr->u.zToken);
       break;
@@ -22964,7 +23614,13 @@ SQLITE_PRIVATE void sqlite3TreeViewExprList(
   }else{
     sqlite3TreeViewLine(pView, "%s", zLabel);
     for(i=0; i<pList->nExpr; i++){
+      int j = pList->a[i].u.x.iOrderByCol;
+      if( j ){
+        sqlite3TreeViewPush(pView, 0);
+        sqlite3TreeViewLine(pView, "iOrderByCol=%d", j);
+      }
       sqlite3TreeViewExpr(pView, pList->a[i].pExpr, i<pList->nExpr-1);
+      if( j ) sqlite3TreeViewPop(pView);
     }
   }
   sqlite3TreeViewPop(pView);
@@ -23180,6 +23836,10 @@ SQLITE_PRIVATE int sqlite3ThreadCreate(
   memset(p, 0, sizeof(*p));
   p->xTask = xTask;
   p->pIn = pIn;
+  /* If the SQLITE_TESTCTRL_FAULT_INSTALL callback is registered to a 
+  ** function that returns SQLITE_ERROR when passed the argument 200, that
+  ** forces worker threads to run sequentially and deterministically 
+  ** for testing purposes. */
   if( sqlite3FaultSim(200) ){
     rc = 1;
   }else{    
@@ -23264,7 +23924,12 @@ SQLITE_PRIVATE int sqlite3ThreadCreate(
   *ppThread = 0;
   p = sqlite3Malloc(sizeof(*p));
   if( p==0 ) return SQLITE_NOMEM;
-  if( sqlite3GlobalConfig.bCoreMutex==0 ){
+  /* If the SQLITE_TESTCTRL_FAULT_INSTALL callback is registered to a 
+  ** function that returns SQLITE_ERROR when passed the argument 200, that
+  ** forces worker threads to run sequentially and deterministically 
+  ** (via the sqlite3FaultSim() term of the conditional) for testing
+  ** purposes. */
+  if( sqlite3GlobalConfig.bCoreMutex==0 || sqlite3FaultSim(200) ){
     memset(p, 0, sizeof(*p));
   }else{
     p->xTask = xTask;
@@ -23292,7 +23957,7 @@ SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){
   assert( ppOut!=0 );
   if( NEVER(p==0) ) return SQLITE_NOMEM;
   if( p->xTask==0 ){
-    assert( p->id==GetCurrentThreadId() );
+    /* assert( p->id==GetCurrentThreadId() ); */
     rc = WAIT_OBJECT_0;
     assert( p->tid==0 );
   }else{
@@ -24979,11 +25644,8 @@ SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
 ** 64-bit integer.
 */
 SQLITE_PRIVATE int sqlite3VarintLen(u64 v){
-  int i = 0;
-  do{
-    i++;
-    v >>= 7;
-  }while( v!=0 && ALWAYS(i<9) );
+  int i;
+  for(i=1; (v >>= 7)!=0; i++){ assert( i<9 ); }
   return i;
 }
 
@@ -24996,11 +25658,13 @@ SQLITE_PRIVATE u32 sqlite3Get4byte(const u8 *p){
   u32 x;
   memcpy(&x,p,4);
   return x;
-#elif SQLITE_BYTEORDER==1234 && defined(__GNUC__) && GCC_VERSION>=4003000
+#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
+    && defined(__GNUC__) && GCC_VERSION>=4003000
   u32 x;
   memcpy(&x,p,4);
   return __builtin_bswap32(x);
-#elif SQLITE_BYTEORDER==1234 && defined(_MSC_VER) && _MSC_VER>=1300
+#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
+    && defined(_MSC_VER) && _MSC_VER>=1300
   u32 x;
   memcpy(&x,p,4);
   return _byteswap_ulong(x);
@@ -25729,9 +26393,9 @@ SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){
      /* 135 */ "FkCounter"        OpHelp("fkctr[P1]+=P2"),
      /* 136 */ "FkIfZero"         OpHelp("if fkctr[P1]==0 goto P2"),
      /* 137 */ "MemMax"           OpHelp("r[P1]=max(r[P1],r[P2])"),
-     /* 138 */ "IfPos"            OpHelp("if r[P1]>0 goto P2"),
-     /* 139 */ "IfNeg"            OpHelp("r[P1]+=P3, if r[P1]<0 goto P2"),
-     /* 140 */ "IfNotZero"        OpHelp("if r[P1]!=0 then r[P1]+=P3, goto P2"),
+     /* 138 */ "IfPos"            OpHelp("if r[P1]>0 then r[P1]-=P3, goto P2"),
+     /* 139 */ "SetIfNotPos"      OpHelp("if r[P1]<=0 then r[P2]=P3"),
+     /* 140 */ "IfNotZero"        OpHelp("if r[P1]!=0 then r[P1]-=P3, goto P2"),
      /* 141 */ "DecrJumpZero"     OpHelp("if (--r[P1])==0 goto P2"),
      /* 142 */ "JumpZeroIncr"     OpHelp("if (r[P1]++)==0 ) goto P2"),
      /* 143 */ "AggStep0"         OpHelp("accum=r[P3] step(r[P2@P5])"),
@@ -29105,7 +29769,6 @@ static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){
   TIMER_START;
   assert( cnt==(cnt&0x1ffff) );
   assert( id->h>2 );
-  cnt &= 0x1ffff;
   do{
 #if defined(USE_PREAD)
     got = osPread(id->h, pBuf, cnt, offset);
@@ -29322,8 +29985,8 @@ static int unixWrite(
     }
   }
 #endif
-
-  while( amt>0 && (wrote = seekAndWrite(pFile, offset, pBuf, amt))>0 ){
+ 
+  while( (wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0 ){
     amt -= wrote;
     offset += wrote;
     pBuf = &((char*)pBuf)[wrote];
@@ -29331,7 +29994,7 @@ static int unixWrite(
   SimulateIOError(( wrote=(-1), amt=1 ));
   SimulateDiskfullError(( wrote=0, amt=1 ));
 
-  if( amt>0 ){
+  if( amt>wrote ){
     if( wrote<0 && pFile->lastErrno!=ENOSPC ){
       /* lastErrno set by seekAndWrite */
       return SQLITE_IOERR_WRITE;
@@ -30620,7 +31283,8 @@ static void unixShmBarrier(
   sqlite3_file *fd                /* Database file holding the shared memory */
 ){
   UNUSED_PARAMETER(fd);
-  unixEnterMutex();
+  sqlite3MemoryBarrier();         /* compiler-defined memory barrier */
+  unixEnterMutex();               /* Also mutex, for redundancy */
   unixLeaveMutex();
 }
 
@@ -37575,8 +38239,8 @@ static void winShmBarrier(
   sqlite3_file *fd          /* Database holding the shared memory */
 ){
   UNUSED_PARAMETER(fd);
-  /* MemoryBarrier(); // does not work -- do not know why not */
-  winShmEnterMutex();
+  sqlite3MemoryBarrier();   /* compiler-defined memory barrier */
+  winShmEnterMutex();       /* Also mutex, for redundancy */
   winShmLeaveMutex();
 }
 
@@ -39800,7 +40464,7 @@ SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int sz, int *aOp){
 struct PCache {
   PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */
   PgHdr *pSynced;                     /* Last synced page in dirty page list */
-  int nRef;                           /* Number of referenced pages */
+  int nRefSum;                        /* Sum of ref counts over all pages */
   int szCache;                        /* Configured cache size */
   int szPage;                         /* Size of every page in this cache */
   int szExtra;                        /* Size of extra space for each page */
@@ -39965,7 +40629,7 @@ SQLITE_PRIVATE int sqlite3PcacheOpen(
 ** are no outstanding page references when this function is called.
 */
 SQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *pCache, int szPage){
-  assert( pCache->nRef==0 && pCache->pDirty==0 );
+  assert( pCache->nRefSum==0 && pCache->pDirty==0 );
   if( pCache->szPage ){
     sqlite3_pcache *pNew;
     pNew = sqlite3GlobalConfig.pcache2.xCreate(
@@ -40132,9 +40796,7 @@ SQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(
   if( !pPgHdr->pPage ){
     return pcacheFetchFinishWithInit(pCache, pgno, pPage);
   }
-  if( 0==pPgHdr->nRef ){
-    pCache->nRef++;
-  }
+  pCache->nRefSum++;
   pPgHdr->nRef++;
   return pPgHdr;
 }
@@ -40145,9 +40807,8 @@ SQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(
 */
 SQLITE_PRIVATE void SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p){
   assert( p->nRef>0 );
-  p->nRef--;
-  if( p->nRef==0 ){
-    p->pCache->nRef--;
+  p->pCache->nRefSum--;
+  if( (--p->nRef)==0 ){
     if( p->flags&PGHDR_CLEAN ){
       pcacheUnpin(p);
     }else if( p->pDirtyPrev!=0 ){
@@ -40163,6 +40824,7 @@ SQLITE_PRIVATE void SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p){
 SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr *p){
   assert(p->nRef>0);
   p->nRef++;
+  p->pCache->nRefSum++;
 }
 
 /*
@@ -40175,7 +40837,7 @@ SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr *p){
   if( p->flags&PGHDR_DIRTY ){
     pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);
   }
-  p->pCache->nRef--;
+  p->pCache->nRefSum--;
   sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 1);
 }
 
@@ -40271,11 +40933,11 @@ SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){
         sqlite3PcacheMakeClean(p);
       }
     }
-    if( pgno==0 && pCache->nRef ){
+    if( pgno==0 && pCache->nRefSum ){
       sqlite3_pcache_page *pPage1;
       pPage1 = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache,1,0);
       if( ALWAYS(pPage1) ){  /* Page 1 is always available in cache, because
-                             ** pCache->nRef>0 */
+                             ** pCache->nRefSum>0 */
         memset(pPage1->pBuf, 0, pCache->szPage);
         pgno = 1;
       }
@@ -40381,10 +41043,13 @@ SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache *pCache){
 }
 
 /* 
-** Return the total number of referenced pages held by the cache.
+** Return the total number of references to all pages held by the cache.
+**
+** This is not the total number of pages referenced, but the sum of the
+** reference count for all pages.
 */
 SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache *pCache){
-  return pCache->nRef;
+  return pCache->nRefSum;
 }
 
 /*
@@ -40519,7 +41184,7 @@ SQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHd
 ** that is allocated when the page cache is created.  The size of the local
 ** bulk allocation can be adjusted using 
 **
-**     sqlite3_config(SQLITE_CONFIG_PCACHE, 0, 0, N).
+**     sqlite3_config(SQLITE_CONFIG_PAGECACHE, 0, 0, N).
 **
 ** If N is positive, then N pages worth of memory are allocated using a single
 ** sqlite3Malloc() call and that memory is used for the first N pages allocated.
@@ -40541,6 +41206,24 @@ typedef struct PgHdr1 PgHdr1;
 typedef struct PgFreeslot PgFreeslot;
 typedef struct PGroup PGroup;
 
+/*
+** Each cache entry is represented by an instance of the following 
+** structure. Unless SQLITE_PCACHE_SEPARATE_HEADER is defined, a buffer of
+** PgHdr1.pCache->szPage bytes is allocated directly before this structure 
+** in memory.
+*/
+struct PgHdr1 {
+  sqlite3_pcache_page page;      /* Base class. Must be first. pBuf & pExtra */
+  unsigned int iKey;             /* Key value (page number) */
+  u8 isPinned;                   /* Page in use, not on the LRU list */
+  u8 isBulkLocal;                /* This page from bulk local storage */
+  u8 isAnchor;                   /* This is the PGroup.lru element */
+  PgHdr1 *pNext;                 /* Next in hash table chain */
+  PCache1 *pCache;               /* Cache that currently owns this page */
+  PgHdr1 *pLruNext;              /* Next in LRU list of unpinned pages */
+  PgHdr1 *pLruPrev;              /* Previous in LRU list of unpinned pages */
+};
+
 /* Each page cache (or PCache) belongs to a PGroup.  A PGroup is a set 
 ** of one or more PCaches that are able to recycle each other's unpinned
 ** pages when they are under memory pressure.  A PGroup is an instance of
@@ -40569,7 +41252,7 @@ struct PGroup {
   unsigned int nMinPage;         /* Sum of nMin for purgeable caches */
   unsigned int mxPinned;         /* nMaxpage + 10 - nMinPage */
   unsigned int nCurrentPage;     /* Number of purgeable pages allocated */
-  PgHdr1 *pLruHead, *pLruTail;   /* LRU list of unpinned pages */
+  PgHdr1 lru;                    /* The beginning and end of the LRU list */
 };
 
 /* Each page cache is an instance of the following object.  Every
@@ -40607,23 +41290,6 @@ struct PCache1 {
   void *pBulk;                        /* Bulk memory used by pcache-local */
 };
 
-/*
-** Each cache entry is represented by an instance of the following 
-** structure. Unless SQLITE_PCACHE_SEPARATE_HEADER is defined, a buffer of
-** PgHdr1.pCache->szPage bytes is allocated directly before this structure 
-** in memory.
-*/
-struct PgHdr1 {
-  sqlite3_pcache_page page;
-  unsigned int iKey;             /* Key value (page number) */
-  u8 isPinned;                   /* Page in use, not on the LRU list */
-  u8 isBulkLocal;                /* This page from bulk local storage */
-  PgHdr1 *pNext;                 /* Next in hash table chain */
-  PCache1 *pCache;               /* Cache that currently owns this page */
-  PgHdr1 *pLruNext;              /* Next in LRU list of unpinned pages */
-  PgHdr1 *pLruPrev;              /* Previous in LRU list of unpinned pages */
-};
-
 /*
 ** Free slots in the allocator used to divide up the global page cache
 ** buffer provided using the SQLITE_CONFIG_PAGECACHE mechanism.
@@ -40684,6 +41350,7 @@ static SQLITE_WSD struct PCacheGlobal {
 /******************************************************************************/
 /******** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions **************/
 
+
 /*
 ** This function is called during initialization if a static buffer is 
 ** supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHE
@@ -40743,6 +41410,7 @@ static int pcache1InitBulk(PCache1 *pCache){
       pX->page.pBuf = zBulk;
       pX->page.pExtra = &pX[1];
       pX->isBulkLocal = 1;
+      pX->isAnchor = 0;
       pX->pNext = pCache->pFree;
       pCache->pFree = pX;
       zBulk += pCache->szAlloc;
@@ -40846,7 +41514,7 @@ static int pcache1MemSize(void *p){
 /*
 ** Allocate a new page object initially associated with cache pCache.
 */
-static PgHdr1 *pcache1AllocPage(PCache1 *pCache){
+static PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){
   PgHdr1 *p = 0;
   void *pPg;
 
@@ -40864,6 +41532,7 @@ static PgHdr1 *pcache1AllocPage(PCache1 *pCache){
     assert( pCache->pGroup==&pcache1.grp );
     pcache1LeaveMutex(pCache->pGroup);
 #endif
+    if( benignMalloc ){ sqlite3BeginBenignMalloc(); }
 #ifdef SQLITE_PCACHE_SEPARATE_HEADER
     pPg = pcache1Alloc(pCache->szPage);
     p = sqlite3Malloc(sizeof(PgHdr1) + pCache->szExtra);
@@ -40876,6 +41545,7 @@ static PgHdr1 *pcache1AllocPage(PCache1 *pCache){
     pPg = pcache1Alloc(pCache->szAlloc);
     p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];
 #endif
+    if( benignMalloc ){ sqlite3EndBenignMalloc(); }
 #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
     pcache1EnterMutex(pCache->pGroup);
 #endif
@@ -40883,6 +41553,7 @@ static PgHdr1 *pcache1AllocPage(PCache1 *pCache){
     p->page.pBuf = pPg;
     p->page.pExtra = &p[1];
     p->isBulkLocal = 0;
+    p->isAnchor = 0;
   }
   if( pCache->bPurgeable ){
     pCache->pGroup->nCurrentPage++;
@@ -41009,22 +41680,16 @@ static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){
   assert( pPage!=0 );
   assert( pPage->isPinned==0 );
   pCache = pPage->pCache;
-  assert( pPage->pLruNext || pPage==pCache->pGroup->pLruTail );
-  assert( pPage->pLruPrev || pPage==pCache->pGroup->pLruHead );
+  assert( pPage->pLruNext );
+  assert( pPage->pLruPrev );
   assert( sqlite3_mutex_held(pCache->pGroup->mutex) );
-  if( pPage->pLruPrev ){
-    pPage->pLruPrev->pLruNext = pPage->pLruNext;
-  }else{
-    pCache->pGroup->pLruHead = pPage->pLruNext;
-  }
-  if( pPage->pLruNext ){
-    pPage->pLruNext->pLruPrev = pPage->pLruPrev;
-  }else{
-    pCache->pGroup->pLruTail = pPage->pLruPrev;
-  }
+  pPage->pLruPrev->pLruNext = pPage->pLruNext;
+  pPage->pLruNext->pLruPrev = pPage->pLruPrev;
   pPage->pLruNext = 0;
   pPage->pLruPrev = 0;
   pPage->isPinned = 1;
+  assert( pPage->isAnchor==0 );
+  assert( pCache->pGroup->lru.isAnchor==1 );
   pCache->nRecyclable--;
   return pPage;
 }
@@ -41057,9 +41722,11 @@ static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){
 */
 static void pcache1EnforceMaxPage(PCache1 *pCache){
   PGroup *pGroup = pCache->pGroup;
+  PgHdr1 *p;
   assert( sqlite3_mutex_held(pGroup->mutex) );
-  while( pGroup->nCurrentPage>pGroup->nMaxPage && pGroup->pLruTail ){
-    PgHdr1 *p = pGroup->pLruTail;
+  while( pGroup->nCurrentPage>pGroup->nMaxPage
+      && (p=pGroup->lru.pLruPrev)->isAnchor==0
+  ){
     assert( p->pCache->pGroup==pGroup );
     assert( p->isPinned==0 );
     pcache1PinPage(p);
@@ -41193,6 +41860,10 @@ static sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){
     }else{
       pGroup = &pcache1.grp;
     }
+    if( pGroup->lru.isAnchor==0 ){
+      pGroup->lru.isAnchor = 1;
+      pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;
+    }
     pCache->pGroup = pGroup;
     pCache->szPage = szPage;
     pCache->szExtra = szExtra;
@@ -41300,11 +41971,11 @@ static SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2(
 
   /* Step 4. Try to recycle a page. */
   if( pCache->bPurgeable
-   && pGroup->pLruTail
+   && !pGroup->lru.pLruPrev->isAnchor
    && ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))
   ){
     PCache1 *pOther;
-    pPage = pGroup->pLruTail;
+    pPage = pGroup->lru.pLruPrev;
     assert( pPage->isPinned==0 );
     pcache1RemoveFromHash(pPage, 0);
     pcache1PinPage(pPage);
@@ -41321,9 +41992,7 @@ static SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2(
   ** attempt to allocate a new one. 
   */
   if( !pPage ){
-    if( createFlag==1 ){ sqlite3BeginBenignMalloc(); }
-    pPage = pcache1AllocPage(pCache);
-    if( createFlag==1 ){ sqlite3EndBenignMalloc(); }
+    pPage = pcache1AllocPage(pCache, createFlag==1);
   }
 
   if( pPage ){
@@ -41415,7 +42084,10 @@ static PgHdr1 *pcache1FetchNoMutex(
   pPage = pCache->apHash[iKey % pCache->nHash];
   while( pPage && pPage->iKey!=iKey ){ pPage = pPage->pNext; }
 
-  /* Step 2: Abort if no existing page is found and createFlag is 0 */
+  /* Step 2: If the page was found in the hash table, then return it.
+  ** If the page was not in the hash table and createFlag is 0, abort.
+  ** Otherwise (page not in hash and createFlag!=0) continue with
+  ** subsequent steps to try to create the page. */
   if( pPage ){
     if( !pPage->isPinned ){
       return pcache1PinPage(pPage);
@@ -41492,21 +42164,16 @@ static void pcache1Unpin(
   ** part of the PGroup LRU list.
   */
   assert( pPage->pLruPrev==0 && pPage->pLruNext==0 );
-  assert( pGroup->pLruHead!=pPage && pGroup->pLruTail!=pPage );
   assert( pPage->isPinned==1 );
 
   if( reuseUnlikely || pGroup->nCurrentPage>pGroup->nMaxPage ){
     pcache1RemoveFromHash(pPage, 1);
   }else{
     /* Add the page to the PGroup LRU list. */
-    if( pGroup->pLruHead ){
-      pGroup->pLruHead->pLruPrev = pPage;
-      pPage->pLruNext = pGroup->pLruHead;
-      pGroup->pLruHead = pPage;
-    }else{
-      pGroup->pLruTail = pPage;
-      pGroup->pLruHead = pPage;
-    }
+    PgHdr1 **ppFirst = &pGroup->lru.pLruNext;
+    pPage->pLruPrev = &pGroup->lru;
+    (pPage->pLruNext = *ppFirst)->pLruPrev = pPage;
+    *ppFirst = pPage;
     pCache->nRecyclable++;
     pPage->isPinned = 0;
   }
@@ -41644,7 +42311,10 @@ SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int nReq){
   if( sqlite3GlobalConfig.nPage==0 ){
     PgHdr1 *p;
     pcache1EnterMutex(&pcache1.grp);
-    while( (nReq<0 || nFree<nReq) && ((p=pcache1.grp.pLruTail)!=0) ){
+    while( (nReq<0 || nFree<nReq)
+       &&  (p=pcache1.grp.lru.pLruPrev)!=0
+       &&  p->isAnchor==0
+    ){
       nFree += pcache1MemSize(p->page.pBuf);
 #ifdef SQLITE_PCACHE_SEPARATE_HEADER
       nFree += sqlite3MemSize(p);
@@ -41672,7 +42342,7 @@ SQLITE_PRIVATE void sqlite3PcacheStats(
 ){
   PgHdr1 *p;
   int nRecyclable = 0;
-  for(p=pcache1.grp.pLruHead; p; p=p->pLruNext){
+  for(p=pcache1.grp.lru.pLruNext; p && !p->isAnchor; p=p->pLruNext){
     assert( p->isPinned==0 );
     nRecyclable++;
   }
@@ -42986,7 +43656,7 @@ struct Pager {
   u8 doNotSpill;              /* Do not spill the cache when non-zero */
   u8 subjInMemory;            /* True to use in-memory sub-journals */
   u8 bUseFetch;               /* True to use xFetch() */
-  u8 hasBeenUsed;             /* True if any content previously read */
+  u8 hasHeldSharedLock;       /* True if a shared lock has ever been held */
   Pgno dbSize;                /* Number of pages in the database */
   Pgno dbOrigSize;            /* dbSize before the current transaction */
   Pgno dbFileSize;            /* Number of pages in the database file */
@@ -44455,6 +45125,20 @@ static void pagerReportSize(Pager *pPager){
 # define pagerReportSize(X)     /* No-op if we do not support a codec */
 #endif
 
+#ifdef SQLITE_HAS_CODEC
+/*
+** Make sure the number of reserved bits is the same in the destination
+** pager as it is in the source.  This comes up when a VACUUM changes the
+** number of reserved bits to the "optimal" amount.
+*/
+SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager *pDest, Pager *pSrc){
+  if( pDest->nReserve!=pSrc->nReserve ){
+    pDest->nReserve = pSrc->nReserve;
+    pagerReportSize(pDest);
+  }
+}
+#endif
+
 /*
 ** Read a single page from either the journal file (if isMainJrnl==1) or
 ** from the sub-journal (if isMainJrnl==0) and playback that page.
@@ -47436,10 +48120,10 @@ SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager){
       );
     }
 
-    if( !pPager->tempFile && pPager->hasBeenUsed ){
+    if( !pPager->tempFile && pPager->hasHeldSharedLock ){
       /* The shared-lock has just been acquired then check to
       ** see if the database has been modified.  If the database has changed,
-      ** flush the cache.  The pPager->hasBeenUsed flag prevents this from
+      ** flush the cache.  The hasHeldSharedLock flag prevents this from
       ** occurring on the very first access to a file, in order to save a
       ** single unnecessary sqlite3OsRead() call at the start-up.
       **
@@ -47509,6 +48193,7 @@ SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager){
     assert( pPager->eState==PAGER_OPEN );
   }else{
     pPager->eState = PAGER_READER;
+    pPager->hasHeldSharedLock = 1;
   }
   return rc;
 }
@@ -47592,21 +48277,25 @@ SQLITE_PRIVATE int sqlite3PagerAcquire(
   ** page 1 if there is no write-transaction open or the ACQUIRE_READONLY
   ** flag was specified by the caller. And so long as the db is not a 
   ** temporary or in-memory database.  */
-  const int bMmapOk = (pgno!=1 && USEFETCH(pPager)
+  const int bMmapOk = (pgno>1 && USEFETCH(pPager)
    && (pPager->eState==PAGER_READER || (flags & PAGER_GET_READONLY))
 #ifdef SQLITE_HAS_CODEC
    && pPager->xCodec==0
 #endif
   );
 
+  /* Optimization note:  Adding the "pgno<=1" term before "pgno==0" here
+  ** allows the compiler optimizer to reuse the results of the "pgno>1"
+  ** test in the previous statement, and avoid testing pgno==0 in the
+  ** common case where pgno is large. */
+  if( pgno<=1 && pgno==0 ){
+    return SQLITE_CORRUPT_BKPT;
+  }
   assert( pPager->eState>=PAGER_READER );
   assert( assert_pager_state(pPager) );
   assert( noContent==0 || bMmapOk==0 );
 
-  if( pgno==0 ){
-    return SQLITE_CORRUPT_BKPT;
-  }
-  pPager->hasBeenUsed = 1;
+  assert( pPager->hasHeldSharedLock==1 );
 
   /* If the pager is in the error state, return an error immediately. 
   ** Otherwise, request the page from the PCache layer. */
@@ -47761,7 +48450,7 @@ SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){
   assert( pgno!=0 );
   assert( pPager->pPCache!=0 );
   pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);
-  assert( pPage==0 || pPager->hasBeenUsed );
+  assert( pPage==0 || pPager->hasHeldSharedLock );
   if( pPage==0 ) return 0;
   return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);
 }
@@ -48728,7 +49417,7 @@ SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager *pPager){
 
 #ifdef SQLITE_DEBUG
 /*
-** Return the number of references to the pager.
+** Return the sum of the reference counts for all pages held by pPager.
 */
 SQLITE_PRIVATE int sqlite3PagerRefcount(Pager *pPager){
   return sqlite3PcacheRefCount(pPager->pPCache);
@@ -50040,6 +50729,7 @@ struct Wal {
   u8 syncHeader;             /* Fsync the WAL header if true */
   u8 padToSectorBoundary;    /* Pad transactions out to the next sector */
   WalIndexHdr hdr;           /* Wal-index header for current transaction */
+  u32 minFrame;              /* Ignore wal frames before this one */
   const char *zWalName;      /* Name of WAL file */
   u32 nCkpt;                 /* Checkpoint sequence counter in the wal-header */
 #ifdef SQLITE_DEBUG
@@ -51908,12 +52598,27 @@ static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){
     ** pWal->hdr.mxFrame risks reading a corrupted snapshot. So, retry
     ** instead.
     **
-    ** This does not guarantee that the copy of the wal-index header is up to
-    ** date before proceeding. That would not be possible without somehow
-    ** blocking writers. It only guarantees that a dangerous checkpoint or 
-    ** log-wrap (either of which would require an exclusive lock on
-    ** WAL_READ_LOCK(mxI)) has not occurred since the snapshot was valid.
+    ** Before checking that the live wal-index header has not changed
+    ** since it was read, set Wal.minFrame to the first frame in the wal
+    ** file that has not yet been checkpointed. This client will not need
+    ** to read any frames earlier than minFrame from the wal file - they
+    ** can be safely read directly from the database file.
+    **
+    ** Because a ShmBarrier() call is made between taking the copy of 
+    ** nBackfill and checking that the wal-header in shared-memory still
+    ** matches the one cached in pWal->hdr, it is guaranteed that the 
+    ** checkpointer that set nBackfill was not working with a wal-index
+    ** header newer than that cached in pWal->hdr. If it were, that could
+    ** cause a problem. The checkpointer could omit to checkpoint
+    ** a version of page X that lies before pWal->minFrame (call that version
+    ** A) on the basis that there is a newer version (version B) of the same
+    ** page later in the wal file. But if version B happens to like past
+    ** frame pWal->hdr.mxFrame - then the client would incorrectly assume
+    ** that it can read version A from the database file. However, since
+    ** we can guarantee that the checkpointer that set nBackfill could not
+    ** see any pages past pWal->hdr.mxFrame, this problem does not come up.
     */
+    pWal->minFrame = pInfo->nBackfill+1;
     walShmBarrier(pWal);
     if( pInfo->aReadMark[mxI]!=mxReadMark
      || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))
@@ -51984,6 +52689,7 @@ SQLITE_PRIVATE int sqlite3WalFindFrame(
   u32 iRead = 0;                  /* If !=0, WAL frame to return data from */
   u32 iLast = pWal->hdr.mxFrame;  /* Last page in WAL for this reader */
   int iHash;                      /* Used to loop through N hash tables */
+  int iMinHash;
 
   /* This routine is only be called from within a read transaction. */
   assert( pWal->readLock>=0 || pWal->lockError );
@@ -52024,7 +52730,8 @@ SQLITE_PRIVATE int sqlite3WalFindFrame(
   **     This condition filters out entries that were added to the hash
   **     table after the current read-transaction had started.
   */
-  for(iHash=walFramePage(iLast); iHash>=0 && iRead==0; iHash--){
+  iMinHash = walFramePage(pWal->minFrame);
+  for(iHash=walFramePage(iLast); iHash>=iMinHash && iRead==0; iHash--){
     volatile ht_slot *aHash;      /* Pointer to hash table */
     volatile u32 *aPgno;          /* Pointer to array of page numbers */
     u32 iZero;                    /* Frame number corresponding to aPgno[0] */
@@ -52039,7 +52746,7 @@ SQLITE_PRIVATE int sqlite3WalFindFrame(
     nCollide = HASHTABLE_NSLOT;
     for(iKey=walHash(pgno); aHash[iKey]; iKey=walNextHash(iKey)){
       u32 iFrame = aHash[iKey] + iZero;
-      if( iFrame<=iLast && aPgno[aHash[iKey]]==pgno ){
+      if( iFrame<=iLast && iFrame>=pWal->minFrame && aPgno[aHash[iKey]]==pgno ){
         assert( iFrame>iRead || CORRUPT_DB );
         iRead = iFrame;
       }
@@ -52056,7 +52763,8 @@ SQLITE_PRIVATE int sqlite3WalFindFrame(
   {
     u32 iRead2 = 0;
     u32 iTest;
-    for(iTest=iLast; iTest>0; iTest--){
+    assert( pWal->minFrame>0 );
+    for(iTest=iLast; iTest>=pWal->minFrame; iTest--){
       if( walFramePgno(pWal, iTest)==pgno ){
         iRead2 = iTest;
         break;
@@ -53496,9 +54204,11 @@ struct IntegrityCk {
 */
 #if SQLITE_BYTEORDER==4321
 # define get2byteAligned(x)  (*(u16*)(x))
-#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4008000
+#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
+    && GCC_VERSION>=4008000
 # define get2byteAligned(x)  __builtin_bswap16(*(u16*)(x))
-#elif SQLITE_BYTEORDER==1234 && defined(_MSC_VER) && _MSC_VER>=1300
+#elif SQLITE_BYTEORDER==1234 && !defined(SQLITE_DISABLE_INTRINSIC) \
+    && defined(_MSC_VER) && _MSC_VER>=1300
 # define get2byteAligned(x)  _byteswap_ushort(*(u16*)(x))
 #else
 # define get2byteAligned(x)  ((x)[0]<<8 | (x)[1])
@@ -54385,26 +55095,25 @@ static void btreeReleaseAllCursorPages(BtCursor *pCur){
   pCur->iPage = -1;
 }
 
-
 /*
-** Save the current cursor position in the variables BtCursor.nKey 
-** and BtCursor.pKey. The cursor's state is set to CURSOR_REQUIRESEEK.
+** The cursor passed as the only argument must point to a valid entry
+** when this function is called (i.e. have eState==CURSOR_VALID). This
+** function saves the current cursor key in variables pCur->nKey and
+** pCur->pKey. SQLITE_OK is returned if successful or an SQLite error 
+** code otherwise.
 **
-** The caller must ensure that the cursor is valid (has eState==CURSOR_VALID)
-** prior to calling this routine.  
+** If the cursor is open on an intkey table, then the integer key
+** (the rowid) is stored in pCur->nKey and pCur->pKey is left set to
+** NULL. If the cursor is open on a non-intkey table, then pCur->pKey is 
+** set to point to a malloced buffer pCur->nKey bytes in size containing 
+** the key.
 */
-static int saveCursorPosition(BtCursor *pCur){
+static int saveCursorKey(BtCursor *pCur){
   int rc;
-
-  assert( CURSOR_VALID==pCur->eState || CURSOR_SKIPNEXT==pCur->eState );
+  assert( CURSOR_VALID==pCur->eState );
   assert( 0==pCur->pKey );
   assert( cursorHoldsMutex(pCur) );
 
-  if( pCur->eState==CURSOR_SKIPNEXT ){
-    pCur->eState = CURSOR_VALID;
-  }else{
-    pCur->skipNext = 0;
-  }
   rc = sqlite3BtreeKeySize(pCur, &pCur->nKey);
   assert( rc==SQLITE_OK );  /* KeySize() cannot fail */
 
@@ -54412,8 +55121,7 @@ static int saveCursorPosition(BtCursor *pCur){
   ** stores the integer key in pCur->nKey. In this case this value is
   ** all that is required. Otherwise, if pCur is not open on an intKey
   ** table, then malloc space for and store the pCur->nKey bytes of key 
-  ** data.
-  */
+  ** data.  */
   if( 0==pCur->curIntKey ){
     void *pKey = sqlite3Malloc( pCur->nKey );
     if( pKey ){
@@ -54428,13 +55136,36 @@ static int saveCursorPosition(BtCursor *pCur){
     }
   }
   assert( !pCur->curIntKey || !pCur->pKey );
+  return rc;
+}
 
+/*
+** Save the current cursor position in the variables BtCursor.nKey 
+** and BtCursor.pKey. The cursor's state is set to CURSOR_REQUIRESEEK.
+**
+** The caller must ensure that the cursor is valid (has eState==CURSOR_VALID)
+** prior to calling this routine.  
+*/
+static int saveCursorPosition(BtCursor *pCur){
+  int rc;
+
+  assert( CURSOR_VALID==pCur->eState || CURSOR_SKIPNEXT==pCur->eState );
+  assert( 0==pCur->pKey );
+  assert( cursorHoldsMutex(pCur) );
+
+  if( pCur->eState==CURSOR_SKIPNEXT ){
+    pCur->eState = CURSOR_VALID;
+  }else{
+    pCur->skipNext = 0;
+  }
+
+  rc = saveCursorKey(pCur);
   if( rc==SQLITE_OK ){
     btreeReleaseAllCursorPages(pCur);
     pCur->eState = CURSOR_REQUIRESEEK;
   }
 
-  invalidateOverflowCache(pCur);
+  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl|BTCF_AtLast);
   return rc;
 }
 
@@ -60272,7 +61003,13 @@ static int pageInsertArray(
       if( pData<pBegin ) return 1;
       pSlot = pData;
     }
-    memcpy(pSlot, pCArray->apCell[i], sz);
+    /* pSlot and pCArray->apCell[i] will never overlap on a well-formed
+    ** database.  But they might for a corrupt database.  Hence use memmove()
+    ** since memcpy() sends SIGABORT with overlapping buffers on OpenBSD */
+    assert( (pSlot+sz)<=pCArray->apCell[i]
+         || pSlot>=(pCArray->apCell[i]+sz)
+         || CORRUPT_DB );
+    memmove(pSlot, pCArray->apCell[i], sz);
     put2byte(pCellptr, (pSlot - aData));
     pCellptr += 2;
   }
@@ -61397,7 +62134,7 @@ static int balance_nonroot(
     ** by smaller than the child due to the database header, and so all the
     ** free space needs to be up front.
     */
-    assert( nNew==1 );
+    assert( nNew==1 || CORRUPT_DB );
     rc = defragmentPage(apNew[0]);
     testcase( rc!=SQLITE_OK );
     assert( apNew[0]->nFree == 
@@ -61820,10 +62557,15 @@ SQLITE_PRIVATE int sqlite3BtreeInsert(
 }
 
 /*
-** Delete the entry that the cursor is pointing to.  The cursor
-** is left pointing at an arbitrary location.
+** Delete the entry that the cursor is pointing to. 
+**
+** If the second parameter is zero, then the cursor is left pointing at an
+** arbitrary location after the delete. If it is non-zero, then the cursor 
+** is left in a state such that the next call to BtreeNext() or BtreePrev()
+** moves it to the same row as it would if the call to BtreeDelete() had
+** been omitted.
 */
-SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur){
+SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur, int bPreserve){
   Btree *p = pCur->pBtree;
   BtShared *pBt = p->pBt;              
   int rc;                              /* Return code */
@@ -61832,6 +62574,7 @@ SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur){
   int iCellIdx;                        /* Index of cell to delete */
   int iCellDepth;                      /* Depth of node containing pCell */ 
   u16 szCell;                          /* Size of the cell being deleted */
+  int bSkipnext = 0;                   /* Leaf cursor in SKIPNEXT state */
 
   assert( cursorHoldsMutex(pCur) );
   assert( pBt->inTransaction==TRANS_WRITE );
@@ -61861,10 +62604,7 @@ SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur){
   }
 
   /* Save the positions of any other cursors open on this table before
-  ** making any modifications. Make the page containing the entry to be 
-  ** deleted writable. Then free any overflow pages associated with the 
-  ** entry and finally remove the cell itself from within the page.  
-  */
+  ** making any modifications.  */
   if( pCur->curFlags & BTCF_Multiple ){
     rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
     if( rc ) return rc;
@@ -61876,6 +62616,31 @@ SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur){
     invalidateIncrblobCursors(p, pCur->info.nKey, 0);
   }
 
+  /* If the bPreserve flag is set to true, then the cursor position must
+  ** be preserved following this delete operation. If the current delete
+  ** will cause a b-tree rebalance, then this is done by saving the cursor
+  ** key and leaving the cursor in CURSOR_REQUIRESEEK state before 
+  ** returning. 
+  **
+  ** Or, if the current delete will not cause a rebalance, then the cursor
+  ** will be left in CURSOR_SKIPNEXT state pointing to the entry immediately
+  ** before or after the deleted entry. In this case set bSkipnext to true.  */
+  if( bPreserve ){
+    if( !pPage->leaf 
+     || (pPage->nFree+cellSizePtr(pPage,pCell)+2)>(int)(pBt->usableSize*2/3)
+    ){
+      /* A b-tree rebalance will be required after deleting this entry.
+      ** Save the cursor key.  */
+      rc = saveCursorKey(pCur);
+      if( rc ) return rc;
+    }else{
+      bSkipnext = 1;
+    }
+  }
+
+  /* Make the page containing the entry to be deleted writable. Then free any
+  ** overflow pages associated with the entry and finally remove the cell
+  ** itself from within the page.  */
   rc = sqlite3PagerWrite(pPage->pDbPage);
   if( rc ) return rc;
   rc = clearCell(pPage, pCell, &szCell);
@@ -61929,7 +62694,23 @@ SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur){
   }
 
   if( rc==SQLITE_OK ){
-    moveToRoot(pCur);
+    if( bSkipnext ){
+      assert( bPreserve && pCur->iPage==iCellDepth );
+      assert( pPage==pCur->apPage[pCur->iPage] );
+      assert( (pPage->nCell>0 || CORRUPT_DB) && iCellIdx<=pPage->nCell );
+      pCur->eState = CURSOR_SKIPNEXT;
+      if( iCellIdx>=pPage->nCell ){
+        pCur->skipNext = -1;
+        pCur->aiIdx[iCellDepth] = pPage->nCell-1;
+      }else{
+        pCur->skipNext = 1;
+      }
+    }else{
+      rc = moveToRoot(pCur);
+      if( bPreserve ){
+        pCur->eState = CURSOR_REQUIRESEEK;
+      }
+    }
   }
   return rc;
 }
@@ -62494,7 +63275,6 @@ static void checkAppendMsg(
   ...
 ){
   va_list ap;
-  char zBuf[200];
   if( !pCheck->mxErr ) return;
   pCheck->mxErr--;
   pCheck->nErr++;
@@ -62503,8 +63283,7 @@ static void checkAppendMsg(
     sqlite3StrAccumAppend(&pCheck->errMsg, "\n", 1);
   }
   if( pCheck->zPfx ){
-    sqlite3_snprintf(sizeof(zBuf), zBuf, pCheck->zPfx, pCheck->v1, pCheck->v2);
-    sqlite3StrAccumAppendAll(&pCheck->errMsg, zBuf);
+    sqlite3XPrintf(&pCheck->errMsg, 0, pCheck->zPfx, pCheck->v1, pCheck->v2);
   }
   sqlite3VXPrintf(&pCheck->errMsg, 1, zFormat, ap);
   va_end(ap);
@@ -62653,6 +63432,10 @@ static void checkList(
 #endif
     iPage = get4byte(pOvflData);
     sqlite3PagerUnref(pOvflPage);
+
+    if( isFreeList && N<(iPage!=0) ){
+      checkAppendMsg(pCheck, "free-page count in header is too small");
+    }
   }
 }
 #endif /* SQLITE_OMIT_INTEGRITY_CHECK */
@@ -64146,6 +64929,10 @@ SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){
   b.pDest = pTo;
   b.iNext = 1;
 
+#ifdef SQLITE_HAS_CODEC
+  sqlite3PagerAlignReserve(sqlite3BtreePager(pTo), sqlite3BtreePager(pFrom));
+#endif
+
   /* 0x7FFFFFFF is the hard limit for the number of pages in a database
   ** file. By passing this as the number of pages to copy to
   ** sqlite3_backup_step(), we can guarantee that the copy finishes 
@@ -65329,7 +66116,7 @@ static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
 ** to be a scalar SQL function. If
 **
 **   * all function arguments are SQL literals,
-**   * the SQLITE_FUNC_CONSTANT function flag is set, and
+**   * one of the SQLITE_FUNC_CONSTANT or _SLOCHNG function flags is set, and
 **   * the SQLITE_FUNC_NEEDCOLL function flag is not set,
 **
 ** then this routine attempts to invoke the SQL function. Assuming no
@@ -65370,7 +66157,7 @@ static int valueFromFunction(
   nName = sqlite3Strlen30(p->u.zToken);
   pFunc = sqlite3FindFunction(db, p->u.zToken, nName, nVal, enc, 0);
   assert( pFunc );
-  if( (pFunc->funcFlags & SQLITE_FUNC_CONSTANT)==0 
+  if( (pFunc->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG))==0 
    || (pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)
   ){
     return SQLITE_OK;
@@ -65964,7 +66751,7 @@ SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, int isPrepa
 */
 SQLITE_API const char *SQLITE_STDCALL sqlite3_sql(sqlite3_stmt *pStmt){
   Vdbe *p = (Vdbe *)pStmt;
-  return (p && p->isPrepareV2) ? p->zSql : 0;
+  return p ? p->zSql : 0;
 }
 
 /*
@@ -66111,6 +66898,44 @@ SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){
   return sqlite3VdbeAddOp3(p, op, p1, p2, 0);
 }
 
+/* Generate code for an unconditional jump to instruction iDest
+*/
+SQLITE_PRIVATE int sqlite3VdbeGoto(Vdbe *p, int iDest){
+  return sqlite3VdbeAddOp3(p, OP_Goto, 0, iDest, 0);
+}
+
+/* Generate code to cause the string zStr to be loaded into
+** register iDest
+*/
+SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){
+  return sqlite3VdbeAddOp4(p, OP_String8, 0, iDest, 0, zStr, 0);
+}
+
+/*
+** Generate code that initializes multiple registers to string or integer
+** constants.  The registers begin with iDest and increase consecutively.
+** One register is initialized for each characgter in zTypes[].  For each
+** "s" character in zTypes[], the register is a string if the argument is
+** not NULL, or OP_Null if the value is a null pointer.  For each "i" character
+** in zTypes[], the register is initialized to an integer.
+*/
+SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){
+  va_list ap;
+  int i;
+  char c;
+  va_start(ap, zTypes);
+  for(i=0; (c = zTypes[i])!=0; i++){
+    if( c=='s' ){
+      const char *z = va_arg(ap, const char*);
+      int addr = sqlite3VdbeAddOp2(p, z==0 ? OP_Null : OP_String8, 0, iDest++);
+      if( z ) sqlite3VdbeChangeP4(p, addr, z, 0);
+    }else{
+      assert( c=='i' );
+      sqlite3VdbeAddOp2(p, OP_Integer, va_arg(ap, int), iDest++);
+    }
+  }
+  va_end(ap);
+}
 
 /*
 ** Add an opcode that includes the p4 value as a pointer.
@@ -66130,7 +66955,8 @@ SQLITE_PRIVATE int sqlite3VdbeAddOp4(
 }
 
 /*
-** Add an opcode that includes the p4 value with a P4_INT64 type.
+** Add an opcode that includes the p4 value with a P4_INT64 or
+** P4_REAL type.
 */
 SQLITE_PRIVATE int sqlite3VdbeAddOp4Dup8(
   Vdbe *p,            /* Add the opcode to this VM */
@@ -66215,7 +67041,8 @@ SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe *v, int x){
   int j = -1-x;
   assert( v->magic==VDBE_MAGIC_INIT );
   assert( j<p->nLabel );
-  if( ALWAYS(j>=0) && p->aLabel ){
+  assert( j>=0 );
+  if( p->aLabel ){
     p->aLabel[j] = v->nOp;
   }
   p->iFixedOp = v->nOp - 1;
@@ -66359,17 +67186,21 @@ SQLITE_PRIVATE int sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){
 #endif /* SQLITE_DEBUG - the sqlite3AssertMayAbort() function */
 
 /*
-** Loop through the program looking for P2 values that are negative
-** on jump instructions.  Each such value is a label.  Resolve the
-** label by setting the P2 value to its correct non-zero value.
+** This routine is called after all opcodes have been inserted.  It loops
+** through all the opcodes and fixes up some details.
 **
-** This routine is called once after all opcodes have been inserted.
+** (1) For each jump instruction with a negative P2 value (a label)
+**     resolve the P2 value to an actual address.
 **
-** Variable *pMaxFuncArgs is set to the maximum value of any P2 argument 
-** to an OP_Function, OP_AggStep or OP_VFilter opcode. This is used by 
-** sqlite3VdbeMakeReady() to size the Vdbe.apArg[] array.
+** (2) Compute the maximum number of arguments used by any SQL function
+**     and store that value in *pMaxFuncArgs.
 **
-** The Op.opflags field is set on all opcodes.
+** (3) Update the Vdbe.readOnly and Vdbe.bIsReader flags to accurately
+**     indicate what the prepared statement actually does.
+**
+** (4) Initialize the p4.xAdvance pointer on opcodes that use it.
+**
+** (5) Reclaim the memory allocated for storing labels.
 */
 static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){
   int i;
@@ -66482,46 +67313,44 @@ SQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg)
 ** address of the first operation added.
 */
 SQLITE_PRIVATE int sqlite3VdbeAddOpList(Vdbe *p, int nOp, VdbeOpList const *aOp, int iLineno){
-  int addr;
+  int addr, i;
+  VdbeOp *pOut;
+  assert( nOp>0 );
   assert( p->magic==VDBE_MAGIC_INIT );
   if( p->nOp + nOp > p->pParse->nOpAlloc && growOpArray(p, nOp) ){
     return 0;
   }
   addr = p->nOp;
-  if( ALWAYS(nOp>0) ){
-    int i;
-    VdbeOpList const *pIn = aOp;
-    for(i=0; i<nOp; i++, pIn++){
-      int p2 = pIn->p2;
-      VdbeOp *pOut = &p->aOp[i+addr];
-      pOut->opcode = pIn->opcode;
-      pOut->p1 = pIn->p1;
-      if( p2<0 ){
-        assert( sqlite3OpcodeProperty[pOut->opcode] & OPFLG_JUMP );
-        pOut->p2 = addr + ADDR(p2);
-      }else{
-        pOut->p2 = p2;
-      }
-      pOut->p3 = pIn->p3;
-      pOut->p4type = P4_NOTUSED;
-      pOut->p4.p = 0;
-      pOut->p5 = 0;
+  pOut = &p->aOp[addr];
+  for(i=0; i<nOp; i++, aOp++, pOut++){
+    int p2 = aOp->p2;
+    pOut->opcode = aOp->opcode;
+    pOut->p1 = aOp->p1;
+    if( p2<0 ){
+      assert( sqlite3OpcodeProperty[pOut->opcode] & OPFLG_JUMP );
+      pOut->p2 = addr + ADDR(p2);
+    }else{
+      pOut->p2 = p2;
+    }
+    pOut->p3 = aOp->p3;
+    pOut->p4type = P4_NOTUSED;
+    pOut->p4.p = 0;
+    pOut->p5 = 0;
 #ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
-      pOut->zComment = 0;
+    pOut->zComment = 0;
 #endif
 #ifdef SQLITE_VDBE_COVERAGE
-      pOut->iSrcLine = iLineno+i;
+    pOut->iSrcLine = iLineno+i;
 #else
-      (void)iLineno;
+    (void)iLineno;
 #endif
 #ifdef SQLITE_DEBUG
-      if( p->db->flags & SQLITE_VdbeAddopTrace ){
-        sqlite3VdbePrintOp(0, i+addr, &p->aOp[i+addr]);
-      }
-#endif
+    if( p->db->flags & SQLITE_VdbeAddopTrace ){
+      sqlite3VdbePrintOp(0, i+addr, &p->aOp[i+addr]);
     }
-    p->nOp += nOp;
+#endif
   }
+  p->nOp += nOp;
   return addr;
 }
 
@@ -66554,49 +67383,23 @@ SQLITE_PRIVATE void sqlite3VdbeScanStatus(
 
 
 /*
-** Change the value of the P1 operand for a specific instruction.
-** This routine is useful when a large program is loaded from a
-** static array using sqlite3VdbeAddOpList but we want to make a
-** few minor changes to the program.
+** Change the value of the opcode, or P1, P2, P3, or P5 operands
+** for a specific instruction.
 */
+SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe *p, u32 addr, u8 iNewOpcode){
+  sqlite3VdbeGetOp(p,addr)->opcode = iNewOpcode;
+}
 SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe *p, u32 addr, int val){
-  assert( p!=0 );
-  if( ((u32)p->nOp)>addr ){
-    p->aOp[addr].p1 = val;
-  }
+  sqlite3VdbeGetOp(p,addr)->p1 = val;
 }
-
-/*
-** Change the value of the P2 operand for a specific instruction.
-** This routine is useful for setting a jump destination.
-*/
 SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe *p, u32 addr, int val){
-  assert( p!=0 );
-  if( ((u32)p->nOp)>addr ){
-    p->aOp[addr].p2 = val;
-  }
+  sqlite3VdbeGetOp(p,addr)->p2 = val;
 }
-
-/*
-** Change the value of the P3 operand for a specific instruction.
-*/
 SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe *p, u32 addr, int val){
-  assert( p!=0 );
-  if( ((u32)p->nOp)>addr ){
-    p->aOp[addr].p3 = val;
-  }
+  sqlite3VdbeGetOp(p,addr)->p3 = val;
 }
-
-/*
-** Change the value of the P5 operand for the most recently
-** added operation.
-*/
-SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe *p, u8 val){
-  assert( p!=0 );
-  if( p->aOp ){
-    assert( p->nOp>0 );
-    p->aOp[p->nOp-1].p5 = val;
-  }
+SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe *p, u8 p5){
+  sqlite3VdbeGetOp(p,-1)->p5 = p5;
 }
 
 /*
@@ -66604,8 +67407,8 @@ SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe *p, u8 val){
 ** the address of the next instruction to be coded.
 */
 SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe *p, int addr){
-  sqlite3VdbeChangeP2(p, addr, p->nOp);
   p->pParse->iFixedOp = p->nOp - 1;
+  sqlite3VdbeChangeP2(p, addr, p->nOp);
 }
 
 
@@ -66990,8 +67793,9 @@ static char *displayP4(Op *pOp, char *zTemp, int nTemp){
           zColl = "B";
           n = 1;
         }
-        if( i+n>nTemp-6 ){
+        if( i+n>nTemp-7 ){
           memcpy(&zTemp[i],",...",4);
+          i += 4;
           break;
         }
         zTemp[i++] = ',';
@@ -70332,6 +71136,9 @@ SQLITE_API int SQLITE_STDCALL sqlite3_value_int(sqlite3_value *pVal){
 SQLITE_API sqlite_int64 SQLITE_STDCALL sqlite3_value_int64(sqlite3_value *pVal){
   return sqlite3VdbeIntValue((Mem*)pVal);
 }
+SQLITE_API unsigned int SQLITE_STDCALL sqlite3_value_subtype(sqlite3_value *pVal){
+  return ((Mem*)pVal)->eSubtype;
+}
 SQLITE_API const unsigned char *SQLITE_STDCALL sqlite3_value_text(sqlite3_value *pVal){
   return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);
 }
@@ -70510,6 +71317,10 @@ SQLITE_API void SQLITE_STDCALL sqlite3_result_null(sqlite3_context *pCtx){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetNull(pCtx->pOut);
 }
+SQLITE_API void SQLITE_STDCALL sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){
+  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
+  pCtx->pOut->eSubtype = eSubtype & 0xff;
+}
 SQLITE_API void SQLITE_STDCALL sqlite3_result_text(
   sqlite3_context *pCtx, 
   const char *z, 
@@ -70756,7 +71567,7 @@ static int sqlite3Step(Vdbe *p){
   ** were called on statement p.
   */
   assert( rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR 
-       || rc==SQLITE_BUSY || rc==SQLITE_MISUSE
+       || (rc&0xff)==SQLITE_BUSY || rc==SQLITE_MISUSE
   );
   assert( (p->rc!=SQLITE_ROW && p->rc!=SQLITE_DONE) || p->rc==p->rcApp );
   if( p->isPrepareV2 && rc!=SQLITE_ROW && rc!=SQLITE_DONE ){
@@ -70841,7 +71652,7 @@ SQLITE_API void *SQLITE_STDCALL sqlite3_user_data(sqlite3_context *p){
 ** application defined function.
 */
 SQLITE_API sqlite3 *SQLITE_STDCALL sqlite3_context_db_handle(sqlite3_context *p){
-  assert( p && p->pFunc );
+  assert( p && p->pOut );
   return p->pOut->db;
 }
 
@@ -71050,18 +71861,19 @@ static const Mem *columnNullValue(void){
 #endif
     = {
         /* .u          = */ {0},
-        /* .flags      = */ MEM_Null,
-        /* .enc        = */ 0,
-        /* .n          = */ 0,
-        /* .z          = */ 0,
-        /* .zMalloc    = */ 0,
-        /* .szMalloc   = */ 0,
-        /* .iPadding1  = */ 0,
-        /* .db         = */ 0,
-        /* .xDel       = */ 0,
+        /* .flags      = */ (u16)MEM_Null,
+        /* .enc        = */ (u8)0,
+        /* .eSubtype   = */ (u8)0,
+        /* .n          = */ (int)0,
+        /* .z          = */ (char*)0,
+        /* .zMalloc    = */ (char*)0,
+        /* .szMalloc   = */ (int)0,
+        /* .uTemp      = */ (u32)0,
+        /* .db         = */ (sqlite3*)0,
+        /* .xDel       = */ (void(*)(void*))0,
 #ifdef SQLITE_DEBUG
-        /* .pScopyFrom = */ 0,
-        /* .pFiller    = */ 0,
+        /* .pScopyFrom = */ (Mem*)0,
+        /* .pFiller    = */ (void*)0,
 #endif
       };
   return &nullMem;
@@ -72659,7 +73471,7 @@ SQLITE_PRIVATE int sqlite3VdbeExec(
     ** sqlite3_column_text16() failed.  */
     goto no_mem;
   }
-  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY );
+  assert( p->rc==SQLITE_OK || (p->rc&0xff)==SQLITE_BUSY );
   assert( p->bIsReader || p->readOnly!=0 );
   p->rc = SQLITE_OK;
   p->iCurrentTime = 0;
@@ -75096,12 +75908,12 @@ case OP_AutoCommit: {
       goto vdbe_return;
     }else{
       db->autoCommit = (u8)desiredAutoCommit;
-      if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){
-        p->pc = (int)(pOp - aOp);
-        db->autoCommit = (u8)(1-desiredAutoCommit);
-        p->rc = rc = SQLITE_BUSY;
-        goto vdbe_return;
-      }
+    }
+    if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){
+      p->pc = (int)(pOp - aOp);
+      db->autoCommit = (u8)(1-desiredAutoCommit);
+      p->rc = rc = SQLITE_BUSY;
+      goto vdbe_return;
     }
     assert( db->nStatement==0 );
     sqlite3CloseSavepoints(db);
@@ -75173,9 +75985,11 @@ case OP_Transaction: {
 
   if( pBt ){
     rc = sqlite3BtreeBeginTrans(pBt, pOp->p2);
-    if( rc==SQLITE_BUSY ){
+    testcase( rc==SQLITE_BUSY_SNAPSHOT );
+    testcase( rc==SQLITE_BUSY_RECOVERY );
+    if( (rc&0xff)==SQLITE_BUSY ){
       p->pc = (int)(pOp - aOp);
-      p->rc = rc = SQLITE_BUSY;
+      p->rc = rc;
       goto vdbe_return;
     }
     if( rc!=SQLITE_OK ){
@@ -76054,9 +76868,10 @@ case OP_Found: {        /* jump, in3 */
 **
 ** P1 is the index of a cursor open on an SQL table btree (with integer
 ** keys).  P3 is an integer rowid.  If P1 does not contain a record with
-** rowid P3 then jump immediately to P2.  If P1 does contain a record
-** with rowid P3 then leave the cursor pointing at that record and fall
-** through to the next instruction.
+** rowid P3 then jump immediately to P2.  Or, if P2 is 0, raise an
+** SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then 
+** leave the cursor pointing at that record and fall through to the next
+** instruction.
 **
 ** The OP_NotFound opcode performs the same operation on index btrees
 ** (with arbitrary multi-value keys).
@@ -76088,13 +76903,21 @@ case OP_NotExists: {        /* jump, in3 */
   res = 0;
   iKey = pIn3->u.i;
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);
+  assert( rc==SQLITE_OK || res==0 );
   pC->movetoTarget = iKey;  /* Used by OP_Delete */
   pC->nullRow = 0;
   pC->cacheStatus = CACHE_STALE;
   pC->deferredMoveto = 0;
   VdbeBranchTaken(res!=0,2);
   pC->seekResult = res;
-  if( res!=0 ) goto jump_to_p2;
+  if( res!=0 ){
+    assert( rc==SQLITE_OK );
+    if( pOp->p2==0 ){
+      rc = SQLITE_CORRUPT_BKPT;
+    }else{
+      goto jump_to_p2;
+    }
+  }
   break;
 }
 
@@ -76360,14 +77183,15 @@ case OP_InsertInt: {
   break;
 }
 
-/* Opcode: Delete P1 P2 * P4 *
+/* Opcode: Delete P1 P2 * P4 P5
 **
 ** Delete the record at which the P1 cursor is currently pointing.
 **
-** The cursor will be left pointing at either the next or the previous
-** record in the table. If it is left pointing at the next record, then
-** the next Next instruction will be a no-op.  Hence it is OK to delete
-** a record from within a Next loop.
+** If the P5 parameter is non-zero, the cursor will be left pointing at 
+** either the next or the previous record in the table. If it is left 
+** pointing at the next record, then the next Next instruction will be a 
+** no-op. As a result, in this case it is OK to delete a record from within a
+** Next loop. If P5 is zero, then the cursor is left in an undefined state.
 **
 ** If the OPFLAG_NCHANGE flag of P2 is set, then the row change count is
 ** incremented (otherwise not).
@@ -76382,6 +77206,7 @@ case OP_InsertInt: {
 */
 case OP_Delete: {
   VdbeCursor *pC;
+  u8 hasUpdateCallback;
 
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
@@ -76389,22 +77214,27 @@ case OP_Delete: {
   assert( pC->pCursor!=0 );  /* Only valid for real tables, no pseudotables */
   assert( pC->deferredMoveto==0 );
 
+  hasUpdateCallback = db->xUpdateCallback && pOp->p4.z && pC->isTable;
+  if( pOp->p5 && hasUpdateCallback ){
+    sqlite3BtreeKeySize(pC->pCursor, &pC->movetoTarget);
+  }
+
 #ifdef SQLITE_DEBUG
   /* The seek operation that positioned the cursor prior to OP_Delete will
   ** have also set the pC->movetoTarget field to the rowid of the row that
   ** is being deleted */
-  if( pOp->p4.z && pC->isTable ){
+  if( pOp->p4.z && pC->isTable && pOp->p5==0 ){
     i64 iKey = 0;
     sqlite3BtreeKeySize(pC->pCursor, &iKey);
     assert( pC->movetoTarget==iKey ); 
   }
 #endif
  
-  rc = sqlite3BtreeDelete(pC->pCursor);
+  rc = sqlite3BtreeDelete(pC->pCursor, pOp->p5);
   pC->cacheStatus = CACHE_STALE;
 
   /* Invoke the update-hook if required. */
-  if( rc==SQLITE_OK && db->xUpdateCallback && pOp->p4.z && pC->isTable ){
+  if( rc==SQLITE_OK && hasUpdateCallback ){
     db->xUpdateCallback(db->pUpdateArg, SQLITE_DELETE,
                         db->aDb[pC->iDb].zName, pOp->p4.z, pC->movetoTarget);
     assert( pC->iDb>=0 );
@@ -76943,7 +77773,7 @@ case OP_IdxDelete: {
 #endif
   rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res);
   if( rc==SQLITE_OK && res==0 ){
-    rc = sqlite3BtreeDelete(pCrsr);
+    rc = sqlite3BtreeDelete(pCrsr, 0);
   }
   assert( pC->deferredMoveto==0 );
   pC->cacheStatus = CACHE_STALE;
@@ -77741,12 +78571,12 @@ case OP_MemMax: {        /* in2 */
 }
 #endif /* SQLITE_OMIT_AUTOINCREMENT */
 
-/* Opcode: IfPos P1 P2 * * *
-** Synopsis: if r[P1]>0 goto P2
+/* Opcode: IfPos P1 P2 P3 * *
+** Synopsis: if r[P1]>0 then r[P1]-=P3, goto P2
 **
 ** Register P1 must contain an integer.
-** If the value of register P1 is 1 or greater, jump to P2 and
-** add the literal value P3 to register P1.
+** If the value of register P1 is 1 or greater, subtract P3 from the
+** value in P1 and jump to P2.
 **
 ** If the initial value of register P1 is less than 1, then the
 ** value is unchanged and control passes through to the next instruction.
@@ -77755,38 +78585,44 @@ case OP_IfPos: {        /* jump, in1 */
   pIn1 = &aMem[pOp->p1];
   assert( pIn1->flags&MEM_Int );
   VdbeBranchTaken( pIn1->u.i>0, 2);
-  if( pIn1->u.i>0 ) goto jump_to_p2;
+  if( pIn1->u.i>0 ){
+    pIn1->u.i -= pOp->p3;
+    goto jump_to_p2;
+  }
   break;
 }
 
-/* Opcode: IfNeg P1 P2 P3 * *
-** Synopsis: r[P1]+=P3, if r[P1]<0 goto P2
+/* Opcode: SetIfNotPos P1 P2 P3 * *
+** Synopsis: if r[P1]<=0 then r[P2]=P3
 **
-** Register P1 must contain an integer.  Add literal P3 to the value in
-** register P1 then if the value of register P1 is less than zero, jump to P2. 
+** Register P1 must contain an integer.
+** If the value of register P1 is not positive (if it is less than 1) then
+** set the value of register P2 to be the integer P3.
 */
-case OP_IfNeg: {        /* jump, in1 */
+case OP_SetIfNotPos: {        /* in1, in2 */
   pIn1 = &aMem[pOp->p1];
   assert( pIn1->flags&MEM_Int );
-  pIn1->u.i += pOp->p3;
-  VdbeBranchTaken(pIn1->u.i<0, 2);
-  if( pIn1->u.i<0 ) goto jump_to_p2;
+  if( pIn1->u.i<=0 ){
+    pOut = out2Prerelease(p, pOp);
+    pOut->u.i = pOp->p3;
+  }
   break;
 }
 
 /* Opcode: IfNotZero P1 P2 P3 * *
-** Synopsis: if r[P1]!=0 then r[P1]+=P3, goto P2
+** Synopsis: if r[P1]!=0 then r[P1]-=P3, goto P2
 **
 ** Register P1 must contain an integer.  If the content of register P1 is
-** initially nonzero, then add P3 to P1 and jump to P2.  If register P1 is
-** initially zero, leave it unchanged and fall through.
+** initially nonzero, then subtract P3 from the value in register P1 and
+** jump to P2.  If register P1 is initially zero, leave it unchanged
+** and fall through.
 */
 case OP_IfNotZero: {        /* jump, in1 */
   pIn1 = &aMem[pOp->p1];
   assert( pIn1->flags&MEM_Int );
   VdbeBranchTaken(pIn1->u.i<0, 2);
   if( pIn1->u.i ){
-     pIn1->u.i += pOp->p3;
+     pIn1->u.i -= pOp->p3;
      goto jump_to_p2;
   }
   break;
@@ -79011,7 +79847,8 @@ SQLITE_API int SQLITE_STDCALL sqlite3_blob_open(
       for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
         int j;
         for(j=0; j<pIdx->nKeyCol; j++){
-          if( pIdx->aiColumn[j]==iCol ){
+          /* FIXME: Be smarter about indexes that use expressions */
+          if( pIdx->aiColumn[j]==iCol || pIdx->aiColumn[j]==XN_EXPR ){
             zFault = "indexed";
           }
         }
@@ -82592,6 +83429,11 @@ SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
       if( sqlite3WalkSelect(pWalker, pItem->pSelect) ){
         return WRC_Abort;
       }
+      if( pItem->fg.isTabFunc
+       && sqlite3WalkExprList(pWalker, pItem->u1.pFuncArg)
+      ){
+        return WRC_Abort;
+      }
     }
   }
   return WRC_Continue;
@@ -82689,30 +83531,6 @@ static void incrAggFunctionDepth(Expr *pExpr, int N){
 ** Turn the pExpr expression into an alias for the iCol-th column of the
 ** result set in pEList.
 **
-** If the result set column is a simple column reference, then this routine
-** makes an exact copy.  But for any other kind of expression, this
-** routine make a copy of the result set column as the argument to the
-** TK_AS operator.  The TK_AS operator causes the expression to be
-** evaluated just once and then reused for each alias.
-**
-** The reason for suppressing the TK_AS term when the expression is a simple
-** column reference is so that the column reference will be recognized as
-** usable by indices within the WHERE clause processing logic. 
-**
-** The TK_AS operator is inhibited if zType[0]=='G'.  This means
-** that in a GROUP BY clause, the expression is evaluated twice.  Hence:
-**
-**     SELECT random()%5 AS x, count(*) FROM tab GROUP BY x
-**
-** Is equivalent to:
-**
-**     SELECT random()%5 AS x, count(*) FROM tab GROUP BY random()%5
-**
-** The result of random()%5 in the GROUP BY clause is probably different
-** from the result in the result-set.  On the other hand Standard SQL does
-** not allow the GROUP BY clause to contain references to result-set columns.
-** So this should never come up in well-formed queries.
-**
 ** If the reference is followed by a COLLATE operator, then make sure
 ** the COLLATE operator is preserved.  For example:
 **
@@ -82746,19 +83564,11 @@ static void resolveAlias(
   db = pParse->db;
   pDup = sqlite3ExprDup(db, pOrig, 0);
   if( pDup==0 ) return;
-  if( pOrig->op!=TK_COLUMN && zType[0]!='G' ){
-    incrAggFunctionDepth(pDup, nSubquery);
-    pDup = sqlite3PExpr(pParse, TK_AS, pDup, 0, 0);
-    if( pDup==0 ) return;
-    ExprSetProperty(pDup, EP_Skip);
-    if( pEList->a[iCol].u.x.iAlias==0 ){
-      pEList->a[iCol].u.x.iAlias = (u16)(++pParse->nAlias);
-    }
-    pDup->iTable = pEList->a[iCol].u.x.iAlias;
-  }
+  if( zType[0]!='G' ) incrAggFunctionDepth(pDup, nSubquery);
   if( pExpr->op==TK_COLLATE ){
     pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken);
   }
+  ExprSetProperty(pDup, EP_Alias);
 
   /* Before calling sqlite3ExprDelete(), set the EP_Static flag. This 
   ** prevents ExprDelete() from deleting the Expr structure itself,
@@ -82950,7 +83760,7 @@ static int lookupName(
             ** USING clause, then skip this match.
             */
             if( cnt==1 ){
-              if( pItem->jointype & JT_NATURAL ) continue;
+              if( pItem->fg.jointype & JT_NATURAL ) continue;
               if( nameInUsingClause(pItem->pUsing, zCol) ) continue;
             }
             cnt++;
@@ -82965,8 +83775,8 @@ static int lookupName(
         pExpr->iTable = pMatch->iCursor;
         pExpr->pTab = pMatch->pTab;
         /* RIGHT JOIN not (yet) supported */
-        assert( (pMatch->jointype & JT_RIGHT)==0 );
-        if( (pMatch->jointype & JT_LEFT)!=0 ){
+        assert( (pMatch->fg.jointype & JT_RIGHT)==0 );
+        if( (pMatch->fg.jointype & JT_LEFT)!=0 ){
           ExprSetProperty(pExpr, EP_CanBeNull);
         }
         pSchema = pExpr->pTab->pSchema;
@@ -83031,8 +83841,13 @@ static int lookupName(
     /*
     ** Perhaps the name is a reference to the ROWID
     */
-    if( cnt==0 && cntTab==1 && pMatch && sqlite3IsRowid(zCol)
-     && VisibleRowid(pMatch->pTab) ){
+    if( cnt==0
+     && cntTab==1
+     && pMatch
+     && (pNC->ncFlags & NC_IdxExpr)==0
+     && sqlite3IsRowid(zCol)
+     && VisibleRowid(pMatch->pTab)
+    ){
       cnt = 1;
       pExpr->iColumn = -1;     /* IMP: R-44911-55124 */
       pExpr->affinity = SQLITE_AFF_INTEGER;
@@ -83051,9 +83866,9 @@ static int lookupName(
     ** resolved by the time the WHERE clause is resolved.
     **
     ** The ability to use an output result-set column in the WHERE, GROUP BY,
-    ** or HAVING clauses, or as part of a larger expression in the ORDRE BY
+    ** or HAVING clauses, or as part of a larger expression in the ORDER BY
     ** clause is not standard SQL.  This is a (goofy) SQLite extension, that
-    ** is supported for backwards compatibility only.  TO DO: Issue a warning
+    ** is supported for backwards compatibility only. Hence, we issue a warning
     ** on sqlite3_log() whenever the capability is used.
     */
     if( (pEList = pNC->pEList)!=0
@@ -83150,7 +83965,7 @@ static int lookupName(
 lookupname_end:
   if( cnt==1 ){
     assert( pNC!=0 );
-    if( pExpr->op!=TK_AS ){
+    if( !ExprHasProperty(pExpr, EP_Alias) ){
       sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
     }
     /* Increment the nRef value on all name contexts from TopNC up to
@@ -83191,36 +84006,25 @@ SQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSr
 }
 
 /*
-** Report an error that an expression is not valid for a partial index WHERE
-** clause.
+** Report an error that an expression is not valid for some set of
+** pNC->ncFlags values determined by validMask.
 */
-static void notValidPartIdxWhere(
+static void notValid(
   Parse *pParse,       /* Leave error message here */
   NameContext *pNC,    /* The name context */
-  const char *zMsg     /* Type of error */
+  const char *zMsg,    /* Type of error */
+  int validMask        /* Set of contexts for which prohibited */
 ){
-  if( (pNC->ncFlags & NC_PartIdx)!=0 ){
-    sqlite3ErrorMsg(pParse, "%s prohibited in partial index WHERE clauses",
-                    zMsg);
-  }
-}
-
+  assert( (validMask&~(NC_IsCheck|NC_PartIdx|NC_IdxExpr))==0 );
+  if( (pNC->ncFlags & validMask)!=0 ){
+    const char *zIn = "partial index WHERE clauses";
+    if( pNC->ncFlags & NC_IdxExpr )      zIn = "index expressions";
 #ifndef SQLITE_OMIT_CHECK
-/*
-** Report an error that an expression is not valid for a CHECK constraint.
-*/
-static void notValidCheckConstraint(
-  Parse *pParse,       /* Leave error message here */
-  NameContext *pNC,    /* The name context */
-  const char *zMsg     /* Type of error */
-){
-  if( (pNC->ncFlags & NC_IsCheck)!=0 ){
-    sqlite3ErrorMsg(pParse,"%s prohibited in CHECK constraints", zMsg);
+    else if( pNC->ncFlags & NC_IsCheck ) zIn = "CHECK constraints";
+#endif
+    sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
   }
 }
-#else
-# define notValidCheckConstraint(P,N,M)
-#endif
 
 /*
 ** Expression p should encode a floating point value between 1.0 and 0.0.
@@ -83305,6 +84109,8 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
       Expr *pRight;
 
       /* if( pSrcList==0 ) break; */
+      notValid(pParse, pNC, "the \".\" operator", NC_IdxExpr);
+      /*notValid(pParse, pNC, "the \".\" operator", NC_PartIdx|NC_IsCheck, 1);*/
       pRight = pExpr->pRight;
       if( pRight->op==TK_ID ){
         zDb = 0;
@@ -83334,7 +84140,7 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
       u8 enc = ENC(pParse->db);   /* The database encoding */
 
       assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
-      notValidPartIdxWhere(pParse, pNC, "functions");
+      notValid(pParse, pNC, "functions", NC_PartIdx);
       zId = pExpr->u.zToken;
       nId = sqlite3Strlen30(zId);
       pDef = sqlite3FindFunction(pParse->db, zId, nId, n, enc, 0);
@@ -83382,9 +84188,18 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
           return WRC_Prune;
         }
 #endif
-        if( pDef->funcFlags & SQLITE_FUNC_CONSTANT ){
+        if( pDef->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG) ){
+          /* For the purposes of the EP_ConstFunc flag, date and time
+          ** functions and other functions that change slowly are considered
+          ** constant because they are constant for the duration of one query */
           ExprSetProperty(pExpr,EP_ConstFunc);
         }
+        if( (pDef->funcFlags & SQLITE_FUNC_CONSTANT)==0 ){
+          /* Date/time functions that use 'now', and other functions like
+          ** sqlite_version() that might change over time cannot be used
+          ** in an index. */
+          notValid(pParse, pNC, "non-deterministic functions", NC_IdxExpr);
+        }
       }
       if( is_agg && (pNC->ncFlags & NC_AllowAgg)==0 ){
         sqlite3ErrorMsg(pParse, "misuse of aggregate function %.*s()", nId,zId);
@@ -83430,8 +84245,7 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
       testcase( pExpr->op==TK_IN );
       if( ExprHasProperty(pExpr, EP_xIsSelect) ){
         int nRef = pNC->nRef;
-        notValidCheckConstraint(pParse, pNC, "subqueries");
-        notValidPartIdxWhere(pParse, pNC, "subqueries");
+        notValid(pParse, pNC, "subqueries", NC_IsCheck|NC_PartIdx|NC_IdxExpr);
         sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
         assert( pNC->nRef>=nRef );
         if( nRef!=pNC->nRef ){
@@ -83441,8 +84255,7 @@ static int resolveExprStep(Walker *pWalker, Expr *pExpr){
       break;
     }
     case TK_VARIABLE: {
-      notValidCheckConstraint(pParse, pNC, "parameters");
-      notValidPartIdxWhere(pParse, pNC, "parameters");
+      notValid(pParse, pNC, "parameters", NC_IsCheck|NC_PartIdx|NC_IdxExpr);
       break;
     }
   }
@@ -83786,7 +84599,6 @@ static int resolveSelectStep(Walker *pWalker, Select *p){
   int isCompound;         /* True if p is a compound select */
   int nCompound;          /* Number of compound terms processed so far */
   Parse *pParse;          /* Parsing context */
-  ExprList *pEList;       /* Result set expression list */
   int i;                  /* Loop counter */
   ExprList *pGroupBy;     /* The GROUP BY clause */
   Select *pLeftmost;      /* Left-most of SELECT of a compound */
@@ -83859,7 +84671,7 @@ static int resolveSelectStep(Walker *pWalker, Select *p){
         ** parent contexts. After resolving references to expressions in
         ** pItem->pSelect, check if this value has changed. If so, then
         ** SELECT statement pItem->pSelect must be correlated. Set the
-        ** pItem->isCorrelated flag if this is the case. */
+        ** pItem->fg.isCorrelated flag if this is the case. */
         for(pNC=pOuterNC; pNC; pNC=pNC->pNext) nRef += pNC->nRef;
 
         if( pItem->zName ) pParse->zAuthContext = pItem->zName;
@@ -83868,8 +84680,8 @@ static int resolveSelectStep(Walker *pWalker, Select *p){
         if( pParse->nErr || db->mallocFailed ) return WRC_Abort;
 
         for(pNC=pOuterNC; pNC; pNC=pNC->pNext) nRef -= pNC->nRef;
-        assert( pItem->isCorrelated==0 && nRef<=0 );
-        pItem->isCorrelated = (nRef!=0);
+        assert( pItem->fg.isCorrelated==0 && nRef<=0 );
+        pItem->fg.isCorrelated = (nRef!=0);
       }
     }
   
@@ -83881,14 +84693,7 @@ static int resolveSelectStep(Walker *pWalker, Select *p){
     sNC.pNext = pOuterNC;
   
     /* Resolve names in the result set. */
-    pEList = p->pEList;
-    assert( pEList!=0 );
-    for(i=0; i<pEList->nExpr; i++){
-      Expr *pX = pEList->a[i].pExpr;
-      if( sqlite3ResolveExprNames(&sNC, pX) ){
-        return WRC_Abort;
-      }
-    }
+    if( sqlite3ResolveExprListNames(&sNC, p->pEList) ) return WRC_Abort;
   
     /* If there are no aggregate functions in the result-set, and no GROUP BY 
     ** expression, do not allow aggregates in any of the other expressions.
@@ -83921,6 +84726,16 @@ static int resolveSelectStep(Walker *pWalker, Select *p){
     if( sqlite3ResolveExprNames(&sNC, p->pHaving) ) return WRC_Abort;
     if( sqlite3ResolveExprNames(&sNC, p->pWhere) ) return WRC_Abort;
 
+    /* Resolve names in table-valued-function arguments */
+    for(i=0; i<p->pSrc->nSrc; i++){
+      struct SrcList_item *pItem = &p->pSrc->a[i];
+      if( pItem->fg.isTabFunc
+       && sqlite3ResolveExprListNames(&sNC, pItem->u1.pFuncArg) 
+      ){
+        return WRC_Abort;
+      }
+    }
+
     /* The ORDER BY and GROUP BY clauses may not refer to terms in
     ** outer queries 
     */
@@ -84084,6 +84899,22 @@ SQLITE_PRIVATE int sqlite3ResolveExprNames(
   return ExprHasProperty(pExpr, EP_Error);
 }
 
+/*
+** Resolve all names for all expression in an expression list.  This is
+** just like sqlite3ResolveExprNames() except that it works for an expression
+** list rather than a single expression.
+*/
+SQLITE_PRIVATE int sqlite3ResolveExprListNames( 
+  NameContext *pNC,       /* Namespace to resolve expressions in. */
+  ExprList *pList         /* The expression list to be analyzed. */
+){
+  int i;
+  assert( pList!=0 );
+  for(i=0; i<pList->nExpr; i++){
+    if( sqlite3ResolveExprNames(pNC, pList->a[i].pExpr) ) return WRC_Abort;
+  }
+  return WRC_Continue;
+}
 
 /*
 ** Resolve all names in all expressions of a SELECT and in all
@@ -84127,15 +84958,14 @@ SQLITE_PRIVATE void sqlite3ResolveSelectNames(
 SQLITE_PRIVATE void sqlite3ResolveSelfReference(
   Parse *pParse,      /* Parsing context */
   Table *pTab,        /* The table being referenced */
-  int type,           /* NC_IsCheck or NC_PartIdx */
+  int type,           /* NC_IsCheck or NC_PartIdx or NC_IdxExpr */
   Expr *pExpr,        /* Expression to resolve.  May be NULL. */
   ExprList *pList     /* Expression list to resolve.  May be NUL. */
 ){
   SrcList sSrc;                   /* Fake SrcList for pParse->pNewTable */
   NameContext sNC;                /* Name context for pParse->pNewTable */
-  int i;                          /* Loop counter */
 
-  assert( type==NC_IsCheck || type==NC_PartIdx );
+  assert( type==NC_IsCheck || type==NC_PartIdx || type==NC_IdxExpr );
   memset(&sNC, 0, sizeof(sNC));
   memset(&sSrc, 0, sizeof(sSrc));
   sSrc.nSrc = 1;
@@ -84146,13 +84976,7 @@ SQLITE_PRIVATE void sqlite3ResolveSelfReference(
   sNC.pSrcList = &sSrc;
   sNC.ncFlags = type;
   if( sqlite3ResolveExprNames(&sNC, pExpr) ) return;
-  if( pList ){
-    for(i=0; i<pList->nExpr; i++){
-      if( sqlite3ResolveExprNames(&sNC, pList->a[i].pExpr) ){
-        return;
-      }
-    }
-  }
+  if( pList ) sqlite3ResolveExprListNames(&sNC, pList);
 }
 
 /************** End of resolve.c *********************************************/
@@ -84250,7 +85074,7 @@ SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, con
 }
 
 /*
-** Skip over any TK_COLLATE or TK_AS operators and any unlikely()
+** Skip over any TK_COLLATE operators and any unlikely()
 ** or likelihood() function at the root of an expression.
 */
 SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr *pExpr){
@@ -84261,7 +85085,7 @@ SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr *pExpr){
       assert( pExpr->op==TK_FUNCTION );
       pExpr = pExpr->x.pList->a[0].pExpr;
     }else{
-      assert( pExpr->op==TK_COLLATE || pExpr->op==TK_AS );
+      assert( pExpr->op==TK_COLLATE );
       pExpr = pExpr->pLeft;
     }
   }   
@@ -84592,7 +85416,7 @@ SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){
 ** is responsible for making sure the node eventually gets freed.
 **
 ** If dequote is true, then the token (if it exists) is dequoted.
-** If dequote is false, no dequoting is performance.  The deQuote
+** If dequote is false, no dequoting is performed.  The deQuote
 ** parameter is ignored if pToken is NULL or if the token does not
 ** appear to be quoted.  If the quotes were of the form "..." (double-quotes)
 ** then the EP_DblQuoted flag is set on the expression node.
@@ -85193,16 +86017,18 @@ SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){
     pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);
     pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
     pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);
-    pNewItem->jointype = pOldItem->jointype;
+    pNewItem->fg = pOldItem->fg;
     pNewItem->iCursor = pOldItem->iCursor;
     pNewItem->addrFillSub = pOldItem->addrFillSub;
     pNewItem->regReturn = pOldItem->regReturn;
-    pNewItem->isCorrelated = pOldItem->isCorrelated;
-    pNewItem->viaCoroutine = pOldItem->viaCoroutine;
-    pNewItem->isRecursive = pOldItem->isRecursive;
-    pNewItem->zIndexedBy = sqlite3DbStrDup(db, pOldItem->zIndexedBy);
-    pNewItem->notIndexed = pOldItem->notIndexed;
-    pNewItem->pIndex = pOldItem->pIndex;
+    if( pNewItem->fg.isIndexedBy ){
+      pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem->u1.zIndexedBy);
+    }
+    pNewItem->pIBIndex = pOldItem->pIBIndex;
+    if( pNewItem->fg.isTabFunc ){
+      pNewItem->u1.pFuncArg = 
+          sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);
+    }
     pTab = pNewItem->pTab = pOldItem->pTab;
     if( pTab ){
       pTab->nRef++;
@@ -85317,6 +86143,20 @@ SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(
   return 0;
 }
 
+/*
+** Set the sort order for the last element on the given ExprList.
+*/
+SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder){
+  if( p==0 ) return;
+  assert( SQLITE_SO_UNDEFINED<0 && SQLITE_SO_ASC>=0 && SQLITE_SO_DESC>0 );
+  assert( p->nExpr>0 );
+  if( iSortOrder<0 ){
+    assert( p->a[p->nExpr-1].sortOrder==SQLITE_SO_ASC );
+    return;
+  }
+  p->a[p->nExpr-1].sortOrder = (u8)iSortOrder;
+}
+
 /*
 ** Set the ExprList.a[].zName element of the most recently added item
 ** on the expression list.
@@ -85738,13 +86578,13 @@ SQLITE_PRIVATE int sqlite3CodeOnce(Parse *pParse){
 ** to be set to NULL if iCur contains one or more NULL values.
 */
 static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){
-  int j1;
+  int addr1;
   sqlite3VdbeAddOp2(v, OP_Integer, 0, regHasNull);
-  j1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);
+  addr1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);
   sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, regHasNull);
   sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);
   VdbeComment((v, "first_entry_in(%d)", iCur));
-  sqlite3VdbeJumpHere(v, j1);
+  sqlite3VdbeJumpHere(v, addr1);
 }
 
 
@@ -86288,7 +87128,7 @@ static void sqlite3ExprCodeIN(
     }
     if( regCkNull ){
       sqlite3VdbeAddOp2(v, OP_IsNull, regCkNull, destIfNull); VdbeCoverage(v);
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);
+      sqlite3VdbeGoto(v, destIfFalse);
     }
     sqlite3VdbeResolveLabel(v, labelOk);
     sqlite3ReleaseTempReg(pParse, regCkNull);
@@ -86306,7 +87146,7 @@ static void sqlite3ExprCodeIN(
         int addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, r1); VdbeCoverage(v);
         sqlite3VdbeAddOp2(v, OP_Rewind, pExpr->iTable, destIfFalse);
         VdbeCoverage(v);
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfNull);
+        sqlite3VdbeGoto(v, destIfNull);
         sqlite3VdbeJumpHere(v, addr1);
       }
     }
@@ -86344,7 +87184,7 @@ static void sqlite3ExprCodeIN(
         ** the presence of a NULL on the RHS makes a difference in the
         ** outcome.
         */
-        int j1;
+        int addr1;
   
         /* First check to see if the LHS is contained in the RHS.  If so,
         ** then the answer is TRUE the presence of NULLs in the RHS does
@@ -86352,12 +87192,12 @@ static void sqlite3ExprCodeIN(
         ** answer is NULL if the RHS contains NULLs and the answer is
         ** FALSE if the RHS is NULL-free.
         */
-        j1 = sqlite3VdbeAddOp4Int(v, OP_Found, pExpr->iTable, 0, r1, 1);
+        addr1 = sqlite3VdbeAddOp4Int(v, OP_Found, pExpr->iTable, 0, r1, 1);
         VdbeCoverage(v);
         sqlite3VdbeAddOp2(v, OP_IsNull, rRhsHasNull, destIfNull);
         VdbeCoverage(v);
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);
-        sqlite3VdbeJumpHere(v, j1);
+        sqlite3VdbeGoto(v, destIfFalse);
+        sqlite3VdbeJumpHere(v, addr1);
       }
     }
   }
@@ -86575,6 +87415,28 @@ static void sqlite3ExprCachePinRegister(Parse *pParse, int iReg){
   }
 }
 
+/* Generate code that will load into register regOut a value that is
+** appropriate for the iIdxCol-th column of index pIdx.
+*/
+SQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(
+  Parse *pParse,  /* The parsing context */
+  Index *pIdx,    /* The index whose column is to be loaded */
+  int iTabCur,    /* Cursor pointing to a table row */
+  int iIdxCol,    /* The column of the index to be loaded */
+  int regOut      /* Store the index column value in this register */
+){
+  i16 iTabCol = pIdx->aiColumn[iIdxCol];
+  if( iTabCol==XN_EXPR ){
+    assert( pIdx->aColExpr );
+    assert( pIdx->aColExpr->nExpr>iIdxCol );
+    pParse->iSelfTab = iTabCur;
+    sqlite3ExprCode(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);
+  }else{
+    sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,
+                                    iTabCol, regOut);
+  }
+}
+
 /*
 ** Generate code to extract the value of the iCol-th column of a table.
 */
@@ -86760,8 +87622,9 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)
           inReg = pExpr->iColumn + pParse->ckBase;
           break;
         }else{
-          /* Deleting from a partial index */
-          iTab = pParse->iPartIdxTab;
+          /* Coding an expression that is part of an index where column names
+          ** in the index refer to the table to which the index belongs */
+          iTab = pParse->iSelfTab;
         }
       }
       inReg = sqlite3ExprCodeGetColumn(pParse, pExpr->pTab,
@@ -86782,7 +87645,7 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)
 #endif
     case TK_STRING: {
       assert( !ExprHasProperty(pExpr, EP_IntValue) );
-      sqlite3VdbeAddOp4(v, OP_String8, 0, target, 0, pExpr->u.zToken, 0);
+      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);
       break;
     }
     case TK_NULL: {
@@ -86821,10 +87684,6 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)
       inReg = pExpr->iTable;
       break;
     }
-    case TK_AS: {
-      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
-      break;
-    }
 #ifndef SQLITE_OMIT_CAST
     case TK_CAST: {
       /* Expressions of the form:   CAST(pLeft AS token) */
@@ -87055,7 +87914,7 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)
         }
 
         sqlite3ExprCachePush(pParse);     /* Ticket 2ea2425d34be */
-        sqlite3ExprCodeExprList(pParse, pFarg, r1,
+        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,
                                 SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);
         sqlite3ExprCachePop(pParse);      /* Ticket 2ea2425d34be */
       }else{
@@ -87279,7 +88138,7 @@ SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target)
         sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);
         testcase( aListelem[i+1].pExpr->op==TK_COLUMN );
         sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, endLabel);
+        sqlite3VdbeGoto(v, endLabel);
         sqlite3ExprCachePop(pParse);
         sqlite3VdbeResolveLabel(v, nextCase);
       }
@@ -87471,11 +88330,13 @@ SQLITE_PRIVATE int sqlite3ExprCodeExprList(
   Parse *pParse,     /* Parsing context */
   ExprList *pList,   /* The expression list to be coded */
   int target,        /* Where to write results */
+  int srcReg,        /* Source registers if SQLITE_ECEL_REF */
   u8 flags           /* SQLITE_ECEL_* flags */
 ){
   struct ExprList_item *pItem;
-  int i, n;
+  int i, j, n;
   u8 copyOp = (flags & SQLITE_ECEL_DUP) ? OP_Copy : OP_SCopy;
+  Vdbe *v = pParse->pVdbe;
   assert( pList!=0 );
   assert( target>0 );
   assert( pParse->pVdbe!=0 );  /* Never gets this far otherwise */
@@ -87483,13 +88344,14 @@ SQLITE_PRIVATE int sqlite3ExprCodeExprList(
   if( !ConstFactorOk(pParse) ) flags &= ~SQLITE_ECEL_FACTOR;
   for(pItem=pList->a, i=0; i<n; i++, pItem++){
     Expr *pExpr = pItem->pExpr;
-    if( (flags & SQLITE_ECEL_FACTOR)!=0 && sqlite3ExprIsConstant(pExpr) ){
+    if( (flags & SQLITE_ECEL_REF)!=0 && (j = pList->a[i].u.x.iOrderByCol)>0 ){
+      sqlite3VdbeAddOp2(v, copyOp, j+srcReg-1, target+i);
+    }else if( (flags & SQLITE_ECEL_FACTOR)!=0 && sqlite3ExprIsConstant(pExpr) ){
       sqlite3ExprCodeAtInit(pParse, pExpr, target+i, 0);
     }else{
       int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);
       if( inReg!=target+i ){
         VdbeOp *pOp;
-        Vdbe *v = pParse->pVdbe;
         if( copyOp==OP_Copy
          && (pOp=sqlite3VdbeGetOp(v, -1))->opcode==OP_Copy
          && pOp->p1+pOp->p3+1==inReg
@@ -87666,14 +88528,14 @@ SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int
       int destIfFalse = sqlite3VdbeMakeLabel(v);
       int destIfNull = jumpIfNull ? dest : destIfFalse;
       sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, dest);
+      sqlite3VdbeGoto(v, dest);
       sqlite3VdbeResolveLabel(v, destIfFalse);
       break;
     }
 #endif
     default: {
       if( exprAlwaysTrue(pExpr) ){
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, dest);
+        sqlite3VdbeGoto(v, dest);
       }else if( exprAlwaysFalse(pExpr) ){
         /* No-op */
       }else{
@@ -87829,7 +88691,7 @@ SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int
 #endif
     default: {
       if( exprAlwaysFalse(pExpr) ){
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, dest);
+        sqlite3VdbeGoto(v, dest);
       }else if( exprAlwaysTrue(pExpr) ){
         /* no-op */
       }else{
@@ -87905,7 +88767,9 @@ SQLITE_PRIVATE int sqlite3ExprCompare(Expr *pA, Expr *pB, int iTab){
     return 2;
   }
   if( pA->op!=TK_COLUMN && ALWAYS(pA->op!=TK_AGG_COLUMN) && pA->u.zToken ){
-    if( strcmp(pA->u.zToken,pB->u.zToken)!=0 ){
+    if( pA->op==TK_FUNCTION ){
+      if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;
+    }else if( strcmp(pA->u.zToken,pB->u.zToken)!=0 ){
       return pA->op==TK_COLLATE ? 1 : 2;
     }
   }
@@ -88813,7 +89677,7 @@ SQLITE_PRIVATE void sqlite3AlterRenameTable(
 #ifndef SQLITE_OMIT_VIRTUALTABLE
   if( pVTab ){
     int i = ++pParse->nMem;
-    sqlite3VdbeAddOp4(v, OP_String8, 0, i, 0, zName, 0);
+    sqlite3VdbeLoadString(v, i, zName);
     sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0,(const char*)pVTab, P4_VTAB);
     sqlite3MayAbort(pParse);
   }
@@ -88924,14 +89788,14 @@ SQLITE_PRIVATE void sqlite3MinimumFileFormat(Parse *pParse, int iDb, int minForm
   if( ALWAYS(v) ){
     int r1 = sqlite3GetTempReg(pParse);
     int r2 = sqlite3GetTempReg(pParse);
-    int j1;
+    int addr1;
     sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT);
     sqlite3VdbeUsesBtree(v, iDb);
     sqlite3VdbeAddOp2(v, OP_Integer, minFormat, r2);
-    j1 = sqlite3VdbeAddOp3(v, OP_Ge, r2, 0, r1);
+    addr1 = sqlite3VdbeAddOp3(v, OP_Ge, r2, 0, r1);
     sqlite3VdbeChangeP5(v, SQLITE_NOTNULL); VdbeCoverage(v);
     sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, r2);
-    sqlite3VdbeJumpHere(v, j1);
+    sqlite3VdbeJumpHere(v, addr1);
     sqlite3ReleaseTempReg(pParse, r1);
     sqlite3ReleaseTempReg(pParse, r2);
   }
@@ -90171,7 +91035,7 @@ static void analyzeOneTable(
   iIdxCur = iTab++;
   pParse->nTab = MAX(pParse->nTab, iTab);
   sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);
-  sqlite3VdbeAddOp4(v, OP_String8, 0, regTabname, 0, pTab->zName, 0);
+  sqlite3VdbeLoadString(v, regTabname, pTab->zName);
 
   for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
     int nCol;                     /* Number of columns in pIdx. "N" */
@@ -90193,7 +91057,7 @@ static void analyzeOneTable(
     }
 
     /* Populate the register containing the index name. */
-    sqlite3VdbeAddOp4(v, OP_String8, 0, regIdxname, 0, zIdxName, 0);
+    sqlite3VdbeLoadString(v, regIdxname, zIdxName);
     VdbeComment((v, "Analysis for %s.%s", pTab->zName, zIdxName));
 
     /*
@@ -90307,7 +91171,7 @@ static void analyzeOneTable(
         VdbeCoverage(v);
       }
       sqlite3VdbeAddOp2(v, OP_Integer, nColTest, regChng);
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, endDistinctTest);
+      sqlite3VdbeGoto(v, endDistinctTest);
   
   
       /*
@@ -90343,6 +91207,7 @@ static void analyzeOneTable(
       regKey = sqlite3GetTempRange(pParse, pPk->nKeyCol);
       for(j=0; j<pPk->nKeyCol; j++){
         k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[j]);
+        assert( k>=0 && k<pTab->nCol );
         sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);
         VdbeComment((v, "%s", pTab->aCol[pPk->aiColumn[j]].zName));
       }
@@ -90392,12 +91257,10 @@ static void analyzeOneTable(
       ** be taken */
       VdbeCoverageNeverTaken(v);
 #ifdef SQLITE_ENABLE_STAT3
-      sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, 
-                                      pIdx->aiColumn[0], regSample);
+      sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, 0, regSample);
 #else
       for(i=0; i<nCol; i++){
-        i16 iCol = pIdx->aiColumn[i];
-        sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, iCol, regCol+i);
+        sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, i, regCol+i);
       }
       sqlite3VdbeAddOp3(v, OP_MakeRecord, regCol, nCol, regSample);
 #endif
@@ -92094,6 +92957,8 @@ SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse){
           db->aDb[iDb].pSchema->iGeneration  /* P4 */
         );
         if( db->init.busy==0 ) sqlite3VdbeChangeP5(v, 1);
+        VdbeComment((v,
+              "usesStmtJournal=%d", pParse->mayAbort && pParse->isMultiWrite));
       }
 #ifndef SQLITE_OMIT_VIRTUALTABLE
       for(i=0; i<pParse->nVtabLock; i++){
@@ -92123,7 +92988,7 @@ SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse){
       }
 
       /* Finally, jump back to the beginning of the executable code. */
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, 1);
+      sqlite3VdbeGoto(v, 1);
     }
   }
 
@@ -92258,6 +93123,17 @@ SQLITE_PRIVATE Table *sqlite3LocateTable(
   p = sqlite3FindTable(pParse->db, zName, zDbase);
   if( p==0 ){
     const char *zMsg = isView ? "no such view" : "no such table";
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+    if( sqlite3FindDbName(pParse->db, zDbase)<1 ){
+      /* If zName is the not the name of a table in the schema created using
+      ** CREATE, then check to see if it is the name of an virtual table that
+      ** can be an eponymous virtual table. */
+      Module *pMod = (Module*)sqlite3HashFind(&pParse->db->aModule, zName);
+      if( pMod && sqlite3VtabEponymousTableInit(pParse, pMod) ){
+        return pMod->pEpoTab;
+      }
+    }
+#endif
     if( zDbase ){
       sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
     }else{
@@ -92265,7 +93141,7 @@ SQLITE_PRIVATE Table *sqlite3LocateTable(
     }
     pParse->checkSchema = 1;
   }
-#if SQLITE_USER_AUTHENICATION
+#if SQLITE_USER_AUTHENTICATION
   else if( pParse->db->auth.authLevel<UAUTH_User ){
     sqlite3ErrorMsg(pParse, "user not authenticated");
     p = 0;
@@ -92336,6 +93212,7 @@ static void freeIndex(sqlite3 *db, Index *p){
   sqlite3DeleteIndexSamples(db, p);
 #endif
   sqlite3ExprDelete(db, p->pPartIdxWhere);
+  sqlite3ExprListDelete(db, p->aColExpr);
   sqlite3DbFree(db, p->zColAff);
   if( p->isResized ) sqlite3DbFree(db, p->azColl);
 #ifdef SQLITE_ENABLE_STAT3_OR_STAT4
@@ -92462,7 +93339,7 @@ SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3 *db){
 ** Delete memory allocated for the column names of a table or view (the
 ** Table.aCol[] array).
 */
-static void sqliteDeleteColumnNames(sqlite3 *db, Table *pTable){
+SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable){
   int i;
   Column *pCol;
   assert( pTable!=0 );
@@ -92529,13 +93406,11 @@ SQLITE_PRIVATE void sqlite3DeleteTable(sqlite3 *db, Table *pTable){
 
   /* Delete the Table structure itself.
   */
-  sqliteDeleteColumnNames(db, pTable);
+  sqlite3DeleteColumnNames(db, pTable);
   sqlite3DbFree(db, pTable->zName);
   sqlite3DbFree(db, pTable->zColAff);
   sqlite3SelectDelete(db, pTable->pSelect);
-#ifndef SQLITE_OMIT_CHECK
   sqlite3ExprListDelete(db, pTable->pCheck);
-#endif
 #ifndef SQLITE_OMIT_VIRTUALTABLE
   sqlite3VtabClear(db, pTable);
 #endif
@@ -92875,9 +93750,11 @@ SQLITE_PRIVATE void sqlite3StartTable(
   ** now.
   */
   if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){
-    int j1;
+    int addr1;
     int fileFormat;
     int reg1, reg2, reg3;
+    /* nullRow[] is an OP_Record encoding of a row containing 5 NULLs */
+    static const char nullRow[] = { 6, 0, 0, 0, 0, 0 };
     sqlite3BeginWriteOperation(pParse, 1, iDb);
 
 #ifndef SQLITE_OMIT_VIRTUALTABLE
@@ -92894,14 +93771,14 @@ SQLITE_PRIVATE void sqlite3StartTable(
     reg3 = ++pParse->nMem;
     sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT);
     sqlite3VdbeUsesBtree(v, iDb);
-    j1 = sqlite3VdbeAddOp1(v, OP_If, reg3); VdbeCoverage(v);
+    addr1 = sqlite3VdbeAddOp1(v, OP_If, reg3); VdbeCoverage(v);
     fileFormat = (db->flags & SQLITE_LegacyFileFmt)!=0 ?
                   1 : SQLITE_MAX_FILE_FORMAT;
     sqlite3VdbeAddOp2(v, OP_Integer, fileFormat, reg3);
     sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, reg3);
     sqlite3VdbeAddOp2(v, OP_Integer, ENC(db), reg3);
     sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, reg3);
-    sqlite3VdbeJumpHere(v, j1);
+    sqlite3VdbeJumpHere(v, addr1);
 
     /* This just creates a place-holder record in the sqlite_master table.
     ** The record created does not contain anything yet.  It will be replaced
@@ -92922,7 +93799,7 @@ SQLITE_PRIVATE void sqlite3StartTable(
     }
     sqlite3OpenMasterTable(pParse, iDb);
     sqlite3VdbeAddOp2(v, OP_NewRowid, 0, reg1);
-    sqlite3VdbeAddOp2(v, OP_Null, 0, reg3);
+    sqlite3VdbeAddOp4(v, OP_Blob, 6, reg3, 0, nullRow, P4_STATIC);
     sqlite3VdbeAddOp3(v, OP_Insert, 0, reg3, reg1);
     sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
     sqlite3VdbeAddOp0(v, OP_Close);
@@ -93159,6 +94036,30 @@ SQLITE_PRIVATE void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){
   sqlite3ExprDelete(db, pSpan->pExpr);
 }
 
+/*
+** Backwards Compatibility Hack:
+** 
+** Historical versions of SQLite accepted strings as column names in
+** indexes and PRIMARY KEY constraints and in UNIQUE constraints.  Example:
+**
+**     CREATE TABLE xyz(a,b,c,d,e,PRIMARY KEY('a'),UNIQUE('b','c' COLLATE trim)
+**     CREATE INDEX abc ON xyz('c','d' DESC,'e' COLLATE nocase DESC);
+**
+** This is goofy.  But to preserve backwards compatibility we continue to
+** accept it.  This routine does the necessary conversion.  It converts
+** the expression given in its argument from a TK_STRING into a TK_ID
+** if the expression is just a TK_STRING with an optional COLLATE clause.
+** If the epxression is anything other than TK_STRING, the expression is
+** unchanged.
+*/
+static void sqlite3StringToId(Expr *p){
+  if( p->op==TK_STRING ){
+    p->op = TK_ID;
+  }else if( p->op==TK_COLLATE && p->pLeft->op==TK_STRING ){
+    p->pLeft->op = TK_ID;
+  }
+}
+
 /*
 ** Designate the PRIMARY KEY for the table.  pList is a list of names 
 ** of columns that form the primary key.  If pList is NULL, then the
@@ -93203,18 +94104,24 @@ SQLITE_PRIVATE void sqlite3AddPrimaryKey(
   }else{
     nTerm = pList->nExpr;
     for(i=0; i<nTerm; i++){
-      for(iCol=0; iCol<pTab->nCol; iCol++){
-        if( sqlite3StrICmp(pList->a[i].zName, pTab->aCol[iCol].zName)==0 ){
-          pTab->aCol[iCol].colFlags |= COLFLAG_PRIMKEY;
-          zType = pTab->aCol[iCol].zType;
-          break;
+      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);
+      assert( pCExpr!=0 );
+      sqlite3StringToId(pCExpr);
+      if( pCExpr->op==TK_ID ){
+        const char *zCName = pCExpr->u.zToken;
+        for(iCol=0; iCol<pTab->nCol; iCol++){
+          if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zName)==0 ){
+            pTab->aCol[iCol].colFlags |= COLFLAG_PRIMKEY;
+            zType = pTab->aCol[iCol].zType;
+            break;
+          }
         }
       }
     }
   }
   if( nTerm==1
    && zType && sqlite3StrICmp(zType, "INTEGER")==0
-   && sortOrder==SQLITE_SO_ASC
+   && sortOrder!=SQLITE_SO_DESC
   ){
     pTab->iPKey = iCol;
     pTab->keyConf = (u8)onError;
@@ -93581,7 +94488,7 @@ static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
   */
   if( pParse->addrCrTab ){
     assert( v );
-    sqlite3VdbeGetOp(v, pParse->addrCrTab)->opcode = OP_CreateIndex;
+    sqlite3VdbeChangeOpcode(v, pParse->addrCrTab, OP_CreateIndex);
   }
 
   /* Locate the PRIMARY KEY index.  Or, if this table was originally
@@ -93589,10 +94496,12 @@ static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
   */
   if( pTab->iPKey>=0 ){
     ExprList *pList;
-    pList = sqlite3ExprListAppend(pParse, 0, 0);
+    Token ipkToken;
+    ipkToken.z = pTab->aCol[pTab->iPKey].zName;
+    ipkToken.n = sqlite3Strlen30(ipkToken.z);
+    pList = sqlite3ExprListAppend(pParse, 0, 
+                  sqlite3ExprAlloc(db, TK_ID, &ipkToken, 0));
     if( pList==0 ) return;
-    pList->a[0].zName = sqlite3DbStrDup(pParse->db,
-                                        pTab->aCol[pTab->iPKey].zName);
     pList->a[0].sortOrder = pParse->iPkSortOrder;
     assert( pParse->pNewTable==pTab );
     pPk = sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0);
@@ -93608,7 +94517,7 @@ static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
     ** a database schema).  */
     if( v ){
       assert( db->init.busy==0 );
-      sqlite3VdbeGetOp(v, pPk->tnum)->opcode = OP_Goto;
+      sqlite3VdbeChangeOpcode(v, pPk->tnum, OP_Goto);
     }
 
     /*
@@ -93718,9 +94627,10 @@ SQLITE_PRIVATE void sqlite3EndTable(
   int iDb;                  /* Database in which the table lives */
   Index *pIdx;              /* An implied index of the table */
 
-  if( (pEnd==0 && pSelect==0) || db->mallocFailed ){
+  if( pEnd==0 && pSelect==0 ){
     return;
   }
+  assert( !db->mallocFailed );
   p = pParse->pNewTable;
   if( p==0 ) return;
 
@@ -93851,7 +94761,7 @@ SQLITE_PRIVATE void sqlite3EndTable(
       sqlite3TableAffinity(v, p, 0);
       sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);
       sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, addrInsLoop);
+      sqlite3VdbeGoto(v, addrInsLoop);
       sqlite3VdbeJumpHere(v, addrInsLoop);
       sqlite3VdbeAddOp1(v, OP_Close, 1);
     }
@@ -93948,6 +94858,7 @@ SQLITE_PRIVATE void sqlite3CreateView(
   Token *pBegin,     /* The CREATE token that begins the statement */
   Token *pName1,     /* The token that holds the name of the view */
   Token *pName2,     /* The token that holds the name of the view */
+  ExprList *pCNames, /* Optional list of view column names */
   Select *pSelect,   /* A SELECT statement that will become the new view */
   int isTemp,        /* TRUE for a TEMPORARY view */
   int noErr          /* Suppress error messages if VIEW already exists */
@@ -93963,22 +94874,15 @@ SQLITE_PRIVATE void sqlite3CreateView(
 
   if( pParse->nVar>0 ){
     sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
-    sqlite3SelectDelete(db, pSelect);
-    return;
+    goto create_view_fail;
   }
   sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
   p = pParse->pNewTable;
-  if( p==0 || pParse->nErr ){
-    sqlite3SelectDelete(db, pSelect);
-    return;
-  }
+  if( p==0 || pParse->nErr ) goto create_view_fail;
   sqlite3TwoPartName(pParse, pName1, pName2, &pName);
   iDb = sqlite3SchemaToIndex(db, p->pSchema);
   sqlite3FixInit(&sFix, pParse, iDb, "view", pName);
-  if( sqlite3FixSelect(&sFix, pSelect) ){
-    sqlite3SelectDelete(db, pSelect);
-    return;
-  }
+  if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;
 
   /* Make a copy of the entire SELECT statement that defines the view.
   ** This will force all the Expr.token.z values to be dynamically
@@ -93986,30 +94890,31 @@ SQLITE_PRIVATE void sqlite3CreateView(
   ** they will persist after the current sqlite3_exec() call returns.
   */
   p->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);
-  sqlite3SelectDelete(db, pSelect);
-  if( db->mallocFailed ){
-    return;
-  }
-  if( !db->init.busy ){
-    sqlite3ViewGetColumnNames(pParse, p);
-  }
+  p->pCheck = sqlite3ExprListDup(db, pCNames, EXPRDUP_REDUCE);
+  if( db->mallocFailed ) goto create_view_fail;
 
   /* Locate the end of the CREATE VIEW statement.  Make sEnd point to
   ** the end.
   */
   sEnd = pParse->sLastToken;
-  if( ALWAYS(sEnd.z[0]!=0) && sEnd.z[0]!=';' ){
+  assert( sEnd.z[0]!=0 );
+  if( sEnd.z[0]!=';' ){
     sEnd.z += sEnd.n;
   }
   sEnd.n = 0;
   n = (int)(sEnd.z - pBegin->z);
+  assert( n>0 );
   z = pBegin->z;
-  while( ALWAYS(n>0) && sqlite3Isspace(z[n-1]) ){ n--; }
+  while( sqlite3Isspace(z[n-1]) ){ n--; }
   sEnd.z = &z[n-1];
   sEnd.n = 1;
 
   /* Use sqlite3EndTable() to add the view to the SQLITE_MASTER table */
   sqlite3EndTable(pParse, 0, &sEnd, 0, 0);
+
+create_view_fail:
+  sqlite3SelectDelete(db, pSelect);
+  sqlite3ExprListDelete(db, pCNames);
   return;
 }
 #endif /* SQLITE_OMIT_VIEW */
@@ -94027,6 +94932,7 @@ SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){
   int n;            /* Temporarily holds the number of cursors assigned */
   sqlite3 *db = pParse->db;  /* Database connection for malloc errors */
   sqlite3_xauth xAuth;       /* Saved xAuth pointer */
+  u8 bEnabledLA;             /* Saved db->lookaside.bEnabled state */
 
   assert( pTable );
 
@@ -94072,40 +94978,46 @@ SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){
   ** statement that defines the view.
   */
   assert( pTable->pSelect );
-  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);
-  if( pSel ){
-    u8 enableLookaside = db->lookaside.bEnabled;
-    n = pParse->nTab;
-    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);
-    pTable->nCol = -1;
+  bEnabledLA = db->lookaside.bEnabled;
+  if( pTable->pCheck ){
     db->lookaside.bEnabled = 0;
+    sqlite3ColumnsFromExprList(pParse, pTable->pCheck, 
+                               &pTable->nCol, &pTable->aCol);
+  }else{
+    pSel = sqlite3SelectDup(db, pTable->pSelect, 0);
+    if( pSel ){
+      n = pParse->nTab;
+      sqlite3SrcListAssignCursors(pParse, pSel->pSrc);
+      pTable->nCol = -1;
+      db->lookaside.bEnabled = 0;
 #ifndef SQLITE_OMIT_AUTHORIZATION
-    xAuth = db->xAuth;
-    db->xAuth = 0;
-    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
-    db->xAuth = xAuth;
+      xAuth = db->xAuth;
+      db->xAuth = 0;
+      pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
+      db->xAuth = xAuth;
 #else
-    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
-#endif
-    db->lookaside.bEnabled = enableLookaside;
-    pParse->nTab = n;
-    if( pSelTab ){
-      assert( pTable->aCol==0 );
-      pTable->nCol = pSelTab->nCol;
-      pTable->aCol = pSelTab->aCol;
-      pSelTab->nCol = 0;
-      pSelTab->aCol = 0;
-      sqlite3DeleteTable(db, pSelTab);
-      assert( sqlite3SchemaMutexHeld(db, 0, pTable->pSchema) );
-      pTable->pSchema->schemaFlags |= DB_UnresetViews;
-    }else{
-      pTable->nCol = 0;
+      pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
+#endif
+      pParse->nTab = n;
+      if( pSelTab ){
+        assert( pTable->aCol==0 );
+        pTable->nCol = pSelTab->nCol;
+        pTable->aCol = pSelTab->aCol;
+        pSelTab->nCol = 0;
+        pSelTab->aCol = 0;
+        sqlite3DeleteTable(db, pSelTab);
+        assert( sqlite3SchemaMutexHeld(db, 0, pTable->pSchema) );
+      }else{
+        pTable->nCol = 0;
+        nErr++;
+      }
+      sqlite3SelectDelete(db, pSel);
+    } else {
       nErr++;
     }
-    sqlite3SelectDelete(db, pSel);
-  } else {
-    nErr++;
   }
+  db->lookaside.bEnabled = bEnabledLA;
+  pTable->pSchema->schemaFlags |= DB_UnresetViews;
 #endif /* SQLITE_OMIT_VIEW */
   return nErr;  
 }
@@ -94122,7 +95034,7 @@ static void sqliteViewResetAll(sqlite3 *db, int idx){
   for(i=sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i;i=sqliteHashNext(i)){
     Table *pTab = sqliteHashData(i);
     if( pTab->pSelect ){
-      sqliteDeleteColumnNames(db, pTab);
+      sqlite3DeleteColumnNames(db, pTab);
       pTab->aCol = 0;
       pTab->nCol = 0;
     }
@@ -94677,7 +95589,7 @@ static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){
   assert( pKey!=0 || db->mallocFailed || pParse->nErr );
   if( IsUniqueIndex(pIndex) && pKey!=0 ){
     int j2 = sqlite3VdbeCurrentAddr(v) + 3;
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, j2);
+    sqlite3VdbeGoto(v, j2);
     addr2 = sqlite3VdbeCurrentAddr(v);
     sqlite3VdbeAddOp4Int(v, OP_SorterCompare, iSorter, j2, regRecord,
                          pIndex->nKeyCol); VdbeCoverage(v);
@@ -94774,7 +95686,6 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
   int iDb;             /* Index of the database that is being written */
   Token *pName = 0;    /* Unqualified name of the index to create */
   struct ExprList_item *pListItem; /* For looping over pList */
-  const Column *pTabCol;           /* A column in the table */
   int nExtra = 0;                  /* Space allocated for zExtra[] */
   int nExtraCol;                   /* Number of extra columns needed */
   char *zExtra = 0;                /* Extra space after the Index object */
@@ -94929,11 +95840,16 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
   ** So create a fake list to simulate this.
   */
   if( pList==0 ){
-    pList = sqlite3ExprListAppend(pParse, 0, 0);
+    Token prevCol;
+    prevCol.z = pTab->aCol[pTab->nCol-1].zName;
+    prevCol.n = sqlite3Strlen30(prevCol.z);
+    pList = sqlite3ExprListAppend(pParse, 0,
+              sqlite3ExprAlloc(db, TK_ID, &prevCol, 0));
     if( pList==0 ) goto exit_create_index;
-    pList->a[0].zName = sqlite3DbStrDup(pParse->db,
-                                        pTab->aCol[pTab->nCol-1].zName);
-    pList->a[0].sortOrder = (u8)sortOrder;
+    assert( pList->nExpr==1 );
+    sqlite3ExprListSetSortOrder(pList, sortOrder);
+  }else{
+    sqlite3ExprListCheckLength(pParse, pList, "index");
   }
 
   /* Figure out how many bytes of space are required to store explicitly
@@ -94941,8 +95857,8 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
   */
   for(i=0; i<pList->nExpr; i++){
     Expr *pExpr = pList->a[i].pExpr;
-    if( pExpr ){
-      assert( pExpr->op==TK_COLLATE );
+    assert( pExpr!=0 );
+    if( pExpr->op==TK_COLLATE ){
       nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));
     }
   }
@@ -94983,35 +95899,54 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
     sortOrderMask = 0;    /* Ignore DESC */
   }
 
-  /* Scan the names of the columns of the table to be indexed and
-  ** load the column indices into the Index structure.  Report an error
-  ** if any column is not found.
+  /* Analyze the list of expressions that form the terms of the index and
+  ** report any errors.  In the common case where the expression is exactly
+  ** a table column, store that column in aiColumn[].  For general expressions,
+  ** populate pIndex->aColExpr and store XN_EXPR (-2) in aiColumn[].
   **
-  ** TODO:  Add a test to make sure that the same column is not named
-  ** more than once within the same index.  Only the first instance of
-  ** the column will ever be used by the optimizer.  Note that using the
-  ** same column more than once cannot be an error because that would 
-  ** break backwards compatibility - it needs to be a warning.
+  ** TODO: Issue a warning if two or more columns of the index are identical.
+  ** TODO: Issue a warning if the table primary key is used as part of the
+  ** index key.
   */
   for(i=0, pListItem=pList->a; i<pList->nExpr; i++, pListItem++){
-    const char *zColName = pListItem->zName;
-    int requestedSortOrder;
+    Expr *pCExpr;                  /* The i-th index expression */
+    int requestedSortOrder;        /* ASC or DESC on the i-th expression */
     char *zColl;                   /* Collation sequence name */
 
-    for(j=0, pTabCol=pTab->aCol; j<pTab->nCol; j++, pTabCol++){
-      if( sqlite3StrICmp(zColName, pTabCol->zName)==0 ) break;
-    }
-    if( j>=pTab->nCol ){
-      sqlite3ErrorMsg(pParse, "table %s has no column named %s",
-        pTab->zName, zColName);
-      pParse->checkSchema = 1;
-      goto exit_create_index;
+    sqlite3StringToId(pListItem->pExpr);
+    sqlite3ResolveSelfReference(pParse, pTab, NC_IdxExpr, pListItem->pExpr, 0);
+    if( pParse->nErr ) goto exit_create_index;
+    pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);
+    if( pCExpr->op!=TK_COLUMN ){
+      if( pTab==pParse->pNewTable ){
+        sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and "
+                                "UNIQUE constraints");
+        goto exit_create_index;
+      }
+      if( pIndex->aColExpr==0 ){
+        ExprList *pCopy = sqlite3ExprListDup(db, pList, 0);
+        pIndex->aColExpr = pCopy;
+        if( !db->mallocFailed ){
+          assert( pCopy!=0 );
+          pListItem = &pCopy->a[i];
+        }
+      }
+      j = XN_EXPR;
+      pIndex->aiColumn[i] = XN_EXPR;
+      pIndex->uniqNotNull = 0;
+    }else{
+      j = pCExpr->iColumn;
+      assert( j<=0x7fff );
+      if( j<0 ){
+        j = pTab->iPKey;
+      }else if( pTab->aCol[j].notNull==0 ){
+        pIndex->uniqNotNull = 0;
+      }
+      pIndex->aiColumn[i] = (i16)j;
     }
-    assert( j<=0x7fff );
-    pIndex->aiColumn[i] = (i16)j;
-    if( pListItem->pExpr ){
+    zColl = 0;
+    if( pListItem->pExpr->op==TK_COLLATE ){
       int nColl;
-      assert( pListItem->pExpr->op==TK_COLLATE );
       zColl = pListItem->pExpr->u.zToken;
       nColl = sqlite3Strlen30(zColl) + 1;
       assert( nExtra>=nColl );
@@ -95019,21 +95954,26 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
       zColl = zExtra;
       zExtra += nColl;
       nExtra -= nColl;
-    }else{
+    }else if( j>=0 ){
       zColl = pTab->aCol[j].zColl;
-      if( !zColl ) zColl = "BINARY";
     }
+    if( !zColl ) zColl = "BINARY";
     if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){
       goto exit_create_index;
     }
     pIndex->azColl[i] = zColl;
     requestedSortOrder = pListItem->sortOrder & sortOrderMask;
     pIndex->aSortOrder[i] = (u8)requestedSortOrder;
-    if( pTab->aCol[j].notNull==0 ) pIndex->uniqNotNull = 0;
   }
+
+  /* Append the table key to the end of the index.  For WITHOUT ROWID
+  ** tables (when pPk!=0) this will be the declared PRIMARY KEY.  For
+  ** normal tables (when pPk==0) this will be the rowid.
+  */
   if( pPk ){
     for(j=0; j<pPk->nKeyCol; j++){
       int x = pPk->aiColumn[j];
+      assert( x>=0 );
       if( hasColumn(pIndex->aiColumn, pIndex->nKeyCol, x) ){
         pIndex->nColumn--; 
       }else{
@@ -95045,7 +95985,7 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
     }
     assert( i==pIndex->nColumn );
   }else{
-    pIndex->aiColumn[i] = -1;
+    pIndex->aiColumn[i] = XN_ROWID;
     pIndex->azColl[i] = "BINARY";
   }
   sqlite3DefaultRowEst(pIndex);
@@ -95084,6 +96024,7 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
       for(k=0; k<pIdx->nKeyCol; k++){
         const char *z1;
         const char *z2;
+        assert( pIdx->aiColumn[k]>=0 );
         if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;
         z1 = pIdx->azColl[k];
         z2 = pIndex->azColl[k];
@@ -95115,6 +96056,7 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
   /* Link the new Index structure to its table and to the other
   ** in-memory database structures. 
   */
+  assert( pParse->nErr==0 );
   if( db->init.busy ){
     Index *p;
     assert( sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );
@@ -95144,7 +96086,7 @@ SQLITE_PRIVATE Index *sqlite3CreateIndex(
   ** has just been created, it contains no data and the index initialization
   ** step can be skipped.
   */
-  else if( pParse->nErr==0 && (HasRowid(pTab) || pTblName!=0) ){
+  else if( HasRowid(pTab) || pTblName!=0 ){
     Vdbe *v;
     char *zStmt;
     int iMem = ++pParse->nMem;
@@ -95604,7 +96546,8 @@ SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){
     sqlite3DbFree(db, pItem->zDatabase);
     sqlite3DbFree(db, pItem->zName);
     sqlite3DbFree(db, pItem->zAlias);
-    sqlite3DbFree(db, pItem->zIndexedBy);
+    if( pItem->fg.isIndexedBy ) sqlite3DbFree(db, pItem->u1.zIndexedBy);
+    if( pItem->fg.isTabFunc ) sqlite3ExprListDelete(db, pItem->u1.pFuncArg);
     sqlite3DeleteTable(db, pItem->pTab);
     sqlite3SelectDelete(db, pItem->pSelect);
     sqlite3ExprDelete(db, pItem->pOn);
@@ -95677,17 +96620,37 @@ SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pI
   assert( pIndexedBy!=0 );
   if( p && ALWAYS(p->nSrc>0) ){
     struct SrcList_item *pItem = &p->a[p->nSrc-1];
-    assert( pItem->notIndexed==0 && pItem->zIndexedBy==0 );
+    assert( pItem->fg.notIndexed==0 );
+    assert( pItem->fg.isIndexedBy==0 );
+    assert( pItem->fg.isTabFunc==0 );
     if( pIndexedBy->n==1 && !pIndexedBy->z ){
       /* A "NOT INDEXED" clause was supplied. See parse.y 
       ** construct "indexed_opt" for details. */
-      pItem->notIndexed = 1;
+      pItem->fg.notIndexed = 1;
     }else{
-      pItem->zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);
+      pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);
+      pItem->fg.isIndexedBy = (pItem->u1.zIndexedBy!=0);
     }
   }
 }
 
+/*
+** Add the list of function arguments to the SrcList entry for a
+** table-valued-function.
+*/
+SQLITE_PRIVATE void sqlite3SrcListFuncArgs(Parse *pParse, SrcList *p, ExprList *pList){
+  if( p && pList ){
+    struct SrcList_item *pItem = &p->a[p->nSrc-1];
+    assert( pItem->fg.notIndexed==0 );
+    assert( pItem->fg.isIndexedBy==0 );
+    assert( pItem->fg.isTabFunc==0 );
+    pItem->u1.pFuncArg = pList;
+    pItem->fg.isTabFunc = 1;
+  }else{
+    sqlite3ExprListDelete(pParse->db, pList);
+  }
+}
+
 /*
 ** When building up a FROM clause in the parser, the join operator
 ** is initially attached to the left operand.  But the code generator
@@ -95707,9 +96670,9 @@ SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList *p){
   if( p ){
     int i;
     for(i=p->nSrc-1; i>0; i--){
-      p->a[i].jointype = p->a[i-1].jointype;
+      p->a[i].fg.jointype = p->a[i-1].fg.jointype;
     }
-    p->a[0].jointype = 0;
+    p->a[0].fg.jointype = 0;
   }
 }
 
@@ -95953,12 +96916,16 @@ SQLITE_PRIVATE void sqlite3UniqueConstraint(
   Table *pTab = pIdx->pTable;
 
   sqlite3StrAccumInit(&errMsg, pParse->db, 0, 0, 200);
-  for(j=0; j<pIdx->nKeyCol; j++){
-    char *zCol = pTab->aCol[pIdx->aiColumn[j]].zName;
-    if( j ) sqlite3StrAccumAppend(&errMsg, ", ", 2);
-    sqlite3StrAccumAppendAll(&errMsg, pTab->zName);
-    sqlite3StrAccumAppend(&errMsg, ".", 1);
-    sqlite3StrAccumAppendAll(&errMsg, zCol);
+  if( pIdx->aColExpr ){
+    sqlite3XPrintf(&errMsg, 0, "index '%q'", pIdx->zName);
+  }else{
+    for(j=0; j<pIdx->nKeyCol; j++){
+      char *zCol;
+      assert( pIdx->aiColumn[j]>=0 );
+      zCol = pTab->aCol[pIdx->aiColumn[j]].zName;
+      if( j ) sqlite3StrAccumAppend(&errMsg, ", ", 2);
+      sqlite3XPrintf(&errMsg, 0, "%s.%s", pTab->zName, zCol);
+    }
   }
   zErr = sqlite3StrAccumFinish(&errMsg);
   sqlite3HaltConstraint(pParse, 
@@ -96203,7 +97170,7 @@ SQLITE_PRIVATE With *sqlite3WithAdd(
     pNew->a[pNew->nCte].pSelect = pQuery;
     pNew->a[pNew->nCte].pCols = pArglist;
     pNew->a[pNew->nCte].zName = zName;
-    pNew->a[pNew->nCte].zErr = 0;
+    pNew->a[pNew->nCte].zCteErr = 0;
     pNew->nCte++;
   }
 
@@ -96946,7 +97913,7 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
   int iDb;               /* Database number */
   int memCnt = -1;       /* Memory cell used for change counting */
   int rcauth;            /* Value returned by authorization callback */
-  int okOnePass;         /* True for one-pass algorithm without the FIFO */
+  int eOnePass;          /* ONEPASS_OFF or _SINGLE or _MULTI */
   int aiCurOnePass[2];   /* The write cursors opened by WHERE_ONEPASS */
   u8 *aToOpen = 0;       /* Open cursor iTabCur+j if aToOpen[j] is true */
   Index *pPk;            /* The PRIMARY KEY index on the table */
@@ -96958,12 +97925,12 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
   int iRowSet = 0;       /* Register for rowset of rows to delete */
   int addrBypass = 0;    /* Address of jump over the delete logic */
   int addrLoop = 0;      /* Top of the delete loop */
-  int addrDelete = 0;    /* Jump directly to the delete logic */
   int addrEphOpen = 0;   /* Instruction to open the Ephemeral table */
  
 #ifndef SQLITE_OMIT_TRIGGER
   int isView;                  /* True if attempting to delete from a view */
   Trigger *pTrigger;           /* List of table triggers, if required */
+  int bComplex;                /* True if there are either triggers or FKs */
 #endif
 
   memset(&sContext, 0, sizeof(sContext));
@@ -96987,9 +97954,11 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
 #ifndef SQLITE_OMIT_TRIGGER
   pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);
   isView = pTab->pSelect!=0;
+  bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);
 #else
 # define pTrigger 0
 # define isView 0
+# define bComplex 0
 #endif
 #ifdef SQLITE_OMIT_VIEW
 # undef isView
@@ -97070,8 +98039,10 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
   ** It is easier just to erase the whole table. Prior to version 3.6.5,
   ** this optimization caused the row change count (the value returned by 
   ** API function sqlite3_count_changes) to be set incorrectly.  */
-  if( rcauth==SQLITE_OK && pWhere==0 && !pTrigger && !IsVirtual(pTab) 
-   && 0==sqlite3FkRequired(pParse, pTab, 0, 0)
+  if( rcauth==SQLITE_OK
+   && pWhere==0
+   && !bComplex
+   && !IsVirtual(pTab)
   ){
     assert( !isView );
     sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);
@@ -97086,6 +98057,8 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
   }else
 #endif /* SQLITE_OMIT_TRUNCATE_OPTIMIZATION */
   {
+    u16 wcf = WHERE_ONEPASS_DESIRED|WHERE_DUPLICATES_OK;
+    wcf |= (bComplex ? 0 : WHERE_ONEPASS_MULTIROW);
     if( HasRowid(pTab) ){
       /* For a rowid table, initialize the RowSet to an empty set */
       pPk = 0;
@@ -97106,13 +98079,18 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
     }
   
     /* Construct a query to find the rowid or primary key for every row
-    ** to be deleted, based on the WHERE clause.
+    ** to be deleted, based on the WHERE clause. Set variable eOnePass
+    ** to indicate the strategy used to implement this delete:
+    **
+    **  ONEPASS_OFF:    Two-pass approach - use a FIFO for rowids/PK values.
+    **  ONEPASS_SINGLE: One-pass approach - at most one row deleted.
+    **  ONEPASS_MULTI:  One-pass approach - any number of rows may be deleted.
     */
-    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, 
-                               WHERE_ONEPASS_DESIRED|WHERE_DUPLICATES_OK,
-                               iTabCur+1);
+    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, wcf, iTabCur+1);
     if( pWInfo==0 ) goto delete_from_cleanup;
-    okOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
+    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
+    assert( IsVirtual(pTab)==0 || eOnePass!=ONEPASS_MULTI );
+    assert( IsVirtual(pTab) || bComplex || eOnePass!=ONEPASS_OFF );
   
     /* Keep track of the number of rows to be deleted */
     if( db->flags & SQLITE_CountRows ){
@@ -97122,6 +98100,7 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
     /* Extract the rowid or primary key for the current row */
     if( pPk ){
       for(i=0; i<nPk; i++){
+        assert( pPk->aiColumn[i]>=0 );
         sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur,
                                         pPk->aiColumn[i], iPk+i);
       }
@@ -97132,11 +98111,10 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
       if( iKey>pParse->nMem ) pParse->nMem = iKey;
     }
   
-    if( okOnePass ){
-      /* For ONEPASS, no need to store the rowid/primary-key.  There is only
+    if( eOnePass!=ONEPASS_OFF ){
+      /* For ONEPASS, no need to store the rowid/primary-key. There is only
       ** one, so just keep it in its register(s) and fall through to the
-      ** delete code.
-      */
+      ** delete code.  */
       nKey = nPk; /* OP_Found will use an unpacked key */
       aToOpen = sqlite3DbMallocRaw(db, nIdx+2);
       if( aToOpen==0 ){
@@ -97148,27 +98126,27 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
       if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iTabCur] = 0;
       if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iTabCur] = 0;
       if( addrEphOpen ) sqlite3VdbeChangeToNoop(v, addrEphOpen);
-      addrDelete = sqlite3VdbeAddOp0(v, OP_Goto); /* Jump to DELETE logic */
-    }else if( pPk ){
-      /* Construct a composite key for the row to be deleted and remember it */
-      iKey = ++pParse->nMem;
-      nKey = 0;   /* Zero tells OP_Found to use a composite key */
-      sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, iKey,
-                        sqlite3IndexAffinityStr(v, pPk), nPk);
-      sqlite3VdbeAddOp2(v, OP_IdxInsert, iEphCur, iKey);
     }else{
-      /* Get the rowid of the row to be deleted and remember it in the RowSet */
-      nKey = 1;  /* OP_Seek always uses a single rowid */
-      sqlite3VdbeAddOp2(v, OP_RowSetAdd, iRowSet, iKey);
+      if( pPk ){
+        /* Add the PK key for this row to the temporary table */
+        iKey = ++pParse->nMem;
+        nKey = 0;   /* Zero tells OP_Found to use a composite key */
+        sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, iKey,
+            sqlite3IndexAffinityStr(pParse->db, pPk), nPk);
+        sqlite3VdbeAddOp2(v, OP_IdxInsert, iEphCur, iKey);
+      }else{
+        /* Add the rowid of the row to be deleted to the RowSet */
+        nKey = 1;  /* OP_Seek always uses a single rowid */
+        sqlite3VdbeAddOp2(v, OP_RowSetAdd, iRowSet, iKey);
+      }
     }
   
-    /* End of the WHERE loop */
-    sqlite3WhereEnd(pWInfo);
-    if( okOnePass ){
-      /* Bypass the delete logic below if the WHERE loop found zero rows */
+    /* If this DELETE cannot use the ONEPASS strategy, this is the 
+    ** end of the WHERE loop */
+    if( eOnePass!=ONEPASS_OFF ){
       addrBypass = sqlite3VdbeMakeLabel(v);
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, addrBypass);
-      sqlite3VdbeJumpHere(v, addrDelete);
+    }else{
+      sqlite3WhereEnd(pWInfo);
     }
   
     /* Unless this is a view, open cursors for the table we are 
@@ -97177,21 +98155,24 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
     ** triggers.
     */
     if( !isView ){
+      int iAddrOnce = 0;
+      if( eOnePass==ONEPASS_MULTI ){
+        iAddrOnce = sqlite3CodeOnce(pParse); VdbeCoverage(v);
+      }
       testcase( IsVirtual(pTab) );
       sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, iTabCur, aToOpen,
                                  &iDataCur, &iIdxCur);
       assert( pPk || IsVirtual(pTab) || iDataCur==iTabCur );
       assert( pPk || IsVirtual(pTab) || iIdxCur==iDataCur+1 );
+      if( eOnePass==ONEPASS_MULTI ) sqlite3VdbeJumpHere(v, iAddrOnce);
     }
   
     /* Set up a loop over the rowids/primary-keys that were found in the
     ** where-clause loop above.
     */
-    if( okOnePass ){
-      /* Just one row.  Hence the top-of-loop is a no-op */
+    if( eOnePass!=ONEPASS_OFF ){
       assert( nKey==nPk );  /* OP_Found will use an unpacked key */
-      assert( !IsVirtual(pTab) );
-      if( aToOpen[iDataCur-iTabCur] ){
+      if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){
         assert( pPk!=0 || pTab->pSelect!=0 );
         sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, addrBypass, iKey, nKey);
         VdbeCoverage(v);
@@ -97213,23 +98194,32 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
       sqlite3VtabMakeWritable(pParse, pTab);
       sqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iKey, pVTab, P4_VTAB);
       sqlite3VdbeChangeP5(v, OE_Abort);
+      assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );
       sqlite3MayAbort(pParse);
+      if( eOnePass==ONEPASS_SINGLE && sqlite3IsToplevel(pParse) ){
+        pParse->isMultiWrite = 0;
+      }
     }else
 #endif
     {
       int count = (pParse->nested==0);    /* True to count changes */
+      int iIdxNoSeek = -1;
+      if( bComplex==0 && aiCurOnePass[1]!=iDataCur ){
+        iIdxNoSeek = aiCurOnePass[1];
+      }
       sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
-                               iKey, nKey, count, OE_Default, okOnePass);
+          iKey, nKey, count, OE_Default, eOnePass, iIdxNoSeek);
     }
   
     /* End of the loop over all rowids/primary-keys. */
-    if( okOnePass ){
+    if( eOnePass!=ONEPASS_OFF ){
       sqlite3VdbeResolveLabel(v, addrBypass);
+      sqlite3WhereEnd(pWInfo);
     }else if( pPk ){
       sqlite3VdbeAddOp2(v, OP_Next, iEphCur, addrLoop+1); VdbeCoverage(v);
       sqlite3VdbeJumpHere(v, addrLoop);
     }else{
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, addrLoop);
+      sqlite3VdbeGoto(v, addrLoop);
       sqlite3VdbeJumpHere(v, addrLoop);
     }     
   
@@ -97296,6 +98286,25 @@ SQLITE_PRIVATE void sqlite3DeleteFrom(
 **       sequence of nPk memory cells starting at iPk.  If nPk==0 that means
 **       that a search record formed from OP_MakeRecord is contained in the
 **       single memory location iPk.
+**
+** eMode:
+**   Parameter eMode may be passed either ONEPASS_OFF (0), ONEPASS_SINGLE, or
+**   ONEPASS_MULTI.  If eMode is not ONEPASS_OFF, then the cursor
+**   iDataCur already points to the row to delete. If eMode is ONEPASS_OFF
+**   then this function must seek iDataCur to the entry identified by iPk
+**   and nPk before reading from it.
+**
+**   If eMode is ONEPASS_MULTI, then this call is being made as part
+**   of a ONEPASS delete that affects multiple rows. In this case, if 
+**   iIdxNoSeek is a valid cursor number (>=0), then its position should
+**   be preserved following the delete operation. Or, if iIdxNoSeek is not
+**   a valid cursor number, the position of iDataCur should be preserved
+**   instead.
+**
+** iIdxNoSeek:
+**   If iIdxNoSeek is a valid cursor number (>=0), then it identifies an
+**   index cursor (from within array of cursors starting at iIdxCur) that
+**   already points to the index entry to be deleted.
 */
 SQLITE_PRIVATE void sqlite3GenerateRowDelete(
   Parse *pParse,     /* Parsing context */
@@ -97307,7 +98316,8 @@ SQLITE_PRIVATE void sqlite3GenerateRowDelete(
   i16 nPk,           /* Number of PRIMARY KEY memory cells */
   u8 count,          /* If non-zero, increment the row change counter */
   u8 onconf,         /* Default ON CONFLICT policy for triggers */
-  u8 bNoSeek         /* iDataCur is already pointing to the row to delete */
+  u8 eMode,          /* ONEPASS_OFF, _SINGLE, or _MULTI.  See above */
+  int iIdxNoSeek     /* Cursor number of cursor that does not need seeking */
 ){
   Vdbe *v = pParse->pVdbe;        /* Vdbe */
   int iOld = 0;                   /* First register in OLD.* array */
@@ -97324,7 +98334,7 @@ SQLITE_PRIVATE void sqlite3GenerateRowDelete(
   ** not attempt to delete it or fire any DELETE triggers.  */
   iLabel = sqlite3VdbeMakeLabel(v);
   opSeek = HasRowid(pTab) ? OP_NotExists : OP_NotFound;
-  if( !bNoSeek ){
+  if( eMode==ONEPASS_OFF ){
     sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
     VdbeCoverageIf(v, opSeek==OP_NotExists);
     VdbeCoverageIf(v, opSeek==OP_NotFound);
@@ -97384,11 +98394,15 @@ SQLITE_PRIVATE void sqlite3GenerateRowDelete(
   ** a view (in which case the only effect of the DELETE statement is to
   ** fire the INSTEAD OF triggers).  */ 
   if( pTab->pSelect==0 ){
-    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, 0);
+    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,iIdxNoSeek);
     sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, (count?OPFLAG_NCHANGE:0));
     if( count ){
       sqlite3VdbeChangeP4(v, -1, pTab->zName, P4_TRANSIENT);
     }
+    if( iIdxNoSeek>=0 ){
+      sqlite3VdbeAddOp1(v, OP_Delete, iIdxNoSeek);
+    }
+    sqlite3VdbeChangeP5(v, eMode==ONEPASS_MULTI);
   }
 
   /* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to
@@ -97431,7 +98445,8 @@ SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(
   Table *pTab,       /* Table containing the row to be deleted */
   int iDataCur,      /* Cursor of table holding data. */
   int iIdxCur,       /* First index cursor */
-  int *aRegIdx       /* Only delete if aRegIdx!=0 && aRegIdx[i]>0 */
+  int *aRegIdx,      /* Only delete if aRegIdx!=0 && aRegIdx[i]>0 */
+  int iIdxNoSeek     /* Do not delete from this cursor */
 ){
   int i;             /* Index loop counter */
   int r1 = -1;       /* Register holding an index key */
@@ -97447,11 +98462,12 @@ SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(
     assert( iIdxCur+i!=iDataCur || pPk==pIdx );
     if( aRegIdx!=0 && aRegIdx[i]==0 ) continue;
     if( pIdx==pPk ) continue;
+    if( iIdxCur+i==iIdxNoSeek ) continue;
     VdbeModuleComment((v, "GenRowIdxDel for %s", pIdx->zName));
     r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1,
-                                 &iPartIdxLabel, pPrior, r1);
+        &iPartIdxLabel, pPrior, r1);
     sqlite3VdbeAddOp3(v, OP_IdxDelete, iIdxCur+i, r1,
-                      pIdx->uniqNotNull ? pIdx->nKeyCol : pIdx->nColumn);
+        pIdx->uniqNotNull ? pIdx->nKeyCol : pIdx->nColumn);
     sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
     pPrior = pIdx;
   }
@@ -97500,14 +98516,13 @@ SQLITE_PRIVATE int sqlite3GenerateIndexKey(
 ){
   Vdbe *v = pParse->pVdbe;
   int j;
-  Table *pTab = pIdx->pTable;
   int regBase;
   int nCol;
 
   if( piPartIdxLabel ){
     if( pIdx->pPartIdxWhere ){
       *piPartIdxLabel = sqlite3VdbeMakeLabel(v);
-      pParse->iPartIdxTab = iDataCur;
+      pParse->iSelfTab = iDataCur;
       sqlite3ExprCachePush(pParse);
       sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel, 
                             SQLITE_JUMPIFNULL);
@@ -97519,9 +98534,14 @@ SQLITE_PRIVATE int sqlite3GenerateIndexKey(
   regBase = sqlite3GetTempRange(pParse, nCol);
   if( pPrior && (regBase!=regPrior || pPrior->pPartIdxWhere) ) pPrior = 0;
   for(j=0; j<nCol; j++){
-    if( pPrior && pPrior->aiColumn[j]==pIdx->aiColumn[j] ) continue;
-    sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, pIdx->aiColumn[j],
-                                    regBase+j);
+    if( pPrior
+     && pPrior->aiColumn[j]==pIdx->aiColumn[j]
+     && pPrior->aiColumn[j]!=XN_EXPR
+    ){
+      /* This column was already computed by the previous index */
+      continue;
+    }
+    sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase+j);
     /* If the column affinity is REAL but the number is an integer, then it
     ** might be stored in the table as an integer (using a compact
     ** representation) then converted to REAL by an OP_RealAffinity opcode.
@@ -99290,15 +100310,15 @@ SQLITE_PRIVATE void sqlite3RegisterGlobalFunctions(void){
     VFUNCTION(random,            0, 0, 0, randomFunc       ),
     VFUNCTION(randomblob,        1, 0, 0, randomBlob       ),
     FUNCTION(nullif,             2, 0, 1, nullifFunc       ),
-    FUNCTION(sqlite_version,     0, 0, 0, versionFunc      ),
-    FUNCTION(sqlite_source_id,   0, 0, 0, sourceidFunc     ),
+    DFUNCTION(sqlite_version,    0, 0, 0, versionFunc      ),
+    DFUNCTION(sqlite_source_id,  0, 0, 0, sourceidFunc     ),
     FUNCTION(sqlite_log,         2, 0, 0, errlogFunc       ),
 #if SQLITE_USER_AUTHENTICATION
     FUNCTION(sqlite_crypt,       2, 0, 0, sqlite3CryptFunc ),
 #endif
 #ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
-    FUNCTION(sqlite_compileoption_used,1, 0, 0, compileoptionusedFunc  ),
-    FUNCTION(sqlite_compileoption_get, 1, 0, 0, compileoptiongetFunc  ),
+    DFUNCTION(sqlite_compileoption_used,1, 0, 0, compileoptionusedFunc  ),
+    DFUNCTION(sqlite_compileoption_get, 1, 0, 0, compileoptiongetFunc  ),
 #endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */
     FUNCTION(quote,              1, 0, 0, quoteFunc        ),
     VFUNCTION(last_insert_rowid, 0, 0, 0, last_insert_rowid),
@@ -99310,8 +100330,8 @@ SQLITE_PRIVATE void sqlite3RegisterGlobalFunctions(void){
     FUNCTION(soundex,            1, 0, 0, soundexFunc      ),
   #endif
   #ifndef SQLITE_OMIT_LOAD_EXTENSION
-    FUNCTION(load_extension,     1, 0, 0, loadExt          ),
-    FUNCTION(load_extension,     2, 0, 0, loadExt          ),
+    VFUNCTION(load_extension,    1, 0, 0, loadExt          ),
+    VFUNCTION(load_extension,    2, 0, 0, loadExt          ),
   #endif
     AGGREGATE(sum,               1, 0, 0, sumStep,         sumFinalize    ),
     AGGREGATE(total,             1, 0, 0, sumStep,         totalFinalize    ),
@@ -99604,6 +100624,8 @@ SQLITE_PRIVATE int sqlite3FkLocateIndex(
           char *zDfltColl;                  /* Def. collation for column */
           char *zIdxCol;                    /* Name of indexed column */
 
+          if( iCol<0 ) break; /* No foreign keys against expression indexes */
+
           /* If the index uses a collation sequence that is different from
           ** the default collation sequence for the column, this index is
           ** unusable. Bail out early in this case.  */
@@ -99726,7 +100748,7 @@ static void fkLookupParent(
   
       sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenRead);
       sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, regTemp); VdbeCoverage(v);
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, iOk);
+      sqlite3VdbeGoto(v, iOk);
       sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
       sqlite3VdbeJumpHere(v, iMustBeInt);
       sqlite3ReleaseTempReg(pParse, regTemp);
@@ -99756,6 +100778,7 @@ static void fkLookupParent(
         for(i=0; i<nCol; i++){
           int iChild = aiCol[i]+1+regData;
           int iParent = pIdx->aiColumn[i]+1+regData;
+          assert( pIdx->aiColumn[i]>=0 );
           assert( aiCol[i]!=pTab->iPKey );
           if( pIdx->aiColumn[i]==pTab->iPKey ){
             /* The parent key is a composite key that includes the IPK column */
@@ -99764,11 +100787,11 @@ static void fkLookupParent(
           sqlite3VdbeAddOp3(v, OP_Ne, iChild, iJump, iParent); VdbeCoverage(v);
           sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL);
         }
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, iOk);
+        sqlite3VdbeGoto(v, iOk);
       }
   
       sqlite3VdbeAddOp4(v, OP_MakeRecord, regTemp, nCol, regRec,
-                        sqlite3IndexAffinityStr(v,pIdx), nCol);
+                        sqlite3IndexAffinityStr(pParse->db,pIdx), nCol);
       sqlite3VdbeAddOp4Int(v, OP_Found, iCur, iOk, regRec, 0); VdbeCoverage(v);
   
       sqlite3ReleaseTempReg(pParse, regRec);
@@ -99964,6 +100987,7 @@ static void fkScanChildren(
       assert( pIdx!=0 );
       for(i=0; i<pPk->nKeyCol; i++){
         i16 iCol = pIdx->aiColumn[i];
+        assert( iCol>=0 );
         pLeft = exprTableRegister(pParse, pTab, regData, iCol);
         pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, iCol);
         pEq = sqlite3PExpr(pParse, TK_EQ, pLeft, pRight, 0);
@@ -100283,6 +101307,7 @@ SQLITE_PRIVATE void sqlite3FkCheck(
       if( aiCol[i]==pTab->iPKey ){
         aiCol[i] = -1;
       }
+      assert( pIdx==0 || pIdx->aiColumn[i]>=0 );
 #ifndef SQLITE_OMIT_AUTHORIZATION
       /* Request permission to read the parent key columns. If the 
       ** authorization callback returns SQLITE_IGNORE, behave as if any
@@ -100414,7 +101439,10 @@ SQLITE_PRIVATE u32 sqlite3FkOldmask(
       Index *pIdx = 0;
       sqlite3FkLocateIndex(pParse, pTab, p, &pIdx, 0);
       if( pIdx ){
-        for(i=0; i<pIdx->nKeyCol; i++) mask |= COLUMN_MASK(pIdx->aiColumn[i]);
+        for(i=0; i<pIdx->nKeyCol; i++){
+          assert( pIdx->aiColumn[i]>=0 );
+          mask |= COLUMN_MASK(pIdx->aiColumn[i]);
+        }
       }
     }
   }
@@ -100537,6 +101565,7 @@ static Trigger *fkActionTrigger(
       iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
       assert( iFromCol>=0 );
       assert( pIdx!=0 || (pTab->iPKey>=0 && pTab->iPKey<pTab->nCol) );
+      assert( pIdx==0 || pIdx->aiColumn[i]>=0 );
       tToCol.z = pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zName;
       tFromCol.z = pFKey->pFrom->aCol[iFromCol].zName;
 
@@ -100825,7 +101854,7 @@ SQLITE_PRIVATE void sqlite3OpenTable(
 ** is managed along with the rest of the Index structure. It will be
 ** released when sqlite3DeleteIndex() is called.
 */
-SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){
+SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx){
   if( !pIdx->zColAff ){
     /* The first time a column affinity string for a particular index is
     ** required, it is allocated and populated here. It is then stored as
@@ -100837,7 +101866,6 @@ SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){
     */
     int n;
     Table *pTab = pIdx->pTable;
-    sqlite3 *db = sqlite3VdbeDb(v);
     pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);
     if( !pIdx->zColAff ){
       db->mallocFailed = 1;
@@ -100845,7 +101873,18 @@ SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){
     }
     for(n=0; n<pIdx->nColumn; n++){
       i16 x = pIdx->aiColumn[n];
-      pIdx->zColAff[n] = x<0 ? SQLITE_AFF_INTEGER : pTab->aCol[x].affinity;
+      if( x>=0 ){
+        pIdx->zColAff[n] = pTab->aCol[x].affinity;
+      }else if( x==XN_ROWID ){
+        pIdx->zColAff[n] = SQLITE_AFF_INTEGER;
+      }else{
+        char aff;
+        assert( x==XN_EXPR );
+        assert( pIdx->aColExpr!=0 );
+        aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);
+        if( aff==0 ) aff = SQLITE_AFF_BLOB;
+        pIdx->zColAff[n] = aff;
+      }
     }
     pIdx->zColAff[n] = 0;
   }
@@ -101006,7 +102045,7 @@ SQLITE_PRIVATE void sqlite3AutoincrementBegin(Parse *pParse){
   /* This routine is never called during trigger-generation.  It is
   ** only called from the top-level */
   assert( pParse->pTriggerTab==0 );
-  assert( pParse==sqlite3ParseToplevel(pParse) );
+  assert( sqlite3IsToplevel(pParse) );
 
   assert( v );   /* We failed long ago if this is not so */
   for(p = pParse->pAinc; p; p = p->pNext){
@@ -101016,14 +102055,14 @@ SQLITE_PRIVATE void sqlite3AutoincrementBegin(Parse *pParse){
     sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenRead);
     sqlite3VdbeAddOp3(v, OP_Null, 0, memId, memId+1);
     addr = sqlite3VdbeCurrentAddr(v);
-    sqlite3VdbeAddOp4(v, OP_String8, 0, memId-1, 0, p->pTab->zName, 0);
+    sqlite3VdbeLoadString(v, memId-1, p->pTab->zName);
     sqlite3VdbeAddOp2(v, OP_Rewind, 0, addr+9); VdbeCoverage(v);
     sqlite3VdbeAddOp3(v, OP_Column, 0, 0, memId);
     sqlite3VdbeAddOp3(v, OP_Ne, memId-1, addr+7, memId); VdbeCoverage(v);
     sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL);
     sqlite3VdbeAddOp2(v, OP_Rowid, 0, memId+1);
     sqlite3VdbeAddOp3(v, OP_Column, 0, 1, memId);
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, addr+9);
+    sqlite3VdbeGoto(v, addr+9);
     sqlite3VdbeAddOp2(v, OP_Next, 0, addr+2); VdbeCoverage(v);
     sqlite3VdbeAddOp2(v, OP_Integer, 0, memId);
     sqlite3VdbeAddOp0(v, OP_Close);
@@ -101059,16 +102098,16 @@ SQLITE_PRIVATE void sqlite3AutoincrementEnd(Parse *pParse){
   assert( v );
   for(p = pParse->pAinc; p; p = p->pNext){
     Db *pDb = &db->aDb[p->iDb];
-    int j1;
+    int addr1;
     int iRec;
     int memId = p->regCtr;
 
     iRec = sqlite3GetTempReg(pParse);
     assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );
     sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenWrite);
-    j1 = sqlite3VdbeAddOp1(v, OP_NotNull, memId+1); VdbeCoverage(v);
+    addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, memId+1); VdbeCoverage(v);
     sqlite3VdbeAddOp2(v, OP_NewRowid, 0, memId+1);
-    sqlite3VdbeJumpHere(v, j1);
+    sqlite3VdbeJumpHere(v, addr1);
     sqlite3VdbeAddOp3(v, OP_MakeRecord, memId-1, 2, iRec);
     sqlite3VdbeAddOp3(v, OP_Insert, 0, iRec, memId+1);
     sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
@@ -101447,7 +102486,7 @@ SQLITE_PRIVATE void sqlite3Insert(
       sqlite3VdbeAddOp3(v, OP_MakeRecord, regFromSelect, nColumn, regRec);
       sqlite3VdbeAddOp2(v, OP_NewRowid, srcTab, regTempRowid);
       sqlite3VdbeAddOp3(v, OP_Insert, srcTab, regRec, regTempRowid);
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, addrL);
+      sqlite3VdbeGoto(v, addrL);
       sqlite3VdbeJumpHere(v, addrL);
       sqlite3ReleaseTempReg(pParse, regRec);
       sqlite3ReleaseTempReg(pParse, regTempRowid);
@@ -101461,11 +102500,13 @@ SQLITE_PRIVATE void sqlite3Insert(
     sNC.pParse = pParse;
     srcTab = -1;
     assert( useTempTable==0 );
-    nColumn = pList ? pList->nExpr : 0;
-    for(i=0; i<nColumn; i++){
-      if( sqlite3ResolveExprNames(&sNC, pList->a[i].pExpr) ){
+    if( pList ){
+      nColumn = pList->nExpr;
+      if( sqlite3ResolveExprListNames(&sNC, pList) ){
         goto insert_cleanup;
       }
+    }else{
+      nColumn = 0;
     }
   }
 
@@ -101558,7 +102599,7 @@ SQLITE_PRIVATE void sqlite3Insert(
     if( ipkColumn<0 ){
       sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);
     }else{
-      int j1;
+      int addr1;
       assert( !withoutRowid );
       if( useTempTable ){
         sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regCols);
@@ -101566,9 +102607,9 @@ SQLITE_PRIVATE void sqlite3Insert(
         assert( pSelect==0 );  /* Otherwise useTempTable is true */
         sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);
       }
-      j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regCols); VdbeCoverage(v);
+      addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regCols); VdbeCoverage(v);
       sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);
-      sqlite3VdbeJumpHere(v, j1);
+      sqlite3VdbeJumpHere(v, addr1);
       sqlite3VdbeAddOp1(v, OP_MustBeInt, regCols); VdbeCoverage(v);
     }
 
@@ -101642,14 +102683,14 @@ SQLITE_PRIVATE void sqlite3Insert(
       ** to generate a unique primary key value.
       */
       if( !appendFlag ){
-        int j1;
+        int addr1;
         if( !IsVirtual(pTab) ){
-          j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid); VdbeCoverage(v);
+          addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid); VdbeCoverage(v);
           sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);
-          sqlite3VdbeJumpHere(v, j1);
+          sqlite3VdbeJumpHere(v, addr1);
         }else{
-          j1 = sqlite3VdbeCurrentAddr(v);
-          sqlite3VdbeAddOp2(v, OP_IsNull, regRowid, j1+2); VdbeCoverage(v);
+          addr1 = sqlite3VdbeCurrentAddr(v);
+          sqlite3VdbeAddOp2(v, OP_IsNull, regRowid, addr1+2); VdbeCoverage(v);
         }
         sqlite3VdbeAddOp1(v, OP_MustBeInt, regRowid); VdbeCoverage(v);
       }
@@ -101746,7 +102787,7 @@ SQLITE_PRIVATE void sqlite3Insert(
     sqlite3VdbeJumpHere(v, addrInsTop);
     sqlite3VdbeAddOp1(v, OP_Close, srcTab);
   }else if( pSelect ){
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrCont);
+    sqlite3VdbeGoto(v, addrCont);
     sqlite3VdbeJumpHere(v, addrInsTop);
   }
 
@@ -101903,7 +102944,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
   int ix;              /* Index loop counter */
   int nCol;            /* Number of columns */
   int onError;         /* Conflict resolution strategy */
-  int j1;              /* Address of jump instruction */
+  int addr1;           /* Address of jump instruction */
   int seenReplace = 0; /* True if REPLACE is used to resolve INT PK conflict */
   int nPkField;        /* Number of fields in PRIMARY KEY. 1 for ROWID tables */
   int ipkTop = 0;      /* Top of the rowid change constraint check */
@@ -101974,9 +103015,10 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
       }
       default: {
         assert( onError==OE_Replace );
-        j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regNewData+1+i); VdbeCoverage(v);
+        addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regNewData+1+i);
+           VdbeCoverage(v);
         sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regNewData+1+i);
-        sqlite3VdbeJumpHere(v, j1);
+        sqlite3VdbeJumpHere(v, addr1);
         break;
       }
     }
@@ -101993,7 +103035,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
       int allOk = sqlite3VdbeMakeLabel(v);
       sqlite3ExprIfTrue(pParse, pCheck->a[i].pExpr, allOk, SQLITE_JUMPIFNULL);
       if( onError==OE_Ignore ){
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest);
+        sqlite3VdbeGoto(v, ignoreDest);
       }else{
         char *zName = pCheck->a[i].zName;
         if( zName==0 ) zName = pTab->zName;
@@ -102091,17 +103133,20 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
         if( pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0) ){
           sqlite3MultiWrite(pParse);
           sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
-                                   regNewData, 1, 0, OE_Replace, 1);
-        }else if( pTab->pIndex ){
-          sqlite3MultiWrite(pParse);
-          sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, 0);
+                                   regNewData, 1, 0, OE_Replace,
+                                   ONEPASS_SINGLE, -1);
+        }else{
+          if( pTab->pIndex ){
+            sqlite3MultiWrite(pParse);
+            sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,-1);
+          }
         }
         seenReplace = 1;
         break;
       }
       case OE_Ignore: {
         /*assert( seenReplace==0 );*/
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest);
+        sqlite3VdbeGoto(v, ignoreDest);
         break;
       }
     }
@@ -102149,15 +103194,22 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
     for(i=0; i<pIdx->nColumn; i++){
       int iField = pIdx->aiColumn[i];
       int x;
-      if( iField<0 || iField==pTab->iPKey ){
-        if( regRowid==regIdx+i ) continue; /* ROWID already in regIdx+i */
-        x = regNewData;
-        regRowid =  pIdx->pPartIdxWhere ? -1 : regIdx+i;
+      if( iField==XN_EXPR ){
+        pParse->ckBase = regNewData+1;
+        sqlite3ExprCode(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);
+        pParse->ckBase = 0;
+        VdbeComment((v, "%s column %d", pIdx->zName, i));
       }else{
-        x = iField + regNewData + 1;
+        if( iField==XN_ROWID || iField==pTab->iPKey ){
+          if( regRowid==regIdx+i ) continue; /* ROWID already in regIdx+i */
+          x = regNewData;
+          regRowid =  pIdx->pPartIdxWhere ? -1 : regIdx+i;
+        }else{
+          x = iField + regNewData + 1;
+        }
+        sqlite3VdbeAddOp2(v, OP_SCopy, x, regIdx+i);
+        VdbeComment((v, "%s", iField<0 ? "rowid" : pTab->aCol[iField].zName));
       }
-      sqlite3VdbeAddOp2(v, OP_SCopy, x, regIdx+i);
-      VdbeComment((v, "%s", iField<0 ? "rowid" : pTab->aCol[iField].zName));
     }
     sqlite3VdbeAddOp3(v, OP_MakeRecord, regIdx, pIdx->nColumn, aRegIdx[ix]);
     VdbeComment((v, "for %s", pIdx->zName));
@@ -102207,6 +103259,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
         ** store it in registers regR..regR+nPk-1 */
         if( pIdx!=pPk ){
           for(i=0; i<pPk->nKeyCol; i++){
+            assert( pPk->aiColumn[i]>=0 );
             x = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);
             sqlite3VdbeAddOp3(v, OP_Column, iThisCur, x, regR+i);
             VdbeComment((v, "%s.%s", pTab->zName,
@@ -102228,6 +103281,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
           for(i=0; i<pPk->nKeyCol; i++){
             char *p4 = (char*)sqlite3LocateCollSeq(pParse, pPk->azColl[i]);
             x = pPk->aiColumn[i];
+            assert( x>=0 );
             if( i==(pPk->nKeyCol-1) ){
               addrJump = addrUniqueOk;
               op = OP_Eq;
@@ -102254,7 +103308,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
         break;
       }
       case OE_Ignore: {
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest);
+        sqlite3VdbeGoto(v, ignoreDest);
         break;
       }
       default: {
@@ -102265,7 +103319,8 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
           pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);
         }
         sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
-                                 regR, nPkField, 0, OE_Replace, pIdx==pPk);
+            regR, nPkField, 0, OE_Replace,
+            (pIdx==pPk ? ONEPASS_SINGLE : ONEPASS_OFF), -1);
         seenReplace = 1;
         break;
       }
@@ -102275,7 +103330,7 @@ SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(
     if( regR!=regIdx ) sqlite3ReleaseTempRange(pParse, regR, nPkField);
   }
   if( ipkTop ){
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, ipkTop+1);
+    sqlite3VdbeGoto(v, ipkTop+1);
     sqlite3VdbeJumpHere(v, ipkBottom);
   }
   
@@ -102478,6 +103533,13 @@ static int xferCompatibleIndex(Index *pDest, Index *pSrc){
     if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){
       return 0;   /* Different columns indexed */
     }
+    if( pSrc->aiColumn[i]==XN_EXPR ){
+      assert( pSrc->aColExpr!=0 && pDest->aColExpr!=0 );
+      if( sqlite3ExprCompare(pSrc->aColExpr->a[i].pExpr,
+                             pDest->aColExpr->a[i].pExpr, -1)!=0 ){
+        return 0;   /* Different expressions in the index */
+      }
+    }
     if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){
       return 0;   /* Different sort orders */
     }
@@ -102721,7 +103783,7 @@ static int xferOptimization(
     ** (3) onError is something other than OE_Abort and OE_Rollback.
     */
     addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iDest, 0); VdbeCoverage(v);
-    emptyDestTest = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0);
+    emptyDestTest = sqlite3VdbeAddOp0(v, OP_Goto);
     sqlite3VdbeJumpHere(v, addr1);
   }
   if( HasRowid(pSrc) ){
@@ -103258,6 +104320,9 @@ struct sqlite3_api_routines {
   void (*value_free)(sqlite3_value*);
   int (*result_zeroblob64)(sqlite3_context*,sqlite3_uint64);
   int (*bind_zeroblob64)(sqlite3_stmt*, int, sqlite3_uint64);
+  /* Version 3.9.0 and later */
+  unsigned int (*value_subtype)(sqlite3_value*);
+  void (*result_subtype)(sqlite3_context*,unsigned int);
 };
 
 /*
@@ -103271,7 +104336,7 @@ struct sqlite3_api_routines {
 ** the API.  So the redefinition macros are only valid if the
 ** SQLITE_CORE macros is undefined.
 */
-#ifndef SQLITE_CORE
+#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
 #define sqlite3_aggregate_context      sqlite3_api->aggregate_context
 #ifndef SQLITE_OMIT_DEPRECATED
 #define sqlite3_aggregate_count        sqlite3_api->aggregate_count
@@ -103398,6 +104463,7 @@ struct sqlite3_api_routines {
 #define sqlite3_value_text16le         sqlite3_api->value_text16le
 #define sqlite3_value_type             sqlite3_api->value_type
 #define sqlite3_vmprintf               sqlite3_api->vmprintf
+#define sqlite3_vsnprintf              sqlite3_api->vsnprintf
 #define sqlite3_overload_function      sqlite3_api->overload_function
 #define sqlite3_prepare_v2             sqlite3_api->prepare_v2
 #define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2
@@ -103493,9 +104559,12 @@ struct sqlite3_api_routines {
 #define sqlite3_value_free             sqlite3_api->value_free
 #define sqlite3_result_zeroblob64      sqlite3_api->result_zeroblob64
 #define sqlite3_bind_zeroblob64        sqlite3_api->bind_zeroblob64
-#endif /* SQLITE_CORE */
+/* Version 3.9.0 and later */
+#define sqlite3_value_subtype          sqlite3_api->value_subtype
+#define sqlite3_result_subtype         sqlite3_api->result_subtype
+#endif /* !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION) */
 
-#ifndef SQLITE_CORE
+#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
   /* This case when the file really is being compiled as a loadable 
   ** extension */
 # define SQLITE_EXTENSION_INIT1     const sqlite3_api_routines *sqlite3_api=0;
@@ -103904,7 +104973,10 @@ static const sqlite3_api_routines sqlite3Apis = {
   (sqlite3_value*(*)(const sqlite3_value*))sqlite3_value_dup,
   sqlite3_value_free,
   sqlite3_result_zeroblob64,
-  sqlite3_bind_zeroblob64
+  sqlite3_bind_zeroblob64,
+  /* Version 3.9.0 and later */
+  sqlite3_value_subtype,
+  sqlite3_result_subtype
 };
 
 /*
@@ -104109,7 +105181,7 @@ SQLITE_API int SQLITE_STDCALL sqlite3_enable_load_extension(sqlite3 *db, int ono
 ** dummy pointer.
 */
 #ifdef SQLITE_OMIT_LOAD_EXTENSION
-static const sqlite3_api_routines sqlite3Apis = { 0 };
+static const sqlite3_api_routines sqlite3Apis;
 #endif
 
 
@@ -104901,20 +105973,46 @@ static int changeTempStorage(Parse *pParse, const char *zStorageType){
 }
 #endif /* SQLITE_PAGER_PRAGMAS */
 
+/*
+** Set the names of the first N columns to the values in azCol[]
+*/
+static void setAllColumnNames(
+  Vdbe *v,               /* The query under construction */
+  int N,                 /* Number of columns */
+  const char **azCol     /* Names of columns */
+){
+  int i;
+  sqlite3VdbeSetNumCols(v, N);
+  for(i=0; i<N; i++){
+    sqlite3VdbeSetColName(v, i, COLNAME_NAME, azCol[i], SQLITE_STATIC);
+  }
+}
+static void setOneColumnName(Vdbe *v, const char *z){
+  setAllColumnNames(v, 1, &z);
+}
+
 /*
 ** Generate code to return a single integer value.
 */
-static void returnSingleInt(Parse *pParse, const char *zLabel, i64 value){
-  Vdbe *v = sqlite3GetVdbe(pParse);
-  int nMem = ++pParse->nMem;
-  i64 *pI64 = sqlite3DbMallocRaw(pParse->db, sizeof(value));
-  if( pI64 ){
-    memcpy(pI64, &value, sizeof(value));
+static void returnSingleInt(Vdbe *v, const char *zLabel, i64 value){
+  sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, 1, 0, (const u8*)&value, P4_INT64);
+  setOneColumnName(v, zLabel);
+  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
+}
+
+/*
+** Generate code to return a single text value.
+*/
+static void returnSingleText(
+  Vdbe *v,                /* Prepared statement under construction */
+  const char *zLabel,     /* Name of the result column */
+  const char *zValue      /* Value to be returned */
+){
+  if( zValue ){
+    sqlite3VdbeLoadString(v, 1, (const char*)zValue);
+    setOneColumnName(v, zLabel);
+    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
   }
-  sqlite3VdbeAddOp4(v, OP_Int64, 0, nMem, 0, (char*)pI64, P4_INT64);
-  sqlite3VdbeSetNumCols(v, 1);
-  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC);
-  sqlite3VdbeAddOp2(v, OP_ResultRow, nMem, 1);
 }
 
 
@@ -105078,14 +106176,8 @@ SQLITE_PRIVATE void sqlite3Pragma(
   db->busyHandler.nBusy = 0;
   rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);
   if( rc==SQLITE_OK ){
-    if( aFcntl[0] ){
-      int nMem = ++pParse->nMem;
-      sqlite3VdbeAddOp4(v, OP_String8, 0, nMem, 0, aFcntl[0], 0);
-      sqlite3VdbeSetNumCols(v, 1);
-      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "result", SQLITE_STATIC);
-      sqlite3VdbeAddOp2(v, OP_ResultRow, nMem, 1);
-      sqlite3_free(aFcntl[0]);
-    }
+    returnSingleText(v, "result", aFcntl[0]);
+    sqlite3_free(aFcntl[0]);
     goto pragma_out;
   }
   if( rc!=SQLITE_NOTFOUND ){
@@ -105155,8 +106247,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     int addr;
     sqlite3VdbeUsesBtree(v, iDb);
     if( !zRight ){
-      sqlite3VdbeSetNumCols(v, 1);
-      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "cache_size", SQLITE_STATIC);
+      setOneColumnName(v, "cache_size");
       pParse->nMem += 2;
       addr = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize,iLn);
       sqlite3VdbeChangeP1(v, addr, iDb);
@@ -105190,7 +106281,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     assert( pBt!=0 );
     if( !zRight ){
       int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;
-      returnSingleInt(pParse, "page_size", size);
+      returnSingleInt(v, "page_size", size);
     }else{
       /* Malloc may fail when setting the page-size, as there is an internal
       ** buffer that the pager module resizes using sqlite3_realloc().
@@ -105225,7 +106316,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
       }
     }
     b = sqlite3BtreeSecureDelete(pBt, b);
-    returnSingleInt(pParse, "secure_delete", b);
+    returnSingleInt(v, "secure_delete", b);
     break;
   }
 
@@ -105304,10 +106395,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){
       zRet = "exclusive";
     }
-    sqlite3VdbeSetNumCols(v, 1);
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "locking_mode", SQLITE_STATIC);
-    sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, zRet, 0);
-    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
+    returnSingleText(v, "locking_mode", zRet);
     break;
   }
 
@@ -105320,9 +106408,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     int eMode;        /* One of the PAGER_JOURNALMODE_XXX symbols */
     int ii;           /* Loop counter */
 
-    sqlite3VdbeSetNumCols(v, 1);
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "journal_mode", SQLITE_STATIC);
-
+    setOneColumnName(v, "journal_mode");
     if( zRight==0 ){
       /* If there is no "=MODE" part of the pragma, do a query for the
       ** current mode */
@@ -105368,7 +106454,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
       if( iLimit<-1 ) iLimit = -1;
     }
     iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);
-    returnSingleInt(pParse, "journal_size_limit", iLimit);
+    returnSingleInt(v, "journal_size_limit", iLimit);
     break;
   }
 
@@ -105386,7 +106472,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     Btree *pBt = pDb->pBt;
     assert( pBt!=0 );
     if( !zRight ){
-      returnSingleInt(pParse, "auto_vacuum", sqlite3BtreeGetAutoVacuum(pBt));
+      returnSingleInt(v, "auto_vacuum", sqlite3BtreeGetAutoVacuum(pBt));
     }else{
       int eAuto = getAutoVacuum(zRight);
       assert( eAuto>=0 && eAuto<=2 );
@@ -105464,7 +106550,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
     if( !zRight ){
       if( sqlite3ReadSchema(pParse) ) goto pragma_out;
-      returnSingleInt(pParse, "cache_size", pDb->pSchema->cache_size);
+      returnSingleInt(v, "cache_size", pDb->pSchema->cache_size);
     }else{
       int size = sqlite3Atoi(zRight);
       pDb->pSchema->cache_size = size;
@@ -105510,7 +106596,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     rc = SQLITE_OK;
 #endif
     if( rc==SQLITE_OK ){
-      returnSingleInt(pParse, "mmap_size", sz);
+      returnSingleInt(v, "mmap_size", sz);
     }else if( rc!=SQLITE_NOTFOUND ){
       pParse->nErr++;
       pParse->rc = rc;
@@ -105531,7 +106617,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
   */
   case PragTyp_TEMP_STORE: {
     if( !zRight ){
-      returnSingleInt(pParse, "temp_store", db->temp_store);
+      returnSingleInt(v, "temp_store", db->temp_store);
     }else{
       changeTempStorage(pParse, zRight);
     }
@@ -105550,13 +106636,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
   */
   case PragTyp_TEMP_STORE_DIRECTORY: {
     if( !zRight ){
-      if( sqlite3_temp_directory ){
-        sqlite3VdbeSetNumCols(v, 1);
-        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, 
-            "temp_store_directory", SQLITE_STATIC);
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, sqlite3_temp_directory, 0);
-        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
-      }
+      returnSingleText(v, "temp_store_directory", sqlite3_temp_directory);
     }else{
 #ifndef SQLITE_OMIT_WSD
       if( zRight[0] ){
@@ -105600,13 +106680,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
   */
   case PragTyp_DATA_STORE_DIRECTORY: {
     if( !zRight ){
-      if( sqlite3_data_directory ){
-        sqlite3VdbeSetNumCols(v, 1);
-        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, 
-            "data_store_directory", SQLITE_STATIC);
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, sqlite3_data_directory, 0);
-        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
-      }
+      returnSingleText(v, "data_store_directory", sqlite3_data_directory);
     }else{
 #ifndef SQLITE_OMIT_WSD
       if( zRight[0] ){
@@ -105645,14 +106719,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
       sqlite3_file *pFile = sqlite3PagerFile(pPager);
       sqlite3OsFileControlHint(pFile, SQLITE_GET_LOCKPROXYFILE, 
                            &proxy_file_path);
-      
-      if( proxy_file_path ){
-        sqlite3VdbeSetNumCols(v, 1);
-        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, 
-                              "lock_proxy_file", SQLITE_STATIC);
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, proxy_file_path, 0);
-        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
-      }
+      returnSingleText(v, "lock_proxy_file", proxy_file_path);
     }else{
       Pager *pPager = sqlite3BtreePager(pDb->pBt);
       sqlite3_file *pFile = sqlite3PagerFile(pPager);
@@ -105684,7 +106751,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
   */
   case PragTyp_SYNCHRONOUS: {
     if( !zRight ){
-      returnSingleInt(pParse, "synchronous", pDb->safety_level-1);
+      returnSingleInt(v, "synchronous", pDb->safety_level-1);
     }else{
       if( !db->autoCommit ){
         sqlite3ErrorMsg(pParse, 
@@ -105703,7 +106770,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
 #ifndef SQLITE_OMIT_FLAG_PRAGMAS
   case PragTyp_FLAG: {
     if( zRight==0 ){
-      returnSingleInt(pParse, pPragma->zName, (db->flags & pPragma->iArg)!=0 );
+      returnSingleInt(v, pPragma->zName, (db->flags & pPragma->iArg)!=0 );
     }else{
       int mask = pPragma->iArg;    /* Mask of bits to set or clear. */
       if( db->autoCommit==0 ){
@@ -105753,35 +106820,22 @@ SQLITE_PRIVATE void sqlite3Pragma(
     Table *pTab;
     pTab = sqlite3FindTable(db, zRight, zDb);
     if( pTab ){
+      static const char *azCol[] = {
+         "cid", "name", "type", "notnull", "dflt_value", "pk"
+      };
       int i, k;
       int nHidden = 0;
       Column *pCol;
       Index *pPk = sqlite3PrimaryKeyIndex(pTab);
-      sqlite3VdbeSetNumCols(v, 6);
       pParse->nMem = 6;
       sqlite3CodeVerifySchema(pParse, iDb);
-      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "cid", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "type", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "notnull", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 4, COLNAME_NAME, "dflt_value", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 5, COLNAME_NAME, "pk", SQLITE_STATIC);
+      setAllColumnNames(v, 6, azCol); assert( 6==ArraySize(azCol) );
       sqlite3ViewGetColumnNames(pParse, pTab);
       for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
         if( IsHiddenColumn(pCol) ){
           nHidden++;
           continue;
         }
-        sqlite3VdbeAddOp2(v, OP_Integer, i-nHidden, 1);
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pCol->zName, 0);
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,
-           pCol->zType ? pCol->zType : "", 0);
-        sqlite3VdbeAddOp2(v, OP_Integer, (pCol->notNull ? 1 : 0), 4);
-        if( pCol->zDflt ){
-          sqlite3VdbeAddOp4(v, OP_String8, 0, 5, 0, (char*)pCol->zDflt, 0);
-        }else{
-          sqlite3VdbeAddOp2(v, OP_Null, 0, 5);
-        }
         if( (pCol->colFlags & COLFLAG_PRIMKEY)==0 ){
           k = 0;
         }else if( pPk==0 ){
@@ -105789,7 +106843,13 @@ SQLITE_PRIVATE void sqlite3Pragma(
         }else{
           for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}
         }
-        sqlite3VdbeAddOp2(v, OP_Integer, k, 6);
+        sqlite3VdbeMultiLoad(v, 1, "issisi",
+               i-nHidden,
+               pCol->zName,
+               pCol->zType ? pCol->zType : "",
+               pCol->notNull ? 1 : 0,
+               pCol->zDflt,
+               k);
         sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 6);
       }
     }
@@ -105797,31 +106857,26 @@ SQLITE_PRIVATE void sqlite3Pragma(
   break;
 
   case PragTyp_STATS: {
+    static const char *azCol[] = { "table", "index", "width", "height" };
     Index *pIdx;
     HashElem *i;
     v = sqlite3GetVdbe(pParse);
-    sqlite3VdbeSetNumCols(v, 4);
     pParse->nMem = 4;
     sqlite3CodeVerifySchema(pParse, iDb);
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "table", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "index", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "width", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "height", SQLITE_STATIC);
+    setAllColumnNames(v, 4, azCol);  assert( 4==ArraySize(azCol) );
     for(i=sqliteHashFirst(&pDb->pSchema->tblHash); i; i=sqliteHashNext(i)){
       Table *pTab = sqliteHashData(i);
-      sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, pTab->zName, 0);
-      sqlite3VdbeAddOp2(v, OP_Null, 0, 2);
-      sqlite3VdbeAddOp2(v, OP_Integer,
-                           (int)sqlite3LogEstToInt(pTab->szTabRow), 3);
-      sqlite3VdbeAddOp2(v, OP_Integer, 
-          (int)sqlite3LogEstToInt(pTab->nRowLogEst), 4);
+      sqlite3VdbeMultiLoad(v, 1, "ssii",
+           pTab->zName,
+           0,
+           (int)sqlite3LogEstToInt(pTab->szTabRow),
+           (int)sqlite3LogEstToInt(pTab->nRowLogEst));
       sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 4);
       for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pIdx->zName, 0);
-        sqlite3VdbeAddOp2(v, OP_Integer,
-                             (int)sqlite3LogEstToInt(pIdx->szIdxRow), 3);
-        sqlite3VdbeAddOp2(v, OP_Integer, 
-            (int)sqlite3LogEstToInt(pIdx->aiRowLogEst[0]), 4);
+        sqlite3VdbeMultiLoad(v, 2, "sii",
+           pIdx->zName,
+           (int)sqlite3LogEstToInt(pIdx->szIdxRow),
+           (int)sqlite3LogEstToInt(pIdx->aiRowLogEst[0]));
         sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 4);
       }
     }
@@ -105833,6 +106888,9 @@ SQLITE_PRIVATE void sqlite3Pragma(
     Table *pTab;
     pIdx = sqlite3FindIndex(db, zRight, zDb);
     if( pIdx ){
+      static const char *azCol[] = {
+         "seqno", "cid", "name", "desc", "coll", "key"
+      };
       int i;
       int mx;
       if( pPragma->iArg ){
@@ -105845,29 +106903,18 @@ SQLITE_PRIVATE void sqlite3Pragma(
         pParse->nMem = 3;
       }
       pTab = pIdx->pTable;
-      sqlite3VdbeSetNumCols(v, pParse->nMem);
       sqlite3CodeVerifySchema(pParse, iDb);
-      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seqno", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "cid", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "name", SQLITE_STATIC);
-      if( pPragma->iArg ){
-        sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "desc", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 4, COLNAME_NAME, "coll", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 5, COLNAME_NAME, "key", SQLITE_STATIC);
-      }
+      assert( pParse->nMem<=ArraySize(azCol) );
+      setAllColumnNames(v, pParse->nMem, azCol);
       for(i=0; i<mx; i++){
         i16 cnum = pIdx->aiColumn[i];
-        sqlite3VdbeAddOp2(v, OP_Integer, i, 1);
-        sqlite3VdbeAddOp2(v, OP_Integer, cnum, 2);
-        if( cnum<0 ){
-          sqlite3VdbeAddOp2(v, OP_Null, 0, 3);
-        }else{
-          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pTab->aCol[cnum].zName, 0);
-        }
+        sqlite3VdbeMultiLoad(v, 1, "iis", i, cnum,
+                             cnum<0 ? 0 : pTab->aCol[cnum].zName);
         if( pPragma->iArg ){
-          sqlite3VdbeAddOp2(v, OP_Integer, pIdx->aSortOrder[i], 4);
-          sqlite3VdbeAddOp4(v, OP_String8, 0, 5, 0, pIdx->azColl[i], 0);
-          sqlite3VdbeAddOp2(v, OP_Integer, i<pIdx->nKeyCol, 6);
+          sqlite3VdbeMultiLoad(v, 4, "isi",
+            pIdx->aSortOrder[i],
+            pIdx->azColl[i],
+            i<pIdx->nKeyCol);
         }
         sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);
       }
@@ -105881,22 +106928,21 @@ SQLITE_PRIVATE void sqlite3Pragma(
     int i;
     pTab = sqlite3FindTable(db, zRight, zDb);
     if( pTab ){
+      static const char *azCol[] = {
+        "seq", "name", "unique", "origin", "partial"
+      };
       v = sqlite3GetVdbe(pParse);
-      sqlite3VdbeSetNumCols(v, 5);
       pParse->nMem = 5;
       sqlite3CodeVerifySchema(pParse, iDb);
-      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "unique", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "origin", SQLITE_STATIC);
-      sqlite3VdbeSetColName(v, 4, COLNAME_NAME, "partial", SQLITE_STATIC);
+      setAllColumnNames(v, 5, azCol);  assert( 5==ArraySize(azCol) );
       for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){
         const char *azOrigin[] = { "c", "u", "pk" };
-        sqlite3VdbeAddOp2(v, OP_Integer, i, 1);
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pIdx->zName, 0);
-        sqlite3VdbeAddOp2(v, OP_Integer, IsUniqueIndex(pIdx), 3);
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 4, 0, azOrigin[pIdx->idxType], 0);
-        sqlite3VdbeAddOp2(v, OP_Integer, pIdx->pPartIdxWhere!=0, 5);
+        sqlite3VdbeMultiLoad(v, 1, "isisi",
+           i,
+           pIdx->zName,
+           IsUniqueIndex(pIdx),
+           azOrigin[pIdx->idxType],
+           pIdx->pPartIdxWhere!=0);
         sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);
       }
     }
@@ -105904,35 +106950,31 @@ SQLITE_PRIVATE void sqlite3Pragma(
   break;
 
   case PragTyp_DATABASE_LIST: {
+    static const char *azCol[] = { "seq", "name", "file" };
     int i;
-    sqlite3VdbeSetNumCols(v, 3);
     pParse->nMem = 3;
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "file", SQLITE_STATIC);
+    setAllColumnNames(v, 3, azCol); assert( 3==ArraySize(azCol) );
     for(i=0; i<db->nDb; i++){
       if( db->aDb[i].pBt==0 ) continue;
       assert( db->aDb[i].zName!=0 );
-      sqlite3VdbeAddOp2(v, OP_Integer, i, 1);
-      sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, db->aDb[i].zName, 0);
-      sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,
-           sqlite3BtreeGetFilename(db->aDb[i].pBt), 0);
+      sqlite3VdbeMultiLoad(v, 1, "iss",
+         i,
+         db->aDb[i].zName,
+         sqlite3BtreeGetFilename(db->aDb[i].pBt));
       sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);
     }
   }
   break;
 
   case PragTyp_COLLATION_LIST: {
+    static const char *azCol[] = { "seq", "name" };
     int i = 0;
     HashElem *p;
-    sqlite3VdbeSetNumCols(v, 2);
     pParse->nMem = 2;
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE_STATIC);
+    setAllColumnNames(v, 2, azCol); assert( 2==ArraySize(azCol) );
     for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){
       CollSeq *pColl = (CollSeq *)sqliteHashData(p);
-      sqlite3VdbeAddOp2(v, OP_Integer, i++, 1);
-      sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pColl->zName, 0);
+      sqlite3VdbeMultiLoad(v, 1, "is", i++, pColl->zName);
       sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);
     }
   }
@@ -105948,33 +106990,26 @@ SQLITE_PRIVATE void sqlite3Pragma(
       v = sqlite3GetVdbe(pParse);
       pFK = pTab->pFKey;
       if( pFK ){
+        static const char *azCol[] = {
+           "id", "seq", "table", "from", "to", "on_update", "on_delete",
+           "match"
+        };
         int i = 0; 
-        sqlite3VdbeSetNumCols(v, 8);
         pParse->nMem = 8;
         sqlite3CodeVerifySchema(pParse, iDb);
-        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "id", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "seq", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "table", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "from", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 4, COLNAME_NAME, "to", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 5, COLNAME_NAME, "on_update", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 6, COLNAME_NAME, "on_delete", SQLITE_STATIC);
-        sqlite3VdbeSetColName(v, 7, COLNAME_NAME, "match", SQLITE_STATIC);
+        setAllColumnNames(v, 8, azCol); assert( 8==ArraySize(azCol) );
         while(pFK){
           int j;
           for(j=0; j<pFK->nCol; j++){
-            char *zCol = pFK->aCol[j].zCol;
-            char *zOnDelete = (char *)actionName(pFK->aAction[0]);
-            char *zOnUpdate = (char *)actionName(pFK->aAction[1]);
-            sqlite3VdbeAddOp2(v, OP_Integer, i, 1);
-            sqlite3VdbeAddOp2(v, OP_Integer, j, 2);
-            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pFK->zTo, 0);
-            sqlite3VdbeAddOp4(v, OP_String8, 0, 4, 0,
-                              pTab->aCol[pFK->aCol[j].iFrom].zName, 0);
-            sqlite3VdbeAddOp4(v, zCol ? OP_String8 : OP_Null, 0, 5, 0, zCol, 0);
-            sqlite3VdbeAddOp4(v, OP_String8, 0, 6, 0, zOnUpdate, 0);
-            sqlite3VdbeAddOp4(v, OP_String8, 0, 7, 0, zOnDelete, 0);
-            sqlite3VdbeAddOp4(v, OP_String8, 0, 8, 0, "NONE", 0);
+            sqlite3VdbeMultiLoad(v, 1, "iissssss",
+                   i,
+                   j,
+                   pFK->zTo,
+                   pTab->aCol[pFK->aCol[j].iFrom].zName,
+                   pFK->aCol[j].zCol,
+                   actionName(pFK->aAction[1]),  /* ON UPDATE */
+                   actionName(pFK->aAction[0]),  /* ON DELETE */
+                   "NONE");
             sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 8);
           }
           ++i;
@@ -106003,17 +107038,14 @@ SQLITE_PRIVATE void sqlite3Pragma(
     int addrTop;           /* Top of a loop checking foreign keys */
     int addrOk;            /* Jump here if the key is OK */
     int *aiCols;           /* child to parent column mapping */
+    static const char *azCol[] = { "table", "rowid", "parent", "fkid" };
 
     regResult = pParse->nMem+1;
     pParse->nMem += 4;
     regKey = ++pParse->nMem;
     regRow = ++pParse->nMem;
     v = sqlite3GetVdbe(pParse);
-    sqlite3VdbeSetNumCols(v, 4);
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "table", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "rowid", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "parent", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 3, COLNAME_NAME, "fkid", SQLITE_STATIC);
+    setAllColumnNames(v, 4, azCol); assert( 4==ArraySize(azCol) );
     sqlite3CodeVerifySchema(pParse, iDb);
     k = sqliteHashFirst(&db->aDb[iDb].pSchema->tblHash);
     while( k ){
@@ -106028,8 +107060,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
       sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
       if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;
       sqlite3OpenTable(pParse, 0, iDb, pTab, OP_OpenRead);
-      sqlite3VdbeAddOp4(v, OP_String8, 0, regResult, 0, pTab->zName,
-                        P4_TRANSIENT);
+      sqlite3VdbeLoadString(v, regResult, pTab->zName);
       for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){
         pParent = sqlite3FindTable(db, pFK->zTo, zDb);
         if( pParent==0 ) continue;
@@ -106074,7 +107105,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
             sqlite3VdbeAddOp2(v, OP_Rowid, 0, regRow);
           }
           sqlite3VdbeAddOp3(v, OP_NotExists, i, 0, regRow); VdbeCoverage(v);
-          sqlite3VdbeAddOp2(v, OP_Goto, 0, addrOk);
+          sqlite3VdbeGoto(v, addrOk);
           sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
         }else{
           for(j=0; j<pFK->nCol; j++){
@@ -106084,15 +107115,13 @@ SQLITE_PRIVATE void sqlite3Pragma(
           }
           if( pParent ){
             sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,
-                              sqlite3IndexAffinityStr(v,pIdx), pFK->nCol);
+                              sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);
             sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);
             VdbeCoverage(v);
           }
         }
         sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);
-        sqlite3VdbeAddOp4(v, OP_String8, 0, regResult+2, 0, 
-                          pFK->zTo, P4_TRANSIENT);
-        sqlite3VdbeAddOp2(v, OP_Integer, i-1, regResult+3);
+        sqlite3VdbeMultiLoad(v, regResult+2, "si", pFK->zTo, i-1);
         sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);
         sqlite3VdbeResolveLabel(v, addrOk);
         sqlite3DbFree(db, aiCols);
@@ -106146,8 +107175,9 @@ SQLITE_PRIVATE void sqlite3Pragma(
     */
     static const int iLn = VDBE_OFFSET_LINENO(2);
     static const VdbeOpList endCode[] = {
-      { OP_IfNeg,       1, 0,        0},    /* 0 */
-      { OP_String8,     0, 3,        0},    /* 1 */
+      { OP_AddImm,      1, 0,        0},    /* 0 */
+      { OP_If,          1, 0,        0},    /* 1 */
+      { OP_String8,     0, 3,        0},    /* 2 */
       { OP_ResultRow,   3, 1,        0},
     };
 
@@ -106168,8 +107198,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
 
     /* Initialize the VDBE program */
     pParse->nMem = 6;
-    sqlite3VdbeSetNumCols(v, 1);
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "integrity_check", SQLITE_STATIC);
+    setOneColumnName(v, "integrity_check");
 
     /* Set the maximum error count */
     mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;
@@ -106291,13 +107320,11 @@ SQLITE_PRIVATE void sqlite3Pragma(
           jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, iIdxCur+j, ckUniq, r1,
                                       pIdx->nColumn); VdbeCoverage(v);
           sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1); /* Decrement error limit */
-          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, "row ", P4_STATIC);
+          sqlite3VdbeLoadString(v, 3, "row ");
           sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);
-          sqlite3VdbeAddOp4(v, OP_String8, 0, 4, 0, 
-                            " missing from index ", P4_STATIC);
+          sqlite3VdbeLoadString(v, 4, " missing from index ");
           sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);
-          jmp5 = sqlite3VdbeAddOp4(v, OP_String8, 0, 4, 0,
-                                   pIdx->zName, P4_TRANSIENT);
+          jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);
           sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);
           sqlite3VdbeAddOp2(v, OP_ResultRow, 3, 1);
           jmp4 = sqlite3VdbeAddOp1(v, OP_IfPos, 1); VdbeCoverage(v);
@@ -106312,20 +107339,19 @@ SQLITE_PRIVATE void sqlite3Pragma(
             int kk;
             for(kk=0; kk<pIdx->nKeyCol; kk++){
               int iCol = pIdx->aiColumn[kk];
-              assert( iCol>=0 && iCol<pTab->nCol );
-              if( pTab->aCol[iCol].notNull ) continue;
+              assert( iCol!=XN_ROWID && iCol<pTab->nCol );
+              if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;
               sqlite3VdbeAddOp2(v, OP_IsNull, r1+kk, uniqOk);
               VdbeCoverage(v);
             }
             jmp6 = sqlite3VdbeAddOp1(v, OP_Next, iIdxCur+j); VdbeCoverage(v);
-            sqlite3VdbeAddOp2(v, OP_Goto, 0, uniqOk);
+            sqlite3VdbeGoto(v, uniqOk);
             sqlite3VdbeJumpHere(v, jmp6);
             sqlite3VdbeAddOp4Int(v, OP_IdxGT, iIdxCur+j, uniqOk, r1,
                                  pIdx->nKeyCol); VdbeCoverage(v);
             sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1); /* Decrement error limit */
-            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,
-                              "non-unique entry in index ", P4_STATIC);
-            sqlite3VdbeAddOp2(v, OP_Goto, 0, jmp5);
+            sqlite3VdbeLoadString(v, 3, "non-unique entry in index ");
+            sqlite3VdbeGoto(v, jmp5);
             sqlite3VdbeResolveLabel(v, uniqOk);
           }
           sqlite3VdbeJumpHere(v, jmp4);
@@ -106334,8 +107360,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
         sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);
         sqlite3VdbeJumpHere(v, loopTop-1);
 #ifndef SQLITE_OMIT_BTREECOUNT
-        sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, 
-                     "wrong # of entries in index ", P4_STATIC);
+        sqlite3VdbeLoadString(v, 2, "wrong # of entries in index ");
         for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
           if( pPk==pIdx ) continue;
           addr = sqlite3VdbeCurrentAddr(v);
@@ -106345,7 +107370,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
           sqlite3VdbeAddOp3(v, OP_Eq, 8+j, addr+8, 3); VdbeCoverage(v);
           sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
           sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);
-          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pIdx->zName, P4_TRANSIENT);
+          sqlite3VdbeLoadString(v, 3, pIdx->zName);
           sqlite3VdbeAddOp3(v, OP_Concat, 3, 2, 7);
           sqlite3VdbeAddOp2(v, OP_ResultRow, 7, 1);
         }
@@ -106353,9 +107378,9 @@ SQLITE_PRIVATE void sqlite3Pragma(
       } 
     }
     addr = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);
-    sqlite3VdbeChangeP3(v, addr, -mxErr);
-    sqlite3VdbeJumpHere(v, addr);
-    sqlite3VdbeChangeP4(v, addr+1, "ok", P4_STATIC);
+    sqlite3VdbeChangeP2(v, addr, -mxErr);
+    sqlite3VdbeJumpHere(v, addr+1);
+    sqlite3VdbeChangeP4(v, addr+2, "ok", P4_STATIC);
   }
   break;
 #endif /* SQLITE_OMIT_INTEGRITY_CHECK */
@@ -106401,14 +107426,10 @@ SQLITE_PRIVATE void sqlite3Pragma(
     const struct EncName *pEnc;
     if( !zRight ){    /* "PRAGMA encoding" */
       if( sqlite3ReadSchema(pParse) ) goto pragma_out;
-      sqlite3VdbeSetNumCols(v, 1);
-      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "encoding", SQLITE_STATIC);
-      sqlite3VdbeAddOp2(v, OP_String8, 0, 1);
       assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );
       assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );
       assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );
-      sqlite3VdbeChangeP4(v, -1, encnames[ENC(pParse->db)].zName, P4_STATIC);
-      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
+      returnSingleText(v, "encoding", encnames[ENC(pParse->db)].zName);
     }else{                        /* "PRAGMA encoding = XXX" */
       /* Only change the value of sqlite.enc if the database handle is not
       ** initialized. If the main database exists, the new sqlite.enc value
@@ -106509,11 +107530,10 @@ SQLITE_PRIVATE void sqlite3Pragma(
   case PragTyp_COMPILE_OPTIONS: {
     int i = 0;
     const char *zOpt;
-    sqlite3VdbeSetNumCols(v, 1);
     pParse->nMem = 1;
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "compile_option", SQLITE_STATIC);
+    setOneColumnName(v, "compile_option");
     while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){
-      sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, zOpt, 0);
+      sqlite3VdbeLoadString(v, 1, zOpt);
       sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);
     }
   }
@@ -106527,6 +107547,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
   ** Checkpoint the database.
   */
   case PragTyp_WAL_CHECKPOINT: {
+    static const char *azCol[] = { "busy", "log", "checkpointed" };
     int iBt = (pId2->z?iDb:SQLITE_MAX_ATTACHED);
     int eMode = SQLITE_CHECKPOINT_PASSIVE;
     if( zRight ){
@@ -106538,12 +107559,8 @@ SQLITE_PRIVATE void sqlite3Pragma(
         eMode = SQLITE_CHECKPOINT_TRUNCATE;
       }
     }
-    sqlite3VdbeSetNumCols(v, 3);
+    setAllColumnNames(v, 3, azCol);  assert( 3==ArraySize(azCol) );
     pParse->nMem = 3;
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "busy", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "log", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 2, COLNAME_NAME, "checkpointed", SQLITE_STATIC);
-
     sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);
     sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);
   }
@@ -106561,7 +107578,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     if( zRight ){
       sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));
     }
-    returnSingleInt(pParse, "wal_autocheckpoint", 
+    returnSingleInt(v, "wal_autocheckpoint", 
        db->xWalCallback==sqlite3WalDefaultHook ? 
            SQLITE_PTR_TO_INT(db->pWalArg) : 0);
   }
@@ -106594,7 +107611,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     if( zRight ){
       sqlite3_busy_timeout(db, sqlite3Atoi(zRight));
     }
-    returnSingleInt(pParse, "timeout",  db->busyTimeout);
+    returnSingleInt(v, "timeout",  db->busyTimeout);
     break;
   }
 
@@ -106614,7 +107631,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){
       sqlite3_soft_heap_limit64(N);
     }
-    returnSingleInt(pParse, "soft_heap_limit",  sqlite3_soft_heap_limit64(-1));
+    returnSingleInt(v, "soft_heap_limit",  sqlite3_soft_heap_limit64(-1));
     break;
   }
 
@@ -106633,7 +107650,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
     ){
       sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, (int)(N&0x7fffffff));
     }
-    returnSingleInt(pParse, "threads",
+    returnSingleInt(v, "threads",
                     sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));
     break;
   }
@@ -106646,17 +107663,15 @@ SQLITE_PRIVATE void sqlite3Pragma(
     static const char *const azLockName[] = {
       "unlocked", "shared", "reserved", "pending", "exclusive"
     };
+    static const char *azCol[] = { "database", "status" };
     int i;
-    sqlite3VdbeSetNumCols(v, 2);
+    setAllColumnNames(v, 2, azCol); assert( 2==ArraySize(azCol) );
     pParse->nMem = 2;
-    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "database", SQLITE_STATIC);
-    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, "status", SQLITE_STATIC);
     for(i=0; i<db->nDb; i++){
       Btree *pBt;
       const char *zState = "unknown";
       int j;
       if( db->aDb[i].zName==0 ) continue;
-      sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, db->aDb[i].zName, P4_STATIC);
       pBt = db->aDb[i].pBt;
       if( pBt==0 || sqlite3BtreePager(pBt)==0 ){
         zState = "closed";
@@ -106664,7 +107679,7 @@ SQLITE_PRIVATE void sqlite3Pragma(
                                      SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){
          zState = azLockName[j];
       }
-      sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, zState, P4_STATIC);
+      sqlite3VdbeMultiLoad(v, 1, "ss", db->aDb[i].zName, zState);
       sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);
     }
     break;
@@ -108029,12 +109044,12 @@ static int sqliteProcessJoin(Parse *pParse, Select *p){
     int isOuter;
 
     if( NEVER(pLeftTab==0 || pRightTab==0) ) continue;
-    isOuter = (pRight->jointype & JT_OUTER)!=0;
+    isOuter = (pRight->fg.jointype & JT_OUTER)!=0;
 
     /* When the NATURAL keyword is present, add WHERE clause terms for
     ** every column that the two tables have in common.
     */
-    if( pRight->jointype & JT_NATURAL ){
+    if( pRight->fg.jointype & JT_NATURAL ){
       if( pRight->pOn || pRight->pUsing ){
         sqlite3ErrorMsg(pParse, "a NATURAL join may not have "
            "an ON or USING clause", 0);
@@ -108119,6 +109134,7 @@ static void pushOntoSorter(
   SortCtx *pSort,        /* Information about the ORDER BY clause */
   Select *pSelect,       /* The whole SELECT statement */
   int regData,           /* First register holding data to be sorted */
+  int regOrigData,       /* First register holding data before packing */
   int nData,             /* Number of elements in the data array */
   int nPrefixReg         /* No. of reg prior to regData available for use */
 ){
@@ -108132,6 +109148,7 @@ static void pushOntoSorter(
   int op;                            /* Opcode to add sorter record to sorter */
 
   assert( bSeq==0 || bSeq==1 );
+  assert( nData==1 || regData==regOrigData );
   if( nPrefixReg ){
     assert( nPrefixReg==nExpr+bSeq );
     regBase = regData - nExpr - bSeq;
@@ -108139,7 +109156,8 @@ static void pushOntoSorter(
     regBase = pParse->nMem + 1;
     pParse->nMem += nBase;
   }
-  sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, SQLITE_ECEL_DUP);
+  sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,
+                          SQLITE_ECEL_DUP|SQLITE_ECEL_REF);
   if( bSeq ){
     sqlite3VdbeAddOp2(v, OP_Sequence, pSort->iECursor, regBase+nExpr);
   }
@@ -108199,7 +109217,7 @@ static void pushOntoSorter(
     }else{
       iLimit = pSelect->iLimit;
     }
-    addr = sqlite3VdbeAddOp3(v, OP_IfNotZero, iLimit, 0, -1); VdbeCoverage(v);
+    addr = sqlite3VdbeAddOp3(v, OP_IfNotZero, iLimit, 0, 1); VdbeCoverage(v);
     sqlite3VdbeAddOp1(v, OP_Last, pSort->iECursor);
     sqlite3VdbeAddOp1(v, OP_Delete, pSort->iECursor);
     sqlite3VdbeJumpHere(v, addr);
@@ -108215,11 +109233,8 @@ static void codeOffset(
   int iContinue     /* Jump here to skip the current record */
 ){
   if( iOffset>0 ){
-    int addr;
-    addr = sqlite3VdbeAddOp3(v, OP_IfNeg, iOffset, 0, -1); VdbeCoverage(v);
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, iContinue);
-    VdbeComment((v, "skip OFFSET records"));
-    sqlite3VdbeJumpHere(v, addr);
+    sqlite3VdbeAddOp3(v, OP_IfPos, iOffset, iContinue, 1); VdbeCoverage(v);
+    VdbeComment((v, "OFFSET"));
   }
 }
 
@@ -108349,7 +109364,7 @@ static void selectInnerLoop(
     }else{
       ecelFlags = 0;
     }
-    sqlite3ExprCodeExprList(pParse, pEList, regResult, ecelFlags);
+    sqlite3ExprCodeExprList(pParse, pEList, regResult, 0, ecelFlags);
   }
 
   /* If the DISTINCT keyword was present on the SELECT statement
@@ -108465,7 +109480,7 @@ static void selectInnerLoop(
       }
 #endif
       if( pSort ){
-        pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, 1, nPrefixReg);
+        pushOntoSorter(pParse, pSort, p, r1+nPrefixReg,regResult,1,nPrefixReg);
       }else{
         int r2 = sqlite3GetTempReg(pParse);
         sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2);
@@ -108491,7 +109506,7 @@ static void selectInnerLoop(
         ** ORDER BY in this case since the order of entries in the set
         ** does not matter.  But there might be a LIMIT clause, in which
         ** case the order does matter */
-        pushOntoSorter(pParse, pSort, p, regResult, 1, nPrefixReg);
+        pushOntoSorter(pParse, pSort, p, regResult, regResult, 1, nPrefixReg);
       }else{
         int r1 = sqlite3GetTempReg(pParse);
         sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult,1,r1, &pDest->affSdst, 1);
@@ -108517,7 +109532,7 @@ static void selectInnerLoop(
     case SRT_Mem: {
       assert( nResultCol==1 );
       if( pSort ){
-        pushOntoSorter(pParse, pSort, p, regResult, 1, nPrefixReg);
+        pushOntoSorter(pParse, pSort, p, regResult, regResult, 1, nPrefixReg);
       }else{
         assert( regResult==iParm );
         /* The LIMIT clause will jump out of the loop for us */
@@ -108531,7 +109546,8 @@ static void selectInnerLoop(
       testcase( eDest==SRT_Coroutine );
       testcase( eDest==SRT_Output );
       if( pSort ){
-        pushOntoSorter(pParse, pSort, p, regResult, nResultCol, nPrefixReg);
+        pushOntoSorter(pParse, pSort, p, regResult, regResult, nResultCol,
+                       nPrefixReg);
       }else if( eDest==SRT_Coroutine ){
         sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);
       }else{
@@ -108825,7 +109841,7 @@ static void generateSortTail(
 
   if( pSort->labelBkOut ){
     sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrBreak);
+    sqlite3VdbeGoto(v, addrBreak);
     sqlite3VdbeResolveLabel(v, pSort->labelBkOut);
   }
   iTab = pSort->iECursor;
@@ -109210,7 +110226,7 @@ static void generateColumnNames(
 ** Return SQLITE_OK on success.  If a memory allocation error occurs,
 ** store NULL in *paCol and 0 in *pnCol and return SQLITE_NOMEM.
 */
-static int selectColumnsFromExprList(
+SQLITE_PRIVATE int sqlite3ColumnsFromExprList(
   Parse *pParse,          /* Parsing context */
   ExprList *pEList,       /* Expr list from which to derive column names */
   i16 *pnCol,             /* Write the number of columns here */
@@ -109377,7 +110393,7 @@ SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect){
   pTab->nRef = 1;
   pTab->zName = 0;
   pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
-  selectColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);
+  sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);
   selectAddColumnTypeAndCollation(pParse, pTab, pSelect);
   pTab->iPKey = -1;
   if( db->mallocFailed ){
@@ -109434,7 +110450,7 @@ static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
   Vdbe *v = 0;
   int iLimit = 0;
   int iOffset;
-  int addr1, n;
+  int n;
   if( p->iLimit ) return;
 
   /* 
@@ -109453,7 +110469,7 @@ static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
       sqlite3VdbeAddOp2(v, OP_Integer, n, iLimit);
       VdbeComment((v, "LIMIT counter"));
       if( n==0 ){
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);
+        sqlite3VdbeGoto(v, iBreak);
       }else if( n>=0 && p->nSelectRow>(u64)n ){
         p->nSelectRow = n;
       }
@@ -109469,14 +110485,10 @@ static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
       sqlite3ExprCode(pParse, p->pOffset, iOffset);
       sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset); VdbeCoverage(v);
       VdbeComment((v, "OFFSET counter"));
-      addr1 = sqlite3VdbeAddOp1(v, OP_IfPos, iOffset); VdbeCoverage(v);
-      sqlite3VdbeAddOp2(v, OP_Integer, 0, iOffset);
-      sqlite3VdbeJumpHere(v, addr1);
+      sqlite3VdbeAddOp3(v, OP_SetIfNotPos, iOffset, iOffset, 0);
       sqlite3VdbeAddOp3(v, OP_Add, iLimit, iOffset, iOffset+1);
       VdbeComment((v, "LIMIT+OFFSET"));
-      addr1 = sqlite3VdbeAddOp1(v, OP_IfPos, iLimit); VdbeCoverage(v);
-      sqlite3VdbeAddOp2(v, OP_Integer, -1, iOffset+1);
-      sqlite3VdbeJumpHere(v, addr1);
+      sqlite3VdbeAddOp3(v, OP_SetIfNotPos, iLimit, iOffset+1, -1);
     }
   }
 }
@@ -109556,7 +110568,7 @@ static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){
 **
 **
 ** There is exactly one reference to the recursive-table in the FROM clause
-** of recursive-query, marked with the SrcList->a[].isRecursive flag.
+** of recursive-query, marked with the SrcList->a[].fg.isRecursive flag.
 **
 ** The setup-query runs once to generate an initial set of rows that go
 ** into a Queue table.  Rows are extracted from the Queue table one by
@@ -109621,7 +110633,7 @@ static void generateWithRecursiveQuery(
 
   /* Locate the cursor number of the Current table */
   for(i=0; ALWAYS(i<pSrc->nSrc); i++){
-    if( pSrc->a[i].isRecursive ){
+    if( pSrc->a[i].fg.isRecursive ){
       iCurrent = pSrc->a[i].iCursor;
       break;
     }
@@ -109701,7 +110713,7 @@ static void generateWithRecursiveQuery(
   }
 
   /* Keep running the loop until the Queue is empty */
-  sqlite3VdbeAddOp2(v, OP_Goto, 0, addrTop);
+  sqlite3VdbeGoto(v, addrTop);
   sqlite3VdbeResolveLabel(v, addrBreak);
 
 end_of_recursive_query:
@@ -109892,6 +110904,11 @@ static int multiSelect(
       if( p->iLimit ){
         addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);
         VdbeComment((v, "Jump ahead if LIMIT reached"));
+        if( p->iOffset ){
+          sqlite3VdbeAddOp3(v, OP_SetIfNotPos, p->iOffset, p->iOffset, 0);
+          sqlite3VdbeAddOp3(v, OP_Add, p->iLimit, p->iOffset, p->iOffset+1);
+          sqlite3VdbeAddOp3(v, OP_SetIfNotPos, p->iLimit, p->iOffset+1, -1);
+        }
       }
       explainSetInteger(iSub2, pParse->iNextSelectId);
       rc = sqlite3Select(pParse, p, &dest);
@@ -110199,12 +111216,12 @@ static int generateOutputSubroutine(
   /* Suppress duplicates for UNION, EXCEPT, and INTERSECT 
   */
   if( regPrev ){
-    int j1, j2;
-    j1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);
-    j2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev+1, pIn->nSdst,
+    int addr1, addr2;
+    addr1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);
+    addr2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev+1, pIn->nSdst,
                               (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
-    sqlite3VdbeAddOp3(v, OP_Jump, j2+2, iContinue, j2+2); VdbeCoverage(v);
-    sqlite3VdbeJumpHere(v, j1);
+    sqlite3VdbeAddOp3(v, OP_Jump, addr2+2, iContinue, addr2+2); VdbeCoverage(v);
+    sqlite3VdbeJumpHere(v, addr1);
     sqlite3VdbeAddOp3(v, OP_Copy, pIn->iSdst, regPrev+1, pIn->nSdst-1);
     sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev);
   }
@@ -110421,7 +111438,7 @@ static int multiSelectOrderBy(
   int savedOffset;      /* Saved value of p->iOffset */
   int labelCmpr;        /* Label for the start of the merge algorithm */
   int labelEnd;         /* Label for the end of the overall SELECT stmt */
-  int j1;               /* Jump instructions that get retargetted */
+  int addr1;            /* Jump instructions that get retargetted */
   int op;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */
   KeyInfo *pKeyDup = 0; /* Comparison information for duplicate removal */
   KeyInfo *pKeyMerge;   /* Comparison information for merging rows */
@@ -110557,19 +111574,19 @@ static int multiSelectOrderBy(
   ** left of the compound operator - the "A" select.
   */
   addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;
-  j1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrA, 0, addrSelectA);
+  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrA, 0, addrSelectA);
   VdbeComment((v, "left SELECT"));
   pPrior->iLimit = regLimitA;
   explainSetInteger(iSub1, pParse->iNextSelectId);
   sqlite3Select(pParse, pPrior, &destA);
   sqlite3VdbeAddOp1(v, OP_EndCoroutine, regAddrA);
-  sqlite3VdbeJumpHere(v, j1);
+  sqlite3VdbeJumpHere(v, addr1);
 
   /* Generate a coroutine to evaluate the SELECT statement on 
   ** the right - the "B" select
   */
   addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;
-  j1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrB, 0, addrSelectB);
+  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrB, 0, addrSelectB);
   VdbeComment((v, "right SELECT"));
   savedLimit = p->iLimit;
   savedOffset = p->iOffset;
@@ -110610,7 +111627,7 @@ static int multiSelectOrderBy(
     addrEofA = sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);
     addrEofA_noB = sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, labelEnd);
                                      VdbeCoverage(v);
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEofA);
+    sqlite3VdbeGoto(v, addrEofA);
     p->nSelectRow += pPrior->nSelectRow;
   }
 
@@ -110624,7 +111641,7 @@ static int multiSelectOrderBy(
     VdbeNoopComment((v, "eof-B subroutine"));
     addrEofB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);
     sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, labelEnd); VdbeCoverage(v);
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEofB);
+    sqlite3VdbeGoto(v, addrEofB);
   }
 
   /* Generate code to handle the case of A<B
@@ -110632,7 +111649,7 @@ static int multiSelectOrderBy(
   VdbeNoopComment((v, "A-lt-B subroutine"));
   addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);
   sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);
-  sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr);
+  sqlite3VdbeGoto(v, labelCmpr);
 
   /* Generate code to handle the case of A==B
   */
@@ -110645,7 +111662,7 @@ static int multiSelectOrderBy(
     VdbeNoopComment((v, "A-eq-B subroutine"));
     addrAeqB =
     sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr);
+    sqlite3VdbeGoto(v, labelCmpr);
   }
 
   /* Generate code to handle the case of A>B
@@ -110656,11 +111673,11 @@ static int multiSelectOrderBy(
     sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);
   }
   sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);
-  sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr);
+  sqlite3VdbeGoto(v, labelCmpr);
 
   /* This code runs once to initialize everything.
   */
-  sqlite3VdbeJumpHere(v, j1);
+  sqlite3VdbeJumpHere(v, addr1);
   sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA_noB); VdbeCoverage(v);
   sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);
 
@@ -110703,7 +111720,7 @@ static int multiSelectOrderBy(
 #if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
 /* Forward Declarations */
 static void substExprList(sqlite3*, ExprList*, int, ExprList*);
-static void substSelect(sqlite3*, Select *, int, ExprList *);
+static void substSelect(sqlite3*, Select *, int, ExprList*, int);
 
 /*
 ** Scan through the expression pExpr.  Replace every reference to
@@ -110740,7 +111757,7 @@ static Expr *substExpr(
     pExpr->pLeft = substExpr(db, pExpr->pLeft, iTable, pEList);
     pExpr->pRight = substExpr(db, pExpr->pRight, iTable, pEList);
     if( ExprHasProperty(pExpr, EP_xIsSelect) ){
-      substSelect(db, pExpr->x.pSelect, iTable, pEList);
+      substSelect(db, pExpr->x.pSelect, iTable, pEList, 1);
     }else{
       substExprList(db, pExpr->x.pList, iTable, pEList);
     }
@@ -110763,25 +111780,28 @@ static void substSelect(
   sqlite3 *db,         /* Report malloc errors here */
   Select *p,           /* SELECT statement in which to make substitutions */
   int iTable,          /* Table to be replaced */
-  ExprList *pEList     /* Substitute values */
+  ExprList *pEList,    /* Substitute values */
+  int doPrior          /* Do substitutes on p->pPrior too */
 ){
   SrcList *pSrc;
   struct SrcList_item *pItem;
   int i;
   if( !p ) return;
-  substExprList(db, p->pEList, iTable, pEList);
-  substExprList(db, p->pGroupBy, iTable, pEList);
-  substExprList(db, p->pOrderBy, iTable, pEList);
-  p->pHaving = substExpr(db, p->pHaving, iTable, pEList);
-  p->pWhere = substExpr(db, p->pWhere, iTable, pEList);
-  substSelect(db, p->pPrior, iTable, pEList);
-  pSrc = p->pSrc;
-  assert( pSrc );  /* Even for (SELECT 1) we have: pSrc!=0 but pSrc->nSrc==0 */
-  if( ALWAYS(pSrc) ){
+  do{
+    substExprList(db, p->pEList, iTable, pEList);
+    substExprList(db, p->pGroupBy, iTable, pEList);
+    substExprList(db, p->pOrderBy, iTable, pEList);
+    p->pHaving = substExpr(db, p->pHaving, iTable, pEList);
+    p->pWhere = substExpr(db, p->pWhere, iTable, pEList);
+    pSrc = p->pSrc;
+    assert( pSrc!=0 );
     for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
-      substSelect(db, pItem->pSelect, iTable, pEList);
+      substSelect(db, pItem->pSelect, iTable, pEList, 1);
+      if( pItem->fg.isTabFunc ){
+        substExprList(db, pItem->u1.pFuncArg, iTable, pEList);
+      }
     }
-  }
+  }while( doPrior && (p = p->pPrior)!=0 );
 }
 #endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */
 
@@ -110933,7 +111953,7 @@ static int flattenSubquery(
   int subqueryIsAgg    /* True if the subquery uses aggregate functions */
 ){
   const char *zSavedAuthContext = pParse->zAuthContext;
-  Select *pParent;
+  Select *pParent;    /* Current UNION ALL term of the other query */
   Select *pSub;       /* The inner query or "subquery" */
   Select *pSub1;      /* Pointer to the rightmost select in sub-query */
   SrcList *pSrc;      /* The FROM clause of the outer query */
@@ -111036,7 +112056,7 @@ static int flattenSubquery(
   ** is fraught with danger.  Best to avoid the whole thing.  If the
   ** subquery is the right term of a LEFT JOIN, then do not flatten.
   */
-  if( (pSubitem->jointype & JT_OUTER)!=0 ){
+  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){
     return 0;
   }
 
@@ -111207,7 +112227,7 @@ static int flattenSubquery(
 
     if( pSrc ){
       assert( pParent==p );  /* First time through the loop */
-      jointype = pSubitem->jointype;
+      jointype = pSubitem->fg.jointype;
     }else{
       assert( pParent!=p );  /* 2nd and subsequent times through the loop */
       pSrc = pParent->pSrc = sqlite3SrcListAppend(db, 0, 0, 0);
@@ -111228,9 +112248,9 @@ static int flattenSubquery(
     **
     ** The outer query has 3 slots in its FROM clause.  One slot of the
     ** outer query (the middle slot) is used by the subquery.  The next
-    ** block of code will expand the out query to 4 slots.  The middle
-    ** slot is expanded to two slots in order to make space for the
-    ** two elements in the FROM clause of the subquery.
+    ** block of code will expand the outer query FROM clause to 4 slots.
+    ** The middle slot is expanded to two slots in order to make space
+    ** for the two elements in the FROM clause of the subquery.
     */
     if( nSubSrc>1 ){
       pParent->pSrc = pSrc = sqlite3SrcListEnlarge(db, pSrc, nSubSrc-1,iFrom+1);
@@ -111247,7 +112267,7 @@ static int flattenSubquery(
       pSrc->a[i+iFrom] = pSubSrc->a[i];
       memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
     }
-    pSrc->a[iFrom].jointype = jointype;
+    pSrc->a[iFrom].fg.jointype = jointype;
   
     /* Now begin substituting subquery result set expressions for 
     ** references to the iParent in the outer query.
@@ -111269,11 +112289,6 @@ static int flattenSubquery(
         pList->a[i].zName = zName;
       }
     }
-    substExprList(db, pParent->pEList, iParent, pSub->pEList);
-    if( isAgg ){
-      substExprList(db, pParent->pGroupBy, iParent, pSub->pEList);
-      pParent->pHaving = substExpr(db, pParent->pHaving, iParent, pSub->pEList);
-    }
     if( pSub->pOrderBy ){
       /* At this point, any non-zero iOrderByCol values indicate that the
       ** ORDER BY column expression is identical to the iOrderByCol'th
@@ -111293,27 +112308,20 @@ static int flattenSubquery(
       assert( pSub->pPrior==0 );
       pParent->pOrderBy = pOrderBy;
       pSub->pOrderBy = 0;
-    }else if( pParent->pOrderBy ){
-      substExprList(db, pParent->pOrderBy, iParent, pSub->pEList);
-    }
-    if( pSub->pWhere ){
-      pWhere = sqlite3ExprDup(db, pSub->pWhere, 0);
-    }else{
-      pWhere = 0;
     }
+    pWhere = sqlite3ExprDup(db, pSub->pWhere, 0);
     if( subqueryIsAgg ){
       assert( pParent->pHaving==0 );
       pParent->pHaving = pParent->pWhere;
       pParent->pWhere = pWhere;
-      pParent->pHaving = substExpr(db, pParent->pHaving, iParent, pSub->pEList);
       pParent->pHaving = sqlite3ExprAnd(db, pParent->pHaving, 
                                   sqlite3ExprDup(db, pSub->pHaving, 0));
       assert( pParent->pGroupBy==0 );
       pParent->pGroupBy = sqlite3ExprListDup(db, pSub->pGroupBy, 0);
     }else{
-      pParent->pWhere = substExpr(db, pParent->pWhere, iParent, pSub->pEList);
       pParent->pWhere = sqlite3ExprAnd(db, pParent->pWhere, pWhere);
     }
+    substSelect(db, pParent, iParent, pSub->pEList, 0);
   
     /* The flattened query is distinct if either the inner or the
     ** outer query is distinct. 
@@ -111380,6 +112388,9 @@ static int flattenSubquery(
 **       enforces this restriction since this routine does not have enough
 **       information to know.)
 **
+**   (5) The WHERE clause expression originates in the ON or USING clause
+**       of a LEFT JOIN.
+**
 ** Return 0 if no changes are made and non-zero if one or more WHERE clause
 ** terms are duplicated into the subquery.
 */
@@ -111402,6 +112413,7 @@ static int pushDownWhereTerms(
     nChng += pushDownWhereTerms(db, pSubq, pWhere->pRight, iCursor);
     pWhere = pWhere->pLeft;
   }
+  if( ExprHasProperty(pWhere,EP_FromJoin) ) return 0; /* restriction 5 */
   if( sqlite3ExprIsTableConstant(pWhere, iCursor) ){
     nChng++;
     while( pSubq ){
@@ -111498,9 +112510,9 @@ static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){
 ** pFrom->pIndex and return SQLITE_OK.
 */
 SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){
-  if( pFrom->pTab && pFrom->zIndexedBy ){
+  if( pFrom->pTab && pFrom->fg.isIndexedBy ){
     Table *pTab = pFrom->pTab;
-    char *zIndexedBy = pFrom->zIndexedBy;
+    char *zIndexedBy = pFrom->u1.zIndexedBy;
     Index *pIdx;
     for(pIdx=pTab->pIndex; 
         pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy); 
@@ -111511,7 +112523,7 @@ SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pF
       pParse->checkSchema = 1;
       return SQLITE_ERROR;
     }
-    pFrom->pIndex = pIdx;
+    pFrom->pIBIndex = pIdx;
   }
   return SQLITE_OK;
 }
@@ -111672,12 +112684,12 @@ static int withExpand(
     int bMayRecursive;            /* True if compound joined by UNION [ALL] */
     With *pSavedWith;             /* Initial value of pParse->pWith */
 
-    /* If pCte->zErr is non-NULL at this point, then this is an illegal
+    /* If pCte->zCteErr is non-NULL at this point, then this is an illegal
     ** recursive reference to CTE pCte. Leave an error in pParse and return
-    ** early. If pCte->zErr is NULL, then this is not a recursive reference.
+    ** early. If pCte->zCteErr is NULL, then this is not a recursive reference.
     ** In this case, proceed.  */
-    if( pCte->zErr ){
-      sqlite3ErrorMsg(pParse, pCte->zErr, pCte->zName);
+    if( pCte->zCteErr ){
+      sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);
       return SQLITE_ERROR;
     }
 
@@ -111706,7 +112718,7 @@ static int withExpand(
          && 0==sqlite3StrICmp(pItem->zName, pCte->zName)
           ){
           pItem->pTab = pTab;
-          pItem->isRecursive = 1;
+          pItem->fg.isRecursive = 1;
           pTab->nRef++;
           pSel->selFlags |= SF_Recursive;
         }
@@ -111722,7 +112734,7 @@ static int withExpand(
     }
     assert( pTab->nRef==1 || ((pSel->selFlags&SF_Recursive) && pTab->nRef==2 ));
 
-    pCte->zErr = "circular reference: %s";
+    pCte->zCteErr = "circular reference: %s";
     pSavedWith = pParse->pWith;
     pParse->pWith = pWith;
     sqlite3WalkSelect(pWalker, bMayRecursive ? pSel->pPrior : pSel);
@@ -111740,16 +112752,16 @@ static int withExpand(
       pEList = pCte->pCols;
     }
 
-    selectColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);
+    sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);
     if( bMayRecursive ){
       if( pSel->selFlags & SF_Recursive ){
-        pCte->zErr = "multiple recursive references: %s";
+        pCte->zCteErr = "multiple recursive references: %s";
       }else{
-        pCte->zErr = "recursive reference in a subquery: %s";
+        pCte->zCteErr = "recursive reference in a subquery: %s";
       }
       sqlite3WalkSelect(pWalker, pSel);
     }
-    pCte->zErr = 0;
+    pCte->zCteErr = 0;
     pParse->pWith = pSavedWith;
   }
 
@@ -111836,17 +112848,9 @@ static int selectExpander(Walker *pWalker, Select *p){
   */
   for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
     Table *pTab;
-    assert( pFrom->isRecursive==0 || pFrom->pTab );
-    if( pFrom->isRecursive ) continue;
-    if( pFrom->pTab!=0 ){
-      /* This statement has already been prepared.  There is no need
-      ** to go further. */
-      assert( i==0 );
-#ifndef SQLITE_OMIT_CTE
-      selectPopWith(pWalker, p);
-#endif
-      return WRC_Prune;
-    }
+    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );
+    if( pFrom->fg.isRecursive ) continue;
+    assert( pFrom->pTab==0 );
 #ifndef SQLITE_OMIT_CTE
     if( withExpand(pWalker, pFrom) ) return WRC_Abort;
     if( pFrom->pTab ) {} else
@@ -111863,7 +112867,7 @@ static int selectExpander(Walker *pWalker, Select *p){
       pTab->nRef = 1;
       pTab->zName = sqlite3MPrintf(db, "sqlite_sq_%p", (void*)pTab);
       while( pSel->pPrior ){ pSel = pSel->pPrior; }
-      selectColumnsFromExprList(pParse, pSel->pEList, &pTab->nCol, &pTab->aCol);
+      sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);
       pTab->iPKey = -1;
       pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
       pTab->tabFlags |= TF_Ephemeral;
@@ -111882,12 +112886,19 @@ static int selectExpander(Walker *pWalker, Select *p){
       pTab->nRef++;
 #if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)
       if( pTab->pSelect || IsVirtual(pTab) ){
-        /* We reach here if the named table is a really a view */
+        i16 nCol;
         if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;
         assert( pFrom->pSelect==0 );
+        if( pFrom->fg.isTabFunc && !IsVirtual(pTab) ){
+          sqlite3ErrorMsg(pParse, "'%s' is not a function", pTab->zName);
+          return WRC_Abort;
+        }
         pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);
         sqlite3SelectSetName(pFrom->pSelect, pTab->zName);
+        nCol = pTab->nCol;
+        pTab->nCol = -1;
         sqlite3WalkSelect(pWalker, pFrom->pSelect);
+        pTab->nCol = nCol;
       }
 #endif
     }
@@ -112000,7 +113011,7 @@ static int selectExpander(Walker *pWalker, Select *p){
             tableSeen = 1;
 
             if( i>0 && zTName==0 ){
-              if( (pFrom->jointype & JT_NATURAL)!=0
+              if( (pFrom->fg.jointype & JT_NATURAL)!=0
                 && tableAndColumnIndex(pTabList, i, zName, 0, 0)
               ){
                 /* In a NATURAL join, omit the join columns from the 
@@ -112135,19 +113146,19 @@ static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){
   struct SrcList_item *pFrom;
 
   assert( p->selFlags & SF_Resolved );
-  if( (p->selFlags & SF_HasTypeInfo)==0 ){
-    p->selFlags |= SF_HasTypeInfo;
-    pParse = pWalker->pParse;
-    pTabList = p->pSrc;
-    for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
-      Table *pTab = pFrom->pTab;
-      if( ALWAYS(pTab!=0) && (pTab->tabFlags & TF_Ephemeral)!=0 ){
-        /* A sub-query in the FROM clause of a SELECT */
-        Select *pSel = pFrom->pSelect;
-        if( pSel ){
-          while( pSel->pPrior ) pSel = pSel->pPrior;
-          selectAddColumnTypeAndCollation(pParse, pTab, pSel);
-        }
+  assert( (p->selFlags & SF_HasTypeInfo)==0 );
+  p->selFlags |= SF_HasTypeInfo;
+  pParse = pWalker->pParse;
+  pTabList = p->pSrc;
+  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
+    Table *pTab = pFrom->pTab;
+    assert( pTab!=0 );
+    if( (pTab->tabFlags & TF_Ephemeral)!=0 ){
+      /* A sub-query in the FROM clause of a SELECT */
+      Select *pSel = pFrom->pSelect;
+      if( pSel ){
+        while( pSel->pPrior ) pSel = pSel->pPrior;
+        selectAddColumnTypeAndCollation(pParse, pTab, pSel);
       }
     }
   }
@@ -112286,7 +113297,7 @@ static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo){
     if( pList ){
       nArg = pList->nExpr;
       regAgg = sqlite3GetTempRange(pParse, nArg);
-      sqlite3ExprCodeExprList(pParse, pList, regAgg, SQLITE_ECEL_DUP);
+      sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, SQLITE_ECEL_DUP);
     }else{
       nArg = 0;
       regAgg = 0;
@@ -112473,7 +113484,17 @@ SQLITE_PRIVATE int sqlite3Select(
     struct SrcList_item *pItem = &pTabList->a[i];
     Select *pSub = pItem->pSelect;
     int isAggSub;
+    Table *pTab = pItem->pTab;
     if( pSub==0 ) continue;
+
+    /* Catch mismatch in the declared columns of a view and the number of
+    ** columns in the SELECT on the RHS */
+    if( pTab->nCol!=pSub->pEList->nExpr ){
+      sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d",
+                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);
+      goto select_end;
+    }
+
     isAggSub = (pSub->selFlags & SF_Aggregate)!=0;
     if( flattenSubquery(pParse, p, i, isAgg, isAggSub) ){
       /* This subquery can be absorbed into its parent. */
@@ -112527,7 +113548,7 @@ SQLITE_PRIVATE int sqlite3Select(
     ** is sufficient, though the subroutine to manifest the view does need
     ** to be invoked again. */
     if( pItem->addrFillSub ){
-      if( pItem->viaCoroutine==0 ){
+      if( pItem->fg.viaCoroutine==0 ){
         sqlite3VdbeAddOp2(v, OP_Gosub, pItem->regReturn, pItem->addrFillSub);
       }
       continue;
@@ -112545,7 +113566,7 @@ SQLITE_PRIVATE int sqlite3Select(
     /* Make copies of constant WHERE-clause terms in the outer query down
     ** inside the subquery.  This can help the subquery to run more efficiently.
     */
-    if( (pItem->jointype & JT_OUTER)==0
+    if( (pItem->fg.jointype & JT_OUTER)==0
      && pushDownWhereTerms(db, pSub, p->pWhere, pItem->iCursor)
     ){
 #if SELECTTRACE_ENABLED
@@ -112574,7 +113595,7 @@ SQLITE_PRIVATE int sqlite3Select(
       explainSetInteger(pItem->iSelectId, (u8)pParse->iNextSelectId);
       sqlite3Select(pParse, pSub, &dest);
       pItem->pTab->nRowLogEst = sqlite3LogEst(pSub->nSelectRow);
-      pItem->viaCoroutine = 1;
+      pItem->fg.viaCoroutine = 1;
       pItem->regResult = dest.iSdst;
       sqlite3VdbeAddOp1(v, OP_EndCoroutine, pItem->regReturn);
       sqlite3VdbeJumpHere(v, addrTop-1);
@@ -112592,7 +113613,7 @@ SQLITE_PRIVATE int sqlite3Select(
       pItem->regReturn = ++pParse->nMem;
       topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);
       pItem->addrFillSub = topAddr+1;
-      if( pItem->isCorrelated==0 ){
+      if( pItem->fg.isCorrelated==0 ){
         /* If the subquery is not correlated and if we are not inside of
         ** a trigger, then we only need to compute the value of the subquery
         ** once. */
@@ -112690,7 +113711,7 @@ SQLITE_PRIVATE int sqlite3Select(
   p->nSelectRow = LARGEST_INT64;
   computeLimitRegisters(pParse, p, iEnd);
   if( p->iLimit==0 && sSort.addrSortIndex>=0 ){
-    sqlite3VdbeGetOp(v, sSort.addrSortIndex)->opcode = OP_SorterOpen;
+    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);
     sSort.sortFlags |= SORTFLAG_UseSorter;
   }
 
@@ -112825,7 +113846,7 @@ SQLITE_PRIVATE int sqlite3Select(
     */
     if( pGroupBy ){
       KeyInfo *pKeyInfo;  /* Keying information for the group by clause */
-      int j1;             /* A-vs-B comparision jump */
+      int addr1;          /* A-vs-B comparision jump */
       int addrOutputRow;  /* Start of subroutine that outputs a result row */
       int regOutputRow;   /* Return address register for output subroutine */
       int addrSetAbort;   /* Set the abort flag and return */
@@ -112906,7 +113927,7 @@ SQLITE_PRIVATE int sqlite3Select(
         }
         regBase = sqlite3GetTempRange(pParse, nCol);
         sqlite3ExprCacheClear(pParse);
-        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0);
+        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);
         j = nGroupBy;
         for(i=0; i<sAggInfo.nColumn; i++){
           struct AggInfo_col *pCol = &sAggInfo.aCol[i];
@@ -112973,8 +113994,8 @@ SQLITE_PRIVATE int sqlite3Select(
       }
       sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,
                           (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
-      j1 = sqlite3VdbeCurrentAddr(v);
-      sqlite3VdbeAddOp3(v, OP_Jump, j1+1, 0, j1+1); VdbeCoverage(v);
+      addr1 = sqlite3VdbeCurrentAddr(v);
+      sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);
 
       /* Generate code that runs whenever the GROUP BY changes.
       ** Changes in the GROUP BY are detected by the previous code
@@ -112996,7 +114017,7 @@ SQLITE_PRIVATE int sqlite3Select(
       /* Update the aggregate accumulators based on the content of
       ** the current row
       */
-      sqlite3VdbeJumpHere(v, j1);
+      sqlite3VdbeJumpHere(v, addr1);
       updateAccumulator(pParse, &sAggInfo);
       sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);
       VdbeComment((v, "indicate data in accumulator"));
@@ -113018,7 +114039,7 @@ SQLITE_PRIVATE int sqlite3Select(
 
       /* Jump over the subroutines
       */
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEnd);
+      sqlite3VdbeGoto(v, addrEnd);
 
       /* Generate a subroutine that outputs a single row of the result
       ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag
@@ -113172,7 +114193,7 @@ SQLITE_PRIVATE int sqlite3Select(
         updateAccumulator(pParse, &sAggInfo);
         assert( pMinMax==0 || pMinMax->nExpr==1 );
         if( sqlite3WhereIsOrdered(pWInfo)>0 ){
-          sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3WhereBreakLabel(pWInfo));
+          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));
           VdbeComment((v, "%s() by index",
                 (flag==WHERE_ORDERBY_MIN?"min":"max")));
         }
@@ -114695,9 +115716,9 @@ SQLITE_PRIVATE void sqlite3Update(
 
   /* Register Allocations */
   int regRowCount = 0;   /* A count of rows changed */
-  int regOldRowid;       /* The old rowid */
-  int regNewRowid;       /* The new rowid */
-  int regNew;            /* Content of the NEW.* table in triggers */
+  int regOldRowid = 0;   /* The old rowid */
+  int regNewRowid = 0;   /* The new rowid */
+  int regNew = 0;        /* Content of the NEW.* table in triggers */
   int regOld = 0;        /* Content of OLD.* table in triggers */
   int regRowSet = 0;     /* Rowset of rows to be updated */
   int regKey = 0;        /* composite PRIMARY KEY value */
@@ -114833,7 +115854,9 @@ SQLITE_PRIVATE void sqlite3Update(
 
   /* There is one entry in the aRegIdx[] array for each index on the table
   ** being updated.  Fill in aRegIdx[] with a register number that will hold
-  ** the key for accessing each index.  
+  ** the key for accessing each index.
+  **
+  ** FIXME:  Be smarter about omitting indexes that use expressions.
   */
   for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
     int reg;
@@ -114842,7 +115865,8 @@ SQLITE_PRIVATE void sqlite3Update(
     }else{
       reg = 0;
       for(i=0; i<pIdx->nKeyCol; i++){
-        if( aXRef[pIdx->aiColumn[i]]>=0 ){
+        i16 iIdxCol = pIdx->aiColumn[i];
+        if( iIdxCol<0 || aXRef[iIdxCol]>=0 ){
           reg = ++pParse->nMem;
           break;
         }
@@ -114858,29 +115882,20 @@ SQLITE_PRIVATE void sqlite3Update(
   if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
   sqlite3BeginWriteOperation(pParse, 1, iDb);
 
-#ifndef SQLITE_OMIT_VIRTUALTABLE
-  /* Virtual tables must be handled separately */
-  if( IsVirtual(pTab) ){
-    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,
-                       pWhere, onError);
-    pWhere = 0;
-    pTabList = 0;
-    goto update_cleanup;
-  }
-#endif
-
   /* Allocate required registers. */
-  regRowSet = ++pParse->nMem;
-  regOldRowid = regNewRowid = ++pParse->nMem;
-  if( chngPk || pTrigger || hasFK ){
-    regOld = pParse->nMem + 1;
+  if( !IsVirtual(pTab) ){
+    regRowSet = ++pParse->nMem;
+    regOldRowid = regNewRowid = ++pParse->nMem;
+    if( chngPk || pTrigger || hasFK ){
+      regOld = pParse->nMem + 1;
+      pParse->nMem += pTab->nCol;
+    }
+    if( chngKey || pTrigger || hasFK ){
+      regNewRowid = ++pParse->nMem;
+    }
+    regNew = pParse->nMem + 1;
     pParse->nMem += pTab->nCol;
   }
-  if( chngKey || pTrigger || hasFK ){
-    regNewRowid = ++pParse->nMem;
-  }
-  regNew = pParse->nMem + 1;
-  pParse->nMem += pTab->nCol;
 
   /* Start the view context. */
   if( isView ){
@@ -114903,6 +115918,15 @@ SQLITE_PRIVATE void sqlite3Update(
     goto update_cleanup;
   }
 
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+  /* Virtual tables must be handled separately */
+  if( IsVirtual(pTab) ){
+    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,
+                       pWhere, onError);
+    goto update_cleanup;
+  }
+#endif
+
   /* Begin the database scan
   */
   if( HasRowid(pTab) ){
@@ -114942,6 +115966,7 @@ SQLITE_PRIVATE void sqlite3Update(
     if( pWInfo==0 ) goto update_cleanup;
     okOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
     for(i=0; i<nPk; i++){
+      assert( pPk->aiColumn[i]>=0 );
       sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, pPk->aiColumn[i],
                                       iPk+i);
     }
@@ -114951,7 +115976,7 @@ SQLITE_PRIVATE void sqlite3Update(
       regKey = iPk;
     }else{
       sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,
-                        sqlite3IndexAffinityStr(v, pPk), nPk);
+                        sqlite3IndexAffinityStr(db, pPk), nPk);
       sqlite3VdbeAddOp2(v, OP_IdxInsert, iEph, regKey);
     }
     sqlite3WhereEnd(pWInfo);
@@ -115064,7 +116089,6 @@ SQLITE_PRIVATE void sqlite3Update(
   newmask = sqlite3TriggerColmask(
       pParse, pTrigger, pChanges, 1, TRIGGER_BEFORE, pTab, onError
   );
-  /*sqlite3VdbeAddOp3(v, OP_Null, 0, regNew, regNew+pTab->nCol-1);*/
   for(i=0; i<pTab->nCol; i++){
     if( i==pTab->iPKey ){
       sqlite3VdbeAddOp2(v, OP_Null, 0, regNew+i);
@@ -115122,7 +116146,7 @@ SQLITE_PRIVATE void sqlite3Update(
   }
 
   if( !isView ){
-    int j1 = 0;           /* Address of jump instruction */
+    int addr1 = 0;        /* Address of jump instruction */
     int bReplace = 0;     /* True if REPLACE conflict resolution might happen */
 
     /* Do constraint checks. */
@@ -115138,20 +116162,20 @@ SQLITE_PRIVATE void sqlite3Update(
     /* Delete the index entries associated with the current record.  */
     if( bReplace || chngKey ){
       if( pPk ){
-        j1 = sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, 0, regKey, nKey);
+        addr1 = sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, 0, regKey, nKey);
       }else{
-        j1 = sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, 0, regOldRowid);
+        addr1 = sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, 0, regOldRowid);
       }
       VdbeCoverageNeverTaken(v);
     }
-    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx);
+    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);
   
     /* If changing the record number, delete the old record.  */
     if( hasFK || chngKey || pPk!=0 ){
       sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, 0);
     }
     if( bReplace || chngKey ){
-      sqlite3VdbeJumpHere(v, j1);
+      sqlite3VdbeJumpHere(v, addr1);
     }
 
     if( hasFK ){
@@ -115188,7 +116212,7 @@ SQLITE_PRIVATE void sqlite3Update(
     sqlite3VdbeResolveLabel(v, labelContinue);
     sqlite3VdbeAddOp2(v, OP_Next, iEph, addrTop); VdbeCoverage(v);
   }else{
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, labelContinue);
+    sqlite3VdbeGoto(v, labelContinue);
   }
   sqlite3VdbeResolveLabel(v, labelBreak);
 
@@ -115242,21 +116266,23 @@ SQLITE_PRIVATE void sqlite3Update(
 /*
 ** Generate code for an UPDATE of a virtual table.
 **
-** The strategy is that we create an ephemeral table that contains
+** There are two possible strategies - the default and the special 
+** "onepass" strategy. Onepass is only used if the virtual table 
+** implementation indicates that pWhere may match at most one row.
+**
+** The default strategy is to create an ephemeral table that contains
 ** for each row to be changed:
 **
 **   (A)  The original rowid of that row.
-**   (B)  The revised rowid for the row. (note1)
+**   (B)  The revised rowid for the row.
 **   (C)  The content of every column in the row.
 **
-** Then we loop over this ephemeral table and for each row in
-** the ephemeral table call VUpdate.
+** Then loop through the contents of this ephemeral table executing a
+** VUpdate for each row. When finished, drop the ephemeral table.
 **
-** When finished, drop the ephemeral table.
-**
-** (note1) Actually, if we know in advance that (A) is always the same
-** as (B) we only store (A), then duplicate (A) when pulling
-** it out of the ephemeral table before calling VUpdate.
+** The "onepass" strategy does not use an ephemeral table. Instead, it
+** stores the same values (A, B and C above) in a register array and
+** makes a single invocation of VUpdate.
 */
 static void updateVirtualTable(
   Parse *pParse,       /* The parsing context */
@@ -115269,66 +116295,96 @@ static void updateVirtualTable(
   int onError          /* ON CONFLICT strategy */
 ){
   Vdbe *v = pParse->pVdbe;  /* Virtual machine under construction */
-  ExprList *pEList = 0;     /* The result set of the SELECT statement */
-  Select *pSelect = 0;      /* The SELECT statement */
-  Expr *pExpr;              /* Temporary expression */
   int ephemTab;             /* Table holding the result of the SELECT */
   int i;                    /* Loop counter */
-  int addr;                 /* Address of top of loop */
-  int iReg;                 /* First register in set passed to OP_VUpdate */
   sqlite3 *db = pParse->db; /* Database connection */
   const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);
-  SelectDest dest;
-
-  /* Construct the SELECT statement that will find the new values for
-  ** all updated rows. 
-  */
-  pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ID, "_rowid_"));
+  WhereInfo *pWInfo;
+  int nArg = 2 + pTab->nCol;      /* Number of arguments to VUpdate */
+  int regArg;                     /* First register in VUpdate arg array */
+  int regRec;                     /* Register in which to assemble record */
+  int regRowid;                   /* Register for ephem table rowid */
+  int iCsr = pSrc->a[0].iCursor;  /* Cursor used for virtual table scan */
+  int aDummy[2];                  /* Unused arg for sqlite3WhereOkOnePass() */
+  int bOnePass;                   /* True to use onepass strategy */
+  int addr;                       /* Address of OP_OpenEphemeral */
+
+  /* Allocate nArg registers to martial the arguments to VUpdate. Then
+  ** create and open the ephemeral table in which the records created from
+  ** these arguments will be temporarily stored. */
+  assert( v );
+  ephemTab = pParse->nTab++;
+  addr= sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);
+  regArg = pParse->nMem + 1;
+  pParse->nMem += nArg;
+  regRec = ++pParse->nMem;
+  regRowid = ++pParse->nMem;
+
+  /* Start scanning the virtual table */
+  pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0,0,WHERE_ONEPASS_DESIRED,0);
+  if( pWInfo==0 ) return;
+
+  /* Populate the argument registers. */
+  sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);
   if( pRowid ){
-    pEList = sqlite3ExprListAppend(pParse, pEList,
-                                   sqlite3ExprDup(db, pRowid, 0));
+    sqlite3ExprCode(pParse, pRowid, regArg+1);
+  }else{
+    sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);
   }
-  assert( pTab->iPKey<0 );
   for(i=0; i<pTab->nCol; i++){
     if( aXRef[i]>=0 ){
-      pExpr = sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0);
+      sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);
     }else{
-      pExpr = sqlite3Expr(db, TK_ID, pTab->aCol[i].zName);
+      sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);
     }
-    pEList = sqlite3ExprListAppend(pParse, pEList, pExpr);
   }
-  pSelect = sqlite3SelectNew(pParse, pEList, pSrc, pWhere, 0, 0, 0, 0, 0, 0);
-  
-  /* Create the ephemeral table into which the update results will
-  ** be stored.
-  */
-  assert( v );
-  ephemTab = pParse->nTab++;
 
-  /* fill the ephemeral table 
-  */
-  sqlite3SelectDestInit(&dest, SRT_EphemTab, ephemTab);
-  sqlite3Select(pParse, pSelect, &dest);
+  bOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);
 
-  /* Generate code to scan the ephemeral table and call VUpdate. */
-  iReg = ++pParse->nMem;
-  pParse->nMem += pTab->nCol+1;
-  addr = sqlite3VdbeAddOp2(v, OP_Rewind, ephemTab, 0); VdbeCoverage(v);
-  sqlite3VdbeAddOp3(v, OP_Column,  ephemTab, 0, iReg);
-  sqlite3VdbeAddOp3(v, OP_Column, ephemTab, (pRowid?1:0), iReg+1);
-  for(i=0; i<pTab->nCol; i++){
-    sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i+1+(pRowid!=0), iReg+2+i);
+  if( bOnePass ){
+    /* If using the onepass strategy, no-op out the OP_OpenEphemeral coded
+    ** above. Also, if this is a top-level parse (not a trigger), clear the
+    ** multi-write flag so that the VM does not open a statement journal */
+    sqlite3VdbeChangeToNoop(v, addr);
+    if( sqlite3IsToplevel(pParse) ){
+      pParse->isMultiWrite = 0;
+    }
+  }else{
+    /* Create a record from the argument register contents and insert it into
+    ** the ephemeral table. */
+    sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);
+    sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);
+    sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);
+  }
+
+
+  if( bOnePass==0 ){
+    /* End the virtual table scan */
+    sqlite3WhereEnd(pWInfo);
+
+    /* Begin scannning through the ephemeral table. */
+    addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);
+
+    /* Extract arguments from the current row of the ephemeral table and 
+    ** invoke the VUpdate method.  */
+    for(i=0; i<nArg; i++){
+      sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i, regArg+i);
+    }
   }
   sqlite3VtabMakeWritable(pParse, pTab);
-  sqlite3VdbeAddOp4(v, OP_VUpdate, 0, pTab->nCol+2, iReg, pVTab, P4_VTAB);
+  sqlite3VdbeAddOp4(v, OP_VUpdate, 0, nArg, regArg, pVTab, P4_VTAB);
   sqlite3VdbeChangeP5(v, onError==OE_Default ? OE_Abort : onError);
   sqlite3MayAbort(pParse);
-  sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr+1); VdbeCoverage(v);
-  sqlite3VdbeJumpHere(v, addr);
-  sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);
 
-  /* Cleanup */
-  sqlite3SelectDelete(db, pSelect);  
+  /* End of the ephemeral table scan. Or, if using the onepass strategy,
+  ** jump to here if the scan visited zero rows. */
+  if( bOnePass==0 ){
+    sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr+1); VdbeCoverage(v);
+    sqlite3VdbeJumpHere(v, addr);
+    sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);
+  }else{
+    sqlite3WhereEnd(pWInfo);
+  }
 }
 #endif /* SQLITE_OMIT_VIRTUALTABLE */
 
@@ -115770,6 +116826,7 @@ static int createModule(
       pMod->pModule = pModule;
       pMod->pAux = pAux;
       pMod->xDestroy = xDestroy;
+      pMod->pEpoTab = 0;
       pDel = (Module *)sqlite3HashInsert(&db->aModule,zCopy,(void*)pMod);
       assert( pDel==0 || pDel==pMod );
       if( pDel ){
@@ -115997,23 +117054,17 @@ SQLITE_PRIVATE void sqlite3VtabClear(sqlite3 *db, Table *p){
 ** deleted.
 */
 static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){
-  int i = pTable->nModuleArg++;
-  int nBytes = sizeof(char *)*(1+pTable->nModuleArg);
+  int nBytes = sizeof(char *)*(2+pTable->nModuleArg);
   char **azModuleArg;
   azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);
   if( azModuleArg==0 ){
-    int j;
-    for(j=0; j<i; j++){
-      sqlite3DbFree(db, pTable->azModuleArg[j]);
-    }
     sqlite3DbFree(db, zArg);
-    sqlite3DbFree(db, pTable->azModuleArg);
-    pTable->nModuleArg = 0;
   }else{
+    int i = pTable->nModuleArg++;
     azModuleArg[i] = zArg;
     azModuleArg[i+1] = 0;
+    pTable->azModuleArg = azModuleArg;
   }
-  pTable->azModuleArg = azModuleArg;
 }
 
 /*
@@ -116140,7 +117191,7 @@ SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){
     sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);
 
     iReg = ++pParse->nMem;
-    sqlite3VdbeAddOp4(v, OP_String8, 0, iReg, 0, pTab->zName, 0);
+    sqlite3VdbeLoadString(v, iReg, pTab->zName);
     sqlite3VdbeAddOp2(v, OP_VCreate, iDb, iReg);
   }
 
@@ -116416,7 +117467,7 @@ SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab,
   ** invoke it now. If the module has not been registered, return an 
   ** error. Otherwise, do nothing.
   */
-  if( !pMod ){
+  if( pMod==0 || pMod->pModule->xCreate==0 || pMod->pModule->xDestroy==0 ){
     *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
     rc = SQLITE_ERROR;
   }else{
@@ -116518,6 +117569,7 @@ SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab
   pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);
   if( ALWAYS(pTab!=0 && pTab->pVTable!=0) ){
     VTable *p;
+    int (*xDestroy)(sqlite3_vtab *);
     for(p=pTab->pVTable; p; p=p->pNext){
       assert( p->pVtab );
       if( p->pVtab->nRef>0 ){
@@ -116525,7 +117577,9 @@ SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab
       }
     }
     p = vtabDisconnectAll(db, pTab);
-    rc = p->pMod->pModule->xDestroy(p->pVtab);
+    xDestroy = p->pMod->pModule->xDestroy;
+    assert( xDestroy!=0 );  /* Checked before the virtual table is created */
+    rc = xDestroy(p->pVtab);
     /* Remove the sqlite3_vtab* from the aVTrans[] array, if applicable */
     if( rc==SQLITE_OK ){
       assert( pTab->pVTable==p && p->pNext==0 );
@@ -116651,7 +117705,9 @@ SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){
     if( rc==SQLITE_OK ){
       rc = pModule->xBegin(pVTab->pVtab);
       if( rc==SQLITE_OK ){
+        int iSvpt = db->nStatement + db->nSavepoint;
         addToVTrans(db, pVTab);
+        if( iSvpt ) rc = sqlite3VtabSavepoint(db, SAVEPOINT_BEGIN, iSvpt-1);
       }
     }
   }
@@ -116804,6 +117860,67 @@ SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){
   }
 }
 
+/*
+** Check to see if virtual tale module pMod can be have an eponymous
+** virtual table instance.  If it can, create one if one does not already
+** exist. Return non-zero if the eponymous virtual table instance exists
+** when this routine returns, and return zero if it does not exist.
+**
+** An eponymous virtual table instance is one that is named after its
+** module, and more importantly, does not require a CREATE VIRTUAL TABLE
+** statement in order to come into existance.  Eponymous virtual table
+** instances always exist.  They cannot be DROP-ed.
+**
+** Any virtual table module for which xConnect and xCreate are the same
+** method can have an eponymous virtual table instance.
+*/
+SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod){
+  const sqlite3_module *pModule = pMod->pModule;
+  Table *pTab;
+  char *zErr = 0;
+  int nName;
+  int rc;
+  sqlite3 *db = pParse->db;
+  if( pMod->pEpoTab ) return 1;
+  if( pModule->xCreate!=0 && pModule->xCreate!=pModule->xConnect ) return 0;
+  nName = sqlite3Strlen30(pMod->zName) + 1;
+  pTab = sqlite3DbMallocZero(db, sizeof(Table) + nName);
+  if( pTab==0 ) return 0;
+  pMod->pEpoTab = pTab;
+  pTab->zName = (char*)&pTab[1];
+  memcpy(pTab->zName, pMod->zName, nName);
+  pTab->nRef = 1;
+  pTab->pSchema = db->aDb[0].pSchema;
+  pTab->tabFlags |= TF_Virtual;
+  pTab->nModuleArg = 0;
+  pTab->iPKey = -1;
+  addModuleArgument(db, pTab, sqlite3DbStrDup(db, pTab->zName));
+  addModuleArgument(db, pTab, 0);
+  addModuleArgument(db, pTab, sqlite3DbStrDup(db, pTab->zName));
+  rc = vtabCallConstructor(db, pTab, pMod, pModule->xConnect, &zErr);
+  if( rc ){
+    sqlite3ErrorMsg(pParse, "%s", zErr);
+    sqlite3DbFree(db, zErr);
+    sqlite3VtabEponymousTableClear(db, pMod);
+    return 0;
+  }
+  return 1;
+}
+
+/*
+** Erase the eponymous virtual table instance associated with
+** virtual table module pMod, if it exists.
+*/
+SQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3 *db, Module *pMod){
+  Table *pTab = pMod->pEpoTab;
+  if( pTab!=0 ){
+    sqlite3DeleteColumnNames(db, pTab);
+    sqlite3VtabClear(db, pTab);
+    sqlite3DbFree(db, pTab);
+    pMod->pEpoTab = 0;
+  }
+}
+
 /*
 ** Return the ON CONFLICT resolution mode in effect for the virtual
 ** table update operation currently in progress.
@@ -117174,12 +118291,14 @@ struct WhereScan {
   WhereClause *pOrigWC;      /* Original, innermost WhereClause */
   WhereClause *pWC;          /* WhereClause currently being scanned */
   char *zCollName;           /* Required collating sequence, if not NULL */
+  Expr *pIdxExpr;            /* Search for this index expression */
   char idxaff;               /* Must match this affinity, if zCollName!=NULL */
   unsigned char nEquiv;      /* Number of entries in aEquiv[] */
   unsigned char iEquiv;      /* Next unused slot in aEquiv[] */
   u32 opMask;                /* Acceptable operators */
   int k;                     /* Resume scanning at this->pWC->a[this->k] */
-  int aEquiv[22];            /* Cursor,Column pairs for equivalence classes */
+  int aiCur[11];             /* Cursors in the equivalence class */
+  i16 aiColumn[11];          /* Corresponding column number in the eq-class */
 };
 
 /*
@@ -117298,7 +118417,7 @@ struct WhereInfo {
   u16 wctrlFlags;           /* Flags originally passed to sqlite3WhereBegin() */
   i8 nOBSat;                /* Number of ORDER BY terms satisfied by indices */
   u8 sorted;                /* True if really sorted (not just grouped) */
-  u8 okOnePass;             /* Ok to use one-pass algorithm for UPDATE/DELETE */
+  u8 eOnePass;              /* ONEPASS_OFF, or _SINGLE, or _MULTI */
   u8 untestedTerms;         /* Not all WHERE terms resolved by outer loop */
   u8 eDistinct;             /* One of the WHERE_DISTINCT_* values below */
   u8 nLevel;                /* Number of nested loop */
@@ -117363,6 +118482,7 @@ SQLITE_PRIVATE void sqlite3WhereSplit(WhereClause*,Expr*,u8);
 SQLITE_PRIVATE Bitmask sqlite3WhereExprUsage(WhereMaskSet*, Expr*);
 SQLITE_PRIVATE Bitmask sqlite3WhereExprListUsage(WhereMaskSet*, ExprList*);
 SQLITE_PRIVATE void sqlite3WhereExprAnalyze(SrcList*, WhereClause*);
+SQLITE_PRIVATE void sqlite3WhereTabFuncArgs(Parse*, struct SrcList_item*, WhereClause*);
 
 
 
@@ -117440,6 +118560,16 @@ static void explainAppendTerm(
   sqlite3StrAccumAppend(pStr, "?", 1);
 }
 
+/*
+** Return the name of the i-th column of the pIdx index.
+*/
+static const char *explainIndexColumnName(Index *pIdx, int i){
+  i = pIdx->aiColumn[i];
+  if( i==XN_EXPR ) return "<expr>";
+  if( i==XN_ROWID ) return "rowid";
+  return pIdx->pTable->aCol[i].zName;
+}
+
 /*
 ** Argument pLevel describes a strategy for scanning table pTab. This 
 ** function appends text to pStr that describes the subset of table
@@ -117454,33 +118584,27 @@ static void explainAppendTerm(
 **
 **   "a=? AND b>?"
 */
-static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop, Table *pTab){
+static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop){
   Index *pIndex = pLoop->u.btree.pIndex;
   u16 nEq = pLoop->u.btree.nEq;
   u16 nSkip = pLoop->nSkip;
   int i, j;
-  Column *aCol = pTab->aCol;
-  i16 *aiColumn = pIndex->aiColumn;
 
   if( nEq==0 && (pLoop->wsFlags&(WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))==0 ) return;
   sqlite3StrAccumAppend(pStr, " (", 2);
   for(i=0; i<nEq; i++){
-    char *z = aiColumn[i] < 0 ? "rowid" : aCol[aiColumn[i]].zName;
-    if( i>=nSkip ){
-      explainAppendTerm(pStr, i, z, "=");
-    }else{
-      if( i ) sqlite3StrAccumAppend(pStr, " AND ", 5);
-      sqlite3XPrintf(pStr, 0, "ANY(%s)", z);
-    }
+    const char *z = explainIndexColumnName(pIndex, i);
+    if( i ) sqlite3StrAccumAppend(pStr, " AND ", 5);
+    sqlite3XPrintf(pStr, 0, i>=nSkip ? "%s=?" : "ANY(%s)", z);
   }
 
   j = i;
   if( pLoop->wsFlags&WHERE_BTM_LIMIT ){
-    char *z = aiColumn[j] < 0 ? "rowid" : aCol[aiColumn[j]].zName;
+    const char *z = explainIndexColumnName(pIndex, i);
     explainAppendTerm(pStr, i++, z, ">");
   }
   if( pLoop->wsFlags&WHERE_TOP_LIMIT ){
-    char *z = aiColumn[j] < 0 ? "rowid" : aCol[aiColumn[j]].zName;
+    const char *z = explainIndexColumnName(pIndex, j);
     explainAppendTerm(pStr, i, z, "<");
   }
   sqlite3StrAccumAppend(pStr, ")", 1);
@@ -117561,22 +118685,21 @@ SQLITE_PRIVATE int sqlite3WhereExplainOneScan(
       if( zFmt ){
         sqlite3StrAccumAppend(&str, " USING ", 7);
         sqlite3XPrintf(&str, 0, zFmt, pIdx->zName);
-        explainIndexRange(&str, pLoop, pItem->pTab);
+        explainIndexRange(&str, pLoop);
       }
     }else if( (flags & WHERE_IPK)!=0 && (flags & WHERE_CONSTRAINT)!=0 ){
-      const char *zRange;
+      const char *zRangeOp;
       if( flags&(WHERE_COLUMN_EQ|WHERE_COLUMN_IN) ){
-        zRange = "(rowid=?)";
+        zRangeOp = "=";
       }else if( (flags&WHERE_BOTH_LIMIT)==WHERE_BOTH_LIMIT ){
-        zRange = "(rowid>? AND rowid<?)";
+        zRangeOp = ">? AND rowid<";
       }else if( flags&WHERE_BTM_LIMIT ){
-        zRange = "(rowid>?)";
+        zRangeOp = ">";
       }else{
         assert( flags&WHERE_TOP_LIMIT);
-        zRange = "(rowid<?)";
+        zRangeOp = "<";
       }
-      sqlite3StrAccumAppendAll(&str, " USING INTEGER PRIMARY KEY ");
-      sqlite3StrAccumAppendAll(&str, zRange);
+      sqlite3XPrintf(&str, 0, " USING INTEGER PRIMARY KEY (rowid%s?)",zRangeOp);
     }
 #ifndef SQLITE_OMIT_VIRTUALTABLE
     else if( (flags & WHERE_VIRTUALTABLE)!=0 ){
@@ -117891,7 +119014,7 @@ static int codeAllEqualityTerms(
   nReg = pLoop->u.btree.nEq + nExtraReg;
   pParse->nMem += nReg;
 
-  zAff = sqlite3DbStrDup(pParse->db, sqlite3IndexAffinityStr(v, pIdx));
+  zAff = sqlite3DbStrDup(pParse->db,sqlite3IndexAffinityStr(pParse->db,pIdx));
   if( !zAff ){
     pParse->db->mallocFailed = 1;
   }
@@ -117910,8 +119033,8 @@ static int codeAllEqualityTerms(
     sqlite3VdbeJumpHere(v, j);
     for(j=0; j<nSkip; j++){
       sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, j, regBase+j);
-      assert( pIdx->aiColumn[j]>=0 );
-      VdbeComment((v, "%s", pIdx->pTable->aCol[pIdx->aiColumn[j]].zName));
+      testcase( pIdx->aiColumn[j]==XN_EXPR );
+      VdbeComment((v, "%s", explainIndexColumnName(pIdx, j)));
     }
   }    
 
@@ -118045,14 +119168,14 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
   ** initialize a memory cell that records if this table matches any
   ** row of the left table of the join.
   */
-  if( pLevel->iFrom>0 && (pTabItem[0].jointype & JT_LEFT)!=0 ){
+  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){
     pLevel->iLeftJoin = ++pParse->nMem;
     sqlite3VdbeAddOp2(v, OP_Integer, 0, pLevel->iLeftJoin);
     VdbeComment((v, "init LEFT JOIN no-match flag"));
   }
 
   /* Special case of a FROM clause subquery implemented as a co-routine */
-  if( pTabItem->viaCoroutine ){
+  if( pTabItem->fg.viaCoroutine ){
     int regYield = pTabItem->regReturn;
     sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);
     pLevel->p2 =  sqlite3VdbeAddOp2(v, OP_Yield, regYield, addrBrk);
@@ -118096,8 +119219,8 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
         disableTerm(pLevel, pLoop->aLTerm[j]);
       }
     }
-    pLevel->op = OP_VNext;
     pLevel->p1 = iCur;
+    pLevel->op = pWInfo->eOnePass ? OP_Noop : OP_VNext;
     pLevel->p2 = sqlite3VdbeCurrentAddr(v);
     sqlite3ReleaseTempRange(pParse, iReg, nConstraint+2);
     sqlite3ExprCachePop(pParse);
@@ -118465,7 +119588,12 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
       iRowidReg = ++pParse->nMem;
       sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, iRowidReg);
       sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);
-      sqlite3VdbeAddOp2(v, OP_Seek, iCur, iRowidReg);  /* Deferred seek */
+      if( pWInfo->eOnePass!=ONEPASS_OFF ){
+        sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, iRowidReg);
+        VdbeCoverage(v);
+      }else{
+        sqlite3VdbeAddOp2(v, OP_Seek, iCur, iRowidReg);  /* Deferred seek */
+      }
     }else if( iCur!=iIdxCur ){
       Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);
       iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);
@@ -118657,7 +119785,7 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
       if( pOrTerm->leftCursor==iCur || (pOrTerm->eOperator & WO_AND)!=0 ){
         WhereInfo *pSubWInfo;           /* Info for single OR-term scan */
         Expr *pOrExpr = pOrTerm->pExpr; /* Current OR clause term */
-        int j1 = 0;                     /* Address of jump operation */
+        int jmp1 = 0;                   /* Address of jump operation */
         if( pAndExpr && !ExprHasProperty(pOrExpr, EP_FromJoin) ){
           pAndExpr->pLeft = pOrExpr;
           pOrExpr = pAndExpr;
@@ -118684,7 +119812,8 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
             int iSet = ((ii==pOrWc->nTerm-1)?-1:ii);
             if( HasRowid(pTab) ){
               r = sqlite3ExprCodeGetColumn(pParse, pTab, -1, iCur, regRowid, 0);
-              j1 = sqlite3VdbeAddOp4Int(v, OP_RowSetTest, regRowset, 0, r,iSet);
+              jmp1 = sqlite3VdbeAddOp4Int(v, OP_RowSetTest, regRowset, 0,
+                                           r,iSet);
               VdbeCoverage(v);
             }else{
               Index *pPk = sqlite3PrimaryKeyIndex(pTab);
@@ -118714,7 +119843,7 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
               ** need to insert the key into the temp table, as it will never 
               ** be tested for.  */ 
               if( iSet ){
-                j1 = sqlite3VdbeAddOp4Int(v, OP_Found, regRowset, 0, r, nPk);
+                jmp1 = sqlite3VdbeAddOp4Int(v, OP_Found, regRowset, 0, r, nPk);
                 VdbeCoverage(v);
               }
               if( iSet>=0 ){
@@ -118733,7 +119862,7 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
 
           /* Jump here (skipping the main loop body subroutine) if the
           ** current sub-WHERE row is a duplicate from prior sub-WHEREs. */
-          if( j1 ) sqlite3VdbeJumpHere(v, j1);
+          if( jmp1 ) sqlite3VdbeJumpHere(v, jmp1);
 
           /* The pSubWInfo->untestedTerms flag means that this OR term
           ** contained one or more AND term from a notReady table.  The
@@ -118779,7 +119908,7 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
       sqlite3ExprDelete(db, pAndExpr);
     }
     sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, pLevel->addrBrk);
+    sqlite3VdbeGoto(v, pLevel->addrBrk);
     sqlite3VdbeResolveLabel(v, iLoopBody);
 
     if( pWInfo->nLevel>1 ) sqlite3StackFree(db, pOrTab);
@@ -118794,7 +119923,7 @@ SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(
     static const u8 aStep[] = { OP_Next, OP_Prev };
     static const u8 aStart[] = { OP_Rewind, OP_Last };
     assert( bRev==0 || bRev==1 );
-    if( pTabItem->isRecursive ){
+    if( pTabItem->fg.isRecursive ){
       /* Tables marked isRecursive have only a single row that is stored in
       ** a pseudo-cursor.  No need to Rewind or Next such cursors. */
       pLevel->op = OP_Noop;
@@ -119702,6 +120831,51 @@ static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){
   return mask;
 }
 
+/*
+** Expression pExpr is one operand of a comparison operator that might
+** be useful for indexing.  This routine checks to see if pExpr appears
+** in any index.  Return TRUE (1) if pExpr is an indexed term and return
+** FALSE (0) if not.  If TRUE is returned, also set *piCur to the cursor
+** number of the table that is indexed and *piColumn to the column number
+** of the column that is indexed, or -2 if an expression is being indexed.
+**
+** If pExpr is a TK_COLUMN column reference, then this routine always returns
+** true even if that particular column is not indexed, because the column
+** might be added to an automatic index later.
+*/
+static int exprMightBeIndexed(
+  SrcList *pFrom,        /* The FROM clause */
+  Bitmask mPrereq,       /* Bitmask of FROM clause terms referenced by pExpr */
+  Expr *pExpr,           /* An operand of a comparison operator */
+  int *piCur,            /* Write the referenced table cursor number here */
+  int *piColumn          /* Write the referenced table column number here */
+){
+  Index *pIdx;
+  int i;
+  int iCur;
+  if( pExpr->op==TK_COLUMN ){
+    *piCur = pExpr->iTable;
+    *piColumn = pExpr->iColumn;
+    return 1;
+  }
+  if( mPrereq==0 ) return 0;                 /* No table references */
+  if( (mPrereq&(mPrereq-1))!=0 ) return 0;   /* Refs more than one table */
+  for(i=0; mPrereq>1; i++, mPrereq>>=1){}
+  iCur = pFrom->a[i].iCursor;
+  for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){
+    if( pIdx->aColExpr==0 ) continue;
+    for(i=0; i<pIdx->nKeyCol; i++){
+      if( pIdx->aiColumn[i]!=(-2) ) continue;
+      if( sqlite3ExprCompare(pExpr, pIdx->aColExpr->a[i].pExpr, iCur)==0 ){
+        *piCur = iCur;
+        *piColumn = -2;
+        return 1;
+      }
+    }
+  }
+  return 0;
+}
+
 /*
 ** The input to this routine is an WhereTerm structure with only the
 ** "pExpr" field filled in.  The job of this routine is to analyze the
@@ -119772,16 +120946,19 @@ static void exprAnalyze(
   pTerm->iParent = -1;
   pTerm->eOperator = 0;
   if( allowedOp(op) ){
+    int iCur, iColumn;
     Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);
     Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);
     u16 opMask = (pTerm->prereqRight & prereqLeft)==0 ? WO_ALL : WO_EQUIV;
-    if( pLeft->op==TK_COLUMN ){
-      pTerm->leftCursor = pLeft->iTable;
-      pTerm->u.leftColumn = pLeft->iColumn;
+    if( exprMightBeIndexed(pSrc, prereqLeft, pLeft, &iCur, &iColumn) ){
+      pTerm->leftCursor = iCur;
+      pTerm->u.leftColumn = iColumn;
       pTerm->eOperator = operatorMask(op) & opMask;
     }
     if( op==TK_IS ) pTerm->wtFlags |= TERM_IS;
-    if( pRight && pRight->op==TK_COLUMN ){
+    if( pRight 
+     && exprMightBeIndexed(pSrc, pTerm->prereqRight, pRight, &iCur, &iColumn)
+    ){
       WhereTerm *pNew;
       Expr *pDup;
       u16 eExtraOp = 0;        /* Extra bits for pNew->eOperator */
@@ -119809,9 +120986,8 @@ static void exprAnalyze(
         pNew = pTerm;
       }
       exprCommute(pParse, pDup);
-      pLeft = sqlite3ExprSkipCollate(pDup->pLeft);
-      pNew->leftCursor = pLeft->iTable;
-      pNew->u.leftColumn = pLeft->iColumn;
+      pNew->leftCursor = iCur;
+      pNew->u.leftColumn = iColumn;
       testcase( (prereqLeft | extraRight) != prereqLeft );
       pNew->prereqRight = prereqLeft | extraRight;
       pNew->prereqAll = prereqAll;
@@ -120155,6 +121331,46 @@ SQLITE_PRIVATE void sqlite3WhereExprAnalyze(
   }
 }
 
+/*
+** For table-valued-functions, transform the function arguments into
+** new WHERE clause terms.  
+**
+** Each function argument translates into an equality constraint against
+** a HIDDEN column in the table.
+*/
+SQLITE_PRIVATE void sqlite3WhereTabFuncArgs(
+  Parse *pParse,                    /* Parsing context */
+  struct SrcList_item *pItem,       /* The FROM clause term to process */
+  WhereClause *pWC                  /* Xfer function arguments to here */
+){
+  Table *pTab;
+  int j, k;
+  ExprList *pArgs;
+  Expr *pColRef;
+  Expr *pTerm;
+  if( pItem->fg.isTabFunc==0 ) return;
+  pTab = pItem->pTab;
+  assert( pTab!=0 );
+  pArgs = pItem->u1.pFuncArg;
+  assert( pArgs!=0 );
+  for(j=k=0; j<pArgs->nExpr; j++){
+    while( k<pTab->nCol && (pTab->aCol[k].colFlags & COLFLAG_HIDDEN)==0 ){ k++; }
+    if( k>=pTab->nCol ){
+      sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d",
+                      pTab->zName, j);
+      return;
+    }
+    pColRef = sqlite3PExpr(pParse, TK_COLUMN, 0, 0, 0);
+    if( pColRef==0 ) return;
+    pColRef->iTable = pItem->iCursor;
+    pColRef->iColumn = k++;
+    pColRef->pTab = pTab;
+    pTerm = sqlite3PExpr(pParse, TK_EQ, pColRef,
+                         sqlite3ExprDup(pParse->db, pArgs->a[j].pExpr, 0), 0);
+    whereClauseInsert(pWC, pTerm, TERM_DYNAMIC);
+  }
+}
+
 /************** End of whereexpr.c *******************************************/
 /************** Begin file where.c *******************************************/
 /*
@@ -120228,9 +121444,11 @@ SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo *pWInfo){
 }
 
 /*
-** Return TRUE if an UPDATE or DELETE statement can operate directly on
-** the rowids returned by a WHERE clause.  Return FALSE if doing an
-** UPDATE or DELETE might change subsequent WHERE clause results.
+** Return ONEPASS_OFF (0) if an UPDATE or DELETE statement is unable to
+** operate directly on the rowis returned by a WHERE clause.  Return
+** ONEPASS_SINGLE (1) if the statement can operation directly because only
+** a single row is to be changed.  Return ONEPASS_MULTI (2) if the one-pass
+** optimization can be used on multiple 
 **
 ** If the ONEPASS optimization is used (if this routine returns true)
 ** then also write the indices of open cursors used by ONEPASS
@@ -120244,7 +121462,14 @@ SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo *pWInfo){
 */
 SQLITE_PRIVATE int sqlite3WhereOkOnePass(WhereInfo *pWInfo, int *aiCur){
   memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int)*2);
-  return pWInfo->okOnePass;
+#ifdef WHERETRACE_ENABLED
+  if( sqlite3WhereTrace && pWInfo->eOnePass!=ONEPASS_OFF ){
+    sqlite3DebugPrintf("%s cursors: %d %d\n",
+         pWInfo->eOnePass==ONEPASS_SINGLE ? "ONEPASS_SINGLE" : "ONEPASS_MULTI",
+         aiCur[0], aiCur[1]);
+  }
+#endif
+  return pWInfo->eOnePass;
 }
 
 /*
@@ -120330,37 +121555,39 @@ static void createMask(WhereMaskSet *pMaskSet, int iCursor){
 */
 static WhereTerm *whereScanNext(WhereScan *pScan){
   int iCur;            /* The cursor on the LHS of the term */
-  int iColumn;         /* The column on the LHS of the term.  -1 for IPK */
+  i16 iColumn;         /* The column on the LHS of the term.  -1 for IPK */
   Expr *pX;            /* An expression being tested */
   WhereClause *pWC;    /* Shorthand for pScan->pWC */
   WhereTerm *pTerm;    /* The term being tested */
   int k = pScan->k;    /* Where to start scanning */
 
   while( pScan->iEquiv<=pScan->nEquiv ){
-    iCur = pScan->aEquiv[pScan->iEquiv-2];
-    iColumn = pScan->aEquiv[pScan->iEquiv-1];
+    iCur = pScan->aiCur[pScan->iEquiv-1];
+    iColumn = pScan->aiColumn[pScan->iEquiv-1];
+    if( iColumn==XN_EXPR && pScan->pIdxExpr==0 ) return 0;
     while( (pWC = pScan->pWC)!=0 ){
       for(pTerm=pWC->a+k; k<pWC->nTerm; k++, pTerm++){
         if( pTerm->leftCursor==iCur
          && pTerm->u.leftColumn==iColumn
-         && (pScan->iEquiv<=2 || !ExprHasProperty(pTerm->pExpr, EP_FromJoin))
+         && (iColumn!=XN_EXPR
+             || sqlite3ExprCompare(pTerm->pExpr->pLeft,pScan->pIdxExpr,iCur)==0)
+         && (pScan->iEquiv<=1 || !ExprHasProperty(pTerm->pExpr, EP_FromJoin))
         ){
           if( (pTerm->eOperator & WO_EQUIV)!=0
-           && pScan->nEquiv<ArraySize(pScan->aEquiv)
+           && pScan->nEquiv<ArraySize(pScan->aiCur)
+           && (pX = sqlite3ExprSkipCollate(pTerm->pExpr->pRight))->op==TK_COLUMN
           ){
             int j;
-            pX = sqlite3ExprSkipCollate(pTerm->pExpr->pRight);
-            assert( pX->op==TK_COLUMN );
-            for(j=0; j<pScan->nEquiv; j+=2){
-              if( pScan->aEquiv[j]==pX->iTable
-               && pScan->aEquiv[j+1]==pX->iColumn ){
+            for(j=0; j<pScan->nEquiv; j++){
+              if( pScan->aiCur[j]==pX->iTable
+               && pScan->aiColumn[j]==pX->iColumn ){
                   break;
               }
             }
             if( j==pScan->nEquiv ){
-              pScan->aEquiv[j] = pX->iTable;
-              pScan->aEquiv[j+1] = pX->iColumn;
-              pScan->nEquiv += 2;
+              pScan->aiCur[j] = pX->iTable;
+              pScan->aiColumn[j] = pX->iColumn;
+              pScan->nEquiv++;
             }
           }
           if( (pTerm->eOperator & pScan->opMask)!=0 ){
@@ -120382,8 +121609,8 @@ static WhereTerm *whereScanNext(WhereScan *pScan){
             }
             if( (pTerm->eOperator & (WO_EQ|WO_IS))!=0
              && (pX = pTerm->pExpr->pRight)->op==TK_COLUMN
-             && pX->iTable==pScan->aEquiv[0]
-             && pX->iColumn==pScan->aEquiv[1]
+             && pX->iTable==pScan->aiCur[0]
+             && pX->iColumn==pScan->aiColumn[0]
             ){
               testcase( pTerm->eOperator & WO_IS );
               continue;
@@ -120398,7 +121625,7 @@ static WhereTerm *whereScanNext(WhereScan *pScan){
     }
     pScan->pWC = pScan->pOrigWC;
     k = 0;
-    pScan->iEquiv += 2;
+    pScan->iEquiv++;
   }
   return 0;
 }
@@ -120427,16 +121654,19 @@ static WhereTerm *whereScanInit(
   u32 opMask,             /* Operator(s) to scan for */
   Index *pIdx             /* Must be compatible with this index */
 ){
-  int j;
+  int j = 0;
 
   /* memset(pScan, 0, sizeof(*pScan)); */
   pScan->pOrigWC = pWC;
   pScan->pWC = pWC;
+  pScan->pIdxExpr = 0;
+  if( pIdx ){
+    j = iColumn;
+    iColumn = pIdx->aiColumn[j];
+    if( iColumn==XN_EXPR ) pScan->pIdxExpr = pIdx->aColExpr->a[j].pExpr;
+  }
   if( pIdx && iColumn>=0 ){
     pScan->idxaff = pIdx->pTable->aCol[iColumn].affinity;
-    for(j=0; pIdx->aiColumn[j]!=iColumn; j++){
-      if( NEVER(j>pIdx->nColumn) ) return 0;
-    }
     pScan->zCollName = pIdx->azColl[j];
   }else{
     pScan->idxaff = 0;
@@ -120444,10 +121674,10 @@ static WhereTerm *whereScanInit(
   }
   pScan->opMask = opMask;
   pScan->k = 0;
-  pScan->aEquiv[0] = iCur;
-  pScan->aEquiv[1] = iColumn;
-  pScan->nEquiv = 2;
-  pScan->iEquiv = 2;
+  pScan->aiCur[0] = iCur;
+  pScan->aiColumn[0] = iColumn;
+  pScan->nEquiv = 1;
+  pScan->iEquiv = 1;
   return whereScanNext(pScan);
 }
 
@@ -120457,15 +121687,16 @@ static WhereTerm *whereScanInit(
 ** the WO_xx operator codes specified by the op parameter.
 ** Return a pointer to the term.  Return 0 if not found.
 **
+** If pIdx!=0 then search for terms matching the iColumn-th column of pIdx
+** rather than the iColumn-th column of table iCur.
+**
 ** The term returned might by Y=<expr> if there is another constraint in
 ** the WHERE clause that specifies that X=Y.  Any such constraints will be
 ** identified by the WO_EQUIV bit in the pTerm->eOperator field.  The
-** aEquiv[] array holds X and all its equivalents, with each SQL variable
-** taking up two slots in aEquiv[].  The first slot is for the cursor number
-** and the second is for the column number.  There are 22 slots in aEquiv[]
-** so that means we can look for X plus up to 10 other equivalent values.
-** Hence a search for X will return <expr> if X=A1 and A1=A2 and A2=A3
-** and ... and A9=A10 and A10=<expr>.
+** aiCur[]/iaColumn[] arrays hold X and all its equivalents. There are 11
+** slots in aiCur[]/aiColumn[] so that means we can look for X plus up to 10
+** other equivalent values.  Hence a search for X will return <expr> if X=A1
+** and A1=A2 and A2=A3 and ... and A9=A10 and A10=<expr>.
 **
 ** If there are multiple terms in the WHERE clause of the form "X <op> <expr>"
 ** then try for the one with no dependencies on <expr> - in other words where
@@ -120534,6 +121765,25 @@ static int findIndexCol(
   return -1;
 }
 
+/*
+** Return TRUE if the iCol-th column of index pIdx is NOT NULL
+*/
+static int indexColumnNotNull(Index *pIdx, int iCol){
+  int j;
+  assert( pIdx!=0 );
+  assert( iCol>=0 && iCol<pIdx->nColumn );
+  j = pIdx->aiColumn[iCol];
+  if( j>=0 ){
+    return pIdx->pTable->aCol[j].notNull;
+  }else if( j==(-1) ){
+    return 1;
+  }else{
+    assert( j==(-2) );
+    return 0;  /* Assume an indexed expression can always yield a NULL */
+
+  }
+}
+
 /*
 ** Return true if the DISTINCT expression-list passed as the third argument
 ** is redundant.
@@ -120584,12 +121834,9 @@ static int isDistinctRedundant(
   for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
     if( !IsUniqueIndex(pIdx) ) continue;
     for(i=0; i<pIdx->nKeyCol; i++){
-      i16 iCol = pIdx->aiColumn[i];
-      if( 0==sqlite3WhereFindTerm(pWC, iBase, iCol, ~(Bitmask)0, WO_EQ, pIdx) ){
-        int iIdxCol = findIndexCol(pParse, pDistinct, iBase, pIdx, i);
-        if( iIdxCol<0 || pTab->aCol[iCol].notNull==0 ){
-          break;
-        }
+      if( 0==sqlite3WhereFindTerm(pWC, iBase, i, ~(Bitmask)0, WO_EQ, pIdx) ){
+        if( findIndexCol(pParse, pDistinct, iBase, pIdx, i)<0 ) break;
+        if( indexColumnNotNull(pIdx, i)==0 ) break;
       }
     }
     if( i==pIdx->nKeyCol ){
@@ -120613,14 +121860,20 @@ static LogEst estLog(LogEst N){
 ** Convert OP_Column opcodes to OP_Copy in previously generated code.
 **
 ** This routine runs over generated VDBE code and translates OP_Column
-** opcodes into OP_Copy, and OP_Rowid into OP_Null, when the table is being
-** accessed via co-routine instead of via table lookup.
+** opcodes into OP_Copy when the table is being accessed via co-routine 
+** instead of via table lookup.
+**
+** If the bIncrRowid parameter is 0, then any OP_Rowid instructions on
+** cursor iTabCur are transformed into OP_Null. Or, if bIncrRowid is non-zero,
+** then each OP_Rowid is transformed into an instruction to increment the
+** value stored in its output register.
 */
 static void translateColumnToCopy(
   Vdbe *v,            /* The VDBE containing code to translate */
   int iStart,         /* Translate from this opcode to the end */
   int iTabCur,        /* OP_Column/OP_Rowid references to this table */
-  int iRegister       /* The first column is in this register */
+  int iRegister,      /* The first column is in this register */
+  int bIncrRowid      /* If non-zero, transform OP_rowid to OP_AddImm(1) */
 ){
   VdbeOp *pOp = sqlite3VdbeGetOp(v, iStart);
   int iEnd = sqlite3VdbeCurrentAddr(v);
@@ -120632,9 +121885,16 @@ static void translateColumnToCopy(
       pOp->p2 = pOp->p3;
       pOp->p3 = 0;
     }else if( pOp->opcode==OP_Rowid ){
-      pOp->opcode = OP_Null;
-      pOp->p1 = 0;
-      pOp->p3 = 0;
+      if( bIncrRowid ){
+        /* Increment the value stored in the P2 operand of the OP_Rowid. */
+        pOp->opcode = OP_AddImm;
+        pOp->p1 = pOp->p2;
+        pOp->p2 = 1;
+      }else{
+        pOp->opcode = OP_Null;
+        pOp->p1 = 0;
+        pOp->p3 = 0;
+      }
     }
   }
 }
@@ -120742,6 +122002,8 @@ static void constructAutomaticIndex(
   Expr *pPartial = 0;         /* Partial Index Expression */
   int iContinue = 0;          /* Jump here to skip excluded rows */
   struct SrcList_item *pTabItem;  /* FROM clause term being indexed */
+  int addrCounter;            /* Address where integer counter is initialized */
+  int regBase;                /* Array of registers where record is assembled */
 
   /* Generate code to skip over the creation and initialization of the
   ** transient index on 2nd and subsequent iterations of the loop. */
@@ -120855,7 +122117,7 @@ static void constructAutomaticIndex(
     }
   }
   assert( n==nKeyCol );
-  pIdx->aiColumn[n] = -1;
+  pIdx->aiColumn[n] = XN_ROWID;
   pIdx->azColl[n] = "BINARY";
 
   /* Create the automatic index */
@@ -120868,8 +122130,9 @@ static void constructAutomaticIndex(
   /* Fill the automatic index with content */
   sqlite3ExprCachePush(pParse);
   pTabItem = &pWC->pWInfo->pTabList->a[pLevel->iFrom];
-  if( pTabItem->viaCoroutine ){
+  if( pTabItem->fg.viaCoroutine ){
     int regYield = pTabItem->regReturn;
+    addrCounter = sqlite3VdbeAddOp2(v, OP_Integer, 0, 0);
     sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);
     addrTop =  sqlite3VdbeAddOp1(v, OP_Yield, regYield);
     VdbeCoverage(v);
@@ -120883,14 +122146,17 @@ static void constructAutomaticIndex(
     pLoop->wsFlags |= WHERE_PARTIALIDX;
   }
   regRecord = sqlite3GetTempReg(pParse);
-  sqlite3GenerateIndexKey(pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0);
+  regBase = sqlite3GenerateIndexKey(
+      pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0
+  );
   sqlite3VdbeAddOp2(v, OP_IdxInsert, pLevel->iIdxCur, regRecord);
   sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
   if( pPartial ) sqlite3VdbeResolveLabel(v, iContinue);
-  if( pTabItem->viaCoroutine ){
-    translateColumnToCopy(v, addrTop, pLevel->iTabCur, pTabItem->regResult);
-    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrTop);
-    pTabItem->viaCoroutine = 0;
+  if( pTabItem->fg.viaCoroutine ){
+    sqlite3VdbeChangeP2(v, addrCounter, regBase+n);
+    translateColumnToCopy(v, addrTop, pLevel->iTabCur, pTabItem->regResult, 1);
+    sqlite3VdbeGoto(v, addrTop);
+    pTabItem->fg.viaCoroutine = 0;
   }else{
     sqlite3VdbeAddOp2(v, OP_Next, pLevel->iTabCur, addrTop+1); VdbeCoverage(v);
   }
@@ -120941,6 +122207,7 @@ static sqlite3_index_info *allocateIndexInfo(
     testcase( pTerm->eOperator & WO_ALL );
     if( (pTerm->eOperator & ~(WO_ISNULL|WO_EQUIV|WO_IS))==0 ) continue;
     if( pTerm->wtFlags & TERM_VNULL ) continue;
+    assert( pTerm->u.leftColumn>=(-1) );
     nTerm++;
   }
 
@@ -120996,6 +122263,7 @@ static sqlite3_index_info *allocateIndexInfo(
     testcase( pTerm->eOperator & WO_ALL );
     if( (pTerm->eOperator & ~(WO_ISNULL|WO_EQUIV|WO_IS))==0 ) continue;
     if( pTerm->wtFlags & TERM_VNULL ) continue;
+    assert( pTerm->u.leftColumn>=(-1) );
     pIdxCons[j].iColumn = pTerm->u.leftColumn;
     pIdxCons[j].iTermOffset = i;
     op = (u8)pTerm->eOperator & WO_ALL;
@@ -121286,6 +122554,21 @@ static LogEst whereRangeAdjust(WhereTerm *pTerm, LogEst nNew){
   return nRet;
 }
 
+
+#ifdef SQLITE_ENABLE_STAT3_OR_STAT4
+/*
+** Return the affinity for a single column of an index.
+*/
+static char sqlite3IndexColumnAffinity(sqlite3 *db, Index *pIdx, int iCol){
+  assert( iCol>=0 && iCol<pIdx->nColumn );
+  if( !pIdx->zColAff ){
+    if( sqlite3IndexAffinityStr(db, pIdx)==0 ) return SQLITE_AFF_BLOB;
+  }
+  return pIdx->zColAff[iCol];
+}
+#endif
+
+
 #ifdef SQLITE_ENABLE_STAT3_OR_STAT4
 /* 
 ** This function is called to estimate the number of rows visited by a
@@ -121335,8 +122618,7 @@ static int whereRangeSkipScanEst(
   int nLower = -1;
   int nUpper = p->nSample+1;
   int rc = SQLITE_OK;
-  int iCol = p->aiColumn[nEq];
-  u8 aff = iCol>=0 ? p->pTable->aCol[iCol].affinity : SQLITE_AFF_INTEGER;
+  u8 aff = sqlite3IndexColumnAffinity(db, p, nEq);
   CollSeq *pColl;
   
   sqlite3_value *p1 = 0;          /* Value extracted from pLower */
@@ -121484,11 +122766,8 @@ static int whereRangeScanEst(
         testcase( pRec->nField!=pBuilder->nRecValid );
         pRec->nField = pBuilder->nRecValid;
       }
-      if( nEq==p->nKeyCol ){
-        aff = SQLITE_AFF_INTEGER;
-      }else{
-        aff = p->pTable->aCol[p->aiColumn[nEq]].affinity;
-      }
+      aff = sqlite3IndexColumnAffinity(pParse->db, p, nEq);
+      assert( nEq!=p->nKeyCol || aff==SQLITE_AFF_INTEGER );
       /* Determine iLower and iUpper using ($P) only. */
       if( nEq==0 ){
         iLower = 0;
@@ -121646,7 +122925,7 @@ static int whereEqualScanEst(
     return SQLITE_OK;
   }
 
-  aff = p->pTable->aCol[p->aiColumn[nEq-1]].affinity;
+  aff = sqlite3IndexColumnAffinity(pParse->db, p, nEq-1);
   rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, aff, nEq-1, &bOk);
   pBuilder->pRec = pRec;
   if( rc!=SQLITE_OK ) return rc;
@@ -122073,18 +123352,20 @@ static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate){
   ** and prereqs.
   */
   if( pBuilder->pOrSet!=0 ){
+    if( pTemplate->nLTerm ){
 #if WHERETRACE_ENABLED
-    u16 n = pBuilder->pOrSet->n;
-    int x =
+      u16 n = pBuilder->pOrSet->n;
+      int x =
 #endif
-    whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun,
+      whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun,
                                     pTemplate->nOut);
 #if WHERETRACE_ENABLED /* 0x8 */
-    if( sqlite3WhereTrace & 0x8 ){
-      sqlite3DebugPrintf(x?"   or-%d:  ":"   or-X:  ", n);
-      whereLoopPrint(pTemplate, pBuilder->pWC);
-    }
+      if( sqlite3WhereTrace & 0x8 ){
+        sqlite3DebugPrintf(x?"   or-%d:  ":"   or-X:  ", n);
+        whereLoopPrint(pTemplate, pBuilder->pWC);
+      }
 #endif
+    }
     return SQLITE_OK;
   }
 
@@ -122274,7 +123555,6 @@ static int whereLoopAddBtreeIndex(
   u16 saved_nSkip;                /* Original value of pNew->nSkip */
   u32 saved_wsFlags;              /* Original value of pNew->wsFlags */
   LogEst saved_nOut;              /* Original value of pNew->nOut */
-  int iCol;                       /* Index of the column in the table */
   int rc = SQLITE_OK;             /* Return code */
   LogEst rSize;                   /* Number of rows in the table */
   LogEst rLogSize;                /* Logarithm of table size */
@@ -122287,7 +123567,7 @@ static int whereLoopAddBtreeIndex(
   assert( (pNew->wsFlags & WHERE_TOP_LIMIT)==0 );
   if( pNew->wsFlags & WHERE_BTM_LIMIT ){
     opMask = WO_LT|WO_LE;
-  }else if( /*pProbe->tnum<=0 ||*/ (pSrc->jointype & JT_LEFT)!=0 ){
+  }else if( /*pProbe->tnum<=0 ||*/ (pSrc->fg.jointype & JT_LEFT)!=0 ){
     opMask = WO_EQ|WO_IN|WO_GT|WO_GE|WO_LT|WO_LE;
   }else{
     opMask = WO_EQ|WO_IN|WO_GT|WO_GE|WO_LT|WO_LE|WO_ISNULL|WO_IS;
@@ -122295,16 +123575,15 @@ static int whereLoopAddBtreeIndex(
   if( pProbe->bUnordered ) opMask &= ~(WO_GT|WO_GE|WO_LT|WO_LE);
 
   assert( pNew->u.btree.nEq<pProbe->nColumn );
-  iCol = pProbe->aiColumn[pNew->u.btree.nEq];
 
-  pTerm = whereScanInit(&scan, pBuilder->pWC, pSrc->iCursor, iCol,
-                        opMask, pProbe);
   saved_nEq = pNew->u.btree.nEq;
   saved_nSkip = pNew->nSkip;
   saved_nLTerm = pNew->nLTerm;
   saved_wsFlags = pNew->wsFlags;
   saved_prereq = pNew->prereq;
   saved_nOut = pNew->nOut;
+  pTerm = whereScanInit(&scan, pBuilder->pWC, pSrc->iCursor, saved_nEq,
+                        opMask, pProbe);
   pNew->rSetup = 0;
   rSize = pProbe->aiRowLogEst[0];
   rLogSize = estLog(rSize);
@@ -122317,7 +123596,7 @@ static int whereLoopAddBtreeIndex(
     int nRecValid = pBuilder->nRecValid;
 #endif
     if( (eOp==WO_ISNULL || (pTerm->wtFlags&TERM_VNULL)!=0)
-     && (iCol<0 || pSrc->pTab->aCol[iCol].notNull)
+     && indexColumnNotNull(pProbe, saved_nEq)
     ){
       continue; /* ignore IS [NOT] NULL constraints on NOT NULL columns */
     }
@@ -122354,8 +123633,12 @@ static int whereLoopAddBtreeIndex(
                         ** changes "x IN (?)" into "x=?". */
 
     }else if( eOp & (WO_EQ|WO_IS) ){
+      int iCol = pProbe->aiColumn[saved_nEq];
       pNew->wsFlags |= WHERE_COLUMN_EQ;
-      if( iCol<0 || (nInMul==0 && pNew->u.btree.nEq==pProbe->nKeyCol-1) ){
+      assert( saved_nEq==pNew->u.btree.nEq );
+      if( iCol==XN_ROWID 
+       || (iCol>0 && nInMul==0 && saved_nEq==pProbe->nKeyCol-1)
+      ){
         if( iCol>=0 && pProbe->uniqNotNull==0 ){
           pNew->wsFlags |= WHERE_UNQ_WANTED;
         }else{
@@ -122406,7 +123689,7 @@ static int whereLoopAddBtreeIndex(
       assert( eOp & (WO_ISNULL|WO_EQ|WO_IN|WO_IS) );
 
       assert( pNew->nOut==saved_nOut );
-      if( pTerm->truthProb<=0 && iCol>=0 ){
+      if( pTerm->truthProb<=0 && pProbe->aiColumn[saved_nEq]>=0 ){
         assert( (eOp & WO_IN) || nIn==0 );
         testcase( eOp & WO_IN );
         pNew->nOut += pTerm->truthProb;
@@ -122541,18 +123824,25 @@ static int indexMightHelpWithOrderBy(
   int iCursor
 ){
   ExprList *pOB;
+  ExprList *aColExpr;
   int ii, jj;
 
   if( pIndex->bUnordered ) return 0;
   if( (pOB = pBuilder->pWInfo->pOrderBy)==0 ) return 0;
   for(ii=0; ii<pOB->nExpr; ii++){
     Expr *pExpr = sqlite3ExprSkipCollate(pOB->a[ii].pExpr);
-    if( pExpr->op!=TK_COLUMN ) return 0;
-    if( pExpr->iTable==iCursor ){
+    if( pExpr->op==TK_COLUMN && pExpr->iTable==iCursor ){
       if( pExpr->iColumn<0 ) return 1;
       for(jj=0; jj<pIndex->nKeyCol; jj++){
         if( pExpr->iColumn==pIndex->aiColumn[jj] ) return 1;
       }
+    }else if( (aColExpr = pIndex->aColExpr)!=0 ){
+      for(jj=0; jj<pIndex->nKeyCol; jj++){
+        if( pIndex->aiColumn[jj]!=XN_EXPR ) continue;
+        if( sqlite3ExprCompare(pExpr,aColExpr->a[jj].pExpr,iCursor)==0 ){
+          return 1;
+        }
+      }
     }
   }
   return 0;
@@ -122582,6 +123872,10 @@ static Bitmask columnsInIndex(Index *pIdx){
 static int whereUsablePartialIndex(int iTab, WhereClause *pWC, Expr *pWhere){
   int i;
   WhereTerm *pTerm;
+  while( pWhere->op==TK_AND ){
+    if( !whereUsablePartialIndex(iTab,pWC,pWhere->pLeft) ) return 0;
+    pWhere = pWhere->pRight;
+  }
   for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
     Expr *pExpr = pTerm->pExpr;
     if( sqlite3ExprImpliesExpr(pExpr, pWhere, iTab) 
@@ -122657,9 +123951,9 @@ static int whereLoopAddBtree(
   pWC = pBuilder->pWC;
   assert( !IsVirtual(pSrc->pTab) );
 
-  if( pSrc->pIndex ){
+  if( pSrc->pIBIndex ){
     /* An INDEXED BY clause specifies a particular index to use */
-    pProbe = pSrc->pIndex;
+    pProbe = pSrc->pIBIndex;
   }else if( !HasRowid(pTab) ){
     pProbe = pTab->pIndex;
   }else{
@@ -122679,7 +123973,7 @@ static int whereLoopAddBtree(
     aiRowEstPk[0] = pTab->nRowLogEst;
     aiRowEstPk[1] = 0;
     pFirst = pSrc->pTab->pIndex;
-    if( pSrc->notIndexed==0 ){
+    if( pSrc->fg.notIndexed==0 ){
       /* The real indices of the table are only considered if the
       ** NOT INDEXED qualifier is omitted from the FROM clause */
       sPk.pNext = pFirst;
@@ -122691,14 +123985,14 @@ static int whereLoopAddBtree(
 
 #ifndef SQLITE_OMIT_AUTOMATIC_INDEX
   /* Automatic indexes */
-  if( !pBuilder->pOrSet   /* Not part of an OR optimization */
+  if( !pBuilder->pOrSet      /* Not part of an OR optimization */
    && (pWInfo->wctrlFlags & WHERE_NO_AUTOINDEX)==0
    && (pWInfo->pParse->db->flags & SQLITE_AutoIndex)!=0
-   && pSrc->pIndex==0     /* Has no INDEXED BY clause */
-   && !pSrc->notIndexed   /* Has no NOT INDEXED clause */
-   && HasRowid(pTab)      /* Is not a WITHOUT ROWID table. (FIXME: Why not?) */
-   && !pSrc->isCorrelated /* Not a correlated subquery */
-   && !pSrc->isRecursive  /* Not a recursive common table expression. */
+   && pSrc->pIBIndex==0      /* Has no INDEXED BY clause */
+   && !pSrc->fg.notIndexed   /* Has no NOT INDEXED clause */
+   && HasRowid(pTab)         /* Not WITHOUT ROWID table. (FIXME: Why not?) */
+   && !pSrc->fg.isCorrelated /* Not a correlated subquery */
+   && !pSrc->fg.isRecursive  /* Not a recursive common table expression. */
   ){
     /* Generate auto-index WhereLoops */
     WhereTerm *pTerm;
@@ -122819,7 +124113,7 @@ static int whereLoopAddBtree(
 
     /* If there was an INDEXED BY clause, then only that one index is
     ** considered. */
-    if( pSrc->pIndex ) break;
+    if( pSrc->pIBIndex ) break;
   }
   return rc;
 }
@@ -122941,6 +124235,7 @@ static int whereLoopAddVirtual(
     pIdxInfo->orderByConsumed = 0;
     pIdxInfo->estimatedCost = SQLITE_BIG_DBL / (double)2;
     pIdxInfo->estimatedRows = 25;
+    pIdxInfo->idxFlags = 0;
     rc = vtabBestIndex(pParse, pTab, pIdxInfo);
     if( rc ) goto whereLoopAddVtab_exit;
     pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
@@ -122986,6 +124281,7 @@ static int whereLoopAddVirtual(
           ** (2) Multiple outputs from a single IN value will not merge
           ** together.  */
           pIdxInfo->orderByConsumed = 0;
+          pIdxInfo->idxFlags &= ~SQLITE_INDEX_SCAN_UNIQUE;
         }
       }
     }
@@ -123001,6 +124297,14 @@ static int whereLoopAddVirtual(
       pNew->rSetup = 0;
       pNew->rRun = sqlite3LogEstFromDouble(pIdxInfo->estimatedCost);
       pNew->nOut = sqlite3LogEst(pIdxInfo->estimatedRows);
+
+      /* Set the WHERE_ONEROW flag if the xBestIndex() method indicated
+      ** that the scan will visit at most one row. Clear it otherwise. */
+      if( pIdxInfo->idxFlags & SQLITE_INDEX_SCAN_UNIQUE ){
+        pNew->wsFlags |= WHERE_ONEROW;
+      }else{
+        pNew->wsFlags &= ~WHERE_ONEROW;
+      }
       whereLoopInsert(pBuilder, pNew);
       if( pNew->u.vtab.needFree ){
         sqlite3_free(pNew->u.vtab.idxStr);
@@ -123165,16 +124469,16 @@ static int whereLoopAddAll(WhereLoopBuilder *pBuilder){
     Bitmask mUnusable = 0;
     pNew->iTab = iTab;
     pNew->maskSelf = sqlite3WhereGetMask(&pWInfo->sMaskSet, pItem->iCursor);
-    if( ((pItem->jointype|priorJointype) & (JT_LEFT|JT_CROSS))!=0 ){
+    if( ((pItem->fg.jointype|priorJointype) & (JT_LEFT|JT_CROSS))!=0 ){
       /* This condition is true when pItem is the FROM clause term on the
       ** right-hand-side of a LEFT or CROSS JOIN.  */
       mExtra = mPrior;
     }
-    priorJointype = pItem->jointype;
+    priorJointype = pItem->fg.jointype;
     if( IsVirtual(pItem->pTab) ){
       struct SrcList_item *p;
       for(p=&pItem[1]; p<pEnd; p++){
-        if( mUnusable || (p->jointype & (JT_LEFT|JT_CROSS)) ){
+        if( mUnusable || (p->fg.jointype & (JT_LEFT|JT_CROSS)) ){
           mUnusable |= sqlite3WhereGetMask(&pWInfo->sMaskSet, p->iCursor);
         }
       }
@@ -123322,7 +124626,8 @@ static i8 wherePathSatisfiesOrderBy(
         nKeyCol = pIndex->nKeyCol;
         nColumn = pIndex->nColumn;
         assert( nColumn==nKeyCol+1 || !HasRowid(pIndex->pTable) );
-        assert( pIndex->aiColumn[nColumn-1]==(-1) || !HasRowid(pIndex->pTable));
+        assert( pIndex->aiColumn[nColumn-1]==XN_ROWID
+                          || !HasRowid(pIndex->pTable));
         isOrderDistinct = IsUniqueIndex(pIndex);
       }
 
@@ -123354,7 +124659,7 @@ static i8 wherePathSatisfiesOrderBy(
           revIdx = pIndex->aSortOrder[j];
           if( iColumn==pIndex->pTable->iPKey ) iColumn = -1;
         }else{
-          iColumn = -1;
+          iColumn = XN_ROWID;
           revIdx = 0;
         }
 
@@ -123380,9 +124685,15 @@ static i8 wherePathSatisfiesOrderBy(
           testcase( wctrlFlags & WHERE_GROUPBY );
           testcase( wctrlFlags & WHERE_DISTINCTBY );
           if( (wctrlFlags & (WHERE_GROUPBY|WHERE_DISTINCTBY))==0 ) bOnce = 0;
-          if( pOBExpr->op!=TK_COLUMN ) continue;
-          if( pOBExpr->iTable!=iCur ) continue;
-          if( pOBExpr->iColumn!=iColumn ) continue;
+          if( iColumn>=(-1) ){
+            if( pOBExpr->op!=TK_COLUMN ) continue;
+            if( pOBExpr->iTable!=iCur ) continue;
+            if( pOBExpr->iColumn!=iColumn ) continue;
+          }else{
+            if( sqlite3ExprCompare(pOBExpr,pIndex->aColExpr->a[j].pExpr,iCur) ){
+              continue;
+            }
+          }
           if( iColumn>=0 ){
             pColl = sqlite3ExprCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);
             if( !pColl ) pColl = db->pDfltColl;
@@ -123904,7 +125215,7 @@ static int whereShortCut(WhereLoopBuilder *pBuilder){
   pItem = pWInfo->pTabList->a;
   pTab = pItem->pTab;
   if( IsVirtual(pTab) ) return 0;
-  if( pItem->zIndexedBy ) return 0;
+  if( pItem->fg.isIndexedBy ) return 0;
   iCur = pItem->iCursor;
   pWC = &pWInfo->sWC;
   pLoop = pBuilder->pNew;
@@ -123929,7 +125240,7 @@ static int whereShortCut(WhereLoopBuilder *pBuilder){
       ) continue;
       opMask = pIdx->uniqNotNull ? (WO_EQ|WO_IS) : WO_EQ;
       for(j=0; j<pIdx->nKeyCol; j++){
-        pTerm = sqlite3WhereFindTerm(pWC, iCur, pIdx->aiColumn[j], 0, opMask, pIdx);
+        pTerm = sqlite3WhereFindTerm(pWC, iCur, j, 0, opMask, pIdx);
         if( pTerm==0 ) break;
         testcase( pTerm->eOperator & WO_IS );
         pLoop->aLTerm[j] = pTerm;
@@ -124075,6 +125386,10 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   sqlite3 *db;               /* Database connection */
   int rc;                    /* Return code */
 
+  assert( (wctrlFlags & WHERE_ONEPASS_MULTIROW)==0 || (
+        (wctrlFlags & WHERE_ONEPASS_DESIRED)!=0 
+     && (wctrlFlags & WHERE_OMIT_OPEN_CLOSE)==0 
+  ));
 
   /* Variable initialization */
   db = pParse->db;
@@ -124130,6 +125445,7 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   pWInfo->iBreak = pWInfo->iContinue = sqlite3VdbeMakeLabel(v);
   pWInfo->wctrlFlags = wctrlFlags;
   pWInfo->savedNQueryLoop = pParse->nQueryLoop;
+  assert( pWInfo->eOnePass==ONEPASS_OFF );  /* ONEPASS defaults to OFF */
   pMaskSet = &pWInfo->sMaskSet;
   sWLB.pWInfo = pWInfo;
   sWLB.pWC = &pWInfo->sWC;
@@ -124169,14 +125485,12 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
 
   /* Assign a bit from the bitmask to every term in the FROM clause.
   **
-  ** When assigning bitmask values to FROM clause cursors, it must be
-  ** the case that if X is the bitmask for the N-th FROM clause term then
-  ** the bitmask for all FROM clause terms to the left of the N-th term
-  ** is (X-1).   An expression from the ON clause of a LEFT JOIN can use
-  ** its Expr.iRightJoinTable value to find the bitmask of the right table
-  ** of the join.  Subtracting one from the right table bitmask gives a
-  ** bitmask for all tables to the left of the join.  Knowing the bitmask
-  ** for all tables to the left of a left join is important.  Ticket #3015.
+  ** The N-th term of the FROM clause is assigned a bitmask of 1<<N.
+  **
+  ** The rule of the previous sentence ensures thta if X is the bitmask for
+  ** a table T, then X-1 is the bitmask for all other tables to the left of T.
+  ** Knowing the bitmask for all tables to the left of a left join is
+  ** important.  Ticket #3015.
   **
   ** Note that bitmasks are created for all pTabList->nSrc tables in
   ** pTabList, not just the first nTabList tables.  nTabList is normally
@@ -124185,15 +125499,12 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   */
   for(ii=0; ii<pTabList->nSrc; ii++){
     createMask(pMaskSet, pTabList->a[ii].iCursor);
+    sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);
   }
-#ifndef NDEBUG
-  {
-    Bitmask toTheLeft = 0;
-    for(ii=0; ii<pTabList->nSrc; ii++){
-      Bitmask m = sqlite3WhereGetMask(pMaskSet, pTabList->a[ii].iCursor);
-      assert( (m-1)==toTheLeft );
-      toTheLeft |= m;
-    }
+#ifdef SQLITE_DEBUG
+  for(ii=0; ii<pTabList->nSrc; ii++){
+    Bitmask m = sqlite3WhereGetMask(pMaskSet, pTabList->a[ii].iCursor);
+    assert( m==MASKBIT(ii) );
   }
 #endif
 
@@ -124213,7 +125524,8 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   }
 
   /* Construct the WhereLoop objects */
-  WHERETRACE(0xffff,("*** Optimizer Start ***\n"));
+  WHERETRACE(0xffff,("*** Optimizer Start *** (wctrlFlags: 0x%x)\n",
+             wctrlFlags));
 #if defined(WHERETRACE_ENABLED)
   if( sqlite3WhereTrace & 0x100 ){ /* Display all terms of the WHERE clause */
     int i;
@@ -124291,7 +125603,7 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
     while( pWInfo->nLevel>=2 ){
       WhereTerm *pTerm, *pEnd;
       pLoop = pWInfo->a[pWInfo->nLevel-1].pWLoop;
-      if( (pWInfo->pTabList->a[pLoop->iTab].jointype & JT_LEFT)==0 ) break;
+      if( (pWInfo->pTabList->a[pLoop->iTab].fg.jointype & JT_LEFT)==0 ) break;
       if( (wctrlFlags & WHERE_WANT_DISTINCT)==0
        && (pLoop->wsFlags & WHERE_ONEROW)==0
       ){
@@ -124321,11 +125633,16 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
   ** the statement to update or delete a single row.
   */
   assert( (wctrlFlags & WHERE_ONEPASS_DESIRED)==0 || pWInfo->nLevel==1 );
-  if( (wctrlFlags & WHERE_ONEPASS_DESIRED)!=0 
-   && (pWInfo->a[0].pWLoop->wsFlags & WHERE_ONEROW)!=0 ){
-    pWInfo->okOnePass = 1;
-    if( HasRowid(pTabList->a[0].pTab) ){
-      pWInfo->a[0].pWLoop->wsFlags &= ~WHERE_IDX_ONLY;
+  if( (wctrlFlags & WHERE_ONEPASS_DESIRED)!=0 ){
+    int wsFlags = pWInfo->a[0].pWLoop->wsFlags;
+    int bOnerow = (wsFlags & WHERE_ONEROW)!=0;
+    if( bOnerow || ( (wctrlFlags & WHERE_ONEPASS_MULTIROW)
+       && 0==(wsFlags & WHERE_VIRTUALTABLE)
+    )){
+      pWInfo->eOnePass = bOnerow ? ONEPASS_SINGLE : ONEPASS_MULTI;
+      if( HasRowid(pTabList->a[0].pTab) ){
+        pWInfo->a[0].pWLoop->wsFlags &= ~WHERE_IDX_ONLY;
+      }
     }
   }
 
@@ -124356,15 +125673,15 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
     if( (pLoop->wsFlags & WHERE_IDX_ONLY)==0
          && (wctrlFlags & WHERE_OMIT_OPEN_CLOSE)==0 ){
       int op = OP_OpenRead;
-      if( pWInfo->okOnePass ){
+      if( pWInfo->eOnePass!=ONEPASS_OFF ){
         op = OP_OpenWrite;
         pWInfo->aiCurOnePass[0] = pTabItem->iCursor;
       };
       sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);
       assert( pTabItem->iCursor==pLevel->iTabCur );
-      testcase( !pWInfo->okOnePass && pTab->nCol==BMS-1 );
-      testcase( !pWInfo->okOnePass && pTab->nCol==BMS );
-      if( !pWInfo->okOnePass && pTab->nCol<BMS && HasRowid(pTab) ){
+      testcase( pWInfo->eOnePass==ONEPASS_OFF && pTab->nCol==BMS-1 );
+      testcase( pWInfo->eOnePass==ONEPASS_OFF && pTab->nCol==BMS );
+      if( pWInfo->eOnePass==ONEPASS_OFF && pTab->nCol<BMS && HasRowid(pTab) ){
         Bitmask b = pTabItem->colUsed;
         int n = 0;
         for(; b; b=b>>1, n++){}
@@ -124392,7 +125709,7 @@ SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(
         ** WITHOUT ROWID table.  No need for a separate index */
         iIndexCur = pLevel->iTabCur;
         op = 0;
-      }else if( pWInfo->okOnePass ){
+      }else if( pWInfo->eOnePass!=ONEPASS_OFF ){
         Index *pJ = pTabItem->pTab->pIndex;
         iIndexCur = iIdxCur;
         assert( wctrlFlags & WHERE_ONEPASS_DESIRED );
@@ -124529,7 +125846,7 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
     }
     sqlite3VdbeResolveLabel(v, pLevel->addrBrk);
     if( pLevel->addrSkip ){
-      sqlite3VdbeAddOp2(v, OP_Goto, 0, pLevel->addrSkip);
+      sqlite3VdbeGoto(v, pLevel->addrSkip);
       VdbeComment((v, "next skip-scan on %s", pLoop->u.btree.pIndex->zName));
       sqlite3VdbeJumpHere(v, pLevel->addrSkip);
       sqlite3VdbeJumpHere(v, pLevel->addrSkip-2);
@@ -124557,7 +125874,7 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
       if( pLevel->op==OP_Return ){
         sqlite3VdbeAddOp2(v, OP_Gosub, pLevel->p1, pLevel->addrFirst);
       }else{
-        sqlite3VdbeAddOp2(v, OP_Goto, 0, pLevel->addrFirst);
+        sqlite3VdbeGoto(v, pLevel->addrFirst);
       }
       sqlite3VdbeJumpHere(v, addr);
     }
@@ -124584,9 +125901,9 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
     ** the co-routine into OP_Copy of result contained in a register.
     ** OP_Rowid becomes OP_Null.
     */
-    if( pTabItem->viaCoroutine && !db->mallocFailed ){
+    if( pTabItem->fg.viaCoroutine && !db->mallocFailed ){
       translateColumnToCopy(v, pLevel->addrBody, pLevel->iTabCur,
-                            pTabItem->regResult);
+                            pTabItem->regResult, 0);
       continue;
     }
 
@@ -124600,7 +125917,7 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
      && (pWInfo->wctrlFlags & WHERE_OMIT_OPEN_CLOSE)==0
     ){
       int ws = pLoop->wsFlags;
-      if( !pWInfo->okOnePass && (ws & WHERE_IDX_ONLY)==0 ){
+      if( pWInfo->eOnePass==ONEPASS_OFF && (ws & WHERE_IDX_ONLY)==0 ){
         sqlite3VdbeAddOp1(v, OP_Close, pTabItem->iCursor);
       }
       if( (ws & WHERE_INDEXED)!=0
@@ -124627,7 +125944,10 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
     }else if( pLoop->wsFlags & WHERE_MULTI_OR ){
       pIdx = pLevel->u.pCovidx;
     }
-    if( pIdx && !db->mallocFailed ){
+    if( pIdx
+     && (pWInfo->eOnePass==ONEPASS_OFF || !HasRowid(pIdx->pTable))
+     && !db->mallocFailed
+    ){
       last = sqlite3VdbeCurrentAddr(v);
       k = pLevel->addrBody;
       pOp = sqlite3VdbeGetOp(v, k);
@@ -124639,6 +125959,7 @@ SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){
           if( !HasRowid(pTab) ){
             Index *pPk = sqlite3PrimaryKeyIndex(pTab);
             x = pPk->aiColumn[x];
+            assert( x>=0 );
           }
           x = sqlite3ColumnOfIndex(pIdx, x);
           if( x>=0 ){
@@ -124818,6 +126139,29 @@ struct AttachKey { int type;  Token key; };
     pOut->zStart = pPreOp->z;
     pOut->zEnd = pOperand->zEnd;
   }
+
+  /* Add a single new term to an ExprList that is used to store a
+  ** list of identifiers.  Report an error if the ID list contains
+  ** a COLLATE clause or an ASC or DESC keyword, except ignore the
+  ** error while parsing a legacy schema.
+  */
+  static ExprList *parserAddExprIdListTerm(
+    Parse *pParse,
+    ExprList *pPrior,
+    Token *pIdToken,
+    int hasCollate,
+    int sortOrder
+  ){
+    ExprList *p = sqlite3ExprListAppend(pParse, pPrior, 0);
+    if( (hasCollate || sortOrder!=SQLITE_SO_UNDEFINED)
+        && pParse->db->init.busy==0
+    ){
+      sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"",
+                         pIdToken->n, pIdToken->z);
+    }
+    sqlite3ExprListSetName(pParse, p, pIdToken, 1);
+    return p;
+  }
 /* Next is all token values, in a form suitable for use by makeheaders.
 ** This section will be null unless lemon is run with the -m switch.
 */
@@ -124862,10 +126206,17 @@ struct AttachKey { int type;  Token key; };
 **    sqlite3ParserARG_PDECL     A parameter declaration for the %extra_argument
 **    sqlite3ParserARG_STORE     Code to store %extra_argument into yypParser
 **    sqlite3ParserARG_FETCH     Code to extract %extra_argument from yypParser
-**    YYNSTATE           the combined number of states.
-**    YYNRULE            the number of rules in the grammar
 **    YYERRORSYMBOL      is the code number of the error symbol.  If not
 **                       defined, then do no error processing.
+**    YYNSTATE           the combined number of states.
+**    YYNRULE            the number of rules in the grammar
+**    YY_MAX_SHIFT       Maximum value for shift actions
+**    YY_MIN_SHIFTREDUCE Minimum value for shift-reduce actions
+**    YY_MAX_SHIFTREDUCE Maximum value for shift-reduce actions
+**    YY_MIN_REDUCE      Maximum value for reduce actions
+**    YY_ERROR_ACTION    The yy_action[] code for syntax error
+**    YY_ACCEPT_ACTION   The yy_action[] code for accept
+**    YY_NO_ACTION       The yy_action[] code for no-op
 */
 #define YYCODETYPE unsigned char
 #define YYNOCODE 254
@@ -124898,12 +126249,17 @@ typedef union {
 #define sqlite3ParserARG_PDECL ,Parse *pParse
 #define sqlite3ParserARG_FETCH Parse *pParse = yypParser->pParse
 #define sqlite3ParserARG_STORE yypParser->pParse = pParse
-#define YYNSTATE 642
-#define YYNRULE 327
 #define YYFALLBACK 1
-#define YY_NO_ACTION      (YYNSTATE+YYNRULE+2)
-#define YY_ACCEPT_ACTION  (YYNSTATE+YYNRULE+1)
-#define YY_ERROR_ACTION   (YYNSTATE+YYNRULE)
+#define YYNSTATE             436
+#define YYNRULE              328
+#define YY_MAX_SHIFT         435
+#define YY_MIN_SHIFTREDUCE   649
+#define YY_MAX_SHIFTREDUCE   976
+#define YY_MIN_REDUCE        977
+#define YY_MAX_REDUCE        1304
+#define YY_ERROR_ACTION      1305
+#define YY_ACCEPT_ACTION     1306
+#define YY_NO_ACTION         1307
 
 /* The yyzerominor constant is used to initialize instances of
 ** YYMINORTYPE objects to zero. */
@@ -124930,16 +126286,20 @@ static const YYMINORTYPE yyzerominor = { 0 };
 ** Suppose the action integer is N.  Then the action is determined as
 ** follows
 **
-**   0 <= N < YYNSTATE                  Shift N.  That is, push the lookahead
+**   0 <= N <= YY_MAX_SHIFT             Shift N.  That is, push the lookahead
 **                                      token onto the stack and goto state N.
 **
-**   YYNSTATE <= N < YYNSTATE+YYNRULE   Reduce by rule N-YYNSTATE.
+**   N between YY_MIN_SHIFTREDUCE       Shift to an arbitrary state then
+**     and YY_MAX_SHIFTREDUCE           reduce by rule N-YY_MIN_SHIFTREDUCE.
 **
-**   N == YYNSTATE+YYNRULE              A syntax error has occurred.
+**   N between YY_MIN_REDUCE            Reduce by rule N-YY_MIN_REDUCE
+**     and YY_MAX_REDUCE
+
+**   N == YY_ERROR_ACTION               A syntax error has occurred.
 **
-**   N == YYNSTATE+YYNRULE+1            The parser accepts its input.
+**   N == YY_ACCEPT_ACTION              The parser accepts its input.
 **
-**   N == YYNSTATE+YYNRULE+2            No such action.  Denotes unused
+**   N == YY_NO_ACTION                  No such action.  Denotes unused
 **                                      slots in the yy_action[] table.
 **
 ** The action table is constructed as a single large table named yy_action[].
@@ -124969,463 +126329,446 @@ static const YYMINORTYPE yyzerominor = { 0 };
 **                     shifting non-terminals after a reduce.
 **  yy_default[]       Default action for each state.
 */
-#define YY_ACTTAB_COUNT (1497)
+#define YY_ACTTAB_COUNT (1501)
 static const YYACTIONTYPE yy_action[] = {
- /*     0 */   306,  212,  432,  955,  639,  191,  955,  295,  559,   88,
- /*    10 */    88,   88,   88,   81,   86,   86,   86,   86,   85,   85,
- /*    20 */    84,   84,   84,   83,  330,  185,  184,  183,  635,  635,
- /*    30 */   292,  606,  606,   88,   88,   88,   88,  683,   86,   86,
- /*    40 */    86,   86,   85,   85,   84,   84,   84,   83,  330,   16,
- /*    50 */   436,  597,   89,   90,   80,  600,  599,  601,  601,   87,
- /*    60 */    87,   88,   88,   88,   88,  684,   86,   86,   86,   86,
- /*    70 */    85,   85,   84,   84,   84,   83,  330,  306,  559,   84,
- /*    80 */    84,   84,   83,  330,   65,   86,   86,   86,   86,   85,
- /*    90 */    85,   84,   84,   84,   83,  330,  635,  635,  634,  633,
- /*   100 */   182,  682,  550,  379,  376,  375,   17,  322,  606,  606,
- /*   110 */   371,  198,  479,   91,  374,   82,   79,  165,   85,   85,
- /*   120 */    84,   84,   84,   83,  330,  598,  635,  635,  107,   89,
- /*   130 */    90,   80,  600,  599,  601,  601,   87,   87,   88,   88,
- /*   140 */    88,   88,  186,   86,   86,   86,   86,   85,   85,   84,
- /*   150 */    84,   84,   83,  330,  306,  594,  594,  142,  328,  327,
- /*   160 */   484,  249,  344,  238,  635,  635,  634,  633,  585,  448,
- /*   170 */   526,  525,  229,  388,    1,  394,  450,  584,  449,  635,
- /*   180 */   635,  635,  635,  319,  395,  606,  606,  199,  157,  273,
- /*   190 */   382,  268,  381,  187,  635,  635,  634,  633,  311,  555,
- /*   200 */   266,  593,  593,  266,  347,  588,   89,   90,   80,  600,
- /*   210 */   599,  601,  601,   87,   87,   88,   88,   88,   88,  478,
- /*   220 */    86,   86,   86,   86,   85,   85,   84,   84,   84,   83,
- /*   230 */   330,  306,  272,  536,  634,  633,  146,  610,  197,  310,
- /*   240 */   575,  182,  482,  271,  379,  376,  375,  506,   21,  634,
- /*   250 */   633,  634,  633,  635,  635,  374,  611,  574,  548,  440,
- /*   260 */   111,  563,  606,  606,  634,  633,  324,  479,  608,  608,
- /*   270 */   608,  300,  435,  573,  119,  407,  210,  162,  562,  883,
- /*   280 */   592,  592,  306,   89,   90,   80,  600,  599,  601,  601,
- /*   290 */    87,   87,   88,   88,   88,   88,  506,   86,   86,   86,
- /*   300 */    86,   85,   85,   84,   84,   84,   83,  330,  620,  111,
- /*   310 */   635,  635,  361,  606,  606,  358,  249,  349,  248,  433,
- /*   320 */   243,  479,  586,  634,  633,  195,  611,   93,  119,  221,
- /*   330 */   575,  497,  534,  534,   89,   90,   80,  600,  599,  601,
- /*   340 */   601,   87,   87,   88,   88,   88,   88,  574,   86,   86,
- /*   350 */    86,   86,   85,   85,   84,   84,   84,   83,  330,  306,
- /*   360 */    77,  429,  638,  573,  589,  530,  240,  230,  242,  105,
- /*   370 */   249,  349,  248,  515,  588,  208,  460,  529,  564,  173,
- /*   380 */   634,  633,  970,  144,  430,    2,  424,  228,  380,  557,
- /*   390 */   606,  606,  190,  153,  159,  158,  514,   51,  632,  631,
- /*   400 */   630,   71,  536,  432,  954,  196,  610,  954,  614,   45,
- /*   410 */    18,   89,   90,   80,  600,  599,  601,  601,   87,   87,
- /*   420 */    88,   88,   88,   88,  261,   86,   86,   86,   86,   85,
- /*   430 */    85,   84,   84,   84,   83,  330,  306,  608,  608,  608,
- /*   440 */   542,  424,  402,  385,  241,  506,  451,  320,  211,  543,
- /*   450 */   164,  436,  386,  293,  451,  587,  108,  496,  111,  334,
- /*   460 */   391,  591,  424,  614,   27,  452,  453,  606,  606,   72,
- /*   470 */   257,   70,  259,  452,  339,  342,  564,  582,   68,  415,
- /*   480 */   469,  328,  327,   62,  614,   45,  110,  393,   89,   90,
- /*   490 */    80,  600,  599,  601,  601,   87,   87,   88,   88,   88,
- /*   500 */    88,  152,   86,   86,   86,   86,   85,   85,   84,   84,
- /*   510 */    84,   83,  330,  306,  110,  499,  520,  538,  402,  389,
- /*   520 */   424,  110,  566,  500,  593,  593,  454,   82,   79,  165,
- /*   530 */   424,  591,  384,  564,  340,  615,  188,  162,  424,  350,
- /*   540 */   616,  424,  614,   44,  606,  606,  445,  582,  300,  434,
- /*   550 */   151,   19,  614,    9,  568,  580,  348,  615,  469,  567,
- /*   560 */   614,   26,  616,  614,   45,   89,   90,   80,  600,  599,
- /*   570 */   601,  601,   87,   87,   88,   88,   88,   88,  411,   86,
- /*   580 */    86,   86,   86,   85,   85,   84,   84,   84,   83,  330,
- /*   590 */   306,  579,  110,  578,  521,  282,  433,  398,  400,  255,
- /*   600 */   486,   82,   79,  165,  487,  164,   82,   79,  165,  488,
- /*   610 */   488,  364,  387,  424,  544,  544,  509,  350,  362,  155,
- /*   620 */   191,  606,  606,  559,  642,  640,  333,   82,   79,  165,
- /*   630 */   305,  564,  507,  312,  357,  614,   45,  329,  596,  595,
- /*   640 */   194,  337,   89,   90,   80,  600,  599,  601,  601,   87,
- /*   650 */    87,   88,   88,   88,   88,  424,   86,   86,   86,   86,
- /*   660 */    85,   85,   84,   84,   84,   83,  330,  306,   20,  323,
- /*   670 */   150,  263,  211,  543,  421,  596,  595,  614,   22,  424,
- /*   680 */   193,  424,  284,  424,  391,  424,  509,  424,  577,  424,
- /*   690 */   186,  335,  424,  559,  424,  313,  120,  546,  606,  606,
- /*   700 */    67,  614,   47,  614,   50,  614,   48,  614,  100,  614,
- /*   710 */    99,  614,  101,  576,  614,  102,  614,  109,  326,   89,
- /*   720 */    90,   80,  600,  599,  601,  601,   87,   87,   88,   88,
- /*   730 */    88,   88,  424,   86,   86,   86,   86,   85,   85,   84,
- /*   740 */    84,   84,   83,  330,  306,  424,  311,  424,  585,   54,
- /*   750 */   424,  516,  517,  590,  614,  112,  424,  584,  424,  572,
- /*   760 */   424,  195,  424,  571,  424,   67,  424,  614,   94,  614,
- /*   770 */    98,  424,  614,   97,  264,  606,  606,  195,  614,   46,
- /*   780 */   614,   96,  614,   30,  614,   49,  614,  115,  614,  114,
- /*   790 */   418,  229,  388,  614,  113,  306,   89,   90,   80,  600,
- /*   800 */   599,  601,  601,   87,   87,   88,   88,   88,   88,  424,
- /*   810 */    86,   86,   86,   86,   85,   85,   84,   84,   84,   83,
- /*   820 */   330,  119,  424,  590,  110,  372,  606,  606,  195,   53,
- /*   830 */   250,  614,   29,  195,  472,  438,  729,  190,  302,  498,
- /*   840 */    14,  523,  641,    2,  614,   43,  306,   89,   90,   80,
- /*   850 */   600,  599,  601,  601,   87,   87,   88,   88,   88,   88,
- /*   860 */   424,   86,   86,   86,   86,   85,   85,   84,   84,   84,
- /*   870 */    83,  330,  424,  613,  964,  964,  354,  606,  606,  420,
- /*   880 */   312,   64,  614,   42,  391,  355,  283,  437,  301,  255,
- /*   890 */   414,  410,  495,  492,  614,   28,  471,  306,   89,   90,
- /*   900 */    80,  600,  599,  601,  601,   87,   87,   88,   88,   88,
- /*   910 */    88,  424,   86,   86,   86,   86,   85,   85,   84,   84,
- /*   920 */    84,   83,  330,  424,  110,  110,  110,  110,  606,  606,
- /*   930 */   110,  254,   13,  614,   41,  532,  531,  283,  481,  531,
- /*   940 */   457,  284,  119,  561,  356,  614,   40,  284,  306,   89,
- /*   950 */    78,   80,  600,  599,  601,  601,   87,   87,   88,   88,
- /*   960 */    88,   88,  424,   86,   86,   86,   86,   85,   85,   84,
- /*   970 */    84,   84,   83,  330,  110,  424,  341,  220,  555,  606,
- /*   980 */   606,  351,  555,  318,  614,   95,  413,  255,   83,  330,
- /*   990 */   284,  284,  255,  640,  333,  356,  255,  614,   39,  306,
- /*  1000 */   356,   90,   80,  600,  599,  601,  601,   87,   87,   88,
- /*  1010 */    88,   88,   88,  424,   86,   86,   86,   86,   85,   85,
- /*  1020 */    84,   84,   84,   83,  330,  424,  317,  316,  141,  465,
- /*  1030 */   606,  606,  219,  619,  463,  614,   10,  417,  462,  255,
- /*  1040 */   189,  510,  553,  351,  207,  363,  161,  614,   38,  315,
- /*  1050 */   218,  255,  255,   80,  600,  599,  601,  601,   87,   87,
- /*  1060 */    88,   88,   88,   88,  424,   86,   86,   86,   86,   85,
- /*  1070 */    85,   84,   84,   84,   83,  330,   76,  419,  255,    3,
- /*  1080 */   878,  461,  424,  247,  331,  331,  614,   37,  217,   76,
- /*  1090 */   419,  390,    3,  216,  215,  422,    4,  331,  331,  424,
- /*  1100 */   547,   12,  424,  545,  614,   36,  424,  541,  422,  424,
- /*  1110 */   540,  424,  214,  424,  408,  424,  539,  403,  605,  605,
- /*  1120 */   237,  614,   25,  119,  614,   24,  588,  408,  614,   45,
- /*  1130 */   118,  614,   35,  614,   34,  614,   33,  614,   23,  588,
- /*  1140 */    60,  223,  603,  602,  513,  378,   73,   74,  140,  139,
- /*  1150 */   424,  110,  265,   75,  426,  425,   59,  424,  610,   73,
- /*  1160 */    74,  549,  402,  404,  424,  373,   75,  426,  425,  604,
- /*  1170 */   138,  610,  614,   11,  392,   76,  419,  181,    3,  614,
- /*  1180 */    32,  271,  369,  331,  331,  493,  614,   31,  149,  608,
- /*  1190 */   608,  608,  607,   15,  422,  365,  614,    8,  137,  489,
- /*  1200 */   136,  190,  608,  608,  608,  607,   15,  485,  176,  135,
- /*  1210 */     7,  252,  477,  408,  174,  133,  175,  474,   57,   56,
- /*  1220 */   132,  130,  119,   76,  419,  588,    3,  468,  245,  464,
- /*  1230 */   171,  331,  331,  125,  123,  456,  447,  122,  446,  104,
- /*  1240 */   336,  231,  422,  166,  154,   73,   74,  332,  116,  431,
- /*  1250 */   121,  309,   75,  426,  425,  222,  106,  610,  308,  637,
- /*  1260 */   204,  408,  629,  627,  628,    6,  200,  428,  427,  290,
- /*  1270 */   203,  622,  201,  588,   62,   63,  289,   66,  419,  399,
- /*  1280 */     3,  401,  288,   92,  143,  331,  331,  287,  608,  608,
- /*  1290 */   608,  607,   15,   73,   74,  227,  422,  325,   69,  416,
- /*  1300 */    75,  426,  425,  612,  412,  610,  192,   61,  569,  209,
- /*  1310 */   396,  226,  278,  225,  383,  408,  527,  558,  276,  533,
- /*  1320 */   552,  528,  321,  523,  370,  508,  180,  588,  494,  179,
- /*  1330 */   366,  117,  253,  269,  522,  503,  608,  608,  608,  607,
- /*  1340 */    15,  551,  502,   58,  274,  524,  178,   73,   74,  304,
- /*  1350 */   501,  368,  303,  206,   75,  426,  425,  491,  360,  610,
- /*  1360 */   213,  177,  483,  131,  345,  298,  297,  296,  202,  294,
- /*  1370 */   480,  490,  466,  134,  172,  129,  444,  346,  470,  128,
- /*  1380 */   314,  459,  103,  127,  126,  148,  124,  167,  443,  235,
- /*  1390 */   608,  608,  608,  607,   15,  442,  439,  623,  234,  299,
- /*  1400 */   145,  583,  291,  377,  581,  160,  119,  156,  270,  636,
- /*  1410 */   971,  169,  279,  626,  520,  625,  473,  624,  170,  621,
- /*  1420 */   618,  119,  168,   55,  409,  423,  537,  609,  286,  285,
- /*  1430 */   405,  570,  560,  556,    5,   52,  458,  554,  147,  267,
- /*  1440 */   519,  504,  518,  406,  262,  239,  260,  512,  343,  511,
- /*  1450 */   258,  353,  565,  256,  224,  251,  359,  277,  275,  476,
- /*  1460 */   475,  246,  352,  244,  467,  455,  236,  233,  232,  307,
- /*  1470 */   441,  281,  205,  163,  397,  280,  535,  505,  330,  617,
- /*  1480 */   971,  971,  971,  971,  367,  971,  971,  971,  971,  971,
- /*  1490 */   971,  971,  971,  971,  971,  971,  338,
+ /*     0 */   311, 1306,  145,  651,    2,  192,  652,  338,  780,   92,
+ /*    10 */    92,   92,   92,   85,   90,   90,   90,   90,   89,   89,
+ /*    20 */    88,   88,   88,   87,  335,   88,   88,   88,   87,  335,
+ /*    30 */   327,  856,  856,   92,   92,   92,   92,  776,   90,   90,
+ /*    40 */    90,   90,   89,   89,   88,   88,   88,   87,  335,   86,
+ /*    50 */    83,  166,   93,   94,   84,  868,  871,  860,  860,   91,
+ /*    60 */    91,   92,   92,   92,   92,  335,   90,   90,   90,   90,
+ /*    70 */    89,   89,   88,   88,   88,   87,  335,  311,  780,   90,
+ /*    80 */    90,   90,   90,   89,   89,   88,   88,   88,   87,  335,
+ /*    90 */   123,  808,  689,  689,  689,  689,  112,  230,  430,  257,
+ /*   100 */   809,  698,  430,   86,   83,  166,  324,   55,  856,  856,
+ /*   110 */   201,  158,  276,  387,  271,  386,  188,  689,  689,  828,
+ /*   120 */   833,   49,  944,  269,  833,   49,  123,   87,  335,   93,
+ /*   130 */    94,   84,  868,  871,  860,  860,   91,   91,   92,   92,
+ /*   140 */    92,   92,  342,   90,   90,   90,   90,   89,   89,   88,
+ /*   150 */    88,   88,   87,  335,  311,  328,  333,  332,  701,  408,
+ /*   160 */   394,   69,  690,  691,  690,  691,  715,  910,  251,  354,
+ /*   170 */   250,  698,  704,  430,  908,  430,  909,   89,   89,   88,
+ /*   180 */    88,   88,   87,  335,  391,  856,  856,  690,  691,  183,
+ /*   190 */    95,  340,  384,  381,  380,  833,   31,  833,   49,  912,
+ /*   200 */   912,  333,  332,  379,  123,  311,   93,   94,   84,  868,
+ /*   210 */   871,  860,  860,   91,   91,   92,   92,   92,   92,  114,
+ /*   220 */    90,   90,   90,   90,   89,   89,   88,   88,   88,   87,
+ /*   230 */   335,  430,  408,  399,  435,  657,  856,  856,  346,   57,
+ /*   240 */   232,  828,  109,   20,  912,  912,  231,  393,  937,  760,
+ /*   250 */    97,  751,  752,  833,   49,  708,  708,   93,   94,   84,
+ /*   260 */   868,  871,  860,  860,   91,   91,   92,   92,   92,   92,
+ /*   270 */   707,   90,   90,   90,   90,   89,   89,   88,   88,   88,
+ /*   280 */    87,  335,  311,  114,   22,  706,  688,   58,  408,  390,
+ /*   290 */   251,  349,  240,  749,  752,  689,  689,  847,  685,  115,
+ /*   300 */    21,  231,  393,  689,  689,  697,  183,  355,  430,  384,
+ /*   310 */   381,  380,  192,  856,  856,  780,  123,  160,  159,  223,
+ /*   320 */   379,  738,   25,  315,  362,  841,  143,  689,  689,  835,
+ /*   330 */   833,   48,  339,  937,   93,   94,   84,  868,  871,  860,
+ /*   340 */   860,   91,   91,   92,   92,   92,   92,  914,   90,   90,
+ /*   350 */    90,   90,   89,   89,   88,   88,   88,   87,  335,  311,
+ /*   360 */   840,  840,  840,  266,  430,  690,  691,  778,  114, 1300,
+ /*   370 */  1300,  430,    1,  690,  691,  697,  688,  689,  689,  689,
+ /*   380 */   689,  689,  689,  287,  298,  780,  833,   10,  686,  115,
+ /*   390 */   856,  856,  355,  833,   10,  828,  366,  690,  691,  363,
+ /*   400 */   321,   76,  123,   74,   23,  737,  807,  323,  356,  353,
+ /*   410 */   847,   93,   94,   84,  868,  871,  860,  860,   91,   91,
+ /*   420 */    92,   92,   92,   92,  940,   90,   90,   90,   90,   89,
+ /*   430 */    89,   88,   88,   88,   87,  335,  311,  806,  841,  429,
+ /*   440 */   713,  941,  835,  430,  251,  354,  250,  690,  691,  690,
+ /*   450 */   691,  690,  691,   86,   83,  166,   24,  942,  151,  753,
+ /*   460 */   285,  907,  403,  907,  164,  833,   10,  856,  856,  965,
+ /*   470 */   306,  754,  679,  840,  840,  840,  795,  216,  794,  222,
+ /*   480 */   906,  344,  906,  904,   86,   83,  166,  286,   93,   94,
+ /*   490 */    84,  868,  871,  860,  860,   91,   91,   92,   92,   92,
+ /*   500 */    92,  430,   90,   90,   90,   90,   89,   89,   88,   88,
+ /*   510 */    88,   87,  335,  311,  430,  724,  352,  705,  427,  699,
+ /*   520 */   700,  376,  210,  833,   49,  793,  397,  857,  857,  940,
+ /*   530 */   213,  762,  727,  334,  699,  700,  833,   10,   86,   83,
+ /*   540 */   166,  345,  396,  902,  856,  856,  941,  385,  833,    9,
+ /*   550 */   406,  869,  872,  187,  890,  728,  347,  398,  404,  977,
+ /*   560 */   652,  338,  942,  954,  413,   93,   94,   84,  868,  871,
+ /*   570 */   860,  860,   91,   91,   92,   92,   92,   92,  861,   90,
+ /*   580 */    90,   90,   90,   89,   89,   88,   88,   88,   87,  335,
+ /*   590 */   311, 1219,  114,  430,  834,  430,    5,  165,  192,  688,
+ /*   600 */   832,  780,  430,  723,  430,  234,  325,  189,  163,  316,
+ /*   610 */   356,  955,  115,  235,  269,  833,   35,  833,   36,  747,
+ /*   620 */   720,  856,  856,  793,  833,   12,  833,   27,  745,  174,
+ /*   630 */   968, 1290,  968, 1291, 1290,  310, 1291,  693,  317,  245,
+ /*   640 */   264,  311,   93,   94,   84,  868,  871,  860,  860,   91,
+ /*   650 */    91,   92,   92,   92,   92,  832,   90,   90,   90,   90,
+ /*   660 */    89,   89,   88,   88,   88,   87,  335,  430,  320,  213,
+ /*   670 */   762,  780,  856,  856,  920,  920,  369,  257,  966,  220,
+ /*   680 */   966,  396,  663,  664,  665,  242,  259,  244,  262,  833,
+ /*   690 */    37,  650,    2,   93,   94,   84,  868,  871,  860,  860,
+ /*   700 */    91,   91,   92,   92,   92,   92,  430,   90,   90,   90,
+ /*   710 */    90,   89,   89,   88,   88,   88,   87,  335,  311,  430,
+ /*   720 */   239,  430,  917,  368,  430,  238,  916,  793,  833,   38,
+ /*   730 */   430,  825,  430,   66,  430,  392,  430,  766,  766,  430,
+ /*   740 */   367,  833,   39,  833,   28,  430,  833,   29,   68,  856,
+ /*   750 */   856,  900,  833,   40,  833,   41,  833,   42,  833,   11,
+ /*   760 */    72,  833,   43,  243,  305,  970,  114,  833,   99,  961,
+ /*   770 */    93,   94,   84,  868,  871,  860,  860,   91,   91,   92,
+ /*   780 */    92,   92,   92,  430,   90,   90,   90,   90,   89,   89,
+ /*   790 */    88,   88,   88,   87,  335,  311,  430,  361,  430,  165,
+ /*   800 */   147,  430,  186,  185,  184,  833,   44,  430,  289,  430,
+ /*   810 */   246,  430,  971,  430,  212,  163,  430,  357,  833,   45,
+ /*   820 */   833,   32,  932,  833,   46,  793,  856,  856,  718,  833,
+ /*   830 */    47,  833,   33,  833,  117,  833,  118,   75,  833,  119,
+ /*   840 */   288,  305,  967,  214,  935,  322,  311,   93,   94,   84,
+ /*   850 */   868,  871,  860,  860,   91,   91,   92,   92,   92,   92,
+ /*   860 */   430,   90,   90,   90,   90,   89,   89,   88,   88,   88,
+ /*   870 */    87,  335,  430,  832,  426,  317,  288,  856,  856,  114,
+ /*   880 */   763,  257,  833,   53,  930,  219,  364,  257,  257,  971,
+ /*   890 */   361,  396,  257,  257,  833,   34,  257,  311,   93,   94,
+ /*   900 */    84,  868,  871,  860,  860,   91,   91,   92,   92,   92,
+ /*   910 */    92,  430,   90,   90,   90,   90,   89,   89,   88,   88,
+ /*   920 */    88,   87,  335,  430,  217,  318,  124,  253,  856,  856,
+ /*   930 */   218,  943,  257,  833,  100,  898,  759,  774,  361,  755,
+ /*   940 */   423,  329,  758, 1017,  289,  833,   50,  682,  311,   93,
+ /*   950 */    82,   84,  868,  871,  860,  860,   91,   91,   92,   92,
+ /*   960 */    92,   92,  430,   90,   90,   90,   90,   89,   89,   88,
+ /*   970 */    88,   88,   87,  335,  430,  256,  419,  114,  249,  856,
+ /*   980 */   856,  331,  114,  400,  833,  101,  359,  187, 1064,  726,
+ /*   990 */   725,  739,  401,  416,  420,  360,  833,  102,  424,  311,
+ /*  1000 */   258,   94,   84,  868,  871,  860,  860,   91,   91,   92,
+ /*  1010 */    92,   92,   92,  430,   90,   90,   90,   90,   89,   89,
+ /*  1020 */    88,   88,   88,   87,  335,  430,  221,  261,  114,  114,
+ /*  1030 */   856,  856,  808,  114,  156,  833,   98,  772,  733,  734,
+ /*  1040 */   275,  809,  771,  316,  263,  265,  960,  833,  116,  307,
+ /*  1050 */   741,  274,  722,   84,  868,  871,  860,  860,   91,   91,
+ /*  1060 */    92,   92,   92,   92,  430,   90,   90,   90,   90,   89,
+ /*  1070 */    89,   88,   88,   88,   87,  335,   80,  425,  830,    3,
+ /*  1080 */  1214,  191,  430,  721,  336,  336,  833,  113,  252,   80,
+ /*  1090 */   425,   68,    3,  913,  913,  428,  270,  336,  336,  430,
+ /*  1100 */   377,  784,  430,  197,  833,  106,  430,  716,  428,  430,
+ /*  1110 */   267,  430,  897,   68,  414,  430,  769,  409,  430,   71,
+ /*  1120 */   430,  833,  105,  123,  833,  103,  847,  414,  833,   49,
+ /*  1130 */   843,  833,  104,  833,   52,  800,  123,  833,   54,  847,
+ /*  1140 */   833,   51,  833,   26,  831,  802,   77,   78,  191,  389,
+ /*  1150 */   430,  372,  114,   79,  432,  431,  911,  911,  835,   77,
+ /*  1160 */    78,  779,  893,  408,  410,  197,   79,  432,  431,  791,
+ /*  1170 */   226,  835,  833,   30,  772,   80,  425,  716,    3,  771,
+ /*  1180 */   411,  412,  897,  336,  336,  290,  291,  839,  703,  840,
+ /*  1190 */   840,  840,  842,   19,  428,  695,  684,  672,  111,  671,
+ /*  1200 */   843,  673,  840,  840,  840,  842,   19,  207,  661,  278,
+ /*  1210 */   148,  304,  280,  414,  282,    6,  822,  348,  248,  241,
+ /*  1220 */   358,  934,  720,   80,  425,  847,    3,  161,  382,  273,
+ /*  1230 */   284,  336,  336,  415,  296,  958,  895,  894,  157,  674,
+ /*  1240 */   107,  194,  428,  948,  135,   77,   78,  777,  953,  951,
+ /*  1250 */    56,  319,   79,  432,  431,  121,   66,  835,   59,  128,
+ /*  1260 */   146,  414,  350,  130,  351,  819,  131,  132,  133,  375,
+ /*  1270 */   173,  149,  138,  847,  936,  365,  178,   70,  425,  827,
+ /*  1280 */     3,  889,   62,  371,  915,  336,  336,  792,  840,  840,
+ /*  1290 */   840,  842,   19,   77,   78,  208,  428,  144,  179,  373,
+ /*  1300 */    79,  432,  431,  255,  180,  835,  260,  675,  181,  308,
+ /*  1310 */   388,  744,  326,  743,  742,  414,  731,  718,  712,  402,
+ /*  1320 */   309,  711,  788,   65,  277,  272,  789,  847,  730,  710,
+ /*  1330 */   709,  279,  193,  787,  281,  876,  840,  840,  840,  842,
+ /*  1340 */    19,  786,  283,   73,  418,  330,  422,   77,   78,  227,
+ /*  1350 */    96,  407,   67,  405,   79,  432,  431,  292,  228,  835,
+ /*  1360 */   215,  202,  229,  293,  767,  303,  302,  301,  204,  299,
+ /*  1370 */   294,  295,  676,    7,  681,  433,  669,  206,  110,  224,
+ /*  1380 */   203,  205,  434,  667,  666,  658,  120,  168,  656,  237,
+ /*  1390 */   840,  840,  840,  842,   19,  337,  155,  233,  236,  341,
+ /*  1400 */   167,  905,  108,  313,  903,  826,  314,  125,  126,  127,
+ /*  1410 */   129,  170,  247,  756,  172,  928,  134,  136,  171,   60,
+ /*  1420 */    61,  123,  169,  137,  175,  933,  176,  927,    8,   13,
+ /*  1430 */   177,  254,  191,  918,  139,  370,  924,  140,  678,  150,
+ /*  1440 */   374,  274,  182,  378,  141,  122,   63,   14,  383,  729,
+ /*  1450 */   268,   15,   64,  225,  846,  845,  874,   16,  765,  770,
+ /*  1460 */     4,  162,  209,  395,  211,  142,  878,  796,  801,  312,
+ /*  1470 */   190,   71,   68,  875,  873,  939,  199,  938,   17,  195,
+ /*  1480 */    18,  196,  417,  975,  152,  653,  976,  198,  153,  421,
+ /*  1490 */   877,  154,  200,  844,  696,   81,  343,  297, 1019, 1018,
+ /*  1500 */   300,
 };
 static const YYCODETYPE yy_lookahead[] = {
- /*     0 */    19,   22,   22,   23,    1,   24,   26,   15,   27,   80,
+ /*     0 */    19,  144,  145,  146,  147,   24,    1,    2,   27,   80,
  /*    10 */    81,   82,   83,   84,   85,   86,   87,   88,   89,   90,
- /*    20 */    91,   92,   93,   94,   95,  108,  109,  110,   27,   28,
- /*    30 */    23,   50,   51,   80,   81,   82,   83,  122,   85,   86,
- /*    40 */    87,   88,   89,   90,   91,   92,   93,   94,   95,   22,
- /*    50 */    70,   23,   71,   72,   73,   74,   75,   76,   77,   78,
- /*    60 */    79,   80,   81,   82,   83,  122,   85,   86,   87,   88,
- /*    70 */    89,   90,   91,   92,   93,   94,   95,   19,   97,   91,
- /*    80 */    92,   93,   94,   95,   26,   85,   86,   87,   88,   89,
- /*    90 */    90,   91,   92,   93,   94,   95,   27,   28,   97,   98,
- /*   100 */    99,  122,  211,  102,  103,  104,   79,   19,   50,   51,
- /*   110 */    19,  122,   59,   55,  113,  224,  225,  226,   89,   90,
- /*   120 */    91,   92,   93,   94,   95,   23,   27,   28,   26,   71,
+ /*    20 */    91,   92,   93,   94,   95,   91,   92,   93,   94,   95,
+ /*    30 */    19,   50,   51,   80,   81,   82,   83,  212,   85,   86,
+ /*    40 */    87,   88,   89,   90,   91,   92,   93,   94,   95,  224,
+ /*    50 */   225,  226,   71,   72,   73,   74,   75,   76,   77,   78,
+ /*    60 */    79,   80,   81,   82,   83,   95,   85,   86,   87,   88,
+ /*    70 */    89,   90,   91,   92,   93,   94,   95,   19,   97,   85,
+ /*    80 */    86,   87,   88,   89,   90,   91,   92,   93,   94,   95,
+ /*    90 */    66,   33,   27,   28,   27,   28,   22,  201,  152,  152,
+ /*   100 */    42,   27,  152,  224,  225,  226,   95,  211,   50,   51,
+ /*   110 */    99,  100,  101,  102,  103,  104,  105,   27,   28,   59,
+ /*   120 */   174,  175,  243,  112,  174,  175,   66,   94,   95,   71,
  /*   130 */    72,   73,   74,   75,   76,   77,   78,   79,   80,   81,
- /*   140 */    82,   83,   51,   85,   86,   87,   88,   89,   90,   91,
- /*   150 */    92,   93,   94,   95,   19,  132,  133,   58,   89,   90,
- /*   160 */    21,  108,  109,  110,   27,   28,   97,   98,   33,  100,
- /*   170 */     7,    8,  119,  120,   22,   19,  107,   42,  109,   27,
- /*   180 */    28,   27,   28,   95,   28,   50,   51,   99,  100,  101,
- /*   190 */   102,  103,  104,  105,   27,   28,   97,   98,  107,  152,
- /*   200 */   112,  132,  133,  112,   65,   69,   71,   72,   73,   74,
- /*   210 */    75,   76,   77,   78,   79,   80,   81,   82,   83,   11,
+ /*   140 */    82,   83,  195,   85,   86,   87,   88,   89,   90,   91,
+ /*   150 */    92,   93,   94,   95,   19,  209,   89,   90,  173,  209,
+ /*   160 */   210,   26,   97,   98,   97,   98,  181,  100,  108,  109,
+ /*   170 */   110,   97,  174,  152,  107,  152,  109,   89,   90,   91,
+ /*   180 */    92,   93,   94,   95,  163,   50,   51,   97,   98,   99,
+ /*   190 */    55,  244,  102,  103,  104,  174,  175,  174,  175,  132,
+ /*   200 */   133,   89,   90,  113,   66,   19,   71,   72,   73,   74,
+ /*   210 */    75,   76,   77,   78,   79,   80,   81,   82,   83,  198,
  /*   220 */    85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
- /*   230 */    95,   19,  101,   97,   97,   98,   24,  101,  122,  157,
- /*   240 */    12,   99,  103,  112,  102,  103,  104,  152,   22,   97,
- /*   250 */    98,   97,   98,   27,   28,  113,   27,   29,   91,  164,
- /*   260 */   165,  124,   50,   51,   97,   98,  219,   59,  132,  133,
- /*   270 */   134,   22,   23,   45,   66,   47,  212,  213,  124,  140,
- /*   280 */   132,  133,   19,   71,   72,   73,   74,   75,   76,   77,
- /*   290 */    78,   79,   80,   81,   82,   83,  152,   85,   86,   87,
- /*   300 */    88,   89,   90,   91,   92,   93,   94,   95,  164,  165,
- /*   310 */    27,   28,  230,   50,   51,  233,  108,  109,  110,   70,
- /*   320 */    16,   59,   23,   97,   98,   26,   97,   22,   66,  185,
- /*   330 */    12,  187,   27,   28,   71,   72,   73,   74,   75,   76,
- /*   340 */    77,   78,   79,   80,   81,   82,   83,   29,   85,   86,
+ /*   230 */    95,  152,  209,  210,  148,  149,   50,   51,  100,   53,
+ /*   240 */   154,   59,  156,   22,  132,  133,  119,  120,  163,  163,
+ /*   250 */    22,  192,  193,  174,  175,   27,   28,   71,   72,   73,
+ /*   260 */    74,   75,   76,   77,   78,   79,   80,   81,   82,   83,
+ /*   270 */   174,   85,   86,   87,   88,   89,   90,   91,   92,   93,
+ /*   280 */    94,   95,   19,  198,  198,  174,  152,   24,  209,  210,
+ /*   290 */   108,  109,  110,  192,  193,   27,   28,   69,  164,  165,
+ /*   300 */    79,  119,  120,   27,   28,   27,   99,  222,  152,  102,
+ /*   310 */   103,  104,   24,   50,   51,   27,   66,   89,   90,  185,
+ /*   320 */   113,  187,   22,  157,  239,   97,   58,   27,   28,  101,
+ /*   330 */   174,  175,  246,  163,   71,   72,   73,   74,   75,   76,
+ /*   340 */    77,   78,   79,   80,   81,   82,   83,   11,   85,   86,
  /*   350 */    87,   88,   89,   90,   91,   92,   93,   94,   95,   19,
- /*   360 */    22,  148,  149,   45,   23,   47,   62,  154,   64,  156,
- /*   370 */   108,  109,  110,   37,   69,   23,  163,   59,   26,   26,
- /*   380 */    97,   98,  144,  145,  146,  147,  152,  200,   52,   23,
- /*   390 */    50,   51,   26,   22,   89,   90,   60,  210,    7,    8,
- /*   400 */     9,  138,   97,   22,   23,   26,  101,   26,  174,  175,
- /*   410 */   197,   71,   72,   73,   74,   75,   76,   77,   78,   79,
- /*   420 */    80,   81,   82,   83,   16,   85,   86,   87,   88,   89,
- /*   430 */    90,   91,   92,   93,   94,   95,   19,  132,  133,  134,
- /*   440 */    23,  152,  208,  209,  140,  152,  152,  111,  195,  196,
- /*   450 */    98,   70,  163,  160,  152,   23,   22,  164,  165,  246,
- /*   460 */   207,   27,  152,  174,  175,  171,  172,   50,   51,  137,
- /*   470 */    62,  139,   64,  171,  172,  222,  124,   27,  138,   24,
- /*   480 */   163,   89,   90,  130,  174,  175,  197,  163,   71,   72,
+ /*   360 */   132,  133,  134,   23,  152,   97,   98,   91,  198,  119,
+ /*   370 */   120,  152,   22,   97,   98,   97,  152,   27,   28,   27,
+ /*   380 */    28,   27,   28,  227,  160,   97,  174,  175,  164,  165,
+ /*   390 */    50,   51,  222,  174,  175,   59,  230,   97,   98,  233,
+ /*   400 */   188,  137,   66,  139,  234,  187,  177,  188,  152,  239,
+ /*   410 */    69,   71,   72,   73,   74,   75,   76,   77,   78,   79,
+ /*   420 */    80,   81,   82,   83,   12,   85,   86,   87,   88,   89,
+ /*   430 */    90,   91,   92,   93,   94,   95,   19,  177,   97,  152,
+ /*   440 */    23,   29,  101,  152,  108,  109,  110,   97,   98,   97,
+ /*   450 */    98,   97,   98,  224,  225,  226,   22,   45,   24,   47,
+ /*   460 */   152,  152,  152,  152,  152,  174,  175,   50,   51,  249,
+ /*   470 */   250,   59,   21,  132,  133,  134,  124,  221,  124,  188,
+ /*   480 */   171,  172,  171,  172,  224,  225,  226,  152,   71,   72,
  /*   490 */    73,   74,   75,   76,   77,   78,   79,   80,   81,   82,
- /*   500 */    83,   22,   85,   86,   87,   88,   89,   90,   91,   92,
- /*   510 */    93,   94,   95,   19,  197,  181,  182,   23,  208,  209,
- /*   520 */   152,  197,   26,  189,  132,  133,  232,  224,  225,  226,
- /*   530 */   152,   97,   91,   26,  232,  116,  212,  213,  152,  222,
- /*   540 */   121,  152,  174,  175,   50,   51,  243,   97,   22,   23,
- /*   550 */    22,  234,  174,  175,  177,   23,  239,  116,  163,  177,
- /*   560 */   174,  175,  121,  174,  175,   71,   72,   73,   74,   75,
- /*   570 */    76,   77,   78,   79,   80,   81,   82,   83,   24,   85,
+ /*   500 */    83,  152,   85,   86,   87,   88,   89,   90,   91,   92,
+ /*   510 */    93,   94,   95,   19,  152,  183,   65,   23,  170,  171,
+ /*   520 */   172,   19,   23,  174,  175,   26,  152,   50,   51,   12,
+ /*   530 */   196,  197,   37,  170,  171,  172,  174,  175,  224,  225,
+ /*   540 */   226,  232,  208,  232,   50,   51,   29,   52,  174,  175,
+ /*   550 */   188,   74,   75,   51,  103,   60,  222,  163,  209,    0,
+ /*   560 */     1,    2,   45,  152,   47,   71,   72,   73,   74,   75,
+ /*   570 */    76,   77,   78,   79,   80,   81,   82,   83,  101,   85,
  /*   580 */    86,   87,   88,   89,   90,   91,   92,   93,   94,   95,
- /*   590 */    19,   23,  197,   11,   23,  227,   70,  208,  220,  152,
- /*   600 */    31,  224,  225,  226,   35,   98,  224,  225,  226,  108,
- /*   610 */   109,  110,  115,  152,  117,  118,   27,  222,   49,  123,
- /*   620 */    24,   50,   51,   27,    0,    1,    2,  224,  225,  226,
- /*   630 */   166,  124,  168,  169,  239,  174,  175,  170,  171,  172,
- /*   640 */    22,  194,   71,   72,   73,   74,   75,   76,   77,   78,
+ /*   590 */    19,  140,  198,  152,   23,  152,   22,   98,   24,  152,
+ /*   600 */   152,   27,  152,  183,  152,  152,  111,  213,  214,  107,
+ /*   610 */   152,  164,  165,  152,  112,  174,  175,  174,  175,  181,
+ /*   620 */   182,   50,   51,  124,  174,  175,  174,  175,  190,   26,
+ /*   630 */    22,   23,   22,   23,   26,  166,   26,  168,  169,   16,
+ /*   640 */    16,   19,   71,   72,   73,   74,   75,   76,   77,   78,
  /*   650 */    79,   80,   81,   82,   83,  152,   85,   86,   87,   88,
- /*   660 */    89,   90,   91,   92,   93,   94,   95,   19,   22,  208,
- /*   670 */    24,   23,  195,  196,  170,  171,  172,  174,  175,  152,
- /*   680 */    26,  152,  152,  152,  207,  152,   97,  152,   23,  152,
- /*   690 */    51,  244,  152,   97,  152,  247,  248,   23,   50,   51,
- /*   700 */    26,  174,  175,  174,  175,  174,  175,  174,  175,  174,
- /*   710 */   175,  174,  175,   23,  174,  175,  174,  175,  188,   71,
- /*   720 */    72,   73,   74,   75,   76,   77,   78,   79,   80,   81,
- /*   730 */    82,   83,  152,   85,   86,   87,   88,   89,   90,   91,
- /*   740 */    92,   93,   94,   95,   19,  152,  107,  152,   33,   24,
- /*   750 */   152,  100,  101,   27,  174,  175,  152,   42,  152,   23,
- /*   760 */   152,   26,  152,   23,  152,   26,  152,  174,  175,  174,
- /*   770 */   175,  152,  174,  175,   23,   50,   51,   26,  174,  175,
- /*   780 */   174,  175,  174,  175,  174,  175,  174,  175,  174,  175,
- /*   790 */   163,  119,  120,  174,  175,   19,   71,   72,   73,   74,
- /*   800 */    75,   76,   77,   78,   79,   80,   81,   82,   83,  152,
- /*   810 */    85,   86,   87,   88,   89,   90,   91,   92,   93,   94,
- /*   820 */    95,   66,  152,   97,  197,   23,   50,   51,   26,   53,
- /*   830 */    23,  174,  175,   26,   23,   23,   23,   26,   26,   26,
- /*   840 */    36,  106,  146,  147,  174,  175,   19,   71,   72,   73,
+ /*   660 */    89,   90,   91,   92,   93,   94,   95,  152,  220,  196,
+ /*   670 */   197,   97,   50,   51,  108,  109,  110,  152,   70,  221,
+ /*   680 */    70,  208,    7,    8,    9,   62,   62,   64,   64,  174,
+ /*   690 */   175,  146,  147,   71,   72,   73,   74,   75,   76,   77,
+ /*   700 */    78,   79,   80,   81,   82,   83,  152,   85,   86,   87,
+ /*   710 */    88,   89,   90,   91,   92,   93,   94,   95,   19,  152,
+ /*   720 */   195,  152,   31,  220,  152,  152,   35,   26,  174,  175,
+ /*   730 */   152,  163,  152,  130,  152,  115,  152,  117,  118,  152,
+ /*   740 */    49,  174,  175,  174,  175,  152,  174,  175,   26,   50,
+ /*   750 */    51,  152,  174,  175,  174,  175,  174,  175,  174,  175,
+ /*   760 */   138,  174,  175,  140,   22,   23,  198,  174,  175,  152,
+ /*   770 */    71,   72,   73,   74,   75,   76,   77,   78,   79,   80,
+ /*   780 */    81,   82,   83,  152,   85,   86,   87,   88,   89,   90,
+ /*   790 */    91,   92,   93,   94,   95,   19,  152,  152,  152,   98,
+ /*   800 */    24,  152,  108,  109,  110,  174,  175,  152,  152,  152,
+ /*   810 */   152,  152,   70,  152,  213,  214,  152,  152,  174,  175,
+ /*   820 */   174,  175,  152,  174,  175,  124,   50,   51,  106,  174,
+ /*   830 */   175,  174,  175,  174,  175,  174,  175,  138,  174,  175,
+ /*   840 */   152,   22,   23,   22,  163,  189,   19,   71,   72,   73,
  /*   850 */    74,   75,   76,   77,   78,   79,   80,   81,   82,   83,
  /*   860 */   152,   85,   86,   87,   88,   89,   90,   91,   92,   93,
- /*   870 */    94,   95,  152,  196,  119,  120,   19,   50,   51,  168,
- /*   880 */   169,   26,  174,  175,  207,   28,  152,  249,  250,  152,
- /*   890 */   163,  163,  163,  163,  174,  175,  163,   19,   71,   72,
+ /*   870 */    94,   95,  152,  152,  168,  169,  152,   50,   51,  198,
+ /*   880 */   197,  152,  174,  175,  152,  240,  152,  152,  152,   70,
+ /*   890 */   152,  208,  152,  152,  174,  175,  152,   19,   71,   72,
  /*   900 */    73,   74,   75,   76,   77,   78,   79,   80,   81,   82,
  /*   910 */    83,  152,   85,   86,   87,   88,   89,   90,   91,   92,
- /*   920 */    93,   94,   95,  152,  197,  197,  197,  197,   50,   51,
- /*   930 */   197,  194,   36,  174,  175,  191,  192,  152,  191,  192,
- /*   940 */   163,  152,   66,  124,  152,  174,  175,  152,   19,   71,
+ /*   920 */    93,   94,   95,  152,  195,  247,  248,  152,   50,   51,
+ /*   930 */   195,  195,  152,  174,  175,  195,  195,   26,  152,  195,
+ /*   940 */   252,  220,  163,  122,  152,  174,  175,  163,   19,   71,
  /*   950 */    72,   73,   74,   75,   76,   77,   78,   79,   80,   81,
  /*   960 */    82,   83,  152,   85,   86,   87,   88,   89,   90,   91,
- /*   970 */    92,   93,   94,   95,  197,  152,  100,  188,  152,   50,
- /*   980 */    51,  152,  152,  188,  174,  175,  252,  152,   94,   95,
- /*   990 */   152,  152,  152,    1,    2,  152,  152,  174,  175,   19,
+ /*   970 */    92,   93,   94,   95,  152,  195,  252,  198,  240,   50,
+ /*   980 */    51,  189,  198,   19,  174,  175,   19,   51,   23,  100,
+ /*   990 */   101,   26,   28,  163,  163,   28,  174,  175,  163,   19,
  /*  1000 */   152,   72,   73,   74,   75,   76,   77,   78,   79,   80,
  /*  1010 */    81,   82,   83,  152,   85,   86,   87,   88,   89,   90,
- /*  1020 */    91,   92,   93,   94,   95,  152,  188,  188,   22,  194,
- /*  1030 */    50,   51,  240,  173,  194,  174,  175,  252,  194,  152,
- /*  1040 */    36,  181,   28,  152,   23,  219,  122,  174,  175,  219,
- /*  1050 */   221,  152,  152,   73,   74,   75,   76,   77,   78,   79,
+ /*  1020 */    91,   92,   93,   94,   95,  152,  240,  152,  198,  198,
+ /*  1030 */    50,   51,   33,  198,  123,  174,  175,  116,    7,    8,
+ /*  1040 */   101,   42,  121,  107,  152,  152,   23,  174,  175,   26,
+ /*  1050 */   152,  112,  183,   73,   74,   75,   76,   77,   78,   79,
  /*  1060 */    80,   81,   82,   83,  152,   85,   86,   87,   88,   89,
- /*  1070 */    90,   91,   92,   93,   94,   95,   19,   20,  152,   22,
- /*  1080 */    23,  194,  152,  240,   27,   28,  174,  175,  240,   19,
- /*  1090 */    20,   26,   22,  194,  194,   38,   22,   27,   28,  152,
- /*  1100 */    23,   22,  152,  116,  174,  175,  152,   23,   38,  152,
- /*  1110 */    23,  152,  221,  152,   57,  152,   23,  163,   50,   51,
- /*  1120 */   194,  174,  175,   66,  174,  175,   69,   57,  174,  175,
- /*  1130 */    40,  174,  175,  174,  175,  174,  175,  174,  175,   69,
- /*  1140 */    22,   53,   74,   75,   30,   53,   89,   90,   22,   22,
- /*  1150 */   152,  197,   23,   96,   97,   98,   22,  152,  101,   89,
- /*  1160 */    90,   91,  208,  209,  152,   53,   96,   97,   98,  101,
- /*  1170 */    22,  101,  174,  175,  152,   19,   20,  105,   22,  174,
- /*  1180 */   175,  112,   19,   27,   28,   20,  174,  175,   24,  132,
- /*  1190 */   133,  134,  135,  136,   38,   44,  174,  175,  107,   61,
- /*  1200 */    54,   26,  132,  133,  134,  135,  136,   54,  107,   22,
- /*  1210 */     5,  140,    1,   57,   36,  111,  122,   28,   79,   79,
- /*  1220 */   131,  123,   66,   19,   20,   69,   22,    1,   16,   20,
- /*  1230 */   125,   27,   28,  123,  111,  120,   23,  131,   23,   16,
- /*  1240 */    68,  142,   38,   15,   22,   89,   90,    3,  167,    4,
- /*  1250 */   248,  251,   96,   97,   98,  180,  180,  101,  251,  151,
- /*  1260 */     6,   57,  151,   13,  151,   26,   25,  151,  161,  202,
- /*  1270 */   153,  162,  153,   69,  130,  128,  203,   19,   20,  127,
- /*  1280 */    22,  126,  204,  129,   22,   27,   28,  205,  132,  133,
- /*  1290 */   134,  135,  136,   89,   90,  231,   38,   95,  137,  179,
- /*  1300 */    96,   97,   98,  206,  179,  101,  122,  107,  159,  159,
- /*  1310 */   125,  231,  216,  228,  107,   57,  184,  217,  216,  176,
- /*  1320 */   217,  176,   48,  106,   18,  184,  158,   69,  159,  158,
- /*  1330 */    46,   71,  237,  176,  176,  176,  132,  133,  134,  135,
- /*  1340 */   136,  217,  176,  137,  216,  178,  158,   89,   90,  179,
- /*  1350 */   176,  159,  179,  159,   96,   97,   98,  159,  159,  101,
- /*  1360 */     5,  158,  202,   22,   18,   10,   11,   12,   13,   14,
- /*  1370 */   190,  238,   17,  190,  158,  193,   41,  159,  202,  193,
- /*  1380 */   159,  202,  245,  193,  193,  223,  190,   32,  159,   34,
- /*  1390 */   132,  133,  134,  135,  136,  159,   39,  155,   43,  150,
- /*  1400 */   223,  177,  201,  178,  177,  186,   66,  199,  177,  152,
- /*  1410 */   253,   56,  215,  152,  182,  152,  202,  152,   63,  152,
- /*  1420 */   152,   66,   67,  242,  229,  152,  174,  152,  152,  152,
- /*  1430 */   152,  152,  152,  152,  199,  242,  202,  152,  198,  152,
- /*  1440 */   152,  152,  183,  192,  152,  215,  152,  183,  215,  183,
- /*  1450 */   152,  241,  214,  152,  211,  152,  152,  211,  211,  152,
- /*  1460 */   152,  241,  152,  152,  152,  152,  152,  152,  152,  114,
- /*  1470 */   152,  152,  235,  152,  152,  152,  174,  187,   95,  174,
- /*  1480 */   253,  253,  253,  253,  236,  253,  253,  253,  253,  253,
- /*  1490 */   253,  253,  253,  253,  253,  253,  141,
+ /*  1070 */    90,   91,   92,   93,   94,   95,   19,   20,   23,   22,
+ /*  1080 */    23,   26,  152,  152,   27,   28,  174,  175,   23,   19,
+ /*  1090 */    20,   26,   22,  132,  133,   38,  152,   27,   28,  152,
+ /*  1100 */    23,  215,  152,   26,  174,  175,  152,   27,   38,  152,
+ /*  1110 */    23,  152,   27,   26,   57,  152,   23,  163,  152,   26,
+ /*  1120 */   152,  174,  175,   66,  174,  175,   69,   57,  174,  175,
+ /*  1130 */    27,  174,  175,  174,  175,  152,   66,  174,  175,   69,
+ /*  1140 */   174,  175,  174,  175,  152,   23,   89,   90,   26,   91,
+ /*  1150 */   152,  236,  198,   96,   97,   98,  132,  133,  101,   89,
+ /*  1160 */    90,  152,   23,  209,  210,   26,   96,   97,   98,  152,
+ /*  1170 */   212,  101,  174,  175,  116,   19,   20,   97,   22,  121,
+ /*  1180 */   152,  193,   97,   27,   28,  152,  152,  152,  152,  132,
+ /*  1190 */   133,  134,  135,  136,   38,   23,  152,  152,   26,  152,
+ /*  1200 */    97,  152,  132,  133,  134,  135,  136,  235,  152,  212,
+ /*  1210 */   199,  150,  212,   57,  212,  200,  203,  216,  241,  216,
+ /*  1220 */   241,  203,  182,   19,   20,   69,   22,  186,  178,  177,
+ /*  1230 */   216,   27,   28,  229,  202,   39,  177,  177,  200,  155,
+ /*  1240 */   245,  122,   38,   41,   22,   89,   90,   91,  159,  159,
+ /*  1250 */   242,  159,   96,   97,   98,   71,  130,  101,  242,  191,
+ /*  1260 */   223,   57,   18,  194,  159,  203,  194,  194,  194,   18,
+ /*  1270 */   158,  223,  191,   69,  203,  159,  158,   19,   20,  191,
+ /*  1280 */    22,  203,  137,   46,  238,   27,   28,  159,  132,  133,
+ /*  1290 */   134,  135,  136,   89,   90,  159,   38,   22,  158,  179,
+ /*  1300 */    96,   97,   98,  237,  158,  101,  159,  159,  158,  179,
+ /*  1310 */   107,  176,   48,  176,  176,   57,  184,  106,  176,  125,
+ /*  1320 */   179,  178,  218,  107,  217,  176,  218,   69,  184,  176,
+ /*  1330 */   176,  217,  159,  218,  217,  159,  132,  133,  134,  135,
+ /*  1340 */   136,  218,  217,  137,  179,   95,  179,   89,   90,  228,
+ /*  1350 */   129,  126,  128,  127,   96,   97,   98,  206,  231,  101,
+ /*  1360 */     5,   25,  231,  205,  207,   10,   11,   12,   13,   14,
+ /*  1370 */   204,  203,   17,   26,  162,  161,   13,    6,  180,  180,
+ /*  1380 */   153,  153,  151,  151,  151,  151,  167,   32,    4,   34,
+ /*  1390 */   132,  133,  134,  135,  136,    3,   22,  142,   43,   68,
+ /*  1400 */    15,   23,   16,  251,   23,  120,  251,  248,  131,  111,
+ /*  1410 */   123,   56,   16,   20,  125,    1,  123,  131,   63,   79,
+ /*  1420 */    79,   66,   67,  111,   36,   28,  122,    1,    5,   22,
+ /*  1430 */   107,  140,   26,   54,   54,   44,   61,  107,   20,   24,
+ /*  1440 */    19,  112,  105,   53,   22,   40,   22,   22,   53,   30,
+ /*  1450 */    23,   22,   22,   53,   23,   23,   23,   22,  116,   23,
+ /*  1460 */    22,  122,   23,   26,   23,   22,   11,  124,   28,  114,
+ /*  1470 */    36,   26,   26,   23,   23,   23,  122,   23,   36,   26,
+ /*  1480 */    36,   22,   24,   23,   22,    1,   23,   26,   22,   24,
+ /*  1490 */    23,   22,  122,   23,   23,   22,  141,   23,  122,  122,
+ /*  1500 */    15,
 };
-#define YY_SHIFT_USE_DFLT (-86)
-#define YY_SHIFT_COUNT (429)
-#define YY_SHIFT_MIN   (-85)
-#define YY_SHIFT_MAX   (1383)
+#define YY_SHIFT_USE_DFLT (-72)
+#define YY_SHIFT_COUNT (435)
+#define YY_SHIFT_MIN   (-71)
+#define YY_SHIFT_MAX   (1485)
 static const short yy_shift_ofst[] = {
- /*     0 */   992, 1057, 1355, 1156, 1204, 1204,    1,  262,  -19,  135,
- /*    10 */   135,  776, 1204, 1204, 1204, 1204,   69,   69,   53,  208,
- /*    20 */   283,  755,   58,  725,  648,  571,  494,  417,  340,  263,
- /*    30 */   212,  827,  827,  827,  827,  827,  827,  827,  827,  827,
- /*    40 */   827,  827,  827,  827,  827,  827,  878,  827,  929,  980,
- /*    50 */   980, 1070, 1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204,
+ /*     0 */     5, 1057, 1355, 1070, 1204, 1204, 1204,   90,   60,  -19,
+ /*    10 */    58,   58,  186, 1204, 1204, 1204, 1204, 1204, 1204, 1204,
+ /*    20 */    67,   67,  182,  336,   65,  250,  135,  263,  340,  417,
+ /*    30 */   494,  571,  622,  699,  776,  827,  827,  827,  827,  827,
+ /*    40 */   827,  827,  827,  827,  827,  827,  827,  827,  827,  827,
+ /*    50 */   878,  827,  929,  980,  980, 1156, 1204, 1204, 1204, 1204,
  /*    60 */  1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204,
  /*    70 */  1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204,
- /*    80 */  1258, 1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204,
- /*    90 */  1204, 1204, 1204, 1204,  -71,  -47,  -47,  -47,  -47,  -47,
- /*   100 */     0,   29,  -12,  283,  283,  139,   91,  392,  392,  894,
- /*   110 */   672,  726, 1383,  -86,  -86,  -86,   88,  318,  318,   99,
- /*   120 */   381,  -20,  283,  283,  283,  283,  283,  283,  283,  283,
- /*   130 */   283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
- /*   140 */   283,  283,  283,  283,  624,  876,  726,  672, 1340, 1340,
- /*   150 */  1340, 1340, 1340, 1340,  -86,  -86,  -86,  305,  136,  136,
- /*   160 */   142,  167,  226,  154,  137,  152,  283,  283,  283,  283,
- /*   170 */   283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
- /*   180 */   283,  283,  283,  336,  336,  336,  283,  283,  352,  283,
- /*   190 */   283,  283,  283,  283,  228,  283,  283,  283,  283,  283,
- /*   200 */   283,  283,  283,  283,  283,  501,  569,  596,  596,  596,
- /*   210 */   507,  497,  441,  391,  353,  156,  156,  857,  353,  857,
- /*   220 */   735,  813,  639,  715,  156,  332,  715,  715,  496,  419,
- /*   230 */   646, 1357, 1184, 1184, 1335, 1335, 1184, 1341, 1260, 1144,
- /*   240 */  1346, 1346, 1346, 1346, 1184, 1306, 1144, 1341, 1260, 1260,
- /*   250 */  1144, 1184, 1306, 1206, 1284, 1184, 1184, 1306, 1184, 1306,
- /*   260 */  1184, 1306, 1262, 1207, 1207, 1207, 1274, 1262, 1207, 1217,
- /*   270 */  1207, 1274, 1207, 1207, 1185, 1200, 1185, 1200, 1185, 1200,
- /*   280 */  1184, 1184, 1161, 1262, 1202, 1202, 1262, 1154, 1155, 1147,
- /*   290 */  1152, 1144, 1241, 1239, 1250, 1250, 1254, 1254, 1254, 1254,
- /*   300 */   -86,  -86,  -86,  -86,  -86,  -86, 1068,  304,  526,  249,
- /*   310 */   408,  -83,  434,  812,   27,  811,  807,  802,  751,  589,
- /*   320 */   651,  163,  131,  674,  366,  450,  299,  148,   23,  102,
- /*   330 */   229,  -21, 1245, 1244, 1222, 1099, 1228, 1172, 1223, 1215,
- /*   340 */  1213, 1115, 1106, 1123, 1110, 1209, 1105, 1212, 1226, 1098,
- /*   350 */  1089, 1140, 1139, 1104, 1189, 1178, 1094, 1211, 1205, 1187,
- /*   360 */  1101, 1071, 1153, 1175, 1146, 1138, 1151, 1091, 1164, 1165,
- /*   370 */  1163, 1069, 1072, 1148, 1112, 1134, 1127, 1129, 1126, 1092,
- /*   380 */  1114, 1118, 1088, 1090, 1093, 1087, 1084,  987, 1079, 1077,
- /*   390 */  1074, 1065,  924, 1021, 1014, 1004, 1006,  819,  739,  896,
- /*   400 */   855,  804,  739,  740,  736,  690,  654,  665,  618,  582,
- /*   410 */   568,  528,  554,  379,  532,  479,  455,  379,  432,  371,
- /*   420 */   341,   28,  338,  116,  -11,  -57,  -85,    7,   -8,    3,
+ /*    80 */  1204, 1204, 1204, 1204, 1258, 1204, 1204, 1204, 1204, 1204,
+ /*    90 */  1204, 1204, 1204, 1204, 1204, 1204, 1204, 1204,  -71,  -47,
+ /*   100 */   -47,  -47,  -47,  -47,   -6,   88,  -66,   65,   65,  451,
+ /*   110 */   502,  112,  112,   33,  127,  278,  -30,  -72,  -72,  -72,
+ /*   120 */    11,  412,  412,  268,  608,  610,   65,   65,   65,   65,
+ /*   130 */    65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
+ /*   140 */    65,   65,   65,   65,   65,  559,  138,  278,  127,   24,
+ /*   150 */    24,   24,   24,   24,   24,  -72,  -72,  -72,  228,  341,
+ /*   160 */   341,  207,  276,  300,  352,  354,  350,   65,   65,   65,
+ /*   170 */    65,   65,   65,   65,   65,   65,   65,   65,   65,   65,
+ /*   180 */    65,   65,   65,   65,  495,  495,  495,   65,   65,  499,
+ /*   190 */    65,   65,   65,  574,   65,   65,  517,   65,   65,   65,
+ /*   200 */    65,   65,   65,   65,   65,   65,   65,  566,  691,  288,
+ /*   210 */   288,  288,  701,  620, 1058,  675,  603,  964,  964,  967,
+ /*   220 */   603,  967,  722,  965,  936,  999,  964,  264,  999,  999,
+ /*   230 */   911,  921,  434, 1196, 1119, 1119, 1202, 1202, 1119, 1222,
+ /*   240 */  1184, 1126, 1244, 1244, 1244, 1244, 1119, 1251, 1126, 1222,
+ /*   250 */  1184, 1184, 1126, 1119, 1251, 1145, 1237, 1119, 1119, 1251,
+ /*   260 */  1275, 1119, 1251, 1119, 1251, 1275, 1203, 1203, 1203, 1264,
+ /*   270 */  1275, 1203, 1211, 1203, 1264, 1203, 1203, 1194, 1216, 1194,
+ /*   280 */  1216, 1194, 1216, 1194, 1216, 1119, 1119, 1206, 1275, 1250,
+ /*   290 */  1250, 1275, 1221, 1225, 1224, 1226, 1126, 1336, 1347, 1363,
+ /*   300 */  1363, 1371, 1371, 1371, 1371,  -72,  -72,  -72,  -72,  -72,
+ /*   310 */   -72,  477,  623,  742,  819,  624,  694,   74, 1023,  221,
+ /*   320 */  1055, 1065, 1077, 1087, 1080,  889, 1031,  939, 1093, 1122,
+ /*   330 */  1085, 1139,  961, 1024, 1172, 1103,  821, 1384, 1392, 1374,
+ /*   340 */  1255, 1385, 1331, 1386, 1378, 1381, 1285, 1277, 1298, 1287,
+ /*   350 */  1393, 1289, 1396, 1414, 1293, 1286, 1340, 1341, 1312, 1397,
+ /*   360 */  1388, 1304, 1426, 1423, 1407, 1323, 1291, 1379, 1406, 1380,
+ /*   370 */  1375, 1391, 1330, 1415, 1418, 1421, 1329, 1337, 1422, 1390,
+ /*   380 */  1424, 1425, 1427, 1429, 1395, 1419, 1430, 1400, 1405, 1431,
+ /*   390 */  1432, 1433, 1342, 1435, 1436, 1438, 1437, 1339, 1439, 1441,
+ /*   400 */  1440, 1434, 1443, 1343, 1445, 1442, 1446, 1444, 1445, 1450,
+ /*   410 */  1451, 1452, 1453, 1454, 1459, 1455, 1460, 1462, 1458, 1461,
+ /*   420 */  1463, 1466, 1465, 1461, 1467, 1469, 1470, 1471, 1473, 1354,
+ /*   430 */  1370, 1376, 1377, 1474, 1485, 1484,
 };
-#define YY_REDUCE_USE_DFLT (-110)
-#define YY_REDUCE_COUNT (305)
-#define YY_REDUCE_MIN   (-109)
-#define YY_REDUCE_MAX   (1323)
+#define YY_REDUCE_USE_DFLT (-176)
+#define YY_REDUCE_COUNT (310)
+#define YY_REDUCE_MIN   (-175)
+#define YY_REDUCE_MAX   (1234)
 static const short yy_reduce_ofst[] = {
- /*     0 */   238,  954,  213,  289,  310,  234,  144,  317, -109,  382,
- /*    10 */   377,  303,  461,  389,  378,  368,  302,  294,  253,  395,
- /*    20 */   293,  324,  403,  403,  403,  403,  403,  403,  403,  403,
- /*    30 */   403,  403,  403,  403,  403,  403,  403,  403,  403,  403,
- /*    40 */   403,  403,  403,  403,  403,  403,  403,  403,  403,  403,
- /*    50 */   403, 1022, 1012, 1005,  998,  963,  961,  959,  957,  950,
- /*    60 */   947,  930,  912,  873,  861,  823,  810,  771,  759,  720,
- /*    70 */   708,  670,  657,  619,  614,  612,  610,  608,  606,  604,
- /*    80 */   598,  595,  593,  580,  542,  540,  537,  535,  533,  531,
- /*    90 */   529,  527,  503,  386,  403,  403,  403,  403,  403,  403,
- /*   100 */   403,  403,  403,   95,  447,   82,  334,  504,  467,  403,
- /*   110 */   477,  464,  403,  403,  403,  403,  860,  747,  744,  785,
- /*   120 */   638,  638,  926,  891,  900,  899,  887,  844,  840,  835,
- /*   130 */   848,  830,  843,  829,  792,  839,  826,  737,  838,  795,
- /*   140 */   789,   47,  734,  530,  696,  777,  711,  677,  733,  730,
- /*   150 */   729,  728,  727,  627,  448,   64,  187, 1305, 1302, 1252,
- /*   160 */  1290, 1273, 1323, 1322, 1321, 1319, 1318, 1316, 1315, 1314,
- /*   170 */  1313, 1312, 1311, 1310, 1308, 1307, 1304, 1303, 1301, 1298,
- /*   180 */  1294, 1292, 1289, 1266, 1264, 1259, 1288, 1287, 1238, 1285,
- /*   190 */  1281, 1280, 1279, 1278, 1251, 1277, 1276, 1275, 1273, 1268,
- /*   200 */  1267, 1265, 1263, 1261, 1257, 1248, 1237, 1247, 1246, 1243,
- /*   210 */  1238, 1240, 1235, 1249, 1234, 1233, 1230, 1220, 1214, 1210,
- /*   220 */  1225, 1219, 1232, 1231, 1197, 1195, 1227, 1224, 1201, 1208,
- /*   230 */  1242, 1137, 1236, 1229, 1193, 1181, 1221, 1177, 1196, 1179,
- /*   240 */  1191, 1190, 1186, 1182, 1218, 1216, 1176, 1162, 1183, 1180,
- /*   250 */  1160, 1199, 1203, 1133, 1095, 1198, 1194, 1188, 1192, 1171,
- /*   260 */  1169, 1168, 1173, 1174, 1166, 1159, 1141, 1170, 1158, 1167,
- /*   270 */  1157, 1132, 1145, 1143, 1124, 1128, 1103, 1102, 1100, 1096,
- /*   280 */  1150, 1149, 1085, 1125, 1080, 1064, 1120, 1097, 1082, 1078,
- /*   290 */  1073, 1067, 1109, 1107, 1119, 1117, 1116, 1113, 1111, 1108,
- /*   300 */  1007, 1000, 1002, 1076, 1075, 1081,
+ /*     0 */  -143,  954,   86,   21,  -50,   23,   79,  134,  170, -175,
+ /*    10 */   229,  260, -121,  212,  219,  291,  -54,  349,  362,  156,
+ /*    20 */   309,  311,  334,   85,  224,  394,  314,  314,  314,  314,
+ /*    30 */   314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+ /*    40 */   314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
+ /*    50 */   314,  314,  314,  314,  314,  374,  441,  443,  450,  452,
+ /*    60 */   515,  554,  567,  569,  572,  578,  580,  582,  584,  587,
+ /*    70 */   593,  631,  644,  646,  649,  655,  657,  659,  661,  664,
+ /*    80 */   708,  720,  759,  771,  810,  822,  861,  873,  912,  930,
+ /*    90 */   947,  950,  957,  959,  963,  966,  968,  998,  314,  314,
+ /*   100 */   314,  314,  314,  314,  314,  314,  314,  447,  -53,  166,
+ /*   110 */   438,  348,  363,  314,  473,  469,  314,  314,  314,  314,
+ /*   120 */   -15,   59,  101,  688,  220,  220,  525,  256,  729,  735,
+ /*   130 */   736,  740,  741,  744,  645,  448,  738,  458,  786,  503,
+ /*   140 */   780,  656,  721,  724,  792,  545,  568,  706,  683,  681,
+ /*   150 */   779,  784,  830,  831,  835,  678,  601, -104,   -2,   96,
+ /*   160 */   111,  218,  287,  308,  310,  312,  335,  411,  453,  461,
+ /*   170 */   573,  599,  617,  658,  665,  670,  732,  734,  775,  848,
+ /*   180 */   875,  892,  893,  898,  332,  420,  869,  931,  944,  886,
+ /*   190 */   983,  992, 1009,  958, 1017, 1028,  988, 1033, 1034, 1035,
+ /*   200 */   287, 1036, 1044, 1045, 1047, 1049, 1056,  915,  972,  997,
+ /*   210 */  1000, 1002,  886, 1011, 1015, 1061, 1013, 1001, 1003,  977,
+ /*   220 */  1018,  979, 1050, 1041, 1040, 1052, 1014, 1004, 1059, 1060,
+ /*   230 */  1032, 1038, 1084,  995, 1089, 1090, 1008, 1016, 1092, 1037,
+ /*   240 */  1068, 1062, 1069, 1072, 1073, 1074, 1105, 1112, 1071, 1048,
+ /*   250 */  1081, 1088, 1078, 1116, 1118, 1046, 1066, 1128, 1136, 1140,
+ /*   260 */  1120, 1147, 1146, 1148, 1150, 1130, 1135, 1137, 1138, 1132,
+ /*   270 */  1141, 1142, 1143, 1149, 1144, 1153, 1154, 1104, 1107, 1108,
+ /*   280 */  1114, 1115, 1117, 1123, 1125, 1173, 1176, 1121, 1165, 1127,
+ /*   290 */  1131, 1167, 1157, 1151, 1158, 1166, 1168, 1212, 1214, 1227,
+ /*   300 */  1228, 1231, 1232, 1233, 1234, 1152, 1155, 1159, 1198, 1199,
+ /*   310 */  1219,
 };
 static const YYACTIONTYPE yy_default[] = {
- /*     0 */   647,  964,  964,  964,  878,  878,  969,  964,  774,  802,
- /*    10 */   802,  938,  969,  969,  969,  876,  969,  969,  969,  964,
- /*    20 */   969,  778,  808,  969,  969,  969,  969,  969,  969,  969,
- /*    30 */   969,  937,  939,  816,  815,  918,  789,  813,  806,  810,
- /*    40 */   879,  872,  873,  871,  875,  880,  969,  809,  841,  856,
- /*    50 */   840,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*    60 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*    70 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*    80 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*    90 */   969,  969,  969,  969,  850,  855,  862,  854,  851,  843,
- /*   100 */   842,  844,  845,  969,  969,  673,  739,  969,  969,  846,
- /*   110 */   969,  685,  847,  859,  858,  857,  680,  969,  969,  969,
- /*   120 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*   130 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*   140 */   969,  969,  969,  969,  647,  964,  969,  969,  964,  964,
- /*   150 */   964,  964,  964,  964,  956,  778,  768,  969,  969,  969,
- /*   160 */   969,  969,  969,  969,  969,  969,  969,  944,  942,  969,
- /*   170 */   891,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*   180 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*   190 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*   200 */   969,  969,  969,  969,  653,  969,  911,  774,  774,  774,
- /*   210 */   776,  754,  766,  655,  812,  791,  791,  923,  812,  923,
- /*   220 */   710,  733,  707,  802,  791,  874,  802,  802,  775,  766,
- /*   230 */   969,  949,  782,  782,  941,  941,  782,  821,  743,  812,
- /*   240 */   750,  750,  750,  750,  782,  670,  812,  821,  743,  743,
- /*   250 */   812,  782,  670,  917,  915,  782,  782,  670,  782,  670,
- /*   260 */   782,  670,  884,  741,  741,  741,  725,  884,  741,  710,
- /*   270 */   741,  725,  741,  741,  795,  790,  795,  790,  795,  790,
- /*   280 */   782,  782,  969,  884,  888,  888,  884,  807,  796,  805,
- /*   290 */   803,  812,  676,  728,  663,  663,  652,  652,  652,  652,
- /*   300 */   961,  961,  956,  712,  712,  695,  969,  969,  969,  969,
- /*   310 */   969,  969,  687,  969,  893,  969,  969,  969,  969,  969,
- /*   320 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*   330 */   969,  828,  969,  648,  951,  969,  969,  948,  969,  969,
- /*   340 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*   350 */   969,  969,  969,  969,  969,  969,  921,  969,  969,  969,
- /*   360 */   969,  969,  969,  914,  913,  969,  969,  969,  969,  969,
- /*   370 */   969,  969,  969,  969,  969,  969,  969,  969,  969,  969,
- /*   380 */   969,  969,  969,  969,  969,  969,  969,  757,  969,  969,
- /*   390 */   969,  761,  969,  969,  969,  969,  969,  969,  804,  969,
- /*   400 */   797,  969,  877,  969,  969,  969,  969,  969,  969,  969,
- /*   410 */   969,  969,  969,  966,  969,  969,  969,  965,  969,  969,
- /*   420 */   969,  969,  969,  830,  969,  829,  833,  969,  661,  969,
- /*   430 */   644,  649,  960,  963,  962,  959,  958,  957,  952,  950,
- /*   440 */   947,  946,  945,  943,  940,  936,  897,  895,  902,  901,
- /*   450 */   900,  899,  898,  896,  894,  892,  818,  817,  814,  811,
- /*   460 */   753,  935,  890,  752,  749,  748,  669,  953,  920,  929,
- /*   470 */   928,  927,  822,  926,  925,  924,  922,  919,  906,  820,
- /*   480 */   819,  744,  882,  881,  672,  910,  909,  908,  912,  916,
- /*   490 */   907,  784,  751,  671,  668,  675,  679,  731,  732,  740,
- /*   500 */   738,  737,  736,  735,  734,  730,  681,  686,  724,  709,
- /*   510 */   708,  717,  716,  722,  721,  720,  719,  718,  715,  714,
- /*   520 */   713,  706,  705,  711,  704,  727,  726,  723,  703,  747,
- /*   530 */   746,  745,  742,  702,  701,  700,  833,  699,  698,  838,
- /*   540 */   837,  866,  826,  755,  759,  758,  762,  763,  771,  770,
- /*   550 */   769,  780,  781,  793,  792,  824,  823,  794,  779,  773,
- /*   560 */   772,  788,  787,  786,  785,  777,  767,  799,  798,  868,
- /*   570 */   783,  867,  865,  934,  933,  932,  931,  930,  870,  967,
- /*   580 */   968,  887,  889,  886,  801,  800,  885,  869,  839,  836,
- /*   590 */   690,  691,  905,  904,  903,  693,  692,  689,  688,  863,
- /*   600 */   860,  852,  864,  861,  853,  849,  848,  834,  832,  831,
- /*   610 */   827,  835,  760,  756,  825,  765,  764,  697,  696,  694,
- /*   620 */   678,  677,  674,  667,  665,  664,  666,  662,  660,  659,
- /*   630 */   658,  657,  656,  684,  683,  682,  654,  651,  650,  646,
- /*   640 */   645,  643,
+ /*     0 */   982, 1300, 1300, 1300, 1214, 1214, 1214, 1305, 1300, 1109,
+ /*    10 */  1138, 1138, 1274, 1305, 1305, 1305, 1305, 1305, 1305, 1212,
+ /*    20 */  1305, 1305, 1305, 1300, 1305, 1113, 1144, 1305, 1305, 1305,
+ /*    30 */  1305, 1305, 1305, 1305, 1305, 1273, 1275, 1152, 1151, 1254,
+ /*    40 */  1125, 1149, 1142, 1146, 1215, 1208, 1209, 1207, 1211, 1216,
+ /*    50 */  1305, 1145, 1177, 1192, 1176, 1305, 1305, 1305, 1305, 1305,
+ /*    60 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*    70 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*    80 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*    90 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1186, 1191,
+ /*   100 */  1198, 1190, 1187, 1179, 1178, 1180, 1181, 1305, 1305, 1008,
+ /*   110 */  1074, 1305, 1305, 1182, 1305, 1020, 1183, 1195, 1194, 1193,
+ /*   120 */  1015, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   130 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   140 */  1305, 1305, 1305, 1305, 1305,  982, 1300, 1305, 1305, 1300,
+ /*   150 */  1300, 1300, 1300, 1300, 1300, 1292, 1113, 1103, 1305, 1305,
+ /*   160 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1280, 1278,
+ /*   170 */  1305, 1227, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   180 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   190 */  1305, 1305, 1305, 1109, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   200 */  1305, 1305, 1305, 1305, 1305, 1305,  988, 1305, 1247, 1109,
+ /*   210 */  1109, 1109, 1111, 1089, 1101,  990, 1148, 1127, 1127, 1259,
+ /*   220 */  1148, 1259, 1045, 1068, 1042, 1138, 1127, 1210, 1138, 1138,
+ /*   230 */  1110, 1101, 1305, 1285, 1118, 1118, 1277, 1277, 1118, 1157,
+ /*   240 */  1078, 1148, 1085, 1085, 1085, 1085, 1118, 1005, 1148, 1157,
+ /*   250 */  1078, 1078, 1148, 1118, 1005, 1253, 1251, 1118, 1118, 1005,
+ /*   260 */  1220, 1118, 1005, 1118, 1005, 1220, 1076, 1076, 1076, 1060,
+ /*   270 */  1220, 1076, 1045, 1076, 1060, 1076, 1076, 1131, 1126, 1131,
+ /*   280 */  1126, 1131, 1126, 1131, 1126, 1118, 1118, 1305, 1220, 1224,
+ /*   290 */  1224, 1220, 1143, 1132, 1141, 1139, 1148, 1011, 1063,  998,
+ /*   300 */   998,  987,  987,  987,  987, 1297, 1297, 1292, 1047, 1047,
+ /*   310 */  1030, 1305, 1305, 1305, 1305, 1305, 1305, 1022, 1305, 1229,
+ /*   320 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   330 */  1305, 1305, 1305, 1305, 1305, 1305, 1164, 1305,  983, 1287,
+ /*   340 */  1305, 1305, 1284, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   350 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   360 */  1305, 1257, 1305, 1305, 1305, 1305, 1305, 1305, 1250, 1249,
+ /*   370 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   380 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305,
+ /*   390 */  1305, 1305, 1092, 1305, 1305, 1305, 1096, 1305, 1305, 1305,
+ /*   400 */  1305, 1305, 1305, 1305, 1140, 1305, 1133, 1305, 1213, 1305,
+ /*   410 */  1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1305, 1302,
+ /*   420 */  1305, 1305, 1305, 1301, 1305, 1305, 1305, 1305, 1305, 1166,
+ /*   430 */  1305, 1165, 1169, 1305,  996, 1305,
 };
 
 /* The next table maps tokens into fallback tokens.  If a construct
@@ -125524,9 +126867,13 @@ static const YYCODETYPE yyFallback[] = {
 **   +  The semantic value stored at this level of the stack.  This is
 **      the information used by the action routines in the grammar.
 **      It is sometimes called the "minor" token.
+**
+** After the "shift" half of a SHIFTREDUCE action, the stateno field
+** actually contains the reduce action for the second half of the
+** SHIFTREDUCE.
 */
 struct yyStackEntry {
-  YYACTIONTYPE stateno;  /* The state-number */
+  YYACTIONTYPE stateno;  /* The state-number, or reduce action in SHIFTREDUCE */
   YYCODETYPE major;      /* The major token value.  This is the code
                          ** number for the token at this stack level */
   YYMINORTYPE minor;     /* The user-supplied minor token value.  This
@@ -125632,18 +126979,18 @@ static const char *const yyTokenName[] = {
   "column",        "columnid",      "type",          "carglist",    
   "typetoken",     "typename",      "signed",        "plus_num",    
   "minus_num",     "ccons",         "term",          "expr",        
-  "onconf",        "sortorder",     "autoinc",       "idxlist_opt", 
+  "onconf",        "sortorder",     "autoinc",       "eidlist_opt", 
   "refargs",       "defer_subclause",  "refarg",        "refact",      
   "init_deferred_pred_opt",  "conslist",      "tconscomma",    "tcons",       
-  "idxlist",       "defer_subclause_opt",  "orconf",        "resolvetype", 
-  "raisetype",     "ifexists",      "fullname",      "selectnowith",
-  "oneselect",     "with",          "multiselect_op",  "distinct",    
-  "selcollist",    "from",          "where_opt",     "groupby_opt", 
-  "having_opt",    "orderby_opt",   "limit_opt",     "values",      
-  "nexprlist",     "exprlist",      "sclp",          "as",          
-  "seltablist",    "stl_prefix",    "joinop",        "indexed_opt", 
-  "on_opt",        "using_opt",     "joinop2",       "idlist",      
-  "sortlist",      "setlist",       "insert_cmd",    "inscollist_opt",
+  "sortlist",      "eidlist",       "defer_subclause_opt",  "orconf",      
+  "resolvetype",   "raisetype",     "ifexists",      "fullname",    
+  "selectnowith",  "oneselect",     "with",          "multiselect_op",
+  "distinct",      "selcollist",    "from",          "where_opt",   
+  "groupby_opt",   "having_opt",    "orderby_opt",   "limit_opt",   
+  "values",        "nexprlist",     "exprlist",      "sclp",        
+  "as",            "seltablist",    "stl_prefix",    "joinop",      
+  "indexed_opt",   "on_opt",        "using_opt",     "joinop2",     
+  "idlist",        "setlist",       "insert_cmd",    "idlist_opt",  
   "likeop",        "between_op",    "in_op",         "case_operand",
   "case_exprlist",  "case_else",     "uniqueflag",    "collate",     
   "nmnum",         "trigger_decl",  "trigger_cmd_list",  "trigger_time",
@@ -125724,7 +127071,7 @@ static const char *const yyRuleName[] = {
  /*  62 */ "ccons ::= PRIMARY KEY sortorder onconf autoinc",
  /*  63 */ "ccons ::= UNIQUE onconf",
  /*  64 */ "ccons ::= CHECK LP expr RP",
- /*  65 */ "ccons ::= REFERENCES nm idxlist_opt refargs",
+ /*  65 */ "ccons ::= REFERENCES nm eidlist_opt refargs",
  /*  66 */ "ccons ::= defer_subclause",
  /*  67 */ "ccons ::= COLLATE ID|STRING",
  /*  68 */ "autoinc ::=",
@@ -125752,10 +127099,10 @@ static const char *const yyRuleName[] = {
  /*  90 */ "tconscomma ::= COMMA",
  /*  91 */ "tconscomma ::=",
  /*  92 */ "tcons ::= CONSTRAINT nm",
- /*  93 */ "tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf",
- /*  94 */ "tcons ::= UNIQUE LP idxlist RP onconf",
+ /*  93 */ "tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf",
+ /*  94 */ "tcons ::= UNIQUE LP sortlist RP onconf",
  /*  95 */ "tcons ::= CHECK LP expr RP onconf",
- /*  96 */ "tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt",
+ /*  96 */ "tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt",
  /*  97 */ "defer_subclause_opt ::=",
  /*  98 */ "defer_subclause_opt ::= defer_subclause",
  /*  99 */ "onconf ::=",
@@ -125768,7 +127115,7 @@ static const char *const yyRuleName[] = {
  /* 106 */ "cmd ::= DROP TABLE ifexists fullname",
  /* 107 */ "ifexists ::= IF EXISTS",
  /* 108 */ "ifexists ::=",
- /* 109 */ "cmd ::= createkw temp VIEW ifnotexists nm dbnm AS select",
+ /* 109 */ "cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select",
  /* 110 */ "cmd ::= DROP VIEW ifexists fullname",
  /* 111 */ "cmd ::= select",
  /* 112 */ "select ::= with selectnowith",
@@ -125797,195 +127144,196 @@ static const char *const yyRuleName[] = {
  /* 135 */ "stl_prefix ::= seltablist joinop",
  /* 136 */ "stl_prefix ::=",
  /* 137 */ "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt",
- /* 138 */ "seltablist ::= stl_prefix LP select RP as on_opt using_opt",
- /* 139 */ "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",
- /* 140 */ "dbnm ::=",
- /* 141 */ "dbnm ::= DOT nm",
- /* 142 */ "fullname ::= nm dbnm",
- /* 143 */ "joinop ::= COMMA|JOIN",
- /* 144 */ "joinop ::= JOIN_KW JOIN",
- /* 145 */ "joinop ::= JOIN_KW nm JOIN",
- /* 146 */ "joinop ::= JOIN_KW nm nm JOIN",
- /* 147 */ "on_opt ::= ON expr",
- /* 148 */ "on_opt ::=",
- /* 149 */ "indexed_opt ::=",
- /* 150 */ "indexed_opt ::= INDEXED BY nm",
- /* 151 */ "indexed_opt ::= NOT INDEXED",
- /* 152 */ "using_opt ::= USING LP idlist RP",
- /* 153 */ "using_opt ::=",
- /* 154 */ "orderby_opt ::=",
- /* 155 */ "orderby_opt ::= ORDER BY sortlist",
- /* 156 */ "sortlist ::= sortlist COMMA expr sortorder",
- /* 157 */ "sortlist ::= expr sortorder",
- /* 158 */ "sortorder ::= ASC",
- /* 159 */ "sortorder ::= DESC",
- /* 160 */ "sortorder ::=",
- /* 161 */ "groupby_opt ::=",
- /* 162 */ "groupby_opt ::= GROUP BY nexprlist",
- /* 163 */ "having_opt ::=",
- /* 164 */ "having_opt ::= HAVING expr",
- /* 165 */ "limit_opt ::=",
- /* 166 */ "limit_opt ::= LIMIT expr",
- /* 167 */ "limit_opt ::= LIMIT expr OFFSET expr",
- /* 168 */ "limit_opt ::= LIMIT expr COMMA expr",
- /* 169 */ "cmd ::= with DELETE FROM fullname indexed_opt where_opt",
- /* 170 */ "where_opt ::=",
- /* 171 */ "where_opt ::= WHERE expr",
- /* 172 */ "cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt",
- /* 173 */ "setlist ::= setlist COMMA nm EQ expr",
- /* 174 */ "setlist ::= nm EQ expr",
- /* 175 */ "cmd ::= with insert_cmd INTO fullname inscollist_opt select",
- /* 176 */ "cmd ::= with insert_cmd INTO fullname inscollist_opt DEFAULT VALUES",
- /* 177 */ "insert_cmd ::= INSERT orconf",
- /* 178 */ "insert_cmd ::= REPLACE",
- /* 179 */ "inscollist_opt ::=",
- /* 180 */ "inscollist_opt ::= LP idlist RP",
- /* 181 */ "idlist ::= idlist COMMA nm",
- /* 182 */ "idlist ::= nm",
- /* 183 */ "expr ::= term",
- /* 184 */ "expr ::= LP expr RP",
- /* 185 */ "term ::= NULL",
- /* 186 */ "expr ::= ID|INDEXED",
- /* 187 */ "expr ::= JOIN_KW",
- /* 188 */ "expr ::= nm DOT nm",
- /* 189 */ "expr ::= nm DOT nm DOT nm",
- /* 190 */ "term ::= INTEGER|FLOAT|BLOB",
- /* 191 */ "term ::= STRING",
- /* 192 */ "expr ::= VARIABLE",
- /* 193 */ "expr ::= expr COLLATE ID|STRING",
- /* 194 */ "expr ::= CAST LP expr AS typetoken RP",
- /* 195 */ "expr ::= ID|INDEXED LP distinct exprlist RP",
- /* 196 */ "expr ::= ID|INDEXED LP STAR RP",
- /* 197 */ "term ::= CTIME_KW",
- /* 198 */ "expr ::= expr AND expr",
- /* 199 */ "expr ::= expr OR expr",
- /* 200 */ "expr ::= expr LT|GT|GE|LE expr",
- /* 201 */ "expr ::= expr EQ|NE expr",
- /* 202 */ "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",
- /* 203 */ "expr ::= expr PLUS|MINUS expr",
- /* 204 */ "expr ::= expr STAR|SLASH|REM expr",
- /* 205 */ "expr ::= expr CONCAT expr",
- /* 206 */ "likeop ::= LIKE_KW|MATCH",
- /* 207 */ "likeop ::= NOT LIKE_KW|MATCH",
- /* 208 */ "expr ::= expr likeop expr",
- /* 209 */ "expr ::= expr likeop expr ESCAPE expr",
- /* 210 */ "expr ::= expr ISNULL|NOTNULL",
- /* 211 */ "expr ::= expr NOT NULL",
- /* 212 */ "expr ::= expr IS expr",
- /* 213 */ "expr ::= expr IS NOT expr",
- /* 214 */ "expr ::= NOT expr",
- /* 215 */ "expr ::= BITNOT expr",
- /* 216 */ "expr ::= MINUS expr",
- /* 217 */ "expr ::= PLUS expr",
- /* 218 */ "between_op ::= BETWEEN",
- /* 219 */ "between_op ::= NOT BETWEEN",
- /* 220 */ "expr ::= expr between_op expr AND expr",
- /* 221 */ "in_op ::= IN",
- /* 222 */ "in_op ::= NOT IN",
- /* 223 */ "expr ::= expr in_op LP exprlist RP",
- /* 224 */ "expr ::= LP select RP",
- /* 225 */ "expr ::= expr in_op LP select RP",
- /* 226 */ "expr ::= expr in_op nm dbnm",
- /* 227 */ "expr ::= EXISTS LP select RP",
- /* 228 */ "expr ::= CASE case_operand case_exprlist case_else END",
- /* 229 */ "case_exprlist ::= case_exprlist WHEN expr THEN expr",
- /* 230 */ "case_exprlist ::= WHEN expr THEN expr",
- /* 231 */ "case_else ::= ELSE expr",
- /* 232 */ "case_else ::=",
- /* 233 */ "case_operand ::= expr",
- /* 234 */ "case_operand ::=",
- /* 235 */ "exprlist ::= nexprlist",
- /* 236 */ "exprlist ::=",
- /* 237 */ "nexprlist ::= nexprlist COMMA expr",
- /* 238 */ "nexprlist ::= expr",
- /* 239 */ "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP idxlist RP where_opt",
- /* 240 */ "uniqueflag ::= UNIQUE",
- /* 241 */ "uniqueflag ::=",
- /* 242 */ "idxlist_opt ::=",
- /* 243 */ "idxlist_opt ::= LP idxlist RP",
- /* 244 */ "idxlist ::= idxlist COMMA nm collate sortorder",
- /* 245 */ "idxlist ::= nm collate sortorder",
- /* 246 */ "collate ::=",
- /* 247 */ "collate ::= COLLATE ID|STRING",
- /* 248 */ "cmd ::= DROP INDEX ifexists fullname",
- /* 249 */ "cmd ::= VACUUM",
- /* 250 */ "cmd ::= VACUUM nm",
- /* 251 */ "cmd ::= PRAGMA nm dbnm",
- /* 252 */ "cmd ::= PRAGMA nm dbnm EQ nmnum",
- /* 253 */ "cmd ::= PRAGMA nm dbnm LP nmnum RP",
- /* 254 */ "cmd ::= PRAGMA nm dbnm EQ minus_num",
- /* 255 */ "cmd ::= PRAGMA nm dbnm LP minus_num RP",
- /* 256 */ "nmnum ::= plus_num",
- /* 257 */ "nmnum ::= nm",
- /* 258 */ "nmnum ::= ON",
- /* 259 */ "nmnum ::= DELETE",
- /* 260 */ "nmnum ::= DEFAULT",
- /* 261 */ "plus_num ::= PLUS INTEGER|FLOAT",
- /* 262 */ "plus_num ::= INTEGER|FLOAT",
- /* 263 */ "minus_num ::= MINUS INTEGER|FLOAT",
- /* 264 */ "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END",
- /* 265 */ "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause",
- /* 266 */ "trigger_time ::= BEFORE",
- /* 267 */ "trigger_time ::= AFTER",
- /* 268 */ "trigger_time ::= INSTEAD OF",
- /* 269 */ "trigger_time ::=",
- /* 270 */ "trigger_event ::= DELETE|INSERT",
- /* 271 */ "trigger_event ::= UPDATE",
- /* 272 */ "trigger_event ::= UPDATE OF idlist",
- /* 273 */ "foreach_clause ::=",
- /* 274 */ "foreach_clause ::= FOR EACH ROW",
- /* 275 */ "when_clause ::=",
- /* 276 */ "when_clause ::= WHEN expr",
- /* 277 */ "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI",
- /* 278 */ "trigger_cmd_list ::= trigger_cmd SEMI",
- /* 279 */ "trnm ::= nm",
- /* 280 */ "trnm ::= nm DOT nm",
- /* 281 */ "tridxby ::=",
- /* 282 */ "tridxby ::= INDEXED BY nm",
- /* 283 */ "tridxby ::= NOT INDEXED",
- /* 284 */ "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt",
- /* 285 */ "trigger_cmd ::= insert_cmd INTO trnm inscollist_opt select",
- /* 286 */ "trigger_cmd ::= DELETE FROM trnm tridxby where_opt",
- /* 287 */ "trigger_cmd ::= select",
- /* 288 */ "expr ::= RAISE LP IGNORE RP",
- /* 289 */ "expr ::= RAISE LP raisetype COMMA nm RP",
- /* 290 */ "raisetype ::= ROLLBACK",
- /* 291 */ "raisetype ::= ABORT",
- /* 292 */ "raisetype ::= FAIL",
- /* 293 */ "cmd ::= DROP TRIGGER ifexists fullname",
- /* 294 */ "cmd ::= ATTACH database_kw_opt expr AS expr key_opt",
- /* 295 */ "cmd ::= DETACH database_kw_opt expr",
- /* 296 */ "key_opt ::=",
- /* 297 */ "key_opt ::= KEY expr",
- /* 298 */ "database_kw_opt ::= DATABASE",
- /* 299 */ "database_kw_opt ::=",
- /* 300 */ "cmd ::= REINDEX",
- /* 301 */ "cmd ::= REINDEX nm dbnm",
- /* 302 */ "cmd ::= ANALYZE",
- /* 303 */ "cmd ::= ANALYZE nm dbnm",
- /* 304 */ "cmd ::= ALTER TABLE fullname RENAME TO nm",
- /* 305 */ "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column",
- /* 306 */ "add_column_fullname ::= fullname",
- /* 307 */ "kwcolumn_opt ::=",
- /* 308 */ "kwcolumn_opt ::= COLUMNKW",
- /* 309 */ "cmd ::= create_vtab",
- /* 310 */ "cmd ::= create_vtab LP vtabarglist RP",
- /* 311 */ "create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm",
- /* 312 */ "vtabarglist ::= vtabarg",
- /* 313 */ "vtabarglist ::= vtabarglist COMMA vtabarg",
- /* 314 */ "vtabarg ::=",
- /* 315 */ "vtabarg ::= vtabarg vtabargtoken",
- /* 316 */ "vtabargtoken ::= ANY",
- /* 317 */ "vtabargtoken ::= lp anylist RP",
- /* 318 */ "lp ::= LP",
- /* 319 */ "anylist ::=",
- /* 320 */ "anylist ::= anylist LP anylist RP",
- /* 321 */ "anylist ::= anylist ANY",
- /* 322 */ "with ::=",
- /* 323 */ "with ::= WITH wqlist",
- /* 324 */ "with ::= WITH RECURSIVE wqlist",
- /* 325 */ "wqlist ::= nm idxlist_opt AS LP select RP",
- /* 326 */ "wqlist ::= wqlist COMMA nm idxlist_opt AS LP select RP",
+ /* 138 */ "seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt",
+ /* 139 */ "seltablist ::= stl_prefix LP select RP as on_opt using_opt",
+ /* 140 */ "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",
+ /* 141 */ "dbnm ::=",
+ /* 142 */ "dbnm ::= DOT nm",
+ /* 143 */ "fullname ::= nm dbnm",
+ /* 144 */ "joinop ::= COMMA|JOIN",
+ /* 145 */ "joinop ::= JOIN_KW JOIN",
+ /* 146 */ "joinop ::= JOIN_KW nm JOIN",
+ /* 147 */ "joinop ::= JOIN_KW nm nm JOIN",
+ /* 148 */ "on_opt ::= ON expr",
+ /* 149 */ "on_opt ::=",
+ /* 150 */ "indexed_opt ::=",
+ /* 151 */ "indexed_opt ::= INDEXED BY nm",
+ /* 152 */ "indexed_opt ::= NOT INDEXED",
+ /* 153 */ "using_opt ::= USING LP idlist RP",
+ /* 154 */ "using_opt ::=",
+ /* 155 */ "orderby_opt ::=",
+ /* 156 */ "orderby_opt ::= ORDER BY sortlist",
+ /* 157 */ "sortlist ::= sortlist COMMA expr sortorder",
+ /* 158 */ "sortlist ::= expr sortorder",
+ /* 159 */ "sortorder ::= ASC",
+ /* 160 */ "sortorder ::= DESC",
+ /* 161 */ "sortorder ::=",
+ /* 162 */ "groupby_opt ::=",
+ /* 163 */ "groupby_opt ::= GROUP BY nexprlist",
+ /* 164 */ "having_opt ::=",
+ /* 165 */ "having_opt ::= HAVING expr",
+ /* 166 */ "limit_opt ::=",
+ /* 167 */ "limit_opt ::= LIMIT expr",
+ /* 168 */ "limit_opt ::= LIMIT expr OFFSET expr",
+ /* 169 */ "limit_opt ::= LIMIT expr COMMA expr",
+ /* 170 */ "cmd ::= with DELETE FROM fullname indexed_opt where_opt",
+ /* 171 */ "where_opt ::=",
+ /* 172 */ "where_opt ::= WHERE expr",
+ /* 173 */ "cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt",
+ /* 174 */ "setlist ::= setlist COMMA nm EQ expr",
+ /* 175 */ "setlist ::= nm EQ expr",
+ /* 176 */ "cmd ::= with insert_cmd INTO fullname idlist_opt select",
+ /* 177 */ "cmd ::= with insert_cmd INTO fullname idlist_opt DEFAULT VALUES",
+ /* 178 */ "insert_cmd ::= INSERT orconf",
+ /* 179 */ "insert_cmd ::= REPLACE",
+ /* 180 */ "idlist_opt ::=",
+ /* 181 */ "idlist_opt ::= LP idlist RP",
+ /* 182 */ "idlist ::= idlist COMMA nm",
+ /* 183 */ "idlist ::= nm",
+ /* 184 */ "expr ::= term",
+ /* 185 */ "expr ::= LP expr RP",
+ /* 186 */ "term ::= NULL",
+ /* 187 */ "expr ::= ID|INDEXED",
+ /* 188 */ "expr ::= JOIN_KW",
+ /* 189 */ "expr ::= nm DOT nm",
+ /* 190 */ "expr ::= nm DOT nm DOT nm",
+ /* 191 */ "term ::= INTEGER|FLOAT|BLOB",
+ /* 192 */ "term ::= STRING",
+ /* 193 */ "expr ::= VARIABLE",
+ /* 194 */ "expr ::= expr COLLATE ID|STRING",
+ /* 195 */ "expr ::= CAST LP expr AS typetoken RP",
+ /* 196 */ "expr ::= ID|INDEXED LP distinct exprlist RP",
+ /* 197 */ "expr ::= ID|INDEXED LP STAR RP",
+ /* 198 */ "term ::= CTIME_KW",
+ /* 199 */ "expr ::= expr AND expr",
+ /* 200 */ "expr ::= expr OR expr",
+ /* 201 */ "expr ::= expr LT|GT|GE|LE expr",
+ /* 202 */ "expr ::= expr EQ|NE expr",
+ /* 203 */ "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",
+ /* 204 */ "expr ::= expr PLUS|MINUS expr",
+ /* 205 */ "expr ::= expr STAR|SLASH|REM expr",
+ /* 206 */ "expr ::= expr CONCAT expr",
+ /* 207 */ "likeop ::= LIKE_KW|MATCH",
+ /* 208 */ "likeop ::= NOT LIKE_KW|MATCH",
+ /* 209 */ "expr ::= expr likeop expr",
+ /* 210 */ "expr ::= expr likeop expr ESCAPE expr",
+ /* 211 */ "expr ::= expr ISNULL|NOTNULL",
+ /* 212 */ "expr ::= expr NOT NULL",
+ /* 213 */ "expr ::= expr IS expr",
+ /* 214 */ "expr ::= expr IS NOT expr",
+ /* 215 */ "expr ::= NOT expr",
+ /* 216 */ "expr ::= BITNOT expr",
+ /* 217 */ "expr ::= MINUS expr",
+ /* 218 */ "expr ::= PLUS expr",
+ /* 219 */ "between_op ::= BETWEEN",
+ /* 220 */ "between_op ::= NOT BETWEEN",
+ /* 221 */ "expr ::= expr between_op expr AND expr",
+ /* 222 */ "in_op ::= IN",
+ /* 223 */ "in_op ::= NOT IN",
+ /* 224 */ "expr ::= expr in_op LP exprlist RP",
+ /* 225 */ "expr ::= LP select RP",
+ /* 226 */ "expr ::= expr in_op LP select RP",
+ /* 227 */ "expr ::= expr in_op nm dbnm",
+ /* 228 */ "expr ::= EXISTS LP select RP",
+ /* 229 */ "expr ::= CASE case_operand case_exprlist case_else END",
+ /* 230 */ "case_exprlist ::= case_exprlist WHEN expr THEN expr",
+ /* 231 */ "case_exprlist ::= WHEN expr THEN expr",
+ /* 232 */ "case_else ::= ELSE expr",
+ /* 233 */ "case_else ::=",
+ /* 234 */ "case_operand ::= expr",
+ /* 235 */ "case_operand ::=",
+ /* 236 */ "exprlist ::= nexprlist",
+ /* 237 */ "exprlist ::=",
+ /* 238 */ "nexprlist ::= nexprlist COMMA expr",
+ /* 239 */ "nexprlist ::= expr",
+ /* 240 */ "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt",
+ /* 241 */ "uniqueflag ::= UNIQUE",
+ /* 242 */ "uniqueflag ::=",
+ /* 243 */ "eidlist_opt ::=",
+ /* 244 */ "eidlist_opt ::= LP eidlist RP",
+ /* 245 */ "eidlist ::= eidlist COMMA nm collate sortorder",
+ /* 246 */ "eidlist ::= nm collate sortorder",
+ /* 247 */ "collate ::=",
+ /* 248 */ "collate ::= COLLATE ID|STRING",
+ /* 249 */ "cmd ::= DROP INDEX ifexists fullname",
+ /* 250 */ "cmd ::= VACUUM",
+ /* 251 */ "cmd ::= VACUUM nm",
+ /* 252 */ "cmd ::= PRAGMA nm dbnm",
+ /* 253 */ "cmd ::= PRAGMA nm dbnm EQ nmnum",
+ /* 254 */ "cmd ::= PRAGMA nm dbnm LP nmnum RP",
+ /* 255 */ "cmd ::= PRAGMA nm dbnm EQ minus_num",
+ /* 256 */ "cmd ::= PRAGMA nm dbnm LP minus_num RP",
+ /* 257 */ "nmnum ::= plus_num",
+ /* 258 */ "nmnum ::= nm",
+ /* 259 */ "nmnum ::= ON",
+ /* 260 */ "nmnum ::= DELETE",
+ /* 261 */ "nmnum ::= DEFAULT",
+ /* 262 */ "plus_num ::= PLUS INTEGER|FLOAT",
+ /* 263 */ "plus_num ::= INTEGER|FLOAT",
+ /* 264 */ "minus_num ::= MINUS INTEGER|FLOAT",
+ /* 265 */ "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END",
+ /* 266 */ "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause",
+ /* 267 */ "trigger_time ::= BEFORE",
+ /* 268 */ "trigger_time ::= AFTER",
+ /* 269 */ "trigger_time ::= INSTEAD OF",
+ /* 270 */ "trigger_time ::=",
+ /* 271 */ "trigger_event ::= DELETE|INSERT",
+ /* 272 */ "trigger_event ::= UPDATE",
+ /* 273 */ "trigger_event ::= UPDATE OF idlist",
+ /* 274 */ "foreach_clause ::=",
+ /* 275 */ "foreach_clause ::= FOR EACH ROW",
+ /* 276 */ "when_clause ::=",
+ /* 277 */ "when_clause ::= WHEN expr",
+ /* 278 */ "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI",
+ /* 279 */ "trigger_cmd_list ::= trigger_cmd SEMI",
+ /* 280 */ "trnm ::= nm",
+ /* 281 */ "trnm ::= nm DOT nm",
+ /* 282 */ "tridxby ::=",
+ /* 283 */ "tridxby ::= INDEXED BY nm",
+ /* 284 */ "tridxby ::= NOT INDEXED",
+ /* 285 */ "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt",
+ /* 286 */ "trigger_cmd ::= insert_cmd INTO trnm idlist_opt select",
+ /* 287 */ "trigger_cmd ::= DELETE FROM trnm tridxby where_opt",
+ /* 288 */ "trigger_cmd ::= select",
+ /* 289 */ "expr ::= RAISE LP IGNORE RP",
+ /* 290 */ "expr ::= RAISE LP raisetype COMMA nm RP",
+ /* 291 */ "raisetype ::= ROLLBACK",
+ /* 292 */ "raisetype ::= ABORT",
+ /* 293 */ "raisetype ::= FAIL",
+ /* 294 */ "cmd ::= DROP TRIGGER ifexists fullname",
+ /* 295 */ "cmd ::= ATTACH database_kw_opt expr AS expr key_opt",
+ /* 296 */ "cmd ::= DETACH database_kw_opt expr",
+ /* 297 */ "key_opt ::=",
+ /* 298 */ "key_opt ::= KEY expr",
+ /* 299 */ "database_kw_opt ::= DATABASE",
+ /* 300 */ "database_kw_opt ::=",
+ /* 301 */ "cmd ::= REINDEX",
+ /* 302 */ "cmd ::= REINDEX nm dbnm",
+ /* 303 */ "cmd ::= ANALYZE",
+ /* 304 */ "cmd ::= ANALYZE nm dbnm",
+ /* 305 */ "cmd ::= ALTER TABLE fullname RENAME TO nm",
+ /* 306 */ "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column",
+ /* 307 */ "add_column_fullname ::= fullname",
+ /* 308 */ "kwcolumn_opt ::=",
+ /* 309 */ "kwcolumn_opt ::= COLUMNKW",
+ /* 310 */ "cmd ::= create_vtab",
+ /* 311 */ "cmd ::= create_vtab LP vtabarglist RP",
+ /* 312 */ "create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm",
+ /* 313 */ "vtabarglist ::= vtabarg",
+ /* 314 */ "vtabarglist ::= vtabarglist COMMA vtabarg",
+ /* 315 */ "vtabarg ::=",
+ /* 316 */ "vtabarg ::= vtabarg vtabargtoken",
+ /* 317 */ "vtabargtoken ::= ANY",
+ /* 318 */ "vtabargtoken ::= lp anylist RP",
+ /* 319 */ "lp ::= LP",
+ /* 320 */ "anylist ::=",
+ /* 321 */ "anylist ::= anylist LP anylist RP",
+ /* 322 */ "anylist ::= anylist ANY",
+ /* 323 */ "with ::=",
+ /* 324 */ "with ::= WITH wqlist",
+ /* 325 */ "with ::= WITH RECURSIVE wqlist",
+ /* 326 */ "wqlist ::= nm eidlist_opt AS LP select RP",
+ /* 327 */ "wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP",
 };
 #endif /* NDEBUG */
 
@@ -126065,9 +127413,9 @@ static void yy_destructor(
     ** inside the C code.
     */
     case 163: /* select */
-    case 195: /* selectnowith */
-    case 196: /* oneselect */
-    case 207: /* values */
+    case 196: /* selectnowith */
+    case 197: /* oneselect */
+    case 208: /* values */
 {
 sqlite3SelectDelete(pParse->db, (yypminor->yy3));
 }
@@ -126078,38 +127426,38 @@ sqlite3SelectDelete(pParse->db, (yypminor->yy3));
 sqlite3ExprDelete(pParse->db, (yypminor->yy346).pExpr);
 }
       break;
-    case 179: /* idxlist_opt */
-    case 188: /* idxlist */
-    case 200: /* selcollist */
-    case 203: /* groupby_opt */
-    case 205: /* orderby_opt */
-    case 208: /* nexprlist */
-    case 209: /* exprlist */
-    case 210: /* sclp */
-    case 220: /* sortlist */
+    case 179: /* eidlist_opt */
+    case 188: /* sortlist */
+    case 189: /* eidlist */
+    case 201: /* selcollist */
+    case 204: /* groupby_opt */
+    case 206: /* orderby_opt */
+    case 209: /* nexprlist */
+    case 210: /* exprlist */
+    case 211: /* sclp */
     case 221: /* setlist */
     case 228: /* case_exprlist */
 {
 sqlite3ExprListDelete(pParse->db, (yypminor->yy14));
 }
       break;
-    case 194: /* fullname */
-    case 201: /* from */
-    case 212: /* seltablist */
-    case 213: /* stl_prefix */
+    case 195: /* fullname */
+    case 202: /* from */
+    case 213: /* seltablist */
+    case 214: /* stl_prefix */
 {
 sqlite3SrcListDelete(pParse->db, (yypminor->yy65));
 }
       break;
-    case 197: /* with */
+    case 198: /* with */
     case 252: /* wqlist */
 {
 sqlite3WithDelete(pParse->db, (yypminor->yy59));
 }
       break;
-    case 202: /* where_opt */
-    case 204: /* having_opt */
-    case 216: /* on_opt */
+    case 203: /* where_opt */
+    case 205: /* having_opt */
+    case 217: /* on_opt */
     case 227: /* case_operand */
     case 229: /* case_else */
     case 238: /* when_clause */
@@ -126118,9 +127466,9 @@ sqlite3WithDelete(pParse->db, (yypminor->yy59));
 sqlite3ExprDelete(pParse->db, (yypminor->yy132));
 }
       break;
-    case 217: /* using_opt */
-    case 219: /* idlist */
-    case 223: /* inscollist_opt */
+    case 218: /* using_opt */
+    case 220: /* idlist */
+    case 223: /* idlist_opt */
 {
 sqlite3IdListDelete(pParse->db, (yypminor->yy408));
 }
@@ -126220,10 +127568,10 @@ static int yy_find_shift_action(
   int i;
   int stateno = pParser->yystack[pParser->yyidx].stateno;
  
-  if( stateno>YY_SHIFT_COUNT
-   || (i = yy_shift_ofst[stateno])==YY_SHIFT_USE_DFLT ){
-    return yy_default[stateno];
-  }
+  if( stateno>=YY_MIN_REDUCE ) return stateno;
+  assert( stateno <= YY_SHIFT_COUNT );
+  i = yy_shift_ofst[stateno];
+  if( i==YY_SHIFT_USE_DFLT ) return yy_default[stateno];
   assert( iLookAhead!=YYNOCODE );
   i += iLookAhead;
   if( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){
@@ -126326,7 +127674,29 @@ static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){
 }
 
 /*
-** Perform a shift action.
+** Print tracing information for a SHIFT action
+*/
+#ifndef NDEBUG
+static void yyTraceShift(yyParser *yypParser, int yyNewState){
+  if( yyTraceFILE ){
+    int i;
+    if( yyNewState<YYNSTATE ){
+      fprintf(yyTraceFILE,"%sShift %d\n",yyTracePrompt,yyNewState);
+      fprintf(yyTraceFILE,"%sStack:",yyTracePrompt);
+      for(i=1; i<=yypParser->yyidx; i++)
+        fprintf(yyTraceFILE," %s",yyTokenName[yypParser->yystack[i].major]);
+      fprintf(yyTraceFILE,"\n");
+    }else{
+      fprintf(yyTraceFILE,"%sShift *\n",yyTracePrompt);
+    }
+  }
+}
+#else
+# define yyTraceShift(X,Y)
+#endif
+
+/*
+** Perform a shift action.  Return the number of errors.
 */
 static void yy_shift(
   yyParser *yypParser,          /* The parser to be shifted */
@@ -126359,16 +127729,7 @@ static void yy_shift(
   yytos->stateno = (YYACTIONTYPE)yyNewState;
   yytos->major = (YYCODETYPE)yyMajor;
   yytos->minor = *yypMinor;
-#ifndef NDEBUG
-  if( yyTraceFILE && yypParser->yyidx>0 ){
-    int i;
-    fprintf(yyTraceFILE,"%sShift %d\n",yyTracePrompt,yyNewState);
-    fprintf(yyTraceFILE,"%sStack:",yyTracePrompt);
-    for(i=1; i<=yypParser->yyidx; i++)
-      fprintf(yyTraceFILE," %s",yyTokenName[yypParser->yystack[i].major]);
-    fprintf(yyTraceFILE,"\n");
-  }
-#endif
+  yyTraceShift(yypParser, yyNewState);
 }
 
 /* The following table contains information about every rule that
@@ -126475,81 +127836,82 @@ static const struct {
   { 187, 5 },
   { 187, 5 },
   { 187, 10 },
-  { 189, 0 },
-  { 189, 1 },
+  { 190, 0 },
+  { 190, 1 },
   { 176, 0 },
   { 176, 3 },
-  { 190, 0 },
-  { 190, 2 },
-  { 191, 1 },
-  { 191, 1 },
-  { 191, 1 },
+  { 191, 0 },
+  { 191, 2 },
+  { 192, 1 },
+  { 192, 1 },
+  { 192, 1 },
   { 149, 4 },
-  { 193, 2 },
-  { 193, 0 },
-  { 149, 8 },
+  { 194, 2 },
+  { 194, 0 },
+  { 149, 9 },
   { 149, 4 },
   { 149, 1 },
   { 163, 2 },
-  { 195, 1 },
-  { 195, 3 },
-  { 198, 1 },
-  { 198, 2 },
-  { 198, 1 },
-  { 196, 9 },
   { 196, 1 },
-  { 207, 4 },
-  { 207, 5 },
+  { 196, 3 },
   { 199, 1 },
+  { 199, 2 },
   { 199, 1 },
-  { 199, 0 },
-  { 210, 2 },
-  { 210, 0 },
-  { 200, 3 },
-  { 200, 2 },
-  { 200, 4 },
+  { 197, 9 },
+  { 197, 1 },
+  { 208, 4 },
+  { 208, 5 },
+  { 200, 1 },
+  { 200, 1 },
+  { 200, 0 },
   { 211, 2 },
-  { 211, 1 },
   { 211, 0 },
-  { 201, 0 },
+  { 201, 3 },
   { 201, 2 },
-  { 213, 2 },
-  { 213, 0 },
-  { 212, 7 },
-  { 212, 7 },
-  { 212, 7 },
+  { 201, 4 },
+  { 212, 2 },
+  { 212, 1 },
+  { 212, 0 },
+  { 202, 0 },
+  { 202, 2 },
+  { 214, 2 },
+  { 214, 0 },
+  { 213, 7 },
+  { 213, 9 },
+  { 213, 7 },
+  { 213, 7 },
   { 159, 0 },
   { 159, 2 },
-  { 194, 2 },
-  { 214, 1 },
-  { 214, 2 },
-  { 214, 3 },
-  { 214, 4 },
-  { 216, 2 },
-  { 216, 0 },
-  { 215, 0 },
-  { 215, 3 },
+  { 195, 2 },
+  { 215, 1 },
   { 215, 2 },
-  { 217, 4 },
+  { 215, 3 },
+  { 215, 4 },
+  { 217, 2 },
   { 217, 0 },
-  { 205, 0 },
-  { 205, 3 },
-  { 220, 4 },
-  { 220, 2 },
+  { 216, 0 },
+  { 216, 3 },
+  { 216, 2 },
+  { 218, 4 },
+  { 218, 0 },
+  { 206, 0 },
+  { 206, 3 },
+  { 188, 4 },
+  { 188, 2 },
   { 177, 1 },
   { 177, 1 },
   { 177, 0 },
-  { 203, 0 },
-  { 203, 3 },
   { 204, 0 },
-  { 204, 2 },
-  { 206, 0 },
-  { 206, 2 },
-  { 206, 4 },
-  { 206, 4 },
+  { 204, 3 },
+  { 205, 0 },
+  { 205, 2 },
+  { 207, 0 },
+  { 207, 2 },
+  { 207, 4 },
+  { 207, 4 },
   { 149, 6 },
-  { 202, 0 },
-  { 202, 2 },
+  { 203, 0 },
+  { 203, 2 },
   { 149, 8 },
   { 221, 5 },
   { 221, 3 },
@@ -126559,8 +127921,8 @@ static const struct {
   { 222, 1 },
   { 223, 0 },
   { 223, 3 },
-  { 219, 3 },
-  { 219, 1 },
+  { 220, 3 },
+  { 220, 1 },
   { 175, 1 },
   { 175, 3 },
   { 174, 1 },
@@ -126613,17 +127975,17 @@ static const struct {
   { 229, 0 },
   { 227, 1 },
   { 227, 0 },
+  { 210, 1 },
+  { 210, 0 },
+  { 209, 3 },
   { 209, 1 },
-  { 209, 0 },
-  { 208, 3 },
-  { 208, 1 },
   { 149, 12 },
   { 230, 1 },
   { 230, 0 },
   { 179, 0 },
   { 179, 3 },
-  { 188, 5 },
-  { 188, 3 },
+  { 189, 5 },
+  { 189, 3 },
   { 231, 0 },
   { 231, 2 },
   { 149, 4 },
@@ -126668,9 +128030,9 @@ static const struct {
   { 239, 1 },
   { 175, 4 },
   { 175, 6 },
-  { 192, 1 },
-  { 192, 1 },
-  { 192, 1 },
+  { 193, 1 },
+  { 193, 1 },
+  { 193, 1 },
   { 149, 4 },
   { 149, 6 },
   { 149, 3 },
@@ -126700,9 +128062,9 @@ static const struct {
   { 251, 0 },
   { 251, 4 },
   { 251, 2 },
-  { 197, 0 },
-  { 197, 2 },
-  { 197, 3 },
+  { 198, 0 },
+  { 198, 2 },
+  { 198, 3 },
   { 252, 6 },
   { 252, 8 },
 };
@@ -126727,8 +128089,9 @@ static void yy_reduce(
 #ifndef NDEBUG
   if( yyTraceFILE && yyruleno>=0 
         && yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) ){
-    fprintf(yyTraceFILE, "%sReduce [%s].\n", yyTracePrompt,
-      yyRuleName[yyruleno]);
+    yysize = yyRuleInfo[yyruleno].nrhs;
+    fprintf(yyTraceFILE, "%sReduce [%s] -> state %d.\n", yyTracePrompt,
+      yyRuleName[yyruleno], yymsp[-yysize].stateno);
   }
 #endif /* NDEBUG */
 
@@ -126825,8 +128188,9 @@ static void yy_reduce(
       case 85: /* init_deferred_pred_opt ::= INITIALLY IMMEDIATE */ yytestcase(yyruleno==85);
       case 97: /* defer_subclause_opt ::= */ yytestcase(yyruleno==97);
       case 108: /* ifexists ::= */ yytestcase(yyruleno==108);
-      case 218: /* between_op ::= BETWEEN */ yytestcase(yyruleno==218);
-      case 221: /* in_op ::= IN */ yytestcase(yyruleno==221);
+      case 219: /* between_op ::= BETWEEN */ yytestcase(yyruleno==219);
+      case 222: /* in_op ::= IN */ yytestcase(yyruleno==222);
+      case 247: /* collate ::= */ yytestcase(yyruleno==247);
 {yygotominor.yy328 = 0;}
         break;
       case 29: /* ifnotexists ::= IF NOT EXISTS */
@@ -126834,8 +128198,9 @@ static void yy_reduce(
       case 69: /* autoinc ::= AUTOINCR */ yytestcase(yyruleno==69);
       case 84: /* init_deferred_pred_opt ::= INITIALLY DEFERRED */ yytestcase(yyruleno==84);
       case 107: /* ifexists ::= IF EXISTS */ yytestcase(yyruleno==107);
-      case 219: /* between_op ::= NOT BETWEEN */ yytestcase(yyruleno==219);
-      case 222: /* in_op ::= NOT IN */ yytestcase(yyruleno==222);
+      case 220: /* between_op ::= NOT BETWEEN */ yytestcase(yyruleno==220);
+      case 223: /* in_op ::= NOT IN */ yytestcase(yyruleno==223);
+      case 248: /* collate ::= COLLATE ID|STRING */ yytestcase(yyruleno==248);
 {yygotominor.yy328 = 1;}
         break;
       case 32: /* create_table_args ::= LP columnlist conslist_opt RP table_options */
@@ -126882,18 +128247,17 @@ static void yy_reduce(
       case 48: /* typename ::= ID|STRING */ yytestcase(yyruleno==48);
       case 130: /* as ::= AS nm */ yytestcase(yyruleno==130);
       case 131: /* as ::= ID|STRING */ yytestcase(yyruleno==131);
-      case 141: /* dbnm ::= DOT nm */ yytestcase(yyruleno==141);
-      case 150: /* indexed_opt ::= INDEXED BY nm */ yytestcase(yyruleno==150);
-      case 247: /* collate ::= COLLATE ID|STRING */ yytestcase(yyruleno==247);
-      case 256: /* nmnum ::= plus_num */ yytestcase(yyruleno==256);
-      case 257: /* nmnum ::= nm */ yytestcase(yyruleno==257);
-      case 258: /* nmnum ::= ON */ yytestcase(yyruleno==258);
-      case 259: /* nmnum ::= DELETE */ yytestcase(yyruleno==259);
-      case 260: /* nmnum ::= DEFAULT */ yytestcase(yyruleno==260);
-      case 261: /* plus_num ::= PLUS INTEGER|FLOAT */ yytestcase(yyruleno==261);
-      case 262: /* plus_num ::= INTEGER|FLOAT */ yytestcase(yyruleno==262);
-      case 263: /* minus_num ::= MINUS INTEGER|FLOAT */ yytestcase(yyruleno==263);
-      case 279: /* trnm ::= nm */ yytestcase(yyruleno==279);
+      case 142: /* dbnm ::= DOT nm */ yytestcase(yyruleno==142);
+      case 151: /* indexed_opt ::= INDEXED BY nm */ yytestcase(yyruleno==151);
+      case 257: /* nmnum ::= plus_num */ yytestcase(yyruleno==257);
+      case 258: /* nmnum ::= nm */ yytestcase(yyruleno==258);
+      case 259: /* nmnum ::= ON */ yytestcase(yyruleno==259);
+      case 260: /* nmnum ::= DELETE */ yytestcase(yyruleno==260);
+      case 261: /* nmnum ::= DEFAULT */ yytestcase(yyruleno==261);
+      case 262: /* plus_num ::= PLUS INTEGER|FLOAT */ yytestcase(yyruleno==262);
+      case 263: /* plus_num ::= INTEGER|FLOAT */ yytestcase(yyruleno==263);
+      case 264: /* minus_num ::= MINUS INTEGER|FLOAT */ yytestcase(yyruleno==264);
+      case 280: /* trnm ::= nm */ yytestcase(yyruleno==280);
 {yygotominor.yy0 = yymsp[0].minor.yy0;}
         break;
       case 44: /* type ::= typetoken */
@@ -126953,7 +128317,7 @@ static void yy_reduce(
       case 64: /* ccons ::= CHECK LP expr RP */
 {sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy346.pExpr);}
         break;
-      case 65: /* ccons ::= REFERENCES nm idxlist_opt refargs */
+      case 65: /* ccons ::= REFERENCES nm eidlist_opt refargs */
 {sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy14,yymsp[0].minor.yy328);}
         break;
       case 66: /* ccons ::= defer_subclause */
@@ -127008,16 +128372,16 @@ static void yy_reduce(
       case 90: /* tconscomma ::= COMMA */
 {pParse->constraintName.n = 0;}
         break;
-      case 93: /* tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf */
+      case 93: /* tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf */
 {sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy14,yymsp[0].minor.yy328,yymsp[-2].minor.yy328,0);}
         break;
-      case 94: /* tcons ::= UNIQUE LP idxlist RP onconf */
+      case 94: /* tcons ::= UNIQUE LP sortlist RP onconf */
 {sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy14,yymsp[0].minor.yy328,0,0,0,0);}
         break;
       case 95: /* tcons ::= CHECK LP expr RP onconf */
 {sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy346.pExpr);}
         break;
-      case 96: /* tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt */
+      case 96: /* tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt */
 {
     sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy14, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy14, yymsp[-1].minor.yy328);
     sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy328);
@@ -127043,9 +128407,9 @@ static void yy_reduce(
   sqlite3DropTable(pParse, yymsp[0].minor.yy65, 0, yymsp[-1].minor.yy328);
 }
         break;
-      case 109: /* cmd ::= createkw temp VIEW ifnotexists nm dbnm AS select */
+      case 109: /* cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select */
 {
-  sqlite3CreateView(pParse, &yymsp[-7].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, yymsp[0].minor.yy3, yymsp[-6].minor.yy328, yymsp[-4].minor.yy328);
+  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy14, yymsp[0].minor.yy3, yymsp[-7].minor.yy328, yymsp[-5].minor.yy328);
 }
         break;
       case 110: /* cmd ::= DROP VIEW ifexists fullname */
@@ -127162,14 +128526,14 @@ static void yy_reduce(
 {yygotominor.yy381 = 0;}
         break;
       case 125: /* sclp ::= selcollist COMMA */
-      case 243: /* idxlist_opt ::= LP idxlist RP */ yytestcase(yyruleno==243);
+      case 244: /* eidlist_opt ::= LP eidlist RP */ yytestcase(yyruleno==244);
 {yygotominor.yy14 = yymsp[-1].minor.yy14;}
         break;
       case 126: /* sclp ::= */
-      case 154: /* orderby_opt ::= */ yytestcase(yyruleno==154);
-      case 161: /* groupby_opt ::= */ yytestcase(yyruleno==161);
-      case 236: /* exprlist ::= */ yytestcase(yyruleno==236);
-      case 242: /* idxlist_opt ::= */ yytestcase(yyruleno==242);
+      case 155: /* orderby_opt ::= */ yytestcase(yyruleno==155);
+      case 162: /* groupby_opt ::= */ yytestcase(yyruleno==162);
+      case 237: /* exprlist ::= */ yytestcase(yyruleno==237);
+      case 243: /* eidlist_opt ::= */ yytestcase(yyruleno==243);
 {yygotominor.yy14 = 0;}
         break;
       case 127: /* selcollist ::= sclp expr as */
@@ -127208,7 +128572,7 @@ static void yy_reduce(
       case 135: /* stl_prefix ::= seltablist joinop */
 {
    yygotominor.yy65 = yymsp[-1].minor.yy65;
-   if( ALWAYS(yygotominor.yy65 && yygotominor.yy65->nSrc>0) ) yygotominor.yy65->a[yygotominor.yy65->nSrc-1].jointype = (u8)yymsp[0].minor.yy328;
+   if( ALWAYS(yygotominor.yy65 && yygotominor.yy65->nSrc>0) ) yygotominor.yy65->a[yygotominor.yy65->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy328;
 }
         break;
       case 136: /* stl_prefix ::= */
@@ -127220,12 +128584,18 @@ static void yy_reduce(
   sqlite3SrcListIndexedBy(pParse, yygotominor.yy65, &yymsp[-2].minor.yy0);
 }
         break;
-      case 138: /* seltablist ::= stl_prefix LP select RP as on_opt using_opt */
+      case 138: /* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt */
+{
+  yygotominor.yy65 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-8].minor.yy65,&yymsp[-7].minor.yy0,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy132,yymsp[0].minor.yy408);
+  sqlite3SrcListFuncArgs(pParse, yygotominor.yy65, yymsp[-4].minor.yy14);
+}
+        break;
+      case 139: /* seltablist ::= stl_prefix LP select RP as on_opt using_opt */
 {
     yygotominor.yy65 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy65,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy3,yymsp[-1].minor.yy132,yymsp[0].minor.yy408);
   }
         break;
-      case 139: /* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
+      case 140: /* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */
 {
     if( yymsp[-6].minor.yy65==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy132==0 && yymsp[0].minor.yy408==0 ){
       yygotominor.yy65 = yymsp[-4].minor.yy65;
@@ -127249,94 +128619,96 @@ static void yy_reduce(
     }
   }
         break;
-      case 140: /* dbnm ::= */
-      case 149: /* indexed_opt ::= */ yytestcase(yyruleno==149);
+      case 141: /* dbnm ::= */
+      case 150: /* indexed_opt ::= */ yytestcase(yyruleno==150);
 {yygotominor.yy0.z=0; yygotominor.yy0.n=0;}
         break;
-      case 142: /* fullname ::= nm dbnm */
+      case 143: /* fullname ::= nm dbnm */
 {yygotominor.yy65 = sqlite3SrcListAppend(pParse->db,0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);}
         break;
-      case 143: /* joinop ::= COMMA|JOIN */
+      case 144: /* joinop ::= COMMA|JOIN */
 { yygotominor.yy328 = JT_INNER; }
         break;
-      case 144: /* joinop ::= JOIN_KW JOIN */
+      case 145: /* joinop ::= JOIN_KW JOIN */
 { yygotominor.yy328 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0); }
         break;
-      case 145: /* joinop ::= JOIN_KW nm JOIN */
+      case 146: /* joinop ::= JOIN_KW nm JOIN */
 { yygotominor.yy328 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); }
         break;
-      case 146: /* joinop ::= JOIN_KW nm nm JOIN */
+      case 147: /* joinop ::= JOIN_KW nm nm JOIN */
 { yygotominor.yy328 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0); }
         break;
-      case 147: /* on_opt ::= ON expr */
-      case 164: /* having_opt ::= HAVING expr */ yytestcase(yyruleno==164);
-      case 171: /* where_opt ::= WHERE expr */ yytestcase(yyruleno==171);
-      case 231: /* case_else ::= ELSE expr */ yytestcase(yyruleno==231);
-      case 233: /* case_operand ::= expr */ yytestcase(yyruleno==233);
+      case 148: /* on_opt ::= ON expr */
+      case 165: /* having_opt ::= HAVING expr */ yytestcase(yyruleno==165);
+      case 172: /* where_opt ::= WHERE expr */ yytestcase(yyruleno==172);
+      case 232: /* case_else ::= ELSE expr */ yytestcase(yyruleno==232);
+      case 234: /* case_operand ::= expr */ yytestcase(yyruleno==234);
 {yygotominor.yy132 = yymsp[0].minor.yy346.pExpr;}
         break;
-      case 148: /* on_opt ::= */
-      case 163: /* having_opt ::= */ yytestcase(yyruleno==163);
-      case 170: /* where_opt ::= */ yytestcase(yyruleno==170);
-      case 232: /* case_else ::= */ yytestcase(yyruleno==232);
-      case 234: /* case_operand ::= */ yytestcase(yyruleno==234);
+      case 149: /* on_opt ::= */
+      case 164: /* having_opt ::= */ yytestcase(yyruleno==164);
+      case 171: /* where_opt ::= */ yytestcase(yyruleno==171);
+      case 233: /* case_else ::= */ yytestcase(yyruleno==233);
+      case 235: /* case_operand ::= */ yytestcase(yyruleno==235);
 {yygotominor.yy132 = 0;}
         break;
-      case 151: /* indexed_opt ::= NOT INDEXED */
+      case 152: /* indexed_opt ::= NOT INDEXED */
 {yygotominor.yy0.z=0; yygotominor.yy0.n=1;}
         break;
-      case 152: /* using_opt ::= USING LP idlist RP */
-      case 180: /* inscollist_opt ::= LP idlist RP */ yytestcase(yyruleno==180);
+      case 153: /* using_opt ::= USING LP idlist RP */
+      case 181: /* idlist_opt ::= LP idlist RP */ yytestcase(yyruleno==181);
 {yygotominor.yy408 = yymsp[-1].minor.yy408;}
         break;
-      case 153: /* using_opt ::= */
-      case 179: /* inscollist_opt ::= */ yytestcase(yyruleno==179);
+      case 154: /* using_opt ::= */
+      case 180: /* idlist_opt ::= */ yytestcase(yyruleno==180);
 {yygotominor.yy408 = 0;}
         break;
-      case 155: /* orderby_opt ::= ORDER BY sortlist */
-      case 162: /* groupby_opt ::= GROUP BY nexprlist */ yytestcase(yyruleno==162);
-      case 235: /* exprlist ::= nexprlist */ yytestcase(yyruleno==235);
+      case 156: /* orderby_opt ::= ORDER BY sortlist */
+      case 163: /* groupby_opt ::= GROUP BY nexprlist */ yytestcase(yyruleno==163);
+      case 236: /* exprlist ::= nexprlist */ yytestcase(yyruleno==236);
 {yygotominor.yy14 = yymsp[0].minor.yy14;}
         break;
-      case 156: /* sortlist ::= sortlist COMMA expr sortorder */
+      case 157: /* sortlist ::= sortlist COMMA expr sortorder */
 {
   yygotominor.yy14 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy14,yymsp[-1].minor.yy346.pExpr);
-  if( yygotominor.yy14 ) yygotominor.yy14->a[yygotominor.yy14->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy328;
+  sqlite3ExprListSetSortOrder(yygotominor.yy14,yymsp[0].minor.yy328);
 }
         break;
-      case 157: /* sortlist ::= expr sortorder */
+      case 158: /* sortlist ::= expr sortorder */
 {
   yygotominor.yy14 = sqlite3ExprListAppend(pParse,0,yymsp[-1].minor.yy346.pExpr);
-  if( yygotominor.yy14 && ALWAYS(yygotominor.yy14->a) ) yygotominor.yy14->a[0].sortOrder = (u8)yymsp[0].minor.yy328;
+  sqlite3ExprListSetSortOrder(yygotominor.yy14,yymsp[0].minor.yy328);
 }
         break;
-      case 158: /* sortorder ::= ASC */
-      case 160: /* sortorder ::= */ yytestcase(yyruleno==160);
+      case 159: /* sortorder ::= ASC */
 {yygotominor.yy328 = SQLITE_SO_ASC;}
         break;
-      case 159: /* sortorder ::= DESC */
+      case 160: /* sortorder ::= DESC */
 {yygotominor.yy328 = SQLITE_SO_DESC;}
         break;
-      case 165: /* limit_opt ::= */
+      case 161: /* sortorder ::= */
+{yygotominor.yy328 = SQLITE_SO_UNDEFINED;}
+        break;
+      case 166: /* limit_opt ::= */
 {yygotominor.yy476.pLimit = 0; yygotominor.yy476.pOffset = 0;}
         break;
-      case 166: /* limit_opt ::= LIMIT expr */
+      case 167: /* limit_opt ::= LIMIT expr */
 {yygotominor.yy476.pLimit = yymsp[0].minor.yy346.pExpr; yygotominor.yy476.pOffset = 0;}
         break;
-      case 167: /* limit_opt ::= LIMIT expr OFFSET expr */
+      case 168: /* limit_opt ::= LIMIT expr OFFSET expr */
 {yygotominor.yy476.pLimit = yymsp[-2].minor.yy346.pExpr; yygotominor.yy476.pOffset = yymsp[0].minor.yy346.pExpr;}
         break;
-      case 168: /* limit_opt ::= LIMIT expr COMMA expr */
+      case 169: /* limit_opt ::= LIMIT expr COMMA expr */
 {yygotominor.yy476.pOffset = yymsp[-2].minor.yy346.pExpr; yygotominor.yy476.pLimit = yymsp[0].minor.yy346.pExpr;}
         break;
-      case 169: /* cmd ::= with DELETE FROM fullname indexed_opt where_opt */
+      case 170: /* cmd ::= with DELETE FROM fullname indexed_opt where_opt */
 {
   sqlite3WithPush(pParse, yymsp[-5].minor.yy59, 1);
   sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy65, &yymsp[-1].minor.yy0);
   sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy65,yymsp[0].minor.yy132);
 }
         break;
-      case 172: /* cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt */
+      case 173: /* cmd ::= with UPDATE orconf fullname indexed_opt SET setlist where_opt */
 {
   sqlite3WithPush(pParse, yymsp[-7].minor.yy59, 1);
   sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy65, &yymsp[-3].minor.yy0);
@@ -127344,58 +128716,58 @@ static void yy_reduce(
   sqlite3Update(pParse,yymsp[-4].minor.yy65,yymsp[-1].minor.yy14,yymsp[0].minor.yy132,yymsp[-5].minor.yy186);
 }
         break;
-      case 173: /* setlist ::= setlist COMMA nm EQ expr */
+      case 174: /* setlist ::= setlist COMMA nm EQ expr */
 {
   yygotominor.yy14 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy14, yymsp[0].minor.yy346.pExpr);
   sqlite3ExprListSetName(pParse, yygotominor.yy14, &yymsp[-2].minor.yy0, 1);
 }
         break;
-      case 174: /* setlist ::= nm EQ expr */
+      case 175: /* setlist ::= nm EQ expr */
 {
   yygotominor.yy14 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy346.pExpr);
   sqlite3ExprListSetName(pParse, yygotominor.yy14, &yymsp[-2].minor.yy0, 1);
 }
         break;
-      case 175: /* cmd ::= with insert_cmd INTO fullname inscollist_opt select */
+      case 176: /* cmd ::= with insert_cmd INTO fullname idlist_opt select */
 {
   sqlite3WithPush(pParse, yymsp[-5].minor.yy59, 1);
   sqlite3Insert(pParse, yymsp[-2].minor.yy65, yymsp[0].minor.yy3, yymsp[-1].minor.yy408, yymsp[-4].minor.yy186);
 }
         break;
-      case 176: /* cmd ::= with insert_cmd INTO fullname inscollist_opt DEFAULT VALUES */
+      case 177: /* cmd ::= with insert_cmd INTO fullname idlist_opt DEFAULT VALUES */
 {
   sqlite3WithPush(pParse, yymsp[-6].minor.yy59, 1);
   sqlite3Insert(pParse, yymsp[-3].minor.yy65, 0, yymsp[-2].minor.yy408, yymsp[-5].minor.yy186);
 }
         break;
-      case 177: /* insert_cmd ::= INSERT orconf */
+      case 178: /* insert_cmd ::= INSERT orconf */
 {yygotominor.yy186 = yymsp[0].minor.yy186;}
         break;
-      case 178: /* insert_cmd ::= REPLACE */
+      case 179: /* insert_cmd ::= REPLACE */
 {yygotominor.yy186 = OE_Replace;}
         break;
-      case 181: /* idlist ::= idlist COMMA nm */
+      case 182: /* idlist ::= idlist COMMA nm */
 {yygotominor.yy408 = sqlite3IdListAppend(pParse->db,yymsp[-2].minor.yy408,&yymsp[0].minor.yy0);}
         break;
-      case 182: /* idlist ::= nm */
+      case 183: /* idlist ::= nm */
 {yygotominor.yy408 = sqlite3IdListAppend(pParse->db,0,&yymsp[0].minor.yy0);}
         break;
-      case 183: /* expr ::= term */
+      case 184: /* expr ::= term */
 {yygotominor.yy346 = yymsp[0].minor.yy346;}
         break;
-      case 184: /* expr ::= LP expr RP */
+      case 185: /* expr ::= LP expr RP */
 {yygotominor.yy346.pExpr = yymsp[-1].minor.yy346.pExpr; spanSet(&yygotominor.yy346,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);}
         break;
-      case 185: /* term ::= NULL */
-      case 190: /* term ::= INTEGER|FLOAT|BLOB */ yytestcase(yyruleno==190);
-      case 191: /* term ::= STRING */ yytestcase(yyruleno==191);
+      case 186: /* term ::= NULL */
+      case 191: /* term ::= INTEGER|FLOAT|BLOB */ yytestcase(yyruleno==191);
+      case 192: /* term ::= STRING */ yytestcase(yyruleno==192);
 {spanExpr(&yygotominor.yy346, pParse, yymsp[0].major, &yymsp[0].minor.yy0);}
         break;
-      case 186: /* expr ::= ID|INDEXED */
-      case 187: /* expr ::= JOIN_KW */ yytestcase(yyruleno==187);
+      case 187: /* expr ::= ID|INDEXED */
+      case 188: /* expr ::= JOIN_KW */ yytestcase(yyruleno==188);
 {spanExpr(&yygotominor.yy346, pParse, TK_ID, &yymsp[0].minor.yy0);}
         break;
-      case 188: /* expr ::= nm DOT nm */
+      case 189: /* expr ::= nm DOT nm */
 {
   Expr *temp1 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0);
   Expr *temp2 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[0].minor.yy0);
@@ -127403,7 +128775,7 @@ static void yy_reduce(
   spanSet(&yygotominor.yy346,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);
 }
         break;
-      case 189: /* expr ::= nm DOT nm DOT nm */
+      case 190: /* expr ::= nm DOT nm DOT nm */
 {
   Expr *temp1 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-4].minor.yy0);
   Expr *temp2 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0);
@@ -127413,7 +128785,7 @@ static void yy_reduce(
   spanSet(&yygotominor.yy346,&yymsp[-4].minor.yy0,&yymsp[0].minor.yy0);
 }
         break;
-      case 192: /* expr ::= VARIABLE */
+      case 193: /* expr ::= VARIABLE */
 {
   if( yymsp[0].minor.yy0.n>=2 && yymsp[0].minor.yy0.z[0]=='#' && sqlite3Isdigit(yymsp[0].minor.yy0.z[1]) ){
     /* When doing a nested parse, one can include terms in an expression
@@ -127433,20 +128805,20 @@ static void yy_reduce(
   spanSet(&yygotominor.yy346, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);
 }
         break;
-      case 193: /* expr ::= expr COLLATE ID|STRING */
+      case 194: /* expr ::= expr COLLATE ID|STRING */
 {
   yygotominor.yy346.pExpr = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy346.pExpr, &yymsp[0].minor.yy0, 1);
   yygotominor.yy346.zStart = yymsp[-2].minor.yy346.zStart;
   yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
 }
         break;
-      case 194: /* expr ::= CAST LP expr AS typetoken RP */
+      case 195: /* expr ::= CAST LP expr AS typetoken RP */
 {
   yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_CAST, yymsp[-3].minor.yy346.pExpr, 0, &yymsp[-1].minor.yy0);
   spanSet(&yygotominor.yy346,&yymsp[-5].minor.yy0,&yymsp[0].minor.yy0);
 }
         break;
-      case 195: /* expr ::= ID|INDEXED LP distinct exprlist RP */
+      case 196: /* expr ::= ID|INDEXED LP distinct exprlist RP */
 {
   if( yymsp[-1].minor.yy14 && yymsp[-1].minor.yy14->nExpr>pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG] ){
     sqlite3ErrorMsg(pParse, "too many arguments on function %T", &yymsp[-4].minor.yy0);
@@ -127458,35 +128830,35 @@ static void yy_reduce(
   }
 }
         break;
-      case 196: /* expr ::= ID|INDEXED LP STAR RP */
+      case 197: /* expr ::= ID|INDEXED LP STAR RP */
 {
   yygotominor.yy346.pExpr = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0);
   spanSet(&yygotominor.yy346,&yymsp[-3].minor.yy0,&yymsp[0].minor.yy0);
 }
         break;
-      case 197: /* term ::= CTIME_KW */
+      case 198: /* term ::= CTIME_KW */
 {
   yygotominor.yy346.pExpr = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0);
   spanSet(&yygotominor.yy346, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);
 }
         break;
-      case 198: /* expr ::= expr AND expr */
-      case 199: /* expr ::= expr OR expr */ yytestcase(yyruleno==199);
-      case 200: /* expr ::= expr LT|GT|GE|LE expr */ yytestcase(yyruleno==200);
-      case 201: /* expr ::= expr EQ|NE expr */ yytestcase(yyruleno==201);
-      case 202: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */ yytestcase(yyruleno==202);
-      case 203: /* expr ::= expr PLUS|MINUS expr */ yytestcase(yyruleno==203);
-      case 204: /* expr ::= expr STAR|SLASH|REM expr */ yytestcase(yyruleno==204);
-      case 205: /* expr ::= expr CONCAT expr */ yytestcase(yyruleno==205);
+      case 199: /* expr ::= expr AND expr */
+      case 200: /* expr ::= expr OR expr */ yytestcase(yyruleno==200);
+      case 201: /* expr ::= expr LT|GT|GE|LE expr */ yytestcase(yyruleno==201);
+      case 202: /* expr ::= expr EQ|NE expr */ yytestcase(yyruleno==202);
+      case 203: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */ yytestcase(yyruleno==203);
+      case 204: /* expr ::= expr PLUS|MINUS expr */ yytestcase(yyruleno==204);
+      case 205: /* expr ::= expr STAR|SLASH|REM expr */ yytestcase(yyruleno==205);
+      case 206: /* expr ::= expr CONCAT expr */ yytestcase(yyruleno==206);
 {spanBinaryExpr(&yygotominor.yy346,pParse,yymsp[-1].major,&yymsp[-2].minor.yy346,&yymsp[0].minor.yy346);}
         break;
-      case 206: /* likeop ::= LIKE_KW|MATCH */
+      case 207: /* likeop ::= LIKE_KW|MATCH */
 {yygotominor.yy96.eOperator = yymsp[0].minor.yy0; yygotominor.yy96.bNot = 0;}
         break;
-      case 207: /* likeop ::= NOT LIKE_KW|MATCH */
+      case 208: /* likeop ::= NOT LIKE_KW|MATCH */
 {yygotominor.yy96.eOperator = yymsp[0].minor.yy0; yygotominor.yy96.bNot = 1;}
         break;
-      case 208: /* expr ::= expr likeop expr */
+      case 209: /* expr ::= expr likeop expr */
 {
   ExprList *pList;
   pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy346.pExpr);
@@ -127498,7 +128870,7 @@ static void yy_reduce(
   if( yygotominor.yy346.pExpr ) yygotominor.yy346.pExpr->flags |= EP_InfixFunc;
 }
         break;
-      case 209: /* expr ::= expr likeop expr ESCAPE expr */
+      case 210: /* expr ::= expr likeop expr ESCAPE expr */
 {
   ExprList *pList;
   pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy346.pExpr);
@@ -127511,35 +128883,35 @@ static void yy_reduce(
   if( yygotominor.yy346.pExpr ) yygotominor.yy346.pExpr->flags |= EP_InfixFunc;
 }
         break;
-      case 210: /* expr ::= expr ISNULL|NOTNULL */
+      case 211: /* expr ::= expr ISNULL|NOTNULL */
 {spanUnaryPostfix(&yygotominor.yy346,pParse,yymsp[0].major,&yymsp[-1].minor.yy346,&yymsp[0].minor.yy0);}
         break;
-      case 211: /* expr ::= expr NOT NULL */
+      case 212: /* expr ::= expr NOT NULL */
 {spanUnaryPostfix(&yygotominor.yy346,pParse,TK_NOTNULL,&yymsp[-2].minor.yy346,&yymsp[0].minor.yy0);}
         break;
-      case 212: /* expr ::= expr IS expr */
+      case 213: /* expr ::= expr IS expr */
 {
   spanBinaryExpr(&yygotominor.yy346,pParse,TK_IS,&yymsp[-2].minor.yy346,&yymsp[0].minor.yy346);
   binaryToUnaryIfNull(pParse, yymsp[0].minor.yy346.pExpr, yygotominor.yy346.pExpr, TK_ISNULL);
 }
         break;
-      case 213: /* expr ::= expr IS NOT expr */
+      case 214: /* expr ::= expr IS NOT expr */
 {
   spanBinaryExpr(&yygotominor.yy346,pParse,TK_ISNOT,&yymsp[-3].minor.yy346,&yymsp[0].minor.yy346);
   binaryToUnaryIfNull(pParse, yymsp[0].minor.yy346.pExpr, yygotominor.yy346.pExpr, TK_NOTNULL);
 }
         break;
-      case 214: /* expr ::= NOT expr */
-      case 215: /* expr ::= BITNOT expr */ yytestcase(yyruleno==215);
+      case 215: /* expr ::= NOT expr */
+      case 216: /* expr ::= BITNOT expr */ yytestcase(yyruleno==216);
 {spanUnaryPrefix(&yygotominor.yy346,pParse,yymsp[-1].major,&yymsp[0].minor.yy346,&yymsp[-1].minor.yy0);}
         break;
-      case 216: /* expr ::= MINUS expr */
+      case 217: /* expr ::= MINUS expr */
 {spanUnaryPrefix(&yygotominor.yy346,pParse,TK_UMINUS,&yymsp[0].minor.yy346,&yymsp[-1].minor.yy0);}
         break;
-      case 217: /* expr ::= PLUS expr */
+      case 218: /* expr ::= PLUS expr */
 {spanUnaryPrefix(&yygotominor.yy346,pParse,TK_UPLUS,&yymsp[0].minor.yy346,&yymsp[-1].minor.yy0);}
         break;
-      case 220: /* expr ::= expr between_op expr AND expr */
+      case 221: /* expr ::= expr between_op expr AND expr */
 {
   ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy346.pExpr);
   pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy346.pExpr);
@@ -127554,7 +128926,7 @@ static void yy_reduce(
   yygotominor.yy346.zEnd = yymsp[0].minor.yy346.zEnd;
 }
         break;
-      case 223: /* expr ::= expr in_op LP exprlist RP */
+      case 224: /* expr ::= expr in_op LP exprlist RP */
 {
     if( yymsp[-1].minor.yy14==0 ){
       /* Expressions of the form
@@ -127608,7 +128980,7 @@ static void yy_reduce(
     yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
   }
         break;
-      case 224: /* expr ::= LP select RP */
+      case 225: /* expr ::= LP select RP */
 {
     yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_SELECT, 0, 0, 0);
     if( yygotominor.yy346.pExpr ){
@@ -127622,7 +128994,7 @@ static void yy_reduce(
     yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
   }
         break;
-      case 225: /* expr ::= expr in_op LP select RP */
+      case 226: /* expr ::= expr in_op LP select RP */
 {
     yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy346.pExpr, 0, 0);
     if( yygotominor.yy346.pExpr ){
@@ -127637,7 +129009,7 @@ static void yy_reduce(
     yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
   }
         break;
-      case 226: /* expr ::= expr in_op nm dbnm */
+      case 227: /* expr ::= expr in_op nm dbnm */
 {
     SrcList *pSrc = sqlite3SrcListAppend(pParse->db, 0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);
     yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-3].minor.yy346.pExpr, 0, 0);
@@ -127653,7 +129025,7 @@ static void yy_reduce(
     yygotominor.yy346.zEnd = yymsp[0].minor.yy0.z ? &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] : &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n];
   }
         break;
-      case 227: /* expr ::= EXISTS LP select RP */
+      case 228: /* expr ::= EXISTS LP select RP */
 {
     Expr *p = yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_EXISTS, 0, 0, 0);
     if( p ){
@@ -127667,7 +129039,7 @@ static void yy_reduce(
     yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
   }
         break;
-      case 228: /* expr ::= CASE case_operand case_exprlist case_else END */
+      case 229: /* expr ::= CASE case_operand case_exprlist case_else END */
 {
   yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy132, 0, 0);
   if( yygotominor.yy346.pExpr ){
@@ -127681,82 +129053,71 @@ static void yy_reduce(
   yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
 }
         break;
-      case 229: /* case_exprlist ::= case_exprlist WHEN expr THEN expr */
+      case 230: /* case_exprlist ::= case_exprlist WHEN expr THEN expr */
 {
   yygotominor.yy14 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy14, yymsp[-2].minor.yy346.pExpr);
   yygotominor.yy14 = sqlite3ExprListAppend(pParse,yygotominor.yy14, yymsp[0].minor.yy346.pExpr);
 }
         break;
-      case 230: /* case_exprlist ::= WHEN expr THEN expr */
+      case 231: /* case_exprlist ::= WHEN expr THEN expr */
 {
   yygotominor.yy14 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy346.pExpr);
   yygotominor.yy14 = sqlite3ExprListAppend(pParse,yygotominor.yy14, yymsp[0].minor.yy346.pExpr);
 }
         break;
-      case 237: /* nexprlist ::= nexprlist COMMA expr */
+      case 238: /* nexprlist ::= nexprlist COMMA expr */
 {yygotominor.yy14 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy14,yymsp[0].minor.yy346.pExpr);}
         break;
-      case 238: /* nexprlist ::= expr */
+      case 239: /* nexprlist ::= expr */
 {yygotominor.yy14 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy346.pExpr);}
         break;
-      case 239: /* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP idxlist RP where_opt */
+      case 240: /* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt */
 {
   sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, 
                      sqlite3SrcListAppend(pParse->db,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy14, yymsp[-10].minor.yy328,
                       &yymsp[-11].minor.yy0, yymsp[0].minor.yy132, SQLITE_SO_ASC, yymsp[-8].minor.yy328);
 }
         break;
-      case 240: /* uniqueflag ::= UNIQUE */
-      case 291: /* raisetype ::= ABORT */ yytestcase(yyruleno==291);
+      case 241: /* uniqueflag ::= UNIQUE */
+      case 292: /* raisetype ::= ABORT */ yytestcase(yyruleno==292);
 {yygotominor.yy328 = OE_Abort;}
         break;
-      case 241: /* uniqueflag ::= */
+      case 242: /* uniqueflag ::= */
 {yygotominor.yy328 = OE_None;}
         break;
-      case 244: /* idxlist ::= idxlist COMMA nm collate sortorder */
+      case 245: /* eidlist ::= eidlist COMMA nm collate sortorder */
 {
-  Expr *p = sqlite3ExprAddCollateToken(pParse, 0, &yymsp[-1].minor.yy0, 1);
-  yygotominor.yy14 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy14, p);
-  sqlite3ExprListSetName(pParse,yygotominor.yy14,&yymsp[-2].minor.yy0,1);
-  sqlite3ExprListCheckLength(pParse, yygotominor.yy14, "index");
-  if( yygotominor.yy14 ) yygotominor.yy14->a[yygotominor.yy14->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy328;
+  yygotominor.yy14 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy14, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy328, yymsp[0].minor.yy328);
 }
         break;
-      case 245: /* idxlist ::= nm collate sortorder */
+      case 246: /* eidlist ::= nm collate sortorder */
 {
-  Expr *p = sqlite3ExprAddCollateToken(pParse, 0, &yymsp[-1].minor.yy0, 1);
-  yygotominor.yy14 = sqlite3ExprListAppend(pParse,0, p);
-  sqlite3ExprListSetName(pParse, yygotominor.yy14, &yymsp[-2].minor.yy0, 1);
-  sqlite3ExprListCheckLength(pParse, yygotominor.yy14, "index");
-  if( yygotominor.yy14 ) yygotominor.yy14->a[yygotominor.yy14->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy328;
+  yygotominor.yy14 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy328, yymsp[0].minor.yy328);
 }
         break;
-      case 246: /* collate ::= */
-{yygotominor.yy0.z = 0; yygotominor.yy0.n = 0;}
-        break;
-      case 248: /* cmd ::= DROP INDEX ifexists fullname */
+      case 249: /* cmd ::= DROP INDEX ifexists fullname */
 {sqlite3DropIndex(pParse, yymsp[0].minor.yy65, yymsp[-1].minor.yy328);}
         break;
-      case 249: /* cmd ::= VACUUM */
-      case 250: /* cmd ::= VACUUM nm */ yytestcase(yyruleno==250);
+      case 250: /* cmd ::= VACUUM */
+      case 251: /* cmd ::= VACUUM nm */ yytestcase(yyruleno==251);
 {sqlite3Vacuum(pParse);}
         break;
-      case 251: /* cmd ::= PRAGMA nm dbnm */
+      case 252: /* cmd ::= PRAGMA nm dbnm */
 {sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}
         break;
-      case 252: /* cmd ::= PRAGMA nm dbnm EQ nmnum */
+      case 253: /* cmd ::= PRAGMA nm dbnm EQ nmnum */
 {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}
         break;
-      case 253: /* cmd ::= PRAGMA nm dbnm LP nmnum RP */
+      case 254: /* cmd ::= PRAGMA nm dbnm LP nmnum RP */
 {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}
         break;
-      case 254: /* cmd ::= PRAGMA nm dbnm EQ minus_num */
+      case 255: /* cmd ::= PRAGMA nm dbnm EQ minus_num */
 {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}
         break;
-      case 255: /* cmd ::= PRAGMA nm dbnm LP minus_num RP */
+      case 256: /* cmd ::= PRAGMA nm dbnm LP minus_num RP */
 {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}
         break;
-      case 264: /* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
+      case 265: /* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */
 {
   Token all;
   all.z = yymsp[-3].minor.yy0.z;
@@ -127764,38 +129125,38 @@ static void yy_reduce(
   sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy473, &all);
 }
         break;
-      case 265: /* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
+      case 266: /* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */
 {
   sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy328, yymsp[-4].minor.yy378.a, yymsp[-4].minor.yy378.b, yymsp[-2].minor.yy65, yymsp[0].minor.yy132, yymsp[-10].minor.yy328, yymsp[-8].minor.yy328);
   yygotominor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0);
 }
         break;
-      case 266: /* trigger_time ::= BEFORE */
-      case 269: /* trigger_time ::= */ yytestcase(yyruleno==269);
+      case 267: /* trigger_time ::= BEFORE */
+      case 270: /* trigger_time ::= */ yytestcase(yyruleno==270);
 { yygotominor.yy328 = TK_BEFORE; }
         break;
-      case 267: /* trigger_time ::= AFTER */
+      case 268: /* trigger_time ::= AFTER */
 { yygotominor.yy328 = TK_AFTER;  }
         break;
-      case 268: /* trigger_time ::= INSTEAD OF */
+      case 269: /* trigger_time ::= INSTEAD OF */
 { yygotominor.yy328 = TK_INSTEAD;}
         break;
-      case 270: /* trigger_event ::= DELETE|INSERT */
-      case 271: /* trigger_event ::= UPDATE */ yytestcase(yyruleno==271);
+      case 271: /* trigger_event ::= DELETE|INSERT */
+      case 272: /* trigger_event ::= UPDATE */ yytestcase(yyruleno==272);
 {yygotominor.yy378.a = yymsp[0].major; yygotominor.yy378.b = 0;}
         break;
-      case 272: /* trigger_event ::= UPDATE OF idlist */
+      case 273: /* trigger_event ::= UPDATE OF idlist */
 {yygotominor.yy378.a = TK_UPDATE; yygotominor.yy378.b = yymsp[0].minor.yy408;}
         break;
-      case 275: /* when_clause ::= */
-      case 296: /* key_opt ::= */ yytestcase(yyruleno==296);
+      case 276: /* when_clause ::= */
+      case 297: /* key_opt ::= */ yytestcase(yyruleno==297);
 { yygotominor.yy132 = 0; }
         break;
-      case 276: /* when_clause ::= WHEN expr */
-      case 297: /* key_opt ::= KEY expr */ yytestcase(yyruleno==297);
+      case 277: /* when_clause ::= WHEN expr */
+      case 298: /* key_opt ::= KEY expr */ yytestcase(yyruleno==298);
 { yygotominor.yy132 = yymsp[0].minor.yy346.pExpr; }
         break;
-      case 277: /* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
+      case 278: /* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */
 {
   assert( yymsp[-2].minor.yy473!=0 );
   yymsp[-2].minor.yy473->pLast->pNext = yymsp[-1].minor.yy473;
@@ -127803,14 +129164,14 @@ static void yy_reduce(
   yygotominor.yy473 = yymsp[-2].minor.yy473;
 }
         break;
-      case 278: /* trigger_cmd_list ::= trigger_cmd SEMI */
+      case 279: /* trigger_cmd_list ::= trigger_cmd SEMI */
 { 
   assert( yymsp[-1].minor.yy473!=0 );
   yymsp[-1].minor.yy473->pLast = yymsp[-1].minor.yy473;
   yygotominor.yy473 = yymsp[-1].minor.yy473;
 }
         break;
-      case 280: /* trnm ::= nm DOT nm */
+      case 281: /* trnm ::= nm DOT nm */
 {
   yygotominor.yy0 = yymsp[0].minor.yy0;
   sqlite3ErrorMsg(pParse, 
@@ -127818,33 +129179,33 @@ static void yy_reduce(
         "statements within triggers");
 }
         break;
-      case 282: /* tridxby ::= INDEXED BY nm */
+      case 283: /* tridxby ::= INDEXED BY nm */
 {
   sqlite3ErrorMsg(pParse,
         "the INDEXED BY clause is not allowed on UPDATE or DELETE statements "
         "within triggers");
 }
         break;
-      case 283: /* tridxby ::= NOT INDEXED */
+      case 284: /* tridxby ::= NOT INDEXED */
 {
   sqlite3ErrorMsg(pParse,
         "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "
         "within triggers");
 }
         break;
-      case 284: /* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt */
+      case 285: /* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt */
 { yygotominor.yy473 = sqlite3TriggerUpdateStep(pParse->db, &yymsp[-4].minor.yy0, yymsp[-1].minor.yy14, yymsp[0].minor.yy132, yymsp[-5].minor.yy186); }
         break;
-      case 285: /* trigger_cmd ::= insert_cmd INTO trnm inscollist_opt select */
+      case 286: /* trigger_cmd ::= insert_cmd INTO trnm idlist_opt select */
 {yygotominor.yy473 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy408, yymsp[0].minor.yy3, yymsp[-4].minor.yy186);}
         break;
-      case 286: /* trigger_cmd ::= DELETE FROM trnm tridxby where_opt */
+      case 287: /* trigger_cmd ::= DELETE FROM trnm tridxby where_opt */
 {yygotominor.yy473 = sqlite3TriggerDeleteStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[0].minor.yy132);}
         break;
-      case 287: /* trigger_cmd ::= select */
+      case 288: /* trigger_cmd ::= select */
 {yygotominor.yy473 = sqlite3TriggerSelectStep(pParse->db, yymsp[0].minor.yy3); }
         break;
-      case 288: /* expr ::= RAISE LP IGNORE RP */
+      case 289: /* expr ::= RAISE LP IGNORE RP */
 {
   yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0, 0); 
   if( yygotominor.yy346.pExpr ){
@@ -127854,7 +129215,7 @@ static void yy_reduce(
   yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
 }
         break;
-      case 289: /* expr ::= RAISE LP raisetype COMMA nm RP */
+      case 290: /* expr ::= RAISE LP raisetype COMMA nm RP */
 {
   yygotominor.yy346.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0, &yymsp[-1].minor.yy0); 
   if( yygotominor.yy346.pExpr ) {
@@ -127864,87 +129225,87 @@ static void yy_reduce(
   yygotominor.yy346.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
 }
         break;
-      case 290: /* raisetype ::= ROLLBACK */
+      case 291: /* raisetype ::= ROLLBACK */
 {yygotominor.yy328 = OE_Rollback;}
         break;
-      case 292: /* raisetype ::= FAIL */
+      case 293: /* raisetype ::= FAIL */
 {yygotominor.yy328 = OE_Fail;}
         break;
-      case 293: /* cmd ::= DROP TRIGGER ifexists fullname */
+      case 294: /* cmd ::= DROP TRIGGER ifexists fullname */
 {
   sqlite3DropTrigger(pParse,yymsp[0].minor.yy65,yymsp[-1].minor.yy328);
 }
         break;
-      case 294: /* cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
+      case 295: /* cmd ::= ATTACH database_kw_opt expr AS expr key_opt */
 {
   sqlite3Attach(pParse, yymsp[-3].minor.yy346.pExpr, yymsp[-1].minor.yy346.pExpr, yymsp[0].minor.yy132);
 }
         break;
-      case 295: /* cmd ::= DETACH database_kw_opt expr */
+      case 296: /* cmd ::= DETACH database_kw_opt expr */
 {
   sqlite3Detach(pParse, yymsp[0].minor.yy346.pExpr);
 }
         break;
-      case 300: /* cmd ::= REINDEX */
+      case 301: /* cmd ::= REINDEX */
 {sqlite3Reindex(pParse, 0, 0);}
         break;
-      case 301: /* cmd ::= REINDEX nm dbnm */
+      case 302: /* cmd ::= REINDEX nm dbnm */
 {sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
         break;
-      case 302: /* cmd ::= ANALYZE */
+      case 303: /* cmd ::= ANALYZE */
 {sqlite3Analyze(pParse, 0, 0);}
         break;
-      case 303: /* cmd ::= ANALYZE nm dbnm */
+      case 304: /* cmd ::= ANALYZE nm dbnm */
 {sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
         break;
-      case 304: /* cmd ::= ALTER TABLE fullname RENAME TO nm */
+      case 305: /* cmd ::= ALTER TABLE fullname RENAME TO nm */
 {
   sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy65,&yymsp[0].minor.yy0);
 }
         break;
-      case 305: /* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column */
+      case 306: /* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column */
 {
   sqlite3AlterFinishAddColumn(pParse, &yymsp[0].minor.yy0);
 }
         break;
-      case 306: /* add_column_fullname ::= fullname */
+      case 307: /* add_column_fullname ::= fullname */
 {
   pParse->db->lookaside.bEnabled = 0;
   sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy65);
 }
         break;
-      case 309: /* cmd ::= create_vtab */
+      case 310: /* cmd ::= create_vtab */
 {sqlite3VtabFinishParse(pParse,0);}
         break;
-      case 310: /* cmd ::= create_vtab LP vtabarglist RP */
+      case 311: /* cmd ::= create_vtab LP vtabarglist RP */
 {sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}
         break;
-      case 311: /* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
+      case 312: /* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm */
 {
     sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy328);
 }
         break;
-      case 314: /* vtabarg ::= */
+      case 315: /* vtabarg ::= */
 {sqlite3VtabArgInit(pParse);}
         break;
-      case 316: /* vtabargtoken ::= ANY */
-      case 317: /* vtabargtoken ::= lp anylist RP */ yytestcase(yyruleno==317);
-      case 318: /* lp ::= LP */ yytestcase(yyruleno==318);
+      case 317: /* vtabargtoken ::= ANY */
+      case 318: /* vtabargtoken ::= lp anylist RP */ yytestcase(yyruleno==318);
+      case 319: /* lp ::= LP */ yytestcase(yyruleno==319);
 {sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}
         break;
-      case 322: /* with ::= */
+      case 323: /* with ::= */
 {yygotominor.yy59 = 0;}
         break;
-      case 323: /* with ::= WITH wqlist */
-      case 324: /* with ::= WITH RECURSIVE wqlist */ yytestcase(yyruleno==324);
+      case 324: /* with ::= WITH wqlist */
+      case 325: /* with ::= WITH RECURSIVE wqlist */ yytestcase(yyruleno==325);
 { yygotominor.yy59 = yymsp[0].minor.yy59; }
         break;
-      case 325: /* wqlist ::= nm idxlist_opt AS LP select RP */
+      case 326: /* wqlist ::= nm eidlist_opt AS LP select RP */
 {
   yygotominor.yy59 = sqlite3WithAdd(pParse, 0, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy14, yymsp[-1].minor.yy3);
 }
         break;
-      case 326: /* wqlist ::= wqlist COMMA nm idxlist_opt AS LP select RP */
+      case 327: /* wqlist ::= wqlist COMMA nm eidlist_opt AS LP select RP */
 {
   yygotominor.yy59 = sqlite3WithAdd(pParse, yymsp[-7].minor.yy59, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy14, yymsp[-1].minor.yy3);
 }
@@ -127972,19 +129333,19 @@ static void yy_reduce(
       /* (88) conslist ::= conslist tconscomma tcons */ yytestcase(yyruleno==88);
       /* (89) conslist ::= tcons */ yytestcase(yyruleno==89);
       /* (91) tconscomma ::= */ yytestcase(yyruleno==91);
-      /* (273) foreach_clause ::= */ yytestcase(yyruleno==273);
-      /* (274) foreach_clause ::= FOR EACH ROW */ yytestcase(yyruleno==274);
-      /* (281) tridxby ::= */ yytestcase(yyruleno==281);
-      /* (298) database_kw_opt ::= DATABASE */ yytestcase(yyruleno==298);
-      /* (299) database_kw_opt ::= */ yytestcase(yyruleno==299);
-      /* (307) kwcolumn_opt ::= */ yytestcase(yyruleno==307);
-      /* (308) kwcolumn_opt ::= COLUMNKW */ yytestcase(yyruleno==308);
-      /* (312) vtabarglist ::= vtabarg */ yytestcase(yyruleno==312);
-      /* (313) vtabarglist ::= vtabarglist COMMA vtabarg */ yytestcase(yyruleno==313);
-      /* (315) vtabarg ::= vtabarg vtabargtoken */ yytestcase(yyruleno==315);
-      /* (319) anylist ::= */ yytestcase(yyruleno==319);
-      /* (320) anylist ::= anylist LP anylist RP */ yytestcase(yyruleno==320);
-      /* (321) anylist ::= anylist ANY */ yytestcase(yyruleno==321);
+      /* (274) foreach_clause ::= */ yytestcase(yyruleno==274);
+      /* (275) foreach_clause ::= FOR EACH ROW */ yytestcase(yyruleno==275);
+      /* (282) tridxby ::= */ yytestcase(yyruleno==282);
+      /* (299) database_kw_opt ::= DATABASE */ yytestcase(yyruleno==299);
+      /* (300) database_kw_opt ::= */ yytestcase(yyruleno==300);
+      /* (308) kwcolumn_opt ::= */ yytestcase(yyruleno==308);
+      /* (309) kwcolumn_opt ::= COLUMNKW */ yytestcase(yyruleno==309);
+      /* (313) vtabarglist ::= vtabarg */ yytestcase(yyruleno==313);
+      /* (314) vtabarglist ::= vtabarglist COMMA vtabarg */ yytestcase(yyruleno==314);
+      /* (316) vtabarg ::= vtabarg vtabargtoken */ yytestcase(yyruleno==316);
+      /* (320) anylist ::= */ yytestcase(yyruleno==320);
+      /* (321) anylist ::= anylist LP anylist RP */ yytestcase(yyruleno==321);
+      /* (322) anylist ::= anylist ANY */ yytestcase(yyruleno==322);
         break;
   };
   assert( yyruleno>=0 && yyruleno<sizeof(yyRuleInfo)/sizeof(yyRuleInfo[0]) );
@@ -127992,9 +129353,9 @@ static void yy_reduce(
   yysize = yyRuleInfo[yyruleno].nrhs;
   yypParser->yyidx -= yysize;
   yyact = yy_find_reduce_action(yymsp[-yysize].stateno,(YYCODETYPE)yygoto);
-  if( yyact < YYNSTATE ){
-#ifdef NDEBUG
-    /* If we are not debugging and the reduce action popped at least
+  if( yyact <= YY_MAX_SHIFTREDUCE ){
+    if( yyact>YY_MAX_SHIFT ) yyact += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;
+    /* If the reduce action popped at least
     ** one element off the stack, then we can push the new element back
     ** onto the stack here, and skip the stack overflow test in yy_shift().
     ** That gives a significant speed improvement. */
@@ -128004,13 +129365,12 @@ static void yy_reduce(
       yymsp->stateno = (YYACTIONTYPE)yyact;
       yymsp->major = (YYCODETYPE)yygoto;
       yymsp->minor = yygotominor;
-    }else
-#endif
-    {
+      yyTraceShift(yypParser, yyact);
+    }else{
       yy_shift(yypParser,yyact,yygoto,&yygotominor);
     }
   }else{
-    assert( yyact == YYNSTATE + YYNRULE + 1 );
+    assert( yyact == YY_ACCEPT_ACTION );
     yy_accept(yypParser);
   }
 }
@@ -128135,12 +129495,13 @@ SQLITE_PRIVATE void sqlite3Parser(
 
   do{
     yyact = yy_find_shift_action(yypParser,(YYCODETYPE)yymajor);
-    if( yyact<YYNSTATE ){
+    if( yyact <= YY_MAX_SHIFTREDUCE ){
+      if( yyact > YY_MAX_SHIFT ) yyact += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;
       yy_shift(yypParser,yyact,yymajor,&yyminorunion);
       yypParser->yyerrcnt--;
       yymajor = YYNOCODE;
-    }else if( yyact < YYNSTATE + YYNRULE ){
-      yy_reduce(yypParser,yyact-YYNSTATE);
+    }else if( yyact <= YY_MAX_REDUCE ){
+      yy_reduce(yypParser,yyact-YY_MIN_REDUCE);
     }else{
       assert( yyact == YY_ERROR_ACTION );
 #ifdef YYERRORSYMBOL
@@ -128190,7 +129551,7 @@ SQLITE_PRIVATE void sqlite3Parser(
           yymx != YYERRORSYMBOL &&
           (yyact = yy_find_reduce_action(
                         yypParser->yystack[yypParser->yyidx].stateno,
-                        YYERRORSYMBOL)) >= YYNSTATE
+                        YYERRORSYMBOL)) >= YY_MIN_REDUCE
         ){
           yy_pop_parser_stack(yypParser);
         }
@@ -128240,6 +129601,11 @@ SQLITE_PRIVATE void sqlite3Parser(
 #endif
     }
   }while( yymajor!=YYNOCODE && yypParser->yyidx>=0 );
+#ifndef NDEBUG
+  if( yyTraceFILE ){
+    fprintf(yyTraceFILE,"%sReturn\n",yyTracePrompt);
+  }
+#endif
   return;
 }
 
@@ -128928,6 +130294,7 @@ SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzEr
   pParse->zTail = zSql;
   i = 0;
   assert( pzErrMsg!=0 );
+  /* sqlite3ParserTrace(stdout, "parser: "); */
   pEngine = sqlite3ParserAlloc(sqlite3Malloc);
   if( pEngine==0 ){
     db->mallocFailed = 1;
@@ -129465,6 +130832,12 @@ SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db);
 /************** End of sqliteicu.h *******************************************/
 /************** Continuing where we left off in main.c ***********************/
 #endif
+#ifdef SQLITE_ENABLE_JSON1
+SQLITE_PRIVATE int sqlite3Json1Init(sqlite3*);
+#endif
+#ifdef SQLITE_ENABLE_FTS5
+SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3*);
+#endif
 
 #ifndef SQLITE_AMALGAMATION
 /* IMPLEMENTATION-OF: R-46656-45156 The sqlite3_version[] string constant
@@ -130372,17 +131745,23 @@ static void functionDestroy(sqlite3 *db, FuncDef *p){
 static void disconnectAllVtab(sqlite3 *db){
 #ifndef SQLITE_OMIT_VIRTUALTABLE
   int i;
+  HashElem *p;
   sqlite3BtreeEnterAll(db);
   for(i=0; i<db->nDb; i++){
     Schema *pSchema = db->aDb[i].pSchema;
     if( db->aDb[i].pSchema ){
-      HashElem *p;
       for(p=sqliteHashFirst(&pSchema->tblHash); p; p=sqliteHashNext(p)){
         Table *pTab = (Table *)sqliteHashData(p);
         if( IsVirtual(pTab) ) sqlite3VtabDisconnect(db, pTab);
       }
     }
   }
+  for(p=sqliteHashFirst(&db->aModule); p; p=sqliteHashNext(p)){
+    Module *pMod = (Module *)sqliteHashData(p);
+    if( pMod->pEpoTab ){
+      sqlite3VtabDisconnect(db, pMod->pEpoTab);
+    }
+  }
   sqlite3VtabUnlockList(db);
   sqlite3BtreeLeaveAll(db);
 #else
@@ -130560,6 +131939,7 @@ SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db){
     if( pMod->xDestroy ){
       pMod->xDestroy(pMod->pAux);
     }
+    sqlite3VtabEponymousTableClear(db, pMod);
     sqlite3DbFree(db, pMod);
   }
   sqlite3HashClear(&db->aModule);
@@ -132305,12 +133685,18 @@ static int openDatabase(
   }
 #endif
 
-#ifdef SQLITE_ENABLE_FTS3
+#ifdef SQLITE_ENABLE_FTS3 /* automatically defined by SQLITE_ENABLE_FTS4 */
   if( !db->mallocFailed && rc==SQLITE_OK ){
     rc = sqlite3Fts3Init(db);
   }
 #endif
 
+#ifdef SQLITE_ENABLE_FTS5
+  if( !db->mallocFailed && rc==SQLITE_OK ){
+    rc = sqlite3Fts5Init(db);
+  }
+#endif
+
 #ifdef SQLITE_ENABLE_ICU
   if( !db->mallocFailed && rc==SQLITE_OK ){
     rc = sqlite3IcuInit(db);
@@ -132329,6 +133715,12 @@ static int openDatabase(
   }
 #endif
 
+#ifdef SQLITE_ENABLE_JSON1
+  if( !db->mallocFailed && rc==SQLITE_OK){
+    rc = sqlite3Json1Init(db);
+  }
+#endif
+
   /* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking
   ** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking
   ** mode.  Doing nothing at all also makes NORMAL the default.
@@ -134403,6 +135795,7 @@ struct Fts3Table {
   int nPendingData;               /* Current bytes of pending data */
   sqlite_int64 iPrevDocid;        /* Docid of most recently inserted document */
   int iPrevLangid;                /* Langid of recently inserted document */
+  int bPrevDelete;                /* True if last operation was a delete */
 
 #if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)
   /* State variables used for validating that the transaction control
@@ -135978,6 +137371,19 @@ static void fts3SetEstimatedRows(sqlite3_index_info *pIdxInfo, i64 nRow){
 #endif
 }
 
+/*
+** Set the SQLITE_INDEX_SCAN_UNIQUE flag in pIdxInfo->flags. Unless this
+** extension is currently being used by a version of SQLite too old to
+** support index-info flags. In that case this function is a no-op.
+*/
+static void fts3SetUniqueFlag(sqlite3_index_info *pIdxInfo){
+#if SQLITE_VERSION_NUMBER>=3008012
+  if( sqlite3_libversion_number()>=3008012 ){
+    pIdxInfo->idxFlags |= SQLITE_INDEX_SCAN_UNIQUE;
+  }
+#endif
+}
+
 /* 
 ** Implementation of the xBestIndex method for FTS3 tables. There
 ** are three possible strategies, in order of preference:
@@ -136068,6 +137474,9 @@ static int fts3BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
     }
   }
 
+  /* If using a docid=? or rowid=? strategy, set the UNIQUE flag. */
+  if( pInfo->idxNum==FTS3_DOCID_SEARCH ) fts3SetUniqueFlag(pInfo);
+
   iIdx = 1;
   if( iCons>=0 ){
     pInfo->aConstraintUsage[iCons].argvIndex = iIdx++;
@@ -141718,125 +143127,151 @@ static int fts3ExprBalance(Fts3Expr **pp, int nMaxDepth){
     rc = SQLITE_ERROR;
   }
 
-  if( rc==SQLITE_OK && (eType==FTSQUERY_AND || eType==FTSQUERY_OR) ){
-    Fts3Expr **apLeaf;
-    apLeaf = (Fts3Expr **)sqlite3_malloc(sizeof(Fts3Expr *) * nMaxDepth);
-    if( 0==apLeaf ){
-      rc = SQLITE_NOMEM;
-    }else{
-      memset(apLeaf, 0, sizeof(Fts3Expr *) * nMaxDepth);
-    }
-
-    if( rc==SQLITE_OK ){
-      int i;
-      Fts3Expr *p;
-
-      /* Set $p to point to the left-most leaf in the tree of eType nodes. */
-      for(p=pRoot; p->eType==eType; p=p->pLeft){
-        assert( p->pParent==0 || p->pParent->pLeft==p );
-        assert( p->pLeft && p->pRight );
+  if( rc==SQLITE_OK ){
+    if( (eType==FTSQUERY_AND || eType==FTSQUERY_OR) ){
+      Fts3Expr **apLeaf;
+      apLeaf = (Fts3Expr **)sqlite3_malloc(sizeof(Fts3Expr *) * nMaxDepth);
+      if( 0==apLeaf ){
+        rc = SQLITE_NOMEM;
+      }else{
+        memset(apLeaf, 0, sizeof(Fts3Expr *) * nMaxDepth);
       }
 
-      /* This loop runs once for each leaf in the tree of eType nodes. */
-      while( 1 ){
-        int iLvl;
-        Fts3Expr *pParent = p->pParent;     /* Current parent of p */
+      if( rc==SQLITE_OK ){
+        int i;
+        Fts3Expr *p;
 
-        assert( pParent==0 || pParent->pLeft==p );
-        p->pParent = 0;
-        if( pParent ){
-          pParent->pLeft = 0;
-        }else{
-          pRoot = 0;
+        /* Set $p to point to the left-most leaf in the tree of eType nodes. */
+        for(p=pRoot; p->eType==eType; p=p->pLeft){
+          assert( p->pParent==0 || p->pParent->pLeft==p );
+          assert( p->pLeft && p->pRight );
         }
-        rc = fts3ExprBalance(&p, nMaxDepth-1);
-        if( rc!=SQLITE_OK ) break;
 
-        for(iLvl=0; p && iLvl<nMaxDepth; iLvl++){
-          if( apLeaf[iLvl]==0 ){
-            apLeaf[iLvl] = p;
-            p = 0;
+        /* This loop runs once for each leaf in the tree of eType nodes. */
+        while( 1 ){
+          int iLvl;
+          Fts3Expr *pParent = p->pParent;     /* Current parent of p */
+
+          assert( pParent==0 || pParent->pLeft==p );
+          p->pParent = 0;
+          if( pParent ){
+            pParent->pLeft = 0;
           }else{
-            assert( pFree );
-            pFree->pLeft = apLeaf[iLvl];
-            pFree->pRight = p;
-            pFree->pLeft->pParent = pFree;
-            pFree->pRight->pParent = pFree;
-
-            p = pFree;
-            pFree = pFree->pParent;
-            p->pParent = 0;
-            apLeaf[iLvl] = 0;
+            pRoot = 0;
           }
-        }
-        if( p ){
-          sqlite3Fts3ExprFree(p);
-          rc = SQLITE_TOOBIG;
-          break;
-        }
-
-        /* If that was the last leaf node, break out of the loop */
-        if( pParent==0 ) break;
-
-        /* Set $p to point to the next leaf in the tree of eType nodes */
-        for(p=pParent->pRight; p->eType==eType; p=p->pLeft);
-
-        /* Remove pParent from the original tree. */
-        assert( pParent->pParent==0 || pParent->pParent->pLeft==pParent );
-        pParent->pRight->pParent = pParent->pParent;
-        if( pParent->pParent ){
-          pParent->pParent->pLeft = pParent->pRight;
-        }else{
-          assert( pParent==pRoot );
-          pRoot = pParent->pRight;
-        }
-
-        /* Link pParent into the free node list. It will be used as an
-        ** internal node of the new tree.  */
-        pParent->pParent = pFree;
-        pFree = pParent;
-      }
+          rc = fts3ExprBalance(&p, nMaxDepth-1);
+          if( rc!=SQLITE_OK ) break;
 
-      if( rc==SQLITE_OK ){
-        p = 0;
-        for(i=0; i<nMaxDepth; i++){
-          if( apLeaf[i] ){
-            if( p==0 ){
-              p = apLeaf[i];
-              p->pParent = 0;
+          for(iLvl=0; p && iLvl<nMaxDepth; iLvl++){
+            if( apLeaf[iLvl]==0 ){
+              apLeaf[iLvl] = p;
+              p = 0;
             }else{
-              assert( pFree!=0 );
+              assert( pFree );
+              pFree->pLeft = apLeaf[iLvl];
               pFree->pRight = p;
-              pFree->pLeft = apLeaf[i];
               pFree->pLeft->pParent = pFree;
               pFree->pRight->pParent = pFree;
 
               p = pFree;
               pFree = pFree->pParent;
               p->pParent = 0;
+              apLeaf[iLvl] = 0;
             }
           }
+          if( p ){
+            sqlite3Fts3ExprFree(p);
+            rc = SQLITE_TOOBIG;
+            break;
+          }
+
+          /* If that was the last leaf node, break out of the loop */
+          if( pParent==0 ) break;
+
+          /* Set $p to point to the next leaf in the tree of eType nodes */
+          for(p=pParent->pRight; p->eType==eType; p=p->pLeft);
+
+          /* Remove pParent from the original tree. */
+          assert( pParent->pParent==0 || pParent->pParent->pLeft==pParent );
+          pParent->pRight->pParent = pParent->pParent;
+          if( pParent->pParent ){
+            pParent->pParent->pLeft = pParent->pRight;
+          }else{
+            assert( pParent==pRoot );
+            pRoot = pParent->pRight;
+          }
+
+          /* Link pParent into the free node list. It will be used as an
+          ** internal node of the new tree.  */
+          pParent->pParent = pFree;
+          pFree = pParent;
         }
-        pRoot = p;
-      }else{
-        /* An error occurred. Delete the contents of the apLeaf[] array 
-        ** and pFree list. Everything else is cleaned up by the call to
-        ** sqlite3Fts3ExprFree(pRoot) below.  */
-        Fts3Expr *pDel;
-        for(i=0; i<nMaxDepth; i++){
-          sqlite3Fts3ExprFree(apLeaf[i]);
-        }
-        while( (pDel=pFree)!=0 ){
-          pFree = pDel->pParent;
-          sqlite3_free(pDel);
+
+        if( rc==SQLITE_OK ){
+          p = 0;
+          for(i=0; i<nMaxDepth; i++){
+            if( apLeaf[i] ){
+              if( p==0 ){
+                p = apLeaf[i];
+                p->pParent = 0;
+              }else{
+                assert( pFree!=0 );
+                pFree->pRight = p;
+                pFree->pLeft = apLeaf[i];
+                pFree->pLeft->pParent = pFree;
+                pFree->pRight->pParent = pFree;
+
+                p = pFree;
+                pFree = pFree->pParent;
+                p->pParent = 0;
+              }
+            }
+          }
+          pRoot = p;
+        }else{
+          /* An error occurred. Delete the contents of the apLeaf[] array 
+          ** and pFree list. Everything else is cleaned up by the call to
+          ** sqlite3Fts3ExprFree(pRoot) below.  */
+          Fts3Expr *pDel;
+          for(i=0; i<nMaxDepth; i++){
+            sqlite3Fts3ExprFree(apLeaf[i]);
+          }
+          while( (pDel=pFree)!=0 ){
+            pFree = pDel->pParent;
+            sqlite3_free(pDel);
+          }
         }
+
+        assert( pFree==0 );
+        sqlite3_free( apLeaf );
+      }
+    }else if( eType==FTSQUERY_NOT ){
+      Fts3Expr *pLeft = pRoot->pLeft;
+      Fts3Expr *pRight = pRoot->pRight;
+
+      pRoot->pLeft = 0;
+      pRoot->pRight = 0;
+      pLeft->pParent = 0;
+      pRight->pParent = 0;
+
+      rc = fts3ExprBalance(&pLeft, nMaxDepth-1);
+      if( rc==SQLITE_OK ){
+        rc = fts3ExprBalance(&pRight, nMaxDepth-1);
       }
 
-      assert( pFree==0 );
-      sqlite3_free( apLeaf );
+      if( rc!=SQLITE_OK ){
+        sqlite3Fts3ExprFree(pRight);
+        sqlite3Fts3ExprFree(pLeft);
+      }else{
+        assert( pLeft && pRight );
+        pRoot->pLeft = pLeft;
+        pLeft->pParent = pRoot;
+        pRoot->pRight = pRight;
+        pRight->pParent = pRoot;
+      }
     }
   }
-
+  
   if( rc!=SQLITE_OK ){
     sqlite3Fts3ExprFree(pRoot);
     pRoot = 0;
@@ -145313,10 +146748,12 @@ static int fts3PendingTermsAdd(
 */
 static int fts3PendingTermsDocid(
   Fts3Table *p,                   /* Full-text table handle */
+  int bDelete,                    /* True if this op is a delete */
   int iLangid,                    /* Language id of row being written */
   sqlite_int64 iDocid             /* Docid of row being written */
 ){
   assert( iLangid>=0 );
+  assert( bDelete==1 || bDelete==0 );
 
   /* TODO(shess) Explore whether partially flushing the buffer on
   ** forced-flush would provide better performance.  I suspect that if
@@ -145324,7 +146761,8 @@ static int fts3PendingTermsDocid(
   ** buffer was half empty, that would let the less frequent terms
   ** generate longer doclists.
   */
-  if( iDocid<=p->iPrevDocid 
+  if( iDocid<p->iPrevDocid 
+   || (iDocid==p->iPrevDocid && p->bPrevDelete==0)
    || p->iPrevLangid!=iLangid
    || p->nPendingData>p->nMaxPendingData 
   ){
@@ -145333,6 +146771,7 @@ static int fts3PendingTermsDocid(
   }
   p->iPrevDocid = iDocid;
   p->iPrevLangid = iLangid;
+  p->bPrevDelete = bDelete;
   return SQLITE_OK;
 }
 
@@ -145522,7 +146961,8 @@ static void fts3DeleteTerms(
     if( SQLITE_ROW==sqlite3_step(pSelect) ){
       int i;
       int iLangid = langidFromSelect(p, pSelect);
-      rc = fts3PendingTermsDocid(p, iLangid, sqlite3_column_int64(pSelect, 0));
+      i64 iDocid = sqlite3_column_int64(pSelect, 0);
+      rc = fts3PendingTermsDocid(p, 1, iLangid, iDocid);
       for(i=1; rc==SQLITE_OK && i<=p->nColumn; i++){
         int iCol = i-1;
         if( p->abNotindexed[iCol]==0 ){
@@ -145770,14 +147210,19 @@ static int fts3SegReaderNext(
 
     if( fts3SegReaderIsPending(pReader) ){
       Fts3HashElem *pElem = *(pReader->ppNextElem);
-      if( pElem==0 ){
-        pReader->aNode = 0;
-      }else{
+      sqlite3_free(pReader->aNode);
+      pReader->aNode = 0;
+      if( pElem ){
+        char *aCopy;
         PendingList *pList = (PendingList *)fts3HashData(pElem);
+        int nCopy = pList->nData+1;
         pReader->zTerm = (char *)fts3HashKey(pElem);
         pReader->nTerm = fts3HashKeysize(pElem);
-        pReader->nNode = pReader->nDoclist = pList->nData + 1;
-        pReader->aNode = pReader->aDoclist = pList->aData;
+        aCopy = (char*)sqlite3_malloc(nCopy);
+        if( !aCopy ) return SQLITE_NOMEM;
+        memcpy(aCopy, pList->aData, nCopy);
+        pReader->nNode = pReader->nDoclist = nCopy;
+        pReader->aNode = pReader->aDoclist = aCopy;
         pReader->ppNextElem++;
         assert( pReader->aNode );
       }
@@ -146017,12 +147462,14 @@ SQLITE_PRIVATE int sqlite3Fts3MsrOvfl(
 ** second argument.
 */
 SQLITE_PRIVATE void sqlite3Fts3SegReaderFree(Fts3SegReader *pReader){
-  if( pReader && !fts3SegReaderIsPending(pReader) ){
-    sqlite3_free(pReader->zTerm);
+  if( pReader ){
+    if( !fts3SegReaderIsPending(pReader) ){
+      sqlite3_free(pReader->zTerm);
+    }
     if( !fts3SegReaderIsRootOnly(pReader) ){
       sqlite3_free(pReader->aNode);
-      sqlite3_blob_close(pReader->pBlob);
     }
+    sqlite3_blob_close(pReader->pBlob);
   }
   sqlite3_free(pReader);
 }
@@ -147965,7 +149412,7 @@ static int fts3DoRebuild(Fts3Table *p){
     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
       int iCol;
       int iLangid = langidFromSelect(p, pStmt);
-      rc = fts3PendingTermsDocid(p, iLangid, sqlite3_column_int64(pStmt, 0));
+      rc = fts3PendingTermsDocid(p, 0, iLangid, sqlite3_column_int64(pStmt, 0));
       memset(aSz, 0, sizeof(aSz[0]) * (p->nColumn+1));
       for(iCol=0; rc==SQLITE_OK && iCol<p->nColumn; iCol++){
         if( p->abNotindexed[iCol]==0 ){
@@ -150070,7 +151517,7 @@ SQLITE_PRIVATE int sqlite3Fts3UpdateMethod(
       }
     }
     if( rc==SQLITE_OK && (!isRemove || *pRowid!=p->iPrevDocid ) ){
-      rc = fts3PendingTermsDocid(p, iLangid, *pRowid);
+      rc = fts3PendingTermsDocid(p, 0, iLangid, *pRowid);
     }
     if( rc==SQLITE_OK ){
       assert( p->iPrevDocid==*pRowid );
@@ -156964,10 +158411,6 @@ SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(
 /* #include <string.h> */
 /* #include <stdio.h> */
 
-#if !defined(_WIN32)
-/* #  include <unistd.h> */
-#endif
-
 /* #include "sqlite3.h" */
 
 #if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_RBU)
@@ -157072,6 +158515,18 @@ SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(
 **
 ** The order of the columns in the data_% table does not matter.
 **
+** Instead of a regular table, the RBU database may also contain virtual
+** tables or view named using the data_<target> naming scheme. 
+**
+** Instead of the plain data_<target> naming scheme, RBU database tables 
+** may also be named data<integer>_<target>, where <integer> is any sequence
+** of zero or more numeric characters (0-9). This can be significant because
+** tables within the RBU database are always processed in order sorted by 
+** name. By judicious selection of the the <integer> portion of the names
+** of the RBU tables the user can therefore control the order in which they
+** are processed. This can be useful, for example, to ensure that "external
+** content" FTS4 tables are updated before their underlying content tables.
+**
 ** If the target database table is a virtual table or a table that has no
 ** PRIMARY KEY declaration, the data_% table must also contain a column 
 ** named "rbu_rowid". This column is mapped to the tables implicit primary 
@@ -157152,6 +158607,14 @@ SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(
 **
 **   UPDATE t1 SET c = rbu_delta(c, 'usa') WHERE a = 4;
 **
+** Finally, if an 'f' character appears in place of a 'd' or 's' in an 
+** ota_control string, the contents of the data_xxx table column is assumed
+** to be a "fossil delta" - a patch to be applied to a blob value in the
+** format used by the fossil source-code management system. In this case
+** the existing value within the target database table must be of type BLOB. 
+** It is replaced by the result of applying the specified fossil delta to
+** itself.
+**
 ** If the target database table is a virtual table or a table with no PRIMARY
 ** KEY, the rbu_control value should not include a character corresponding 
 ** to the rbu_rowid value. For example, this:
@@ -157224,6 +158687,10 @@ SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(
 
 /* #include "sqlite3.h"              ** Required for error code definitions ** */
 
+#if 0
+extern "C" {
+#endif
+
 typedef struct sqlite3rbu sqlite3rbu;
 
 /*
@@ -157309,6 +158776,18 @@ SQLITE_API sqlite3 *SQLITE_STDCALL sqlite3rbu_db(sqlite3rbu*, int bRbu);
 */
 SQLITE_API int SQLITE_STDCALL sqlite3rbu_step(sqlite3rbu *pRbu);
 
+/*
+** Force RBU to save its state to disk.
+**
+** If a power failure or application crash occurs during an update, following
+** system recovery RBU may resume the update from the point at which the state
+** was last saved. In other words, from the most recent successful call to 
+** sqlite3rbu_close() or this function.
+**
+** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
+*/
+SQLITE_API int SQLITE_STDCALL sqlite3rbu_savestate(sqlite3rbu *pRbu);
+
 /*
 ** Close an RBU handle. 
 **
@@ -157390,11 +158869,19 @@ SQLITE_API int SQLITE_STDCALL sqlite3rbu_create_vfs(const char *zName, const cha
 */
 SQLITE_API void SQLITE_STDCALL sqlite3rbu_destroy_vfs(const char *zName);
 
+#if 0
+}  /* end of the 'extern "C"' block */
+#endif
+
 #endif /* _SQLITE3RBU_H */
 
 /************** End of sqlite3rbu.h ******************************************/
 /************** Continuing where we left off in sqlite3rbu.c *****************/
 
+#if defined(_WIN32_WCE)
+/* #include "windows.h" */
+#endif
+
 /* Maximum number of prepared UPDATE statements held by this module */
 #define SQLITE_RBU_UPDATE_CACHESIZE 16
 
@@ -157541,6 +159028,7 @@ struct RbuObjIter {
   /* Output variables. zTbl==0 implies EOF. */
   int bCleanup;                   /* True in "cleanup" state */
   const char *zTbl;               /* Name of target db table */
+  const char *zDataTbl;           /* Name of rbu db table (or null) */
   const char *zIdx;               /* Name of target db index (or null) */
   int iTnum;                      /* Root page of current object */
   int iPkTnum;                    /* If eType==EXTERNAL, root of PK index */
@@ -157551,7 +159039,7 @@ struct RbuObjIter {
   sqlite3_stmt *pSelect;          /* Source data */
   sqlite3_stmt *pInsert;          /* Statement for INSERT operations */
   sqlite3_stmt *pDelete;          /* Statement for DELETE ops */
-  sqlite3_stmt *pTmpInsert;       /* Insert into rbu_tmp_$zTbl */
+  sqlite3_stmt *pTmpInsert;       /* Insert into rbu_tmp_$zDataTbl */
 
   /* Last UPDATE used (for PK b-tree updates only), or NULL. */
   RbuUpdateStmt *pRbuUpdate;
@@ -157662,6 +159150,252 @@ struct rbu_file {
 };
 
 
+/*************************************************************************
+** The following three functions, found below:
+**
+**   rbuDeltaGetInt()
+**   rbuDeltaChecksum()
+**   rbuDeltaApply()
+**
+** are lifted from the fossil source code (http://fossil-scm.org). They
+** are used to implement the scalar SQL function rbu_fossil_delta().
+*/
+
+/*
+** Read bytes from *pz and convert them into a positive integer.  When
+** finished, leave *pz pointing to the first character past the end of
+** the integer.  The *pLen parameter holds the length of the string
+** in *pz and is decremented once for each character in the integer.
+*/
+static unsigned int rbuDeltaGetInt(const char **pz, int *pLen){
+  static const signed char zValue[] = {
+    -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
+     0,  1,  2,  3,  4,  5,  6,  7,    8,  9, -1, -1, -1, -1, -1, -1,
+    -1, 10, 11, 12, 13, 14, 15, 16,   17, 18, 19, 20, 21, 22, 23, 24,
+    25, 26, 27, 28, 29, 30, 31, 32,   33, 34, 35, -1, -1, -1, -1, 36,
+    -1, 37, 38, 39, 40, 41, 42, 43,   44, 45, 46, 47, 48, 49, 50, 51,
+    52, 53, 54, 55, 56, 57, 58, 59,   60, 61, 62, -1, -1, -1, 63, -1,
+  };
+  unsigned int v = 0;
+  int c;
+  unsigned char *z = (unsigned char*)*pz;
+  unsigned char *zStart = z;
+  while( (c = zValue[0x7f&*(z++)])>=0 ){
+     v = (v<<6) + c;
+  }
+  z--;
+  *pLen -= z - zStart;
+  *pz = (char*)z;
+  return v;
+}
+
+/*
+** Compute a 32-bit checksum on the N-byte buffer.  Return the result.
+*/
+static unsigned int rbuDeltaChecksum(const char *zIn, size_t N){
+  const unsigned char *z = (const unsigned char *)zIn;
+  unsigned sum0 = 0;
+  unsigned sum1 = 0;
+  unsigned sum2 = 0;
+  unsigned sum3 = 0;
+  while(N >= 16){
+    sum0 += ((unsigned)z[0] + z[4] + z[8] + z[12]);
+    sum1 += ((unsigned)z[1] + z[5] + z[9] + z[13]);
+    sum2 += ((unsigned)z[2] + z[6] + z[10]+ z[14]);
+    sum3 += ((unsigned)z[3] + z[7] + z[11]+ z[15]);
+    z += 16;
+    N -= 16;
+  }
+  while(N >= 4){
+    sum0 += z[0];
+    sum1 += z[1];
+    sum2 += z[2];
+    sum3 += z[3];
+    z += 4;
+    N -= 4;
+  }
+  sum3 += (sum2 << 8) + (sum1 << 16) + (sum0 << 24);
+  switch(N){
+    case 3:   sum3 += (z[2] << 8);
+    case 2:   sum3 += (z[1] << 16);
+    case 1:   sum3 += (z[0] << 24);
+    default:  ;
+  }
+  return sum3;
+}
+
+/*
+** Apply a delta.
+**
+** The output buffer should be big enough to hold the whole output
+** file and a NUL terminator at the end.  The delta_output_size()
+** routine will determine this size for you.
+**
+** The delta string should be null-terminated.  But the delta string
+** may contain embedded NUL characters (if the input and output are
+** binary files) so we also have to pass in the length of the delta in
+** the lenDelta parameter.
+**
+** This function returns the size of the output file in bytes (excluding
+** the final NUL terminator character).  Except, if the delta string is
+** malformed or intended for use with a source file other than zSrc,
+** then this routine returns -1.
+**
+** Refer to the delta_create() documentation above for a description
+** of the delta file format.
+*/
+static int rbuDeltaApply(
+  const char *zSrc,      /* The source or pattern file */
+  int lenSrc,            /* Length of the source file */
+  const char *zDelta,    /* Delta to apply to the pattern */
+  int lenDelta,          /* Length of the delta */
+  char *zOut             /* Write the output into this preallocated buffer */
+){
+  unsigned int limit;
+  unsigned int total = 0;
+#ifndef FOSSIL_OMIT_DELTA_CKSUM_TEST
+  char *zOrigOut = zOut;
+#endif
+
+  limit = rbuDeltaGetInt(&zDelta, &lenDelta);
+  if( *zDelta!='\n' ){
+    /* ERROR: size integer not terminated by "\n" */
+    return -1;
+  }
+  zDelta++; lenDelta--;
+  while( *zDelta && lenDelta>0 ){
+    unsigned int cnt, ofst;
+    cnt = rbuDeltaGetInt(&zDelta, &lenDelta);
+    switch( zDelta[0] ){
+      case '@': {
+        zDelta++; lenDelta--;
+        ofst = rbuDeltaGetInt(&zDelta, &lenDelta);
+        if( lenDelta>0 && zDelta[0]!=',' ){
+          /* ERROR: copy command not terminated by ',' */
+          return -1;
+        }
+        zDelta++; lenDelta--;
+        total += cnt;
+        if( total>limit ){
+          /* ERROR: copy exceeds output file size */
+          return -1;
+        }
+        if( (int)(ofst+cnt) > lenSrc ){
+          /* ERROR: copy extends past end of input */
+          return -1;
+        }
+        memcpy(zOut, &zSrc[ofst], cnt);
+        zOut += cnt;
+        break;
+      }
+      case ':': {
+        zDelta++; lenDelta--;
+        total += cnt;
+        if( total>limit ){
+          /* ERROR:  insert command gives an output larger than predicted */
+          return -1;
+        }
+        if( (int)cnt>lenDelta ){
+          /* ERROR: insert count exceeds size of delta */
+          return -1;
+        }
+        memcpy(zOut, zDelta, cnt);
+        zOut += cnt;
+        zDelta += cnt;
+        lenDelta -= cnt;
+        break;
+      }
+      case ';': {
+        zDelta++; lenDelta--;
+        zOut[0] = 0;
+#ifndef FOSSIL_OMIT_DELTA_CKSUM_TEST
+        if( cnt!=rbuDeltaChecksum(zOrigOut, total) ){
+          /* ERROR:  bad checksum */
+          return -1;
+        }
+#endif
+        if( total!=limit ){
+          /* ERROR: generated size does not match predicted size */
+          return -1;
+        }
+        return total;
+      }
+      default: {
+        /* ERROR: unknown delta operator */
+        return -1;
+      }
+    }
+  }
+  /* ERROR: unterminated delta */
+  return -1;
+}
+
+static int rbuDeltaOutputSize(const char *zDelta, int lenDelta){
+  int size;
+  size = rbuDeltaGetInt(&zDelta, &lenDelta);
+  if( *zDelta!='\n' ){
+    /* ERROR: size integer not terminated by "\n" */
+    return -1;
+  }
+  return size;
+}
+
+/*
+** End of code taken from fossil.
+*************************************************************************/
+
+/*
+** Implementation of SQL scalar function rbu_fossil_delta().
+**
+** This function applies a fossil delta patch to a blob. Exactly two
+** arguments must be passed to this function. The first is the blob to
+** patch and the second the patch to apply. If no error occurs, this
+** function returns the patched blob.
+*/
+static void rbuFossilDeltaFunc(
+  sqlite3_context *context,
+  int argc,
+  sqlite3_value **argv
+){
+  const char *aDelta;
+  int nDelta;
+  const char *aOrig;
+  int nOrig;
+
+  int nOut;
+  int nOut2;
+  char *aOut;
+
+  assert( argc==2 );
+
+  nOrig = sqlite3_value_bytes(argv[0]);
+  aOrig = (const char*)sqlite3_value_blob(argv[0]);
+  nDelta = sqlite3_value_bytes(argv[1]);
+  aDelta = (const char*)sqlite3_value_blob(argv[1]);
+
+  /* Figure out the size of the output */
+  nOut = rbuDeltaOutputSize(aDelta, nDelta);
+  if( nOut<0 ){
+    sqlite3_result_error(context, "corrupt fossil delta", -1);
+    return;
+  }
+
+  aOut = sqlite3_malloc(nOut+1);
+  if( aOut==0 ){
+    sqlite3_result_error_nomem(context);
+  }else{
+    nOut2 = rbuDeltaApply(aOrig, nOrig, aDelta, nDelta, aOut);
+    if( nOut2!=nOut ){
+      sqlite3_result_error(context, "corrupt fossil delta", -1);
+    }else{
+      sqlite3_result_blob(context, aOut, nOut, sqlite3_free);
+    }
+  }
+}
+
+
 /*
 ** Prepare the SQL statement in buffer zSql against database handle db.
 ** If successful, set *ppStmt to point to the new statement and return
@@ -157828,7 +159562,8 @@ static int rbuObjIterNext(sqlite3rbu *p, RbuObjIter *pIter){
           pIter->zTbl = 0;
         }else{
           pIter->zTbl = (const char*)sqlite3_column_text(pIter->pTblIter, 0);
-          rc = pIter->zTbl ? SQLITE_OK : SQLITE_NOMEM;
+          pIter->zDataTbl = (const char*)sqlite3_column_text(pIter->pTblIter,1);
+          rc = (pIter->zDataTbl && pIter->zTbl) ? SQLITE_OK : SQLITE_NOMEM;
         }
       }else{
         if( pIter->zIdx==0 ){
@@ -157859,6 +159594,40 @@ static int rbuObjIterNext(sqlite3rbu *p, RbuObjIter *pIter){
   return rc;
 }
 
+
+/*
+** The implementation of the rbu_target_name() SQL function. This function
+** accepts one argument - the name of a table in the RBU database. If the
+** table name matches the pattern:
+**
+**     data[0-9]_<name>
+**
+** where <name> is any sequence of 1 or more characters, <name> is returned.
+** Otherwise, if the only argument does not match the above pattern, an SQL
+** NULL is returned.
+**
+**     "data_t1"     -> "t1"
+**     "data0123_t2" -> "t2"
+**     "dataAB_t3"   -> NULL
+*/
+static void rbuTargetNameFunc(
+  sqlite3_context *context,
+  int argc,
+  sqlite3_value **argv
+){
+  const char *zIn;
+  assert( argc==1 );
+
+  zIn = (const char*)sqlite3_value_text(argv[0]);
+  if( zIn && strlen(zIn)>4 && memcmp("data", zIn, 4)==0 ){
+    int i;
+    for(i=4; zIn[i]>='0' && zIn[i]<='9'; i++);
+    if( zIn[i]=='_' && zIn[i+1] ){
+      sqlite3_result_text(context, &zIn[i+1], -1, SQLITE_STATIC);
+    }
+  }
+}
+
 /*
 ** Initialize the iterator structure passed as the second argument.
 **
@@ -157872,8 +159641,9 @@ static int rbuObjIterFirst(sqlite3rbu *p, RbuObjIter *pIter){
   memset(pIter, 0, sizeof(RbuObjIter));
 
   rc = prepareAndCollectError(p->dbRbu, &pIter->pTblIter, &p->zErrmsg, 
-      "SELECT substr(name, 6) FROM sqlite_master "
-      "WHERE type IN ('table', 'view') AND name LIKE 'data_%'"
+      "SELECT rbu_target_name(name) AS target, name FROM sqlite_master "
+      "WHERE type IN ('table', 'view') AND target IS NOT NULL "
+      "ORDER BY name"
   );
 
   if( rc==SQLITE_OK ){
@@ -158140,7 +159910,7 @@ static void rbuTableType(
   }
 
 rbuTableType_end: {
-    int i;
+    unsigned int i;
     for(i=0; i<sizeof(aStmt)/sizeof(aStmt[0]); i++){
       rbuFinalize(p, aStmt[i]);
     }
@@ -158219,7 +159989,7 @@ static int rbuObjIterCacheTableInfo(sqlite3rbu *p, RbuObjIter *pIter){
     ** of the input table. Ignore any input table columns that begin with
     ** "rbu_".  */
     p->rc = prepareFreeAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg, 
-        sqlite3_mprintf("SELECT * FROM 'data_%q'", pIter->zTbl)
+        sqlite3_mprintf("SELECT * FROM '%q'", pIter->zDataTbl)
     );
     if( p->rc==SQLITE_OK ){
       nCol = sqlite3_column_count(pStmt);
@@ -158244,7 +160014,7 @@ static int rbuObjIterCacheTableInfo(sqlite3rbu *p, RbuObjIter *pIter){
     ){
       p->rc = SQLITE_ERROR;
       p->zErrmsg = sqlite3_mprintf(
-          "table data_%q %s rbu_rowid column", pIter->zTbl,
+          "table %q %s rbu_rowid column", pIter->zDataTbl,
           (bRbuRowid ? "may not have" : "requires")
       );
     }
@@ -158265,8 +160035,8 @@ static int rbuObjIterCacheTableInfo(sqlite3rbu *p, RbuObjIter *pIter){
       }
       if( i==pIter->nTblCol ){
         p->rc = SQLITE_ERROR;
-        p->zErrmsg = sqlite3_mprintf("column missing from data_%q: %s",
-            pIter->zTbl, zName
+        p->zErrmsg = sqlite3_mprintf("column missing from %q: %s",
+            pIter->zDataTbl, zName
         );
       }else{
         int iPk = sqlite3_column_int(pStmt, 5);
@@ -158553,7 +160323,7 @@ static char *rbuObjIterGetSetlist(
   if( p->rc==SQLITE_OK ){
     int i;
 
-    if( strlen(zMask)!=pIter->nTblCol ){
+    if( (int)strlen(zMask)!=pIter->nTblCol ){
       rbuBadControlError(p);
     }else{
       const char *zSep = "";
@@ -158565,12 +160335,18 @@ static char *rbuObjIterGetSetlist(
           );
           zSep = ", ";
         }
-        if( c=='d' ){
+        else if( c=='d' ){
           zList = rbuMPrintf(p, "%z%s\"%w\"=rbu_delta(\"%w\", ?%d)", 
               zList, zSep, pIter->azTblCol[i], pIter->azTblCol[i], i+1
           );
           zSep = ", ";
         }
+        else if( c=='f' ){
+          zList = rbuMPrintf(p, "%z%s\"%w\"=rbu_fossil_delta(\"%w\", ?%d)", 
+              zList, zSep, pIter->azTblCol[i], pIter->azTblCol[i], i+1
+          );
+          zSep = ", ";
+        }
       }
     }
   }
@@ -158821,7 +160597,7 @@ static void rbuObjIterPrepareTmpInsert(
     p->rc = prepareFreeAndCollectError(
         p->dbRbu, &pIter->pTmpInsert, &p->zErrmsg, sqlite3_mprintf(
           "INSERT INTO %s.'rbu_tmp_%q'(rbu_control,%s%s) VALUES(%z)", 
-          p->zStateDb, pIter->zTbl, zCollist, zRbuRowid, zBind
+          p->zStateDb, pIter->zDataTbl, zCollist, zRbuRowid, zBind
     ));
   }
 }
@@ -158917,18 +160693,18 @@ static int rbuObjIterPrepareAll(
         if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){
           zSql = sqlite3_mprintf(
               "SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' ORDER BY %s%s",
-              zCollist, p->zStateDb, pIter->zTbl,
+              zCollist, p->zStateDb, pIter->zDataTbl,
               zCollist, zLimit
           );
         }else{
           zSql = sqlite3_mprintf(
-              "SELECT %s, rbu_control FROM 'data_%q' "
+              "SELECT %s, rbu_control FROM '%q' "
               "WHERE typeof(rbu_control)='integer' AND rbu_control!=1 "
               "UNION ALL "
               "SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' "
               "ORDER BY %s%s",
-              zCollist, pIter->zTbl, 
-              zCollist, p->zStateDb, pIter->zTbl, 
+              zCollist, pIter->zDataTbl, 
+              zCollist, p->zStateDb, pIter->zDataTbl, 
               zCollist, zLimit
           );
         }
@@ -158952,16 +160728,6 @@ static int rbuObjIterPrepareAll(
       zCollist = rbuObjIterGetCollist(p, pIter);
       pIter->nCol = pIter->nTblCol;
 
-      /* Create the SELECT statement to read keys from data_xxx */
-      if( p->rc==SQLITE_OK ){
-        p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,
-            sqlite3_mprintf(
-              "SELECT %s, rbu_control%s FROM 'data_%q'%s", 
-              zCollist, (bRbuRowid ? ", rbu_rowid" : ""), zTbl, zLimit
-            )
-        );
-      }
-
       /* Create the imposter table or tables (if required). */
       rbuCreateImposterTable(p, pIter);
       rbuCreateImposterTable2(p, pIter);
@@ -158995,10 +160761,10 @@ static int rbuObjIterPrepareAll(
         /* Create the rbu_tmp_xxx table and the triggers to populate it. */
         rbuMPrintfExec(p, p->dbRbu,
             "CREATE TABLE IF NOT EXISTS %s.'rbu_tmp_%q' AS "
-            "SELECT *%s FROM 'data_%q' WHERE 0;"
-            , p->zStateDb
-            , zTbl, (pIter->eType==RBU_PK_EXTERNAL ? ", 0 AS rbu_rowid" : "")
-            , zTbl
+            "SELECT *%s FROM '%q' WHERE 0;"
+            , p->zStateDb, pIter->zDataTbl
+            , (pIter->eType==RBU_PK_EXTERNAL ? ", 0 AS rbu_rowid" : "")
+            , pIter->zDataTbl
         );
 
         rbuMPrintfExec(p, p->dbMain,
@@ -159034,6 +160800,17 @@ static int rbuObjIterPrepareAll(
         rbuObjIterPrepareTmpInsert(p, pIter, zCollist, zRbuRowid);
       }
 
+      /* Create the SELECT statement to read keys from data_xxx */
+      if( p->rc==SQLITE_OK ){
+        p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,
+            sqlite3_mprintf(
+              "SELECT %s, rbu_control%s FROM '%q'%s", 
+              zCollist, (bRbuRowid ? ", rbu_rowid" : ""), 
+              pIter->zDataTbl, zLimit
+            )
+        );
+      }
+
       sqlite3_free(zWhere);
       sqlite3_free(zOldlist);
       sqlite3_free(zNewlist);
@@ -159164,6 +160941,18 @@ static void rbuOpenDatabase(sqlite3rbu *p){
     );
   }
 
+  if( p->rc==SQLITE_OK ){
+    p->rc = sqlite3_create_function(p->dbMain, 
+        "rbu_fossil_delta", 2, SQLITE_UTF8, 0, rbuFossilDeltaFunc, 0, 0
+    );
+  }
+
+  if( p->rc==SQLITE_OK ){
+    p->rc = sqlite3_create_function(p->dbRbu, 
+        "rbu_target_name", 1, SQLITE_UTF8, (void*)p, rbuTargetNameFunc, 0, 0
+    );
+  }
+
   if( p->rc==SQLITE_OK ){
     p->rc = sqlite3_file_control(p->dbMain, "main", SQLITE_FCNTL_RBU, (void*)p);
   }
@@ -159386,6 +161175,30 @@ static void rbuLockDatabase(sqlite3rbu *p){
   }
 }
 
+#if defined(_WIN32_WCE)
+static LPWSTR rbuWinUtf8ToUnicode(const char *zFilename){
+  int nChar;
+  LPWSTR zWideFilename;
+
+  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0);
+  if( nChar==0 ){
+    return 0;
+  }
+  zWideFilename = sqlite3_malloc( nChar*sizeof(zWideFilename[0]) );
+  if( zWideFilename==0 ){
+    return 0;
+  }
+  memset(zWideFilename, 0, nChar*sizeof(zWideFilename[0]));
+  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename,
+                                nChar);
+  if( nChar==0 ){
+    sqlite3_free(zWideFilename);
+    zWideFilename = 0;
+  }
+  return zWideFilename;
+}
+#endif
+
 /*
 ** The RBU handle is currently in RBU_STAGE_OAL state, with a SHARED lock
 ** on the database file. This proc moves the *-oal file to the *-wal path,
@@ -159420,10 +161233,37 @@ static void rbuMoveOalFile(sqlite3rbu *p){
       rbuObjIterFinalize(&p->objiter);
       sqlite3_close(p->dbMain);
       sqlite3_close(p->dbRbu);
+      p->dbMain = 0;
+      p->dbRbu = 0;
+
+#if defined(_WIN32_WCE)
+      {
+        LPWSTR zWideOal;
+        LPWSTR zWideWal;
+
+        zWideOal = rbuWinUtf8ToUnicode(zOal);
+        if( zWideOal ){
+          zWideWal = rbuWinUtf8ToUnicode(zWal);
+          if( zWideWal ){
+            if( MoveFileW(zWideOal, zWideWal) ){
+              p->rc = SQLITE_OK;
+            }else{
+              p->rc = SQLITE_IOERR;
+            }
+            sqlite3_free(zWideWal);
+          }else{
+            p->rc = SQLITE_IOERR_NOMEM;
+          }
+          sqlite3_free(zWideOal);
+        }else{
+          p->rc = SQLITE_IOERR_NOMEM;
+        }
+      }
+#else
       p->rc = rename(zOal, zWal) ? SQLITE_IOERR : SQLITE_OK;
+#endif
+
       if( p->rc==SQLITE_OK ){
-        p->dbMain = 0;
-        p->dbRbu = 0;
         rbuOpenDatabase(p);
         rbuSetupCheckpoint(p, 0);
       }
@@ -159593,7 +161433,7 @@ static int rbuStep(sqlite3rbu *p){
         for(i=0; p->rc==SQLITE_OK && i<pIter->nCol; i++){
           char c = zMask[pIter->aiSrcOrder[i]];
           pVal = sqlite3_column_value(pIter->pSelect, i);
-          if( pIter->abTblPk[i] || c=='x' || c=='d' ){
+          if( pIter->abTblPk[i] || c!='.' ){
             p->rc = sqlite3_bind_value(pUpdate, i+1, pVal);
           }
         }
@@ -159705,7 +161545,7 @@ SQLITE_API int SQLITE_STDCALL sqlite3rbu_step(sqlite3rbu *p){
             ** But the contents can be deleted.  */
             if( pIter->abIndexed ){
               rbuMPrintfExec(p, p->dbRbu, 
-                  "DELETE FROM %s.'rbu_tmp_%q'", p->zStateDb, pIter->zTbl
+                  "DELETE FROM %s.'rbu_tmp_%q'", p->zStateDb, pIter->zDataTbl
               );
             }
           }else{
@@ -159928,10 +161768,13 @@ static void rbuSetupOal(sqlite3rbu *p, RbuState *pState){
 ** leave an error code and error message in the rbu handle.
 */
 static void rbuDeleteOalFile(sqlite3rbu *p){
-  char *zOal = sqlite3_mprintf("%s-oal", p->zTarget);
-  assert( p->rc==SQLITE_OK && p->zErrmsg==0 );
-  unlink(zOal);
-  sqlite3_free(zOal);
+  char *zOal = rbuMPrintf(p, "%s-oal", p->zTarget);
+  if( zOal ){
+    sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
+    assert( pVfs && p->rc==SQLITE_OK && p->zErrmsg==0 );
+    pVfs->xDelete(pVfs, zOal, 0);
+    sqlite3_free(zOal);
+  }
 }
 
 /*
@@ -160044,14 +161887,25 @@ SQLITE_API sqlite3rbu *SQLITE_STDCALL sqlite3rbu_open(
 
     if( p->rc==SQLITE_OK ){
       if( p->eStage==RBU_STAGE_OAL ){
+        sqlite3 *db = p->dbMain;
 
         /* Open transactions both databases. The *-oal file is opened or
         ** created at this point. */
-        p->rc = sqlite3_exec(p->dbMain, "BEGIN IMMEDIATE", 0, 0, &p->zErrmsg);
+        p->rc = sqlite3_exec(db, "BEGIN IMMEDIATE", 0, 0, &p->zErrmsg);
         if( p->rc==SQLITE_OK ){
           p->rc = sqlite3_exec(p->dbRbu, "BEGIN IMMEDIATE", 0, 0, &p->zErrmsg);
         }
-  
+
+        /* Check if the main database is a zipvfs db. If it is, set the upper
+        ** level pager to use "journal_mode=off". This prevents it from 
+        ** generating a large journal using a temp file.  */
+        if( p->rc==SQLITE_OK ){
+          int frc = sqlite3_file_control(db, "main", SQLITE_FCNTL_ZIPVFS, 0);
+          if( frc==SQLITE_OK ){
+            p->rc = sqlite3_exec(db, "PRAGMA journal_mode=off",0,0,&p->zErrmsg);
+          }
+        }
+
         /* Point the object iterator at the first object */
         if( p->rc==SQLITE_OK ){
           p->rc = rbuObjIterFirst(p, &p->objiter);
@@ -160165,6 +162019,32 @@ SQLITE_API sqlite3_int64 SQLITE_STDCALL sqlite3rbu_progress(sqlite3rbu *pRbu){
   return pRbu->nProgress;
 }
 
+SQLITE_API int SQLITE_STDCALL sqlite3rbu_savestate(sqlite3rbu *p){
+  int rc = p->rc;
+  
+  if( rc==SQLITE_DONE ) return SQLITE_OK;
+
+  assert( p->eStage>=RBU_STAGE_OAL && p->eStage<=RBU_STAGE_DONE );
+  if( p->eStage==RBU_STAGE_OAL ){
+    assert( rc!=SQLITE_DONE );
+    if( rc==SQLITE_OK ) rc = sqlite3_exec(p->dbMain, "COMMIT", 0, 0, 0);
+  }
+
+  p->rc = rc;
+  rbuSaveState(p, p->eStage);
+  rc = p->rc;
+
+  if( p->eStage==RBU_STAGE_OAL ){
+    assert( rc!=SQLITE_DONE );
+    if( rc==SQLITE_OK ) rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, 0);
+    if( rc==SQLITE_OK ) rc = sqlite3_exec(p->dbRbu, "BEGIN IMMEDIATE", 0, 0, 0);
+    if( rc==SQLITE_OK ) rc = sqlite3_exec(p->dbMain, "BEGIN IMMEDIATE", 0, 0,0);
+  }
+
+  p->rc = rc;
+  return rc;
+}
+
 /**************************************************************************
 ** Beginning of RBU VFS shim methods. The VFS shim modifies the behaviour
 ** of a standard VFS in the following ways:
@@ -160644,7 +162524,8 @@ static int rbuVfsOpen(
     rbuVfsShmMap,                 /* xShmMap */
     rbuVfsShmLock,                /* xShmLock */
     rbuVfsShmBarrier,             /* xShmBarrier */
-    rbuVfsShmUnmap                /* xShmUnmap */
+    rbuVfsShmUnmap,               /* xShmUnmap */
+    0, 0                          /* xFetch, xUnfetch */
   };
   rbu_vfs *pRbuVfs = (rbu_vfs*)pVfs;
   sqlite3_vfs *pRealVfs = pRbuVfs->pRealVfs;
@@ -160986,6 +162867,9 @@ SQLITE_API int SQLITE_STDCALL sqlite3rbu_create_vfs(const char *zName, const cha
 ** information from an SQLite database in order to implement the
 ** "sqlite3_analyzer" utility.  See the ../tool/spaceanal.tcl script
 ** for an example implementation.
+**
+** Additional information is available on the "dbstat.html" page of the
+** official SQLite documentation.
 */
 
 /* #include "sqliteInt.h"   ** Requires access to internal data structures ** */
@@ -161034,7 +162918,8 @@ SQLITE_API int SQLITE_STDCALL sqlite3rbu_create_vfs(const char *zName, const cha
   "  unused     INTEGER,          /* Bytes of unused space on this page */" \
   "  mx_payload INTEGER,          /* Largest payload size of all cells */"  \
   "  pgoffset   INTEGER,          /* Offset of page in file */"             \
-  "  pgsize     INTEGER           /* Size of the page */"                   \
+  "  pgsize     INTEGER,          /* Size of the page */"                   \
+  "  schema     TEXT HIDDEN       /* Database schema being analyzed */"     \
   ");"
 
 
@@ -161072,6 +162957,7 @@ struct StatCursor {
   sqlite3_vtab_cursor base;
   sqlite3_stmt *pStmt;            /* Iterates through set of root pages */
   int isEof;                      /* After pStmt has returned SQLITE_DONE */
+  int iDb;                        /* Schema used for this query */
 
   StatPage aPage[32];
   int iPage;                      /* Current entry in aPage[] */
@@ -161149,9 +163035,32 @@ static int statDisconnect(sqlite3_vtab *pVtab){
 
 /*
 ** There is no "best-index". This virtual table always does a linear
-** scan of the binary VFS log file.
+** scan.  However, a schema=? constraint should cause this table to
+** operate on a different database schema, so check for it.
+**
+** idxNum is normally 0, but will be 1 if a schema=? constraint exists.
 */
 static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
+  int i;
+
+  pIdxInfo->estimatedCost = 1.0e6;  /* Initial cost estimate */
+
+  /* Look for a valid schema=? constraint.  If found, change the idxNum to
+  ** 1 and request the value of that constraint be sent to xFilter.  And
+  ** lower the cost estimate to encourage the constrained version to be
+  ** used.
+  */
+  for(i=0; i<pIdxInfo->nConstraint; i++){
+    if( pIdxInfo->aConstraint[i].usable==0 ) continue;
+    if( pIdxInfo->aConstraint[i].op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;
+    if( pIdxInfo->aConstraint[i].iColumn!=10 ) continue;
+    pIdxInfo->idxNum = 1;
+    pIdxInfo->estimatedCost = 1.0;
+    pIdxInfo->aConstraintUsage[i].argvIndex = 1;
+    pIdxInfo->aConstraintUsage[i].omit = 1;
+    break;
+  }
+
 
   /* Records are always returned in ascending order of (name, path). 
   ** If this will satisfy the client, set the orderByConsumed flag so that 
@@ -161171,7 +163080,6 @@ static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
     pIdxInfo->orderByConsumed = 1;
   }
 
-  pIdxInfo->estimatedCost = 10.0;
   return SQLITE_OK;
 }
 
@@ -161181,36 +163089,18 @@ static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
 static int statOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
   StatTable *pTab = (StatTable *)pVTab;
   StatCursor *pCsr;
-  int rc;
 
   pCsr = (StatCursor *)sqlite3_malloc64(sizeof(StatCursor));
   if( pCsr==0 ){
-    rc = SQLITE_NOMEM;
+    return SQLITE_NOMEM;
   }else{
-    char *zSql;
     memset(pCsr, 0, sizeof(StatCursor));
     pCsr->base.pVtab = pVTab;
-
-    zSql = sqlite3_mprintf(
-        "SELECT 'sqlite_master' AS name, 1 AS rootpage, 'table' AS type"
-        "  UNION ALL  "
-        "SELECT name, rootpage, type"
-        "  FROM \"%w\".sqlite_master WHERE rootpage!=0"
-        "  ORDER BY name", pTab->db->aDb[pTab->iDb].zName);
-    if( zSql==0 ){
-      rc = SQLITE_NOMEM;
-    }else{
-      rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pStmt, 0);
-      sqlite3_free(zSql);
-    }
-    if( rc!=SQLITE_OK ){
-      sqlite3_free(pCsr);
-      pCsr = 0;
-    }
+    pCsr->iDb = pTab->iDb;
   }
 
   *ppCursor = (sqlite3_vtab_cursor *)pCsr;
-  return rc;
+  return SQLITE_OK;
 }
 
 static void statClearPage(StatPage *p){
@@ -161235,6 +163125,7 @@ static void statResetCsr(StatCursor *pCsr){
   pCsr->iPage = 0;
   sqlite3_free(pCsr->zPath);
   pCsr->zPath = 0;
+  pCsr->isEof = 0;
 }
 
 /*
@@ -161397,7 +163288,7 @@ static int statNext(sqlite3_vtab_cursor *pCursor){
   char *z;
   StatCursor *pCsr = (StatCursor *)pCursor;
   StatTable *pTab = (StatTable *)pCursor->pVtab;
-  Btree *pBt = pTab->db->aDb[pTab->iDb].pBt;
+  Btree *pBt = pTab->db->aDb[pCsr->iDb].pBt;
   Pager *pPager = sqlite3BtreePager(pBt);
 
   sqlite3_free(pCsr->zPath);
@@ -161535,9 +163426,43 @@ static int statFilter(
   int argc, sqlite3_value **argv
 ){
   StatCursor *pCsr = (StatCursor *)pCursor;
+  StatTable *pTab = (StatTable*)(pCursor->pVtab);
+  char *zSql;
+  int rc = SQLITE_OK;
+  char *zMaster;
 
+  if( idxNum==1 ){
+    const char *zDbase = (const char*)sqlite3_value_text(argv[0]);
+    pCsr->iDb = sqlite3FindDbName(pTab->db, zDbase);
+    if( pCsr->iDb<0 ){
+      sqlite3_free(pCursor->pVtab->zErrMsg);
+      pCursor->pVtab->zErrMsg = sqlite3_mprintf("no such schema: %s", zDbase);
+      return pCursor->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;
+    }
+  }else{
+    pCsr->iDb = pTab->iDb;
+  }
   statResetCsr(pCsr);
-  return statNext(pCursor);
+  sqlite3_finalize(pCsr->pStmt);
+  pCsr->pStmt = 0;
+  zMaster = pCsr->iDb==1 ? "sqlite_temp_master" : "sqlite_master";
+  zSql = sqlite3_mprintf(
+      "SELECT 'sqlite_master' AS name, 1 AS rootpage, 'table' AS type"
+      "  UNION ALL  "
+      "SELECT name, rootpage, type"
+      "  FROM \"%w\".%s WHERE rootpage!=0"
+      "  ORDER BY name", pTab->db->aDb[pCsr->iDb].zName, zMaster);
+  if( zSql==0 ){
+    return SQLITE_NOMEM;
+  }else{
+    rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pStmt, 0);
+    sqlite3_free(zSql);
+  }
+
+  if( rc==SQLITE_OK ){
+    rc = statNext(pCursor);
+  }
+  return rc;
 }
 
 static int statColumn(
@@ -161574,10 +163499,15 @@ static int statColumn(
     case 8:            /* pgoffset */
       sqlite3_result_int64(ctx, pCsr->iOffset);
       break;
-    default:           /* pgsize */
-      assert( i==9 );
+    case 9:            /* pgsize */
       sqlite3_result_int(ctx, pCsr->szPage);
       break;
+    default: {          /* schema */
+      sqlite3 *db = sqlite3_context_db_handle(ctx);
+      int iDb = pCsr->iDb;
+      sqlite3_result_text(ctx, db->aDb[iDb].zName, -1, SQLITE_STATIC);
+      break;
+    }
   }
   return SQLITE_OK;
 }
@@ -161621,3 +163551,20702 @@ SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3 *db){ return SQLITE_OK; }
 #endif /* SQLITE_ENABLE_DBSTAT_VTAB */
 
 /************** End of dbstat.c **********************************************/
+/************** Begin file json1.c *******************************************/
+/*
+** 2015-08-12
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** This SQLite extension implements JSON functions.  The interface is
+** modeled after MySQL JSON functions:
+**
+**     https://dev.mysql.com/doc/refman/5.7/en/json.html
+**
+** For the time being, all JSON is stored as pure text.  (We might add
+** a JSONB type in the future which stores a binary encoding of JSON in
+** a BLOB, but there is no support for JSONB in the current implementation.
+** This implementation parses JSON text at 250 MB/s, so it is hard to see
+** how JSONB might improve on that.)
+*/
+#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_JSON1)
+#if !defined(_SQLITEINT_H_)
+/* #include "sqlite3ext.h" */
+#endif
+SQLITE_EXTENSION_INIT1
+/* #include <assert.h> */
+/* #include <string.h> */
+/* #include <stdlib.h> */
+/* #include <stdarg.h> */
+
+#define UNUSED_PARAM(X)  (void)(X)
+
+#ifndef LARGEST_INT64
+# define LARGEST_INT64  (0xffffffff|(((sqlite3_int64)0x7fffffff)<<32))
+# define SMALLEST_INT64 (((sqlite3_int64)-1) - LARGEST_INT64)
+#endif
+
+/*
+** Versions of isspace(), isalnum() and isdigit() to which it is safe
+** to pass signed char values.
+*/
+#ifdef sqlite3Isdigit
+   /* Use the SQLite core versions if this routine is part of the
+   ** SQLite amalgamation */
+#  define safe_isdigit(x) sqlite3Isdigit(x)
+#  define safe_isalnum(x) sqlite3Isalnum(x)
+#else
+   /* Use the standard library for separate compilation */
+#include <ctype.h>  /* amalgamator: keep */
+#  define safe_isdigit(x) isdigit((unsigned char)(x))
+#  define safe_isalnum(x) isalnum((unsigned char)(x))
+#endif
+
+/*
+** Growing our own isspace() routine this way is twice as fast as
+** the library isspace() function, resulting in a 7% overall performance
+** increase for the parser.  (Ubuntu14.10 gcc 4.8.4 x64 with -Os).
+*/
+static const char jsonIsSpace[] = {
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 1, 1, 0, 0, 1, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  1, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,
+};
+#define safe_isspace(x) (jsonIsSpace[(unsigned char)x])
+
+#ifndef SQLITE_AMALGAMATION
+  /* Unsigned integer types.  These are already defined in the sqliteInt.h,
+  ** but the definitions need to be repeated for separate compilation. */
+  typedef sqlite3_uint64 u64;
+  typedef unsigned int u32;
+  typedef unsigned char u8;
+#endif
+
+/* Objects */
+typedef struct JsonString JsonString;
+typedef struct JsonNode JsonNode;
+typedef struct JsonParse JsonParse;
+
+/* An instance of this object represents a JSON string
+** under construction.  Really, this is a generic string accumulator
+** that can be and is used to create strings other than JSON.
+*/
+struct JsonString {
+  sqlite3_context *pCtx;   /* Function context - put error messages here */
+  char *zBuf;              /* Append JSON content here */
+  u64 nAlloc;              /* Bytes of storage available in zBuf[] */
+  u64 nUsed;               /* Bytes of zBuf[] currently used */
+  u8 bStatic;              /* True if zBuf is static space */
+  u8 bErr;                 /* True if an error has been encountered */
+  char zSpace[100];        /* Initial static space */
+};
+
+/* JSON type values
+*/
+#define JSON_NULL     0
+#define JSON_TRUE     1
+#define JSON_FALSE    2
+#define JSON_INT      3
+#define JSON_REAL     4
+#define JSON_STRING   5
+#define JSON_ARRAY    6
+#define JSON_OBJECT   7
+
+/* The "subtype" set for JSON values */
+#define JSON_SUBTYPE  74    /* Ascii for "J" */
+
+/*
+** Names of the various JSON types:
+*/
+static const char * const jsonType[] = {
+  "null", "true", "false", "integer", "real", "text", "array", "object"
+};
+
+/* Bit values for the JsonNode.jnFlag field
+*/
+#define JNODE_RAW     0x01         /* Content is raw, not JSON encoded */
+#define JNODE_ESCAPE  0x02         /* Content is text with \ escapes */
+#define JNODE_REMOVE  0x04         /* Do not output */
+#define JNODE_REPLACE 0x08         /* Replace with JsonNode.iVal */
+#define JNODE_APPEND  0x10         /* More ARRAY/OBJECT entries at u.iAppend */
+#define JNODE_LABEL   0x20         /* Is a label of an object */
+
+
+/* A single node of parsed JSON
+*/
+struct JsonNode {
+  u8 eType;              /* One of the JSON_ type values */
+  u8 jnFlags;            /* JNODE flags */
+  u8 iVal;               /* Replacement value when JNODE_REPLACE */
+  u32 n;                 /* Bytes of content, or number of sub-nodes */
+  union {
+    const char *zJContent; /* Content for INT, REAL, and STRING */
+    u32 iAppend;           /* More terms for ARRAY and OBJECT */
+    u32 iKey;              /* Key for ARRAY objects in json_tree() */
+  } u;
+};
+
+/* A completely parsed JSON string
+*/
+struct JsonParse {
+  u32 nNode;         /* Number of slots of aNode[] used */
+  u32 nAlloc;        /* Number of slots of aNode[] allocated */
+  JsonNode *aNode;   /* Array of nodes containing the parse */
+  const char *zJson; /* Original JSON string */
+  u32 *aUp;          /* Index of parent of each node */
+  u8 oom;            /* Set to true if out of memory */
+  u8 nErr;           /* Number of errors seen */
+};
+
+/**************************************************************************
+** Utility routines for dealing with JsonString objects
+**************************************************************************/
+
+/* Set the JsonString object to an empty string
+*/
+static void jsonZero(JsonString *p){
+  p->zBuf = p->zSpace;
+  p->nAlloc = sizeof(p->zSpace);
+  p->nUsed = 0;
+  p->bStatic = 1;
+}
+
+/* Initialize the JsonString object
+*/
+static void jsonInit(JsonString *p, sqlite3_context *pCtx){
+  p->pCtx = pCtx;
+  p->bErr = 0;
+  jsonZero(p);
+}
+
+
+/* Free all allocated memory and reset the JsonString object back to its
+** initial state.
+*/
+static void jsonReset(JsonString *p){
+  if( !p->bStatic ) sqlite3_free(p->zBuf);
+  jsonZero(p);
+}
+
+
+/* Report an out-of-memory (OOM) condition 
+*/
+static void jsonOom(JsonString *p){
+  p->bErr = 1;
+  sqlite3_result_error_nomem(p->pCtx);
+  jsonReset(p);
+}
+
+/* Enlarge pJson->zBuf so that it can hold at least N more bytes.
+** Return zero on success.  Return non-zero on an OOM error
+*/
+static int jsonGrow(JsonString *p, u32 N){
+  u64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;
+  char *zNew;
+  if( p->bStatic ){
+    if( p->bErr ) return 1;
+    zNew = sqlite3_malloc64(nTotal);
+    if( zNew==0 ){
+      jsonOom(p);
+      return SQLITE_NOMEM;
+    }
+    memcpy(zNew, p->zBuf, (size_t)p->nUsed);
+    p->zBuf = zNew;
+    p->bStatic = 0;
+  }else{
+    zNew = sqlite3_realloc64(p->zBuf, nTotal);
+    if( zNew==0 ){
+      jsonOom(p);
+      return SQLITE_NOMEM;
+    }
+    p->zBuf = zNew;
+  }
+  p->nAlloc = nTotal;
+  return SQLITE_OK;
+}
+
+/* Append N bytes from zIn onto the end of the JsonString string.
+*/
+static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){
+  if( (N+p->nUsed >= p->nAlloc) && jsonGrow(p,N)!=0 ) return;
+  memcpy(p->zBuf+p->nUsed, zIn, N);
+  p->nUsed += N;
+}
+
+/* Append formatted text (not to exceed N bytes) to the JsonString.
+*/
+static void jsonPrintf(int N, JsonString *p, const char *zFormat, ...){
+  va_list ap;
+  if( (p->nUsed + N >= p->nAlloc) && jsonGrow(p, N) ) return;
+  va_start(ap, zFormat);
+  sqlite3_vsnprintf(N, p->zBuf+p->nUsed, zFormat, ap);
+  va_end(ap);
+  p->nUsed += (int)strlen(p->zBuf+p->nUsed);
+}
+
+/* Append a single character
+*/
+static void jsonAppendChar(JsonString *p, char c){
+  if( p->nUsed>=p->nAlloc && jsonGrow(p,1)!=0 ) return;
+  p->zBuf[p->nUsed++] = c;
+}
+
+/* Append a comma separator to the output buffer, if the previous
+** character is not '[' or '{'.
+*/
+static void jsonAppendSeparator(JsonString *p){
+  char c;
+  if( p->nUsed==0 ) return;
+  c = p->zBuf[p->nUsed-1];
+  if( c!='[' && c!='{' ) jsonAppendChar(p, ',');
+}
+
+/* Append the N-byte string in zIn to the end of the JsonString string
+** under construction.  Enclose the string in "..." and escape
+** any double-quotes or backslash characters contained within the
+** string.
+*/
+static void jsonAppendString(JsonString *p, const char *zIn, u32 N){
+  u32 i;
+  if( (N+p->nUsed+2 >= p->nAlloc) && jsonGrow(p,N+2)!=0 ) return;
+  p->zBuf[p->nUsed++] = '"';
+  for(i=0; i<N; i++){
+    char c = zIn[i];
+    if( c=='"' || c=='\\' ){
+      if( (p->nUsed+N+3-i > p->nAlloc) && jsonGrow(p,N+3-i)!=0 ) return;
+      p->zBuf[p->nUsed++] = '\\';
+    }
+    p->zBuf[p->nUsed++] = c;
+  }
+  p->zBuf[p->nUsed++] = '"';
+  assert( p->nUsed<p->nAlloc );
+}
+
+/*
+** Append a function parameter value to the JSON string under 
+** construction.
+*/
+static void jsonAppendValue(
+  JsonString *p,                 /* Append to this JSON string */
+  sqlite3_value *pValue          /* Value to append */
+){
+  switch( sqlite3_value_type(pValue) ){
+    case SQLITE_NULL: {
+      jsonAppendRaw(p, "null", 4);
+      break;
+    }
+    case SQLITE_INTEGER:
+    case SQLITE_FLOAT: {
+      const char *z = (const char*)sqlite3_value_text(pValue);
+      u32 n = (u32)sqlite3_value_bytes(pValue);
+      jsonAppendRaw(p, z, n);
+      break;
+    }
+    case SQLITE_TEXT: {
+      const char *z = (const char*)sqlite3_value_text(pValue);
+      u32 n = (u32)sqlite3_value_bytes(pValue);
+      if( sqlite3_value_subtype(pValue)==JSON_SUBTYPE ){
+        jsonAppendRaw(p, z, n);
+      }else{
+        jsonAppendString(p, z, n);
+      }
+      break;
+    }
+    default: {
+      if( p->bErr==0 ){
+        sqlite3_result_error(p->pCtx, "JSON cannot hold BLOB values", -1);
+        p->bErr = 1;
+        jsonReset(p);
+      }
+      break;
+    }
+  }
+}
+
+
+/* Make the JSON in p the result of the SQL function.
+*/
+static void jsonResult(JsonString *p){
+  if( p->bErr==0 ){
+    sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed, 
+                          p->bStatic ? SQLITE_TRANSIENT : sqlite3_free,
+                          SQLITE_UTF8);
+    jsonZero(p);
+  }
+  assert( p->bStatic );
+}
+
+/**************************************************************************
+** Utility routines for dealing with JsonNode and JsonParse objects
+**************************************************************************/
+
+/*
+** Return the number of consecutive JsonNode slots need to represent
+** the parsed JSON at pNode.  The minimum answer is 1.  For ARRAY and
+** OBJECT types, the number might be larger.
+**
+** Appended elements are not counted.  The value returned is the number
+** by which the JsonNode counter should increment in order to go to the
+** next peer value.
+*/
+static u32 jsonNodeSize(JsonNode *pNode){
+  return pNode->eType>=JSON_ARRAY ? pNode->n+1 : 1;
+}
+
+/*
+** Reclaim all memory allocated by a JsonParse object.  But do not
+** delete the JsonParse object itself.
+*/
+static void jsonParseReset(JsonParse *pParse){
+  sqlite3_free(pParse->aNode);
+  pParse->aNode = 0;
+  pParse->nNode = 0;
+  pParse->nAlloc = 0;
+  sqlite3_free(pParse->aUp);
+  pParse->aUp = 0;
+}
+
+/*
+** Convert the JsonNode pNode into a pure JSON string and
+** append to pOut.  Subsubstructure is also included.  Return
+** the number of JsonNode objects that are encoded.
+*/
+static void jsonRenderNode(
+  JsonNode *pNode,               /* The node to render */
+  JsonString *pOut,              /* Write JSON here */
+  sqlite3_value **aReplace       /* Replacement values */
+){
+  switch( pNode->eType ){
+    default: {
+      assert( pNode->eType==JSON_NULL );
+      jsonAppendRaw(pOut, "null", 4);
+      break;
+    }
+    case JSON_TRUE: {
+      jsonAppendRaw(pOut, "true", 4);
+      break;
+    }
+    case JSON_FALSE: {
+      jsonAppendRaw(pOut, "false", 5);
+      break;
+    }
+    case JSON_STRING: {
+      if( pNode->jnFlags & JNODE_RAW ){
+        jsonAppendString(pOut, pNode->u.zJContent, pNode->n);
+        break;
+      }
+      /* Fall through into the next case */
+    }
+    case JSON_REAL:
+    case JSON_INT: {
+      jsonAppendRaw(pOut, pNode->u.zJContent, pNode->n);
+      break;
+    }
+    case JSON_ARRAY: {
+      u32 j = 1;
+      jsonAppendChar(pOut, '[');
+      for(;;){
+        while( j<=pNode->n ){
+          if( pNode[j].jnFlags & (JNODE_REMOVE|JNODE_REPLACE) ){
+            if( pNode[j].jnFlags & JNODE_REPLACE ){
+              jsonAppendSeparator(pOut);
+              jsonAppendValue(pOut, aReplace[pNode[j].iVal]);
+            }
+          }else{
+            jsonAppendSeparator(pOut);
+            jsonRenderNode(&pNode[j], pOut, aReplace);
+          }
+          j += jsonNodeSize(&pNode[j]);
+        }
+        if( (pNode->jnFlags & JNODE_APPEND)==0 ) break;
+        pNode = &pNode[pNode->u.iAppend];
+        j = 1;
+      }
+      jsonAppendChar(pOut, ']');
+      break;
+    }
+    case JSON_OBJECT: {
+      u32 j = 1;
+      jsonAppendChar(pOut, '{');
+      for(;;){
+        while( j<=pNode->n ){
+          if( (pNode[j+1].jnFlags & JNODE_REMOVE)==0 ){
+            jsonAppendSeparator(pOut);
+            jsonRenderNode(&pNode[j], pOut, aReplace);
+            jsonAppendChar(pOut, ':');
+            if( pNode[j+1].jnFlags & JNODE_REPLACE ){
+              jsonAppendValue(pOut, aReplace[pNode[j+1].iVal]);
+            }else{
+              jsonRenderNode(&pNode[j+1], pOut, aReplace);
+            }
+          }
+          j += 1 + jsonNodeSize(&pNode[j+1]);
+        }
+        if( (pNode->jnFlags & JNODE_APPEND)==0 ) break;
+        pNode = &pNode[pNode->u.iAppend];
+        j = 1;
+      }
+      jsonAppendChar(pOut, '}');
+      break;
+    }
+  }
+}
+
+/*
+** Return a JsonNode and all its descendents as a JSON string.
+*/
+static void jsonReturnJson(
+  JsonNode *pNode,            /* Node to return */
+  sqlite3_context *pCtx,      /* Return value for this function */
+  sqlite3_value **aReplace    /* Array of replacement values */
+){
+  JsonString s;
+  jsonInit(&s, pCtx);
+  jsonRenderNode(pNode, &s, aReplace);
+  jsonResult(&s);
+  sqlite3_result_subtype(pCtx, JSON_SUBTYPE);
+}
+
+/*
+** Make the JsonNode the return value of the function.
+*/
+static void jsonReturn(
+  JsonNode *pNode,            /* Node to return */
+  sqlite3_context *pCtx,      /* Return value for this function */
+  sqlite3_value **aReplace    /* Array of replacement values */
+){
+  switch( pNode->eType ){
+    default: {
+      assert( pNode->eType==JSON_NULL );
+      sqlite3_result_null(pCtx);
+      break;
+    }
+    case JSON_TRUE: {
+      sqlite3_result_int(pCtx, 1);
+      break;
+    }
+    case JSON_FALSE: {
+      sqlite3_result_int(pCtx, 0);
+      break;
+    }
+    case JSON_INT: {
+      sqlite3_int64 i = 0;
+      const char *z = pNode->u.zJContent;
+      if( z[0]=='-' ){ z++; }
+      while( z[0]>='0' && z[0]<='9' ){
+        unsigned v = *(z++) - '0';
+        if( i>=LARGEST_INT64/10 ){
+          if( i>LARGEST_INT64/10 ) goto int_as_real;
+          if( z[0]>='0' && z[0]<='9' ) goto int_as_real;
+          if( v==9 ) goto int_as_real;
+          if( v==8 ){
+            if( pNode->u.zJContent[0]=='-' ){
+              sqlite3_result_int64(pCtx, SMALLEST_INT64);
+              goto int_done;
+            }else{
+              goto int_as_real;
+            }
+          }
+        }
+        i = i*10 + v;
+      }
+      if( pNode->u.zJContent[0]=='-' ){ i = -i; }
+      sqlite3_result_int64(pCtx, i);
+      int_done:
+      break;
+      int_as_real: /* fall through to real */;
+    }
+    case JSON_REAL: {
+      double r;
+#ifdef SQLITE_AMALGAMATION
+      const char *z = pNode->u.zJContent;
+      sqlite3AtoF(z, &r, sqlite3Strlen30(z), SQLITE_UTF8);
+#else
+      r = strtod(pNode->u.zJContent, 0);
+#endif
+      sqlite3_result_double(pCtx, r);
+      break;
+    }
+    case JSON_STRING: {
+#if 0 /* Never happens because JNODE_RAW is only set by json_set(),
+      ** json_insert() and json_replace() and those routines do not
+      ** call jsonReturn() */
+      if( pNode->jnFlags & JNODE_RAW ){
+        sqlite3_result_text(pCtx, pNode->u.zJContent, pNode->n,
+                            SQLITE_TRANSIENT);
+      }else 
+#endif
+      assert( (pNode->jnFlags & JNODE_RAW)==0 );
+      if( (pNode->jnFlags & JNODE_ESCAPE)==0 ){
+        /* JSON formatted without any backslash-escapes */
+        sqlite3_result_text(pCtx, pNode->u.zJContent+1, pNode->n-2,
+                            SQLITE_TRANSIENT);
+      }else{
+        /* Translate JSON formatted string into raw text */
+        u32 i;
+        u32 n = pNode->n;
+        const char *z = pNode->u.zJContent;
+        char *zOut;
+        u32 j;
+        zOut = sqlite3_malloc( n+1 );
+        if( zOut==0 ){
+          sqlite3_result_error_nomem(pCtx);
+          break;
+        }
+        for(i=1, j=0; i<n-1; i++){
+          char c = z[i];
+          if( c!='\\' ){
+            zOut[j++] = c;
+          }else{
+            c = z[++i];
+            if( c=='u' ){
+              u32 v = 0, k;
+              for(k=0; k<4 && i<n-2; i++, k++){
+                c = z[i+1];
+                if( c>='0' && c<='9' ) v = v*16 + c - '0';
+                else if( c>='A' && c<='F' ) v = v*16 + c - 'A' + 10;
+                else if( c>='a' && c<='f' ) v = v*16 + c - 'a' + 10;
+                else break;
+              }
+              if( v==0 ) break;
+              if( v<=0x7f ){
+                zOut[j++] = (char)v;
+              }else if( v<=0x7ff ){
+                zOut[j++] = (char)(0xc0 | (v>>6));
+                zOut[j++] = 0x80 | (v&0x3f);
+              }else{
+                zOut[j++] = (char)(0xe0 | (v>>12));
+                zOut[j++] = 0x80 | ((v>>6)&0x3f);
+                zOut[j++] = 0x80 | (v&0x3f);
+              }
+            }else{
+              if( c=='b' ){
+                c = '\b';
+              }else if( c=='f' ){
+                c = '\f';
+              }else if( c=='n' ){
+                c = '\n';
+              }else if( c=='r' ){
+                c = '\r';
+              }else if( c=='t' ){
+                c = '\t';
+              }
+              zOut[j++] = c;
+            }
+          }
+        }
+        zOut[j] = 0;
+        sqlite3_result_text(pCtx, zOut, j, sqlite3_free);
+      }
+      break;
+    }
+    case JSON_ARRAY:
+    case JSON_OBJECT: {
+      jsonReturnJson(pNode, pCtx, aReplace);
+      break;
+    }
+  }
+}
+
+/* Forward reference */
+static int jsonParseAddNode(JsonParse*,u32,u32,const char*);
+
+/*
+** A macro to hint to the compiler that a function should not be
+** inlined.
+*/
+#if defined(__GNUC__)
+#  define JSON_NOINLINE  __attribute__((noinline))
+#elif defined(_MSC_VER) && _MSC_VER>=1310
+#  define JSON_NOINLINE  __declspec(noinline)
+#else
+#  define JSON_NOINLINE
+#endif
+
+
+static JSON_NOINLINE int jsonParseAddNodeExpand(
+  JsonParse *pParse,        /* Append the node to this object */
+  u32 eType,                /* Node type */
+  u32 n,                    /* Content size or sub-node count */
+  const char *zContent      /* Content */
+){
+  u32 nNew;
+  JsonNode *pNew;
+  assert( pParse->nNode>=pParse->nAlloc );
+  if( pParse->oom ) return -1;
+  nNew = pParse->nAlloc*2 + 10;
+  pNew = sqlite3_realloc(pParse->aNode, sizeof(JsonNode)*nNew);
+  if( pNew==0 ){
+    pParse->oom = 1;
+    return -1;
+  }
+  pParse->nAlloc = nNew;
+  pParse->aNode = pNew;
+  assert( pParse->nNode<pParse->nAlloc );
+  return jsonParseAddNode(pParse, eType, n, zContent);
+}
+
+/*
+** Create a new JsonNode instance based on the arguments and append that
+** instance to the JsonParse.  Return the index in pParse->aNode[] of the
+** new node, or -1 if a memory allocation fails.
+*/
+static int jsonParseAddNode(
+  JsonParse *pParse,        /* Append the node to this object */
+  u32 eType,                /* Node type */
+  u32 n,                    /* Content size or sub-node count */
+  const char *zContent      /* Content */
+){
+  JsonNode *p;
+  if( pParse->nNode>=pParse->nAlloc ){
+    return jsonParseAddNodeExpand(pParse, eType, n, zContent);
+  }
+  p = &pParse->aNode[pParse->nNode];
+  p->eType = (u8)eType;
+  p->jnFlags = 0;
+  p->iVal = 0;
+  p->n = n;
+  p->u.zJContent = zContent;
+  return pParse->nNode++;
+}
+
+/*
+** Parse a single JSON value which begins at pParse->zJson[i].  Return the
+** index of the first character past the end of the value parsed.
+**
+** Return negative for a syntax error.  Special cases:  return -2 if the
+** first non-whitespace character is '}' and return -3 if the first
+** non-whitespace character is ']'.
+*/
+static int jsonParseValue(JsonParse *pParse, u32 i){
+  char c;
+  u32 j;
+  int iThis;
+  int x;
+  JsonNode *pNode;
+  while( safe_isspace(pParse->zJson[i]) ){ i++; }
+  if( (c = pParse->zJson[i])=='{' ){
+    /* Parse object */
+    iThis = jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);
+    if( iThis<0 ) return -1;
+    for(j=i+1;;j++){
+      while( safe_isspace(pParse->zJson[j]) ){ j++; }
+      x = jsonParseValue(pParse, j);
+      if( x<0 ){
+        if( x==(-2) && pParse->nNode==(u32)iThis+1 ) return j+1;
+        return -1;
+      }
+      if( pParse->oom ) return -1;
+      pNode = &pParse->aNode[pParse->nNode-1];
+      if( pNode->eType!=JSON_STRING ) return -1;
+      pNode->jnFlags |= JNODE_LABEL;
+      j = x;
+      while( safe_isspace(pParse->zJson[j]) ){ j++; }
+      if( pParse->zJson[j]!=':' ) return -1;
+      j++;
+      x = jsonParseValue(pParse, j);
+      if( x<0 ) return -1;
+      j = x;
+      while( safe_isspace(pParse->zJson[j]) ){ j++; }
+      c = pParse->zJson[j];
+      if( c==',' ) continue;
+      if( c!='}' ) return -1;
+      break;
+    }
+    pParse->aNode[iThis].n = pParse->nNode - (u32)iThis - 1;
+    return j+1;
+  }else if( c=='[' ){
+    /* Parse array */
+    iThis = jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);
+    if( iThis<0 ) return -1;
+    for(j=i+1;;j++){
+      while( safe_isspace(pParse->zJson[j]) ){ j++; }
+      x = jsonParseValue(pParse, j);
+      if( x<0 ){
+        if( x==(-3) && pParse->nNode==(u32)iThis+1 ) return j+1;
+        return -1;
+      }
+      j = x;
+      while( safe_isspace(pParse->zJson[j]) ){ j++; }
+      c = pParse->zJson[j];
+      if( c==',' ) continue;
+      if( c!=']' ) return -1;
+      break;
+    }
+    pParse->aNode[iThis].n = pParse->nNode - (u32)iThis - 1;
+    return j+1;
+  }else if( c=='"' ){
+    /* Parse string */
+    u8 jnFlags = 0;
+    j = i+1;
+    for(;;){
+      c = pParse->zJson[j];
+      if( c==0 ) return -1;
+      if( c=='\\' ){
+        c = pParse->zJson[++j];
+        if( c==0 ) return -1;
+        jnFlags = JNODE_ESCAPE;
+      }else if( c=='"' ){
+        break;
+      }
+      j++;
+    }
+    jsonParseAddNode(pParse, JSON_STRING, j+1-i, &pParse->zJson[i]);
+    if( !pParse->oom ) pParse->aNode[pParse->nNode-1].jnFlags = jnFlags;
+    return j+1;
+  }else if( c=='n'
+         && strncmp(pParse->zJson+i,"null",4)==0
+         && !safe_isalnum(pParse->zJson[i+4]) ){
+    jsonParseAddNode(pParse, JSON_NULL, 0, 0);
+    return i+4;
+  }else if( c=='t'
+         && strncmp(pParse->zJson+i,"true",4)==0
+         && !safe_isalnum(pParse->zJson[i+4]) ){
+    jsonParseAddNode(pParse, JSON_TRUE, 0, 0);
+    return i+4;
+  }else if( c=='f'
+         && strncmp(pParse->zJson+i,"false",5)==0
+         && !safe_isalnum(pParse->zJson[i+5]) ){
+    jsonParseAddNode(pParse, JSON_FALSE, 0, 0);
+    return i+5;
+  }else if( c=='-' || (c>='0' && c<='9') ){
+    /* Parse number */
+    u8 seenDP = 0;
+    u8 seenE = 0;
+    j = i+1;
+    for(;; j++){
+      c = pParse->zJson[j];
+      if( c>='0' && c<='9' ) continue;
+      if( c=='.' ){
+        if( pParse->zJson[j-1]=='-' ) return -1;
+        if( seenDP ) return -1;
+        seenDP = 1;
+        continue;
+      }
+      if( c=='e' || c=='E' ){
+        if( pParse->zJson[j-1]<'0' ) return -1;
+        if( seenE ) return -1;
+        seenDP = seenE = 1;
+        c = pParse->zJson[j+1];
+        if( c=='+' || c=='-' ){
+          j++;
+          c = pParse->zJson[j+1];
+        }
+        if( c<'0' || c>'9' ) return -1;
+        continue;
+      }
+      break;
+    }
+    if( pParse->zJson[j-1]<'0' ) return -1;
+    jsonParseAddNode(pParse, seenDP ? JSON_REAL : JSON_INT,
+                        j - i, &pParse->zJson[i]);
+    return j;
+  }else if( c=='}' ){
+    return -2;  /* End of {...} */
+  }else if( c==']' ){
+    return -3;  /* End of [...] */
+  }else if( c==0 ){
+    return 0;   /* End of file */
+  }else{
+    return -1;  /* Syntax error */
+  }
+}
+
+/*
+** Parse a complete JSON string.  Return 0 on success or non-zero if there
+** are any errors.  If an error occurs, free all memory associated with
+** pParse.
+**
+** pParse is uninitialized when this routine is called.
+*/
+static int jsonParse(
+  JsonParse *pParse,           /* Initialize and fill this JsonParse object */
+  sqlite3_context *pCtx,       /* Report errors here */
+  const char *zJson            /* Input JSON text to be parsed */
+){
+  int i;
+  memset(pParse, 0, sizeof(*pParse));
+  if( zJson==0 ) return 1;
+  pParse->zJson = zJson;
+  i = jsonParseValue(pParse, 0);
+  if( pParse->oom ) i = -1;
+  if( i>0 ){
+    while( safe_isspace(zJson[i]) ) i++;
+    if( zJson[i] ) i = -1;
+  }
+  if( i<=0 ){
+    if( pCtx!=0 ){
+      if( pParse->oom ){
+        sqlite3_result_error_nomem(pCtx);
+      }else{
+        sqlite3_result_error(pCtx, "malformed JSON", -1);
+      }
+    }
+    jsonParseReset(pParse);
+    return 1;
+  }
+  return 0;
+}
+
+/* Mark node i of pParse as being a child of iParent.  Call recursively
+** to fill in all the descendants of node i.
+*/
+static void jsonParseFillInParentage(JsonParse *pParse, u32 i, u32 iParent){
+  JsonNode *pNode = &pParse->aNode[i];
+  u32 j;
+  pParse->aUp[i] = iParent;
+  switch( pNode->eType ){
+    case JSON_ARRAY: {
+      for(j=1; j<=pNode->n; j += jsonNodeSize(pNode+j)){
+        jsonParseFillInParentage(pParse, i+j, i);
+      }
+      break;
+    }
+    case JSON_OBJECT: {
+      for(j=1; j<=pNode->n; j += jsonNodeSize(pNode+j+1)+1){
+        pParse->aUp[i+j] = i;
+        jsonParseFillInParentage(pParse, i+j+1, i);
+      }
+      break;
+    }
+    default: {
+      break;
+    }
+  }
+}
+
+/*
+** Compute the parentage of all nodes in a completed parse.
+*/
+static int jsonParseFindParents(JsonParse *pParse){
+  u32 *aUp;
+  assert( pParse->aUp==0 );
+  aUp = pParse->aUp = sqlite3_malloc( sizeof(u32)*pParse->nNode );
+  if( aUp==0 ){
+    pParse->oom = 1;
+    return SQLITE_NOMEM;
+  }
+  jsonParseFillInParentage(pParse, 0, 0);
+  return SQLITE_OK;
+}
+
+/*
+** Compare the OBJECT label at pNode against zKey,nKey.  Return true on
+** a match.
+*/
+static int jsonLabelCompare(JsonNode *pNode, const char *zKey, u32 nKey){
+  if( pNode->jnFlags & JNODE_RAW ){
+    if( pNode->n!=nKey ) return 0;
+    return strncmp(pNode->u.zJContent, zKey, nKey)==0;
+  }else{
+    if( pNode->n!=nKey+2 ) return 0;
+    return strncmp(pNode->u.zJContent+1, zKey, nKey)==0;
+  }
+}
+
+/* forward declaration */
+static JsonNode *jsonLookupAppend(JsonParse*,const char*,int*,const char**);
+
+/*
+** Search along zPath to find the node specified.  Return a pointer
+** to that node, or NULL if zPath is malformed or if there is no such
+** node.
+**
+** If pApnd!=0, then try to append new nodes to complete zPath if it is
+** possible to do so and if no existing node corresponds to zPath.  If
+** new nodes are appended *pApnd is set to 1.
+*/
+static JsonNode *jsonLookupStep(
+  JsonParse *pParse,      /* The JSON to search */
+  u32 iRoot,              /* Begin the search at this node */
+  const char *zPath,      /* The path to search */
+  int *pApnd,             /* Append nodes to complete path if not NULL */
+  const char **pzErr      /* Make *pzErr point to any syntax error in zPath */
+){
+  u32 i, j, nKey;
+  const char *zKey;
+  JsonNode *pRoot = &pParse->aNode[iRoot];
+  if( zPath[0]==0 ) return pRoot;
+  if( zPath[0]=='.' ){
+    if( pRoot->eType!=JSON_OBJECT ) return 0;
+    zPath++;
+    if( zPath[0]=='"' ){
+      zKey = zPath + 1;
+      for(i=1; zPath[i] && zPath[i]!='"'; i++){}
+      nKey = i-1;
+      if( zPath[i] ){
+        i++;
+      }else{
+        *pzErr = zPath;
+        return 0;
+      }
+    }else{
+      zKey = zPath;
+      for(i=0; zPath[i] && zPath[i]!='.' && zPath[i]!='['; i++){}
+      nKey = i;
+    }
+    if( nKey==0 ){
+      *pzErr = zPath;
+      return 0;
+    }
+    j = 1;
+    for(;;){
+      while( j<=pRoot->n ){
+        if( jsonLabelCompare(pRoot+j, zKey, nKey) ){
+          return jsonLookupStep(pParse, iRoot+j+1, &zPath[i], pApnd, pzErr);
+        }
+        j++;
+        j += jsonNodeSize(&pRoot[j]);
+      }
+      if( (pRoot->jnFlags & JNODE_APPEND)==0 ) break;
+      iRoot += pRoot->u.iAppend;
+      pRoot = &pParse->aNode[iRoot];
+      j = 1;
+    }
+    if( pApnd ){
+      u32 iStart, iLabel;
+      JsonNode *pNode;
+      iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);
+      iLabel = jsonParseAddNode(pParse, JSON_STRING, i, zPath);
+      zPath += i;
+      pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
+      if( pParse->oom ) return 0;
+      if( pNode ){
+        pRoot = &pParse->aNode[iRoot];
+        pRoot->u.iAppend = iStart - iRoot;
+        pRoot->jnFlags |= JNODE_APPEND;
+        pParse->aNode[iLabel].jnFlags |= JNODE_RAW;
+      }
+      return pNode;
+    }
+  }else if( zPath[0]=='[' && safe_isdigit(zPath[1]) ){
+    if( pRoot->eType!=JSON_ARRAY ) return 0;
+    i = 0;
+    j = 1;
+    while( safe_isdigit(zPath[j]) ){
+      i = i*10 + zPath[j] - '0';
+      j++;
+    }
+    if( zPath[j]!=']' ){
+      *pzErr = zPath;
+      return 0;
+    }
+    zPath += j + 1;
+    j = 1;
+    for(;;){
+      while( j<=pRoot->n && (i>0 || (pRoot[j].jnFlags & JNODE_REMOVE)!=0) ){
+        if( (pRoot[j].jnFlags & JNODE_REMOVE)==0 ) i--;
+        j += jsonNodeSize(&pRoot[j]);
+      }
+      if( (pRoot->jnFlags & JNODE_APPEND)==0 ) break;
+      iRoot += pRoot->u.iAppend;
+      pRoot = &pParse->aNode[iRoot];
+      j = 1;
+    }
+    if( j<=pRoot->n ){
+      return jsonLookupStep(pParse, iRoot+j, zPath, pApnd, pzErr);
+    }
+    if( i==0 && pApnd ){
+      u32 iStart;
+      JsonNode *pNode;
+      iStart = jsonParseAddNode(pParse, JSON_ARRAY, 1, 0);
+      pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);
+      if( pParse->oom ) return 0;
+      if( pNode ){
+        pRoot = &pParse->aNode[iRoot];
+        pRoot->u.iAppend = iStart - iRoot;
+        pRoot->jnFlags |= JNODE_APPEND;
+      }
+      return pNode;
+    }
+  }else{
+    *pzErr = zPath;
+  }
+  return 0;
+}
+
+/*
+** Append content to pParse that will complete zPath.  Return a pointer
+** to the inserted node, or return NULL if the append fails.
+*/
+static JsonNode *jsonLookupAppend(
+  JsonParse *pParse,     /* Append content to the JSON parse */
+  const char *zPath,     /* Description of content to append */
+  int *pApnd,            /* Set this flag to 1 */
+  const char **pzErr     /* Make this point to any syntax error */
+){
+  *pApnd = 1;
+  if( zPath[0]==0 ){
+    jsonParseAddNode(pParse, JSON_NULL, 0, 0);
+    return pParse->oom ? 0 : &pParse->aNode[pParse->nNode-1];
+  }
+  if( zPath[0]=='.' ){
+    jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);
+  }else if( strncmp(zPath,"[0]",3)==0 ){
+    jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);
+  }else{
+    return 0;
+  }
+  if( pParse->oom ) return 0;
+  return jsonLookupStep(pParse, pParse->nNode-1, zPath, pApnd, pzErr);
+}
+
+/*
+** Return the text of a syntax error message on a JSON path.  Space is
+** obtained from sqlite3_malloc().
+*/
+static char *jsonPathSyntaxError(const char *zErr){
+  return sqlite3_mprintf("JSON path error near '%q'", zErr);
+}
+
+/*
+** Do a node lookup using zPath.  Return a pointer to the node on success.
+** Return NULL if not found or if there is an error.
+**
+** On an error, write an error message into pCtx and increment the
+** pParse->nErr counter.
+**
+** If pApnd!=NULL then try to append missing nodes and set *pApnd = 1 if
+** nodes are appended.
+*/
+static JsonNode *jsonLookup(
+  JsonParse *pParse,      /* The JSON to search */
+  const char *zPath,      /* The path to search */
+  int *pApnd,             /* Append nodes to complete path if not NULL */
+  sqlite3_context *pCtx   /* Report errors here, if not NULL */
+){
+  const char *zErr = 0;
+  JsonNode *pNode = 0;
+  char *zMsg;
+
+  if( zPath==0 ) return 0;
+  if( zPath[0]!='$' ){
+    zErr = zPath;
+    goto lookup_err;
+  }
+  zPath++;
+  pNode = jsonLookupStep(pParse, 0, zPath, pApnd, &zErr);
+  if( zErr==0 ) return pNode;
+
+lookup_err:
+  pParse->nErr++;
+  assert( zErr!=0 && pCtx!=0 );
+  zMsg = jsonPathSyntaxError(zErr);
+  if( zMsg ){
+    sqlite3_result_error(pCtx, zMsg, -1);
+    sqlite3_free(zMsg);
+  }else{
+    sqlite3_result_error_nomem(pCtx);
+  }
+  return 0;
+}
+
+
+/*
+** Report the wrong number of arguments for json_insert(), json_replace()
+** or json_set().
+*/
+static void jsonWrongNumArgs(
+  sqlite3_context *pCtx,
+  const char *zFuncName
+){
+  char *zMsg = sqlite3_mprintf("json_%s() needs an odd number of arguments",
+                               zFuncName);
+  sqlite3_result_error(pCtx, zMsg, -1);
+  sqlite3_free(zMsg);     
+}
+
+
+/****************************************************************************
+** SQL functions used for testing and debugging
+****************************************************************************/
+
+#ifdef SQLITE_DEBUG
+/*
+** The json_parse(JSON) function returns a string which describes
+** a parse of the JSON provided.  Or it returns NULL if JSON is not
+** well-formed.
+*/
+static void jsonParseFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  JsonString s;       /* Output string - not real JSON */
+  JsonParse x;        /* The parse */
+  u32 i;
+
+  assert( argc==1 );
+  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
+  jsonParseFindParents(&x);
+  jsonInit(&s, ctx);
+  for(i=0; i<x.nNode; i++){
+    const char *zType;
+    if( x.aNode[i].jnFlags & JNODE_LABEL ){
+      assert( x.aNode[i].eType==JSON_STRING );
+      zType = "label";
+    }else{
+      zType = jsonType[x.aNode[i].eType];
+    }
+    jsonPrintf(100, &s,"node %3u: %7s n=%-4d up=%-4d",
+               i, zType, x.aNode[i].n, x.aUp[i]);
+    if( x.aNode[i].u.zJContent!=0 ){
+      jsonAppendRaw(&s, " ", 1);
+      jsonAppendRaw(&s, x.aNode[i].u.zJContent, x.aNode[i].n);
+    }
+    jsonAppendRaw(&s, "\n", 1);
+  }
+  jsonParseReset(&x);
+  jsonResult(&s);
+}
+
+/*
+** The json_test1(JSON) function return true (1) if the input is JSON
+** text generated by another json function.  It returns (0) if the input
+** is not known to be JSON.
+*/
+static void jsonTest1Func(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  UNUSED_PARAM(argc);
+  sqlite3_result_int(ctx, sqlite3_value_subtype(argv[0])==JSON_SUBTYPE);
+}
+#endif /* SQLITE_DEBUG */
+
+/****************************************************************************
+** SQL function implementations
+****************************************************************************/
+
+/*
+** Implementation of the json_array(VALUE,...) function.  Return a JSON
+** array that contains all values given in arguments.  Or if any argument
+** is a BLOB, throw an error.
+*/
+static void jsonArrayFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  int i;
+  JsonString jx;
+
+  jsonInit(&jx, ctx);
+  jsonAppendChar(&jx, '[');
+  for(i=0; i<argc; i++){
+    jsonAppendSeparator(&jx);
+    jsonAppendValue(&jx, argv[i]);
+  }
+  jsonAppendChar(&jx, ']');
+  jsonResult(&jx);
+  sqlite3_result_subtype(ctx, JSON_SUBTYPE);
+}
+
+
+/*
+** json_array_length(JSON)
+** json_array_length(JSON, PATH)
+**
+** Return the number of elements in the top-level JSON array.  
+** Return 0 if the input is not a well-formed JSON array.
+*/
+static void jsonArrayLengthFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  JsonParse x;          /* The parse */
+  sqlite3_int64 n = 0;
+  u32 i;
+  JsonNode *pNode;
+
+  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
+  assert( x.nNode );
+  if( argc==2 ){
+    const char *zPath = (const char*)sqlite3_value_text(argv[1]);
+    pNode = jsonLookup(&x, zPath, 0, ctx);
+  }else{
+    pNode = x.aNode;
+  }
+  if( pNode==0 ){
+    x.nErr = 1;
+  }else if( pNode->eType==JSON_ARRAY ){
+    assert( (pNode->jnFlags & JNODE_APPEND)==0 );
+    for(i=1; i<=pNode->n; n++){
+      i += jsonNodeSize(&pNode[i]);
+    }
+  }
+  if( x.nErr==0 ) sqlite3_result_int64(ctx, n);
+  jsonParseReset(&x);
+}
+
+/*
+** json_extract(JSON, PATH, ...)
+**
+** Return the element described by PATH.  Return NULL if there is no
+** PATH element.  If there are multiple PATHs, then return a JSON array
+** with the result from each path.  Throw an error if the JSON or any PATH
+** is malformed.
+*/
+static void jsonExtractFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  JsonParse x;          /* The parse */
+  JsonNode *pNode;
+  const char *zPath;
+  JsonString jx;
+  int i;
+
+  if( argc<2 ) return;
+  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
+  jsonInit(&jx, ctx);
+  jsonAppendChar(&jx, '[');
+  for(i=1; i<argc; i++){
+    zPath = (const char*)sqlite3_value_text(argv[i]);
+    pNode = jsonLookup(&x, zPath, 0, ctx);
+    if( x.nErr ) break;
+    if( argc>2 ){
+      jsonAppendSeparator(&jx);
+      if( pNode ){
+        jsonRenderNode(pNode, &jx, 0);
+      }else{
+        jsonAppendRaw(&jx, "null", 4);
+      }
+    }else if( pNode ){
+      jsonReturn(pNode, ctx, 0);
+    }
+  }
+  if( argc>2 && i==argc ){
+    jsonAppendChar(&jx, ']');
+    jsonResult(&jx);
+    sqlite3_result_subtype(ctx, JSON_SUBTYPE);
+  }
+  jsonReset(&jx);
+  jsonParseReset(&x);
+}
+
+/*
+** Implementation of the json_object(NAME,VALUE,...) function.  Return a JSON
+** object that contains all name/value given in arguments.  Or if any name
+** is not a string or if any value is a BLOB, throw an error.
+*/
+static void jsonObjectFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  int i;
+  JsonString jx;
+  const char *z;
+  u32 n;
+
+  if( argc&1 ){
+    sqlite3_result_error(ctx, "json_object() requires an even number "
+                                  "of arguments", -1);
+    return;
+  }
+  jsonInit(&jx, ctx);
+  jsonAppendChar(&jx, '{');
+  for(i=0; i<argc; i+=2){
+    if( sqlite3_value_type(argv[i])!=SQLITE_TEXT ){
+      sqlite3_result_error(ctx, "json_object() labels must be TEXT", -1);
+      jsonReset(&jx);
+      return;
+    }
+    jsonAppendSeparator(&jx);
+    z = (const char*)sqlite3_value_text(argv[i]);
+    n = (u32)sqlite3_value_bytes(argv[i]);
+    jsonAppendString(&jx, z, n);
+    jsonAppendChar(&jx, ':');
+    jsonAppendValue(&jx, argv[i+1]);
+  }
+  jsonAppendChar(&jx, '}');
+  jsonResult(&jx);
+  sqlite3_result_subtype(ctx, JSON_SUBTYPE);
+}
+
+
+/*
+** json_remove(JSON, PATH, ...)
+**
+** Remove the named elements from JSON and return the result.  malformed
+** JSON or PATH arguments result in an error.
+*/
+static void jsonRemoveFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  JsonParse x;          /* The parse */
+  JsonNode *pNode;
+  const char *zPath;
+  u32 i;
+
+  if( argc<1 ) return;
+  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
+  assert( x.nNode );
+  for(i=1; i<(u32)argc; i++){
+    zPath = (const char*)sqlite3_value_text(argv[i]);
+    if( zPath==0 ) goto remove_done;
+    pNode = jsonLookup(&x, zPath, 0, ctx);
+    if( x.nErr ) goto remove_done;
+    if( pNode ) pNode->jnFlags |= JNODE_REMOVE;
+  }
+  if( (x.aNode[0].jnFlags & JNODE_REMOVE)==0 ){
+    jsonReturnJson(x.aNode, ctx, 0);
+  }
+remove_done:
+  jsonParseReset(&x);
+}
+
+/*
+** json_replace(JSON, PATH, VALUE, ...)
+**
+** Replace the value at PATH with VALUE.  If PATH does not already exist,
+** this routine is a no-op.  If JSON or PATH is malformed, throw an error.
+*/
+static void jsonReplaceFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  JsonParse x;          /* The parse */
+  JsonNode *pNode;
+  const char *zPath;
+  u32 i;
+
+  if( argc<1 ) return;
+  if( (argc&1)==0 ) {
+    jsonWrongNumArgs(ctx, "replace");
+    return;
+  }
+  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
+  assert( x.nNode );
+  for(i=1; i<(u32)argc; i+=2){
+    zPath = (const char*)sqlite3_value_text(argv[i]);
+    pNode = jsonLookup(&x, zPath, 0, ctx);
+    if( x.nErr ) goto replace_err;
+    if( pNode ){
+      pNode->jnFlags |= (u8)JNODE_REPLACE;
+      pNode->iVal = (u8)(i+1);
+    }
+  }
+  if( x.aNode[0].jnFlags & JNODE_REPLACE ){
+    sqlite3_result_value(ctx, argv[x.aNode[0].iVal]);
+  }else{
+    jsonReturnJson(x.aNode, ctx, argv);
+  }
+replace_err:
+  jsonParseReset(&x);
+}
+
+/*
+** json_set(JSON, PATH, VALUE, ...)
+**
+** Set the value at PATH to VALUE.  Create the PATH if it does not already
+** exist.  Overwrite existing values that do exist.
+** If JSON or PATH is malformed, throw an error.
+**
+** json_insert(JSON, PATH, VALUE, ...)
+**
+** Create PATH and initialize it to VALUE.  If PATH already exists, this
+** routine is a no-op.  If JSON or PATH is malformed, throw an error.
+*/
+static void jsonSetFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  JsonParse x;          /* The parse */
+  JsonNode *pNode;
+  const char *zPath;
+  u32 i;
+  int bApnd;
+  int bIsSet = *(int*)sqlite3_user_data(ctx);
+
+  if( argc<1 ) return;
+  if( (argc&1)==0 ) {
+    jsonWrongNumArgs(ctx, bIsSet ? "set" : "insert");
+    return;
+  }
+  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
+  assert( x.nNode );
+  for(i=1; i<(u32)argc; i+=2){
+    zPath = (const char*)sqlite3_value_text(argv[i]);
+    bApnd = 0;
+    pNode = jsonLookup(&x, zPath, &bApnd, ctx);
+    if( x.oom ){
+      sqlite3_result_error_nomem(ctx);
+      goto jsonSetDone;
+    }else if( x.nErr ){
+      goto jsonSetDone;
+    }else if( pNode && (bApnd || bIsSet) ){
+      pNode->jnFlags |= (u8)JNODE_REPLACE;
+      pNode->iVal = (u8)(i+1);
+    }
+  }
+  if( x.aNode[0].jnFlags & JNODE_REPLACE ){
+    sqlite3_result_value(ctx, argv[x.aNode[0].iVal]);
+  }else{
+    jsonReturnJson(x.aNode, ctx, argv);
+  }
+jsonSetDone:
+  jsonParseReset(&x);
+}
+
+/*
+** json_type(JSON)
+** json_type(JSON, PATH)
+**
+** Return the top-level "type" of a JSON string.  Throw an error if
+** either the JSON or PATH inputs are not well-formed.
+*/
+static void jsonTypeFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  JsonParse x;          /* The parse */
+  const char *zPath;
+  JsonNode *pNode;
+
+  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;
+  assert( x.nNode );
+  if( argc==2 ){
+    zPath = (const char*)sqlite3_value_text(argv[1]);
+    pNode = jsonLookup(&x, zPath, 0, ctx);
+  }else{
+    pNode = x.aNode;
+  }
+  if( pNode ){
+    sqlite3_result_text(ctx, jsonType[pNode->eType], -1, SQLITE_STATIC);
+  }
+  jsonParseReset(&x);
+}
+
+/*
+** json_valid(JSON)
+**
+** Return 1 if JSON is a well-formed JSON string according to RFC-7159.
+** Return 0 otherwise.
+*/
+static void jsonValidFunc(
+  sqlite3_context *ctx,
+  int argc,
+  sqlite3_value **argv
+){
+  JsonParse x;          /* The parse */
+  int rc = 0;
+
+  UNUSED_PARAM(argc);
+  if( jsonParse(&x, 0, (const char*)sqlite3_value_text(argv[0]))==0 ){
+    rc = 1;
+  }
+  jsonParseReset(&x);
+  sqlite3_result_int(ctx, rc);
+}
+
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+/****************************************************************************
+** The json_each virtual table
+****************************************************************************/
+typedef struct JsonEachCursor JsonEachCursor;
+struct JsonEachCursor {
+  sqlite3_vtab_cursor base;  /* Base class - must be first */
+  u32 iRowid;                /* The rowid */
+  u32 iBegin;                /* The first node of the scan */
+  u32 i;                     /* Index in sParse.aNode[] of current row */
+  u32 iEnd;                  /* EOF when i equals or exceeds this value */
+  u8 eType;                  /* Type of top-level element */
+  u8 bRecursive;             /* True for json_tree().  False for json_each() */
+  char *zJson;               /* Input JSON */
+  char *zRoot;               /* Path by which to filter zJson */
+  JsonParse sParse;          /* Parse of the input JSON */
+};
+
+/* Constructor for the json_each virtual table */
+static int jsonEachConnect(
+  sqlite3 *db,
+  void *pAux,
+  int argc, const char *const*argv,
+  sqlite3_vtab **ppVtab,
+  char **pzErr
+){
+  sqlite3_vtab *pNew;
+  int rc;
+
+/* Column numbers */
+#define JEACH_KEY     0
+#define JEACH_VALUE   1
+#define JEACH_TYPE    2
+#define JEACH_ATOM    3
+#define JEACH_ID      4
+#define JEACH_PARENT  5
+#define JEACH_FULLKEY 6
+#define JEACH_PATH    7
+#define JEACH_JSON    8
+#define JEACH_ROOT    9
+
+  UNUSED_PARAM(pzErr);
+  UNUSED_PARAM(argv);
+  UNUSED_PARAM(argc);
+  UNUSED_PARAM(pAux);
+  rc = sqlite3_declare_vtab(db, 
+     "CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,"
+                    "json HIDDEN,root HIDDEN)");
+  if( rc==SQLITE_OK ){
+    pNew = *ppVtab = sqlite3_malloc( sizeof(*pNew) );
+    if( pNew==0 ) return SQLITE_NOMEM;
+    memset(pNew, 0, sizeof(*pNew));
+  }
+  return rc;
+}
+
+/* destructor for json_each virtual table */
+static int jsonEachDisconnect(sqlite3_vtab *pVtab){
+  sqlite3_free(pVtab);
+  return SQLITE_OK;
+}
+
+/* constructor for a JsonEachCursor object for json_each(). */
+static int jsonEachOpenEach(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
+  JsonEachCursor *pCur;
+
+  UNUSED_PARAM(p);
+  pCur = sqlite3_malloc( sizeof(*pCur) );
+  if( pCur==0 ) return SQLITE_NOMEM;
+  memset(pCur, 0, sizeof(*pCur));
+  *ppCursor = &pCur->base;
+  return SQLITE_OK;
+}
+
+/* constructor for a JsonEachCursor object for json_tree(). */
+static int jsonEachOpenTree(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
+  int rc = jsonEachOpenEach(p, ppCursor);
+  if( rc==SQLITE_OK ){
+    JsonEachCursor *pCur = (JsonEachCursor*)*ppCursor;
+    pCur->bRecursive = 1;
+  }
+  return rc;
+}
+
+/* Reset a JsonEachCursor back to its original state.  Free any memory
+** held. */
+static void jsonEachCursorReset(JsonEachCursor *p){
+  sqlite3_free(p->zJson);
+  sqlite3_free(p->zRoot);
+  jsonParseReset(&p->sParse);
+  p->iRowid = 0;
+  p->i = 0;
+  p->iEnd = 0;
+  p->eType = 0;
+  p->zJson = 0;
+  p->zRoot = 0;
+}
+
+/* Destructor for a jsonEachCursor object */
+static int jsonEachClose(sqlite3_vtab_cursor *cur){
+  JsonEachCursor *p = (JsonEachCursor*)cur;
+  jsonEachCursorReset(p);
+  sqlite3_free(cur);
+  return SQLITE_OK;
+}
+
+/* Return TRUE if the jsonEachCursor object has been advanced off the end
+** of the JSON object */
+static int jsonEachEof(sqlite3_vtab_cursor *cur){
+  JsonEachCursor *p = (JsonEachCursor*)cur;
+  return p->i >= p->iEnd;
+}
+
+/* Advance the cursor to the next element for json_tree() */
+static int jsonEachNext(sqlite3_vtab_cursor *cur){
+  JsonEachCursor *p = (JsonEachCursor*)cur;
+  if( p->bRecursive ){
+    if( p->sParse.aNode[p->i].jnFlags & JNODE_LABEL ) p->i++;
+    p->i++;
+    p->iRowid++;
+    if( p->i<p->iEnd ){
+      u32 iUp = p->sParse.aUp[p->i];
+      JsonNode *pUp = &p->sParse.aNode[iUp];
+      p->eType = pUp->eType;
+      if( pUp->eType==JSON_ARRAY ){
+        if( iUp==p->i-1 ){
+          pUp->u.iKey = 0;
+        }else{
+          pUp->u.iKey++;
+        }
+      }
+    }
+  }else{
+    switch( p->eType ){
+      case JSON_ARRAY: {
+        p->i += jsonNodeSize(&p->sParse.aNode[p->i]);
+        p->iRowid++;
+        break;
+      }
+      case JSON_OBJECT: {
+        p->i += 1 + jsonNodeSize(&p->sParse.aNode[p->i+1]);
+        p->iRowid++;
+        break;
+      }
+      default: {
+        p->i = p->iEnd;
+        break;
+      }
+    }
+  }
+  return SQLITE_OK;
+}
+
+/* Append the name of the path for element i to pStr
+*/
+static void jsonEachComputePath(
+  JsonEachCursor *p,       /* The cursor */
+  JsonString *pStr,        /* Write the path here */
+  u32 i                    /* Path to this element */
+){
+  JsonNode *pNode, *pUp;
+  u32 iUp;
+  if( i==0 ){
+    jsonAppendChar(pStr, '$');
+    return;
+  }
+  iUp = p->sParse.aUp[i];
+  jsonEachComputePath(p, pStr, iUp);
+  pNode = &p->sParse.aNode[i];
+  pUp = &p->sParse.aNode[iUp];
+  if( pUp->eType==JSON_ARRAY ){
+    jsonPrintf(30, pStr, "[%d]", pUp->u.iKey);
+  }else{
+    assert( pUp->eType==JSON_OBJECT );
+    if( (pNode->jnFlags & JNODE_LABEL)==0 ) pNode--;
+    assert( pNode->eType==JSON_STRING );
+    assert( pNode->jnFlags & JNODE_LABEL );
+    jsonPrintf(pNode->n+1, pStr, ".%.*s", pNode->n-2, pNode->u.zJContent+1);
+  }
+}
+
+/* Return the value of a column */
+static int jsonEachColumn(
+  sqlite3_vtab_cursor *cur,   /* The cursor */
+  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */
+  int i                       /* Which column to return */
+){
+  JsonEachCursor *p = (JsonEachCursor*)cur;
+  JsonNode *pThis = &p->sParse.aNode[p->i];
+  switch( i ){
+    case JEACH_KEY: {
+      if( p->i==0 ) break;
+      if( p->eType==JSON_OBJECT ){
+        jsonReturn(pThis, ctx, 0);
+      }else if( p->eType==JSON_ARRAY ){
+        u32 iKey;
+        if( p->bRecursive ){
+          if( p->iRowid==0 ) break;
+          iKey = p->sParse.aNode[p->sParse.aUp[p->i]].u.iKey;
+        }else{
+          iKey = p->iRowid;
+        }
+        sqlite3_result_int64(ctx, (sqlite3_int64)iKey);
+      }
+      break;
+    }
+    case JEACH_VALUE: {
+      if( pThis->jnFlags & JNODE_LABEL ) pThis++;
+      jsonReturn(pThis, ctx, 0);
+      break;
+    }
+    case JEACH_TYPE: {
+      if( pThis->jnFlags & JNODE_LABEL ) pThis++;
+      sqlite3_result_text(ctx, jsonType[pThis->eType], -1, SQLITE_STATIC);
+      break;
+    }
+    case JEACH_ATOM: {
+      if( pThis->jnFlags & JNODE_LABEL ) pThis++;
+      if( pThis->eType>=JSON_ARRAY ) break;
+      jsonReturn(pThis, ctx, 0);
+      break;
+    }
+    case JEACH_ID: {
+      sqlite3_result_int64(ctx, 
+         (sqlite3_int64)p->i + ((pThis->jnFlags & JNODE_LABEL)!=0));
+      break;
+    }
+    case JEACH_PARENT: {
+      if( p->i>p->iBegin && p->bRecursive ){
+        sqlite3_result_int64(ctx, (sqlite3_int64)p->sParse.aUp[p->i]);
+      }
+      break;
+    }
+    case JEACH_FULLKEY: {
+      JsonString x;
+      jsonInit(&x, ctx);
+      if( p->bRecursive ){
+        jsonEachComputePath(p, &x, p->i);
+      }else{
+        if( p->zRoot ){
+          jsonAppendRaw(&x, p->zRoot, (int)strlen(p->zRoot));
+        }else{
+          jsonAppendChar(&x, '$');
+        }
+        if( p->eType==JSON_ARRAY ){
+          jsonPrintf(30, &x, "[%d]", p->iRowid);
+        }else{
+          jsonPrintf(pThis->n, &x, ".%.*s", pThis->n-2, pThis->u.zJContent+1);
+        }
+      }
+      jsonResult(&x);
+      break;
+    }
+    case JEACH_PATH: {
+      if( p->bRecursive ){
+        JsonString x;
+        jsonInit(&x, ctx);
+        jsonEachComputePath(p, &x, p->sParse.aUp[p->i]);
+        jsonResult(&x);
+        break;
+      }
+      /* For json_each() path and root are the same so fall through
+      ** into the root case */
+    }
+    case JEACH_ROOT: {
+      const char *zRoot = p->zRoot;
+       if( zRoot==0 ) zRoot = "$";
+      sqlite3_result_text(ctx, zRoot, -1, SQLITE_STATIC);
+      break;
+    }
+    case JEACH_JSON: {
+      assert( i==JEACH_JSON );
+      sqlite3_result_text(ctx, p->sParse.zJson, -1, SQLITE_STATIC);
+      break;
+    }
+  }
+  return SQLITE_OK;
+}
+
+/* Return the current rowid value */
+static int jsonEachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
+  JsonEachCursor *p = (JsonEachCursor*)cur;
+  *pRowid = p->iRowid;
+  return SQLITE_OK;
+}
+
+/* The query strategy is to look for an equality constraint on the json
+** column.  Without such a constraint, the table cannot operate.  idxNum is
+** 1 if the constraint is found, 3 if the constraint and zRoot are found,
+** and 0 otherwise.
+*/
+static int jsonEachBestIndex(
+  sqlite3_vtab *tab,
+  sqlite3_index_info *pIdxInfo
+){
+  int i;
+  int jsonIdx = -1;
+  int rootIdx = -1;
+  const struct sqlite3_index_constraint *pConstraint;
+
+  UNUSED_PARAM(tab);
+  pConstraint = pIdxInfo->aConstraint;
+  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
+    if( pConstraint->usable==0 ) continue;
+    if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;
+    switch( pConstraint->iColumn ){
+      case JEACH_JSON:   jsonIdx = i;    break;
+      case JEACH_ROOT:   rootIdx = i;    break;
+      default:           /* no-op */     break;
+    }
+  }
+  if( jsonIdx<0 ){
+    pIdxInfo->idxNum = 0;
+    pIdxInfo->estimatedCost = 1e99;
+  }else{
+    pIdxInfo->estimatedCost = 1.0;
+    pIdxInfo->aConstraintUsage[jsonIdx].argvIndex = 1;
+    pIdxInfo->aConstraintUsage[jsonIdx].omit = 1;
+    if( rootIdx<0 ){
+      pIdxInfo->idxNum = 1;
+    }else{
+      pIdxInfo->aConstraintUsage[rootIdx].argvIndex = 2;
+      pIdxInfo->aConstraintUsage[rootIdx].omit = 1;
+      pIdxInfo->idxNum = 3;
+    }
+  }
+  return SQLITE_OK;
+}
+
+/* Start a search on a new JSON string */
+static int jsonEachFilter(
+  sqlite3_vtab_cursor *cur,
+  int idxNum, const char *idxStr,
+  int argc, sqlite3_value **argv
+){
+  JsonEachCursor *p = (JsonEachCursor*)cur;
+  const char *z;
+  const char *zRoot = 0;
+  sqlite3_int64 n;
+
+  UNUSED_PARAM(idxStr);
+  UNUSED_PARAM(argc);
+  jsonEachCursorReset(p);
+  if( idxNum==0 ) return SQLITE_OK;
+  z = (const char*)sqlite3_value_text(argv[0]);
+  if( z==0 ) return SQLITE_OK;
+  n = sqlite3_value_bytes(argv[0]);
+  p->zJson = sqlite3_malloc64( n+1 );
+  if( p->zJson==0 ) return SQLITE_NOMEM;
+  memcpy(p->zJson, z, (size_t)n+1);
+  if( jsonParse(&p->sParse, 0, p->zJson) ){
+    int rc = SQLITE_NOMEM;
+    if( p->sParse.oom==0 ){
+      sqlite3_free(cur->pVtab->zErrMsg);
+      cur->pVtab->zErrMsg = sqlite3_mprintf("malformed JSON");
+      if( cur->pVtab->zErrMsg ) rc = SQLITE_ERROR;
+    }
+    jsonEachCursorReset(p);
+    return rc;
+  }else if( p->bRecursive && jsonParseFindParents(&p->sParse) ){
+    jsonEachCursorReset(p);
+    return SQLITE_NOMEM;
+  }else{
+    JsonNode *pNode = 0;
+    if( idxNum==3 ){
+      const char *zErr = 0;
+      zRoot = (const char*)sqlite3_value_text(argv[1]);
+      if( zRoot==0 ) return SQLITE_OK;
+      n = sqlite3_value_bytes(argv[1]);
+      p->zRoot = sqlite3_malloc64( n+1 );
+      if( p->zRoot==0 ) return SQLITE_NOMEM;
+      memcpy(p->zRoot, zRoot, (size_t)n+1);
+      if( zRoot[0]!='$' ){
+        zErr = zRoot;
+      }else{
+        pNode = jsonLookupStep(&p->sParse, 0, p->zRoot+1, 0, &zErr);
+      }
+      if( zErr ){
+        sqlite3_free(cur->pVtab->zErrMsg);
+        cur->pVtab->zErrMsg = jsonPathSyntaxError(zErr);
+        jsonEachCursorReset(p);
+        return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;
+      }else if( pNode==0 ){
+        return SQLITE_OK;
+      }
+    }else{
+      pNode = p->sParse.aNode;
+    }
+    p->iBegin = p->i = (int)(pNode - p->sParse.aNode);
+    p->eType = pNode->eType;
+    if( p->eType>=JSON_ARRAY ){
+      pNode->u.iKey = 0;
+      p->iEnd = p->i + pNode->n + 1;
+      if( p->bRecursive ){
+        p->eType = p->sParse.aNode[p->sParse.aUp[p->i]].eType;
+        if( p->i>0 && (p->sParse.aNode[p->i-1].jnFlags & JNODE_LABEL)!=0 ){
+          p->i--;
+        }
+      }else{
+        p->i++;
+      }
+    }else{
+      p->iEnd = p->i+1;
+    }
+  }
+  return SQLITE_OK;
+}
+
+/* The methods of the json_each virtual table */
+static sqlite3_module jsonEachModule = {
+  0,                         /* iVersion */
+  0,                         /* xCreate */
+  jsonEachConnect,           /* xConnect */
+  jsonEachBestIndex,         /* xBestIndex */
+  jsonEachDisconnect,        /* xDisconnect */
+  0,                         /* xDestroy */
+  jsonEachOpenEach,          /* xOpen - open a cursor */
+  jsonEachClose,             /* xClose - close a cursor */
+  jsonEachFilter,            /* xFilter - configure scan constraints */
+  jsonEachNext,              /* xNext - advance a cursor */
+  jsonEachEof,               /* xEof - check for end of scan */
+  jsonEachColumn,            /* xColumn - read data */
+  jsonEachRowid,             /* xRowid - read data */
+  0,                         /* xUpdate */
+  0,                         /* xBegin */
+  0,                         /* xSync */
+  0,                         /* xCommit */
+  0,                         /* xRollback */
+  0,                         /* xFindMethod */
+  0,                         /* xRename */
+  0,                         /* xSavepoint */
+  0,                         /* xRelease */
+  0                          /* xRollbackTo */
+};
+
+/* The methods of the json_tree virtual table. */
+static sqlite3_module jsonTreeModule = {
+  0,                         /* iVersion */
+  0,                         /* xCreate */
+  jsonEachConnect,           /* xConnect */
+  jsonEachBestIndex,         /* xBestIndex */
+  jsonEachDisconnect,        /* xDisconnect */
+  0,                         /* xDestroy */
+  jsonEachOpenTree,          /* xOpen - open a cursor */
+  jsonEachClose,             /* xClose - close a cursor */
+  jsonEachFilter,            /* xFilter - configure scan constraints */
+  jsonEachNext,              /* xNext - advance a cursor */
+  jsonEachEof,               /* xEof - check for end of scan */
+  jsonEachColumn,            /* xColumn - read data */
+  jsonEachRowid,             /* xRowid - read data */
+  0,                         /* xUpdate */
+  0,                         /* xBegin */
+  0,                         /* xSync */
+  0,                         /* xCommit */
+  0,                         /* xRollback */
+  0,                         /* xFindMethod */
+  0,                         /* xRename */
+  0,                         /* xSavepoint */
+  0,                         /* xRelease */
+  0                          /* xRollbackTo */
+};
+#endif /* SQLITE_OMIT_VIRTUALTABLE */
+
+/****************************************************************************
+** The following routines are the only publically visible identifiers in this
+** file.  Call the following routines in order to register the various SQL
+** functions and the virtual table implemented by this file.
+****************************************************************************/
+
+SQLITE_PRIVATE int sqlite3Json1Init(sqlite3 *db){
+  int rc = SQLITE_OK;
+  unsigned int i;
+  static const struct {
+     const char *zName;
+     int nArg;
+     int flag;
+     void (*xFunc)(sqlite3_context*,int,sqlite3_value**);
+  } aFunc[] = {
+    { "json",                 1, 0,   jsonRemoveFunc        },
+    { "json_array",          -1, 0,   jsonArrayFunc         },
+    { "json_array_length",    1, 0,   jsonArrayLengthFunc   },
+    { "json_array_length",    2, 0,   jsonArrayLengthFunc   },
+    { "json_extract",        -1, 0,   jsonExtractFunc       },
+    { "json_insert",         -1, 0,   jsonSetFunc           },
+    { "json_object",         -1, 0,   jsonObjectFunc        },
+    { "json_remove",         -1, 0,   jsonRemoveFunc        },
+    { "json_replace",        -1, 0,   jsonReplaceFunc       },
+    { "json_set",            -1, 1,   jsonSetFunc           },
+    { "json_type",            1, 0,   jsonTypeFunc          },
+    { "json_type",            2, 0,   jsonTypeFunc          },
+    { "json_valid",           1, 0,   jsonValidFunc         },
+
+#if SQLITE_DEBUG
+    /* DEBUG and TESTING functions */
+    { "json_parse",           1, 0,   jsonParseFunc         },
+    { "json_test1",           1, 0,   jsonTest1Func         },
+#endif
+  };
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+  static const struct {
+     const char *zName;
+     sqlite3_module *pModule;
+  } aMod[] = {
+    { "json_each",            &jsonEachModule               },
+    { "json_tree",            &jsonTreeModule               },
+  };
+#endif
+  for(i=0; i<sizeof(aFunc)/sizeof(aFunc[0]) && rc==SQLITE_OK; i++){
+    rc = sqlite3_create_function(db, aFunc[i].zName, aFunc[i].nArg,
+                                 SQLITE_UTF8 | SQLITE_DETERMINISTIC, 
+                                 (void*)&aFunc[i].flag,
+                                 aFunc[i].xFunc, 0, 0);
+  }
+#ifndef SQLITE_OMIT_VIRTUALTABLE
+  for(i=0; i<sizeof(aMod)/sizeof(aMod[0]) && rc==SQLITE_OK; i++){
+    rc = sqlite3_create_module(db, aMod[i].zName, aMod[i].pModule, 0);
+  }
+#endif
+  return rc;
+}
+
+
+#ifndef SQLITE_CORE
+#ifdef _WIN32
+__declspec(dllexport)
+#endif
+SQLITE_API int SQLITE_STDCALL sqlite3_json_init(
+  sqlite3 *db, 
+  char **pzErrMsg, 
+  const sqlite3_api_routines *pApi
+){
+  SQLITE_EXTENSION_INIT2(pApi);
+  (void)pzErrMsg;  /* Unused parameter */
+  return sqlite3Json1Init(db);
+}
+#endif
+#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_JSON1) */
+
+/************** End of json1.c ***********************************************/
+/************** Begin file fts5.c ********************************************/
+
+
+#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS5) 
+
+#if !defined(NDEBUG) && !defined(SQLITE_DEBUG) 
+# define NDEBUG 1
+#endif
+#if defined(NDEBUG) && defined(SQLITE_DEBUG)
+# undef NDEBUG
+#endif
+
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** Interfaces to extend FTS5. Using the interfaces defined in this file, 
+** FTS5 may be extended with:
+**
+**     * custom tokenizers, and
+**     * custom auxiliary functions.
+*/
+
+
+#ifndef _FTS5_H
+#define _FTS5_H
+
+/* #include "sqlite3.h" */
+
+#if 0
+extern "C" {
+#endif
+
+/*************************************************************************
+** CUSTOM AUXILIARY FUNCTIONS
+**
+** Virtual table implementations may overload SQL functions by implementing
+** the sqlite3_module.xFindFunction() method.
+*/
+
+typedef struct Fts5ExtensionApi Fts5ExtensionApi;
+typedef struct Fts5Context Fts5Context;
+typedef struct Fts5PhraseIter Fts5PhraseIter;
+
+typedef void (*fts5_extension_function)(
+  const Fts5ExtensionApi *pApi,   /* API offered by current FTS version */
+  Fts5Context *pFts,              /* First arg to pass to pApi functions */
+  sqlite3_context *pCtx,          /* Context for returning result/error */
+  int nVal,                       /* Number of values in apVal[] array */
+  sqlite3_value **apVal           /* Array of trailing arguments */
+);
+
+struct Fts5PhraseIter {
+  const unsigned char *a;
+  const unsigned char *b;
+};
+
+/*
+** EXTENSION API FUNCTIONS
+**
+** xUserData(pFts):
+**   Return a copy of the context pointer the extension function was 
+**   registered with.
+**
+** xColumnTotalSize(pFts, iCol, pnToken):
+**   If parameter iCol is less than zero, set output variable *pnToken
+**   to the total number of tokens in the FTS5 table. Or, if iCol is
+**   non-negative but less than the number of columns in the table, return
+**   the total number of tokens in column iCol, considering all rows in 
+**   the FTS5 table.
+**
+**   If parameter iCol is greater than or equal to the number of columns
+**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
+**   an OOM condition or IO error), an appropriate SQLite error code is 
+**   returned.
+**
+** xColumnCount(pFts):
+**   Return the number of columns in the table.
+**
+** xColumnSize(pFts, iCol, pnToken):
+**   If parameter iCol is less than zero, set output variable *pnToken
+**   to the total number of tokens in the current row. Or, if iCol is
+**   non-negative but less than the number of columns in the table, set
+**   *pnToken to the number of tokens in column iCol of the current row.
+**
+**   If parameter iCol is greater than or equal to the number of columns
+**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
+**   an OOM condition or IO error), an appropriate SQLite error code is 
+**   returned.
+**
+** xColumnText:
+**   This function attempts to retrieve the text of column iCol of the
+**   current document. If successful, (*pz) is set to point to a buffer
+**   containing the text in utf-8 encoding, (*pn) is set to the size in bytes
+**   (not characters) of the buffer and SQLITE_OK is returned. Otherwise,
+**   if an error occurs, an SQLite error code is returned and the final values
+**   of (*pz) and (*pn) are undefined.
+**
+** xPhraseCount:
+**   Returns the number of phrases in the current query expression.
+**
+** xPhraseSize:
+**   Returns the number of tokens in phrase iPhrase of the query. Phrases
+**   are numbered starting from zero.
+**
+** xInstCount:
+**   Set *pnInst to the total number of occurrences of all phrases within
+**   the query within the current row. Return SQLITE_OK if successful, or
+**   an error code (i.e. SQLITE_NOMEM) if an error occurs.
+**
+** xInst:
+**   Query for the details of phrase match iIdx within the current row.
+**   Phrase matches are numbered starting from zero, so the iIdx argument
+**   should be greater than or equal to zero and smaller than the value
+**   output by xInstCount().
+**
+**   Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) 
+**   if an error occurs.
+**
+** xRowid:
+**   Returns the rowid of the current row.
+**
+** xTokenize:
+**   Tokenize text using the tokenizer belonging to the FTS5 table.
+**
+** xQueryPhrase(pFts5, iPhrase, pUserData, xCallback):
+**   This API function is used to query the FTS table for phrase iPhrase
+**   of the current query. Specifically, a query equivalent to:
+**
+**       ... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid
+**
+**   with $p set to a phrase equivalent to the phrase iPhrase of the
+**   current query is executed. For each row visited, the callback function
+**   passed as the fourth argument is invoked. The context and API objects 
+**   passed to the callback function may be used to access the properties of
+**   each matched row. Invoking Api.xUserData() returns a copy of the pointer
+**   passed as the third argument to pUserData.
+**
+**   If the callback function returns any value other than SQLITE_OK, the
+**   query is abandoned and the xQueryPhrase function returns immediately.
+**   If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK.
+**   Otherwise, the error code is propagated upwards.
+**
+**   If the query runs to completion without incident, SQLITE_OK is returned.
+**   Or, if some error occurs before the query completes or is aborted by
+**   the callback, an SQLite error code is returned.
+**
+**
+** xSetAuxdata(pFts5, pAux, xDelete)
+**
+**   Save the pointer passed as the second argument as the extension functions 
+**   "auxiliary data". The pointer may then be retrieved by the current or any
+**   future invocation of the same fts5 extension function made as part of
+**   of the same MATCH query using the xGetAuxdata() API.
+**
+**   Each extension function is allocated a single auxiliary data slot for
+**   each FTS query (MATCH expression). If the extension function is invoked 
+**   more than once for a single FTS query, then all invocations share a 
+**   single auxiliary data context.
+**
+**   If there is already an auxiliary data pointer when this function is
+**   invoked, then it is replaced by the new pointer. If an xDelete callback
+**   was specified along with the original pointer, it is invoked at this
+**   point.
+**
+**   The xDelete callback, if one is specified, is also invoked on the
+**   auxiliary data pointer after the FTS5 query has finished.
+**
+**   If an error (e.g. an OOM condition) occurs within this function, an
+**   the auxiliary data is set to NULL and an error code returned. If the
+**   xDelete parameter was not NULL, it is invoked on the auxiliary data
+**   pointer before returning.
+**
+**
+** xGetAuxdata(pFts5, bClear)
+**
+**   Returns the current auxiliary data pointer for the fts5 extension 
+**   function. See the xSetAuxdata() method for details.
+**
+**   If the bClear argument is non-zero, then the auxiliary data is cleared
+**   (set to NULL) before this function returns. In this case the xDelete,
+**   if any, is not invoked.
+**
+**
+** xRowCount(pFts5, pnRow)
+**
+**   This function is used to retrieve the total number of rows in the table.
+**   In other words, the same value that would be returned by:
+**
+**        SELECT count(*) FROM ftstable;
+**
+** xPhraseFirst()
+**   This function is used, along with type Fts5PhraseIter and the xPhraseNext
+**   method, to iterate through all instances of a single query phrase within
+**   the current row. This is the same information as is accessible via the
+**   xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient
+**   to use, this API may be faster under some circumstances. To iterate 
+**   through instances of phrase iPhrase, use the following code:
+**
+**       Fts5PhraseIter iter;
+**       int iCol, iOff;
+**       for(pApi->xPhraseFirst(pFts, iPhrase, &iter, &iCol, &iOff);
+**           iOff>=0;
+**           pApi->xPhraseNext(pFts, &iter, &iCol, &iOff)
+**       ){
+**         // An instance of phrase iPhrase at offset iOff of column iCol
+**       }
+**
+**   The Fts5PhraseIter structure is defined above. Applications should not
+**   modify this structure directly - it should only be used as shown above
+**   with the xPhraseFirst() and xPhraseNext() API methods.
+**
+** xPhraseNext()
+**   See xPhraseFirst above.
+*/
+struct Fts5ExtensionApi {
+  int iVersion;                   /* Currently always set to 1 */
+
+  void *(*xUserData)(Fts5Context*);
+
+  int (*xColumnCount)(Fts5Context*);
+  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
+  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);
+
+  int (*xTokenize)(Fts5Context*, 
+    const char *pText, int nText, /* Text to tokenize */
+    void *pCtx,                   /* Context passed to xToken() */
+    int (*xToken)(void*, int, const char*, int, int, int)       /* Callback */
+  );
+
+  int (*xPhraseCount)(Fts5Context*);
+  int (*xPhraseSize)(Fts5Context*, int iPhrase);
+
+  int (*xInstCount)(Fts5Context*, int *pnInst);
+  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);
+
+  sqlite3_int64 (*xRowid)(Fts5Context*);
+  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
+  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);
+
+  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
+    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
+  );
+  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
+  void *(*xGetAuxdata)(Fts5Context*, int bClear);
+
+  void (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
+  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);
+};
+
+/* 
+** CUSTOM AUXILIARY FUNCTIONS
+*************************************************************************/
+
+/*************************************************************************
+** CUSTOM TOKENIZERS
+**
+** Applications may also register custom tokenizer types. A tokenizer 
+** is registered by providing fts5 with a populated instance of the 
+** following structure. All structure methods must be defined, setting
+** any member of the fts5_tokenizer struct to NULL leads to undefined
+** behaviour. The structure methods are expected to function as follows:
+**
+** xCreate:
+**   This function is used to allocate and inititalize a tokenizer instance.
+**   A tokenizer instance is required to actually tokenize text.
+**
+**   The first argument passed to this function is a copy of the (void*)
+**   pointer provided by the application when the fts5_tokenizer object
+**   was registered with FTS5 (the third argument to xCreateTokenizer()). 
+**   The second and third arguments are an array of nul-terminated strings
+**   containing the tokenizer arguments, if any, specified following the
+**   tokenizer name as part of the CREATE VIRTUAL TABLE statement used
+**   to create the FTS5 table.
+**
+**   The final argument is an output variable. If successful, (*ppOut) 
+**   should be set to point to the new tokenizer handle and SQLITE_OK
+**   returned. If an error occurs, some value other than SQLITE_OK should
+**   be returned. In this case, fts5 assumes that the final value of *ppOut 
+**   is undefined.
+**
+** xDelete:
+**   This function is invoked to delete a tokenizer handle previously
+**   allocated using xCreate(). Fts5 guarantees that this function will
+**   be invoked exactly once for each successful call to xCreate().
+**
+** xTokenize:
+**   This function is expected to tokenize the nText byte string indicated 
+**   by argument pText. pText may or may not be nul-terminated. The first
+**   argument passed to this function is a pointer to an Fts5Tokenizer object
+**   returned by an earlier call to xCreate().
+**
+**   The second argument indicates the reason that FTS5 is requesting
+**   tokenization of the supplied text. This is always one of the following
+**   four values:
+**
+**   <ul><li> <b>FTS5_TOKENIZE_DOCUMENT</b> - A document is being inserted into
+**            or removed from the FTS table. The tokenizer is being invoked to
+**            determine the set of tokens to add to (or delete from) the
+**            FTS index.
+**
+**       <li> <b>FTS5_TOKENIZE_QUERY</b> - A MATCH query is being executed 
+**            against the FTS index. The tokenizer is being called to tokenize 
+**            a bareword or quoted string specified as part of the query.
+**
+**       <li> <b>(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)</b> - Same as
+**            FTS5_TOKENIZE_QUERY, except that the bareword or quoted string is
+**            followed by a "*" character, indicating that the last token
+**            returned by the tokenizer will be treated as a token prefix.
+**
+**       <li> <b>FTS5_TOKENIZE_AUX</b> - The tokenizer is being invoked to 
+**            satisfy an fts5_api.xTokenize() request made by an auxiliary
+**            function. Or an fts5_api.xColumnSize() request made by the same
+**            on a columnsize=0 database.  
+**   </ul>
+**
+**   For each token in the input string, the supplied callback xToken() must
+**   be invoked. The first argument to it should be a copy of the pointer
+**   passed as the second argument to xTokenize(). The third and fourth
+**   arguments are a pointer to a buffer containing the token text, and the
+**   size of the token in bytes. The 4th and 5th arguments are the byte offsets
+**   of the first byte of and first byte immediately following the text from
+**   which the token is derived within the input.
+**
+**   The second argument passed to the xToken() callback ("tflags") should
+**   normally be set to 0. The exception is if the tokenizer supports 
+**   synonyms. In this case see the discussion below for details.
+**
+**   FTS5 assumes the xToken() callback is invoked for each token in the 
+**   order that they occur within the input text.
+**
+**   If an xToken() callback returns any value other than SQLITE_OK, then
+**   the tokenization should be abandoned and the xTokenize() method should
+**   immediately return a copy of the xToken() return value. Or, if the
+**   input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally,
+**   if an error occurs with the xTokenize() implementation itself, it
+**   may abandon the tokenization and return any error code other than
+**   SQLITE_OK or SQLITE_DONE.
+**
+** SYNONYM SUPPORT
+**
+**   Custom tokenizers may also support synonyms. Consider a case in which a
+**   user wishes to query for a phrase such as "first place". Using the 
+**   built-in tokenizers, the FTS5 query 'first + place' will match instances
+**   of "first place" within the document set, but not alternative forms
+**   such as "1st place". In some applications, it would be better to match
+**   all instances of "first place" or "1st place" regardless of which form
+**   the user specified in the MATCH query text.
+**
+**   There are several ways to approach this in FTS5:
+**
+**   <ol><li> By mapping all synonyms to a single token. In this case, the 
+**            In the above example, this means that the tokenizer returns the
+**            same token for inputs "first" and "1st". Say that token is in
+**            fact "first", so that when the user inserts the document "I won
+**            1st place" entries are added to the index for tokens "i", "won",
+**            "first" and "place". If the user then queries for '1st + place',
+**            the tokenizer substitutes "first" for "1st" and the query works
+**            as expected.
+**
+**       <li> By adding multiple synonyms for a single term to the FTS index.
+**            In this case, when tokenizing query text, the tokenizer may 
+**            provide multiple synonyms for a single term within the document.
+**            FTS5 then queries the index for each synonym individually. For
+**            example, faced with the query:
+**
+**   <codeblock>
+**     ... MATCH 'first place'</codeblock>
+**
+**            the tokenizer offers both "1st" and "first" as synonyms for the
+**            first token in the MATCH query and FTS5 effectively runs a query 
+**            similar to:
+**
+**   <codeblock>
+**     ... MATCH '(first OR 1st) place'</codeblock>
+**
+**            except that, for the purposes of auxiliary functions, the query
+**            still appears to contain just two phrases - "(first OR 1st)" 
+**            being treated as a single phrase.
+**
+**       <li> By adding multiple synonyms for a single term to the FTS index.
+**            Using this method, when tokenizing document text, the tokenizer
+**            provides multiple synonyms for each token. So that when a 
+**            document such as "I won first place" is tokenized, entries are
+**            added to the FTS index for "i", "won", "first", "1st" and
+**            "place".
+**
+**            This way, even if the tokenizer does not provide synonyms
+**            when tokenizing query text (it should not - to do would be
+**            inefficient), it doesn't matter if the user queries for 
+**            'first + place' or '1st + place', as there are entires in the
+**            FTS index corresponding to both forms of the first token.
+**   </ol>
+**
+**   Whether it is parsing document or query text, any call to xToken that
+**   specifies a <i>tflags</i> argument with the FTS5_TOKEN_COLOCATED bit
+**   is considered to supply a synonym for the previous token. For example,
+**   when parsing the document "I won first place", a tokenizer that supports
+**   synonyms would call xToken() 5 times, as follows:
+**
+**   <codeblock>
+**       xToken(pCtx, 0, "i",                      1,  0,  1);
+**       xToken(pCtx, 0, "won",                    3,  2,  5);
+**       xToken(pCtx, 0, "first",                  5,  6, 11);
+**       xToken(pCtx, FTS5_TOKEN_COLOCATED, "1st", 3,  6, 11);
+**       xToken(pCtx, 0, "place",                  5, 12, 17);
+**</codeblock>
+**
+**   It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time
+**   xToken() is called. Multiple synonyms may be specified for a single token
+**   by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. 
+**   There is no limit to the number of synonyms that may be provided for a
+**   single token.
+**
+**   In many cases, method (1) above is the best approach. It does not add 
+**   extra data to the FTS index or require FTS5 to query for multiple terms,
+**   so it is efficient in terms of disk space and query speed. However, it
+**   does not support prefix queries very well. If, as suggested above, the
+**   token "first" is subsituted for "1st" by the tokenizer, then the query:
+**
+**   <codeblock>
+**     ... MATCH '1s*'</codeblock>
+**
+**   will not match documents that contain the token "1st" (as the tokenizer
+**   will probably not map "1s" to any prefix of "first").
+**
+**   For full prefix support, method (3) may be preferred. In this case, 
+**   because the index contains entries for both "first" and "1st", prefix
+**   queries such as 'fi*' or '1s*' will match correctly. However, because
+**   extra entries are added to the FTS index, this method uses more space
+**   within the database.
+**
+**   Method (2) offers a midpoint between (1) and (3). Using this method,
+**   a query such as '1s*' will match documents that contain the literal 
+**   token "1st", but not "first" (assuming the tokenizer is not able to
+**   provide synonyms for prefixes). However, a non-prefix query like '1st'
+**   will match against "1st" and "first". This method does not require
+**   extra disk space, as no extra entries are added to the FTS index. 
+**   On the other hand, it may require more CPU cycles to run MATCH queries,
+**   as separate queries of the FTS index are required for each synonym.
+**
+**   When using methods (2) or (3), it is important that the tokenizer only
+**   provide synonyms when tokenizing document text (method (2)) or query
+**   text (method (3)), not both. Doing so will not cause any errors, but is
+**   inefficient.
+*/
+typedef struct Fts5Tokenizer Fts5Tokenizer;
+typedef struct fts5_tokenizer fts5_tokenizer;
+struct fts5_tokenizer {
+  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
+  void (*xDelete)(Fts5Tokenizer*);
+  int (*xTokenize)(Fts5Tokenizer*, 
+      void *pCtx,
+      int flags,            /* Mask of FTS5_TOKENIZE_* flags */
+      const char *pText, int nText, 
+      int (*xToken)(
+        void *pCtx,         /* Copy of 2nd argument to xTokenize() */
+        int tflags,         /* Mask of FTS5_TOKEN_* flags */
+        const char *pToken, /* Pointer to buffer containing token */
+        int nToken,         /* Size of token in bytes */
+        int iStart,         /* Byte offset of token within input text */
+        int iEnd            /* Byte offset of end of token within input text */
+      )
+  );
+};
+
+/* Flags that may be passed as the third argument to xTokenize() */
+#define FTS5_TOKENIZE_QUERY     0x0001
+#define FTS5_TOKENIZE_PREFIX    0x0002
+#define FTS5_TOKENIZE_DOCUMENT  0x0004
+#define FTS5_TOKENIZE_AUX       0x0008
+
+/* Flags that may be passed by the tokenizer implementation back to FTS5
+** as the third argument to the supplied xToken callback. */
+#define FTS5_TOKEN_COLOCATED    0x0001      /* Same position as prev. token */
+
+/*
+** END OF CUSTOM TOKENIZERS
+*************************************************************************/
+
+/*************************************************************************
+** FTS5 EXTENSION REGISTRATION API
+*/
+typedef struct fts5_api fts5_api;
+struct fts5_api {
+  int iVersion;                   /* Currently always set to 2 */
+
+  /* Create a new tokenizer */
+  int (*xCreateTokenizer)(
+    fts5_api *pApi,
+    const char *zName,
+    void *pContext,
+    fts5_tokenizer *pTokenizer,
+    void (*xDestroy)(void*)
+  );
+
+  /* Find an existing tokenizer */
+  int (*xFindTokenizer)(
+    fts5_api *pApi,
+    const char *zName,
+    void **ppContext,
+    fts5_tokenizer *pTokenizer
+  );
+
+  /* Create a new auxiliary function */
+  int (*xCreateFunction)(
+    fts5_api *pApi,
+    const char *zName,
+    void *pContext,
+    fts5_extension_function xFunction,
+    void (*xDestroy)(void*)
+  );
+};
+
+/*
+** END OF REGISTRATION API
+*************************************************************************/
+
+#if 0
+}  /* end of the 'extern "C"' block */
+#endif
+
+#endif /* _FTS5_H */
+
+
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+*/
+#ifndef _FTS5INT_H
+#define _FTS5INT_H
+
+/* #include "sqlite3ext.h" */
+SQLITE_EXTENSION_INIT1
+
+/* #include <string.h> */
+/* #include <assert.h> */
+
+#ifndef SQLITE_AMALGAMATION
+
+typedef unsigned char  u8;
+typedef unsigned int   u32;
+typedef unsigned short u16;
+typedef sqlite3_int64 i64;
+typedef sqlite3_uint64 u64;
+
+#define ArraySize(x) (sizeof(x) / sizeof(x[0]))
+
+#define testcase(x)
+#define ALWAYS(x) 1
+#define NEVER(x) 0
+
+#define MIN(x,y) (((x) < (y)) ? (x) : (y))
+#define MAX(x,y) (((x) > (y)) ? (x) : (y))
+
+/*
+** Constants for the largest and smallest possible 64-bit signed integers.
+*/
+# define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))
+# define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)
+
+#endif
+
+
+/*
+** Maximum number of prefix indexes on single FTS5 table. This must be
+** less than 32. If it is set to anything large than that, an #error
+** directive in fts5_index.c will cause the build to fail.
+*/
+#define FTS5_MAX_PREFIX_INDEXES 31
+
+#define FTS5_DEFAULT_NEARDIST 10
+#define FTS5_DEFAULT_RANK     "bm25"
+
+/* Name of rank and rowid columns */
+#define FTS5_RANK_NAME "rank"
+#define FTS5_ROWID_NAME "rowid"
+
+#ifdef SQLITE_DEBUG
+# define FTS5_CORRUPT sqlite3Fts5Corrupt()
+static int sqlite3Fts5Corrupt(void);
+#else
+# define FTS5_CORRUPT SQLITE_CORRUPT_VTAB
+#endif
+
+/*
+** The assert_nc() macro is similar to the assert() macro, except that it
+** is used for assert() conditions that are true only if it can be 
+** guranteed that the database is not corrupt.
+*/
+#ifdef SQLITE_DEBUG
+SQLITE_API extern int sqlite3_fts5_may_be_corrupt;
+# define assert_nc(x) assert(sqlite3_fts5_may_be_corrupt || (x))
+#else
+# define assert_nc(x) assert(x)
+#endif
+
+typedef struct Fts5Global Fts5Global;
+typedef struct Fts5Colset Fts5Colset;
+
+/* If a NEAR() clump or phrase may only match a specific set of columns, 
+** then an object of the following type is used to record the set of columns.
+** Each entry in the aiCol[] array is a column that may be matched.
+**
+** This object is used by fts5_expr.c and fts5_index.c.
+*/
+struct Fts5Colset {
+  int nCol;
+  int aiCol[1];
+};
+
+
+
+/**************************************************************************
+** Interface to code in fts5_config.c. fts5_config.c contains contains code
+** to parse the arguments passed to the CREATE VIRTUAL TABLE statement.
+*/
+
+typedef struct Fts5Config Fts5Config;
+
+/*
+** An instance of the following structure encodes all information that can
+** be gleaned from the CREATE VIRTUAL TABLE statement.
+**
+** And all information loaded from the %_config table.
+**
+** nAutomerge:
+**   The minimum number of segments that an auto-merge operation should
+**   attempt to merge together. A value of 1 sets the object to use the 
+**   compile time default. Zero disables auto-merge altogether.
+**
+** zContent:
+**
+** zContentRowid:
+**   The value of the content_rowid= option, if one was specified. Or 
+**   the string "rowid" otherwise. This text is not quoted - if it is
+**   used as part of an SQL statement it needs to be quoted appropriately.
+**
+** zContentExprlist:
+**
+** pzErrmsg:
+**   This exists in order to allow the fts5_index.c module to return a 
+**   decent error message if it encounters a file-format version it does
+**   not understand.
+**
+** bColumnsize:
+**   True if the %_docsize table is created.
+**
+** bPrefixIndex:
+**   This is only used for debugging. If set to false, any prefix indexes
+**   are ignored. This value is configured using:
+**
+**       INSERT INTO tbl(tbl, rank) VALUES('prefix-index', $bPrefixIndex);
+**
+*/
+struct Fts5Config {
+  sqlite3 *db;                    /* Database handle */
+  char *zDb;                      /* Database holding FTS index (e.g. "main") */
+  char *zName;                    /* Name of FTS index */
+  int nCol;                       /* Number of columns */
+  char **azCol;                   /* Column names */
+  u8 *abUnindexed;                /* True for unindexed columns */
+  int nPrefix;                    /* Number of prefix indexes */
+  int *aPrefix;                   /* Sizes in bytes of nPrefix prefix indexes */
+  int eContent;                   /* An FTS5_CONTENT value */
+  char *zContent;                 /* content table */ 
+  char *zContentRowid;            /* "content_rowid=" option value */ 
+  int bColumnsize;                /* "columnsize=" option value (dflt==1) */
+  char *zContentExprlist;
+  Fts5Tokenizer *pTok;
+  fts5_tokenizer *pTokApi;
+
+  /* Values loaded from the %_config table */
+  int iCookie;                    /* Incremented when %_config is modified */
+  int pgsz;                       /* Approximate page size used in %_data */
+  int nAutomerge;                 /* 'automerge' setting */
+  int nCrisisMerge;               /* Maximum allowed segments per level */
+  char *zRank;                    /* Name of rank function */
+  char *zRankArgs;                /* Arguments to rank function */
+
+  /* If non-NULL, points to sqlite3_vtab.base.zErrmsg. Often NULL. */
+  char **pzErrmsg;
+
+#ifdef SQLITE_DEBUG
+  int bPrefixIndex;               /* True to use prefix-indexes */
+#endif
+};
+
+/* Current expected value of %_config table 'version' field */
+#define FTS5_CURRENT_VERSION 4
+
+#define FTS5_CONTENT_NORMAL   0
+#define FTS5_CONTENT_NONE     1
+#define FTS5_CONTENT_EXTERNAL 2
+
+
+
+
+static int sqlite3Fts5ConfigParse(
+    Fts5Global*, sqlite3*, int, const char **, Fts5Config**, char**
+);
+static void sqlite3Fts5ConfigFree(Fts5Config*);
+
+static int sqlite3Fts5ConfigDeclareVtab(Fts5Config *pConfig);
+
+static int sqlite3Fts5Tokenize(
+  Fts5Config *pConfig,            /* FTS5 Configuration object */
+  int flags,                      /* FTS5_TOKENIZE_* flags */
+  const char *pText, int nText,   /* Text to tokenize */
+  void *pCtx,                     /* Context passed to xToken() */
+  int (*xToken)(void*, int, const char*, int, int, int)    /* Callback */
+);
+
+static void sqlite3Fts5Dequote(char *z);
+
+/* Load the contents of the %_config table */
+static int sqlite3Fts5ConfigLoad(Fts5Config*, int);
+
+/* Set the value of a single config attribute */
+static int sqlite3Fts5ConfigSetValue(Fts5Config*, const char*, sqlite3_value*, int*);
+
+static int sqlite3Fts5ConfigParseRank(const char*, char**, char**);
+
+/*
+** End of interface to code in fts5_config.c.
+**************************************************************************/
+
+/**************************************************************************
+** Interface to code in fts5_buffer.c.
+*/
+
+/*
+** Buffer object for the incremental building of string data.
+*/
+typedef struct Fts5Buffer Fts5Buffer;
+struct Fts5Buffer {
+  u8 *p;
+  int n;
+  int nSpace;
+};
+
+static int sqlite3Fts5BufferGrow(int*, Fts5Buffer*, int);
+static void sqlite3Fts5BufferAppendVarint(int*, Fts5Buffer*, i64);
+static void sqlite3Fts5BufferAppendBlob(int*, Fts5Buffer*, int, const u8*);
+static void sqlite3Fts5BufferAppendString(int *, Fts5Buffer*, const char*);
+static void sqlite3Fts5BufferFree(Fts5Buffer*);
+static void sqlite3Fts5BufferZero(Fts5Buffer*);
+static void sqlite3Fts5BufferSet(int*, Fts5Buffer*, int, const u8*);
+static void sqlite3Fts5BufferAppendPrintf(int *, Fts5Buffer*, char *zFmt, ...);
+static void sqlite3Fts5BufferAppend32(int*, Fts5Buffer*, int);
+
+static char *sqlite3Fts5Mprintf(int *pRc, const char *zFmt, ...);
+
+#define fts5BufferZero(x)             sqlite3Fts5BufferZero(x)
+#define fts5BufferGrow(a,b,c)         sqlite3Fts5BufferGrow(a,b,c)
+#define fts5BufferAppendVarint(a,b,c) sqlite3Fts5BufferAppendVarint(a,b,c)
+#define fts5BufferFree(a)             sqlite3Fts5BufferFree(a)
+#define fts5BufferAppendBlob(a,b,c,d) sqlite3Fts5BufferAppendBlob(a,b,c,d)
+#define fts5BufferSet(a,b,c,d)        sqlite3Fts5BufferSet(a,b,c,d)
+#define fts5BufferAppend32(a,b,c)     sqlite3Fts5BufferAppend32(a,b,c)
+
+/* Write and decode big-endian 32-bit integer values */
+static void sqlite3Fts5Put32(u8*, int);
+static int sqlite3Fts5Get32(const u8*);
+
+#define FTS5_POS2COLUMN(iPos) (int)(iPos >> 32)
+#define FTS5_POS2OFFSET(iPos) (int)(iPos & 0xFFFFFFFF)
+
+typedef struct Fts5PoslistReader Fts5PoslistReader;
+struct Fts5PoslistReader {
+  /* Variables used only by sqlite3Fts5PoslistIterXXX() functions. */
+  const u8 *a;                    /* Position list to iterate through */
+  int n;                          /* Size of buffer at a[] in bytes */
+  int i;                          /* Current offset in a[] */
+
+  u8 bFlag;                       /* For client use (any custom purpose) */
+
+  /* Output variables */
+  u8 bEof;                        /* Set to true at EOF */
+  i64 iPos;                       /* (iCol<<32) + iPos */
+};
+static int sqlite3Fts5PoslistReaderInit(
+  const u8 *a, int n,             /* Poslist buffer to iterate through */
+  Fts5PoslistReader *pIter        /* Iterator object to initialize */
+);
+static int sqlite3Fts5PoslistReaderNext(Fts5PoslistReader*);
+
+typedef struct Fts5PoslistWriter Fts5PoslistWriter;
+struct Fts5PoslistWriter {
+  i64 iPrev;
+};
+static int sqlite3Fts5PoslistWriterAppend(Fts5Buffer*, Fts5PoslistWriter*, i64);
+
+static int sqlite3Fts5PoslistNext64(
+  const u8 *a, int n,             /* Buffer containing poslist */
+  int *pi,                        /* IN/OUT: Offset within a[] */
+  i64 *piOff                      /* IN/OUT: Current offset */
+);
+
+/* Malloc utility */
+static void *sqlite3Fts5MallocZero(int *pRc, int nByte);
+static char *sqlite3Fts5Strndup(int *pRc, const char *pIn, int nIn);
+
+/* Character set tests (like isspace(), isalpha() etc.) */
+static int sqlite3Fts5IsBareword(char t);
+
+/*
+** End of interface to code in fts5_buffer.c.
+**************************************************************************/
+
+/**************************************************************************
+** Interface to code in fts5_index.c. fts5_index.c contains contains code
+** to access the data stored in the %_data table.
+*/
+
+typedef struct Fts5Index Fts5Index;
+typedef struct Fts5IndexIter Fts5IndexIter;
+
+/*
+** Values used as part of the flags argument passed to IndexQuery().
+*/
+#define FTS5INDEX_QUERY_PREFIX     0x0001   /* Prefix query */
+#define FTS5INDEX_QUERY_DESC       0x0002   /* Docs in descending rowid order */
+#define FTS5INDEX_QUERY_TEST_NOIDX 0x0004   /* Do not use prefix index */
+#define FTS5INDEX_QUERY_SCAN       0x0008   /* Scan query (fts5vocab) */
+
+/*
+** Create/destroy an Fts5Index object.
+*/
+static int sqlite3Fts5IndexOpen(Fts5Config *pConfig, int bCreate, Fts5Index**, char**);
+static int sqlite3Fts5IndexClose(Fts5Index *p);
+
+/*
+** for(
+**   sqlite3Fts5IndexQuery(p, "token", 5, 0, 0, &pIter);
+**   0==sqlite3Fts5IterEof(pIter);
+**   sqlite3Fts5IterNext(pIter)
+** ){
+**   i64 iRowid = sqlite3Fts5IterRowid(pIter);
+** }
+*/
+
+/*
+** Open a new iterator to iterate though all rowids that match the 
+** specified token or token prefix.
+*/
+static int sqlite3Fts5IndexQuery(
+  Fts5Index *p,                   /* FTS index to query */
+  const char *pToken, int nToken, /* Token (or prefix) to query for */
+  int flags,                      /* Mask of FTS5INDEX_QUERY_X flags */
+  Fts5Colset *pColset,            /* Match these columns only */
+  Fts5IndexIter **ppIter          /* OUT: New iterator object */
+);
+
+/*
+** The various operations on open token or token prefix iterators opened
+** using sqlite3Fts5IndexQuery().
+*/
+static int sqlite3Fts5IterEof(Fts5IndexIter*);
+static int sqlite3Fts5IterNext(Fts5IndexIter*);
+static int sqlite3Fts5IterNextFrom(Fts5IndexIter*, i64 iMatch);
+static i64 sqlite3Fts5IterRowid(Fts5IndexIter*);
+static int sqlite3Fts5IterPoslist(Fts5IndexIter*,Fts5Colset*, const u8**, int*, i64*);
+static int sqlite3Fts5IterPoslistBuffer(Fts5IndexIter *pIter, Fts5Buffer *pBuf);
+
+/*
+** Close an iterator opened by sqlite3Fts5IndexQuery().
+*/
+static void sqlite3Fts5IterClose(Fts5IndexIter*);
+
+/*
+** This interface is used by the fts5vocab module.
+*/
+static const char *sqlite3Fts5IterTerm(Fts5IndexIter*, int*);
+static int sqlite3Fts5IterNextScan(Fts5IndexIter*);
+
+
+/*
+** Insert or remove data to or from the index. Each time a document is 
+** added to or removed from the index, this function is called one or more
+** times.
+**
+** For an insert, it must be called once for each token in the new document.
+** If the operation is a delete, it must be called (at least) once for each
+** unique token in the document with an iCol value less than zero. The iPos
+** argument is ignored for a delete.
+*/
+static int sqlite3Fts5IndexWrite(
+  Fts5Index *p,                   /* Index to write to */
+  int iCol,                       /* Column token appears in (-ve -> delete) */
+  int iPos,                       /* Position of token within column */
+  const char *pToken, int nToken  /* Token to add or remove to or from index */
+);
+
+/*
+** Indicate that subsequent calls to sqlite3Fts5IndexWrite() pertain to
+** document iDocid.
+*/
+static int sqlite3Fts5IndexBeginWrite(
+  Fts5Index *p,                   /* Index to write to */
+  int bDelete,                    /* True if current operation is a delete */
+  i64 iDocid                      /* Docid to add or remove data from */
+);
+
+/*
+** Flush any data stored in the in-memory hash tables to the database.
+** If the bCommit flag is true, also close any open blob handles.
+*/
+static int sqlite3Fts5IndexSync(Fts5Index *p, int bCommit);
+
+/*
+** Discard any data stored in the in-memory hash tables. Do not write it
+** to the database. Additionally, assume that the contents of the %_data
+** table may have changed on disk. So any in-memory caches of %_data 
+** records must be invalidated.
+*/
+static int sqlite3Fts5IndexRollback(Fts5Index *p);
+
+/*
+** Get or set the "averages" values.
+*/
+static int sqlite3Fts5IndexGetAverages(Fts5Index *p, i64 *pnRow, i64 *anSize);
+static int sqlite3Fts5IndexSetAverages(Fts5Index *p, const u8*, int);
+
+/*
+** Functions called by the storage module as part of integrity-check.
+*/
+static u64 sqlite3Fts5IndexCksum(Fts5Config*,i64,int,int,const char*,int);
+static int sqlite3Fts5IndexIntegrityCheck(Fts5Index*, u64 cksum);
+
+/* 
+** Called during virtual module initialization to register UDF 
+** fts5_decode() with SQLite 
+*/
+static int sqlite3Fts5IndexInit(sqlite3*);
+
+static int sqlite3Fts5IndexSetCookie(Fts5Index*, int);
+
+/*
+** Return the total number of entries read from the %_data table by 
+** this connection since it was created.
+*/
+static int sqlite3Fts5IndexReads(Fts5Index *p);
+
+static int sqlite3Fts5IndexReinit(Fts5Index *p);
+static int sqlite3Fts5IndexOptimize(Fts5Index *p);
+static int sqlite3Fts5IndexMerge(Fts5Index *p, int nMerge);
+
+static int sqlite3Fts5IndexLoadConfig(Fts5Index *p);
+
+/*
+** End of interface to code in fts5_index.c.
+**************************************************************************/
+
+/**************************************************************************
+** Interface to code in fts5_varint.c. 
+*/
+static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v);
+static int sqlite3Fts5GetVarintLen(u32 iVal);
+static u8 sqlite3Fts5GetVarint(const unsigned char*, u64*);
+static int sqlite3Fts5PutVarint(unsigned char *p, u64 v);
+
+#define fts5GetVarint32(a,b) sqlite3Fts5GetVarint32(a,(u32*)&b)
+#define fts5GetVarint    sqlite3Fts5GetVarint
+
+#define fts5FastGetVarint32(a, iOff, nVal) {      \
+  nVal = (a)[iOff++];                             \
+  if( nVal & 0x80 ){                              \
+    iOff--;                                       \
+    iOff += fts5GetVarint32(&(a)[iOff], nVal);    \
+  }                                               \
+}
+
+
+/*
+** End of interface to code in fts5_varint.c.
+**************************************************************************/
+
+
+/**************************************************************************
+** Interface to code in fts5.c. 
+*/
+
+static int sqlite3Fts5GetTokenizer(
+  Fts5Global*, 
+  const char **azArg,
+  int nArg,
+  Fts5Tokenizer**,
+  fts5_tokenizer**,
+  char **pzErr
+);
+
+static Fts5Index *sqlite3Fts5IndexFromCsrid(Fts5Global*, i64, int*);
+
+/*
+** End of interface to code in fts5.c.
+**************************************************************************/
+
+/**************************************************************************
+** Interface to code in fts5_hash.c. 
+*/
+typedef struct Fts5Hash Fts5Hash;
+
+/*
+** Create a hash table, free a hash table.
+*/
+static int sqlite3Fts5HashNew(Fts5Hash**, int *pnSize);
+static void sqlite3Fts5HashFree(Fts5Hash*);
+
+static int sqlite3Fts5HashWrite(
+  Fts5Hash*,
+  i64 iRowid,                     /* Rowid for this entry */
+  int iCol,                       /* Column token appears in (-ve -> delete) */
+  int iPos,                       /* Position of token within column */
+  char bByte,
+  const char *pToken, int nToken  /* Token to add or remove to or from index */
+);
+
+/*
+** Empty (but do not delete) a hash table.
+*/
+static void sqlite3Fts5HashClear(Fts5Hash*);
+
+static int sqlite3Fts5HashQuery(
+  Fts5Hash*,                      /* Hash table to query */
+  const char *pTerm, int nTerm,   /* Query term */
+  const u8 **ppDoclist,           /* OUT: Pointer to doclist for pTerm */
+  int *pnDoclist                  /* OUT: Size of doclist in bytes */
+);
+
+static int sqlite3Fts5HashScanInit(
+  Fts5Hash*,                      /* Hash table to query */
+  const char *pTerm, int nTerm    /* Query prefix */
+);
+static void sqlite3Fts5HashScanNext(Fts5Hash*);
+static int sqlite3Fts5HashScanEof(Fts5Hash*);
+static void sqlite3Fts5HashScanEntry(Fts5Hash *,
+  const char **pzTerm,            /* OUT: term (nul-terminated) */
+  const u8 **ppDoclist,           /* OUT: pointer to doclist */
+  int *pnDoclist                  /* OUT: size of doclist in bytes */
+);
+
+
+/*
+** End of interface to code in fts5_hash.c.
+**************************************************************************/
+
+/**************************************************************************
+** Interface to code in fts5_storage.c. fts5_storage.c contains contains 
+** code to access the data stored in the %_content and %_docsize tables.
+*/
+
+#define FTS5_STMT_SCAN_ASC  0     /* SELECT rowid, * FROM ... ORDER BY 1 ASC */
+#define FTS5_STMT_SCAN_DESC 1     /* SELECT rowid, * FROM ... ORDER BY 1 DESC */
+#define FTS5_STMT_LOOKUP    2     /* SELECT rowid, * FROM ... WHERE rowid=? */
+
+typedef struct Fts5Storage Fts5Storage;
+
+static int sqlite3Fts5StorageOpen(Fts5Config*, Fts5Index*, int, Fts5Storage**, char**);
+static int sqlite3Fts5StorageClose(Fts5Storage *p);
+static int sqlite3Fts5StorageRename(Fts5Storage*, const char *zName);
+
+static int sqlite3Fts5DropAll(Fts5Config*);
+static int sqlite3Fts5CreateTable(Fts5Config*, const char*, const char*, int, char **);
+
+static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64);
+static int sqlite3Fts5StorageContentInsert(Fts5Storage *p, sqlite3_value**, i64*);
+static int sqlite3Fts5StorageIndexInsert(Fts5Storage *p, sqlite3_value**, i64);
+
+static int sqlite3Fts5StorageIntegrity(Fts5Storage *p);
+
+static int sqlite3Fts5StorageStmt(Fts5Storage *p, int eStmt, sqlite3_stmt**, char**);
+static void sqlite3Fts5StorageStmtRelease(Fts5Storage *p, int eStmt, sqlite3_stmt*);
+
+static int sqlite3Fts5StorageDocsize(Fts5Storage *p, i64 iRowid, int *aCol);
+static int sqlite3Fts5StorageSize(Fts5Storage *p, int iCol, i64 *pnAvg);
+static int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow);
+
+static int sqlite3Fts5StorageSync(Fts5Storage *p, int bCommit);
+static int sqlite3Fts5StorageRollback(Fts5Storage *p);
+
+static int sqlite3Fts5StorageConfigValue(
+    Fts5Storage *p, const char*, sqlite3_value*, int
+);
+
+static int sqlite3Fts5StorageSpecialDelete(Fts5Storage *p, i64 iDel, sqlite3_value**);
+
+static int sqlite3Fts5StorageDeleteAll(Fts5Storage *p);
+static int sqlite3Fts5StorageRebuild(Fts5Storage *p);
+static int sqlite3Fts5StorageOptimize(Fts5Storage *p);
+static int sqlite3Fts5StorageMerge(Fts5Storage *p, int nMerge);
+
+/*
+** End of interface to code in fts5_storage.c.
+**************************************************************************/
+
+
+/**************************************************************************
+** Interface to code in fts5_expr.c. 
+*/
+typedef struct Fts5Expr Fts5Expr;
+typedef struct Fts5ExprNode Fts5ExprNode;
+typedef struct Fts5Parse Fts5Parse;
+typedef struct Fts5Token Fts5Token;
+typedef struct Fts5ExprPhrase Fts5ExprPhrase;
+typedef struct Fts5ExprNearset Fts5ExprNearset;
+
+struct Fts5Token {
+  const char *p;                  /* Token text (not NULL terminated) */
+  int n;                          /* Size of buffer p in bytes */
+};
+
+/* Parse a MATCH expression. */
+static int sqlite3Fts5ExprNew(
+  Fts5Config *pConfig, 
+  const char *zExpr,
+  Fts5Expr **ppNew, 
+  char **pzErr
+);
+
+/*
+** for(rc = sqlite3Fts5ExprFirst(pExpr, pIdx, bDesc);
+**     rc==SQLITE_OK && 0==sqlite3Fts5ExprEof(pExpr);
+**     rc = sqlite3Fts5ExprNext(pExpr)
+** ){
+**   // The document with rowid iRowid matches the expression!
+**   i64 iRowid = sqlite3Fts5ExprRowid(pExpr);
+** }
+*/
+static int sqlite3Fts5ExprFirst(Fts5Expr*, Fts5Index *pIdx, i64 iMin, int bDesc);
+static int sqlite3Fts5ExprNext(Fts5Expr*, i64 iMax);
+static int sqlite3Fts5ExprEof(Fts5Expr*);
+static i64 sqlite3Fts5ExprRowid(Fts5Expr*);
+
+static void sqlite3Fts5ExprFree(Fts5Expr*);
+
+/* Called during startup to register a UDF with SQLite */
+static int sqlite3Fts5ExprInit(Fts5Global*, sqlite3*);
+
+static int sqlite3Fts5ExprPhraseCount(Fts5Expr*);
+static int sqlite3Fts5ExprPhraseSize(Fts5Expr*, int iPhrase);
+static int sqlite3Fts5ExprPoslist(Fts5Expr*, int, const u8 **);
+
+static int sqlite3Fts5ExprClonePhrase(Fts5Config*, Fts5Expr*, int, Fts5Expr**);
+
+/*******************************************
+** The fts5_expr.c API above this point is used by the other hand-written
+** C code in this module. The interfaces below this point are called by
+** the parser code in fts5parse.y.  */
+
+static void sqlite3Fts5ParseError(Fts5Parse *pParse, const char *zFmt, ...);
+
+static Fts5ExprNode *sqlite3Fts5ParseNode(
+  Fts5Parse *pParse,
+  int eType,
+  Fts5ExprNode *pLeft,
+  Fts5ExprNode *pRight,
+  Fts5ExprNearset *pNear
+);
+
+static Fts5ExprPhrase *sqlite3Fts5ParseTerm(
+  Fts5Parse *pParse, 
+  Fts5ExprPhrase *pPhrase, 
+  Fts5Token *pToken,
+  int bPrefix
+);
+
+static Fts5ExprNearset *sqlite3Fts5ParseNearset(
+  Fts5Parse*, 
+  Fts5ExprNearset*,
+  Fts5ExprPhrase* 
+);
+
+static Fts5Colset *sqlite3Fts5ParseColset(
+  Fts5Parse*, 
+  Fts5Colset*, 
+  Fts5Token *
+);
+
+static void sqlite3Fts5ParsePhraseFree(Fts5ExprPhrase*);
+static void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset*);
+static void sqlite3Fts5ParseNodeFree(Fts5ExprNode*);
+
+static void sqlite3Fts5ParseSetDistance(Fts5Parse*, Fts5ExprNearset*, Fts5Token*);
+static void sqlite3Fts5ParseSetColset(Fts5Parse*, Fts5ExprNearset*, Fts5Colset*);
+static void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p);
+static void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token*);
+
+/*
+** End of interface to code in fts5_expr.c.
+**************************************************************************/
+
+
+
+/**************************************************************************
+** Interface to code in fts5_aux.c. 
+*/
+
+static int sqlite3Fts5AuxInit(fts5_api*);
+/*
+** End of interface to code in fts5_aux.c.
+**************************************************************************/
+
+/**************************************************************************
+** Interface to code in fts5_tokenizer.c. 
+*/
+
+static int sqlite3Fts5TokenizerInit(fts5_api*);
+/*
+** End of interface to code in fts5_tokenizer.c.
+**************************************************************************/
+
+/**************************************************************************
+** Interface to code in fts5_vocab.c. 
+*/
+
+static int sqlite3Fts5VocabInit(Fts5Global*, sqlite3*);
+
+/*
+** End of interface to code in fts5_vocab.c.
+**************************************************************************/
+
+
+/**************************************************************************
+** Interface to automatically generated code in fts5_unicode2.c. 
+*/
+static int sqlite3Fts5UnicodeIsalnum(int c);
+static int sqlite3Fts5UnicodeIsdiacritic(int c);
+static int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic);
+/*
+** End of interface to code in fts5_unicode2.c.
+**************************************************************************/
+
+#endif
+
+#define FTS5_OR                               1
+#define FTS5_AND                              2
+#define FTS5_NOT                              3
+#define FTS5_TERM                             4
+#define FTS5_COLON                            5
+#define FTS5_LP                               6
+#define FTS5_RP                               7
+#define FTS5_LCP                              8
+#define FTS5_RCP                              9
+#define FTS5_STRING                          10
+#define FTS5_COMMA                           11
+#define FTS5_PLUS                            12
+#define FTS5_STAR                            13
+
+/* Driver template for the LEMON parser generator.
+** The author disclaims copyright to this source code.
+**
+** This version of "lempar.c" is modified, slightly, for use by SQLite.
+** The only modifications are the addition of a couple of NEVER()
+** macros to disable tests that are needed in the case of a general
+** LALR(1) grammar but which are always false in the
+** specific grammar used by SQLite.
+*/
+/* First off, code is included that follows the "include" declaration
+** in the input grammar file. */
+/* #include <stdio.h> */
+
+
+/*
+** Disable all error recovery processing in the parser push-down
+** automaton.
+*/
+#define fts5YYNOERRORRECOVERY 1
+
+/*
+** Make fts5yytestcase() the same as testcase()
+*/
+#define fts5yytestcase(X) testcase(X)
+
+/* Next is all token values, in a form suitable for use by makeheaders.
+** This section will be null unless lemon is run with the -m switch.
+*/
+/* 
+** These constants (all generated automatically by the parser generator)
+** specify the various kinds of tokens (terminals) that the parser
+** understands. 
+**
+** Each symbol here is a terminal symbol in the grammar.
+*/
+/* Make sure the INTERFACE macro is defined.
+*/
+#ifndef INTERFACE
+# define INTERFACE 1
+#endif
+/* The next thing included is series of defines which control
+** various aspects of the generated parser.
+**    fts5YYCODETYPE         is the data type used for storing terminal
+**                       and nonterminal numbers.  "unsigned char" is
+**                       used if there are fewer than 250 terminals
+**                       and nonterminals.  "int" is used otherwise.
+**    fts5YYNOCODE           is a number of type fts5YYCODETYPE which corresponds
+**                       to no legal terminal or nonterminal number.  This
+**                       number is used to fill in empty slots of the hash 
+**                       table.
+**    fts5YYFALLBACK         If defined, this indicates that one or more tokens
+**                       have fall-back values which should be used if the
+**                       original value of the token will not parse.
+**    fts5YYACTIONTYPE       is the data type used for storing terminal
+**                       and nonterminal numbers.  "unsigned char" is
+**                       used if there are fewer than 250 rules and
+**                       states combined.  "int" is used otherwise.
+**    sqlite3Fts5ParserFTS5TOKENTYPE     is the data type used for minor tokens given 
+**                       directly to the parser from the tokenizer.
+**    fts5YYMINORTYPE        is the data type used for all minor tokens.
+**                       This is typically a union of many types, one of
+**                       which is sqlite3Fts5ParserFTS5TOKENTYPE.  The entry in the union
+**                       for base tokens is called "fts5yy0".
+**    fts5YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
+**                       zero the stack is dynamically sized using realloc()
+**    sqlite3Fts5ParserARG_SDECL     A static variable declaration for the %extra_argument
+**    sqlite3Fts5ParserARG_PDECL     A parameter declaration for the %extra_argument
+**    sqlite3Fts5ParserARG_STORE     Code to store %extra_argument into fts5yypParser
+**    sqlite3Fts5ParserARG_FETCH     Code to extract %extra_argument from fts5yypParser
+**    fts5YYERRORSYMBOL      is the code number of the error symbol.  If not
+**                       defined, then do no error processing.
+**    fts5YYNSTATE           the combined number of states.
+**    fts5YYNRULE            the number of rules in the grammar
+**    fts5YY_MAX_SHIFT       Maximum value for shift actions
+**    fts5YY_MIN_SHIFTREDUCE Minimum value for shift-reduce actions
+**    fts5YY_MAX_SHIFTREDUCE Maximum value for shift-reduce actions
+**    fts5YY_MIN_REDUCE      Maximum value for reduce actions
+**    fts5YY_ERROR_ACTION    The fts5yy_action[] code for syntax error
+**    fts5YY_ACCEPT_ACTION   The fts5yy_action[] code for accept
+**    fts5YY_NO_ACTION       The fts5yy_action[] code for no-op
+*/
+#define fts5YYCODETYPE unsigned char
+#define fts5YYNOCODE 27
+#define fts5YYACTIONTYPE unsigned char
+#define sqlite3Fts5ParserFTS5TOKENTYPE Fts5Token
+typedef union {
+  int fts5yyinit;
+  sqlite3Fts5ParserFTS5TOKENTYPE fts5yy0;
+  Fts5Colset* fts5yy3;
+  Fts5ExprPhrase* fts5yy11;
+  Fts5ExprNode* fts5yy18;
+  int fts5yy20;
+  Fts5ExprNearset* fts5yy26;
+} fts5YYMINORTYPE;
+#ifndef fts5YYSTACKDEPTH
+#define fts5YYSTACKDEPTH 100
+#endif
+#define sqlite3Fts5ParserARG_SDECL Fts5Parse *pParse;
+#define sqlite3Fts5ParserARG_PDECL ,Fts5Parse *pParse
+#define sqlite3Fts5ParserARG_FETCH Fts5Parse *pParse = fts5yypParser->pParse
+#define sqlite3Fts5ParserARG_STORE fts5yypParser->pParse = pParse
+#define fts5YYNSTATE             26
+#define fts5YYNRULE              24
+#define fts5YY_MAX_SHIFT         25
+#define fts5YY_MIN_SHIFTREDUCE   40
+#define fts5YY_MAX_SHIFTREDUCE   63
+#define fts5YY_MIN_REDUCE        64
+#define fts5YY_MAX_REDUCE        87
+#define fts5YY_ERROR_ACTION      88
+#define fts5YY_ACCEPT_ACTION     89
+#define fts5YY_NO_ACTION         90
+
+/* The fts5yyzerominor constant is used to initialize instances of
+** fts5YYMINORTYPE objects to zero. */
+static const fts5YYMINORTYPE fts5yyzerominor = { 0 };
+
+/* Define the fts5yytestcase() macro to be a no-op if is not already defined
+** otherwise.
+**
+** Applications can choose to define fts5yytestcase() in the %include section
+** to a macro that can assist in verifying code coverage.  For production
+** code the fts5yytestcase() macro should be turned off.  But it is useful
+** for testing.
+*/
+#ifndef fts5yytestcase
+# define fts5yytestcase(X)
+#endif
+
+
+/* Next are the tables used to determine what action to take based on the
+** current state and lookahead token.  These tables are used to implement
+** functions that take a state number and lookahead value and return an
+** action integer.  
+**
+** Suppose the action integer is N.  Then the action is determined as
+** follows
+**
+**   0 <= N <= fts5YY_MAX_SHIFT             Shift N.  That is, push the lookahead
+**                                      token onto the stack and goto state N.
+**
+**   N between fts5YY_MIN_SHIFTREDUCE       Shift to an arbitrary state then
+**     and fts5YY_MAX_SHIFTREDUCE           reduce by rule N-fts5YY_MIN_SHIFTREDUCE.
+**
+**   N between fts5YY_MIN_REDUCE            Reduce by rule N-fts5YY_MIN_REDUCE
+**     and fts5YY_MAX_REDUCE
+
+**   N == fts5YY_ERROR_ACTION               A syntax error has occurred.
+**
+**   N == fts5YY_ACCEPT_ACTION              The parser accepts its input.
+**
+**   N == fts5YY_NO_ACTION                  No such action.  Denotes unused
+**                                      slots in the fts5yy_action[] table.
+**
+** The action table is constructed as a single large table named fts5yy_action[].
+** Given state S and lookahead X, the action is computed as
+**
+**      fts5yy_action[ fts5yy_shift_ofst[S] + X ]
+**
+** If the index value fts5yy_shift_ofst[S]+X is out of range or if the value
+** fts5yy_lookahead[fts5yy_shift_ofst[S]+X] is not equal to X or if fts5yy_shift_ofst[S]
+** is equal to fts5YY_SHIFT_USE_DFLT, it means that the action is not in the table
+** and that fts5yy_default[S] should be used instead.  
+**
+** The formula above is for computing the action when the lookahead is
+** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
+** a reduce action) then the fts5yy_reduce_ofst[] array is used in place of
+** the fts5yy_shift_ofst[] array and fts5YY_REDUCE_USE_DFLT is used in place of
+** fts5YY_SHIFT_USE_DFLT.
+**
+** The following are the tables generated in this section:
+**
+**  fts5yy_action[]        A single table containing all actions.
+**  fts5yy_lookahead[]     A table containing the lookahead for each entry in
+**                     fts5yy_action.  Used to detect hash collisions.
+**  fts5yy_shift_ofst[]    For each state, the offset into fts5yy_action for
+**                     shifting terminals.
+**  fts5yy_reduce_ofst[]   For each state, the offset into fts5yy_action for
+**                     shifting non-terminals after a reduce.
+**  fts5yy_default[]       Default action for each state.
+*/
+#define fts5YY_ACTTAB_COUNT (78)
+static const fts5YYACTIONTYPE fts5yy_action[] = {
+ /*     0 */    89,   15,   46,    5,   48,   24,   12,   19,   23,   14,
+ /*    10 */    46,    5,   48,   24,   20,   21,   23,   43,   46,    5,
+ /*    20 */    48,   24,    6,   18,   23,   17,   46,    5,   48,   24,
+ /*    30 */    75,    7,   23,   25,   46,    5,   48,   24,   62,   47,
+ /*    40 */    23,   48,   24,    7,   11,   23,    9,    3,    4,    2,
+ /*    50 */    62,   50,   52,   44,   64,    3,    4,    2,   49,    4,
+ /*    60 */     2,    1,   23,   11,   16,    9,   12,    2,   10,   61,
+ /*    70 */    53,   59,   62,   60,   22,   13,   55,    8,
+};
+static const fts5YYCODETYPE fts5yy_lookahead[] = {
+ /*     0 */    15,   16,   17,   18,   19,   20,   10,   11,   23,   16,
+ /*    10 */    17,   18,   19,   20,   23,   24,   23,   16,   17,   18,
+ /*    20 */    19,   20,   22,   23,   23,   16,   17,   18,   19,   20,
+ /*    30 */     5,    6,   23,   16,   17,   18,   19,   20,   13,   17,
+ /*    40 */    23,   19,   20,    6,    8,   23,   10,    1,    2,    3,
+ /*    50 */    13,    9,   10,    7,    0,    1,    2,    3,   19,    2,
+ /*    60 */     3,    6,   23,    8,   21,   10,   10,    3,   10,   25,
+ /*    70 */    10,   10,   13,   25,   12,   10,    7,    5,
+};
+#define fts5YY_SHIFT_USE_DFLT (-5)
+#define fts5YY_SHIFT_COUNT (25)
+#define fts5YY_SHIFT_MIN   (-4)
+#define fts5YY_SHIFT_MAX   (72)
+static const signed char fts5yy_shift_ofst[] = {
+ /*     0 */    55,   55,   55,   55,   55,   36,   -4,   56,   58,   25,
+ /*    10 */    37,   60,   59,   59,   46,   54,   42,   57,   62,   61,
+ /*    20 */    62,   69,   65,   62,   72,   64,
+};
+#define fts5YY_REDUCE_USE_DFLT (-16)
+#define fts5YY_REDUCE_COUNT (13)
+#define fts5YY_REDUCE_MIN   (-15)
+#define fts5YY_REDUCE_MAX   (48)
+static const signed char fts5yy_reduce_ofst[] = {
+ /*     0 */   -15,   -7,    1,    9,   17,   22,   -9,    0,   39,   44,
+ /*    10 */    44,   43,   44,   48,
+};
+static const fts5YYACTIONTYPE fts5yy_default[] = {
+ /*     0 */    88,   88,   88,   88,   88,   69,   82,   88,   88,   87,
+ /*    10 */    87,   88,   87,   87,   88,   88,   88,   66,   80,   88,
+ /*    20 */    81,   88,   88,   78,   88,   65,
+};
+
+/* The next table maps tokens into fallback tokens.  If a construct
+** like the following:
+** 
+**      %fallback ID X Y Z.
+**
+** appears in the grammar, then ID becomes a fallback token for X, Y,
+** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
+** but it does not parse, the type of the token is changed to ID and
+** the parse is retried before an error is thrown.
+*/
+#ifdef fts5YYFALLBACK
+static const fts5YYCODETYPE fts5yyFallback[] = {
+};
+#endif /* fts5YYFALLBACK */
+
+/* The following structure represents a single element of the
+** parser's stack.  Information stored includes:
+**
+**   +  The state number for the parser at this level of the stack.
+**
+**   +  The value of the token stored at this level of the stack.
+**      (In other words, the "major" token.)
+**
+**   +  The semantic value stored at this level of the stack.  This is
+**      the information used by the action routines in the grammar.
+**      It is sometimes called the "minor" token.
+**
+** After the "shift" half of a SHIFTREDUCE action, the stateno field
+** actually contains the reduce action for the second half of the
+** SHIFTREDUCE.
+*/
+struct fts5yyStackEntry {
+  fts5YYACTIONTYPE stateno;  /* The state-number, or reduce action in SHIFTREDUCE */
+  fts5YYCODETYPE major;      /* The major token value.  This is the code
+                         ** number for the token at this stack level */
+  fts5YYMINORTYPE minor;     /* The user-supplied minor token value.  This
+                         ** is the value of the token  */
+};
+typedef struct fts5yyStackEntry fts5yyStackEntry;
+
+/* The state of the parser is completely contained in an instance of
+** the following structure */
+struct fts5yyParser {
+  int fts5yyidx;                    /* Index of top element in stack */
+#ifdef fts5YYTRACKMAXSTACKDEPTH
+  int fts5yyidxMax;                 /* Maximum value of fts5yyidx */
+#endif
+  int fts5yyerrcnt;                 /* Shifts left before out of the error */
+  sqlite3Fts5ParserARG_SDECL                /* A place to hold %extra_argument */
+#if fts5YYSTACKDEPTH<=0
+  int fts5yystksz;                  /* Current side of the stack */
+  fts5yyStackEntry *fts5yystack;        /* The parser's stack */
+#else
+  fts5yyStackEntry fts5yystack[fts5YYSTACKDEPTH];  /* The parser's stack */
+#endif
+};
+typedef struct fts5yyParser fts5yyParser;
+
+#ifndef NDEBUG
+/* #include <stdio.h> */
+static FILE *fts5yyTraceFILE = 0;
+static char *fts5yyTracePrompt = 0;
+#endif /* NDEBUG */
+
+#ifndef NDEBUG
+/* 
+** Turn parser tracing on by giving a stream to which to write the trace
+** and a prompt to preface each trace message.  Tracing is turned off
+** by making either argument NULL 
+**
+** Inputs:
+** <ul>
+** <li> A FILE* to which trace output should be written.
+**      If NULL, then tracing is turned off.
+** <li> A prefix string written at the beginning of every
+**      line of trace output.  If NULL, then tracing is
+**      turned off.
+** </ul>
+**
+** Outputs:
+** None.
+*/
+static void sqlite3Fts5ParserTrace(FILE *TraceFILE, char *zTracePrompt){
+  fts5yyTraceFILE = TraceFILE;
+  fts5yyTracePrompt = zTracePrompt;
+  if( fts5yyTraceFILE==0 ) fts5yyTracePrompt = 0;
+  else if( fts5yyTracePrompt==0 ) fts5yyTraceFILE = 0;
+}
+#endif /* NDEBUG */
+
+#ifndef NDEBUG
+/* For tracing shifts, the names of all terminals and nonterminals
+** are required.  The following table supplies these names */
+static const char *const fts5yyTokenName[] = { 
+  "$",             "OR",            "AND",           "NOT",         
+  "TERM",          "COLON",         "LP",            "RP",          
+  "LCP",           "RCP",           "STRING",        "COMMA",       
+  "PLUS",          "STAR",          "error",         "input",       
+  "expr",          "cnearset",      "exprlist",      "nearset",     
+  "colset",        "colsetlist",    "nearphrases",   "phrase",      
+  "neardist_opt",  "star_opt",    
+};
+#endif /* NDEBUG */
+
+#ifndef NDEBUG
+/* For tracing reduce actions, the names of all rules are required.
+*/
+static const char *const fts5yyRuleName[] = {
+ /*   0 */ "input ::= expr",
+ /*   1 */ "expr ::= expr AND expr",
+ /*   2 */ "expr ::= expr OR expr",
+ /*   3 */ "expr ::= expr NOT expr",
+ /*   4 */ "expr ::= LP expr RP",
+ /*   5 */ "expr ::= exprlist",
+ /*   6 */ "exprlist ::= cnearset",
+ /*   7 */ "exprlist ::= exprlist cnearset",
+ /*   8 */ "cnearset ::= nearset",
+ /*   9 */ "cnearset ::= colset COLON nearset",
+ /*  10 */ "colset ::= LCP colsetlist RCP",
+ /*  11 */ "colset ::= STRING",
+ /*  12 */ "colsetlist ::= colsetlist STRING",
+ /*  13 */ "colsetlist ::= STRING",
+ /*  14 */ "nearset ::= phrase",
+ /*  15 */ "nearset ::= STRING LP nearphrases neardist_opt RP",
+ /*  16 */ "nearphrases ::= phrase",
+ /*  17 */ "nearphrases ::= nearphrases phrase",
+ /*  18 */ "neardist_opt ::=",
+ /*  19 */ "neardist_opt ::= COMMA STRING",
+ /*  20 */ "phrase ::= phrase PLUS STRING star_opt",
+ /*  21 */ "phrase ::= STRING star_opt",
+ /*  22 */ "star_opt ::= STAR",
+ /*  23 */ "star_opt ::=",
+};
+#endif /* NDEBUG */
+
+
+#if fts5YYSTACKDEPTH<=0
+/*
+** Try to increase the size of the parser stack.
+*/
+static void fts5yyGrowStack(fts5yyParser *p){
+  int newSize;
+  fts5yyStackEntry *pNew;
+
+  newSize = p->fts5yystksz*2 + 100;
+  pNew = realloc(p->fts5yystack, newSize*sizeof(pNew[0]));
+  if( pNew ){
+    p->fts5yystack = pNew;
+    p->fts5yystksz = newSize;
+#ifndef NDEBUG
+    if( fts5yyTraceFILE ){
+      fprintf(fts5yyTraceFILE,"%sStack grows to %d entries!\n",
+              fts5yyTracePrompt, p->fts5yystksz);
+    }
+#endif
+  }
+}
+#endif
+
+/* 
+** This function allocates a new parser.
+** The only argument is a pointer to a function which works like
+** malloc.
+**
+** Inputs:
+** A pointer to the function used to allocate memory.
+**
+** Outputs:
+** A pointer to a parser.  This pointer is used in subsequent calls
+** to sqlite3Fts5Parser and sqlite3Fts5ParserFree.
+*/
+static void *sqlite3Fts5ParserAlloc(void *(*mallocProc)(u64)){
+  fts5yyParser *pParser;
+  pParser = (fts5yyParser*)(*mallocProc)( (u64)sizeof(fts5yyParser) );
+  if( pParser ){
+    pParser->fts5yyidx = -1;
+#ifdef fts5YYTRACKMAXSTACKDEPTH
+    pParser->fts5yyidxMax = 0;
+#endif
+#if fts5YYSTACKDEPTH<=0
+    pParser->fts5yystack = NULL;
+    pParser->fts5yystksz = 0;
+    fts5yyGrowStack(pParser);
+#endif
+  }
+  return pParser;
+}
+
+/* The following function deletes the value associated with a
+** symbol.  The symbol can be either a terminal or nonterminal.
+** "fts5yymajor" is the symbol code, and "fts5yypminor" is a pointer to
+** the value.
+*/
+static void fts5yy_destructor(
+  fts5yyParser *fts5yypParser,    /* The parser */
+  fts5YYCODETYPE fts5yymajor,     /* Type code for object to destroy */
+  fts5YYMINORTYPE *fts5yypminor   /* The object to be destroyed */
+){
+  sqlite3Fts5ParserARG_FETCH;
+  switch( fts5yymajor ){
+    /* Here is inserted the actions which take place when a
+    ** terminal or non-terminal is destroyed.  This can happen
+    ** when the symbol is popped from the stack during a
+    ** reduce or during error processing or when a parser is 
+    ** being destroyed before it is finished parsing.
+    **
+    ** Note: during a reduce, the only symbols destroyed are those
+    ** which appear on the RHS of the rule, but which are not used
+    ** inside the C code.
+    */
+    case 15: /* input */
+{
+ (void)pParse; 
+}
+      break;
+    case 16: /* expr */
+    case 17: /* cnearset */
+    case 18: /* exprlist */
+{
+ sqlite3Fts5ParseNodeFree((fts5yypminor->fts5yy18)); 
+}
+      break;
+    case 19: /* nearset */
+    case 22: /* nearphrases */
+{
+ sqlite3Fts5ParseNearsetFree((fts5yypminor->fts5yy26)); 
+}
+      break;
+    case 20: /* colset */
+    case 21: /* colsetlist */
+{
+ sqlite3_free((fts5yypminor->fts5yy3)); 
+}
+      break;
+    case 23: /* phrase */
+{
+ sqlite3Fts5ParsePhraseFree((fts5yypminor->fts5yy11)); 
+}
+      break;
+    default:  break;   /* If no destructor action specified: do nothing */
+  }
+}
+
+/*
+** Pop the parser's stack once.
+**
+** If there is a destructor routine associated with the token which
+** is popped from the stack, then call it.
+**
+** Return the major token number for the symbol popped.
+*/
+static int fts5yy_pop_parser_stack(fts5yyParser *pParser){
+  fts5YYCODETYPE fts5yymajor;
+  fts5yyStackEntry *fts5yytos = &pParser->fts5yystack[pParser->fts5yyidx];
+
+  /* There is no mechanism by which the parser stack can be popped below
+  ** empty in SQLite.  */
+  assert( pParser->fts5yyidx>=0 );
+#ifndef NDEBUG
+  if( fts5yyTraceFILE && pParser->fts5yyidx>=0 ){
+    fprintf(fts5yyTraceFILE,"%sPopping %s\n",
+      fts5yyTracePrompt,
+      fts5yyTokenName[fts5yytos->major]);
+  }
+#endif
+  fts5yymajor = fts5yytos->major;
+  fts5yy_destructor(pParser, fts5yymajor, &fts5yytos->minor);
+  pParser->fts5yyidx--;
+  return fts5yymajor;
+}
+
+/* 
+** Deallocate and destroy a parser.  Destructors are all called for
+** all stack elements before shutting the parser down.
+**
+** Inputs:
+** <ul>
+** <li>  A pointer to the parser.  This should be a pointer
+**       obtained from sqlite3Fts5ParserAlloc.
+** <li>  A pointer to a function used to reclaim memory obtained
+**       from malloc.
+** </ul>
+*/
+static void sqlite3Fts5ParserFree(
+  void *p,                    /* The parser to be deleted */
+  void (*freeProc)(void*)     /* Function used to reclaim memory */
+){
+  fts5yyParser *pParser = (fts5yyParser*)p;
+  /* In SQLite, we never try to destroy a parser that was not successfully
+  ** created in the first place. */
+  if( NEVER(pParser==0) ) return;
+  while( pParser->fts5yyidx>=0 ) fts5yy_pop_parser_stack(pParser);
+#if fts5YYSTACKDEPTH<=0
+  free(pParser->fts5yystack);
+#endif
+  (*freeProc)((void*)pParser);
+}
+
+/*
+** Return the peak depth of the stack for a parser.
+*/
+#ifdef fts5YYTRACKMAXSTACKDEPTH
+static int sqlite3Fts5ParserStackPeak(void *p){
+  fts5yyParser *pParser = (fts5yyParser*)p;
+  return pParser->fts5yyidxMax;
+}
+#endif
+
+/*
+** Find the appropriate action for a parser given the terminal
+** look-ahead token iLookAhead.
+**
+** If the look-ahead token is fts5YYNOCODE, then check to see if the action is
+** independent of the look-ahead.  If it is, return the action, otherwise
+** return fts5YY_NO_ACTION.
+*/
+static int fts5yy_find_shift_action(
+  fts5yyParser *pParser,        /* The parser */
+  fts5YYCODETYPE iLookAhead     /* The look-ahead token */
+){
+  int i;
+  int stateno = pParser->fts5yystack[pParser->fts5yyidx].stateno;
+ 
+  if( stateno>=fts5YY_MIN_REDUCE ) return stateno;
+  assert( stateno <= fts5YY_SHIFT_COUNT );
+  i = fts5yy_shift_ofst[stateno];
+  if( i==fts5YY_SHIFT_USE_DFLT ) return fts5yy_default[stateno];
+  assert( iLookAhead!=fts5YYNOCODE );
+  i += iLookAhead;
+  if( i<0 || i>=fts5YY_ACTTAB_COUNT || fts5yy_lookahead[i]!=iLookAhead ){
+    if( iLookAhead>0 ){
+#ifdef fts5YYFALLBACK
+      fts5YYCODETYPE iFallback;            /* Fallback token */
+      if( iLookAhead<sizeof(fts5yyFallback)/sizeof(fts5yyFallback[0])
+             && (iFallback = fts5yyFallback[iLookAhead])!=0 ){
+#ifndef NDEBUG
+        if( fts5yyTraceFILE ){
+          fprintf(fts5yyTraceFILE, "%sFALLBACK %s => %s\n",
+             fts5yyTracePrompt, fts5yyTokenName[iLookAhead], fts5yyTokenName[iFallback]);
+        }
+#endif
+        return fts5yy_find_shift_action(pParser, iFallback);
+      }
+#endif
+#ifdef fts5YYWILDCARD
+      {
+        int j = i - iLookAhead + fts5YYWILDCARD;
+        if( 
+#if fts5YY_SHIFT_MIN+fts5YYWILDCARD<0
+          j>=0 &&
+#endif
+#if fts5YY_SHIFT_MAX+fts5YYWILDCARD>=fts5YY_ACTTAB_COUNT
+          j<fts5YY_ACTTAB_COUNT &&
+#endif
+          fts5yy_lookahead[j]==fts5YYWILDCARD
+        ){
+#ifndef NDEBUG
+          if( fts5yyTraceFILE ){
+            fprintf(fts5yyTraceFILE, "%sWILDCARD %s => %s\n",
+               fts5yyTracePrompt, fts5yyTokenName[iLookAhead], fts5yyTokenName[fts5YYWILDCARD]);
+          }
+#endif /* NDEBUG */
+          return fts5yy_action[j];
+        }
+      }
+#endif /* fts5YYWILDCARD */
+    }
+    return fts5yy_default[stateno];
+  }else{
+    return fts5yy_action[i];
+  }
+}
+
+/*
+** Find the appropriate action for a parser given the non-terminal
+** look-ahead token iLookAhead.
+**
+** If the look-ahead token is fts5YYNOCODE, then check to see if the action is
+** independent of the look-ahead.  If it is, return the action, otherwise
+** return fts5YY_NO_ACTION.
+*/
+static int fts5yy_find_reduce_action(
+  int stateno,              /* Current state number */
+  fts5YYCODETYPE iLookAhead     /* The look-ahead token */
+){
+  int i;
+#ifdef fts5YYERRORSYMBOL
+  if( stateno>fts5YY_REDUCE_COUNT ){
+    return fts5yy_default[stateno];
+  }
+#else
+  assert( stateno<=fts5YY_REDUCE_COUNT );
+#endif
+  i = fts5yy_reduce_ofst[stateno];
+  assert( i!=fts5YY_REDUCE_USE_DFLT );
+  assert( iLookAhead!=fts5YYNOCODE );
+  i += iLookAhead;
+#ifdef fts5YYERRORSYMBOL
+  if( i<0 || i>=fts5YY_ACTTAB_COUNT || fts5yy_lookahead[i]!=iLookAhead ){
+    return fts5yy_default[stateno];
+  }
+#else
+  assert( i>=0 && i<fts5YY_ACTTAB_COUNT );
+  assert( fts5yy_lookahead[i]==iLookAhead );
+#endif
+  return fts5yy_action[i];
+}
+
+/*
+** The following routine is called if the stack overflows.
+*/
+static void fts5yyStackOverflow(fts5yyParser *fts5yypParser, fts5YYMINORTYPE *fts5yypMinor){
+   sqlite3Fts5ParserARG_FETCH;
+   fts5yypParser->fts5yyidx--;
+#ifndef NDEBUG
+   if( fts5yyTraceFILE ){
+     fprintf(fts5yyTraceFILE,"%sStack Overflow!\n",fts5yyTracePrompt);
+   }
+#endif
+   while( fts5yypParser->fts5yyidx>=0 ) fts5yy_pop_parser_stack(fts5yypParser);
+   /* Here code is inserted which will execute if the parser
+   ** stack every overflows */
+
+  assert( 0 );
+   sqlite3Fts5ParserARG_STORE; /* Suppress warning about unused %extra_argument var */
+}
+
+/*
+** Print tracing information for a SHIFT action
+*/
+#ifndef NDEBUG
+static void fts5yyTraceShift(fts5yyParser *fts5yypParser, int fts5yyNewState){
+  if( fts5yyTraceFILE ){
+    int i;
+    if( fts5yyNewState<fts5YYNSTATE ){
+      fprintf(fts5yyTraceFILE,"%sShift %d\n",fts5yyTracePrompt,fts5yyNewState);
+      fprintf(fts5yyTraceFILE,"%sStack:",fts5yyTracePrompt);
+      for(i=1; i<=fts5yypParser->fts5yyidx; i++)
+        fprintf(fts5yyTraceFILE," %s",fts5yyTokenName[fts5yypParser->fts5yystack[i].major]);
+      fprintf(fts5yyTraceFILE,"\n");
+    }else{
+      fprintf(fts5yyTraceFILE,"%sShift *\n",fts5yyTracePrompt);
+    }
+  }
+}
+#else
+# define fts5yyTraceShift(X,Y)
+#endif
+
+/*
+** Perform a shift action.  Return the number of errors.
+*/
+static void fts5yy_shift(
+  fts5yyParser *fts5yypParser,          /* The parser to be shifted */
+  int fts5yyNewState,               /* The new state to shift in */
+  int fts5yyMajor,                  /* The major token to shift in */
+  fts5YYMINORTYPE *fts5yypMinor         /* Pointer to the minor token to shift in */
+){
+  fts5yyStackEntry *fts5yytos;
+  fts5yypParser->fts5yyidx++;
+#ifdef fts5YYTRACKMAXSTACKDEPTH
+  if( fts5yypParser->fts5yyidx>fts5yypParser->fts5yyidxMax ){
+    fts5yypParser->fts5yyidxMax = fts5yypParser->fts5yyidx;
+  }
+#endif
+#if fts5YYSTACKDEPTH>0 
+  if( fts5yypParser->fts5yyidx>=fts5YYSTACKDEPTH ){
+    fts5yyStackOverflow(fts5yypParser, fts5yypMinor);
+    return;
+  }
+#else
+  if( fts5yypParser->fts5yyidx>=fts5yypParser->fts5yystksz ){
+    fts5yyGrowStack(fts5yypParser);
+    if( fts5yypParser->fts5yyidx>=fts5yypParser->fts5yystksz ){
+      fts5yyStackOverflow(fts5yypParser, fts5yypMinor);
+      return;
+    }
+  }
+#endif
+  fts5yytos = &fts5yypParser->fts5yystack[fts5yypParser->fts5yyidx];
+  fts5yytos->stateno = (fts5YYACTIONTYPE)fts5yyNewState;
+  fts5yytos->major = (fts5YYCODETYPE)fts5yyMajor;
+  fts5yytos->minor = *fts5yypMinor;
+  fts5yyTraceShift(fts5yypParser, fts5yyNewState);
+}
+
+/* The following table contains information about every rule that
+** is used during the reduce.
+*/
+static const struct {
+  fts5YYCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
+  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
+} fts5yyRuleInfo[] = {
+  { 15, 1 },
+  { 16, 3 },
+  { 16, 3 },
+  { 16, 3 },
+  { 16, 3 },
+  { 16, 1 },
+  { 18, 1 },
+  { 18, 2 },
+  { 17, 1 },
+  { 17, 3 },
+  { 20, 3 },
+  { 20, 1 },
+  { 21, 2 },
+  { 21, 1 },
+  { 19, 1 },
+  { 19, 5 },
+  { 22, 1 },
+  { 22, 2 },
+  { 24, 0 },
+  { 24, 2 },
+  { 23, 4 },
+  { 23, 2 },
+  { 25, 1 },
+  { 25, 0 },
+};
+
+static void fts5yy_accept(fts5yyParser*);  /* Forward Declaration */
+
+/*
+** Perform a reduce action and the shift that must immediately
+** follow the reduce.
+*/
+static void fts5yy_reduce(
+  fts5yyParser *fts5yypParser,         /* The parser */
+  int fts5yyruleno                 /* Number of the rule by which to reduce */
+){
+  int fts5yygoto;                     /* The next state */
+  int fts5yyact;                      /* The next action */
+  fts5YYMINORTYPE fts5yygotominor;        /* The LHS of the rule reduced */
+  fts5yyStackEntry *fts5yymsp;            /* The top of the parser's stack */
+  int fts5yysize;                     /* Amount to pop the stack */
+  sqlite3Fts5ParserARG_FETCH;
+  fts5yymsp = &fts5yypParser->fts5yystack[fts5yypParser->fts5yyidx];
+#ifndef NDEBUG
+  if( fts5yyTraceFILE && fts5yyruleno>=0 
+        && fts5yyruleno<(int)(sizeof(fts5yyRuleName)/sizeof(fts5yyRuleName[0])) ){
+    fts5yysize = fts5yyRuleInfo[fts5yyruleno].nrhs;
+    fprintf(fts5yyTraceFILE, "%sReduce [%s] -> state %d.\n", fts5yyTracePrompt,
+      fts5yyRuleName[fts5yyruleno], fts5yymsp[-fts5yysize].stateno);
+  }
+#endif /* NDEBUG */
+
+  /* Silence complaints from purify about fts5yygotominor being uninitialized
+  ** in some cases when it is copied into the stack after the following
+  ** switch.  fts5yygotominor is uninitialized when a rule reduces that does
+  ** not set the value of its left-hand side nonterminal.  Leaving the
+  ** value of the nonterminal uninitialized is utterly harmless as long
+  ** as the value is never used.  So really the only thing this code
+  ** accomplishes is to quieten purify.  
+  **
+  ** 2007-01-16:  The wireshark project (www.wireshark.org) reports that
+  ** without this code, their parser segfaults.  I'm not sure what there
+  ** parser is doing to make this happen.  This is the second bug report
+  ** from wireshark this week.  Clearly they are stressing Lemon in ways
+  ** that it has not been previously stressed...  (SQLite ticket #2172)
+  */
+  /*memset(&fts5yygotominor, 0, sizeof(fts5yygotominor));*/
+  fts5yygotominor = fts5yyzerominor;
+
+
+  switch( fts5yyruleno ){
+  /* Beginning here are the reduction cases.  A typical example
+  ** follows:
+  **   case 0:
+  **  #line <lineno> <grammarfile>
+  **     { ... }           // User supplied code
+  **  #line <lineno> <thisfile>
+  **     break;
+  */
+      case 0: /* input ::= expr */
+{ sqlite3Fts5ParseFinished(pParse, fts5yymsp[0].minor.fts5yy18); }
+        break;
+      case 1: /* expr ::= expr AND expr */
+{
+  fts5yygotominor.fts5yy18 = sqlite3Fts5ParseNode(pParse, FTS5_AND, fts5yymsp[-2].minor.fts5yy18, fts5yymsp[0].minor.fts5yy18, 0);
+}
+        break;
+      case 2: /* expr ::= expr OR expr */
+{
+  fts5yygotominor.fts5yy18 = sqlite3Fts5ParseNode(pParse, FTS5_OR, fts5yymsp[-2].minor.fts5yy18, fts5yymsp[0].minor.fts5yy18, 0);
+}
+        break;
+      case 3: /* expr ::= expr NOT expr */
+{
+  fts5yygotominor.fts5yy18 = sqlite3Fts5ParseNode(pParse, FTS5_NOT, fts5yymsp[-2].minor.fts5yy18, fts5yymsp[0].minor.fts5yy18, 0);
+}
+        break;
+      case 4: /* expr ::= LP expr RP */
+{fts5yygotominor.fts5yy18 = fts5yymsp[-1].minor.fts5yy18;}
+        break;
+      case 5: /* expr ::= exprlist */
+      case 6: /* exprlist ::= cnearset */ fts5yytestcase(fts5yyruleno==6);
+{fts5yygotominor.fts5yy18 = fts5yymsp[0].minor.fts5yy18;}
+        break;
+      case 7: /* exprlist ::= exprlist cnearset */
+{
+  fts5yygotominor.fts5yy18 = sqlite3Fts5ParseNode(pParse, FTS5_AND, fts5yymsp[-1].minor.fts5yy18, fts5yymsp[0].minor.fts5yy18, 0);
+}
+        break;
+      case 8: /* cnearset ::= nearset */
+{ 
+  fts5yygotominor.fts5yy18 = sqlite3Fts5ParseNode(pParse, FTS5_STRING, 0, 0, fts5yymsp[0].minor.fts5yy26); 
+}
+        break;
+      case 9: /* cnearset ::= colset COLON nearset */
+{ 
+  sqlite3Fts5ParseSetColset(pParse, fts5yymsp[0].minor.fts5yy26, fts5yymsp[-2].minor.fts5yy3);
+  fts5yygotominor.fts5yy18 = sqlite3Fts5ParseNode(pParse, FTS5_STRING, 0, 0, fts5yymsp[0].minor.fts5yy26); 
+}
+        break;
+      case 10: /* colset ::= LCP colsetlist RCP */
+{ fts5yygotominor.fts5yy3 = fts5yymsp[-1].minor.fts5yy3; }
+        break;
+      case 11: /* colset ::= STRING */
+{
+  fts5yygotominor.fts5yy3 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);
+}
+        break;
+      case 12: /* colsetlist ::= colsetlist STRING */
+{ 
+  fts5yygotominor.fts5yy3 = sqlite3Fts5ParseColset(pParse, fts5yymsp[-1].minor.fts5yy3, &fts5yymsp[0].minor.fts5yy0); }
+        break;
+      case 13: /* colsetlist ::= STRING */
+{ 
+  fts5yygotominor.fts5yy3 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0); 
+}
+        break;
+      case 14: /* nearset ::= phrase */
+{ fts5yygotominor.fts5yy26 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy11); }
+        break;
+      case 15: /* nearset ::= STRING LP nearphrases neardist_opt RP */
+{
+  sqlite3Fts5ParseNear(pParse, &fts5yymsp[-4].minor.fts5yy0);
+  sqlite3Fts5ParseSetDistance(pParse, fts5yymsp[-2].minor.fts5yy26, &fts5yymsp[-1].minor.fts5yy0);
+  fts5yygotominor.fts5yy26 = fts5yymsp[-2].minor.fts5yy26;
+}
+        break;
+      case 16: /* nearphrases ::= phrase */
+{ 
+  fts5yygotominor.fts5yy26 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy11); 
+}
+        break;
+      case 17: /* nearphrases ::= nearphrases phrase */
+{
+  fts5yygotominor.fts5yy26 = sqlite3Fts5ParseNearset(pParse, fts5yymsp[-1].minor.fts5yy26, fts5yymsp[0].minor.fts5yy11);
+}
+        break;
+      case 18: /* neardist_opt ::= */
+{ fts5yygotominor.fts5yy0.p = 0; fts5yygotominor.fts5yy0.n = 0; }
+        break;
+      case 19: /* neardist_opt ::= COMMA STRING */
+{ fts5yygotominor.fts5yy0 = fts5yymsp[0].minor.fts5yy0; }
+        break;
+      case 20: /* phrase ::= phrase PLUS STRING star_opt */
+{ 
+  fts5yygotominor.fts5yy11 = sqlite3Fts5ParseTerm(pParse, fts5yymsp[-3].minor.fts5yy11, &fts5yymsp[-1].minor.fts5yy0, fts5yymsp[0].minor.fts5yy20);
+}
+        break;
+      case 21: /* phrase ::= STRING star_opt */
+{ 
+  fts5yygotominor.fts5yy11 = sqlite3Fts5ParseTerm(pParse, 0, &fts5yymsp[-1].minor.fts5yy0, fts5yymsp[0].minor.fts5yy20);
+}
+        break;
+      case 22: /* star_opt ::= STAR */
+{ fts5yygotominor.fts5yy20 = 1; }
+        break;
+      case 23: /* star_opt ::= */
+{ fts5yygotominor.fts5yy20 = 0; }
+        break;
+      default:
+        break;
+  };
+  assert( fts5yyruleno>=0 && fts5yyruleno<sizeof(fts5yyRuleInfo)/sizeof(fts5yyRuleInfo[0]) );
+  fts5yygoto = fts5yyRuleInfo[fts5yyruleno].lhs;
+  fts5yysize = fts5yyRuleInfo[fts5yyruleno].nrhs;
+  fts5yypParser->fts5yyidx -= fts5yysize;
+  fts5yyact = fts5yy_find_reduce_action(fts5yymsp[-fts5yysize].stateno,(fts5YYCODETYPE)fts5yygoto);
+  if( fts5yyact <= fts5YY_MAX_SHIFTREDUCE ){
+    if( fts5yyact>fts5YY_MAX_SHIFT ) fts5yyact += fts5YY_MIN_REDUCE - fts5YY_MIN_SHIFTREDUCE;
+    /* If the reduce action popped at least
+    ** one element off the stack, then we can push the new element back
+    ** onto the stack here, and skip the stack overflow test in fts5yy_shift().
+    ** That gives a significant speed improvement. */
+    if( fts5yysize ){
+      fts5yypParser->fts5yyidx++;
+      fts5yymsp -= fts5yysize-1;
+      fts5yymsp->stateno = (fts5YYACTIONTYPE)fts5yyact;
+      fts5yymsp->major = (fts5YYCODETYPE)fts5yygoto;
+      fts5yymsp->minor = fts5yygotominor;
+      fts5yyTraceShift(fts5yypParser, fts5yyact);
+    }else{
+      fts5yy_shift(fts5yypParser,fts5yyact,fts5yygoto,&fts5yygotominor);
+    }
+  }else{
+    assert( fts5yyact == fts5YY_ACCEPT_ACTION );
+    fts5yy_accept(fts5yypParser);
+  }
+}
+
+/*
+** The following code executes when the parse fails
+*/
+#ifndef fts5YYNOERRORRECOVERY
+static void fts5yy_parse_failed(
+  fts5yyParser *fts5yypParser           /* The parser */
+){
+  sqlite3Fts5ParserARG_FETCH;
+#ifndef NDEBUG
+  if( fts5yyTraceFILE ){
+    fprintf(fts5yyTraceFILE,"%sFail!\n",fts5yyTracePrompt);
+  }
+#endif
+  while( fts5yypParser->fts5yyidx>=0 ) fts5yy_pop_parser_stack(fts5yypParser);
+  /* Here code is inserted which will be executed whenever the
+  ** parser fails */
+  sqlite3Fts5ParserARG_STORE; /* Suppress warning about unused %extra_argument variable */
+}
+#endif /* fts5YYNOERRORRECOVERY */
+
+/*
+** The following code executes when a syntax error first occurs.
+*/
+static void fts5yy_syntax_error(
+  fts5yyParser *fts5yypParser,           /* The parser */
+  int fts5yymajor,                   /* The major type of the error token */
+  fts5YYMINORTYPE fts5yyminor            /* The minor type of the error token */
+){
+  sqlite3Fts5ParserARG_FETCH;
+#define FTS5TOKEN (fts5yyminor.fts5yy0)
+
+  sqlite3Fts5ParseError(
+    pParse, "fts5: syntax error near \"%.*s\"",FTS5TOKEN.n,FTS5TOKEN.p
+  );
+  sqlite3Fts5ParserARG_STORE; /* Suppress warning about unused %extra_argument variable */
+}
+
+/*
+** The following is executed when the parser accepts
+*/
+static void fts5yy_accept(
+  fts5yyParser *fts5yypParser           /* The parser */
+){
+  sqlite3Fts5ParserARG_FETCH;
+#ifndef NDEBUG
+  if( fts5yyTraceFILE ){
+    fprintf(fts5yyTraceFILE,"%sAccept!\n",fts5yyTracePrompt);
+  }
+#endif
+  while( fts5yypParser->fts5yyidx>=0 ) fts5yy_pop_parser_stack(fts5yypParser);
+  /* Here code is inserted which will be executed whenever the
+  ** parser accepts */
+  sqlite3Fts5ParserARG_STORE; /* Suppress warning about unused %extra_argument variable */
+}
+
+/* The main parser program.
+** The first argument is a pointer to a structure obtained from
+** "sqlite3Fts5ParserAlloc" which describes the current state of the parser.
+** The second argument is the major token number.  The third is
+** the minor token.  The fourth optional argument is whatever the
+** user wants (and specified in the grammar) and is available for
+** use by the action routines.
+**
+** Inputs:
+** <ul>
+** <li> A pointer to the parser (an opaque structure.)
+** <li> The major token number.
+** <li> The minor token number.
+** <li> An option argument of a grammar-specified type.
+** </ul>
+**
+** Outputs:
+** None.
+*/
+static void sqlite3Fts5Parser(
+  void *fts5yyp,                   /* The parser */
+  int fts5yymajor,                 /* The major token code number */
+  sqlite3Fts5ParserFTS5TOKENTYPE fts5yyminor       /* The value for the token */
+  sqlite3Fts5ParserARG_PDECL               /* Optional %extra_argument parameter */
+){
+  fts5YYMINORTYPE fts5yyminorunion;
+  int fts5yyact;            /* The parser action. */
+#if !defined(fts5YYERRORSYMBOL) && !defined(fts5YYNOERRORRECOVERY)
+  int fts5yyendofinput;     /* True if we are at the end of input */
+#endif
+#ifdef fts5YYERRORSYMBOL
+  int fts5yyerrorhit = 0;   /* True if fts5yymajor has invoked an error */
+#endif
+  fts5yyParser *fts5yypParser;  /* The parser */
+
+  /* (re)initialize the parser, if necessary */
+  fts5yypParser = (fts5yyParser*)fts5yyp;
+  if( fts5yypParser->fts5yyidx<0 ){
+#if fts5YYSTACKDEPTH<=0
+    if( fts5yypParser->fts5yystksz <=0 ){
+      /*memset(&fts5yyminorunion, 0, sizeof(fts5yyminorunion));*/
+      fts5yyminorunion = fts5yyzerominor;
+      fts5yyStackOverflow(fts5yypParser, &fts5yyminorunion);
+      return;
+    }
+#endif
+    fts5yypParser->fts5yyidx = 0;
+    fts5yypParser->fts5yyerrcnt = -1;
+    fts5yypParser->fts5yystack[0].stateno = 0;
+    fts5yypParser->fts5yystack[0].major = 0;
+  }
+  fts5yyminorunion.fts5yy0 = fts5yyminor;
+#if !defined(fts5YYERRORSYMBOL) && !defined(fts5YYNOERRORRECOVERY)
+  fts5yyendofinput = (fts5yymajor==0);
+#endif
+  sqlite3Fts5ParserARG_STORE;
+
+#ifndef NDEBUG
+  if( fts5yyTraceFILE ){
+    fprintf(fts5yyTraceFILE,"%sInput %s\n",fts5yyTracePrompt,fts5yyTokenName[fts5yymajor]);
+  }
+#endif
+
+  do{
+    fts5yyact = fts5yy_find_shift_action(fts5yypParser,(fts5YYCODETYPE)fts5yymajor);
+    if( fts5yyact <= fts5YY_MAX_SHIFTREDUCE ){
+      if( fts5yyact > fts5YY_MAX_SHIFT ) fts5yyact += fts5YY_MIN_REDUCE - fts5YY_MIN_SHIFTREDUCE;
+      fts5yy_shift(fts5yypParser,fts5yyact,fts5yymajor,&fts5yyminorunion);
+      fts5yypParser->fts5yyerrcnt--;
+      fts5yymajor = fts5YYNOCODE;
+    }else if( fts5yyact <= fts5YY_MAX_REDUCE ){
+      fts5yy_reduce(fts5yypParser,fts5yyact-fts5YY_MIN_REDUCE);
+    }else{
+      assert( fts5yyact == fts5YY_ERROR_ACTION );
+#ifdef fts5YYERRORSYMBOL
+      int fts5yymx;
+#endif
+#ifndef NDEBUG
+      if( fts5yyTraceFILE ){
+        fprintf(fts5yyTraceFILE,"%sSyntax Error!\n",fts5yyTracePrompt);
+      }
+#endif
+#ifdef fts5YYERRORSYMBOL
+      /* A syntax error has occurred.
+      ** The response to an error depends upon whether or not the
+      ** grammar defines an error token "ERROR".  
+      **
+      ** This is what we do if the grammar does define ERROR:
+      **
+      **  * Call the %syntax_error function.
+      **
+      **  * Begin popping the stack until we enter a state where
+      **    it is legal to shift the error symbol, then shift
+      **    the error symbol.
+      **
+      **  * Set the error count to three.
+      **
+      **  * Begin accepting and shifting new tokens.  No new error
+      **    processing will occur until three tokens have been
+      **    shifted successfully.
+      **
+      */
+      if( fts5yypParser->fts5yyerrcnt<0 ){
+        fts5yy_syntax_error(fts5yypParser,fts5yymajor,fts5yyminorunion);
+      }
+      fts5yymx = fts5yypParser->fts5yystack[fts5yypParser->fts5yyidx].major;
+      if( fts5yymx==fts5YYERRORSYMBOL || fts5yyerrorhit ){
+#ifndef NDEBUG
+        if( fts5yyTraceFILE ){
+          fprintf(fts5yyTraceFILE,"%sDiscard input token %s\n",
+             fts5yyTracePrompt,fts5yyTokenName[fts5yymajor]);
+        }
+#endif
+        fts5yy_destructor(fts5yypParser, (fts5YYCODETYPE)fts5yymajor,&fts5yyminorunion);
+        fts5yymajor = fts5YYNOCODE;
+      }else{
+         while(
+          fts5yypParser->fts5yyidx >= 0 &&
+          fts5yymx != fts5YYERRORSYMBOL &&
+          (fts5yyact = fts5yy_find_reduce_action(
+                        fts5yypParser->fts5yystack[fts5yypParser->fts5yyidx].stateno,
+                        fts5YYERRORSYMBOL)) >= fts5YY_MIN_REDUCE
+        ){
+          fts5yy_pop_parser_stack(fts5yypParser);
+        }
+        if( fts5yypParser->fts5yyidx < 0 || fts5yymajor==0 ){
+          fts5yy_destructor(fts5yypParser,(fts5YYCODETYPE)fts5yymajor,&fts5yyminorunion);
+          fts5yy_parse_failed(fts5yypParser);
+          fts5yymajor = fts5YYNOCODE;
+        }else if( fts5yymx!=fts5YYERRORSYMBOL ){
+          fts5YYMINORTYPE u2;
+          u2.fts5YYERRSYMDT = 0;
+          fts5yy_shift(fts5yypParser,fts5yyact,fts5YYERRORSYMBOL,&u2);
+        }
+      }
+      fts5yypParser->fts5yyerrcnt = 3;
+      fts5yyerrorhit = 1;
+#elif defined(fts5YYNOERRORRECOVERY)
+      /* If the fts5YYNOERRORRECOVERY macro is defined, then do not attempt to
+      ** do any kind of error recovery.  Instead, simply invoke the syntax
+      ** error routine and continue going as if nothing had happened.
+      **
+      ** Applications can set this macro (for example inside %include) if
+      ** they intend to abandon the parse upon the first syntax error seen.
+      */
+      fts5yy_syntax_error(fts5yypParser,fts5yymajor,fts5yyminorunion);
+      fts5yy_destructor(fts5yypParser,(fts5YYCODETYPE)fts5yymajor,&fts5yyminorunion);
+      fts5yymajor = fts5YYNOCODE;
+      
+#else  /* fts5YYERRORSYMBOL is not defined */
+      /* This is what we do if the grammar does not define ERROR:
+      **
+      **  * Report an error message, and throw away the input token.
+      **
+      **  * If the input token is $, then fail the parse.
+      **
+      ** As before, subsequent error messages are suppressed until
+      ** three input tokens have been successfully shifted.
+      */
+      if( fts5yypParser->fts5yyerrcnt<=0 ){
+        fts5yy_syntax_error(fts5yypParser,fts5yymajor,fts5yyminorunion);
+      }
+      fts5yypParser->fts5yyerrcnt = 3;
+      fts5yy_destructor(fts5yypParser,(fts5YYCODETYPE)fts5yymajor,&fts5yyminorunion);
+      if( fts5yyendofinput ){
+        fts5yy_parse_failed(fts5yypParser);
+      }
+      fts5yymajor = fts5YYNOCODE;
+#endif
+    }
+  }while( fts5yymajor!=fts5YYNOCODE && fts5yypParser->fts5yyidx>=0 );
+#ifndef NDEBUG
+  if( fts5yyTraceFILE ){
+    fprintf(fts5yyTraceFILE,"%sReturn\n",fts5yyTracePrompt);
+  }
+#endif
+  return;
+}
+
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+*/
+
+
+#include <math.h>                 /* amalgamator: keep */
+
+/*
+** Object used to iterate through all "coalesced phrase instances" in 
+** a single column of the current row. If the phrase instances in the
+** column being considered do not overlap, this object simply iterates
+** through them. Or, if they do overlap (share one or more tokens in
+** common), each set of overlapping instances is treated as a single
+** match. See documentation for the highlight() auxiliary function for
+** details.
+**
+** Usage is:
+**
+**   for(rc = fts5CInstIterNext(pApi, pFts, iCol, &iter);
+**      (rc==SQLITE_OK && 0==fts5CInstIterEof(&iter);
+**      rc = fts5CInstIterNext(&iter)
+**   ){
+**     printf("instance starts at %d, ends at %d\n", iter.iStart, iter.iEnd);
+**   }
+**
+*/
+typedef struct CInstIter CInstIter;
+struct CInstIter {
+  const Fts5ExtensionApi *pApi;   /* API offered by current FTS version */
+  Fts5Context *pFts;              /* First arg to pass to pApi functions */
+  int iCol;                       /* Column to search */
+  int iInst;                      /* Next phrase instance index */
+  int nInst;                      /* Total number of phrase instances */
+
+  /* Output variables */
+  int iStart;                     /* First token in coalesced phrase instance */
+  int iEnd;                       /* Last token in coalesced phrase instance */
+};
+
+/*
+** Advance the iterator to the next coalesced phrase instance. Return
+** an SQLite error code if an error occurs, or SQLITE_OK otherwise.
+*/
+static int fts5CInstIterNext(CInstIter *pIter){
+  int rc = SQLITE_OK;
+  pIter->iStart = -1;
+  pIter->iEnd = -1;
+
+  while( rc==SQLITE_OK && pIter->iInst<pIter->nInst ){
+    int ip; int ic; int io;
+    rc = pIter->pApi->xInst(pIter->pFts, pIter->iInst, &ip, &ic, &io);
+    if( rc==SQLITE_OK ){
+      if( ic==pIter->iCol ){
+        int iEnd = io - 1 + pIter->pApi->xPhraseSize(pIter->pFts, ip);
+        if( pIter->iStart<0 ){
+          pIter->iStart = io;
+          pIter->iEnd = iEnd;
+        }else if( io<=pIter->iEnd ){
+          if( iEnd>pIter->iEnd ) pIter->iEnd = iEnd;
+        }else{
+          break;
+        }
+      }
+      pIter->iInst++;
+    }
+  }
+
+  return rc;
+}
+
+/*
+** Initialize the iterator object indicated by the final parameter to 
+** iterate through coalesced phrase instances in column iCol.
+*/
+static int fts5CInstIterInit(
+  const Fts5ExtensionApi *pApi,
+  Fts5Context *pFts,
+  int iCol,
+  CInstIter *pIter
+){
+  int rc;
+
+  memset(pIter, 0, sizeof(CInstIter));
+  pIter->pApi = pApi;
+  pIter->pFts = pFts;
+  pIter->iCol = iCol;
+  rc = pApi->xInstCount(pFts, &pIter->nInst);
+
+  if( rc==SQLITE_OK ){
+    rc = fts5CInstIterNext(pIter);
+  }
+
+  return rc;
+}
+
+
+
+/*************************************************************************
+** Start of highlight() implementation.
+*/
+typedef struct HighlightContext HighlightContext;
+struct HighlightContext {
+  CInstIter iter;                 /* Coalesced Instance Iterator */
+  int iPos;                       /* Current token offset in zIn[] */
+  int iRangeStart;                /* First token to include */
+  int iRangeEnd;                  /* If non-zero, last token to include */
+  const char *zOpen;              /* Opening highlight */
+  const char *zClose;             /* Closing highlight */
+  const char *zIn;                /* Input text */
+  int nIn;                        /* Size of input text in bytes */
+  int iOff;                       /* Current offset within zIn[] */
+  char *zOut;                     /* Output value */
+};
+
+/*
+** Append text to the HighlightContext output string - p->zOut. Argument
+** z points to a buffer containing n bytes of text to append. If n is 
+** negative, everything up until the first '\0' is appended to the output.
+**
+** If *pRc is set to any value other than SQLITE_OK when this function is 
+** called, it is a no-op. If an error (i.e. an OOM condition) is encountered, 
+** *pRc is set to an error code before returning. 
+*/
+static void fts5HighlightAppend(
+  int *pRc, 
+  HighlightContext *p, 
+  const char *z, int n
+){
+  if( *pRc==SQLITE_OK ){
+    if( n<0 ) n = strlen(z);
+    p->zOut = sqlite3_mprintf("%z%.*s", p->zOut, n, z);
+    if( p->zOut==0 ) *pRc = SQLITE_NOMEM;
+  }
+}
+
+/*
+** Tokenizer callback used by implementation of highlight() function.
+*/
+static int fts5HighlightCb(
+  void *pContext,                 /* Pointer to HighlightContext object */
+  int tflags,                     /* Mask of FTS5_TOKEN_* flags */
+  const char *pToken,             /* Buffer containing token */
+  int nToken,                     /* Size of token in bytes */
+  int iStartOff,                  /* Start offset of token */
+  int iEndOff                     /* End offset of token */
+){
+  HighlightContext *p = (HighlightContext*)pContext;
+  int rc = SQLITE_OK;
+  int iPos;
+
+  if( tflags & FTS5_TOKEN_COLOCATED ) return SQLITE_OK;
+  iPos = p->iPos++;
+
+  if( p->iRangeEnd>0 ){
+    if( iPos<p->iRangeStart || iPos>p->iRangeEnd ) return SQLITE_OK;
+    if( p->iRangeStart && iPos==p->iRangeStart ) p->iOff = iStartOff;
+  }
+
+  if( iPos==p->iter.iStart ){
+    fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iStartOff - p->iOff);
+    fts5HighlightAppend(&rc, p, p->zOpen, -1);
+    p->iOff = iStartOff;
+  }
+
+  if( iPos==p->iter.iEnd ){
+    if( p->iRangeEnd && p->iter.iStart<p->iRangeStart ){
+      fts5HighlightAppend(&rc, p, p->zOpen, -1);
+    }
+    fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);
+    fts5HighlightAppend(&rc, p, p->zClose, -1);
+    p->iOff = iEndOff;
+    if( rc==SQLITE_OK ){
+      rc = fts5CInstIterNext(&p->iter);
+    }
+  }
+
+  if( p->iRangeEnd>0 && iPos==p->iRangeEnd ){
+    fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);
+    p->iOff = iEndOff;
+    if( iPos<p->iter.iEnd ){
+      fts5HighlightAppend(&rc, p, p->zClose, -1);
+    }
+  }
+
+  return rc;
+}
+
+/*
+** Implementation of highlight() function.
+*/
+static void fts5HighlightFunction(
+  const Fts5ExtensionApi *pApi,   /* API offered by current FTS version */
+  Fts5Context *pFts,              /* First arg to pass to pApi functions */
+  sqlite3_context *pCtx,          /* Context for returning result/error */
+  int nVal,                       /* Number of values in apVal[] array */
+  sqlite3_value **apVal           /* Array of trailing arguments */
+){
+  HighlightContext ctx;
+  int rc;
+  int iCol;
+
+  if( nVal!=3 ){
+    const char *zErr = "wrong number of arguments to function highlight()";
+    sqlite3_result_error(pCtx, zErr, -1);
+    return;
+  }
+
+  iCol = sqlite3_value_int(apVal[0]);
+  memset(&ctx, 0, sizeof(HighlightContext));
+  ctx.zOpen = (const char*)sqlite3_value_text(apVal[1]);
+  ctx.zClose = (const char*)sqlite3_value_text(apVal[2]);
+  rc = pApi->xColumnText(pFts, iCol, &ctx.zIn, &ctx.nIn);
+
+  if( ctx.zIn ){
+    if( rc==SQLITE_OK ){
+      rc = fts5CInstIterInit(pApi, pFts, iCol, &ctx.iter);
+    }
+
+    if( rc==SQLITE_OK ){
+      rc = pApi->xTokenize(pFts, ctx.zIn, ctx.nIn, (void*)&ctx,fts5HighlightCb);
+    }
+    fts5HighlightAppend(&rc, &ctx, &ctx.zIn[ctx.iOff], ctx.nIn - ctx.iOff);
+
+    if( rc==SQLITE_OK ){
+      sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
+    }
+    sqlite3_free(ctx.zOut);
+  }
+  if( rc!=SQLITE_OK ){
+    sqlite3_result_error_code(pCtx, rc);
+  }
+}
+/*
+** End of highlight() implementation.
+**************************************************************************/
+
+/*
+** Implementation of snippet() function.
+*/
+static void fts5SnippetFunction(
+  const Fts5ExtensionApi *pApi,   /* API offered by current FTS version */
+  Fts5Context *pFts,              /* First arg to pass to pApi functions */
+  sqlite3_context *pCtx,          /* Context for returning result/error */
+  int nVal,                       /* Number of values in apVal[] array */
+  sqlite3_value **apVal           /* Array of trailing arguments */
+){
+  HighlightContext ctx;
+  int rc = SQLITE_OK;             /* Return code */
+  int iCol;                       /* 1st argument to snippet() */
+  const char *zEllips;            /* 4th argument to snippet() */
+  int nToken;                     /* 5th argument to snippet() */
+  int nInst = 0;                  /* Number of instance matches this row */
+  int i;                          /* Used to iterate through instances */
+  int nPhrase;                    /* Number of phrases in query */
+  unsigned char *aSeen;           /* Array of "seen instance" flags */
+  int iBestCol;                   /* Column containing best snippet */
+  int iBestStart = 0;             /* First token of best snippet */
+  int iBestLast;                  /* Last token of best snippet */
+  int nBestScore = 0;             /* Score of best snippet */
+  int nColSize = 0;               /* Total size of iBestCol in tokens */
+
+  if( nVal!=5 ){
+    const char *zErr = "wrong number of arguments to function snippet()";
+    sqlite3_result_error(pCtx, zErr, -1);
+    return;
+  }
+
+  memset(&ctx, 0, sizeof(HighlightContext));
+  iCol = sqlite3_value_int(apVal[0]);
+  ctx.zOpen = (const char*)sqlite3_value_text(apVal[1]);
+  ctx.zClose = (const char*)sqlite3_value_text(apVal[2]);
+  zEllips = (const char*)sqlite3_value_text(apVal[3]);
+  nToken = sqlite3_value_int(apVal[4]);
+  iBestLast = nToken-1;
+
+  iBestCol = (iCol>=0 ? iCol : 0);
+  nPhrase = pApi->xPhraseCount(pFts);
+  aSeen = sqlite3_malloc(nPhrase);
+  if( aSeen==0 ){
+    rc = SQLITE_NOMEM;
+  }
+
+  if( rc==SQLITE_OK ){
+    rc = pApi->xInstCount(pFts, &nInst);
+  }
+  for(i=0; rc==SQLITE_OK && i<nInst; i++){
+    int ip, iSnippetCol, iStart;
+    memset(aSeen, 0, nPhrase);
+    rc = pApi->xInst(pFts, i, &ip, &iSnippetCol, &iStart);
+    if( rc==SQLITE_OK && (iCol<0 || iSnippetCol==iCol) ){
+      int nScore = 1000;
+      int iLast = iStart - 1 + pApi->xPhraseSize(pFts, ip);
+      int j;
+      aSeen[ip] = 1;
+
+      for(j=i+1; rc==SQLITE_OK && j<nInst; j++){
+        int ic; int io; int iFinal;
+        rc = pApi->xInst(pFts, j, &ip, &ic, &io);
+        iFinal = io + pApi->xPhraseSize(pFts, ip) - 1;
+        if( rc==SQLITE_OK && ic==iSnippetCol && iLast<iStart+nToken ){
+          nScore += aSeen[ip] ? 1000 : 1;
+          aSeen[ip] = 1;
+          if( iFinal>iLast ) iLast = iFinal;
+        }
+      }
+
+      if( rc==SQLITE_OK && nScore>nBestScore ){
+        iBestCol = iSnippetCol;
+        iBestStart = iStart;
+        iBestLast = iLast;
+        nBestScore = nScore;
+      }
+    }
+  }
+
+  if( rc==SQLITE_OK ){
+    rc = pApi->xColumnSize(pFts, iBestCol, &nColSize);
+  }
+  if( rc==SQLITE_OK ){
+    rc = pApi->xColumnText(pFts, iBestCol, &ctx.zIn, &ctx.nIn);
+  }
+  if( ctx.zIn ){
+    if( rc==SQLITE_OK ){
+      rc = fts5CInstIterInit(pApi, pFts, iBestCol, &ctx.iter);
+    }
+
+    if( (iBestStart+nToken-1)>iBestLast ){
+      iBestStart -= (iBestStart+nToken-1-iBestLast) / 2;
+    }
+    if( iBestStart+nToken>nColSize ){
+      iBestStart = nColSize - nToken;
+    }
+    if( iBestStart<0 ) iBestStart = 0;
+
+    ctx.iRangeStart = iBestStart;
+    ctx.iRangeEnd = iBestStart + nToken - 1;
+
+    if( iBestStart>0 ){
+      fts5HighlightAppend(&rc, &ctx, zEllips, -1);
+    }
+    if( rc==SQLITE_OK ){
+      rc = pApi->xTokenize(pFts, ctx.zIn, ctx.nIn, (void*)&ctx,fts5HighlightCb);
+    }
+    if( ctx.iRangeEnd>=(nColSize-1) ){
+      fts5HighlightAppend(&rc, &ctx, &ctx.zIn[ctx.iOff], ctx.nIn - ctx.iOff);
+    }else{
+      fts5HighlightAppend(&rc, &ctx, zEllips, -1);
+    }
+
+    if( rc==SQLITE_OK ){
+      sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);
+    }else{
+      sqlite3_result_error_code(pCtx, rc);
+    }
+    sqlite3_free(ctx.zOut);
+  }
+  sqlite3_free(aSeen);
+}
+
+/************************************************************************/
+
+/*
+** The first time the bm25() function is called for a query, an instance
+** of the following structure is allocated and populated.
+*/
+typedef struct Fts5Bm25Data Fts5Bm25Data;
+struct Fts5Bm25Data {
+  int nPhrase;                    /* Number of phrases in query */
+  double avgdl;                   /* Average number of tokens in each row */
+  double *aIDF;                   /* IDF for each phrase */
+  double *aFreq;                  /* Array used to calculate phrase freq. */
+};
+
+/*
+** Callback used by fts5Bm25GetData() to count the number of rows in the
+** table matched by each individual phrase within the query.
+*/
+static int fts5CountCb(
+  const Fts5ExtensionApi *pApi, 
+  Fts5Context *pFts,
+  void *pUserData                 /* Pointer to sqlite3_int64 variable */
+){
+  sqlite3_int64 *pn = (sqlite3_int64*)pUserData;
+  (*pn)++;
+  return SQLITE_OK;
+}
+
+/*
+** Set *ppData to point to the Fts5Bm25Data object for the current query. 
+** If the object has not already been allocated, allocate and populate it
+** now.
+*/
+static int fts5Bm25GetData(
+  const Fts5ExtensionApi *pApi, 
+  Fts5Context *pFts,
+  Fts5Bm25Data **ppData           /* OUT: bm25-data object for this query */
+){
+  int rc = SQLITE_OK;             /* Return code */
+  Fts5Bm25Data *p;                /* Object to return */
+
+  p = pApi->xGetAuxdata(pFts, 0);
+  if( p==0 ){
+    int nPhrase;                  /* Number of phrases in query */
+    sqlite3_int64 nRow = 0;       /* Number of rows in table */
+    sqlite3_int64 nToken = 0;     /* Number of tokens in table */
+    int nByte;                    /* Bytes of space to allocate */
+    int i;
+
+    /* Allocate the Fts5Bm25Data object */
+    nPhrase = pApi->xPhraseCount(pFts);
+    nByte = sizeof(Fts5Bm25Data) + nPhrase*2*sizeof(double);
+    p = (Fts5Bm25Data*)sqlite3_malloc(nByte);
+    if( p==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      memset(p, 0, nByte);
+      p->nPhrase = nPhrase;
+      p->aIDF = (double*)&p[1];
+      p->aFreq = &p->aIDF[nPhrase];
+    }
+
+    /* Calculate the average document length for this FTS5 table */
+    if( rc==SQLITE_OK ) rc = pApi->xRowCount(pFts, &nRow);
+    if( rc==SQLITE_OK ) rc = pApi->xColumnTotalSize(pFts, -1, &nToken);
+    if( rc==SQLITE_OK ) p->avgdl = (double)nToken  / (double)nRow;
+
+    /* Calculate an IDF for each phrase in the query */
+    for(i=0; rc==SQLITE_OK && i<nPhrase; i++){
+      sqlite3_int64 nHit = 0;
+      rc = pApi->xQueryPhrase(pFts, i, (void*)&nHit, fts5CountCb);
+      if( rc==SQLITE_OK ){
+        /* Calculate the IDF (Inverse Document Frequency) for phrase i.
+        ** This is done using the standard BM25 formula as found on wikipedia:
+        **
+        **   IDF = log( (N - nHit + 0.5) / (nHit + 0.5) )
+        **
+        ** where "N" is the total number of documents in the set and nHit
+        ** is the number that contain at least one instance of the phrase
+        ** under consideration.
+        **
+        ** The problem with this is that if (N < 2*nHit), the IDF is 
+        ** negative. Which is undesirable. So the mimimum allowable IDF is
+        ** (1e-6) - roughly the same as a term that appears in just over
+        ** half of set of 5,000,000 documents.  */
+        double idf = log( (nRow - nHit + 0.5) / (nHit + 0.5) );
+        if( idf<=0.0 ) idf = 1e-6;
+        p->aIDF[i] = idf;
+      }
+    }
+
+    if( rc!=SQLITE_OK ){
+      sqlite3_free(p);
+    }else{
+      rc = pApi->xSetAuxdata(pFts, p, sqlite3_free);
+    }
+    if( rc!=SQLITE_OK ) p = 0;
+  }
+  *ppData = p;
+  return rc;
+}
+
+/*
+** Implementation of bm25() function.
+*/
+static void fts5Bm25Function(
+  const Fts5ExtensionApi *pApi,   /* API offered by current FTS version */
+  Fts5Context *pFts,              /* First arg to pass to pApi functions */
+  sqlite3_context *pCtx,          /* Context for returning result/error */
+  int nVal,                       /* Number of values in apVal[] array */
+  sqlite3_value **apVal           /* Array of trailing arguments */
+){
+  const double k1 = 1.2;          /* Constant "k1" from BM25 formula */
+  const double b = 0.75;          /* Constant "b" from BM25 formula */
+  int rc = SQLITE_OK;             /* Error code */
+  double score = 0.0;             /* SQL function return value */
+  Fts5Bm25Data *pData;            /* Values allocated/calculated once only */
+  int i;                          /* Iterator variable */
+  int nInst = 0;                  /* Value returned by xInstCount() */
+  double D = 0.0;                 /* Total number of tokens in row */
+  double *aFreq = 0;              /* Array of phrase freq. for current row */
+
+  /* Calculate the phrase frequency (symbol "f(qi,D)" in the documentation)
+  ** for each phrase in the query for the current row. */
+  rc = fts5Bm25GetData(pApi, pFts, &pData);
+  if( rc==SQLITE_OK ){
+    aFreq = pData->aFreq;
+    memset(aFreq, 0, sizeof(double) * pData->nPhrase);
+    rc = pApi->xInstCount(pFts, &nInst);
+  }
+  for(i=0; rc==SQLITE_OK && i<nInst; i++){
+    int ip; int ic; int io;
+    rc = pApi->xInst(pFts, i, &ip, &ic, &io);
+    if( rc==SQLITE_OK ){
+      double w = (nVal > ic) ? sqlite3_value_double(apVal[ic]) : 1.0;
+      aFreq[ip] += w;
+    }
+  }
+
+  /* Figure out the total size of the current row in tokens. */
+  if( rc==SQLITE_OK ){
+    int nTok;
+    rc = pApi->xColumnSize(pFts, -1, &nTok);
+    D = (double)nTok;
+  }
+
+  /* Determine the BM25 score for the current row. */
+  for(i=0; rc==SQLITE_OK && i<pData->nPhrase; i++){
+    score += pData->aIDF[i] * (
+      ( aFreq[i] * (k1 + 1.0) ) / 
+      ( aFreq[i] + k1 * (1 - b + b * D / pData->avgdl) )
+    );
+  }
+  
+  /* If no error has occurred, return the calculated score. Otherwise,
+  ** throw an SQL exception.  */
+  if( rc==SQLITE_OK ){
+    sqlite3_result_double(pCtx, -1.0 * score);
+  }else{
+    sqlite3_result_error_code(pCtx, rc);
+  }
+}
+
+static int sqlite3Fts5AuxInit(fts5_api *pApi){
+  struct Builtin {
+    const char *zFunc;            /* Function name (nul-terminated) */
+    void *pUserData;              /* User-data pointer */
+    fts5_extension_function xFunc;/* Callback function */
+    void (*xDestroy)(void*);      /* Destructor function */
+  } aBuiltin [] = {
+    { "snippet",   0, fts5SnippetFunction, 0 },
+    { "highlight", 0, fts5HighlightFunction, 0 },
+    { "bm25",      0, fts5Bm25Function,    0 },
+  };
+  int rc = SQLITE_OK;             /* Return code */
+  int i;                          /* To iterate through builtin functions */
+
+  for(i=0; rc==SQLITE_OK && i<sizeof(aBuiltin)/sizeof(aBuiltin[0]); i++){
+    rc = pApi->xCreateFunction(pApi,
+        aBuiltin[i].zFunc,
+        aBuiltin[i].pUserData,
+        aBuiltin[i].xFunc,
+        aBuiltin[i].xDestroy
+    );
+  }
+
+  return rc;
+}
+
+
+
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+*/
+
+
+
+
+static int sqlite3Fts5BufferGrow(int *pRc, Fts5Buffer *pBuf, int nByte){
+
+  if( (pBuf->n + nByte) > pBuf->nSpace ){
+    u8 *pNew;
+    int nNew = pBuf->nSpace ? pBuf->nSpace*2 : 64;
+
+    /* A no-op if an error has already occurred */
+    if( *pRc ) return 1;
+
+    while( nNew<(pBuf->n + nByte) ){
+      nNew = nNew * 2;
+    }
+    pNew = sqlite3_realloc(pBuf->p, nNew);
+    if( pNew==0 ){
+      *pRc = SQLITE_NOMEM;
+      return 1;
+    }else{
+      pBuf->nSpace = nNew;
+      pBuf->p = pNew;
+    }
+  }
+  return 0;
+}
+
+/*
+** Encode value iVal as an SQLite varint and append it to the buffer object
+** pBuf. If an OOM error occurs, set the error code in p.
+*/
+static void sqlite3Fts5BufferAppendVarint(int *pRc, Fts5Buffer *pBuf, i64 iVal){
+  if( sqlite3Fts5BufferGrow(pRc, pBuf, 9) ) return;
+  pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iVal);
+}
+
+static void sqlite3Fts5Put32(u8 *aBuf, int iVal){
+  aBuf[0] = (iVal>>24) & 0x00FF;
+  aBuf[1] = (iVal>>16) & 0x00FF;
+  aBuf[2] = (iVal>> 8) & 0x00FF;
+  aBuf[3] = (iVal>> 0) & 0x00FF;
+}
+
+static int sqlite3Fts5Get32(const u8 *aBuf){
+  return (aBuf[0] << 24) + (aBuf[1] << 16) + (aBuf[2] << 8) + aBuf[3];
+}
+
+static void sqlite3Fts5BufferAppend32(int *pRc, Fts5Buffer *pBuf, int iVal){
+  if( sqlite3Fts5BufferGrow(pRc, pBuf, 4) ) return;
+  sqlite3Fts5Put32(&pBuf->p[pBuf->n], iVal);
+  pBuf->n += 4;
+}
+
+/*
+** Append buffer nData/pData to buffer pBuf. If an OOM error occurs, set 
+** the error code in p. If an error has already occurred when this function
+** is called, it is a no-op.
+*/
+static void sqlite3Fts5BufferAppendBlob(
+  int *pRc,
+  Fts5Buffer *pBuf, 
+  int nData, 
+  const u8 *pData
+){
+  assert( *pRc || nData>=0 );
+  if( sqlite3Fts5BufferGrow(pRc, pBuf, nData) ) return;
+  memcpy(&pBuf->p[pBuf->n], pData, nData);
+  pBuf->n += nData;
+}
+
+/*
+** Append the nul-terminated string zStr to the buffer pBuf. This function
+** ensures that the byte following the buffer data is set to 0x00, even 
+** though this byte is not included in the pBuf->n count.
+*/
+static void sqlite3Fts5BufferAppendString(
+  int *pRc,
+  Fts5Buffer *pBuf, 
+  const char *zStr
+){
+  int nStr = strlen(zStr);
+  sqlite3Fts5BufferAppendBlob(pRc, pBuf, nStr+1, (const u8*)zStr);
+  pBuf->n--;
+}
+
+/*
+** Argument zFmt is a printf() style format string. This function performs
+** the printf() style processing, then appends the results to buffer pBuf.
+**
+** Like sqlite3Fts5BufferAppendString(), this function ensures that the byte 
+** following the buffer data is set to 0x00, even though this byte is not
+** included in the pBuf->n count.
+*/ 
+static void sqlite3Fts5BufferAppendPrintf(
+  int *pRc,
+  Fts5Buffer *pBuf, 
+  char *zFmt, ...
+){
+  if( *pRc==SQLITE_OK ){
+    char *zTmp;
+    va_list ap;
+    va_start(ap, zFmt);
+    zTmp = sqlite3_vmprintf(zFmt, ap);
+    va_end(ap);
+
+    if( zTmp==0 ){
+      *pRc = SQLITE_NOMEM;
+    }else{
+      sqlite3Fts5BufferAppendString(pRc, pBuf, zTmp);
+      sqlite3_free(zTmp);
+    }
+  }
+}
+
+static char *sqlite3Fts5Mprintf(int *pRc, const char *zFmt, ...){
+  char *zRet = 0;
+  if( *pRc==SQLITE_OK ){
+    va_list ap;
+    va_start(ap, zFmt);
+    zRet = sqlite3_vmprintf(zFmt, ap);
+    va_end(ap);
+    if( zRet==0 ){
+      *pRc = SQLITE_NOMEM; 
+    }
+  }
+  return zRet;
+}
+ 
+
+/*
+** Free any buffer allocated by pBuf. Zero the structure before returning.
+*/
+static void sqlite3Fts5BufferFree(Fts5Buffer *pBuf){
+  sqlite3_free(pBuf->p);
+  memset(pBuf, 0, sizeof(Fts5Buffer));
+}
+
+/*
+** Zero the contents of the buffer object. But do not free the associated 
+** memory allocation.
+*/
+static void sqlite3Fts5BufferZero(Fts5Buffer *pBuf){
+  pBuf->n = 0;
+}
+
+/*
+** Set the buffer to contain nData/pData. If an OOM error occurs, leave an
+** the error code in p. If an error has already occurred when this function
+** is called, it is a no-op.
+*/
+static void sqlite3Fts5BufferSet(
+  int *pRc,
+  Fts5Buffer *pBuf, 
+  int nData, 
+  const u8 *pData
+){
+  pBuf->n = 0;
+  sqlite3Fts5BufferAppendBlob(pRc, pBuf, nData, pData);
+}
+
+static int sqlite3Fts5PoslistNext64(
+  const u8 *a, int n,             /* Buffer containing poslist */
+  int *pi,                        /* IN/OUT: Offset within a[] */
+  i64 *piOff                      /* IN/OUT: Current offset */
+){
+  int i = *pi;
+  if( i>=n ){
+    /* EOF */
+    *piOff = -1;
+    return 1;  
+  }else{
+    i64 iOff = *piOff;
+    int iVal;
+    fts5FastGetVarint32(a, i, iVal);
+    if( iVal==1 ){
+      fts5FastGetVarint32(a, i, iVal);
+      iOff = ((i64)iVal) << 32;
+      fts5FastGetVarint32(a, i, iVal);
+    }
+    *piOff = iOff + (iVal-2);
+    *pi = i;
+    return 0;
+  }
+}
+
+
+/*
+** Advance the iterator object passed as the only argument. Return true
+** if the iterator reaches EOF, or false otherwise.
+*/
+static int sqlite3Fts5PoslistReaderNext(Fts5PoslistReader *pIter){
+  if( sqlite3Fts5PoslistNext64(pIter->a, pIter->n, &pIter->i, &pIter->iPos) ){
+    pIter->bEof = 1;
+  }
+  return pIter->bEof;
+}
+
+static int sqlite3Fts5PoslistReaderInit(
+  const u8 *a, int n,             /* Poslist buffer to iterate through */
+  Fts5PoslistReader *pIter        /* Iterator object to initialize */
+){
+  memset(pIter, 0, sizeof(*pIter));
+  pIter->a = a;
+  pIter->n = n;
+  sqlite3Fts5PoslistReaderNext(pIter);
+  return pIter->bEof;
+}
+
+static int sqlite3Fts5PoslistWriterAppend(
+  Fts5Buffer *pBuf, 
+  Fts5PoslistWriter *pWriter,
+  i64 iPos
+){
+  static const i64 colmask = ((i64)(0x7FFFFFFF)) << 32;
+  int rc = SQLITE_OK;
+  if( 0==sqlite3Fts5BufferGrow(&rc, pBuf, 5+5+5) ){
+    if( (iPos & colmask) != (pWriter->iPrev & colmask) ){
+      pBuf->p[pBuf->n++] = 1;
+      pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos>>32));
+      pWriter->iPrev = (iPos & colmask);
+    }
+    pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos-pWriter->iPrev)+2);
+    pWriter->iPrev = iPos;
+  }
+  return rc;
+}
+
+static void *sqlite3Fts5MallocZero(int *pRc, int nByte){
+  void *pRet = 0;
+  if( *pRc==SQLITE_OK ){
+    pRet = sqlite3_malloc(nByte);
+    if( pRet==0 && nByte>0 ){
+      *pRc = SQLITE_NOMEM;
+    }else{
+      memset(pRet, 0, nByte);
+    }
+  }
+  return pRet;
+}
+
+/*
+** Return a nul-terminated copy of the string indicated by pIn. If nIn
+** is non-negative, then it is the length of the string in bytes. Otherwise,
+** the length of the string is determined using strlen().
+**
+** It is the responsibility of the caller to eventually free the returned
+** buffer using sqlite3_free(). If an OOM error occurs, NULL is returned. 
+*/
+static char *sqlite3Fts5Strndup(int *pRc, const char *pIn, int nIn){
+  char *zRet = 0;
+  if( *pRc==SQLITE_OK ){
+    if( nIn<0 ){
+      nIn = strlen(pIn);
+    }
+    zRet = (char*)sqlite3_malloc(nIn+1);
+    if( zRet ){
+      memcpy(zRet, pIn, nIn);
+      zRet[nIn] = '\0';
+    }else{
+      *pRc = SQLITE_NOMEM;
+    }
+  }
+  return zRet;
+}
+
+
+/*
+** Return true if character 't' may be part of an FTS5 bareword, or false
+** otherwise. Characters that may be part of barewords:
+**
+**   * All non-ASCII characters,
+**   * The 52 upper and lower case ASCII characters, and
+**   * The 10 integer ASCII characters.
+**   * The underscore character "_" (0x5F).
+**   * The unicode "subsitute" character (0x1A).
+*/
+static int sqlite3Fts5IsBareword(char t){
+  u8 aBareword[128] = {
+    0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0,   /* 0x00 .. 0x0F */
+    0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 1, 0, 0, 0, 0, 0,   /* 0x10 .. 0x1F */
+    0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0,   /* 0x20 .. 0x2F */
+    1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 0, 0, 0, 0, 0, 0,   /* 0x30 .. 0x3F */
+    0, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 1, 1, 1, 1, 1,   /* 0x40 .. 0x4F */
+    1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 0, 0, 0, 0, 1,   /* 0x50 .. 0x5F */
+    0, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 1, 1, 1, 1, 1,   /* 0x60 .. 0x6F */
+    1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 0, 0, 0, 0, 0    /* 0x70 .. 0x7F */
+  };
+
+  return (t & 0x80) || aBareword[(int)t];
+}
+
+
+
+/*
+** 2014 Jun 09
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** This is an SQLite module implementing full-text search.
+*/
+
+
+
+
+#define FTS5_DEFAULT_PAGE_SIZE   4050
+#define FTS5_DEFAULT_AUTOMERGE      4
+#define FTS5_DEFAULT_CRISISMERGE   16
+
+/* Maximum allowed page size */
+#define FTS5_MAX_PAGE_SIZE (128*1024)
+
+static int fts5_iswhitespace(char x){
+  return (x==' ');
+}
+
+static int fts5_isopenquote(char x){
+  return (x=='"' || x=='\'' || x=='[' || x=='`');
+}
+
+/*
+** Argument pIn points to a character that is part of a nul-terminated 
+** string. Return a pointer to the first character following *pIn in 
+** the string that is not a white-space character.
+*/
+static const char *fts5ConfigSkipWhitespace(const char *pIn){
+  const char *p = pIn;
+  if( p ){
+    while( fts5_iswhitespace(*p) ){ p++; }
+  }
+  return p;
+}
+
+/*
+** Argument pIn points to a character that is part of a nul-terminated 
+** string. Return a pointer to the first character following *pIn in 
+** the string that is not a "bareword" character.
+*/
+static const char *fts5ConfigSkipBareword(const char *pIn){
+  const char *p = pIn;
+  while ( sqlite3Fts5IsBareword(*p) ) p++;
+  if( p==pIn ) p = 0;
+  return p;
+}
+
+static int fts5_isdigit(char a){
+  return (a>='0' && a<='9');
+}
+
+
+
+static const char *fts5ConfigSkipLiteral(const char *pIn){
+  const char *p = pIn;
+  switch( *p ){
+    case 'n': case 'N':
+      if( sqlite3_strnicmp("null", p, 4)==0 ){
+        p = &p[4];
+      }else{
+        p = 0;
+      }
+      break;
+
+    case 'x': case 'X':
+      p++;
+      if( *p=='\'' ){
+        p++;
+        while( (*p>='a' && *p<='f') 
+            || (*p>='A' && *p<='F') 
+            || (*p>='0' && *p<='9') 
+            ){
+          p++;
+        }
+        if( *p=='\'' && 0==((p-pIn)%2) ){
+          p++;
+        }else{
+          p = 0;
+        }
+      }else{
+        p = 0;
+      }
+      break;
+
+    case '\'':
+      p++;
+      while( p ){
+        if( *p=='\'' ){
+          p++;
+          if( *p!='\'' ) break;
+        }
+        p++;
+        if( *p==0 ) p = 0;
+      }
+      break;
+
+    default:
+      /* maybe a number */
+      if( *p=='+' || *p=='-' ) p++;
+      while( fts5_isdigit(*p) ) p++;
+
+      /* At this point, if the literal was an integer, the parse is 
+      ** finished. Or, if it is a floating point value, it may continue
+      ** with either a decimal point or an 'E' character. */
+      if( *p=='.' && fts5_isdigit(p[1]) ){
+        p += 2;
+        while( fts5_isdigit(*p) ) p++;
+      }
+      if( p==pIn ) p = 0;
+
+      break;
+  }
+
+  return p;
+}
+
+/*
+** The first character of the string pointed to by argument z is guaranteed
+** to be an open-quote character (see function fts5_isopenquote()).
+**
+** This function searches for the corresponding close-quote character within
+** the string and, if found, dequotes the string in place and adds a new
+** nul-terminator byte.
+**
+** If the close-quote is found, the value returned is the byte offset of
+** the character immediately following it. Or, if the close-quote is not 
+** found, -1 is returned. If -1 is returned, the buffer is left in an 
+** undefined state.
+*/
+static int fts5Dequote(char *z){
+  char q;
+  int iIn = 1;
+  int iOut = 0;
+  q = z[0];
+
+  /* Set stack variable q to the close-quote character */
+  assert( q=='[' || q=='\'' || q=='"' || q=='`' );
+  if( q=='[' ) q = ']';  
+
+  while( ALWAYS(z[iIn]) ){
+    if( z[iIn]==q ){
+      if( z[iIn+1]!=q ){
+        /* Character iIn was the close quote. */
+        iIn++;
+        break;
+      }else{
+        /* Character iIn and iIn+1 form an escaped quote character. Skip
+        ** the input cursor past both and copy a single quote character 
+        ** to the output buffer. */
+        iIn += 2;
+        z[iOut++] = q;
+      }
+    }else{
+      z[iOut++] = z[iIn++];
+    }
+  }
+
+  z[iOut] = '\0';
+  return iIn;
+}
+
+/*
+** Convert an SQL-style quoted string into a normal string by removing
+** the quote characters.  The conversion is done in-place.  If the
+** input does not begin with a quote character, then this routine
+** is a no-op.
+**
+** Examples:
+**
+**     "abc"   becomes   abc
+**     'xyz'   becomes   xyz
+**     [pqr]   becomes   pqr
+**     `mno`   becomes   mno
+*/
+static void sqlite3Fts5Dequote(char *z){
+  char quote;                     /* Quote character (if any ) */
+
+  assert( 0==fts5_iswhitespace(z[0]) );
+  quote = z[0];
+  if( quote=='[' || quote=='\'' || quote=='"' || quote=='`' ){
+    fts5Dequote(z);
+  }
+}
+
+/*
+** Parse a "special" CREATE VIRTUAL TABLE directive and update
+** configuration object pConfig as appropriate.
+**
+** If successful, object pConfig is updated and SQLITE_OK returned. If
+** an error occurs, an SQLite error code is returned and an error message
+** may be left in *pzErr. It is the responsibility of the caller to
+** eventually free any such error message using sqlite3_free().
+*/
+static int fts5ConfigParseSpecial(
+  Fts5Global *pGlobal,
+  Fts5Config *pConfig,            /* Configuration object to update */
+  const char *zCmd,               /* Special command to parse */
+  const char *zArg,               /* Argument to parse */
+  char **pzErr                    /* OUT: Error message */
+){
+  int rc = SQLITE_OK;
+  int nCmd = strlen(zCmd);
+  if( sqlite3_strnicmp("prefix", zCmd, nCmd)==0 ){
+    const int nByte = sizeof(int) * FTS5_MAX_PREFIX_INDEXES;
+    const char *p;
+    if( pConfig->aPrefix ){
+      *pzErr = sqlite3_mprintf("multiple prefix=... directives");
+      rc = SQLITE_ERROR;
+    }else{
+      pConfig->aPrefix = sqlite3Fts5MallocZero(&rc, nByte);
+    }
+    p = zArg;
+    while( rc==SQLITE_OK && p[0] ){
+      int nPre = 0;
+      while( p[0]==' ' ) p++;
+      while( p[0]>='0' && p[0]<='9' && nPre<1000 ){
+        nPre = nPre*10 + (p[0] - '0');
+        p++;
+      }
+      while( p[0]==' ' ) p++;
+      if( p[0]==',' ){
+        p++;
+      }else if( p[0] ){
+        *pzErr = sqlite3_mprintf("malformed prefix=... directive");
+        rc = SQLITE_ERROR;
+      }
+      if( rc==SQLITE_OK && (nPre==0 || nPre>=1000) ){
+        *pzErr = sqlite3_mprintf("prefix length out of range: %d", nPre);
+        rc = SQLITE_ERROR;
+      }
+      pConfig->aPrefix[pConfig->nPrefix] = nPre;
+      pConfig->nPrefix++;
+    }
+    return rc;
+  }
+
+  if( sqlite3_strnicmp("tokenize", zCmd, nCmd)==0 ){
+    const char *p = (const char*)zArg;
+    int nArg = strlen(zArg) + 1;
+    char **azArg = sqlite3Fts5MallocZero(&rc, sizeof(char*) * nArg);
+    char *pDel = sqlite3Fts5MallocZero(&rc, nArg * 2);
+    char *pSpace = pDel;
+
+    if( azArg && pSpace ){
+      if( pConfig->pTok ){
+        *pzErr = sqlite3_mprintf("multiple tokenize=... directives");
+        rc = SQLITE_ERROR;
+      }else{
+        for(nArg=0; p && *p; nArg++){
+          const char *p2 = fts5ConfigSkipWhitespace(p);
+          if( *p2=='\'' ){
+            p = fts5ConfigSkipLiteral(p2);
+          }else{
+            p = fts5ConfigSkipBareword(p2);
+          }
+          if( p ){
+            memcpy(pSpace, p2, p-p2);
+            azArg[nArg] = pSpace;
+            sqlite3Fts5Dequote(pSpace);
+            pSpace += (p - p2) + 1;
+            p = fts5ConfigSkipWhitespace(p);
+          }
+        }
+        if( p==0 ){
+          *pzErr = sqlite3_mprintf("parse error in tokenize directive");
+          rc = SQLITE_ERROR;
+        }else{
+          rc = sqlite3Fts5GetTokenizer(pGlobal, 
+              (const char**)azArg, nArg, &pConfig->pTok, &pConfig->pTokApi,
+              pzErr
+          );
+        }
+      }
+    }
+
+    sqlite3_free(azArg);
+    sqlite3_free(pDel);
+    return rc;
+  }
+
+  if( sqlite3_strnicmp("content", zCmd, nCmd)==0 ){
+    if( pConfig->eContent!=FTS5_CONTENT_NORMAL ){
+      *pzErr = sqlite3_mprintf("multiple content=... directives");
+      rc = SQLITE_ERROR;
+    }else{
+      if( zArg[0] ){
+        pConfig->eContent = FTS5_CONTENT_EXTERNAL;
+        pConfig->zContent = sqlite3Fts5Mprintf(&rc, "%Q.%Q", pConfig->zDb,zArg);
+      }else{
+        pConfig->eContent = FTS5_CONTENT_NONE;
+      }
+    }
+    return rc;
+  }
+
+  if( sqlite3_strnicmp("content_rowid", zCmd, nCmd)==0 ){
+    if( pConfig->zContentRowid ){
+      *pzErr = sqlite3_mprintf("multiple content_rowid=... directives");
+      rc = SQLITE_ERROR;
+    }else{
+      pConfig->zContentRowid = sqlite3Fts5Strndup(&rc, zArg, -1);
+    }
+    return rc;
+  }
+
+  if( sqlite3_strnicmp("columnsize", zCmd, nCmd)==0 ){
+    if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1]!='\0' ){
+      *pzErr = sqlite3_mprintf("malformed columnsize=... directive");
+      rc = SQLITE_ERROR;
+    }else{
+      pConfig->bColumnsize = (zArg[0]=='1');
+    }
+    return rc;
+  }
+
+  *pzErr = sqlite3_mprintf("unrecognized option: \"%.*s\"", nCmd, zCmd);
+  return SQLITE_ERROR;
+}
+
+/*
+** Allocate an instance of the default tokenizer ("simple") at 
+** Fts5Config.pTokenizer. Return SQLITE_OK if successful, or an SQLite error
+** code if an error occurs.
+*/
+static int fts5ConfigDefaultTokenizer(Fts5Global *pGlobal, Fts5Config *pConfig){
+  assert( pConfig->pTok==0 && pConfig->pTokApi==0 );
+  return sqlite3Fts5GetTokenizer(
+      pGlobal, 0, 0, &pConfig->pTok, &pConfig->pTokApi, 0
+  );
+}
+
+/*
+** Gobble up the first bareword or quoted word from the input buffer zIn.
+** Return a pointer to the character immediately following the last in
+** the gobbled word if successful, or a NULL pointer otherwise (failed
+** to find close-quote character).
+**
+** Before returning, set pzOut to point to a new buffer containing a
+** nul-terminated, dequoted copy of the gobbled word. If the word was
+** quoted, *pbQuoted is also set to 1 before returning.
+**
+** If *pRc is other than SQLITE_OK when this function is called, it is
+** a no-op (NULL is returned). Otherwise, if an OOM occurs within this
+** function, *pRc is set to SQLITE_NOMEM before returning. *pRc is *not*
+** set if a parse error (failed to find close quote) occurs.
+*/
+static const char *fts5ConfigGobbleWord(
+  int *pRc,                       /* IN/OUT: Error code */
+  const char *zIn,                /* Buffer to gobble string/bareword from */
+  char **pzOut,                   /* OUT: malloc'd buffer containing str/bw */
+  int *pbQuoted                   /* OUT: Set to true if dequoting required */
+){
+  const char *zRet = 0;
+
+  int nIn = strlen(zIn);
+  char *zOut = sqlite3_malloc(nIn+1);
+
+  assert( *pRc==SQLITE_OK );
+  *pbQuoted = 0;
+  *pzOut = 0;
+
+  if( zOut==0 ){
+    *pRc = SQLITE_NOMEM;
+  }else{
+    memcpy(zOut, zIn, nIn+1);
+    if( fts5_isopenquote(zOut[0]) ){
+      int ii = fts5Dequote(zOut);
+      zRet = &zIn[ii];
+      *pbQuoted = 1;
+    }else{
+      zRet = fts5ConfigSkipBareword(zIn);
+      zOut[zRet-zIn] = '\0';
+    }
+  }
+
+  if( zRet==0 ){
+    sqlite3_free(zOut);
+  }else{
+    *pzOut = zOut;
+  }
+
+  return zRet;
+}
+
+static int fts5ConfigParseColumn(
+  Fts5Config *p, 
+  char *zCol, 
+  char *zArg, 
+  char **pzErr
+){
+  int rc = SQLITE_OK;
+  if( 0==sqlite3_stricmp(zCol, FTS5_RANK_NAME) 
+   || 0==sqlite3_stricmp(zCol, FTS5_ROWID_NAME) 
+  ){
+    *pzErr = sqlite3_mprintf("reserved fts5 column name: %s", zCol);
+    rc = SQLITE_ERROR;
+  }else if( zArg ){
+    if( 0==sqlite3_stricmp(zArg, "unindexed") ){
+      p->abUnindexed[p->nCol] = 1;
+    }else{
+      *pzErr = sqlite3_mprintf("unrecognized column option: %s", zArg);
+      rc = SQLITE_ERROR;
+    }
+  }
+
+  p->azCol[p->nCol++] = zCol;
+  return rc;
+}
+
+/*
+** Populate the Fts5Config.zContentExprlist string.
+*/
+static int fts5ConfigMakeExprlist(Fts5Config *p){
+  int i;
+  int rc = SQLITE_OK;
+  Fts5Buffer buf = {0, 0, 0};
+
+  sqlite3Fts5BufferAppendPrintf(&rc, &buf, "T.%Q", p->zContentRowid);
+  if( p->eContent!=FTS5_CONTENT_NONE ){
+    for(i=0; i<p->nCol; i++){
+      if( p->eContent==FTS5_CONTENT_EXTERNAL ){
+        sqlite3Fts5BufferAppendPrintf(&rc, &buf, ", T.%Q", p->azCol[i]);
+      }else{
+        sqlite3Fts5BufferAppendPrintf(&rc, &buf, ", T.c%d", i);
+      }
+    }
+  }
+
+  assert( p->zContentExprlist==0 );
+  p->zContentExprlist = (char*)buf.p;
+  return rc;
+}
+
+/*
+** Arguments nArg/azArg contain the string arguments passed to the xCreate
+** or xConnect method of the virtual table. This function attempts to 
+** allocate an instance of Fts5Config containing the results of parsing
+** those arguments.
+**
+** If successful, SQLITE_OK is returned and *ppOut is set to point to the
+** new Fts5Config object. If an error occurs, an SQLite error code is 
+** returned, *ppOut is set to NULL and an error message may be left in
+** *pzErr. It is the responsibility of the caller to eventually free any 
+** such error message using sqlite3_free().
+*/
+static int sqlite3Fts5ConfigParse(
+  Fts5Global *pGlobal,
+  sqlite3 *db,
+  int nArg,                       /* Number of arguments */
+  const char **azArg,             /* Array of nArg CREATE VIRTUAL TABLE args */
+  Fts5Config **ppOut,             /* OUT: Results of parse */
+  char **pzErr                    /* OUT: Error message */
+){
+  int rc = SQLITE_OK;             /* Return code */
+  Fts5Config *pRet;               /* New object to return */
+  int i;
+  int nByte;
+
+  *ppOut = pRet = (Fts5Config*)sqlite3_malloc(sizeof(Fts5Config));
+  if( pRet==0 ) return SQLITE_NOMEM;
+  memset(pRet, 0, sizeof(Fts5Config));
+  pRet->db = db;
+  pRet->iCookie = -1;
+
+  nByte = nArg * (sizeof(char*) + sizeof(u8));
+  pRet->azCol = (char**)sqlite3Fts5MallocZero(&rc, nByte);
+  pRet->abUnindexed = (u8*)&pRet->azCol[nArg];
+  pRet->zDb = sqlite3Fts5Strndup(&rc, azArg[1], -1);
+  pRet->zName = sqlite3Fts5Strndup(&rc, azArg[2], -1);
+  pRet->bColumnsize = 1;
+#ifdef SQLITE_DEBUG
+  pRet->bPrefixIndex = 1;
+#endif
+  if( rc==SQLITE_OK && sqlite3_stricmp(pRet->zName, FTS5_RANK_NAME)==0 ){
+    *pzErr = sqlite3_mprintf("reserved fts5 table name: %s", pRet->zName);
+    rc = SQLITE_ERROR;
+  }
+
+  for(i=3; rc==SQLITE_OK && i<nArg; i++){
+    const char *zOrig = azArg[i];
+    const char *z;
+    char *zOne = 0;
+    char *zTwo = 0;
+    int bOption = 0;
+    int bMustBeCol = 0;
+
+    z = fts5ConfigGobbleWord(&rc, zOrig, &zOne, &bMustBeCol);
+    z = fts5ConfigSkipWhitespace(z);
+    if( z && *z=='=' ){
+      bOption = 1;
+      z++;
+      if( bMustBeCol ) z = 0;
+    }
+    z = fts5ConfigSkipWhitespace(z);
+    if( z && z[0] ){
+      int bDummy;
+      z = fts5ConfigGobbleWord(&rc, z, &zTwo, &bDummy);
+      if( z && z[0] ) z = 0;
+    }
+
+    if( rc==SQLITE_OK ){
+      if( z==0 ){
+        *pzErr = sqlite3_mprintf("parse error in \"%s\"", zOrig);
+        rc = SQLITE_ERROR;
+      }else{
+        if( bOption ){
+          rc = fts5ConfigParseSpecial(pGlobal, pRet, zOne, zTwo?zTwo:"", pzErr);
+        }else{
+          rc = fts5ConfigParseColumn(pRet, zOne, zTwo, pzErr);
+          zOne = 0;
+        }
+      }
+    }
+
+    sqlite3_free(zOne);
+    sqlite3_free(zTwo);
+  }
+
+  /* If a tokenizer= option was successfully parsed, the tokenizer has
+  ** already been allocated. Otherwise, allocate an instance of the default
+  ** tokenizer (unicode61) now.  */
+  if( rc==SQLITE_OK && pRet->pTok==0 ){
+    rc = fts5ConfigDefaultTokenizer(pGlobal, pRet);
+  }
+
+  /* If no zContent option was specified, fill in the default values. */
+  if( rc==SQLITE_OK && pRet->zContent==0 ){
+    const char *zTail = 0;
+    assert( pRet->eContent==FTS5_CONTENT_NORMAL 
+         || pRet->eContent==FTS5_CONTENT_NONE 
+    );
+    if( pRet->eContent==FTS5_CONTENT_NORMAL ){
+      zTail = "content";
+    }else if( pRet->bColumnsize ){
+      zTail = "docsize";
+    }
+
+    if( zTail ){
+      pRet->zContent = sqlite3Fts5Mprintf(
+          &rc, "%Q.'%q_%s'", pRet->zDb, pRet->zName, zTail
+      );
+    }
+  }
+
+  if( rc==SQLITE_OK && pRet->zContentRowid==0 ){
+    pRet->zContentRowid = sqlite3Fts5Strndup(&rc, "rowid", -1);
+  }
+
+  /* Formulate the zContentExprlist text */
+  if( rc==SQLITE_OK ){
+    rc = fts5ConfigMakeExprlist(pRet);
+  }
+
+  if( rc!=SQLITE_OK ){
+    sqlite3Fts5ConfigFree(pRet);
+    *ppOut = 0;
+  }
+  return rc;
+}
+
+/*
+** Free the configuration object passed as the only argument.
+*/
+static void sqlite3Fts5ConfigFree(Fts5Config *pConfig){
+  if( pConfig ){
+    int i;
+    if( pConfig->pTok ){
+      pConfig->pTokApi->xDelete(pConfig->pTok);
+    }
+    sqlite3_free(pConfig->zDb);
+    sqlite3_free(pConfig->zName);
+    for(i=0; i<pConfig->nCol; i++){
+      sqlite3_free(pConfig->azCol[i]);
+    }
+    sqlite3_free(pConfig->azCol);
+    sqlite3_free(pConfig->aPrefix);
+    sqlite3_free(pConfig->zRank);
+    sqlite3_free(pConfig->zRankArgs);
+    sqlite3_free(pConfig->zContent);
+    sqlite3_free(pConfig->zContentRowid);
+    sqlite3_free(pConfig->zContentExprlist);
+    sqlite3_free(pConfig);
+  }
+}
+
+/*
+** Call sqlite3_declare_vtab() based on the contents of the configuration
+** object passed as the only argument. Return SQLITE_OK if successful, or
+** an SQLite error code if an error occurs.
+*/
+static int sqlite3Fts5ConfigDeclareVtab(Fts5Config *pConfig){
+  int i;
+  int rc = SQLITE_OK;
+  char *zSql;
+
+  zSql = sqlite3Fts5Mprintf(&rc, "CREATE TABLE x(");
+  for(i=0; zSql && i<pConfig->nCol; i++){
+    const char *zSep = (i==0?"":", ");
+    zSql = sqlite3Fts5Mprintf(&rc, "%z%s%Q", zSql, zSep, pConfig->azCol[i]);
+  }
+  zSql = sqlite3Fts5Mprintf(&rc, "%z, %Q HIDDEN, %s HIDDEN)", 
+      zSql, pConfig->zName, FTS5_RANK_NAME
+  );
+
+  assert( zSql || rc==SQLITE_NOMEM );
+  if( zSql ){
+    rc = sqlite3_declare_vtab(pConfig->db, zSql);
+    sqlite3_free(zSql);
+  }
+  
+  return rc;
+}
+
+/*
+** Tokenize the text passed via the second and third arguments.
+**
+** The callback is invoked once for each token in the input text. The
+** arguments passed to it are, in order:
+**
+**     void *pCtx          // Copy of 4th argument to sqlite3Fts5Tokenize()
+**     const char *pToken  // Pointer to buffer containing token
+**     int nToken          // Size of token in bytes
+**     int iStart          // Byte offset of start of token within input text
+**     int iEnd            // Byte offset of end of token within input text
+**     int iPos            // Position of token in input (first token is 0)
+**
+** If the callback returns a non-zero value the tokenization is abandoned
+** and no further callbacks are issued. 
+**
+** This function returns SQLITE_OK if successful or an SQLite error code
+** if an error occurs. If the tokenization was abandoned early because
+** the callback returned SQLITE_DONE, this is not an error and this function
+** still returns SQLITE_OK. Or, if the tokenization was abandoned early
+** because the callback returned another non-zero value, it is assumed
+** to be an SQLite error code and returned to the caller.
+*/
+static int sqlite3Fts5Tokenize(
+  Fts5Config *pConfig,            /* FTS5 Configuration object */
+  int flags,                      /* FTS5_TOKENIZE_* flags */
+  const char *pText, int nText,   /* Text to tokenize */
+  void *pCtx,                     /* Context passed to xToken() */
+  int (*xToken)(void*, int, const char*, int, int, int)    /* Callback */
+){
+  if( pText==0 ) return SQLITE_OK;
+  return pConfig->pTokApi->xTokenize(
+      pConfig->pTok, pCtx, flags, pText, nText, xToken
+  );
+}
+
+/*
+** Argument pIn points to the first character in what is expected to be
+** a comma-separated list of SQL literals followed by a ')' character.
+** If it actually is this, return a pointer to the ')'. Otherwise, return
+** NULL to indicate a parse error.
+*/
+static const char *fts5ConfigSkipArgs(const char *pIn){
+  const char *p = pIn;
+  
+  while( 1 ){
+    p = fts5ConfigSkipWhitespace(p);
+    p = fts5ConfigSkipLiteral(p);
+    p = fts5ConfigSkipWhitespace(p);
+    if( p==0 || *p==')' ) break;
+    if( *p!=',' ){
+      p = 0;
+      break;
+    }
+    p++;
+  }
+
+  return p;
+}
+
+/*
+** Parameter zIn contains a rank() function specification. The format of 
+** this is:
+**
+**   + Bareword (function name)
+**   + Open parenthesis - "("
+**   + Zero or more SQL literals in a comma separated list
+**   + Close parenthesis - ")"
+*/
+static int sqlite3Fts5ConfigParseRank(
+  const char *zIn,                /* Input string */
+  char **pzRank,                  /* OUT: Rank function name */
+  char **pzRankArgs               /* OUT: Rank function arguments */
+){
+  const char *p = zIn;
+  const char *pRank;
+  char *zRank = 0;
+  char *zRankArgs = 0;
+  int rc = SQLITE_OK;
+
+  *pzRank = 0;
+  *pzRankArgs = 0;
+
+  p = fts5ConfigSkipWhitespace(p);
+  pRank = p;
+  p = fts5ConfigSkipBareword(p);
+
+  if( p ){
+    zRank = sqlite3Fts5MallocZero(&rc, 1 + p - pRank);
+    if( zRank ) memcpy(zRank, pRank, p-pRank);
+  }else{
+    rc = SQLITE_ERROR;
+  }
+
+  if( rc==SQLITE_OK ){
+    p = fts5ConfigSkipWhitespace(p);
+    if( *p!='(' ) rc = SQLITE_ERROR;
+    p++;
+  }
+  if( rc==SQLITE_OK ){
+    const char *pArgs; 
+    p = fts5ConfigSkipWhitespace(p);
+    pArgs = p;
+    if( *p!=')' ){
+      p = fts5ConfigSkipArgs(p);
+      if( p==0 ){
+        rc = SQLITE_ERROR;
+      }else{
+        zRankArgs = sqlite3Fts5MallocZero(&rc, 1 + p - pArgs);
+        if( zRankArgs ) memcpy(zRankArgs, pArgs, p-pArgs);
+      }
+    }
+  }
+
+  if( rc!=SQLITE_OK ){
+    sqlite3_free(zRank);
+    assert( zRankArgs==0 );
+  }else{
+    *pzRank = zRank;
+    *pzRankArgs = zRankArgs;
+  }
+  return rc;
+}
+
+static int sqlite3Fts5ConfigSetValue(
+  Fts5Config *pConfig, 
+  const char *zKey, 
+  sqlite3_value *pVal,
+  int *pbBadkey
+){
+  int rc = SQLITE_OK;
+
+  if( 0==sqlite3_stricmp(zKey, "pgsz") ){
+    int pgsz = 0;
+    if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){
+      pgsz = sqlite3_value_int(pVal);
+    }
+    if( pgsz<=0 || pgsz>FTS5_MAX_PAGE_SIZE ){
+      *pbBadkey = 1;
+    }else{
+      pConfig->pgsz = pgsz;
+    }
+  }
+
+  else if( 0==sqlite3_stricmp(zKey, "automerge") ){
+    int nAutomerge = -1;
+    if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){
+      nAutomerge = sqlite3_value_int(pVal);
+    }
+    if( nAutomerge<0 || nAutomerge>64 ){
+      *pbBadkey = 1;
+    }else{
+      if( nAutomerge==1 ) nAutomerge = FTS5_DEFAULT_AUTOMERGE;
+      pConfig->nAutomerge = nAutomerge;
+    }
+  }
+
+  else if( 0==sqlite3_stricmp(zKey, "crisismerge") ){
+    int nCrisisMerge = -1;
+    if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){
+      nCrisisMerge = sqlite3_value_int(pVal);
+    }
+    if( nCrisisMerge<0 ){
+      *pbBadkey = 1;
+    }else{
+      if( nCrisisMerge<=1 ) nCrisisMerge = FTS5_DEFAULT_CRISISMERGE;
+      pConfig->nCrisisMerge = nCrisisMerge;
+    }
+  }
+
+  else if( 0==sqlite3_stricmp(zKey, "rank") ){
+    const char *zIn = (const char*)sqlite3_value_text(pVal);
+    char *zRank;
+    char *zRankArgs;
+    rc = sqlite3Fts5ConfigParseRank(zIn, &zRank, &zRankArgs);
+    if( rc==SQLITE_OK ){
+      sqlite3_free(pConfig->zRank);
+      sqlite3_free(pConfig->zRankArgs);
+      pConfig->zRank = zRank;
+      pConfig->zRankArgs = zRankArgs;
+    }else if( rc==SQLITE_ERROR ){
+      rc = SQLITE_OK;
+      *pbBadkey = 1;
+    }
+  }else{
+    *pbBadkey = 1;
+  }
+  return rc;
+}
+
+/*
+** Load the contents of the %_config table into memory.
+*/
+static int sqlite3Fts5ConfigLoad(Fts5Config *pConfig, int iCookie){
+  const char *zSelect = "SELECT k, v FROM %Q.'%q_config'";
+  char *zSql;
+  sqlite3_stmt *p = 0;
+  int rc = SQLITE_OK;
+  int iVersion = 0;
+
+  /* Set default values */
+  pConfig->pgsz = FTS5_DEFAULT_PAGE_SIZE;
+  pConfig->nAutomerge = FTS5_DEFAULT_AUTOMERGE;
+  pConfig->nCrisisMerge = FTS5_DEFAULT_CRISISMERGE;
+
+  zSql = sqlite3Fts5Mprintf(&rc, zSelect, pConfig->zDb, pConfig->zName);
+  if( zSql ){
+    rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &p, 0);
+    sqlite3_free(zSql);
+  }
+
+  assert( rc==SQLITE_OK || p==0 );
+  if( rc==SQLITE_OK ){
+    while( SQLITE_ROW==sqlite3_step(p) ){
+      const char *zK = (const char*)sqlite3_column_text(p, 0);
+      sqlite3_value *pVal = sqlite3_column_value(p, 1);
+      if( 0==sqlite3_stricmp(zK, "version") ){
+        iVersion = sqlite3_value_int(pVal);
+      }else{
+        int bDummy = 0;
+        sqlite3Fts5ConfigSetValue(pConfig, zK, pVal, &bDummy);
+      }
+    }
+    rc = sqlite3_finalize(p);
+  }
+  
+  if( rc==SQLITE_OK && iVersion!=FTS5_CURRENT_VERSION ){
+    rc = SQLITE_ERROR;
+    if( pConfig->pzErrmsg ){
+      assert( 0==*pConfig->pzErrmsg );
+      *pConfig->pzErrmsg = sqlite3_mprintf(
+          "invalid fts5 file format (found %d, expected %d) - run 'rebuild'",
+          iVersion, FTS5_CURRENT_VERSION
+      );
+    }
+  }
+
+  if( rc==SQLITE_OK ){
+    pConfig->iCookie = iCookie;
+  }
+  return rc;
+}
+
+
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+*/
+
+
+
+
+/*
+** All token types in the generated fts5parse.h file are greater than 0.
+*/
+#define FTS5_EOF 0
+
+#define FTS5_LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))
+
+typedef struct Fts5ExprTerm Fts5ExprTerm;
+
+/*
+** Functions generated by lemon from fts5parse.y.
+*/
+static void *sqlite3Fts5ParserAlloc(void *(*mallocProc)(u64));
+static void sqlite3Fts5ParserFree(void*, void (*freeProc)(void*));
+static void sqlite3Fts5Parser(void*, int, Fts5Token, Fts5Parse*);
+#ifndef NDEBUG
+/* #include <stdio.h> */
+static void sqlite3Fts5ParserTrace(FILE*, char*);
+#endif
+
+
+struct Fts5Expr {
+  Fts5Index *pIndex;
+  Fts5ExprNode *pRoot;
+  int bDesc;                      /* Iterate in descending rowid order */
+  int nPhrase;                    /* Number of phrases in expression */
+  Fts5ExprPhrase **apExprPhrase;  /* Pointers to phrase objects */
+};
+
+/*
+** eType:
+**   Expression node type. Always one of:
+**
+**       FTS5_AND                 (nChild, apChild valid)
+**       FTS5_OR                  (nChild, apChild valid)
+**       FTS5_NOT                 (nChild, apChild valid)
+**       FTS5_STRING              (pNear valid)
+**       FTS5_TERM                (pNear valid)
+*/
+struct Fts5ExprNode {
+  int eType;                      /* Node type */
+  int bEof;                       /* True at EOF */
+  int bNomatch;                   /* True if entry is not a match */
+
+  i64 iRowid;                     /* Current rowid */
+  Fts5ExprNearset *pNear;         /* For FTS5_STRING - cluster of phrases */
+
+  /* Child nodes. For a NOT node, this array always contains 2 entries. For 
+  ** AND or OR nodes, it contains 2 or more entries.  */
+  int nChild;                     /* Number of child nodes */
+  Fts5ExprNode *apChild[1];       /* Array of child nodes */
+};
+
+#define Fts5NodeIsString(p) ((p)->eType==FTS5_TERM || (p)->eType==FTS5_STRING)
+
+/*
+** An instance of the following structure represents a single search term
+** or term prefix.
+*/
+struct Fts5ExprTerm {
+  int bPrefix;                    /* True for a prefix term */
+  char *zTerm;                    /* nul-terminated term */
+  Fts5IndexIter *pIter;           /* Iterator for this term */
+  Fts5ExprTerm *pSynonym;         /* Pointer to first in list of synonyms */
+};
+
+/*
+** A phrase. One or more terms that must appear in a contiguous sequence
+** within a document for it to match.
+*/
+struct Fts5ExprPhrase {
+  Fts5ExprNode *pNode;            /* FTS5_STRING node this phrase is part of */
+  Fts5Buffer poslist;             /* Current position list */
+  int nTerm;                      /* Number of entries in aTerm[] */
+  Fts5ExprTerm aTerm[1];          /* Terms that make up this phrase */
+};
+
+/*
+** One or more phrases that must appear within a certain token distance of
+** each other within each matching document.
+*/
+struct Fts5ExprNearset {
+  int nNear;                      /* NEAR parameter */
+  Fts5Colset *pColset;            /* Columns to search (NULL -> all columns) */
+  int nPhrase;                    /* Number of entries in aPhrase[] array */
+  Fts5ExprPhrase *apPhrase[1];    /* Array of phrase pointers */
+};
+
+
+/*
+** Parse context.
+*/
+struct Fts5Parse {
+  Fts5Config *pConfig;
+  char *zErr;
+  int rc;
+  int nPhrase;                    /* Size of apPhrase array */
+  Fts5ExprPhrase **apPhrase;      /* Array of all phrases */
+  Fts5ExprNode *pExpr;            /* Result of a successful parse */
+};
+
+static void sqlite3Fts5ParseError(Fts5Parse *pParse, const char *zFmt, ...){
+  va_list ap;
+  va_start(ap, zFmt);
+  if( pParse->rc==SQLITE_OK ){
+    pParse->zErr = sqlite3_vmprintf(zFmt, ap);
+    pParse->rc = SQLITE_ERROR;
+  }
+  va_end(ap);
+}
+
+static int fts5ExprIsspace(char t){
+  return t==' ' || t=='\t' || t=='\n' || t=='\r';
+}
+
+/*
+** Read the first token from the nul-terminated string at *pz.
+*/
+static int fts5ExprGetToken(
+  Fts5Parse *pParse, 
+  const char **pz,                /* IN/OUT: Pointer into buffer */
+  Fts5Token *pToken
+){
+  const char *z = *pz;
+  int tok;
+
+  /* Skip past any whitespace */
+  while( fts5ExprIsspace(*z) ) z++;
+
+  pToken->p = z;
+  pToken->n = 1;
+  switch( *z ){
+    case '(':  tok = FTS5_LP;    break;
+    case ')':  tok = FTS5_RP;    break;
+    case '{':  tok = FTS5_LCP;   break;
+    case '}':  tok = FTS5_RCP;   break;
+    case ':':  tok = FTS5_COLON; break;
+    case ',':  tok = FTS5_COMMA; break;
+    case '+':  tok = FTS5_PLUS;  break;
+    case '*':  tok = FTS5_STAR;  break;
+    case '\0': tok = FTS5_EOF;   break;
+
+    case '"': {
+      const char *z2;
+      tok = FTS5_STRING;
+
+      for(z2=&z[1]; 1; z2++){
+        if( z2[0]=='"' ){
+          z2++;
+          if( z2[0]!='"' ) break;
+        }
+        if( z2[0]=='\0' ){
+          sqlite3Fts5ParseError(pParse, "unterminated string");
+          return FTS5_EOF;
+        }
+      }
+      pToken->n = (z2 - z);
+      break;
+    }
+
+    default: {
+      const char *z2;
+      if( sqlite3Fts5IsBareword(z[0])==0 ){
+        sqlite3Fts5ParseError(pParse, "fts5: syntax error near \"%.1s\"", z);
+        return FTS5_EOF;
+      }
+      tok = FTS5_STRING;
+      for(z2=&z[1]; sqlite3Fts5IsBareword(*z2); z2++);
+      pToken->n = (z2 - z);
+      if( pToken->n==2 && memcmp(pToken->p, "OR", 2)==0 )  tok = FTS5_OR;
+      if( pToken->n==3 && memcmp(pToken->p, "NOT", 3)==0 ) tok = FTS5_NOT;
+      if( pToken->n==3 && memcmp(pToken->p, "AND", 3)==0 ) tok = FTS5_AND;
+      break;
+    }
+  }
+
+  *pz = &pToken->p[pToken->n];
+  return tok;
+}
+
+static void *fts5ParseAlloc(u64 t){ return sqlite3_malloc((int)t); }
+static void fts5ParseFree(void *p){ sqlite3_free(p); }
+
+static int sqlite3Fts5ExprNew(
+  Fts5Config *pConfig,            /* FTS5 Configuration */
+  const char *zExpr,              /* Expression text */
+  Fts5Expr **ppNew, 
+  char **pzErr
+){
+  Fts5Parse sParse;
+  Fts5Token token;
+  const char *z = zExpr;
+  int t;                          /* Next token type */
+  void *pEngine;
+  Fts5Expr *pNew;
+
+  *ppNew = 0;
+  *pzErr = 0;
+  memset(&sParse, 0, sizeof(sParse));
+  pEngine = sqlite3Fts5ParserAlloc(fts5ParseAlloc);
+  if( pEngine==0 ){ return SQLITE_NOMEM; }
+  sParse.pConfig = pConfig;
+
+  do {
+    t = fts5ExprGetToken(&sParse, &z, &token);
+    sqlite3Fts5Parser(pEngine, t, token, &sParse);
+  }while( sParse.rc==SQLITE_OK && t!=FTS5_EOF );
+  sqlite3Fts5ParserFree(pEngine, fts5ParseFree);
+
+  assert( sParse.rc!=SQLITE_OK || sParse.zErr==0 );
+  if( sParse.rc==SQLITE_OK ){
+    *ppNew = pNew = sqlite3_malloc(sizeof(Fts5Expr));
+    if( pNew==0 ){
+      sParse.rc = SQLITE_NOMEM;
+      sqlite3Fts5ParseNodeFree(sParse.pExpr);
+    }else{
+      pNew->pRoot = sParse.pExpr;
+      pNew->pIndex = 0;
+      pNew->apExprPhrase = sParse.apPhrase;
+      pNew->nPhrase = sParse.nPhrase;
+      sParse.apPhrase = 0;
+    }
+  }
+
+  sqlite3_free(sParse.apPhrase);
+  *pzErr = sParse.zErr;
+  return sParse.rc;
+}
+
+/*
+** Free the expression node object passed as the only argument.
+*/
+static void sqlite3Fts5ParseNodeFree(Fts5ExprNode *p){
+  if( p ){
+    int i;
+    for(i=0; i<p->nChild; i++){
+      sqlite3Fts5ParseNodeFree(p->apChild[i]);
+    }
+    sqlite3Fts5ParseNearsetFree(p->pNear);
+    sqlite3_free(p);
+  }
+}
+
+/*
+** Free the expression object passed as the only argument.
+*/
+static void sqlite3Fts5ExprFree(Fts5Expr *p){
+  if( p ){
+    sqlite3Fts5ParseNodeFree(p->pRoot);
+    sqlite3_free(p->apExprPhrase);
+    sqlite3_free(p);
+  }
+}
+
+/*
+** Argument pTerm must be a synonym iterator. Return the current rowid
+** that it points to.
+*/
+static i64 fts5ExprSynonymRowid(Fts5ExprTerm *pTerm, int bDesc, int *pbEof){
+  i64 iRet = 0;
+  int bRetValid = 0;
+  Fts5ExprTerm *p;
+
+  assert( pTerm->pSynonym );
+  assert( bDesc==0 || bDesc==1 );
+  for(p=pTerm; p; p=p->pSynonym){
+    if( 0==sqlite3Fts5IterEof(p->pIter) ){
+      i64 iRowid = sqlite3Fts5IterRowid(p->pIter);
+      if( bRetValid==0 || (bDesc!=(iRowid<iRet)) ){
+        iRet = iRowid;
+        bRetValid = 1;
+      }
+    }
+  }
+
+  if( pbEof && bRetValid==0 ) *pbEof = 1;
+  return iRet;
+}
+
+/*
+** Argument pTerm must be a synonym iterator.
+*/
+static int fts5ExprSynonymPoslist(
+  Fts5ExprTerm *pTerm, 
+  Fts5Colset *pColset,
+  i64 iRowid,
+  int *pbDel,                     /* OUT: Caller should sqlite3_free(*pa) */
+  u8 **pa, int *pn
+){
+  Fts5PoslistReader aStatic[4];
+  Fts5PoslistReader *aIter = aStatic;
+  int nIter = 0;
+  int nAlloc = 4;
+  int rc = SQLITE_OK;
+  Fts5ExprTerm *p;
+
+  assert( pTerm->pSynonym );
+  for(p=pTerm; p; p=p->pSynonym){
+    Fts5IndexIter *pIter = p->pIter;
+    if( sqlite3Fts5IterEof(pIter)==0 && sqlite3Fts5IterRowid(pIter)==iRowid ){
+      const u8 *a;
+      int n;
+      i64 dummy;
+      rc = sqlite3Fts5IterPoslist(pIter, pColset, &a, &n, &dummy);
+      if( rc!=SQLITE_OK ) goto synonym_poslist_out;
+      if( nIter==nAlloc ){
+        int nByte = sizeof(Fts5PoslistReader) * nAlloc * 2;
+        Fts5PoslistReader *aNew = (Fts5PoslistReader*)sqlite3_malloc(nByte);
+        if( aNew==0 ){
+          rc = SQLITE_NOMEM;
+          goto synonym_poslist_out;
+        }
+        memcpy(aNew, aIter, sizeof(Fts5PoslistReader) * nIter);
+        nAlloc = nAlloc*2;
+        if( aIter!=aStatic ) sqlite3_free(aIter);
+        aIter = aNew;
+      }
+      sqlite3Fts5PoslistReaderInit(a, n, &aIter[nIter]);
+      assert( aIter[nIter].bEof==0 );
+      nIter++;
+    }
+  }
+
+  assert( *pbDel==0 );
+  if( nIter==1 ){
+    *pa = (u8*)aIter[0].a;
+    *pn = aIter[0].n;
+  }else{
+    Fts5PoslistWriter writer = {0};
+    Fts5Buffer buf = {0,0,0};
+    i64 iPrev = -1;
+    while( 1 ){
+      int i;
+      i64 iMin = FTS5_LARGEST_INT64;
+      for(i=0; i<nIter; i++){
+        if( aIter[i].bEof==0 ){
+          if( aIter[i].iPos==iPrev ){
+            if( sqlite3Fts5PoslistReaderNext(&aIter[i]) ) continue;
+          }
+          if( aIter[i].iPos<iMin ){
+            iMin = aIter[i].iPos;
+          }
+        }
+      }
+      if( iMin==FTS5_LARGEST_INT64 || rc!=SQLITE_OK ) break;
+      rc = sqlite3Fts5PoslistWriterAppend(&buf, &writer, iMin);
+      iPrev = iMin;
+    }
+    if( rc ){
+      sqlite3_free(buf.p);
+    }else{
+      *pa = buf.p;
+      *pn = buf.n;
+      *pbDel = 1;
+    }
+  }
+
+ synonym_poslist_out:
+  if( aIter!=aStatic ) sqlite3_free(aIter);
+  return rc;
+}
+
+
+/*
+** All individual term iterators in pPhrase are guaranteed to be valid and
+** pointing to the same rowid when this function is called. This function 
+** checks if the current rowid really is a match, and if so populates
+** the pPhrase->poslist buffer accordingly. Output parameter *pbMatch
+** is set to true if this is really a match, or false otherwise.
+**
+** SQLITE_OK is returned if an error occurs, or an SQLite error code 
+** otherwise. It is not considered an error code if the current rowid is 
+** not a match.
+*/
+static int fts5ExprPhraseIsMatch(
+  Fts5ExprNode *pNode,            /* Node pPhrase belongs to */
+  Fts5Colset *pColset,            /* Restrict matches to these columns */
+  Fts5ExprPhrase *pPhrase,        /* Phrase object to initialize */
+  int *pbMatch                    /* OUT: Set to true if really a match */
+){
+  Fts5PoslistWriter writer = {0};
+  Fts5PoslistReader aStatic[4];
+  Fts5PoslistReader *aIter = aStatic;
+  int i;
+  int rc = SQLITE_OK;
+  
+  fts5BufferZero(&pPhrase->poslist);
+
+  /* If the aStatic[] array is not large enough, allocate a large array
+  ** using sqlite3_malloc(). This approach could be improved upon. */
+  if( pPhrase->nTerm>(sizeof(aStatic) / sizeof(aStatic[0])) ){
+    int nByte = sizeof(Fts5PoslistReader) * pPhrase->nTerm;
+    aIter = (Fts5PoslistReader*)sqlite3_malloc(nByte);
+    if( !aIter ) return SQLITE_NOMEM;
+  }
+  memset(aIter, 0, sizeof(Fts5PoslistReader) * pPhrase->nTerm);
+
+  /* Initialize a term iterator for each term in the phrase */
+  for(i=0; i<pPhrase->nTerm; i++){
+    Fts5ExprTerm *pTerm = &pPhrase->aTerm[i];
+    i64 dummy;
+    int n = 0;
+    int bFlag = 0;
+    const u8 *a = 0;
+    if( pTerm->pSynonym ){
+      rc = fts5ExprSynonymPoslist(
+          pTerm, pColset, pNode->iRowid, &bFlag, (u8**)&a, &n
+      );
+    }else{
+      rc = sqlite3Fts5IterPoslist(pTerm->pIter, pColset, &a, &n, &dummy);
+    }
+    if( rc!=SQLITE_OK ) goto ismatch_out;
+    sqlite3Fts5PoslistReaderInit(a, n, &aIter[i]);
+    aIter[i].bFlag = bFlag;
+    if( aIter[i].bEof ) goto ismatch_out;
+  }
+
+  while( 1 ){
+    int bMatch;
+    i64 iPos = aIter[0].iPos;
+    do {
+      bMatch = 1;
+      for(i=0; i<pPhrase->nTerm; i++){
+        Fts5PoslistReader *pPos = &aIter[i];
+        i64 iAdj = iPos + i;
+        if( pPos->iPos!=iAdj ){
+          bMatch = 0;
+          while( pPos->iPos<iAdj ){
+            if( sqlite3Fts5PoslistReaderNext(pPos) ) goto ismatch_out;
+          }
+          if( pPos->iPos>iAdj ) iPos = pPos->iPos-i;
+        }
+      }
+    }while( bMatch==0 );
+
+    /* Append position iPos to the output */
+    rc = sqlite3Fts5PoslistWriterAppend(&pPhrase->poslist, &writer, iPos);
+    if( rc!=SQLITE_OK ) goto ismatch_out;
+
+    for(i=0; i<pPhrase->nTerm; i++){
+      if( sqlite3Fts5PoslistReaderNext(&aIter[i]) ) goto ismatch_out;
+    }
+  }
+
+ ismatch_out:
+  *pbMatch = (pPhrase->poslist.n>0);
+  for(i=0; i<pPhrase->nTerm; i++){
+    if( aIter[i].bFlag ) sqlite3_free((u8*)aIter[i].a);
+  }
+  if( aIter!=aStatic ) sqlite3_free(aIter);
+  return rc;
+}
+
+typedef struct Fts5LookaheadReader Fts5LookaheadReader;
+struct Fts5LookaheadReader {
+  const u8 *a;                    /* Buffer containing position list */
+  int n;                          /* Size of buffer a[] in bytes */
+  int i;                          /* Current offset in position list */
+  i64 iPos;                       /* Current position */
+  i64 iLookahead;                 /* Next position */
+};
+
+#define FTS5_LOOKAHEAD_EOF (((i64)1) << 62)
+
+static int fts5LookaheadReaderNext(Fts5LookaheadReader *p){
+  p->iPos = p->iLookahead;
+  if( sqlite3Fts5PoslistNext64(p->a, p->n, &p->i, &p->iLookahead) ){
+    p->iLookahead = FTS5_LOOKAHEAD_EOF;
+  }
+  return (p->iPos==FTS5_LOOKAHEAD_EOF);
+}
+
+static int fts5LookaheadReaderInit(
+  const u8 *a, int n,             /* Buffer to read position list from */
+  Fts5LookaheadReader *p          /* Iterator object to initialize */
+){
+  memset(p, 0, sizeof(Fts5LookaheadReader));
+  p->a = a;
+  p->n = n;
+  fts5LookaheadReaderNext(p);
+  return fts5LookaheadReaderNext(p);
+}
+
+#if 0
+static int fts5LookaheadReaderEof(Fts5LookaheadReader *p){
+  return (p->iPos==FTS5_LOOKAHEAD_EOF);
+}
+#endif
+
+typedef struct Fts5NearTrimmer Fts5NearTrimmer;
+struct Fts5NearTrimmer {
+  Fts5LookaheadReader reader;     /* Input iterator */
+  Fts5PoslistWriter writer;       /* Writer context */
+  Fts5Buffer *pOut;               /* Output poslist */
+};
+
+/*
+** The near-set object passed as the first argument contains more than
+** one phrase. All phrases currently point to the same row. The
+** Fts5ExprPhrase.poslist buffers are populated accordingly. This function
+** tests if the current row contains instances of each phrase sufficiently
+** close together to meet the NEAR constraint. Non-zero is returned if it
+** does, or zero otherwise.
+**
+** If in/out parameter (*pRc) is set to other than SQLITE_OK when this
+** function is called, it is a no-op. Or, if an error (e.g. SQLITE_NOMEM)
+** occurs within this function (*pRc) is set accordingly before returning.
+** The return value is undefined in both these cases.
+** 
+** If no error occurs and non-zero (a match) is returned, the position-list
+** of each phrase object is edited to contain only those entries that
+** meet the constraint before returning.
+*/
+static int fts5ExprNearIsMatch(int *pRc, Fts5ExprNearset *pNear){
+  Fts5NearTrimmer aStatic[4];
+  Fts5NearTrimmer *a = aStatic;
+  Fts5ExprPhrase **apPhrase = pNear->apPhrase;
+
+  int i;
+  int rc = *pRc;
+  int bMatch;
+
+  assert( pNear->nPhrase>1 );
+
+  /* If the aStatic[] array is not large enough, allocate a large array
+  ** using sqlite3_malloc(). This approach could be improved upon. */
+  if( pNear->nPhrase>(sizeof(aStatic) / sizeof(aStatic[0])) ){
+    int nByte = sizeof(Fts5NearTrimmer) * pNear->nPhrase;
+    a = (Fts5NearTrimmer*)sqlite3Fts5MallocZero(&rc, nByte);
+  }else{
+    memset(aStatic, 0, sizeof(aStatic));
+  }
+  if( rc!=SQLITE_OK ){
+    *pRc = rc;
+    return 0;
+  }
+
+  /* Initialize a lookahead iterator for each phrase. After passing the
+  ** buffer and buffer size to the lookaside-reader init function, zero
+  ** the phrase poslist buffer. The new poslist for the phrase (containing
+  ** the same entries as the original with some entries removed on account 
+  ** of the NEAR constraint) is written over the original even as it is
+  ** being read. This is safe as the entries for the new poslist are a
+  ** subset of the old, so it is not possible for data yet to be read to
+  ** be overwritten.  */
+  for(i=0; i<pNear->nPhrase; i++){
+    Fts5Buffer *pPoslist = &apPhrase[i]->poslist;
+    fts5LookaheadReaderInit(pPoslist->p, pPoslist->n, &a[i].reader);
+    pPoslist->n = 0;
+    a[i].pOut = pPoslist;
+  }
+
+  while( 1 ){
+    int iAdv;
+    i64 iMin;
+    i64 iMax;
+
+    /* This block advances the phrase iterators until they point to a set of
+    ** entries that together comprise a match.  */
+    iMax = a[0].reader.iPos;
+    do {
+      bMatch = 1;
+      for(i=0; i<pNear->nPhrase; i++){
+        Fts5LookaheadReader *pPos = &a[i].reader;
+        iMin = iMax - pNear->apPhrase[i]->nTerm - pNear->nNear;
+        if( pPos->iPos<iMin || pPos->iPos>iMax ){
+          bMatch = 0;
+          while( pPos->iPos<iMin ){
+            if( fts5LookaheadReaderNext(pPos) ) goto ismatch_out;
+          }
+          if( pPos->iPos>iMax ) iMax = pPos->iPos;
+        }
+      }
+    }while( bMatch==0 );
+
+    /* Add an entry to each output position list */
+    for(i=0; i<pNear->nPhrase; i++){
+      i64 iPos = a[i].reader.iPos;
+      Fts5PoslistWriter *pWriter = &a[i].writer;
+      if( a[i].pOut->n==0 || iPos!=pWriter->iPrev ){
+        sqlite3Fts5PoslistWriterAppend(a[i].pOut, pWriter, iPos);
+      }
+    }
+
+    iAdv = 0;
+    iMin = a[0].reader.iLookahead;
+    for(i=0; i<pNear->nPhrase; i++){
+      if( a[i].reader.iLookahead < iMin ){
+        iMin = a[i].reader.iLookahead;
+        iAdv = i;
+      }
+    }
+    if( fts5LookaheadReaderNext(&a[iAdv].reader) ) goto ismatch_out;
+  }
+
+  ismatch_out: {
+    int bRet = a[0].pOut->n>0;
+    *pRc = rc;
+    if( a!=aStatic ) sqlite3_free(a);
+    return bRet;
+  }
+}
+
+/*
+** Advance the first term iterator in the first phrase of pNear. Set output
+** variable *pbEof to true if it reaches EOF or if an error occurs.
+**
+** Return SQLITE_OK if successful, or an SQLite error code if an error
+** occurs.
+*/
+static int fts5ExprNearAdvanceFirst(
+  Fts5Expr *pExpr,                /* Expression pPhrase belongs to */
+  Fts5ExprNode *pNode,            /* FTS5_STRING or FTS5_TERM node */
+  int bFromValid,
+  i64 iFrom 
+){
+  Fts5ExprTerm *pTerm = &pNode->pNear->apPhrase[0]->aTerm[0];
+  int rc = SQLITE_OK;
+
+  if( pTerm->pSynonym ){
+    int bEof = 1;
+    Fts5ExprTerm *p;
+
+    /* Find the firstest rowid any synonym points to. */
+    i64 iRowid = fts5ExprSynonymRowid(pTerm, pExpr->bDesc, 0);
+
+    /* Advance each iterator that currently points to iRowid. Or, if iFrom
+    ** is valid - each iterator that points to a rowid before iFrom.  */
+    for(p=pTerm; p; p=p->pSynonym){
+      if( sqlite3Fts5IterEof(p->pIter)==0 ){
+        i64 ii = sqlite3Fts5IterRowid(p->pIter);
+        if( ii==iRowid 
+         || (bFromValid && ii!=iFrom && (ii>iFrom)==pExpr->bDesc) 
+        ){
+          if( bFromValid ){
+            rc = sqlite3Fts5IterNextFrom(p->pIter, iFrom);
+          }else{
+            rc = sqlite3Fts5IterNext(p->pIter);
+          }
+          if( rc!=SQLITE_OK ) break;
+          if( sqlite3Fts5IterEof(p->pIter)==0 ){
+            bEof = 0;
+          }
+        }else{
+          bEof = 0;
+        }
+      }
+    }
+
+    /* Set the EOF flag if either all synonym iterators are at EOF or an
+    ** error has occurred.  */
+    pNode->bEof = (rc || bEof);
+  }else{
+    Fts5IndexIter *pIter = pTerm->pIter;
+
+    assert( Fts5NodeIsString(pNode) );
+    if( bFromValid ){
+      rc = sqlite3Fts5IterNextFrom(pIter, iFrom);
+    }else{
+      rc = sqlite3Fts5IterNext(pIter);
+    }
+
+    pNode->bEof = (rc || sqlite3Fts5IterEof(pIter));
+  }
+
+  return rc;
+}
+
+/*
+** Advance iterator pIter until it points to a value equal to or laster
+** than the initial value of *piLast. If this means the iterator points
+** to a value laster than *piLast, update *piLast to the new lastest value.
+**
+** If the iterator reaches EOF, set *pbEof to true before returning. If
+** an error occurs, set *pRc to an error code. If either *pbEof or *pRc
+** are set, return a non-zero value. Otherwise, return zero.
+*/
+static int fts5ExprAdvanceto(
+  Fts5IndexIter *pIter,           /* Iterator to advance */
+  int bDesc,                      /* True if iterator is "rowid DESC" */
+  i64 *piLast,                    /* IN/OUT: Lastest rowid seen so far */
+  int *pRc,                       /* OUT: Error code */
+  int *pbEof                      /* OUT: Set to true if EOF */
+){
+  i64 iLast = *piLast;
+  i64 iRowid;
+
+  iRowid = sqlite3Fts5IterRowid(pIter);
+  if( (bDesc==0 && iLast>iRowid) || (bDesc && iLast<iRowid) ){
+    int rc = sqlite3Fts5IterNextFrom(pIter, iLast);
+    if( rc || sqlite3Fts5IterEof(pIter) ){
+      *pRc = rc;
+      *pbEof = 1;
+      return 1;
+    }
+    iRowid = sqlite3Fts5IterRowid(pIter);
+    assert( (bDesc==0 && iRowid>=iLast) || (bDesc==1 && iRowid<=iLast) );
+  }
+  *piLast = iRowid;
+
+  return 0;
+}
+
+static int fts5ExprSynonymAdvanceto(
+  Fts5ExprTerm *pTerm,            /* Term iterator to advance */
+  int bDesc,                      /* True if iterator is "rowid DESC" */
+  i64 *piLast,                    /* IN/OUT: Lastest rowid seen so far */
+  int *pRc                        /* OUT: Error code */
+){
+  int rc = SQLITE_OK;
+  i64 iLast = *piLast;
+  Fts5ExprTerm *p;
+  int bEof = 0;
+
+  for(p=pTerm; rc==SQLITE_OK && p; p=p->pSynonym){
+    if( sqlite3Fts5IterEof(p->pIter)==0 ){
+      i64 iRowid = sqlite3Fts5IterRowid(p->pIter);
+      if( (bDesc==0 && iLast>iRowid) || (bDesc && iLast<iRowid) ){
+        rc = sqlite3Fts5IterNextFrom(p->pIter, iLast);
+      }
+    }
+  }
+
+  if( rc!=SQLITE_OK ){
+    *pRc = rc;
+    bEof = 1;
+  }else{
+    *piLast = fts5ExprSynonymRowid(pTerm, bDesc, &bEof);
+  }
+  return bEof;
+}
+
+
+static int fts5ExprNearTest(
+  int *pRc,
+  Fts5Expr *pExpr,                /* Expression that pNear is a part of */
+  Fts5ExprNode *pNode             /* The "NEAR" node (FTS5_STRING) */
+){
+  Fts5ExprNearset *pNear = pNode->pNear;
+  int rc = *pRc;
+  int i;
+
+  /* Check that each phrase in the nearset matches the current row.
+  ** Populate the pPhrase->poslist buffers at the same time. If any
+  ** phrase is not a match, break out of the loop early.  */
+  for(i=0; rc==SQLITE_OK && i<pNear->nPhrase; i++){
+    Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
+    if( pPhrase->nTerm>1 || pPhrase->aTerm[0].pSynonym || pNear->pColset ){
+      int bMatch = 0;
+      rc = fts5ExprPhraseIsMatch(pNode, pNear->pColset, pPhrase, &bMatch);
+      if( bMatch==0 ) break;
+    }else{
+      rc = sqlite3Fts5IterPoslistBuffer(
+          pPhrase->aTerm[0].pIter, &pPhrase->poslist
+      );
+    }
+  }
+
+  *pRc = rc;
+  if( i==pNear->nPhrase && (i==1 || fts5ExprNearIsMatch(pRc, pNear)) ){
+    return 1;
+  }
+
+  return 0;
+}
+
+static int fts5ExprTokenTest(
+  Fts5Expr *pExpr,                /* Expression that pNear is a part of */
+  Fts5ExprNode *pNode             /* The "NEAR" node (FTS5_TERM) */
+){
+  /* As this "NEAR" object is actually a single phrase that consists 
+  ** of a single term only, grab pointers into the poslist managed by the
+  ** fts5_index.c iterator object. This is much faster than synthesizing 
+  ** a new poslist the way we have to for more complicated phrase or NEAR
+  ** expressions.  */
+  Fts5ExprNearset *pNear = pNode->pNear;
+  Fts5ExprPhrase *pPhrase = pNear->apPhrase[0];
+  Fts5IndexIter *pIter = pPhrase->aTerm[0].pIter;
+  Fts5Colset *pColset = pNear->pColset;
+  int rc;
+
+  assert( pNode->eType==FTS5_TERM );
+  assert( pNear->nPhrase==1 && pPhrase->nTerm==1 );
+  assert( pPhrase->aTerm[0].pSynonym==0 );
+
+  rc = sqlite3Fts5IterPoslist(pIter, pColset, 
+      (const u8**)&pPhrase->poslist.p, &pPhrase->poslist.n, &pNode->iRowid
+  );
+  pNode->bNomatch = (pPhrase->poslist.n==0);
+  return rc;
+}
+
+/*
+** All individual term iterators in pNear are guaranteed to be valid when
+** this function is called. This function checks if all term iterators
+** point to the same rowid, and if not, advances them until they do.
+** If an EOF is reached before this happens, *pbEof is set to true before
+** returning.
+**
+** SQLITE_OK is returned if an error occurs, or an SQLite error code 
+** otherwise. It is not considered an error code if an iterator reaches
+** EOF.
+*/
+static int fts5ExprNearNextMatch(
+  Fts5Expr *pExpr,                /* Expression pPhrase belongs to */
+  Fts5ExprNode *pNode
+){
+  Fts5ExprNearset *pNear = pNode->pNear;
+  Fts5ExprPhrase *pLeft = pNear->apPhrase[0];
+  int rc = SQLITE_OK;
+  i64 iLast;                      /* Lastest rowid any iterator points to */
+  int i, j;                       /* Phrase and token index, respectively */
+  int bMatch;                     /* True if all terms are at the same rowid */
+  const int bDesc = pExpr->bDesc;
+
+  /* Check that this node should not be FTS5_TERM */
+  assert( pNear->nPhrase>1 
+       || pNear->apPhrase[0]->nTerm>1 
+       || pNear->apPhrase[0]->aTerm[0].pSynonym
+  );
+
+  /* Initialize iLast, the "lastest" rowid any iterator points to. If the
+  ** iterator skips through rowids in the default ascending order, this means
+  ** the maximum rowid. Or, if the iterator is "ORDER BY rowid DESC", then it
+  ** means the minimum rowid.  */
+  if( pLeft->aTerm[0].pSynonym ){
+    iLast = fts5ExprSynonymRowid(&pLeft->aTerm[0], bDesc, 0);
+  }else{
+    iLast = sqlite3Fts5IterRowid(pLeft->aTerm[0].pIter);
+  }
+
+  do {
+    bMatch = 1;
+    for(i=0; i<pNear->nPhrase; i++){
+      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
+      for(j=0; j<pPhrase->nTerm; j++){
+        Fts5ExprTerm *pTerm = &pPhrase->aTerm[j];
+        if( pTerm->pSynonym ){
+          i64 iRowid = fts5ExprSynonymRowid(pTerm, bDesc, 0);
+          if( iRowid==iLast ) continue;
+          bMatch = 0;
+          if( fts5ExprSynonymAdvanceto(pTerm, bDesc, &iLast, &rc) ){
+            pNode->bEof = 1;
+            return rc;
+          }
+        }else{
+          Fts5IndexIter *pIter = pPhrase->aTerm[j].pIter;
+          i64 iRowid = sqlite3Fts5IterRowid(pIter);
+          if( iRowid==iLast ) continue;
+          bMatch = 0;
+          if( fts5ExprAdvanceto(pIter, bDesc, &iLast, &rc, &pNode->bEof) ){
+            return rc;
+          }
+        }
+      }
+    }
+  }while( bMatch==0 );
+
+  pNode->iRowid = iLast;
+  pNode->bNomatch = (0==fts5ExprNearTest(&rc, pExpr, pNode));
+
+  return rc;
+}
+
+/*
+** Initialize all term iterators in the pNear object. If any term is found
+** to match no documents at all, return immediately without initializing any
+** further iterators.
+*/
+static int fts5ExprNearInitAll(
+  Fts5Expr *pExpr,
+  Fts5ExprNode *pNode
+){
+  Fts5ExprNearset *pNear = pNode->pNear;
+  int i, j;
+  int rc = SQLITE_OK;
+
+  for(i=0; rc==SQLITE_OK && i<pNear->nPhrase; i++){
+    Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
+    for(j=0; j<pPhrase->nTerm; j++){
+      Fts5ExprTerm *pTerm = &pPhrase->aTerm[j];
+      Fts5ExprTerm *p;
+      int bEof = 1;
+
+      for(p=pTerm; p && rc==SQLITE_OK; p=p->pSynonym){
+        if( p->pIter ){
+          sqlite3Fts5IterClose(p->pIter);
+          p->pIter = 0;
+        }
+        rc = sqlite3Fts5IndexQuery(
+            pExpr->pIndex, p->zTerm, strlen(p->zTerm),
+            (pTerm->bPrefix ? FTS5INDEX_QUERY_PREFIX : 0) |
+            (pExpr->bDesc ? FTS5INDEX_QUERY_DESC : 0),
+            pNear->pColset,
+            &p->pIter
+        );
+        assert( rc==SQLITE_OK || p->pIter==0 );
+        if( p->pIter && 0==sqlite3Fts5IterEof(p->pIter) ){
+          bEof = 0;
+        }
+      }
+
+      if( bEof ){
+        pNode->bEof = 1;
+        return rc;
+      }
+    }
+  }
+
+  return rc;
+}
+
+/* fts5ExprNodeNext() calls fts5ExprNodeNextMatch(). And vice-versa. */
+static int fts5ExprNodeNextMatch(Fts5Expr*, Fts5ExprNode*);
+
+
+/*
+** If pExpr is an ASC iterator, this function returns a value with the
+** same sign as:
+**
+**   (iLhs - iRhs)
+**
+** Otherwise, if this is a DESC iterator, the opposite is returned:
+**
+**   (iRhs - iLhs)
+*/
+static int fts5RowidCmp(
+  Fts5Expr *pExpr,
+  i64 iLhs,
+  i64 iRhs
+){
+  assert( pExpr->bDesc==0 || pExpr->bDesc==1 );
+  if( pExpr->bDesc==0 ){
+    if( iLhs<iRhs ) return -1;
+    return (iLhs > iRhs);
+  }else{
+    if( iLhs>iRhs ) return -1;
+    return (iLhs < iRhs);
+  }
+}
+
+static void fts5ExprSetEof(Fts5ExprNode *pNode){
+  int i;
+  pNode->bEof = 1;
+  for(i=0; i<pNode->nChild; i++){
+    fts5ExprSetEof(pNode->apChild[i]);
+  }
+}
+
+static void fts5ExprNodeZeroPoslist(Fts5ExprNode *pNode){
+  if( pNode->eType==FTS5_STRING || pNode->eType==FTS5_TERM ){
+    Fts5ExprNearset *pNear = pNode->pNear;
+    int i;
+    for(i=0; i<pNear->nPhrase; i++){
+      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
+      pPhrase->poslist.n = 0;
+    }
+  }else{
+    int i;
+    for(i=0; i<pNode->nChild; i++){
+      fts5ExprNodeZeroPoslist(pNode->apChild[i]);
+    }
+  }
+}
+
+
+static int fts5ExprNodeNext(Fts5Expr*, Fts5ExprNode*, int, i64);
+
+/*
+** Argument pNode is an FTS5_AND node.
+*/
+static int fts5ExprAndNextRowid(
+  Fts5Expr *pExpr,                /* Expression pPhrase belongs to */
+  Fts5ExprNode *pAnd              /* FTS5_AND node to advance */
+){
+  int iChild;
+  i64 iLast = pAnd->iRowid;
+  int rc = SQLITE_OK;
+  int bMatch;
+
+  assert( pAnd->bEof==0 );
+  do {
+    pAnd->bNomatch = 0;
+    bMatch = 1;
+    for(iChild=0; iChild<pAnd->nChild; iChild++){
+      Fts5ExprNode *pChild = pAnd->apChild[iChild];
+      if( 0 && pChild->eType==FTS5_STRING ){
+        /* TODO */
+      }else{
+        int cmp = fts5RowidCmp(pExpr, iLast, pChild->iRowid);
+        if( cmp>0 ){
+          /* Advance pChild until it points to iLast or laster */
+          rc = fts5ExprNodeNext(pExpr, pChild, 1, iLast);
+          if( rc!=SQLITE_OK ) return rc;
+        }
+      }
+
+      /* If the child node is now at EOF, so is the parent AND node. Otherwise,
+      ** the child node is guaranteed to have advanced at least as far as
+      ** rowid iLast. So if it is not at exactly iLast, pChild->iRowid is the
+      ** new lastest rowid seen so far.  */
+      assert( pChild->bEof || fts5RowidCmp(pExpr, iLast, pChild->iRowid)<=0 );
+      if( pChild->bEof ){
+        fts5ExprSetEof(pAnd);
+        bMatch = 1;
+        break;
+      }else if( iLast!=pChild->iRowid ){
+        bMatch = 0;
+        iLast = pChild->iRowid;
+      }
+
+      if( pChild->bNomatch ){
+        pAnd->bNomatch = 1;
+      }
+    }
+  }while( bMatch==0 );
+
+  if( pAnd->bNomatch && pAnd!=pExpr->pRoot ){
+    fts5ExprNodeZeroPoslist(pAnd);
+  }
+  pAnd->iRowid = iLast;
+  return SQLITE_OK;
+}
+
+
+/*
+** Compare the values currently indicated by the two nodes as follows:
+**
+**    res = (*p1) - (*p2)
+**
+** Nodes that point to values that come later in the iteration order are
+** considered to be larger. Nodes at EOF are the largest of all.
+**
+** This means that if the iteration order is ASC, then numerically larger
+** rowids are considered larger. Or if it is the default DESC, numerically
+** smaller rowids are larger.
+*/
+static int fts5NodeCompare(
+  Fts5Expr *pExpr,
+  Fts5ExprNode *p1, 
+  Fts5ExprNode *p2
+){
+  if( p2->bEof ) return -1;
+  if( p1->bEof ) return +1;
+  return fts5RowidCmp(pExpr, p1->iRowid, p2->iRowid);
+}
+
+/*
+** Advance node iterator pNode, part of expression pExpr. If argument
+** bFromValid is zero, then pNode is advanced exactly once. Or, if argument
+** bFromValid is non-zero, then pNode is advanced until it is at or past
+** rowid value iFrom. Whether "past" means "less than" or "greater than"
+** depends on whether this is an ASC or DESC iterator.
+*/
+static int fts5ExprNodeNext(
+  Fts5Expr *pExpr, 
+  Fts5ExprNode *pNode,
+  int bFromValid,
+  i64 iFrom
+){
+  int rc = SQLITE_OK;
+
+  if( pNode->bEof==0 ){
+    switch( pNode->eType ){
+      case FTS5_STRING: {
+        rc = fts5ExprNearAdvanceFirst(pExpr, pNode, bFromValid, iFrom);
+        break;
+      };
+
+      case FTS5_TERM: {
+        Fts5IndexIter *pIter = pNode->pNear->apPhrase[0]->aTerm[0].pIter;
+        if( bFromValid ){
+          rc = sqlite3Fts5IterNextFrom(pIter, iFrom);
+        }else{
+          rc = sqlite3Fts5IterNext(pIter);
+        }
+        if( rc==SQLITE_OK && sqlite3Fts5IterEof(pIter)==0 ){
+          assert( rc==SQLITE_OK );
+          rc = fts5ExprTokenTest(pExpr, pNode);
+        }else{
+          pNode->bEof = 1;
+        }
+        return rc;
+      };
+
+      case FTS5_AND: {
+        Fts5ExprNode *pLeft = pNode->apChild[0];
+        rc = fts5ExprNodeNext(pExpr, pLeft, bFromValid, iFrom);
+        break;
+      }
+
+      case FTS5_OR: {
+        int i;
+        i64 iLast = pNode->iRowid;
+
+        for(i=0; rc==SQLITE_OK && i<pNode->nChild; i++){
+          Fts5ExprNode *p1 = pNode->apChild[i];
+          assert( p1->bEof || fts5RowidCmp(pExpr, p1->iRowid, iLast)>=0 );
+          if( p1->bEof==0 ){
+            if( (p1->iRowid==iLast) 
+             || (bFromValid && fts5RowidCmp(pExpr, p1->iRowid, iFrom)<0)
+            ){
+              rc = fts5ExprNodeNext(pExpr, p1, bFromValid, iFrom);
+            }
+          }
+        }
+
+        break;
+      }
+
+      default: assert( pNode->eType==FTS5_NOT ); {
+        assert( pNode->nChild==2 );
+        rc = fts5ExprNodeNext(pExpr, pNode->apChild[0], bFromValid, iFrom);
+        break;
+      }
+    }
+
+    if( rc==SQLITE_OK ){
+      rc = fts5ExprNodeNextMatch(pExpr, pNode);
+    }
+  }
+
+  /* Assert that if bFromValid was true, either:
+  **
+  **   a) an error occurred, or
+  **   b) the node is now at EOF, or
+  **   c) the node is now at or past rowid iFrom.
+  */
+  assert( bFromValid==0 
+      || rc!=SQLITE_OK                                                  /* a */
+      || pNode->bEof                                                    /* b */
+      || pNode->iRowid==iFrom || pExpr->bDesc==(pNode->iRowid<iFrom)    /* c */
+  );
+
+  return rc;
+}
+
+
+/*
+** If pNode currently points to a match, this function returns SQLITE_OK
+** without modifying it. Otherwise, pNode is advanced until it does point
+** to a match or EOF is reached.
+*/
+static int fts5ExprNodeNextMatch(
+  Fts5Expr *pExpr,                /* Expression of which pNode is a part */
+  Fts5ExprNode *pNode             /* Expression node to test */
+){
+  int rc = SQLITE_OK;
+  if( pNode->bEof==0 ){
+    switch( pNode->eType ){
+
+      case FTS5_STRING: {
+        /* Advance the iterators until they all point to the same rowid */
+        rc = fts5ExprNearNextMatch(pExpr, pNode);
+        break;
+      }
+
+      case FTS5_TERM: {
+        rc = fts5ExprTokenTest(pExpr, pNode);
+        break;
+      }
+
+      case FTS5_AND: {
+        rc = fts5ExprAndNextRowid(pExpr, pNode);
+        break;
+      }
+
+      case FTS5_OR: {
+        Fts5ExprNode *pNext = pNode->apChild[0];
+        int i;
+
+        for(i=1; i<pNode->nChild; i++){
+          Fts5ExprNode *pChild = pNode->apChild[i];
+          int cmp = fts5NodeCompare(pExpr, pNext, pChild);
+          if( cmp>0 || (cmp==0 && pChild->bNomatch==0) ){
+            pNext = pChild;
+          }
+        }
+        pNode->iRowid = pNext->iRowid;
+        pNode->bEof = pNext->bEof;
+        pNode->bNomatch = pNext->bNomatch;
+        break;
+      }
+
+      default: assert( pNode->eType==FTS5_NOT ); {
+        Fts5ExprNode *p1 = pNode->apChild[0];
+        Fts5ExprNode *p2 = pNode->apChild[1];
+        assert( pNode->nChild==2 );
+
+        while( rc==SQLITE_OK && p1->bEof==0 ){
+          int cmp = fts5NodeCompare(pExpr, p1, p2);
+          if( cmp>0 ){
+            rc = fts5ExprNodeNext(pExpr, p2, 1, p1->iRowid);
+            cmp = fts5NodeCompare(pExpr, p1, p2);
+          }
+          assert( rc!=SQLITE_OK || cmp<=0 );
+          if( cmp || p2->bNomatch ) break;
+          rc = fts5ExprNodeNext(pExpr, p1, 0, 0);
+        }
+        pNode->bEof = p1->bEof;
+        pNode->iRowid = p1->iRowid;
+        break;
+      }
+    }
+  }
+  return rc;
+}
+
+ 
+/*
+** Set node pNode, which is part of expression pExpr, to point to the first
+** match. If there are no matches, set the Node.bEof flag to indicate EOF.
+**
+** Return an SQLite error code if an error occurs, or SQLITE_OK otherwise.
+** It is not an error if there are no matches.
+*/
+static int fts5ExprNodeFirst(Fts5Expr *pExpr, Fts5ExprNode *pNode){
+  int rc = SQLITE_OK;
+  pNode->bEof = 0;
+
+  if( Fts5NodeIsString(pNode) ){
+    /* Initialize all term iterators in the NEAR object. */
+    rc = fts5ExprNearInitAll(pExpr, pNode);
+  }else{
+    int i;
+    for(i=0; i<pNode->nChild && rc==SQLITE_OK; i++){
+      rc = fts5ExprNodeFirst(pExpr, pNode->apChild[i]);
+    }
+    pNode->iRowid = pNode->apChild[0]->iRowid;
+  }
+
+  if( rc==SQLITE_OK ){
+    rc = fts5ExprNodeNextMatch(pExpr, pNode);
+  }
+  return rc;
+}
+
+
+/*
+** Begin iterating through the set of documents in index pIdx matched by
+** the MATCH expression passed as the first argument. If the "bDesc" 
+** parameter is passed a non-zero value, iteration is in descending rowid 
+** order. Or, if it is zero, in ascending order.
+**
+** If iterating in ascending rowid order (bDesc==0), the first document
+** visited is that with the smallest rowid that is larger than or equal
+** to parameter iFirst. Or, if iterating in ascending order (bDesc==1),
+** then the first document visited must have a rowid smaller than or
+** equal to iFirst.
+**
+** Return SQLITE_OK if successful, or an SQLite error code otherwise. It
+** is not considered an error if the query does not match any documents.
+*/
+static int sqlite3Fts5ExprFirst(Fts5Expr *p, Fts5Index *pIdx, i64 iFirst, int bDesc){
+  Fts5ExprNode *pRoot = p->pRoot;
+  int rc = SQLITE_OK;
+  if( pRoot ){
+    p->pIndex = pIdx;
+    p->bDesc = bDesc;
+    rc = fts5ExprNodeFirst(p, pRoot);
+
+    /* If not at EOF but the current rowid occurs earlier than iFirst in
+    ** the iteration order, move to document iFirst or later. */
+    if( pRoot->bEof==0 && fts5RowidCmp(p, pRoot->iRowid, iFirst)<0 ){
+      rc = fts5ExprNodeNext(p, pRoot, 1, iFirst);
+    }
+
+    /* If the iterator is not at a real match, skip forward until it is. */
+    while( pRoot->bNomatch && rc==SQLITE_OK && pRoot->bEof==0 ){
+      rc = fts5ExprNodeNext(p, pRoot, 0, 0);
+    }
+  }
+  return rc;
+}
+
+/*
+** Move to the next document 
+**
+** Return SQLITE_OK if successful, or an SQLite error code otherwise. It
+** is not considered an error if the query does not match any documents.
+*/
+static int sqlite3Fts5ExprNext(Fts5Expr *p, i64 iLast){
+  int rc;
+  Fts5ExprNode *pRoot = p->pRoot;
+  do {
+    rc = fts5ExprNodeNext(p, pRoot, 0, 0);
+  }while( pRoot->bNomatch && pRoot->bEof==0 && rc==SQLITE_OK );
+  if( fts5RowidCmp(p, pRoot->iRowid, iLast)>0 ){
+    pRoot->bEof = 1;
+  }
+  return rc;
+}
+
+static int sqlite3Fts5ExprEof(Fts5Expr *p){
+  return (p->pRoot==0 || p->pRoot->bEof);
+}
+
+static i64 sqlite3Fts5ExprRowid(Fts5Expr *p){
+  return p->pRoot->iRowid;
+}
+
+static int fts5ParseStringFromToken(Fts5Token *pToken, char **pz){
+  int rc = SQLITE_OK;
+  *pz = sqlite3Fts5Strndup(&rc, pToken->p, pToken->n);
+  return rc;
+}
+
+/*
+** Free the phrase object passed as the only argument.
+*/
+static void fts5ExprPhraseFree(Fts5ExprPhrase *pPhrase){
+  if( pPhrase ){
+    int i;
+    for(i=0; i<pPhrase->nTerm; i++){
+      Fts5ExprTerm *pSyn;
+      Fts5ExprTerm *pNext;
+      Fts5ExprTerm *pTerm = &pPhrase->aTerm[i];
+      sqlite3_free(pTerm->zTerm);
+      sqlite3Fts5IterClose(pTerm->pIter);
+
+      for(pSyn=pTerm->pSynonym; pSyn; pSyn=pNext){
+        pNext = pSyn->pSynonym;
+        sqlite3Fts5IterClose(pSyn->pIter);
+        sqlite3_free(pSyn);
+      }
+    }
+    if( pPhrase->poslist.nSpace>0 ) fts5BufferFree(&pPhrase->poslist);
+    sqlite3_free(pPhrase);
+  }
+}
+
+/*
+** If argument pNear is NULL, then a new Fts5ExprNearset object is allocated
+** and populated with pPhrase. Or, if pNear is not NULL, phrase pPhrase is
+** appended to it and the results returned.
+**
+** If an OOM error occurs, both the pNear and pPhrase objects are freed and
+** NULL returned.
+*/
+static Fts5ExprNearset *sqlite3Fts5ParseNearset(
+  Fts5Parse *pParse,              /* Parse context */
+  Fts5ExprNearset *pNear,         /* Existing nearset, or NULL */
+  Fts5ExprPhrase *pPhrase         /* Recently parsed phrase */
+){
+  const int SZALLOC = 8;
+  Fts5ExprNearset *pRet = 0;
+
+  if( pParse->rc==SQLITE_OK ){
+    if( pPhrase==0 ){
+      return pNear;
+    }
+    if( pNear==0 ){
+      int nByte = sizeof(Fts5ExprNearset) + SZALLOC * sizeof(Fts5ExprPhrase*);
+      pRet = sqlite3_malloc(nByte);
+      if( pRet==0 ){
+        pParse->rc = SQLITE_NOMEM;
+      }else{
+        memset(pRet, 0, nByte);
+      }
+    }else if( (pNear->nPhrase % SZALLOC)==0 ){
+      int nNew = pNear->nPhrase + SZALLOC;
+      int nByte = sizeof(Fts5ExprNearset) + nNew * sizeof(Fts5ExprPhrase*);
+
+      pRet = (Fts5ExprNearset*)sqlite3_realloc(pNear, nByte);
+      if( pRet==0 ){
+        pParse->rc = SQLITE_NOMEM;
+      }
+    }else{
+      pRet = pNear;
+    }
+  }
+
+  if( pRet==0 ){
+    assert( pParse->rc!=SQLITE_OK );
+    sqlite3Fts5ParseNearsetFree(pNear);
+    sqlite3Fts5ParsePhraseFree(pPhrase);
+  }else{
+    pRet->apPhrase[pRet->nPhrase++] = pPhrase;
+  }
+  return pRet;
+}
+
+typedef struct TokenCtx TokenCtx;
+struct TokenCtx {
+  Fts5ExprPhrase *pPhrase;
+  int rc;
+};
+
+/*
+** Callback for tokenizing terms used by ParseTerm().
+*/
+static int fts5ParseTokenize(
+  void *pContext,                 /* Pointer to Fts5InsertCtx object */
+  int tflags,                     /* Mask of FTS5_TOKEN_* flags */
+  const char *pToken,             /* Buffer containing token */
+  int nToken,                     /* Size of token in bytes */
+  int iUnused1,                   /* Start offset of token */
+  int iUnused2                    /* End offset of token */
+){
+  int rc = SQLITE_OK;
+  const int SZALLOC = 8;
+  TokenCtx *pCtx = (TokenCtx*)pContext;
+  Fts5ExprPhrase *pPhrase = pCtx->pPhrase;
+
+  /* If an error has already occurred, this is a no-op */
+  if( pCtx->rc!=SQLITE_OK ) return pCtx->rc;
+
+  assert( pPhrase==0 || pPhrase->nTerm>0 );
+  if( pPhrase && (tflags & FTS5_TOKEN_COLOCATED) ){
+    Fts5ExprTerm *pSyn;
+    int nByte = sizeof(Fts5ExprTerm) + nToken+1;
+    pSyn = (Fts5ExprTerm*)sqlite3_malloc(nByte);
+    if( pSyn==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      memset(pSyn, 0, nByte);
+      pSyn->zTerm = (char*)&pSyn[1];
+      memcpy(pSyn->zTerm, pToken, nToken);
+      pSyn->pSynonym = pPhrase->aTerm[pPhrase->nTerm-1].pSynonym;
+      pPhrase->aTerm[pPhrase->nTerm-1].pSynonym = pSyn;
+    }
+  }else{
+    Fts5ExprTerm *pTerm;
+    if( pPhrase==0 || (pPhrase->nTerm % SZALLOC)==0 ){
+      Fts5ExprPhrase *pNew;
+      int nNew = SZALLOC + (pPhrase ? pPhrase->nTerm : 0);
+
+      pNew = (Fts5ExprPhrase*)sqlite3_realloc(pPhrase, 
+          sizeof(Fts5ExprPhrase) + sizeof(Fts5ExprTerm) * nNew
+      );
+      if( pNew==0 ){
+        rc = SQLITE_NOMEM;
+      }else{
+        if( pPhrase==0 ) memset(pNew, 0, sizeof(Fts5ExprPhrase));
+        pCtx->pPhrase = pPhrase = pNew;
+        pNew->nTerm = nNew - SZALLOC;
+      }
+    }
+
+    if( rc==SQLITE_OK ){
+      pTerm = &pPhrase->aTerm[pPhrase->nTerm++];
+      memset(pTerm, 0, sizeof(Fts5ExprTerm));
+      pTerm->zTerm = sqlite3Fts5Strndup(&rc, pToken, nToken);
+    }
+  }
+
+  pCtx->rc = rc;
+  return rc;
+}
+
+
+/*
+** Free the phrase object passed as the only argument.
+*/
+static void sqlite3Fts5ParsePhraseFree(Fts5ExprPhrase *pPhrase){
+  fts5ExprPhraseFree(pPhrase);
+}
+
+/*
+** Free the phrase object passed as the second argument.
+*/
+static void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset *pNear){
+  if( pNear ){
+    int i;
+    for(i=0; i<pNear->nPhrase; i++){
+      fts5ExprPhraseFree(pNear->apPhrase[i]);
+    }
+    sqlite3_free(pNear->pColset);
+    sqlite3_free(pNear);
+  }
+}
+
+static void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p){
+  assert( pParse->pExpr==0 );
+  pParse->pExpr = p;
+}
+
+/*
+** This function is called by the parser to process a string token. The
+** string may or may not be quoted. In any case it is tokenized and a
+** phrase object consisting of all tokens returned.
+*/
+static Fts5ExprPhrase *sqlite3Fts5ParseTerm(
+  Fts5Parse *pParse,              /* Parse context */
+  Fts5ExprPhrase *pAppend,        /* Phrase to append to */
+  Fts5Token *pToken,              /* String to tokenize */
+  int bPrefix                     /* True if there is a trailing "*" */
+){
+  Fts5Config *pConfig = pParse->pConfig;
+  TokenCtx sCtx;                  /* Context object passed to callback */
+  int rc;                         /* Tokenize return code */
+  char *z = 0;
+
+  memset(&sCtx, 0, sizeof(TokenCtx));
+  sCtx.pPhrase = pAppend;
+
+  rc = fts5ParseStringFromToken(pToken, &z);
+  if( rc==SQLITE_OK ){
+    int flags = FTS5_TOKENIZE_QUERY | (bPrefix ? FTS5_TOKENIZE_QUERY : 0);
+    int n;
+    sqlite3Fts5Dequote(z);
+    n = strlen(z);
+    rc = sqlite3Fts5Tokenize(pConfig, flags, z, n, &sCtx, fts5ParseTokenize);
+  }
+  sqlite3_free(z);
+  if( rc || (rc = sCtx.rc) ){
+    pParse->rc = rc;
+    fts5ExprPhraseFree(sCtx.pPhrase);
+    sCtx.pPhrase = 0;
+  }else if( sCtx.pPhrase ){
+
+    if( pAppend==0 ){
+      if( (pParse->nPhrase % 8)==0 ){
+        int nByte = sizeof(Fts5ExprPhrase*) * (pParse->nPhrase + 8);
+        Fts5ExprPhrase **apNew;
+        apNew = (Fts5ExprPhrase**)sqlite3_realloc(pParse->apPhrase, nByte);
+        if( apNew==0 ){
+          pParse->rc = SQLITE_NOMEM;
+          fts5ExprPhraseFree(sCtx.pPhrase);
+          return 0;
+        }
+        pParse->apPhrase = apNew;
+      }
+      pParse->nPhrase++;
+    }
+
+    pParse->apPhrase[pParse->nPhrase-1] = sCtx.pPhrase;
+    assert( sCtx.pPhrase->nTerm>0 );
+    sCtx.pPhrase->aTerm[sCtx.pPhrase->nTerm-1].bPrefix = bPrefix;
+  }
+
+  return sCtx.pPhrase;
+}
+
+/*
+** Create a new FTS5 expression by cloning phrase iPhrase of the
+** expression passed as the second argument.
+*/
+static int sqlite3Fts5ExprClonePhrase(
+  Fts5Config *pConfig,
+  Fts5Expr *pExpr, 
+  int iPhrase, 
+  Fts5Expr **ppNew
+){
+  int rc = SQLITE_OK;             /* Return code */
+  Fts5ExprPhrase *pOrig;          /* The phrase extracted from pExpr */
+  int i;                          /* Used to iterate through phrase terms */
+
+  Fts5Expr *pNew = 0;             /* Expression to return via *ppNew */
+
+  TokenCtx sCtx = {0,0};          /* Context object for fts5ParseTokenize */
+
+
+  pOrig = pExpr->apExprPhrase[iPhrase];
+
+  pNew = (Fts5Expr*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Expr));
+  if( rc==SQLITE_OK ){
+    pNew->apExprPhrase = (Fts5ExprPhrase**)sqlite3Fts5MallocZero(&rc, 
+        sizeof(Fts5ExprPhrase*));
+  }
+  if( rc==SQLITE_OK ){
+    pNew->pRoot = (Fts5ExprNode*)sqlite3Fts5MallocZero(&rc, 
+        sizeof(Fts5ExprNode));
+  }
+  if( rc==SQLITE_OK ){
+    pNew->pRoot->pNear = (Fts5ExprNearset*)sqlite3Fts5MallocZero(&rc, 
+        sizeof(Fts5ExprNearset) + sizeof(Fts5ExprPhrase*));
+  }
+
+  for(i=0; rc==SQLITE_OK && i<pOrig->nTerm; i++){
+    int tflags = 0;
+    Fts5ExprTerm *p;
+    for(p=&pOrig->aTerm[i]; p && rc==SQLITE_OK; p=p->pSynonym){
+      const char *zTerm = p->zTerm;
+      rc = fts5ParseTokenize((void*)&sCtx, tflags, zTerm, strlen(zTerm), 0, 0);
+      tflags = FTS5_TOKEN_COLOCATED;
+    }
+    if( rc==SQLITE_OK ){
+      sCtx.pPhrase->aTerm[i].bPrefix = pOrig->aTerm[i].bPrefix;
+    }
+  }
+
+  if( rc==SQLITE_OK ){
+    /* All the allocations succeeded. Put the expression object together. */
+    pNew->pIndex = pExpr->pIndex;
+    pNew->nPhrase = 1;
+    pNew->apExprPhrase[0] = sCtx.pPhrase;
+    pNew->pRoot->pNear->apPhrase[0] = sCtx.pPhrase;
+    pNew->pRoot->pNear->nPhrase = 1;
+    sCtx.pPhrase->pNode = pNew->pRoot;
+
+    if( pOrig->nTerm==1 && pOrig->aTerm[0].pSynonym==0 ){
+      pNew->pRoot->eType = FTS5_TERM;
+    }else{
+      pNew->pRoot->eType = FTS5_STRING;
+    }
+  }else{
+    sqlite3Fts5ExprFree(pNew);
+    fts5ExprPhraseFree(sCtx.pPhrase);
+    pNew = 0;
+  }
+
+  *ppNew = pNew;
+  return rc;
+}
+
+
+/*
+** Token pTok has appeared in a MATCH expression where the NEAR operator
+** is expected. If token pTok does not contain "NEAR", store an error
+** in the pParse object.
+*/
+static void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token *pTok){
+  if( pTok->n!=4 || memcmp("NEAR", pTok->p, 4) ){
+    sqlite3Fts5ParseError(
+        pParse, "fts5: syntax error near \"%.*s\"", pTok->n, pTok->p
+    );
+  }
+}
+
+static void sqlite3Fts5ParseSetDistance(
+  Fts5Parse *pParse, 
+  Fts5ExprNearset *pNear,
+  Fts5Token *p
+){
+  int nNear = 0;
+  int i;
+  if( p->n ){
+    for(i=0; i<p->n; i++){
+      char c = (char)p->p[i];
+      if( c<'0' || c>'9' ){
+        sqlite3Fts5ParseError(
+            pParse, "expected integer, got \"%.*s\"", p->n, p->p
+        );
+        return;
+      }
+      nNear = nNear * 10 + (p->p[i] - '0');
+    }
+  }else{
+    nNear = FTS5_DEFAULT_NEARDIST;
+  }
+  pNear->nNear = nNear;
+}
+
+/*
+** The second argument passed to this function may be NULL, or it may be
+** an existing Fts5Colset object. This function returns a pointer to
+** a new colset object containing the contents of (p) with new value column
+** number iCol appended. 
+**
+** If an OOM error occurs, store an error code in pParse and return NULL.
+** The old colset object (if any) is not freed in this case.
+*/
+static Fts5Colset *fts5ParseColset(
+  Fts5Parse *pParse,              /* Store SQLITE_NOMEM here if required */
+  Fts5Colset *p,                  /* Existing colset object */
+  int iCol                        /* New column to add to colset object */
+){
+  int nCol = p ? p->nCol : 0;     /* Num. columns already in colset object */
+  Fts5Colset *pNew;               /* New colset object to return */
+
+  assert( pParse->rc==SQLITE_OK );
+  assert( iCol>=0 && iCol<pParse->pConfig->nCol );
+
+  pNew = sqlite3_realloc(p, sizeof(Fts5Colset) + sizeof(int)*nCol);
+  if( pNew==0 ){
+    pParse->rc = SQLITE_NOMEM;
+  }else{
+    int *aiCol = pNew->aiCol;
+    int i, j;
+    for(i=0; i<nCol; i++){
+      if( aiCol[i]==iCol ) return pNew;
+      if( aiCol[i]>iCol ) break;
+    }
+    for(j=nCol; j>i; j--){
+      aiCol[j] = aiCol[j-1];
+    }
+    aiCol[i] = iCol;
+    pNew->nCol = nCol+1;
+
+#ifndef NDEBUG
+    /* Check that the array is in order and contains no duplicate entries. */
+    for(i=1; i<pNew->nCol; i++) assert( pNew->aiCol[i]>pNew->aiCol[i-1] );
+#endif
+  }
+
+  return pNew;
+}
+
+static Fts5Colset *sqlite3Fts5ParseColset(
+  Fts5Parse *pParse,              /* Store SQLITE_NOMEM here if required */
+  Fts5Colset *pColset,            /* Existing colset object */
+  Fts5Token *p
+){
+  Fts5Colset *pRet = 0;
+  int iCol;
+  char *z;                        /* Dequoted copy of token p */
+
+  z = sqlite3Fts5Strndup(&pParse->rc, p->p, p->n);
+  if( pParse->rc==SQLITE_OK ){
+    Fts5Config *pConfig = pParse->pConfig;
+    sqlite3Fts5Dequote(z);
+    for(iCol=0; iCol<pConfig->nCol; iCol++){
+      if( 0==sqlite3_stricmp(pConfig->azCol[iCol], z) ) break;
+    }
+    if( iCol==pConfig->nCol ){
+      sqlite3Fts5ParseError(pParse, "no such column: %s", z);
+    }else{
+      pRet = fts5ParseColset(pParse, pColset, iCol);
+    }
+    sqlite3_free(z);
+  }
+
+  if( pRet==0 ){
+    assert( pParse->rc!=SQLITE_OK );
+    sqlite3_free(pColset);
+  }
+
+  return pRet;
+}
+
+static void sqlite3Fts5ParseSetColset(
+  Fts5Parse *pParse, 
+  Fts5ExprNearset *pNear, 
+  Fts5Colset *pColset 
+){
+  if( pNear ){
+    pNear->pColset = pColset;
+  }else{
+    sqlite3_free(pColset);
+  }
+}
+
+static void fts5ExprAddChildren(Fts5ExprNode *p, Fts5ExprNode *pSub){
+  if( p->eType!=FTS5_NOT && pSub->eType==p->eType ){
+    int nByte = sizeof(Fts5ExprNode*) * pSub->nChild;
+    memcpy(&p->apChild[p->nChild], pSub->apChild, nByte);
+    p->nChild += pSub->nChild;
+    sqlite3_free(pSub);
+  }else{
+    p->apChild[p->nChild++] = pSub;
+  }
+}
+
+/*
+** Allocate and return a new expression object. If anything goes wrong (i.e.
+** OOM error), leave an error code in pParse and return NULL.
+*/
+static Fts5ExprNode *sqlite3Fts5ParseNode(
+  Fts5Parse *pParse,              /* Parse context */
+  int eType,                      /* FTS5_STRING, AND, OR or NOT */
+  Fts5ExprNode *pLeft,            /* Left hand child expression */
+  Fts5ExprNode *pRight,           /* Right hand child expression */
+  Fts5ExprNearset *pNear          /* For STRING expressions, the near cluster */
+){
+  Fts5ExprNode *pRet = 0;
+
+  if( pParse->rc==SQLITE_OK ){
+    int nChild = 0;               /* Number of children of returned node */
+    int nByte;                    /* Bytes of space to allocate for this node */
+ 
+    assert( (eType!=FTS5_STRING && !pNear)
+         || (eType==FTS5_STRING && !pLeft && !pRight)
+    );
+    if( eType==FTS5_STRING && pNear==0 ) return 0;
+    if( eType!=FTS5_STRING && pLeft==0 ) return pRight;
+    if( eType!=FTS5_STRING && pRight==0 ) return pLeft;
+
+    if( eType==FTS5_NOT ){
+      nChild = 2;
+    }else if( eType==FTS5_AND || eType==FTS5_OR ){
+      nChild = 2;
+      if( pLeft->eType==eType ) nChild += pLeft->nChild-1;
+      if( pRight->eType==eType ) nChild += pRight->nChild-1;
+    }
+
+    nByte = sizeof(Fts5ExprNode) + sizeof(Fts5ExprNode*)*(nChild-1);
+    pRet = (Fts5ExprNode*)sqlite3Fts5MallocZero(&pParse->rc, nByte);
+
+    if( pRet ){
+      pRet->eType = eType;
+      pRet->pNear = pNear;
+      if( eType==FTS5_STRING ){
+        int iPhrase;
+        for(iPhrase=0; iPhrase<pNear->nPhrase; iPhrase++){
+          pNear->apPhrase[iPhrase]->pNode = pRet;
+        }
+        if( pNear->nPhrase==1 
+         && pNear->apPhrase[0]->nTerm==1 
+         && pNear->apPhrase[0]->aTerm[0].pSynonym==0
+        ){
+          pRet->eType = FTS5_TERM;
+        }
+      }else{
+        fts5ExprAddChildren(pRet, pLeft);
+        fts5ExprAddChildren(pRet, pRight);
+      }
+    }
+  }
+
+  if( pRet==0 ){
+    assert( pParse->rc!=SQLITE_OK );
+    sqlite3Fts5ParseNodeFree(pLeft);
+    sqlite3Fts5ParseNodeFree(pRight);
+    sqlite3Fts5ParseNearsetFree(pNear);
+  }
+  return pRet;
+}
+
+static char *fts5ExprTermPrint(Fts5ExprTerm *pTerm){
+  int nByte = 0;
+  Fts5ExprTerm *p;
+  char *zQuoted;
+
+  /* Determine the maximum amount of space required. */
+  for(p=pTerm; p; p=p->pSynonym){
+    nByte += strlen(pTerm->zTerm) * 2 + 3 + 2;
+  }
+  zQuoted = sqlite3_malloc(nByte);
+
+  if( zQuoted ){
+    int i = 0;
+    for(p=pTerm; p; p=p->pSynonym){
+      char *zIn = p->zTerm;
+      zQuoted[i++] = '"';
+      while( *zIn ){
+        if( *zIn=='"' ) zQuoted[i++] = '"';
+        zQuoted[i++] = *zIn++;
+      }
+      zQuoted[i++] = '"';
+      if( p->pSynonym ) zQuoted[i++] = '|';
+    }
+    if( pTerm->bPrefix ){
+      zQuoted[i++] = ' ';
+      zQuoted[i++] = '*';
+    }
+    zQuoted[i++] = '\0';
+  }
+  return zQuoted;
+}
+
+static char *fts5PrintfAppend(char *zApp, const char *zFmt, ...){
+  char *zNew;
+  va_list ap;
+  va_start(ap, zFmt);
+  zNew = sqlite3_vmprintf(zFmt, ap);
+  va_end(ap);
+  if( zApp && zNew ){
+    char *zNew2 = sqlite3_mprintf("%s%s", zApp, zNew);
+    sqlite3_free(zNew);
+    zNew = zNew2;
+  }
+  sqlite3_free(zApp);
+  return zNew;
+}
+
+/*
+** Compose a tcl-readable representation of expression pExpr. Return a 
+** pointer to a buffer containing that representation. It is the 
+** responsibility of the caller to at some point free the buffer using 
+** sqlite3_free().
+*/
+static char *fts5ExprPrintTcl(
+  Fts5Config *pConfig, 
+  const char *zNearsetCmd,
+  Fts5ExprNode *pExpr
+){
+  char *zRet = 0;
+  if( pExpr->eType==FTS5_STRING || pExpr->eType==FTS5_TERM ){
+    Fts5ExprNearset *pNear = pExpr->pNear;
+    int i; 
+    int iTerm;
+
+    zRet = fts5PrintfAppend(zRet, "%s ", zNearsetCmd);
+    if( zRet==0 ) return 0;
+    if( pNear->pColset ){
+      int *aiCol = pNear->pColset->aiCol;
+      int nCol = pNear->pColset->nCol;
+      if( nCol==1 ){
+        zRet = fts5PrintfAppend(zRet, "-col %d ", aiCol[0]);
+      }else{
+        zRet = fts5PrintfAppend(zRet, "-col {%d", aiCol[0]);
+        for(i=1; i<pNear->pColset->nCol; i++){
+          zRet = fts5PrintfAppend(zRet, " %d", aiCol[i]);
+        }
+        zRet = fts5PrintfAppend(zRet, "} ");
+      }
+      if( zRet==0 ) return 0;
+    }
+
+    if( pNear->nPhrase>1 ){
+      zRet = fts5PrintfAppend(zRet, "-near %d ", pNear->nNear);
+      if( zRet==0 ) return 0;
+    }
+
+    zRet = fts5PrintfAppend(zRet, "--");
+    if( zRet==0 ) return 0;
+
+    for(i=0; i<pNear->nPhrase; i++){
+      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
+
+      zRet = fts5PrintfAppend(zRet, " {");
+      for(iTerm=0; zRet && iTerm<pPhrase->nTerm; iTerm++){
+        char *zTerm = pPhrase->aTerm[iTerm].zTerm;
+        zRet = fts5PrintfAppend(zRet, "%s%s", iTerm==0?"":" ", zTerm);
+      }
+
+      if( zRet ) zRet = fts5PrintfAppend(zRet, "}");
+      if( zRet==0 ) return 0;
+    }
+
+  }else{
+    char const *zOp = 0;
+    int i;
+    switch( pExpr->eType ){
+      case FTS5_AND: zOp = "AND"; break;
+      case FTS5_NOT: zOp = "NOT"; break;
+      default: 
+        assert( pExpr->eType==FTS5_OR );
+        zOp = "OR"; 
+        break;
+    }
+
+    zRet = sqlite3_mprintf("%s", zOp);
+    for(i=0; zRet && i<pExpr->nChild; i++){
+      char *z = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->apChild[i]);
+      if( !z ){
+        sqlite3_free(zRet);
+        zRet = 0;
+      }else{
+        zRet = fts5PrintfAppend(zRet, " [%z]", z);
+      }
+    }
+  }
+
+  return zRet;
+}
+
+static char *fts5ExprPrint(Fts5Config *pConfig, Fts5ExprNode *pExpr){
+  char *zRet = 0;
+  if( pExpr->eType==FTS5_STRING || pExpr->eType==FTS5_TERM ){
+    Fts5ExprNearset *pNear = pExpr->pNear;
+    int i; 
+    int iTerm;
+
+    if( pNear->pColset ){
+      int iCol = pNear->pColset->aiCol[0];
+      zRet = fts5PrintfAppend(zRet, "%s : ", pConfig->azCol[iCol]);
+      if( zRet==0 ) return 0;
+    }
+
+    if( pNear->nPhrase>1 ){
+      zRet = fts5PrintfAppend(zRet, "NEAR(");
+      if( zRet==0 ) return 0;
+    }
+
+    for(i=0; i<pNear->nPhrase; i++){
+      Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];
+      if( i!=0 ){
+        zRet = fts5PrintfAppend(zRet, " ");
+        if( zRet==0 ) return 0;
+      }
+      for(iTerm=0; iTerm<pPhrase->nTerm; iTerm++){
+        char *zTerm = fts5ExprTermPrint(&pPhrase->aTerm[iTerm]);
+        if( zTerm ){
+          zRet = fts5PrintfAppend(zRet, "%s%s", iTerm==0?"":" + ", zTerm);
+          sqlite3_free(zTerm);
+        }
+        if( zTerm==0 || zRet==0 ){
+          sqlite3_free(zRet);
+          return 0;
+        }
+      }
+    }
+
+    if( pNear->nPhrase>1 ){
+      zRet = fts5PrintfAppend(zRet, ", %d)", pNear->nNear);
+      if( zRet==0 ) return 0;
+    }
+
+  }else{
+    char const *zOp = 0;
+    int i;
+
+    switch( pExpr->eType ){
+      case FTS5_AND: zOp = " AND "; break;
+      case FTS5_NOT: zOp = " NOT "; break;
+      default:  
+        assert( pExpr->eType==FTS5_OR );
+        zOp = " OR "; 
+        break;
+    }
+
+    for(i=0; i<pExpr->nChild; i++){
+      char *z = fts5ExprPrint(pConfig, pExpr->apChild[i]);
+      if( z==0 ){
+        sqlite3_free(zRet);
+        zRet = 0;
+      }else{
+        int e = pExpr->apChild[i]->eType;
+        int b = (e!=FTS5_STRING && e!=FTS5_TERM);
+        zRet = fts5PrintfAppend(zRet, "%s%s%z%s", 
+            (i==0 ? "" : zOp),
+            (b?"(":""), z, (b?")":"")
+        );
+      }
+      if( zRet==0 ) break;
+    }
+  }
+
+  return zRet;
+}
+
+/*
+** The implementation of user-defined scalar functions fts5_expr() (bTcl==0)
+** and fts5_expr_tcl() (bTcl!=0).
+*/
+static void fts5ExprFunction(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args */
+  sqlite3_value **apVal,          /* Function arguments */
+  int bTcl
+){
+  Fts5Global *pGlobal = (Fts5Global*)sqlite3_user_data(pCtx);
+  sqlite3 *db = sqlite3_context_db_handle(pCtx);
+  const char *zExpr = 0;
+  char *zErr = 0;
+  Fts5Expr *pExpr = 0;
+  int rc;
+  int i;
+
+  const char **azConfig;          /* Array of arguments for Fts5Config */
+  const char *zNearsetCmd = "nearset";
+  int nConfig;                    /* Size of azConfig[] */
+  Fts5Config *pConfig = 0;
+  int iArg = 1;
+
+  if( nArg<1 ){
+    zErr = sqlite3_mprintf("wrong number of arguments to function %s",
+        bTcl ? "fts5_expr_tcl" : "fts5_expr"
+    );
+    sqlite3_result_error(pCtx, zErr, -1);
+    sqlite3_free(zErr);
+    return;
+  }
+
+  if( bTcl && nArg>1 ){
+    zNearsetCmd = (const char*)sqlite3_value_text(apVal[1]);
+    iArg = 2;
+  }
+
+  nConfig = 3 + (nArg-iArg);
+  azConfig = (const char**)sqlite3_malloc(sizeof(char*) * nConfig);
+  if( azConfig==0 ){
+    sqlite3_result_error_nomem(pCtx);
+    return;
+  }
+  azConfig[0] = 0;
+  azConfig[1] = "main";
+  azConfig[2] = "tbl";
+  for(i=3; iArg<nArg; iArg++){
+    azConfig[i++] = (const char*)sqlite3_value_text(apVal[iArg]);
+  }
+
+  zExpr = (const char*)sqlite3_value_text(apVal[0]);
+
+  rc = sqlite3Fts5ConfigParse(pGlobal, db, nConfig, azConfig, &pConfig, &zErr);
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5ExprNew(pConfig, zExpr, &pExpr, &zErr);
+  }
+  if( rc==SQLITE_OK ){
+    char *zText;
+    if( pExpr->pRoot==0 ){
+      zText = sqlite3_mprintf("");
+    }else if( bTcl ){
+      zText = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->pRoot);
+    }else{
+      zText = fts5ExprPrint(pConfig, pExpr->pRoot);
+    }
+    if( zText==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      sqlite3_result_text(pCtx, zText, -1, SQLITE_TRANSIENT);
+      sqlite3_free(zText);
+    }
+  }
+
+  if( rc!=SQLITE_OK ){
+    if( zErr ){
+      sqlite3_result_error(pCtx, zErr, -1);
+      sqlite3_free(zErr);
+    }else{
+      sqlite3_result_error_code(pCtx, rc);
+    }
+  }
+  sqlite3_free((void *)azConfig);
+  sqlite3Fts5ConfigFree(pConfig);
+  sqlite3Fts5ExprFree(pExpr);
+}
+
+static void fts5ExprFunctionHr(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args */
+  sqlite3_value **apVal           /* Function arguments */
+){
+  fts5ExprFunction(pCtx, nArg, apVal, 0);
+}
+static void fts5ExprFunctionTcl(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args */
+  sqlite3_value **apVal           /* Function arguments */
+){
+  fts5ExprFunction(pCtx, nArg, apVal, 1);
+}
+
+/*
+** The implementation of an SQLite user-defined-function that accepts a
+** single integer as an argument. If the integer is an alpha-numeric 
+** unicode code point, 1 is returned. Otherwise 0.
+*/
+static void fts5ExprIsAlnum(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args */
+  sqlite3_value **apVal           /* Function arguments */
+){
+  int iCode;
+  if( nArg!=1 ){
+    sqlite3_result_error(pCtx, 
+        "wrong number of arguments to function fts5_isalnum", -1
+    );
+    return;
+  }
+  iCode = sqlite3_value_int(apVal[0]);
+  sqlite3_result_int(pCtx, sqlite3Fts5UnicodeIsalnum(iCode));
+}
+
+static void fts5ExprFold(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args */
+  sqlite3_value **apVal           /* Function arguments */
+){
+  if( nArg!=1 && nArg!=2 ){
+    sqlite3_result_error(pCtx, 
+        "wrong number of arguments to function fts5_fold", -1
+    );
+  }else{
+    int iCode;
+    int bRemoveDiacritics = 0;
+    iCode = sqlite3_value_int(apVal[0]);
+    if( nArg==2 ) bRemoveDiacritics = sqlite3_value_int(apVal[1]);
+    sqlite3_result_int(pCtx, sqlite3Fts5UnicodeFold(iCode, bRemoveDiacritics));
+  }
+}
+
+/*
+** This is called during initialization to register the fts5_expr() scalar
+** UDF with the SQLite handle passed as the only argument.
+*/
+static int sqlite3Fts5ExprInit(Fts5Global *pGlobal, sqlite3 *db){
+  struct Fts5ExprFunc {
+    const char *z;
+    void (*x)(sqlite3_context*,int,sqlite3_value**);
+  } aFunc[] = {
+    { "fts5_expr",     fts5ExprFunctionHr },
+    { "fts5_expr_tcl", fts5ExprFunctionTcl },
+    { "fts5_isalnum",  fts5ExprIsAlnum },
+    { "fts5_fold",     fts5ExprFold },
+  };
+  int i;
+  int rc = SQLITE_OK;
+  void *pCtx = (void*)pGlobal;
+
+  for(i=0; rc==SQLITE_OK && i<(sizeof(aFunc) / sizeof(aFunc[0])); i++){
+    struct Fts5ExprFunc *p = &aFunc[i];
+    rc = sqlite3_create_function(db, p->z, -1, SQLITE_UTF8, pCtx, p->x, 0, 0);
+  }
+
+  /* Avoid a warning indicating that sqlite3Fts5ParserTrace() is unused */
+#ifndef NDEBUG
+  (void)sqlite3Fts5ParserTrace;
+#endif
+
+  return rc;
+}
+
+/*
+** Return the number of phrases in expression pExpr.
+*/
+static int sqlite3Fts5ExprPhraseCount(Fts5Expr *pExpr){
+  return (pExpr ? pExpr->nPhrase : 0);
+}
+
+/*
+** Return the number of terms in the iPhrase'th phrase in pExpr.
+*/
+static int sqlite3Fts5ExprPhraseSize(Fts5Expr *pExpr, int iPhrase){
+  if( iPhrase<0 || iPhrase>=pExpr->nPhrase ) return 0;
+  return pExpr->apExprPhrase[iPhrase]->nTerm;
+}
+
+/*
+** This function is used to access the current position list for phrase
+** iPhrase.
+*/
+static int sqlite3Fts5ExprPoslist(Fts5Expr *pExpr, int iPhrase, const u8 **pa){
+  int nRet;
+  Fts5ExprPhrase *pPhrase = pExpr->apExprPhrase[iPhrase];
+  Fts5ExprNode *pNode = pPhrase->pNode;
+  if( pNode->bEof==0 && pNode->iRowid==pExpr->pRoot->iRowid ){
+    *pa = pPhrase->poslist.p;
+    nRet = pPhrase->poslist.n;
+  }else{
+    *pa = 0;
+    nRet = 0;
+  }
+  return nRet;
+}
+
+/*
+** 2014 August 11
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+*/
+
+
+
+
+typedef struct Fts5HashEntry Fts5HashEntry;
+
+/*
+** This file contains the implementation of an in-memory hash table used
+** to accumuluate "term -> doclist" content before it is flused to a level-0
+** segment.
+*/
+
+
+struct Fts5Hash {
+  int *pnByte;                    /* Pointer to bytes counter */
+  int nEntry;                     /* Number of entries currently in hash */
+  int nSlot;                      /* Size of aSlot[] array */
+  Fts5HashEntry *pScan;           /* Current ordered scan item */
+  Fts5HashEntry **aSlot;          /* Array of hash slots */
+};
+
+/*
+** Each entry in the hash table is represented by an object of the 
+** following type. Each object, its key (zKey[]) and its current data
+** are stored in a single memory allocation. The position list data 
+** immediately follows the key data in memory.
+**
+** The data that follows the key is in a similar, but not identical format
+** to the doclist data stored in the database. It is:
+**
+**   * Rowid, as a varint
+**   * Position list, without 0x00 terminator.
+**   * Size of previous position list and rowid, as a 4 byte
+**     big-endian integer.
+**
+** iRowidOff:
+**   Offset of last rowid written to data area. Relative to first byte of
+**   structure.
+**
+** nData:
+**   Bytes of data written since iRowidOff.
+*/
+struct Fts5HashEntry {
+  Fts5HashEntry *pHashNext;       /* Next hash entry with same hash-key */
+  Fts5HashEntry *pScanNext;       /* Next entry in sorted order */
+  
+  int nAlloc;                     /* Total size of allocation */
+  int iSzPoslist;                 /* Offset of space for 4-byte poslist size */
+  int nData;                      /* Total bytes of data (incl. structure) */
+  u8 bDel;                        /* Set delete-flag @ iSzPoslist */
+
+  int iCol;                       /* Column of last value written */
+  int iPos;                       /* Position of last value written */
+  i64 iRowid;                     /* Rowid of last value written */
+  char zKey[8];                   /* Nul-terminated entry key */
+};
+
+/*
+** Size of Fts5HashEntry without the zKey[] array.
+*/
+#define FTS5_HASHENTRYSIZE (sizeof(Fts5HashEntry)-8)
+
+
+
+/*
+** Allocate a new hash table.
+*/
+static int sqlite3Fts5HashNew(Fts5Hash **ppNew, int *pnByte){
+  int rc = SQLITE_OK;
+  Fts5Hash *pNew;
+
+  *ppNew = pNew = (Fts5Hash*)sqlite3_malloc(sizeof(Fts5Hash));
+  if( pNew==0 ){
+    rc = SQLITE_NOMEM;
+  }else{
+    int nByte;
+    memset(pNew, 0, sizeof(Fts5Hash));
+    pNew->pnByte = pnByte;
+
+    pNew->nSlot = 1024;
+    nByte = sizeof(Fts5HashEntry*) * pNew->nSlot;
+    pNew->aSlot = (Fts5HashEntry**)sqlite3_malloc(nByte);
+    if( pNew->aSlot==0 ){
+      sqlite3_free(pNew);
+      *ppNew = 0;
+      rc = SQLITE_NOMEM;
+    }else{
+      memset(pNew->aSlot, 0, nByte);
+    }
+  }
+  return rc;
+}
+
+/*
+** Free a hash table object.
+*/
+static void sqlite3Fts5HashFree(Fts5Hash *pHash){
+  if( pHash ){
+    sqlite3Fts5HashClear(pHash);
+    sqlite3_free(pHash->aSlot);
+    sqlite3_free(pHash);
+  }
+}
+
+/*
+** Empty (but do not delete) a hash table.
+*/
+static void sqlite3Fts5HashClear(Fts5Hash *pHash){
+  int i;
+  for(i=0; i<pHash->nSlot; i++){
+    Fts5HashEntry *pNext;
+    Fts5HashEntry *pSlot;
+    for(pSlot=pHash->aSlot[i]; pSlot; pSlot=pNext){
+      pNext = pSlot->pHashNext;
+      sqlite3_free(pSlot);
+    }
+  }
+  memset(pHash->aSlot, 0, pHash->nSlot * sizeof(Fts5HashEntry*));
+  pHash->nEntry = 0;
+}
+
+static unsigned int fts5HashKey(int nSlot, const u8 *p, int n){
+  int i;
+  unsigned int h = 13;
+  for(i=n-1; i>=0; i--){
+    h = (h << 3) ^ h ^ p[i];
+  }
+  return (h % nSlot);
+}
+
+static unsigned int fts5HashKey2(int nSlot, u8 b, const u8 *p, int n){
+  int i;
+  unsigned int h = 13;
+  for(i=n-1; i>=0; i--){
+    h = (h << 3) ^ h ^ p[i];
+  }
+  h = (h << 3) ^ h ^ b;
+  return (h % nSlot);
+}
+
+/*
+** Resize the hash table by doubling the number of slots.
+*/
+static int fts5HashResize(Fts5Hash *pHash){
+  int nNew = pHash->nSlot*2;
+  int i;
+  Fts5HashEntry **apNew;
+  Fts5HashEntry **apOld = pHash->aSlot;
+
+  apNew = (Fts5HashEntry**)sqlite3_malloc(nNew*sizeof(Fts5HashEntry*));
+  if( !apNew ) return SQLITE_NOMEM;
+  memset(apNew, 0, nNew*sizeof(Fts5HashEntry*));
+
+  for(i=0; i<pHash->nSlot; i++){
+    while( apOld[i] ){
+      int iHash;
+      Fts5HashEntry *p = apOld[i];
+      apOld[i] = p->pHashNext;
+      iHash = fts5HashKey(nNew, (u8*)p->zKey, strlen(p->zKey));
+      p->pHashNext = apNew[iHash];
+      apNew[iHash] = p;
+    }
+  }
+
+  sqlite3_free(apOld);
+  pHash->nSlot = nNew;
+  pHash->aSlot = apNew;
+  return SQLITE_OK;
+}
+
+static void fts5HashAddPoslistSize(Fts5HashEntry *p){
+  if( p->iSzPoslist ){
+    u8 *pPtr = (u8*)p;
+    int nSz = (p->nData - p->iSzPoslist - 1);         /* Size in bytes */
+    int nPos = nSz*2 + p->bDel;                       /* Value of nPos field */
+
+    assert( p->bDel==0 || p->bDel==1 );
+    if( nPos<=127 ){
+      pPtr[p->iSzPoslist] = nPos;
+    }else{
+      int nByte = sqlite3Fts5GetVarintLen((u32)nPos);
+      memmove(&pPtr[p->iSzPoslist + nByte], &pPtr[p->iSzPoslist + 1], nSz);
+      sqlite3Fts5PutVarint(&pPtr[p->iSzPoslist], nPos);
+      p->nData += (nByte-1);
+    }
+    p->bDel = 0;
+    p->iSzPoslist = 0;
+  }
+}
+
+static int sqlite3Fts5HashWrite(
+  Fts5Hash *pHash,
+  i64 iRowid,                     /* Rowid for this entry */
+  int iCol,                       /* Column token appears in (-ve -> delete) */
+  int iPos,                       /* Position of token within column */
+  char bByte,                     /* First byte of token */
+  const char *pToken, int nToken  /* Token to add or remove to or from index */
+){
+  unsigned int iHash;
+  Fts5HashEntry *p;
+  u8 *pPtr;
+  int nIncr = 0;                  /* Amount to increment (*pHash->pnByte) by */
+
+  /* Attempt to locate an existing hash entry */
+  iHash = fts5HashKey2(pHash->nSlot, (u8)bByte, (const u8*)pToken, nToken);
+  for(p=pHash->aSlot[iHash]; p; p=p->pHashNext){
+    if( p->zKey[0]==bByte 
+     && memcmp(&p->zKey[1], pToken, nToken)==0 
+     && p->zKey[nToken+1]==0 
+    ){
+      break;
+    }
+  }
+
+  /* If an existing hash entry cannot be found, create a new one. */
+  if( p==0 ){
+    int nByte = FTS5_HASHENTRYSIZE + (nToken+1) + 1 + 64;
+    if( nByte<128 ) nByte = 128;
+
+    if( (pHash->nEntry*2)>=pHash->nSlot ){
+      int rc = fts5HashResize(pHash);
+      if( rc!=SQLITE_OK ) return rc;
+      iHash = fts5HashKey2(pHash->nSlot, (u8)bByte, (const u8*)pToken, nToken);
+    }
+
+    p = (Fts5HashEntry*)sqlite3_malloc(nByte);
+    if( !p ) return SQLITE_NOMEM;
+    memset(p, 0, FTS5_HASHENTRYSIZE);
+    p->nAlloc = nByte;
+    p->zKey[0] = bByte;
+    memcpy(&p->zKey[1], pToken, nToken);
+    assert( iHash==fts5HashKey(pHash->nSlot, (u8*)p->zKey, nToken+1) );
+    p->zKey[nToken+1] = '\0';
+    p->nData = nToken+1 + 1 + FTS5_HASHENTRYSIZE;
+    p->nData += sqlite3Fts5PutVarint(&((u8*)p)[p->nData], iRowid);
+    p->iSzPoslist = p->nData;
+    p->nData += 1;
+    p->iRowid = iRowid;
+    p->pHashNext = pHash->aSlot[iHash];
+    pHash->aSlot[iHash] = p;
+    pHash->nEntry++;
+    nIncr += p->nData;
+  }
+
+  /* Check there is enough space to append a new entry. Worst case scenario
+  ** is:
+  **
+  **     + 9 bytes for a new rowid,
+  **     + 4 byte reserved for the "poslist size" varint.
+  **     + 1 byte for a "new column" byte,
+  **     + 3 bytes for a new column number (16-bit max) as a varint,
+  **     + 5 bytes for the new position offset (32-bit max).
+  */
+  if( (p->nAlloc - p->nData) < (9 + 4 + 1 + 3 + 5) ){
+    int nNew = p->nAlloc * 2;
+    Fts5HashEntry *pNew;
+    Fts5HashEntry **pp;
+    pNew = (Fts5HashEntry*)sqlite3_realloc(p, nNew);
+    if( pNew==0 ) return SQLITE_NOMEM;
+    pNew->nAlloc = nNew;
+    for(pp=&pHash->aSlot[iHash]; *pp!=p; pp=&(*pp)->pHashNext);
+    *pp = pNew;
+    p = pNew;
+  }
+  pPtr = (u8*)p;
+  nIncr -= p->nData;
+
+  /* If this is a new rowid, append the 4-byte size field for the previous
+  ** entry, and the new rowid for this entry.  */
+  if( iRowid!=p->iRowid ){
+    fts5HashAddPoslistSize(p);
+    p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iRowid - p->iRowid);
+    p->iSzPoslist = p->nData;
+    p->nData += 1;
+    p->iCol = 0;
+    p->iPos = 0;
+    p->iRowid = iRowid;
+  }
+
+  if( iCol>=0 ){
+    /* Append a new column value, if necessary */
+    assert( iCol>=p->iCol );
+    if( iCol!=p->iCol ){
+      pPtr[p->nData++] = 0x01;
+      p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iCol);
+      p->iCol = iCol;
+      p->iPos = 0;
+    }
+
+    /* Append the new position offset */
+    p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iPos - p->iPos + 2);
+    p->iPos = iPos;
+  }else{
+    /* This is a delete. Set the delete flag. */
+    p->bDel = 1;
+  }
+  nIncr += p->nData;
+
+  *pHash->pnByte += nIncr;
+  return SQLITE_OK;
+}
+
+
+/*
+** Arguments pLeft and pRight point to linked-lists of hash-entry objects,
+** each sorted in key order. This function merges the two lists into a
+** single list and returns a pointer to its first element.
+*/
+static Fts5HashEntry *fts5HashEntryMerge(
+  Fts5HashEntry *pLeft,
+  Fts5HashEntry *pRight
+){
+  Fts5HashEntry *p1 = pLeft;
+  Fts5HashEntry *p2 = pRight;
+  Fts5HashEntry *pRet = 0;
+  Fts5HashEntry **ppOut = &pRet;
+
+  while( p1 || p2 ){
+    if( p1==0 ){
+      *ppOut = p2;
+      p2 = 0;
+    }else if( p2==0 ){
+      *ppOut = p1;
+      p1 = 0;
+    }else{
+      int i = 0;
+      while( p1->zKey[i]==p2->zKey[i] ) i++;
+
+      if( ((u8)p1->zKey[i])>((u8)p2->zKey[i]) ){
+        /* p2 is smaller */
+        *ppOut = p2;
+        ppOut = &p2->pScanNext;
+        p2 = p2->pScanNext;
+      }else{
+        /* p1 is smaller */
+        *ppOut = p1;
+        ppOut = &p1->pScanNext;
+        p1 = p1->pScanNext;
+      }
+      *ppOut = 0;
+    }
+  }
+
+  return pRet;
+}
+
+/*
+** Extract all tokens from hash table iHash and link them into a list
+** in sorted order. The hash table is cleared before returning. It is
+** the responsibility of the caller to free the elements of the returned
+** list.
+*/
+static int fts5HashEntrySort(
+  Fts5Hash *pHash, 
+  const char *pTerm, int nTerm,   /* Query prefix, if any */
+  Fts5HashEntry **ppSorted
+){
+  const int nMergeSlot = 32;
+  Fts5HashEntry **ap;
+  Fts5HashEntry *pList;
+  int iSlot;
+  int i;
+
+  *ppSorted = 0;
+  ap = sqlite3_malloc(sizeof(Fts5HashEntry*) * nMergeSlot);
+  if( !ap ) return SQLITE_NOMEM;
+  memset(ap, 0, sizeof(Fts5HashEntry*) * nMergeSlot);
+
+  for(iSlot=0; iSlot<pHash->nSlot; iSlot++){
+    Fts5HashEntry *pIter;
+    for(pIter=pHash->aSlot[iSlot]; pIter; pIter=pIter->pHashNext){
+      if( pTerm==0 || 0==memcmp(pIter->zKey, pTerm, nTerm) ){
+        Fts5HashEntry *pEntry = pIter;
+        pEntry->pScanNext = 0;
+        for(i=0; ap[i]; i++){
+          pEntry = fts5HashEntryMerge(pEntry, ap[i]);
+          ap[i] = 0;
+        }
+        ap[i] = pEntry;
+      }
+    }
+  }
+
+  pList = 0;
+  for(i=0; i<nMergeSlot; i++){
+    pList = fts5HashEntryMerge(pList, ap[i]);
+  }
+
+  pHash->nEntry = 0;
+  sqlite3_free(ap);
+  *ppSorted = pList;
+  return SQLITE_OK;
+}
+
+/*
+** Query the hash table for a doclist associated with term pTerm/nTerm.
+*/
+static int sqlite3Fts5HashQuery(
+  Fts5Hash *pHash,                /* Hash table to query */
+  const char *pTerm, int nTerm,   /* Query term */
+  const u8 **ppDoclist,           /* OUT: Pointer to doclist for pTerm */
+  int *pnDoclist                  /* OUT: Size of doclist in bytes */
+){
+  unsigned int iHash = fts5HashKey(pHash->nSlot, (const u8*)pTerm, nTerm);
+  Fts5HashEntry *p;
+
+  for(p=pHash->aSlot[iHash]; p; p=p->pHashNext){
+    if( memcmp(p->zKey, pTerm, nTerm)==0 && p->zKey[nTerm]==0 ) break;
+  }
+
+  if( p ){
+    fts5HashAddPoslistSize(p);
+    *ppDoclist = (const u8*)&p->zKey[nTerm+1];
+    *pnDoclist = p->nData - (FTS5_HASHENTRYSIZE + nTerm + 1);
+  }else{
+    *ppDoclist = 0;
+    *pnDoclist = 0;
+  }
+
+  return SQLITE_OK;
+}
+
+static int sqlite3Fts5HashScanInit(
+  Fts5Hash *p,                    /* Hash table to query */
+  const char *pTerm, int nTerm    /* Query prefix */
+){
+  return fts5HashEntrySort(p, pTerm, nTerm, &p->pScan);
+}
+
+static void sqlite3Fts5HashScanNext(Fts5Hash *p){
+  assert( !sqlite3Fts5HashScanEof(p) );
+  p->pScan = p->pScan->pScanNext;
+}
+
+static int sqlite3Fts5HashScanEof(Fts5Hash *p){
+  return (p->pScan==0);
+}
+
+static void sqlite3Fts5HashScanEntry(
+  Fts5Hash *pHash,
+  const char **pzTerm,            /* OUT: term (nul-terminated) */
+  const u8 **ppDoclist,           /* OUT: pointer to doclist */
+  int *pnDoclist                  /* OUT: size of doclist in bytes */
+){
+  Fts5HashEntry *p;
+  if( (p = pHash->pScan) ){
+    int nTerm = strlen(p->zKey);
+    fts5HashAddPoslistSize(p);
+    *pzTerm = p->zKey;
+    *ppDoclist = (const u8*)&p->zKey[nTerm+1];
+    *pnDoclist = p->nData - (FTS5_HASHENTRYSIZE + nTerm + 1);
+  }else{
+    *pzTerm = 0;
+    *ppDoclist = 0;
+    *pnDoclist = 0;
+  }
+}
+
+
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** Low level access to the FTS index stored in the database file. The 
+** routines in this file file implement all read and write access to the
+** %_data table. Other parts of the system access this functionality via
+** the interface defined in fts5Int.h.
+*/
+
+
+
+/*
+** Overview:
+**
+** The %_data table contains all the FTS indexes for an FTS5 virtual table.
+** As well as the main term index, there may be up to 31 prefix indexes.
+** The format is similar to FTS3/4, except that:
+**
+**   * all segment b-tree leaf data is stored in fixed size page records 
+**     (e.g. 1000 bytes). A single doclist may span multiple pages. Care is 
+**     taken to ensure it is possible to iterate in either direction through 
+**     the entries in a doclist, or to seek to a specific entry within a 
+**     doclist, without loading it into memory.
+**
+**   * large doclists that span many pages have associated "doclist index"
+**     records that contain a copy of the first rowid on each page spanned by
+**     the doclist. This is used to speed up seek operations, and merges of
+**     large doclists with very small doclists.
+**
+**   * extra fields in the "structure record" record the state of ongoing
+**     incremental merge operations.
+**
+*/
+
+
+#define FTS5_OPT_WORK_UNIT  1000  /* Number of leaf pages per optimize step */
+#define FTS5_WORK_UNIT      64    /* Number of leaf pages in unit of work */
+
+#define FTS5_MIN_DLIDX_SIZE 4     /* Add dlidx if this many empty pages */
+
+#define FTS5_MAIN_PREFIX '0'
+
+#if FTS5_MAX_PREFIX_INDEXES > 31
+# error "FTS5_MAX_PREFIX_INDEXES is too large"
+#endif
+
+/*
+** Details:
+**
+** The %_data table managed by this module,
+**
+**     CREATE TABLE %_data(id INTEGER PRIMARY KEY, block BLOB);
+**
+** , contains the following 5 types of records. See the comments surrounding
+** the FTS5_*_ROWID macros below for a description of how %_data rowids are 
+** assigned to each fo them.
+**
+** 1. Structure Records:
+**
+**   The set of segments that make up an index - the index structure - are
+**   recorded in a single record within the %_data table. The record consists
+**   of a single 32-bit configuration cookie value followed by a list of 
+**   SQLite varints. If the FTS table features more than one index (because
+**   there are one or more prefix indexes), it is guaranteed that all share
+**   the same cookie value.
+**
+**   Immediately following the configuration cookie, the record begins with
+**   three varints:
+**
+**     + number of levels,
+**     + total number of segments on all levels,
+**     + value of write counter.
+**
+**   Then, for each level from 0 to nMax:
+**
+**     + number of input segments in ongoing merge.
+**     + total number of segments in level.
+**     + for each segment from oldest to newest:
+**         + segment id (always > 0)
+**         + first leaf page number (often 1, always greater than 0)
+**         + final leaf page number
+**
+** 2. The Averages Record:
+**
+**   A single record within the %_data table. The data is a list of varints.
+**   The first value is the number of rows in the index. Then, for each column
+**   from left to right, the total number of tokens in the column for all
+**   rows of the table.
+**
+** 3. Segment leaves:
+**
+**   TERM/DOCLIST FORMAT:
+**
+**     Most of each segment leaf is taken up by term/doclist data. The 
+**     general format of term/doclist, starting with the first term
+**     on the leaf page, is:
+**
+**         varint : size of first term
+**         blob:    first term data
+**         doclist: first doclist
+**         zero-or-more {
+**           varint:  number of bytes in common with previous term
+**           varint:  number of bytes of new term data (nNew)
+**           blob:    nNew bytes of new term data
+**           doclist: next doclist
+**         }
+**
+**     doclist format:
+**
+**         varint:  first rowid
+**         poslist: first poslist
+**         zero-or-more {
+**           varint:  rowid delta (always > 0)
+**           poslist: next poslist
+**         }
+**
+**     poslist format:
+**
+**         varint: size of poslist in bytes multiplied by 2, not including
+**                 this field. Plus 1 if this entry carries the "delete" flag.
+**         collist: collist for column 0
+**         zero-or-more {
+**           0x01 byte
+**           varint: column number (I)
+**           collist: collist for column I
+**         }
+**
+**     collist format:
+**
+**         varint: first offset + 2
+**         zero-or-more {
+**           varint: offset delta + 2
+**         }
+**
+**   PAGE FORMAT
+**
+**     Each leaf page begins with a 4-byte header containing 2 16-bit 
+**     unsigned integer fields in big-endian format. They are:
+**
+**       * The byte offset of the first rowid on the page, if it exists
+**         and occurs before the first term (otherwise 0).
+**
+**       * The byte offset of the start of the page footer. If the page
+**         footer is 0 bytes in size, then this field is the same as the
+**         size of the leaf page in bytes.
+**
+**     The page footer consists of a single varint for each term located
+**     on the page. Each varint is the byte offset of the current term
+**     within the page, delta-compressed against the previous value. In
+**     other words, the first varint in the footer is the byte offset of
+**     the first term, the second is the byte offset of the second less that
+**     of the first, and so on.
+**
+**     The term/doclist format described above is accurate if the entire
+**     term/doclist data fits on a single leaf page. If this is not the case,
+**     the format is changed in two ways:
+**
+**       + if the first rowid on a page occurs before the first term, it
+**         is stored as a literal value:
+**
+**             varint:  first rowid
+**
+**       + the first term on each page is stored in the same way as the
+**         very first term of the segment:
+**
+**             varint : size of first term
+**             blob:    first term data
+**
+** 5. Segment doclist indexes:
+**
+**   Doclist indexes are themselves b-trees, however they usually consist of
+**   a single leaf record only. The format of each doclist index leaf page 
+**   is:
+**
+**     * Flags byte. Bits are:
+**         0x01: Clear if leaf is also the root page, otherwise set.
+**
+**     * Page number of fts index leaf page. As a varint.
+**
+**     * First rowid on page indicated by previous field. As a varint.
+**
+**     * A list of varints, one for each subsequent termless page. A 
+**       positive delta if the termless page contains at least one rowid, 
+**       or an 0x00 byte otherwise.
+**
+**   Internal doclist index nodes are:
+**
+**     * Flags byte. Bits are:
+**         0x01: Clear for root page, otherwise set.
+**
+**     * Page number of first child page. As a varint.
+**
+**     * Copy of first rowid on page indicated by previous field. As a varint.
+**
+**     * A list of delta-encoded varints - the first rowid on each subsequent
+**       child page. 
+**
+*/
+
+/*
+** Rowids for the averages and structure records in the %_data table.
+*/
+#define FTS5_AVERAGES_ROWID     1    /* Rowid used for the averages record */
+#define FTS5_STRUCTURE_ROWID   10    /* The structure record */
+
+/*
+** Macros determining the rowids used by segment leaves and dlidx leaves
+** and nodes. All nodes and leaves are stored in the %_data table with large
+** positive rowids.
+**
+** Each segment has a unique non-zero 16-bit id.
+**
+** The rowid for each segment leaf is found by passing the segment id and 
+** the leaf page number to the FTS5_SEGMENT_ROWID macro. Leaves are numbered
+** sequentially starting from 1.
+*/
+#define FTS5_DATA_ID_B     16     /* Max seg id number 65535 */
+#define FTS5_DATA_DLI_B     1     /* Doclist-index flag (1 bit) */
+#define FTS5_DATA_HEIGHT_B  5     /* Max dlidx tree height of 32 */
+#define FTS5_DATA_PAGE_B   31     /* Max page number of 2147483648 */
+
+#define fts5_dri(segid, dlidx, height, pgno) (                                 \
+ ((i64)(segid)  << (FTS5_DATA_PAGE_B+FTS5_DATA_HEIGHT_B+FTS5_DATA_DLI_B)) +    \
+ ((i64)(dlidx)  << (FTS5_DATA_PAGE_B + FTS5_DATA_HEIGHT_B)) +                  \
+ ((i64)(height) << (FTS5_DATA_PAGE_B)) +                                       \
+ ((i64)(pgno))                                                                 \
+)
+
+#define FTS5_SEGMENT_ROWID(segid, pgno)       fts5_dri(segid, 0, 0, pgno)
+#define FTS5_DLIDX_ROWID(segid, height, pgno) fts5_dri(segid, 1, height, pgno)
+
+/*
+** Maximum segments permitted in a single index 
+*/
+#define FTS5_MAX_SEGMENT 2000
+
+#ifdef SQLITE_DEBUG
+static int sqlite3Fts5Corrupt() { return SQLITE_CORRUPT_VTAB; }
+#endif
+
+
+/*
+** Each time a blob is read from the %_data table, it is padded with this
+** many zero bytes. This makes it easier to decode the various record formats
+** without overreading if the records are corrupt.
+*/
+#define FTS5_DATA_ZERO_PADDING 8
+#define FTS5_DATA_PADDING 20
+
+typedef struct Fts5Data Fts5Data;
+typedef struct Fts5DlidxIter Fts5DlidxIter;
+typedef struct Fts5DlidxLvl Fts5DlidxLvl;
+typedef struct Fts5DlidxWriter Fts5DlidxWriter;
+typedef struct Fts5PageWriter Fts5PageWriter;
+typedef struct Fts5SegIter Fts5SegIter;
+typedef struct Fts5DoclistIter Fts5DoclistIter;
+typedef struct Fts5SegWriter Fts5SegWriter;
+typedef struct Fts5Structure Fts5Structure;
+typedef struct Fts5StructureLevel Fts5StructureLevel;
+typedef struct Fts5StructureSegment Fts5StructureSegment;
+
+struct Fts5Data {
+  u8 *p;                          /* Pointer to buffer containing record */
+  int nn;                         /* Size of record in bytes */
+  int szLeaf;                     /* Size of leaf without page-index */
+};
+
+/*
+** One object per %_data table.
+*/
+struct Fts5Index {
+  Fts5Config *pConfig;            /* Virtual table configuration */
+  char *zDataTbl;                 /* Name of %_data table */
+  int nWorkUnit;                  /* Leaf pages in a "unit" of work */
+
+  /*
+  ** Variables related to the accumulation of tokens and doclists within the
+  ** in-memory hash tables before they are flushed to disk.
+  */
+  Fts5Hash *pHash;                /* Hash table for in-memory data */
+  int nMaxPendingData;            /* Max pending data before flush to disk */
+  int nPendingData;               /* Current bytes of pending data */
+  i64 iWriteRowid;                /* Rowid for current doc being written */
+  int bDelete;                    /* Current write is a delete */
+
+  /* Error state. */
+  int rc;                         /* Current error code */
+
+  /* State used by the fts5DataXXX() functions. */
+  sqlite3_blob *pReader;          /* RO incr-blob open on %_data table */
+  sqlite3_stmt *pWriter;          /* "INSERT ... %_data VALUES(?,?)" */
+  sqlite3_stmt *pDeleter;         /* "DELETE FROM %_data ... id>=? AND id<=?" */
+  sqlite3_stmt *pIdxWriter;       /* "INSERT ... %_idx VALUES(?,?,?,?)" */
+  sqlite3_stmt *pIdxDeleter;      /* "DELETE FROM %_idx WHERE segid=? */
+  sqlite3_stmt *pIdxSelect;
+  int nRead;                      /* Total number of blocks read */
+};
+
+struct Fts5DoclistIter {
+  u8 *aEof;                       /* Pointer to 1 byte past end of doclist */
+
+  /* Output variables. aPoslist==0 at EOF */
+  i64 iRowid;
+  u8 *aPoslist;
+  int nPoslist;
+  int nSize;
+};
+
+/*
+** The contents of the "structure" record for each index are represented
+** using an Fts5Structure record in memory. Which uses instances of the 
+** other Fts5StructureXXX types as components.
+*/
+struct Fts5StructureSegment {
+  int iSegid;                     /* Segment id */
+  int pgnoFirst;                  /* First leaf page number in segment */
+  int pgnoLast;                   /* Last leaf page number in segment */
+};
+struct Fts5StructureLevel {
+  int nMerge;                     /* Number of segments in incr-merge */
+  int nSeg;                       /* Total number of segments on level */
+  Fts5StructureSegment *aSeg;     /* Array of segments. aSeg[0] is oldest. */
+};
+struct Fts5Structure {
+  int nRef;                       /* Object reference count */
+  u64 nWriteCounter;              /* Total leaves written to level 0 */
+  int nSegment;                   /* Total segments in this structure */
+  int nLevel;                     /* Number of levels in this index */
+  Fts5StructureLevel aLevel[1];   /* Array of nLevel level objects */
+};
+
+/*
+** An object of type Fts5SegWriter is used to write to segments.
+*/
+struct Fts5PageWriter {
+  int pgno;                       /* Page number for this page */
+  int iPrevPgidx;                 /* Previous value written into pgidx */
+  Fts5Buffer buf;                 /* Buffer containing leaf data */
+  Fts5Buffer pgidx;               /* Buffer containing page-index */
+  Fts5Buffer term;                /* Buffer containing previous term on page */
+};
+struct Fts5DlidxWriter {
+  int pgno;                       /* Page number for this page */
+  int bPrevValid;                 /* True if iPrev is valid */
+  i64 iPrev;                      /* Previous rowid value written to page */
+  Fts5Buffer buf;                 /* Buffer containing page data */
+};
+struct Fts5SegWriter {
+  int iSegid;                     /* Segid to write to */
+  Fts5PageWriter writer;          /* PageWriter object */
+  i64 iPrevRowid;                 /* Previous rowid written to current leaf */
+  u8 bFirstRowidInDoclist;        /* True if next rowid is first in doclist */
+  u8 bFirstRowidInPage;           /* True if next rowid is first in page */
+  /* TODO1: Can use (writer.pgidx.n==0) instead of bFirstTermInPage */
+  u8 bFirstTermInPage;            /* True if next term will be first in leaf */
+  int nLeafWritten;               /* Number of leaf pages written */
+  int nEmpty;                     /* Number of contiguous term-less nodes */
+
+  int nDlidx;                     /* Allocated size of aDlidx[] array */
+  Fts5DlidxWriter *aDlidx;        /* Array of Fts5DlidxWriter objects */
+
+  /* Values to insert into the %_idx table */
+  Fts5Buffer btterm;              /* Next term to insert into %_idx table */
+  int iBtPage;                    /* Page number corresponding to btterm */
+};
+
+/*
+** Object for iterating through the merged results of one or more segments,
+** visiting each term/rowid pair in the merged data.
+**
+** nSeg is always a power of two greater than or equal to the number of
+** segments that this object is merging data from. Both the aSeg[] and
+** aFirst[] arrays are sized at nSeg entries. The aSeg[] array is padded
+** with zeroed objects - these are handled as if they were iterators opened
+** on empty segments.
+**
+** The results of comparing segments aSeg[N] and aSeg[N+1], where N is an
+** even number, is stored in aFirst[(nSeg+N)/2]. The "result" of the 
+** comparison in this context is the index of the iterator that currently
+** points to the smaller term/rowid combination. Iterators at EOF are
+** considered to be greater than all other iterators.
+**
+** aFirst[1] contains the index in aSeg[] of the iterator that points to
+** the smallest key overall. aFirst[0] is unused. 
+*/
+
+typedef struct Fts5CResult Fts5CResult;
+struct Fts5CResult {
+  u16 iFirst;                     /* aSeg[] index of firstest iterator */
+  u8 bTermEq;                     /* True if the terms are equal */
+};
+
+/*
+** Object for iterating through a single segment, visiting each term/rowid
+** pair in the segment.
+**
+** pSeg:
+**   The segment to iterate through.
+**
+** iLeafPgno:
+**   Current leaf page number within segment.
+**
+** iLeafOffset:
+**   Byte offset within the current leaf that is the first byte of the 
+**   position list data (one byte passed the position-list size field).
+**   rowid field of the current entry. Usually this is the size field of the
+**   position list data. The exception is if the rowid for the current entry 
+**   is the last thing on the leaf page.
+**
+** pLeaf:
+**   Buffer containing current leaf page data. Set to NULL at EOF.
+**
+** iTermLeafPgno, iTermLeafOffset:
+**   Leaf page number containing the last term read from the segment. And
+**   the offset immediately following the term data.
+**
+** flags:
+**   Mask of FTS5_SEGITER_XXX values. Interpreted as follows:
+**
+**   FTS5_SEGITER_ONETERM:
+**     If set, set the iterator to point to EOF after the current doclist 
+**     has been exhausted. Do not proceed to the next term in the segment.
+**
+**   FTS5_SEGITER_REVERSE:
+**     This flag is only ever set if FTS5_SEGITER_ONETERM is also set. If
+**     it is set, iterate through rowid in descending order instead of the
+**     default ascending order.
+**
+** iRowidOffset/nRowidOffset/aRowidOffset:
+**     These are used if the FTS5_SEGITER_REVERSE flag is set.
+**
+**     For each rowid on the page corresponding to the current term, the
+**     corresponding aRowidOffset[] entry is set to the byte offset of the
+**     start of the "position-list-size" field within the page.
+**
+** iTermIdx:
+**     Index of current term on iTermLeafPgno.
+*/
+struct Fts5SegIter {
+  Fts5StructureSegment *pSeg;     /* Segment to iterate through */
+  int flags;                      /* Mask of configuration flags */
+  int iLeafPgno;                  /* Current leaf page number */
+  Fts5Data *pLeaf;                /* Current leaf data */
+  Fts5Data *pNextLeaf;            /* Leaf page (iLeafPgno+1) */
+  int iLeafOffset;                /* Byte offset within current leaf */
+
+  /* The page and offset from which the current term was read. The offset 
+  ** is the offset of the first rowid in the current doclist.  */
+  int iTermLeafPgno;
+  int iTermLeafOffset;
+
+  int iPgidxOff;                  /* Next offset in pgidx */
+  int iEndofDoclist;
+
+  /* The following are only used if the FTS5_SEGITER_REVERSE flag is set. */
+  int iRowidOffset;               /* Current entry in aRowidOffset[] */
+  int nRowidOffset;               /* Allocated size of aRowidOffset[] array */
+  int *aRowidOffset;              /* Array of offset to rowid fields */
+
+  Fts5DlidxIter *pDlidx;          /* If there is a doclist-index */
+
+  /* Variables populated based on current entry. */
+  Fts5Buffer term;                /* Current term */
+  i64 iRowid;                     /* Current rowid */
+  int nPos;                       /* Number of bytes in current position list */
+  int bDel;                       /* True if the delete flag is set */
+};
+
+/*
+** Argument is a pointer to an Fts5Data structure that contains a 
+** leaf page.
+*/
+#define ASSERT_SZLEAF_OK(x) assert( \
+    (x)->szLeaf==(x)->nn || (x)->szLeaf==fts5GetU16(&(x)->p[2]) \
+)
+
+#define FTS5_SEGITER_ONETERM 0x01
+#define FTS5_SEGITER_REVERSE 0x02
+
+
+/* 
+** Argument is a pointer to an Fts5Data structure that contains a leaf
+** page. This macro evaluates to true if the leaf contains no terms, or
+** false if it contains at least one term.
+*/
+#define fts5LeafIsTermless(x) ((x)->szLeaf >= (x)->nn)
+
+#define fts5LeafTermOff(x, i) (fts5GetU16(&(x)->p[(x)->szLeaf + (i)*2]))
+
+#define fts5LeafFirstRowidOff(x) (fts5GetU16((x)->p))
+
+/*
+** poslist:
+**   Used by sqlite3Fts5IterPoslist() when the poslist needs to be buffered.
+**   There is no way to tell if this is populated or not.
+*/
+struct Fts5IndexIter {
+  Fts5Index *pIndex;              /* Index that owns this iterator */
+  Fts5Structure *pStruct;         /* Database structure for this iterator */
+  Fts5Buffer poslist;             /* Buffer containing current poslist */
+
+  int nSeg;                       /* Size of aSeg[] array */
+  int bRev;                       /* True to iterate in reverse order */
+  u8 bSkipEmpty;                  /* True to skip deleted entries */
+  u8 bEof;                        /* True at EOF */
+  u8 bFiltered;                   /* True if column-filter already applied */
+
+  i64 iSwitchRowid;               /* Firstest rowid of other than aFirst[1] */
+  Fts5CResult *aFirst;            /* Current merge state (see above) */
+  Fts5SegIter aSeg[1];            /* Array of segment iterators */
+};
+
+
+/*
+** An instance of the following type is used to iterate through the contents
+** of a doclist-index record.
+**
+** pData:
+**   Record containing the doclist-index data.
+**
+** bEof:
+**   Set to true once iterator has reached EOF.
+**
+** iOff:
+**   Set to the current offset within record pData.
+*/
+struct Fts5DlidxLvl {
+  Fts5Data *pData;              /* Data for current page of this level */
+  int iOff;                     /* Current offset into pData */
+  int bEof;                     /* At EOF already */
+  int iFirstOff;                /* Used by reverse iterators */
+
+  /* Output variables */
+  int iLeafPgno;                /* Page number of current leaf page */
+  i64 iRowid;                   /* First rowid on leaf iLeafPgno */
+};
+struct Fts5DlidxIter {
+  int nLvl;
+  int iSegid;
+  Fts5DlidxLvl aLvl[1];
+};
+
+static void fts5PutU16(u8 *aOut, u16 iVal){
+  aOut[0] = (iVal>>8);
+  aOut[1] = (iVal&0xFF);
+}
+
+static u16 fts5GetU16(const u8 *aIn){
+  return ((u16)aIn[0] << 8) + aIn[1];
+} 
+
+/*
+** Allocate and return a buffer at least nByte bytes in size.
+**
+** If an OOM error is encountered, return NULL and set the error code in
+** the Fts5Index handle passed as the first argument.
+*/
+static void *fts5IdxMalloc(Fts5Index *p, int nByte){
+  return sqlite3Fts5MallocZero(&p->rc, nByte);
+}
+
+/*
+** Compare the contents of the pLeft buffer with the pRight/nRight blob.
+**
+** Return -ve if pLeft is smaller than pRight, 0 if they are equal or
+** +ve if pRight is smaller than pLeft. In other words:
+**
+**     res = *pLeft - *pRight
+*/
+#ifdef SQLITE_DEBUG
+static int fts5BufferCompareBlob(
+  Fts5Buffer *pLeft,              /* Left hand side of comparison */
+  const u8 *pRight, int nRight    /* Right hand side of comparison */
+){
+  int nCmp = MIN(pLeft->n, nRight);
+  int res = memcmp(pLeft->p, pRight, nCmp);
+  return (res==0 ? (pLeft->n - nRight) : res);
+}
+#endif
+
+/*
+** Compare the contents of the two buffers using memcmp(). If one buffer
+** is a prefix of the other, it is considered the lesser.
+**
+** Return -ve if pLeft is smaller than pRight, 0 if they are equal or
+** +ve if pRight is smaller than pLeft. In other words:
+**
+**     res = *pLeft - *pRight
+*/
+static int fts5BufferCompare(Fts5Buffer *pLeft, Fts5Buffer *pRight){
+  int nCmp = MIN(pLeft->n, pRight->n);
+  int res = memcmp(pLeft->p, pRight->p, nCmp);
+  return (res==0 ? (pLeft->n - pRight->n) : res);
+}
+
+#ifdef SQLITE_DEBUG
+static int fts5BlobCompare(
+  const u8 *pLeft, int nLeft, 
+  const u8 *pRight, int nRight
+){
+  int nCmp = MIN(nLeft, nRight);
+  int res = memcmp(pLeft, pRight, nCmp);
+  return (res==0 ? (nLeft - nRight) : res);
+}
+#endif
+
+static int fts5LeafFirstTermOff(Fts5Data *pLeaf){
+  int ret;
+  fts5GetVarint32(&pLeaf->p[pLeaf->szLeaf], ret);
+  return ret;
+}
+
+/*
+** Close the read-only blob handle, if it is open.
+*/
+static void fts5CloseReader(Fts5Index *p){
+  if( p->pReader ){
+    sqlite3_blob *pReader = p->pReader;
+    p->pReader = 0;
+    sqlite3_blob_close(pReader);
+  }
+}
+
+
+/*
+** Retrieve a record from the %_data table.
+**
+** If an error occurs, NULL is returned and an error left in the 
+** Fts5Index object.
+*/
+static Fts5Data *fts5DataRead(Fts5Index *p, i64 iRowid){
+  Fts5Data *pRet = 0;
+  if( p->rc==SQLITE_OK ){
+    int rc = SQLITE_OK;
+
+    if( p->pReader ){
+      /* This call may return SQLITE_ABORT if there has been a savepoint
+      ** rollback since it was last used. In this case a new blob handle
+      ** is required.  */
+      sqlite3_blob *pBlob = p->pReader;
+      p->pReader = 0;
+      rc = sqlite3_blob_reopen(pBlob, iRowid);
+      assert( p->pReader==0 );
+      p->pReader = pBlob;
+      if( rc!=SQLITE_OK ){
+        fts5CloseReader(p);
+      }
+      if( rc==SQLITE_ABORT ) rc = SQLITE_OK;
+    }
+
+    /* If the blob handle is not open at this point, open it and seek 
+    ** to the requested entry.  */
+    if( p->pReader==0 && rc==SQLITE_OK ){
+      Fts5Config *pConfig = p->pConfig;
+      rc = sqlite3_blob_open(pConfig->db, 
+          pConfig->zDb, p->zDataTbl, "block", iRowid, 0, &p->pReader
+      );
+    }
+
+    /* If either of the sqlite3_blob_open() or sqlite3_blob_reopen() calls
+    ** above returned SQLITE_ERROR, return SQLITE_CORRUPT_VTAB instead.
+    ** All the reasons those functions might return SQLITE_ERROR - missing
+    ** table, missing row, non-blob/text in block column - indicate 
+    ** backing store corruption.  */
+    if( rc==SQLITE_ERROR ) rc = FTS5_CORRUPT;
+
+    if( rc==SQLITE_OK ){
+      u8 *aOut = 0;               /* Read blob data into this buffer */
+      int nByte = sqlite3_blob_bytes(p->pReader);
+      int nAlloc = sizeof(Fts5Data) + nByte + FTS5_DATA_PADDING;
+      pRet = (Fts5Data*)sqlite3_malloc(nAlloc);
+      if( pRet ){
+        pRet->nn = nByte;
+        aOut = pRet->p = (u8*)&pRet[1];
+      }else{
+        rc = SQLITE_NOMEM;
+      }
+
+      if( rc==SQLITE_OK ){
+        rc = sqlite3_blob_read(p->pReader, aOut, nByte, 0);
+      }
+      if( rc!=SQLITE_OK ){
+        sqlite3_free(pRet);
+        pRet = 0;
+      }else{
+        /* TODO1: Fix this */
+        pRet->szLeaf = fts5GetU16(&pRet->p[2]);
+      }
+    }
+    p->rc = rc;
+    p->nRead++;
+  }
+
+  assert( (pRet==0)==(p->rc!=SQLITE_OK) );
+  return pRet;
+}
+
+/*
+** Release a reference to data record returned by an earlier call to
+** fts5DataRead().
+*/
+static void fts5DataRelease(Fts5Data *pData){
+  sqlite3_free(pData);
+}
+
+static int fts5IndexPrepareStmt(
+  Fts5Index *p,
+  sqlite3_stmt **ppStmt,
+  char *zSql
+){
+  if( p->rc==SQLITE_OK ){
+    if( zSql ){
+      p->rc = sqlite3_prepare_v2(p->pConfig->db, zSql, -1, ppStmt, 0);
+    }else{
+      p->rc = SQLITE_NOMEM;
+    }
+  }
+  sqlite3_free(zSql);
+  return p->rc;
+}
+
+
+/*
+** INSERT OR REPLACE a record into the %_data table.
+*/
+static void fts5DataWrite(Fts5Index *p, i64 iRowid, const u8 *pData, int nData){
+  if( p->rc!=SQLITE_OK ) return;
+
+  if( p->pWriter==0 ){
+    Fts5Config *pConfig = p->pConfig;
+    fts5IndexPrepareStmt(p, &p->pWriter, sqlite3_mprintf(
+          "REPLACE INTO '%q'.'%q_data'(id, block) VALUES(?,?)", 
+          pConfig->zDb, pConfig->zName
+    ));
+    if( p->rc ) return;
+  }
+
+  sqlite3_bind_int64(p->pWriter, 1, iRowid);
+  sqlite3_bind_blob(p->pWriter, 2, pData, nData, SQLITE_STATIC);
+  sqlite3_step(p->pWriter);
+  p->rc = sqlite3_reset(p->pWriter);
+}
+
+/*
+** Execute the following SQL:
+**
+**     DELETE FROM %_data WHERE id BETWEEN $iFirst AND $iLast
+*/
+static void fts5DataDelete(Fts5Index *p, i64 iFirst, i64 iLast){
+  if( p->rc!=SQLITE_OK ) return;
+
+  if( p->pDeleter==0 ){
+    int rc;
+    Fts5Config *pConfig = p->pConfig;
+    char *zSql = sqlite3_mprintf(
+        "DELETE FROM '%q'.'%q_data' WHERE id>=? AND id<=?", 
+          pConfig->zDb, pConfig->zName
+    );
+    if( zSql==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &p->pDeleter, 0);
+      sqlite3_free(zSql);
+    }
+    if( rc!=SQLITE_OK ){
+      p->rc = rc;
+      return;
+    }
+  }
+
+  sqlite3_bind_int64(p->pDeleter, 1, iFirst);
+  sqlite3_bind_int64(p->pDeleter, 2, iLast);
+  sqlite3_step(p->pDeleter);
+  p->rc = sqlite3_reset(p->pDeleter);
+}
+
+/*
+** Remove all records associated with segment iSegid.
+*/
+static void fts5DataRemoveSegment(Fts5Index *p, int iSegid){
+  i64 iFirst = FTS5_SEGMENT_ROWID(iSegid, 0);
+  i64 iLast = FTS5_SEGMENT_ROWID(iSegid+1, 0)-1;
+  fts5DataDelete(p, iFirst, iLast);
+  if( p->pIdxDeleter==0 ){
+    Fts5Config *pConfig = p->pConfig;
+    fts5IndexPrepareStmt(p, &p->pIdxDeleter, sqlite3_mprintf(
+          "DELETE FROM '%q'.'%q_idx' WHERE segid=?",
+          pConfig->zDb, pConfig->zName
+    ));
+  }
+  if( p->rc==SQLITE_OK ){
+    sqlite3_bind_int(p->pIdxDeleter, 1, iSegid);
+    sqlite3_step(p->pIdxDeleter);
+    p->rc = sqlite3_reset(p->pIdxDeleter);
+  }
+}
+
+/*
+** Release a reference to an Fts5Structure object returned by an earlier 
+** call to fts5StructureRead() or fts5StructureDecode().
+*/
+static void fts5StructureRelease(Fts5Structure *pStruct){
+  if( pStruct && 0>=(--pStruct->nRef) ){
+    int i;
+    assert( pStruct->nRef==0 );
+    for(i=0; i<pStruct->nLevel; i++){
+      sqlite3_free(pStruct->aLevel[i].aSeg);
+    }
+    sqlite3_free(pStruct);
+  }
+}
+
+static void fts5StructureRef(Fts5Structure *pStruct){
+  pStruct->nRef++;
+}
+
+/*
+** Deserialize and return the structure record currently stored in serialized
+** form within buffer pData/nData.
+**
+** The Fts5Structure.aLevel[] and each Fts5StructureLevel.aSeg[] array
+** are over-allocated by one slot. This allows the structure contents
+** to be more easily edited.
+**
+** If an error occurs, *ppOut is set to NULL and an SQLite error code
+** returned. Otherwise, *ppOut is set to point to the new object and
+** SQLITE_OK returned.
+*/
+static int fts5StructureDecode(
+  const u8 *pData,                /* Buffer containing serialized structure */
+  int nData,                      /* Size of buffer pData in bytes */
+  int *piCookie,                  /* Configuration cookie value */
+  Fts5Structure **ppOut           /* OUT: Deserialized object */
+){
+  int rc = SQLITE_OK;
+  int i = 0;
+  int iLvl;
+  int nLevel = 0;
+  int nSegment = 0;
+  int nByte;                      /* Bytes of space to allocate at pRet */
+  Fts5Structure *pRet = 0;        /* Structure object to return */
+
+  /* Grab the cookie value */
+  if( piCookie ) *piCookie = sqlite3Fts5Get32(pData);
+  i = 4;
+
+  /* Read the total number of levels and segments from the start of the
+  ** structure record.  */
+  i += fts5GetVarint32(&pData[i], nLevel);
+  i += fts5GetVarint32(&pData[i], nSegment);
+  nByte = (
+      sizeof(Fts5Structure) +                    /* Main structure */
+      sizeof(Fts5StructureLevel) * (nLevel-1)    /* aLevel[] array */
+  );
+  pRet = (Fts5Structure*)sqlite3Fts5MallocZero(&rc, nByte);
+
+  if( pRet ){
+    pRet->nRef = 1;
+    pRet->nLevel = nLevel;
+    pRet->nSegment = nSegment;
+    i += sqlite3Fts5GetVarint(&pData[i], &pRet->nWriteCounter);
+
+    for(iLvl=0; rc==SQLITE_OK && iLvl<nLevel; iLvl++){
+      Fts5StructureLevel *pLvl = &pRet->aLevel[iLvl];
+      int nTotal;
+      int iSeg;
+
+      i += fts5GetVarint32(&pData[i], pLvl->nMerge);
+      i += fts5GetVarint32(&pData[i], nTotal);
+      assert( nTotal>=pLvl->nMerge );
+      pLvl->aSeg = (Fts5StructureSegment*)sqlite3Fts5MallocZero(&rc, 
+          nTotal * sizeof(Fts5StructureSegment)
+      );
+
+      if( rc==SQLITE_OK ){
+        pLvl->nSeg = nTotal;
+        for(iSeg=0; iSeg<nTotal; iSeg++){
+          i += fts5GetVarint32(&pData[i], pLvl->aSeg[iSeg].iSegid);
+          i += fts5GetVarint32(&pData[i], pLvl->aSeg[iSeg].pgnoFirst);
+          i += fts5GetVarint32(&pData[i], pLvl->aSeg[iSeg].pgnoLast);
+        }
+      }else{
+        fts5StructureRelease(pRet);
+        pRet = 0;
+      }
+    }
+  }
+
+  *ppOut = pRet;
+  return rc;
+}
+
+/*
+**
+*/
+static void fts5StructureAddLevel(int *pRc, Fts5Structure **ppStruct){
+  if( *pRc==SQLITE_OK ){
+    Fts5Structure *pStruct = *ppStruct;
+    int nLevel = pStruct->nLevel;
+    int nByte = (
+        sizeof(Fts5Structure) +                  /* Main structure */
+        sizeof(Fts5StructureLevel) * (nLevel+1)  /* aLevel[] array */
+    );
+
+    pStruct = sqlite3_realloc(pStruct, nByte);
+    if( pStruct ){
+      memset(&pStruct->aLevel[nLevel], 0, sizeof(Fts5StructureLevel));
+      pStruct->nLevel++;
+      *ppStruct = pStruct;
+    }else{
+      *pRc = SQLITE_NOMEM;
+    }
+  }
+}
+
+/*
+** Extend level iLvl so that there is room for at least nExtra more
+** segments.
+*/
+static void fts5StructureExtendLevel(
+  int *pRc, 
+  Fts5Structure *pStruct, 
+  int iLvl, 
+  int nExtra, 
+  int bInsert
+){
+  if( *pRc==SQLITE_OK ){
+    Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];
+    Fts5StructureSegment *aNew;
+    int nByte;
+
+    nByte = (pLvl->nSeg + nExtra) * sizeof(Fts5StructureSegment);
+    aNew = sqlite3_realloc(pLvl->aSeg, nByte);
+    if( aNew ){
+      if( bInsert==0 ){
+        memset(&aNew[pLvl->nSeg], 0, sizeof(Fts5StructureSegment) * nExtra);
+      }else{
+        int nMove = pLvl->nSeg * sizeof(Fts5StructureSegment);
+        memmove(&aNew[nExtra], aNew, nMove);
+        memset(aNew, 0, sizeof(Fts5StructureSegment) * nExtra);
+      }
+      pLvl->aSeg = aNew;
+    }else{
+      *pRc = SQLITE_NOMEM;
+    }
+  }
+}
+
+/*
+** Read, deserialize and return the structure record.
+**
+** The Fts5Structure.aLevel[] and each Fts5StructureLevel.aSeg[] array
+** are over-allocated as described for function fts5StructureDecode() 
+** above.
+**
+** If an error occurs, NULL is returned and an error code left in the
+** Fts5Index handle. If an error has already occurred when this function
+** is called, it is a no-op.
+*/
+static Fts5Structure *fts5StructureRead(Fts5Index *p){
+  Fts5Config *pConfig = p->pConfig;
+  Fts5Structure *pRet = 0;        /* Object to return */
+  int iCookie;                    /* Configuration cookie */
+  Fts5Data *pData;
+
+  pData = fts5DataRead(p, FTS5_STRUCTURE_ROWID);
+  if( p->rc ) return 0;
+  /* TODO: Do we need this if the leaf-index is appended? Probably... */
+  memset(&pData->p[pData->nn], 0, FTS5_DATA_PADDING);
+  p->rc = fts5StructureDecode(pData->p, pData->nn, &iCookie, &pRet);
+  if( p->rc==SQLITE_OK && pConfig->iCookie!=iCookie ){
+    p->rc = sqlite3Fts5ConfigLoad(pConfig, iCookie);
+  }
+
+  fts5DataRelease(pData);
+  if( p->rc!=SQLITE_OK ){
+    fts5StructureRelease(pRet);
+    pRet = 0;
+  }
+  return pRet;
+}
+
+/*
+** Return the total number of segments in index structure pStruct. This
+** function is only ever used as part of assert() conditions.
+*/
+#ifdef SQLITE_DEBUG
+static int fts5StructureCountSegments(Fts5Structure *pStruct){
+  int nSegment = 0;               /* Total number of segments */
+  if( pStruct ){
+    int iLvl;                     /* Used to iterate through levels */
+    for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){
+      nSegment += pStruct->aLevel[iLvl].nSeg;
+    }
+  }
+
+  return nSegment;
+}
+#endif
+
+/*
+** Serialize and store the "structure" record.
+**
+** If an error occurs, leave an error code in the Fts5Index object. If an
+** error has already occurred, this function is a no-op.
+*/
+static void fts5StructureWrite(Fts5Index *p, Fts5Structure *pStruct){
+  if( p->rc==SQLITE_OK ){
+    Fts5Buffer buf;               /* Buffer to serialize record into */
+    int iLvl;                     /* Used to iterate through levels */
+    int iCookie;                  /* Cookie value to store */
+
+    assert( pStruct->nSegment==fts5StructureCountSegments(pStruct) );
+    memset(&buf, 0, sizeof(Fts5Buffer));
+
+    /* Append the current configuration cookie */
+    iCookie = p->pConfig->iCookie;
+    if( iCookie<0 ) iCookie = 0;
+    fts5BufferAppend32(&p->rc, &buf, iCookie);
+
+    fts5BufferAppendVarint(&p->rc, &buf, pStruct->nLevel);
+    fts5BufferAppendVarint(&p->rc, &buf, pStruct->nSegment);
+    fts5BufferAppendVarint(&p->rc, &buf, (i64)pStruct->nWriteCounter);
+
+    for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){
+      int iSeg;                     /* Used to iterate through segments */
+      Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];
+      fts5BufferAppendVarint(&p->rc, &buf, pLvl->nMerge);
+      fts5BufferAppendVarint(&p->rc, &buf, pLvl->nSeg);
+      assert( pLvl->nMerge<=pLvl->nSeg );
+
+      for(iSeg=0; iSeg<pLvl->nSeg; iSeg++){
+        fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].iSegid);
+        fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].pgnoFirst);
+        fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].pgnoLast);
+      }
+    }
+
+    fts5DataWrite(p, FTS5_STRUCTURE_ROWID, buf.p, buf.n);
+    fts5BufferFree(&buf);
+  }
+}
+
+#if 0
+static void fts5DebugStructure(int*,Fts5Buffer*,Fts5Structure*);
+static void fts5PrintStructure(const char *zCaption, Fts5Structure *pStruct){
+  int rc = SQLITE_OK;
+  Fts5Buffer buf;
+  memset(&buf, 0, sizeof(buf));
+  fts5DebugStructure(&rc, &buf, pStruct);
+  fprintf(stdout, "%s: %s\n", zCaption, buf.p);
+  fflush(stdout);
+  fts5BufferFree(&buf);
+}
+#else
+# define fts5PrintStructure(x,y)
+#endif
+
+static int fts5SegmentSize(Fts5StructureSegment *pSeg){
+  return 1 + pSeg->pgnoLast - pSeg->pgnoFirst;
+}
+
+/*
+** Return a copy of index structure pStruct. Except, promote as many 
+** segments as possible to level iPromote. If an OOM occurs, NULL is 
+** returned.
+*/
+static void fts5StructurePromoteTo(
+  Fts5Index *p,
+  int iPromote,
+  int szPromote,
+  Fts5Structure *pStruct
+){
+  int il, is;
+  Fts5StructureLevel *pOut = &pStruct->aLevel[iPromote];
+
+  if( pOut->nMerge==0 ){
+    for(il=iPromote+1; il<pStruct->nLevel; il++){
+      Fts5StructureLevel *pLvl = &pStruct->aLevel[il];
+      if( pLvl->nMerge ) return;
+      for(is=pLvl->nSeg-1; is>=0; is--){
+        int sz = fts5SegmentSize(&pLvl->aSeg[is]);
+        if( sz>szPromote ) return;
+        fts5StructureExtendLevel(&p->rc, pStruct, iPromote, 1, 1);
+        if( p->rc ) return;
+        memcpy(pOut->aSeg, &pLvl->aSeg[is], sizeof(Fts5StructureSegment));
+        pOut->nSeg++;
+        pLvl->nSeg--;
+      }
+    }
+  }
+}
+
+/*
+** A new segment has just been written to level iLvl of index structure
+** pStruct. This function determines if any segments should be promoted
+** as a result. Segments are promoted in two scenarios:
+**
+**   a) If the segment just written is smaller than one or more segments
+**      within the previous populated level, it is promoted to the previous
+**      populated level.
+**
+**   b) If the segment just written is larger than the newest segment on
+**      the next populated level, then that segment, and any other adjacent
+**      segments that are also smaller than the one just written, are 
+**      promoted. 
+**
+** If one or more segments are promoted, the structure object is updated
+** to reflect this.
+*/
+static void fts5StructurePromote(
+  Fts5Index *p,                   /* FTS5 backend object */
+  int iLvl,                       /* Index level just updated */
+  Fts5Structure *pStruct          /* Index structure */
+){
+  if( p->rc==SQLITE_OK ){
+    int iTst;
+    int iPromote = -1;
+    int szPromote = 0;            /* Promote anything this size or smaller */
+    Fts5StructureSegment *pSeg;   /* Segment just written */
+    int szSeg;                    /* Size of segment just written */
+    int nSeg = pStruct->aLevel[iLvl].nSeg;
+
+    if( nSeg==0 ) return;
+    pSeg = &pStruct->aLevel[iLvl].aSeg[pStruct->aLevel[iLvl].nSeg-1];
+    szSeg = (1 + pSeg->pgnoLast - pSeg->pgnoFirst);
+
+    /* Check for condition (a) */
+    for(iTst=iLvl-1; iTst>=0 && pStruct->aLevel[iTst].nSeg==0; iTst--);
+    if( iTst>=0 ){
+      int i;
+      int szMax = 0;
+      Fts5StructureLevel *pTst = &pStruct->aLevel[iTst];
+      assert( pTst->nMerge==0 );
+      for(i=0; i<pTst->nSeg; i++){
+        int sz = pTst->aSeg[i].pgnoLast - pTst->aSeg[i].pgnoFirst + 1;
+        if( sz>szMax ) szMax = sz;
+      }
+      if( szMax>=szSeg ){
+        /* Condition (a) is true. Promote the newest segment on level 
+        ** iLvl to level iTst.  */
+        iPromote = iTst;
+        szPromote = szMax;
+      }
+    }
+
+    /* If condition (a) is not met, assume (b) is true. StructurePromoteTo()
+    ** is a no-op if it is not.  */
+    if( iPromote<0 ){
+      iPromote = iLvl;
+      szPromote = szSeg;
+    }
+    fts5StructurePromoteTo(p, iPromote, szPromote, pStruct);
+  }
+}
+
+
+/*
+** Advance the iterator passed as the only argument. If the end of the 
+** doclist-index page is reached, return non-zero.
+*/
+static int fts5DlidxLvlNext(Fts5DlidxLvl *pLvl){
+  Fts5Data *pData = pLvl->pData;
+
+  if( pLvl->iOff==0 ){
+    assert( pLvl->bEof==0 );
+    pLvl->iOff = 1;
+    pLvl->iOff += fts5GetVarint32(&pData->p[1], pLvl->iLeafPgno);
+    pLvl->iOff += fts5GetVarint(&pData->p[pLvl->iOff], (u64*)&pLvl->iRowid);
+    pLvl->iFirstOff = pLvl->iOff;
+  }else{
+    int iOff;
+    for(iOff=pLvl->iOff; iOff<pData->nn; iOff++){
+      if( pData->p[iOff] ) break; 
+    }
+
+    if( iOff<pData->nn ){
+      i64 iVal;
+      pLvl->iLeafPgno += (iOff - pLvl->iOff) + 1;
+      iOff += fts5GetVarint(&pData->p[iOff], (u64*)&iVal);
+      pLvl->iRowid += iVal;
+      pLvl->iOff = iOff;
+    }else{
+      pLvl->bEof = 1;
+    }
+  }
+
+  return pLvl->bEof;
+}
+
+/*
+** Advance the iterator passed as the only argument.
+*/
+static int fts5DlidxIterNextR(Fts5Index *p, Fts5DlidxIter *pIter, int iLvl){
+  Fts5DlidxLvl *pLvl = &pIter->aLvl[iLvl];
+
+  assert( iLvl<pIter->nLvl );
+  if( fts5DlidxLvlNext(pLvl) ){
+    if( (iLvl+1) < pIter->nLvl ){
+      fts5DlidxIterNextR(p, pIter, iLvl+1);
+      if( pLvl[1].bEof==0 ){
+        fts5DataRelease(pLvl->pData);
+        memset(pLvl, 0, sizeof(Fts5DlidxLvl));
+        pLvl->pData = fts5DataRead(p, 
+            FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)
+        );
+        if( pLvl->pData ) fts5DlidxLvlNext(pLvl);
+      }
+    }
+  }
+
+  return pIter->aLvl[0].bEof;
+}
+static int fts5DlidxIterNext(Fts5Index *p, Fts5DlidxIter *pIter){
+  return fts5DlidxIterNextR(p, pIter, 0);
+}
+
+/*
+** The iterator passed as the first argument has the following fields set
+** as follows. This function sets up the rest of the iterator so that it
+** points to the first rowid in the doclist-index.
+**
+**   pData:
+**     pointer to doclist-index record, 
+**
+** When this function is called pIter->iLeafPgno is the page number the
+** doclist is associated with (the one featuring the term).
+*/
+static int fts5DlidxIterFirst(Fts5DlidxIter *pIter){
+  int i;
+  for(i=0; i<pIter->nLvl; i++){
+    fts5DlidxLvlNext(&pIter->aLvl[i]);
+  }
+  return pIter->aLvl[0].bEof;
+}
+
+
+static int fts5DlidxIterEof(Fts5Index *p, Fts5DlidxIter *pIter){
+  return p->rc!=SQLITE_OK || pIter->aLvl[0].bEof;
+}
+
+static void fts5DlidxIterLast(Fts5Index *p, Fts5DlidxIter *pIter){
+  int i;
+
+  /* Advance each level to the last entry on the last page */
+  for(i=pIter->nLvl-1; p->rc==SQLITE_OK && i>=0; i--){
+    Fts5DlidxLvl *pLvl = &pIter->aLvl[i];
+    while( fts5DlidxLvlNext(pLvl)==0 );
+    pLvl->bEof = 0;
+
+    if( i>0 ){
+      Fts5DlidxLvl *pChild = &pLvl[-1];
+      fts5DataRelease(pChild->pData);
+      memset(pChild, 0, sizeof(Fts5DlidxLvl));
+      pChild->pData = fts5DataRead(p, 
+          FTS5_DLIDX_ROWID(pIter->iSegid, i-1, pLvl->iLeafPgno)
+      );
+    }
+  }
+}
+
+/*
+** Move the iterator passed as the only argument to the previous entry.
+*/
+static int fts5DlidxLvlPrev(Fts5DlidxLvl *pLvl){
+  int iOff = pLvl->iOff;
+
+  assert( pLvl->bEof==0 );
+  if( iOff<=pLvl->iFirstOff ){
+    pLvl->bEof = 1;
+  }else{
+    u8 *a = pLvl->pData->p;
+    i64 iVal;
+    int iLimit;
+    int ii;
+    int nZero = 0;
+
+    /* Currently iOff points to the first byte of a varint. This block 
+    ** decrements iOff until it points to the first byte of the previous 
+    ** varint. Taking care not to read any memory locations that occur
+    ** before the buffer in memory.  */
+    iLimit = (iOff>9 ? iOff-9 : 0);
+    for(iOff--; iOff>iLimit; iOff--){
+      if( (a[iOff-1] & 0x80)==0 ) break;
+    }
+
+    fts5GetVarint(&a[iOff], (u64*)&iVal);
+    pLvl->iRowid -= iVal;
+    pLvl->iLeafPgno--;
+
+    /* Skip backwards past any 0x00 varints. */
+    for(ii=iOff-1; ii>=pLvl->iFirstOff && a[ii]==0x00; ii--){
+      nZero++;
+    }
+    if( ii>=pLvl->iFirstOff && (a[ii] & 0x80) ){
+      /* The byte immediately before the last 0x00 byte has the 0x80 bit
+      ** set. So the last 0x00 is only a varint 0 if there are 8 more 0x80
+      ** bytes before a[ii]. */
+      int bZero = 0;              /* True if last 0x00 counts */
+      if( (ii-8)>=pLvl->iFirstOff ){
+        int j;
+        for(j=1; j<=8 && (a[ii-j] & 0x80); j++);
+        bZero = (j>8);
+      }
+      if( bZero==0 ) nZero--;
+    }
+    pLvl->iLeafPgno -= nZero;
+    pLvl->iOff = iOff - nZero;
+  }
+
+  return pLvl->bEof;
+}
+
+static int fts5DlidxIterPrevR(Fts5Index *p, Fts5DlidxIter *pIter, int iLvl){
+  Fts5DlidxLvl *pLvl = &pIter->aLvl[iLvl];
+
+  assert( iLvl<pIter->nLvl );
+  if( fts5DlidxLvlPrev(pLvl) ){
+    if( (iLvl+1) < pIter->nLvl ){
+      fts5DlidxIterPrevR(p, pIter, iLvl+1);
+      if( pLvl[1].bEof==0 ){
+        fts5DataRelease(pLvl->pData);
+        memset(pLvl, 0, sizeof(Fts5DlidxLvl));
+        pLvl->pData = fts5DataRead(p, 
+            FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)
+        );
+        if( pLvl->pData ){
+          while( fts5DlidxLvlNext(pLvl)==0 );
+          pLvl->bEof = 0;
+        }
+      }
+    }
+  }
+
+  return pIter->aLvl[0].bEof;
+}
+static int fts5DlidxIterPrev(Fts5Index *p, Fts5DlidxIter *pIter){
+  return fts5DlidxIterPrevR(p, pIter, 0);
+}
+
+/*
+** Free a doclist-index iterator object allocated by fts5DlidxIterInit().
+*/
+static void fts5DlidxIterFree(Fts5DlidxIter *pIter){
+  if( pIter ){
+    int i;
+    for(i=0; i<pIter->nLvl; i++){
+      fts5DataRelease(pIter->aLvl[i].pData);
+    }
+    sqlite3_free(pIter);
+  }
+}
+
+static Fts5DlidxIter *fts5DlidxIterInit(
+  Fts5Index *p,                   /* Fts5 Backend to iterate within */
+  int bRev,                       /* True for ORDER BY ASC */
+  int iSegid,                     /* Segment id */
+  int iLeafPg                     /* Leaf page number to load dlidx for */
+){
+  Fts5DlidxIter *pIter = 0;
+  int i;
+  int bDone = 0;
+
+  for(i=0; p->rc==SQLITE_OK && bDone==0; i++){
+    int nByte = sizeof(Fts5DlidxIter) + i * sizeof(Fts5DlidxLvl);
+    Fts5DlidxIter *pNew;
+
+    pNew = (Fts5DlidxIter*)sqlite3_realloc(pIter, nByte);
+    if( pNew==0 ){
+      p->rc = SQLITE_NOMEM;
+    }else{
+      i64 iRowid = FTS5_DLIDX_ROWID(iSegid, i, iLeafPg);
+      Fts5DlidxLvl *pLvl = &pNew->aLvl[i];
+      pIter = pNew;
+      memset(pLvl, 0, sizeof(Fts5DlidxLvl));
+      pLvl->pData = fts5DataRead(p, iRowid);
+      if( pLvl->pData && (pLvl->pData->p[0] & 0x0001)==0 ){
+        bDone = 1;
+      }
+      pIter->nLvl = i+1;
+    }
+  }
+
+  if( p->rc==SQLITE_OK ){
+    pIter->iSegid = iSegid;
+    if( bRev==0 ){
+      fts5DlidxIterFirst(pIter);
+    }else{
+      fts5DlidxIterLast(p, pIter);
+    }
+  }
+
+  if( p->rc!=SQLITE_OK ){
+    fts5DlidxIterFree(pIter);
+    pIter = 0;
+  }
+
+  return pIter;
+}
+
+static i64 fts5DlidxIterRowid(Fts5DlidxIter *pIter){
+  return pIter->aLvl[0].iRowid;
+}
+static int fts5DlidxIterPgno(Fts5DlidxIter *pIter){
+  return pIter->aLvl[0].iLeafPgno;
+}
+
+/*
+** Load the next leaf page into the segment iterator.
+*/
+static void fts5SegIterNextPage(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5SegIter *pIter              /* Iterator to advance to next page */
+){
+  Fts5Data *pLeaf;
+  Fts5StructureSegment *pSeg = pIter->pSeg;
+  fts5DataRelease(pIter->pLeaf);
+  pIter->iLeafPgno++;
+  if( pIter->pNextLeaf ){
+    pIter->pLeaf = pIter->pNextLeaf;
+    pIter->pNextLeaf = 0;
+  }else if( pIter->iLeafPgno<=pSeg->pgnoLast ){
+    pIter->pLeaf = fts5DataRead(p, 
+        FTS5_SEGMENT_ROWID(pSeg->iSegid, pIter->iLeafPgno)
+    );
+  }else{
+    pIter->pLeaf = 0;
+  }
+  pLeaf = pIter->pLeaf;
+
+  if( pLeaf ){
+    pIter->iPgidxOff = pLeaf->szLeaf;
+    if( fts5LeafIsTermless(pLeaf) ){
+      pIter->iEndofDoclist = pLeaf->nn+1;
+    }else{
+      pIter->iPgidxOff += fts5GetVarint32(&pLeaf->p[pIter->iPgidxOff],
+          pIter->iEndofDoclist
+      );
+    }
+  }
+}
+
+/*
+** Argument p points to a buffer containing a varint to be interpreted as a
+** position list size field. Read the varint and return the number of bytes
+** read. Before returning, set *pnSz to the number of bytes in the position
+** list, and *pbDel to true if the delete flag is set, or false otherwise.
+*/
+static int fts5GetPoslistSize(const u8 *p, int *pnSz, int *pbDel){
+  int nSz;
+  int n = 0;
+  fts5FastGetVarint32(p, n, nSz);
+  assert_nc( nSz>=0 );
+  *pnSz = nSz/2;
+  *pbDel = nSz & 0x0001;
+  return n;
+}
+
+/*
+** Fts5SegIter.iLeafOffset currently points to the first byte of a
+** position-list size field. Read the value of the field and store it
+** in the following variables:
+**
+**   Fts5SegIter.nPos
+**   Fts5SegIter.bDel
+**
+** Leave Fts5SegIter.iLeafOffset pointing to the first byte of the 
+** position list content (if any).
+*/
+static void fts5SegIterLoadNPos(Fts5Index *p, Fts5SegIter *pIter){
+  if( p->rc==SQLITE_OK ){
+    int iOff = pIter->iLeafOffset;  /* Offset to read at */
+    int nSz;
+    ASSERT_SZLEAF_OK(pIter->pLeaf);
+    fts5FastGetVarint32(pIter->pLeaf->p, iOff, nSz);
+    pIter->bDel = (nSz & 0x0001);
+    pIter->nPos = nSz>>1;
+    pIter->iLeafOffset = iOff;
+  }
+}
+
+static void fts5SegIterLoadRowid(Fts5Index *p, Fts5SegIter *pIter){
+  u8 *a = pIter->pLeaf->p;        /* Buffer to read data from */
+  int iOff = pIter->iLeafOffset;
+
+  ASSERT_SZLEAF_OK(pIter->pLeaf);
+  if( iOff>=pIter->pLeaf->szLeaf ){
+    fts5SegIterNextPage(p, pIter);
+    if( pIter->pLeaf==0 ){
+      if( p->rc==SQLITE_OK ) p->rc = FTS5_CORRUPT;
+      return;
+    }
+    iOff = 4;
+    a = pIter->pLeaf->p;
+  }
+  iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);
+  pIter->iLeafOffset = iOff;
+}
+
+/*
+** Fts5SegIter.iLeafOffset currently points to the first byte of the 
+** "nSuffix" field of a term. Function parameter nKeep contains the value
+** of the "nPrefix" field (if there was one - it is passed 0 if this is
+** the first term in the segment).
+**
+** This function populates:
+**
+**   Fts5SegIter.term
+**   Fts5SegIter.rowid
+**
+** accordingly and leaves (Fts5SegIter.iLeafOffset) set to the content of
+** the first position list. The position list belonging to document 
+** (Fts5SegIter.iRowid).
+*/
+static void fts5SegIterLoadTerm(Fts5Index *p, Fts5SegIter *pIter, int nKeep){
+  u8 *a = pIter->pLeaf->p;        /* Buffer to read data from */
+  int iOff = pIter->iLeafOffset;  /* Offset to read at */
+  int nNew;                       /* Bytes of new data */
+
+  iOff += fts5GetVarint32(&a[iOff], nNew);
+  pIter->term.n = nKeep;
+  fts5BufferAppendBlob(&p->rc, &pIter->term, nNew, &a[iOff]);
+  iOff += nNew;
+  pIter->iTermLeafOffset = iOff;
+  pIter->iTermLeafPgno = pIter->iLeafPgno;
+  pIter->iLeafOffset = iOff;
+
+  if( pIter->iPgidxOff>=pIter->pLeaf->nn ){
+    pIter->iEndofDoclist = pIter->pLeaf->nn+1;
+  }else{
+    int nExtra;
+    pIter->iPgidxOff += fts5GetVarint32(&a[pIter->iPgidxOff], nExtra);
+    pIter->iEndofDoclist += nExtra;
+  }
+
+  fts5SegIterLoadRowid(p, pIter);
+}
+
+/*
+** Initialize the iterator object pIter to iterate through the entries in
+** segment pSeg. The iterator is left pointing to the first entry when 
+** this function returns.
+**
+** If an error occurs, Fts5Index.rc is set to an appropriate error code. If 
+** an error has already occurred when this function is called, it is a no-op.
+*/
+static void fts5SegIterInit(
+  Fts5Index *p,                   /* FTS index object */
+  Fts5StructureSegment *pSeg,     /* Description of segment */
+  Fts5SegIter *pIter              /* Object to populate */
+){
+  if( pSeg->pgnoFirst==0 ){
+    /* This happens if the segment is being used as an input to an incremental
+    ** merge and all data has already been "trimmed". See function
+    ** fts5TrimSegments() for details. In this case leave the iterator empty.
+    ** The caller will see the (pIter->pLeaf==0) and assume the iterator is
+    ** at EOF already. */
+    assert( pIter->pLeaf==0 );
+    return;
+  }
+
+  if( p->rc==SQLITE_OK ){
+    memset(pIter, 0, sizeof(*pIter));
+    pIter->pSeg = pSeg;
+    pIter->iLeafPgno = pSeg->pgnoFirst-1;
+    fts5SegIterNextPage(p, pIter);
+  }
+
+  if( p->rc==SQLITE_OK ){
+    pIter->iLeafOffset = 4;
+    assert_nc( pIter->pLeaf->nn>4 );
+    assert( fts5LeafFirstTermOff(pIter->pLeaf)==4 );
+    pIter->iPgidxOff = pIter->pLeaf->szLeaf+1;
+    fts5SegIterLoadTerm(p, pIter, 0);
+    fts5SegIterLoadNPos(p, pIter);
+  }
+}
+
+/*
+** This function is only ever called on iterators created by calls to
+** Fts5IndexQuery() with the FTS5INDEX_QUERY_DESC flag set.
+**
+** The iterator is in an unusual state when this function is called: the
+** Fts5SegIter.iLeafOffset variable is set to the offset of the start of
+** the position-list size field for the first relevant rowid on the page.
+** Fts5SegIter.rowid is set, but nPos and bDel are not.
+**
+** This function advances the iterator so that it points to the last 
+** relevant rowid on the page and, if necessary, initializes the 
+** aRowidOffset[] and iRowidOffset variables. At this point the iterator
+** is in its regular state - Fts5SegIter.iLeafOffset points to the first
+** byte of the position list content associated with said rowid.
+*/
+static void fts5SegIterReverseInitPage(Fts5Index *p, Fts5SegIter *pIter){
+  int n = pIter->pLeaf->szLeaf;
+  int i = pIter->iLeafOffset;
+  u8 *a = pIter->pLeaf->p;
+  int iRowidOffset = 0;
+
+  if( n>pIter->iEndofDoclist ){
+    n = pIter->iEndofDoclist;
+  }
+
+  ASSERT_SZLEAF_OK(pIter->pLeaf);
+  while( 1 ){
+    i64 iDelta = 0;
+    int nPos;
+    int bDummy;
+
+    i += fts5GetPoslistSize(&a[i], &nPos, &bDummy);
+    i += nPos;
+    if( i>=n ) break;
+    i += fts5GetVarint(&a[i], (u64*)&iDelta);
+    pIter->iRowid += iDelta;
+
+    if( iRowidOffset>=pIter->nRowidOffset ){
+      int nNew = pIter->nRowidOffset + 8;
+      int *aNew = (int*)sqlite3_realloc(pIter->aRowidOffset, nNew*sizeof(int));
+      if( aNew==0 ){
+        p->rc = SQLITE_NOMEM;
+        break;
+      }
+      pIter->aRowidOffset = aNew;
+      pIter->nRowidOffset = nNew;
+    }
+
+    pIter->aRowidOffset[iRowidOffset++] = pIter->iLeafOffset;
+    pIter->iLeafOffset = i;
+  }
+  pIter->iRowidOffset = iRowidOffset;
+  fts5SegIterLoadNPos(p, pIter);
+}
+
+/*
+**
+*/
+static void fts5SegIterReverseNewPage(Fts5Index *p, Fts5SegIter *pIter){
+  assert( pIter->flags & FTS5_SEGITER_REVERSE );
+  assert( pIter->flags & FTS5_SEGITER_ONETERM );
+
+  fts5DataRelease(pIter->pLeaf);
+  pIter->pLeaf = 0;
+  while( p->rc==SQLITE_OK && pIter->iLeafPgno>pIter->iTermLeafPgno ){
+    Fts5Data *pNew;
+    pIter->iLeafPgno--;
+    pNew = fts5DataRead(p, FTS5_SEGMENT_ROWID(
+          pIter->pSeg->iSegid, pIter->iLeafPgno
+    ));
+    if( pNew ){
+      /* iTermLeafOffset may be equal to szLeaf if the term is the last
+      ** thing on the page - i.e. the first rowid is on the following page.
+      ** In this case leaf pIter->pLeaf==0, this iterator is at EOF. */
+      if( pIter->iLeafPgno==pIter->iTermLeafPgno 
+       && pIter->iTermLeafOffset<pNew->szLeaf 
+      ){
+        pIter->pLeaf = pNew;
+        pIter->iLeafOffset = pIter->iTermLeafOffset;
+      }else{
+        int iRowidOff;
+        iRowidOff = fts5LeafFirstRowidOff(pNew);
+        if( iRowidOff ){
+          pIter->pLeaf = pNew;
+          pIter->iLeafOffset = iRowidOff;
+        }
+      }
+
+      if( pIter->pLeaf ){
+        u8 *a = &pIter->pLeaf->p[pIter->iLeafOffset];
+        pIter->iLeafOffset += fts5GetVarint(a, (u64*)&pIter->iRowid);
+        break;
+      }else{
+        fts5DataRelease(pNew);
+      }
+    }
+  }
+
+  if( pIter->pLeaf ){
+    pIter->iEndofDoclist = pIter->pLeaf->nn+1;
+    fts5SegIterReverseInitPage(p, pIter);
+  }
+}
+
+/*
+** Return true if the iterator passed as the second argument currently
+** points to a delete marker. A delete marker is an entry with a 0 byte
+** position-list.
+*/
+static int fts5MultiIterIsEmpty(Fts5Index *p, Fts5IndexIter *pIter){
+  Fts5SegIter *pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];
+  return (p->rc==SQLITE_OK && pSeg->pLeaf && pSeg->nPos==0);
+}
+
+/*
+** Advance iterator pIter to the next entry. 
+**
+** If an error occurs, Fts5Index.rc is set to an appropriate error code. It 
+** is not considered an error if the iterator reaches EOF. If an error has 
+** already occurred when this function is called, it is a no-op.
+*/
+static void fts5SegIterNext(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5SegIter *pIter,             /* Iterator to advance */
+  int *pbNewTerm                  /* OUT: Set for new term */
+){
+  assert( pbNewTerm==0 || *pbNewTerm==0 );
+  if( p->rc==SQLITE_OK ){
+    if( pIter->flags & FTS5_SEGITER_REVERSE ){
+      assert( pIter->pNextLeaf==0 );
+      if( pIter->iRowidOffset>0 ){
+        u8 *a = pIter->pLeaf->p;
+        int iOff;
+        int nPos;
+        int bDummy;
+        i64 iDelta;
+
+        pIter->iRowidOffset--;
+        pIter->iLeafOffset = iOff = pIter->aRowidOffset[pIter->iRowidOffset];
+        iOff += fts5GetPoslistSize(&a[iOff], &nPos, &bDummy);
+        iOff += nPos;
+        fts5GetVarint(&a[iOff], (u64*)&iDelta);
+        pIter->iRowid -= iDelta;
+        fts5SegIterLoadNPos(p, pIter);
+      }else{
+        fts5SegIterReverseNewPage(p, pIter);
+      }
+    }else{
+      Fts5Data *pLeaf = pIter->pLeaf;
+      int iOff;
+      int bNewTerm = 0;
+      int nKeep = 0;
+
+      /* Search for the end of the position list within the current page. */
+      u8 *a = pLeaf->p;
+      int n = pLeaf->szLeaf;
+
+      ASSERT_SZLEAF_OK(pLeaf);
+      iOff = pIter->iLeafOffset + pIter->nPos;
+
+      if( iOff<n ){
+        /* The next entry is on the current page. */
+        assert_nc( iOff<=pIter->iEndofDoclist );
+        if( iOff>=pIter->iEndofDoclist ){
+          bNewTerm = 1;
+          if( iOff!=fts5LeafFirstTermOff(pLeaf) ){
+            iOff += fts5GetVarint32(&a[iOff], nKeep);
+          }
+        }else{
+          u64 iDelta;
+          iOff += sqlite3Fts5GetVarint(&a[iOff], &iDelta);
+          pIter->iRowid += iDelta;
+          assert_nc( iDelta>0 );
+        }
+        pIter->iLeafOffset = iOff;
+
+      }else if( pIter->pSeg==0 ){
+        const u8 *pList = 0;
+        const char *zTerm = 0;
+        int nList = 0;
+        if( 0==(pIter->flags & FTS5_SEGITER_ONETERM) ){
+          sqlite3Fts5HashScanNext(p->pHash);
+          sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &pList, &nList);
+        }
+        if( pList==0 ){
+          fts5DataRelease(pIter->pLeaf);
+          pIter->pLeaf = 0;
+        }else{
+          pIter->pLeaf->p = (u8*)pList;
+          pIter->pLeaf->nn = nList;
+          pIter->pLeaf->szLeaf = nList;
+          pIter->iEndofDoclist = nList+1;
+          sqlite3Fts5BufferSet(&p->rc, &pIter->term, strlen(zTerm), (u8*)zTerm);
+          pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);
+          if( pbNewTerm ) *pbNewTerm = 1;
+        }
+      }else{
+        iOff = 0;
+        /* Next entry is not on the current page */
+        while( iOff==0 ){
+          fts5SegIterNextPage(p, pIter);
+          pLeaf = pIter->pLeaf;
+          if( pLeaf==0 ) break;
+          ASSERT_SZLEAF_OK(pLeaf);
+          if( (iOff = fts5LeafFirstRowidOff(pLeaf)) && iOff<pLeaf->szLeaf ){
+            iOff += sqlite3Fts5GetVarint(&pLeaf->p[iOff], (u64*)&pIter->iRowid);
+            pIter->iLeafOffset = iOff;
+
+            if( pLeaf->nn>pLeaf->szLeaf ){
+              pIter->iPgidxOff = pLeaf->szLeaf + fts5GetVarint32(
+                  &pLeaf->p[pLeaf->szLeaf], pIter->iEndofDoclist
+              );
+            }
+
+          }
+          else if( pLeaf->nn>pLeaf->szLeaf ){
+            pIter->iPgidxOff = pLeaf->szLeaf + fts5GetVarint32(
+                &pLeaf->p[pLeaf->szLeaf], iOff
+            );
+            pIter->iLeafOffset = iOff;
+            pIter->iEndofDoclist = iOff;
+            bNewTerm = 1;
+          }
+          if( iOff>=pLeaf->szLeaf ){
+            p->rc = FTS5_CORRUPT;
+            return;
+          }
+        }
+      }
+
+      /* Check if the iterator is now at EOF. If so, return early. */
+      if( pIter->pLeaf ){
+        if( bNewTerm ){
+          if( pIter->flags & FTS5_SEGITER_ONETERM ){
+            fts5DataRelease(pIter->pLeaf);
+            pIter->pLeaf = 0;
+          }else{
+            fts5SegIterLoadTerm(p, pIter, nKeep);
+            fts5SegIterLoadNPos(p, pIter);
+            if( pbNewTerm ) *pbNewTerm = 1;
+          }
+        }else{
+          fts5SegIterLoadNPos(p, pIter);
+        }
+      }
+    }
+  }
+}
+
+#define SWAPVAL(T, a, b) { T tmp; tmp=a; a=b; b=tmp; }
+
+/*
+** Iterator pIter currently points to the first rowid in a doclist. This
+** function sets the iterator up so that iterates in reverse order through
+** the doclist.
+*/
+static void fts5SegIterReverse(Fts5Index *p, Fts5SegIter *pIter){
+  Fts5DlidxIter *pDlidx = pIter->pDlidx;
+  Fts5Data *pLast = 0;
+  int pgnoLast = 0;
+
+  if( pDlidx ){
+    int iSegid = pIter->pSeg->iSegid;
+    pgnoLast = fts5DlidxIterPgno(pDlidx);
+    pLast = fts5DataRead(p, FTS5_SEGMENT_ROWID(iSegid, pgnoLast));
+  }else{
+    Fts5Data *pLeaf = pIter->pLeaf;         /* Current leaf data */
+
+    /* Currently, Fts5SegIter.iLeafOffset points to the first byte of
+    ** position-list content for the current rowid. Back it up so that it
+    ** points to the start of the position-list size field. */
+    pIter->iLeafOffset -= sqlite3Fts5GetVarintLen(pIter->nPos*2+pIter->bDel);
+
+    /* If this condition is true then the largest rowid for the current
+    ** term may not be stored on the current page. So search forward to
+    ** see where said rowid really is.  */
+    if( pIter->iEndofDoclist>=pLeaf->szLeaf ){
+      int pgno;
+      Fts5StructureSegment *pSeg = pIter->pSeg;
+
+      /* The last rowid in the doclist may not be on the current page. Search
+      ** forward to find the page containing the last rowid.  */
+      for(pgno=pIter->iLeafPgno+1; !p->rc && pgno<=pSeg->pgnoLast; pgno++){
+        i64 iAbs = FTS5_SEGMENT_ROWID(pSeg->iSegid, pgno);
+        Fts5Data *pNew = fts5DataRead(p, iAbs);
+        if( pNew ){
+          int iRowid, bTermless;
+          iRowid = fts5LeafFirstRowidOff(pNew);
+          bTermless = fts5LeafIsTermless(pNew);
+          if( iRowid ){
+            SWAPVAL(Fts5Data*, pNew, pLast);
+            pgnoLast = pgno;
+          }
+          fts5DataRelease(pNew);
+          if( bTermless==0 ) break;
+        }
+      }
+    }
+  }
+
+  /* If pLast is NULL at this point, then the last rowid for this doclist
+  ** lies on the page currently indicated by the iterator. In this case 
+  ** pIter->iLeafOffset is already set to point to the position-list size
+  ** field associated with the first relevant rowid on the page.
+  **
+  ** Or, if pLast is non-NULL, then it is the page that contains the last
+  ** rowid. In this case configure the iterator so that it points to the
+  ** first rowid on this page.
+  */
+  if( pLast ){
+    int iOff;
+    fts5DataRelease(pIter->pLeaf);
+    pIter->pLeaf = pLast;
+    pIter->iLeafPgno = pgnoLast;
+    iOff = fts5LeafFirstRowidOff(pLast);
+    iOff += fts5GetVarint(&pLast->p[iOff], (u64*)&pIter->iRowid);
+    pIter->iLeafOffset = iOff;
+
+    if( fts5LeafIsTermless(pLast) ){
+      pIter->iEndofDoclist = pLast->nn+1;
+    }else{
+      pIter->iEndofDoclist = fts5LeafFirstTermOff(pLast);
+    }
+
+  }
+
+  fts5SegIterReverseInitPage(p, pIter);
+}
+
+/*
+** Iterator pIter currently points to the first rowid of a doclist.
+** There is a doclist-index associated with the final term on the current 
+** page. If the current term is the last term on the page, load the 
+** doclist-index from disk and initialize an iterator at (pIter->pDlidx).
+*/
+static void fts5SegIterLoadDlidx(Fts5Index *p, Fts5SegIter *pIter){
+  int iSeg = pIter->pSeg->iSegid;
+  int bRev = (pIter->flags & FTS5_SEGITER_REVERSE);
+  Fts5Data *pLeaf = pIter->pLeaf; /* Current leaf data */
+
+  assert( pIter->flags & FTS5_SEGITER_ONETERM );
+  assert( pIter->pDlidx==0 );
+
+  /* Check if the current doclist ends on this page. If it does, return
+  ** early without loading the doclist-index (as it belongs to a different
+  ** term. */
+  if( pIter->iTermLeafPgno==pIter->iLeafPgno 
+   && pIter->iEndofDoclist<pLeaf->szLeaf 
+  ){
+    return;
+  }
+
+  pIter->pDlidx = fts5DlidxIterInit(p, bRev, iSeg, pIter->iTermLeafPgno);
+}
+
+#define fts5IndexSkipVarint(a, iOff) {            \
+  int iEnd = iOff+9;                              \
+  while( (a[iOff++] & 0x80) && iOff<iEnd );       \
+}
+
+/*
+** The iterator object passed as the second argument currently contains
+** no valid values except for the Fts5SegIter.pLeaf member variable. This
+** function searches the leaf page for a term matching (pTerm/nTerm).
+**
+** If the specified term is found on the page, then the iterator is left
+** pointing to it. If argument bGe is zero and the term is not found,
+** the iterator is left pointing at EOF.
+**
+** If bGe is non-zero and the specified term is not found, then the
+** iterator is left pointing to the smallest term in the segment that
+** is larger than the specified term, even if this term is not on the
+** current page.
+*/
+static void fts5LeafSeek(
+  Fts5Index *p,                   /* Leave any error code here */
+  int bGe,                        /* True for a >= search */
+  Fts5SegIter *pIter,             /* Iterator to seek */
+  const u8 *pTerm, int nTerm      /* Term to search for */
+){
+  int iOff;
+  const u8 *a = pIter->pLeaf->p;
+  int szLeaf = pIter->pLeaf->szLeaf;
+  int n = pIter->pLeaf->nn;
+
+  int nMatch = 0;
+  int nKeep = 0;
+  int nNew = 0;
+  int iTermOff;
+  int iPgidx;                     /* Current offset in pgidx */
+  int bEndOfPage = 0;
+
+  assert( p->rc==SQLITE_OK );
+
+  iPgidx = szLeaf;
+  iPgidx += fts5GetVarint32(&a[iPgidx], iTermOff);
+  iOff = iTermOff;
+
+  while( 1 ){
+
+    /* Figure out how many new bytes are in this term */
+    fts5FastGetVarint32(a, iOff, nNew);
+    if( nKeep<nMatch ){
+      goto search_failed;
+    }
+
+    assert( nKeep>=nMatch );
+    if( nKeep==nMatch ){
+      int nCmp;
+      int i;
+      nCmp = MIN(nNew, nTerm-nMatch);
+      for(i=0; i<nCmp; i++){
+        if( a[iOff+i]!=pTerm[nMatch+i] ) break;
+      }
+      nMatch += i;
+
+      if( nTerm==nMatch ){
+        if( i==nNew ){
+          goto search_success;
+        }else{
+          goto search_failed;
+        }
+      }else if( i<nNew && a[iOff+i]>pTerm[nMatch] ){
+        goto search_failed;
+      }
+    }
+
+    if( iPgidx>=n ){
+      bEndOfPage = 1;
+      break;
+    }
+
+    iPgidx += fts5GetVarint32(&a[iPgidx], nKeep);
+    iTermOff += nKeep;
+    iOff = iTermOff;
+
+    /* Read the nKeep field of the next term. */
+    fts5FastGetVarint32(a, iOff, nKeep);
+  }
+
+ search_failed:
+  if( bGe==0 ){
+    fts5DataRelease(pIter->pLeaf);
+    pIter->pLeaf = 0;
+    return;
+  }else if( bEndOfPage ){
+    do {
+      fts5SegIterNextPage(p, pIter);
+      if( pIter->pLeaf==0 ) return;
+      a = pIter->pLeaf->p;
+      if( fts5LeafIsTermless(pIter->pLeaf)==0 ){
+        fts5GetVarint32(&pIter->pLeaf->p[pIter->pLeaf->szLeaf], iOff);
+        if( iOff<4 || iOff>=pIter->pLeaf->szLeaf ){
+          p->rc = FTS5_CORRUPT;
+        }else{
+          nKeep = 0;
+          iOff += fts5GetVarint32(&a[iOff], nNew);
+          break;
+        }
+      }
+    }while( 1 );
+  }
+
+ search_success:
+
+  pIter->iLeafOffset = iOff + nNew;
+  pIter->iTermLeafOffset = pIter->iLeafOffset;
+  pIter->iTermLeafPgno = pIter->iLeafPgno;
+
+  fts5BufferSet(&p->rc, &pIter->term, nKeep, pTerm);
+  fts5BufferAppendBlob(&p->rc, &pIter->term, nNew, &a[iOff]);
+
+  if( iPgidx>=n ){
+    pIter->iEndofDoclist = pIter->pLeaf->nn+1;
+  }else{
+    int nExtra;
+    iPgidx += fts5GetVarint32(&a[iPgidx], nExtra);
+    pIter->iEndofDoclist = iTermOff + nExtra;
+  }
+  pIter->iPgidxOff = iPgidx;
+
+  fts5SegIterLoadRowid(p, pIter);
+  fts5SegIterLoadNPos(p, pIter);
+}
+
+/*
+** Initialize the object pIter to point to term pTerm/nTerm within segment
+** pSeg. If there is no such term in the index, the iterator is set to EOF.
+**
+** If an error occurs, Fts5Index.rc is set to an appropriate error code. If 
+** an error has already occurred when this function is called, it is a no-op.
+*/
+static void fts5SegIterSeekInit(
+  Fts5Index *p,                   /* FTS5 backend */
+  Fts5Buffer *pBuf,               /* Buffer to use for loading pages */
+  const u8 *pTerm, int nTerm,     /* Term to seek to */
+  int flags,                      /* Mask of FTS5INDEX_XXX flags */
+  Fts5StructureSegment *pSeg,     /* Description of segment */
+  Fts5SegIter *pIter              /* Object to populate */
+){
+  int iPg = 1;
+  int bGe = (flags & FTS5INDEX_QUERY_SCAN);
+  int bDlidx = 0;                 /* True if there is a doclist-index */
+
+  static int nCall = 0;
+  nCall++;
+
+  assert( bGe==0 || (flags & FTS5INDEX_QUERY_DESC)==0 );
+  assert( pTerm && nTerm );
+  memset(pIter, 0, sizeof(*pIter));
+  pIter->pSeg = pSeg;
+
+  /* This block sets stack variable iPg to the leaf page number that may
+  ** contain term (pTerm/nTerm), if it is present in the segment. */
+  if( p->pIdxSelect==0 ){
+    Fts5Config *pConfig = p->pConfig;
+    fts5IndexPrepareStmt(p, &p->pIdxSelect, sqlite3_mprintf(
+          "SELECT pgno FROM '%q'.'%q_idx' WHERE "
+          "segid=? AND term<=? ORDER BY term DESC LIMIT 1",
+          pConfig->zDb, pConfig->zName
+    ));
+  }
+  if( p->rc ) return;
+  sqlite3_bind_int(p->pIdxSelect, 1, pSeg->iSegid);
+  sqlite3_bind_blob(p->pIdxSelect, 2, pTerm, nTerm, SQLITE_STATIC);
+  if( SQLITE_ROW==sqlite3_step(p->pIdxSelect) ){
+    i64 val = sqlite3_column_int(p->pIdxSelect, 0);
+    iPg = (int)(val>>1);
+    bDlidx = (val & 0x0001);
+  }
+  p->rc = sqlite3_reset(p->pIdxSelect);
+
+  if( iPg<pSeg->pgnoFirst ){
+    iPg = pSeg->pgnoFirst;
+    bDlidx = 0;
+  }
+
+  pIter->iLeafPgno = iPg - 1;
+  fts5SegIterNextPage(p, pIter);
+
+  if( pIter->pLeaf ){
+    fts5LeafSeek(p, bGe, pIter, pTerm, nTerm);
+  }
+
+  if( p->rc==SQLITE_OK && bGe==0 ){
+    pIter->flags |= FTS5_SEGITER_ONETERM;
+    if( pIter->pLeaf ){
+      if( flags & FTS5INDEX_QUERY_DESC ){
+        pIter->flags |= FTS5_SEGITER_REVERSE;
+      }
+      if( bDlidx ){
+        fts5SegIterLoadDlidx(p, pIter);
+      }
+      if( flags & FTS5INDEX_QUERY_DESC ){
+        fts5SegIterReverse(p, pIter);
+      }
+    }
+  }
+
+  /* Either:
+  **
+  **   1) an error has occurred, or
+  **   2) the iterator points to EOF, or
+  **   3) the iterator points to an entry with term (pTerm/nTerm), or
+  **   4) the FTS5INDEX_QUERY_SCAN flag was set and the iterator points
+  **      to an entry with a term greater than or equal to (pTerm/nTerm).
+  */
+  assert( p->rc!=SQLITE_OK                                          /* 1 */
+   || pIter->pLeaf==0                                               /* 2 */
+   || fts5BufferCompareBlob(&pIter->term, pTerm, nTerm)==0          /* 3 */
+   || (bGe && fts5BufferCompareBlob(&pIter->term, pTerm, nTerm)>0)  /* 4 */
+  );
+}
+
+/*
+** Initialize the object pIter to point to term pTerm/nTerm within the
+** in-memory hash table. If there is no such term in the hash-table, the 
+** iterator is set to EOF.
+**
+** If an error occurs, Fts5Index.rc is set to an appropriate error code. If 
+** an error has already occurred when this function is called, it is a no-op.
+*/
+static void fts5SegIterHashInit(
+  Fts5Index *p,                   /* FTS5 backend */
+  const u8 *pTerm, int nTerm,     /* Term to seek to */
+  int flags,                      /* Mask of FTS5INDEX_XXX flags */
+  Fts5SegIter *pIter              /* Object to populate */
+){
+  const u8 *pList = 0;
+  int nList = 0;
+  const u8 *z = 0;
+  int n = 0;
+
+  assert( p->pHash );
+  assert( p->rc==SQLITE_OK );
+
+  if( pTerm==0 || (flags & FTS5INDEX_QUERY_SCAN) ){
+    p->rc = sqlite3Fts5HashScanInit(p->pHash, (const char*)pTerm, nTerm);
+    sqlite3Fts5HashScanEntry(p->pHash, (const char**)&z, &pList, &nList);
+    n = (z ? strlen((const char*)z) : 0);
+  }else{
+    pIter->flags |= FTS5_SEGITER_ONETERM;
+    sqlite3Fts5HashQuery(p->pHash, (const char*)pTerm, nTerm, &pList, &nList);
+    z = pTerm;
+    n = nTerm;
+  }
+
+  if( pList ){
+    Fts5Data *pLeaf;
+    sqlite3Fts5BufferSet(&p->rc, &pIter->term, n, z);
+    pLeaf = fts5IdxMalloc(p, sizeof(Fts5Data));
+    if( pLeaf==0 ) return;
+    pLeaf->p = (u8*)pList;
+    pLeaf->nn = pLeaf->szLeaf = nList;
+    pIter->pLeaf = pLeaf;
+    pIter->iLeafOffset = fts5GetVarint(pLeaf->p, (u64*)&pIter->iRowid);
+    pIter->iEndofDoclist = pLeaf->nn+1;
+
+    if( flags & FTS5INDEX_QUERY_DESC ){
+      pIter->flags |= FTS5_SEGITER_REVERSE;
+      fts5SegIterReverseInitPage(p, pIter);
+    }else{
+      fts5SegIterLoadNPos(p, pIter);
+    }
+  }
+}
+
+/*
+** Zero the iterator passed as the only argument.
+*/
+static void fts5SegIterClear(Fts5SegIter *pIter){
+  fts5BufferFree(&pIter->term);
+  fts5DataRelease(pIter->pLeaf);
+  fts5DataRelease(pIter->pNextLeaf);
+  fts5DlidxIterFree(pIter->pDlidx);
+  sqlite3_free(pIter->aRowidOffset);
+  memset(pIter, 0, sizeof(Fts5SegIter));
+}
+
+#ifdef SQLITE_DEBUG
+
+/*
+** This function is used as part of the big assert() procedure implemented by
+** fts5AssertMultiIterSetup(). It ensures that the result currently stored
+** in *pRes is the correct result of comparing the current positions of the
+** two iterators.
+*/
+static void fts5AssertComparisonResult(
+  Fts5IndexIter *pIter, 
+  Fts5SegIter *p1,
+  Fts5SegIter *p2,
+  Fts5CResult *pRes
+){
+  int i1 = p1 - pIter->aSeg;
+  int i2 = p2 - pIter->aSeg;
+
+  if( p1->pLeaf || p2->pLeaf ){
+    if( p1->pLeaf==0 ){
+      assert( pRes->iFirst==i2 );
+    }else if( p2->pLeaf==0 ){
+      assert( pRes->iFirst==i1 );
+    }else{
+      int nMin = MIN(p1->term.n, p2->term.n);
+      int res = memcmp(p1->term.p, p2->term.p, nMin);
+      if( res==0 ) res = p1->term.n - p2->term.n;
+
+      if( res==0 ){
+        assert( pRes->bTermEq==1 );
+        assert( p1->iRowid!=p2->iRowid );
+        res = ((p1->iRowid > p2->iRowid)==pIter->bRev) ? -1 : 1;
+      }else{
+        assert( pRes->bTermEq==0 );
+      }
+
+      if( res<0 ){
+        assert( pRes->iFirst==i1 );
+      }else{
+        assert( pRes->iFirst==i2 );
+      }
+    }
+  }
+}
+
+/*
+** This function is a no-op unless SQLITE_DEBUG is defined when this module
+** is compiled. In that case, this function is essentially an assert() 
+** statement used to verify that the contents of the pIter->aFirst[] array
+** are correct.
+*/
+static void fts5AssertMultiIterSetup(Fts5Index *p, Fts5IndexIter *pIter){
+  if( p->rc==SQLITE_OK ){
+    Fts5SegIter *pFirst = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
+    int i;
+
+    assert( (pFirst->pLeaf==0)==pIter->bEof );
+
+    /* Check that pIter->iSwitchRowid is set correctly. */
+    for(i=0; i<pIter->nSeg; i++){
+      Fts5SegIter *p1 = &pIter->aSeg[i];
+      assert( p1==pFirst 
+           || p1->pLeaf==0 
+           || fts5BufferCompare(&pFirst->term, &p1->term) 
+           || p1->iRowid==pIter->iSwitchRowid
+           || (p1->iRowid<pIter->iSwitchRowid)==pIter->bRev
+      );
+    }
+
+    for(i=0; i<pIter->nSeg; i+=2){
+      Fts5SegIter *p1 = &pIter->aSeg[i];
+      Fts5SegIter *p2 = &pIter->aSeg[i+1];
+      Fts5CResult *pRes = &pIter->aFirst[(pIter->nSeg + i) / 2];
+      fts5AssertComparisonResult(pIter, p1, p2, pRes);
+    }
+
+    for(i=1; i<(pIter->nSeg / 2); i+=2){
+      Fts5SegIter *p1 = &pIter->aSeg[ pIter->aFirst[i*2].iFirst ];
+      Fts5SegIter *p2 = &pIter->aSeg[ pIter->aFirst[i*2+1].iFirst ];
+      Fts5CResult *pRes = &pIter->aFirst[i];
+      fts5AssertComparisonResult(pIter, p1, p2, pRes);
+    }
+  }
+}
+#else
+# define fts5AssertMultiIterSetup(x,y)
+#endif
+
+/*
+** Do the comparison necessary to populate pIter->aFirst[iOut].
+**
+** If the returned value is non-zero, then it is the index of an entry
+** in the pIter->aSeg[] array that is (a) not at EOF, and (b) pointing
+** to a key that is a duplicate of another, higher priority, 
+** segment-iterator in the pSeg->aSeg[] array.
+*/
+static int fts5MultiIterDoCompare(Fts5IndexIter *pIter, int iOut){
+  int i1;                         /* Index of left-hand Fts5SegIter */
+  int i2;                         /* Index of right-hand Fts5SegIter */
+  int iRes;
+  Fts5SegIter *p1;                /* Left-hand Fts5SegIter */
+  Fts5SegIter *p2;                /* Right-hand Fts5SegIter */
+  Fts5CResult *pRes = &pIter->aFirst[iOut];
+
+  assert( iOut<pIter->nSeg && iOut>0 );
+  assert( pIter->bRev==0 || pIter->bRev==1 );
+
+  if( iOut>=(pIter->nSeg/2) ){
+    i1 = (iOut - pIter->nSeg/2) * 2;
+    i2 = i1 + 1;
+  }else{
+    i1 = pIter->aFirst[iOut*2].iFirst;
+    i2 = pIter->aFirst[iOut*2+1].iFirst;
+  }
+  p1 = &pIter->aSeg[i1];
+  p2 = &pIter->aSeg[i2];
+
+  pRes->bTermEq = 0;
+  if( p1->pLeaf==0 ){           /* If p1 is at EOF */
+    iRes = i2;
+  }else if( p2->pLeaf==0 ){     /* If p2 is at EOF */
+    iRes = i1;
+  }else{
+    int res = fts5BufferCompare(&p1->term, &p2->term);
+    if( res==0 ){
+      assert( i2>i1 );
+      assert( i2!=0 );
+      pRes->bTermEq = 1;
+      if( p1->iRowid==p2->iRowid ){
+        p1->bDel = p2->bDel;
+        return i2;
+      }
+      res = ((p1->iRowid > p2->iRowid)==pIter->bRev) ? -1 : +1;
+    }
+    assert( res!=0 );
+    if( res<0 ){
+      iRes = i1;
+    }else{
+      iRes = i2;
+    }
+  }
+
+  pRes->iFirst = iRes;
+  return 0;
+}
+
+/*
+** Move the seg-iter so that it points to the first rowid on page iLeafPgno.
+** It is an error if leaf iLeafPgno does not exist or contains no rowids.
+*/
+static void fts5SegIterGotoPage(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5SegIter *pIter,             /* Iterator to advance */
+  int iLeafPgno
+){
+  assert( iLeafPgno>pIter->iLeafPgno );
+
+  if( iLeafPgno>pIter->pSeg->pgnoLast ){
+    p->rc = FTS5_CORRUPT;
+  }else{
+    fts5DataRelease(pIter->pNextLeaf);
+    pIter->pNextLeaf = 0;
+    pIter->iLeafPgno = iLeafPgno-1;
+    fts5SegIterNextPage(p, pIter);
+    assert( p->rc!=SQLITE_OK || pIter->iLeafPgno==iLeafPgno );
+
+    if( p->rc==SQLITE_OK ){
+      int iOff;
+      u8 *a = pIter->pLeaf->p;
+      int n = pIter->pLeaf->szLeaf;
+
+      iOff = fts5LeafFirstRowidOff(pIter->pLeaf);
+      if( iOff<4 || iOff>=n ){
+        p->rc = FTS5_CORRUPT;
+      }else{
+        iOff += fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);
+        pIter->iLeafOffset = iOff;
+        fts5SegIterLoadNPos(p, pIter);
+      }
+    }
+  }
+}
+
+/*
+** Advance the iterator passed as the second argument until it is at or 
+** past rowid iFrom. Regardless of the value of iFrom, the iterator is
+** always advanced at least once.
+*/
+static void fts5SegIterNextFrom(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5SegIter *pIter,             /* Iterator to advance */
+  i64 iMatch                      /* Advance iterator at least this far */
+){
+  int bRev = (pIter->flags & FTS5_SEGITER_REVERSE);
+  Fts5DlidxIter *pDlidx = pIter->pDlidx;
+  int iLeafPgno = pIter->iLeafPgno;
+  int bMove = 1;
+
+  assert( pIter->flags & FTS5_SEGITER_ONETERM );
+  assert( pIter->pDlidx );
+  assert( pIter->pLeaf );
+
+  if( bRev==0 ){
+    while( !fts5DlidxIterEof(p, pDlidx) && iMatch>fts5DlidxIterRowid(pDlidx) ){
+      iLeafPgno = fts5DlidxIterPgno(pDlidx);
+      fts5DlidxIterNext(p, pDlidx);
+    }
+    assert_nc( iLeafPgno>=pIter->iLeafPgno || p->rc );
+    if( iLeafPgno>pIter->iLeafPgno ){
+      fts5SegIterGotoPage(p, pIter, iLeafPgno);
+      bMove = 0;
+    }
+  }else{
+    assert( pIter->pNextLeaf==0 );
+    assert( iMatch<pIter->iRowid );
+    while( !fts5DlidxIterEof(p, pDlidx) && iMatch<fts5DlidxIterRowid(pDlidx) ){
+      fts5DlidxIterPrev(p, pDlidx);
+    }
+    iLeafPgno = fts5DlidxIterPgno(pDlidx);
+
+    assert( fts5DlidxIterEof(p, pDlidx) || iLeafPgno<=pIter->iLeafPgno );
+
+    if( iLeafPgno<pIter->iLeafPgno ){
+      pIter->iLeafPgno = iLeafPgno+1;
+      fts5SegIterReverseNewPage(p, pIter);
+      bMove = 0;
+    }
+  }
+
+  do{
+    if( bMove ) fts5SegIterNext(p, pIter, 0);
+    if( pIter->pLeaf==0 ) break;
+    if( bRev==0 && pIter->iRowid>=iMatch ) break;
+    if( bRev!=0 && pIter->iRowid<=iMatch ) break;
+    bMove = 1;
+  }while( p->rc==SQLITE_OK );
+}
+
+
+/*
+** Free the iterator object passed as the second argument.
+*/
+static void fts5MultiIterFree(Fts5Index *p, Fts5IndexIter *pIter){
+  if( pIter ){
+    int i;
+    for(i=0; i<pIter->nSeg; i++){
+      fts5SegIterClear(&pIter->aSeg[i]);
+    }
+    fts5StructureRelease(pIter->pStruct);
+    fts5BufferFree(&pIter->poslist);
+    sqlite3_free(pIter);
+  }
+}
+
+static void fts5MultiIterAdvanced(
+  Fts5Index *p,                   /* FTS5 backend to iterate within */
+  Fts5IndexIter *pIter,           /* Iterator to update aFirst[] array for */
+  int iChanged,                   /* Index of sub-iterator just advanced */
+  int iMinset                     /* Minimum entry in aFirst[] to set */
+){
+  int i;
+  for(i=(pIter->nSeg+iChanged)/2; i>=iMinset && p->rc==SQLITE_OK; i=i/2){
+    int iEq;
+    if( (iEq = fts5MultiIterDoCompare(pIter, i)) ){
+      fts5SegIterNext(p, &pIter->aSeg[iEq], 0);
+      i = pIter->nSeg + iEq;
+    }
+  }
+}
+
+/*
+** Sub-iterator iChanged of iterator pIter has just been advanced. It still
+** points to the same term though - just a different rowid. This function
+** attempts to update the contents of the pIter->aFirst[] accordingly.
+** If it does so successfully, 0 is returned. Otherwise 1.
+**
+** If non-zero is returned, the caller should call fts5MultiIterAdvanced()
+** on the iterator instead. That function does the same as this one, except
+** that it deals with more complicated cases as well.
+*/ 
+static int fts5MultiIterAdvanceRowid(
+  Fts5Index *p,                   /* FTS5 backend to iterate within */
+  Fts5IndexIter *pIter,           /* Iterator to update aFirst[] array for */
+  int iChanged                    /* Index of sub-iterator just advanced */
+){
+  Fts5SegIter *pNew = &pIter->aSeg[iChanged];
+
+  if( pNew->iRowid==pIter->iSwitchRowid
+   || (pNew->iRowid<pIter->iSwitchRowid)==pIter->bRev
+  ){
+    int i;
+    Fts5SegIter *pOther = &pIter->aSeg[iChanged ^ 0x0001];
+    pIter->iSwitchRowid = pIter->bRev ? SMALLEST_INT64 : LARGEST_INT64;
+    for(i=(pIter->nSeg+iChanged)/2; 1; i=i/2){
+      Fts5CResult *pRes = &pIter->aFirst[i];
+
+      assert( pNew->pLeaf );
+      assert( pRes->bTermEq==0 || pOther->pLeaf );
+
+      if( pRes->bTermEq ){
+        if( pNew->iRowid==pOther->iRowid ){
+          return 1;
+        }else if( (pOther->iRowid>pNew->iRowid)==pIter->bRev ){
+          pIter->iSwitchRowid = pOther->iRowid;
+          pNew = pOther;
+        }else if( (pOther->iRowid>pIter->iSwitchRowid)==pIter->bRev ){
+          pIter->iSwitchRowid = pOther->iRowid;
+        }
+      }
+      pRes->iFirst = (pNew - pIter->aSeg);
+      if( i==1 ) break;
+
+      pOther = &pIter->aSeg[ pIter->aFirst[i ^ 0x0001].iFirst ];
+    }
+  }
+
+  return 0;
+}
+
+/*
+** Set the pIter->bEof variable based on the state of the sub-iterators.
+*/
+static void fts5MultiIterSetEof(Fts5IndexIter *pIter){
+  Fts5SegIter *pSeg = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
+  pIter->bEof = pSeg->pLeaf==0;
+  pIter->iSwitchRowid = pSeg->iRowid;
+}
+
+/*
+** Move the iterator to the next entry. 
+**
+** If an error occurs, an error code is left in Fts5Index.rc. It is not 
+** considered an error if the iterator reaches EOF, or if it is already at 
+** EOF when this function is called.
+*/
+static void fts5MultiIterNext(
+  Fts5Index *p, 
+  Fts5IndexIter *pIter,
+  int bFrom,                      /* True if argument iFrom is valid */
+  i64 iFrom                       /* Advance at least as far as this */
+){
+  if( p->rc==SQLITE_OK ){
+    int bUseFrom = bFrom;
+    do {
+      int iFirst = pIter->aFirst[1].iFirst;
+      int bNewTerm = 0;
+      Fts5SegIter *pSeg = &pIter->aSeg[iFirst];
+      assert( p->rc==SQLITE_OK );
+      if( bUseFrom && pSeg->pDlidx ){
+        fts5SegIterNextFrom(p, pSeg, iFrom);
+      }else{
+        fts5SegIterNext(p, pSeg, &bNewTerm);
+      }
+
+      if( pSeg->pLeaf==0 || bNewTerm 
+       || fts5MultiIterAdvanceRowid(p, pIter, iFirst)
+      ){
+        fts5MultiIterAdvanced(p, pIter, iFirst, 1);
+        fts5MultiIterSetEof(pIter);
+      }
+      fts5AssertMultiIterSetup(p, pIter);
+
+      bUseFrom = 0;
+    }while( pIter->bSkipEmpty && fts5MultiIterIsEmpty(p, pIter) );
+  }
+}
+
+static Fts5IndexIter *fts5MultiIterAlloc(
+  Fts5Index *p,                   /* FTS5 backend to iterate within */
+  int nSeg
+){
+  Fts5IndexIter *pNew;
+  int nSlot;                      /* Power of two >= nSeg */
+
+  for(nSlot=2; nSlot<nSeg; nSlot=nSlot*2);
+  pNew = fts5IdxMalloc(p, 
+      sizeof(Fts5IndexIter) +             /* pNew */
+      sizeof(Fts5SegIter) * (nSlot-1) +   /* pNew->aSeg[] */
+      sizeof(Fts5CResult) * nSlot         /* pNew->aFirst[] */
+  );
+  if( pNew ){
+    pNew->nSeg = nSlot;
+    pNew->aFirst = (Fts5CResult*)&pNew->aSeg[nSlot];
+    pNew->pIndex = p;
+  }
+  return pNew;
+}
+
+/*
+** Allocate a new Fts5IndexIter object.
+**
+** The new object will be used to iterate through data in structure pStruct.
+** If iLevel is -ve, then all data in all segments is merged. Or, if iLevel
+** is zero or greater, data from the first nSegment segments on level iLevel
+** is merged.
+**
+** The iterator initially points to the first term/rowid entry in the 
+** iterated data.
+*/
+static void fts5MultiIterNew(
+  Fts5Index *p,                   /* FTS5 backend to iterate within */
+  Fts5Structure *pStruct,         /* Structure of specific index */
+  int bSkipEmpty,                 /* True to ignore delete-keys */
+  int flags,                      /* FTS5INDEX_QUERY_XXX flags */
+  const u8 *pTerm, int nTerm,     /* Term to seek to (or NULL/0) */
+  int iLevel,                     /* Level to iterate (-1 for all) */
+  int nSegment,                   /* Number of segments to merge (iLevel>=0) */
+  Fts5IndexIter **ppOut           /* New object */
+){
+  int nSeg = 0;                   /* Number of segment-iters in use */
+  int iIter = 0;                  /* */
+  int iSeg;                       /* Used to iterate through segments */
+  Fts5Buffer buf = {0,0,0};       /* Buffer used by fts5SegIterSeekInit() */
+  Fts5StructureLevel *pLvl;
+  Fts5IndexIter *pNew;
+
+  assert( (pTerm==0 && nTerm==0) || iLevel<0 );
+
+  /* Allocate space for the new multi-seg-iterator. */
+  if( p->rc==SQLITE_OK ){
+    if( iLevel<0 ){
+      assert( pStruct->nSegment==fts5StructureCountSegments(pStruct) );
+      nSeg = pStruct->nSegment;
+      nSeg += (p->pHash ? 1 : 0);
+    }else{
+      nSeg = MIN(pStruct->aLevel[iLevel].nSeg, nSegment);
+    }
+  }
+  *ppOut = pNew = fts5MultiIterAlloc(p, nSeg);
+  if( pNew==0 ) return;
+  pNew->bRev = (0!=(flags & FTS5INDEX_QUERY_DESC));
+  pNew->bSkipEmpty = bSkipEmpty;
+  pNew->pStruct = pStruct;
+  fts5StructureRef(pStruct);
+
+  /* Initialize each of the component segment iterators. */
+  if( iLevel<0 ){
+    Fts5StructureLevel *pEnd = &pStruct->aLevel[pStruct->nLevel];
+    if( p->pHash ){
+      /* Add a segment iterator for the current contents of the hash table. */
+      Fts5SegIter *pIter = &pNew->aSeg[iIter++];
+      fts5SegIterHashInit(p, pTerm, nTerm, flags, pIter);
+    }
+    for(pLvl=&pStruct->aLevel[0]; pLvl<pEnd; pLvl++){
+      for(iSeg=pLvl->nSeg-1; iSeg>=0; iSeg--){
+        Fts5StructureSegment *pSeg = &pLvl->aSeg[iSeg];
+        Fts5SegIter *pIter = &pNew->aSeg[iIter++];
+        if( pTerm==0 ){
+          fts5SegIterInit(p, pSeg, pIter);
+        }else{
+          fts5SegIterSeekInit(p, &buf, pTerm, nTerm, flags, pSeg, pIter);
+        }
+      }
+    }
+  }else{
+    pLvl = &pStruct->aLevel[iLevel];
+    for(iSeg=nSeg-1; iSeg>=0; iSeg--){
+      fts5SegIterInit(p, &pLvl->aSeg[iSeg], &pNew->aSeg[iIter++]);
+    }
+  }
+  assert( iIter==nSeg );
+
+  /* If the above was successful, each component iterators now points 
+  ** to the first entry in its segment. In this case initialize the 
+  ** aFirst[] array. Or, if an error has occurred, free the iterator
+  ** object and set the output variable to NULL.  */
+  if( p->rc==SQLITE_OK ){
+    for(iIter=pNew->nSeg-1; iIter>0; iIter--){
+      int iEq;
+      if( (iEq = fts5MultiIterDoCompare(pNew, iIter)) ){
+        fts5SegIterNext(p, &pNew->aSeg[iEq], 0);
+        fts5MultiIterAdvanced(p, pNew, iEq, iIter);
+      }
+    }
+    fts5MultiIterSetEof(pNew);
+    fts5AssertMultiIterSetup(p, pNew);
+
+    if( pNew->bSkipEmpty && fts5MultiIterIsEmpty(p, pNew) ){
+      fts5MultiIterNext(p, pNew, 0, 0);
+    }
+  }else{
+    fts5MultiIterFree(p, pNew);
+    *ppOut = 0;
+  }
+  fts5BufferFree(&buf);
+}
+
+/*
+** Create an Fts5IndexIter that iterates through the doclist provided
+** as the second argument.
+*/
+static void fts5MultiIterNew2(
+  Fts5Index *p,                   /* FTS5 backend to iterate within */
+  Fts5Data *pData,                /* Doclist to iterate through */
+  int bDesc,                      /* True for descending rowid order */
+  Fts5IndexIter **ppOut           /* New object */
+){
+  Fts5IndexIter *pNew;
+  pNew = fts5MultiIterAlloc(p, 2);
+  if( pNew ){
+    Fts5SegIter *pIter = &pNew->aSeg[1];
+
+    pNew->bFiltered = 1;
+    pIter->flags = FTS5_SEGITER_ONETERM;
+    if( pData->szLeaf>0 ){
+      pIter->pLeaf = pData;
+      pIter->iLeafOffset = fts5GetVarint(pData->p, (u64*)&pIter->iRowid);
+      pIter->iEndofDoclist = pData->nn;
+      pNew->aFirst[1].iFirst = 1;
+      if( bDesc ){
+        pNew->bRev = 1;
+        pIter->flags |= FTS5_SEGITER_REVERSE;
+        fts5SegIterReverseInitPage(p, pIter);
+      }else{
+        fts5SegIterLoadNPos(p, pIter);
+      }
+      pData = 0;
+    }else{
+      pNew->bEof = 1;
+    }
+
+    *ppOut = pNew;
+  }
+
+  fts5DataRelease(pData);
+}
+
+/*
+** Return true if the iterator is at EOF or if an error has occurred. 
+** False otherwise.
+*/
+static int fts5MultiIterEof(Fts5Index *p, Fts5IndexIter *pIter){
+  assert( p->rc 
+      || (pIter->aSeg[ pIter->aFirst[1].iFirst ].pLeaf==0)==pIter->bEof 
+  );
+  return (p->rc || pIter->bEof);
+}
+
+/*
+** Return the rowid of the entry that the iterator currently points
+** to. If the iterator points to EOF when this function is called the
+** results are undefined.
+*/
+static i64 fts5MultiIterRowid(Fts5IndexIter *pIter){
+  assert( pIter->aSeg[ pIter->aFirst[1].iFirst ].pLeaf );
+  return pIter->aSeg[ pIter->aFirst[1].iFirst ].iRowid;
+}
+
+/*
+** Move the iterator to the next entry at or following iMatch.
+*/
+static void fts5MultiIterNextFrom(
+  Fts5Index *p, 
+  Fts5IndexIter *pIter, 
+  i64 iMatch
+){
+  while( 1 ){
+    i64 iRowid;
+    fts5MultiIterNext(p, pIter, 1, iMatch);
+    if( fts5MultiIterEof(p, pIter) ) break;
+    iRowid = fts5MultiIterRowid(pIter);
+    if( pIter->bRev==0 && iRowid>=iMatch ) break;
+    if( pIter->bRev!=0 && iRowid<=iMatch ) break;
+  }
+}
+
+/*
+** Return a pointer to a buffer containing the term associated with the 
+** entry that the iterator currently points to.
+*/
+static const u8 *fts5MultiIterTerm(Fts5IndexIter *pIter, int *pn){
+  Fts5SegIter *p = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
+  *pn = p->term.n;
+  return p->term.p;
+}
+
+static void fts5ChunkIterate(
+  Fts5Index *p,                   /* Index object */
+  Fts5SegIter *pSeg,              /* Poslist of this iterator */
+  void *pCtx,                     /* Context pointer for xChunk callback */
+  void (*xChunk)(Fts5Index*, void*, const u8*, int)
+){
+  int nRem = pSeg->nPos;          /* Number of bytes still to come */
+  Fts5Data *pData = 0;
+  u8 *pChunk = &pSeg->pLeaf->p[pSeg->iLeafOffset];
+  int nChunk = MIN(nRem, pSeg->pLeaf->szLeaf - pSeg->iLeafOffset);
+  int pgno = pSeg->iLeafPgno;
+  int pgnoSave = 0;
+
+  if( (pSeg->flags & FTS5_SEGITER_REVERSE)==0 ){
+    pgnoSave = pgno+1;
+  }
+
+  while( 1 ){
+    xChunk(p, pCtx, pChunk, nChunk);
+    nRem -= nChunk;
+    fts5DataRelease(pData);
+    if( nRem<=0 ){
+      break;
+    }else{
+      pgno++;
+      pData = fts5DataRead(p, FTS5_SEGMENT_ROWID(pSeg->pSeg->iSegid, pgno));
+      if( pData==0 ) break;
+      pChunk = &pData->p[4];
+      nChunk = MIN(nRem, pData->szLeaf - 4);
+      if( pgno==pgnoSave ){
+        assert( pSeg->pNextLeaf==0 );
+        pSeg->pNextLeaf = pData;
+        pData = 0;
+      }
+    }
+  }
+}
+
+
+
+/*
+** Allocate a new segment-id for the structure pStruct. The new segment
+** id must be between 1 and 65335 inclusive, and must not be used by 
+** any currently existing segment. If a free segment id cannot be found,
+** SQLITE_FULL is returned.
+**
+** If an error has already occurred, this function is a no-op. 0 is 
+** returned in this case.
+*/
+static int fts5AllocateSegid(Fts5Index *p, Fts5Structure *pStruct){
+  int iSegid = 0;
+
+  if( p->rc==SQLITE_OK ){
+    if( pStruct->nSegment>=FTS5_MAX_SEGMENT ){
+      p->rc = SQLITE_FULL;
+    }else{
+      while( iSegid==0 ){
+        int iLvl, iSeg;
+        sqlite3_randomness(sizeof(u32), (void*)&iSegid);
+        iSegid = iSegid & ((1 << FTS5_DATA_ID_B)-1);
+        for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){
+          for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){
+            if( iSegid==pStruct->aLevel[iLvl].aSeg[iSeg].iSegid ){
+              iSegid = 0;
+            }
+          }
+        }
+      }
+    }
+  }
+
+  return iSegid;
+}
+
+/*
+** Discard all data currently cached in the hash-tables.
+*/
+static void fts5IndexDiscardData(Fts5Index *p){
+  assert( p->pHash || p->nPendingData==0 );
+  if( p->pHash ){
+    sqlite3Fts5HashClear(p->pHash);
+    p->nPendingData = 0;
+  }
+}
+
+/*
+** Return the size of the prefix, in bytes, that buffer (nNew/pNew) shares
+** with buffer (nOld/pOld).
+*/
+static int fts5PrefixCompress(
+  int nOld, const u8 *pOld,
+  int nNew, const u8 *pNew
+){
+  int i;
+  assert( fts5BlobCompare(pOld, nOld, pNew, nNew)<0 );
+  for(i=0; i<nOld; i++){
+    if( pOld[i]!=pNew[i] ) break;
+  }
+  return i;
+}
+
+static void fts5WriteDlidxClear(
+  Fts5Index *p, 
+  Fts5SegWriter *pWriter,
+  int bFlush                      /* If true, write dlidx to disk */
+){
+  int i;
+  assert( bFlush==0 || (pWriter->nDlidx>0 && pWriter->aDlidx[0].buf.n>0) );
+  for(i=0; i<pWriter->nDlidx; i++){
+    Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[i];
+    if( pDlidx->buf.n==0 ) break;
+    if( bFlush ){
+      assert( pDlidx->pgno!=0 );
+      fts5DataWrite(p, 
+          FTS5_DLIDX_ROWID(pWriter->iSegid, i, pDlidx->pgno),
+          pDlidx->buf.p, pDlidx->buf.n
+      );
+    }
+    sqlite3Fts5BufferZero(&pDlidx->buf);
+    pDlidx->bPrevValid = 0;
+  }
+}
+
+/*
+** Grow the pWriter->aDlidx[] array to at least nLvl elements in size.
+** Any new array elements are zeroed before returning.
+*/
+static int fts5WriteDlidxGrow(
+  Fts5Index *p,
+  Fts5SegWriter *pWriter,
+  int nLvl
+){
+  if( p->rc==SQLITE_OK && nLvl>=pWriter->nDlidx ){
+    Fts5DlidxWriter *aDlidx = (Fts5DlidxWriter*)sqlite3_realloc(
+        pWriter->aDlidx, sizeof(Fts5DlidxWriter) * nLvl
+    );
+    if( aDlidx==0 ){
+      p->rc = SQLITE_NOMEM;
+    }else{
+      int nByte = sizeof(Fts5DlidxWriter) * (nLvl - pWriter->nDlidx);
+      memset(&aDlidx[pWriter->nDlidx], 0, nByte);
+      pWriter->aDlidx = aDlidx;
+      pWriter->nDlidx = nLvl;
+    }
+  }
+  return p->rc;
+}
+
+/*
+** If the current doclist-index accumulating in pWriter->aDlidx[] is large
+** enough, flush it to disk and return 1. Otherwise discard it and return
+** zero.
+*/
+static int fts5WriteFlushDlidx(Fts5Index *p, Fts5SegWriter *pWriter){
+  int bFlag = 0;
+
+  /* If there were FTS5_MIN_DLIDX_SIZE or more empty leaf pages written
+  ** to the database, also write the doclist-index to disk.  */
+  if( pWriter->aDlidx[0].buf.n>0 && pWriter->nEmpty>=FTS5_MIN_DLIDX_SIZE ){
+    bFlag = 1;
+  }
+  fts5WriteDlidxClear(p, pWriter, bFlag);
+  pWriter->nEmpty = 0;
+  return bFlag;
+}
+
+/*
+** This function is called whenever processing of the doclist for the 
+** last term on leaf page (pWriter->iBtPage) is completed. 
+**
+** The doclist-index for that term is currently stored in-memory within the
+** Fts5SegWriter.aDlidx[] array. If it is large enough, this function
+** writes it out to disk. Or, if it is too small to bother with, discards
+** it.
+**
+** Fts5SegWriter.btterm currently contains the first term on page iBtPage.
+*/
+static void fts5WriteFlushBtree(Fts5Index *p, Fts5SegWriter *pWriter){
+  int bFlag;
+
+  assert( pWriter->iBtPage || pWriter->nEmpty==0 );
+  if( pWriter->iBtPage==0 ) return;
+  bFlag = fts5WriteFlushDlidx(p, pWriter);
+
+  if( p->rc==SQLITE_OK ){
+    const char *z = (pWriter->btterm.n>0?(const char*)pWriter->btterm.p:"");
+    /* The following was already done in fts5WriteInit(): */
+    /* sqlite3_bind_int(p->pIdxWriter, 1, pWriter->iSegid); */
+    sqlite3_bind_blob(p->pIdxWriter, 2, z, pWriter->btterm.n, SQLITE_STATIC);
+    sqlite3_bind_int64(p->pIdxWriter, 3, bFlag + ((i64)pWriter->iBtPage<<1));
+    sqlite3_step(p->pIdxWriter);
+    p->rc = sqlite3_reset(p->pIdxWriter);
+  }
+  pWriter->iBtPage = 0;
+}
+
+/*
+** This is called once for each leaf page except the first that contains
+** at least one term. Argument (nTerm/pTerm) is the split-key - a term that
+** is larger than all terms written to earlier leaves, and equal to or
+** smaller than the first term on the new leaf.
+**
+** If an error occurs, an error code is left in Fts5Index.rc. If an error
+** has already occurred when this function is called, it is a no-op.
+*/
+static void fts5WriteBtreeTerm(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5SegWriter *pWriter,         /* Writer object */
+  int nTerm, const u8 *pTerm      /* First term on new page */
+){
+  fts5WriteFlushBtree(p, pWriter);
+  fts5BufferSet(&p->rc, &pWriter->btterm, nTerm, pTerm);
+  pWriter->iBtPage = pWriter->writer.pgno;
+}
+
+/*
+** This function is called when flushing a leaf page that contains no
+** terms at all to disk.
+*/
+static void fts5WriteBtreeNoTerm(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5SegWriter *pWriter          /* Writer object */
+){
+  /* If there were no rowids on the leaf page either and the doclist-index
+  ** has already been started, append an 0x00 byte to it.  */
+  if( pWriter->bFirstRowidInPage && pWriter->aDlidx[0].buf.n>0 ){
+    Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[0];
+    assert( pDlidx->bPrevValid );
+    sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, 0);
+  }
+
+  /* Increment the "number of sequential leaves without a term" counter. */
+  pWriter->nEmpty++;
+}
+
+static i64 fts5DlidxExtractFirstRowid(Fts5Buffer *pBuf){
+  i64 iRowid;
+  int iOff;
+
+  iOff = 1 + fts5GetVarint(&pBuf->p[1], (u64*)&iRowid);
+  fts5GetVarint(&pBuf->p[iOff], (u64*)&iRowid);
+  return iRowid;
+}
+
+/*
+** Rowid iRowid has just been appended to the current leaf page. It is the
+** first on the page. This function appends an appropriate entry to the current
+** doclist-index.
+*/
+static void fts5WriteDlidxAppend(
+  Fts5Index *p, 
+  Fts5SegWriter *pWriter, 
+  i64 iRowid
+){
+  int i;
+  int bDone = 0;
+
+  for(i=0; p->rc==SQLITE_OK && bDone==0; i++){
+    i64 iVal;
+    Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[i];
+
+    if( pDlidx->buf.n>=p->pConfig->pgsz ){
+      /* The current doclist-index page is full. Write it to disk and push
+      ** a copy of iRowid (which will become the first rowid on the next
+      ** doclist-index leaf page) up into the next level of the b-tree 
+      ** hierarchy. If the node being flushed is currently the root node,
+      ** also push its first rowid upwards. */
+      pDlidx->buf.p[0] = 0x01;    /* Not the root node */
+      fts5DataWrite(p, 
+          FTS5_DLIDX_ROWID(pWriter->iSegid, i, pDlidx->pgno),
+          pDlidx->buf.p, pDlidx->buf.n
+      );
+      fts5WriteDlidxGrow(p, pWriter, i+2);
+      pDlidx = &pWriter->aDlidx[i];
+      if( p->rc==SQLITE_OK && pDlidx[1].buf.n==0 ){
+        i64 iFirst = fts5DlidxExtractFirstRowid(&pDlidx->buf);
+
+        /* This was the root node. Push its first rowid up to the new root. */
+        pDlidx[1].pgno = pDlidx->pgno;
+        sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, 0);
+        sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, pDlidx->pgno);
+        sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, iFirst);
+        pDlidx[1].bPrevValid = 1;
+        pDlidx[1].iPrev = iFirst;
+      }
+
+      sqlite3Fts5BufferZero(&pDlidx->buf);
+      pDlidx->bPrevValid = 0;
+      pDlidx->pgno++;
+    }else{
+      bDone = 1;
+    }
+
+    if( pDlidx->bPrevValid ){
+      iVal = iRowid - pDlidx->iPrev;
+    }else{
+      i64 iPgno = (i==0 ? pWriter->writer.pgno : pDlidx[-1].pgno);
+      assert( pDlidx->buf.n==0 );
+      sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, !bDone);
+      sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, iPgno);
+      iVal = iRowid;
+    }
+
+    sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, iVal);
+    pDlidx->bPrevValid = 1;
+    pDlidx->iPrev = iRowid;
+  }
+}
+
+static void fts5WriteFlushLeaf(Fts5Index *p, Fts5SegWriter *pWriter){
+  static const u8 zero[] = { 0x00, 0x00, 0x00, 0x00 };
+  Fts5PageWriter *pPage = &pWriter->writer;
+  i64 iRowid;
+
+  assert( (pPage->pgidx.n==0)==(pWriter->bFirstTermInPage) );
+
+  /* Set the szLeaf header field. */
+  assert( 0==fts5GetU16(&pPage->buf.p[2]) );
+  fts5PutU16(&pPage->buf.p[2], pPage->buf.n);
+
+  if( pWriter->bFirstTermInPage ){
+    /* No term was written to this page. */
+    assert( pPage->pgidx.n==0 );
+    fts5WriteBtreeNoTerm(p, pWriter);
+  }else{
+    /* Append the pgidx to the page buffer. Set the szLeaf header field. */
+    fts5BufferAppendBlob(&p->rc, &pPage->buf, pPage->pgidx.n, pPage->pgidx.p);
+  }
+
+  /* Write the page out to disk */
+  iRowid = FTS5_SEGMENT_ROWID(pWriter->iSegid, pPage->pgno);
+  fts5DataWrite(p, iRowid, pPage->buf.p, pPage->buf.n);
+
+  /* Initialize the next page. */
+  fts5BufferZero(&pPage->buf);
+  fts5BufferZero(&pPage->pgidx);
+  fts5BufferAppendBlob(&p->rc, &pPage->buf, 4, zero);
+  pPage->iPrevPgidx = 0;
+  pPage->pgno++;
+
+  /* Increase the leaves written counter */
+  pWriter->nLeafWritten++;
+
+  /* The new leaf holds no terms or rowids */
+  pWriter->bFirstTermInPage = 1;
+  pWriter->bFirstRowidInPage = 1;
+}
+
+/*
+** Append term pTerm/nTerm to the segment being written by the writer passed
+** as the second argument.
+**
+** If an error occurs, set the Fts5Index.rc error code. If an error has 
+** already occurred, this function is a no-op.
+*/
+static void fts5WriteAppendTerm(
+  Fts5Index *p, 
+  Fts5SegWriter *pWriter,
+  int nTerm, const u8 *pTerm 
+){
+  int nPrefix;                    /* Bytes of prefix compression for term */
+  Fts5PageWriter *pPage = &pWriter->writer;
+  Fts5Buffer *pPgidx = &pWriter->writer.pgidx;
+
+  assert( p->rc==SQLITE_OK );
+  assert( pPage->buf.n>=4 );
+  assert( pPage->buf.n>4 || pWriter->bFirstTermInPage );
+
+  /* If the current leaf page is full, flush it to disk. */
+  if( (pPage->buf.n + pPgidx->n + nTerm + 2)>=p->pConfig->pgsz ){
+    if( pPage->buf.n>4 ){
+      fts5WriteFlushLeaf(p, pWriter);
+    }
+    fts5BufferGrow(&p->rc, &pPage->buf, nTerm+FTS5_DATA_PADDING);
+  }
+  
+  /* TODO1: Updating pgidx here. */
+  pPgidx->n += sqlite3Fts5PutVarint(
+      &pPgidx->p[pPgidx->n], pPage->buf.n - pPage->iPrevPgidx
+  );
+  pPage->iPrevPgidx = pPage->buf.n;
+#if 0
+  fts5PutU16(&pPgidx->p[pPgidx->n], pPage->buf.n);
+  pPgidx->n += 2;
+#endif
+
+  if( pWriter->bFirstTermInPage ){
+    nPrefix = 0;
+    if( pPage->pgno!=1 ){
+      /* This is the first term on a leaf that is not the leftmost leaf in
+      ** the segment b-tree. In this case it is necessary to add a term to
+      ** the b-tree hierarchy that is (a) larger than the largest term 
+      ** already written to the segment and (b) smaller than or equal to
+      ** this term. In other words, a prefix of (pTerm/nTerm) that is one
+      ** byte longer than the longest prefix (pTerm/nTerm) shares with the
+      ** previous term. 
+      **
+      ** Usually, the previous term is available in pPage->term. The exception
+      ** is if this is the first term written in an incremental-merge step.
+      ** In this case the previous term is not available, so just write a
+      ** copy of (pTerm/nTerm) into the parent node. This is slightly
+      ** inefficient, but still correct.  */
+      int n = nTerm;
+      if( pPage->term.n ){
+        n = 1 + fts5PrefixCompress(pPage->term.n, pPage->term.p, nTerm, pTerm);
+      }
+      fts5WriteBtreeTerm(p, pWriter, n, pTerm);
+      pPage = &pWriter->writer;
+    }
+  }else{
+    nPrefix = fts5PrefixCompress(pPage->term.n, pPage->term.p, nTerm, pTerm);
+    fts5BufferAppendVarint(&p->rc, &pPage->buf, nPrefix);
+  }
+
+  /* Append the number of bytes of new data, then the term data itself
+  ** to the page. */
+  fts5BufferAppendVarint(&p->rc, &pPage->buf, nTerm - nPrefix);
+  fts5BufferAppendBlob(&p->rc, &pPage->buf, nTerm - nPrefix, &pTerm[nPrefix]);
+
+  /* Update the Fts5PageWriter.term field. */
+  fts5BufferSet(&p->rc, &pPage->term, nTerm, pTerm);
+  pWriter->bFirstTermInPage = 0;
+
+  pWriter->bFirstRowidInPage = 0;
+  pWriter->bFirstRowidInDoclist = 1;
+
+  assert( p->rc || (pWriter->nDlidx>0 && pWriter->aDlidx[0].buf.n==0) );
+  pWriter->aDlidx[0].pgno = pPage->pgno;
+}
+
+/*
+** Append a rowid and position-list size field to the writers output. 
+*/
+static void fts5WriteAppendRowid(
+  Fts5Index *p, 
+  Fts5SegWriter *pWriter,
+  i64 iRowid,
+  int nPos
+){
+  if( p->rc==SQLITE_OK ){
+    Fts5PageWriter *pPage = &pWriter->writer;
+
+    if( (pPage->buf.n + pPage->pgidx.n)>=p->pConfig->pgsz ){
+      fts5WriteFlushLeaf(p, pWriter);
+    }
+
+    /* If this is to be the first rowid written to the page, set the 
+    ** rowid-pointer in the page-header. Also append a value to the dlidx
+    ** buffer, in case a doclist-index is required.  */
+    if( pWriter->bFirstRowidInPage ){
+      fts5PutU16(pPage->buf.p, pPage->buf.n);
+      fts5WriteDlidxAppend(p, pWriter, iRowid);
+    }
+
+    /* Write the rowid. */
+    if( pWriter->bFirstRowidInDoclist || pWriter->bFirstRowidInPage ){
+      fts5BufferAppendVarint(&p->rc, &pPage->buf, iRowid);
+    }else{
+      assert( p->rc || iRowid>pWriter->iPrevRowid );
+      fts5BufferAppendVarint(&p->rc, &pPage->buf, iRowid - pWriter->iPrevRowid);
+    }
+    pWriter->iPrevRowid = iRowid;
+    pWriter->bFirstRowidInDoclist = 0;
+    pWriter->bFirstRowidInPage = 0;
+
+    fts5BufferAppendVarint(&p->rc, &pPage->buf, nPos);
+  }
+}
+
+static void fts5WriteAppendPoslistData(
+  Fts5Index *p, 
+  Fts5SegWriter *pWriter, 
+  const u8 *aData, 
+  int nData
+){
+  Fts5PageWriter *pPage = &pWriter->writer;
+  const u8 *a = aData;
+  int n = nData;
+  
+  assert( p->pConfig->pgsz>0 );
+  while( p->rc==SQLITE_OK 
+     && (pPage->buf.n + pPage->pgidx.n + n)>=p->pConfig->pgsz 
+  ){
+    int nReq = p->pConfig->pgsz - pPage->buf.n - pPage->pgidx.n;
+    int nCopy = 0;
+    while( nCopy<nReq ){
+      i64 dummy;
+      nCopy += fts5GetVarint(&a[nCopy], (u64*)&dummy);
+    }
+    fts5BufferAppendBlob(&p->rc, &pPage->buf, nCopy, a);
+    a += nCopy;
+    n -= nCopy;
+    fts5WriteFlushLeaf(p, pWriter);
+  }
+  if( n>0 ){
+    fts5BufferAppendBlob(&p->rc, &pPage->buf, n, a);
+  }
+}
+
+/*
+** Flush any data cached by the writer object to the database. Free any
+** allocations associated with the writer.
+*/
+static void fts5WriteFinish(
+  Fts5Index *p, 
+  Fts5SegWriter *pWriter,         /* Writer object */
+  int *pnLeaf                     /* OUT: Number of leaf pages in b-tree */
+){
+  int i;
+  Fts5PageWriter *pLeaf = &pWriter->writer;
+  if( p->rc==SQLITE_OK ){
+    assert( pLeaf->pgno>=1 );
+    if( pLeaf->buf.n>4 ){
+      fts5WriteFlushLeaf(p, pWriter);
+    }
+    *pnLeaf = pLeaf->pgno-1;
+    fts5WriteFlushBtree(p, pWriter);
+  }
+  fts5BufferFree(&pLeaf->term);
+  fts5BufferFree(&pLeaf->buf);
+  fts5BufferFree(&pLeaf->pgidx);
+  fts5BufferFree(&pWriter->btterm);
+
+  for(i=0; i<pWriter->nDlidx; i++){
+    sqlite3Fts5BufferFree(&pWriter->aDlidx[i].buf);
+  }
+  sqlite3_free(pWriter->aDlidx);
+}
+
+static void fts5WriteInit(
+  Fts5Index *p, 
+  Fts5SegWriter *pWriter, 
+  int iSegid
+){
+  const int nBuffer = p->pConfig->pgsz + FTS5_DATA_PADDING;
+
+  memset(pWriter, 0, sizeof(Fts5SegWriter));
+  pWriter->iSegid = iSegid;
+
+  fts5WriteDlidxGrow(p, pWriter, 1);
+  pWriter->writer.pgno = 1;
+  pWriter->bFirstTermInPage = 1;
+  pWriter->iBtPage = 1;
+
+  /* Grow the two buffers to pgsz + padding bytes in size. */
+  fts5BufferGrow(&p->rc, &pWriter->writer.pgidx, nBuffer);
+  fts5BufferGrow(&p->rc, &pWriter->writer.buf, nBuffer);
+
+  if( p->pIdxWriter==0 ){
+    Fts5Config *pConfig = p->pConfig;
+    fts5IndexPrepareStmt(p, &p->pIdxWriter, sqlite3_mprintf(
+          "INSERT INTO '%q'.'%q_idx'(segid,term,pgno) VALUES(?,?,?)", 
+          pConfig->zDb, pConfig->zName
+    ));
+  }
+
+  if( p->rc==SQLITE_OK ){
+    /* Initialize the 4-byte leaf-page header to 0x00. */
+    memset(pWriter->writer.buf.p, 0, 4);
+    pWriter->writer.buf.n = 4;
+
+    /* Bind the current output segment id to the index-writer. This is an
+    ** optimization over binding the same value over and over as rows are
+    ** inserted into %_idx by the current writer.  */
+    sqlite3_bind_int(p->pIdxWriter, 1, pWriter->iSegid);
+  }
+}
+
+/*
+** Iterator pIter was used to iterate through the input segments of on an
+** incremental merge operation. This function is called if the incremental
+** merge step has finished but the input has not been completely exhausted.
+*/
+static void fts5TrimSegments(Fts5Index *p, Fts5IndexIter *pIter){
+  int i;
+  Fts5Buffer buf;
+  memset(&buf, 0, sizeof(Fts5Buffer));
+  for(i=0; i<pIter->nSeg; i++){
+    Fts5SegIter *pSeg = &pIter->aSeg[i];
+    if( pSeg->pSeg==0 ){
+      /* no-op */
+    }else if( pSeg->pLeaf==0 ){
+      /* All keys from this input segment have been transfered to the output.
+      ** Set both the first and last page-numbers to 0 to indicate that the
+      ** segment is now empty. */
+      pSeg->pSeg->pgnoLast = 0;
+      pSeg->pSeg->pgnoFirst = 0;
+    }else{
+      int iOff = pSeg->iTermLeafOffset;     /* Offset on new first leaf page */
+      i64 iLeafRowid;
+      Fts5Data *pData;
+      int iId = pSeg->pSeg->iSegid;
+      u8 aHdr[4] = {0x00, 0x00, 0x00, 0x00};
+
+      iLeafRowid = FTS5_SEGMENT_ROWID(iId, pSeg->iTermLeafPgno);
+      pData = fts5DataRead(p, iLeafRowid);
+      if( pData ){
+        fts5BufferZero(&buf);
+        fts5BufferGrow(&p->rc, &buf, pData->nn);
+        fts5BufferAppendBlob(&p->rc, &buf, sizeof(aHdr), aHdr);
+        fts5BufferAppendVarint(&p->rc, &buf, pSeg->term.n);
+        fts5BufferAppendBlob(&p->rc, &buf, pSeg->term.n, pSeg->term.p);
+        fts5BufferAppendBlob(&p->rc, &buf, pData->szLeaf-iOff, &pData->p[iOff]);
+        if( p->rc==SQLITE_OK ){
+          /* Set the szLeaf field */
+          fts5PutU16(&buf.p[2], buf.n);
+        }
+
+        /* Set up the new page-index array */
+        fts5BufferAppendVarint(&p->rc, &buf, 4);
+        if( pSeg->iLeafPgno==pSeg->iTermLeafPgno 
+         && pSeg->iEndofDoclist<pData->szLeaf 
+        ){
+          int nDiff = pData->szLeaf - pSeg->iEndofDoclist;
+          fts5BufferAppendVarint(&p->rc, &buf, buf.n - 1 - nDiff - 4);
+          fts5BufferAppendBlob(&p->rc, &buf, 
+              pData->nn - pSeg->iPgidxOff, &pData->p[pSeg->iPgidxOff]
+          );
+        }
+
+        fts5DataRelease(pData);
+        pSeg->pSeg->pgnoFirst = pSeg->iTermLeafPgno;
+        fts5DataDelete(p, FTS5_SEGMENT_ROWID(iId, 1), iLeafRowid);
+        fts5DataWrite(p, iLeafRowid, buf.p, buf.n);
+      }
+    }
+  }
+  fts5BufferFree(&buf);
+}
+
+static void fts5MergeChunkCallback(
+  Fts5Index *p, 
+  void *pCtx, 
+  const u8 *pChunk, int nChunk
+){
+  Fts5SegWriter *pWriter = (Fts5SegWriter*)pCtx;
+  fts5WriteAppendPoslistData(p, pWriter, pChunk, nChunk);
+}
+
+/*
+**
+*/
+static void fts5IndexMergeLevel(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5Structure **ppStruct,       /* IN/OUT: Stucture of index */
+  int iLvl,                       /* Level to read input from */
+  int *pnRem                      /* Write up to this many output leaves */
+){
+  Fts5Structure *pStruct = *ppStruct;
+  Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];
+  Fts5StructureLevel *pLvlOut;
+  Fts5IndexIter *pIter = 0;       /* Iterator to read input data */
+  int nRem = pnRem ? *pnRem : 0;  /* Output leaf pages left to write */
+  int nInput;                     /* Number of input segments */
+  Fts5SegWriter writer;           /* Writer object */
+  Fts5StructureSegment *pSeg;     /* Output segment */
+  Fts5Buffer term;
+  int bOldest;                    /* True if the output segment is the oldest */
+
+  assert( iLvl<pStruct->nLevel );
+  assert( pLvl->nMerge<=pLvl->nSeg );
+
+  memset(&writer, 0, sizeof(Fts5SegWriter));
+  memset(&term, 0, sizeof(Fts5Buffer));
+  if( pLvl->nMerge ){
+    pLvlOut = &pStruct->aLevel[iLvl+1];
+    assert( pLvlOut->nSeg>0 );
+    nInput = pLvl->nMerge;
+    pSeg = &pLvlOut->aSeg[pLvlOut->nSeg-1];
+
+    fts5WriteInit(p, &writer, pSeg->iSegid);
+    writer.writer.pgno = pSeg->pgnoLast+1;
+    writer.iBtPage = 0;
+  }else{
+    int iSegid = fts5AllocateSegid(p, pStruct);
+
+    /* Extend the Fts5Structure object as required to ensure the output
+    ** segment exists. */
+    if( iLvl==pStruct->nLevel-1 ){
+      fts5StructureAddLevel(&p->rc, ppStruct);
+      pStruct = *ppStruct;
+    }
+    fts5StructureExtendLevel(&p->rc, pStruct, iLvl+1, 1, 0);
+    if( p->rc ) return;
+    pLvl = &pStruct->aLevel[iLvl];
+    pLvlOut = &pStruct->aLevel[iLvl+1];
+
+    fts5WriteInit(p, &writer, iSegid);
+
+    /* Add the new segment to the output level */
+    pSeg = &pLvlOut->aSeg[pLvlOut->nSeg];
+    pLvlOut->nSeg++;
+    pSeg->pgnoFirst = 1;
+    pSeg->iSegid = iSegid;
+    pStruct->nSegment++;
+
+    /* Read input from all segments in the input level */
+    nInput = pLvl->nSeg;
+  }
+  bOldest = (pLvlOut->nSeg==1 && pStruct->nLevel==iLvl+2);
+
+  assert( iLvl>=0 );
+  for(fts5MultiIterNew(p, pStruct, 0, 0, 0, 0, iLvl, nInput, &pIter);
+      fts5MultiIterEof(p, pIter)==0;
+      fts5MultiIterNext(p, pIter, 0, 0)
+  ){
+    Fts5SegIter *pSegIter = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
+    int nPos;                     /* position-list size field value */
+    int nTerm;
+    const u8 *pTerm;
+
+    /* Check for key annihilation. */
+    if( pSegIter->nPos==0 && (bOldest || pSegIter->bDel==0) ) continue;
+
+    pTerm = fts5MultiIterTerm(pIter, &nTerm);
+    if( nTerm!=term.n || memcmp(pTerm, term.p, nTerm) ){
+      if( pnRem && writer.nLeafWritten>nRem ){
+        break;
+      }
+
+      /* This is a new term. Append a term to the output segment. */
+      fts5WriteAppendTerm(p, &writer, nTerm, pTerm);
+      fts5BufferSet(&p->rc, &term, nTerm, pTerm);
+    }
+
+    /* Append the rowid to the output */
+    /* WRITEPOSLISTSIZE */
+    nPos = pSegIter->nPos*2 + pSegIter->bDel;
+    fts5WriteAppendRowid(p, &writer, fts5MultiIterRowid(pIter), nPos);
+
+    /* Append the position-list data to the output */
+    fts5ChunkIterate(p, pSegIter, (void*)&writer, fts5MergeChunkCallback);
+  }
+
+  /* Flush the last leaf page to disk. Set the output segment b-tree height
+  ** and last leaf page number at the same time.  */
+  fts5WriteFinish(p, &writer, &pSeg->pgnoLast);
+
+  if( fts5MultiIterEof(p, pIter) ){
+    int i;
+
+    /* Remove the redundant segments from the %_data table */
+    for(i=0; i<nInput; i++){
+      fts5DataRemoveSegment(p, pLvl->aSeg[i].iSegid);
+    }
+
+    /* Remove the redundant segments from the input level */
+    if( pLvl->nSeg!=nInput ){
+      int nMove = (pLvl->nSeg - nInput) * sizeof(Fts5StructureSegment);
+      memmove(pLvl->aSeg, &pLvl->aSeg[nInput], nMove);
+    }
+    pStruct->nSegment -= nInput;
+    pLvl->nSeg -= nInput;
+    pLvl->nMerge = 0;
+    if( pSeg->pgnoLast==0 ){
+      pLvlOut->nSeg--;
+      pStruct->nSegment--;
+    }
+  }else{
+    assert( pSeg->pgnoLast>0 );
+    fts5TrimSegments(p, pIter);
+    pLvl->nMerge = nInput;
+  }
+
+  fts5MultiIterFree(p, pIter);
+  fts5BufferFree(&term);
+  if( pnRem ) *pnRem -= writer.nLeafWritten;
+}
+
+/*
+** Do up to nPg pages of automerge work on the index.
+*/
+static void fts5IndexMerge(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5Structure **ppStruct,       /* IN/OUT: Current structure of index */
+  int nPg                         /* Pages of work to do */
+){
+  int nRem = nPg;
+  Fts5Structure *pStruct = *ppStruct;
+  while( nRem>0 && p->rc==SQLITE_OK ){
+    int iLvl;                   /* To iterate through levels */
+    int iBestLvl = 0;           /* Level offering the most input segments */
+    int nBest = 0;              /* Number of input segments on best level */
+
+    /* Set iBestLvl to the level to read input segments from. */
+    assert( pStruct->nLevel>0 );
+    for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){
+      Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];
+      if( pLvl->nMerge ){
+        if( pLvl->nMerge>nBest ){
+          iBestLvl = iLvl;
+          nBest = pLvl->nMerge;
+        }
+        break;
+      }
+      if( pLvl->nSeg>nBest ){
+        nBest = pLvl->nSeg;
+        iBestLvl = iLvl;
+      }
+    }
+
+    /* If nBest is still 0, then the index must be empty. */
+#ifdef SQLITE_DEBUG
+    for(iLvl=0; nBest==0 && iLvl<pStruct->nLevel; iLvl++){
+      assert( pStruct->aLevel[iLvl].nSeg==0 );
+    }
+#endif
+
+    if( nBest<p->pConfig->nAutomerge 
+        && pStruct->aLevel[iBestLvl].nMerge==0 
+      ){
+      break;
+    }
+    fts5IndexMergeLevel(p, &pStruct, iBestLvl, &nRem);
+    if( p->rc==SQLITE_OK && pStruct->aLevel[iBestLvl].nMerge==0 ){
+      fts5StructurePromote(p, iBestLvl+1, pStruct);
+    }
+  }
+  *ppStruct = pStruct;
+}
+
+/*
+** A total of nLeaf leaf pages of data has just been flushed to a level-0
+** segment. This function updates the write-counter accordingly and, if
+** necessary, performs incremental merge work.
+**
+** If an error occurs, set the Fts5Index.rc error code. If an error has 
+** already occurred, this function is a no-op.
+*/
+static void fts5IndexAutomerge(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5Structure **ppStruct,       /* IN/OUT: Current structure of index */
+  int nLeaf                       /* Number of output leaves just written */
+){
+  if( p->rc==SQLITE_OK && p->pConfig->nAutomerge>0 ){
+    Fts5Structure *pStruct = *ppStruct;
+    u64 nWrite;                   /* Initial value of write-counter */
+    int nWork;                    /* Number of work-quanta to perform */
+    int nRem;                     /* Number of leaf pages left to write */
+
+    /* Update the write-counter. While doing so, set nWork. */
+    nWrite = pStruct->nWriteCounter;
+    nWork = (int)(((nWrite + nLeaf) / p->nWorkUnit) - (nWrite / p->nWorkUnit));
+    pStruct->nWriteCounter += nLeaf;
+    nRem = (int)(p->nWorkUnit * nWork * pStruct->nLevel);
+
+    fts5IndexMerge(p, ppStruct, nRem);
+  }
+}
+
+static void fts5IndexCrisismerge(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5Structure **ppStruct        /* IN/OUT: Current structure of index */
+){
+  const int nCrisis = p->pConfig->nCrisisMerge;
+  Fts5Structure *pStruct = *ppStruct;
+  int iLvl = 0;
+
+  assert( p->rc!=SQLITE_OK || pStruct->nLevel>0 );
+  while( p->rc==SQLITE_OK && pStruct->aLevel[iLvl].nSeg>=nCrisis ){
+    fts5IndexMergeLevel(p, &pStruct, iLvl, 0);
+    assert( p->rc!=SQLITE_OK || pStruct->nLevel>(iLvl+1) );
+    fts5StructurePromote(p, iLvl+1, pStruct);
+    iLvl++;
+  }
+  *ppStruct = pStruct;
+}
+
+static int fts5IndexReturn(Fts5Index *p){
+  int rc = p->rc;
+  p->rc = SQLITE_OK;
+  return rc;
+}
+
+typedef struct Fts5FlushCtx Fts5FlushCtx;
+struct Fts5FlushCtx {
+  Fts5Index *pIdx;
+  Fts5SegWriter writer; 
+};
+
+/*
+** Buffer aBuf[] contains a list of varints, all small enough to fit
+** in a 32-bit integer. Return the size of the largest prefix of this 
+** list nMax bytes or less in size.
+*/
+static int fts5PoslistPrefix(const u8 *aBuf, int nMax){
+  int ret;
+  u32 dummy;
+  ret = fts5GetVarint32(aBuf, dummy);
+  if( ret<nMax ){
+    while( 1 ){
+      int i = fts5GetVarint32(&aBuf[ret], dummy);
+      if( (ret + i) > nMax ) break;
+      ret += i;
+    }
+  }
+  return ret;
+}
+
+#define fts5BufferSafeAppendBlob(pBuf, pBlob, nBlob) {     \
+  assert( (pBuf)->nSpace>=((pBuf)->n+nBlob) );             \
+  memcpy(&(pBuf)->p[(pBuf)->n], pBlob, nBlob);             \
+  (pBuf)->n += nBlob;                                      \
+}
+
+#define fts5BufferSafeAppendVarint(pBuf, iVal) {                \
+  (pBuf)->n += sqlite3Fts5PutVarint(&(pBuf)->p[(pBuf)->n], (iVal));  \
+  assert( (pBuf)->nSpace>=(pBuf)->n );                          \
+}
+
+/*
+** Flush the contents of in-memory hash table iHash to a new level-0 
+** segment on disk. Also update the corresponding structure record.
+**
+** If an error occurs, set the Fts5Index.rc error code. If an error has 
+** already occurred, this function is a no-op.
+*/
+static void fts5FlushOneHash(Fts5Index *p){
+  Fts5Hash *pHash = p->pHash;
+  Fts5Structure *pStruct;
+  int iSegid;
+  int pgnoLast = 0;                 /* Last leaf page number in segment */
+
+  /* Obtain a reference to the index structure and allocate a new segment-id
+  ** for the new level-0 segment.  */
+  pStruct = fts5StructureRead(p);
+  iSegid = fts5AllocateSegid(p, pStruct);
+
+  if( iSegid ){
+    const int pgsz = p->pConfig->pgsz;
+
+    Fts5StructureSegment *pSeg;   /* New segment within pStruct */
+    Fts5Buffer *pBuf;             /* Buffer in which to assemble leaf page */
+    Fts5Buffer *pPgidx;           /* Buffer in which to assemble pgidx */
+
+    Fts5SegWriter writer;
+    fts5WriteInit(p, &writer, iSegid);
+
+    pBuf = &writer.writer.buf;
+    pPgidx = &writer.writer.pgidx;
+
+    /* fts5WriteInit() should have initialized the buffers to (most likely)
+    ** the maximum space required. */
+    assert( p->rc || pBuf->nSpace>=(pgsz + FTS5_DATA_PADDING) );
+    assert( p->rc || pPgidx->nSpace>=(pgsz + FTS5_DATA_PADDING) );
+
+    /* Begin scanning through hash table entries. This loop runs once for each
+    ** term/doclist currently stored within the hash table. */
+    if( p->rc==SQLITE_OK ){
+      p->rc = sqlite3Fts5HashScanInit(pHash, 0, 0);
+    }
+    while( p->rc==SQLITE_OK && 0==sqlite3Fts5HashScanEof(pHash) ){
+      const char *zTerm;          /* Buffer containing term */
+      const u8 *pDoclist;         /* Pointer to doclist for this term */
+      int nDoclist;               /* Size of doclist in bytes */
+
+      /* Write the term for this entry to disk. */
+      sqlite3Fts5HashScanEntry(pHash, &zTerm, &pDoclist, &nDoclist);
+      fts5WriteAppendTerm(p, &writer, strlen(zTerm), (const u8*)zTerm);
+
+      assert( writer.bFirstRowidInPage==0 );
+      if( pgsz>=(pBuf->n + pPgidx->n + nDoclist + 1) ){
+        /* The entire doclist will fit on the current leaf. */
+        fts5BufferSafeAppendBlob(pBuf, pDoclist, nDoclist);
+      }else{
+        i64 iRowid = 0;
+        i64 iDelta = 0;
+        int iOff = 0;
+
+        /* The entire doclist will not fit on this leaf. The following 
+        ** loop iterates through the poslists that make up the current 
+        ** doclist.  */
+        while( p->rc==SQLITE_OK && iOff<nDoclist ){
+          int nPos;
+          int nCopy;
+          int bDummy;
+          iOff += fts5GetVarint(&pDoclist[iOff], (u64*)&iDelta);
+          nCopy = fts5GetPoslistSize(&pDoclist[iOff], &nPos, &bDummy);
+          nCopy += nPos;
+          iRowid += iDelta;
+          
+          if( writer.bFirstRowidInPage ){
+            fts5PutU16(&pBuf->p[0], pBuf->n);   /* first rowid on page */
+            pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iRowid);
+            writer.bFirstRowidInPage = 0;
+            fts5WriteDlidxAppend(p, &writer, iRowid);
+          }else{
+            pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iDelta);
+          }
+          assert( pBuf->n<=pBuf->nSpace );
+
+          if( (pBuf->n + pPgidx->n + nCopy) <= pgsz ){
+            /* The entire poslist will fit on the current leaf. So copy
+            ** it in one go. */
+            fts5BufferSafeAppendBlob(pBuf, &pDoclist[iOff], nCopy);
+          }else{
+            /* The entire poslist will not fit on this leaf. So it needs
+            ** to be broken into sections. The only qualification being
+            ** that each varint must be stored contiguously.  */
+            const u8 *pPoslist = &pDoclist[iOff];
+            int iPos = 0;
+            while( p->rc==SQLITE_OK ){
+              int nSpace = pgsz - pBuf->n - pPgidx->n;
+              int n = 0;
+              if( (nCopy - iPos)<=nSpace ){
+                n = nCopy - iPos;
+              }else{
+                n = fts5PoslistPrefix(&pPoslist[iPos], nSpace);
+              }
+              assert( n>0 );
+              fts5BufferSafeAppendBlob(pBuf, &pPoslist[iPos], n);
+              iPos += n;
+              if( (pBuf->n + pPgidx->n)>=pgsz ){
+                fts5WriteFlushLeaf(p, &writer);
+              }
+              if( iPos>=nCopy ) break;
+            }
+          }
+          iOff += nCopy;
+        }
+      }
+
+      /* TODO2: Doclist terminator written here. */
+      /* pBuf->p[pBuf->n++] = '\0'; */
+      assert( pBuf->n<=pBuf->nSpace );
+      sqlite3Fts5HashScanNext(pHash);
+    }
+    sqlite3Fts5HashClear(pHash);
+    fts5WriteFinish(p, &writer, &pgnoLast);
+
+    /* Update the Fts5Structure. It is written back to the database by the
+    ** fts5StructureRelease() call below.  */
+    if( pStruct->nLevel==0 ){
+      fts5StructureAddLevel(&p->rc, &pStruct);
+    }
+    fts5StructureExtendLevel(&p->rc, pStruct, 0, 1, 0);
+    if( p->rc==SQLITE_OK ){
+      pSeg = &pStruct->aLevel[0].aSeg[ pStruct->aLevel[0].nSeg++ ];
+      pSeg->iSegid = iSegid;
+      pSeg->pgnoFirst = 1;
+      pSeg->pgnoLast = pgnoLast;
+      pStruct->nSegment++;
+    }
+    fts5StructurePromote(p, 0, pStruct);
+  }
+
+  fts5IndexAutomerge(p, &pStruct, pgnoLast);
+  fts5IndexCrisismerge(p, &pStruct);
+  fts5StructureWrite(p, pStruct);
+  fts5StructureRelease(pStruct);
+}
+
+/*
+** Flush any data stored in the in-memory hash tables to the database.
+*/
+static void fts5IndexFlush(Fts5Index *p){
+  /* Unless it is empty, flush the hash table to disk */
+  if( p->nPendingData ){
+    assert( p->pHash );
+    p->nPendingData = 0;
+    fts5FlushOneHash(p);
+  }
+}
+
+
+static int sqlite3Fts5IndexOptimize(Fts5Index *p){
+  Fts5Structure *pStruct;
+  Fts5Structure *pNew = 0;
+  int nSeg = 0;
+
+  assert( p->rc==SQLITE_OK );
+  fts5IndexFlush(p);
+  pStruct = fts5StructureRead(p);
+
+  if( pStruct ){
+    assert( pStruct->nSegment==fts5StructureCountSegments(pStruct) );
+    nSeg = pStruct->nSegment;
+    if( nSeg>1 ){
+      int nByte = sizeof(Fts5Structure);
+      nByte += (pStruct->nLevel+1) * sizeof(Fts5StructureLevel);
+      pNew = (Fts5Structure*)sqlite3Fts5MallocZero(&p->rc, nByte);
+    }
+  }
+  if( pNew ){
+    Fts5StructureLevel *pLvl;
+    int nByte = nSeg * sizeof(Fts5StructureSegment);
+    pNew->nLevel = pStruct->nLevel+1;
+    pNew->nRef = 1;
+    pNew->nWriteCounter = pStruct->nWriteCounter;
+    pLvl = &pNew->aLevel[pStruct->nLevel];
+    pLvl->aSeg = (Fts5StructureSegment*)sqlite3Fts5MallocZero(&p->rc, nByte);
+    if( pLvl->aSeg ){
+      int iLvl, iSeg;
+      int iSegOut = 0;
+      for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){
+        for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){
+          pLvl->aSeg[iSegOut] = pStruct->aLevel[iLvl].aSeg[iSeg];
+          iSegOut++;
+        }
+      }
+      pNew->nSegment = pLvl->nSeg = nSeg;
+    }else{
+      sqlite3_free(pNew);
+      pNew = 0;
+    }
+  }
+
+  if( pNew ){
+    int iLvl = pNew->nLevel-1;
+    while( p->rc==SQLITE_OK && pNew->aLevel[iLvl].nSeg>0 ){
+      int nRem = FTS5_OPT_WORK_UNIT;
+      fts5IndexMergeLevel(p, &pNew, iLvl, &nRem);
+    }
+
+    fts5StructureWrite(p, pNew);
+    fts5StructureRelease(pNew);
+  }
+
+  fts5StructureRelease(pStruct);
+  return fts5IndexReturn(p); 
+}
+
+static int sqlite3Fts5IndexMerge(Fts5Index *p, int nMerge){
+  Fts5Structure *pStruct;
+
+  pStruct = fts5StructureRead(p);
+  if( pStruct && pStruct->nLevel ){
+    fts5IndexMerge(p, &pStruct, nMerge);
+    fts5StructureWrite(p, pStruct);
+  }
+  fts5StructureRelease(pStruct);
+
+  return fts5IndexReturn(p);
+}
+
+static void fts5PoslistCallback(
+  Fts5Index *p, 
+  void *pContext, 
+  const u8 *pChunk, int nChunk
+){
+  assert_nc( nChunk>=0 );
+  if( nChunk>0 ){
+    fts5BufferSafeAppendBlob((Fts5Buffer*)pContext, pChunk, nChunk);
+  }
+}
+
+typedef struct PoslistCallbackCtx PoslistCallbackCtx;
+struct PoslistCallbackCtx {
+  Fts5Buffer *pBuf;               /* Append to this buffer */
+  Fts5Colset *pColset;            /* Restrict matches to this column */
+  int eState;                     /* See above */
+};
+
+/*
+** TODO: Make this more efficient!
+*/
+static int fts5IndexColsetTest(Fts5Colset *pColset, int iCol){
+  int i;
+  for(i=0; i<pColset->nCol; i++){
+    if( pColset->aiCol[i]==iCol ) return 1;
+  }
+  return 0;
+}
+
+static void fts5PoslistFilterCallback(
+  Fts5Index *p, 
+  void *pContext, 
+  const u8 *pChunk, int nChunk
+){
+  PoslistCallbackCtx *pCtx = (PoslistCallbackCtx*)pContext;
+  assert_nc( nChunk>=0 );
+  if( nChunk>0 ){
+    /* Search through to find the first varint with value 1. This is the
+    ** start of the next columns hits. */
+    int i = 0;
+    int iStart = 0;
+
+    if( pCtx->eState==2 ){
+      int iCol;
+      fts5FastGetVarint32(pChunk, i, iCol);
+      if( fts5IndexColsetTest(pCtx->pColset, iCol) ){
+        pCtx->eState = 1;
+        fts5BufferSafeAppendVarint(pCtx->pBuf, 1);
+      }else{
+        pCtx->eState = 0;
+      }
+    }
+
+    do {
+      while( i<nChunk && pChunk[i]!=0x01 ){
+        while( pChunk[i] & 0x80 ) i++;
+        i++;
+      }
+      if( pCtx->eState ){
+        fts5BufferSafeAppendBlob(pCtx->pBuf, &pChunk[iStart], i-iStart);
+      }
+      if( i<nChunk ){
+        int iCol;
+        iStart = i;
+        i++;
+        if( i>=nChunk ){
+          pCtx->eState = 2;
+        }else{
+          fts5FastGetVarint32(pChunk, i, iCol);
+          pCtx->eState = fts5IndexColsetTest(pCtx->pColset, iCol);
+          if( pCtx->eState ){
+            fts5BufferSafeAppendBlob(pCtx->pBuf, &pChunk[iStart], i-iStart);
+            iStart = i;
+          }
+        }
+      }
+    }while( i<nChunk );
+  }
+}
+
+/*
+** Iterator pIter currently points to a valid entry (not EOF). This
+** function appends the position list data for the current entry to
+** buffer pBuf. It does not make a copy of the position-list size
+** field.
+*/
+static void fts5SegiterPoslist(
+  Fts5Index *p,
+  Fts5SegIter *pSeg,
+  Fts5Colset *pColset,
+  Fts5Buffer *pBuf
+){
+  if( 0==fts5BufferGrow(&p->rc, pBuf, pSeg->nPos) ){
+    if( pColset==0 ){
+      fts5ChunkIterate(p, pSeg, (void*)pBuf, fts5PoslistCallback);
+    }else{
+      PoslistCallbackCtx sCtx;
+      sCtx.pBuf = pBuf;
+      sCtx.pColset = pColset;
+      sCtx.eState = pColset ? fts5IndexColsetTest(pColset, 0) : 1;
+      assert( sCtx.eState==0 || sCtx.eState==1 );
+      fts5ChunkIterate(p, pSeg, (void*)&sCtx, fts5PoslistFilterCallback);
+    }
+  }
+}
+
+/*
+** IN/OUT parameter (*pa) points to a position list n bytes in size. If
+** the position list contains entries for column iCol, then (*pa) is set
+** to point to the sub-position-list for that column and the number of
+** bytes in it returned. Or, if the argument position list does not
+** contain any entries for column iCol, return 0.
+*/
+static int fts5IndexExtractCol(
+  const u8 **pa,                  /* IN/OUT: Pointer to poslist */
+  int n,                          /* IN: Size of poslist in bytes */
+  int iCol                        /* Column to extract from poslist */
+){
+  int iCurrent = 0;               /* Anything before the first 0x01 is col 0 */
+  const u8 *p = *pa;
+  const u8 *pEnd = &p[n];         /* One byte past end of position list */
+  u8 prev = 0;
+
+  while( iCol!=iCurrent ){
+    /* Advance pointer p until it points to pEnd or an 0x01 byte that is
+    ** not part of a varint */
+    while( (prev & 0x80) || *p!=0x01 ){
+      prev = *p++;
+      if( p==pEnd ) return 0;
+    }
+    *pa = p++;
+    p += fts5GetVarint32(p, iCurrent);
+  }
+
+  /* Advance pointer p until it points to pEnd or an 0x01 byte that is
+  ** not part of a varint */
+  assert( (prev & 0x80)==0 );
+  while( p<pEnd && ((prev & 0x80) || *p!=0x01) ){
+    prev = *p++;
+  }
+  return p - (*pa);
+}
+
+
+/*
+** Iterator pMulti currently points to a valid entry (not EOF). This
+** function appends the following to buffer pBuf:
+**
+**   * The varint iDelta, and
+**   * the position list that currently points to, including the size field.
+**
+** If argument pColset is NULL, then the position list is filtered according
+** to pColset before being appended to the buffer. If this means there are
+** no entries in the position list, nothing is appended to the buffer (not
+** even iDelta).
+**
+** If an error occurs, an error code is left in p->rc. 
+*/
+static int fts5AppendPoslist(
+  Fts5Index *p,
+  i64 iDelta,
+  Fts5IndexIter *pMulti,
+  Fts5Colset *pColset,
+  Fts5Buffer *pBuf
+){
+  if( p->rc==SQLITE_OK ){
+    Fts5SegIter *pSeg = &pMulti->aSeg[ pMulti->aFirst[1].iFirst ];
+    assert( fts5MultiIterEof(p, pMulti)==0 );
+    assert( pSeg->nPos>0 );
+    if( 0==fts5BufferGrow(&p->rc, pBuf, pSeg->nPos+9+9) ){
+      int iSv1;
+      int iSv2;
+      int iData;
+
+      /* Append iDelta */
+      iSv1 = pBuf->n;
+      fts5BufferSafeAppendVarint(pBuf, iDelta);
+
+      /* WRITEPOSLISTSIZE */
+      iSv2 = pBuf->n;
+      fts5BufferSafeAppendVarint(pBuf, pSeg->nPos*2);
+      iData = pBuf->n;
+
+      if( pSeg->iLeafOffset+pSeg->nPos<=pSeg->pLeaf->szLeaf 
+       && (pColset==0 || pColset->nCol==1)
+      ){
+        const u8 *pPos = &pSeg->pLeaf->p[pSeg->iLeafOffset];
+        int nPos;
+        if( pColset ){
+          nPos = fts5IndexExtractCol(&pPos, pSeg->nPos, pColset->aiCol[0]);
+        }else{
+          nPos = pSeg->nPos;
+        }
+        fts5BufferSafeAppendBlob(pBuf, pPos, nPos);
+      }else{
+        fts5SegiterPoslist(p, pSeg, pColset, pBuf);
+      }
+
+      if( pColset ){
+        int nActual = pBuf->n - iData;
+        if( nActual!=pSeg->nPos ){
+          if( nActual==0 ){
+            pBuf->n = iSv1;
+            return 1;
+          }else{
+            int nReq = sqlite3Fts5GetVarintLen((u32)(nActual*2));
+            while( iSv2<(iData-nReq) ){ pBuf->p[iSv2++] = 0x80; }
+            sqlite3Fts5PutVarint(&pBuf->p[iSv2], nActual*2);
+          }
+        }
+      }
+    }
+  }
+
+  return 0;
+}
+
+static void fts5DoclistIterNext(Fts5DoclistIter *pIter){
+  u8 *p = pIter->aPoslist + pIter->nSize + pIter->nPoslist;
+
+  assert( pIter->aPoslist );
+  if( p>=pIter->aEof ){
+    pIter->aPoslist = 0;
+  }else{
+    i64 iDelta;
+
+    p += fts5GetVarint(p, (u64*)&iDelta);
+    pIter->iRowid += iDelta;
+
+    /* Read position list size */
+    if( p[0] & 0x80 ){
+      int nPos;
+      pIter->nSize = fts5GetVarint32(p, nPos);
+      pIter->nPoslist = (nPos>>1);
+    }else{
+      pIter->nPoslist = ((int)(p[0])) >> 1;
+      pIter->nSize = 1;
+    }
+
+    pIter->aPoslist = p;
+  }
+}
+
+static void fts5DoclistIterInit(
+  Fts5Buffer *pBuf, 
+  Fts5DoclistIter *pIter
+){
+  memset(pIter, 0, sizeof(*pIter));
+  pIter->aPoslist = pBuf->p;
+  pIter->aEof = &pBuf->p[pBuf->n];
+  fts5DoclistIterNext(pIter);
+}
+
+#if 0
+/*
+** Append a doclist to buffer pBuf.
+**
+** This function assumes that space within the buffer has already been
+** allocated.
+*/
+static void fts5MergeAppendDocid(
+  Fts5Buffer *pBuf,               /* Buffer to write to */
+  i64 *piLastRowid,               /* IN/OUT: Previous rowid written (if any) */
+  i64 iRowid                      /* Rowid to append */
+){
+  assert( pBuf->n!=0 || (*piLastRowid)==0 );
+  fts5BufferSafeAppendVarint(pBuf, iRowid - *piLastRowid);
+  *piLastRowid = iRowid;
+}
+#endif
+
+#define fts5MergeAppendDocid(pBuf, iLastRowid, iRowid) {       \
+  assert( (pBuf)->n!=0 || (iLastRowid)==0 );                   \
+  fts5BufferSafeAppendVarint((pBuf), (iRowid) - (iLastRowid)); \
+  (iLastRowid) = (iRowid);                                     \
+}
+
+/*
+** Buffers p1 and p2 contain doclists. This function merges the content
+** of the two doclists together and sets buffer p1 to the result before
+** returning.
+**
+** If an error occurs, an error code is left in p->rc. If an error has
+** already occurred, this function is a no-op.
+*/
+static void fts5MergePrefixLists(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5Buffer *p1,                 /* First list to merge */
+  Fts5Buffer *p2                  /* Second list to merge */
+){
+  if( p2->n ){
+    i64 iLastRowid = 0;
+    Fts5DoclistIter i1;
+    Fts5DoclistIter i2;
+    Fts5Buffer out;
+    Fts5Buffer tmp;
+    memset(&out, 0, sizeof(out));
+    memset(&tmp, 0, sizeof(tmp));
+
+    sqlite3Fts5BufferGrow(&p->rc, &out, p1->n + p2->n);
+    fts5DoclistIterInit(p1, &i1);
+    fts5DoclistIterInit(p2, &i2);
+    while( p->rc==SQLITE_OK && (i1.aPoslist!=0 || i2.aPoslist!=0) ){
+      if( i2.aPoslist==0 || (i1.aPoslist && i1.iRowid<i2.iRowid) ){
+        /* Copy entry from i1 */
+        fts5MergeAppendDocid(&out, iLastRowid, i1.iRowid);
+        fts5BufferSafeAppendBlob(&out, i1.aPoslist, i1.nPoslist+i1.nSize);
+        fts5DoclistIterNext(&i1);
+      }
+      else if( i1.aPoslist==0 || i2.iRowid!=i1.iRowid ){
+        /* Copy entry from i2 */
+        fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);
+        fts5BufferSafeAppendBlob(&out, i2.aPoslist, i2.nPoslist+i2.nSize);
+        fts5DoclistIterNext(&i2);
+      }
+      else{
+        i64 iPos1 = 0;
+        i64 iPos2 = 0;
+        int iOff1 = 0;
+        int iOff2 = 0;
+        u8 *a1 = &i1.aPoslist[i1.nSize];
+        u8 *a2 = &i2.aPoslist[i2.nSize];
+
+        Fts5PoslistWriter writer;
+        memset(&writer, 0, sizeof(writer));
+
+        /* Merge the two position lists. */ 
+        fts5MergeAppendDocid(&out, iLastRowid, i2.iRowid);
+        fts5BufferZero(&tmp);
+
+        sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);
+        sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);
+
+        while( p->rc==SQLITE_OK && (iPos1>=0 || iPos2>=0) ){
+          i64 iNew;
+          if( iPos2<0 || (iPos1>=0 && iPos1<iPos2) ){
+            iNew = iPos1;
+            sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1, &iPos1);
+          }else{
+            iNew = iPos2;
+            sqlite3Fts5PoslistNext64(a2, i2.nPoslist, &iOff2, &iPos2);
+            if( iPos1==iPos2 ){
+              sqlite3Fts5PoslistNext64(a1, i1.nPoslist, &iOff1,&iPos1);
+            }
+          }
+          p->rc = sqlite3Fts5PoslistWriterAppend(&tmp, &writer, iNew);
+        }
+
+        /* WRITEPOSLISTSIZE */
+        fts5BufferSafeAppendVarint(&out, tmp.n * 2);
+        fts5BufferSafeAppendBlob(&out, tmp.p, tmp.n);
+        fts5DoclistIterNext(&i1);
+        fts5DoclistIterNext(&i2);
+      }
+    }
+
+    fts5BufferSet(&p->rc, p1, out.n, out.p);
+    fts5BufferFree(&tmp);
+    fts5BufferFree(&out);
+  }
+}
+
+static void fts5BufferSwap(Fts5Buffer *p1, Fts5Buffer *p2){
+  Fts5Buffer tmp = *p1;
+  *p1 = *p2;
+  *p2 = tmp;
+}
+
+static void fts5SetupPrefixIter(
+  Fts5Index *p,                   /* Index to read from */
+  int bDesc,                      /* True for "ORDER BY rowid DESC" */
+  const u8 *pToken,               /* Buffer containing prefix to match */
+  int nToken,                     /* Size of buffer pToken in bytes */
+  Fts5Colset *pColset,            /* Restrict matches to these columns */
+  Fts5IndexIter **ppIter          /* OUT: New iterator */
+){
+  Fts5Structure *pStruct;
+  Fts5Buffer *aBuf;
+  const int nBuf = 32;
+
+  aBuf = (Fts5Buffer*)fts5IdxMalloc(p, sizeof(Fts5Buffer)*nBuf);
+  pStruct = fts5StructureRead(p);
+
+  if( aBuf && pStruct ){
+    const int flags = FTS5INDEX_QUERY_SCAN;
+    int i;
+    i64 iLastRowid = 0;
+    Fts5IndexIter *p1 = 0;     /* Iterator used to gather data from index */
+    Fts5Data *pData;
+    Fts5Buffer doclist;
+
+    memset(&doclist, 0, sizeof(doclist));
+    for(fts5MultiIterNew(p, pStruct, 1, flags, pToken, nToken, -1, 0, &p1);
+        fts5MultiIterEof(p, p1)==0;
+        fts5MultiIterNext(p, p1, 0, 0)
+    ){
+      i64 iRowid = fts5MultiIterRowid(p1);
+      int nTerm;
+      const u8 *pTerm = fts5MultiIterTerm(p1, &nTerm);
+      assert_nc( memcmp(pToken, pTerm, MIN(nToken, nTerm))<=0 );
+      if( nTerm<nToken || memcmp(pToken, pTerm, nToken) ) break;
+
+      if( doclist.n>0 && iRowid<=iLastRowid ){
+        for(i=0; p->rc==SQLITE_OK && doclist.n; i++){
+          assert( i<nBuf );
+          if( aBuf[i].n==0 ){
+            fts5BufferSwap(&doclist, &aBuf[i]);
+            fts5BufferZero(&doclist);
+          }else{
+            fts5MergePrefixLists(p, &doclist, &aBuf[i]);
+            fts5BufferZero(&aBuf[i]);
+          }
+        }
+        iLastRowid = 0;
+      }
+
+      if( !fts5AppendPoslist(p, iRowid-iLastRowid, p1, pColset, &doclist) ){
+        iLastRowid = iRowid;
+      }
+    }
+
+    for(i=0; i<nBuf; i++){
+      if( p->rc==SQLITE_OK ){
+        fts5MergePrefixLists(p, &doclist, &aBuf[i]);
+      }
+      fts5BufferFree(&aBuf[i]);
+    }
+    fts5MultiIterFree(p, p1);
+
+    pData = fts5IdxMalloc(p, sizeof(Fts5Data) + doclist.n);
+    if( pData ){
+      pData->p = (u8*)&pData[1];
+      pData->nn = pData->szLeaf = doclist.n;
+      memcpy(pData->p, doclist.p, doclist.n);
+      fts5MultiIterNew2(p, pData, bDesc, ppIter);
+    }
+    fts5BufferFree(&doclist);
+  }
+
+  fts5StructureRelease(pStruct);
+  sqlite3_free(aBuf);
+}
+
+
+/*
+** Indicate that all subsequent calls to sqlite3Fts5IndexWrite() pertain
+** to the document with rowid iRowid.
+*/
+static int sqlite3Fts5IndexBeginWrite(Fts5Index *p, int bDelete, i64 iRowid){
+  assert( p->rc==SQLITE_OK );
+
+  /* Allocate the hash table if it has not already been allocated */
+  if( p->pHash==0 ){
+    p->rc = sqlite3Fts5HashNew(&p->pHash, &p->nPendingData);
+  }
+
+  /* Flush the hash table to disk if required */
+  if( iRowid<p->iWriteRowid 
+   || (iRowid==p->iWriteRowid && p->bDelete==0)
+   || (p->nPendingData > p->nMaxPendingData) 
+  ){
+    fts5IndexFlush(p);
+  }
+
+  p->iWriteRowid = iRowid;
+  p->bDelete = bDelete;
+  return fts5IndexReturn(p);
+}
+
+/*
+** Commit data to disk.
+*/
+static int sqlite3Fts5IndexSync(Fts5Index *p, int bCommit){
+  assert( p->rc==SQLITE_OK );
+  fts5IndexFlush(p);
+  if( bCommit ) fts5CloseReader(p);
+  return fts5IndexReturn(p);
+}
+
+/*
+** Discard any data stored in the in-memory hash tables. Do not write it
+** to the database. Additionally, assume that the contents of the %_data
+** table may have changed on disk. So any in-memory caches of %_data 
+** records must be invalidated.
+*/
+static int sqlite3Fts5IndexRollback(Fts5Index *p){
+  fts5CloseReader(p);
+  fts5IndexDiscardData(p);
+  assert( p->rc==SQLITE_OK );
+  return SQLITE_OK;
+}
+
+/*
+** The %_data table is completely empty when this function is called. This
+** function populates it with the initial structure objects for each index,
+** and the initial version of the "averages" record (a zero-byte blob).
+*/
+static int sqlite3Fts5IndexReinit(Fts5Index *p){
+  Fts5Structure s;
+  memset(&s, 0, sizeof(Fts5Structure));
+  fts5DataWrite(p, FTS5_AVERAGES_ROWID, (const u8*)"", 0);
+  fts5StructureWrite(p, &s);
+  return fts5IndexReturn(p);
+}
+
+/*
+** Open a new Fts5Index handle. If the bCreate argument is true, create
+** and initialize the underlying %_data table.
+**
+** If successful, set *pp to point to the new object and return SQLITE_OK.
+** Otherwise, set *pp to NULL and return an SQLite error code.
+*/
+static int sqlite3Fts5IndexOpen(
+  Fts5Config *pConfig, 
+  int bCreate, 
+  Fts5Index **pp,
+  char **pzErr
+){
+  int rc = SQLITE_OK;
+  Fts5Index *p;                   /* New object */
+
+  *pp = p = (Fts5Index*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Index));
+  if( rc==SQLITE_OK ){
+    p->pConfig = pConfig;
+    p->nWorkUnit = FTS5_WORK_UNIT;
+    p->nMaxPendingData = 1024*1024;
+    p->zDataTbl = sqlite3Fts5Mprintf(&rc, "%s_data", pConfig->zName);
+    if( p->zDataTbl && bCreate ){
+      rc = sqlite3Fts5CreateTable(
+          pConfig, "data", "id INTEGER PRIMARY KEY, block BLOB", 0, pzErr
+      );
+      if( rc==SQLITE_OK ){
+        rc = sqlite3Fts5CreateTable(pConfig, "idx", 
+            "segid, term, pgno, PRIMARY KEY(segid, term)", 
+            1, pzErr
+        );
+      }
+      if( rc==SQLITE_OK ){
+        rc = sqlite3Fts5IndexReinit(p);
+      }
+    }
+  }
+
+  assert( rc!=SQLITE_OK || p->rc==SQLITE_OK );
+  if( rc ){
+    sqlite3Fts5IndexClose(p);
+    *pp = 0;
+  }
+  return rc;
+}
+
+/*
+** Close a handle opened by an earlier call to sqlite3Fts5IndexOpen().
+*/
+static int sqlite3Fts5IndexClose(Fts5Index *p){
+  int rc = SQLITE_OK;
+  if( p ){
+    assert( p->pReader==0 );
+    sqlite3_finalize(p->pWriter);
+    sqlite3_finalize(p->pDeleter);
+    sqlite3_finalize(p->pIdxWriter);
+    sqlite3_finalize(p->pIdxDeleter);
+    sqlite3_finalize(p->pIdxSelect);
+    sqlite3Fts5HashFree(p->pHash);
+    sqlite3_free(p->zDataTbl);
+    sqlite3_free(p);
+  }
+  return rc;
+}
+
+/*
+** Argument p points to a buffer containing utf-8 text that is n bytes in 
+** size. Return the number of bytes in the nChar character prefix of the
+** buffer, or 0 if there are less than nChar characters in total.
+*/
+static int fts5IndexCharlenToBytelen(const char *p, int nByte, int nChar){
+  int n = 0;
+  int i;
+  for(i=0; i<nChar; i++){
+    if( n>=nByte ) return 0;      /* Input contains fewer than nChar chars */
+    if( (unsigned char)p[n++]>=0xc0 ){
+      while( (p[n] & 0xc0)==0x80 ) n++;
+    }
+  }
+  return n;
+}
+
+/*
+** pIn is a UTF-8 encoded string, nIn bytes in size. Return the number of
+** unicode characters in the string.
+*/
+static int fts5IndexCharlen(const char *pIn, int nIn){
+  int nChar = 0;            
+  int i = 0;
+  while( i<nIn ){
+    if( (unsigned char)pIn[i++]>=0xc0 ){
+      while( i<nIn && (pIn[i] & 0xc0)==0x80 ) i++;
+    }
+    nChar++;
+  }
+  return nChar;
+}
+
+/*
+** Insert or remove data to or from the index. Each time a document is 
+** added to or removed from the index, this function is called one or more
+** times.
+**
+** For an insert, it must be called once for each token in the new document.
+** If the operation is a delete, it must be called (at least) once for each
+** unique token in the document with an iCol value less than zero. The iPos
+** argument is ignored for a delete.
+*/
+static int sqlite3Fts5IndexWrite(
+  Fts5Index *p,                   /* Index to write to */
+  int iCol,                       /* Column token appears in (-ve -> delete) */
+  int iPos,                       /* Position of token within column */
+  const char *pToken, int nToken  /* Token to add or remove to or from index */
+){
+  int i;                          /* Used to iterate through indexes */
+  int rc = SQLITE_OK;             /* Return code */
+  Fts5Config *pConfig = p->pConfig;
+
+  assert( p->rc==SQLITE_OK );
+  assert( (iCol<0)==p->bDelete );
+
+  /* Add the entry to the main terms index. */
+  rc = sqlite3Fts5HashWrite(
+      p->pHash, p->iWriteRowid, iCol, iPos, FTS5_MAIN_PREFIX, pToken, nToken
+  );
+
+  for(i=0; i<pConfig->nPrefix && rc==SQLITE_OK; i++){
+    int nByte = fts5IndexCharlenToBytelen(pToken, nToken, pConfig->aPrefix[i]);
+    if( nByte ){
+      rc = sqlite3Fts5HashWrite(p->pHash, 
+          p->iWriteRowid, iCol, iPos, FTS5_MAIN_PREFIX+i+1, pToken, nByte
+      );
+    }
+  }
+
+  return rc;
+}
+
+/*
+** Open a new iterator to iterate though all rowid that match the 
+** specified token or token prefix.
+*/
+static int sqlite3Fts5IndexQuery(
+  Fts5Index *p,                   /* FTS index to query */
+  const char *pToken, int nToken, /* Token (or prefix) to query for */
+  int flags,                      /* Mask of FTS5INDEX_QUERY_X flags */
+  Fts5Colset *pColset,            /* Match these columns only */
+  Fts5IndexIter **ppIter          /* OUT: New iterator object */
+){
+  Fts5Config *pConfig = p->pConfig;
+  Fts5IndexIter *pRet = 0;
+  int iIdx = 0;
+  Fts5Buffer buf = {0, 0, 0};
+
+  /* If the QUERY_SCAN flag is set, all other flags must be clear. */
+  assert( (flags & FTS5INDEX_QUERY_SCAN)==0
+       || (flags & FTS5INDEX_QUERY_SCAN)==FTS5INDEX_QUERY_SCAN
+  );
+
+  if( sqlite3Fts5BufferGrow(&p->rc, &buf, nToken+1)==0 ){
+    memcpy(&buf.p[1], pToken, nToken);
+
+#ifdef SQLITE_DEBUG
+    /* If the QUERY_TEST_NOIDX flag was specified, then this must be a
+    ** prefix-query. Instead of using a prefix-index (if one exists), 
+    ** evaluate the prefix query using the main FTS index. This is used
+    ** for internal sanity checking by the integrity-check in debug 
+    ** mode only.  */
+    if( pConfig->bPrefixIndex==0 || (flags & FTS5INDEX_QUERY_TEST_NOIDX) ){
+      assert( flags & FTS5INDEX_QUERY_PREFIX );
+      iIdx = 1+pConfig->nPrefix;
+    }else
+#endif
+    if( flags & FTS5INDEX_QUERY_PREFIX ){
+      int nChar = fts5IndexCharlen(pToken, nToken);
+      for(iIdx=1; iIdx<=pConfig->nPrefix; iIdx++){
+        if( pConfig->aPrefix[iIdx-1]==nChar ) break;
+      }
+    }
+
+    if( iIdx<=pConfig->nPrefix ){
+      Fts5Structure *pStruct = fts5StructureRead(p);
+      buf.p[0] = FTS5_MAIN_PREFIX + iIdx;
+      if( pStruct ){
+        fts5MultiIterNew(p, pStruct, 1, flags, buf.p, nToken+1, -1, 0, &pRet);
+        fts5StructureRelease(pStruct);
+      }
+    }else{
+      int bDesc = (flags & FTS5INDEX_QUERY_DESC)!=0;
+      buf.p[0] = FTS5_MAIN_PREFIX;
+      fts5SetupPrefixIter(p, bDesc, buf.p, nToken+1, pColset, &pRet);
+    }
+
+    if( p->rc ){
+      sqlite3Fts5IterClose(pRet);
+      pRet = 0;
+      fts5CloseReader(p);
+    }
+    *ppIter = pRet;
+    sqlite3Fts5BufferFree(&buf);
+  }
+  return fts5IndexReturn(p);
+}
+
+/*
+** Return true if the iterator passed as the only argument is at EOF.
+*/
+static int sqlite3Fts5IterEof(Fts5IndexIter *pIter){
+  assert( pIter->pIndex->rc==SQLITE_OK );
+  return pIter->bEof;
+}
+
+/*
+** Move to the next matching rowid. 
+*/
+static int sqlite3Fts5IterNext(Fts5IndexIter *pIter){
+  assert( pIter->pIndex->rc==SQLITE_OK );
+  fts5MultiIterNext(pIter->pIndex, pIter, 0, 0);
+  return fts5IndexReturn(pIter->pIndex);
+}
+
+/*
+** Move to the next matching term/rowid. Used by the fts5vocab module.
+*/
+static int sqlite3Fts5IterNextScan(Fts5IndexIter *pIter){
+  Fts5Index *p = pIter->pIndex;
+
+  assert( pIter->pIndex->rc==SQLITE_OK );
+
+  fts5MultiIterNext(p, pIter, 0, 0);
+  if( p->rc==SQLITE_OK ){
+    Fts5SegIter *pSeg = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
+    if( pSeg->pLeaf && pSeg->term.p[0]!=FTS5_MAIN_PREFIX ){
+      fts5DataRelease(pSeg->pLeaf);
+      pSeg->pLeaf = 0;
+      pIter->bEof = 1;
+    }
+  }
+
+  return fts5IndexReturn(pIter->pIndex);
+}
+
+/*
+** Move to the next matching rowid that occurs at or after iMatch. The
+** definition of "at or after" depends on whether this iterator iterates
+** in ascending or descending rowid order.
+*/
+static int sqlite3Fts5IterNextFrom(Fts5IndexIter *pIter, i64 iMatch){
+  fts5MultiIterNextFrom(pIter->pIndex, pIter, iMatch);
+  return fts5IndexReturn(pIter->pIndex);
+}
+
+/*
+** Return the current rowid.
+*/
+static i64 sqlite3Fts5IterRowid(Fts5IndexIter *pIter){
+  return fts5MultiIterRowid(pIter);
+}
+
+/*
+** Return the current term.
+*/
+static const char *sqlite3Fts5IterTerm(Fts5IndexIter *pIter, int *pn){
+  int n;
+  const char *z = (const char*)fts5MultiIterTerm(pIter, &n);
+  *pn = n-1;
+  return &z[1];
+}
+
+
+static int fts5IndexExtractColset (
+  Fts5Colset *pColset,            /* Colset to filter on */
+  const u8 *pPos, int nPos,       /* Position list */
+  Fts5Buffer *pBuf                /* Output buffer */
+){
+  int rc = SQLITE_OK;
+  int i;
+
+  fts5BufferZero(pBuf);
+  for(i=0; i<pColset->nCol; i++){
+    const u8 *pSub = pPos;
+    int nSub = fts5IndexExtractCol(&pSub, nPos, pColset->aiCol[i]);
+    if( nSub ){
+      fts5BufferAppendBlob(&rc, pBuf, nSub, pSub);
+    }
+  }
+  return rc;
+}
+
+
+/*
+** Return a pointer to a buffer containing a copy of the position list for
+** the current entry. Output variable *pn is set to the size of the buffer 
+** in bytes before returning.
+**
+** The returned position list does not include the "number of bytes" varint
+** field that starts the position list on disk.
+*/
+static int sqlite3Fts5IterPoslist(
+  Fts5IndexIter *pIter, 
+  Fts5Colset *pColset,            /* Column filter (or NULL) */
+  const u8 **pp,                  /* OUT: Pointer to position-list data */
+  int *pn,                        /* OUT: Size of position-list in bytes */
+  i64 *piRowid                    /* OUT: Current rowid */
+){
+  Fts5SegIter *pSeg = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
+  assert( pIter->pIndex->rc==SQLITE_OK );
+  *piRowid = pSeg->iRowid;
+  if( pSeg->iLeafOffset+pSeg->nPos<=pSeg->pLeaf->szLeaf ){
+    u8 *pPos = &pSeg->pLeaf->p[pSeg->iLeafOffset];
+    if( pColset==0 || pIter->bFiltered ){
+      *pn = pSeg->nPos;
+      *pp = pPos;
+    }else if( pColset->nCol==1 ){
+      *pp = pPos;
+      *pn = fts5IndexExtractCol(pp, pSeg->nPos, pColset->aiCol[0]);
+    }else{
+      fts5BufferZero(&pIter->poslist);
+      fts5IndexExtractColset(pColset, pPos, pSeg->nPos, &pIter->poslist);
+      *pp = pIter->poslist.p;
+      *pn = pIter->poslist.n;
+    }
+  }else{
+    fts5BufferZero(&pIter->poslist);
+    fts5SegiterPoslist(pIter->pIndex, pSeg, pColset, &pIter->poslist);
+    *pp = pIter->poslist.p;
+    *pn = pIter->poslist.n;
+  }
+  return fts5IndexReturn(pIter->pIndex);
+}
+
+/*
+** This function is similar to sqlite3Fts5IterPoslist(), except that it
+** copies the position list into the buffer supplied as the second 
+** argument.
+*/
+static int sqlite3Fts5IterPoslistBuffer(Fts5IndexIter *pIter, Fts5Buffer *pBuf){
+  Fts5Index *p = pIter->pIndex;
+  Fts5SegIter *pSeg = &pIter->aSeg[ pIter->aFirst[1].iFirst ];
+  assert( p->rc==SQLITE_OK );
+  fts5BufferZero(pBuf);
+  fts5SegiterPoslist(p, pSeg, 0, pBuf);
+  return fts5IndexReturn(p);
+}
+
+/*
+** Close an iterator opened by an earlier call to sqlite3Fts5IndexQuery().
+*/
+static void sqlite3Fts5IterClose(Fts5IndexIter *pIter){
+  if( pIter ){
+    Fts5Index *pIndex = pIter->pIndex;
+    fts5MultiIterFree(pIter->pIndex, pIter);
+    fts5CloseReader(pIndex);
+  }
+}
+
+/*
+** Read and decode the "averages" record from the database. 
+**
+** Parameter anSize must point to an array of size nCol, where nCol is
+** the number of user defined columns in the FTS table.
+*/
+static int sqlite3Fts5IndexGetAverages(Fts5Index *p, i64 *pnRow, i64 *anSize){
+  int nCol = p->pConfig->nCol;
+  Fts5Data *pData;
+
+  *pnRow = 0;
+  memset(anSize, 0, sizeof(i64) * nCol);
+  pData = fts5DataRead(p, FTS5_AVERAGES_ROWID);
+  if( p->rc==SQLITE_OK && pData->nn ){
+    int i = 0;
+    int iCol;
+    i += fts5GetVarint(&pData->p[i], (u64*)pnRow);
+    for(iCol=0; i<pData->nn && iCol<nCol; iCol++){
+      i += fts5GetVarint(&pData->p[i], (u64*)&anSize[iCol]);
+    }
+  }
+
+  fts5DataRelease(pData);
+  return fts5IndexReturn(p);
+}
+
+/*
+** Replace the current "averages" record with the contents of the buffer 
+** supplied as the second argument.
+*/
+static int sqlite3Fts5IndexSetAverages(Fts5Index *p, const u8 *pData, int nData){
+  assert( p->rc==SQLITE_OK );
+  fts5DataWrite(p, FTS5_AVERAGES_ROWID, pData, nData);
+  return fts5IndexReturn(p);
+}
+
+/*
+** Return the total number of blocks this module has read from the %_data
+** table since it was created.
+*/
+static int sqlite3Fts5IndexReads(Fts5Index *p){
+  return p->nRead;
+}
+
+/*
+** Set the 32-bit cookie value stored at the start of all structure 
+** records to the value passed as the second argument.
+**
+** Return SQLITE_OK if successful, or an SQLite error code if an error
+** occurs.
+*/
+static int sqlite3Fts5IndexSetCookie(Fts5Index *p, int iNew){
+  int rc;                              /* Return code */
+  Fts5Config *pConfig = p->pConfig;    /* Configuration object */
+  u8 aCookie[4];                       /* Binary representation of iNew */
+  sqlite3_blob *pBlob = 0;
+
+  assert( p->rc==SQLITE_OK );
+  sqlite3Fts5Put32(aCookie, iNew);
+
+  rc = sqlite3_blob_open(pConfig->db, pConfig->zDb, p->zDataTbl, 
+      "block", FTS5_STRUCTURE_ROWID, 1, &pBlob
+  );
+  if( rc==SQLITE_OK ){
+    sqlite3_blob_write(pBlob, aCookie, 4, 0);
+    rc = sqlite3_blob_close(pBlob);
+  }
+
+  return rc;
+}
+
+static int sqlite3Fts5IndexLoadConfig(Fts5Index *p){
+  Fts5Structure *pStruct;
+  pStruct = fts5StructureRead(p);
+  fts5StructureRelease(pStruct);
+  return fts5IndexReturn(p);
+}
+
+
+/*************************************************************************
+**************************************************************************
+** Below this point is the implementation of the integrity-check 
+** functionality.
+*/
+
+/*
+** Return a simple checksum value based on the arguments.
+*/
+static u64 fts5IndexEntryCksum(
+  i64 iRowid, 
+  int iCol, 
+  int iPos, 
+  int iIdx,
+  const char *pTerm,
+  int nTerm
+){
+  int i;
+  u64 ret = iRowid;
+  ret += (ret<<3) + iCol;
+  ret += (ret<<3) + iPos;
+  if( iIdx>=0 ) ret += (ret<<3) + (FTS5_MAIN_PREFIX + iIdx);
+  for(i=0; i<nTerm; i++) ret += (ret<<3) + pTerm[i];
+  return ret;
+}
+
+#ifdef SQLITE_DEBUG
+/*
+** This function is purely an internal test. It does not contribute to 
+** FTS functionality, or even the integrity-check, in any way.
+**
+** Instead, it tests that the same set of pgno/rowid combinations are 
+** visited regardless of whether the doclist-index identified by parameters
+** iSegid/iLeaf is iterated in forwards or reverse order.
+*/
+static void fts5TestDlidxReverse(
+  Fts5Index *p, 
+  int iSegid,                     /* Segment id to load from */
+  int iLeaf                       /* Load doclist-index for this leaf */
+){
+  Fts5DlidxIter *pDlidx = 0;
+  u64 cksum1 = 13;
+  u64 cksum2 = 13;
+
+  for(pDlidx=fts5DlidxIterInit(p, 0, iSegid, iLeaf);
+      fts5DlidxIterEof(p, pDlidx)==0;
+      fts5DlidxIterNext(p, pDlidx)
+  ){
+    i64 iRowid = fts5DlidxIterRowid(pDlidx);
+    int pgno = fts5DlidxIterPgno(pDlidx);
+    assert( pgno>iLeaf );
+    cksum1 += iRowid + ((i64)pgno<<32);
+  }
+  fts5DlidxIterFree(pDlidx);
+  pDlidx = 0;
+
+  for(pDlidx=fts5DlidxIterInit(p, 1, iSegid, iLeaf);
+      fts5DlidxIterEof(p, pDlidx)==0;
+      fts5DlidxIterPrev(p, pDlidx)
+  ){
+    i64 iRowid = fts5DlidxIterRowid(pDlidx);
+    int pgno = fts5DlidxIterPgno(pDlidx);
+    assert( fts5DlidxIterPgno(pDlidx)>iLeaf );
+    cksum2 += iRowid + ((i64)pgno<<32);
+  }
+  fts5DlidxIterFree(pDlidx);
+  pDlidx = 0;
+
+  if( p->rc==SQLITE_OK && cksum1!=cksum2 ) p->rc = FTS5_CORRUPT;
+}
+
+static int fts5QueryCksum(
+  Fts5Index *p,                   /* Fts5 index object */
+  int iIdx,
+  const char *z,                  /* Index key to query for */
+  int n,                          /* Size of index key in bytes */
+  int flags,                      /* Flags for Fts5IndexQuery */
+  u64 *pCksum                     /* IN/OUT: Checksum value */
+){
+  u64 cksum = *pCksum;
+  Fts5IndexIter *pIdxIter = 0;
+  int rc = sqlite3Fts5IndexQuery(p, z, n, flags, 0, &pIdxIter);
+
+  while( rc==SQLITE_OK && 0==sqlite3Fts5IterEof(pIdxIter) ){
+    i64 dummy;
+    const u8 *pPos;
+    int nPos;
+    i64 rowid = sqlite3Fts5IterRowid(pIdxIter);
+    rc = sqlite3Fts5IterPoslist(pIdxIter, 0, &pPos, &nPos, &dummy);
+    if( rc==SQLITE_OK ){
+      Fts5PoslistReader sReader;
+      for(sqlite3Fts5PoslistReaderInit(pPos, nPos, &sReader);
+          sReader.bEof==0;
+          sqlite3Fts5PoslistReaderNext(&sReader)
+      ){
+        int iCol = FTS5_POS2COLUMN(sReader.iPos);
+        int iOff = FTS5_POS2OFFSET(sReader.iPos);
+        cksum ^= fts5IndexEntryCksum(rowid, iCol, iOff, iIdx, z, n);
+      }
+      rc = sqlite3Fts5IterNext(pIdxIter);
+    }
+  }
+  sqlite3Fts5IterClose(pIdxIter);
+
+  *pCksum = cksum;
+  return rc;
+}
+
+
+/*
+** This function is also purely an internal test. It does not contribute to 
+** FTS functionality, or even the integrity-check, in any way.
+*/
+static void fts5TestTerm(
+  Fts5Index *p, 
+  Fts5Buffer *pPrev,              /* Previous term */
+  const char *z, int n,           /* Possibly new term to test */
+  u64 expected,
+  u64 *pCksum
+){
+  int rc = p->rc;
+  if( pPrev->n==0 ){
+    fts5BufferSet(&rc, pPrev, n, (const u8*)z);
+  }else
+  if( rc==SQLITE_OK && (pPrev->n!=n || memcmp(pPrev->p, z, n)) ){
+    u64 cksum3 = *pCksum;
+    const char *zTerm = (const char*)&pPrev->p[1];  /* term sans prefix-byte */
+    int nTerm = pPrev->n-1;            /* Size of zTerm in bytes */
+    int iIdx = (pPrev->p[0] - FTS5_MAIN_PREFIX);
+    int flags = (iIdx==0 ? 0 : FTS5INDEX_QUERY_PREFIX);
+    u64 ck1 = 0;
+    u64 ck2 = 0;
+
+    /* Check that the results returned for ASC and DESC queries are
+    ** the same. If not, call this corruption.  */
+    rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, flags, &ck1);
+    if( rc==SQLITE_OK ){
+      int f = flags|FTS5INDEX_QUERY_DESC;
+      rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);
+    }
+    if( rc==SQLITE_OK && ck1!=ck2 ) rc = FTS5_CORRUPT;
+
+    /* If this is a prefix query, check that the results returned if the
+    ** the index is disabled are the same. In both ASC and DESC order. 
+    **
+    ** This check may only be performed if the hash table is empty. This
+    ** is because the hash table only supports a single scan query at
+    ** a time, and the multi-iter loop from which this function is called
+    ** is already performing such a scan. */
+    if( p->nPendingData==0 ){
+      if( iIdx>0 && rc==SQLITE_OK ){
+        int f = flags|FTS5INDEX_QUERY_TEST_NOIDX;
+        ck2 = 0;
+        rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);
+        if( rc==SQLITE_OK && ck1!=ck2 ) rc = FTS5_CORRUPT;
+      }
+      if( iIdx>0 && rc==SQLITE_OK ){
+        int f = flags|FTS5INDEX_QUERY_TEST_NOIDX|FTS5INDEX_QUERY_DESC;
+        ck2 = 0;
+        rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);
+        if( rc==SQLITE_OK && ck1!=ck2 ) rc = FTS5_CORRUPT;
+      }
+    }
+
+    cksum3 ^= ck1;
+    fts5BufferSet(&rc, pPrev, n, (const u8*)z);
+
+    if( rc==SQLITE_OK && cksum3!=expected ){
+      rc = FTS5_CORRUPT;
+    }
+    *pCksum = cksum3;
+  }
+  p->rc = rc;
+}
+ 
+#else
+# define fts5TestDlidxReverse(x,y,z)
+# define fts5TestTerm(u,v,w,x,y,z)
+#endif
+
+/*
+** Check that:
+**
+**   1) All leaves of pSeg between iFirst and iLast (inclusive) exist and
+**      contain zero terms.
+**   2) All leaves of pSeg between iNoRowid and iLast (inclusive) exist and
+**      contain zero rowids.
+*/
+static void fts5IndexIntegrityCheckEmpty(
+  Fts5Index *p,
+  Fts5StructureSegment *pSeg,     /* Segment to check internal consistency */
+  int iFirst,
+  int iNoRowid,
+  int iLast
+){
+  int i;
+
+  /* Now check that the iter.nEmpty leaves following the current leaf
+  ** (a) exist and (b) contain no terms. */
+  for(i=iFirst; p->rc==SQLITE_OK && i<=iLast; i++){
+    Fts5Data *pLeaf = fts5DataRead(p, FTS5_SEGMENT_ROWID(pSeg->iSegid, i));
+    if( pLeaf ){
+      if( !fts5LeafIsTermless(pLeaf) ) p->rc = FTS5_CORRUPT;
+      if( i>=iNoRowid && 0!=fts5LeafFirstRowidOff(pLeaf) ) p->rc = FTS5_CORRUPT;
+    }
+    fts5DataRelease(pLeaf);
+  }
+}
+
+static void fts5IntegrityCheckPgidx(Fts5Index *p, Fts5Data *pLeaf){
+  int iTermOff = 0;
+  int ii;
+
+  Fts5Buffer buf1 = {0,0,0};
+  Fts5Buffer buf2 = {0,0,0};
+
+  ii = pLeaf->szLeaf;
+  while( ii<pLeaf->nn && p->rc==SQLITE_OK ){
+    int res;
+    int iOff;
+    int nIncr;
+
+    ii += fts5GetVarint32(&pLeaf->p[ii], nIncr);
+    iTermOff += nIncr;
+    iOff = iTermOff;
+
+    if( iOff>=pLeaf->szLeaf ){
+      p->rc = FTS5_CORRUPT;
+    }else if( iTermOff==nIncr ){
+      int nByte;
+      iOff += fts5GetVarint32(&pLeaf->p[iOff], nByte);
+      if( (iOff+nByte)>pLeaf->szLeaf ){
+        p->rc = FTS5_CORRUPT;
+      }else{
+        fts5BufferSet(&p->rc, &buf1, nByte, &pLeaf->p[iOff]);
+      }
+    }else{
+      int nKeep, nByte;
+      iOff += fts5GetVarint32(&pLeaf->p[iOff], nKeep);
+      iOff += fts5GetVarint32(&pLeaf->p[iOff], nByte);
+      if( nKeep>buf1.n || (iOff+nByte)>pLeaf->szLeaf ){
+        p->rc = FTS5_CORRUPT;
+      }else{
+        buf1.n = nKeep;
+        fts5BufferAppendBlob(&p->rc, &buf1, nByte, &pLeaf->p[iOff]);
+      }
+
+      if( p->rc==SQLITE_OK ){
+        res = fts5BufferCompare(&buf1, &buf2);
+        if( res<=0 ) p->rc = FTS5_CORRUPT;
+      }
+    }
+    fts5BufferSet(&p->rc, &buf2, buf1.n, buf1.p);
+  }
+
+  fts5BufferFree(&buf1);
+  fts5BufferFree(&buf2);
+}
+
+static void fts5IndexIntegrityCheckSegment(
+  Fts5Index *p,                   /* FTS5 backend object */
+  Fts5StructureSegment *pSeg      /* Segment to check internal consistency */
+){
+  Fts5Config *pConfig = p->pConfig;
+  sqlite3_stmt *pStmt = 0;
+  int rc2;
+  int iIdxPrevLeaf = pSeg->pgnoFirst-1;
+  int iDlidxPrevLeaf = pSeg->pgnoLast;
+
+  if( pSeg->pgnoFirst==0 ) return;
+
+  fts5IndexPrepareStmt(p, &pStmt, sqlite3_mprintf(
+      "SELECT segid, term, (pgno>>1), (pgno&1) FROM %Q.'%q_idx' WHERE segid=%d",
+      pConfig->zDb, pConfig->zName, pSeg->iSegid
+  ));
+
+  /* Iterate through the b-tree hierarchy.  */
+  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){
+    i64 iRow;                     /* Rowid for this leaf */
+    Fts5Data *pLeaf;              /* Data for this leaf */
+
+    int nIdxTerm = sqlite3_column_bytes(pStmt, 1);
+    const char *zIdxTerm = (const char*)sqlite3_column_text(pStmt, 1);
+    int iIdxLeaf = sqlite3_column_int(pStmt, 2);
+    int bIdxDlidx = sqlite3_column_int(pStmt, 3);
+
+    /* If the leaf in question has already been trimmed from the segment, 
+    ** ignore this b-tree entry. Otherwise, load it into memory. */
+    if( iIdxLeaf<pSeg->pgnoFirst ) continue;
+    iRow = FTS5_SEGMENT_ROWID(pSeg->iSegid, iIdxLeaf);
+    pLeaf = fts5DataRead(p, iRow);
+    if( pLeaf==0 ) break;
+
+    /* Check that the leaf contains at least one term, and that it is equal
+    ** to or larger than the split-key in zIdxTerm.  Also check that if there
+    ** is also a rowid pointer within the leaf page header, it points to a
+    ** location before the term.  */
+    if( pLeaf->nn<=pLeaf->szLeaf ){
+      p->rc = FTS5_CORRUPT;
+    }else{
+      int iOff;                   /* Offset of first term on leaf */
+      int iRowidOff;              /* Offset of first rowid on leaf */
+      int nTerm;                  /* Size of term on leaf in bytes */
+      int res;                    /* Comparison of term and split-key */
+
+      iOff = fts5LeafFirstTermOff(pLeaf);
+      iRowidOff = fts5LeafFirstRowidOff(pLeaf);
+      if( iRowidOff>=iOff ){
+        p->rc = FTS5_CORRUPT;
+      }else{
+        iOff += fts5GetVarint32(&pLeaf->p[iOff], nTerm);
+        res = memcmp(&pLeaf->p[iOff], zIdxTerm, MIN(nTerm, nIdxTerm));
+        if( res==0 ) res = nTerm - nIdxTerm;
+        if( res<0 ) p->rc = FTS5_CORRUPT;
+      }
+
+      fts5IntegrityCheckPgidx(p, pLeaf);
+    }
+    fts5DataRelease(pLeaf);
+    if( p->rc ) break;
+
+
+    /* Now check that the iter.nEmpty leaves following the current leaf
+    ** (a) exist and (b) contain no terms. */
+    fts5IndexIntegrityCheckEmpty(
+        p, pSeg, iIdxPrevLeaf+1, iDlidxPrevLeaf+1, iIdxLeaf-1
+    );
+    if( p->rc ) break;
+
+    /* If there is a doclist-index, check that it looks right. */
+    if( bIdxDlidx ){
+      Fts5DlidxIter *pDlidx = 0;  /* For iterating through doclist index */
+      int iPrevLeaf = iIdxLeaf;
+      int iSegid = pSeg->iSegid;
+      int iPg = 0;
+      i64 iKey;
+
+      for(pDlidx=fts5DlidxIterInit(p, 0, iSegid, iIdxLeaf);
+          fts5DlidxIterEof(p, pDlidx)==0;
+          fts5DlidxIterNext(p, pDlidx)
+      ){
+
+        /* Check any rowid-less pages that occur before the current leaf. */
+        for(iPg=iPrevLeaf+1; iPg<fts5DlidxIterPgno(pDlidx); iPg++){
+          iKey = FTS5_SEGMENT_ROWID(iSegid, iPg);
+          pLeaf = fts5DataRead(p, iKey);
+          if( pLeaf ){
+            if( fts5LeafFirstRowidOff(pLeaf)!=0 ) p->rc = FTS5_CORRUPT;
+            fts5DataRelease(pLeaf);
+          }
+        }
+        iPrevLeaf = fts5DlidxIterPgno(pDlidx);
+
+        /* Check that the leaf page indicated by the iterator really does
+        ** contain the rowid suggested by the same. */
+        iKey = FTS5_SEGMENT_ROWID(iSegid, iPrevLeaf);
+        pLeaf = fts5DataRead(p, iKey);
+        if( pLeaf ){
+          i64 iRowid;
+          int iRowidOff = fts5LeafFirstRowidOff(pLeaf);
+          ASSERT_SZLEAF_OK(pLeaf);
+          if( iRowidOff>=pLeaf->szLeaf ){
+            p->rc = FTS5_CORRUPT;
+          }else{
+            fts5GetVarint(&pLeaf->p[iRowidOff], (u64*)&iRowid);
+            if( iRowid!=fts5DlidxIterRowid(pDlidx) ) p->rc = FTS5_CORRUPT;
+          }
+          fts5DataRelease(pLeaf);
+        }
+      }
+
+      iDlidxPrevLeaf = iPg;
+      fts5DlidxIterFree(pDlidx);
+      fts5TestDlidxReverse(p, iSegid, iIdxLeaf);
+    }else{
+      iDlidxPrevLeaf = pSeg->pgnoLast;
+      /* TODO: Check there is no doclist index */
+    }
+
+    iIdxPrevLeaf = iIdxLeaf;
+  }
+
+  rc2 = sqlite3_finalize(pStmt);
+  if( p->rc==SQLITE_OK ) p->rc = rc2;
+
+  /* Page iter.iLeaf must now be the rightmost leaf-page in the segment */
+#if 0
+  if( p->rc==SQLITE_OK && iter.iLeaf!=pSeg->pgnoLast ){
+    p->rc = FTS5_CORRUPT;
+  }
+#endif
+}
+
+
+/*
+** Run internal checks to ensure that the FTS index (a) is internally 
+** consistent and (b) contains entries for which the XOR of the checksums
+** as calculated by fts5IndexEntryCksum() is cksum.
+**
+** Return SQLITE_CORRUPT if any of the internal checks fail, or if the
+** checksum does not match. Return SQLITE_OK if all checks pass without
+** error, or some other SQLite error code if another error (e.g. OOM)
+** occurs.
+*/
+static int sqlite3Fts5IndexIntegrityCheck(Fts5Index *p, u64 cksum){
+  u64 cksum2 = 0;                 /* Checksum based on contents of indexes */
+  Fts5Buffer poslist = {0,0,0};   /* Buffer used to hold a poslist */
+  Fts5IndexIter *pIter;           /* Used to iterate through entire index */
+  Fts5Structure *pStruct;         /* Index structure */
+
+  /* Used by extra internal tests only run if NDEBUG is not defined */
+  u64 cksum3 = 0;                 /* Checksum based on contents of indexes */
+  Fts5Buffer term = {0,0,0};      /* Buffer used to hold most recent term */
+  
+  /* Load the FTS index structure */
+  pStruct = fts5StructureRead(p);
+
+  /* Check that the internal nodes of each segment match the leaves */
+  if( pStruct ){
+    int iLvl, iSeg;
+    for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){
+      for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){
+        Fts5StructureSegment *pSeg = &pStruct->aLevel[iLvl].aSeg[iSeg];
+        fts5IndexIntegrityCheckSegment(p, pSeg);
+      }
+    }
+  }
+
+  /* The cksum argument passed to this function is a checksum calculated
+  ** based on all expected entries in the FTS index (including prefix index
+  ** entries). This block checks that a checksum calculated based on the
+  ** actual contents of FTS index is identical.
+  **
+  ** Two versions of the same checksum are calculated. The first (stack
+  ** variable cksum2) based on entries extracted from the full-text index
+  ** while doing a linear scan of each individual index in turn. 
+  **
+  ** As each term visited by the linear scans, a separate query for the
+  ** same term is performed. cksum3 is calculated based on the entries
+  ** extracted by these queries.
+  */
+  for(fts5MultiIterNew(p, pStruct, 0, 0, 0, 0, -1, 0, &pIter);
+      fts5MultiIterEof(p, pIter)==0;
+      fts5MultiIterNext(p, pIter, 0, 0)
+  ){
+    int n;                      /* Size of term in bytes */
+    i64 iPos = 0;               /* Position read from poslist */
+    int iOff = 0;               /* Offset within poslist */
+    i64 iRowid = fts5MultiIterRowid(pIter);
+    char *z = (char*)fts5MultiIterTerm(pIter, &n);
+
+    /* If this is a new term, query for it. Update cksum3 with the results. */
+    fts5TestTerm(p, &term, z, n, cksum2, &cksum3);
+
+    poslist.n = 0;
+    fts5SegiterPoslist(p, &pIter->aSeg[pIter->aFirst[1].iFirst] , 0, &poslist);
+    while( 0==sqlite3Fts5PoslistNext64(poslist.p, poslist.n, &iOff, &iPos) ){
+      int iCol = FTS5_POS2COLUMN(iPos);
+      int iTokOff = FTS5_POS2OFFSET(iPos);
+      cksum2 ^= fts5IndexEntryCksum(iRowid, iCol, iTokOff, -1, z, n);
+    }
+  }
+  fts5TestTerm(p, &term, 0, 0, cksum2, &cksum3);
+
+  fts5MultiIterFree(p, pIter);
+  if( p->rc==SQLITE_OK && cksum!=cksum2 ) p->rc = FTS5_CORRUPT;
+
+  fts5StructureRelease(pStruct);
+  fts5BufferFree(&term);
+  fts5BufferFree(&poslist);
+  return fts5IndexReturn(p);
+}
+
+
+/*
+** Calculate and return a checksum that is the XOR of the index entry
+** checksum of all entries that would be generated by the token specified
+** by the final 5 arguments.
+*/
+static u64 sqlite3Fts5IndexCksum(
+  Fts5Config *pConfig,            /* Configuration object */
+  i64 iRowid,                     /* Document term appears in */
+  int iCol,                       /* Column term appears in */
+  int iPos,                       /* Position term appears in */
+  const char *pTerm, int nTerm    /* Term at iPos */
+){
+  u64 ret = 0;                    /* Return value */
+  int iIdx;                       /* For iterating through indexes */
+
+  ret = fts5IndexEntryCksum(iRowid, iCol, iPos, 0, pTerm, nTerm);
+
+  for(iIdx=0; iIdx<pConfig->nPrefix; iIdx++){
+    int nByte = fts5IndexCharlenToBytelen(pTerm, nTerm, pConfig->aPrefix[iIdx]);
+    if( nByte ){
+      ret ^= fts5IndexEntryCksum(iRowid, iCol, iPos, iIdx+1, pTerm, nByte);
+    }
+  }
+
+  return ret;
+}
+
+/*************************************************************************
+**************************************************************************
+** Below this point is the implementation of the fts5_decode() scalar
+** function only.
+*/
+
+/*
+** Decode a segment-data rowid from the %_data table. This function is
+** the opposite of macro FTS5_SEGMENT_ROWID().
+*/
+static void fts5DecodeRowid(
+  i64 iRowid,                     /* Rowid from %_data table */
+  int *piSegid,                   /* OUT: Segment id */
+  int *pbDlidx,                   /* OUT: Dlidx flag */
+  int *piHeight,                  /* OUT: Height */
+  int *piPgno                     /* OUT: Page number */
+){
+  *piPgno = (int)(iRowid & (((i64)1 << FTS5_DATA_PAGE_B) - 1));
+  iRowid >>= FTS5_DATA_PAGE_B;
+
+  *piHeight = (int)(iRowid & (((i64)1 << FTS5_DATA_HEIGHT_B) - 1));
+  iRowid >>= FTS5_DATA_HEIGHT_B;
+
+  *pbDlidx = (int)(iRowid & 0x0001);
+  iRowid >>= FTS5_DATA_DLI_B;
+
+  *piSegid = (int)(iRowid & (((i64)1 << FTS5_DATA_ID_B) - 1));
+}
+
+static void fts5DebugRowid(int *pRc, Fts5Buffer *pBuf, i64 iKey){
+  int iSegid, iHeight, iPgno, bDlidx;       /* Rowid compenents */
+  fts5DecodeRowid(iKey, &iSegid, &bDlidx, &iHeight, &iPgno);
+
+  if( iSegid==0 ){
+    if( iKey==FTS5_AVERAGES_ROWID ){
+      sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{averages} ");
+    }else{
+      sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{structure}");
+    }
+  }
+  else{
+    sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{%ssegid=%d h=%d pgno=%d}",
+        bDlidx ? "dlidx " : "", iSegid, iHeight, iPgno
+    );
+  }
+}
+
+static void fts5DebugStructure(
+  int *pRc,                       /* IN/OUT: error code */
+  Fts5Buffer *pBuf,
+  Fts5Structure *p
+){
+  int iLvl, iSeg;                 /* Iterate through levels, segments */
+
+  for(iLvl=0; iLvl<p->nLevel; iLvl++){
+    Fts5StructureLevel *pLvl = &p->aLevel[iLvl];
+    sqlite3Fts5BufferAppendPrintf(pRc, pBuf, 
+        " {lvl=%d nMerge=%d nSeg=%d", iLvl, pLvl->nMerge, pLvl->nSeg
+    );
+    for(iSeg=0; iSeg<pLvl->nSeg; iSeg++){
+      Fts5StructureSegment *pSeg = &pLvl->aSeg[iSeg];
+      sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " {id=%d leaves=%d..%d}", 
+          pSeg->iSegid, pSeg->pgnoFirst, pSeg->pgnoLast
+      );
+    }
+    sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "}");
+  }
+}
+
+/*
+** This is part of the fts5_decode() debugging aid.
+**
+** Arguments pBlob/nBlob contain a serialized Fts5Structure object. This
+** function appends a human-readable representation of the same object
+** to the buffer passed as the second argument. 
+*/
+static void fts5DecodeStructure(
+  int *pRc,                       /* IN/OUT: error code */
+  Fts5Buffer *pBuf,
+  const u8 *pBlob, int nBlob
+){
+  int rc;                         /* Return code */
+  Fts5Structure *p = 0;           /* Decoded structure object */
+
+  rc = fts5StructureDecode(pBlob, nBlob, 0, &p);
+  if( rc!=SQLITE_OK ){
+    *pRc = rc;
+    return;
+  }
+
+  fts5DebugStructure(pRc, pBuf, p);
+  fts5StructureRelease(p);
+}
+
+/*
+** This is part of the fts5_decode() debugging aid.
+**
+** Arguments pBlob/nBlob contain an "averages" record. This function 
+** appends a human-readable representation of record to the buffer passed 
+** as the second argument. 
+*/
+static void fts5DecodeAverages(
+  int *pRc,                       /* IN/OUT: error code */
+  Fts5Buffer *pBuf,
+  const u8 *pBlob, int nBlob
+){
+  int i = 0;
+  const char *zSpace = "";
+
+  while( i<nBlob ){
+    u64 iVal;
+    i += sqlite3Fts5GetVarint(&pBlob[i], &iVal);
+    sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "%s%d", zSpace, (int)iVal);
+    zSpace = " ";
+  }
+}
+
+/*
+** Buffer (a/n) is assumed to contain a list of serialized varints. Read
+** each varint and append its string representation to buffer pBuf. Return
+** after either the input buffer is exhausted or a 0 value is read.
+**
+** The return value is the number of bytes read from the input buffer.
+*/
+static int fts5DecodePoslist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n){
+  int iOff = 0;
+  while( iOff<n ){
+    int iVal;
+    iOff += fts5GetVarint32(&a[iOff], iVal);
+    sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " %d", iVal);
+  }
+  return iOff;
+}
+
+/*
+** The start of buffer (a/n) contains the start of a doclist. The doclist
+** may or may not finish within the buffer. This function appends a text
+** representation of the part of the doclist that is present to buffer
+** pBuf. 
+**
+** The return value is the number of bytes read from the input buffer.
+*/
+static int fts5DecodeDoclist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n){
+  i64 iDocid = 0;
+  int iOff = 0;
+
+  if( n>0 ){
+    iOff = sqlite3Fts5GetVarint(a, (u64*)&iDocid);
+    sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " id=%lld", iDocid);
+  }
+  while( iOff<n ){
+    int nPos;
+    int bDummy;
+    iOff += fts5GetPoslistSize(&a[iOff], &nPos, &bDummy);
+    iOff += fts5DecodePoslist(pRc, pBuf, &a[iOff], MIN(n-iOff, nPos));
+    if( iOff<n ){
+      i64 iDelta;
+      iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&iDelta);
+      iDocid += iDelta;
+      sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " id=%lld", iDocid);
+    }
+  }
+
+  return iOff;
+}
+
+/*
+** The implementation of user-defined scalar function fts5_decode().
+*/
+static void fts5DecodeFunction(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args (always 2) */
+  sqlite3_value **apVal           /* Function arguments */
+){
+  i64 iRowid;                     /* Rowid for record being decoded */
+  int iSegid,iHeight,iPgno,bDlidx;/* Rowid components */
+  const u8 *aBlob; int n;         /* Record to decode */
+  u8 *a = 0;
+  Fts5Buffer s;                   /* Build up text to return here */
+  int rc = SQLITE_OK;             /* Return code */
+  int nSpace = 0;
+
+  assert( nArg==2 );
+  memset(&s, 0, sizeof(Fts5Buffer));
+  iRowid = sqlite3_value_int64(apVal[0]);
+
+  /* Make a copy of the second argument (a blob) in aBlob[]. The aBlob[]
+  ** copy is followed by FTS5_DATA_ZERO_PADDING 0x00 bytes, which prevents
+  ** buffer overreads even if the record is corrupt.  */
+  n = sqlite3_value_bytes(apVal[1]);
+  aBlob = sqlite3_value_blob(apVal[1]);
+  nSpace = n + FTS5_DATA_ZERO_PADDING;
+  a = (u8*)sqlite3Fts5MallocZero(&rc, nSpace);
+  if( a==0 ) goto decode_out;
+  memcpy(a, aBlob, n);
+
+
+  fts5DecodeRowid(iRowid, &iSegid, &bDlidx, &iHeight, &iPgno);
+
+  fts5DebugRowid(&rc, &s, iRowid);
+  if( bDlidx ){
+    Fts5Data dlidx;
+    Fts5DlidxLvl lvl;
+
+    dlidx.p = a;
+    dlidx.nn = n;
+
+    memset(&lvl, 0, sizeof(Fts5DlidxLvl));
+    lvl.pData = &dlidx;
+    lvl.iLeafPgno = iPgno;
+
+    for(fts5DlidxLvlNext(&lvl); lvl.bEof==0; fts5DlidxLvlNext(&lvl)){
+      sqlite3Fts5BufferAppendPrintf(&rc, &s, 
+          " %d(%lld)", lvl.iLeafPgno, lvl.iRowid
+      );
+    }
+  }else if( iSegid==0 ){
+    if( iRowid==FTS5_AVERAGES_ROWID ){
+      fts5DecodeAverages(&rc, &s, a, n);
+    }else{
+      fts5DecodeStructure(&rc, &s, a, n);
+    }
+  }else{
+    Fts5Buffer term;              /* Current term read from page */
+    int szLeaf;                   /* Offset of pgidx in a[] */
+    int iPgidxOff;
+    int iPgidxPrev = 0;           /* Previous value read from pgidx */
+    int iTermOff = 0;
+    int iRowidOff = 0;
+    int iOff;
+    int nDoclist;
+
+    memset(&term, 0, sizeof(Fts5Buffer));
+
+    if( n<4 ){
+      sqlite3Fts5BufferSet(&rc, &s, 7, (const u8*)"corrupt");
+      goto decode_out;
+    }else{
+      iRowidOff = fts5GetU16(&a[0]);
+      iPgidxOff = szLeaf = fts5GetU16(&a[2]);
+      if( iPgidxOff<n ){
+        fts5GetVarint32(&a[iPgidxOff], iTermOff);
+      }
+    }
+
+    /* Decode the position list tail at the start of the page */
+    if( iRowidOff!=0 ){
+      iOff = iRowidOff;
+    }else if( iTermOff!=0 ){
+      iOff = iTermOff;
+    }else{
+      iOff = szLeaf;
+    }
+    fts5DecodePoslist(&rc, &s, &a[4], iOff-4);
+
+    /* Decode any more doclist data that appears on the page before the
+    ** first term. */
+    nDoclist = (iTermOff ? iTermOff : szLeaf) - iOff;
+    fts5DecodeDoclist(&rc, &s, &a[iOff], nDoclist);
+
+    while( iPgidxOff<n ){
+      int bFirst = (iPgidxOff==szLeaf);     /* True for first term on page */
+      int nByte;                            /* Bytes of data */
+      int iEnd;
+      
+      iPgidxOff += fts5GetVarint32(&a[iPgidxOff], nByte);
+      iPgidxPrev += nByte;
+      iOff = iPgidxPrev;
+
+      if( iPgidxOff<n ){
+        fts5GetVarint32(&a[iPgidxOff], nByte);
+        iEnd = iPgidxPrev + nByte;
+      }else{
+        iEnd = szLeaf;
+      }
+
+      if( bFirst==0 ){
+        iOff += fts5GetVarint32(&a[iOff], nByte);
+        term.n = nByte;
+      }
+      iOff += fts5GetVarint32(&a[iOff], nByte);
+      fts5BufferAppendBlob(&rc, &term, nByte, &a[iOff]);
+      iOff += nByte;
+
+      sqlite3Fts5BufferAppendPrintf(
+          &rc, &s, " term=%.*s", term.n, (const char*)term.p
+      );
+      iOff += fts5DecodeDoclist(&rc, &s, &a[iOff], iEnd-iOff);
+    }
+
+    fts5BufferFree(&term);
+  }
+  
+ decode_out:
+  sqlite3_free(a);
+  if( rc==SQLITE_OK ){
+    sqlite3_result_text(pCtx, (const char*)s.p, s.n, SQLITE_TRANSIENT);
+  }else{
+    sqlite3_result_error_code(pCtx, rc);
+  }
+  fts5BufferFree(&s);
+}
+
+/*
+** The implementation of user-defined scalar function fts5_rowid().
+*/
+static void fts5RowidFunction(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args (always 2) */
+  sqlite3_value **apVal           /* Function arguments */
+){
+  const char *zArg;
+  if( nArg==0 ){
+    sqlite3_result_error(pCtx, "should be: fts5_rowid(subject, ....)", -1);
+  }else{
+    zArg = (const char*)sqlite3_value_text(apVal[0]);
+    if( 0==sqlite3_stricmp(zArg, "segment") ){
+      i64 iRowid;
+      int segid, pgno;
+      if( nArg!=3 ){
+        sqlite3_result_error(pCtx, 
+            "should be: fts5_rowid('segment', segid, pgno))", -1
+        );
+      }else{
+        segid = sqlite3_value_int(apVal[1]);
+        pgno = sqlite3_value_int(apVal[2]);
+        iRowid = FTS5_SEGMENT_ROWID(segid, pgno);
+        sqlite3_result_int64(pCtx, iRowid);
+      }
+    }else{
+      sqlite3_result_error(pCtx, 
+        "first arg to fts5_rowid() must be 'segment'" , -1
+      );
+    }
+  }
+}
+
+/*
+** This is called as part of registering the FTS5 module with database
+** connection db. It registers several user-defined scalar functions useful
+** with FTS5.
+**
+** If successful, SQLITE_OK is returned. If an error occurs, some other
+** SQLite error code is returned instead.
+*/
+static int sqlite3Fts5IndexInit(sqlite3 *db){
+  int rc = sqlite3_create_function(
+      db, "fts5_decode", 2, SQLITE_UTF8, 0, fts5DecodeFunction, 0, 0
+  );
+  if( rc==SQLITE_OK ){
+    rc = sqlite3_create_function(
+        db, "fts5_rowid", -1, SQLITE_UTF8, 0, fts5RowidFunction, 0, 0
+    );
+  }
+  return rc;
+}
+
+
+/*
+** 2014 Jun 09
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** This is an SQLite module implementing full-text search.
+*/
+
+
+
+/*
+** This variable is set to false when running tests for which the on disk
+** structures should not be corrupt. Otherwise, true. If it is false, extra
+** assert() conditions in the fts5 code are activated - conditions that are
+** only true if it is guaranteed that the fts5 database is not corrupt.
+*/
+SQLITE_API int sqlite3_fts5_may_be_corrupt = 1;
+
+
+typedef struct Fts5Auxdata Fts5Auxdata;
+typedef struct Fts5Auxiliary Fts5Auxiliary;
+typedef struct Fts5Cursor Fts5Cursor;
+typedef struct Fts5Sorter Fts5Sorter;
+typedef struct Fts5Table Fts5Table;
+typedef struct Fts5TokenizerModule Fts5TokenizerModule;
+
+/*
+** NOTES ON TRANSACTIONS: 
+**
+** SQLite invokes the following virtual table methods as transactions are 
+** opened and closed by the user:
+**
+**     xBegin():    Start of a new transaction.
+**     xSync():     Initial part of two-phase commit.
+**     xCommit():   Final part of two-phase commit.
+**     xRollback(): Rollback the transaction.
+**
+** Anything that is required as part of a commit that may fail is performed
+** in the xSync() callback. Current versions of SQLite ignore any errors 
+** returned by xCommit().
+**
+** And as sub-transactions are opened/closed:
+**
+**     xSavepoint(int S):  Open savepoint S.
+**     xRelease(int S):    Commit and close savepoint S.
+**     xRollbackTo(int S): Rollback to start of savepoint S.
+**
+** During a write-transaction the fts5_index.c module may cache some data 
+** in-memory. It is flushed to disk whenever xSync(), xRelease() or
+** xSavepoint() is called. And discarded whenever xRollback() or xRollbackTo() 
+** is called.
+**
+** Additionally, if SQLITE_DEBUG is defined, an instance of the following
+** structure is used to record the current transaction state. This information
+** is not required, but it is used in the assert() statements executed by
+** function fts5CheckTransactionState() (see below).
+*/
+struct Fts5TransactionState {
+  int eState;                     /* 0==closed, 1==open, 2==synced */
+  int iSavepoint;                 /* Number of open savepoints (0 -> none) */
+};
+
+/*
+** A single object of this type is allocated when the FTS5 module is 
+** registered with a database handle. It is used to store pointers to
+** all registered FTS5 extensions - tokenizers and auxiliary functions.
+*/
+struct Fts5Global {
+  fts5_api api;                   /* User visible part of object (see fts5.h) */
+  sqlite3 *db;                    /* Associated database connection */ 
+  i64 iNextId;                    /* Used to allocate unique cursor ids */
+  Fts5Auxiliary *pAux;            /* First in list of all aux. functions */
+  Fts5TokenizerModule *pTok;      /* First in list of all tokenizer modules */
+  Fts5TokenizerModule *pDfltTok;  /* Default tokenizer module */
+  Fts5Cursor *pCsr;               /* First in list of all open cursors */
+};
+
+/*
+** Each auxiliary function registered with the FTS5 module is represented
+** by an object of the following type. All such objects are stored as part
+** of the Fts5Global.pAux list.
+*/
+struct Fts5Auxiliary {
+  Fts5Global *pGlobal;            /* Global context for this function */
+  char *zFunc;                    /* Function name (nul-terminated) */
+  void *pUserData;                /* User-data pointer */
+  fts5_extension_function xFunc;  /* Callback function */
+  void (*xDestroy)(void*);        /* Destructor function */
+  Fts5Auxiliary *pNext;           /* Next registered auxiliary function */
+};
+
+/*
+** Each tokenizer module registered with the FTS5 module is represented
+** by an object of the following type. All such objects are stored as part
+** of the Fts5Global.pTok list.
+*/
+struct Fts5TokenizerModule {
+  char *zName;                    /* Name of tokenizer */
+  void *pUserData;                /* User pointer passed to xCreate() */
+  fts5_tokenizer x;               /* Tokenizer functions */
+  void (*xDestroy)(void*);        /* Destructor function */
+  Fts5TokenizerModule *pNext;     /* Next registered tokenizer module */
+};
+
+/*
+** Virtual-table object.
+*/
+struct Fts5Table {
+  sqlite3_vtab base;              /* Base class used by SQLite core */
+  Fts5Config *pConfig;            /* Virtual table configuration */
+  Fts5Index *pIndex;              /* Full-text index */
+  Fts5Storage *pStorage;          /* Document store */
+  Fts5Global *pGlobal;            /* Global (connection wide) data */
+  Fts5Cursor *pSortCsr;           /* Sort data from this cursor */
+#ifdef SQLITE_DEBUG
+  struct Fts5TransactionState ts;
+#endif
+};
+
+struct Fts5MatchPhrase {
+  Fts5Buffer *pPoslist;           /* Pointer to current poslist */
+  int nTerm;                      /* Size of phrase in terms */
+};
+
+/*
+** pStmt:
+**   SELECT rowid, <fts> FROM <fts> ORDER BY +rank;
+**
+** aIdx[]:
+**   There is one entry in the aIdx[] array for each phrase in the query,
+**   the value of which is the offset within aPoslist[] following the last 
+**   byte of the position list for the corresponding phrase.
+*/
+struct Fts5Sorter {
+  sqlite3_stmt *pStmt;
+  i64 iRowid;                     /* Current rowid */
+  const u8 *aPoslist;             /* Position lists for current row */
+  int nIdx;                       /* Number of entries in aIdx[] */
+  int aIdx[1];                    /* Offsets into aPoslist for current row */
+};
+
+
+/*
+** Virtual-table cursor object.
+**
+** iSpecial:
+**   If this is a 'special' query (refer to function fts5SpecialMatch()), 
+**   then this variable contains the result of the query. 
+**
+** iFirstRowid, iLastRowid:
+**   These variables are only used for FTS5_PLAN_MATCH cursors. Assuming the
+**   cursor iterates in ascending order of rowids, iFirstRowid is the lower
+**   limit of rowids to return, and iLastRowid the upper. In other words, the
+**   WHERE clause in the user's query might have been:
+**
+**       <tbl> MATCH <expr> AND rowid BETWEEN $iFirstRowid AND $iLastRowid
+**
+**   If the cursor iterates in descending order of rowid, iFirstRowid
+**   is the upper limit (i.e. the "first" rowid visited) and iLastRowid
+**   the lower.
+*/
+struct Fts5Cursor {
+  sqlite3_vtab_cursor base;       /* Base class used by SQLite core */
+  Fts5Cursor *pNext;              /* Next cursor in Fts5Cursor.pCsr list */
+  int *aColumnSize;               /* Values for xColumnSize() */
+  i64 iCsrId;                     /* Cursor id */
+
+  /* Zero from this point onwards on cursor reset */
+  int ePlan;                      /* FTS5_PLAN_XXX value */
+  int bDesc;                      /* True for "ORDER BY rowid DESC" queries */
+  i64 iFirstRowid;                /* Return no rowids earlier than this */
+  i64 iLastRowid;                 /* Return no rowids later than this */
+  sqlite3_stmt *pStmt;            /* Statement used to read %_content */
+  Fts5Expr *pExpr;                /* Expression for MATCH queries */
+  Fts5Sorter *pSorter;            /* Sorter for "ORDER BY rank" queries */
+  int csrflags;                   /* Mask of cursor flags (see below) */
+  i64 iSpecial;                   /* Result of special query */
+
+  /* "rank" function. Populated on demand from vtab.xColumn(). */
+  char *zRank;                    /* Custom rank function */
+  char *zRankArgs;                /* Custom rank function args */
+  Fts5Auxiliary *pRank;           /* Rank callback (or NULL) */
+  int nRankArg;                   /* Number of trailing arguments for rank() */
+  sqlite3_value **apRankArg;      /* Array of trailing arguments */
+  sqlite3_stmt *pRankArgStmt;     /* Origin of objects in apRankArg[] */
+
+  /* Auxiliary data storage */
+  Fts5Auxiliary *pAux;            /* Currently executing extension function */
+  Fts5Auxdata *pAuxdata;          /* First in linked list of saved aux-data */
+
+  /* Cache used by auxiliary functions xInst() and xInstCount() */
+  Fts5PoslistReader *aInstIter;   /* One for each phrase */
+  int nInstAlloc;                 /* Size of aInst[] array (entries / 3) */
+  int nInstCount;                 /* Number of phrase instances */
+  int *aInst;                     /* 3 integers per phrase instance */
+};
+
+/*
+** Bits that make up the "idxNum" parameter passed indirectly by 
+** xBestIndex() to xFilter().
+*/
+#define FTS5_BI_MATCH        0x0001         /* <tbl> MATCH ? */
+#define FTS5_BI_RANK         0x0002         /* rank MATCH ? */
+#define FTS5_BI_ROWID_EQ     0x0004         /* rowid == ? */
+#define FTS5_BI_ROWID_LE     0x0008         /* rowid <= ? */
+#define FTS5_BI_ROWID_GE     0x0010         /* rowid >= ? */
+
+#define FTS5_BI_ORDER_RANK   0x0020
+#define FTS5_BI_ORDER_ROWID  0x0040
+#define FTS5_BI_ORDER_DESC   0x0080
+
+/*
+** Values for Fts5Cursor.csrflags
+*/
+#define FTS5CSR_REQUIRE_CONTENT   0x01
+#define FTS5CSR_REQUIRE_DOCSIZE   0x02
+#define FTS5CSR_REQUIRE_INST      0x04
+#define FTS5CSR_EOF               0x08
+#define FTS5CSR_FREE_ZRANK        0x10
+#define FTS5CSR_REQUIRE_RESEEK    0x20
+
+#define BitFlagAllTest(x,y) (((x) & (y))==(y))
+#define BitFlagTest(x,y)    (((x) & (y))!=0)
+
+
+/*
+** Macros to Set(), Clear() and Test() cursor flags.
+*/
+#define CsrFlagSet(pCsr, flag)   ((pCsr)->csrflags |= (flag))
+#define CsrFlagClear(pCsr, flag) ((pCsr)->csrflags &= ~(flag))
+#define CsrFlagTest(pCsr, flag)  ((pCsr)->csrflags & (flag))
+
+struct Fts5Auxdata {
+  Fts5Auxiliary *pAux;            /* Extension to which this belongs */
+  void *pPtr;                     /* Pointer value */
+  void(*xDelete)(void*);          /* Destructor */
+  Fts5Auxdata *pNext;             /* Next object in linked list */
+};
+
+#ifdef SQLITE_DEBUG
+#define FTS5_BEGIN      1
+#define FTS5_SYNC       2
+#define FTS5_COMMIT     3
+#define FTS5_ROLLBACK   4
+#define FTS5_SAVEPOINT  5
+#define FTS5_RELEASE    6
+#define FTS5_ROLLBACKTO 7
+static void fts5CheckTransactionState(Fts5Table *p, int op, int iSavepoint){
+  switch( op ){
+    case FTS5_BEGIN:
+      assert( p->ts.eState==0 );
+      p->ts.eState = 1;
+      p->ts.iSavepoint = -1;
+      break;
+
+    case FTS5_SYNC:
+      assert( p->ts.eState==1 );
+      p->ts.eState = 2;
+      break;
+
+    case FTS5_COMMIT:
+      assert( p->ts.eState==2 );
+      p->ts.eState = 0;
+      break;
+
+    case FTS5_ROLLBACK:
+      assert( p->ts.eState==1 || p->ts.eState==2 || p->ts.eState==0 );
+      p->ts.eState = 0;
+      break;
+
+    case FTS5_SAVEPOINT:
+      assert( p->ts.eState==1 );
+      assert( iSavepoint>=0 );
+      assert( iSavepoint>p->ts.iSavepoint );
+      p->ts.iSavepoint = iSavepoint;
+      break;
+      
+    case FTS5_RELEASE:
+      assert( p->ts.eState==1 );
+      assert( iSavepoint>=0 );
+      assert( iSavepoint<=p->ts.iSavepoint );
+      p->ts.iSavepoint = iSavepoint-1;
+      break;
+
+    case FTS5_ROLLBACKTO:
+      assert( p->ts.eState==1 );
+      assert( iSavepoint>=0 );
+      assert( iSavepoint<=p->ts.iSavepoint );
+      p->ts.iSavepoint = iSavepoint;
+      break;
+  }
+}
+#else
+# define fts5CheckTransactionState(x,y,z)
+#endif
+
+/*
+** Return true if pTab is a contentless table.
+*/
+static int fts5IsContentless(Fts5Table *pTab){
+  return pTab->pConfig->eContent==FTS5_CONTENT_NONE;
+}
+
+/*
+** Delete a virtual table handle allocated by fts5InitVtab(). 
+*/
+static void fts5FreeVtab(Fts5Table *pTab){
+  if( pTab ){
+    sqlite3Fts5IndexClose(pTab->pIndex);
+    sqlite3Fts5StorageClose(pTab->pStorage);
+    sqlite3Fts5ConfigFree(pTab->pConfig);
+    sqlite3_free(pTab);
+  }
+}
+
+/*
+** The xDisconnect() virtual table method.
+*/
+static int fts5DisconnectMethod(sqlite3_vtab *pVtab){
+  fts5FreeVtab((Fts5Table*)pVtab);
+  return SQLITE_OK;
+}
+
+/*
+** The xDestroy() virtual table method.
+*/
+static int fts5DestroyMethod(sqlite3_vtab *pVtab){
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  int rc = sqlite3Fts5DropAll(pTab->pConfig);
+  if( rc==SQLITE_OK ){
+    fts5FreeVtab((Fts5Table*)pVtab);
+  }
+  return rc;
+}
+
+/*
+** This function is the implementation of both the xConnect and xCreate
+** methods of the FTS3 virtual table.
+**
+** The argv[] array contains the following:
+**
+**   argv[0]   -> module name  ("fts5")
+**   argv[1]   -> database name
+**   argv[2]   -> table name
+**   argv[...] -> "column name" and other module argument fields.
+*/
+static int fts5InitVtab(
+  int bCreate,                    /* True for xCreate, false for xConnect */
+  sqlite3 *db,                    /* The SQLite database connection */
+  void *pAux,                     /* Hash table containing tokenizers */
+  int argc,                       /* Number of elements in argv array */
+  const char * const *argv,       /* xCreate/xConnect argument array */
+  sqlite3_vtab **ppVTab,          /* Write the resulting vtab structure here */
+  char **pzErr                    /* Write any error message here */
+){
+  Fts5Global *pGlobal = (Fts5Global*)pAux;
+  const char **azConfig = (const char**)argv;
+  int rc = SQLITE_OK;             /* Return code */
+  Fts5Config *pConfig = 0;        /* Results of parsing argc/argv */
+  Fts5Table *pTab = 0;            /* New virtual table object */
+
+  /* Allocate the new vtab object and parse the configuration */
+  pTab = (Fts5Table*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Table));
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5ConfigParse(pGlobal, db, argc, azConfig, &pConfig, pzErr);
+    assert( (rc==SQLITE_OK && *pzErr==0) || pConfig==0 );
+  }
+  if( rc==SQLITE_OK ){
+    pTab->pConfig = pConfig;
+    pTab->pGlobal = pGlobal;
+  }
+
+  /* Open the index sub-system */
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5IndexOpen(pConfig, bCreate, &pTab->pIndex, pzErr);
+  }
+
+  /* Open the storage sub-system */
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5StorageOpen(
+        pConfig, pTab->pIndex, bCreate, &pTab->pStorage, pzErr
+    );
+  }
+
+  /* Call sqlite3_declare_vtab() */
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5ConfigDeclareVtab(pConfig);
+  }
+
+  if( rc!=SQLITE_OK ){
+    fts5FreeVtab(pTab);
+    pTab = 0;
+  }else if( bCreate ){
+    fts5CheckTransactionState(pTab, FTS5_BEGIN, 0);
+  }
+  *ppVTab = (sqlite3_vtab*)pTab;
+  return rc;
+}
+
+/*
+** The xConnect() and xCreate() methods for the virtual table. All the
+** work is done in function fts5InitVtab().
+*/
+static int fts5ConnectMethod(
+  sqlite3 *db,                    /* Database connection */
+  void *pAux,                     /* Pointer to tokenizer hash table */
+  int argc,                       /* Number of elements in argv array */
+  const char * const *argv,       /* xCreate/xConnect argument array */
+  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */
+  char **pzErr                    /* OUT: sqlite3_malloc'd error message */
+){
+  return fts5InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr);
+}
+static int fts5CreateMethod(
+  sqlite3 *db,                    /* Database connection */
+  void *pAux,                     /* Pointer to tokenizer hash table */
+  int argc,                       /* Number of elements in argv array */
+  const char * const *argv,       /* xCreate/xConnect argument array */
+  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */
+  char **pzErr                    /* OUT: sqlite3_malloc'd error message */
+){
+  return fts5InitVtab(1, db, pAux, argc, argv, ppVtab, pzErr);
+}
+
+/*
+** The different query plans.
+*/
+#define FTS5_PLAN_MATCH          1       /* (<tbl> MATCH ?) */
+#define FTS5_PLAN_SOURCE         2       /* A source cursor for SORTED_MATCH */
+#define FTS5_PLAN_SPECIAL        3       /* An internal query */
+#define FTS5_PLAN_SORTED_MATCH   4       /* (<tbl> MATCH ? ORDER BY rank) */
+#define FTS5_PLAN_SCAN           5       /* No usable constraint */
+#define FTS5_PLAN_ROWID          6       /* (rowid = ?) */
+
+/*
+** Set the SQLITE_INDEX_SCAN_UNIQUE flag in pIdxInfo->flags. Unless this
+** extension is currently being used by a version of SQLite too old to
+** support index-info flags. In that case this function is a no-op.
+*/
+static void fts5SetUniqueFlag(sqlite3_index_info *pIdxInfo){
+#if SQLITE_VERSION_NUMBER>=3008012
+  if( sqlite3_libversion_number()>=3008012 ){
+    pIdxInfo->idxFlags |= SQLITE_INDEX_SCAN_UNIQUE;
+  }
+#endif
+}
+
+/*
+** Implementation of the xBestIndex method for FTS5 tables. Within the 
+** WHERE constraint, it searches for the following:
+**
+**   1. A MATCH constraint against the special column.
+**   2. A MATCH constraint against the "rank" column.
+**   3. An == constraint against the rowid column.
+**   4. A < or <= constraint against the rowid column.
+**   5. A > or >= constraint against the rowid column.
+**
+** Within the ORDER BY, either:
+**
+**   5. ORDER BY rank [ASC|DESC]
+**   6. ORDER BY rowid [ASC|DESC]
+**
+** Costs are assigned as follows:
+**
+**  a) If an unusable MATCH operator is present in the WHERE clause, the
+**     cost is unconditionally set to 1e50 (a really big number).
+**
+**  a) If a MATCH operator is present, the cost depends on the other
+**     constraints also present. As follows:
+**
+**       * No other constraints:         cost=1000.0
+**       * One rowid range constraint:   cost=750.0
+**       * Both rowid range constraints: cost=500.0
+**       * An == rowid constraint:       cost=100.0
+**
+**  b) Otherwise, if there is no MATCH:
+**
+**       * No other constraints:         cost=1000000.0
+**       * One rowid range constraint:   cost=750000.0
+**       * Both rowid range constraints: cost=250000.0
+**       * An == rowid constraint:       cost=10.0
+**
+** Costs are not modified by the ORDER BY clause.
+*/
+static int fts5BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
+  Fts5Table *pTab = (Fts5Table*)pVTab;
+  Fts5Config *pConfig = pTab->pConfig;
+  int idxFlags = 0;               /* Parameter passed through to xFilter() */
+  int bHasMatch;
+  int iNext;
+  int i;
+
+  struct Constraint {
+    int op;                       /* Mask against sqlite3_index_constraint.op */
+    int fts5op;                   /* FTS5 mask for idxFlags */
+    int iCol;                     /* 0==rowid, 1==tbl, 2==rank */
+    int omit;                     /* True to omit this if found */
+    int iConsIndex;               /* Index in pInfo->aConstraint[] */
+  } aConstraint[] = {
+    {SQLITE_INDEX_CONSTRAINT_MATCH|SQLITE_INDEX_CONSTRAINT_EQ, 
+                                    FTS5_BI_MATCH,    1, 1, -1},
+    {SQLITE_INDEX_CONSTRAINT_MATCH|SQLITE_INDEX_CONSTRAINT_EQ, 
+                                    FTS5_BI_RANK,     2, 1, -1},
+    {SQLITE_INDEX_CONSTRAINT_EQ,    FTS5_BI_ROWID_EQ, 0, 0, -1},
+    {SQLITE_INDEX_CONSTRAINT_LT|SQLITE_INDEX_CONSTRAINT_LE, 
+                                    FTS5_BI_ROWID_LE, 0, 0, -1},
+    {SQLITE_INDEX_CONSTRAINT_GT|SQLITE_INDEX_CONSTRAINT_GE, 
+                                    FTS5_BI_ROWID_GE, 0, 0, -1},
+  };
+
+  int aColMap[3];
+  aColMap[0] = -1;
+  aColMap[1] = pConfig->nCol;
+  aColMap[2] = pConfig->nCol+1;
+
+  /* Set idxFlags flags for all WHERE clause terms that will be used. */
+  for(i=0; i<pInfo->nConstraint; i++){
+    struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];
+    int j;
+    for(j=0; j<sizeof(aConstraint)/sizeof(aConstraint[0]); j++){
+      struct Constraint *pC = &aConstraint[j];
+      if( p->iColumn==aColMap[pC->iCol] && p->op & pC->op ){
+        if( p->usable ){
+          pC->iConsIndex = i;
+          idxFlags |= pC->fts5op;
+        }else if( j==0 ){
+          /* As there exists an unusable MATCH constraint this is an 
+          ** unusable plan. Set a prohibitively high cost. */
+          pInfo->estimatedCost = 1e50;
+          return SQLITE_OK;
+        }
+      }
+    }
+  }
+
+  /* Set idxFlags flags for the ORDER BY clause */
+  if( pInfo->nOrderBy==1 ){
+    int iSort = pInfo->aOrderBy[0].iColumn;
+    if( iSort==(pConfig->nCol+1) && BitFlagTest(idxFlags, FTS5_BI_MATCH) ){
+      idxFlags |= FTS5_BI_ORDER_RANK;
+    }else if( iSort==-1 ){
+      idxFlags |= FTS5_BI_ORDER_ROWID;
+    }
+    if( BitFlagTest(idxFlags, FTS5_BI_ORDER_RANK|FTS5_BI_ORDER_ROWID) ){
+      pInfo->orderByConsumed = 1;
+      if( pInfo->aOrderBy[0].desc ){
+        idxFlags |= FTS5_BI_ORDER_DESC;
+      }
+    }
+  }
+
+  /* Calculate the estimated cost based on the flags set in idxFlags. */
+  bHasMatch = BitFlagTest(idxFlags, FTS5_BI_MATCH);
+  if( BitFlagTest(idxFlags, FTS5_BI_ROWID_EQ) ){
+    pInfo->estimatedCost = bHasMatch ? 100.0 : 10.0;
+    if( bHasMatch==0 ) fts5SetUniqueFlag(pInfo);
+  }else if( BitFlagAllTest(idxFlags, FTS5_BI_ROWID_LE|FTS5_BI_ROWID_GE) ){
+    pInfo->estimatedCost = bHasMatch ? 500.0 : 250000.0;
+  }else if( BitFlagTest(idxFlags, FTS5_BI_ROWID_LE|FTS5_BI_ROWID_GE) ){
+    pInfo->estimatedCost = bHasMatch ? 750.0 : 750000.0;
+  }else{
+    pInfo->estimatedCost = bHasMatch ? 1000.0 : 1000000.0;
+  }
+
+  /* Assign argvIndex values to each constraint in use. */
+  iNext = 1;
+  for(i=0; i<sizeof(aConstraint)/sizeof(aConstraint[0]); i++){
+    struct Constraint *pC = &aConstraint[i];
+    if( pC->iConsIndex>=0 ){
+      pInfo->aConstraintUsage[pC->iConsIndex].argvIndex = iNext++;
+      pInfo->aConstraintUsage[pC->iConsIndex].omit = pC->omit;
+    }
+  }
+
+  pInfo->idxNum = idxFlags;
+  return SQLITE_OK;
+}
+
+/*
+** Implementation of xOpen method.
+*/
+static int fts5OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){
+  Fts5Table *pTab = (Fts5Table*)pVTab;
+  Fts5Config *pConfig = pTab->pConfig;
+  Fts5Cursor *pCsr;               /* New cursor object */
+  int nByte;                      /* Bytes of space to allocate */
+  int rc = SQLITE_OK;             /* Return code */
+
+  nByte = sizeof(Fts5Cursor) + pConfig->nCol * sizeof(int);
+  pCsr = (Fts5Cursor*)sqlite3_malloc(nByte);
+  if( pCsr ){
+    Fts5Global *pGlobal = pTab->pGlobal;
+    memset(pCsr, 0, nByte);
+    pCsr->aColumnSize = (int*)&pCsr[1];
+    pCsr->pNext = pGlobal->pCsr;
+    pGlobal->pCsr = pCsr;
+    pCsr->iCsrId = ++pGlobal->iNextId;
+  }else{
+    rc = SQLITE_NOMEM;
+  }
+  *ppCsr = (sqlite3_vtab_cursor*)pCsr;
+  return rc;
+}
+
+static int fts5StmtType(Fts5Cursor *pCsr){
+  if( pCsr->ePlan==FTS5_PLAN_SCAN ){
+    return (pCsr->bDesc) ? FTS5_STMT_SCAN_DESC : FTS5_STMT_SCAN_ASC;
+  }
+  return FTS5_STMT_LOOKUP;
+}
+
+/*
+** This function is called after the cursor passed as the only argument
+** is moved to point at a different row. It clears all cached data 
+** specific to the previous row stored by the cursor object.
+*/
+static void fts5CsrNewrow(Fts5Cursor *pCsr){
+  CsrFlagSet(pCsr, 
+      FTS5CSR_REQUIRE_CONTENT 
+    | FTS5CSR_REQUIRE_DOCSIZE 
+    | FTS5CSR_REQUIRE_INST 
+  );
+}
+
+static void fts5FreeCursorComponents(Fts5Cursor *pCsr){
+  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+  Fts5Auxdata *pData;
+  Fts5Auxdata *pNext;
+
+  sqlite3_free(pCsr->aInstIter);
+  sqlite3_free(pCsr->aInst);
+  if( pCsr->pStmt ){
+    int eStmt = fts5StmtType(pCsr);
+    sqlite3Fts5StorageStmtRelease(pTab->pStorage, eStmt, pCsr->pStmt);
+  }
+  if( pCsr->pSorter ){
+    Fts5Sorter *pSorter = pCsr->pSorter;
+    sqlite3_finalize(pSorter->pStmt);
+    sqlite3_free(pSorter);
+  }
+
+  if( pCsr->ePlan!=FTS5_PLAN_SOURCE ){
+    sqlite3Fts5ExprFree(pCsr->pExpr);
+  }
+
+  for(pData=pCsr->pAuxdata; pData; pData=pNext){
+    pNext = pData->pNext;
+    if( pData->xDelete ) pData->xDelete(pData->pPtr);
+    sqlite3_free(pData);
+  }
+
+  sqlite3_finalize(pCsr->pRankArgStmt);
+  sqlite3_free(pCsr->apRankArg);
+
+  if( CsrFlagTest(pCsr, FTS5CSR_FREE_ZRANK) ){
+    sqlite3_free(pCsr->zRank);
+    sqlite3_free(pCsr->zRankArgs);
+  }
+
+  memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan - (u8*)pCsr));
+}
+
+
+/*
+** Close the cursor.  For additional information see the documentation
+** on the xClose method of the virtual table interface.
+*/
+static int fts5CloseMethod(sqlite3_vtab_cursor *pCursor){
+  if( pCursor ){
+    Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
+    Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
+    Fts5Cursor **pp;
+
+    fts5FreeCursorComponents(pCsr);
+    /* Remove the cursor from the Fts5Global.pCsr list */
+    for(pp=&pTab->pGlobal->pCsr; (*pp)!=pCsr; pp=&(*pp)->pNext);
+    *pp = pCsr->pNext;
+
+    sqlite3_free(pCsr);
+  }
+  return SQLITE_OK;
+}
+
+static int fts5SorterNext(Fts5Cursor *pCsr){
+  Fts5Sorter *pSorter = pCsr->pSorter;
+  int rc;
+
+  rc = sqlite3_step(pSorter->pStmt);
+  if( rc==SQLITE_DONE ){
+    rc = SQLITE_OK;
+    CsrFlagSet(pCsr, FTS5CSR_EOF);
+  }else if( rc==SQLITE_ROW ){
+    const u8 *a;
+    const u8 *aBlob;
+    int nBlob;
+    int i;
+    int iOff = 0;
+    rc = SQLITE_OK;
+
+    pSorter->iRowid = sqlite3_column_int64(pSorter->pStmt, 0);
+    nBlob = sqlite3_column_bytes(pSorter->pStmt, 1);
+    aBlob = a = sqlite3_column_blob(pSorter->pStmt, 1);
+
+    for(i=0; i<(pSorter->nIdx-1); i++){
+      int iVal;
+      a += fts5GetVarint32(a, iVal);
+      iOff += iVal;
+      pSorter->aIdx[i] = iOff;
+    }
+    pSorter->aIdx[i] = &aBlob[nBlob] - a;
+
+    pSorter->aPoslist = a;
+    fts5CsrNewrow(pCsr);
+  }
+
+  return rc;
+}
+
+
+/*
+** Set the FTS5CSR_REQUIRE_RESEEK flag on all FTS5_PLAN_MATCH cursors 
+** open on table pTab.
+*/
+static void fts5TripCursors(Fts5Table *pTab){
+  Fts5Cursor *pCsr;
+  for(pCsr=pTab->pGlobal->pCsr; pCsr; pCsr=pCsr->pNext){
+    if( pCsr->ePlan==FTS5_PLAN_MATCH
+     && pCsr->base.pVtab==(sqlite3_vtab*)pTab 
+    ){
+      CsrFlagSet(pCsr, FTS5CSR_REQUIRE_RESEEK);
+    }
+  }
+}
+
+/*
+** If the REQUIRE_RESEEK flag is set on the cursor passed as the first
+** argument, close and reopen all Fts5IndexIter iterators that the cursor 
+** is using. Then attempt to move the cursor to a rowid equal to or laster
+** (in the cursors sort order - ASC or DESC) than the current rowid. 
+**
+** If the new rowid is not equal to the old, set output parameter *pbSkip
+** to 1 before returning. Otherwise, leave it unchanged.
+**
+** Return SQLITE_OK if successful or if no reseek was required, or an 
+** error code if an error occurred.
+*/
+static int fts5CursorReseek(Fts5Cursor *pCsr, int *pbSkip){
+  int rc = SQLITE_OK;
+  assert( *pbSkip==0 );
+  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_RESEEK) ){
+    Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+    int bDesc = pCsr->bDesc;
+    i64 iRowid = sqlite3Fts5ExprRowid(pCsr->pExpr);
+
+    rc = sqlite3Fts5ExprFirst(pCsr->pExpr, pTab->pIndex, iRowid, bDesc);
+    if( rc==SQLITE_OK && iRowid!=sqlite3Fts5ExprRowid(pCsr->pExpr) ){
+      *pbSkip = 1;
+    }
+
+    CsrFlagClear(pCsr, FTS5CSR_REQUIRE_RESEEK);
+    fts5CsrNewrow(pCsr);
+    if( sqlite3Fts5ExprEof(pCsr->pExpr) ){
+      CsrFlagSet(pCsr, FTS5CSR_EOF);
+    }
+  }
+  return rc;
+}
+
+
+/*
+** Advance the cursor to the next row in the table that matches the 
+** search criteria.
+**
+** Return SQLITE_OK if nothing goes wrong.  SQLITE_OK is returned
+** even if we reach end-of-file.  The fts5EofMethod() will be called
+** subsequently to determine whether or not an EOF was hit.
+*/
+static int fts5NextMethod(sqlite3_vtab_cursor *pCursor){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
+  int rc = SQLITE_OK;
+
+  assert( (pCsr->ePlan<3)==
+          (pCsr->ePlan==FTS5_PLAN_MATCH || pCsr->ePlan==FTS5_PLAN_SOURCE) 
+  );
+
+  if( pCsr->ePlan<3 ){
+    int bSkip = 0;
+    if( (rc = fts5CursorReseek(pCsr, &bSkip)) || bSkip ) return rc;
+    rc = sqlite3Fts5ExprNext(pCsr->pExpr, pCsr->iLastRowid);
+    if( sqlite3Fts5ExprEof(pCsr->pExpr) ){
+      CsrFlagSet(pCsr, FTS5CSR_EOF);
+    }
+    fts5CsrNewrow(pCsr);
+  }else{
+    switch( pCsr->ePlan ){
+      case FTS5_PLAN_SPECIAL: {
+        CsrFlagSet(pCsr, FTS5CSR_EOF);
+        break;
+      }
+  
+      case FTS5_PLAN_SORTED_MATCH: {
+        rc = fts5SorterNext(pCsr);
+        break;
+      }
+  
+      default:
+        rc = sqlite3_step(pCsr->pStmt);
+        if( rc!=SQLITE_ROW ){
+          CsrFlagSet(pCsr, FTS5CSR_EOF);
+          rc = sqlite3_reset(pCsr->pStmt);
+        }else{
+          rc = SQLITE_OK;
+        }
+        break;
+    }
+  }
+  
+  return rc;
+}
+
+static int fts5CursorFirstSorted(Fts5Table *pTab, Fts5Cursor *pCsr, int bDesc){
+  Fts5Config *pConfig = pTab->pConfig;
+  Fts5Sorter *pSorter;
+  int nPhrase;
+  int nByte;
+  int rc = SQLITE_OK;
+  char *zSql;
+  const char *zRank = pCsr->zRank;
+  const char *zRankArgs = pCsr->zRankArgs;
+  
+  nPhrase = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
+  nByte = sizeof(Fts5Sorter) + sizeof(int) * (nPhrase-1);
+  pSorter = (Fts5Sorter*)sqlite3_malloc(nByte);
+  if( pSorter==0 ) return SQLITE_NOMEM;
+  memset(pSorter, 0, nByte);
+  pSorter->nIdx = nPhrase;
+
+  /* TODO: It would be better to have some system for reusing statement
+  ** handles here, rather than preparing a new one for each query. But that
+  ** is not possible as SQLite reference counts the virtual table objects.
+  ** And since the statement required here reads from this very virtual 
+  ** table, saving it creates a circular reference.
+  **
+  ** If SQLite a built-in statement cache, this wouldn't be a problem. */
+  zSql = sqlite3Fts5Mprintf(&rc, 
+      "SELECT rowid, rank FROM %Q.%Q ORDER BY %s(%s%s%s) %s",
+      pConfig->zDb, pConfig->zName, zRank, pConfig->zName,
+      (zRankArgs ? ", " : ""),
+      (zRankArgs ? zRankArgs : ""),
+      bDesc ? "DESC" : "ASC"
+  );
+  if( zSql ){
+    rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pSorter->pStmt, 0);
+    sqlite3_free(zSql);
+  }
+
+  pCsr->pSorter = pSorter;
+  if( rc==SQLITE_OK ){
+    assert( pTab->pSortCsr==0 );
+    pTab->pSortCsr = pCsr;
+    rc = fts5SorterNext(pCsr);
+    pTab->pSortCsr = 0;
+  }
+
+  if( rc!=SQLITE_OK ){
+    sqlite3_finalize(pSorter->pStmt);
+    sqlite3_free(pSorter);
+    pCsr->pSorter = 0;
+  }
+
+  return rc;
+}
+
+static int fts5CursorFirst(Fts5Table *pTab, Fts5Cursor *pCsr, int bDesc){
+  int rc;
+  Fts5Expr *pExpr = pCsr->pExpr;
+  rc = sqlite3Fts5ExprFirst(pExpr, pTab->pIndex, pCsr->iFirstRowid, bDesc);
+  if( sqlite3Fts5ExprEof(pExpr) ){
+    CsrFlagSet(pCsr, FTS5CSR_EOF);
+  }
+  fts5CsrNewrow(pCsr);
+  return rc;
+}
+
+/*
+** Process a "special" query. A special query is identified as one with a
+** MATCH expression that begins with a '*' character. The remainder of
+** the text passed to the MATCH operator are used as  the special query
+** parameters.
+*/
+static int fts5SpecialMatch(
+  Fts5Table *pTab, 
+  Fts5Cursor *pCsr, 
+  const char *zQuery
+){
+  int rc = SQLITE_OK;             /* Return code */
+  const char *z = zQuery;         /* Special query text */
+  int n;                          /* Number of bytes in text at z */
+
+  while( z[0]==' ' ) z++;
+  for(n=0; z[n] && z[n]!=' '; n++);
+
+  assert( pTab->base.zErrMsg==0 );
+  pCsr->ePlan = FTS5_PLAN_SPECIAL;
+
+  if( 0==sqlite3_strnicmp("reads", z, n) ){
+    pCsr->iSpecial = sqlite3Fts5IndexReads(pTab->pIndex);
+  }
+  else if( 0==sqlite3_strnicmp("id", z, n) ){
+    pCsr->iSpecial = pCsr->iCsrId;
+  }
+  else{
+    /* An unrecognized directive. Return an error message. */
+    pTab->base.zErrMsg = sqlite3_mprintf("unknown special query: %.*s", n, z);
+    rc = SQLITE_ERROR;
+  }
+
+  return rc;
+}
+
+/*
+** Search for an auxiliary function named zName that can be used with table
+** pTab. If one is found, return a pointer to the corresponding Fts5Auxiliary
+** structure. Otherwise, if no such function exists, return NULL.
+*/
+static Fts5Auxiliary *fts5FindAuxiliary(Fts5Table *pTab, const char *zName){
+  Fts5Auxiliary *pAux;
+
+  for(pAux=pTab->pGlobal->pAux; pAux; pAux=pAux->pNext){
+    if( sqlite3_stricmp(zName, pAux->zFunc)==0 ) return pAux;
+  }
+
+  /* No function of the specified name was found. Return 0. */
+  return 0;
+}
+
+
+static int fts5FindRankFunction(Fts5Cursor *pCsr){
+  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+  Fts5Config *pConfig = pTab->pConfig;
+  int rc = SQLITE_OK;
+  Fts5Auxiliary *pAux = 0;
+  const char *zRank = pCsr->zRank;
+  const char *zRankArgs = pCsr->zRankArgs;
+
+  if( zRankArgs ){
+    char *zSql = sqlite3Fts5Mprintf(&rc, "SELECT %s", zRankArgs);
+    if( zSql ){
+      sqlite3_stmt *pStmt = 0;
+      rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pStmt, 0);
+      sqlite3_free(zSql);
+      assert( rc==SQLITE_OK || pCsr->pRankArgStmt==0 );
+      if( rc==SQLITE_OK ){
+        if( SQLITE_ROW==sqlite3_step(pStmt) ){
+          int nByte;
+          pCsr->nRankArg = sqlite3_column_count(pStmt);
+          nByte = sizeof(sqlite3_value*)*pCsr->nRankArg;
+          pCsr->apRankArg = (sqlite3_value**)sqlite3Fts5MallocZero(&rc, nByte);
+          if( rc==SQLITE_OK ){
+            int i;
+            for(i=0; i<pCsr->nRankArg; i++){
+              pCsr->apRankArg[i] = sqlite3_column_value(pStmt, i);
+            }
+          }
+          pCsr->pRankArgStmt = pStmt;
+        }else{
+          rc = sqlite3_finalize(pStmt);
+          assert( rc!=SQLITE_OK );
+        }
+      }
+    }
+  }
+
+  if( rc==SQLITE_OK ){
+    pAux = fts5FindAuxiliary(pTab, zRank);
+    if( pAux==0 ){
+      assert( pTab->base.zErrMsg==0 );
+      pTab->base.zErrMsg = sqlite3_mprintf("no such function: %s", zRank);
+      rc = SQLITE_ERROR;
+    }
+  }
+
+  pCsr->pRank = pAux;
+  return rc;
+}
+
+
+static int fts5CursorParseRank(
+  Fts5Config *pConfig,
+  Fts5Cursor *pCsr, 
+  sqlite3_value *pRank
+){
+  int rc = SQLITE_OK;
+  if( pRank ){
+    const char *z = (const char*)sqlite3_value_text(pRank);
+    char *zRank = 0;
+    char *zRankArgs = 0;
+
+    if( z==0 ){
+      if( sqlite3_value_type(pRank)==SQLITE_NULL ) rc = SQLITE_ERROR;
+    }else{
+      rc = sqlite3Fts5ConfigParseRank(z, &zRank, &zRankArgs);
+    }
+    if( rc==SQLITE_OK ){
+      pCsr->zRank = zRank;
+      pCsr->zRankArgs = zRankArgs;
+      CsrFlagSet(pCsr, FTS5CSR_FREE_ZRANK);
+    }else if( rc==SQLITE_ERROR ){
+      pCsr->base.pVtab->zErrMsg = sqlite3_mprintf(
+          "parse error in rank function: %s", z
+      );
+    }
+  }else{
+    if( pConfig->zRank ){
+      pCsr->zRank = (char*)pConfig->zRank;
+      pCsr->zRankArgs = (char*)pConfig->zRankArgs;
+    }else{
+      pCsr->zRank = (char*)FTS5_DEFAULT_RANK;
+      pCsr->zRankArgs = 0;
+    }
+  }
+  return rc;
+}
+
+static i64 fts5GetRowidLimit(sqlite3_value *pVal, i64 iDefault){
+  if( pVal ){
+    int eType = sqlite3_value_numeric_type(pVal);
+    if( eType==SQLITE_INTEGER ){
+      return sqlite3_value_int64(pVal);
+    }
+  }
+  return iDefault;
+}
+
+/*
+** This is the xFilter interface for the virtual table.  See
+** the virtual table xFilter method documentation for additional
+** information.
+** 
+** There are three possible query strategies:
+**
+**   1. Full-text search using a MATCH operator.
+**   2. A by-rowid lookup.
+**   3. A full-table scan.
+*/
+static int fts5FilterMethod(
+  sqlite3_vtab_cursor *pCursor,   /* The cursor used for this query */
+  int idxNum,                     /* Strategy index */
+  const char *idxStr,             /* Unused */
+  int nVal,                       /* Number of elements in apVal */
+  sqlite3_value **apVal           /* Arguments for the indexing scheme */
+){
+  Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
+  Fts5Config *pConfig = pTab->pConfig;
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
+  int rc = SQLITE_OK;             /* Error code */
+  int iVal = 0;                   /* Counter for apVal[] */
+  int bDesc;                      /* True if ORDER BY [rank|rowid] DESC */
+  int bOrderByRank;               /* True if ORDER BY rank */
+  sqlite3_value *pMatch = 0;      /* <tbl> MATCH ? expression (or NULL) */
+  sqlite3_value *pRank = 0;       /* rank MATCH ? expression (or NULL) */
+  sqlite3_value *pRowidEq = 0;    /* rowid = ? expression (or NULL) */
+  sqlite3_value *pRowidLe = 0;    /* rowid <= ? expression (or NULL) */
+  sqlite3_value *pRowidGe = 0;    /* rowid >= ? expression (or NULL) */
+  char **pzErrmsg = pConfig->pzErrmsg;
+
+  if( pCsr->ePlan ){
+    fts5FreeCursorComponents(pCsr);
+    memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan-(u8*)pCsr));
+  }
+
+  assert( pCsr->pStmt==0 );
+  assert( pCsr->pExpr==0 );
+  assert( pCsr->csrflags==0 );
+  assert( pCsr->pRank==0 );
+  assert( pCsr->zRank==0 );
+  assert( pCsr->zRankArgs==0 );
+
+  assert( pzErrmsg==0 || pzErrmsg==&pTab->base.zErrMsg );
+  pConfig->pzErrmsg = &pTab->base.zErrMsg;
+
+  /* Decode the arguments passed through to this function.
+  **
+  ** Note: The following set of if(...) statements must be in the same
+  ** order as the corresponding entries in the struct at the top of
+  ** fts5BestIndexMethod().  */
+  if( BitFlagTest(idxNum, FTS5_BI_MATCH) ) pMatch = apVal[iVal++];
+  if( BitFlagTest(idxNum, FTS5_BI_RANK) ) pRank = apVal[iVal++];
+  if( BitFlagTest(idxNum, FTS5_BI_ROWID_EQ) ) pRowidEq = apVal[iVal++];
+  if( BitFlagTest(idxNum, FTS5_BI_ROWID_LE) ) pRowidLe = apVal[iVal++];
+  if( BitFlagTest(idxNum, FTS5_BI_ROWID_GE) ) pRowidGe = apVal[iVal++];
+  assert( iVal==nVal );
+  bOrderByRank = ((idxNum & FTS5_BI_ORDER_RANK) ? 1 : 0);
+  pCsr->bDesc = bDesc = ((idxNum & FTS5_BI_ORDER_DESC) ? 1 : 0);
+
+  /* Set the cursor upper and lower rowid limits. Only some strategies 
+  ** actually use them. This is ok, as the xBestIndex() method leaves the
+  ** sqlite3_index_constraint.omit flag clear for range constraints
+  ** on the rowid field.  */
+  if( pRowidEq ){
+    pRowidLe = pRowidGe = pRowidEq;
+  }
+  if( bDesc ){
+    pCsr->iFirstRowid = fts5GetRowidLimit(pRowidLe, LARGEST_INT64);
+    pCsr->iLastRowid = fts5GetRowidLimit(pRowidGe, SMALLEST_INT64);
+  }else{
+    pCsr->iLastRowid = fts5GetRowidLimit(pRowidLe, LARGEST_INT64);
+    pCsr->iFirstRowid = fts5GetRowidLimit(pRowidGe, SMALLEST_INT64);
+  }
+
+  if( pTab->pSortCsr ){
+    /* If pSortCsr is non-NULL, then this call is being made as part of 
+    ** processing for a "... MATCH <expr> ORDER BY rank" query (ePlan is
+    ** set to FTS5_PLAN_SORTED_MATCH). pSortCsr is the cursor that will
+    ** return results to the user for this query. The current cursor 
+    ** (pCursor) is used to execute the query issued by function 
+    ** fts5CursorFirstSorted() above.  */
+    assert( pRowidEq==0 && pRowidLe==0 && pRowidGe==0 && pRank==0 );
+    assert( nVal==0 && pMatch==0 && bOrderByRank==0 && bDesc==0 );
+    assert( pCsr->iLastRowid==LARGEST_INT64 );
+    assert( pCsr->iFirstRowid==SMALLEST_INT64 );
+    pCsr->ePlan = FTS5_PLAN_SOURCE;
+    pCsr->pExpr = pTab->pSortCsr->pExpr;
+    rc = fts5CursorFirst(pTab, pCsr, bDesc);
+  }else if( pMatch ){
+    const char *zExpr = (const char*)sqlite3_value_text(apVal[0]);
+    if( zExpr==0 ) zExpr = "";
+
+    rc = fts5CursorParseRank(pConfig, pCsr, pRank);
+    if( rc==SQLITE_OK ){
+      if( zExpr[0]=='*' ){
+        /* The user has issued a query of the form "MATCH '*...'". This
+        ** indicates that the MATCH expression is not a full text query,
+        ** but a request for an internal parameter.  */
+        rc = fts5SpecialMatch(pTab, pCsr, &zExpr[1]);
+      }else{
+        char **pzErr = &pTab->base.zErrMsg;
+        rc = sqlite3Fts5ExprNew(pConfig, zExpr, &pCsr->pExpr, pzErr);
+        if( rc==SQLITE_OK ){
+          if( bOrderByRank ){
+            pCsr->ePlan = FTS5_PLAN_SORTED_MATCH;
+            rc = fts5CursorFirstSorted(pTab, pCsr, bDesc);
+          }else{
+            pCsr->ePlan = FTS5_PLAN_MATCH;
+            rc = fts5CursorFirst(pTab, pCsr, bDesc);
+          }
+        }
+      }
+    }
+  }else if( pConfig->zContent==0 ){
+    *pConfig->pzErrmsg = sqlite3_mprintf(
+        "%s: table does not support scanning", pConfig->zName
+    );
+    rc = SQLITE_ERROR;
+  }else{
+    /* This is either a full-table scan (ePlan==FTS5_PLAN_SCAN) or a lookup
+    ** by rowid (ePlan==FTS5_PLAN_ROWID).  */
+    pCsr->ePlan = (pRowidEq ? FTS5_PLAN_ROWID : FTS5_PLAN_SCAN);
+    rc = sqlite3Fts5StorageStmt(
+        pTab->pStorage, fts5StmtType(pCsr), &pCsr->pStmt, &pTab->base.zErrMsg
+    );
+    if( rc==SQLITE_OK ){
+      if( pCsr->ePlan==FTS5_PLAN_ROWID ){
+        sqlite3_bind_value(pCsr->pStmt, 1, apVal[0]);
+      }else{
+        sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iFirstRowid);
+        sqlite3_bind_int64(pCsr->pStmt, 2, pCsr->iLastRowid);
+      }
+      rc = fts5NextMethod(pCursor);
+    }
+  }
+
+  pConfig->pzErrmsg = pzErrmsg;
+  return rc;
+}
+
+/* 
+** This is the xEof method of the virtual table. SQLite calls this 
+** routine to find out if it has reached the end of a result set.
+*/
+static int fts5EofMethod(sqlite3_vtab_cursor *pCursor){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
+  return (CsrFlagTest(pCsr, FTS5CSR_EOF) ? 1 : 0);
+}
+
+/*
+** Return the rowid that the cursor currently points to.
+*/
+static i64 fts5CursorRowid(Fts5Cursor *pCsr){
+  assert( pCsr->ePlan==FTS5_PLAN_MATCH 
+       || pCsr->ePlan==FTS5_PLAN_SORTED_MATCH 
+       || pCsr->ePlan==FTS5_PLAN_SOURCE 
+  );
+  if( pCsr->pSorter ){
+    return pCsr->pSorter->iRowid;
+  }else{
+    return sqlite3Fts5ExprRowid(pCsr->pExpr);
+  }
+}
+
+/* 
+** This is the xRowid method. The SQLite core calls this routine to
+** retrieve the rowid for the current row of the result set. fts5
+** exposes %_content.rowid as the rowid for the virtual table. The
+** rowid should be written to *pRowid.
+*/
+static int fts5RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
+  int ePlan = pCsr->ePlan;
+  
+  assert( CsrFlagTest(pCsr, FTS5CSR_EOF)==0 );
+  switch( ePlan ){
+    case FTS5_PLAN_SPECIAL:
+      *pRowid = 0;
+      break;
+
+    case FTS5_PLAN_SOURCE:
+    case FTS5_PLAN_MATCH:
+    case FTS5_PLAN_SORTED_MATCH:
+      *pRowid = fts5CursorRowid(pCsr);
+      break;
+
+    default:
+      *pRowid = sqlite3_column_int64(pCsr->pStmt, 0);
+      break;
+  }
+
+  return SQLITE_OK;
+}
+
+/*
+** If the cursor requires seeking (bSeekRequired flag is set), seek it.
+** Return SQLITE_OK if no error occurs, or an SQLite error code otherwise.
+**
+** If argument bErrormsg is true and an error occurs, an error message may
+** be left in sqlite3_vtab.zErrMsg.
+*/
+static int fts5SeekCursor(Fts5Cursor *pCsr, int bErrormsg){
+  int rc = SQLITE_OK;
+
+  /* If the cursor does not yet have a statement handle, obtain one now. */ 
+  if( pCsr->pStmt==0 ){
+    Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+    int eStmt = fts5StmtType(pCsr);
+    rc = sqlite3Fts5StorageStmt(
+        pTab->pStorage, eStmt, &pCsr->pStmt, (bErrormsg?&pTab->base.zErrMsg:0)
+    );
+    assert( rc!=SQLITE_OK || pTab->base.zErrMsg==0 );
+    assert( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_CONTENT) );
+  }
+
+  if( rc==SQLITE_OK && CsrFlagTest(pCsr, FTS5CSR_REQUIRE_CONTENT) ){
+    assert( pCsr->pExpr );
+    sqlite3_reset(pCsr->pStmt);
+    sqlite3_bind_int64(pCsr->pStmt, 1, fts5CursorRowid(pCsr));
+    rc = sqlite3_step(pCsr->pStmt);
+    if( rc==SQLITE_ROW ){
+      rc = SQLITE_OK;
+      CsrFlagClear(pCsr, FTS5CSR_REQUIRE_CONTENT);
+    }else{
+      rc = sqlite3_reset(pCsr->pStmt);
+      if( rc==SQLITE_OK ){
+        rc = FTS5_CORRUPT;
+      }
+    }
+  }
+  return rc;
+}
+
+static void fts5SetVtabError(Fts5Table *p, const char *zFormat, ...){
+  va_list ap;                     /* ... printf arguments */
+  va_start(ap, zFormat);
+  assert( p->base.zErrMsg==0 );
+  p->base.zErrMsg = sqlite3_vmprintf(zFormat, ap);
+  va_end(ap);
+}
+
+/*
+** This function is called to handle an FTS INSERT command. In other words,
+** an INSERT statement of the form:
+**
+**     INSERT INTO fts(fts) VALUES($pCmd)
+**     INSERT INTO fts(fts, rank) VALUES($pCmd, $pVal)
+**
+** Argument pVal is the value assigned to column "fts" by the INSERT 
+** statement. This function returns SQLITE_OK if successful, or an SQLite
+** error code if an error occurs.
+**
+** The commands implemented by this function are documented in the "Special
+** INSERT Directives" section of the documentation. It should be updated if
+** more commands are added to this function.
+*/
+static int fts5SpecialInsert(
+  Fts5Table *pTab,                /* Fts5 table object */
+  const char *zCmd,               /* Text inserted into table-name column */
+  sqlite3_value *pVal             /* Value inserted into rank column */
+){
+  Fts5Config *pConfig = pTab->pConfig;
+  int rc = SQLITE_OK;
+  int bError = 0;
+
+  if( 0==sqlite3_stricmp("delete-all", zCmd) ){
+    if( pConfig->eContent==FTS5_CONTENT_NORMAL ){
+      fts5SetVtabError(pTab, 
+          "'delete-all' may only be used with a "
+          "contentless or external content fts5 table"
+      );
+      rc = SQLITE_ERROR;
+    }else{
+      rc = sqlite3Fts5StorageDeleteAll(pTab->pStorage);
+    }
+  }else if( 0==sqlite3_stricmp("rebuild", zCmd) ){
+    if( pConfig->eContent==FTS5_CONTENT_NONE ){
+      fts5SetVtabError(pTab, 
+          "'rebuild' may not be used with a contentless fts5 table"
+      );
+      rc = SQLITE_ERROR;
+    }else{
+      rc = sqlite3Fts5StorageRebuild(pTab->pStorage);
+    }
+  }else if( 0==sqlite3_stricmp("optimize", zCmd) ){
+    rc = sqlite3Fts5StorageOptimize(pTab->pStorage);
+  }else if( 0==sqlite3_stricmp("merge", zCmd) ){
+    int nMerge = sqlite3_value_int(pVal);
+    rc = sqlite3Fts5StorageMerge(pTab->pStorage, nMerge);
+  }else if( 0==sqlite3_stricmp("integrity-check", zCmd) ){
+    rc = sqlite3Fts5StorageIntegrity(pTab->pStorage);
+#ifdef SQLITE_DEBUG
+  }else if( 0==sqlite3_stricmp("prefix-index", zCmd) ){
+    pConfig->bPrefixIndex = sqlite3_value_int(pVal);
+#endif
+  }else{
+    rc = sqlite3Fts5IndexLoadConfig(pTab->pIndex);
+    if( rc==SQLITE_OK ){
+      rc = sqlite3Fts5ConfigSetValue(pTab->pConfig, zCmd, pVal, &bError);
+    }
+    if( rc==SQLITE_OK ){
+      if( bError ){
+        rc = SQLITE_ERROR;
+      }else{
+        rc = sqlite3Fts5StorageConfigValue(pTab->pStorage, zCmd, pVal, 0);
+      }
+    }
+  }
+  return rc;
+}
+
+static int fts5SpecialDelete(
+  Fts5Table *pTab, 
+  sqlite3_value **apVal, 
+  sqlite3_int64 *piRowid
+){
+  int rc = SQLITE_OK;
+  int eType1 = sqlite3_value_type(apVal[1]);
+  if( eType1==SQLITE_INTEGER ){
+    sqlite3_int64 iDel = sqlite3_value_int64(apVal[1]);
+    rc = sqlite3Fts5StorageSpecialDelete(pTab->pStorage, iDel, &apVal[2]);
+  }
+  return rc;
+}
+
+static void fts5StorageInsert(
+  int *pRc, 
+  Fts5Table *pTab, 
+  sqlite3_value **apVal, 
+  i64 *piRowid
+){
+  int rc = *pRc;
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, apVal, piRowid);
+  }
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5StorageIndexInsert(pTab->pStorage, apVal, *piRowid);
+  }
+  *pRc = rc;
+}
+
+/* 
+** This function is the implementation of the xUpdate callback used by 
+** FTS3 virtual tables. It is invoked by SQLite each time a row is to be
+** inserted, updated or deleted.
+**
+** A delete specifies a single argument - the rowid of the row to remove.
+** 
+** Update and insert operations pass:
+**
+**   1. The "old" rowid, or NULL.
+**   2. The "new" rowid.
+**   3. Values for each of the nCol matchable columns.
+**   4. Values for the two hidden columns (<tablename> and "rank").
+*/
+static int fts5UpdateMethod(
+  sqlite3_vtab *pVtab,            /* Virtual table handle */
+  int nArg,                       /* Size of argument array */
+  sqlite3_value **apVal,          /* Array of arguments */
+  sqlite_int64 *pRowid            /* OUT: The affected (or effected) rowid */
+){
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  Fts5Config *pConfig = pTab->pConfig;
+  int eType0;                     /* value_type() of apVal[0] */
+  int rc = SQLITE_OK;             /* Return code */
+
+  /* A transaction must be open when this is called. */
+  assert( pTab->ts.eState==1 );
+
+  assert( pVtab->zErrMsg==0 );
+  assert( nArg==1 || nArg==(2+pConfig->nCol+2) );
+  assert( nArg==1 
+      || sqlite3_value_type(apVal[1])==SQLITE_INTEGER 
+      || sqlite3_value_type(apVal[1])==SQLITE_NULL 
+  );
+  assert( pTab->pConfig->pzErrmsg==0 );
+  pTab->pConfig->pzErrmsg = &pTab->base.zErrMsg;
+
+  /* Put any active cursors into REQUIRE_SEEK state. */
+  fts5TripCursors(pTab);
+
+  eType0 = sqlite3_value_type(apVal[0]);
+  if( eType0==SQLITE_NULL 
+   && sqlite3_value_type(apVal[2+pConfig->nCol])!=SQLITE_NULL 
+  ){
+    /* A "special" INSERT op. These are handled separately. */
+    const char *z = (const char*)sqlite3_value_text(apVal[2+pConfig->nCol]);
+    if( pConfig->eContent!=FTS5_CONTENT_NORMAL 
+      && 0==sqlite3_stricmp("delete", z) 
+    ){
+      rc = fts5SpecialDelete(pTab, apVal, pRowid);
+    }else{
+      rc = fts5SpecialInsert(pTab, z, apVal[2 + pConfig->nCol + 1]);
+    }
+  }else{
+    /* A regular INSERT, UPDATE or DELETE statement. The trick here is that
+    ** any conflict on the rowid value must be detected before any 
+    ** modifications are made to the database file. There are 4 cases:
+    **
+    **   1) DELETE
+    **   2) UPDATE (rowid not modified)
+    **   3) UPDATE (rowid modified)
+    **   4) INSERT
+    **
+    ** Cases 3 and 4 may violate the rowid constraint.
+    */
+    int eConflict = sqlite3_vtab_on_conflict(pConfig->db);
+
+    assert( eType0==SQLITE_INTEGER || eType0==SQLITE_NULL );
+    assert( nArg!=1 || eType0==SQLITE_INTEGER );
+
+    /* Filter out attempts to run UPDATE or DELETE on contentless tables.
+    ** This is not suported.  */
+    if( eType0==SQLITE_INTEGER && fts5IsContentless(pTab) ){
+      pTab->base.zErrMsg = sqlite3_mprintf(
+          "cannot %s contentless fts5 table: %s", 
+          (nArg>1 ? "UPDATE" : "DELETE from"), pConfig->zName
+      );
+      rc = SQLITE_ERROR;
+    }
+
+    /* Case 1: DELETE */
+    else if( nArg==1 ){
+      i64 iDel = sqlite3_value_int64(apVal[0]);  /* Rowid to delete */
+      rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel);
+    }
+
+    /* Case 2: INSERT */
+    else if( eType0!=SQLITE_INTEGER ){     
+      /* If this is a REPLACE, first remove the current entry (if any) */
+      if( eConflict==SQLITE_REPLACE 
+       && sqlite3_value_type(apVal[1])==SQLITE_INTEGER 
+      ){
+        i64 iNew = sqlite3_value_int64(apVal[1]);  /* Rowid to delete */
+        rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew);
+      }
+      fts5StorageInsert(&rc, pTab, apVal, pRowid);
+    }
+
+    /* Case 2: UPDATE */
+    else{
+      i64 iOld = sqlite3_value_int64(apVal[0]);  /* Old rowid */
+      i64 iNew = sqlite3_value_int64(apVal[1]);  /* New rowid */
+      if( iOld!=iNew ){
+        if( eConflict==SQLITE_REPLACE ){
+          rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld);
+          if( rc==SQLITE_OK ){
+            rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew);
+          }
+          fts5StorageInsert(&rc, pTab, apVal, pRowid);
+        }else{
+          rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, apVal, pRowid);
+          if( rc==SQLITE_OK ){
+            rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld);
+          }
+          if( rc==SQLITE_OK ){
+            rc = sqlite3Fts5StorageIndexInsert(pTab->pStorage, apVal, *pRowid);
+          }
+        }
+      }else{
+        rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld);
+        fts5StorageInsert(&rc, pTab, apVal, pRowid);
+      }
+    }
+  }
+
+  pTab->pConfig->pzErrmsg = 0;
+  return rc;
+}
+
+/*
+** Implementation of xSync() method. 
+*/
+static int fts5SyncMethod(sqlite3_vtab *pVtab){
+  int rc;
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  fts5CheckTransactionState(pTab, FTS5_SYNC, 0);
+  pTab->pConfig->pzErrmsg = &pTab->base.zErrMsg;
+  fts5TripCursors(pTab);
+  rc = sqlite3Fts5StorageSync(pTab->pStorage, 1);
+  pTab->pConfig->pzErrmsg = 0;
+  return rc;
+}
+
+/*
+** Implementation of xBegin() method. 
+*/
+static int fts5BeginMethod(sqlite3_vtab *pVtab){
+  fts5CheckTransactionState((Fts5Table*)pVtab, FTS5_BEGIN, 0);
+  return SQLITE_OK;
+}
+
+/*
+** Implementation of xCommit() method. This is a no-op. The contents of
+** the pending-terms hash-table have already been flushed into the database
+** by fts5SyncMethod().
+*/
+static int fts5CommitMethod(sqlite3_vtab *pVtab){
+  fts5CheckTransactionState((Fts5Table*)pVtab, FTS5_COMMIT, 0);
+  return SQLITE_OK;
+}
+
+/*
+** Implementation of xRollback(). Discard the contents of the pending-terms
+** hash-table. Any changes made to the database are reverted by SQLite.
+*/
+static int fts5RollbackMethod(sqlite3_vtab *pVtab){
+  int rc;
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  fts5CheckTransactionState(pTab, FTS5_ROLLBACK, 0);
+  rc = sqlite3Fts5StorageRollback(pTab->pStorage);
+  return rc;
+}
+
+static void *fts5ApiUserData(Fts5Context *pCtx){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  return pCsr->pAux->pUserData;
+}
+
+static int fts5ApiColumnCount(Fts5Context *pCtx){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  return ((Fts5Table*)(pCsr->base.pVtab))->pConfig->nCol;
+}
+
+static int fts5ApiColumnTotalSize(
+  Fts5Context *pCtx, 
+  int iCol, 
+  sqlite3_int64 *pnToken
+){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+  return sqlite3Fts5StorageSize(pTab->pStorage, iCol, pnToken);
+}
+
+static int fts5ApiRowCount(Fts5Context *pCtx, i64 *pnRow){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+  return sqlite3Fts5StorageRowCount(pTab->pStorage, pnRow);
+}
+
+static int fts5ApiTokenize(
+  Fts5Context *pCtx, 
+  const char *pText, int nText, 
+  void *pUserData,
+  int (*xToken)(void*, int, const char*, int, int, int)
+){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+  return sqlite3Fts5Tokenize(
+      pTab->pConfig, FTS5_TOKENIZE_AUX, pText, nText, pUserData, xToken
+  );
+}
+
+static int fts5ApiPhraseCount(Fts5Context *pCtx){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  return sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
+}
+
+static int fts5ApiPhraseSize(Fts5Context *pCtx, int iPhrase){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  return sqlite3Fts5ExprPhraseSize(pCsr->pExpr, iPhrase);
+}
+
+static int fts5CsrPoslist(Fts5Cursor *pCsr, int iPhrase, const u8 **pa){
+  int n;
+  if( pCsr->pSorter ){
+    Fts5Sorter *pSorter = pCsr->pSorter;
+    int i1 = (iPhrase==0 ? 0 : pSorter->aIdx[iPhrase-1]);
+    n = pSorter->aIdx[iPhrase] - i1;
+    *pa = &pSorter->aPoslist[i1];
+  }else{
+    n = sqlite3Fts5ExprPoslist(pCsr->pExpr, iPhrase, pa);
+  }
+  return n;
+}
+
+/*
+** Ensure that the Fts5Cursor.nInstCount and aInst[] variables are populated
+** correctly for the current view. Return SQLITE_OK if successful, or an
+** SQLite error code otherwise.
+*/
+static int fts5CacheInstArray(Fts5Cursor *pCsr){
+  int rc = SQLITE_OK;
+  Fts5PoslistReader *aIter;       /* One iterator for each phrase */
+  int nIter;                      /* Number of iterators/phrases */
+  
+  nIter = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
+  if( pCsr->aInstIter==0 ){
+    int nByte = sizeof(Fts5PoslistReader) * nIter;
+    pCsr->aInstIter = (Fts5PoslistReader*)sqlite3Fts5MallocZero(&rc, nByte);
+  }
+  aIter = pCsr->aInstIter;
+
+  if( aIter ){
+    int nInst = 0;                /* Number instances seen so far */
+    int i;
+
+    /* Initialize all iterators */
+    for(i=0; i<nIter; i++){
+      const u8 *a;
+      int n = fts5CsrPoslist(pCsr, i, &a);
+      sqlite3Fts5PoslistReaderInit(a, n, &aIter[i]);
+    }
+
+    while( 1 ){
+      int *aInst;
+      int iBest = -1;
+      for(i=0; i<nIter; i++){
+        if( (aIter[i].bEof==0) 
+         && (iBest<0 || aIter[i].iPos<aIter[iBest].iPos) 
+        ){
+          iBest = i;
+        }
+      }
+      if( iBest<0 ) break;
+
+      nInst++;
+      if( nInst>=pCsr->nInstAlloc ){
+        pCsr->nInstAlloc = pCsr->nInstAlloc ? pCsr->nInstAlloc*2 : 32;
+        aInst = (int*)sqlite3_realloc(
+            pCsr->aInst, pCsr->nInstAlloc*sizeof(int)*3
+        );
+        if( aInst ){
+          pCsr->aInst = aInst;
+        }else{
+          rc = SQLITE_NOMEM;
+          break;
+        }
+      }
+
+      aInst = &pCsr->aInst[3 * (nInst-1)];
+      aInst[0] = iBest;
+      aInst[1] = FTS5_POS2COLUMN(aIter[iBest].iPos);
+      aInst[2] = FTS5_POS2OFFSET(aIter[iBest].iPos);
+      sqlite3Fts5PoslistReaderNext(&aIter[iBest]);
+    }
+
+    pCsr->nInstCount = nInst;
+    CsrFlagClear(pCsr, FTS5CSR_REQUIRE_INST);
+  }
+  return rc;
+}
+
+static int fts5ApiInstCount(Fts5Context *pCtx, int *pnInst){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  int rc = SQLITE_OK;
+  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_INST)==0 
+   || SQLITE_OK==(rc = fts5CacheInstArray(pCsr)) ){
+    *pnInst = pCsr->nInstCount;
+  }
+  return rc;
+}
+
+static int fts5ApiInst(
+  Fts5Context *pCtx, 
+  int iIdx, 
+  int *piPhrase, 
+  int *piCol, 
+  int *piOff
+){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  int rc = SQLITE_OK;
+  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_INST)==0 
+   || SQLITE_OK==(rc = fts5CacheInstArray(pCsr)) 
+  ){
+    if( iIdx<0 || iIdx>=pCsr->nInstCount ){
+      rc = SQLITE_RANGE;
+    }else{
+      *piPhrase = pCsr->aInst[iIdx*3];
+      *piCol = pCsr->aInst[iIdx*3 + 1];
+      *piOff = pCsr->aInst[iIdx*3 + 2];
+    }
+  }
+  return rc;
+}
+
+static sqlite3_int64 fts5ApiRowid(Fts5Context *pCtx){
+  return fts5CursorRowid((Fts5Cursor*)pCtx);
+}
+
+static int fts5ApiColumnText(
+  Fts5Context *pCtx, 
+  int iCol, 
+  const char **pz, 
+  int *pn
+){
+  int rc = SQLITE_OK;
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  if( fts5IsContentless((Fts5Table*)(pCsr->base.pVtab)) ){
+    *pz = 0;
+    *pn = 0;
+  }else{
+    rc = fts5SeekCursor(pCsr, 0);
+    if( rc==SQLITE_OK ){
+      *pz = (const char*)sqlite3_column_text(pCsr->pStmt, iCol+1);
+      *pn = sqlite3_column_bytes(pCsr->pStmt, iCol+1);
+    }
+  }
+  return rc;
+}
+
+static int fts5ColumnSizeCb(
+  void *pContext,                 /* Pointer to int */
+  int tflags,
+  const char *pToken,             /* Buffer containing token */
+  int nToken,                     /* Size of token in bytes */
+  int iStart,                     /* Start offset of token */
+  int iEnd                        /* End offset of token */
+){
+  int *pCnt = (int*)pContext;
+  if( (tflags & FTS5_TOKEN_COLOCATED)==0 ){
+    (*pCnt)++;
+  }
+  return SQLITE_OK;
+}
+
+static int fts5ApiColumnSize(Fts5Context *pCtx, int iCol, int *pnToken){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+  Fts5Config *pConfig = pTab->pConfig;
+  int rc = SQLITE_OK;
+
+  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_DOCSIZE) ){
+    if( pConfig->bColumnsize ){
+      i64 iRowid = fts5CursorRowid(pCsr);
+      rc = sqlite3Fts5StorageDocsize(pTab->pStorage, iRowid, pCsr->aColumnSize);
+    }else if( pConfig->zContent==0 ){
+      int i;
+      for(i=0; i<pConfig->nCol; i++){
+        if( pConfig->abUnindexed[i]==0 ){
+          pCsr->aColumnSize[i] = -1;
+        }
+      }
+    }else{
+      int i;
+      for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){
+        if( pConfig->abUnindexed[i]==0 ){
+          const char *z; int n;
+          void *p = (void*)(&pCsr->aColumnSize[i]);
+          pCsr->aColumnSize[i] = 0;
+          rc = fts5ApiColumnText(pCtx, i, &z, &n);
+          if( rc==SQLITE_OK ){
+            rc = sqlite3Fts5Tokenize(
+                pConfig, FTS5_TOKENIZE_AUX, z, n, p, fts5ColumnSizeCb
+            );
+          }
+        }
+      }
+    }
+    CsrFlagClear(pCsr, FTS5CSR_REQUIRE_DOCSIZE);
+  }
+  if( iCol<0 ){
+    int i;
+    *pnToken = 0;
+    for(i=0; i<pConfig->nCol; i++){
+      *pnToken += pCsr->aColumnSize[i];
+    }
+  }else if( iCol<pConfig->nCol ){
+    *pnToken = pCsr->aColumnSize[iCol];
+  }else{
+    *pnToken = 0;
+    rc = SQLITE_RANGE;
+  }
+  return rc;
+}
+
+/*
+** Implementation of the xSetAuxdata() method.
+*/
+static int fts5ApiSetAuxdata(
+  Fts5Context *pCtx,              /* Fts5 context */
+  void *pPtr,                     /* Pointer to save as auxdata */
+  void(*xDelete)(void*)           /* Destructor for pPtr (or NULL) */
+){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  Fts5Auxdata *pData;
+
+  /* Search through the cursors list of Fts5Auxdata objects for one that
+  ** corresponds to the currently executing auxiliary function.  */
+  for(pData=pCsr->pAuxdata; pData; pData=pData->pNext){
+    if( pData->pAux==pCsr->pAux ) break;
+  }
+
+  if( pData ){
+    if( pData->xDelete ){
+      pData->xDelete(pData->pPtr);
+    }
+  }else{
+    int rc = SQLITE_OK;
+    pData = (Fts5Auxdata*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Auxdata));
+    if( pData==0 ){
+      if( xDelete ) xDelete(pPtr);
+      return rc;
+    }
+    pData->pAux = pCsr->pAux;
+    pData->pNext = pCsr->pAuxdata;
+    pCsr->pAuxdata = pData;
+  }
+
+  pData->xDelete = xDelete;
+  pData->pPtr = pPtr;
+  return SQLITE_OK;
+}
+
+static void *fts5ApiGetAuxdata(Fts5Context *pCtx, int bClear){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  Fts5Auxdata *pData;
+  void *pRet = 0;
+
+  for(pData=pCsr->pAuxdata; pData; pData=pData->pNext){
+    if( pData->pAux==pCsr->pAux ) break;
+  }
+
+  if( pData ){
+    pRet = pData->pPtr;
+    if( bClear ){
+      pData->pPtr = 0;
+      pData->xDelete = 0;
+    }
+  }
+
+  return pRet;
+}
+
+static void fts5ApiPhraseNext(
+  Fts5Context *pCtx, 
+  Fts5PhraseIter *pIter, 
+  int *piCol, int *piOff
+){
+  if( pIter->a>=pIter->b ){
+    *piCol = -1;
+    *piOff = -1;
+  }else{
+    int iVal;
+    pIter->a += fts5GetVarint32(pIter->a, iVal);
+    if( iVal==1 ){
+      pIter->a += fts5GetVarint32(pIter->a, iVal);
+      *piCol = iVal;
+      *piOff = 0;
+      pIter->a += fts5GetVarint32(pIter->a, iVal);
+    }
+    *piOff += (iVal-2);
+  }
+}
+
+static void fts5ApiPhraseFirst(
+  Fts5Context *pCtx, 
+  int iPhrase, 
+  Fts5PhraseIter *pIter, 
+  int *piCol, int *piOff
+){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  int n = fts5CsrPoslist(pCsr, iPhrase, &pIter->a);
+  pIter->b = &pIter->a[n];
+  *piCol = 0;
+  *piOff = 0;
+  fts5ApiPhraseNext(pCtx, pIter, piCol, piOff);
+}
+
+static int fts5ApiQueryPhrase(Fts5Context*, int, void*, 
+    int(*)(const Fts5ExtensionApi*, Fts5Context*, void*)
+);
+
+static const Fts5ExtensionApi sFts5Api = {
+  2,                            /* iVersion */
+  fts5ApiUserData,
+  fts5ApiColumnCount,
+  fts5ApiRowCount,
+  fts5ApiColumnTotalSize,
+  fts5ApiTokenize,
+  fts5ApiPhraseCount,
+  fts5ApiPhraseSize,
+  fts5ApiInstCount,
+  fts5ApiInst,
+  fts5ApiRowid,
+  fts5ApiColumnText,
+  fts5ApiColumnSize,
+  fts5ApiQueryPhrase,
+  fts5ApiSetAuxdata,
+  fts5ApiGetAuxdata,
+  fts5ApiPhraseFirst,
+  fts5ApiPhraseNext,
+};
+
+
+/*
+** Implementation of API function xQueryPhrase().
+*/
+static int fts5ApiQueryPhrase(
+  Fts5Context *pCtx, 
+  int iPhrase, 
+  void *pUserData,
+  int(*xCallback)(const Fts5ExtensionApi*, Fts5Context*, void*)
+){
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;
+  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);
+  int rc;
+  Fts5Cursor *pNew = 0;
+
+  rc = fts5OpenMethod(pCsr->base.pVtab, (sqlite3_vtab_cursor**)&pNew);
+  if( rc==SQLITE_OK ){
+    Fts5Config *pConf = pTab->pConfig;
+    pNew->ePlan = FTS5_PLAN_MATCH;
+    pNew->iFirstRowid = SMALLEST_INT64;
+    pNew->iLastRowid = LARGEST_INT64;
+    pNew->base.pVtab = (sqlite3_vtab*)pTab;
+    rc = sqlite3Fts5ExprClonePhrase(pConf, pCsr->pExpr, iPhrase, &pNew->pExpr);
+  }
+
+  if( rc==SQLITE_OK ){
+    for(rc = fts5CursorFirst(pTab, pNew, 0);
+        rc==SQLITE_OK && CsrFlagTest(pNew, FTS5CSR_EOF)==0;
+        rc = fts5NextMethod((sqlite3_vtab_cursor*)pNew)
+    ){
+      rc = xCallback(&sFts5Api, (Fts5Context*)pNew, pUserData);
+      if( rc!=SQLITE_OK ){
+        if( rc==SQLITE_DONE ) rc = SQLITE_OK;
+        break;
+      }
+    }
+  }
+
+  fts5CloseMethod((sqlite3_vtab_cursor*)pNew);
+  return rc;
+}
+
+static void fts5ApiInvoke(
+  Fts5Auxiliary *pAux,
+  Fts5Cursor *pCsr,
+  sqlite3_context *context,
+  int argc,
+  sqlite3_value **argv
+){
+  assert( pCsr->pAux==0 );
+  pCsr->pAux = pAux;
+  pAux->xFunc(&sFts5Api, (Fts5Context*)pCsr, context, argc, argv);
+  pCsr->pAux = 0;
+}
+
+static Fts5Cursor *fts5CursorFromCsrid(Fts5Global *pGlobal, i64 iCsrId){
+  Fts5Cursor *pCsr;
+  for(pCsr=pGlobal->pCsr; pCsr; pCsr=pCsr->pNext){
+    if( pCsr->iCsrId==iCsrId ) break;
+  }
+  return pCsr;
+}
+
+static void fts5ApiCallback(
+  sqlite3_context *context,
+  int argc,
+  sqlite3_value **argv
+){
+
+  Fts5Auxiliary *pAux;
+  Fts5Cursor *pCsr;
+  i64 iCsrId;
+
+  assert( argc>=1 );
+  pAux = (Fts5Auxiliary*)sqlite3_user_data(context);
+  iCsrId = sqlite3_value_int64(argv[0]);
+
+  pCsr = fts5CursorFromCsrid(pAux->pGlobal, iCsrId);
+  if( pCsr==0 ){
+    char *zErr = sqlite3_mprintf("no such cursor: %lld", iCsrId);
+    sqlite3_result_error(context, zErr, -1);
+    sqlite3_free(zErr);
+  }else{
+    fts5ApiInvoke(pAux, pCsr, context, argc-1, &argv[1]);
+  }
+}
+
+
+/*
+** Given cursor id iId, return a pointer to the corresponding Fts5Index 
+** object. Or NULL If the cursor id does not exist.
+**
+** If successful, set *pnCol to the number of indexed columns in the
+** table before returning.
+*/
+static Fts5Index *sqlite3Fts5IndexFromCsrid(
+  Fts5Global *pGlobal, 
+  i64 iCsrId, 
+  int *pnCol
+){
+  Fts5Cursor *pCsr;
+  Fts5Table *pTab;
+
+  pCsr = fts5CursorFromCsrid(pGlobal, iCsrId);
+  pTab = (Fts5Table*)pCsr->base.pVtab;
+  *pnCol = pTab->pConfig->nCol;
+
+  return pTab->pIndex;
+}
+
+/*
+** Return a "position-list blob" corresponding to the current position of
+** cursor pCsr via sqlite3_result_blob(). A position-list blob contains
+** the current position-list for each phrase in the query associated with
+** cursor pCsr.
+**
+** A position-list blob begins with (nPhrase-1) varints, where nPhrase is
+** the number of phrases in the query. Following the varints are the
+** concatenated position lists for each phrase, in order.
+**
+** The first varint (if it exists) contains the size of the position list
+** for phrase 0. The second (same disclaimer) contains the size of position
+** list 1. And so on. There is no size field for the final position list,
+** as it can be derived from the total size of the blob.
+*/
+static int fts5PoslistBlob(sqlite3_context *pCtx, Fts5Cursor *pCsr){
+  int i;
+  int rc = SQLITE_OK;
+  int nPhrase = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);
+  Fts5Buffer val;
+
+  memset(&val, 0, sizeof(Fts5Buffer));
+
+  /* Append the varints */
+  for(i=0; i<(nPhrase-1); i++){
+    const u8 *dummy;
+    int nByte = sqlite3Fts5ExprPoslist(pCsr->pExpr, i, &dummy);
+    sqlite3Fts5BufferAppendVarint(&rc, &val, nByte);
+  }
+
+  /* Append the position lists */
+  for(i=0; i<nPhrase; i++){
+    const u8 *pPoslist;
+    int nPoslist;
+    nPoslist = sqlite3Fts5ExprPoslist(pCsr->pExpr, i, &pPoslist);
+    sqlite3Fts5BufferAppendBlob(&rc, &val, nPoslist, pPoslist);
+  }
+
+  sqlite3_result_blob(pCtx, val.p, val.n, sqlite3_free);
+  return rc;
+}
+
+/* 
+** This is the xColumn method, called by SQLite to request a value from
+** the row that the supplied cursor currently points to.
+*/
+static int fts5ColumnMethod(
+  sqlite3_vtab_cursor *pCursor,   /* Cursor to retrieve value from */
+  sqlite3_context *pCtx,          /* Context for sqlite3_result_xxx() calls */
+  int iCol                        /* Index of column to read value from */
+){
+  Fts5Table *pTab = (Fts5Table*)(pCursor->pVtab);
+  Fts5Config *pConfig = pTab->pConfig;
+  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;
+  int rc = SQLITE_OK;
+  
+  assert( CsrFlagTest(pCsr, FTS5CSR_EOF)==0 );
+
+  if( pCsr->ePlan==FTS5_PLAN_SPECIAL ){
+    if( iCol==pConfig->nCol ){
+      sqlite3_result_int64(pCtx, pCsr->iSpecial);
+    }
+  }else
+
+  if( iCol==pConfig->nCol ){
+    /* User is requesting the value of the special column with the same name
+    ** as the table. Return the cursor integer id number. This value is only
+    ** useful in that it may be passed as the first argument to an FTS5
+    ** auxiliary function.  */
+    sqlite3_result_int64(pCtx, pCsr->iCsrId);
+  }else if( iCol==pConfig->nCol+1 ){
+
+    /* The value of the "rank" column. */
+    if( pCsr->ePlan==FTS5_PLAN_SOURCE ){
+      fts5PoslistBlob(pCtx, pCsr);
+    }else if( 
+        pCsr->ePlan==FTS5_PLAN_MATCH
+     || pCsr->ePlan==FTS5_PLAN_SORTED_MATCH
+    ){
+      if( pCsr->pRank || SQLITE_OK==(rc = fts5FindRankFunction(pCsr)) ){
+        fts5ApiInvoke(pCsr->pRank, pCsr, pCtx, pCsr->nRankArg, pCsr->apRankArg);
+      }
+    }
+  }else if( !fts5IsContentless(pTab) ){
+    rc = fts5SeekCursor(pCsr, 1);
+    if( rc==SQLITE_OK ){
+      sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol+1));
+    }
+  }
+  return rc;
+}
+
+
+/*
+** This routine implements the xFindFunction method for the FTS3
+** virtual table.
+*/
+static int fts5FindFunctionMethod(
+  sqlite3_vtab *pVtab,            /* Virtual table handle */
+  int nArg,                       /* Number of SQL function arguments */
+  const char *zName,              /* Name of SQL function */
+  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), /* OUT: Result */
+  void **ppArg                    /* OUT: User data for *pxFunc */
+){
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  Fts5Auxiliary *pAux;
+
+  pAux = fts5FindAuxiliary(pTab, zName);
+  if( pAux ){
+    *pxFunc = fts5ApiCallback;
+    *ppArg = (void*)pAux;
+    return 1;
+  }
+
+  /* No function of the specified name was found. Return 0. */
+  return 0;
+}
+
+/*
+** Implementation of FTS5 xRename method. Rename an fts5 table.
+*/
+static int fts5RenameMethod(
+  sqlite3_vtab *pVtab,            /* Virtual table handle */
+  const char *zName               /* New name of table */
+){
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  return sqlite3Fts5StorageRename(pTab->pStorage, zName);
+}
+
+/*
+** The xSavepoint() method.
+**
+** Flush the contents of the pending-terms table to disk.
+*/
+static int fts5SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  fts5CheckTransactionState(pTab, FTS5_SAVEPOINT, iSavepoint);
+  fts5TripCursors(pTab);
+  return sqlite3Fts5StorageSync(pTab->pStorage, 0);
+}
+
+/*
+** The xRelease() method.
+**
+** This is a no-op.
+*/
+static int fts5ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint){
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  fts5CheckTransactionState(pTab, FTS5_RELEASE, iSavepoint);
+  fts5TripCursors(pTab);
+  return sqlite3Fts5StorageSync(pTab->pStorage, 0);
+}
+
+/*
+** The xRollbackTo() method.
+**
+** Discard the contents of the pending terms table.
+*/
+static int fts5RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint){
+  Fts5Table *pTab = (Fts5Table*)pVtab;
+  fts5CheckTransactionState(pTab, FTS5_ROLLBACKTO, iSavepoint);
+  fts5TripCursors(pTab);
+  return sqlite3Fts5StorageRollback(pTab->pStorage);
+}
+
+/*
+** Register a new auxiliary function with global context pGlobal.
+*/
+static int fts5CreateAux(
+  fts5_api *pApi,                 /* Global context (one per db handle) */
+  const char *zName,              /* Name of new function */
+  void *pUserData,                /* User data for aux. function */
+  fts5_extension_function xFunc,  /* Aux. function implementation */
+  void(*xDestroy)(void*)          /* Destructor for pUserData */
+){
+  Fts5Global *pGlobal = (Fts5Global*)pApi;
+  int rc = sqlite3_overload_function(pGlobal->db, zName, -1);
+  if( rc==SQLITE_OK ){
+    Fts5Auxiliary *pAux;
+    int nName;                      /* Size of zName in bytes, including \0 */
+    int nByte;                      /* Bytes of space to allocate */
+
+    nName = (int)strlen(zName) + 1;
+    nByte = sizeof(Fts5Auxiliary) + nName;
+    pAux = (Fts5Auxiliary*)sqlite3_malloc(nByte);
+    if( pAux ){
+      memset(pAux, 0, nByte);
+      pAux->zFunc = (char*)&pAux[1];
+      memcpy(pAux->zFunc, zName, nName);
+      pAux->pGlobal = pGlobal;
+      pAux->pUserData = pUserData;
+      pAux->xFunc = xFunc;
+      pAux->xDestroy = xDestroy;
+      pAux->pNext = pGlobal->pAux;
+      pGlobal->pAux = pAux;
+    }else{
+      rc = SQLITE_NOMEM;
+    }
+  }
+
+  return rc;
+}
+
+/*
+** Register a new tokenizer. This is the implementation of the 
+** fts5_api.xCreateTokenizer() method.
+*/
+static int fts5CreateTokenizer(
+  fts5_api *pApi,                 /* Global context (one per db handle) */
+  const char *zName,              /* Name of new function */
+  void *pUserData,                /* User data for aux. function */
+  fts5_tokenizer *pTokenizer,     /* Tokenizer implementation */
+  void(*xDestroy)(void*)          /* Destructor for pUserData */
+){
+  Fts5Global *pGlobal = (Fts5Global*)pApi;
+  Fts5TokenizerModule *pNew;
+  int nName;                      /* Size of zName and its \0 terminator */
+  int nByte;                      /* Bytes of space to allocate */
+  int rc = SQLITE_OK;
+
+  nName = (int)strlen(zName) + 1;
+  nByte = sizeof(Fts5TokenizerModule) + nName;
+  pNew = (Fts5TokenizerModule*)sqlite3_malloc(nByte);
+  if( pNew ){
+    memset(pNew, 0, nByte);
+    pNew->zName = (char*)&pNew[1];
+    memcpy(pNew->zName, zName, nName);
+    pNew->pUserData = pUserData;
+    pNew->x = *pTokenizer;
+    pNew->xDestroy = xDestroy;
+    pNew->pNext = pGlobal->pTok;
+    pGlobal->pTok = pNew;
+    if( pNew->pNext==0 ){
+      pGlobal->pDfltTok = pNew;
+    }
+  }else{
+    rc = SQLITE_NOMEM;
+  }
+
+  return rc;
+}
+
+static Fts5TokenizerModule *fts5LocateTokenizer(
+  Fts5Global *pGlobal, 
+  const char *zName
+){
+  Fts5TokenizerModule *pMod = 0;
+
+  if( zName==0 ){
+    pMod = pGlobal->pDfltTok;
+  }else{
+    for(pMod=pGlobal->pTok; pMod; pMod=pMod->pNext){
+      if( sqlite3_stricmp(zName, pMod->zName)==0 ) break;
+    }
+  }
+
+  return pMod;
+}
+
+/*
+** Find a tokenizer. This is the implementation of the 
+** fts5_api.xFindTokenizer() method.
+*/
+static int fts5FindTokenizer(
+  fts5_api *pApi,                 /* Global context (one per db handle) */
+  const char *zName,              /* Name of new function */
+  void **ppUserData,
+  fts5_tokenizer *pTokenizer      /* Populate this object */
+){
+  int rc = SQLITE_OK;
+  Fts5TokenizerModule *pMod;
+
+  pMod = fts5LocateTokenizer((Fts5Global*)pApi, zName);
+  if( pMod ){
+    *pTokenizer = pMod->x;
+    *ppUserData = pMod->pUserData;
+  }else{
+    memset(pTokenizer, 0, sizeof(fts5_tokenizer));
+    rc = SQLITE_ERROR;
+  }
+
+  return rc;
+}
+
+static int sqlite3Fts5GetTokenizer(
+  Fts5Global *pGlobal, 
+  const char **azArg,
+  int nArg,
+  Fts5Tokenizer **ppTok,
+  fts5_tokenizer **ppTokApi,
+  char **pzErr
+){
+  Fts5TokenizerModule *pMod;
+  int rc = SQLITE_OK;
+
+  pMod = fts5LocateTokenizer(pGlobal, nArg==0 ? 0 : azArg[0]);
+  if( pMod==0 ){
+    assert( nArg>0 );
+    rc = SQLITE_ERROR;
+    *pzErr = sqlite3_mprintf("no such tokenizer: %s", azArg[0]);
+  }else{
+    rc = pMod->x.xCreate(pMod->pUserData, &azArg[1], (nArg?nArg-1:0), ppTok);
+    *ppTokApi = &pMod->x;
+    if( rc!=SQLITE_OK && pzErr ){
+      *pzErr = sqlite3_mprintf("error in tokenizer constructor");
+    }
+  }
+
+  if( rc!=SQLITE_OK ){
+    *ppTokApi = 0;
+    *ppTok = 0;
+  }
+
+  return rc;
+}
+
+static void fts5ModuleDestroy(void *pCtx){
+  Fts5TokenizerModule *pTok, *pNextTok;
+  Fts5Auxiliary *pAux, *pNextAux;
+  Fts5Global *pGlobal = (Fts5Global*)pCtx;
+
+  for(pAux=pGlobal->pAux; pAux; pAux=pNextAux){
+    pNextAux = pAux->pNext;
+    if( pAux->xDestroy ) pAux->xDestroy(pAux->pUserData);
+    sqlite3_free(pAux);
+  }
+
+  for(pTok=pGlobal->pTok; pTok; pTok=pNextTok){
+    pNextTok = pTok->pNext;
+    if( pTok->xDestroy ) pTok->xDestroy(pTok->pUserData);
+    sqlite3_free(pTok);
+  }
+
+  sqlite3_free(pGlobal);
+}
+
+static void fts5Fts5Func(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args */
+  sqlite3_value **apVal           /* Function arguments */
+){
+  Fts5Global *pGlobal = (Fts5Global*)sqlite3_user_data(pCtx);
+  char buf[8];
+  assert( nArg==0 );
+  assert( sizeof(buf)>=sizeof(pGlobal) );
+  memcpy(buf, (void*)&pGlobal, sizeof(pGlobal));
+  sqlite3_result_blob(pCtx, buf, sizeof(pGlobal), SQLITE_TRANSIENT);
+}
+
+/*
+** Implementation of fts5_source_id() function.
+*/
+static void fts5SourceIdFunc(
+  sqlite3_context *pCtx,          /* Function call context */
+  int nArg,                       /* Number of args */
+  sqlite3_value **apVal           /* Function arguments */
+){
+  assert( nArg==0 );
+  sqlite3_result_text(pCtx, "fts5: 2015-11-02 18:31:45 bda77dda9697c463c3d0704014d51627fceee328", -1, SQLITE_TRANSIENT);
+}
+
+static int fts5Init(sqlite3 *db){
+  static const sqlite3_module fts5Mod = {
+    /* iVersion      */ 2,
+    /* xCreate       */ fts5CreateMethod,
+    /* xConnect      */ fts5ConnectMethod,
+    /* xBestIndex    */ fts5BestIndexMethod,
+    /* xDisconnect   */ fts5DisconnectMethod,
+    /* xDestroy      */ fts5DestroyMethod,
+    /* xOpen         */ fts5OpenMethod,
+    /* xClose        */ fts5CloseMethod,
+    /* xFilter       */ fts5FilterMethod,
+    /* xNext         */ fts5NextMethod,
+    /* xEof          */ fts5EofMethod,
+    /* xColumn       */ fts5ColumnMethod,
+    /* xRowid        */ fts5RowidMethod,
+    /* xUpdate       */ fts5UpdateMethod,
+    /* xBegin        */ fts5BeginMethod,
+    /* xSync         */ fts5SyncMethod,
+    /* xCommit       */ fts5CommitMethod,
+    /* xRollback     */ fts5RollbackMethod,
+    /* xFindFunction */ fts5FindFunctionMethod,
+    /* xRename       */ fts5RenameMethod,
+    /* xSavepoint    */ fts5SavepointMethod,
+    /* xRelease      */ fts5ReleaseMethod,
+    /* xRollbackTo   */ fts5RollbackToMethod,
+  };
+
+  int rc;
+  Fts5Global *pGlobal = 0;
+
+  pGlobal = (Fts5Global*)sqlite3_malloc(sizeof(Fts5Global));
+  if( pGlobal==0 ){
+    rc = SQLITE_NOMEM;
+  }else{
+    void *p = (void*)pGlobal;
+    memset(pGlobal, 0, sizeof(Fts5Global));
+    pGlobal->db = db;
+    pGlobal->api.iVersion = 2;
+    pGlobal->api.xCreateFunction = fts5CreateAux;
+    pGlobal->api.xCreateTokenizer = fts5CreateTokenizer;
+    pGlobal->api.xFindTokenizer = fts5FindTokenizer;
+    rc = sqlite3_create_module_v2(db, "fts5", &fts5Mod, p, fts5ModuleDestroy);
+    if( rc==SQLITE_OK ) rc = sqlite3Fts5IndexInit(db);
+    if( rc==SQLITE_OK ) rc = sqlite3Fts5ExprInit(pGlobal, db);
+    if( rc==SQLITE_OK ) rc = sqlite3Fts5AuxInit(&pGlobal->api);
+    if( rc==SQLITE_OK ) rc = sqlite3Fts5TokenizerInit(&pGlobal->api);
+    if( rc==SQLITE_OK ) rc = sqlite3Fts5VocabInit(pGlobal, db);
+    if( rc==SQLITE_OK ){
+      rc = sqlite3_create_function(
+          db, "fts5", 0, SQLITE_UTF8, p, fts5Fts5Func, 0, 0
+      );
+    }
+    if( rc==SQLITE_OK ){
+      rc = sqlite3_create_function(
+          db, "fts5_source_id", 0, SQLITE_UTF8, p, fts5SourceIdFunc, 0, 0
+      );
+    }
+  }
+  return rc;
+}
+
+/*
+** The following functions are used to register the module with SQLite. If
+** this module is being built as part of the SQLite core (SQLITE_CORE is
+** defined), then sqlite3_open() will call sqlite3Fts5Init() directly.
+**
+** Or, if this module is being built as a loadable extension, 
+** sqlite3Fts5Init() is omitted and the two standard entry points
+** sqlite3_fts_init() and sqlite3_fts5_init() defined instead.
+*/
+#ifndef SQLITE_CORE
+#ifdef _WIN32
+__declspec(dllexport)
+#endif
+SQLITE_API int SQLITE_STDCALL sqlite3_fts_init(
+  sqlite3 *db,
+  char **pzErrMsg,
+  const sqlite3_api_routines *pApi
+){
+  SQLITE_EXTENSION_INIT2(pApi);
+  (void)pzErrMsg;  /* Unused parameter */
+  return fts5Init(db);
+}
+
+#ifdef _WIN32
+__declspec(dllexport)
+#endif
+SQLITE_API int SQLITE_STDCALL sqlite3_fts5_init(
+  sqlite3 *db,
+  char **pzErrMsg,
+  const sqlite3_api_routines *pApi
+){
+  SQLITE_EXTENSION_INIT2(pApi);
+  (void)pzErrMsg;  /* Unused parameter */
+  return fts5Init(db);
+}
+#else
+SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3 *db){
+  return fts5Init(db);
+}
+#endif
+
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+*/
+
+
+
+
+struct Fts5Storage {
+  Fts5Config *pConfig;
+  Fts5Index *pIndex;
+  int bTotalsValid;               /* True if nTotalRow/aTotalSize[] are valid */
+  i64 nTotalRow;                  /* Total number of rows in FTS table */
+  i64 *aTotalSize;                /* Total sizes of each column */ 
+  sqlite3_stmt *aStmt[11];
+};
+
+
+#if FTS5_STMT_SCAN_ASC!=0 
+# error "FTS5_STMT_SCAN_ASC mismatch" 
+#endif
+#if FTS5_STMT_SCAN_DESC!=1 
+# error "FTS5_STMT_SCAN_DESC mismatch" 
+#endif
+#if FTS5_STMT_LOOKUP!=2
+# error "FTS5_STMT_LOOKUP mismatch" 
+#endif
+
+#define FTS5_STMT_INSERT_CONTENT  3
+#define FTS5_STMT_REPLACE_CONTENT 4
+#define FTS5_STMT_DELETE_CONTENT  5
+#define FTS5_STMT_REPLACE_DOCSIZE  6
+#define FTS5_STMT_DELETE_DOCSIZE  7
+#define FTS5_STMT_LOOKUP_DOCSIZE  8
+#define FTS5_STMT_REPLACE_CONFIG 9
+#define FTS5_STMT_SCAN 10
+
+/*
+** Prepare the two insert statements - Fts5Storage.pInsertContent and
+** Fts5Storage.pInsertDocsize - if they have not already been prepared.
+** Return SQLITE_OK if successful, or an SQLite error code if an error
+** occurs.
+*/
+static int fts5StorageGetStmt(
+  Fts5Storage *p,                 /* Storage handle */
+  int eStmt,                      /* FTS5_STMT_XXX constant */
+  sqlite3_stmt **ppStmt,          /* OUT: Prepared statement handle */
+  char **pzErrMsg                 /* OUT: Error message (if any) */
+){
+  int rc = SQLITE_OK;
+
+  /* If there is no %_docsize table, there should be no requests for 
+  ** statements to operate on it.  */
+  assert( p->pConfig->bColumnsize || (
+        eStmt!=FTS5_STMT_REPLACE_DOCSIZE 
+     && eStmt!=FTS5_STMT_DELETE_DOCSIZE 
+     && eStmt!=FTS5_STMT_LOOKUP_DOCSIZE 
+  ));
+
+  assert( eStmt>=0 && eStmt<ArraySize(p->aStmt) );
+  if( p->aStmt[eStmt]==0 ){
+    const char *azStmt[] = {
+      "SELECT %s FROM %s T WHERE T.%Q >= ? AND T.%Q <= ? ORDER BY T.%Q ASC",
+      "SELECT %s FROM %s T WHERE T.%Q <= ? AND T.%Q >= ? ORDER BY T.%Q DESC",
+      "SELECT %s FROM %s T WHERE T.%Q=?",               /* LOOKUP  */
+
+      "INSERT INTO %Q.'%q_content' VALUES(%s)",         /* INSERT_CONTENT  */
+      "REPLACE INTO %Q.'%q_content' VALUES(%s)",        /* REPLACE_CONTENT */
+      "DELETE FROM %Q.'%q_content' WHERE id=?",         /* DELETE_CONTENT  */
+      "REPLACE INTO %Q.'%q_docsize' VALUES(?,?)",       /* REPLACE_DOCSIZE  */
+      "DELETE FROM %Q.'%q_docsize' WHERE id=?",         /* DELETE_DOCSIZE  */
+
+      "SELECT sz FROM %Q.'%q_docsize' WHERE id=?",      /* LOOKUP_DOCSIZE  */
+
+      "REPLACE INTO %Q.'%q_config' VALUES(?,?)",        /* REPLACE_CONFIG */
+      "SELECT %s FROM %s AS T",                         /* SCAN */
+    };
+    Fts5Config *pC = p->pConfig;
+    char *zSql = 0;
+
+    switch( eStmt ){
+      case FTS5_STMT_SCAN:
+        zSql = sqlite3_mprintf(azStmt[eStmt], 
+            pC->zContentExprlist, pC->zContent
+        );
+        break;
+
+      case FTS5_STMT_SCAN_ASC:
+      case FTS5_STMT_SCAN_DESC:
+        zSql = sqlite3_mprintf(azStmt[eStmt], pC->zContentExprlist, 
+            pC->zContent, pC->zContentRowid, pC->zContentRowid,
+            pC->zContentRowid
+        );
+        break;
+
+      case FTS5_STMT_LOOKUP:
+        zSql = sqlite3_mprintf(azStmt[eStmt], 
+            pC->zContentExprlist, pC->zContent, pC->zContentRowid
+        );
+        break;
+
+      case FTS5_STMT_INSERT_CONTENT: 
+      case FTS5_STMT_REPLACE_CONTENT: {
+        int nCol = pC->nCol + 1;
+        char *zBind;
+        int i;
+
+        zBind = sqlite3_malloc(1 + nCol*2);
+        if( zBind ){
+          for(i=0; i<nCol; i++){
+            zBind[i*2] = '?';
+            zBind[i*2 + 1] = ',';
+          }
+          zBind[i*2-1] = '\0';
+          zSql = sqlite3_mprintf(azStmt[eStmt], pC->zDb, pC->zName, zBind);
+          sqlite3_free(zBind);
+        }
+        break;
+      }
+
+      default:
+        zSql = sqlite3_mprintf(azStmt[eStmt], pC->zDb, pC->zName);
+        break;
+    }
+
+    if( zSql==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      rc = sqlite3_prepare_v2(pC->db, zSql, -1, &p->aStmt[eStmt], 0);
+      sqlite3_free(zSql);
+      if( rc!=SQLITE_OK && pzErrMsg ){
+        *pzErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pC->db));
+      }
+    }
+  }
+
+  *ppStmt = p->aStmt[eStmt];
+  return rc;
+}
+
+
+static int fts5ExecPrintf(
+  sqlite3 *db,
+  char **pzErr,
+  const char *zFormat,
+  ...
+){
+  int rc;
+  va_list ap;                     /* ... printf arguments */
+  char *zSql;
+
+  va_start(ap, zFormat);
+  zSql = sqlite3_vmprintf(zFormat, ap);
+
+  if( zSql==0 ){
+    rc = SQLITE_NOMEM;
+  }else{
+    rc = sqlite3_exec(db, zSql, 0, 0, pzErr);
+    sqlite3_free(zSql);
+  }
+
+  va_end(ap);
+  return rc;
+}
+
+/*
+** Drop all shadow tables. Return SQLITE_OK if successful or an SQLite error
+** code otherwise.
+*/
+static int sqlite3Fts5DropAll(Fts5Config *pConfig){
+  int rc = fts5ExecPrintf(pConfig->db, 0, 
+      "DROP TABLE IF EXISTS %Q.'%q_data';"
+      "DROP TABLE IF EXISTS %Q.'%q_idx';"
+      "DROP TABLE IF EXISTS %Q.'%q_config';",
+      pConfig->zDb, pConfig->zName,
+      pConfig->zDb, pConfig->zName,
+      pConfig->zDb, pConfig->zName
+  );
+  if( rc==SQLITE_OK && pConfig->bColumnsize ){
+    rc = fts5ExecPrintf(pConfig->db, 0, 
+        "DROP TABLE IF EXISTS %Q.'%q_docsize';",
+        pConfig->zDb, pConfig->zName
+    );
+  }
+  if( rc==SQLITE_OK && pConfig->eContent==FTS5_CONTENT_NORMAL ){
+    rc = fts5ExecPrintf(pConfig->db, 0, 
+        "DROP TABLE IF EXISTS %Q.'%q_content';",
+        pConfig->zDb, pConfig->zName
+    );
+  }
+  return rc;
+}
+
+static void fts5StorageRenameOne(
+  Fts5Config *pConfig,            /* Current FTS5 configuration */
+  int *pRc,                       /* IN/OUT: Error code */
+  const char *zTail,              /* Tail of table name e.g. "data", "config" */
+  const char *zName               /* New name of FTS5 table */
+){
+  if( *pRc==SQLITE_OK ){
+    *pRc = fts5ExecPrintf(pConfig->db, 0, 
+        "ALTER TABLE %Q.'%q_%s' RENAME TO '%q_%s';",
+        pConfig->zDb, pConfig->zName, zTail, zName, zTail
+    );
+  }
+}
+
+static int sqlite3Fts5StorageRename(Fts5Storage *pStorage, const char *zName){
+  Fts5Config *pConfig = pStorage->pConfig;
+  int rc = sqlite3Fts5StorageSync(pStorage, 1);
+
+  fts5StorageRenameOne(pConfig, &rc, "data", zName);
+  fts5StorageRenameOne(pConfig, &rc, "idx", zName);
+  fts5StorageRenameOne(pConfig, &rc, "config", zName);
+  if( pConfig->bColumnsize ){
+    fts5StorageRenameOne(pConfig, &rc, "docsize", zName);
+  }
+  if( pConfig->eContent==FTS5_CONTENT_NORMAL ){
+    fts5StorageRenameOne(pConfig, &rc, "content", zName);
+  }
+  return rc;
+}
+
+/*
+** Create the shadow table named zPost, with definition zDefn. Return
+** SQLITE_OK if successful, or an SQLite error code otherwise.
+*/
+static int sqlite3Fts5CreateTable(
+  Fts5Config *pConfig,            /* FTS5 configuration */
+  const char *zPost,              /* Shadow table to create (e.g. "content") */
+  const char *zDefn,              /* Columns etc. for shadow table */
+  int bWithout,                   /* True for without rowid */
+  char **pzErr                    /* OUT: Error message */
+){
+  int rc;
+  char *zErr = 0;
+
+  rc = fts5ExecPrintf(pConfig->db, &zErr, "CREATE TABLE %Q.'%q_%q'(%s)%s",
+      pConfig->zDb, pConfig->zName, zPost, zDefn, bWithout?" WITHOUT ROWID":""
+  );
+  if( zErr ){
+    *pzErr = sqlite3_mprintf(
+        "fts5: error creating shadow table %q_%s: %s", 
+        pConfig->zName, zPost, zErr
+    );
+    sqlite3_free(zErr);
+  }
+
+  return rc;
+}
+
+/*
+** Open a new Fts5Index handle. If the bCreate argument is true, create
+** and initialize the underlying tables 
+**
+** If successful, set *pp to point to the new object and return SQLITE_OK.
+** Otherwise, set *pp to NULL and return an SQLite error code.
+*/
+static int sqlite3Fts5StorageOpen(
+  Fts5Config *pConfig, 
+  Fts5Index *pIndex, 
+  int bCreate, 
+  Fts5Storage **pp,
+  char **pzErr                    /* OUT: Error message */
+){
+  int rc = SQLITE_OK;
+  Fts5Storage *p;                 /* New object */
+  int nByte;                      /* Bytes of space to allocate */
+
+  nByte = sizeof(Fts5Storage)               /* Fts5Storage object */
+        + pConfig->nCol * sizeof(i64);      /* Fts5Storage.aTotalSize[] */
+  *pp = p = (Fts5Storage*)sqlite3_malloc(nByte);
+  if( !p ) return SQLITE_NOMEM;
+
+  memset(p, 0, nByte);
+  p->aTotalSize = (i64*)&p[1];
+  p->pConfig = pConfig;
+  p->pIndex = pIndex;
+
+  if( bCreate ){
+    if( pConfig->eContent==FTS5_CONTENT_NORMAL ){
+      int nDefn = 32 + pConfig->nCol*10;
+      char *zDefn = sqlite3_malloc(32 + pConfig->nCol * 10);
+      if( zDefn==0 ){
+        rc = SQLITE_NOMEM;
+      }else{
+        int i;
+        int iOff;
+        sqlite3_snprintf(nDefn, zDefn, "id INTEGER PRIMARY KEY");
+        iOff = strlen(zDefn);
+        for(i=0; i<pConfig->nCol; i++){
+          sqlite3_snprintf(nDefn-iOff, &zDefn[iOff], ", c%d", i);
+          iOff += strlen(&zDefn[iOff]);
+        }
+        rc = sqlite3Fts5CreateTable(pConfig, "content", zDefn, 0, pzErr);
+      }
+      sqlite3_free(zDefn);
+    }
+
+    if( rc==SQLITE_OK && pConfig->bColumnsize ){
+      rc = sqlite3Fts5CreateTable(
+          pConfig, "docsize", "id INTEGER PRIMARY KEY, sz BLOB", 0, pzErr
+      );
+    }
+    if( rc==SQLITE_OK ){
+      rc = sqlite3Fts5CreateTable(
+          pConfig, "config", "k PRIMARY KEY, v", 1, pzErr
+      );
+    }
+    if( rc==SQLITE_OK ){
+      rc = sqlite3Fts5StorageConfigValue(p, "version", 0, FTS5_CURRENT_VERSION);
+    }
+  }
+
+  if( rc ){
+    sqlite3Fts5StorageClose(p);
+    *pp = 0;
+  }
+  return rc;
+}
+
+/*
+** Close a handle opened by an earlier call to sqlite3Fts5StorageOpen().
+*/
+static int sqlite3Fts5StorageClose(Fts5Storage *p){
+  int rc = SQLITE_OK;
+  if( p ){
+    int i;
+
+    /* Finalize all SQL statements */
+    for(i=0; i<ArraySize(p->aStmt); i++){
+      sqlite3_finalize(p->aStmt[i]);
+    }
+
+    sqlite3_free(p);
+  }
+  return rc;
+}
+
+typedef struct Fts5InsertCtx Fts5InsertCtx;
+struct Fts5InsertCtx {
+  Fts5Storage *pStorage;
+  int iCol;
+  int szCol;                      /* Size of column value in tokens */
+};
+
+/*
+** Tokenization callback used when inserting tokens into the FTS index.
+*/
+static int fts5StorageInsertCallback(
+  void *pContext,                 /* Pointer to Fts5InsertCtx object */
+  int tflags,
+  const char *pToken,             /* Buffer containing token */
+  int nToken,                     /* Size of token in bytes */
+  int iStart,                     /* Start offset of token */
+  int iEnd                        /* End offset of token */
+){
+  Fts5InsertCtx *pCtx = (Fts5InsertCtx*)pContext;
+  Fts5Index *pIdx = pCtx->pStorage->pIndex;
+  if( (tflags & FTS5_TOKEN_COLOCATED)==0 || pCtx->szCol==0 ){
+    pCtx->szCol++;
+  }
+  return sqlite3Fts5IndexWrite(pIdx, pCtx->iCol, pCtx->szCol-1, pToken, nToken);
+}
+
+/*
+** If a row with rowid iDel is present in the %_content table, add the
+** delete-markers to the FTS index necessary to delete it. Do not actually
+** remove the %_content row at this time though.
+*/
+static int fts5StorageDeleteFromIndex(Fts5Storage *p, i64 iDel){
+  Fts5Config *pConfig = p->pConfig;
+  sqlite3_stmt *pSeek;            /* SELECT to read row iDel from %_data */
+  int rc;                         /* Return code */
+
+  rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP, &pSeek, 0);
+  if( rc==SQLITE_OK ){
+    int rc2;
+    sqlite3_bind_int64(pSeek, 1, iDel);
+    if( sqlite3_step(pSeek)==SQLITE_ROW ){
+      int iCol;
+      Fts5InsertCtx ctx;
+      ctx.pStorage = p;
+      ctx.iCol = -1;
+      rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 1, iDel);
+      for(iCol=1; rc==SQLITE_OK && iCol<=pConfig->nCol; iCol++){
+        if( pConfig->abUnindexed[iCol-1] ) continue;
+        ctx.szCol = 0;
+        rc = sqlite3Fts5Tokenize(pConfig, 
+            FTS5_TOKENIZE_DOCUMENT,
+            (const char*)sqlite3_column_text(pSeek, iCol),
+            sqlite3_column_bytes(pSeek, iCol),
+            (void*)&ctx,
+            fts5StorageInsertCallback
+        );
+        p->aTotalSize[iCol-1] -= (i64)ctx.szCol;
+      }
+      p->nTotalRow--;
+    }
+    rc2 = sqlite3_reset(pSeek);
+    if( rc==SQLITE_OK ) rc = rc2;
+  }
+
+  return rc;
+}
+
+
+/*
+** Insert a record into the %_docsize table. Specifically, do:
+**
+**   INSERT OR REPLACE INTO %_docsize(id, sz) VALUES(iRowid, pBuf);
+**
+** If there is no %_docsize table (as happens if the columnsize=0 option
+** is specified when the FTS5 table is created), this function is a no-op.
+*/
+static int fts5StorageInsertDocsize(
+  Fts5Storage *p,                 /* Storage module to write to */
+  i64 iRowid,                     /* id value */
+  Fts5Buffer *pBuf                /* sz value */
+){
+  int rc = SQLITE_OK;
+  if( p->pConfig->bColumnsize ){
+    sqlite3_stmt *pReplace = 0;
+    rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_DOCSIZE, &pReplace, 0);
+    if( rc==SQLITE_OK ){
+      sqlite3_bind_int64(pReplace, 1, iRowid);
+      sqlite3_bind_blob(pReplace, 2, pBuf->p, pBuf->n, SQLITE_STATIC);
+      sqlite3_step(pReplace);
+      rc = sqlite3_reset(pReplace);
+    }
+  }
+  return rc;
+}
+
+/*
+** Load the contents of the "averages" record from disk into the 
+** p->nTotalRow and p->aTotalSize[] variables. If successful, and if
+** argument bCache is true, set the p->bTotalsValid flag to indicate
+** that the contents of aTotalSize[] and nTotalRow are valid until
+** further notice.
+**
+** Return SQLITE_OK if successful, or an SQLite error code if an error
+** occurs.
+*/
+static int fts5StorageLoadTotals(Fts5Storage *p, int bCache){
+  int rc = SQLITE_OK;
+  if( p->bTotalsValid==0 ){
+    rc = sqlite3Fts5IndexGetAverages(p->pIndex, &p->nTotalRow, p->aTotalSize);
+    p->bTotalsValid = bCache;
+  }
+  return rc;
+}
+
+/*
+** Store the current contents of the p->nTotalRow and p->aTotalSize[] 
+** variables in the "averages" record on disk.
+**
+** Return SQLITE_OK if successful, or an SQLite error code if an error
+** occurs.
+*/
+static int fts5StorageSaveTotals(Fts5Storage *p){
+  int nCol = p->pConfig->nCol;
+  int i;
+  Fts5Buffer buf;
+  int rc = SQLITE_OK;
+  memset(&buf, 0, sizeof(buf));
+
+  sqlite3Fts5BufferAppendVarint(&rc, &buf, p->nTotalRow);
+  for(i=0; i<nCol; i++){
+    sqlite3Fts5BufferAppendVarint(&rc, &buf, p->aTotalSize[i]);
+  }
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5IndexSetAverages(p->pIndex, buf.p, buf.n);
+  }
+  sqlite3_free(buf.p);
+
+  return rc;
+}
+
+/*
+** Remove a row from the FTS table.
+*/
+static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64 iDel){
+  Fts5Config *pConfig = p->pConfig;
+  int rc;
+  sqlite3_stmt *pDel = 0;
+
+  rc = fts5StorageLoadTotals(p, 1);
+
+  /* Delete the index records */
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageDeleteFromIndex(p, iDel);
+  }
+
+  /* Delete the %_docsize record */
+  if( rc==SQLITE_OK && pConfig->bColumnsize ){
+    rc = fts5StorageGetStmt(p, FTS5_STMT_DELETE_DOCSIZE, &pDel, 0);
+    if( rc==SQLITE_OK ){
+      sqlite3_bind_int64(pDel, 1, iDel);
+      sqlite3_step(pDel);
+      rc = sqlite3_reset(pDel);
+    }
+  }
+
+  /* Delete the %_content record */
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageGetStmt(p, FTS5_STMT_DELETE_CONTENT, &pDel, 0);
+  }
+  if( rc==SQLITE_OK ){
+    sqlite3_bind_int64(pDel, 1, iDel);
+    sqlite3_step(pDel);
+    rc = sqlite3_reset(pDel);
+  }
+
+  /* Write the averages record */
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageSaveTotals(p);
+  }
+
+  return rc;
+}
+
+static int sqlite3Fts5StorageSpecialDelete(
+  Fts5Storage *p, 
+  i64 iDel, 
+  sqlite3_value **apVal
+){
+  Fts5Config *pConfig = p->pConfig;
+  int rc;
+  sqlite3_stmt *pDel = 0;
+
+  assert( pConfig->eContent!=FTS5_CONTENT_NORMAL );
+  rc = fts5StorageLoadTotals(p, 1);
+
+  /* Delete the index records */
+  if( rc==SQLITE_OK ){
+    int iCol;
+    Fts5InsertCtx ctx;
+    ctx.pStorage = p;
+    ctx.iCol = -1;
+
+    rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 1, iDel);
+    for(iCol=0; rc==SQLITE_OK && iCol<pConfig->nCol; iCol++){
+      if( pConfig->abUnindexed[iCol] ) continue;
+      ctx.szCol = 0;
+      rc = sqlite3Fts5Tokenize(pConfig, 
+        FTS5_TOKENIZE_DOCUMENT,
+        (const char*)sqlite3_value_text(apVal[iCol]),
+        sqlite3_value_bytes(apVal[iCol]),
+        (void*)&ctx,
+        fts5StorageInsertCallback
+      );
+      p->aTotalSize[iCol] -= (i64)ctx.szCol;
+    }
+    p->nTotalRow--;
+  }
+
+  /* Delete the %_docsize record */
+  if( pConfig->bColumnsize ){
+    if( rc==SQLITE_OK ){
+      rc = fts5StorageGetStmt(p, FTS5_STMT_DELETE_DOCSIZE, &pDel, 0);
+    }
+    if( rc==SQLITE_OK ){
+      sqlite3_bind_int64(pDel, 1, iDel);
+      sqlite3_step(pDel);
+      rc = sqlite3_reset(pDel);
+    }
+  }
+
+  /* Write the averages record */
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageSaveTotals(p);
+  }
+
+  return rc;
+}
+
+/*
+** Delete all entries in the FTS5 index.
+*/
+static int sqlite3Fts5StorageDeleteAll(Fts5Storage *p){
+  Fts5Config *pConfig = p->pConfig;
+  int rc;
+
+  /* Delete the contents of the %_data and %_docsize tables. */
+  rc = fts5ExecPrintf(pConfig->db, 0,
+      "DELETE FROM %Q.'%q_data';" 
+      "DELETE FROM %Q.'%q_idx';",
+      pConfig->zDb, pConfig->zName,
+      pConfig->zDb, pConfig->zName
+  );
+  if( rc==SQLITE_OK && pConfig->bColumnsize ){
+    rc = fts5ExecPrintf(pConfig->db, 0,
+        "DELETE FROM %Q.'%q_docsize';",
+        pConfig->zDb, pConfig->zName
+    );
+  }
+
+  /* Reinitialize the %_data table. This call creates the initial structure
+  ** and averages records.  */
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5IndexReinit(p->pIndex);
+  }
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5StorageConfigValue(p, "version", 0, FTS5_CURRENT_VERSION);
+  }
+  return rc;
+}
+
+static int sqlite3Fts5StorageRebuild(Fts5Storage *p){
+  Fts5Buffer buf = {0,0,0};
+  Fts5Config *pConfig = p->pConfig;
+  sqlite3_stmt *pScan = 0;
+  Fts5InsertCtx ctx;
+  int rc;
+
+  memset(&ctx, 0, sizeof(Fts5InsertCtx));
+  ctx.pStorage = p;
+  rc = sqlite3Fts5StorageDeleteAll(p);
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageLoadTotals(p, 1);
+  }
+
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);
+  }
+
+  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pScan) ){
+    i64 iRowid = sqlite3_column_int64(pScan, 0);
+
+    sqlite3Fts5BufferZero(&buf);
+    rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 0, iRowid);
+    for(ctx.iCol=0; rc==SQLITE_OK && ctx.iCol<pConfig->nCol; ctx.iCol++){
+      ctx.szCol = 0;
+      if( pConfig->abUnindexed[ctx.iCol]==0 ){
+        rc = sqlite3Fts5Tokenize(pConfig, 
+            FTS5_TOKENIZE_DOCUMENT,
+            (const char*)sqlite3_column_text(pScan, ctx.iCol+1),
+            sqlite3_column_bytes(pScan, ctx.iCol+1),
+            (void*)&ctx,
+            fts5StorageInsertCallback
+        );
+      }
+      sqlite3Fts5BufferAppendVarint(&rc, &buf, ctx.szCol);
+      p->aTotalSize[ctx.iCol] += (i64)ctx.szCol;
+    }
+    p->nTotalRow++;
+
+    if( rc==SQLITE_OK ){
+      rc = fts5StorageInsertDocsize(p, iRowid, &buf);
+    }
+  }
+  sqlite3_free(buf.p);
+
+  /* Write the averages record */
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageSaveTotals(p);
+  }
+  return rc;
+}
+
+static int sqlite3Fts5StorageOptimize(Fts5Storage *p){
+  return sqlite3Fts5IndexOptimize(p->pIndex);
+}
+
+static int sqlite3Fts5StorageMerge(Fts5Storage *p, int nMerge){
+  return sqlite3Fts5IndexMerge(p->pIndex, nMerge);
+}
+
+/*
+** Allocate a new rowid. This is used for "external content" tables when
+** a NULL value is inserted into the rowid column. The new rowid is allocated
+** by inserting a dummy row into the %_docsize table. The dummy will be
+** overwritten later.
+**
+** If the %_docsize table does not exist, SQLITE_MISMATCH is returned. In
+** this case the user is required to provide a rowid explicitly.
+*/
+static int fts5StorageNewRowid(Fts5Storage *p, i64 *piRowid){
+  int rc = SQLITE_MISMATCH;
+  if( p->pConfig->bColumnsize ){
+    sqlite3_stmt *pReplace = 0;
+    rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_DOCSIZE, &pReplace, 0);
+    if( rc==SQLITE_OK ){
+      sqlite3_bind_null(pReplace, 1);
+      sqlite3_bind_null(pReplace, 2);
+      sqlite3_step(pReplace);
+      rc = sqlite3_reset(pReplace);
+    }
+    if( rc==SQLITE_OK ){
+      *piRowid = sqlite3_last_insert_rowid(p->pConfig->db);
+    }
+  }
+  return rc;
+}
+
+/*
+** Insert a new row into the FTS content table.
+*/
+static int sqlite3Fts5StorageContentInsert(
+  Fts5Storage *p, 
+  sqlite3_value **apVal, 
+  i64 *piRowid
+){
+  Fts5Config *pConfig = p->pConfig;
+  int rc = SQLITE_OK;
+
+  /* Insert the new row into the %_content table. */
+  if( pConfig->eContent!=FTS5_CONTENT_NORMAL ){
+    if( sqlite3_value_type(apVal[1])==SQLITE_INTEGER ){
+      *piRowid = sqlite3_value_int64(apVal[1]);
+    }else{
+      rc = fts5StorageNewRowid(p, piRowid);
+    }
+  }else{
+    sqlite3_stmt *pInsert = 0;    /* Statement to write %_content table */
+    int i;                        /* Counter variable */
+#if 0
+    if( eConflict==SQLITE_REPLACE ){
+      eStmt = FTS5_STMT_REPLACE_CONTENT;
+      rc = fts5StorageDeleteFromIndex(p, sqlite3_value_int64(apVal[1]));
+    }else{
+      eStmt = FTS5_STMT_INSERT_CONTENT;
+    }
+#endif
+    if( rc==SQLITE_OK ){
+      rc = fts5StorageGetStmt(p, FTS5_STMT_INSERT_CONTENT, &pInsert, 0);
+    }
+    for(i=1; rc==SQLITE_OK && i<=pConfig->nCol+1; i++){
+      rc = sqlite3_bind_value(pInsert, i, apVal[i]);
+    }
+    if( rc==SQLITE_OK ){
+      sqlite3_step(pInsert);
+      rc = sqlite3_reset(pInsert);
+    }
+    *piRowid = sqlite3_last_insert_rowid(pConfig->db);
+  }
+
+  return rc;
+}
+
+/*
+** Insert new entries into the FTS index and %_docsize table.
+*/
+static int sqlite3Fts5StorageIndexInsert(
+  Fts5Storage *p, 
+  sqlite3_value **apVal, 
+  i64 iRowid
+){
+  Fts5Config *pConfig = p->pConfig;
+  int rc = SQLITE_OK;             /* Return code */
+  Fts5InsertCtx ctx;              /* Tokenization callback context object */
+  Fts5Buffer buf;                 /* Buffer used to build up %_docsize blob */
+
+  memset(&buf, 0, sizeof(Fts5Buffer));
+  ctx.pStorage = p;
+  rc = fts5StorageLoadTotals(p, 1);
+
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 0, iRowid);
+  }
+  for(ctx.iCol=0; rc==SQLITE_OK && ctx.iCol<pConfig->nCol; ctx.iCol++){
+    ctx.szCol = 0;
+    if( pConfig->abUnindexed[ctx.iCol]==0 ){
+      rc = sqlite3Fts5Tokenize(pConfig, 
+          FTS5_TOKENIZE_DOCUMENT,
+          (const char*)sqlite3_value_text(apVal[ctx.iCol+2]),
+          sqlite3_value_bytes(apVal[ctx.iCol+2]),
+          (void*)&ctx,
+          fts5StorageInsertCallback
+      );
+    }
+    sqlite3Fts5BufferAppendVarint(&rc, &buf, ctx.szCol);
+    p->aTotalSize[ctx.iCol] += (i64)ctx.szCol;
+  }
+  p->nTotalRow++;
+
+  /* Write the %_docsize record */
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageInsertDocsize(p, iRowid, &buf);
+  }
+  sqlite3_free(buf.p);
+
+  /* Write the averages record */
+  if( rc==SQLITE_OK ){
+    rc = fts5StorageSaveTotals(p);
+  }
+
+  return rc;
+}
+
+static int fts5StorageCount(Fts5Storage *p, const char *zSuffix, i64 *pnRow){
+  Fts5Config *pConfig = p->pConfig;
+  char *zSql;
+  int rc;
+
+  zSql = sqlite3_mprintf("SELECT count(*) FROM %Q.'%q_%s'", 
+      pConfig->zDb, pConfig->zName, zSuffix
+  );
+  if( zSql==0 ){
+    rc = SQLITE_NOMEM;
+  }else{
+    sqlite3_stmt *pCnt = 0;
+    rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pCnt, 0);
+    if( rc==SQLITE_OK ){
+      if( SQLITE_ROW==sqlite3_step(pCnt) ){
+        *pnRow = sqlite3_column_int64(pCnt, 0);
+      }
+      rc = sqlite3_finalize(pCnt);
+    }
+  }
+
+  sqlite3_free(zSql);
+  return rc;
+}
+
+/*
+** Context object used by sqlite3Fts5StorageIntegrity().
+*/
+typedef struct Fts5IntegrityCtx Fts5IntegrityCtx;
+struct Fts5IntegrityCtx {
+  i64 iRowid;
+  int iCol;
+  int szCol;
+  u64 cksum;
+  Fts5Config *pConfig;
+};
+
+/*
+** Tokenization callback used by integrity check.
+*/
+static int fts5StorageIntegrityCallback(
+  void *pContext,                 /* Pointer to Fts5InsertCtx object */
+  int tflags,
+  const char *pToken,             /* Buffer containing token */
+  int nToken,                     /* Size of token in bytes */
+  int iStart,                     /* Start offset of token */
+  int iEnd                        /* End offset of token */
+){
+  Fts5IntegrityCtx *pCtx = (Fts5IntegrityCtx*)pContext;
+  if( (tflags & FTS5_TOKEN_COLOCATED)==0 || pCtx->szCol==0 ){
+    pCtx->szCol++;
+  }
+  pCtx->cksum ^= sqlite3Fts5IndexCksum(
+      pCtx->pConfig, pCtx->iRowid, pCtx->iCol, pCtx->szCol-1, pToken, nToken
+  );
+  return SQLITE_OK;
+}
+
+/*
+** Check that the contents of the FTS index match that of the %_content
+** table. Return SQLITE_OK if they do, or SQLITE_CORRUPT if not. Return
+** some other SQLite error code if an error occurs while attempting to
+** determine this.
+*/
+static int sqlite3Fts5StorageIntegrity(Fts5Storage *p){
+  Fts5Config *pConfig = p->pConfig;
+  int rc;                         /* Return code */
+  int *aColSize;                  /* Array of size pConfig->nCol */
+  i64 *aTotalSize;                /* Array of size pConfig->nCol */
+  Fts5IntegrityCtx ctx;
+  sqlite3_stmt *pScan;
+
+  memset(&ctx, 0, sizeof(Fts5IntegrityCtx));
+  ctx.pConfig = p->pConfig;
+  aTotalSize = (i64*)sqlite3_malloc(pConfig->nCol * (sizeof(int)+sizeof(i64)));
+  if( !aTotalSize ) return SQLITE_NOMEM;
+  aColSize = (int*)&aTotalSize[pConfig->nCol];
+  memset(aTotalSize, 0, sizeof(i64) * pConfig->nCol);
+
+  /* Generate the expected index checksum based on the contents of the
+  ** %_content table. This block stores the checksum in ctx.cksum. */
+  rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);
+  if( rc==SQLITE_OK ){
+    int rc2;
+    while( SQLITE_ROW==sqlite3_step(pScan) ){
+      int i;
+      ctx.iRowid = sqlite3_column_int64(pScan, 0);
+      ctx.szCol = 0;
+      if( pConfig->bColumnsize ){
+        rc = sqlite3Fts5StorageDocsize(p, ctx.iRowid, aColSize);
+      }
+      for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){
+        if( pConfig->abUnindexed[i] ) continue;
+        ctx.iCol = i;
+        ctx.szCol = 0;
+        rc = sqlite3Fts5Tokenize(pConfig, 
+            FTS5_TOKENIZE_DOCUMENT,
+            (const char*)sqlite3_column_text(pScan, i+1),
+            sqlite3_column_bytes(pScan, i+1),
+            (void*)&ctx,
+            fts5StorageIntegrityCallback
+        );
+        if( pConfig->bColumnsize && ctx.szCol!=aColSize[i] ){
+          rc = FTS5_CORRUPT;
+        }
+        aTotalSize[i] += ctx.szCol;
+      }
+      if( rc!=SQLITE_OK ) break;
+    }
+    rc2 = sqlite3_reset(pScan);
+    if( rc==SQLITE_OK ) rc = rc2;
+  }
+
+  /* Test that the "totals" (sometimes called "averages") record looks Ok */
+  if( rc==SQLITE_OK ){
+    int i;
+    rc = fts5StorageLoadTotals(p, 0);
+    for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){
+      if( p->aTotalSize[i]!=aTotalSize[i] ) rc = FTS5_CORRUPT;
+    }
+  }
+
+  /* Check that the %_docsize and %_content tables contain the expected
+  ** number of rows.  */
+  if( rc==SQLITE_OK && pConfig->eContent==FTS5_CONTENT_NORMAL ){
+    i64 nRow;
+    rc = fts5StorageCount(p, "content", &nRow);
+    if( rc==SQLITE_OK && nRow!=p->nTotalRow ) rc = FTS5_CORRUPT;
+  }
+  if( rc==SQLITE_OK && pConfig->bColumnsize ){
+    i64 nRow;
+    rc = fts5StorageCount(p, "docsize", &nRow);
+    if( rc==SQLITE_OK && nRow!=p->nTotalRow ) rc = FTS5_CORRUPT;
+  }
+
+  /* Pass the expected checksum down to the FTS index module. It will
+  ** verify, amongst other things, that it matches the checksum generated by
+  ** inspecting the index itself.  */
+  if( rc==SQLITE_OK ){
+    rc = sqlite3Fts5IndexIntegrityCheck(p->pIndex, ctx.cksum);
+  }
+
+  sqlite3_free(aTotalSize);
+  return rc;
+}
+
+/*
+** Obtain an SQLite statement handle that may be used to read data from the
+** %_content table.
+*/
+static int sqlite3Fts5StorageStmt(
+  Fts5Storage *p, 
+  int eStmt, 
+  sqlite3_stmt **pp, 
+  char **pzErrMsg
+){
+  int rc;
+  assert( eStmt==FTS5_STMT_SCAN_ASC 
+       || eStmt==FTS5_STMT_SCAN_DESC
+       || eStmt==FTS5_STMT_LOOKUP
+  );
+  rc = fts5StorageGetStmt(p, eStmt, pp, pzErrMsg);
+  if( rc==SQLITE_OK ){
+    assert( p->aStmt[eStmt]==*pp );
+    p->aStmt[eStmt] = 0;
+  }
+  return rc;
+}
+
+/*
+** Release an SQLite statement handle obtained via an earlier call to
+** sqlite3Fts5StorageStmt(). The eStmt parameter passed to this function
+** must match that passed to the sqlite3Fts5StorageStmt() call.
+*/
+static void sqlite3Fts5StorageStmtRelease(
+  Fts5Storage *p, 
+  int eStmt, 
+  sqlite3_stmt *pStmt
+){
+  assert( eStmt==FTS5_STMT_SCAN_ASC
+       || eStmt==FTS5_STMT_SCAN_DESC
+       || eStmt==FTS5_STMT_LOOKUP
+  );
+  if( p->aStmt[eStmt]==0 ){
+    sqlite3_reset(pStmt);
+    p->aStmt[eStmt] = pStmt;
+  }else{
+    sqlite3_finalize(pStmt);
+  }
+}
+
+static int fts5StorageDecodeSizeArray(
+  int *aCol, int nCol,            /* Array to populate */
+  const u8 *aBlob, int nBlob      /* Record to read varints from */
+){
+  int i;
+  int iOff = 0;
+  for(i=0; i<nCol; i++){
+    if( iOff>=nBlob ) return 1;
+    iOff += fts5GetVarint32(&aBlob[iOff], aCol[i]);
+  }
+  return (iOff!=nBlob);
+}
+
+/*
+** Argument aCol points to an array of integers containing one entry for
+** each table column. This function reads the %_docsize record for the
+** specified rowid and populates aCol[] with the results.
+**
+** An SQLite error code is returned if an error occurs, or SQLITE_OK
+** otherwise.
+*/
+static int sqlite3Fts5StorageDocsize(Fts5Storage *p, i64 iRowid, int *aCol){
+  int nCol = p->pConfig->nCol;    /* Number of user columns in table */
+  sqlite3_stmt *pLookup = 0;      /* Statement to query %_docsize */
+  int rc;                         /* Return Code */
+
+  assert( p->pConfig->bColumnsize );
+  rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP_DOCSIZE, &pLookup, 0);
+  if( rc==SQLITE_OK ){
+    int bCorrupt = 1;
+    sqlite3_bind_int64(pLookup, 1, iRowid);
+    if( SQLITE_ROW==sqlite3_step(pLookup) ){
+      const u8 *aBlob = sqlite3_column_blob(pLookup, 0);
+      int nBlob = sqlite3_column_bytes(pLookup, 0);
+      if( 0==fts5StorageDecodeSizeArray(aCol, nCol, aBlob, nBlob) ){
+        bCorrupt = 0;
+      }
+    }
+    rc = sqlite3_reset(pLookup);
+    if( bCorrupt && rc==SQLITE_OK ){
+      rc = FTS5_CORRUPT;
+    }
+  }
+
+  return rc;
+}
+
+static int sqlite3Fts5StorageSize(Fts5Storage *p, int iCol, i64 *pnToken){
+  int rc = fts5StorageLoadTotals(p, 0);
+  if( rc==SQLITE_OK ){
+    *pnToken = 0;
+    if( iCol<0 ){
+      int i;
+      for(i=0; i<p->pConfig->nCol; i++){
+        *pnToken += p->aTotalSize[i];
+      }
+    }else if( iCol<p->pConfig->nCol ){
+      *pnToken = p->aTotalSize[iCol];
+    }else{
+      rc = SQLITE_RANGE;
+    }
+  }
+  return rc;
+}
+
+static int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow){
+  int rc = fts5StorageLoadTotals(p, 0);
+  if( rc==SQLITE_OK ){
+    *pnRow = p->nTotalRow;
+  }
+  return rc;
+}
+
+/*
+** Flush any data currently held in-memory to disk.
+*/
+static int sqlite3Fts5StorageSync(Fts5Storage *p, int bCommit){
+  if( bCommit && p->bTotalsValid ){
+    int rc = fts5StorageSaveTotals(p);
+    p->bTotalsValid = 0;
+    if( rc!=SQLITE_OK ) return rc;
+  }
+  return sqlite3Fts5IndexSync(p->pIndex, bCommit);
+}
+
+static int sqlite3Fts5StorageRollback(Fts5Storage *p){
+  p->bTotalsValid = 0;
+  return sqlite3Fts5IndexRollback(p->pIndex);
+}
+
+static int sqlite3Fts5StorageConfigValue(
+  Fts5Storage *p, 
+  const char *z,
+  sqlite3_value *pVal,
+  int iVal
+){
+  sqlite3_stmt *pReplace = 0;
+  int rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_CONFIG, &pReplace, 0);
+  if( rc==SQLITE_OK ){
+    sqlite3_bind_text(pReplace, 1, z, -1, SQLITE_STATIC);
+    if( pVal ){
+      sqlite3_bind_value(pReplace, 2, pVal);
+    }else{
+      sqlite3_bind_int(pReplace, 2, iVal);
+    }
+    sqlite3_step(pReplace);
+    rc = sqlite3_reset(pReplace);
+  }
+  if( rc==SQLITE_OK && pVal ){
+    int iNew = p->pConfig->iCookie + 1;
+    rc = sqlite3Fts5IndexSetCookie(p->pIndex, iNew);
+    if( rc==SQLITE_OK ){
+      p->pConfig->iCookie = iNew;
+    }
+  }
+  return rc;
+}
+
+
+
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+*/
+
+
+
+/**************************************************************************
+** Start of ascii tokenizer implementation.
+*/
+
+/*
+** For tokenizers with no "unicode" modifier, the set of token characters
+** is the same as the set of ASCII range alphanumeric characters. 
+*/
+static unsigned char aAsciiTokenChar[128] = {
+  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   /* 0x00..0x0F */
+  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   /* 0x10..0x1F */
+  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,   /* 0x20..0x2F */
+  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 0, 0, 0, 0, 0, 0,   /* 0x30..0x3F */
+  0, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   /* 0x40..0x4F */
+  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 0, 0, 0, 0, 0,   /* 0x50..0x5F */
+  0, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   /* 0x60..0x6F */
+  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 0, 0, 0, 0, 0,   /* 0x70..0x7F */
+};
+
+typedef struct AsciiTokenizer AsciiTokenizer;
+struct AsciiTokenizer {
+  unsigned char aTokenChar[128];
+};
+
+static void fts5AsciiAddExceptions(
+  AsciiTokenizer *p, 
+  const char *zArg, 
+  int bTokenChars
+){
+  int i;
+  for(i=0; zArg[i]; i++){
+    if( (zArg[i] & 0x80)==0 ){
+      p->aTokenChar[(int)zArg[i]] = (unsigned char)bTokenChars;
+    }
+  }
+}
+
+/*
+** Delete a "ascii" tokenizer.
+*/
+static void fts5AsciiDelete(Fts5Tokenizer *p){
+  sqlite3_free(p);
+}
+
+/*
+** Create an "ascii" tokenizer.
+*/
+static int fts5AsciiCreate(
+  void *pCtx, 
+  const char **azArg, int nArg,
+  Fts5Tokenizer **ppOut
+){
+  int rc = SQLITE_OK;
+  AsciiTokenizer *p = 0;
+  if( nArg%2 ){
+    rc = SQLITE_ERROR;
+  }else{
+    p = sqlite3_malloc(sizeof(AsciiTokenizer));
+    if( p==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      int i;
+      memset(p, 0, sizeof(AsciiTokenizer));
+      memcpy(p->aTokenChar, aAsciiTokenChar, sizeof(aAsciiTokenChar));
+      for(i=0; rc==SQLITE_OK && i<nArg; i+=2){
+        const char *zArg = azArg[i+1];
+        if( 0==sqlite3_stricmp(azArg[i], "tokenchars") ){
+          fts5AsciiAddExceptions(p, zArg, 1);
+        }else
+        if( 0==sqlite3_stricmp(azArg[i], "separators") ){
+          fts5AsciiAddExceptions(p, zArg, 0);
+        }else{
+          rc = SQLITE_ERROR;
+        }
+      }
+      if( rc!=SQLITE_OK ){
+        fts5AsciiDelete((Fts5Tokenizer*)p);
+        p = 0;
+      }
+    }
+  }
+
+  *ppOut = (Fts5Tokenizer*)p;
+  return rc;
+}
+
+
+static void asciiFold(char *aOut, const char *aIn, int nByte){
+  int i;
+  for(i=0; i<nByte; i++){
+    char c = aIn[i];
+    if( c>='A' && c<='Z' ) c += 32;
+    aOut[i] = c;
+  }
+}
+
+/*
+** Tokenize some text using the ascii tokenizer.
+*/
+static int fts5AsciiTokenize(
+  Fts5Tokenizer *pTokenizer,
+  void *pCtx,
+  int flags,
+  const char *pText, int nText,
+  int (*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd)
+){
+  AsciiTokenizer *p = (AsciiTokenizer*)pTokenizer;
+  int rc = SQLITE_OK;
+  int ie;
+  int is = 0;
+
+  char aFold[64];
+  int nFold = sizeof(aFold);
+  char *pFold = aFold;
+  unsigned char *a = p->aTokenChar;
+
+  while( is<nText && rc==SQLITE_OK ){
+    int nByte;
+
+    /* Skip any leading divider characters. */
+    while( is<nText && ((pText[is]&0x80)==0 && a[(int)pText[is]]==0) ){
+      is++;
+    }
+    if( is==nText ) break;
+
+    /* Count the token characters */
+    ie = is+1;
+    while( ie<nText && ((pText[ie]&0x80) || a[(int)pText[ie]] ) ){
+      ie++;
+    }
+
+    /* Fold to lower case */
+    nByte = ie-is;
+    if( nByte>nFold ){
+      if( pFold!=aFold ) sqlite3_free(pFold);
+      pFold = sqlite3_malloc(nByte*2);
+      if( pFold==0 ){
+        rc = SQLITE_NOMEM;
+        break;
+      }
+      nFold = nByte*2;
+    }
+    asciiFold(pFold, &pText[is], nByte);
+
+    /* Invoke the token callback */
+    rc = xToken(pCtx, 0, pFold, nByte, is, ie);
+    is = ie+1;
+  }
+  
+  if( pFold!=aFold ) sqlite3_free(pFold);
+  if( rc==SQLITE_DONE ) rc = SQLITE_OK;
+  return rc;
+}
+
+/**************************************************************************
+** Start of unicode61 tokenizer implementation.
+*/
+
+
+/*
+** The following two macros - READ_UTF8 and WRITE_UTF8 - have been copied
+** from the sqlite3 source file utf.c. If this file is compiled as part
+** of the amalgamation, they are not required.
+*/
+#ifndef SQLITE_AMALGAMATION
+
+static const unsigned char sqlite3Utf8Trans1[] = {
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
+};
+
+#define READ_UTF8(zIn, zTerm, c)                           \
+  c = *(zIn++);                                            \
+  if( c>=0xc0 ){                                           \
+    c = sqlite3Utf8Trans1[c-0xc0];                         \
+    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
+      c = (c<<6) + (0x3f & *(zIn++));                      \
+    }                                                      \
+    if( c<0x80                                             \
+        || (c&0xFFFFF800)==0xD800                          \
+        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
+  }
+
+
+#define WRITE_UTF8(zOut, c) {                          \
+  if( c<0x00080 ){                                     \
+    *zOut++ = (unsigned char)(c&0xFF);                 \
+  }                                                    \
+  else if( c<0x00800 ){                                \
+    *zOut++ = 0xC0 + (unsigned char)((c>>6)&0x1F);     \
+    *zOut++ = 0x80 + (unsigned char)(c & 0x3F);        \
+  }                                                    \
+  else if( c<0x10000 ){                                \
+    *zOut++ = 0xE0 + (unsigned char)((c>>12)&0x0F);    \
+    *zOut++ = 0x80 + (unsigned char)((c>>6) & 0x3F);   \
+    *zOut++ = 0x80 + (unsigned char)(c & 0x3F);        \
+  }else{                                               \
+    *zOut++ = 0xF0 + (unsigned char)((c>>18) & 0x07);  \
+    *zOut++ = 0x80 + (unsigned char)((c>>12) & 0x3F);  \
+    *zOut++ = 0x80 + (unsigned char)((c>>6) & 0x3F);   \
+    *zOut++ = 0x80 + (unsigned char)(c & 0x3F);        \
+  }                                                    \
+}
+
+#endif /* ifndef SQLITE_AMALGAMATION */
+
+typedef struct Unicode61Tokenizer Unicode61Tokenizer;
+struct Unicode61Tokenizer {
+  unsigned char aTokenChar[128];  /* ASCII range token characters */
+  char *aFold;                    /* Buffer to fold text into */
+  int nFold;                      /* Size of aFold[] in bytes */
+  int bRemoveDiacritic;           /* True if remove_diacritics=1 is set */
+  int nException;
+  int *aiException;
+};
+
+static int fts5UnicodeAddExceptions(
+  Unicode61Tokenizer *p,          /* Tokenizer object */
+  const char *z,                  /* Characters to treat as exceptions */
+  int bTokenChars                 /* 1 for 'tokenchars', 0 for 'separators' */
+){
+  int rc = SQLITE_OK;
+  int n = strlen(z);
+  int *aNew;
+
+  if( n>0 ){
+    aNew = (int*)sqlite3_realloc(p->aiException, (n+p->nException)*sizeof(int));
+    if( aNew ){
+      int nNew = p->nException;
+      const unsigned char *zCsr = (const unsigned char*)z;
+      const unsigned char *zTerm = (const unsigned char*)&z[n];
+      while( zCsr<zTerm ){
+        int iCode;
+        int bToken;
+        READ_UTF8(zCsr, zTerm, iCode);
+        if( iCode<128 ){
+          p->aTokenChar[iCode] = bTokenChars;
+        }else{
+          bToken = sqlite3Fts5UnicodeIsalnum(iCode);
+          assert( (bToken==0 || bToken==1) ); 
+          assert( (bTokenChars==0 || bTokenChars==1) );
+          if( bToken!=bTokenChars && sqlite3Fts5UnicodeIsdiacritic(iCode)==0 ){
+            int i;
+            for(i=0; i<nNew; i++){
+              if( aNew[i]>iCode ) break;
+            }
+            memmove(&aNew[i+1], &aNew[i], (nNew-i)*sizeof(int));
+            aNew[i] = iCode;
+            nNew++;
+          }
+        }
+      }
+      p->aiException = aNew;
+      p->nException = nNew;
+    }else{
+      rc = SQLITE_NOMEM;
+    }
+  }
+
+  return rc;
+}
+
+/*
+** Return true if the p->aiException[] array contains the value iCode.
+*/
+static int fts5UnicodeIsException(Unicode61Tokenizer *p, int iCode){
+  if( p->nException>0 ){
+    int *a = p->aiException;
+    int iLo = 0;
+    int iHi = p->nException-1;
+
+    while( iHi>=iLo ){
+      int iTest = (iHi + iLo) / 2;
+      if( iCode==a[iTest] ){
+        return 1;
+      }else if( iCode>a[iTest] ){
+        iLo = iTest+1;
+      }else{
+        iHi = iTest-1;
+      }
+    }
+  }
+
+  return 0;
+}
+
+/*
+** Delete a "unicode61" tokenizer.
+*/
+static void fts5UnicodeDelete(Fts5Tokenizer *pTok){
+  if( pTok ){
+    Unicode61Tokenizer *p = (Unicode61Tokenizer*)pTok;
+    sqlite3_free(p->aiException);
+    sqlite3_free(p->aFold);
+    sqlite3_free(p);
+  }
+  return;
+}
+
+/*
+** Create a "unicode61" tokenizer.
+*/
+static int fts5UnicodeCreate(
+  void *pCtx, 
+  const char **azArg, int nArg,
+  Fts5Tokenizer **ppOut
+){
+  int rc = SQLITE_OK;             /* Return code */
+  Unicode61Tokenizer *p = 0;      /* New tokenizer object */ 
+
+  if( nArg%2 ){
+    rc = SQLITE_ERROR;
+  }else{
+    p = (Unicode61Tokenizer*)sqlite3_malloc(sizeof(Unicode61Tokenizer));
+    if( p ){
+      int i;
+      memset(p, 0, sizeof(Unicode61Tokenizer));
+      memcpy(p->aTokenChar, aAsciiTokenChar, sizeof(aAsciiTokenChar));
+      p->bRemoveDiacritic = 1;
+      p->nFold = 64;
+      p->aFold = sqlite3_malloc(p->nFold * sizeof(char));
+      if( p->aFold==0 ){
+        rc = SQLITE_NOMEM;
+      }
+      for(i=0; rc==SQLITE_OK && i<nArg; i+=2){
+        const char *zArg = azArg[i+1];
+        if( 0==sqlite3_stricmp(azArg[i], "remove_diacritics") ){
+          if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1] ){
+            rc = SQLITE_ERROR;
+          }
+          p->bRemoveDiacritic = (zArg[0]=='1');
+        }else
+        if( 0==sqlite3_stricmp(azArg[i], "tokenchars") ){
+          rc = fts5UnicodeAddExceptions(p, zArg, 1);
+        }else
+        if( 0==sqlite3_stricmp(azArg[i], "separators") ){
+          rc = fts5UnicodeAddExceptions(p, zArg, 0);
+        }else{
+          rc = SQLITE_ERROR;
+        }
+      }
+    }else{
+      rc = SQLITE_NOMEM;
+    }
+    if( rc!=SQLITE_OK ){
+      fts5UnicodeDelete((Fts5Tokenizer*)p);
+      p = 0;
+    }
+    *ppOut = (Fts5Tokenizer*)p;
+  }
+  return rc;
+}
+
+/*
+** Return true if, for the purposes of tokenizing with the tokenizer
+** passed as the first argument, codepoint iCode is considered a token 
+** character (not a separator).
+*/
+static int fts5UnicodeIsAlnum(Unicode61Tokenizer *p, int iCode){
+  assert( (sqlite3Fts5UnicodeIsalnum(iCode) & 0xFFFFFFFE)==0 );
+  return sqlite3Fts5UnicodeIsalnum(iCode) ^ fts5UnicodeIsException(p, iCode);
+}
+
+static int fts5UnicodeTokenize(
+  Fts5Tokenizer *pTokenizer,
+  void *pCtx,
+  int flags,
+  const char *pText, int nText,
+  int (*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd)
+){
+  Unicode61Tokenizer *p = (Unicode61Tokenizer*)pTokenizer;
+  int rc = SQLITE_OK;
+  unsigned char *a = p->aTokenChar;
+
+  unsigned char *zTerm = (unsigned char*)&pText[nText];
+  unsigned char *zCsr = (unsigned char *)pText;
+
+  /* Output buffer */
+  char *aFold = p->aFold;
+  int nFold = p->nFold;
+  const char *pEnd = &aFold[nFold-6];
+
+  /* Each iteration of this loop gobbles up a contiguous run of separators,
+  ** then the next token.  */
+  while( rc==SQLITE_OK ){
+    int iCode;                    /* non-ASCII codepoint read from input */
+    char *zOut = aFold;
+    int is;
+    int ie;
+
+    /* Skip any separator characters. */
+    while( 1 ){
+      if( zCsr>=zTerm ) goto tokenize_done;
+      if( *zCsr & 0x80 ) {
+        /* A character outside of the ascii range. Skip past it if it is
+        ** a separator character. Or break out of the loop if it is not. */
+        is = zCsr - (unsigned char*)pText;
+        READ_UTF8(zCsr, zTerm, iCode);
+        if( fts5UnicodeIsAlnum(p, iCode) ){
+          goto non_ascii_tokenchar;
+        }
+      }else{
+        if( a[*zCsr] ){
+          is = zCsr - (unsigned char*)pText;
+          goto ascii_tokenchar;
+        }
+        zCsr++;
+      }
+    }
+
+    /* Run through the tokenchars. Fold them into the output buffer along
+    ** the way.  */
+    while( zCsr<zTerm ){
+
+      /* Grow the output buffer so that there is sufficient space to fit the
+      ** largest possible utf-8 character.  */
+      if( zOut>pEnd ){
+        aFold = sqlite3_malloc(nFold*2);
+        if( aFold==0 ){
+          rc = SQLITE_NOMEM;
+          goto tokenize_done;
+        }
+        zOut = &aFold[zOut - p->aFold];
+        memcpy(aFold, p->aFold, nFold);
+        sqlite3_free(p->aFold);
+        p->aFold = aFold;
+        p->nFold = nFold = nFold*2;
+        pEnd = &aFold[nFold-6];
+      }
+
+      if( *zCsr & 0x80 ){
+        /* An non-ascii-range character. Fold it into the output buffer if
+        ** it is a token character, or break out of the loop if it is not. */
+        READ_UTF8(zCsr, zTerm, iCode);
+        if( fts5UnicodeIsAlnum(p,iCode)||sqlite3Fts5UnicodeIsdiacritic(iCode) ){
+ non_ascii_tokenchar:
+          iCode = sqlite3Fts5UnicodeFold(iCode, p->bRemoveDiacritic);
+          if( iCode ) WRITE_UTF8(zOut, iCode);
+        }else{
+          break;
+        }
+      }else if( a[*zCsr]==0 ){
+        /* An ascii-range separator character. End of token. */
+        break; 
+      }else{
+ ascii_tokenchar:
+        if( *zCsr>='A' && *zCsr<='Z' ){
+          *zOut++ = *zCsr + 32;
+        }else{
+          *zOut++ = *zCsr;
+        }
+        zCsr++;
+      }
+      ie = zCsr - (unsigned char*)pText;
+    }
+
+    /* Invoke the token callback */
+    rc = xToken(pCtx, 0, aFold, zOut-aFold, is, ie); 
+  }
+  
+ tokenize_done:
+  if( rc==SQLITE_DONE ) rc = SQLITE_OK;
+  return rc;
+}
+
+/**************************************************************************
+** Start of porter stemmer implementation.
+*/
+
+/* Any tokens larger than this (in bytes) are passed through without
+** stemming. */
+#define FTS5_PORTER_MAX_TOKEN 64
+
+typedef struct PorterTokenizer PorterTokenizer;
+struct PorterTokenizer {
+  fts5_tokenizer tokenizer;       /* Parent tokenizer module */
+  Fts5Tokenizer *pTokenizer;      /* Parent tokenizer instance */
+  char aBuf[FTS5_PORTER_MAX_TOKEN + 64];
+};
+
+/*
+** Delete a "porter" tokenizer.
+*/
+static void fts5PorterDelete(Fts5Tokenizer *pTok){
+  if( pTok ){
+    PorterTokenizer *p = (PorterTokenizer*)pTok;
+    if( p->pTokenizer ){
+      p->tokenizer.xDelete(p->pTokenizer);
+    }
+    sqlite3_free(p);
+  }
+}
+
+/*
+** Create a "porter" tokenizer.
+*/
+static int fts5PorterCreate(
+  void *pCtx, 
+  const char **azArg, int nArg,
+  Fts5Tokenizer **ppOut
+){
+  fts5_api *pApi = (fts5_api*)pCtx;
+  int rc = SQLITE_OK;
+  PorterTokenizer *pRet;
+  void *pUserdata = 0;
+  const char *zBase = "unicode61";
+
+  if( nArg>0 ){
+    zBase = azArg[0];
+  }
+
+  pRet = (PorterTokenizer*)sqlite3_malloc(sizeof(PorterTokenizer));
+  if( pRet ){
+    memset(pRet, 0, sizeof(PorterTokenizer));
+    rc = pApi->xFindTokenizer(pApi, zBase, &pUserdata, &pRet->tokenizer);
+  }else{
+    rc = SQLITE_NOMEM;
+  }
+  if( rc==SQLITE_OK ){
+    int nArg2 = (nArg>0 ? nArg-1 : 0);
+    const char **azArg2 = (nArg2 ? &azArg[1] : 0);
+    rc = pRet->tokenizer.xCreate(pUserdata, azArg2, nArg2, &pRet->pTokenizer);
+  }
+
+  if( rc!=SQLITE_OK ){
+    fts5PorterDelete((Fts5Tokenizer*)pRet);
+    pRet = 0;
+  }
+  *ppOut = (Fts5Tokenizer*)pRet;
+  return rc;
+}
+
+typedef struct PorterContext PorterContext;
+struct PorterContext {
+  void *pCtx;
+  int (*xToken)(void*, int, const char*, int, int, int);
+  char *aBuf;
+};
+
+typedef struct PorterRule PorterRule;
+struct PorterRule {
+  const char *zSuffix;
+  int nSuffix;
+  int (*xCond)(char *zStem, int nStem);
+  const char *zOutput;
+  int nOutput;
+};
+
+#if 0
+static int fts5PorterApply(char *aBuf, int *pnBuf, PorterRule *aRule){
+  int ret = -1;
+  int nBuf = *pnBuf;
+  PorterRule *p;
+
+  for(p=aRule; p->zSuffix; p++){
+    assert( strlen(p->zSuffix)==p->nSuffix );
+    assert( strlen(p->zOutput)==p->nOutput );
+    if( nBuf<p->nSuffix ) continue;
+    if( 0==memcmp(&aBuf[nBuf - p->nSuffix], p->zSuffix, p->nSuffix) ) break;
+  }
+
+  if( p->zSuffix ){
+    int nStem = nBuf - p->nSuffix;
+    if( p->xCond==0 || p->xCond(aBuf, nStem) ){
+      memcpy(&aBuf[nStem], p->zOutput, p->nOutput);
+      *pnBuf = nStem + p->nOutput;
+      ret = p - aRule;
+    }
+  }
+
+  return ret;
+}
+#endif
+
+static int fts5PorterIsVowel(char c, int bYIsVowel){
+  return (
+      c=='a' || c=='e' || c=='i' || c=='o' || c=='u' || (bYIsVowel && c=='y')
+  );
+}
+
+static int fts5PorterGobbleVC(char *zStem, int nStem, int bPrevCons){
+  int i;
+  int bCons = bPrevCons;
+
+  /* Scan for a vowel */
+  for(i=0; i<nStem; i++){
+    if( 0==(bCons = !fts5PorterIsVowel(zStem[i], bCons)) ) break;
+  }
+
+  /* Scan for a consonent */
+  for(i++; i<nStem; i++){
+    if( (bCons = !fts5PorterIsVowel(zStem[i], bCons)) ) return i+1;
+  }
+  return 0;
+}
+
+/* porter rule condition: (m > 0) */
+static int fts5Porter_MGt0(char *zStem, int nStem){
+  return !!fts5PorterGobbleVC(zStem, nStem, 0);
+}
+
+/* porter rule condition: (m > 1) */
+static int fts5Porter_MGt1(char *zStem, int nStem){
+  int n;
+  n = fts5PorterGobbleVC(zStem, nStem, 0);
+  if( n && fts5PorterGobbleVC(&zStem[n], nStem-n, 1) ){
+    return 1;
+  }
+  return 0;
+}
+
+/* porter rule condition: (m = 1) */
+static int fts5Porter_MEq1(char *zStem, int nStem){
+  int n;
+  n = fts5PorterGobbleVC(zStem, nStem, 0);
+  if( n && 0==fts5PorterGobbleVC(&zStem[n], nStem-n, 1) ){
+    return 1;
+  }
+  return 0;
+}
+
+/* porter rule condition: (*o) */
+static int fts5Porter_Ostar(char *zStem, int nStem){
+  if( zStem[nStem-1]=='w' || zStem[nStem-1]=='x' || zStem[nStem-1]=='y' ){
+    return 0;
+  }else{
+    int i;
+    int mask = 0;
+    int bCons = 0;
+    for(i=0; i<nStem; i++){
+      bCons = !fts5PorterIsVowel(zStem[i], bCons);
+      assert( bCons==0 || bCons==1 );
+      mask = (mask << 1) + bCons;
+    }
+    return ((mask & 0x0007)==0x0005);
+  }
+}
+
+/* porter rule condition: (m > 1 and (*S or *T)) */
+static int fts5Porter_MGt1_and_S_or_T(char *zStem, int nStem){
+  assert( nStem>0 );
+  return (zStem[nStem-1]=='s' || zStem[nStem-1]=='t') 
+      && fts5Porter_MGt1(zStem, nStem);
+}
+
+/* porter rule condition: (*v*) */
+static int fts5Porter_Vowel(char *zStem, int nStem){
+  int i;
+  for(i=0; i<nStem; i++){
+    if( fts5PorterIsVowel(zStem[i], i>0) ){
+      return 1;
+    }
+  }
+  return 0;
+}
+
+
+/**************************************************************************
+***************************************************************************
+** GENERATED CODE STARTS HERE (mkportersteps.tcl)
+*/
+
+static int fts5PorterStep4(char *aBuf, int *pnBuf){
+  int ret = 0;
+  int nBuf = *pnBuf;
+  switch( aBuf[nBuf-2] ){
+    
+    case 'a': 
+      if( nBuf>2 && 0==memcmp("al", &aBuf[nBuf-2], 2) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-2) ){
+          *pnBuf = nBuf - 2;
+        }
+      }
+      break;
+  
+    case 'c': 
+      if( nBuf>4 && 0==memcmp("ance", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-4) ){
+          *pnBuf = nBuf - 4;
+        }
+      }else if( nBuf>4 && 0==memcmp("ence", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-4) ){
+          *pnBuf = nBuf - 4;
+        }
+      }
+      break;
+  
+    case 'e': 
+      if( nBuf>2 && 0==memcmp("er", &aBuf[nBuf-2], 2) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-2) ){
+          *pnBuf = nBuf - 2;
+        }
+      }
+      break;
+  
+    case 'i': 
+      if( nBuf>2 && 0==memcmp("ic", &aBuf[nBuf-2], 2) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-2) ){
+          *pnBuf = nBuf - 2;
+        }
+      }
+      break;
+  
+    case 'l': 
+      if( nBuf>4 && 0==memcmp("able", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-4) ){
+          *pnBuf = nBuf - 4;
+        }
+      }else if( nBuf>4 && 0==memcmp("ible", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-4) ){
+          *pnBuf = nBuf - 4;
+        }
+      }
+      break;
+  
+    case 'n': 
+      if( nBuf>3 && 0==memcmp("ant", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }else if( nBuf>5 && 0==memcmp("ement", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-5) ){
+          *pnBuf = nBuf - 5;
+        }
+      }else if( nBuf>4 && 0==memcmp("ment", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-4) ){
+          *pnBuf = nBuf - 4;
+        }
+      }else if( nBuf>3 && 0==memcmp("ent", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }
+      break;
+  
+    case 'o': 
+      if( nBuf>3 && 0==memcmp("ion", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1_and_S_or_T(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }else if( nBuf>2 && 0==memcmp("ou", &aBuf[nBuf-2], 2) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-2) ){
+          *pnBuf = nBuf - 2;
+        }
+      }
+      break;
+  
+    case 's': 
+      if( nBuf>3 && 0==memcmp("ism", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }
+      break;
+  
+    case 't': 
+      if( nBuf>3 && 0==memcmp("ate", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }else if( nBuf>3 && 0==memcmp("iti", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }
+      break;
+  
+    case 'u': 
+      if( nBuf>3 && 0==memcmp("ous", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }
+      break;
+  
+    case 'v': 
+      if( nBuf>3 && 0==memcmp("ive", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }
+      break;
+  
+    case 'z': 
+      if( nBuf>3 && 0==memcmp("ize", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt1(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }
+      break;
+  
+  }
+  return ret;
+}
+  
+
+static int fts5PorterStep1B2(char *aBuf, int *pnBuf){
+  int ret = 0;
+  int nBuf = *pnBuf;
+  switch( aBuf[nBuf-2] ){
+    
+    case 'a': 
+      if( nBuf>2 && 0==memcmp("at", &aBuf[nBuf-2], 2) ){
+        memcpy(&aBuf[nBuf-2], "ate", 3);
+        *pnBuf = nBuf - 2 + 3;
+        ret = 1;
+      }
+      break;
+  
+    case 'b': 
+      if( nBuf>2 && 0==memcmp("bl", &aBuf[nBuf-2], 2) ){
+        memcpy(&aBuf[nBuf-2], "ble", 3);
+        *pnBuf = nBuf - 2 + 3;
+        ret = 1;
+      }
+      break;
+  
+    case 'i': 
+      if( nBuf>2 && 0==memcmp("iz", &aBuf[nBuf-2], 2) ){
+        memcpy(&aBuf[nBuf-2], "ize", 3);
+        *pnBuf = nBuf - 2 + 3;
+        ret = 1;
+      }
+      break;
+  
+  }
+  return ret;
+}
+  
+
+static int fts5PorterStep2(char *aBuf, int *pnBuf){
+  int ret = 0;
+  int nBuf = *pnBuf;
+  switch( aBuf[nBuf-2] ){
+    
+    case 'a': 
+      if( nBuf>7 && 0==memcmp("ational", &aBuf[nBuf-7], 7) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-7) ){
+          memcpy(&aBuf[nBuf-7], "ate", 3);
+          *pnBuf = nBuf - 7 + 3;
+        }
+      }else if( nBuf>6 && 0==memcmp("tional", &aBuf[nBuf-6], 6) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-6) ){
+          memcpy(&aBuf[nBuf-6], "tion", 4);
+          *pnBuf = nBuf - 6 + 4;
+        }
+      }
+      break;
+  
+    case 'c': 
+      if( nBuf>4 && 0==memcmp("enci", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-4) ){
+          memcpy(&aBuf[nBuf-4], "ence", 4);
+          *pnBuf = nBuf - 4 + 4;
+        }
+      }else if( nBuf>4 && 0==memcmp("anci", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-4) ){
+          memcpy(&aBuf[nBuf-4], "ance", 4);
+          *pnBuf = nBuf - 4 + 4;
+        }
+      }
+      break;
+  
+    case 'e': 
+      if( nBuf>4 && 0==memcmp("izer", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-4) ){
+          memcpy(&aBuf[nBuf-4], "ize", 3);
+          *pnBuf = nBuf - 4 + 3;
+        }
+      }
+      break;
+  
+    case 'g': 
+      if( nBuf>4 && 0==memcmp("logi", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-4) ){
+          memcpy(&aBuf[nBuf-4], "log", 3);
+          *pnBuf = nBuf - 4 + 3;
+        }
+      }
+      break;
+  
+    case 'l': 
+      if( nBuf>3 && 0==memcmp("bli", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-3) ){
+          memcpy(&aBuf[nBuf-3], "ble", 3);
+          *pnBuf = nBuf - 3 + 3;
+        }
+      }else if( nBuf>4 && 0==memcmp("alli", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-4) ){
+          memcpy(&aBuf[nBuf-4], "al", 2);
+          *pnBuf = nBuf - 4 + 2;
+        }
+      }else if( nBuf>5 && 0==memcmp("entli", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "ent", 3);
+          *pnBuf = nBuf - 5 + 3;
+        }
+      }else if( nBuf>3 && 0==memcmp("eli", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-3) ){
+          memcpy(&aBuf[nBuf-3], "e", 1);
+          *pnBuf = nBuf - 3 + 1;
+        }
+      }else if( nBuf>5 && 0==memcmp("ousli", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "ous", 3);
+          *pnBuf = nBuf - 5 + 3;
+        }
+      }
+      break;
+  
+    case 'o': 
+      if( nBuf>7 && 0==memcmp("ization", &aBuf[nBuf-7], 7) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-7) ){
+          memcpy(&aBuf[nBuf-7], "ize", 3);
+          *pnBuf = nBuf - 7 + 3;
+        }
+      }else if( nBuf>5 && 0==memcmp("ation", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "ate", 3);
+          *pnBuf = nBuf - 5 + 3;
+        }
+      }else if( nBuf>4 && 0==memcmp("ator", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-4) ){
+          memcpy(&aBuf[nBuf-4], "ate", 3);
+          *pnBuf = nBuf - 4 + 3;
+        }
+      }
+      break;
+  
+    case 's': 
+      if( nBuf>5 && 0==memcmp("alism", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "al", 2);
+          *pnBuf = nBuf - 5 + 2;
+        }
+      }else if( nBuf>7 && 0==memcmp("iveness", &aBuf[nBuf-7], 7) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-7) ){
+          memcpy(&aBuf[nBuf-7], "ive", 3);
+          *pnBuf = nBuf - 7 + 3;
+        }
+      }else if( nBuf>7 && 0==memcmp("fulness", &aBuf[nBuf-7], 7) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-7) ){
+          memcpy(&aBuf[nBuf-7], "ful", 3);
+          *pnBuf = nBuf - 7 + 3;
+        }
+      }else if( nBuf>7 && 0==memcmp("ousness", &aBuf[nBuf-7], 7) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-7) ){
+          memcpy(&aBuf[nBuf-7], "ous", 3);
+          *pnBuf = nBuf - 7 + 3;
+        }
+      }
+      break;
+  
+    case 't': 
+      if( nBuf>5 && 0==memcmp("aliti", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "al", 2);
+          *pnBuf = nBuf - 5 + 2;
+        }
+      }else if( nBuf>5 && 0==memcmp("iviti", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "ive", 3);
+          *pnBuf = nBuf - 5 + 3;
+        }
+      }else if( nBuf>6 && 0==memcmp("biliti", &aBuf[nBuf-6], 6) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-6) ){
+          memcpy(&aBuf[nBuf-6], "ble", 3);
+          *pnBuf = nBuf - 6 + 3;
+        }
+      }
+      break;
+  
+  }
+  return ret;
+}
+  
+
+static int fts5PorterStep3(char *aBuf, int *pnBuf){
+  int ret = 0;
+  int nBuf = *pnBuf;
+  switch( aBuf[nBuf-2] ){
+    
+    case 'a': 
+      if( nBuf>4 && 0==memcmp("ical", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-4) ){
+          memcpy(&aBuf[nBuf-4], "ic", 2);
+          *pnBuf = nBuf - 4 + 2;
+        }
+      }
+      break;
+  
+    case 's': 
+      if( nBuf>4 && 0==memcmp("ness", &aBuf[nBuf-4], 4) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-4) ){
+          *pnBuf = nBuf - 4;
+        }
+      }
+      break;
+  
+    case 't': 
+      if( nBuf>5 && 0==memcmp("icate", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "ic", 2);
+          *pnBuf = nBuf - 5 + 2;
+        }
+      }else if( nBuf>5 && 0==memcmp("iciti", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "ic", 2);
+          *pnBuf = nBuf - 5 + 2;
+        }
+      }
+      break;
+  
+    case 'u': 
+      if( nBuf>3 && 0==memcmp("ful", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+        }
+      }
+      break;
+  
+    case 'v': 
+      if( nBuf>5 && 0==memcmp("ative", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          *pnBuf = nBuf - 5;
+        }
+      }
+      break;
+  
+    case 'z': 
+      if( nBuf>5 && 0==memcmp("alize", &aBuf[nBuf-5], 5) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-5) ){
+          memcpy(&aBuf[nBuf-5], "al", 2);
+          *pnBuf = nBuf - 5 + 2;
+        }
+      }
+      break;
+  
+  }
+  return ret;
+}
+  
+
+static int fts5PorterStep1B(char *aBuf, int *pnBuf){
+  int ret = 0;
+  int nBuf = *pnBuf;
+  switch( aBuf[nBuf-2] ){
+    
+    case 'e': 
+      if( nBuf>3 && 0==memcmp("eed", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_MGt0(aBuf, nBuf-3) ){
+          memcpy(&aBuf[nBuf-3], "ee", 2);
+          *pnBuf = nBuf - 3 + 2;
+        }
+      }else if( nBuf>2 && 0==memcmp("ed", &aBuf[nBuf-2], 2) ){
+        if( fts5Porter_Vowel(aBuf, nBuf-2) ){
+          *pnBuf = nBuf - 2;
+          ret = 1;
+        }
+      }
+      break;
+  
+    case 'n': 
+      if( nBuf>3 && 0==memcmp("ing", &aBuf[nBuf-3], 3) ){
+        if( fts5Porter_Vowel(aBuf, nBuf-3) ){
+          *pnBuf = nBuf - 3;
+          ret = 1;
+        }
+      }
+      break;
+  
+  }
+  return ret;
+}
+  
+/* 
+** GENERATED CODE ENDS HERE (mkportersteps.tcl)
+***************************************************************************
+**************************************************************************/
+
+static void fts5PorterStep1A(char *aBuf, int *pnBuf){
+  int nBuf = *pnBuf;
+  if( aBuf[nBuf-1]=='s' ){
+    if( aBuf[nBuf-2]=='e' ){
+      if( (nBuf>4 && aBuf[nBuf-4]=='s' && aBuf[nBuf-3]=='s') 
+       || (nBuf>3 && aBuf[nBuf-3]=='i' )
+      ){
+        *pnBuf = nBuf-2;
+      }else{
+        *pnBuf = nBuf-1;
+      }
+    }
+    else if( aBuf[nBuf-2]!='s' ){
+      *pnBuf = nBuf-1;
+    }
+  }
+}
+
+static int fts5PorterCb(
+  void *pCtx, 
+  int tflags,
+  const char *pToken, 
+  int nToken, 
+  int iStart, 
+  int iEnd
+){
+  PorterContext *p = (PorterContext*)pCtx;
+
+  char *aBuf;
+  int nBuf;
+
+  if( nToken>FTS5_PORTER_MAX_TOKEN || nToken<3 ) goto pass_through;
+  aBuf = p->aBuf;
+  nBuf = nToken;
+  memcpy(aBuf, pToken, nBuf);
+
+  /* Step 1. */
+  fts5PorterStep1A(aBuf, &nBuf);
+  if( fts5PorterStep1B(aBuf, &nBuf) ){
+    if( fts5PorterStep1B2(aBuf, &nBuf)==0 ){
+      char c = aBuf[nBuf-1];
+      if( fts5PorterIsVowel(c, 0)==0 
+       && c!='l' && c!='s' && c!='z' && c==aBuf[nBuf-2] 
+      ){
+        nBuf--;
+      }else if( fts5Porter_MEq1(aBuf, nBuf) && fts5Porter_Ostar(aBuf, nBuf) ){
+        aBuf[nBuf++] = 'e';
+      }
+    }
+  }
+
+  /* Step 1C. */
+  if( aBuf[nBuf-1]=='y' && fts5Porter_Vowel(aBuf, nBuf-1) ){
+    aBuf[nBuf-1] = 'i';
+  }
+
+  /* Steps 2 through 4. */
+  fts5PorterStep2(aBuf, &nBuf);
+  fts5PorterStep3(aBuf, &nBuf);
+  fts5PorterStep4(aBuf, &nBuf);
+
+  /* Step 5a. */
+  assert( nBuf>0 );
+  if( aBuf[nBuf-1]=='e' ){
+    if( fts5Porter_MGt1(aBuf, nBuf-1) 
+     || (fts5Porter_MEq1(aBuf, nBuf-1) && !fts5Porter_Ostar(aBuf, nBuf-1))
+    ){
+      nBuf--;
+    }
+  }
+
+  /* Step 5b. */
+  if( nBuf>1 && aBuf[nBuf-1]=='l' 
+   && aBuf[nBuf-2]=='l' && fts5Porter_MGt1(aBuf, nBuf-1) 
+  ){
+    nBuf--;
+  }
+
+  return p->xToken(p->pCtx, tflags, aBuf, nBuf, iStart, iEnd);
+
+ pass_through:
+  return p->xToken(p->pCtx, tflags, pToken, nToken, iStart, iEnd);
+}
+
+/*
+** Tokenize using the porter tokenizer.
+*/
+static int fts5PorterTokenize(
+  Fts5Tokenizer *pTokenizer,
+  void *pCtx,
+  int flags,
+  const char *pText, int nText,
+  int (*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd)
+){
+  PorterTokenizer *p = (PorterTokenizer*)pTokenizer;
+  PorterContext sCtx;
+  sCtx.xToken = xToken;
+  sCtx.pCtx = pCtx;
+  sCtx.aBuf = p->aBuf;
+  return p->tokenizer.xTokenize(
+      p->pTokenizer, (void*)&sCtx, flags, pText, nText, fts5PorterCb
+  );
+}
+
+/*
+** Register all built-in tokenizers with FTS5.
+*/
+static int sqlite3Fts5TokenizerInit(fts5_api *pApi){
+  struct BuiltinTokenizer {
+    const char *zName;
+    fts5_tokenizer x;
+  } aBuiltin[] = {
+    { "unicode61", {fts5UnicodeCreate, fts5UnicodeDelete, fts5UnicodeTokenize}},
+    { "ascii",     {fts5AsciiCreate, fts5AsciiDelete, fts5AsciiTokenize }},
+    { "porter",    {fts5PorterCreate, fts5PorterDelete, fts5PorterTokenize }},
+  };
+  
+  int rc = SQLITE_OK;             /* Return code */
+  int i;                          /* To iterate through builtin functions */
+
+  for(i=0; rc==SQLITE_OK && i<sizeof(aBuiltin)/sizeof(aBuiltin[0]); i++){
+    rc = pApi->xCreateTokenizer(pApi,
+        aBuiltin[i].zName,
+        (void*)pApi,
+        &aBuiltin[i].x,
+        0
+    );
+  }
+
+  return rc;
+}
+
+
+
+/*
+** 2012 May 25
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+*/
+
+/*
+** DO NOT EDIT THIS MACHINE GENERATED FILE.
+*/
+
+
+/* #include <assert.h> */
+
+/*
+** Return true if the argument corresponds to a unicode codepoint
+** classified as either a letter or a number. Otherwise false.
+**
+** The results are undefined if the value passed to this function
+** is less than zero.
+*/
+static int sqlite3Fts5UnicodeIsalnum(int c){
+  /* Each unsigned integer in the following array corresponds to a contiguous
+  ** range of unicode codepoints that are not either letters or numbers (i.e.
+  ** codepoints for which this function should return 0).
+  **
+  ** The most significant 22 bits in each 32-bit value contain the first 
+  ** codepoint in the range. The least significant 10 bits are used to store
+  ** the size of the range (always at least 1). In other words, the value 
+  ** ((C<<22) + N) represents a range of N codepoints starting with codepoint 
+  ** C. It is not possible to represent a range larger than 1023 codepoints 
+  ** using this format.
+  */
+  static const unsigned int aEntry[] = {
+    0x00000030, 0x0000E807, 0x00016C06, 0x0001EC2F, 0x0002AC07,
+    0x0002D001, 0x0002D803, 0x0002EC01, 0x0002FC01, 0x00035C01,
+    0x0003DC01, 0x000B0804, 0x000B480E, 0x000B9407, 0x000BB401,
+    0x000BBC81, 0x000DD401, 0x000DF801, 0x000E1002, 0x000E1C01,
+    0x000FD801, 0x00120808, 0x00156806, 0x00162402, 0x00163C01,
+    0x00164437, 0x0017CC02, 0x00180005, 0x00181816, 0x00187802,
+    0x00192C15, 0x0019A804, 0x0019C001, 0x001B5001, 0x001B580F,
+    0x001B9C07, 0x001BF402, 0x001C000E, 0x001C3C01, 0x001C4401,
+    0x001CC01B, 0x001E980B, 0x001FAC09, 0x001FD804, 0x00205804,
+    0x00206C09, 0x00209403, 0x0020A405, 0x0020C00F, 0x00216403,
+    0x00217801, 0x0023901B, 0x00240004, 0x0024E803, 0x0024F812,
+    0x00254407, 0x00258804, 0x0025C001, 0x00260403, 0x0026F001,
+    0x0026F807, 0x00271C02, 0x00272C03, 0x00275C01, 0x00278802,
+    0x0027C802, 0x0027E802, 0x00280403, 0x0028F001, 0x0028F805,
+    0x00291C02, 0x00292C03, 0x00294401, 0x0029C002, 0x0029D401,
+    0x002A0403, 0x002AF001, 0x002AF808, 0x002B1C03, 0x002B2C03,
+    0x002B8802, 0x002BC002, 0x002C0403, 0x002CF001, 0x002CF807,
+    0x002D1C02, 0x002D2C03, 0x002D5802, 0x002D8802, 0x002DC001,
+    0x002E0801, 0x002EF805, 0x002F1803, 0x002F2804, 0x002F5C01,
+    0x002FCC08, 0x00300403, 0x0030F807, 0x00311803, 0x00312804,
+    0x00315402, 0x00318802, 0x0031FC01, 0x00320802, 0x0032F001,
+    0x0032F807, 0x00331803, 0x00332804, 0x00335402, 0x00338802,
+    0x00340802, 0x0034F807, 0x00351803, 0x00352804, 0x00355C01,
+    0x00358802, 0x0035E401, 0x00360802, 0x00372801, 0x00373C06,
+    0x00375801, 0x00376008, 0x0037C803, 0x0038C401, 0x0038D007,
+    0x0038FC01, 0x00391C09, 0x00396802, 0x003AC401, 0x003AD006,
+    0x003AEC02, 0x003B2006, 0x003C041F, 0x003CD00C, 0x003DC417,
+    0x003E340B, 0x003E6424, 0x003EF80F, 0x003F380D, 0x0040AC14,
+    0x00412806, 0x00415804, 0x00417803, 0x00418803, 0x00419C07,
+    0x0041C404, 0x0042080C, 0x00423C01, 0x00426806, 0x0043EC01,
+    0x004D740C, 0x004E400A, 0x00500001, 0x0059B402, 0x005A0001,
+    0x005A6C02, 0x005BAC03, 0x005C4803, 0x005CC805, 0x005D4802,
+    0x005DC802, 0x005ED023, 0x005F6004, 0x005F7401, 0x0060000F,
+    0x0062A401, 0x0064800C, 0x0064C00C, 0x00650001, 0x00651002,
+    0x0066C011, 0x00672002, 0x00677822, 0x00685C05, 0x00687802,
+    0x0069540A, 0x0069801D, 0x0069FC01, 0x006A8007, 0x006AA006,
+    0x006C0005, 0x006CD011, 0x006D6823, 0x006E0003, 0x006E840D,
+    0x006F980E, 0x006FF004, 0x00709014, 0x0070EC05, 0x0071F802,
+    0x00730008, 0x00734019, 0x0073B401, 0x0073C803, 0x00770027,
+    0x0077F004, 0x007EF401, 0x007EFC03, 0x007F3403, 0x007F7403,
+    0x007FB403, 0x007FF402, 0x00800065, 0x0081A806, 0x0081E805,
+    0x00822805, 0x0082801A, 0x00834021, 0x00840002, 0x00840C04,
+    0x00842002, 0x00845001, 0x00845803, 0x00847806, 0x00849401,
+    0x00849C01, 0x0084A401, 0x0084B801, 0x0084E802, 0x00850005,
+    0x00852804, 0x00853C01, 0x00864264, 0x00900027, 0x0091000B,
+    0x0092704E, 0x00940200, 0x009C0475, 0x009E53B9, 0x00AD400A,
+    0x00B39406, 0x00B3BC03, 0x00B3E404, 0x00B3F802, 0x00B5C001,
+    0x00B5FC01, 0x00B7804F, 0x00B8C00C, 0x00BA001A, 0x00BA6C59,
+    0x00BC00D6, 0x00BFC00C, 0x00C00005, 0x00C02019, 0x00C0A807,
+    0x00C0D802, 0x00C0F403, 0x00C26404, 0x00C28001, 0x00C3EC01,
+    0x00C64002, 0x00C6580A, 0x00C70024, 0x00C8001F, 0x00C8A81E,
+    0x00C94001, 0x00C98020, 0x00CA2827, 0x00CB003F, 0x00CC0100,
+    0x01370040, 0x02924037, 0x0293F802, 0x02983403, 0x0299BC10,
+    0x029A7C01, 0x029BC008, 0x029C0017, 0x029C8002, 0x029E2402,
+    0x02A00801, 0x02A01801, 0x02A02C01, 0x02A08C09, 0x02A0D804,
+    0x02A1D004, 0x02A20002, 0x02A2D011, 0x02A33802, 0x02A38012,
+    0x02A3E003, 0x02A4980A, 0x02A51C0D, 0x02A57C01, 0x02A60004,
+    0x02A6CC1B, 0x02A77802, 0x02A8A40E, 0x02A90C01, 0x02A93002,
+    0x02A97004, 0x02A9DC03, 0x02A9EC01, 0x02AAC001, 0x02AAC803,
+    0x02AADC02, 0x02AAF802, 0x02AB0401, 0x02AB7802, 0x02ABAC07,
+    0x02ABD402, 0x02AF8C0B, 0x03600001, 0x036DFC02, 0x036FFC02,
+    0x037FFC01, 0x03EC7801, 0x03ECA401, 0x03EEC810, 0x03F4F802,
+    0x03F7F002, 0x03F8001A, 0x03F88007, 0x03F8C023, 0x03F95013,
+    0x03F9A004, 0x03FBFC01, 0x03FC040F, 0x03FC6807, 0x03FCEC06,
+    0x03FD6C0B, 0x03FF8007, 0x03FFA007, 0x03FFE405, 0x04040003,
+    0x0404DC09, 0x0405E411, 0x0406400C, 0x0407402E, 0x040E7C01,
+    0x040F4001, 0x04215C01, 0x04247C01, 0x0424FC01, 0x04280403,
+    0x04281402, 0x04283004, 0x0428E003, 0x0428FC01, 0x04294009,
+    0x0429FC01, 0x042CE407, 0x04400003, 0x0440E016, 0x04420003,
+    0x0442C012, 0x04440003, 0x04449C0E, 0x04450004, 0x04460003,
+    0x0446CC0E, 0x04471404, 0x045AAC0D, 0x0491C004, 0x05BD442E,
+    0x05BE3C04, 0x074000F6, 0x07440027, 0x0744A4B5, 0x07480046,
+    0x074C0057, 0x075B0401, 0x075B6C01, 0x075BEC01, 0x075C5401,
+    0x075CD401, 0x075D3C01, 0x075DBC01, 0x075E2401, 0x075EA401,
+    0x075F0C01, 0x07BBC002, 0x07C0002C, 0x07C0C064, 0x07C2800F,
+    0x07C2C40E, 0x07C3040F, 0x07C3440F, 0x07C4401F, 0x07C4C03C,
+    0x07C5C02B, 0x07C7981D, 0x07C8402B, 0x07C90009, 0x07C94002,
+    0x07CC0021, 0x07CCC006, 0x07CCDC46, 0x07CE0014, 0x07CE8025,
+    0x07CF1805, 0x07CF8011, 0x07D0003F, 0x07D10001, 0x07D108B6,
+    0x07D3E404, 0x07D4003E, 0x07D50004, 0x07D54018, 0x07D7EC46,
+    0x07D9140B, 0x07DA0046, 0x07DC0074, 0x38000401, 0x38008060,
+    0x380400F0,
+  };
+  static const unsigned int aAscii[4] = {
+    0xFFFFFFFF, 0xFC00FFFF, 0xF8000001, 0xF8000001,
+  };
+
+  if( c<128 ){
+    return ( (aAscii[c >> 5] & (1 << (c & 0x001F)))==0 );
+  }else if( c<(1<<22) ){
+    unsigned int key = (((unsigned int)c)<<10) | 0x000003FF;
+    int iRes = 0;
+    int iHi = sizeof(aEntry)/sizeof(aEntry[0]) - 1;
+    int iLo = 0;
+    while( iHi>=iLo ){
+      int iTest = (iHi + iLo) / 2;
+      if( key >= aEntry[iTest] ){
+        iRes = iTest;
+        iLo = iTest+1;
+      }else{
+        iHi = iTest-1;
+      }
+    }
+    assert( aEntry[0]<key );
+    assert( key>=aEntry[iRes] );
+    return (((unsigned int)c) >= ((aEntry[iRes]>>10) + (aEntry[iRes]&0x3FF)));
+  }
+  return 1;
+}
+
+
+/*
+** If the argument is a codepoint corresponding to a lowercase letter
+** in the ASCII range with a diacritic added, return the codepoint
+** of the ASCII letter only. For example, if passed 235 - "LATIN
+** SMALL LETTER E WITH DIAERESIS" - return 65 ("LATIN SMALL LETTER
+** E"). The resuls of passing a codepoint that corresponds to an
+** uppercase letter are undefined.
+*/
+static int fts5_remove_diacritic(int c){
+  unsigned short aDia[] = {
+        0,  1797,  1848,  1859,  1891,  1928,  1940,  1995, 
+     2024,  2040,  2060,  2110,  2168,  2206,  2264,  2286, 
+     2344,  2383,  2472,  2488,  2516,  2596,  2668,  2732, 
+     2782,  2842,  2894,  2954,  2984,  3000,  3028,  3336, 
+     3456,  3696,  3712,  3728,  3744,  3896,  3912,  3928, 
+     3968,  4008,  4040,  4106,  4138,  4170,  4202,  4234, 
+     4266,  4296,  4312,  4344,  4408,  4424,  4472,  4504, 
+     6148,  6198,  6264,  6280,  6360,  6429,  6505,  6529, 
+    61448, 61468, 61534, 61592, 61642, 61688, 61704, 61726, 
+    61784, 61800, 61836, 61880, 61914, 61948, 61998, 62122, 
+    62154, 62200, 62218, 62302, 62364, 62442, 62478, 62536, 
+    62554, 62584, 62604, 62640, 62648, 62656, 62664, 62730, 
+    62924, 63050, 63082, 63274, 63390, 
+  };
+  char aChar[] = {
+    '\0', 'a',  'c',  'e',  'i',  'n',  'o',  'u',  'y',  'y',  'a',  'c',  
+    'd',  'e',  'e',  'g',  'h',  'i',  'j',  'k',  'l',  'n',  'o',  'r',  
+    's',  't',  'u',  'u',  'w',  'y',  'z',  'o',  'u',  'a',  'i',  'o',  
+    'u',  'g',  'k',  'o',  'j',  'g',  'n',  'a',  'e',  'i',  'o',  'r',  
+    'u',  's',  't',  'h',  'a',  'e',  'o',  'y',  '\0', '\0', '\0', '\0', 
+    '\0', '\0', '\0', '\0', 'a',  'b',  'd',  'd',  'e',  'f',  'g',  'h',  
+    'h',  'i',  'k',  'l',  'l',  'm',  'n',  'p',  'r',  'r',  's',  't',  
+    'u',  'v',  'w',  'w',  'x',  'y',  'z',  'h',  't',  'w',  'y',  'a',  
+    'e',  'i',  'o',  'u',  'y',  
+  };
+
+  unsigned int key = (((unsigned int)c)<<3) | 0x00000007;
+  int iRes = 0;
+  int iHi = sizeof(aDia)/sizeof(aDia[0]) - 1;
+  int iLo = 0;
+  while( iHi>=iLo ){
+    int iTest = (iHi + iLo) / 2;
+    if( key >= aDia[iTest] ){
+      iRes = iTest;
+      iLo = iTest+1;
+    }else{
+      iHi = iTest-1;
+    }
+  }
+  assert( key>=aDia[iRes] );
+  return ((c > (aDia[iRes]>>3) + (aDia[iRes]&0x07)) ? c : (int)aChar[iRes]);
+}
+
+
+/*
+** Return true if the argument interpreted as a unicode codepoint
+** is a diacritical modifier character.
+*/
+static int sqlite3Fts5UnicodeIsdiacritic(int c){
+  unsigned int mask0 = 0x08029FDF;
+  unsigned int mask1 = 0x000361F8;
+  if( c<768 || c>817 ) return 0;
+  return (c < 768+32) ?
+      (mask0 & (1 << (c-768))) :
+      (mask1 & (1 << (c-768-32)));
+}
+
+
+/*
+** Interpret the argument as a unicode codepoint. If the codepoint
+** is an upper case character that has a lower case equivalent,
+** return the codepoint corresponding to the lower case version.
+** Otherwise, return a copy of the argument.
+**
+** The results are undefined if the value passed to this function
+** is less than zero.
+*/
+static int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic){
+  /* Each entry in the following array defines a rule for folding a range
+  ** of codepoints to lower case. The rule applies to a range of nRange
+  ** codepoints starting at codepoint iCode.
+  **
+  ** If the least significant bit in flags is clear, then the rule applies
+  ** to all nRange codepoints (i.e. all nRange codepoints are upper case and
+  ** need to be folded). Or, if it is set, then the rule only applies to
+  ** every second codepoint in the range, starting with codepoint C.
+  **
+  ** The 7 most significant bits in flags are an index into the aiOff[]
+  ** array. If a specific codepoint C does require folding, then its lower
+  ** case equivalent is ((C + aiOff[flags>>1]) & 0xFFFF).
+  **
+  ** The contents of this array are generated by parsing the CaseFolding.txt
+  ** file distributed as part of the "Unicode Character Database". See
+  ** http://www.unicode.org for details.
+  */
+  static const struct TableEntry {
+    unsigned short iCode;
+    unsigned char flags;
+    unsigned char nRange;
+  } aEntry[] = {
+    {65, 14, 26},          {181, 64, 1},          {192, 14, 23},
+    {216, 14, 7},          {256, 1, 48},          {306, 1, 6},
+    {313, 1, 16},          {330, 1, 46},          {376, 116, 1},
+    {377, 1, 6},           {383, 104, 1},         {385, 50, 1},
+    {386, 1, 4},           {390, 44, 1},          {391, 0, 1},
+    {393, 42, 2},          {395, 0, 1},           {398, 32, 1},
+    {399, 38, 1},          {400, 40, 1},          {401, 0, 1},
+    {403, 42, 1},          {404, 46, 1},          {406, 52, 1},
+    {407, 48, 1},          {408, 0, 1},           {412, 52, 1},
+    {413, 54, 1},          {415, 56, 1},          {416, 1, 6},
+    {422, 60, 1},          {423, 0, 1},           {425, 60, 1},
+    {428, 0, 1},           {430, 60, 1},          {431, 0, 1},
+    {433, 58, 2},          {435, 1, 4},           {439, 62, 1},
+    {440, 0, 1},           {444, 0, 1},           {452, 2, 1},
+    {453, 0, 1},           {455, 2, 1},           {456, 0, 1},
+    {458, 2, 1},           {459, 1, 18},          {478, 1, 18},
+    {497, 2, 1},           {498, 1, 4},           {502, 122, 1},
+    {503, 134, 1},         {504, 1, 40},          {544, 110, 1},
+    {546, 1, 18},          {570, 70, 1},          {571, 0, 1},
+    {573, 108, 1},         {574, 68, 1},          {577, 0, 1},
+    {579, 106, 1},         {580, 28, 1},          {581, 30, 1},
+    {582, 1, 10},          {837, 36, 1},          {880, 1, 4},
+    {886, 0, 1},           {902, 18, 1},          {904, 16, 3},
+    {908, 26, 1},          {910, 24, 2},          {913, 14, 17},
+    {931, 14, 9},          {962, 0, 1},           {975, 4, 1},
+    {976, 140, 1},         {977, 142, 1},         {981, 146, 1},
+    {982, 144, 1},         {984, 1, 24},          {1008, 136, 1},
+    {1009, 138, 1},        {1012, 130, 1},        {1013, 128, 1},
+    {1015, 0, 1},          {1017, 152, 1},        {1018, 0, 1},
+    {1021, 110, 3},        {1024, 34, 16},        {1040, 14, 32},
+    {1120, 1, 34},         {1162, 1, 54},         {1216, 6, 1},
+    {1217, 1, 14},         {1232, 1, 88},         {1329, 22, 38},
+    {4256, 66, 38},        {4295, 66, 1},         {4301, 66, 1},
+    {7680, 1, 150},        {7835, 132, 1},        {7838, 96, 1},
+    {7840, 1, 96},         {7944, 150, 8},        {7960, 150, 6},
+    {7976, 150, 8},        {7992, 150, 8},        {8008, 150, 6},
+    {8025, 151, 8},        {8040, 150, 8},        {8072, 150, 8},
+    {8088, 150, 8},        {8104, 150, 8},        {8120, 150, 2},
+    {8122, 126, 2},        {8124, 148, 1},        {8126, 100, 1},
+    {8136, 124, 4},        {8140, 148, 1},        {8152, 150, 2},
+    {8154, 120, 2},        {8168, 150, 2},        {8170, 118, 2},
+    {8172, 152, 1},        {8184, 112, 2},        {8186, 114, 2},
+    {8188, 148, 1},        {8486, 98, 1},         {8490, 92, 1},
+    {8491, 94, 1},         {8498, 12, 1},         {8544, 8, 16},
+    {8579, 0, 1},          {9398, 10, 26},        {11264, 22, 47},
+    {11360, 0, 1},         {11362, 88, 1},        {11363, 102, 1},
+    {11364, 90, 1},        {11367, 1, 6},         {11373, 84, 1},
+    {11374, 86, 1},        {11375, 80, 1},        {11376, 82, 1},
+    {11378, 0, 1},         {11381, 0, 1},         {11390, 78, 2},
+    {11392, 1, 100},       {11499, 1, 4},         {11506, 0, 1},
+    {42560, 1, 46},        {42624, 1, 24},        {42786, 1, 14},
+    {42802, 1, 62},        {42873, 1, 4},         {42877, 76, 1},
+    {42878, 1, 10},        {42891, 0, 1},         {42893, 74, 1},
+    {42896, 1, 4},         {42912, 1, 10},        {42922, 72, 1},
+    {65313, 14, 26},       
+  };
+  static const unsigned short aiOff[] = {
+   1,     2,     8,     15,    16,    26,    28,    32,    
+   37,    38,    40,    48,    63,    64,    69,    71,    
+   79,    80,    116,   202,   203,   205,   206,   207,   
+   209,   210,   211,   213,   214,   217,   218,   219,   
+   775,   7264,  10792, 10795, 23228, 23256, 30204, 54721, 
+   54753, 54754, 54756, 54787, 54793, 54809, 57153, 57274, 
+   57921, 58019, 58363, 61722, 65268, 65341, 65373, 65406, 
+   65408, 65410, 65415, 65424, 65436, 65439, 65450, 65462, 
+   65472, 65476, 65478, 65480, 65482, 65488, 65506, 65511, 
+   65514, 65521, 65527, 65528, 65529, 
+  };
+
+  int ret = c;
+
+  assert( sizeof(unsigned short)==2 && sizeof(unsigned char)==1 );
+
+  if( c<128 ){
+    if( c>='A' && c<='Z' ) ret = c + ('a' - 'A');
+  }else if( c<65536 ){
+    const struct TableEntry *p;
+    int iHi = sizeof(aEntry)/sizeof(aEntry[0]) - 1;
+    int iLo = 0;
+    int iRes = -1;
+
+    assert( c>aEntry[0].iCode );
+    while( iHi>=iLo ){
+      int iTest = (iHi + iLo) / 2;
+      int cmp = (c - aEntry[iTest].iCode);
+      if( cmp>=0 ){
+        iRes = iTest;
+        iLo = iTest+1;
+      }else{
+        iHi = iTest-1;
+      }
+    }
+
+    assert( iRes>=0 && c>=aEntry[iRes].iCode );
+    p = &aEntry[iRes];
+    if( c<(p->iCode + p->nRange) && 0==(0x01 & p->flags & (p->iCode ^ c)) ){
+      ret = (c + (aiOff[p->flags>>1])) & 0x0000FFFF;
+      assert( ret>0 );
+    }
+
+    if( bRemoveDiacritic ) ret = fts5_remove_diacritic(ret);
+  }
+  
+  else if( c>=66560 && c<66600 ){
+    ret = c + 40;
+  }
+
+  return ret;
+}
+
+/*
+** 2015 May 30
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** Routines for varint serialization and deserialization.
+*/
+
+
+
+/*
+** This is a copy of the sqlite3GetVarint32() routine from the SQLite core.
+** Except, this version does handle the single byte case that the core
+** version depends on being handled before its function is called.
+*/
+static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v){
+  u32 a,b;
+
+  /* The 1-byte case. Overwhelmingly the most common. */
+  a = *p;
+  /* a: p0 (unmasked) */
+  if (!(a&0x80))
+  {
+    /* Values between 0 and 127 */
+    *v = a;
+    return 1;
+  }
+
+  /* The 2-byte case */
+  p++;
+  b = *p;
+  /* b: p1 (unmasked) */
+  if (!(b&0x80))
+  {
+    /* Values between 128 and 16383 */
+    a &= 0x7f;
+    a = a<<7;
+    *v = a | b;
+    return 2;
+  }
+
+  /* The 3-byte case */
+  p++;
+  a = a<<14;
+  a |= *p;
+  /* a: p0<<14 | p2 (unmasked) */
+  if (!(a&0x80))
+  {
+    /* Values between 16384 and 2097151 */
+    a &= (0x7f<<14)|(0x7f);
+    b &= 0x7f;
+    b = b<<7;
+    *v = a | b;
+    return 3;
+  }
+
+  /* A 32-bit varint is used to store size information in btrees.
+  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.
+  ** A 3-byte varint is sufficient, for example, to record the size
+  ** of a 1048569-byte BLOB or string.
+  **
+  ** We only unroll the first 1-, 2-, and 3- byte cases.  The very
+  ** rare larger cases can be handled by the slower 64-bit varint
+  ** routine.
+  */
+  {
+    u64 v64;
+    u8 n;
+    p -= 2;
+    n = sqlite3Fts5GetVarint(p, &v64);
+    *v = (u32)v64;
+    assert( n>3 && n<=9 );
+    return n;
+  }
+}
+
+
+/*
+** Bitmasks used by sqlite3GetVarint().  These precomputed constants
+** are defined here rather than simply putting the constant expressions
+** inline in order to work around bugs in the RVT compiler.
+**
+** SLOT_2_0     A mask for  (0x7f<<14) | 0x7f
+**
+** SLOT_4_2_0   A mask for  (0x7f<<28) | SLOT_2_0
+*/
+#define SLOT_2_0     0x001fc07f
+#define SLOT_4_2_0   0xf01fc07f
+
+/*
+** Read a 64-bit variable-length integer from memory starting at p[0].
+** Return the number of bytes read.  The value is stored in *v.
+*/
+static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){
+  u32 a,b,s;
+
+  a = *p;
+  /* a: p0 (unmasked) */
+  if (!(a&0x80))
+  {
+    *v = a;
+    return 1;
+  }
+
+  p++;
+  b = *p;
+  /* b: p1 (unmasked) */
+  if (!(b&0x80))
+  {
+    a &= 0x7f;
+    a = a<<7;
+    a |= b;
+    *v = a;
+    return 2;
+  }
+
+  /* Verify that constants are precomputed correctly */
+  assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );
+  assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) );
+
+  p++;
+  a = a<<14;
+  a |= *p;
+  /* a: p0<<14 | p2 (unmasked) */
+  if (!(a&0x80))
+  {
+    a &= SLOT_2_0;
+    b &= 0x7f;
+    b = b<<7;
+    a |= b;
+    *v = a;
+    return 3;
+  }
+
+  /* CSE1 from below */
+  a &= SLOT_2_0;
+  p++;
+  b = b<<14;
+  b |= *p;
+  /* b: p1<<14 | p3 (unmasked) */
+  if (!(b&0x80))
+  {
+    b &= SLOT_2_0;
+    /* moved CSE1 up */
+    /* a &= (0x7f<<14)|(0x7f); */
+    a = a<<7;
+    a |= b;
+    *v = a;
+    return 4;
+  }
+
+  /* a: p0<<14 | p2 (masked) */
+  /* b: p1<<14 | p3 (unmasked) */
+  /* 1:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */
+  /* moved CSE1 up */
+  /* a &= (0x7f<<14)|(0x7f); */
+  b &= SLOT_2_0;
+  s = a;
+  /* s: p0<<14 | p2 (masked) */
+
+  p++;
+  a = a<<14;
+  a |= *p;
+  /* a: p0<<28 | p2<<14 | p4 (unmasked) */
+  if (!(a&0x80))
+  {
+    /* we can skip these cause they were (effectively) done above in calc'ing s */
+    /* a &= (0x7f<<28)|(0x7f<<14)|(0x7f); */
+    /* b &= (0x7f<<14)|(0x7f); */
+    b = b<<7;
+    a |= b;
+    s = s>>18;
+    *v = ((u64)s)<<32 | a;
+    return 5;
+  }
+
+  /* 2:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */
+  s = s<<7;
+  s |= b;
+  /* s: p0<<21 | p1<<14 | p2<<7 | p3 (masked) */
+
+  p++;
+  b = b<<14;
+  b |= *p;
+  /* b: p1<<28 | p3<<14 | p5 (unmasked) */
+  if (!(b&0x80))
+  {
+    /* we can skip this cause it was (effectively) done above in calc'ing s */
+    /* b &= (0x7f<<28)|(0x7f<<14)|(0x7f); */
+    a &= SLOT_2_0;
+    a = a<<7;
+    a |= b;
+    s = s>>18;
+    *v = ((u64)s)<<32 | a;
+    return 6;
+  }
+
+  p++;
+  a = a<<14;
+  a |= *p;
+  /* a: p2<<28 | p4<<14 | p6 (unmasked) */
+  if (!(a&0x80))
+  {
+    a &= SLOT_4_2_0;
+    b &= SLOT_2_0;
+    b = b<<7;
+    a |= b;
+    s = s>>11;
+    *v = ((u64)s)<<32 | a;
+    return 7;
+  }
+
+  /* CSE2 from below */
+  a &= SLOT_2_0;
+  p++;
+  b = b<<14;
+  b |= *p;
+  /* b: p3<<28 | p5<<14 | p7 (unmasked) */
+  if (!(b&0x80))
+  {
+    b &= SLOT_4_2_0;
+    /* moved CSE2 up */
+    /* a &= (0x7f<<14)|(0x7f); */
+    a = a<<7;
+    a |= b;
+    s = s>>4;
+    *v = ((u64)s)<<32 | a;
+    return 8;
+  }
+
+  p++;
+  a = a<<15;
+  a |= *p;
+  /* a: p4<<29 | p6<<15 | p8 (unmasked) */
+
+  /* moved CSE2 up */
+  /* a &= (0x7f<<29)|(0x7f<<15)|(0xff); */
+  b &= SLOT_2_0;
+  b = b<<8;
+  a |= b;
+
+  s = s<<4;
+  b = p[-4];
+  b &= 0x7f;
+  b = b>>3;
+  s |= b;
+
+  *v = ((u64)s)<<32 | a;
+
+  return 9;
+}
+
+/*
+** The variable-length integer encoding is as follows:
+**
+** KEY:
+**         A = 0xxxxxxx    7 bits of data and one flag bit
+**         B = 1xxxxxxx    7 bits of data and one flag bit
+**         C = xxxxxxxx    8 bits of data
+**
+**  7 bits - A
+** 14 bits - BA
+** 21 bits - BBA
+** 28 bits - BBBA
+** 35 bits - BBBBA
+** 42 bits - BBBBBA
+** 49 bits - BBBBBBA
+** 56 bits - BBBBBBBA
+** 64 bits - BBBBBBBBC
+*/
+
+#ifdef SQLITE_NOINLINE
+# define FTS5_NOINLINE SQLITE_NOINLINE
+#else
+# define FTS5_NOINLINE
+#endif
+
+/*
+** Write a 64-bit variable-length integer to memory starting at p[0].
+** The length of data write will be between 1 and 9 bytes.  The number
+** of bytes written is returned.
+**
+** A variable-length integer consists of the lower 7 bits of each byte
+** for all bytes that have the 8th bit set and one byte with the 8th
+** bit clear.  Except, if we get to the 9th byte, it stores the full
+** 8 bits and is the last byte.
+*/
+static int FTS5_NOINLINE fts5PutVarint64(unsigned char *p, u64 v){
+  int i, j, n;
+  u8 buf[10];
+  if( v & (((u64)0xff000000)<<32) ){
+    p[8] = (u8)v;
+    v >>= 8;
+    for(i=7; i>=0; i--){
+      p[i] = (u8)((v & 0x7f) | 0x80);
+      v >>= 7;
+    }
+    return 9;
+  }    
+  n = 0;
+  do{
+    buf[n++] = (u8)((v & 0x7f) | 0x80);
+    v >>= 7;
+  }while( v!=0 );
+  buf[0] &= 0x7f;
+  assert( n<=9 );
+  for(i=0, j=n-1; j>=0; j--, i++){
+    p[i] = buf[j];
+  }
+  return n;
+}
+
+static int sqlite3Fts5PutVarint(unsigned char *p, u64 v){
+  if( v<=0x7f ){
+    p[0] = v&0x7f;
+    return 1;
+  }
+  if( v<=0x3fff ){
+    p[0] = ((v>>7)&0x7f)|0x80;
+    p[1] = v&0x7f;
+    return 2;
+  }
+  return fts5PutVarint64(p,v);
+}
+
+
+static int sqlite3Fts5GetVarintLen(u32 iVal){
+  if( iVal<(1 << 7 ) ) return 1;
+  if( iVal<(1 << 14) ) return 2;
+  if( iVal<(1 << 21) ) return 3;
+  if( iVal<(1 << 28) ) return 4;
+  return 5;
+}
+
+
+/*
+** 2015 May 08
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** This is an SQLite virtual table module implementing direct access to an
+** existing FTS5 index. The module may create several different types of 
+** tables:
+**
+** col:
+**     CREATE TABLE vocab(term, col, doc, cnt, PRIMARY KEY(term, col));
+**
+**   One row for each term/column combination. The value of $doc is set to
+**   the number of fts5 rows that contain at least one instance of term
+**   $term within column $col. Field $cnt is set to the total number of 
+**   instances of term $term in column $col (in any row of the fts5 table). 
+**
+** row:
+**     CREATE TABLE vocab(term, doc, cnt, PRIMARY KEY(term));
+**
+**   One row for each term in the database. The value of $doc is set to
+**   the number of fts5 rows that contain at least one instance of term
+**   $term. Field $cnt is set to the total number of instances of term 
+**   $term in the database.
+*/
+
+
+
+
+typedef struct Fts5VocabTable Fts5VocabTable;
+typedef struct Fts5VocabCursor Fts5VocabCursor;
+
+struct Fts5VocabTable {
+  sqlite3_vtab base;
+  char *zFts5Tbl;                 /* Name of fts5 table */
+  char *zFts5Db;                  /* Db containing fts5 table */
+  sqlite3 *db;                    /* Database handle */
+  Fts5Global *pGlobal;            /* FTS5 global object for this database */
+  int eType;                      /* FTS5_VOCAB_COL or ROW */
+};
+
+struct Fts5VocabCursor {
+  sqlite3_vtab_cursor base;
+  sqlite3_stmt *pStmt;            /* Statement holding lock on pIndex */
+  Fts5Index *pIndex;              /* Associated FTS5 index */
+
+  int bEof;                       /* True if this cursor is at EOF */
+  Fts5IndexIter *pIter;           /* Term/rowid iterator object */
+
+  /* These are used by 'col' tables only */
+  int nCol;
+  int iCol;
+  i64 *aCnt;
+  i64 *aDoc;
+
+  /* Output values */
+  i64 rowid;                      /* This table's current rowid value */
+  Fts5Buffer term;                /* Current value of 'term' column */
+  i64 aVal[3];                    /* Up to three columns left of 'term' */
+};
+
+#define FTS5_VOCAB_COL    0
+#define FTS5_VOCAB_ROW    1
+
+#define FTS5_VOCAB_COL_SCHEMA  "term, col, doc, cnt"
+#define FTS5_VOCAB_ROW_SCHEMA  "term, doc, cnt"
+
+/*
+** Translate a string containing an fts5vocab table type to an 
+** FTS5_VOCAB_XXX constant. If successful, set *peType to the output
+** value and return SQLITE_OK. Otherwise, set *pzErr to an error message
+** and return SQLITE_ERROR.
+*/
+static int fts5VocabTableType(const char *zType, char **pzErr, int *peType){
+  int rc = SQLITE_OK;
+  char *zCopy = sqlite3Fts5Strndup(&rc, zType, -1);
+  if( rc==SQLITE_OK ){
+    sqlite3Fts5Dequote(zCopy);
+    if( sqlite3_stricmp(zCopy, "col")==0 ){
+      *peType = FTS5_VOCAB_COL;
+    }else
+
+    if( sqlite3_stricmp(zCopy, "row")==0 ){
+      *peType = FTS5_VOCAB_ROW;
+    }else
+    {
+      *pzErr = sqlite3_mprintf("fts5vocab: unknown table type: %Q", zCopy);
+      rc = SQLITE_ERROR;
+    }
+    sqlite3_free(zCopy);
+  }
+
+  return rc;
+}
+
+
+/*
+** The xDisconnect() virtual table method.
+*/
+static int fts5VocabDisconnectMethod(sqlite3_vtab *pVtab){
+  Fts5VocabTable *pTab = (Fts5VocabTable*)pVtab;
+  sqlite3_free(pTab);
+  return SQLITE_OK;
+}
+
+/*
+** The xDestroy() virtual table method.
+*/
+static int fts5VocabDestroyMethod(sqlite3_vtab *pVtab){
+  Fts5VocabTable *pTab = (Fts5VocabTable*)pVtab;
+  sqlite3_free(pTab);
+  return SQLITE_OK;
+}
+
+/*
+** This function is the implementation of both the xConnect and xCreate
+** methods of the FTS3 virtual table.
+**
+** The argv[] array contains the following:
+**
+**   argv[0]   -> module name  ("fts5vocab")
+**   argv[1]   -> database name
+**   argv[2]   -> table name
+**
+** then:
+**
+**   argv[3]   -> name of fts5 table
+**   argv[4]   -> type of fts5vocab table
+**
+** or, for tables in the TEMP schema only.
+**
+**   argv[3]   -> name of fts5 tables database
+**   argv[4]   -> name of fts5 table
+**   argv[5]   -> type of fts5vocab table
+*/
+static int fts5VocabInitVtab(
+  sqlite3 *db,                    /* The SQLite database connection */
+  void *pAux,                     /* Pointer to Fts5Global object */
+  int argc,                       /* Number of elements in argv array */
+  const char * const *argv,       /* xCreate/xConnect argument array */
+  sqlite3_vtab **ppVTab,          /* Write the resulting vtab structure here */
+  char **pzErr                    /* Write any error message here */
+){
+  const char *azSchema[] = { 
+    "CREATE TABlE vocab(" FTS5_VOCAB_COL_SCHEMA  ")", 
+    "CREATE TABlE vocab(" FTS5_VOCAB_ROW_SCHEMA  ")"
+  };
+
+  Fts5VocabTable *pRet = 0;
+  int rc = SQLITE_OK;             /* Return code */
+  int bDb;
+
+  bDb = (argc==6 && strlen(argv[1])==4 && memcmp("temp", argv[1], 4)==0);
+
+  if( argc!=5 && bDb==0 ){
+    *pzErr = sqlite3_mprintf("wrong number of vtable arguments");
+    rc = SQLITE_ERROR;
+  }else{
+    int nByte;                      /* Bytes of space to allocate */
+    const char *zDb = bDb ? argv[3] : argv[1];
+    const char *zTab = bDb ? argv[4] : argv[3];
+    const char *zType = bDb ? argv[5] : argv[4];
+    int nDb = strlen(zDb)+1; 
+    int nTab = strlen(zTab)+1;
+    int eType;
+    
+    rc = fts5VocabTableType(zType, pzErr, &eType);
+    if( rc==SQLITE_OK ){
+      assert( eType>=0 && eType<sizeof(azSchema)/sizeof(azSchema[0]) );
+      rc = sqlite3_declare_vtab(db, azSchema[eType]);
+    }
+
+    nByte = sizeof(Fts5VocabTable) + nDb + nTab;
+    pRet = sqlite3Fts5MallocZero(&rc, nByte);
+    if( pRet ){
+      pRet->pGlobal = (Fts5Global*)pAux;
+      pRet->eType = eType;
+      pRet->db = db;
+      pRet->zFts5Tbl = (char*)&pRet[1];
+      pRet->zFts5Db = &pRet->zFts5Tbl[nTab];
+      memcpy(pRet->zFts5Tbl, zTab, nTab);
+      memcpy(pRet->zFts5Db, zDb, nDb);
+      sqlite3Fts5Dequote(pRet->zFts5Tbl);
+      sqlite3Fts5Dequote(pRet->zFts5Db);
+    }
+  }
+
+  *ppVTab = (sqlite3_vtab*)pRet;
+  return rc;
+}
+
+
+/*
+** The xConnect() and xCreate() methods for the virtual table. All the
+** work is done in function fts5VocabInitVtab().
+*/
+static int fts5VocabConnectMethod(
+  sqlite3 *db,                    /* Database connection */
+  void *pAux,                     /* Pointer to tokenizer hash table */
+  int argc,                       /* Number of elements in argv array */
+  const char * const *argv,       /* xCreate/xConnect argument array */
+  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */
+  char **pzErr                    /* OUT: sqlite3_malloc'd error message */
+){
+  return fts5VocabInitVtab(db, pAux, argc, argv, ppVtab, pzErr);
+}
+static int fts5VocabCreateMethod(
+  sqlite3 *db,                    /* Database connection */
+  void *pAux,                     /* Pointer to tokenizer hash table */
+  int argc,                       /* Number of elements in argv array */
+  const char * const *argv,       /* xCreate/xConnect argument array */
+  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */
+  char **pzErr                    /* OUT: sqlite3_malloc'd error message */
+){
+  return fts5VocabInitVtab(db, pAux, argc, argv, ppVtab, pzErr);
+}
+
+/* 
+** Implementation of the xBestIndex method.
+*/
+static int fts5VocabBestIndexMethod(
+  sqlite3_vtab *pVTab, 
+  sqlite3_index_info *pInfo
+){
+  return SQLITE_OK;
+}
+
+/*
+** Implementation of xOpen method.
+*/
+static int fts5VocabOpenMethod(
+  sqlite3_vtab *pVTab, 
+  sqlite3_vtab_cursor **ppCsr
+){
+  Fts5VocabTable *pTab = (Fts5VocabTable*)pVTab;
+  Fts5Index *pIndex = 0;
+  int nCol = 0;
+  Fts5VocabCursor *pCsr = 0;
+  int rc = SQLITE_OK;
+  sqlite3_stmt *pStmt = 0;
+  char *zSql = 0;
+  int nByte;
+
+  zSql = sqlite3Fts5Mprintf(&rc,
+      "SELECT t.%Q FROM %Q.%Q AS t WHERE t.%Q MATCH '*id'",
+      pTab->zFts5Tbl, pTab->zFts5Db, pTab->zFts5Tbl, pTab->zFts5Tbl
+  );
+  if( zSql ){
+    rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pStmt, 0);
+  }
+  sqlite3_free(zSql);
+  assert( rc==SQLITE_OK || pStmt==0 );
+  if( rc==SQLITE_ERROR ) rc = SQLITE_OK;
+
+  if( pStmt && sqlite3_step(pStmt)==SQLITE_ROW ){
+    i64 iId = sqlite3_column_int64(pStmt, 0);
+    pIndex = sqlite3Fts5IndexFromCsrid(pTab->pGlobal, iId, &nCol);
+  }
+
+  if( rc==SQLITE_OK && pIndex==0 ){
+    rc = sqlite3_finalize(pStmt);
+    pStmt = 0;
+    if( rc==SQLITE_OK ){
+      pVTab->zErrMsg = sqlite3_mprintf(
+          "no such fts5 table: %s.%s", pTab->zFts5Db, pTab->zFts5Tbl
+      );
+      rc = SQLITE_ERROR;
+    }
+  }
+
+  nByte = nCol * sizeof(i64) * 2 + sizeof(Fts5VocabCursor);
+  pCsr = (Fts5VocabCursor*)sqlite3Fts5MallocZero(&rc, nByte);
+  if( pCsr ){
+    pCsr->pIndex = pIndex;
+    pCsr->pStmt = pStmt;
+    pCsr->nCol = nCol;
+    pCsr->aCnt = (i64*)&pCsr[1];
+    pCsr->aDoc = &pCsr->aCnt[nCol];
+  }else{
+    sqlite3_finalize(pStmt);
+  }
+
+  *ppCsr = (sqlite3_vtab_cursor*)pCsr;
+  return rc;
+}
+
+static void fts5VocabResetCursor(Fts5VocabCursor *pCsr){
+  pCsr->rowid = 0;
+  sqlite3Fts5IterClose(pCsr->pIter);
+  pCsr->pIter = 0;
+}
+
+/*
+** Close the cursor.  For additional information see the documentation
+** on the xClose method of the virtual table interface.
+*/
+static int fts5VocabCloseMethod(sqlite3_vtab_cursor *pCursor){
+  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
+  fts5VocabResetCursor(pCsr);
+  sqlite3Fts5BufferFree(&pCsr->term);
+  sqlite3_finalize(pCsr->pStmt);
+  sqlite3_free(pCsr);
+  return SQLITE_OK;
+}
+
+
+/*
+** Advance the cursor to the next row in the table.
+*/
+static int fts5VocabNextMethod(sqlite3_vtab_cursor *pCursor){
+  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
+  Fts5VocabTable *pTab = (Fts5VocabTable*)pCursor->pVtab;
+  int rc = SQLITE_OK;
+
+  pCsr->rowid++;
+
+  if( pTab->eType==FTS5_VOCAB_COL ){
+    for(pCsr->iCol++; pCsr->iCol<pCsr->nCol; pCsr->iCol++){
+      if( pCsr->aCnt[pCsr->iCol] ) break;
+    }
+  }
+
+  if( pTab->eType==FTS5_VOCAB_ROW || pCsr->iCol>=pCsr->nCol ){
+    if( sqlite3Fts5IterEof(pCsr->pIter) ){
+      pCsr->bEof = 1;
+    }else{
+      const char *zTerm;
+      int nTerm;
+
+      zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);
+      sqlite3Fts5BufferSet(&rc, &pCsr->term, nTerm, (const u8*)zTerm);
+      memset(pCsr->aVal, 0, sizeof(pCsr->aVal));
+      memset(pCsr->aCnt, 0, pCsr->nCol * sizeof(i64));
+      memset(pCsr->aDoc, 0, pCsr->nCol * sizeof(i64));
+      pCsr->iCol = 0;
+
+      assert( pTab->eType==FTS5_VOCAB_COL || pTab->eType==FTS5_VOCAB_ROW );
+      while( rc==SQLITE_OK ){
+        i64 dummy;
+        const u8 *pPos; int nPos;   /* Position list */
+        i64 iPos = 0;               /* 64-bit position read from poslist */
+        int iOff = 0;               /* Current offset within position list */
+
+        rc = sqlite3Fts5IterPoslist(pCsr->pIter, 0, &pPos, &nPos, &dummy);
+        if( rc==SQLITE_OK ){
+          if( pTab->eType==FTS5_VOCAB_ROW ){
+            while( 0==sqlite3Fts5PoslistNext64(pPos, nPos, &iOff, &iPos) ){
+              pCsr->aVal[1]++;
+            }
+            pCsr->aVal[0]++;
+          }else{
+            int iCol = -1;
+            while( 0==sqlite3Fts5PoslistNext64(pPos, nPos, &iOff, &iPos) ){
+              int ii = FTS5_POS2COLUMN(iPos);
+              pCsr->aCnt[ii]++;
+              if( iCol!=ii ){
+                pCsr->aDoc[ii]++;
+                iCol = ii;
+              }
+            }
+          }
+          rc = sqlite3Fts5IterNextScan(pCsr->pIter);
+        }
+        if( rc==SQLITE_OK ){
+          zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);
+          if( nTerm!=pCsr->term.n || memcmp(zTerm, pCsr->term.p, nTerm) ) break;
+          if( sqlite3Fts5IterEof(pCsr->pIter) ) break;
+        }
+      }
+    }
+  }
+
+  if( pCsr->bEof==0 && pTab->eType==FTS5_VOCAB_COL ){
+    while( pCsr->aCnt[pCsr->iCol]==0 ) pCsr->iCol++;
+    pCsr->aVal[0] = pCsr->iCol;
+    pCsr->aVal[1] = pCsr->aDoc[pCsr->iCol];
+    pCsr->aVal[2] = pCsr->aCnt[pCsr->iCol];
+  }
+  return rc;
+}
+
+/*
+** This is the xFilter implementation for the virtual table.
+*/
+static int fts5VocabFilterMethod(
+  sqlite3_vtab_cursor *pCursor,   /* The cursor used for this query */
+  int idxNum,                     /* Strategy index */
+  const char *idxStr,             /* Unused */
+  int nVal,                       /* Number of elements in apVal */
+  sqlite3_value **apVal           /* Arguments for the indexing scheme */
+){
+  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
+  int rc;
+  const int flags = FTS5INDEX_QUERY_SCAN;
+
+  fts5VocabResetCursor(pCsr);
+  rc = sqlite3Fts5IndexQuery(pCsr->pIndex, 0, 0, flags, 0, &pCsr->pIter);
+  if( rc==SQLITE_OK ){
+    rc = fts5VocabNextMethod(pCursor);
+  }
+
+  return rc;
+}
+
+/* 
+** This is the xEof method of the virtual table. SQLite calls this 
+** routine to find out if it has reached the end of a result set.
+*/
+static int fts5VocabEofMethod(sqlite3_vtab_cursor *pCursor){
+  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
+  return pCsr->bEof;
+}
+
+static int fts5VocabColumnMethod(
+  sqlite3_vtab_cursor *pCursor,   /* Cursor to retrieve value from */
+  sqlite3_context *pCtx,          /* Context for sqlite3_result_xxx() calls */
+  int iCol                        /* Index of column to read value from */
+){
+  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
+  switch( iCol ){
+    case 0: /* term */
+      sqlite3_result_text(
+          pCtx, (const char*)pCsr->term.p, pCsr->term.n, SQLITE_TRANSIENT
+      );
+      break;
+
+    default:
+      assert( iCol<4 && iCol>0 );
+      sqlite3_result_int64(pCtx, pCsr->aVal[iCol-1]);
+      break;
+  }
+  return SQLITE_OK;
+}
+
+/* 
+** This is the xRowid method. The SQLite core calls this routine to
+** retrieve the rowid for the current row of the result set. The
+** rowid should be written to *pRowid.
+*/
+static int fts5VocabRowidMethod(
+  sqlite3_vtab_cursor *pCursor, 
+  sqlite_int64 *pRowid
+){
+  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;
+  *pRowid = pCsr->rowid;
+  return SQLITE_OK;
+}
+
+static int sqlite3Fts5VocabInit(Fts5Global *pGlobal, sqlite3 *db){
+  static const sqlite3_module fts5Vocab = {
+    /* iVersion      */ 2,
+    /* xCreate       */ fts5VocabCreateMethod,
+    /* xConnect      */ fts5VocabConnectMethod,
+    /* xBestIndex    */ fts5VocabBestIndexMethod,
+    /* xDisconnect   */ fts5VocabDisconnectMethod,
+    /* xDestroy      */ fts5VocabDestroyMethod,
+    /* xOpen         */ fts5VocabOpenMethod,
+    /* xClose        */ fts5VocabCloseMethod,
+    /* xFilter       */ fts5VocabFilterMethod,
+    /* xNext         */ fts5VocabNextMethod,
+    /* xEof          */ fts5VocabEofMethod,
+    /* xColumn       */ fts5VocabColumnMethod,
+    /* xRowid        */ fts5VocabRowidMethod,
+    /* xUpdate       */ 0,
+    /* xBegin        */ 0,
+    /* xSync         */ 0,
+    /* xCommit       */ 0,
+    /* xRollback     */ 0,
+    /* xFindFunction */ 0,
+    /* xRename       */ 0,
+    /* xSavepoint    */ 0,
+    /* xRelease      */ 0,
+    /* xRollbackTo   */ 0,
+  };
+  void *p = (void*)pGlobal;
+
+  return sqlite3_create_module_v2(db, "fts5vocab", &fts5Vocab, p, 0);
+}
+
+
+
+
+    
+#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS5) */
+
+/************** End of fts5.c ************************************************/
diff --git a/TMessagesProj/jni/sqlite/sqlite3.h b/TMessagesProj/jni/sqlite/sqlite3.h
index d3f272c2b..928b43077 100644
--- a/TMessagesProj/jni/sqlite/sqlite3.h
+++ b/TMessagesProj/jni/sqlite/sqlite3.h
@@ -31,7 +31,7 @@
 ** part of the build process.
 */
 #ifndef _SQLITE3_H_
-#define _SQLITE3_H_
+#define _SQLITE3_H_ 
 #include <stdarg.h>     /* Needed for the definition of va_list */
 
 /*
@@ -111,9 +111,9 @@ extern "C" {
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.8.11.1"
-#define SQLITE_VERSION_NUMBER 3008011
-#define SQLITE_SOURCE_ID      "2015-07-29 20:00:57 cf538e2783e468bbc25e7cb2a9ee64d3e0e80b2f"
+#define SQLITE_VERSION        "3.9.2"
+#define SQLITE_VERSION_NUMBER 3009002
+#define SQLITE_SOURCE_ID      "2015-11-02 18:31:45 bda77dda9697c463c3d0704014d51627fceee328"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -124,7 +124,7 @@ extern "C" {
 ** but are associated with the library instead of the header file.  ^(Cautious
 ** programmers might include assert() statements in their application to
 ** verify that values returned by these interfaces match the macros in
-** the header, and thus insure that the application is
+** the header, and thus ensure that the application is
 ** compiled with matching library and header files.
 **
 ** <blockquote><pre>
@@ -374,7 +374,7 @@ typedef int (*sqlite3_callback)(void*,int,char**, char**);
 ** Restrictions:
 **
 ** <ul>
-** <li> The application must insure that the 1st parameter to sqlite3_exec()
+** <li> The application must ensure that the 1st parameter to sqlite3_exec()
 **      is a valid and open [database connection].
 ** <li> The application must not close the [database connection] specified by
 **      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.
@@ -477,6 +477,7 @@ SQLITE_API int SQLITE_STDCALL sqlite3_exec(
 #define SQLITE_IOERR_MMAP              (SQLITE_IOERR | (24<<8))
 #define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25<<8))
 #define SQLITE_IOERR_CONVPATH          (SQLITE_IOERR | (26<<8))
+#define SQLITE_IOERR_VNODE             (SQLITE_IOERR | (27<<8))
 #define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1<<8))
 #define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1<<8))
 #define SQLITE_BUSY_SNAPSHOT           (SQLITE_BUSY   |  (2<<8))
@@ -1366,9 +1367,11 @@ SQLITE_API int SQLITE_STDCALL sqlite3_os_end(void);
 ** applications and so this routine is usually not necessary.  It is
 ** provided to support rare applications with unusual needs.
 **
-** The sqlite3_config() interface is not threadsafe.  The application
-** must insure that no other SQLite interfaces are invoked by other
-** threads while sqlite3_config() is running.  Furthermore, sqlite3_config()
+** <b>The sqlite3_config() interface is not threadsafe. The application
+** must ensure that no other SQLite interfaces are invoked by other
+** threads while sqlite3_config() is running.</b>
+**
+** The sqlite3_config() interface
 ** may only be invoked prior to library initialization using
 ** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].
 ** ^If sqlite3_config() is called after [sqlite3_initialize()] and before
@@ -3373,7 +3376,8 @@ SQLITE_API int SQLITE_STDCALL sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
 **
 ** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if the
 ** [prepared statement] S has been stepped at least once using 
-** [sqlite3_step(S)] but has not run to completion and/or has not 
+** [sqlite3_step(S)] but has neither run to completion (returned
+** [SQLITE_DONE] from [sqlite3_step(S)]) nor
 ** been reset using [sqlite3_reset(S)].  ^The sqlite3_stmt_busy(S)
 ** interface returns false if S is a NULL pointer.  If S is not a 
 ** NULL pointer and is not a pointer to a valid [prepared statement]
@@ -3626,7 +3630,7 @@ SQLITE_API const char *SQLITE_STDCALL sqlite3_bind_parameter_name(sqlite3_stmt*,
 **
 ** See also: [sqlite3_bind_blob|sqlite3_bind()],
 ** [sqlite3_bind_parameter_count()], and
-** [sqlite3_bind_parameter_index()].
+** [sqlite3_bind_parameter_name()].
 */
 SQLITE_API int SQLITE_STDCALL sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
 
@@ -4355,6 +4359,22 @@ SQLITE_API const void *SQLITE_STDCALL sqlite3_value_text16be(sqlite3_value*);
 SQLITE_API int SQLITE_STDCALL sqlite3_value_type(sqlite3_value*);
 SQLITE_API int SQLITE_STDCALL sqlite3_value_numeric_type(sqlite3_value*);
 
+/*
+** CAPI3REF: Finding The Subtype Of SQL Values
+** METHOD: sqlite3_value
+**
+** The sqlite3_value_subtype(V) function returns the subtype for
+** an [application-defined SQL function] argument V.  The subtype
+** information can be used to pass a limited amount of context from
+** one SQL function to another.  Use the [sqlite3_result_subtype()]
+** routine to set the subtype for the return value of an SQL function.
+**
+** SQLite makes no use of subtype itself.  It merely passes the subtype
+** from the result of one [application-defined SQL function] into the
+** input of another.
+*/
+SQLITE_API unsigned int SQLITE_STDCALL sqlite3_value_subtype(sqlite3_value*);
+
 /*
 ** CAPI3REF: Copy And Free SQL Values
 ** METHOD: sqlite3_value
@@ -4654,6 +4674,21 @@ SQLITE_API void SQLITE_STDCALL sqlite3_result_value(sqlite3_context*, sqlite3_va
 SQLITE_API void SQLITE_STDCALL sqlite3_result_zeroblob(sqlite3_context*, int n);
 SQLITE_API int SQLITE_STDCALL sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
 
+
+/*
+** CAPI3REF: Setting The Subtype Of An SQL Function
+** METHOD: sqlite3_context
+**
+** The sqlite3_result_subtype(C,T) function causes the subtype of
+** the result from the [application-defined SQL function] with 
+** [sqlite3_context] C to be the value T.  Only the lower 8 bits 
+** of the subtype T are preserved in current versions of SQLite;
+** higher order bits are discarded.
+** The number of subtype bytes preserved by SQLite might increase
+** in future releases of SQLite.
+*/
+SQLITE_API void SQLITE_STDCALL sqlite3_result_subtype(sqlite3_context*,unsigned int);
+
 /*
 ** CAPI3REF: Define New Collating Sequences
 ** METHOD: sqlite3
@@ -5599,13 +5634,31 @@ struct sqlite3_module {
 ** ^The estimatedRows value is an estimate of the number of rows that
 ** will be returned by the strategy.
 **
+** The xBestIndex method may optionally populate the idxFlags field with a 
+** mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
+** SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
+** assumes that the strategy may visit at most one row. 
+**
+** Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
+** SQLite also assumes that if a call to the xUpdate() method is made as
+** part of the same statement to delete or update a virtual table row and the
+** implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
+** any database changes. In other words, if the xUpdate() returns
+** SQLITE_CONSTRAINT, the database contents must be exactly as they were
+** before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
+** set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
+** the xUpdate method are automatically rolled back by SQLite.
+**
 ** IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
 ** structure for SQLite version 3.8.2. If a virtual table extension is
 ** used with an SQLite version earlier than 3.8.2, the results of attempting 
 ** to read or write the estimatedRows field are undefined (but are likely 
 ** to included crashing the application). The estimatedRows field should
 ** therefore only be used if [sqlite3_libversion_number()] returns a
-** value greater than or equal to 3008002.
+** value greater than or equal to 3008002. Similarly, the idxFlags field
+** was added for version 3.9.0. It may therefore only be used if
+** sqlite3_libversion_number() returns a value greater than or equal to
+** 3009000.
 */
 struct sqlite3_index_info {
   /* Inputs */
@@ -5633,8 +5686,15 @@ struct sqlite3_index_info {
   double estimatedCost;           /* Estimated cost of using this index */
   /* Fields below are only available in SQLite 3.8.2 and later */
   sqlite3_int64 estimatedRows;    /* Estimated number of rows returned */
+  /* Fields below are only available in SQLite 3.9.0 and later */
+  int idxFlags;              /* Mask of SQLITE_INDEX_SCAN_* flags */
 };
 
+/*
+** CAPI3REF: Virtual Table Scan Flags
+*/
+#define SQLITE_INDEX_SCAN_UNIQUE      1     /* Scan visits at most 1 row */
+
 /*
 ** CAPI3REF: Virtual Table Constraint Operator Codes
 **
@@ -6092,6 +6152,9 @@ SQLITE_API int SQLITE_STDCALL sqlite3_vfs_unregister(sqlite3_vfs*);
 ** <li>  SQLITE_MUTEX_STATIC_APP1
 ** <li>  SQLITE_MUTEX_STATIC_APP2
 ** <li>  SQLITE_MUTEX_STATIC_APP3
+** <li>  SQLITE_MUTEX_STATIC_VFS1
+** <li>  SQLITE_MUTEX_STATIC_VFS2
+** <li>  SQLITE_MUTEX_STATIC_VFS3
 ** </ul>
 **
 ** ^The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE)
@@ -7858,3 +7921,523 @@ struct sqlite3_rtree_query_info {
 
 #endif  /* ifndef _SQLITE3RTREE_H_ */
 
+/*
+** 2014 May 31
+**
+** The author disclaims copyright to this source code.  In place of
+** a legal notice, here is a blessing:
+**
+**    May you do good and not evil.
+**    May you find forgiveness for yourself and forgive others.
+**    May you share freely, never taking more than you give.
+**
+******************************************************************************
+**
+** Interfaces to extend FTS5. Using the interfaces defined in this file, 
+** FTS5 may be extended with:
+**
+**     * custom tokenizers, and
+**     * custom auxiliary functions.
+*/
+
+
+#ifndef _FTS5_H
+#define _FTS5_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*************************************************************************
+** CUSTOM AUXILIARY FUNCTIONS
+**
+** Virtual table implementations may overload SQL functions by implementing
+** the sqlite3_module.xFindFunction() method.
+*/
+
+typedef struct Fts5ExtensionApi Fts5ExtensionApi;
+typedef struct Fts5Context Fts5Context;
+typedef struct Fts5PhraseIter Fts5PhraseIter;
+
+typedef void (*fts5_extension_function)(
+  const Fts5ExtensionApi *pApi,   /* API offered by current FTS version */
+  Fts5Context *pFts,              /* First arg to pass to pApi functions */
+  sqlite3_context *pCtx,          /* Context for returning result/error */
+  int nVal,                       /* Number of values in apVal[] array */
+  sqlite3_value **apVal           /* Array of trailing arguments */
+);
+
+struct Fts5PhraseIter {
+  const unsigned char *a;
+  const unsigned char *b;
+};
+
+/*
+** EXTENSION API FUNCTIONS
+**
+** xUserData(pFts):
+**   Return a copy of the context pointer the extension function was 
+**   registered with.
+**
+** xColumnTotalSize(pFts, iCol, pnToken):
+**   If parameter iCol is less than zero, set output variable *pnToken
+**   to the total number of tokens in the FTS5 table. Or, if iCol is
+**   non-negative but less than the number of columns in the table, return
+**   the total number of tokens in column iCol, considering all rows in 
+**   the FTS5 table.
+**
+**   If parameter iCol is greater than or equal to the number of columns
+**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
+**   an OOM condition or IO error), an appropriate SQLite error code is 
+**   returned.
+**
+** xColumnCount(pFts):
+**   Return the number of columns in the table.
+**
+** xColumnSize(pFts, iCol, pnToken):
+**   If parameter iCol is less than zero, set output variable *pnToken
+**   to the total number of tokens in the current row. Or, if iCol is
+**   non-negative but less than the number of columns in the table, set
+**   *pnToken to the number of tokens in column iCol of the current row.
+**
+**   If parameter iCol is greater than or equal to the number of columns
+**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
+**   an OOM condition or IO error), an appropriate SQLite error code is 
+**   returned.
+**
+** xColumnText:
+**   This function attempts to retrieve the text of column iCol of the
+**   current document. If successful, (*pz) is set to point to a buffer
+**   containing the text in utf-8 encoding, (*pn) is set to the size in bytes
+**   (not characters) of the buffer and SQLITE_OK is returned. Otherwise,
+**   if an error occurs, an SQLite error code is returned and the final values
+**   of (*pz) and (*pn) are undefined.
+**
+** xPhraseCount:
+**   Returns the number of phrases in the current query expression.
+**
+** xPhraseSize:
+**   Returns the number of tokens in phrase iPhrase of the query. Phrases
+**   are numbered starting from zero.
+**
+** xInstCount:
+**   Set *pnInst to the total number of occurrences of all phrases within
+**   the query within the current row. Return SQLITE_OK if successful, or
+**   an error code (i.e. SQLITE_NOMEM) if an error occurs.
+**
+** xInst:
+**   Query for the details of phrase match iIdx within the current row.
+**   Phrase matches are numbered starting from zero, so the iIdx argument
+**   should be greater than or equal to zero and smaller than the value
+**   output by xInstCount().
+**
+**   Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) 
+**   if an error occurs.
+**
+** xRowid:
+**   Returns the rowid of the current row.
+**
+** xTokenize:
+**   Tokenize text using the tokenizer belonging to the FTS5 table.
+**
+** xQueryPhrase(pFts5, iPhrase, pUserData, xCallback):
+**   This API function is used to query the FTS table for phrase iPhrase
+**   of the current query. Specifically, a query equivalent to:
+**
+**       ... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid
+**
+**   with $p set to a phrase equivalent to the phrase iPhrase of the
+**   current query is executed. For each row visited, the callback function
+**   passed as the fourth argument is invoked. The context and API objects 
+**   passed to the callback function may be used to access the properties of
+**   each matched row. Invoking Api.xUserData() returns a copy of the pointer
+**   passed as the third argument to pUserData.
+**
+**   If the callback function returns any value other than SQLITE_OK, the
+**   query is abandoned and the xQueryPhrase function returns immediately.
+**   If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK.
+**   Otherwise, the error code is propagated upwards.
+**
+**   If the query runs to completion without incident, SQLITE_OK is returned.
+**   Or, if some error occurs before the query completes or is aborted by
+**   the callback, an SQLite error code is returned.
+**
+**
+** xSetAuxdata(pFts5, pAux, xDelete)
+**
+**   Save the pointer passed as the second argument as the extension functions 
+**   "auxiliary data". The pointer may then be retrieved by the current or any
+**   future invocation of the same fts5 extension function made as part of
+**   of the same MATCH query using the xGetAuxdata() API.
+**
+**   Each extension function is allocated a single auxiliary data slot for
+**   each FTS query (MATCH expression). If the extension function is invoked 
+**   more than once for a single FTS query, then all invocations share a 
+**   single auxiliary data context.
+**
+**   If there is already an auxiliary data pointer when this function is
+**   invoked, then it is replaced by the new pointer. If an xDelete callback
+**   was specified along with the original pointer, it is invoked at this
+**   point.
+**
+**   The xDelete callback, if one is specified, is also invoked on the
+**   auxiliary data pointer after the FTS5 query has finished.
+**
+**   If an error (e.g. an OOM condition) occurs within this function, an
+**   the auxiliary data is set to NULL and an error code returned. If the
+**   xDelete parameter was not NULL, it is invoked on the auxiliary data
+**   pointer before returning.
+**
+**
+** xGetAuxdata(pFts5, bClear)
+**
+**   Returns the current auxiliary data pointer for the fts5 extension 
+**   function. See the xSetAuxdata() method for details.
+**
+**   If the bClear argument is non-zero, then the auxiliary data is cleared
+**   (set to NULL) before this function returns. In this case the xDelete,
+**   if any, is not invoked.
+**
+**
+** xRowCount(pFts5, pnRow)
+**
+**   This function is used to retrieve the total number of rows in the table.
+**   In other words, the same value that would be returned by:
+**
+**        SELECT count(*) FROM ftstable;
+**
+** xPhraseFirst()
+**   This function is used, along with type Fts5PhraseIter and the xPhraseNext
+**   method, to iterate through all instances of a single query phrase within
+**   the current row. This is the same information as is accessible via the
+**   xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient
+**   to use, this API may be faster under some circumstances. To iterate 
+**   through instances of phrase iPhrase, use the following code:
+**
+**       Fts5PhraseIter iter;
+**       int iCol, iOff;
+**       for(pApi->xPhraseFirst(pFts, iPhrase, &iter, &iCol, &iOff);
+**           iOff>=0;
+**           pApi->xPhraseNext(pFts, &iter, &iCol, &iOff)
+**       ){
+**         // An instance of phrase iPhrase at offset iOff of column iCol
+**       }
+**
+**   The Fts5PhraseIter structure is defined above. Applications should not
+**   modify this structure directly - it should only be used as shown above
+**   with the xPhraseFirst() and xPhraseNext() API methods.
+**
+** xPhraseNext()
+**   See xPhraseFirst above.
+*/
+struct Fts5ExtensionApi {
+  int iVersion;                   /* Currently always set to 1 */
+
+  void *(*xUserData)(Fts5Context*);
+
+  int (*xColumnCount)(Fts5Context*);
+  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
+  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);
+
+  int (*xTokenize)(Fts5Context*, 
+    const char *pText, int nText, /* Text to tokenize */
+    void *pCtx,                   /* Context passed to xToken() */
+    int (*xToken)(void*, int, const char*, int, int, int)       /* Callback */
+  );
+
+  int (*xPhraseCount)(Fts5Context*);
+  int (*xPhraseSize)(Fts5Context*, int iPhrase);
+
+  int (*xInstCount)(Fts5Context*, int *pnInst);
+  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);
+
+  sqlite3_int64 (*xRowid)(Fts5Context*);
+  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
+  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);
+
+  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
+    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
+  );
+  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
+  void *(*xGetAuxdata)(Fts5Context*, int bClear);
+
+  void (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
+  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);
+};
+
+/* 
+** CUSTOM AUXILIARY FUNCTIONS
+*************************************************************************/
+
+/*************************************************************************
+** CUSTOM TOKENIZERS
+**
+** Applications may also register custom tokenizer types. A tokenizer 
+** is registered by providing fts5 with a populated instance of the 
+** following structure. All structure methods must be defined, setting
+** any member of the fts5_tokenizer struct to NULL leads to undefined
+** behaviour. The structure methods are expected to function as follows:
+**
+** xCreate:
+**   This function is used to allocate and inititalize a tokenizer instance.
+**   A tokenizer instance is required to actually tokenize text.
+**
+**   The first argument passed to this function is a copy of the (void*)
+**   pointer provided by the application when the fts5_tokenizer object
+**   was registered with FTS5 (the third argument to xCreateTokenizer()). 
+**   The second and third arguments are an array of nul-terminated strings
+**   containing the tokenizer arguments, if any, specified following the
+**   tokenizer name as part of the CREATE VIRTUAL TABLE statement used
+**   to create the FTS5 table.
+**
+**   The final argument is an output variable. If successful, (*ppOut) 
+**   should be set to point to the new tokenizer handle and SQLITE_OK
+**   returned. If an error occurs, some value other than SQLITE_OK should
+**   be returned. In this case, fts5 assumes that the final value of *ppOut 
+**   is undefined.
+**
+** xDelete:
+**   This function is invoked to delete a tokenizer handle previously
+**   allocated using xCreate(). Fts5 guarantees that this function will
+**   be invoked exactly once for each successful call to xCreate().
+**
+** xTokenize:
+**   This function is expected to tokenize the nText byte string indicated 
+**   by argument pText. pText may or may not be nul-terminated. The first
+**   argument passed to this function is a pointer to an Fts5Tokenizer object
+**   returned by an earlier call to xCreate().
+**
+**   The second argument indicates the reason that FTS5 is requesting
+**   tokenization of the supplied text. This is always one of the following
+**   four values:
+**
+**   <ul><li> <b>FTS5_TOKENIZE_DOCUMENT</b> - A document is being inserted into
+**            or removed from the FTS table. The tokenizer is being invoked to
+**            determine the set of tokens to add to (or delete from) the
+**            FTS index.
+**
+**       <li> <b>FTS5_TOKENIZE_QUERY</b> - A MATCH query is being executed 
+**            against the FTS index. The tokenizer is being called to tokenize 
+**            a bareword or quoted string specified as part of the query.
+**
+**       <li> <b>(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)</b> - Same as
+**            FTS5_TOKENIZE_QUERY, except that the bareword or quoted string is
+**            followed by a "*" character, indicating that the last token
+**            returned by the tokenizer will be treated as a token prefix.
+**
+**       <li> <b>FTS5_TOKENIZE_AUX</b> - The tokenizer is being invoked to 
+**            satisfy an fts5_api.xTokenize() request made by an auxiliary
+**            function. Or an fts5_api.xColumnSize() request made by the same
+**            on a columnsize=0 database.  
+**   </ul>
+**
+**   For each token in the input string, the supplied callback xToken() must
+**   be invoked. The first argument to it should be a copy of the pointer
+**   passed as the second argument to xTokenize(). The third and fourth
+**   arguments are a pointer to a buffer containing the token text, and the
+**   size of the token in bytes. The 4th and 5th arguments are the byte offsets
+**   of the first byte of and first byte immediately following the text from
+**   which the token is derived within the input.
+**
+**   The second argument passed to the xToken() callback ("tflags") should
+**   normally be set to 0. The exception is if the tokenizer supports 
+**   synonyms. In this case see the discussion below for details.
+**
+**   FTS5 assumes the xToken() callback is invoked for each token in the 
+**   order that they occur within the input text.
+**
+**   If an xToken() callback returns any value other than SQLITE_OK, then
+**   the tokenization should be abandoned and the xTokenize() method should
+**   immediately return a copy of the xToken() return value. Or, if the
+**   input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally,
+**   if an error occurs with the xTokenize() implementation itself, it
+**   may abandon the tokenization and return any error code other than
+**   SQLITE_OK or SQLITE_DONE.
+**
+** SYNONYM SUPPORT
+**
+**   Custom tokenizers may also support synonyms. Consider a case in which a
+**   user wishes to query for a phrase such as "first place". Using the 
+**   built-in tokenizers, the FTS5 query 'first + place' will match instances
+**   of "first place" within the document set, but not alternative forms
+**   such as "1st place". In some applications, it would be better to match
+**   all instances of "first place" or "1st place" regardless of which form
+**   the user specified in the MATCH query text.
+**
+**   There are several ways to approach this in FTS5:
+**
+**   <ol><li> By mapping all synonyms to a single token. In this case, the 
+**            In the above example, this means that the tokenizer returns the
+**            same token for inputs "first" and "1st". Say that token is in
+**            fact "first", so that when the user inserts the document "I won
+**            1st place" entries are added to the index for tokens "i", "won",
+**            "first" and "place". If the user then queries for '1st + place',
+**            the tokenizer substitutes "first" for "1st" and the query works
+**            as expected.
+**
+**       <li> By adding multiple synonyms for a single term to the FTS index.
+**            In this case, when tokenizing query text, the tokenizer may 
+**            provide multiple synonyms for a single term within the document.
+**            FTS5 then queries the index for each synonym individually. For
+**            example, faced with the query:
+**
+**   <codeblock>
+**     ... MATCH 'first place'</codeblock>
+**
+**            the tokenizer offers both "1st" and "first" as synonyms for the
+**            first token in the MATCH query and FTS5 effectively runs a query 
+**            similar to:
+**
+**   <codeblock>
+**     ... MATCH '(first OR 1st) place'</codeblock>
+**
+**            except that, for the purposes of auxiliary functions, the query
+**            still appears to contain just two phrases - "(first OR 1st)" 
+**            being treated as a single phrase.
+**
+**       <li> By adding multiple synonyms for a single term to the FTS index.
+**            Using this method, when tokenizing document text, the tokenizer
+**            provides multiple synonyms for each token. So that when a 
+**            document such as "I won first place" is tokenized, entries are
+**            added to the FTS index for "i", "won", "first", "1st" and
+**            "place".
+**
+**            This way, even if the tokenizer does not provide synonyms
+**            when tokenizing query text (it should not - to do would be
+**            inefficient), it doesn't matter if the user queries for 
+**            'first + place' or '1st + place', as there are entires in the
+**            FTS index corresponding to both forms of the first token.
+**   </ol>
+**
+**   Whether it is parsing document or query text, any call to xToken that
+**   specifies a <i>tflags</i> argument with the FTS5_TOKEN_COLOCATED bit
+**   is considered to supply a synonym for the previous token. For example,
+**   when parsing the document "I won first place", a tokenizer that supports
+**   synonyms would call xToken() 5 times, as follows:
+**
+**   <codeblock>
+**       xToken(pCtx, 0, "i",                      1,  0,  1);
+**       xToken(pCtx, 0, "won",                    3,  2,  5);
+**       xToken(pCtx, 0, "first",                  5,  6, 11);
+**       xToken(pCtx, FTS5_TOKEN_COLOCATED, "1st", 3,  6, 11);
+**       xToken(pCtx, 0, "place",                  5, 12, 17);
+**</codeblock>
+**
+**   It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time
+**   xToken() is called. Multiple synonyms may be specified for a single token
+**   by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. 
+**   There is no limit to the number of synonyms that may be provided for a
+**   single token.
+**
+**   In many cases, method (1) above is the best approach. It does not add 
+**   extra data to the FTS index or require FTS5 to query for multiple terms,
+**   so it is efficient in terms of disk space and query speed. However, it
+**   does not support prefix queries very well. If, as suggested above, the
+**   token "first" is subsituted for "1st" by the tokenizer, then the query:
+**
+**   <codeblock>
+**     ... MATCH '1s*'</codeblock>
+**
+**   will not match documents that contain the token "1st" (as the tokenizer
+**   will probably not map "1s" to any prefix of "first").
+**
+**   For full prefix support, method (3) may be preferred. In this case, 
+**   because the index contains entries for both "first" and "1st", prefix
+**   queries such as 'fi*' or '1s*' will match correctly. However, because
+**   extra entries are added to the FTS index, this method uses more space
+**   within the database.
+**
+**   Method (2) offers a midpoint between (1) and (3). Using this method,
+**   a query such as '1s*' will match documents that contain the literal 
+**   token "1st", but not "first" (assuming the tokenizer is not able to
+**   provide synonyms for prefixes). However, a non-prefix query like '1st'
+**   will match against "1st" and "first". This method does not require
+**   extra disk space, as no extra entries are added to the FTS index. 
+**   On the other hand, it may require more CPU cycles to run MATCH queries,
+**   as separate queries of the FTS index are required for each synonym.
+**
+**   When using methods (2) or (3), it is important that the tokenizer only
+**   provide synonyms when tokenizing document text (method (2)) or query
+**   text (method (3)), not both. Doing so will not cause any errors, but is
+**   inefficient.
+*/
+typedef struct Fts5Tokenizer Fts5Tokenizer;
+typedef struct fts5_tokenizer fts5_tokenizer;
+struct fts5_tokenizer {
+  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
+  void (*xDelete)(Fts5Tokenizer*);
+  int (*xTokenize)(Fts5Tokenizer*, 
+      void *pCtx,
+      int flags,            /* Mask of FTS5_TOKENIZE_* flags */
+      const char *pText, int nText, 
+      int (*xToken)(
+        void *pCtx,         /* Copy of 2nd argument to xTokenize() */
+        int tflags,         /* Mask of FTS5_TOKEN_* flags */
+        const char *pToken, /* Pointer to buffer containing token */
+        int nToken,         /* Size of token in bytes */
+        int iStart,         /* Byte offset of token within input text */
+        int iEnd            /* Byte offset of end of token within input text */
+      )
+  );
+};
+
+/* Flags that may be passed as the third argument to xTokenize() */
+#define FTS5_TOKENIZE_QUERY     0x0001
+#define FTS5_TOKENIZE_PREFIX    0x0002
+#define FTS5_TOKENIZE_DOCUMENT  0x0004
+#define FTS5_TOKENIZE_AUX       0x0008
+
+/* Flags that may be passed by the tokenizer implementation back to FTS5
+** as the third argument to the supplied xToken callback. */
+#define FTS5_TOKEN_COLOCATED    0x0001      /* Same position as prev. token */
+
+/*
+** END OF CUSTOM TOKENIZERS
+*************************************************************************/
+
+/*************************************************************************
+** FTS5 EXTENSION REGISTRATION API
+*/
+typedef struct fts5_api fts5_api;
+struct fts5_api {
+  int iVersion;                   /* Currently always set to 2 */
+
+  /* Create a new tokenizer */
+  int (*xCreateTokenizer)(
+    fts5_api *pApi,
+    const char *zName,
+    void *pContext,
+    fts5_tokenizer *pTokenizer,
+    void (*xDestroy)(void*)
+  );
+
+  /* Find an existing tokenizer */
+  int (*xFindTokenizer)(
+    fts5_api *pApi,
+    const char *zName,
+    void **ppContext,
+    fts5_tokenizer *pTokenizer
+  );
+
+  /* Create a new auxiliary function */
+  int (*xCreateFunction)(
+    fts5_api *pApi,
+    const char *zName,
+    void *pContext,
+    fts5_extension_function xFunction,
+    void (*xDestroy)(void*)
+  );
+};
+
+/*
+** END OF REGISTRATION API
+*************************************************************************/
+
+#ifdef __cplusplus
+}  /* end of the 'extern "C"' block */
+#endif
+
+#endif /* _FTS5_H */
+
+
diff --git a/TMessagesProj/jni/tgnet/Config.cpp b/TMessagesProj/jni/tgnet/Config.cpp
index 83e94be76..6da1995e6 100644
--- a/TMessagesProj/jni/tgnet/Config.cpp
+++ b/TMessagesProj/jni/tgnet/Config.cpp
@@ -6,6 +6,8 @@
  * Copyright Nikolai Kudashov, 2015.
  */
 
+#include <sys/stat.h>
+#include <unistd.h>
 #include "Config.h"
 #include "ConnectionsManager.h"
 #include "FileLog.h"
@@ -16,9 +18,10 @@ Config::Config(std::string fileName) {
     backupPath = configPath + ".bak";
     FILE *backup = fopen(backupPath.c_str(), "rb");
     if (backup != nullptr) {
+        DEBUG_D("Config(%p, %s) backup file found %s", this, configPath.c_str(), backupPath.c_str());
+        fclose(backup);
         remove(configPath.c_str());
         rename(backupPath.c_str(), configPath.c_str());
-        fclose(backup);
     }
 }
 
@@ -28,10 +31,14 @@ NativeByteBuffer *Config::readConfig() {
     if (file != nullptr) {
         fseek(file, 0, SEEK_END);
         long fileSize = ftell(file);
-        fseek(file, 0, SEEK_SET);
+        if (fseek(file, 0, SEEK_SET)) {
+            DEBUG_E("Config(%p, %s) failed fseek to begin, reopen it", this, configPath.c_str());
+            fclose(file);
+            file = fopen(configPath.c_str(), "rb");
+        }
         uint32_t size = 0;
         int bytesRead = fread(&size, sizeof(uint32_t), 1, file);
-        DEBUG_D("Config(%p, %s) load, size = %u", this, configPath.c_str(), size);
+        DEBUG_D("Config(%p, %s) load, size = %u, fileSize = %u", this, configPath.c_str(), size, (uint32_t) fileSize);
         if (bytesRead > 0 && size > 0 && (int32_t) size < fileSize) {
             buffer = BuffersStorage::getInstance().getFreeBuffer(size);
             if (fread(buffer->bytes(), sizeof(uint8_t), size, file) != size) {
@@ -45,6 +52,7 @@ NativeByteBuffer *Config::readConfig() {
 }
 
 void Config::writeConfig(NativeByteBuffer *buffer) {
+    DEBUG_D("Config(%p, %s) start write config", this, configPath.c_str());
     FILE *file = fopen(configPath.c_str(), "rb");
     FILE *backup = fopen(backupPath.c_str(), "rb");
     bool error = false;
@@ -65,21 +73,53 @@ void Config::writeConfig(NativeByteBuffer *buffer) {
         return;
     }
     file = fopen(configPath.c_str(), "wb");
+    if (chmod(configPath.c_str(), 0660)) {
+        DEBUG_E("Config(%p, %s) chmod failed", this, configPath.c_str());
+    }
     if (file == nullptr) {
+        DEBUG_E("Config(%p, %s) unable to open file for writing", this, configPath.c_str());
         return;
     }
     uint32_t size = buffer->position();
     if (fwrite(&size, sizeof(uint32_t), 1, file) == 1) {
         if (fwrite(buffer->bytes(), sizeof(uint8_t), size, file) != size) {
+            DEBUG_E("Config(%p, %s) failed to write config data to file", this, configPath.c_str());
             error = true;
         }
     } else {
+        DEBUG_E("Config(%p, %s) failed to write config size to file", this, configPath.c_str());
+        error = true;
+    }
+    if (fflush(file)) {
+        DEBUG_E("Config(%p, %s) fflush failed", this, configPath.c_str());
+        error = true;
+    }
+    int fd = fileno(file);
+    if (fd == -1) {
+        DEBUG_E("Config(%p, %s) fileno failed", this, configPath.c_str());
+        error = true;
+    } else {
+        DEBUG_D("Config(%p, %s) fileno = %d", this, configPath.c_str(), fd);
+    }
+    if (fd != -1 && fsync(fd) == -1) {
+        DEBUG_E("Config(%p, %s) fsync failed", this, configPath.c_str());
+        error = true;
+    }
+    if (fclose(file)) {
+        DEBUG_E("Config(%p, %s) fclose failed", this, configPath.c_str());
         error = true;
     }
-    fclose(file);
     if (error) {
-        remove(configPath.c_str());
+        DEBUG_E("Config(%p, %s) failed to write config", this, configPath.c_str());
+        if (remove(configPath.c_str())) {
+            DEBUG_E("Config(%p, %s) remove config failed", this, configPath.c_str());
+        }
     } else {
-        remove(backupPath.c_str());
+        if (remove(backupPath.c_str())) {
+            DEBUG_E("Config(%p, %s) remove backup failed failed", this, configPath.c_str());
+        }
+    }
+    if (!error) {
+        DEBUG_D("Config(%p, %s) config write ok", this, configPath.c_str());
     }
 }
diff --git a/TMessagesProj/jni/tgnet/Connection.cpp b/TMessagesProj/jni/tgnet/Connection.cpp
index cd6041462..16a544f25 100644
--- a/TMessagesProj/jni/tgnet/Connection.cpp
+++ b/TMessagesProj/jni/tgnet/Connection.cpp
@@ -266,7 +266,11 @@ void Connection::connect() {
         if (isTryingNextPort) {
             setTimeout(8);
         } else {
-            setTimeout(15);
+            if (connectionType == ConnectionTypeUpload) {
+                setTimeout(25);
+            } else {
+                setTimeout(15);
+            }
         }
     }
 }
diff --git a/TMessagesProj/jni/tgnet/ConnectionsManager.cpp b/TMessagesProj/jni/tgnet/ConnectionsManager.cpp
index 6825dee04..eed99950d 100644
--- a/TMessagesProj/jni/tgnet/ConnectionsManager.cpp
+++ b/TMessagesProj/jni/tgnet/ConnectionsManager.cpp
@@ -819,7 +819,9 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
 
             for (requestsIter iter = runningRequests.begin(); iter != runningRequests.end(); iter++) {
                 Request *request = iter->get();
-                if (request->messageId < response->first_msg_id && request->connectionType & connection->getConnectionType() && request->datacenterId == datacenter->getDatacenterId()) {
+                Datacenter *requestDatacenter = getDatacenterWithId(request->datacenterId);
+                if (request->messageId < response->first_msg_id && request->connectionType & connection->getConnectionType() && requestDatacenter != nullptr && requestDatacenter->getDatacenterId() == datacenter->getDatacenterId()) {
+                    DEBUG_D("clear request %p - %s", request->rawRequest, typeid(*request->rawRequest).name());
                     request->clear(true);
                 }
             }
@@ -908,8 +910,9 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
         RpcError *error = hasResult ? dynamic_cast<RpcError *>(response->result.get()) : nullptr;
         if (error != nullptr) {
             DEBUG_E("connection(%p, dc%u, type %d) rpc error %d: %s", connection, datacenter->getDatacenterId(), connection->getConnectionType(), error->error_code, error->error_message.c_str());
-            uint32_t migrateToDatacenterId = DEFAULT_DATACENTER_ID;
             if (error->error_code == 303) {
+                uint32_t migrateToDatacenterId = DEFAULT_DATACENTER_ID;
+                
                 static std::vector<std::string> migrateErrors;
                 if (migrateErrors.empty()) {
                     migrateErrors.push_back("NETWORK_MIGRATE_");
@@ -926,11 +929,11 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
                         migrateToDatacenterId = val;
                     }
                 }
-            }
-
-            if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {
-                ignoreResult = true;
-                moveToDatacenter(migrateToDatacenterId);
+                
+                if (migrateToDatacenterId != DEFAULT_DATACENTER_ID) {
+                    ignoreResult = true;
+                    moveToDatacenter(migrateToDatacenterId);
+                }
             }
         }
 
@@ -941,6 +944,7 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
             for (requestsIter iter = runningRequests.begin(); iter != runningRequests.end(); iter++) {
                 Request *request = iter->get();
                 if (request->respondsToMessageId(resultMid)) {
+                    DEBUG_D("got response for request %p - %s", request->rawRequest, typeid(*request->rawRequest).name());
                     bool discardResponse = false;
                     bool isError = false;
                     bool allowInitConnection = true;
@@ -950,7 +954,7 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
                         NativeByteBuffer *unpacked_data = nullptr;
                         TLObject *result = response->result.get();
                         if (typeid(*result) == typeid(TL_gzip_packed)) {
-                            TL_gzip_packed *innerResponse = (TL_gzip_packed *) response->result.get();
+                            TL_gzip_packed *innerResponse = (TL_gzip_packed *) result;
                             unpacked_data = decompressGZip(innerResponse->packed_data.get());
                             TLObject *object = TLdeserialize(request->rawRequest, unpacked_data->limit(), unpacked_data);
                             if (object != nullptr) {
@@ -963,16 +967,14 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
                         TL_error *error2 = hasResult ? dynamic_cast<TL_error *>(response->result.get()) : nullptr;
                         if (error != nullptr) {
                             allowInitConnection = false;
-                            DEBUG_E("rpc error %d: %s", error->error_code, error->error_message.c_str());
+                            DEBUG_E("request %p rpc error %d: %s", request, error->error_code, error->error_message.c_str());
 
-                            if (error->error_code == 500 || error->error_code < 0) {
-                                if (!(request->requestFlags & RequestFlagFailOnServerErrors)) {
-                                    request->serverFailureCount++;
+                            if ((request->requestFlags & RequestFlagFailOnServerErrors) == 0) {
+                                if (error->error_code == 500 || error->error_code < 0) {
                                     discardResponse = true;
-                                    request->minStartTime = request->startTime + request->serverFailureCount > 10 ? 10 : request->serverFailureCount;
-                                }
-                            } else if (error->error_code == 420) {
-                                if (!(request->requestFlags & RequestFlagFailOnServerErrors)) {
+                                    request->minStartTime = request->startTime + (request->serverFailureCount > 10 ? 10 : request->serverFailureCount);
+                                    request->serverFailureCount++;
+                                } else if (error->error_code == 420) {
                                     int32_t waitTime = 2;
                                     static std::string floodWait = "FLOOD_WAIT_";
                                     if (error->error_message.find(floodWait) != std::string::npos) {
@@ -984,14 +986,23 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
                                     }
 
                                     discardResponse = true;
-                                    request->failedByFloodWait = true;
+                                    request->failedByFloodWait = waitTime;
+                                    request->startTime = 0;
                                     request->minStartTime = (int32_t) (getCurrentTimeMillis() / 1000 + waitTime);
+                                } else if (error->error_code == 400) {
+                                    static std::string waitFailed = "MSG_WAIT_FAILED";
+                                    if (error->error_message.find(waitFailed) != std::string::npos) {
+                                        discardResponse = true;
+                                        request->minStartTime = (int32_t) (getCurrentTimeMillis() / 1000 + 1);
+                                        request->startTime = 0;
+                                    }
                                 }
                             }
-
-                            implicitError = new TL_error();
-                            implicitError->code = error->error_code;
-                            implicitError->text = error->error_message;
+                            if (!discardResponse) {
+                                implicitError = new TL_error();
+                                implicitError->code = error->error_code;
+                                implicitError->text = error->error_message;
+                            }
                         } else if (error2 == nullptr) {
                             if (request->rawRequest == nullptr || response->result == nullptr) {
                                 allowInitConnection = false;
@@ -1114,7 +1125,7 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
             int64_t time = (int64_t) (messageId / 4294967296.0 * 1000);
             int64_t currentTime = getCurrentTimeMillis();
             timeDifference = (int32_t) ((time - currentTime) / 1000 - currentPingTime / 2);
-            lastOutgoingMessageId = messageId > lastOutgoingMessageId ? messageId : lastOutgoingMessageId;
+            lastOutgoingMessageId = messageId > (lastOutgoingMessageId ? messageId : lastOutgoingMessageId);
         }
         int64_t resultMid = response->bad_msg_id;
         if (resultMid != 0) {
@@ -1123,10 +1134,10 @@ void ConnectionsManager::processServerResponse(TLObject *message, int64_t messag
                 if ((request->connectionType & ConnectionTypeDownload) == 0) {
                     continue;
                 }
-                if (request->respondsToMessageId(resultMid)) {
+                Datacenter *requestDatacenter = getDatacenterWithId(request->datacenterId);
+                if (requestDatacenter != nullptr && requestDatacenter->getDatacenterId() == datacenter->getDatacenterId()) {
                     request->retryCount = 0;
                     request->failedBySalt = true;
-                    break;
                 }
             }
         }
@@ -1363,12 +1374,6 @@ void ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete
 }
 
 #ifdef ANDROID
-int32_t ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, jobject ptr1, jobject ptr2) {
-    int32_t requestToken = lastRequestToken++;
-    sendRequest(object, onComplete, onQuickAck, flags, datacenterId, connetionType, immediate, requestToken, ptr1, ptr2);
-    return requestToken;
-}
-
 void ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, int32_t requestToken, jobject ptr1, jobject ptr2) {
     if (!currentUserId && !(flags & RequestFlagWithoutLogin)) {
         DEBUG_D("can't do request without login %s", typeid(*object).name());
@@ -1389,11 +1394,13 @@ void ConnectionsManager::sendRequest(TLObject *object, onCompleteFunc onComplete
         return;
     }
     scheduleTask([&, requestToken, object, onComplete, onQuickAck, flags, datacenterId, connetionType, immediate, ptr1, ptr2] {
+        DEBUG_D("send request %p - %s", object, typeid(*object).name());
         Request *request = new Request(requestToken, connetionType, flags, datacenterId, onComplete, onQuickAck);
         request->rawRequest = object;
         request->ptr1 = ptr1;
         request->ptr2 = ptr2;
         request->rpcRequest = wrapInLayer(object, getDatacenterWithId(datacenterId), request);
+        DEBUG_D("send request wrapped %p - %s", request->rpcRequest.get(), typeid(*request->rpcRequest.get()).name());
         requestsQueue.push_back(std::unique_ptr<Request>(request));
         if (immediate) {
             processRequestQueue(0, 0);
@@ -1486,7 +1493,7 @@ void ConnectionsManager::cancelRequestInternal(int32_t token, bool notifyServer,
         Request *request = iter->get();
         if (request->requestToken == token) {
             request->cancelled = true;
-            DEBUG_D("cancelled queued rpc request %s", typeid(*request->rawRequest).name());
+            DEBUG_D("cancelled queued rpc request %p - %s", request->rawRequest, typeid(*request->rawRequest).name());
             requestsQueue.erase(iter);
             if (removeFromClass) {
                 removeRequestFromGuid(token);
@@ -1504,7 +1511,7 @@ void ConnectionsManager::cancelRequestInternal(int32_t token, bool notifyServer,
                 sendRequest(dropAnswer, nullptr, nullptr, RequestFlagEnableUnauthorized | RequestFlagWithoutLogin | RequestFlagFailOnServerErrors, request->datacenterId, request->connectionType, true);
             }
             request->cancelled = true;
-            DEBUG_D("cancelled running rpc request %s", typeid(*request->rawRequest).name());
+            DEBUG_D("cancelled running rpc request %p - %s", request->rawRequest, typeid(*request->rawRequest).name());
             runningRequests.erase(iter);
             if (removeFromClass) {
                 removeRequestFromGuid(token);
@@ -1780,7 +1787,9 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
             continue;
         }
 
-        bool forceThisRequest = request->connectionType & connectionTypes && request->datacenterId == dc;
+        uint32_t requestConnectionType = request->connectionType & 0x0000ffff;
+        
+        bool forceThisRequest = (connectionTypes & requestConnectionType) && requestDatacenter->getDatacenterId() == dc;
 
         if (typeInfo == typeid(TL_get_future_salts) || typeInfo == typeid(TL_destroy_session)) {
             if (request->messageId != 0) {
@@ -1790,7 +1799,12 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
             forceThisRequest = false;
         }
 
-        if (((abs(currentTime - request->startTime) > maxTimeout) && (currentTime > request->minStartTime || abs(currentTime - request->minStartTime) > 60)) || forceThisRequest) {
+        if (forceThisRequest || (abs(currentTime - request->startTime) > maxTimeout &&
+                                 (currentTime >= request->minStartTime ||
+                                  (request->failedByFloodWait != 0 && (request->minStartTime - currentTime) > request->failedByFloodWait) ||
+                                  (request->failedByFloodWait == 0 && abs(currentTime - request->minStartTime) >= 60))
+                                 )
+            ) {
             if (!forceThisRequest && request->connectionToken > 0) {
                 if (request->connectionType & ConnectionTypeGeneric && request->connectionToken == connection->getConnectionToken()) {
                     DEBUG_D("request token is valid, not retrying %s", typeInfo.name());
@@ -1811,25 +1825,29 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
 
             request->retryCount++;
 
-            if (!request->failedBySalt && request->connectionType & ConnectionTypeDownload) {
-                uint32_t retryMax = 10;
-                if (!(request->requestFlags & RequestFlagForceDownload)) {
-                    if (request->failedByFloodWait) {
-                        retryMax = 1;
-                    } else {
-                        retryMax = 6;
+            if (!request->failedBySalt) {
+                if (request->connectionType & ConnectionTypeDownload) {
+                    uint32_t retryMax = 10;
+                    if (!(request->requestFlags & RequestFlagForceDownload)) {
+                        if (request->failedByFloodWait) {
+                            retryMax = 1;
+                        } else {
+                            retryMax = 6;
+                        }
+                    }
+                    if (request->retryCount >= retryMax) {
+                        DEBUG_E("timed out %s", typeInfo.name());
+                        TL_error *error = new TL_error();
+                        error->code = -123;
+                        error->text = "RETRY_LIMIT";
+                        request->onComplete(nullptr, error);
+                        delete error;
+                        iter = runningRequests.erase(iter);
+                        continue;
                     }
                 }
-                if (request->retryCount >= retryMax) {
-                    DEBUG_E("timed out %s", typeInfo.name());
-                    TL_error *error = new TL_error();
-                    error->code = -123;
-                    error->text = "RETRY_LIMIT";
-                    request->onComplete(nullptr, error);
-                    delete error;
-                    iter = runningRequests.erase(iter);
-                    continue;
-                }
+            } else {
+                request->failedBySalt = false;
             }
 
             if (request->messageSeqNo == 0) {
@@ -1849,7 +1867,7 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
             networkMessage->needQuickAck = (request->requestFlags & RequestFlagNeedQuickAck) != 0;
 
             request->connectionToken = connection->getConnectionToken();
-            switch (request->connectionType & 0x0000ffff) {
+            switch (requestConnectionType) {
                 case ConnectionTypeGeneric:
                     addMessageToDatacenter(requestDatacenter->getDatacenterId(), networkMessage, genericMessagesToDatacenters);
                     break;
@@ -2098,9 +2116,11 @@ void ConnectionsManager::processRequestQueue(uint32_t connectionTypes, uint32_t
                         TL_invokeAfterMsg *request = new TL_invokeAfterMsg();
                         request->msg_id = lastSentMessageRpcId;
                         if (message->outgoingBody != nullptr) {
+                            DEBUG_D("wrap outgoingBody(%p, %s) to TL_invokeAfterMsg", message->outgoingBody, typeid(*message->outgoingBody).name());
                             request->outgoingQuery = message->outgoingBody;
                             message->outgoingBody = nullptr;
                         } else {
+                            DEBUG_D("wrap body(%p, %s) to TL_invokeAfterMsg", message->body.get(), typeid(*message->body.get()).name());
                             request->query = std::move(message->body);
                         }
                         message->body = std::unique_ptr<TLObject>(request);
@@ -2369,7 +2389,7 @@ void ConnectionsManager::setDelegate(ConnectiosManagerDelegate *connectiosManage
     delegate = connectiosManagerDelegate;
 }
 
-void ConnectionsManager::init(uint32_t version, int32_t layer, int32_t apiId, std::string deviceModel, std::string systemVersion, std::string appVersion, std::string langCode, std::string configPath, int32_t userId, bool isPaused) {
+void ConnectionsManager::init(uint32_t version, int32_t layer, int32_t apiId, std::string deviceModel, std::string systemVersion, std::string appVersion, std::string langCode, std::string configPath, std::string logPath, int32_t userId, bool isPaused) {
     currentVersion = version;
     currentLayer = layer;
     currentApiId = apiId;
@@ -2379,6 +2399,7 @@ void ConnectionsManager::init(uint32_t version, int32_t layer, int32_t apiId, st
     currentAppVersion = appVersion;
     currentLangCode = langCode;
     currentUserId = userId;
+    currentLogPath = logPath;
     if (isPaused) {
         lastPauseTime = getCurrentTimeMillis();
     }
@@ -2386,6 +2407,10 @@ void ConnectionsManager::init(uint32_t version, int32_t layer, int32_t apiId, st
     if (!currentConfigPath.empty() && currentConfigPath.find_last_of('/') != currentConfigPath.size() - 1) {
         currentConfigPath += "/";
     }
+    
+    if (!logPath.empty()) {
+        FileLog::init(logPath);
+    }
 
     loadConfig();
 
diff --git a/TMessagesProj/jni/tgnet/ConnectionsManager.h b/TMessagesProj/jni/tgnet/ConnectionsManager.h
index 32f9476ec..d389cb32f 100644
--- a/TMessagesProj/jni/tgnet/ConnectionsManager.h
+++ b/TMessagesProj/jni/tgnet/ConnectionsManager.h
@@ -14,6 +14,7 @@
 #include <functional>
 #include <sys/epoll.h>
 #include <map>
+#include <atomic>
 #include <bits/unique_ptr.h>
 #include "Defines.h"
 
@@ -59,11 +60,10 @@ class ConnectionsManager {
     void pauseNetwork();
     void setNetworkAvailable(bool value);
     void setUseIpv6(bool value);
-    void init(uint32_t version, int32_t layer, int32_t apiId, std::string deviceModel, std::string systemVersion, std::string appVersion, std::string langCode, std::string configPath, int32_t userId, bool isPaused);
+    void init(uint32_t version, int32_t layer, int32_t apiId, std::string deviceModel, std::string systemVersion, std::string appVersion, std::string langCode, std::string configPath, std::string logPath, int32_t userId, bool isPaused);
     void updateDcSettings(uint32_t datacenterId);
 
 #ifdef ANDROID
-    int32_t sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, jobject ptr1, jobject ptr2);
     void sendRequest(TLObject *object, onCompleteFunc onComplete, onQuickAckFunc onQuickAck, uint32_t flags, uint32_t datacenterId, ConnectionType connetionType, bool immediate, int32_t requestToken, jobject ptr1, jobject ptr2);
     static void useJavaVM(JavaVM *vm, bool useJavaByteBuffers);
 #endif
@@ -120,7 +120,7 @@ class ConnectionsManager {
     std::map<int32_t, std::vector<std::int32_t>> quickAckIdToRequestIds;
     int32_t pingTime;
     bool testBackend = false;
-    volatile uint32_t lastRequestToken = 1;
+    std::atomic<uint32_t> lastRequestToken{1};
     uint32_t currentDatacenterId = 0;
     uint32_t movingToDatacenterId = DEFAULT_DATACENTER_ID;
     int64_t pushSessionId = 0;
@@ -169,6 +169,7 @@ class ConnectionsManager {
     std::string currentAppVersion;
     std::string currentLangCode;
     std::string currentConfigPath;
+    std::string currentLogPath;
     int32_t currentUserId = 0;
     bool registeredForInternalPush = false;
 
diff --git a/TMessagesProj/jni/tgnet/Datacenter.cpp b/TMessagesProj/jni/tgnet/Datacenter.cpp
index 5dd14406c..d5256199f 100644
--- a/TMessagesProj/jni/tgnet/Datacenter.cpp
+++ b/TMessagesProj/jni/tgnet/Datacenter.cpp
@@ -37,7 +37,7 @@ Datacenter::Datacenter(uint32_t id) {
 
 Datacenter::Datacenter(NativeByteBuffer *data) {
     for (uint32_t a = 0; a < DOWNLOAD_CONNECTIONS_COUNT; a++) {
-        downloadConnections[a] = nullptr;
+        downloadConnections[a] = nullptr; 
     }
     uint32_t currentVersion = data->readUint32(nullptr);
     if (currentVersion >= 2 && currentVersion <= 5) {
@@ -668,9 +668,7 @@ void Datacenter::onHandshakeConnectionConnected(Connection *connection) {
     if (handshakeState == 0 || !needResendData) {
         return;
     }
-    if (handshakeRequest != nullptr) {
-        sendRequestData(handshakeRequest, true);
-    }
+    beginHandshake(false);
 }
 
 inline uint64_t gcd(uint64_t a, uint64_t b) {
@@ -1377,12 +1375,13 @@ NativeByteBuffer *Datacenter::createRequestsData(std::vector<std::unique_ptr<Net
         } else {
             messageBody = networkMessage->message->body.get();
         }
-        DEBUG_D("connection(%p, dc%u, type %d) send message (session: 0x%llx, seqno: %d, messageid: 0x%llx): %s", connection, datacenterId, connection->getConnectionType(), (uint64_t) connection->getSissionId(), networkMessage->message->seqno, (uint64_t) networkMessage->message->msg_id, typeid(*messageBody).name());
+        DEBUG_D("connection(%p, dc%u, type %d) send message (session: 0x%llx, seqno: %d, messageid: 0x%llx): %s(%p)", connection, datacenterId, connection->getConnectionType(), (uint64_t) connection->getSissionId(), networkMessage->message->seqno, (uint64_t) networkMessage->message->msg_id, typeid(*messageBody).name(), messageBody);
 
         int64_t messageTime = (int64_t) (networkMessage->message->msg_id / 4294967296.0 * 1000);
         int64_t currentTime = ConnectionsManager::getInstance().getCurrentTimeMillis() + (int64_t) timeDifference * 1000;
 
         if (messageTime < currentTime - 30000 || messageTime > currentTime + 25000) {
+            DEBUG_D("wrap message in container");
             TL_msg_container *messageContainer = new TL_msg_container();
             messageContainer->messages.push_back(std::move(networkMessage->message));
 
@@ -1395,6 +1394,7 @@ NativeByteBuffer *Datacenter::createRequestsData(std::vector<std::unique_ptr<Net
             messageSeqNo = networkMessage->message->seqno;
         }
     } else {
+        DEBUG_D("start write messages to container");
         TL_msg_container *messageContainer = new TL_msg_container();
         size_t count = requests.size();
         for (uint32_t a = 0; a < count; a++) {
@@ -1404,7 +1404,7 @@ NativeByteBuffer *Datacenter::createRequestsData(std::vector<std::unique_ptr<Net
             } else {
                 messageBody = networkMessage->message->body.get();
             }
-            DEBUG_D("connection(%p, dc%u, type %d) send message (session: 0x%llx, seqno: %d, messageid: 0x%llx): %s", connection, datacenterId, connection->getConnectionType(), (uint64_t) connection->getSissionId(), networkMessage->message->seqno, (uint64_t) networkMessage->message->msg_id, typeid(*messageBody).name());
+            DEBUG_D("connection(%p, dc%u, type %d) send message (session: 0x%llx, seqno: %d, messageid: 0x%llx): %s(%p)", connection, datacenterId, connection->getConnectionType(), (uint64_t) connection->getSissionId(), networkMessage->message->seqno, (uint64_t) networkMessage->message->msg_id, typeid(*messageBody).name(), messageBody);
             messageContainer->messages.push_back(std::unique_ptr<TL_message>(std::move(networkMessage->message)));
         }
         messageId = ConnectionsManager::getInstance().generateMessageId();
diff --git a/TMessagesProj/jni/tgnet/FileLog.cpp b/TMessagesProj/jni/tgnet/FileLog.cpp
index 2827986f9..044a1dc85 100644
--- a/TMessagesProj/jni/tgnet/FileLog.cpp
+++ b/TMessagesProj/jni/tgnet/FileLog.cpp
@@ -8,50 +8,86 @@
 
 #include <stdio.h>
 #include <stdarg.h>
+#include <time.h>
 #include "FileLog.h"
 
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
+FILE *logFile = nullptr;
+
+void FileLog::init(std::string path) {
+    if (path.size() > 0) {
+        logFile = fopen(path.c_str(), "w");
+    }
+}
+
 void FileLog::e(const char *message, ...) {
     va_list argptr;
     va_start(argptr, message);
+    time_t t = time(0);
+    struct tm *now = localtime(&t);
 #ifdef ANDROID
     __android_log_vprint(ANDROID_LOG_ERROR, "tgnet", message, argptr);
 #else
-    printf("error: ");
+    printf("%d-%d %02d:%02d:%02d error: ", now->tm_mon + 1, now->tm_mday, now->tm_hour, now->tm_min, now->tm_sec);
     vprintf(message, argptr);
     printf("\n");
     fflush(stdout);
 #endif
+    if (logFile) {
+        fprintf(logFile, "%d-%d %02d:%02d:%02d error: ", now->tm_mon + 1, now->tm_mday, now->tm_hour, now->tm_min, now->tm_sec);
+        vfprintf(logFile, message, argptr);
+        fprintf(logFile, "\n");
+        fflush(logFile);
+    }
+    
     va_end(argptr);
 }
 
 void FileLog::w(const char *message, ...) {
     va_list argptr;
     va_start(argptr, message);
+    time_t t = time(0);
+    struct tm *now = localtime(&t);
 #ifdef ANDROID
     __android_log_vprint(ANDROID_LOG_WARN, "tgnet", message, argptr);
 #else
-    printf("warning: ");
+    printf("%d-%d %02d:%02d:%02d warning: ", now->tm_mon + 1, now->tm_mday, now->tm_hour, now->tm_min, now->tm_sec);
     vprintf(message, argptr);
     printf("\n");
     fflush(stdout);
 #endif
+    if (logFile) {
+        fprintf(logFile, "%d-%d %02d:%02d:%02d warning: ", now->tm_mon + 1, now->tm_mday, now->tm_hour, now->tm_min, now->tm_sec);
+        vfprintf(logFile, message, argptr);
+        fprintf(logFile, "\n");
+        fflush(logFile);
+    }
+    
     va_end(argptr);
 }
 
 void FileLog::d(const char *message, ...) {
     va_list argptr;
     va_start(argptr, message);
+    time_t t = time(0);
+    struct tm *now = localtime(&t);
 #ifdef ANDROID
     __android_log_vprint(ANDROID_LOG_DEBUG, "tgnet", message, argptr);
 #else
-    printf("debug: ");
+    printf("%d-%d %02d:%02d:%02d debug: ", now->tm_mon + 1, now->tm_mday, now->tm_hour, now->tm_min, now->tm_sec);
     vprintf(message, argptr);
     printf("\n");
     fflush(stdout);
 #endif
+    if (logFile) {
+        fprintf(logFile, "%d-%d %02d:%02d:%02d debug: ", now->tm_mon + 1, now->tm_mday, now->tm_hour, now->tm_min, now->tm_sec);
+        vfprintf(logFile, message, argptr);
+        fprintf(logFile, "\n");
+        fflush(logFile);
+    }
+    
     va_end(argptr);
 }
diff --git a/TMessagesProj/jni/tgnet/FileLog.h b/TMessagesProj/jni/tgnet/FileLog.h
index 664593459..7cf8ce34c 100644
--- a/TMessagesProj/jni/tgnet/FileLog.h
+++ b/TMessagesProj/jni/tgnet/FileLog.h
@@ -13,6 +13,7 @@
 
 class FileLog {
 public:
+    static void init(std::string path);
     static void e(const char *message, ...) __attribute__((format (printf, 1, 2)));
     static void w(const char *message, ...) __attribute__((format (printf, 1, 2)));
     static void d(const char *message, ...) __attribute__((format (printf, 1, 2)));
diff --git a/TMessagesProj/jni/tgnet/MTProtoScheme.cpp b/TMessagesProj/jni/tgnet/MTProtoScheme.cpp
index 45a9448e8..968fd02a0 100644
--- a/TMessagesProj/jni/tgnet/MTProtoScheme.cpp
+++ b/TMessagesProj/jni/tgnet/MTProtoScheme.cpp
@@ -931,7 +931,7 @@ void TL_config::readParams(NativeByteBuffer *stream, bool &error) {
         dc_options.push_back(std::unique_ptr<TL_dcOption>(object));
     }
     chat_size_max = stream->readInt32(&error);
-    broadcast_size_max = stream->readInt32(&error);
+    megagroup_size_max = stream->readInt32(&error);
     forwarded_count_max = stream->readInt32(&error);
     online_update_period_ms = stream->readInt32(&error);
     offline_blur_timeout_ms = stream->readInt32(&error);
@@ -971,7 +971,7 @@ void TL_config::serializeToStream(NativeByteBuffer *stream) {
         dc_options[a]->serializeToStream(stream);
     }
     stream->writeInt32(chat_size_max);
-    stream->writeInt32(broadcast_size_max);
+    stream->writeInt32(megagroup_size_max);
     stream->writeInt32(forwarded_count_max);
     stream->writeInt32(online_update_period_ms);
     stream->writeInt32(offline_blur_timeout_ms);
diff --git a/TMessagesProj/jni/tgnet/MTProtoScheme.h b/TMessagesProj/jni/tgnet/MTProtoScheme.h
index ba07b77fd..baf35ee08 100644
--- a/TMessagesProj/jni/tgnet/MTProtoScheme.h
+++ b/TMessagesProj/jni/tgnet/MTProtoScheme.h
@@ -657,7 +657,7 @@ class TL_disabledFeature : public TLObject {
 class TL_config : public TLObject {
 
 public:
-    static const uint32_t constructor = 0x4e32b894;
+    static const uint32_t constructor = 0x6cb6e65e;
 
     int32_t date;
     int32_t expires;
@@ -665,7 +665,7 @@ class TL_config : public TLObject {
     int32_t this_dc;
     std::vector<std::unique_ptr<TL_dcOption>> dc_options;
     int32_t chat_size_max;
-    int32_t broadcast_size_max;
+    int32_t megagroup_size_max;
     int32_t forwarded_count_max;
     int32_t online_update_period_ms;
     int32_t offline_blur_timeout_ms;
diff --git a/TMessagesProj/jni/tgnet/Request.h b/TMessagesProj/jni/tgnet/Request.h
index afd88b671..5ab9a0930 100644
--- a/TMessagesProj/jni/tgnet/Request.h
+++ b/TMessagesProj/jni/tgnet/Request.h
@@ -34,7 +34,7 @@ class Request {
     int32_t requestToken;
     uint32_t retryCount = 0;
     bool failedBySalt = false;
-    bool failedByFloodWait = false;
+    int32_t failedByFloodWait = 0;
     ConnectionType connectionType;
     uint32_t requestFlags;
     bool completed = false;
diff --git a/TMessagesProj/libs/armeabi-v7a/libtmessages.12.so b/TMessagesProj/libs/armeabi-v7a/libtmessages.15.so
similarity index 53%
rename from TMessagesProj/libs/armeabi-v7a/libtmessages.12.so
rename to TMessagesProj/libs/armeabi-v7a/libtmessages.15.so
index 5eeeff5ce..db018dbe6 100755
Binary files a/TMessagesProj/libs/armeabi-v7a/libtmessages.12.so and b/TMessagesProj/libs/armeabi-v7a/libtmessages.15.so differ
diff --git a/TMessagesProj/libs/armeabi/libtmessages.12.so b/TMessagesProj/libs/armeabi/libtmessages.12.so
deleted file mode 100755
index d08b9a714..000000000
Binary files a/TMessagesProj/libs/armeabi/libtmessages.12.so and /dev/null differ
diff --git a/TMessagesProj/libs/armeabi/libtmessages.15.so b/TMessagesProj/libs/armeabi/libtmessages.15.so
new file mode 100755
index 000000000..a03c82b13
Binary files /dev/null and b/TMessagesProj/libs/armeabi/libtmessages.15.so differ
diff --git a/TMessagesProj/libs/x86/libtmessages.12.so b/TMessagesProj/libs/x86/libtmessages.12.so
deleted file mode 100755
index 55b0bc44a..000000000
Binary files a/TMessagesProj/libs/x86/libtmessages.12.so and /dev/null differ
diff --git a/TMessagesProj/libs/x86/libtmessages.15.so b/TMessagesProj/libs/x86/libtmessages.15.so
new file mode 100755
index 000000000..a669d14bf
Binary files /dev/null and b/TMessagesProj/libs/x86/libtmessages.15.so differ
diff --git a/TMessagesProj/src/main/AndroidManifest.xml b/TMessagesProj/src/main/AndroidManifest.xml
index bd5b61a8e..74e63fcda 100644
--- a/TMessagesProj/src/main/AndroidManifest.xml
+++ b/TMessagesProj/src/main/AndroidManifest.xml
@@ -12,8 +12,6 @@
 
     <uses-feature android:glEsVersion="0x00020000" android:required="false"/>
     <uses-feature android:name="android.hardware.telephony" android:required="false" />
-    <uses-feature android:name="android.hardware.camera.autofocus" android:required="false" />
-    <uses-feature android:name="android.hardware.camera" android:required="false" />
     <uses-feature android:name="android.hardware.wifi" android:required="false" />
     <uses-feature android:name="android.hardware.screen.PORTRAIT" android:required="false" />
     <uses-feature android:name="android.hardware.microphone" android:required="false" />
@@ -26,7 +24,6 @@
     <uses-permission android:name="android.permission.WAKE_LOCK" />
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
-    <uses-permission android:name="android.permission.CAMERA" />
     <uses-permission android:name="android.permission.GET_ACCOUNTS" />
     <uses-permission android:name="android.permission.READ_CONTACTS" />
     <uses-permission android:name="android.permission.WRITE_CONTACTS" />
@@ -39,15 +36,16 @@
     <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
     <uses-permission android:name="android.permission.READ_PHONE_STATE" />
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
+    <uses-permission android:name="android.permission.USE_FINGERPRINT" />
 
     <application
         android:name=".ApplicationLoader"
         android:allowBackup="false"
         android:hardwareAccelerated="@bool/useHardwareAcceleration"
         android:icon="@drawable/ic_launcher"
-        android:label="@string/AppName"
         android:largeHeap="true"
-        android:theme="@style/Theme.TMessages.Start">
+        android:theme="@style/Theme.TMessages.Start"
+        android:manageSpaceActivity="org.telegram.ui.ManageSpaceActivity">
 
         <activity
             android:name="org.telegram.ui.LaunchActivity"
@@ -108,6 +106,14 @@
                 <category android:name="android.intent.category.DEFAULT" />
                 <data android:scheme="tg" />
             </intent-filter>
+            <meta-data android:name="android.service.chooser.chooser_target_service" android:value=".TgChooserTargetService" />
+        </activity>
+        <activity
+            android:name="org.telegram.ui.ManageSpaceActivity"
+            android:configChanges="keyboard|keyboardHidden|orientation|screenSize"
+            android:hardwareAccelerated="@bool/useHardwareAcceleration"
+            android:launchMode="singleTask"
+            android:windowSoftInputMode="adjustPan">
         </activity>
         <activity
             android:name="org.telegram.ui.IntroActivity"
@@ -159,8 +165,18 @@
                 android:resource="@xml/contacts" />
         </service>
 
+        <service
+            android:name="org.telegram.messenger.TgChooserTargetService"
+            android:label="@string/AppName"
+            android:permission="android.permission.BIND_CHOOSER_TARGET_SERVICE">
+            <intent-filter>
+                <action android:name="android.service.chooser.ChooserTargetService" />
+            </intent-filter>
+        </service>
+
         <service android:name=".NotificationsService" android:enabled="true"/>
         <service android:name=".NotificationRepeat" android:exported="false"/>
+        <service android:name=".ClearCacheService" android:exported="false"/>
         <service android:name=".VideoEncodingService" android:enabled="true"/>
         <service android:name=".MusicPlayerService" android:exported="true" android:enabled="true"/>
 
diff --git a/TMessagesProj/src/main/assets/countries.txt b/TMessagesProj/src/main/assets/countries.txt
index c336d0620..8d21851c5 100644
--- a/TMessagesProj/src/main/assets/countries.txt
+++ b/TMessagesProj/src/main/assets/countries.txt
@@ -1,53 +1,53 @@
-1876;JM;Jamaica
-1869;KN;Saint Kitts & Nevis
-1868;TT;Trinidad & Tobago
-1784;VC;Saint Vincent & the Grenadines
-1767;DM;Dominica
-1758;LC;Saint Lucia
-1721;SX;Sint Maarten
-1684;AS;American Samoa
-1671;GU;Guam
-1670;MP;Northern Mariana Islands
-1664;MS;Montserrat
-1649;TC;Turks & Caicos Islands
-1473;GD;Grenada
-1441;BM;Bermuda
-1345;KY;Cayman Islands
-1340;VI;US Virgin Islands
-1284;VG;British Virgin Islands
-1268;AG;Antigua & Barbuda
-1264;AI;Anguilla
-1246;BB;Barbados
-1242;BS;Bahamas
-998;UZ;Uzbekistan
-996;KG;Kyrgyzstan
-995;GE;Georgia
-994;AZ;Azerbaijan
-993;TM;Turkmenistan
-992;TJ;Tajikistan
-977;NP;Nepal
-976;MN;Mongolia
-975;BT;Bhutan
-974;QA;Qatar
-973;BH;Bahrain
-972;IL;Israel
-971;AE;United Arab Emirates
-970;PS;Palestine
-968;OM;Oman
-967;YE;Yemen
-966;SA;Saudi Arabia
-965;KW;Kuwait
-964;IQ;Iraq
-963;SY;Syrian Arab Republic
-962;JO;Jordan
+1876;JM;Jamaica;XXX XXXX
+1869;KN;Saint Kitts & Nevis;XXX XXXX
+1868;TT;Trinidad & Tobago;XXX XXXX
+1784;VC;Saint Vincent & the Grenadines;XXX XXXX
+1767;DM;Dominica;XXX XXXX
+1758;LC;Saint Lucia;XXX XXXX
+1721;SX;Sint Maarten;XXX XXXX
+1684;AS;American Samoa;XXX XXXX
+1671;GU;Guam;XXX XXXX
+1670;MP;Northern Mariana Islands;XXX XXXX
+1664;MS;Montserrat;XXX XXXX
+1649;TC;Turks & Caicos Islands;XXX XXXX
+1473;GD;Grenada;XXX XXXX
+1441;BM;Bermuda;XXX XXXX
+1345;KY;Cayman Islands;XXX XXXX
+1340;VI;US Virgin Islands;XXX XXXX
+1284;VG;British Virgin Islands;XXX XXXX
+1268;AG;Antigua & Barbuda;XXX XXXX
+1264;AI;Anguilla;XXX XXXX
+1246;BB;Barbados;XXX XXXX
+1242;BS;Bahamas;XXX XXXX
+998;UZ;Uzbekistan;XX XXXXXXX
+996;KG;Kyrgyzstan;XXX XXXXXX
+995;GE;Georgia;XXX XXX XXX
+994;AZ;Azerbaijan;XX XXX XXXX
+993;TM;Turkmenistan;XX XXXXXX
+992;TJ;Tajikistan;XX XXX XXXX
+977;NP;Nepal;XX XXXX XXXX
+976;MN;Mongolia;XX XX XXXX
+975;BT;Bhutan;XX XXX XXX
+974;QA;Qatar;XX XXX XXX
+973;BH;Bahrain;XXXX XXXX
+972;IL;Israel;XX XXX XXXX
+971;AE;United Arab Emirates;XX XXX XXXX
+970;PS;Palestine;XXX XX XXXX
+968;OM;Oman;XXXX XXXX
+967;YE;Yemen;XXX XXX XXX
+966;SA;Saudi Arabia;XX XXX XXXX
+965;KW;Kuwait;XXXX XXXX
+964;IQ;Iraq;XXX XXX XXXX
+963;SY;Syria;XXX XXX XXX
+962;JO;Jordan;X XXXX XXXX
 961;LB;Lebanon
-960;MV;Maldives
-886;TW;Taiwan
+960;MV;Maldives;XXX XXXX
+886;TW;Taiwan;XXX XXX XXX
 880;BD;Bangladesh
-856;LA;Laos
+856;LA;Laos;XX XX XXX XXX
 855;KH;Cambodia
-853;MO;Macau
-852;HK;Hong Kong
+853;MO;Macau;XXXX XXXX
+852;HK;Hong Kong;X XXX XXXX
 850;KP;North Korea
 692;MH;Marshall Islands
 691;FM;Micronesia
@@ -67,166 +67,166 @@
 676;TO;Tonga
 675;PG;Papua New Guinea
 674;NR;Nauru
-673;BN;Brunei Darussalam
+673;BN;Brunei Darussalam;XXX XXXX
 672;NF;Norfolk Island
 670;TL;Timor-Leste
 599;BQ;Bonaire, Sint Eustatius & Saba
 599;CW;Curaçao
-598;UY;Uruguay
-597;SR;Suriname
+598;UY;Uruguay;X XXX XXXX
+597;SR;Suriname;XXX XXXX
 596;MQ;Martinique
-595;PY;Paraguay
+595;PY;Paraguay;XXX XXX XXX
 594;GF;French Guiana
-593;EC;Ecuador
+593;EC;Ecuador;XX XXX XXXX
 592;GY;Guyana
-591;BO;Bolivia
-590;GP;Guadeloupe
+591;BO;Bolivia;X XXX XXXX
+590;GP;Guadeloupe;XXX XX XX XX
 509;HT;Haiti
 508;PM;Saint Pierre & Miquelon
-507;PA;Panama
-506;CR;Costa Rica
-505;NI;Nicaragua
-504;HN;Honduras
-503;SV;El Salvador
-502;GT;Guatemala
+507;PA;Panama;XXXX XXXX
+506;CR;Costa Rica;XXXX XXXX
+505;NI;Nicaragua;XXXX XXXX
+504;HN;Honduras;XXXX XXXX
+503;SV;El Salvador;XXXX XXXX
+502;GT;Guatemala;X XXX XXXX
 501;BZ;Belize
 500;FK;Falkland Islands
 423;LI;Liechtenstein
-421;SK;Slovakia
-420;CZ;Czech Republic
-389;MK;Macedonia
-387;BA;Bosnia & Herzegovina
-386;SI;Slovenia
+421;SK;Slovakia;XXX XXX XXX
+420;CZ;Czech Republic;XXX XXX XXX
+389;MK;Macedonia;XX XXX XXX
+387;BA;Bosnia & Herzegovina;XX XXX XXX
+386;SI;Slovenia;XX XXX XXX
 385;HR;Croatia
 382;ME;Montenegro
-381;RS;Serbia
-380;UA;Ukraine
-378;SM;San Marino
-377;MC;Monaco
-376;AD;Andorra
-375;BY;Belarus
-374;AM;Armenia
-373;MD;Moldova
+381;RS;Serbia;XX XXX XXXX
+380;UA;Ukraine;XX XXX XX XX
+378;SM;San Marino;XXX XXX XXXX
+377;MC;Monaco;XXXX XXXX
+376;AD;Andorra;XX XX XX
+375;BY;Belarus;XX XXX XXXX
+374;AM;Armenia;XX XXX XXX
+373;MD;Moldova;XX XXX XXX
 372;EE;Estonia
-371;LV;Latvia
-370;LT;Lithuania
+371;LV;Latvia;XXX XXXXX
+370;LT;Lithuania;XXX XXXXX
 359;BG;Bulgaria
 358;FI;Finland
-357;CY;Cyprus
-356;MT;Malta
-355;AL;Albania
-354;IS;Iceland
-353;IE;Ireland
+357;CY;Cyprus;XXXX XXXX
+356;MT;Malta;XX XX XX XX
+355;AL;Albania;XX XXX XXXX
+354;IS;Iceland;XXX XXXX
+353;IE;Ireland;XX XXX XXXX
 352;LU;Luxembourg
-351;PT;Portugal
-350;GI;Gibraltar
-299;GL;Greenland
-298;FO;Faroe Islands
-297;AW;Aruba
-291;ER;Eritrea
-290;SH;Saint Helena
-269;KM;Comoros
-268;SZ;Swaziland
-267;BW;Botswana
-266;LS;Lesotho
-265;MW;Malawi
-264;NA;Namibia
-263;ZW;Zimbabwe
-262;RE;Réunion
-261;MG;Madagascar
-260;ZM;Zambia
-258;MZ;Mozambique
-257;BI;Burundi
-256;UG;Uganda
-255;TZ;Tanzania
-254;KE;Kenya
-253;DJ;Djibouti
-252;SO;Somalia
-251;ET;Ethiopia
-250;RW;Rwanda
-249;SD;Sudan
-248;SC;Seychelles
-247;SH;Saint Helena
-246;IO;Diego Garcia
-245;GW;Guinea-Bissau
-244;AO;Angola
-243;CD;Congo (Dem. Rep.)
-242;CG;Congo (Rep.)
-241;GA;Gabon
-240;GQ;Equatorial Guinea
-239;ST;São Tomé & Príncipe
-238;CV;Cape Verde
-237;CM;Cameroon
-236;CF;Central African Rep.
-235;TD;Chad
+351;PT;Portugal;X XXXX XXXX
+350;GI;Gibraltar;XXXX XXXX
+299;GL;Greenland;XXX XXX
+298;FO;Faroe Islands;XXX XXX
+297;AW;Aruba;XXX XXXX
+291;ER;Eritrea;X XXX XXX
+290;SH;Saint Helena;XX XXX
+269;KM;Comoros;XXX XXXX
+268;SZ;Swaziland;XXXX XXXX
+267;BW;Botswana;XX XXX XXX
+266;LS;Lesotho;XX XXX XXX
+265;MW;Malawi;77 XXX XXXX
+264;NA;Namibia;XX XXX XXXX
+263;ZW;Zimbabwe;XX XXX XXXX
+262;RE;Réunion;XXX XXX XXX
+261;MG;Madagascar;XX XX XXX XX
+260;ZM;Zambia;XX XXX XXXX
+258;MZ;Mozambique;XX XXX XXXX
+257;BI;Burundi;XX XX XXXX
+256;UG;Uganda;XX XXX XXXX
+255;TZ;Tanzania;XX XXX XXXX
+254;KE;Kenya;XXX XXX XXX
+253;DJ;Djibouti;XX XX XX XX
+252;SO;Somalia;XX XXX XXX
+251;ET;Ethiopia;XX XXX XXXX
+250;RW;Rwanda;XXX XXX XXX
+249;SD;Sudan;XX XXX XXXX
+248;SC;Seychelles;X XX XX XX
+247;SH;Saint Helena;XXXX
+246;IO;Diego Garcia;XXX XXXX
+245;GW;Guinea-Bissau;XXX XXXX
+244;AO;Angola;XXX XXX XXX
+243;CD;Congo (Dem. Rep.);XX XXX XXXX
+242;CG;Congo (Rep.);XX XXX XXXX
+241;GA;Gabon;X XX XX XX
+240;GQ;Equatorial Guinea;XXX XXX XXX
+239;ST;São Tomé & Príncipe;XX XXXXX
+238;CV;Cape Verde;XXX XXXX
+237;CM;Cameroon;XXXX XXXX
+236;CF;Central African Rep.;XX XX XX XX
+235;TD;Chad;XX XX XX XX
 234;NG;Nigeria
 233;GH;Ghana
-232;SL;Sierra Leone
+232;SL;Sierra Leone;XX XXX XXX
 231;LR;Liberia
 230;MU;Mauritius
-229;BJ;Benin
-228;TG;Togo
-227;NE;Niger
-226;BF;Burkina Faso
-225;CI;Côte d`Ivoire
-224;GN;Guinea
-223;ML;Mali
-222;MR;Mauritania
-221;SN;Senegal
-220;GM;Gambia
-218;LY;Libya
-216;TN;Tunisia
-213;DZ;Algeria
-212;MA;Morocco
-211;SS;South Sudan
-98;IR;Iran
+229;BJ;Benin;XX XXX XXX
+228;TG;Togo;XX XXX XXX
+227;NE;Niger;XX XX XX XX
+226;BF;Burkina Faso;XX XX XX XX
+225;CI;Côte d`Ivoire;XX XXX XXX
+224;GN;Guinea;XXX XXX XXX
+223;ML;Mali;XXXX XXXX
+222;MR;Mauritania;XXXX XXXX
+221;SN;Senegal;XX XXX XXXX
+220;GM;Gambia;XXX XXXX
+218;LY;Libya;XX XXX XXXX
+216;TN;Tunisia;XX XXX XXX
+213;DZ;Algeria;XXX XX XX XX
+212;MA;Morocco;XX XXX XXXX
+211;SS;South Sudan;XX XXX XXXX
+98;IR;Iran;XXX XXX XXXX
 95;MM;Myanmar
-94;LK;Sri Lanka
-93;AF;Afghanistan
-92;PK;Pakistan
-91;IN;India
-90;TR;Turkey
-86;CN;China
+94;LK;Sri Lanka;XX XXX XXXX
+93;AF;Afghanistan;XXX XXX XXX
+92;PK;Pakistan;XXX XXX XXXX
+91;IN;India;XXXXX XXXXX
+90;TR;Turkey;XXX XXX XXXX
+86;CN;China;XXX XXXX XXXX
 84;VN;Vietnam
 82;KR;South Korea
-81;JP;Japan
-66;TH;Thailand
-65;SG;Singapore
+81;JP;Japan;XX XXXX XXXX
+66;TH;Thailand;X XXXX XXXX
+65;SG;Singapore;XXXX XXXX
 64;NZ;New Zealand
-63;PH;Philippines
+63;PH;Philippines;XXX XXX XXXX
 62;ID;Indonesia
-61;AU;Australia
+61;AU;Australia;XXX XXX XXX
 60;MY;Malaysia
-58;VE;Venezuela
-57;CO;Colombia
-56;CL;Chile
-55;BR;Brazil
+58;VE;Venezuela;XXX XXX XXXX
+57;CO;Colombia;XXX XXX XXXX
+56;CL;Chile;X XXXX XXXX
+55;BR;Brazil;XX XXXXX XXXX
 54;AR;Argentina
-53;CU;Cuba
+53;CU;Cuba;XXXX XXXX
 52;MX;Mexico
-51;PE;Peru
+51;PE;Peru;XXX XXX XXX
 49;DE;Germany
-48;PL;Poland
-47;NO;Norway
-46;SE;Sweden
-45;DK;Denmark
-44;GB;United Kingdom
+48;PL;Poland;XX XXX XXXX
+47;NO;Norway;XXXX XXXX
+46;SE;Sweden;XX XXX XXXX
+45;DK;Denmark;XXXX XXXX
+44;GB;United Kingdom;XXXX XXXXXX
 43;AT;Austria
 42;YL;Y-land
-41;CH;Switzerland
-40;RO;Romania
+41;CH;Switzerland;XX XXX XXXX
+40;RO;Romania;XXX XXX XXX
 39;IT;Italy
-36;HU;Hungary
-34;ES;Spain
-33;FR;France
-32;BE;Belgium
-31;NL;Netherlands
-30;GR;Greece
-27;ZA;South Africa
-20;EG;Egypt
-7;KZ;Kazakhstan
-7;RU;Russian Federation
-1;PR;Puerto Rico
-1;DO;Dominican Rep.
-1;CA;Canada
-1;US;USA
\ No newline at end of file
+36;HU;Hungary;XXX XXX XXX
+34;ES;Spain;XXX XXX XXX
+33;FR;France;X XX XX XX XX
+32;BE;Belgium;XXX XX XX XX
+31;NL;Netherlands;X XX XX XX XX
+30;GR;Greece;XXX XXX XXXX
+27;ZA;South Africa;XX XXX XXXX
+20;EG;Egypt;XX XXXX XXXX
+7;KZ;Kazakhstan;XXX XXX XX XX
+7;RU;Russian Federation;XXX XXX XXXX
+1;PR;Puerto Rico;XXX XXX XXXX
+1;DO;Dominican Rep.;XXX XXX XXXX
+1;CA;Canada;XXX XXX XXXX
+1;US;USA;XXX XXX XXXX
\ No newline at end of file
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_0.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_0.jpg
deleted file mode 100644
index 251747ff3..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_0.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_1.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_1.jpg
deleted file mode 100644
index 21bc015ea..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_1.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_2.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_2.jpg
deleted file mode 100644
index c1c6fd3b7..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_2.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_3.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_3.jpg
deleted file mode 100644
index bb398488c..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_3.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_4.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_4.jpg
deleted file mode 100644
index a74e170f9..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_4.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_0.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_0.jpg
deleted file mode 100644
index 2fe760d04..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_0.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_1.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_1.jpg
deleted file mode 100644
index 776bf5887..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_1.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_2.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_2.jpg
deleted file mode 100644
index 43a7aa378..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_2.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_3.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_3.jpg
deleted file mode 100644
index 95d146fea..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_3.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_4.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_4.jpg
deleted file mode 100644
index 2be40c476..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji2.0x_a_4.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_0.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_0.jpg
deleted file mode 100644
index bc1d03b45..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_0.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_1.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_1.jpg
deleted file mode 100644
index 8288773c4..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_1.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_2.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_2.jpg
deleted file mode 100644
index feea12096..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_2.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_3.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_3.jpg
deleted file mode 100644
index 0e3bcede0..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_3.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_4.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_4.jpg
deleted file mode 100644
index 1f74e8359..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_4.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_0.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_0.jpg
deleted file mode 100644
index 5218c3ca4..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_0.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_1.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_1.jpg
deleted file mode 100644
index e6192101a..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_1.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_2.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_2.jpg
deleted file mode 100644
index 58476054b..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_2.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_3.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_3.jpg
deleted file mode 100644
index 7e4ea184c..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_3.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_4.jpg b/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_4.jpg
deleted file mode 100644
index 9bb3ea6cd..000000000
Binary files a/TMessagesProj/src/main/assets/emoji/v4_emoji3.0x_a_4.jpg and /dev/null differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_0.jpg
new file mode 100644
index 000000000..fa0923f6c
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_1.jpg
new file mode 100644
index 000000000..ed5a5d679
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_2.jpg
new file mode 100644
index 000000000..9c835601e
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_3.jpg
new file mode 100644
index 000000000..78637adc1
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_0_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_0.jpg
new file mode 100644
index 000000000..da6c51df6
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_1.jpg
new file mode 100644
index 000000000..454a6b2cf
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_2.jpg
new file mode 100644
index 000000000..5e589bd67
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_3.jpg
new file mode 100644
index 000000000..5f266035a
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_1_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_0.jpg
new file mode 100644
index 000000000..47ac67242
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_1.jpg
new file mode 100644
index 000000000..cd48e2672
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_2.jpg
new file mode 100644
index 000000000..01ae27b0d
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_3.jpg
new file mode 100644
index 000000000..1189e43bb
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_2_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_0.jpg
new file mode 100644
index 000000000..de71960a9
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_1.jpg
new file mode 100644
index 000000000..f9d3f664e
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_2.jpg
new file mode 100644
index 000000000..142848445
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_3.jpg
new file mode 100644
index 000000000..6de0df8e2
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_3_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_0.jpg
new file mode 100644
index 000000000..4ed59bede
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_1.jpg
new file mode 100644
index 000000000..7cd44246a
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_2.jpg
new file mode 100644
index 000000000..0169deb51
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_3.jpg
new file mode 100644
index 000000000..2a68beecc
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_4_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_0.jpg
new file mode 100644
index 000000000..714e186a6
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_1.jpg
new file mode 100644
index 000000000..c659dad05
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_2.jpg
new file mode 100644
index 000000000..1e308bdbe
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_3.jpg
new file mode 100644
index 000000000..ca39a7d1a
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_0_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_0.jpg
new file mode 100644
index 000000000..29556f698
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_1.jpg
new file mode 100644
index 000000000..015563d4c
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_2.jpg
new file mode 100644
index 000000000..86306574f
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_3.jpg
new file mode 100644
index 000000000..30b5a9278
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_1_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_0.jpg
new file mode 100644
index 000000000..2ff8348b4
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_1.jpg
new file mode 100644
index 000000000..1398cf95b
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_2.jpg
new file mode 100644
index 000000000..d5843711b
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_3.jpg
new file mode 100644
index 000000000..103f7693c
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_2_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_0.jpg
new file mode 100644
index 000000000..0616f2960
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_1.jpg
new file mode 100644
index 000000000..7a6d2e3f3
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_2.jpg
new file mode 100644
index 000000000..bef04e680
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_3.jpg
new file mode 100644
index 000000000..1ce93089f
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_3_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_0.jpg
new file mode 100644
index 000000000..684965e70
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_1.jpg
new file mode 100644
index 000000000..eef5ec534
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_2.jpg
new file mode 100644
index 000000000..6d147857c
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_3.jpg
new file mode 100644
index 000000000..d08f80b76
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji2.0x_a_4_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_0.jpg
new file mode 100644
index 000000000..2048549a6
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_1.jpg
new file mode 100644
index 000000000..f712e4bb7
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_2.jpg
new file mode 100644
index 000000000..9225aa233
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_3.jpg
new file mode 100644
index 000000000..76657809a
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_0_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_0.jpg
new file mode 100644
index 000000000..ba950bff7
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_1.jpg
new file mode 100644
index 000000000..d1266580a
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_2.jpg
new file mode 100644
index 000000000..c394f8149
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_3.jpg
new file mode 100644
index 000000000..fdfd98d78
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_1_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_0.jpg
new file mode 100644
index 000000000..e19f186a0
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_1.jpg
new file mode 100644
index 000000000..af66cb3c9
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_2.jpg
new file mode 100644
index 000000000..597859740
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_3.jpg
new file mode 100644
index 000000000..476c9ed3f
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_2_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_0.jpg
new file mode 100644
index 000000000..29758492f
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_1.jpg
new file mode 100644
index 000000000..c9613022d
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_2.jpg
new file mode 100644
index 000000000..16d5bbfdd
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_3.jpg
new file mode 100644
index 000000000..f6db0ff32
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_3_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_0.jpg
new file mode 100644
index 000000000..59b6c198b
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_1.jpg
new file mode 100644
index 000000000..d285314ab
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_2.jpg
new file mode 100644
index 000000000..afd775135
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_3.jpg
new file mode 100644
index 000000000..81468d010
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_4_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_0.jpg
new file mode 100644
index 000000000..3e62257dd
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_1.jpg
new file mode 100644
index 000000000..6eff54180
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_2.jpg
new file mode 100644
index 000000000..ff866c722
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_3.jpg
new file mode 100644
index 000000000..1006fa4c0
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_0_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_0.jpg
new file mode 100644
index 000000000..74448ec6e
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_1.jpg
new file mode 100644
index 000000000..e9a646019
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_2.jpg
new file mode 100644
index 000000000..f9d6c78bf
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_3.jpg
new file mode 100644
index 000000000..c27537c2f
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_1_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_0.jpg
new file mode 100644
index 000000000..c54537579
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_1.jpg
new file mode 100644
index 000000000..deaf755ab
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_2.jpg
new file mode 100644
index 000000000..4f06199ed
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_3.jpg
new file mode 100644
index 000000000..aa1261b58
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_2_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_0.jpg
new file mode 100644
index 000000000..ec2ce25c6
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_1.jpg
new file mode 100644
index 000000000..f73bfb8c8
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_2.jpg
new file mode 100644
index 000000000..e81151b98
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_3.jpg
new file mode 100644
index 000000000..cb60b76cb
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_3_3.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_0.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_0.jpg
new file mode 100644
index 000000000..fb85fee49
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_0.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_1.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_1.jpg
new file mode 100644
index 000000000..65f0a2bf1
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_1.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_2.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_2.jpg
new file mode 100644
index 000000000..b5aa9c173
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_2.jpg differ
diff --git a/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_3.jpg b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_3.jpg
new file mode 100644
index 000000000..28d5ef5b9
Binary files /dev/null and b/TMessagesProj/src/main/assets/emoji/v7_emoji3.0x_a_4_3.jpg differ
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteCursor.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteCursor.java
index 87deca404..01275c5a0 100755
--- a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteCursor.java
+++ b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteCursor.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.SQLite;
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteDatabase.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteDatabase.java
index 0aecf4b23..eb8bd6ada 100755
--- a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteDatabase.java
+++ b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteDatabase.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.SQLite;
@@ -22,7 +22,7 @@ public int getSQLiteHandle() {
 	}
 
 	public SQLiteDatabase(String fileName) throws SQLiteException {
-		sqliteHandle = opendb(fileName, ApplicationLoader.applicationContext.getFilesDir().getPath());
+		sqliteHandle = opendb(fileName, ApplicationLoader.getFilesDirFixed().getPath());
 		isOpen = true;
 	}
 
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteException.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteException.java
index d27cfb6a0..2540c0947 100755
--- a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteException.java
+++ b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteException.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.SQLite;
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteNoRowException.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteNoRowException.java
index 042f0070f..944d21430 100755
--- a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteNoRowException.java
+++ b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLiteNoRowException.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.SQLite;
diff --git a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLitePreparedStatement.java b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLitePreparedStatement.java
index a2c871404..cd933701c 100755
--- a/TMessagesProj/src/main/java/org/telegram/SQLite/SQLitePreparedStatement.java
+++ b/TMessagesProj/src/main/java/org/telegram/SQLite/SQLitePreparedStatement.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.SQLite;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AndroidUtilities.java b/TMessagesProj/src/main/java/org/telegram/messenger/AndroidUtilities.java
index acc95e7d3..ab507911d 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AndroidUtilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AndroidUtilities.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -16,6 +16,7 @@
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.database.Cursor;
 import android.graphics.Color;
@@ -74,6 +75,7 @@
 import java.util.Date;
 import java.util.Hashtable;
 import java.util.Locale;
+import java.util.regex.Pattern;
 
 public class AndroidUtilities {
 
@@ -92,6 +94,36 @@
     private static Boolean isTablet = null;
     private static int adjustOwnerClassGuid = 0;
 
+    public static Pattern WEB_URL = null;
+    static {
+        try {
+            final String GOOD_IRI_CHAR = "a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF";
+            final Pattern IP_ADDRESS = Pattern.compile(
+                    "((25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(25[0-5]|2[0-4]"
+                            + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]"
+                            + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
+                            + "|[1-9][0-9]|[0-9]))");
+            final String IRI = "[" + GOOD_IRI_CHAR + "]([" + GOOD_IRI_CHAR + "\\-]{0,61}[" + GOOD_IRI_CHAR + "]){0,1}";
+            final String GOOD_GTLD_CHAR = "a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF";
+            final String GTLD = "[" + GOOD_GTLD_CHAR + "]{2,63}";
+            final String HOST_NAME = "(" + IRI + "\\.)+" + GTLD;
+            final Pattern DOMAIN_NAME = Pattern.compile("(" + HOST_NAME + "|" + IP_ADDRESS + ")");
+            WEB_URL = Pattern.compile(
+                    "((?:(http|https|Http|Https):\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
+                            + "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
+                            + "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
+                            + "(?:" + DOMAIN_NAME + ")"
+                            + "(?:\\:\\d{1,5})?)" // plus option port number
+                            + "(\\/(?:(?:[" + GOOD_IRI_CHAR + "\\;\\/\\?\\:\\@\\&\\=\\#\\~"  // plus option query params
+                            + "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?"
+                            + "(?:\\b|$)");
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+
+
     static {
         density = ApplicationLoader.applicationContext.getResources().getDisplayMetrics().density;
         leftBaseline = isTablet() ? 80 : 72;
@@ -265,7 +297,7 @@ public static int dp(float value) {
         if (value == 0) {
             return 0;
         }
-        return (int)Math.ceil(density * value);
+        return (int) Math.ceil(density * value);
     }
 
     public static int compare(int lhs, int rhs) {
@@ -304,38 +336,6 @@ public static void checkDisplaySize() {
         } catch (Exception e) {
             FileLog.e("tmessages", e);
         }
-
-        /*
-        keyboardHidden
-        public static final int KEYBOARDHIDDEN_NO = 1
-        Constant for keyboardHidden, value corresponding to the keysexposed resource qualifier.
-
-        public static final int KEYBOARDHIDDEN_UNDEFINED = 0
-        Constant for keyboardHidden: a value indicating that no value has been set.
-
-        public static final int KEYBOARDHIDDEN_YES = 2
-        Constant for keyboardHidden, value corresponding to the keyshidden resource qualifier.
-
-        hardKeyboardHidden
-        public static final int HARDKEYBOARDHIDDEN_NO = 1
-        Constant for hardKeyboardHidden, value corresponding to the physical keyboard being exposed.
-
-        public static final int HARDKEYBOARDHIDDEN_UNDEFINED = 0
-        Constant for hardKeyboardHidden: a value indicating that no value has been set.
-
-        public static final int HARDKEYBOARDHIDDEN_YES = 2
-        Constant for hardKeyboardHidden, value corresponding to the physical keyboard being hidden.
-
-        keyboard
-        public static final int KEYBOARD_12KEY = 3
-        Constant for keyboard, value corresponding to the 12key resource qualifier.
-
-        public static final int KEYBOARD_NOKEYS = 1
-        Constant for keyboard, value corresponding to the nokeys resource qualifier.
-
-        public static final int KEYBOARD_QWERTY = 2
-        Constant for keyboard, value corresponding to the qwerty resource qualifier.
-         */
     }
 
     public static float getPixelsInCM(float cm, boolean isX) {
@@ -536,7 +536,7 @@ public static void setProgressBarAnimationDuration(ProgressBar progressBar, int
     }
 
     public static int getViewInset(View view) {
-        if (view == null || Build.VERSION.SDK_INT < 21) {
+        if (view == null || Build.VERSION.SDK_INT < 21 || view.getHeight() == AndroidUtilities.displaySize.y || view.getHeight() == AndroidUtilities.displaySize.y - statusBarHeight) {
             return 0;
         }
         try {
@@ -766,7 +766,7 @@ public void onAnimationEnd(Object animation) {
     }*/
 
     public static void checkForCrashes(Activity context) {
-        CrashManager.register(context, BuildVars.HOCKEY_APP_HASH, new CrashManagerListener() {
+        CrashManager.register(context, BuildVars.DEBUG_VERSION ? BuildVars.HOCKEY_APP_HASH_DEBUG : BuildVars.HOCKEY_APP_HASH, new CrashManagerListener() {
             @Override
             public boolean includeDeviceData() {
                 return true;
@@ -776,7 +776,7 @@ public boolean includeDeviceData() {
 
     public static void checkForUpdates(Activity context) {
         if (BuildVars.DEBUG_VERSION) {
-            UpdateManager.register(context, BuildVars.HOCKEY_APP_HASH);
+            UpdateManager.register(context, BuildVars.DEBUG_VERSION ? BuildVars.HOCKEY_APP_HASH_DEBUG : BuildVars.HOCKEY_APP_HASH);
         }
     }
 
@@ -799,12 +799,19 @@ public static void addMediaToGallery(Uri uri) {
         if (uri == null) {
             return;
         }
-        Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
-        mediaScanIntent.setData(uri);
-        ApplicationLoader.applicationContext.sendBroadcast(mediaScanIntent);
+        try {
+            Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
+            mediaScanIntent.setData(uri);
+            ApplicationLoader.applicationContext.sendBroadcast(mediaScanIntent);
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
     }
 
     private static File getAlbumDir() {
+        if (Build.VERSION.SDK_INT >= 23 && ApplicationLoader.applicationContext.checkSelfPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+            return FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE);
+        }
         File storageDir = null;
         if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
             storageDir = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES), "Telegram");
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/AnimatorListenerAdapterProxy.java b/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/AnimatorListenerAdapterProxy.java
index eb7f73207..a136fbe58 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/AnimatorListenerAdapterProxy.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/AnimatorListenerAdapterProxy.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.AnimationCompat;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/AnimatorSetProxy.java b/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/AnimatorSetProxy.java
index 2dd7f21dd..ac3663877 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/AnimatorSetProxy.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/AnimatorSetProxy.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.AnimationCompat;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/ObjectAnimatorProxy.java b/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/ObjectAnimatorProxy.java
index 6ffffe341..392c25506 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/ObjectAnimatorProxy.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/ObjectAnimatorProxy.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.AnimationCompat;
@@ -73,12 +73,13 @@ public void setInterpolator(Interpolator value) {
         }
     }
 
-    public void start() {
+    public ObjectAnimatorProxy start() {
         if (View10.NEED_PROXY) {
             ((ObjectAnimator10) objectAnimator).start();
         } else {
             ((ObjectAnimator) objectAnimator).start();
         }
+        return this;
     }
 
     public void setAutoCancel(boolean cancel) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/ViewProxy.java b/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/ViewProxy.java
index 492c136b1..e313acb8f 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/ViewProxy.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AnimationCompat/ViewProxy.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.AnimationCompat;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AppStartReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/AppStartReceiver.java
index a601d66c0..153f68966 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AppStartReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AppStartReceiver.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
index 478c039bf..1e485197b 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ApplicationLoader.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -17,6 +17,7 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.SharedPreferences;
+import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageInfo;
 import android.content.res.Configuration;
 import android.graphics.drawable.ColorDrawable;
@@ -92,7 +93,7 @@ public void run() {
                                 cachedWallpaper = applicationContext.getResources().getDrawable(R.drawable.background_hd);
                                 isCustomTheme = false;
                             } else {
-                                File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper.jpg");
+                                File toFile = new File(getFilesDirFixed(), "wallpaper.jpg");
                                 if (toFile.exists()) {
                                     cachedWallpaper = Drawable.createFromPath(toFile.getAbsolutePath());
                                     isCustomTheme = true;
@@ -151,7 +152,7 @@ private static void convertConfig() {
             }
 
             try {
-                File file = new File(ApplicationLoader.applicationContext.getFilesDir(), "tgnet.dat");
+                File file = new File(getFilesDirFixed(), "tgnet.dat");
                 RandomAccessFile fileOutputStream = new RandomAccessFile(file, "rws");
                 byte[] bytes = buffer.toByteArray();
                 fileOutputStream.writeInt(Integer.reverseBytes(bytes.length));
@@ -165,6 +166,24 @@ private static void convertConfig() {
         }
     }
 
+    public static File getFilesDirFixed() {
+        for (int a = 0; a < 10; a++) {
+            File path = ApplicationLoader.applicationContext.getFilesDir();
+            if (path != null) {
+                return path;
+            }
+        }
+        try {
+            ApplicationInfo info = applicationContext.getApplicationInfo();
+            File path = new File(info.dataDir, "files");
+            path.mkdirs();
+            return path;
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return new File("/data/data/org.telegram.messenger/files");
+    }
+
     public static void postInitApplication() {
         if (applicationInited) {
             return;
@@ -201,7 +220,7 @@ public static void postInitApplication() {
         String langCode;
         String appVersion;
         String systemVersion;
-        String configPath = ApplicationLoader.applicationContext.getFilesDir().toString();
+        String configPath = getFilesDirFixed().toString();
 
         try {
             langCode = LocaleController.getLocaleString(LocaleController.getInstance().getSystemDefaultLocale());
@@ -215,21 +234,21 @@ public static void postInitApplication() {
             appVersion = "App version unknown";
             systemVersion = "SDK " + Build.VERSION.SDK_INT;
         }
-        if (langCode.length() == 0) {
+        if (langCode.trim().length() == 0) {
             langCode = "en";
         }
-        if (deviceModel.length() == 0) {
+        if (deviceModel.trim().length() == 0) {
             deviceModel = "Android unknown";
         }
-        if (appVersion.length() == 0) {
+        if (appVersion.trim().length() == 0) {
             appVersion = "App version unknown";
         }
-        if (systemVersion.length() == 0) {
+        if (systemVersion.trim().length() == 0) {
             systemVersion = "SDK Unknown";
         }
 
         MessagesController.getInstance();
-        ConnectionsManager.getInstance().init(BuildVars.BUILD_VERSION, TLRPC.LAYER, BuildVars.APP_ID, deviceModel, systemVersion, appVersion, langCode, configPath, UserConfig.getClientUserId());
+        ConnectionsManager.getInstance().init(BuildVars.BUILD_VERSION, TLRPC.LAYER, BuildVars.APP_ID, deviceModel, systemVersion, appVersion, langCode, configPath, FileLog.getNetworkLogPath(), UserConfig.getClientUserId());
         if (UserConfig.getCurrentUser() != null) {
             MessagesController.getInstance().putUser(UserConfig.getCurrentUser(), true);
             ConnectionsManager.getInstance().applyCountryPortNumber(UserConfig.getCurrentUser().phone);
@@ -308,18 +327,23 @@ public void onConfigurationChanged(Configuration newConfig) {
     }
 
     private void initPlayServices() {
-        if (checkPlayServices()) {
-            gcm = GoogleCloudMessaging.getInstance(this);
-            regid = getRegistrationId();
-
-            if (regid.length() == 0) {
-                registerInBackground();
-            } else {
-                sendRegistrationIdToBackend(false);
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                if (checkPlayServices()) {
+                    gcm = GoogleCloudMessaging.getInstance(ApplicationLoader.this);
+                    regid = getRegistrationId();
+
+                    if (regid.length() == 0) {
+                        registerInBackground();
+                    } else {
+                        sendRegistrationIdToBackend(false);
+                    }
+                } else {
+                    FileLog.d("tmessages", "No valid Google Play Services APK found.");
+                }
             }
-        } else {
-            FileLog.d("tmessages", "No valid Google Play Services APK found.");
-        }
+        }, 1000);
     }
 
     private boolean checkPlayServices() {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AuthenticatorService.java b/TMessagesProj/src/main/java/org/telegram/messenger/AuthenticatorService.java
index e88d46ed2..60984c1b5 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AuthenticatorService.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AuthenticatorService.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AutoMessageHeardReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/AutoMessageHeardReceiver.java
index 9bf109e92..bc08936f1 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AutoMessageHeardReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AutoMessageHeardReceiver.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -21,6 +21,6 @@ public void onReceive(Context context, Intent intent) {
         if (dialog_id == 0 || max_id == 0) {
             return;
         }
-        MessagesController.getInstance().markDialogAsRead(dialog_id, max_id, max_id, 0, 0, true, false);
+        MessagesController.getInstance().markDialogAsRead(dialog_id, max_id, max_id, 0, true, false);
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/AutoMessageReplyReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/AutoMessageReplyReceiver.java
index bc3324449..d15b7cd25 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/AutoMessageReplyReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/AutoMessageReplyReceiver.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -32,6 +32,6 @@ public void onReceive(Context context, Intent intent) {
             return;
         }
         SendMessagesHelper.getInstance().sendMessage(text.toString(), dialog_id, null, null, true, false);
-        MessagesController.getInstance().markDialogAsRead(dialog_id, max_id, max_id, 0, 0, true, false);
+        MessagesController.getInstance().markDialogAsRead(dialog_id, max_id, max_id, 0, true, false);
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Bitmaps.java b/TMessagesProj/src/main/java/org/telegram/messenger/Bitmaps.java
new file mode 100644
index 000000000..c9ee2c4ef
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Bitmaps.java
@@ -0,0 +1,257 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.messenger;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.os.Build;
+
+public class Bitmaps {
+
+    private static volatile Matrix sScaleMatrix;
+
+    private static final ThreadLocal<byte[]> jpegData = new ThreadLocal<byte[]>() {
+        @Override
+        protected byte[] initialValue() {
+            return new byte[]{
+                    (byte) 0xff, (byte) 0xd8, (byte) 0xff, (byte) 0xdb, (byte) 0x00, (byte) 0x43, (byte) 0x00,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,
+                    (byte) 0xff, (byte) 0xff, (byte) 0xc0, (byte) 0x00, (byte) 0x11, (byte) 0x08, (byte) 0x00,
+                    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03, (byte) 0x01, (byte) 0x22, (byte) 0x00,
+                    (byte) 0x02, (byte) 0x11, (byte) 0x00, (byte) 0x03, (byte) 0x11, (byte) 0x00, (byte) 0xff,
+                    (byte) 0xc4, (byte) 0x00, (byte) 0x1f, (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x05,
+                    (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x00,
+                    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
+                    (byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07,
+                    (byte) 0x08, (byte) 0x09, (byte) 0x0a, (byte) 0x0b, (byte) 0xff, (byte) 0xc4, (byte) 0x00,
+                    (byte) 0xb5, (byte) 0x10, (byte) 0x00, (byte) 0x02, (byte) 0x01, (byte) 0x03, (byte) 0x03,
+                    (byte) 0x02, (byte) 0x04, (byte) 0x03, (byte) 0x05, (byte) 0x05, (byte) 0x04, (byte) 0x04,
+                    (byte) 0x00, (byte) 0x00, (byte) 0x01, (byte) 0x7d, (byte) 0x01, (byte) 0x02, (byte) 0x03,
+                    (byte) 0x00, (byte) 0x04, (byte) 0x11, (byte) 0x05, (byte) 0x12, (byte) 0x21, (byte) 0x31,
+                    (byte) 0x41, (byte) 0x06, (byte) 0x13, (byte) 0x51, (byte) 0x61, (byte) 0x07, (byte) 0x22,
+                    (byte) 0x71, (byte) 0x14, (byte) 0x32, (byte) 0x81, (byte) 0x91, (byte) 0xa1, (byte) 0x08,
+                    (byte) 0x23, (byte) 0x42, (byte) 0xb1, (byte) 0xc1, (byte) 0x15, (byte) 0x52, (byte) 0xd1,
+                    (byte) 0xf0, (byte) 0x24, (byte) 0x33, (byte) 0x62, (byte) 0x72, (byte) 0x82, (byte) 0x09,
+                    (byte) 0x0a, (byte) 0x16, (byte) 0x17, (byte) 0x18, (byte) 0x19, (byte) 0x1a, (byte) 0x25,
+                    (byte) 0x26, (byte) 0x27, (byte) 0x28, (byte) 0x29, (byte) 0x2a, (byte) 0x34, (byte) 0x35,
+                    (byte) 0x36, (byte) 0x37, (byte) 0x38, (byte) 0x39, (byte) 0x3a, (byte) 0x43, (byte) 0x44,
+                    (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x4a, (byte) 0x53,
+                    (byte) 0x54, (byte) 0x55, (byte) 0x56, (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x5a,
+                    (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69,
+                    (byte) 0x6a, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78,
+                    (byte) 0x79, (byte) 0x7a, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87,
+                    (byte) 0x88, (byte) 0x89, (byte) 0x8a, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95,
+                    (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9a, (byte) 0xa2, (byte) 0xa3,
+                    (byte) 0xa4, (byte) 0xa5, (byte) 0xa6, (byte) 0xa7, (byte) 0xa8, (byte) 0xa9, (byte) 0xaa,
+                    (byte) 0xb2, (byte) 0xb3, (byte) 0xb4, (byte) 0xb5, (byte) 0xb6, (byte) 0xb7, (byte) 0xb8,
+                    (byte) 0xb9, (byte) 0xba, (byte) 0xc2, (byte) 0xc3, (byte) 0xc4, (byte) 0xc5, (byte) 0xc6,
+                    (byte) 0xc7, (byte) 0xc8, (byte) 0xc9, (byte) 0xca, (byte) 0xd2, (byte) 0xd3, (byte) 0xd4,
+                    (byte) 0xd5, (byte) 0xd6, (byte) 0xd7, (byte) 0xd8, (byte) 0xd9, (byte) 0xda, (byte) 0xe1,
+                    (byte) 0xe2, (byte) 0xe3, (byte) 0xe4, (byte) 0xe5, (byte) 0xe6, (byte) 0xe7, (byte) 0xe8,
+                    (byte) 0xe9, (byte) 0xea, (byte) 0xf1, (byte) 0xf2, (byte) 0xf3, (byte) 0xf4, (byte) 0xf5,
+                    (byte) 0xf6, (byte) 0xf7, (byte) 0xf8, (byte) 0xf9, (byte) 0xfa, (byte) 0xff, (byte) 0xc4,
+                    (byte) 0x00, (byte) 0x1f, (byte) 0x01, (byte) 0x00, (byte) 0x03, (byte) 0x01, (byte) 0x01,
+                    (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01, (byte) 0x01,
+                    (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01,
+                    (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08,
+                    (byte) 0x09, (byte) 0x0a, (byte) 0x0b, (byte) 0xff, (byte) 0xc4, (byte) 0x00, (byte) 0xb5,
+                    (byte) 0x11, (byte) 0x00, (byte) 0x02, (byte) 0x01, (byte) 0x02, (byte) 0x04, (byte) 0x04,
+                    (byte) 0x03, (byte) 0x04, (byte) 0x07, (byte) 0x05, (byte) 0x04, (byte) 0x04, (byte) 0x00,
+                    (byte) 0x01, (byte) 0x02, (byte) 0x77, (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03,
+                    (byte) 0x11, (byte) 0x04, (byte) 0x05, (byte) 0x21, (byte) 0x31, (byte) 0x06, (byte) 0x12,
+                    (byte) 0x41, (byte) 0x51, (byte) 0x07, (byte) 0x61, (byte) 0x71, (byte) 0x13, (byte) 0x22,
+                    (byte) 0x32, (byte) 0x81, (byte) 0x08, (byte) 0x14, (byte) 0x42, (byte) 0x91, (byte) 0xa1,
+                    (byte) 0xb1, (byte) 0xc1, (byte) 0x09, (byte) 0x23, (byte) 0x33, (byte) 0x52, (byte) 0xf0,
+                    (byte) 0x15, (byte) 0x62, (byte) 0x72, (byte) 0xd1, (byte) 0x0a, (byte) 0x16, (byte) 0x24,
+                    (byte) 0x34, (byte) 0xe1, (byte) 0x25, (byte) 0xf1, (byte) 0x17, (byte) 0x18, (byte) 0x19,
+                    (byte) 0x1a, (byte) 0x26, (byte) 0x27, (byte) 0x28, (byte) 0x29, (byte) 0x2a, (byte) 0x35,
+                    (byte) 0x36, (byte) 0x37, (byte) 0x38, (byte) 0x39, (byte) 0x3a, (byte) 0x43, (byte) 0x44,
+                    (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x4a, (byte) 0x53,
+                    (byte) 0x54, (byte) 0x55, (byte) 0x56, (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x5a,
+                    (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69,
+                    (byte) 0x6a, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78,
+                    (byte) 0x79, (byte) 0x7a, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86,
+                    (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x8a, (byte) 0x92, (byte) 0x93, (byte) 0x94,
+                    (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9a, (byte) 0xa2,
+                    (byte) 0xa3, (byte) 0xa4, (byte) 0xa5, (byte) 0xa6, (byte) 0xa7, (byte) 0xa8, (byte) 0xa9,
+                    (byte) 0xaa, (byte) 0xb2, (byte) 0xb3, (byte) 0xb4, (byte) 0xb5, (byte) 0xb6, (byte) 0xb7,
+                    (byte) 0xb8, (byte) 0xb9, (byte) 0xba, (byte) 0xc2, (byte) 0xc3, (byte) 0xc4, (byte) 0xc5,
+                    (byte) 0xc6, (byte) 0xc7, (byte) 0xc8, (byte) 0xc9, (byte) 0xca, (byte) 0xd2, (byte) 0xd3,
+                    (byte) 0xd4, (byte) 0xd5, (byte) 0xd6, (byte) 0xd7, (byte) 0xd8, (byte) 0xd9, (byte) 0xda,
+                    (byte) 0xe2, (byte) 0xe3, (byte) 0xe4, (byte) 0xe5, (byte) 0xe6, (byte) 0xe7, (byte) 0xe8,
+                    (byte) 0xe9, (byte) 0xea, (byte) 0xf2, (byte) 0xf3, (byte) 0xf4, (byte) 0xf5, (byte) 0xf6,
+                    (byte) 0xf7, (byte) 0xf8, (byte) 0xf9, (byte) 0xfa, (byte) 0xff, (byte) 0xda, (byte) 0x00,
+                    (byte) 0x0c, (byte) 0x03, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x11, (byte) 0x03,
+                    (byte) 0x11, (byte) 0x00, (byte) 0x3f, (byte) 0x00, (byte) 0x8e, (byte) 0x8a, (byte) 0x28,
+                    (byte) 0xa0, (byte) 0x0f, (byte) 0xff, (byte) 0xd9
+            };
+        }
+    };
+
+    public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {
+        Bitmap bitmap;
+        if (Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT < 21) {
+            BitmapFactory.Options options = new BitmapFactory.Options();
+            options.inDither = true;
+            options.inPreferredConfig = config;
+            options.inPurgeable = true;
+            options.inSampleSize = 1;
+            options.inMutable = true;
+            byte[] array = jpegData.get();
+            array[76] = (byte) (height >> 8);
+            array[77] = (byte) (height & 0x00ff);
+            array[78] = (byte) (width >> 8);
+            array[79] = (byte) (width & 0x00ff);
+            bitmap = BitmapFactory.decodeByteArray(array, 0, array.length, options);
+            Utilities.pinBitmap(bitmap);
+            bitmap.setHasAlpha(true);
+            bitmap.eraseColor(0);
+        } else {
+            bitmap = Bitmap.createBitmap(width, height, config);
+        }
+        if (config == Bitmap.Config.ARGB_8888 || config == Bitmap.Config.ARGB_4444) {
+            bitmap.eraseColor(Color.TRANSPARENT);
+        }
+        return bitmap;
+    }
+
+    private static void checkXYSign(int x, int y) {
+        if (x < 0) {
+            throw new IllegalArgumentException("x must be >= 0");
+        }
+        if (y < 0) {
+            throw new IllegalArgumentException("y must be >= 0");
+        }
+    }
+
+    private static void checkWidthHeight(int width, int height) {
+        if (width <= 0) {
+            throw new IllegalArgumentException("width must be > 0");
+        }
+        if (height <= 0) {
+            throw new IllegalArgumentException("height must be > 0");
+        }
+    }
+
+    public static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter) {
+        checkXYSign(x, y);
+        checkWidthHeight(width, height);
+        if (x + width > source.getWidth()) {
+            throw new IllegalArgumentException("x + width must be <= bitmap.width()");
+        }
+        if (y + height > source.getHeight()) {
+            throw new IllegalArgumentException("y + height must be <= bitmap.height()");
+        }
+        if (!source.isMutable() && x == 0 && y == 0 && width == source.getWidth() && height == source.getHeight() && (m == null || m.isIdentity())) {
+            return source;
+        }
+
+        int neww = width;
+        int newh = height;
+        Canvas canvas = new Canvas();
+        Bitmap bitmap;
+        Paint paint;
+
+        Rect srcR = new Rect(x, y, x + width, y + height);
+        RectF dstR = new RectF(0, 0, width, height);
+
+        Bitmap.Config newConfig = Bitmap.Config.ARGB_8888;
+        final Bitmap.Config config = source.getConfig();
+        if (config != null) {
+            switch (config) {
+                case RGB_565:
+                    newConfig = Bitmap.Config.RGB_565;
+                    break;
+                case ALPHA_8:
+                    newConfig = Bitmap.Config.ALPHA_8;
+                    break;
+                case ARGB_4444:
+                case ARGB_8888:
+                default:
+                    newConfig = Bitmap.Config.ARGB_8888;
+                    break;
+            }
+        }
+
+        if (m == null || m.isIdentity()) {
+            bitmap = createBitmap(neww, newh, newConfig);
+            paint = null;
+        } else {
+            final boolean transformed = !m.rectStaysRect();
+            RectF deviceR = new RectF();
+            m.mapRect(deviceR, dstR);
+            neww = Math.round(deviceR.width());
+            newh = Math.round(deviceR.height());
+            bitmap = createBitmap(neww, newh, transformed ? Bitmap.Config.ARGB_8888 : newConfig);
+            canvas.translate(-deviceR.left, -deviceR.top);
+            canvas.concat(m);
+            paint = new Paint();
+            paint.setFilterBitmap(filter);
+            if (transformed) {
+                paint.setAntiAlias(true);
+            }
+        }
+        bitmap.setDensity(source.getDensity());
+        if (Build.VERSION.SDK_INT >= 12) {
+            bitmap.setHasAlpha(source.hasAlpha());
+        }
+        if (Build.VERSION.SDK_INT >= 19) {
+            bitmap.setPremultiplied(source.isPremultiplied());
+        }
+        canvas.setBitmap(bitmap);
+        canvas.drawBitmap(source, srcR, dstR, paint);
+        try {
+            canvas.setBitmap(null);
+        } catch (Exception e) {
+            //don't promt, this will crash on 2.x
+        }
+        return bitmap;
+    }
+
+    public static Bitmap createBitmap(Bitmap source, int x, int y, int width, int height) {
+        return createBitmap(source, x, y, width, height, null, false);
+    }
+
+    public static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) {
+        Matrix m;
+        synchronized (Bitmap.class) {
+            m = sScaleMatrix;
+            sScaleMatrix = null;
+        }
+        if (m == null) {
+            m = new Matrix();
+        }
+        final int width = src.getWidth();
+        final int height = src.getHeight();
+        final float sx = dstWidth / (float) width;
+        final float sy = dstHeight / (float) height;
+        m.setScale(sx, sy);
+        Bitmap b = createBitmap(src, 0, 0, width, height, m, filter);
+        synchronized (Bitmap.class) {
+            if (sScaleMatrix == null) {
+                sScaleMatrix = m;
+            }
+        }
+        return b;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java b/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
index e8da530bb..303034bf9 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/BuildVars.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -10,10 +10,11 @@
 
 public class BuildVars {
     public static boolean DEBUG_VERSION = false;
-    public static int BUILD_VERSION = 627;
+    public static int BUILD_VERSION = 695;
     public static int APP_ID = 0; //obtain your own APP_ID at https://core.telegram.org/api/obtaining_api_id
     public static String APP_HASH = ""; //obtain your own APP_HASH at https://core.telegram.org/api/obtaining_api_id
     public static String HOCKEY_APP_HASH = "your-hockeyapp-api-key-here";
+    public static String HOCKEY_APP_HASH_DEBUG = "your-hockeyapp-api-key-here";
     public static String GCM_SENDER_ID = "760348033672";
     public static String SEND_LOGS_EMAIL = "email@gmail.com";
     public static String BING_SEARCH_KEY = ""; //obtain your own KEY at https://www.bing.com/dev/en-us/dev-center
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ChatObject.java b/TMessagesProj/src/main/java/org/telegram/messenger/ChatObject.java
index 702d3ac53..b38d244b4 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ChatObject.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ChatObject.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -16,17 +16,18 @@
     public static final int CHAT_TYPE_BROADCAST = 1;
     public static final int CHAT_TYPE_CHANNEL = 2;
     public static final int CHAT_TYPE_USER = 3;
+    public static final int CHAT_TYPE_MEGAGROUP = 4;
 
     public static boolean isLeftFromChat(TLRPC.Chat chat) {
-        return chat == null || chat instanceof TLRPC.TL_chatForbidden || chat instanceof TLRPC.TL_channelForbidden || (chat.flags & TLRPC.CHAT_FLAG_USER_LEFT) != 0;
+        return chat == null || chat instanceof TLRPC.TL_chatEmpty || chat instanceof TLRPC.TL_chatForbidden || chat instanceof TLRPC.TL_channelForbidden || chat.left || chat.deactivated;
     }
 
     public static boolean isKickedFromChat(TLRPC.Chat chat) {
-        return chat == null || chat instanceof TLRPC.TL_chatForbidden || chat instanceof TLRPC.TL_channelForbidden || (chat.flags & TLRPC.CHAT_FLAG_USER_KICKED) != 0;
+        return chat == null || chat instanceof TLRPC.TL_chatEmpty || chat instanceof TLRPC.TL_chatForbidden || chat instanceof TLRPC.TL_channelForbidden || chat.kicked || chat.deactivated;
     }
 
     public static boolean isNotInChat(TLRPC.Chat chat) {
-        return chat == null || chat instanceof TLRPC.TL_chatForbidden || chat instanceof TLRPC.TL_channelForbidden || (chat.flags & TLRPC.CHAT_FLAG_USER_LEFT) != 0 || (chat.flags & TLRPC.CHAT_FLAG_USER_KICKED) != 0;
+        return chat == null || chat instanceof TLRPC.TL_chatEmpty || chat instanceof TLRPC.TL_chatForbidden || chat instanceof TLRPC.TL_channelForbidden || chat.left || chat.kicked || chat.deactivated;
     }
 
     public static boolean isChannel(TLRPC.Chat chat) {
@@ -40,18 +41,18 @@ public static boolean isChannel(int chatId) {
 
     public static boolean isCanWriteToChannel(int chatId) {
         TLRPC.Chat chat = MessagesController.getInstance().getChat(chatId);
-        return chat != null && ((chat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0 || (chat.flags & TLRPC.CHAT_FLAG_USER_IS_EDITOR) != 0);
+        return chat != null && (chat.creator || chat.editor || chat.megagroup);
     }
 
     public static boolean canWriteToChat(TLRPC.Chat chat) {
-        return !isChannel(chat) || (chat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0 || (chat.flags & TLRPC.CHAT_FLAG_USER_IS_EDITOR) != 0 || (chat.flags & TLRPC.CHAT_FLAG_IS_BROADCAST) == 0;
+        return !isChannel(chat) || chat.creator || chat.editor || !chat.broadcast;
     }
 
     public static TLRPC.Chat getChatByDialog(long did) {
         int lower_id = (int) did;
         int high_id = (int) (did >> 32);
-        if (high_id == 0 && lower_id < 0) {
-            MessagesController.getInstance().getChat(-lower_id);
+        if (lower_id < 0) {
+            return MessagesController.getInstance().getChat(-lower_id);
         }
         return null;
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ClearCacheService.java b/TMessagesProj/src/main/java/org/telegram/messenger/ClearCacheService.java
new file mode 100644
index 000000000..e0ee3635b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ClearCacheService.java
@@ -0,0 +1,77 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.messenger;
+
+import android.app.Activity;
+import android.app.IntentService;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Build;
+import android.system.Os;
+import android.system.StructStat;
+
+import java.io.File;
+import java.util.HashMap;
+
+public class ClearCacheService extends IntentService {
+
+    public ClearCacheService() {
+        super("ClearCacheService");
+    }
+
+    @Override
+    protected void onHandleIntent(Intent intent) {
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
+        final int keepMedia = preferences.getInt("keep_media", 2);
+        if (keepMedia == 2) {
+            return;
+        }
+        Utilities.globalQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                long currentTime = System.currentTimeMillis();
+                long diff = 60 * 60 * 1000 * 24 * (keepMedia == 0 ? 7 : 30);
+                final HashMap<Integer, File> paths = ImageLoader.getInstance().createMediaPaths();
+                for (HashMap.Entry<Integer, File> entry : paths.entrySet()) {
+                    if (entry.getKey() == FileLoader.MEDIA_DIR_CACHE) {
+                        continue;
+                    }
+                    try {
+                        File[] array = entry.getValue().listFiles();
+                        if (array != null) {
+                            for (int b = 0; b < array.length; b++) {
+                                File f = array[b];
+                                if (f.isFile()) {
+                                    if (Build.VERSION.SDK_INT >= 21) {
+                                        try {
+                                            StructStat stat = Os.stat(f.getPath());
+                                            if (stat.st_atime != 0) {
+                                                if (stat.st_atime + diff < currentTime) {
+                                                    f.delete();
+                                                }
+                                            } else if (stat.st_mtime + diff < currentTime) {
+                                                f.delete();
+                                            }
+                                        } catch (Exception e) {
+                                            FileLog.e("tmessages", e);
+                                        }
+                                    } else if (f.lastModified() + diff < currentTime) {
+                                        f.delete();
+                                    }
+                                }
+                            }
+                        }
+                    } catch (Throwable e) {
+                        FileLog.e("tmessages", e);
+                    }
+                }
+            }
+        });
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ContactsController.java b/TMessagesProj/src/main/java/org/telegram/messenger/ContactsController.java
index c0ee19250..4b4a9833b 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ContactsController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ContactsController.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -16,8 +16,10 @@
 import android.content.ContentResolver;
 import android.content.ContentValues;
 import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.net.Uri;
+import android.os.Build;
 import android.provider.BaseColumns;
 import android.provider.ContactsContract;
 import android.text.TextUtils;
@@ -206,8 +208,8 @@ public void checkAppAccount() {
         try {
             accounts = am.getAccountsByType("org.telegram.account");
             if (accounts != null && accounts.length > 0) {
-                for (Account c : accounts) {
-                    am.removeAccount(c, null, null);
+                for (int a = 0; a < accounts.length; a++) {
+                    am.removeAccount(accounts[a], null, null);
                 }
             }
         } catch (Exception e) {
@@ -219,7 +221,7 @@ public void checkAppAccount() {
         if (UserConfig.isClientActivated()) {
             if (accounts.length == 1) {
                 Account acc = accounts[0];
-                if (!acc.name.equals(UserConfig.getCurrentUser().phone)) {
+                if (!acc.name.equals("" + UserConfig.getClientUserId())) {
                     recreateAccount = true;
                 } else {
                     currentAccount = acc;
@@ -234,12 +236,16 @@ public void checkAppAccount() {
             }
         }
         if (recreateAccount) {
-            for (Account c : accounts) {
-                am.removeAccount(c, null, null);
+            try {
+                for (int a = 0; a < accounts.length; a++) {
+                    am.removeAccount(accounts[a], null, null);
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
             }
             if (UserConfig.isClientActivated()) {
                 try {
-                    currentAccount = new Account(UserConfig.getCurrentUser().phone, "org.telegram.messenger");
+                    currentAccount = new Account("" + UserConfig.getClientUserId(), "org.telegram.messenger");
                     am.addAccountExplicitly(currentAccount, "", null);
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -252,8 +258,8 @@ public void deleteAllAppAccounts() {
         try {
             AccountManager am = AccountManager.get(ApplicationLoader.applicationContext);
             Account[] accounts = am.getAccountsByType("org.telegram.messenger");
-            for (Account c : accounts) {
-                am.removeAccount(c, null, null);
+            for (int a = 0; a < accounts.length; a++) {
+                am.removeAccount(accounts[a], null, null);
             }
         } catch (Exception e) {
             e.printStackTrace();
@@ -275,6 +281,9 @@ public void run() {
     private boolean checkContactsInternal() {
         boolean reload = false;
         try {
+            if (!hasContactsPermission()) {
+                return false;
+            }
             ContentResolver cr = ApplicationLoader.applicationContext.getContentResolver();
             Cursor pCur = null;
             try {
@@ -329,6 +338,9 @@ public void run() {
     private HashMap<Integer, Contact> readContactsFromPhoneBook() {
         HashMap<Integer, Contact> contactsMap = new HashMap<>();
         try {
+            if (!hasContactsPermission()) {
+                return contactsMap;
+            }
             ContentResolver cr = ApplicationLoader.applicationContext.getContentResolver();
 
             HashMap<String, Contact> shortContacts = new HashMap<>();
@@ -1036,7 +1048,7 @@ public int compare(TLRPC.TL_contact tl_contact, TLRPC.TL_contact tl_contact2) {
                                 sortedSectionsArray.add(key);
                             }
                             arr.add(value);
-                            if ((user.flags & TLRPC.USER_FLAG_MUTUAL_CONTACT) != 0) {
+                            if (user.mutual_contact) {
                                 arr = sectionsDictMutual.get(key);
                                 if (arr == null) {
                                     arr = new ArrayList<>();
@@ -1272,8 +1284,36 @@ public int compare(String s, String s2) {
         sortedUsersSectionsArray = sortedSectionsArray;
     }
 
+    private boolean hasContactsPermission() {
+        if (Build.VERSION.SDK_INT >= 23) {
+            return ApplicationLoader.applicationContext.checkSelfPermission(android.Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED;
+        }
+        Cursor cursor = null;
+        try {
+            ContentResolver cr = ApplicationLoader.applicationContext.getContentResolver();
+            cursor = cr.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, projectionPhones, null, null, null);
+            if (cursor == null || cursor.getCount() == 0) {
+                return false;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        } finally {
+            try {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+        }
+        return true;
+    }
+
     private void performWriteContactsToPhoneBookInternal(ArrayList<TLRPC.TL_contact> contactsArray) {
         try {
+            if (!hasContactsPermission()) {
+                return;
+            }
             Uri rawContactUri = ContactsContract.RawContacts.CONTENT_URI.buildUpon().appendQueryParameter(ContactsContract.RawContacts.ACCOUNT_NAME, currentAccount.name).appendQueryParameter(ContactsContract.RawContacts.ACCOUNT_TYPE, currentAccount.type).build();
             Cursor c1 = ApplicationLoader.applicationContext.getContentResolver().query(rawContactUri, new String[]{BaseColumns._ID, ContactsContract.RawContacts.SYNC2}, null, null, null);
             HashMap<Integer, Long> bookContacts = new HashMap<>();
@@ -1283,7 +1323,8 @@ private void performWriteContactsToPhoneBookInternal(ArrayList<TLRPC.TL_contact>
                 }
                 c1.close();
 
-                for (TLRPC.TL_contact u : contactsArray) {
+                for (int a = 0; a < contactsArray.size(); a++) {
+                    TLRPC.TL_contact u = contactsArray.get(a);
                     if (!bookContacts.containsKey(u.user_id)) {
                         TLRPC.User user = MessagesController.getInstance().getUser(u.user_id);
                         addContactToPhoneBook(user, false);
@@ -1475,6 +1516,9 @@ public long addContactToPhoneBook(TLRPC.User user, boolean check) {
         if (currentAccount == null || user == null || user.phone == null || user.phone.length() == 0) {
             return -1;
         }
+        if (!hasContactsPermission()) {
+            return -1;
+        }
         long res = -1;
         synchronized (observerLock) {
             ignoreChanges = true;
@@ -1522,7 +1566,9 @@ public long addContactToPhoneBook(TLRPC.User user, boolean check) {
         query.add(builder.build());
         try {
             ContentProviderResult[] result = contentResolver.applyBatch(ContactsContract.AUTHORITY, query);
-            res = Long.parseLong(result[0].uri.getLastPathSegment());
+            if (result != null && result.length > 0 && result[0].uri != null) {
+                res = Long.parseLong(result[0].uri.getLastPathSegment());
+            }
         } catch (Exception e) {
             FileLog.e("tmessages", e);
         }
@@ -1533,11 +1579,14 @@ public long addContactToPhoneBook(TLRPC.User user, boolean check) {
     }
 
     private void deleteContactFromPhoneBook(int uid) {
-        ContentResolver contentResolver = ApplicationLoader.applicationContext.getContentResolver();
+        if (!hasContactsPermission()) {
+            return;
+        }
         synchronized (observerLock) {
             ignoreChanges = true;
         }
         try {
+            ContentResolver contentResolver = ApplicationLoader.applicationContext.getContentResolver();
             Uri rawContactUri = ContactsContract.RawContacts.CONTENT_URI.buildUpon().appendQueryParameter(ContactsContract.CALLER_IS_SYNCADAPTER, "true").appendQueryParameter(ContactsContract.RawContacts.ACCOUNT_NAME, currentAccount.name).appendQueryParameter(ContactsContract.RawContacts.ACCOUNT_TYPE, currentAccount.type).build();
             int value = contentResolver.delete(rawContactUri, ContactsContract.RawContacts.SYNC2 + " = " + uid, null);
         } catch (Exception e) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ContactsSyncAdapterService.java b/TMessagesProj/src/main/java/org/telegram/messenger/ContactsSyncAdapterService.java
index d6d3ecd32..1dac54c94 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ContactsSyncAdapterService.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ContactsSyncAdapterService.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/DispatchQueue.java b/TMessagesProj/src/main/java/org/telegram/messenger/DispatchQueue.java
index 529cbdbc5..b28d0a6e6 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/DispatchQueue.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/DispatchQueue.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -12,9 +12,12 @@
 import android.os.Looper;
 import android.os.Message;
 
+import java.util.concurrent.CountDownLatch;
+
 public class DispatchQueue extends Thread {
-    public volatile Handler handler = null;
-    private final Object handlerSyncObject = new Object();
+
+    private volatile Handler handler = null;
+    private CountDownLatch syncLatch = new CountDownLatch(1);
 
     public DispatchQueue(final String threadName) {
         setName(threadName);
@@ -22,40 +25,24 @@ public DispatchQueue(final String threadName) {
     }
 
     private void sendMessage(Message msg, int delay) {
-        if (handler == null) {
-            try {
-                synchronized (handlerSyncObject) {
-                    handlerSyncObject.wait();
-                }
-            } catch (Throwable t) {
-                t.printStackTrace();
-            }
-        }
-
-        if (handler != null) {
+        try {
+            syncLatch.await();
             if (delay <= 0) {
                 handler.sendMessage(msg);
             } else {
                 handler.sendMessageDelayed(msg, delay);
             }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
         }
     }
 
     public void cancelRunnable(Runnable runnable) {
-        if (handler == null) {
-            synchronized (handlerSyncObject) {
-                if (handler == null) {
-                    try {
-                        handlerSyncObject.wait();
-                    } catch (Throwable t) {
-                        t.printStackTrace();
-                    }
-                }
-            }
-        }
-
-        if (handler != null) {
+        try {
+            syncLatch.await();
             handler.removeCallbacks(runnable);
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
         }
     }
 
@@ -64,39 +51,32 @@ public void postRunnable(Runnable runnable) {
     }
 
     public void postRunnable(Runnable runnable, long delay) {
-        if (handler == null) {
-            synchronized (handlerSyncObject) {
-                if (handler == null) {
-                    try {
-                        handlerSyncObject.wait();
-                    } catch (Throwable t) {
-                        t.printStackTrace();
-                    }
-                }
-            }
-        }
-
-        if (handler != null) {
+        try {
+            syncLatch.await();
             if (delay <= 0) {
                 handler.post(runnable);
             } else {
                 handler.postDelayed(runnable, delay);
             }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
         }
     }
 
     public void cleanupQueue() {
-        if (handler != null) {
+        try {
+            syncLatch.await();
             handler.removeCallbacksAndMessages(null);
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
         }
     }
 
+    @Override
     public void run() {
         Looper.prepare();
-        synchronized (handlerSyncObject) {
-            handler = new Handler();
-            handlerSyncObject.notify();
-        }
+        handler = new Handler();
+        syncLatch.countDown();
         Looper.loop();
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/DownloadObject.java b/TMessagesProj/src/main/java/org/telegram/messenger/DownloadObject.java
index efb90ec94..9bfb579ce 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/DownloadObject.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/DownloadObject.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Emoji.java b/TMessagesProj/src/main/java/org/telegram/messenger/Emoji.java
index b82b7cb46..72992fc2f 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Emoji.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Emoji.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -18,6 +18,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
+import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.text.Spannable;
@@ -29,168 +30,23 @@
 import android.widget.TextView;
 
 public class Emoji {
-    private static HashMap<Long, DrawableInfo> rects = new HashMap<>();
+    private static HashMap<CharSequence, DrawableInfo> rects = new HashMap<>();
     private static int drawImgSize;
     private static int bigImgSize;
     private static boolean inited = false;
     private static Paint placeholderPaint;
-    private static Bitmap emojiBmp[] = new Bitmap[5];
-    private static boolean loadingEmoji[] = new boolean[5];
-
-    private static final int[] cols = {
-            13, 10, 15, 10, 14
-    };
-
-    private static final char[] emojiChars = {
-            0x00A9, 0x00AE, 0x203C, 0x2049, 0x2122, 0x2139, 0x2194, 0x2195, 0x2196, 0x2197,
-            0x2198, 0x2199, 0x21A9, 0x21AA, 0x231A, 0x231B, 0x23E9, 0x23EA, 0x23EB, 0x23EC,
-            0x23F0, 0x23F3, 0x24C2, 0x25AA, 0x25AB, 0x25B6, 0x25C0, 0x25FB, 0x25FC, 0x25FD,
-            0x25FE, 0x2600, 0x2601, 0x260E, 0x2611, 0x2614, 0x2615, 0x261D, 0x263A, 0x2648,
-            0x2649, 0x264A, 0x264B, 0x264C, 0x264D, 0x264E, 0x264F, 0x2650, 0x2651, 0x2652,
-            0x2653, 0x2660, 0x2663, 0x2665, 0x2666, 0x2668, 0x267B, 0x267F, 0x2693, 0x26A0,
-            0x26A1, 0x26AA, 0x26AB, 0x26BD, 0x26BE, 0x26C4, 0x26C5, 0x26CE, 0x26D4, 0x26EA,
-            0x26F2, 0x26F3, 0x26F5, 0x26FA, 0x26FD, 0x2702, 0x2705, 0x2708, 0x2709, 0x270A,
-            0x270B, 0x270C, 0x270F, 0x2712, 0x2714, 0x2716, 0x2728, 0x2733, 0x2734, 0x2744,
-            0x2747, 0x274C, 0x274E, 0x2753, 0x2754, 0x2755, 0x2757, 0x2764, 0x2795, 0x2796,
-            0x2797, 0x27A1, 0x27B0, 0x27BF, 0x2934, 0x2935, 0x2B05, 0x2B06, 0x2B07, 0x2B1B,
-            0x2B1C, 0x2B50, 0x2B55, 0x3030, 0x303D, 0x3297, 0x3299
+    private static final int splitCount = 4;
+    private static Bitmap emojiBmp[][] = new Bitmap[5][splitCount];
+    private static boolean loadingEmoji[][] = new boolean[5][splitCount];
+
+    private static final int[][] cols = {
+            {11, 11, 11, 11},
+            {6, 6, 6, 6},
+            {9, 9, 9, 9},
+            {9, 9, 9, 9},
+            {8, 8, 8, 7}
     };
 
-    public static long[][] data = {
-            new long[]//189
-                    {
-                            0x00000000D83DDE04L, 0x00000000D83DDE03L, 0x00000000D83DDE00L, 0x00000000D83DDE0AL, 0x000000000000263AL, 0x00000000D83DDE09L, 0x00000000D83DDE0DL,
-                            0x00000000D83DDE18L, 0x00000000D83DDE1AL, 0x00000000D83DDE17L, 0x00000000D83DDE19L, 0x00000000D83DDE1CL, 0x00000000D83DDE1DL, 0x00000000D83DDE1BL,
-                            0x00000000D83DDE33L, 0x00000000D83DDE01L, 0x00000000D83DDE14L, 0x00000000D83DDE0CL, 0x00000000D83DDE12L, 0x00000000D83DDE1EL, 0x00000000D83DDE23L,
-                            0x00000000D83DDE22L, 0x00000000D83DDE02L, 0x00000000D83DDE2DL, 0x00000000D83DDE2AL, 0x00000000D83DDE25L, 0x00000000D83DDE30L, 0x00000000D83DDE05L,
-                            0x00000000D83DDE13L, 0x00000000D83DDE29L, 0x00000000D83DDE2BL, 0x00000000D83DDE28L, 0x00000000D83DDE31L, 0x00000000D83DDE20L, 0x00000000D83DDE21L,
-                            0x00000000D83DDE24L, 0x00000000D83DDE16L, 0x00000000D83DDE06L, 0x00000000D83DDE0BL, 0x00000000D83DDE37L, 0x00000000D83DDE0EL, 0x00000000D83DDE34L,
-                            0x00000000D83DDE35L, 0x00000000D83DDE32L, 0x00000000D83DDE1FL, 0x00000000D83DDE26L, 0x00000000D83DDE27L, 0x00000000D83DDE08L, 0x00000000D83DDC7FL,
-                            0x00000000D83DDE2EL, 0x00000000D83DDE2CL, 0x00000000D83DDE10L, 0x00000000D83DDE15L, 0x00000000D83DDE2FL, 0x00000000D83DDE36L, 0x00000000D83DDE07L,
-                            0x00000000D83DDE0FL, 0x00000000D83DDE11L, 0x00000000D83DDC72L, 0x00000000D83DDC73L, 0x00000000D83DDC6EL, 0x00000000D83DDC77L, 0x00000000D83DDC82L,
-                            0x00000000D83DDC76L, 0x00000000D83DDC66L, 0x00000000D83DDC67L, 0x00000000D83DDC68L, 0x00000000D83DDC69L, 0x00000000D83DDC74L, 0x00000000D83DDC75L,
-                            0x00000000D83DDC71L, 0x00000000D83DDC7CL, 0x00000000D83DDC78L, 0x00000000D83DDE3AL, 0x00000000D83DDE38L, 0x00000000D83DDE3BL, 0x00000000D83DDE3DL,
-                            0x00000000D83DDE3CL, 0x00000000D83DDE40L, 0x00000000D83DDE3FL, 0x00000000D83DDE39L, 0x00000000D83DDE3EL, 0x00000000D83DDC79L, 0x00000000D83DDC7AL,
-                            0x00000000D83DDE48L, 0x00000000D83DDE49L, 0x00000000D83DDE4AL, 0x00000000D83DDC80L, 0x00000000D83DDC7DL, 0x00000000D83DDCA9L, 0x00000000D83DDD25L,
-                            0x0000000000002728L, 0x00000000D83CDF1FL, 0x00000000D83DDCABL, 0x00000000D83DDCA5L, 0x00000000D83DDCA2L, 0x00000000D83DDCA6L, 0x00000000D83DDCA7L,
-                            0x00000000D83DDCA4L, 0x00000000D83DDCA8L, 0x00000000D83DDC42L, 0x00000000D83DDC40L, 0x00000000D83DDC43L, 0x00000000D83DDC45L, 0x00000000D83DDC44L,
-                            0x00000000D83DDC4DL, 0x00000000D83DDC4EL, 0x00000000D83DDC4CL, 0x00000000D83DDC4AL, 0x000000000000270AL, 0x000000000000270CL, 0x00000000D83DDC4BL,
-                            0x000000000000270BL, 0x00000000D83DDC50L, 0x00000000D83DDC46L, 0x00000000D83DDC47L, 0x00000000D83DDC49L, 0x00000000D83DDC48L, 0x00000000D83DDE4CL,
-                            0x00000000D83DDE4FL, 0x000000000000261DL, 0x00000000D83DDC4FL, 0x00000000D83DDCAAL, 0x00000000D83DDEB6L, 0x00000000D83CDFC3L, 0x00000000D83DDC83L,
-                            0x00000000D83DDC6BL, 0x00000000D83DDC6AL, 0x00000000D83DDC6CL, 0x00000000D83DDC6DL, 0x00000000D83DDC8FL, 0x00000000D83DDC91L, 0x00000000D83DDC6FL,
-                            0x00000000D83DDE46L, 0x00000000D83DDE45L, 0x00000000D83DDC81L, 0x00000000D83DDE4BL, 0x00000000D83DDC86L, 0x00000000D83DDC87L, 0x00000000D83DDC85L,
-                            0x00000000D83DDC70L, 0x00000000D83DDE4EL, 0x00000000D83DDE4DL, 0x00000000D83DDE47L, 0x00000000D83CDFA9L, 0x00000000D83DDC51L, 0x00000000D83DDC52L,
-                            0x00000000D83DDC5FL, 0x00000000D83DDC5EL, 0x00000000D83DDC61L, 0x00000000D83DDC60L, 0x00000000D83DDC62L, 0x00000000D83DDC55L, 0x00000000D83DDC54L,
-                            0x00000000D83DDC5AL, 0x00000000D83DDC57L, 0x00000000D83CDFBDL, 0x00000000D83DDC56L, 0x00000000D83DDC58L, 0x00000000D83DDC59L, 0x00000000D83DDCBCL,
-                            0x00000000D83DDC5CL, 0x00000000D83DDC5DL, 0x00000000D83DDC5BL, 0x00000000D83DDC53L, 0x00000000D83CDF80L, 0x00000000D83CDF02L, 0x00000000D83DDC84L,
-                            0x00000000D83DDC9BL, 0x00000000D83DDC99L, 0x00000000D83DDC9CL, 0x00000000D83DDC9AL, 0x0000000000002764L, 0x00000000D83DDC94L, 0x00000000D83DDC97L,
-                            0x00000000D83DDC93L, 0x00000000D83DDC95L, 0x00000000D83DDC96L, 0x00000000D83DDC9EL, 0x00000000D83DDC98L, 0x00000000D83DDC8CL, 0x00000000D83DDC8BL,
-                            0x00000000D83DDC8DL, 0x00000000D83DDC8EL, 0x00000000D83DDC64L, 0x00000000D83DDC65L, 0x00000000D83DDCACL, 0x00000000D83DDC63L, 0x00000000D83DDCADL},
-            new long[]//116
-                    {
-                            0x00000000D83DDC36L, 0x00000000D83DDC3AL, 0x00000000D83DDC31L, 0x00000000D83DDC2DL, 0x00000000D83DDC39L, 0x00000000D83DDC30L, 0x00000000D83DDC38L, 0x00000000D83DDC2FL,
-                            0x00000000D83DDC28L, 0x00000000D83DDC3BL, 0x00000000D83DDC37L, 0x00000000D83DDC3DL, 0x00000000D83DDC2EL, 0x00000000D83DDC17L, 0x00000000D83DDC35L,
-                            0x00000000D83DDC12L, 0x00000000D83DDC34L, 0x00000000D83DDC11L, 0x00000000D83DDC18L, 0x00000000D83DDC3CL, 0x00000000D83DDC27L, 0x00000000D83DDC26L,
-                            0x00000000D83DDC24L, 0x00000000D83DDC25L, 0x00000000D83DDC23L, 0x00000000D83DDC14L, 0x00000000D83DDC0DL, 0x00000000D83DDC22L, 0x00000000D83DDC1BL,
-                            0x00000000D83DDC1DL, 0x00000000D83DDC1CL, 0x00000000D83DDC1EL, 0x00000000D83DDC0CL, 0x00000000D83DDC19L, 0x00000000D83DDC1AL, 0x00000000D83DDC20L,
-                            0x00000000D83DDC1FL, 0x00000000D83DDC2CL, 0x00000000D83DDC33L, 0x00000000D83DDC0BL, 0x00000000D83DDC04L, 0x00000000D83DDC0FL, 0x00000000D83DDC00L,
-                            0x00000000D83DDC03L, 0x00000000D83DDC05L, 0x00000000D83DDC07L, 0x00000000D83DDC09L, 0x00000000D83DDC0EL, 0x00000000D83DDC10L, 0x00000000D83DDC13L,
-                            0x00000000D83DDC15L, 0x00000000D83DDC16L, 0x00000000D83DDC01L, 0x00000000D83DDC02L, 0x00000000D83DDC32L, 0x00000000D83DDC21L, 0x00000000D83DDC0AL,
-                            0x00000000D83DDC2BL, 0x00000000D83DDC2AL, 0x00000000D83DDC06L, 0x00000000D83DDC08L, 0x00000000D83DDC29L, 0x00000000D83DDC3EL, 0x00000000D83DDC90L,
-                            0x00000000D83CDF38L, 0x00000000D83CDF37L, 0x00000000D83CDF40L, 0x00000000D83CDF39L, 0x00000000D83CDF3BL, 0x00000000D83CDF3AL, 0x00000000D83CDF41L,
-                            0x00000000D83CDF43L, 0x00000000D83CDF42L, 0x00000000D83CDF3FL, 0x00000000D83CDF3EL, 0x00000000D83CDF44L, 0x00000000D83CDF35L, 0x00000000D83CDF34L,
-                            0x00000000D83CDF32L, 0x00000000D83CDF33L, 0x00000000D83CDF30L, 0x00000000D83CDF31L, 0x00000000D83CDF3CL, 0x00000000D83CDF10L, 0x00000000D83CDF1EL,
-                            0x00000000D83CDF1DL, 0x00000000D83CDF1AL, 0x00000000D83CDF11L, 0x00000000D83CDF12L, 0x00000000D83CDF13L, 0x00000000D83CDF14L, 0x00000000D83CDF15L,
-                            0x00000000D83CDF16L, 0x00000000D83CDF17L, 0x00000000D83CDF18L, 0x00000000D83CDF1CL, 0x00000000D83CDF1BL, 0x00000000D83CDF19L, 0x00000000D83CDF0DL,
-                            0x00000000D83CDF0EL, 0x00000000D83CDF0FL, 0x00000000D83CDF0BL, 0x00000000D83CDF0CL, 0x00000000D83CDF20L, 0x0000000000002B50L, 0x0000000000002600L,
-                            0x00000000000026C5L, 0x0000000000002601L, 0x00000000000026A1L, 0x0000000000002614L, 0x0000000000002744L, 0x00000000000026C4L, 0x00000000D83CDF00L,
-                            0x00000000D83CDF01L, 0x00000000D83CDF08L, 0x00000000D83CDF0AL},
-            new long[]//230
-                    {
-                            0x00000000D83CDF8DL, 0x00000000D83DDC9DL, 0x00000000D83CDF8EL, 0x00000000D83CDF92L, 0x00000000D83CDF93L, 0x00000000D83CDF8FL, 0x00000000D83CDF86L, 0x00000000D83CDF87L,
-                            0x00000000D83CDF90L, 0x00000000D83CDF91L, 0x00000000D83CDF83L, 0x00000000D83DDC7BL, 0x00000000D83CDF85L, 0x00000000D83CDF84L, 0x00000000D83CDF81L,
-                            0x00000000D83CDF8BL, 0x00000000D83CDF89L, 0x00000000D83CDF8AL, 0x00000000D83CDF88L, 0x00000000D83CDF8CL, 0x00000000D83DDD2EL, 0x00000000D83CDFA5L,
-                            0x00000000D83DDCF7L, 0x00000000D83DDCF9L, 0x00000000D83DDCFCL, 0x00000000D83DDCBFL, 0x00000000D83DDCC0L, 0x00000000D83DDCBDL, 0x00000000D83DDCBEL,
-                            0x00000000D83DDCBBL, 0x00000000D83DDCF1L, 0x000000000000260EL, 0x00000000D83DDCDEL, 0x00000000D83DDCDFL, 0x00000000D83DDCE0L, 0x00000000D83DDCE1L,
-                            0x00000000D83DDCFAL, 0x00000000D83DDCFBL, 0x00000000D83DDD0AL, 0x00000000D83DDD09L, 0x00000000D83DDD08L, 0x00000000D83DDD07L, 0x00000000D83DDD14L,
-                            0x00000000D83DDD15L, 0x00000000D83DDCE2L, 0x00000000D83DDCE3L, 0x00000000000023F3L, 0x000000000000231BL, 0x00000000000023F0L, 0x000000000000231AL,
-                            0x00000000D83DDD13L, 0x00000000D83DDD12L, 0x00000000D83DDD0FL, 0x00000000D83DDD10L, 0x00000000D83DDD11L, 0x00000000D83DDD0EL, 0x00000000D83DDCA1L,
-                            0x00000000D83DDD26L, 0x00000000D83DDD06L, 0x00000000D83DDD05L, 0x00000000D83DDD0CL, 0x00000000D83DDD0BL, 0x00000000D83DDD0DL, 0x00000000D83DDEC1L, 0x00000000D83DDEC0L,
-                            0x00000000D83DDEBFL, 0x00000000D83DDEBDL, 0x00000000D83DDD27L, 0x00000000D83DDD29L, 0x00000000D83DDD28L, 0x00000000D83DDEAAL, 0x00000000D83DDEACL,
-                            0x00000000D83DDCA3L, 0x00000000D83DDD2BL, 0x00000000D83DDD2AL, 0x00000000D83DDC8AL, 0x00000000D83DDC89L, 0x00000000D83DDCB0L, 0x00000000D83DDCB4L,
-                            0x00000000D83DDCB5L, 0x00000000D83DDCB7L, 0x00000000D83DDCB6L, 0x00000000D83DDCB3L, 0x00000000D83DDCB8L, 0x00000000D83DDCF2L, 0x00000000D83DDCE7L,
-                            0x00000000D83DDCE5L, 0x00000000D83DDCE4L, 0x0000000000002709L, 0x00000000D83DDCE9L, 0x00000000D83DDCE8L, 0x00000000D83DDCEFL, 0x00000000D83DDCEBL,
-                            0x00000000D83DDCEAL, 0x00000000D83DDCECL, 0x00000000D83DDCEDL, 0x00000000D83DDCEEL, 0x00000000D83DDCE6L, 0x00000000D83DDCDDL, 0x00000000D83DDCC4L,
-                            0x00000000D83DDCC3L, 0x00000000D83DDCD1L, 0x00000000D83DDCCAL, 0x00000000D83DDCC8L, 0x00000000D83DDCC9L, 0x00000000D83DDCDCL, 0x00000000D83DDCCBL,
-                            0x00000000D83DDCC5L, 0x00000000D83DDCC6L, 0x00000000D83DDCC7L, 0x00000000D83DDCC1L, 0x00000000D83DDCC2L, 0x0000000000002702L, 0x00000000D83DDCCCL,
-                            0x00000000D83DDCCEL, 0x0000000000002712L, 0x000000000000270FL, 0x00000000D83DDCCFL, 0x00000000D83DDCD0L, 0x00000000D83DDCD5L, 0x00000000D83DDCD7L,
-                            0x00000000D83DDCD8L, 0x00000000D83DDCD9L, 0x00000000D83DDCD3L, 0x00000000D83DDCD4L, 0x00000000D83DDCD2L, 0x00000000D83DDCDAL, 0x00000000D83DDCD6L,
-                            0x00000000D83DDD16L, 0x00000000D83DDCDBL, 0x00000000D83DDD2CL, 0x00000000D83DDD2DL, 0x00000000D83DDCF0L, 0x00000000D83CDFA8L, 0x00000000D83CDFACL,
-                            0x00000000D83CDFA4L, 0x00000000D83CDFA7L, 0x00000000D83CDFBCL, 0x00000000D83CDFB5L, 0x00000000D83CDFB6L, 0x00000000D83CDFB9L, 0x00000000D83CDFBBL,
-                            0x00000000D83CDFBAL, 0x00000000D83CDFB7L, 0x00000000D83CDFB8L, 0x00000000D83DDC7EL, 0x00000000D83CDFAEL, 0x00000000D83CDCCFL, 0x00000000D83CDFB4L,
-                            0x00000000D83CDC04L, 0x00000000D83CDFB2L, 0x00000000D83CDFAFL, 0x00000000D83CDFC8L, 0x00000000D83CDFC0L, 0x00000000000026BDL, 0x00000000000026BEL,
-                            0x00000000D83CDFBEL, 0x00000000D83CDFB1L, 0x00000000D83CDFC9L, 0x00000000D83CDFB3L, 0x00000000000026F3L, 0x00000000D83DDEB5L, 0x00000000D83DDEB4L,
-                            0x00000000D83CDFC1L, 0x00000000D83CDFC7L, 0x00000000D83CDFC6L, 0x00000000D83CDFBFL, 0x00000000D83CDFC2L, 0x00000000D83CDFCAL, 0x00000000D83CDFC4L,
-                            0x00000000D83CDFA3L, 0x0000000000002615L, 0x00000000D83CDF75L, 0x00000000D83CDF76L, 0x00000000D83CDF7CL, 0x00000000D83CDF7AL, 0x00000000D83CDF7BL,
-                            0x00000000D83CDF78L, 0x00000000D83CDF79L, 0x00000000D83CDF77L, 0x00000000D83CDF74L, 0x00000000D83CDF55L, 0x00000000D83CDF54L, 0x00000000D83CDF5FL,
-                            0x00000000D83CDF57L, 0x00000000D83CDF56L, 0x00000000D83CDF5DL, 0x00000000D83CDF5BL, 0x00000000D83CDF64L, 0x00000000D83CDF71L, 0x00000000D83CDF63L,
-                            0x00000000D83CDF65L, 0x00000000D83CDF59L, 0x00000000D83CDF58L, 0x00000000D83CDF5AL, 0x00000000D83CDF5CL, 0x00000000D83CDF72L, 0x00000000D83CDF62L,
-                            0x00000000D83CDF61L, 0x00000000D83CDF73L, 0x00000000D83CDF5EL, 0x00000000D83CDF69L, 0x00000000D83CDF6EL, 0x00000000D83CDF66L, 0x00000000D83CDF68L,
-                            0x00000000D83CDF67L, 0x00000000D83CDF82L, 0x00000000D83CDF70L, 0x00000000D83CDF6AL, 0x00000000D83CDF6BL, 0x00000000D83CDF6CL, 0x00000000D83CDF6DL,
-                            0x00000000D83CDF6FL, 0x00000000D83CDF4EL, 0x00000000D83CDF4FL, 0x00000000D83CDF4AL, 0x00000000D83CDF4BL, 0x00000000D83CDF52L, 0x00000000D83CDF47L,
-                            0x00000000D83CDF49L, 0x00000000D83CDF53L, 0x00000000D83CDF51L, 0x00000000D83CDF48L, 0x00000000D83CDF4CL, 0x00000000D83CDF50L, 0x00000000D83CDF4DL,
-                            0x00000000D83CDF60L, 0x00000000D83CDF46L, 0x00000000D83CDF45L, 0x00000000D83CDF3DL},
-            new long[]//101
-                    {
-                            0x00000000D83CDFE0L, 0x00000000D83CDFE1L, 0x00000000D83CDFEBL, 0x00000000D83CDFE2L, 0x00000000D83CDFE3L, 0x00000000D83CDFE5L, 0x00000000D83CDFE6L, 0x00000000D83CDFEAL,
-                            0x00000000D83CDFE9L, 0x00000000D83CDFE8L, 0x00000000D83DDC92L, 0x00000000000026EAL, 0x00000000D83CDFECL, 0x00000000D83CDFE4L, 0x00000000D83CDF07L,
-                            0x00000000D83CDF06L, 0x00000000D83CDFEFL, 0x00000000D83CDFF0L, 0x00000000000026FAL, 0x00000000D83CDFEDL, 0x00000000D83DDDFCL, 0x00000000D83DDDFEL,
-                            0x00000000D83DDDFBL, 0x00000000D83CDF04L, 0x00000000D83CDF05L, 0x00000000D83CDF03L, 0x00000000D83DDDFDL, 0x00000000D83CDF09L, 0x00000000D83CDFA0L,
-                            0x00000000D83CDFA1L, 0x00000000000026F2L, 0x00000000D83CDFA2L, 0x00000000D83DDEA2L, 0x00000000000026F5L, 0x00000000D83DDEA4L, 0x00000000D83DDEA3L,
-                            0x0000000000002693L, 0x00000000D83DDE80L, 0x0000000000002708L, 0x00000000D83DDCBAL, 0x00000000D83DDE81L, 0x00000000D83DDE82L, 0x00000000D83DDE8AL,
-                            0x00000000D83DDE89L, 0x00000000D83DDE9EL, 0x00000000D83DDE86L, 0x00000000D83DDE84L, 0x00000000D83DDE85L, 0x00000000D83DDE88L, 0x00000000D83DDE87L,
-                            0x00000000D83DDE9DL, 0x00000000D83DDE8BL, 0x00000000D83DDE83L, 0x00000000D83DDE8EL, 0x00000000D83DDE8CL, 0x00000000D83DDE8DL, 0x00000000D83DDE99L,
-                            0x00000000D83DDE98L, 0x00000000D83DDE97L, 0x00000000D83DDE95L, 0x00000000D83DDE96L, 0x00000000D83DDE9BL, 0x00000000D83DDE9AL, 0x00000000D83DDEA8L,
-                            0x00000000D83DDE93L, 0x00000000D83DDE94L, 0x00000000D83DDE92L, 0x00000000D83DDE91L, 0x00000000D83DDE90L, 0x00000000D83DDEB2L, 0x00000000D83DDEA1L,
-                            0x00000000D83DDE9FL, 0x00000000D83DDEA0L, 0x00000000D83DDE9CL, 0x00000000D83DDC88L, 0x00000000D83DDE8FL, 0x00000000D83CDFABL, 0x00000000D83DDEA6L,
-                            0x00000000D83DDEA5L, 0x00000000000026A0L, 0x00000000D83DDEA7L, 0x00000000D83DDD30L, 0x00000000000026FDL, 0x00000000D83CDFEEL, 0x00000000D83CDFB0L,
-                            0x0000000000002668L, 0x00000000D83DDDFFL, 0x00000000D83CDFAAL, 0x00000000D83CDFADL, 0x00000000D83DDCCDL, 0x00000000D83DDEA9L, 0xD83CDDEFD83CDDF5L,
-                            0xD83CDDF0D83CDDF7L, 0xD83CDDE9D83CDDEAL, 0xD83CDDE8D83CDDF3L, 0xD83CDDFAD83CDDF8L, 0xD83CDDEBD83CDDF7L, 0xD83CDDEAD83CDDF8L, 0xD83CDDEED83CDDF9L,
-                            0xD83CDDF7D83CDDFAL, 0xD83CDDECD83CDDE7L},
-            new long[]//209
-                    {
-                            0x00000000003120E3L, 0x00000000003220E3L, 0x00000000003320E3L, 0x00000000003420E3L, 0x00000000003520E3L, 0x00000000003620E3L, 0x00000000003720E3L,
-                            0x00000000003820E3L, 0x00000000003920E3L, 0x00000000003020E3L, 0x00000000D83DDD1FL, 0x00000000D83DDD22L, 0x00000000002320E3L, 0x00000000D83DDD23L,
-                            0x0000000000002B06L, 0x0000000000002B07L, 0x0000000000002B05L, 0x00000000000027A1L, 0x00000000D83DDD20L, 0x00000000D83DDD21L, 0x00000000D83DDD24L,
-                            0x0000000000002197L, 0x0000000000002196L, 0x0000000000002198L, 0x0000000000002199L, 0x0000000000002194L, 0x0000000000002195L, 0x00000000D83DDD04L,
-                            0x00000000000025C0L, 0x00000000000025B6L, 0x00000000D83DDD3CL, 0x00000000D83DDD3DL, 0x00000000000021A9L, 0x00000000000021AAL, 0x0000000000002139L,
-                            0x00000000000023EAL, 0x00000000000023E9L, 0x00000000000023EBL, 0x00000000000023ECL, 0x0000000000002935L, 0x0000000000002934L, 0x00000000D83CDD97L,
-                            0x00000000D83DDD00L, 0x00000000D83DDD01L, 0x00000000D83DDD02L, 0x00000000D83CDD95L, 0x00000000D83CDD99L, 0x00000000D83CDD92L, 0x00000000D83CDD93L,
-                            0x00000000D83CDD96L, 0x00000000D83DDCF6L, 0x00000000D83CDFA6L, 0x00000000D83CDE01L, 0x00000000D83CDE2FL, 0x00000000D83CDE33L, 0x00000000D83CDE35L,
-                            0x00000000D83CDE32L, 0x00000000D83CDE34L, 0x00000000D83CDE50L, 0x00000000D83CDE39L, 0x00000000D83CDE3AL, 0x00000000D83CDE36L, 0x00000000D83CDE1AL,
-                            0x00000000D83DDEBBL, 0x00000000D83DDEB9L, 0x00000000D83DDEBAL, 0x00000000D83DDEBCL, 0x00000000D83DDEBEL, 0x00000000D83DDEB0L, 0x00000000D83DDEAEL,
-                            0x00000000D83CDD7FL, 0x000000000000267FL, 0x00000000D83DDEADL, 0x00000000D83CDE37L, 0x00000000D83CDE38L, 0x00000000D83CDE02L, 0x00000000000024C2L,
-                            0x00000000D83DDEC2L, 0x00000000D83DDEC4L, 0x00000000D83DDEC5L, 0x00000000D83DDEC3L, 0x00000000D83CDE51L, 0x0000000000003299L, 0x0000000000003297L,
-                            0x00000000D83CDD91L, 0x00000000D83CDD98L, 0x00000000D83CDD94L, 0x00000000D83DDEABL,
-                            0x00000000D83DDD1EL, 0x00000000D83DDCF5L, 0x00000000D83DDEAFL, 0x00000000D83DDEB1L, 0x00000000D83DDEB3L, 0x00000000D83DDEB7L, 0x00000000D83DDEB8L,
-                            0x00000000000026D4L, 0x0000000000002733L, 0x0000000000002747L, 0x000000000000274EL, 0x0000000000002705L, 0x0000000000002734L, 0x00000000D83DDC9FL,
-                            0x00000000D83CDD9AL, 0x00000000D83DDCF3L, 0x00000000D83DDCF4L, 0x00000000D83CDD70L, 0x00000000D83CDD71L, 0x00000000D83CDD8EL, 0x00000000D83CDD7EL,
-                            0x00000000D83DDCA0L, 0x00000000000027BFL, 0x000000000000267BL, 0x0000000000002648L, 0x0000000000002649L, 0x000000000000264AL, 0x000000000000264BL,
-                            0x000000000000264CL, 0x000000000000264DL, 0x000000000000264EL, 0x000000000000264FL, 0x0000000000002650L, 0x0000000000002651L, 0x0000000000002652L,
-                            0x0000000000002653L, 0x00000000000026CEL, 0x00000000D83DDD2FL, 0x00000000D83CDFE7L, 0x00000000D83DDCB9L, 0x00000000D83DDCB2L, 0x00000000D83DDCB1L,
-                            0x00000000000000A9L, 0x00000000000000AEL, 0x0000000000002122L, 0x000000000000303DL, 0x0000000000003030L, 0x00000000D83DDD1DL, 0x00000000D83DDD1AL,
-                            0x00000000D83DDD19L, 0x00000000D83DDD1BL, 0x00000000D83DDD1CL, 0x000000000000274CL, 0x0000000000002B55L, 0x0000000000002757L, 0x000000000000203CL,
-                            0x0000000000002049L, 0x0000000000002753L,
-                            0x0000000000002755L, 0x0000000000002754L, 0x00000000D83DDD03L, 0x00000000D83DDD5BL, 0x00000000D83DDD67L, 0x00000000D83DDD50L, 0x00000000D83DDD5CL,
-                            0x00000000D83DDD51L, 0x00000000D83DDD5DL, 0x00000000D83DDD52L, 0x00000000D83DDD5EL, 0x00000000D83DDD53L, 0x00000000D83DDD5FL, 0x00000000D83DDD54L,
-                            0x00000000D83DDD60L, 0x00000000D83DDD55L, 0x00000000D83DDD56L, 0x00000000D83DDD57L, 0x00000000D83DDD58L, 0x00000000D83DDD59L, 0x00000000D83DDD5AL,
-                            0x00000000D83DDD61L, 0x00000000D83DDD62L, 0x00000000D83DDD63L, 0x00000000D83DDD64L, 0x00000000D83DDD65L, 0x00000000D83DDD66L, 0x0000000000002716L,
-                            0x0000000000002795L, 0x0000000000002796L, 0x0000000000002797L, 0x0000000000002660L, 0x0000000000002665L, 0x0000000000002663L, 0x0000000000002666L,
-                            0x00000000D83DDCAEL, 0x00000000D83DDCAFL, 0x0000000000002714L, 0x0000000000002611L, 0x00000000D83DDD18L, 0x00000000D83DDD17L, 0x00000000000027B0L,
-                            0x00000000D83DDD31L, 0x00000000D83DDD32L, 0x00000000D83DDD33L, 0x00000000000025FCL, 0x00000000000025FBL, 0x00000000000025FEL, 0x00000000000025FDL,
-                            0x00000000000025AAL, 0x00000000000025ABL, 0x00000000D83DDD3AL, 0x0000000000002B1CL, 0x0000000000002B1BL, 0x00000000000026ABL, 0x00000000000026AAL,
-                            0x00000000D83DDD34L, 0x00000000D83DDD35L, 0x00000000D83DDD3BL, 0x00000000D83DDD36L, 0x00000000D83DDD37L, 0x00000000D83DDD38L, 0x00000000D83DDD39L}};
-
     static {
         int emojiFullSize;
         if (AndroidUtilities.density <= 1.0f) {
@@ -200,26 +56,26 @@
         } else if (AndroidUtilities.density <= 2.0f) {
             emojiFullSize = 64;
         } else {
-            emojiFullSize = 96;
+            emojiFullSize = 64;
         }
         drawImgSize = AndroidUtilities.dp(20);
-        if (AndroidUtilities.isTablet()) {
-            bigImgSize = AndroidUtilities.dp(40);
-        } else {
-            bigImgSize = AndroidUtilities.dp(32);
-        }
-
-        for (int j = 0; j < data.length; j++) {
-            for (int i = 0; i < data[j].length; i++) {
-                Rect rect = new Rect((i % cols[j]) * emojiFullSize, (i / cols[j]) * emojiFullSize, (i % cols[j] + 1) * emojiFullSize, (i / cols[j] + 1) * emojiFullSize);
-                rects.put(data[j][i], new DrawableInfo(rect, (byte) j));
+        bigImgSize = AndroidUtilities.dp(AndroidUtilities.isTablet() ? 40 : 32);
+
+        for (int j = 0; j < EmojiData.data.length; j++) {
+            int count2 = (int) Math.ceil(EmojiData.data[j].length / (float) splitCount);
+            int position;
+            for (int i = 0; i < EmojiData.data[j].length; i++) {
+                int page = i / count2;
+                position = i - page * count2;
+                Rect rect = new Rect((position % cols[j][page]) * emojiFullSize, (position / cols[j][page]) * emojiFullSize, (position % cols[j][page] + 1) * emojiFullSize, (position / cols[j][page] + 1) * emojiFullSize);
+                rects.put(EmojiData.data[j][i], new DrawableInfo(rect, (byte) j, (byte) page));
             }
         }
         placeholderPaint = new Paint();
         placeholderPaint.setColor(0x00000000);
     }
 
-    private static void loadEmoji(final int page) {
+    private static void loadEmoji(final int page, final int page2) {
         try {
             float scale;
             int imageResize = 1;
@@ -232,28 +88,31 @@ private static void loadEmoji(final int page) {
             } else if (AndroidUtilities.density <= 2.0f) {
                 scale = 2.0f;
             } else {
-                scale = 3.0f;
+                scale = 2.0f;
             }
 
             String imageName;
             File imageFile;
 
             try {
-                imageName = String.format(Locale.US, "emoji%.01fx_%d.jpg", scale, page);
-                imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
-                if (imageFile.exists()) {
-                    imageFile.delete();
-                }
-                imageName = String.format(Locale.US, "emoji%.01fx_a_%d.jpg", scale, page);
-                imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
-                if (imageFile.exists()) {
-                    imageFile.delete();
+                for (int a = 4; a < 6; a++) {
+                    imageName = String.format(Locale.US, "v%d_emoji%.01fx_%d.jpg", a, scale, page);
+                    imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
+                    if (imageFile.exists()) {
+                        imageFile.delete();
+                    }
+                    imageName = String.format(Locale.US, "v%d_emoji%.01fx_a_%d.jpg", a, scale, page);
+                    imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
+                    if (imageFile.exists()) {
+                        imageFile.delete();
+                    }
                 }
             } catch (Exception e) {
                 FileLog.e("tmessages", e);
             }
 
-            imageName = String.format(Locale.US, "v4_emoji%.01fx_%d.jpg", scale, page);
+
+            imageName = String.format(Locale.US, "v7_emoji%.01fx_%d_%d.jpg", scale, page, page2);
             imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
             if (!imageFile.exists()) {
                 InputStream is = ApplicationLoader.applicationContext.getAssets().open("emoji/" + imageName);
@@ -272,7 +131,7 @@ private static void loadEmoji(final int page) {
             final Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
             Utilities.loadBitmap(imageFile.getAbsolutePath(), bitmap, imageResize, width, height, stride);
 
-            imageName = String.format(Locale.US, "v4_emoji%.01fx_a_%d.jpg", scale, page);
+            imageName = String.format(Locale.US, "v7_emoji%.01fx_a_%d_%d.jpg", scale, page, page2);
             imageFile = ApplicationLoader.applicationContext.getFileStreamPath(imageName);
             if (!imageFile.exists()) {
                 InputStream is = ApplicationLoader.applicationContext.getAssets().open("emoji/" + imageName);
@@ -285,7 +144,7 @@ private static void loadEmoji(final int page) {
             AndroidUtilities.runOnUIThread(new Runnable() {
                 @Override
                 public void run() {
-                    emojiBmp[page] = bitmap;
+                    emojiBmp[page][page2] = bitmap;
                     NotificationCenter.getInstance().postNotificationName(NotificationCenter.emojiDidLoaded);
                 }
             });
@@ -294,19 +153,6 @@ public void run() {
         }
     }
 
-    private static void loadEmojiAsync(final int page) {
-        if (loadingEmoji[page]) {
-            return;
-        }
-        loadingEmoji[page] = true;
-        new Thread(new Runnable() {
-            public void run() {
-                loadEmoji(page);
-                loadingEmoji[page] = false;
-            }
-        }).start();
-    }
-
     public static void invalidateAll(View view) {
         if (view instanceof ViewGroup) {
             ViewGroup g = (ViewGroup) view;
@@ -318,10 +164,41 @@ public static void invalidateAll(View view) {
         }
     }
 
-    public static EmojiDrawable getEmojiDrawable(long code) {
+    public static String fixEmoji(String emoji) {
+        char ch;
+        int lenght = emoji.length();
+        for (int a = 0; a < lenght; a++) {
+            ch = emoji.charAt(a);
+            if (ch >= 0xD83C && ch <= 0xD83E) {
+                if (ch == 0xD83C && a < lenght - 1) {
+                    ch = emoji.charAt(a + 1);
+                    if (ch == 0xDE2F || ch == 0xDC04 || ch == 0xDE1A || ch == 0xDD7F) {
+                        emoji = emoji.substring(0, a + 2) + "\uFE0F" + emoji.substring(a + 2);
+                        lenght++;
+                        a += 2;
+                    } else {
+                        a++;
+                    }
+                } else {
+                    a++;
+                }
+            } else if (ch == 0x20E3) {
+                return emoji;
+            } else if (ch >= 0x203C && ch <= 0x3299) {
+                if (EmojiData.emojiToFE0FMap.containsKey(ch)) {
+                    emoji = emoji.substring(0, a + 1) + "\uFE0F" + emoji.substring(a + 1);
+                    lenght++;
+                    a++;
+                }
+            }
+        }
+        return emoji;
+    }
+
+    public static EmojiDrawable getEmojiDrawable(CharSequence code) {
         DrawableInfo info = rects.get(code);
         if (info == null) {
-            FileLog.e("tmessages", "No emoji drawable for code " + String.format("%016X", code));
+            FileLog.e("tmessages", "No drawable for emoji " + code);
             return null;
         }
         EmojiDrawable ed = new EmojiDrawable(info);
@@ -329,7 +206,7 @@ public static EmojiDrawable getEmojiDrawable(long code) {
         return ed;
     }
 
-    public static Drawable getEmojiBigDrawable(long code) {
+    public static Drawable getEmojiBigDrawable(String code) {
         EmojiDrawable ed = getEmojiDrawable(code);
         if (ed == null) {
             return null;
@@ -342,7 +219,8 @@ public static Drawable getEmojiBigDrawable(long code) {
     public static class EmojiDrawable extends Drawable {
         private DrawableInfo info;
         private boolean fullSize = false;
-        private static Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG | Paint.ANTI_ALIAS_FLAG);
+        private static Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG);
+        private static Rect rect = new Rect();
 
         public EmojiDrawable(DrawableInfo i) {
             info = i;
@@ -353,22 +231,33 @@ public DrawableInfo getDrawableInfo() {
         }
 
         public Rect getDrawRect() {
-            Rect b = copyBounds();
-            int cX = b.centerX(), cY = b.centerY();
-            b.left = cX - (fullSize ? bigImgSize : drawImgSize) / 2;
-            b.right = cX + (fullSize ? bigImgSize : drawImgSize) / 2;
-            b.top = cY - (fullSize ? bigImgSize : drawImgSize) / 2;
-            b.bottom = cY + (fullSize ? bigImgSize : drawImgSize) / 2;
-            return b;
+            Rect original = getBounds();
+            int cX = original.centerX(), cY = original.centerY();
+            rect.left = cX - (fullSize ? bigImgSize : drawImgSize) / 2;
+            rect.right = cX + (fullSize ? bigImgSize : drawImgSize) / 2;
+            rect.top = cY - (fullSize ? bigImgSize : drawImgSize) / 2;
+            rect.bottom = cY + (fullSize ? bigImgSize : drawImgSize) / 2;
+            return rect;
         }
 
         @Override
         public void draw(Canvas canvas) {
-            if (emojiBmp[info.page] == null) {
-                loadEmojiAsync(info.page);
+            if (emojiBmp[info.page][info.page2] == null) {
+                if (loadingEmoji[info.page][info.page2]) {
+                    return;
+                }
+                loadingEmoji[info.page][info.page2] = true;
+                Utilities.globalQueue.postRunnable(new Runnable() {
+                    @Override
+                    public void run() {
+                        loadEmoji(info.page, info.page2);
+                        loadingEmoji[info.page][info.page2] = false;
+                    }
+                });
                 canvas.drawRect(getBounds(), placeholderPaint);
                 return;
             }
+
             Rect b;
             if (fullSize) {
                 b = getDrawRect();
@@ -377,13 +266,13 @@ public void draw(Canvas canvas) {
             }
 
             if (!canvas.quickReject(b.left, b.top, b.right, b.bottom, Canvas.EdgeType.AA)) {
-                canvas.drawBitmap(emojiBmp[info.page], info.rect, b, paint);
+                canvas.drawBitmap(emojiBmp[info.page][info.page2], info.rect, b, paint);
             }
         }
 
         @Override
         public int getOpacity() {
-            return 0;
+            return PixelFormat.TRANSPARENT;
         }
 
         @Override
@@ -400,10 +289,12 @@ public void setColorFilter(ColorFilter cf) {
     private static class DrawableInfo {
         public Rect rect;
         public byte page;
+        public byte page2;
 
-        public DrawableInfo(Rect r, byte p) {
+        public DrawableInfo(Rect r, byte p, byte p2) {
             rect = r;
             page = p;
+            page2 = p2;
         }
     }
 
@@ -416,14 +307,6 @@ private static boolean inArray(char c, char[] a) {
         return false;
     }
 
-    private static boolean isNextCharIsColor(CharSequence cs, int i) {
-        if (i + 2 >= cs.length()) {
-            return false;
-        }
-        int value = cs.charAt(i + 1) << 16 | cs.charAt(i + 2);
-        return value == 0xd83cdffb || value == 0xd83cdffc || value == 0xd83cdffd || value == 0xd83cdffe || value == 0xd83cdfff;
-    }
-
     public static CharSequence replaceEmoji(CharSequence cs, Paint.FontMetricsInt fontMetrics, int size, boolean createNew) {
         if (cs == null || cs.length() == 0) {
             return cs;
@@ -438,65 +321,97 @@ public static CharSequence replaceEmoji(CharSequence cs, Paint.FontMetricsInt fo
         }
         long buf = 0;
         int emojiCount = 0;
+        char c;
+        int startIndex = -1;
+        int startLength = 0;
+        int previousGoodIndex = 0;
+        StringBuilder emojiCode = new StringBuilder(16);
+        boolean nextIsSkinTone;
+        EmojiDrawable drawable;
+        EmojiSpan span;
+        int length = cs.length();
+        boolean doneEmoji = false;
         //s.setSpansCount(emojiCount);
 
         try {
-            for (int i = 0; i < cs.length(); i++) {
-                char c = cs.charAt(i);
-                if (c == 0xD83C || c == 0xD83D || (buf != 0 && (buf & 0xFFFFFFFF00000000L) == 0 && (c >= 0xDDE6 && c <= 0xDDFA))) {
+            for (int i = 0; i < length; i++) {
+                c = cs.charAt(i);
+                if (c >= 0xD83C && c <= 0xD83E || (buf != 0 && (buf & 0xFFFFFFFF00000000L) == 0 && (buf & 0xFFFF) == 0xD83C && (c >= 0xDDE6 && c <= 0xDDFF))) {
+                    if (startIndex == -1) {
+                        startIndex = i;
+                    }
+                    emojiCode.append(c);
+                    startLength++;
                     buf <<= 16;
                     buf |= c;
                 } else if (buf > 0 && (c & 0xF000) == 0xD000) {
-                    buf <<= 16;
-                    buf |= c;
-                    EmojiDrawable d = Emoji.getEmojiDrawable(buf);
-                    if (d != null) {
-                        boolean nextIsSkinTone = isNextCharIsColor(cs, i);
-                        EmojiSpan span = new EmojiSpan(d, DynamicDrawableSpan.ALIGN_BOTTOM, size, fontMetrics);
-                        if (c >= 0xDDE6 && c <= 0xDDFA) {
-                            s.setSpan(span, i - 3, i + (nextIsSkinTone ? 3 : 1), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                        } else {
-                            s.setSpan(span, i - 1, i + (nextIsSkinTone ? 3 : 1), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                        }
-                        emojiCount++;
-                        if (nextIsSkinTone) {
-                            i += 2;
-                        }
-                    }
+                    emojiCode.append(c);
+                    startLength++;
                     buf = 0;
+                    doneEmoji = true;
                 } else if (c == 0x20E3) {
                     if (i > 0) {
-                        char c2 = cs.charAt(i - 1);
-                        if ((c2 >= '0' && c2 <= '9') || c2 == '#') {
-                            buf = c2;
-                            buf <<= 16;
-                            buf |= c;
-                            EmojiDrawable d = Emoji.getEmojiDrawable(buf);
-                            if (d != null) {
-                                boolean nextIsSkinTone = isNextCharIsColor(cs, i);
-                                EmojiSpan span = new EmojiSpan(d, DynamicDrawableSpan.ALIGN_BOTTOM, size, fontMetrics);
-                                s.setSpan(span, i - 1, i + (nextIsSkinTone ? 3 : 1), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                                emojiCount++;
-                                if (nextIsSkinTone) {
-                                    i += 2;
-                                }
+                        char c2 = cs.charAt(previousGoodIndex);
+                        if ((c2 >= '0' && c2 <= '9') || c2 == '#' || c2 == '*') {
+                            startIndex = previousGoodIndex;
+                            startLength = i - previousGoodIndex + 1;
+                            emojiCode.append(c2);
+                            emojiCode.append(c);
+                            doneEmoji = true;
+                        }
+                    }
+                } else if ((c == 0x00A9 || c == 0x00AE || c >= 0x203C && c <= 0x3299) && EmojiData.dataCharsMap.containsKey(c)) {
+                    if (startIndex == -1) {
+                        startIndex = i;
+                    }
+                    startLength++;
+                    emojiCode.append(c);
+                    doneEmoji = true;
+                } else if (startIndex != -1) {
+                    emojiCode.setLength(0);
+                    startIndex = -1;
+                    startLength = 0;
+                    doneEmoji = false;
+                }
+                previousGoodIndex = i;
+                for (int a = 0; a < 3; a++) {
+                    if (i + 1 < length) {
+                        c = cs.charAt(i + 1);
+                        if (a == 1) {
+                            if (c == 0x200D) {
+                                emojiCode.append(c);
+                                i++;
+                                startLength++;
+                                doneEmoji = false;
+                            }
+                        } else {
+                            if (c >= 0xFE00 && c <= 0xFE0F) {
+                                i++;
+                                startLength++;
                             }
-                            buf = 0;
                         }
                     }
-                } else if (inArray(c, emojiChars)) {
-                    EmojiDrawable d = Emoji.getEmojiDrawable(c);
-                    if (d != null) {
-                        boolean nextIsSkinTone = isNextCharIsColor(cs, i);
-                        EmojiSpan span = new EmojiSpan(d, DynamicDrawableSpan.ALIGN_BOTTOM, size, fontMetrics);
-                        s.setSpan(span, i, i + (nextIsSkinTone ? 3 : 1), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                        emojiCount++;
-                        if (nextIsSkinTone) {
+                }
+                if (doneEmoji) {
+                    if (i + 2 < length) {
+                        if (cs.charAt(i + 1) == 0xD83C && cs.charAt(i + 2) >= 0xDFFB && cs.charAt(i + 2) <= 0xDFFF) {
+                            emojiCode.append(cs.subSequence(i + 1, i + 3));
+                            startLength += 2;
                             i += 2;
                         }
                     }
+                    drawable = Emoji.getEmojiDrawable(emojiCode.subSequence(0, emojiCode.length()));
+                    if (drawable != null) {
+                        span = new EmojiSpan(drawable, DynamicDrawableSpan.ALIGN_BOTTOM, size, fontMetrics);
+                        s.setSpan(span, startIndex, startIndex + startLength, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+                        emojiCount++;
+                    }
+                    startLength = 0;
+                    startIndex = -1;
+                    emojiCode.setLength(0);
+                    doneEmoji = false;
                 }
-                if (emojiCount >= 50) {
+                if (emojiCount >= 50) { //654 new
                     break;
                 }
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/EmojiData.java b/TMessagesProj/src/main/java/org/telegram/messenger/EmojiData.java
new file mode 100644
index 000000000..4fdbde10e
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/EmojiData.java
@@ -0,0 +1,348 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.messenger;
+
+import java.util.HashMap;
+
+public class EmojiData {
+
+    public static final char[] emojiToFE0F = {
+            0x2B50, 0x2600, 0x26C5, 0x2601, 0x26A1, 0x2744, 0x26C4, 0x2614, 0x2708, 0x26F5,
+            0x2693, 0x26FD, 0x26F2, 0x26FA, 0x26EA, 0x2615, 0x26BD, 0x26BE, 0x26F3, 0x231A,
+            0x260E, 0x231B, 0x2709, 0x2702, 0x2712, 0x270F, 0x2648, 0x2649, 0x264A, 0x264B,
+            0x264C, 0x264D, 0x264E, 0x264F, 0x2650, 0x2651, 0x2652, 0x2653, 0x2734, 0x3299,
+            0x3297, 0x26D4, 0x2B55, 0x2668, 0x2757, 0x203C, 0x2049, 0x303D, 0x26A0, 0x267B,
+            0x2747, 0x2733, 0x24C2, 0x267F, 0x25B6, 0x25C0, 0x27A1, 0x2B05, 0x2B06, 0x2B07,
+            0x2197, 0x2198, 0x2199, 0x2196, 0x2195, 0x2194, 0x21AA, 0x21A9, 0x2934, 0x2935,
+            0x2139, 0x2714, 0x2716, 0x2611, 0x26AA, 0x26AB, 0x25AA, 0x25AB, 0x2B1B, 0x2B1C,
+            0x25FC, 0x25FB, 0x25FE, 0x25FD, 0x2660, 0x2663, 0x2665, 0x2666, 0x263A, 0x2639,
+            0x270C, 0x261D, 0x2764
+    };
+    //0xD83CDE2F, 0xD83CDC04, 0xD83CDE1A, 0xD83CDD7F
+
+    public static final char[] dataChars = {
+            0x262E, 0x271D, 0x262A, 0x2638, 0x2721, 0x262F, 0x2626, 0x26CE, 0x2648, 0x2649,
+            0x264A, 0x264B, 0x264C, 0x264D, 0x264E, 0x264F, 0x2650, 0x2651, 0x2652, 0x2653,
+            0x269B, 0x2622, 0x2623, 0x2734, 0x3299, 0x3297, 0x26D4, 0x274C, 0x2B55, 0x2668,
+            0x2757, 0x2755, 0x2753, 0x2754, 0x203C, 0x2049, 0x269C, 0x303D, 0x26A0, 0x267B,
+            0x2747, 0x2733, 0x274E, 0x2705, 0x27BF, 0x24C2, 0x267F, 0x25B6, 0x23F8, 0x23EF,
+            0x23F9, 0x23FA, 0x23ED, 0x23EE, 0x23E9, 0x23EA, 0x25C0, 0x23EB, 0x23EC, 0x27A1,
+            0x2B05, 0x2B06, 0x2B07, 0x2197, 0x2198, 0x2199, 0x2196, 0x2195, 0x2194, 0x21AA,
+            0x21A9, 0x2934, 0x2935, 0x2139, 0x3030, 0x27B0, 0x2714, 0x2795, 0x2796, 0x2797,
+            0x2716, 0x00A9, 0x00AE, 0x2122, 0x2611, 0x26AA, 0x26AB, 0x25AA, 0x25AB, 0x2B1B,
+            0x2B1C, 0x25FC, 0x25FB, 0x25FE, 0x25FD, 0x2660, 0x2663, 0x2665, 0x2666, 0x263A,
+            0x2639, 0x270A, 0x270C, 0x270B, 0x261D, 0x270D, 0x26D1, 0x2764, 0x2763, 0x2615,
+            0x26BD, 0x26BE, 0x26F3, 0x26F7, 0x26F8, 0x26F9, 0x231A, 0x2328, 0x260E, 0x23F1,
+            0x23F2, 0x23F0, 0x23F3, 0x231B, 0x2696, 0x2692, 0x26CF, 0x2699, 0x26D3, 0x2694,
+            0x2620, 0x26B0, 0x26B1, 0x2697, 0x26F1, 0x2709, 0x2702, 0x2712, 0x270F, 0x2708,
+            0x26F5, 0x26F4, 0x2693, 0x26FD, 0x26F2, 0x26F0, 0x26FA, 0x26EA, 0x26E9, 0x2618,
+            0x2B50, 0x2728, 0x2604, 0x2600, 0x26C5, 0x2601, 0x26C8, 0x26A1, 0x2744, 0x2603,
+            0x26C4, 0x2602, 0x2614
+    };
+
+    public static final String[] emojiColored = {
+            "🙌", "👏", "👋", "👍", "👎", "👊", "✊", "✌", "👌", "✋",
+            "👐", "💪", "🙏", "☝", "👆", "👇", "👈", "👉", "🖕", "🖐",
+            "🤘", "🖖", "✍", "💅", "👂", "👃", "👶", "👦", "👧", "👨",
+            "👩", "👱", "👴", "👵", "👲", "👳", "👮", "👷", "💂", "🎅",
+            "👼", "👸", "👰", "🚶", "🏃", "💃", "🙇", "💁", "🙅", "🙆",
+            "🙋", "🙎", "🙍", "💇", "💆", "🚣", "🏊", "🏄", "🛀", "⛹",
+            "🏋", "🚴", "🚵", "🏇",
+    };
+
+    public static final String[][] dataColored = {
+            new String[]{
+                    "😀", "😬", "😁", "😂", "😃", "😄", "😅", "😆", "😇", "😉", "😊",
+                    "🙂", "🙃", "☺", "😋", "😌", "😍", "😘", "😗", "😙", "😚",
+                    "😜", "😝", "😛", "🤑", "🤓", "😎", "🤗", "😏", "😶", "😐",
+                    "😑", "😒", "🙄", "🤔", "😳", "😞", "😟", "😠", "😡", "😔",
+                    "😕", "🙁", "☹", "😣", "😖", "😫", "😩", "😤", "😮", "😱",
+                    "😨", "😰", "😯", "😦", "😧", "😢", "😥", "😪", "😓", "😭",
+                    "😵", "😲", "🤐", "😷", "🤒", "🤕", "😴", "💤", "💩", "😈",
+                    "👿", "👹", "👺", "💀", "👻", "👽", "🤖", "😺", "😸", "😹",
+                    "😻", "😼", "😽", "🙀", "😿", "😾", "🙌",
+                    "👏", "👋",
+                    "👍",
+                    "👎", "👊",
+                    "✊", "✌",
+                    "👌",
+                    "✋", "👐",
+                    "💪", "🙏",
+                    "☝",
+                    "👆", "👇",
+                    "👈", "👉",
+                    "🖕",
+                    "🖐", "🤘",
+                    "🖖", "✍",
+                    "💅",
+                    "👄", "👅", "👂", "👃",
+                    "👁", "👀", "👤", "👥", "🗣", "👶",
+                    "👦",
+                    "👧", "👨",
+                    "👩", "👱",
+                    "👴",
+                    "👵", "👲",
+                    "👳", "👮",
+                    "👷",
+                    "💂", "🕵", "🎅",
+                    "👼",
+                    "👸", "👰",
+                    "🚶", "🏃",
+                    "💃",
+                    "👯", "👫", "👬", "👭", "🙇",
+                    "💁", "🙅",
+                    "🙆", "🙋",
+                    "🙎",
+                    "🙍", "💇",
+                    "💆", "💑", "👩‍❤‍👩",
+                    "👨‍❤‍👨", "💏", "👩‍❤‍💋‍👩", "👨‍❤‍💋‍👨", "👪", "👨‍👩‍👧", "👨‍👩‍👧‍👦", "👨‍👩‍👦‍👦", "👨‍👩‍👧‍👧", "👩‍👩‍👦",
+                    "👩‍👩‍👧", "👩‍👩‍👧‍👦", "👩‍👩‍👦‍👦", "👩‍👩‍👧‍👧", "👨‍👨‍👦", "👨‍👨‍👧", "👨‍👨‍👧‍👦", "👨‍👨‍👦‍👦", "👨‍👨‍👧‍👧", "👚",
+                    "👕", "👖", "👔", "👗", "👙", "👘", "💄", "💋", "👣", "👠",
+                    "👡", "👢", "👞", "👟", "👒", "🎩", "🎓", "👑", "⛑", "🎒",
+                    "👝", "👛", "👜", "💼", "👓", "🕶", "💍", "🌂", "❤", "💛",
+                    "💚", "💙", "💜", "💔", "❣", "💕", "💞", "💓", "💗", "💖",
+                    "💘", "💝",
+            },
+            null,
+            new String[]{
+                    "🍏", "🍎", "🍐", "🍊", "🍋", "🍌", "🍉", "🍇", "🍓", "🍈", "🍒",
+                    "🍑", "🍍", "🍅", "🍆", "🌶", "🌽", "🍠", "🍯", "🍞", "🧀",
+                    "🍗", "🍖", "🍤", "🍳", "🍔", "🍟", "🌭", "🍕", "🍝", "🌮",
+                    "🌯", "🍜", "🍲", "🍥", "🍣", "🍱", "🍛", "🍙", "🍚", "🍘",
+                    "🍢", "🍡", "🍧", "🍨", "🍦", "🍰", "🎂", "🍮", "🍬", "🍭",
+                    "🍫", "🍿", "🍩", "🍪", "🍺", "🍻", "🍷", "🍸", "🍹", "🍾",
+                    "🍶", "🍵", "☕", "🍼", "🍴", "🍽", "⚽", "🏀", "🏈", "⚾",
+                    "🎾", "🏐", "🏉", "🎱", "⛳", "🏌", "🏓", "🏸", "🏒", "🏑",
+                    "🏏", "🎿", "⛷", "🏂", "⛸", "🏹", "🎣", "🚣",
+                    "🏊", "🏄",
+                    "🛀",
+                    "⛹", "🏋",
+                    "🚴", "🚵",
+                    "🏇",
+                    "🕴", "🏆", "🎽", "🏅", "🎖", "🎗", "🏵", "🎫", "🎟",
+                    "🎭", "🎨", "🎪", "🎤", "🎧", "🎼", "🎹", "🎷", "🎺", "🎸",
+                    "🎻", "🎬", "🎮", "👾", "🎯", "🎲", "🎰", "🎳", "⌚", "📱",
+                    "📲", "💻", "⌨", "🖥", "🖨", "🖱", "🖲", "🕹", "🗜", "💽",
+                    "💾", "💿", "📀", "📼", "📷", "📸", "📹", "🎥", "📽", "🎞",
+                    "📞", "☎", "📟", "🎛", "⏱", "⏲", "⏰", "🕰", "⏳", "⌛",
+                    "📡", "🔋", "🔌", "💡", "🔦", "🕯", "🗑", "🛢", "💸", "💵",
+                    "💴", "💶", "💷", "💰", "💳", "💎", "⚖", "🔧", "🔨", "⚒",
+                    "🛠", "⛏", "🔩", "⚙", "⛓", "🔫", "💣", "🔪", "🗡", "⚔",
+                    "🛡", "🚬", "☠", "⚰", "⚱", "🏺", "🔮", "📿", "💈", "⚗",
+                    "🔭", "🔬", "🕳", "💊", "💉", "🌡", "🏷", "🔖", "🚽", "🚿",
+                    "🛁", "🔑", "🗝", "🛋", "🛌", "🛏", "🚪", "🛎", "🖼", "🗺",
+                    "⛱", "🗿", "🛍", "🎈", "🎏", "🎀", "🎁", "🎊", "🎉", "🎎",
+                    "🎐", "🎌", "🏮", "✉", "📩", "📨", "📧", "💌", "📮", "📪",
+                    "📫", "📬", "📭", "📦", "📯", "📥", "📤", "📜", "📃", "📑",
+                    "📊", "📈", "📉", "📄", "📅", "📆", "🗓", "📇", "🗃", "🗳",
+                    "🗄", "📋", "🗒", "📁", "📂", "🗂", "🗞", "📰", "📓", "📕",
+                    "📗", "📘", "📙", "📔", "📒", "📚", "📖", "🔗", "📎", "🖇",
+                    "✂", "📐", "📏", "📌", "📍", "🚩", "🏳", "🏴", "🔐", "🔒",
+                    "🔓", "🔏", "🖊", "🖋", "✒", "📝", "✏", "🖍", "🖌", "🔍",
+                    "🔎",
+            },
+            null,
+            null
+    };
+
+    public static final String[][] data = {
+            new String[]{
+                    "😀", "😬", "😁", "😂", "😃", "😄", "😅", "😆", "😇", "😉", "😊",
+                    "🙂", "🙃", "☺", "😋", "😌", "😍", "😘", "😗", "😙", "😚",
+                    "😜", "😝", "😛", "🤑", "🤓", "😎", "🤗", "😏", "😶", "😐",
+                    "😑", "😒", "🙄", "🤔", "😳", "😞", "😟", "😠", "😡", "😔",
+                    "😕", "🙁", "☹", "😣", "😖", "😫", "😩", "😤", "😮", "😱",
+                    "😨", "😰", "😯", "😦", "😧", "😢", "😥", "😪", "😓", "😭",
+                    "😵", "😲", "🤐", "😷", "🤒", "🤕", "😴", "💤", "💩", "😈",
+                    "👿", "👹", "👺", "💀", "👻", "👽", "🤖", "😺", "😸", "😹",
+                    "😻", "😼", "😽", "🙀", "😿", "😾", "🙌", "🙌🏻", "🙌🏼", "🙌🏽",
+                    "🙌🏾", "🙌🏿", "👏", "👏🏻", "👏🏼", "👏🏽", "👏🏾", "👏🏿", "👋", "👋🏻",
+                    "👋🏼", "👋🏽", "👋🏾", "👋🏿", "👍", "👍🏻", "👍🏼", "👍🏽", "👍🏾", "👍🏿",
+                    "👎", "👎🏻", "👎🏼", "👎🏽", "👎🏾", "👎🏿", "👊", "👊🏻", "👊🏼", "👊🏽",
+                    "👊🏾", "👊🏿", "✊", "✊🏻", "✊🏼", "✊🏽", "✊🏾", "✊🏿", "✌", "✌🏻",
+                    "✌🏼", "✌🏽", "✌🏾", "✌🏿", "👌", "👌🏻", "👌🏼", "👌🏽", "👌🏾", "👌🏿",
+                    "✋", "✋🏻", "✋🏼", "✋🏽", "✋🏾", "✋🏿", "👐", "👐🏻", "👐🏼", "👐🏽",
+                    "👐🏾", "👐🏿", "💪", "💪🏻", "💪🏼", "💪🏽", "💪🏾", "💪🏿", "🙏", "🙏🏻",
+                    "🙏🏼", "🙏🏽", "🙏🏾", "🙏🏿", "☝", "☝🏻", "☝🏼", "☝🏽", "☝🏾", "☝🏿",
+                    "👆", "👆🏻", "👆🏼", "👆🏽", "👆🏾", "👆🏿", "👇", "👇🏻", "👇🏼", "👇🏽",
+                    "👇🏾", "👇🏿", "👈", "👈🏻", "👈🏼", "👈🏽", "👈🏾", "👈🏿", "👉", "👉🏻",
+                    "👉🏼", "👉🏽", "👉🏾", "👉🏿", "🖕", "🖕🏻", "🖕🏼", "🖕🏽", "🖕🏾", "🖕🏿",
+                    "🖐", "🖐🏻", "🖐🏼", "🖐🏽", "🖐🏾", "🖐🏿", "🤘", "🤘🏻", "🤘🏼", "🤘🏽",
+                    "🤘🏾", "🤘🏿", "🖖", "🖖🏻", "🖖🏼", "🖖🏽", "🖖🏾", "🖖🏿", "✍", "✍🏻",
+                    "✍🏼", "✍🏽", "✍🏾", "✍🏿", "💅", "💅🏻", "💅🏼", "💅🏽", "💅🏾", "💅🏿",
+                    "👄", "👅", "👂", "👂🏻", "👂🏼", "👂🏽", "👂🏾", "👂🏿", "👃", "👃🏻",
+                    "👃🏼", "👃🏽", "👃🏾", "👃🏿", "👁", "👀", "👤", "👥", "🗣", "👶",
+                    "👶🏻", "👶🏼", "👶🏽", "👶🏾", "👶🏿", "👦", "👦🏻", "👦🏼", "👦🏽", "👦🏾",
+                    "👦🏿", "👧", "👧🏻", "👧🏼", "👧🏽", "👧🏾", "👧🏿", "👨", "👨🏻", "👨🏼",
+                    "👨🏽", "👨🏾", "👨🏿", "👩", "👩🏻", "👩🏼", "👩🏽", "👩🏾", "👩🏿", "👱",
+                    "👱🏻", "👱🏼", "👱🏽", "👱🏾", "👱🏿", "👴", "👴🏻", "👴🏼", "👴🏽", "👴🏾",
+                    "👴🏿", "👵", "👵🏻", "👵🏼", "👵🏽", "👵🏾", "👵🏿", "👲", "👲🏻", "👲🏼",
+                    "👲🏽", "👲🏾", "👲🏿", "👳", "👳🏻", "👳🏼", "👳🏽", "👳🏾", "👳🏿", "👮",
+                    "👮🏻", "👮🏼", "👮🏽", "👮🏾", "👮🏿", "👷", "👷🏻", "👷🏼", "👷🏽", "👷🏾",
+                    "👷🏿", "💂", "💂🏻", "💂🏼", "💂🏽", "💂🏾", "💂🏿", "🕵", "🎅", "🎅🏻",
+                    "🎅🏼", "🎅🏽", "🎅🏾", "🎅🏿", "👼", "👼🏻", "👼🏼", "👼🏽", "👼🏾", "👼🏿",
+                    "👸", "👸🏻", "👸🏼", "👸🏽", "👸🏾", "👸🏿", "👰", "👰🏻", "👰🏼", "👰🏽",
+                    "👰🏾", "👰🏿", "🚶", "🚶🏻", "🚶🏼", "🚶🏽", "🚶🏾", "🚶🏿", "🏃", "🏃🏻",
+                    "🏃🏼", "🏃🏽", "🏃🏾", "🏃🏿", "💃", "💃🏻", "💃🏼", "💃🏽", "💃🏾", "💃🏿",
+                    "👯", "👫", "👬", "👭", "🙇", "🙇🏻", "🙇🏼", "🙇🏽", "🙇🏾", "🙇🏿",
+                    "💁", "💁🏻", "💁🏼", "💁🏽", "💁🏾", "💁🏿", "🙅", "🙅🏻", "🙅🏼", "🙅🏽",
+                    "🙅🏾", "🙅🏿", "🙆", "🙆🏻", "🙆🏼", "🙆🏽", "🙆🏾", "🙆🏿", "🙋", "🙋🏻",
+                    "🙋🏼", "🙋🏽", "🙋🏾", "🙋🏿", "🙎", "🙎🏻", "🙎🏼", "🙎🏽", "🙎🏾", "🙎🏿",
+                    "🙍", "🙍🏻", "🙍🏼", "🙍🏽", "🙍🏾", "🙍🏿", "💇", "💇🏻", "💇🏼", "💇🏽",
+                    "💇🏾", "💇🏿", "💆", "💆🏻", "💆🏼", "💆🏽", "💆🏾", "💆🏿", "💑", "👩‍❤‍👩",
+                    "👨‍❤‍👨", "💏", "👩‍❤‍💋‍👩", "👨‍❤‍💋‍👨", "👪", "👨‍👩‍👧", "👨‍👩‍👧‍👦", "👨‍👩‍👦‍👦", "👨‍👩‍👧‍👧", "👩‍👩‍👦",
+                    "👩‍👩‍👧", "👩‍👩‍👧‍👦", "👩‍👩‍👦‍👦", "👩‍👩‍👧‍👧", "👨‍👨‍👦", "👨‍👨‍👧", "👨‍👨‍👧‍👦", "👨‍👨‍👦‍👦", "👨‍👨‍👧‍👧", "👚",
+                    "👕", "👖", "👔", "👗", "👙", "👘", "💄", "💋", "👣", "👠",
+                    "👡", "👢", "👞", "👟", "👒", "🎩", "🎓", "👑", "⛑", "🎒",
+                    "👝", "👛", "👜", "💼", "👓", "🕶", "💍", "🌂", "❤", "💛",
+                    "💚", "💙", "💜", "💔", "❣", "💕", "💞", "💓", "💗", "💖",
+                    "💘", "💝"
+            },
+            new String[]{
+                    "🐶", "🐱", "🐭", "🐹", "🐰", "🐻", "🐼", "🐨", "🐯", "🦁", "🐮",
+                    "🐷", "🐽", "🐸", "🐙", "🐵", "🙈", "🙉", "🙊", "🐒", "🐔",
+                    "🐧", "🐦", "🐤", "🐣", "🐥", "🐺", "🐗", "🐴", "🦄", "🐝",
+                    "🐛", "🐌", "🐞", "🐜", "🕷", "🦂", "🦀", "🐍", "🐢", "🐠",
+                    "🐟", "🐡", "🐬", "🐳", "🐋", "🐊", "🐆", "🐅", "🐃", "🐂",
+                    "🐄", "🐪", "🐫", "🐘", "🐐", "🐏", "🐑", "🐎", "🐖", "🐀",
+                    "🐁", "🐓", "🦃", "🕊", "🐕", "🐩", "🐈", "🐇", "🐿", "🐾",
+                    "🐉", "🐲", "🌵", "🎄", "🌲", "🌳", "🌴", "🌱", "🌿", "☘",
+                    "🍀", "🎍", "🎋", "🍃", "🍂", "🍁", "🌾", "🌺", "🌻", "🌹",
+                    "🌷", "🌼", "🌸", "💐", "🍄", "🌰", "🎃", "🐚", "🕸", "🌎",
+                    "🌍", "🌏", "🌕", "🌖", "🌗", "🌘", "🌑", "🌒", "🌓", "🌔",
+                    "🌚", "🌝", "🌛", "🌜", "🌞", "🌙", "⭐", "🌟", "💫", "✨",
+                    "☄", "☀", "🌤", "⛅", "🌥", "🌦", "☁", "🌧", "⛈", "🌩",
+                    "⚡", "🔥", "💥", "❄", "🌨", "☃", "⛄", "🌬", "💨", "🌪",
+                    "🌫", "☂", "☔", "💧", "💦", "🌊"
+            },
+            new String[]{
+                    "🍏", "🍎", "🍐", "🍊", "🍋", "🍌", "🍉", "🍇", "🍓", "🍈", "🍒",
+                    "🍑", "🍍", "🍅", "🍆", "🌶", "🌽", "🍠", "🍯", "🍞", "🧀",
+                    "🍗", "🍖", "🍤", "🍳", "🍔", "🍟", "🌭", "🍕", "🍝", "🌮",
+                    "🌯", "🍜", "🍲", "🍥", "🍣", "🍱", "🍛", "🍙", "🍚", "🍘",
+                    "🍢", "🍡", "🍧", "🍨", "🍦", "🍰", "🎂", "🍮", "🍬", "🍭",
+                    "🍫", "🍿", "🍩", "🍪", "🍺", "🍻", "🍷", "🍸", "🍹", "🍾",
+                    "🍶", "🍵", "☕", "🍼", "🍴", "🍽", "⚽", "🏀", "🏈", "⚾",
+                    "🎾", "🏐", "🏉", "🎱", "⛳", "🏌", "🏓", "🏸", "🏒", "🏑",
+                    "🏏", "🎿", "⛷", "🏂", "⛸", "🏹", "🎣", "🚣", "🚣🏻", "🚣🏼",
+                    "🚣🏽", "🚣🏾", "🚣🏿", "🏊", "🏊🏻", "🏊🏼", "🏊🏽", "🏊🏾", "🏊🏿", "🏄",
+                    "🏄🏻", "🏄🏼", "🏄🏽", "🏄🏾", "🏄🏿", "🛀", "🛀🏻", "🛀🏼", "🛀🏽", "🛀🏾",
+                    "🛀🏿", "⛹", "⛹🏻", "⛹🏼", "⛹🏽", "⛹🏾", "⛹🏿", "🏋", "🏋🏻", "🏋🏼",
+                    "🏋🏽", "🏋🏾", "🏋🏿", "🚴", "🚴🏻", "🚴🏼", "🚴🏽", "🚴🏾", "🚴🏿", "🚵",
+                    "🚵🏻", "🚵🏼", "🚵🏽", "🚵🏾", "🚵🏿", "🏇", "🏇🏻", "🏇🏼", "🏇🏽", "🏇🏾",
+                    "🏇🏿", "🕴", "🏆", "🎽", "🏅", "🎖", "🎗", "🏵", "🎫", "🎟",
+                    "🎭", "🎨", "🎪", "🎤", "🎧", "🎼", "🎹", "🎷", "🎺", "🎸",
+                    "🎻", "🎬", "🎮", "👾", "🎯", "🎲", "🎰", "🎳", "⌚", "📱",
+                    "📲", "💻", "⌨", "🖥", "🖨", "🖱", "🖲", "🕹", "🗜", "💽",
+                    "💾", "💿", "📀", "📼", "📷", "📸", "📹", "🎥", "📽", "🎞",
+                    "📞", "☎", "📟", "🎛", "⏱", "⏲", "⏰", "🕰", "⏳", "⌛",
+                    "📡", "🔋", "🔌", "💡", "🔦", "🕯", "🗑", "🛢", "💸", "💵",
+                    "💴", "💶", "💷", "💰", "💳", "💎", "⚖", "🔧", "🔨", "⚒",
+                    "🛠", "⛏", "🔩", "⚙", "⛓", "🔫", "💣", "🔪", "🗡", "⚔",
+                    "🛡", "🚬", "☠", "⚰", "⚱", "🏺", "🔮", "📿", "💈", "⚗",
+                    "🔭", "🔬", "🕳", "💊", "💉", "🌡", "🏷", "🔖", "🚽", "🚿",
+                    "🛁", "🔑", "🗝", "🛋", "🛌", "🛏", "🚪", "🛎", "🖼", "🗺",
+                    "⛱", "🗿", "🛍", "🎈", "🎏", "🎀", "🎁", "🎊", "🎉", "🎎",
+                    "🎐", "🎌", "🏮", "✉", "📩", "📨", "📧", "💌", "📮", "📪",
+                    "📫", "📬", "📭", "📦", "📯", "📥", "📤", "📜", "📃", "📑",
+                    "📊", "📈", "📉", "📄", "📅", "📆", "🗓", "📇", "🗃", "🗳",
+                    "🗄", "📋", "🗒", "📁", "📂", "🗂", "🗞", "📰", "📓", "📕",
+                    "📗", "📘", "📙", "📔", "📒", "📚", "📖", "🔗", "📎", "🖇",
+                    "✂", "📐", "📏", "📌", "📍", "🚩", "🏳", "🏴", "🔐", "🔒",
+                    "🔓", "🔏", "🖊", "🖋", "✒", "📝", "✏", "🖍", "🖌", "🔍",
+                    "🔎"
+            },
+            new String[]{
+                    "🚗", "🚕", "🚙", "🚌", "🚎", "🏎", "🚓", "🚑", "🚒", "🚐", "🚚",
+                    "🚛", "🚜", "🏍", "🚲", "🚨", "🚔", "🚍", "🚘", "🚖", "🚡",
+                    "🚠", "🚟", "🚃", "🚋", "🚝", "🚄", "🚅", "🚈", "🚞", "🚂",
+                    "🚆", "🚇", "🚊", "🚉", "🚁", "🛩", "✈", "🛫", "🛬", "⛵",
+                    "🛥", "🚤", "⛴", "🛳", "🚀", "🛰", "💺", "⚓", "🚧", "⛽",
+                    "🚏", "🚦", "🚥", "🏁", "🚢", "🎡", "🎢", "🎠", "🏗", "🌁",
+                    "🗼", "🏭", "⛲", "🎑", "⛰", "🏔", "🗻", "🌋", "🗾", "🏕",
+                    "⛺", "🏞", "🛣", "🛤", "🌅", "🌄", "🏜", "🏖", "🏝", "🌇",
+                    "🌆", "🏙", "🌃", "🌉", "🌌", "🌠", "🎇", "🎆", "🌈", "🏘",
+                    "🏰", "🏯", "🏟", "🗽", "🏠", "🏡", "🏚", "🏢", "🏬", "🏣",
+                    "🏤", "🏥", "🏦", "🏨", "🏪", "🏫", "🏩", "💒", "🏛", "⛪",
+                    "🕌", "🕍", "🕋", "⛩", "🇦🇺", "🇦🇹", "🇦🇿", "🇦🇽", "🇦🇱", "🇩🇿",
+                    "🇦🇸", "🇦🇮", "🇦🇴", "🇦🇩", "🇦🇶", "🇦🇬", "🇦🇷", "🇦🇲", "🇦🇼", "🇦🇫",
+                    "🇧🇸", "🇧🇩", "🇧🇧", "🇧🇭", "🇧🇾", "🇧🇿", "🇧🇪", "🇧🇯", "🇧🇲", "🇧🇬",
+                    "🇧🇴", "🇧🇶", "🇧🇦", "🇧🇼", "🇧🇷", "🇮🇴", "🇧🇳", "🇧🇫", "🇧🇮", "🇧🇹",
+                    "🇻🇺", "🇻🇦", "🇬🇧", "🇭🇺", "🇻🇪", "🇻🇬", "🇻🇮", "🇹🇱", "🇻🇳", "🇬🇦",
+                    "🇭🇹", "🇬🇾", "🇬🇲", "🇬🇭", "🇬🇵", "🇬🇹", "🇬🇳", "🇬🇼", "🇩🇪", "🇬🇬",
+                    "🇬🇮", "🇭🇳", "🇭🇰", "🇬🇩", "🇬🇱", "🇬🇷", "🇬🇪", "🇬🇺", "🇩🇰", "🇯🇪",
+                    "🇩🇯", "🇩🇲", "🇩🇴", "🇪🇺", "🇪🇬", "🇿🇲", "🇪🇭", "🇿🇼", "🇮🇱", "🇮🇳",
+                    "🇮🇩", "🇯🇴", "🇮🇶", "🇮🇷", "🇮🇪", "🇮🇸", "🇪🇸", "🇮🇹", "🇾🇪", "🇨🇻",
+                    "🇰🇿", "🇰🇾", "🇰🇭", "🇨🇲", "🇨🇦", "🇮🇨", "🇶🇦", "🇰🇪", "🇨🇾", "🇰🇬",
+                    "🇰🇮", "🇨🇳", "🇰🇵", "🇨🇨", "🇨🇴", "🇰🇲", "🇨🇬", "🇨🇩", "🇽🇰", "🇨🇷",
+                    "🇨🇮", "🇨🇺", "🇰🇼", "🇨🇼", "🇱🇦", "🇱🇻", "🇱🇸", "🇱🇷", "🇱🇧", "🇱🇾",
+                    "🇱🇹", "🇱🇮", "🇱🇺", "🇲🇺", "🇲🇷", "🇲🇬", "🇾🇹", "🇲🇴", "🇲🇰", "🇲🇼",
+                    "🇲🇾", "🇲🇱", "🇲🇻", "🇲🇹", "🇲🇦", "🇲🇶", "🇲🇭", "🇲🇽", "🇫🇲", "🇲🇿",
+                    "🇲🇩", "🇲🇨", "🇲🇳", "🇲🇸", "🇲🇲", "🇳🇦", "🇳🇷", "🇳🇵", "🇳🇪", "🇳🇬",
+                    "🇳🇱", "🇳🇮", "🇳🇺", "🇳🇿", "🇳🇨", "🇳🇴", "🇮🇲", "🇳🇫", "🇨🇽", "🇸🇭",
+                    "🇨🇰", "🇹🇨", "🇦🇪", "🇴🇲", "🇵🇰", "🇵🇼", "🇵🇸", "🇵🇦", "🇵🇬", "🇵🇾",
+                    "🇵🇪", "🇵🇳", "🇵🇱", "🇵🇹", "🇵🇷", "🇰🇷", "🇷🇪", "🇷🇺", "🇷🇼", "🇷🇴",
+                    "🇸🇻", "🇼🇸", "🇸🇲", "🇸🇹", "🇸🇦", "🇸🇿", "🇲🇵", "🇸🇨", "🇧🇱", "🇵🇲",
+                    "🇸🇳", "🇻🇨", "🇰🇳", "🇱🇨", "🇷🇸", "🇸🇬", "🇸🇽", "🇸🇾", "🇸🇰", "🇸🇮",
+                    "🇺🇸", "🇸🇧", "🇸🇴", "🇸🇩", "🇸🇷", "🇸🇱", "🇹🇯", "🇹🇭", "🇹🇼", "🇹🇿",
+                    "🇹🇬", "🇹🇰", "🇹🇴", "🇹🇹", "🇹🇻", "🇹🇳", "🇹🇲", "🇹🇷", "🇺🇬", "🇺🇿",
+                    "🇺🇦", "🇼🇫", "🇺🇾", "🇫🇴", "🇫🇯", "🇵🇭", "🇫🇮", "🇫🇰", "🇫🇷", "🇬🇫",
+                    "🇵🇫", "🇹🇫", "🇭🇷", "🇨🇫", "🇹🇩", "🇲🇪", "🇨🇿", "🇨🇱", "🇨🇭", "🇸🇪",
+                    "🇱🇰", "🇪🇨", "🇬🇶", "🇪🇷", "🇪🇪", "🇪🇹", "🇿🇦", "🇬🇸", "🇸🇸", "🇯🇲",
+                    "🇯🇵"
+            },
+            new String[]{
+                    "💟", "☮", "✝", "☪", "🕉", "☸", "✡", "🔯", "🕎", "☯", "☦",
+                    "🛐", "⛎", "♈", "♉", "♊", "♋", "♌", "♍", "♎", "♏",
+                    "♐", "♑", "♒", "♓", "🆔", "⚛", "🈳", "🈹", "☢", "☣",
+                    "📴", "📳", "🈶", "🈚", "🈸", "🈺", "🈷", "✴", "🆚", "🉑",
+                    "💮", "🉐", "㊙", "㊗", "🈴", "🈵", "🈲", "🅰", "🅱", "🆎",
+                    "🆑", "🅾", "🆘", "⛔", "📛", "🚫", "❌", "⭕", "💢", "♨",
+                    "🚷", "🚯", "🚳", "🚱", "🔞", "📵", "❗", "❕", "❓", "❔",
+                    "‼", "⁉", "💯", "🔅", "🔆", "🔱", "⚜", "〽", "⚠", "🚸",
+                    "🔰", "♻", "🈯", "💹", "❇", "✳", "❎", "✅", "💠", "🌀",
+                    "➿", "🌐", "Ⓜ", "🏧", "🈂", "🛂", "🛃", "🛄", "🛅", "♿",
+                    "🚭", "🚾", "🅿", "🚰", "🚹", "🚺", "🚼", "🚻", "🚮", "🎦",
+                    "📶", "🈁", "🆖", "🆗", "🆙", "🆒", "🆕", "🆓", "0⃣", "1⃣",
+                    "2⃣", "3⃣", "4⃣", "5⃣", "6⃣", "7⃣", "8⃣", "9⃣", "🔟", "🔢",
+                    "▶", "⏸", "⏯", "⏹", "⏺", "⏭", "⏮", "⏩", "⏪", "🔀",
+                    "🔁", "🔂", "◀", "🔼", "🔽", "⏫", "⏬", "➡", "⬅", "⬆",
+                    "⬇", "↗", "↘", "↙", "↖", "↕", "↔", "🔄", "↪", "↩",
+                    "⤴", "⤵", "#⃣", "*⃣", "ℹ", "🔤", "🔡", "🔠", "🔣", "🎵",
+                    "🎶", "〰", "➰", "✔", "🔃", "➕", "➖", "➗", "✖", "💲",
+                    "💱", "©", "®", "™", "🔚", "🔙", "🔛", "🔝", "🔜", "☑",
+                    "🔘", "⚪", "⚫", "🔴", "🔵", "🔸", "🔹", "🔶", "🔷", "🔺",
+                    "▪", "▫", "⬛", "⬜", "🔻", "◼", "◻", "◾", "◽", "🔲",
+                    "🔳", "🔈", "🔉", "🔊", "🔇", "📣", "📢", "🔔", "🔕", "🃏",
+                    "🀄", "♠", "♣", "♥", "♦", "🎴", "👁‍🗨", "💭", "🗯", "💬",
+                    "🕐", "🕑", "🕒", "🕓", "🕔", "🕕", "🕖", "🕗", "🕘", "🕙",
+                    "🕚", "🕛", "🕜", "🕝", "🕞", "🕟", "🕠", "🕡", "🕢", "🕣",
+                    "🕤", "🕥", "🕦", "🕧"
+            }
+    };
+
+    public static final HashMap<Character, Boolean> emojiToFE0FMap = new HashMap<>(emojiToFE0F.length);
+    public static final HashMap<Character, Boolean> dataCharsMap = new HashMap<>(dataChars.length);
+    public static final HashMap<String, Boolean> emojiColoredMap = new HashMap<>(emojiColored.length);
+
+    static {
+        for (int a = 0; a < emojiToFE0F.length; a++) {
+            emojiToFE0FMap.put(emojiToFE0F[a], true);
+        }
+        for (int a = 0; a < dataChars.length; a++) {
+            dataCharsMap.put(dataChars[a], true);
+        }
+        for (int a = 0; a < emojiColored.length; a++) {
+            emojiColoredMap.put(emojiColored[a], true);
+        }
+        dataColored[1] = data[1];
+        dataColored[3] = data[3];
+        dataColored[4] = data[4];
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoadOperation.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoadOperation.java
index 6da24d042..295729f0b 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoadOperation.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoadOperation.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -49,6 +49,7 @@
     private int currentDownloadChunkSize;
     private int currentMaxDownloadRequests;
     private int requestsCount;
+    private int renameRetryCount;
 
     private int nextDownloadOffset = 0;
     private ArrayList<RequestInfo> requestInfos;
@@ -194,7 +195,7 @@ public void run() {
         String fileNameTemp;
         String fileNameIv = null;
         if (location.volume_id != 0 && location.local_id != 0) {
-            fileNameTemp = location.volume_id + "_" + location.local_id + "_temp." + ext;
+            fileNameTemp = location.volume_id + "_" + location.local_id + ".temp";
             fileNameFinal = location.volume_id + "_" + location.local_id + "." + ext;
             if (key != null) {
                 fileNameIv = location.volume_id + "_" + location.local_id + ".iv";
@@ -210,7 +211,7 @@ public void run() {
                 return;
             }
         } else {
-            fileNameTemp = datacenter_id + "_" + location.id + "_temp" + ext;
+            fileNameTemp = datacenter_id + "_" + location.id + ".temp";
             fileNameFinal = datacenter_id + "_" + location.id + ext;
             if (key != null) {
                 fileNameIv = datacenter_id + "_" + location.id + ".iv";
@@ -236,7 +237,7 @@ public void run() {
         if (!cacheFileFinal.exists()) {
             cacheFileTemp = new File(tempPath, fileNameTemp);
             if (cacheFileTemp.exists()) {
-                downloadedBytes = (int)cacheFileTemp.length();
+                downloadedBytes = (int) cacheFileTemp.length();
                 nextDownloadOffset = downloadedBytes = downloadedBytes / currentDownloadChunkSize * currentDownloadChunkSize;
             }
 
@@ -324,6 +325,11 @@ public void run() {
     private void cleanup() {
         try {
             if (fileOutputStream != null) {
+                try {
+                    fileOutputStream.getChannel().close();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
                 fileOutputStream.close();
                 fileOutputStream = null;
             }
@@ -340,7 +346,8 @@ private void cleanup() {
             FileLog.e("tmessages", e);
         }
         if (delayedRequestInfos != null) {
-            for (RequestInfo requestInfo : delayedRequestInfos) {
+            for (int a = 0; a < delayedRequestInfos.size(); a++) {
+                RequestInfo requestInfo = delayedRequestInfos.get(a);
                 if (requestInfo.response != null) {
                     requestInfo.response.disableFree = false;
                     requestInfo.response.freeResources();
@@ -358,11 +365,28 @@ private void onFinishLoadingFile() throws Exception {
         cleanup();
         if (cacheIvTemp != null) {
             cacheIvTemp.delete();
+            cacheIvTemp = null;
         }
         if (cacheFileTemp != null) {
-            if (!cacheFileTemp.renameTo(cacheFileFinal)) {
+            boolean renameResult = cacheFileTemp.renameTo(cacheFileFinal);
+            if (!renameResult) {
                 if (BuildVars.DEBUG_VERSION) {
-                    FileLog.e("tmessages", "unable to rename temp = " + cacheFileTemp + " to final = " + cacheFileFinal);
+                    FileLog.e("tmessages", "unable to rename temp = " + cacheFileTemp + " to final = " + cacheFileFinal + " retry = " + renameRetryCount);
+                }
+                renameRetryCount++;
+                if (renameRetryCount < 3) {
+                    state = stateDownloading;
+                    Utilities.stageQueue.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                onFinishLoadingFile();
+                            } catch (Exception e) {
+                                delegate.didFailedLoadingFile(FileLoadOperation.this, 0);
+                            }
+                        }
+                    }, 200);
+                    return;
                 }
                 cacheFileFinal = cacheFileTemp;
             }
@@ -468,7 +492,7 @@ private void processRequestResult(RequestInfo requestInfo, TLRPC.TL_error error)
                 delegate.didFailedLoadingFile(FileLoadOperation.this, 2);
             } else {
                 if (location != null) {
-                    FileLog.e("tmessages", "" + location + " id = " + location.id + " access_hash = " + location.access_hash + " volume_id = " + location.local_id + " secret = " + location.secret);
+                    FileLog.e("tmessages", "" + location + " id = " + location.id + " local_id = " + location.local_id + " access_hash = " + location.access_hash + " volume_id = " + location.volume_id + " secret = " + location.secret);
                 }
                 cleanup();
                 delegate.didFailedLoadingFile(FileLoadOperation.this, 0);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
index 9eb1dd319..8b7f8ef16 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileLoader.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -23,7 +23,7 @@
     public interface FileLoaderDelegate {
         void fileUploadProgressChanged(String location, float progress, boolean isEncrypted);
 
-        void fileDidUploaded(String location, TLRPC.InputFile inputFile, TLRPC.InputEncryptedFile inputEncryptedFile, byte[] key, byte[] iv);
+        void fileDidUploaded(String location, TLRPC.InputFile inputFile, TLRPC.InputEncryptedFile inputEncryptedFile, byte[] key, byte[] iv, long totalFileSize);
 
         void fileDidFailedUpload(String location, boolean isEncrypted);
 
@@ -80,6 +80,10 @@ public void setMediaDirs(HashMap<Integer, File> dirs) {
         mediaDirs = dirs;
     }
 
+    public File checkDirectory(int type) {
+        return mediaDirs.get(type);
+    }
+
     public File getDirectory(int type) {
         File dir = mediaDirs.get(type);
         if (dir == null && type != MEDIA_DIR_CACHE) {
@@ -107,6 +111,7 @@ public void run() {
                 }
                 uploadSizes.remove(location);
                 if (operation != null) {
+                    uploadOperationPathsEnc.remove(location);
                     uploadOperationQueue.remove(operation);
                     uploadSmallOperationQueue.remove(operation);
                     operation.cancel();
@@ -170,7 +175,7 @@ public void run() {
                 }
                 operation.delegate = new FileUploadOperation.FileUploadOperationDelegate() {
                     @Override
-                    public void didFinishUploadingFile(FileUploadOperation operation, final TLRPC.InputFile inputFile, final TLRPC.InputEncryptedFile inputEncryptedFile, final byte[] key, final byte[] iv) {
+                    public void didFinishUploadingFile(final FileUploadOperation operation, final TLRPC.InputFile inputFile, final TLRPC.InputEncryptedFile inputEncryptedFile, final byte[] key, final byte[] iv) {
                         fileLoaderQueue.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -199,7 +204,7 @@ public void run() {
                                     }
                                 }
                                 if (delegate != null) {
-                                    delegate.fileDidUploaded(location, inputFile, inputEncryptedFile, key, iv);
+                                    delegate.fileDidUploaded(location, inputFile, inputEncryptedFile, key, iv, operation.getTotalFileSize());
                                 }
                             }
                         });
@@ -745,14 +750,15 @@ public static String getAttachFileName(TLObject attach, String ext) {
         return "";
     }
 
-    public void deleteFiles(final ArrayList<File> files) {
+    public void deleteFiles(final ArrayList<File> files, final int type) {
         if (files == null || files.isEmpty()) {
             return;
         }
         fileLoaderQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
-                for (File file : files) {
+                for (int a = 0; a < files.size(); a++) {
+                    File file = files.get(a);
                     if (file.exists()) {
                         try {
                             if (!file.delete()) {
@@ -762,6 +768,19 @@ public void run() {
                             FileLog.e("tmessages", e);
                         }
                     }
+                    try {
+                        File qFile = new File(file.getParentFile(), "q_" + file.getName());
+                        if (qFile.exists()) {
+                            if (!qFile.delete()) {
+                                qFile.deleteOnExit();
+                            }
+                        }
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                }
+                if (type == 2) {
+                    ImageLoader.getInstance().clearMemory();
                 }
             }
         });
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileLog.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileLog.java
index 3ce40e4a7..b20f09ae1 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileLog.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileLog.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -22,6 +22,7 @@
     private FastDateFormat dateFormat = null;
     private DispatchQueue logQueue = null;
     private File currentFile = null;
+    private File networkFile = null;
 
     private static volatile FileLog Instance = null;
     public static FileLog getInstance() {
@@ -65,6 +66,25 @@ public FileLog() {
         }
     }
 
+    public static String getNetworkLogPath() {
+        if (!BuildVars.DEBUG_VERSION) {
+            return "";
+        }
+        try {
+            File sdCard = ApplicationLoader.applicationContext.getExternalFilesDir(null);
+            if (sdCard == null) {
+                return "";
+            }
+            File dir = new File(sdCard.getAbsolutePath() + "/logs");
+            dir.mkdirs();
+            getInstance().networkFile = new File(dir, getInstance().dateFormat.format(System.currentTimeMillis()) + "_net.txt");
+            return getInstance().networkFile.getAbsolutePath();
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+        return "";
+    }
+
     public static void e(final String tag, final String message, final Throwable exception) {
         if (!BuildVars.DEBUG_VERSION) {
             return;
@@ -180,6 +200,9 @@ public static void cleanupLogs() {
             if (getInstance().currentFile != null && file.getAbsolutePath().equals(getInstance().currentFile.getAbsolutePath())) {
                 continue;
             }
+            if (getInstance().networkFile != null && file.getAbsolutePath().equals(getInstance().networkFile.getAbsolutePath())) {
+                continue;
+            }
             file.delete();
         }
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/FileUploadOperation.java b/TMessagesProj/src/main/java/org/telegram/messenger/FileUploadOperation.java
index da776516c..e60cc2892 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/FileUploadOperation.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/FileUploadOperation.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -63,6 +63,10 @@ public FileUploadOperation(String location, boolean encrypted, int estimated) {
         estimatedSize = estimated;
     }
 
+    public long getTotalFileSize() {
+        return totalFileSize;
+    }
+
     public void start() {
         if (state != 0) {
             return;
@@ -77,7 +81,7 @@ public void run() {
     }
 
     public void cancel() {
-        if (state != 1) {
+        if (state == 3) {
             return;
         }
         state = 2;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/GcmBroadcastReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/GcmBroadcastReceiver.java
index 8ad9d9a37..7a18c9e1b 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/GcmBroadcastReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/GcmBroadcastReceiver.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ImageLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/ImageLoader.java
index a86af8f97..453e37e51 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ImageLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ImageLoader.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -75,7 +75,7 @@
     private HashMap<String, Runnable> retryHttpsTasks = new HashMap<>();
     private int currentHttpFileLoadTasksCount = 0;
 
-    protected VMRuntimeHack runtimeHack = null;
+    public VMRuntimeHack runtimeHack = null;
     private String ignoreRemoval = null;
 
     private volatile long lastCacheOutTime = 0;
@@ -466,7 +466,7 @@ public void run() {
                     return;
                 }
                 float scaleFactor = Math.min((float) w / size, (float) h / size);
-                Bitmap scaledBitmap = Bitmap.createScaledBitmap(originalBitmap, (int) (w / scaleFactor), (int) (h / scaleFactor), true);
+                Bitmap scaledBitmap = Bitmaps.createScaledBitmap(originalBitmap, (int) (w / scaleFactor), (int) (h / scaleFactor), true);
                 if (scaledBitmap != originalBitmap) {
                     originalBitmap.recycle();
                 }
@@ -590,14 +590,20 @@ public void run() {
                     BitmapFactory.Options opts = new BitmapFactory.Options();
                     opts.inSampleSize = 1;
 
-                    if (!useNativeWebpLoaded && Build.VERSION.SDK_INT > 10 && Build.VERSION.SDK_INT < 21) {
+                    if (Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT < 21) {
                         opts.inPurgeable = true;
                     }
 
                     if (useNativeWebpLoaded) {
                         RandomAccessFile file = new RandomAccessFile(cacheFileFinal, "r");
                         ByteBuffer buffer = file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, cacheFileFinal.length());
-                        image = Utilities.loadWebpImage(buffer, buffer.limit(), null);
+
+                        BitmapFactory.Options bmOptions = new BitmapFactory.Options();
+                        bmOptions.inJustDecodeBounds = true;
+                        Utilities.loadWebpImage(null, buffer, buffer.limit(), bmOptions, true);
+                        image = Bitmaps.createBitmap(bmOptions.outWidth, bmOptions.outHeight, Bitmap.Config.ARGB_8888);
+
+                        Utilities.loadWebpImage(image, buffer, buffer.limit(), null, !opts.inPurgeable);
                         file.close();
                     } else {
                         if (opts.inPurgeable) {
@@ -629,8 +635,7 @@ public void run() {
                             Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
                             Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
                             Utilities.blurBitmap(image, 7, opts.inPurgeable ? 0 : 1);
-                        }
-                        if (blurType == 0 && opts.inPurgeable) {
+                        } else if (blurType == 0 && opts.inPurgeable) {
                             Utilities.pinBitmap(image);
                         }
                         if (runtimeHack != null) {
@@ -730,7 +735,7 @@ public void run() {
                     } else {
                         opts.inPreferredConfig = Bitmap.Config.RGB_565;
                     }
-                    if (!useNativeWebpLoaded && Build.VERSION.SDK_INT > 10 && Build.VERSION.SDK_INT < 21) {
+                    if (Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT < 21) {
                         opts.inPurgeable = true;
                     }
 
@@ -746,7 +751,13 @@ public void run() {
                         if (useNativeWebpLoaded) {
                             RandomAccessFile file = new RandomAccessFile(cacheFileFinal, "r");
                             ByteBuffer buffer = file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, cacheFileFinal.length());
-                            image = Utilities.loadWebpImage(buffer, buffer.limit(), null);
+
+                            BitmapFactory.Options bmOptions = new BitmapFactory.Options();
+                            bmOptions.inJustDecodeBounds = true;
+                            Utilities.loadWebpImage(null, buffer, buffer.limit(), bmOptions, true);
+                            image = Bitmaps.createBitmap(bmOptions.outWidth, bmOptions.outHeight, Bitmap.Config.ARGB_8888);
+
+                            Utilities.loadWebpImage(image, buffer, buffer.limit(), null, !opts.inPurgeable);
                             file.close();
                         } else {
                             if (opts.inPurgeable) {
@@ -776,7 +787,7 @@ public void run() {
                             float bitmapH = image.getHeight();
                             if (!opts.inPurgeable && w_filter != 0 && bitmapW != w_filter && bitmapW > w_filter + 20) {
                                 float scaleFactor = bitmapW / w_filter;
-                                Bitmap scaledBitmap = Bitmap.createScaledBitmap(image, (int) w_filter, (int) (bitmapH / scaleFactor), true);
+                                Bitmap scaledBitmap = Bitmaps.createScaledBitmap(image, (int) w_filter, (int) (bitmapH / scaleFactor), true);
                                 if (image != scaledBitmap) {
                                     image.recycle();
                                     image = scaledBitmap;
@@ -1010,6 +1021,12 @@ public static ImageLoader getInstance() {
     }
 
     public ImageLoader() {
+
+        cacheOutQueue.setPriority(Thread.MIN_PRIORITY);
+        cacheThumbOutQueue.setPriority(Thread.MIN_PRIORITY);
+        thumbGeneratingQueue.setPriority(Thread.MIN_PRIORITY);
+        imageLoadQueue.setPriority(Thread.MIN_PRIORITY);
+
         int cacheSize = Math.min(15, ((ActivityManager) ApplicationLoader.applicationContext.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass() / 7) * 1024 * 1024;
 
         if (Build.VERSION.SDK_INT < 11) {
@@ -1018,8 +1035,8 @@ public ImageLoader() {
         }
         memCache = new LruCache(cacheSize) {
             @Override
-            protected int sizeOf(String key, BitmapDrawable bitmap) {
-                Bitmap b = bitmap.getBitmap();
+            protected int sizeOf(String key, BitmapDrawable value) {
+                Bitmap b = value.getBitmap();
                 if (Build.VERSION.SDK_INT < 12) {
                     return b.getRowBytes() * b.getHeight();
                 } else {
@@ -1028,13 +1045,13 @@ protected int sizeOf(String key, BitmapDrawable bitmap) {
             }
 
             @Override
-            protected void entryRemoved(boolean evicted, String key, final BitmapDrawable oldBitmap, BitmapDrawable newBitmap) {
+            protected void entryRemoved(boolean evicted, String key, final BitmapDrawable oldValue, BitmapDrawable newValue) {
                 if (ignoreRemoval != null && key != null && ignoreRemoval.equals(key)) {
                     return;
                 }
                 final Integer count = bitmapUseCounts.get(key);
                 if (count == null || count == 0) {
-                    Bitmap b = oldBitmap.getBitmap();
+                    Bitmap b = oldValue.getBitmap();
                     if (runtimeHack != null) {
                         runtimeHack.trackAlloc(b.getRowBytes() * b.getHeight());
                     }
@@ -1063,14 +1080,14 @@ public void run() {
             }
 
             @Override
-            public void fileDidUploaded(final String location, final TLRPC.InputFile inputFile, final TLRPC.InputEncryptedFile inputEncryptedFile, final byte[] key, final byte[] iv) {
+            public void fileDidUploaded(final String location, final TLRPC.InputFile inputFile, final TLRPC.InputEncryptedFile inputEncryptedFile, final byte[] key, final byte[] iv, final long totalFileSize) {
                 Utilities.stageQueue.postRunnable(new Runnable() {
                     @Override
                     public void run() {
                         AndroidUtilities.runOnUIThread(new Runnable() {
                             @Override
                             public void run() {
-                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.FileDidUpload, location, inputFile, inputEncryptedFile, key, iv);
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.FileDidUpload, location, inputFile, inputEncryptedFile, key, iv, totalFileSize);
                             }
                         });
                         fileProgresses.remove(location);
@@ -1145,7 +1162,18 @@ public void onReceive(Context arg0, Intent intent) {
                 FileLog.e("tmessages", "file system changed");
                 Runnable r = new Runnable() {
                     public void run() {
-                        FileLoader.getInstance().setMediaDirs(createMediaPaths());
+                        cacheOutQueue.postRunnable(new Runnable() {
+                            @Override
+                            public void run() {
+                                final HashMap<Integer, File> paths = createMediaPaths();
+                                AndroidUtilities.runOnUIThread(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        FileLoader.getInstance().setMediaDirs(paths);
+                                    }
+                                });
+                            }
+                        });
                     }
                 };
                 if (Intent.ACTION_MEDIA_UNMOUNTED.equals(intent.getAction())) {
@@ -1169,10 +1197,38 @@ public void run() {
         filter.addDataScheme("file");
         ApplicationLoader.applicationContext.registerReceiver(receiver, filter);
 
-        FileLoader.getInstance().setMediaDirs(createMediaPaths());
+        HashMap<Integer, File> mediaDirs = new HashMap<>();
+        File cachePath = AndroidUtilities.getCacheDir();
+        if (!cachePath.isDirectory()) {
+            try {
+                cachePath.mkdirs();
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+        }
+        try {
+            new File(cachePath, ".nomedia").createNewFile();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        mediaDirs.put(FileLoader.MEDIA_DIR_CACHE, cachePath);
+        FileLoader.getInstance().setMediaDirs(mediaDirs);
+
+        cacheOutQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                final HashMap<Integer, File> paths = createMediaPaths();
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        FileLoader.getInstance().setMediaDirs(paths);
+                    }
+                });
+            }
+        });
     }
 
-    private HashMap<Integer, File> createMediaPaths() {
+    public HashMap<Integer, File> createMediaPaths() {
         HashMap<Integer, File> mediaDirs = new HashMap<>();
         File cachePath = AndroidUtilities.getCacheDir();
         if (!cachePath.isDirectory()) {
@@ -1200,7 +1256,7 @@ public void run() {
                     try {
                         File imagePath = new File(telegramPath, "Telegram Images");
                         imagePath.mkdir();
-                        if (imagePath.isDirectory() && canMoveFiles(cachePath, imagePath)) {
+                        if (imagePath.isDirectory() && canMoveFiles(cachePath, imagePath, FileLoader.MEDIA_DIR_IMAGE)) {
                             mediaDirs.put(FileLoader.MEDIA_DIR_IMAGE, imagePath);
                             FileLog.e("tmessages", "image path = " + imagePath);
                         }
@@ -1211,7 +1267,7 @@ public void run() {
                     try {
                         File videoPath = new File(telegramPath, "Telegram Video");
                         videoPath.mkdir();
-                        if (videoPath.isDirectory() && canMoveFiles(cachePath, videoPath)) {
+                        if (videoPath.isDirectory() && canMoveFiles(cachePath, videoPath, FileLoader.MEDIA_DIR_VIDEO)) {
                             mediaDirs.put(FileLoader.MEDIA_DIR_VIDEO, videoPath);
                             FileLog.e("tmessages", "video path = " + videoPath);
                         }
@@ -1222,7 +1278,7 @@ public void run() {
                     try {
                         File audioPath = new File(telegramPath, "Telegram Audio");
                         audioPath.mkdir();
-                        if (audioPath.isDirectory() && canMoveFiles(cachePath, audioPath)) {
+                        if (audioPath.isDirectory() && canMoveFiles(cachePath, audioPath, FileLoader.MEDIA_DIR_AUDIO)) {
                             new File(audioPath, ".nomedia").createNewFile();
                             mediaDirs.put(FileLoader.MEDIA_DIR_AUDIO, audioPath);
                             FileLog.e("tmessages", "audio path = " + audioPath);
@@ -1234,7 +1290,7 @@ public void run() {
                     try {
                         File documentPath = new File(telegramPath, "Telegram Documents");
                         documentPath.mkdir();
-                        if (documentPath.isDirectory() && canMoveFiles(cachePath, documentPath)) {
+                        if (documentPath.isDirectory() && canMoveFiles(cachePath, documentPath, FileLoader.MEDIA_DIR_DOCUMENT)) {
                             new File(documentPath, ".nomedia").createNewFile();
                             mediaDirs.put(FileLoader.MEDIA_DIR_DOCUMENT, documentPath);
                             FileLog.e("tmessages", "documents path = " + documentPath);
@@ -1254,23 +1310,35 @@ public void run() {
         return mediaDirs;
     }
 
-    private boolean canMoveFiles(File from, File to) {
+    private boolean canMoveFiles(File from, File to, int type) {
         RandomAccessFile file = null;
         try {
-            for (int a = 0; a < 5; a++) {
-                File srcFile = new File(from, "temp.file");
-                srcFile.createNewFile();
-                file = new RandomAccessFile(srcFile, "rws");
-                file.write(1);
-                file.close();
-                file = null;
-                File dstFile = new File(to, "temp.file");
-                boolean canRename = srcFile.renameTo(dstFile);
-                srcFile.delete();
-                dstFile.delete();
-                if (canRename) {
-                    return true;
-                }
+            File srcFile = null;
+            File dstFile = null;
+            if (type == FileLoader.MEDIA_DIR_IMAGE) {
+                srcFile = new File(from, "000000000_999999_temp.jpg");
+                dstFile = new File(to, "000000000_999999.jpg");
+            } else if (type == FileLoader.MEDIA_DIR_DOCUMENT) {
+                srcFile = new File(from, "000000000_999999_temp.doc");
+                dstFile = new File(to, "000000000_999999.doc");
+            } else if (type == FileLoader.MEDIA_DIR_AUDIO) {
+                srcFile = new File(from, "000000000_999999_temp.ogg");
+                dstFile = new File(to, "000000000_999999.ogg");
+            } else if (type == FileLoader.MEDIA_DIR_VIDEO) {
+                srcFile = new File(from, "000000000_999999_temp.mp4");
+                dstFile = new File(to, "000000000_999999.mp4");
+            }
+            byte[] buffer = new byte[1024];
+            srcFile.createNewFile();
+            file = new RandomAccessFile(srcFile, "rws");
+            file.write(buffer);
+            file.close();
+            file = null;
+            boolean canRename = srcFile.renameTo(dstFile);
+            srcFile.delete();
+            dstFile.delete();
+            if (canRename) {
+                return true;
             }
         } catch (Exception e) {
             FileLog.e("tmessages", e);
@@ -1914,6 +1982,7 @@ public static Bitmap loadBitmap(String path, Uri uri, float maxWidth, float maxH
         }
         bmOptions.inJustDecodeBounds = false;
         bmOptions.inSampleSize = (int) scaleFactor;
+        bmOptions.inPurgeable = Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT < 21;
 
         String exifPath = null;
         if (path != null) {
@@ -1951,7 +2020,14 @@ public static Bitmap loadBitmap(String path, Uri uri, float maxWidth, float maxH
             try {
                 b = BitmapFactory.decodeFile(path, bmOptions);
                 if (b != null) {
-                    b = Bitmap.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), matrix, true);
+                    if (bmOptions.inPurgeable) {
+                        Utilities.pinBitmap(b);
+                    }
+                    Bitmap newBitmap = Bitmaps.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), matrix, true);
+                    if (newBitmap != b) {
+                        b.recycle();
+                        b = newBitmap;
+                    }
                 }
             } catch (Throwable e) {
                 FileLog.e("tmessages", e);
@@ -1959,9 +2035,16 @@ public static Bitmap loadBitmap(String path, Uri uri, float maxWidth, float maxH
                 try {
                     if (b == null) {
                         b = BitmapFactory.decodeFile(path, bmOptions);
+                        if (b != null && bmOptions.inPurgeable) {
+                            Utilities.pinBitmap(b);
+                        }
                     }
                     if (b != null) {
-                        b = Bitmap.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), matrix, true);
+                        Bitmap newBitmap = Bitmaps.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), matrix, true);
+                        if (newBitmap != b) {
+                            b.recycle();
+                            b = newBitmap;
+                        }
                     }
                 } catch (Throwable e2) {
                     FileLog.e("tmessages", e2);
@@ -1971,7 +2054,14 @@ public static Bitmap loadBitmap(String path, Uri uri, float maxWidth, float maxH
             try {
                 b = BitmapFactory.decodeFileDescriptor(fileDescriptor, null, bmOptions);
                 if (b != null) {
-                    b = Bitmap.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), matrix, true);
+                    if (bmOptions.inPurgeable) {
+                        Utilities.pinBitmap(b);
+                    }
+                    Bitmap newBitmap = Bitmaps.createBitmap(b, 0, 0, b.getWidth(), b.getHeight(), matrix, true);
+                    if (newBitmap != b) {
+                        b.recycle();
+                        b = newBitmap;
+                    }
                 }
             } catch (Throwable e) {
                 FileLog.e("tmessages", e);
@@ -2007,7 +2097,7 @@ public static void fillPhotoSizeWithBytes(TLRPC.PhotoSize photoSize) {
     private static TLRPC.PhotoSize scaleAndSaveImageInternal(Bitmap bitmap, int w, int h, float photoW, float photoH, float scaleFactor, int quality, boolean cache, boolean scaleAnyway) throws Exception {
         Bitmap scaledBitmap;
         if (scaleFactor > 1 || scaleAnyway) {
-            scaledBitmap = Bitmap.createScaledBitmap(bitmap, w, h, true);
+            scaledBitmap = Bitmaps.createScaledBitmap(bitmap, w, h, true);
         } else {
             scaledBitmap = bitmap;
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ImageReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/ImageReceiver.java
index 0e9c66388..12ce3f535 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ImageReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ImageReceiver.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/LocaleController.java b/TMessagesProj/src/main/java/org/telegram/messenger/LocaleController.java
index 9a9b4d3f5..355427b08 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/LocaleController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/LocaleController.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -46,14 +46,14 @@
     public static boolean isRTL = false;
     public static int nameDisplayOrder = 1;
     private static boolean is24HourFormat = false;
-    public static FastDateFormat formatterDay;
-    public static FastDateFormat formatterWeek;
-    public static FastDateFormat formatterMonth;
-    public static FastDateFormat formatterYear;
-    public static FastDateFormat formatterMonthYear;
-    public static FastDateFormat formatterYearMax;
-    public static FastDateFormat chatDate;
-    public static FastDateFormat chatFullDate;
+    public FastDateFormat formatterDay;
+    public FastDateFormat formatterWeek;
+    public FastDateFormat formatterMonth;
+    public FastDateFormat formatterYear;
+    public FastDateFormat formatterMonthYear;
+    public FastDateFormat formatterYearMax;
+    public FastDateFormat chatDate;
+    public FastDateFormat chatFullDate;
 
     private HashMap<String, PluralRules> allRules = new HashMap<>();
 
@@ -354,7 +354,7 @@ public boolean applyLanguageFile(File file) {
                     return false;
                 }
 
-                File finalFile = new File(ApplicationLoader.applicationContext.getFilesDir(), languageCode + ".xml");
+                File finalFile = new File(ApplicationLoader.getFilesDirFixed(), languageCode + ".xml");
                 if (!AndroidUtilities.copyFile(file, finalFile)) {
                     return false;
                 }
@@ -495,7 +495,7 @@ private void loadOtherLanguages() {
                 FileLog.e("tmessages", e);
             }
         }
-        return null;
+        return new HashMap<>();
     }
 
     public void applyLanguage(LocaleInfo localeInfo, boolean override) {
@@ -671,9 +671,9 @@ public static String formatDateChat(long date) {
         int dateYear = rightNow.get(Calendar.YEAR);
 
         if (year == dateYear) {
-            return chatDate.format(date * 1000);
+            return getInstance().chatDate.format(date * 1000);
         }
-        return chatFullDate.format(date * 1000);
+        return getInstance().chatFullDate.format(date * 1000);
     }
 
     public static String formatDate(long date) {
@@ -686,13 +686,13 @@ public static String formatDate(long date) {
             int dateYear = rightNow.get(Calendar.YEAR);
 
             if (dateDay == day && year == dateYear) {
-                return formatterDay.format(new Date(date * 1000));
+                return getInstance().formatterDay.format(new Date(date * 1000));
             } else if (dateDay + 1 == day && year == dateYear) {
                 return getString("Yesterday", R.string.Yesterday);
             } else if (year == dateYear) {
-                return formatterMonth.format(new Date(date * 1000));
+                return getInstance().formatterMonth.format(new Date(date * 1000));
             } else {
-                return formatterYear.format(new Date(date * 1000));
+                return getInstance().formatterYear.format(new Date(date * 1000));
             }
         } catch (Exception e) {
             FileLog.e("tmessages", e);
@@ -710,14 +710,22 @@ public static String formatDateOnline(long date) {
             int dateYear = rightNow.get(Calendar.YEAR);
 
             if (dateDay == day && year == dateYear) {
-                return String.format("%s %s %s", LocaleController.getString("LastSeen", R.string.LastSeen), LocaleController.getString("TodayAt", R.string.TodayAt), formatterDay.format(new Date(date * 1000)));
+                return String.format("%s %s %s", LocaleController.getString("LastSeen", R.string.LastSeen), LocaleController.getString("TodayAt", R.string.TodayAt), getInstance().formatterDay.format(new Date(date * 1000)));
+                /*int diff = (int) (ConnectionsManager.getInstance().getCurrentTime() - date) / 60;
+                if (diff < 1) {
+                    return LocaleController.getString("LastSeenNow", R.string.LastSeenNow);
+                } else if (diff < 60) {
+                    return LocaleController.formatPluralString("LastSeenMinutes", diff);
+                } else {
+                    return LocaleController.formatPluralString("LastSeenHours", (int) Math.ceil(diff / 60.0f));
+                }*/
             } else if (dateDay + 1 == day && year == dateYear) {
-                return String.format("%s %s %s", LocaleController.getString("LastSeen", R.string.LastSeen), LocaleController.getString("YesterdayAt", R.string.YesterdayAt), formatterDay.format(new Date(date * 1000)));
+                return String.format("%s %s %s", LocaleController.getString("LastSeen", R.string.LastSeen), LocaleController.getString("YesterdayAt", R.string.YesterdayAt), getInstance().formatterDay.format(new Date(date * 1000)));
             } else if (year == dateYear) {
-                String format = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, formatterMonth.format(new Date(date * 1000)), formatterDay.format(new Date(date * 1000)));
+                String format = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, getInstance().formatterMonth.format(new Date(date * 1000)), getInstance().formatterDay.format(new Date(date * 1000)));
                 return String.format("%s %s", LocaleController.getString("LastSeenDate", R.string.LastSeenDate), format);
             } else {
-                String format = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, formatterYear.format(new Date(date * 1000)), formatterDay.format(new Date(date * 1000)));
+                String format = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, getInstance().formatterYear.format(new Date(date * 1000)), getInstance().formatterDay.format(new Date(date * 1000)));
                 return String.format("%s %s", LocaleController.getString("LastSeenDate", R.string.LastSeenDate), format);
             }
         } catch (Exception e) {
@@ -772,15 +780,15 @@ public static String stringForMessageListDate(long date) {
             int dateYear = rightNow.get(Calendar.YEAR);
 
             if (year != dateYear) {
-                return formatterYear.format(new Date(date * 1000));
+                return getInstance().formatterYear.format(new Date(date * 1000));
             } else {
                 int dayDiff = dateDay - day;
                 if(dayDiff == 0 || dayDiff == -1 && (int)(System.currentTimeMillis() / 1000) - date < 60 * 60 * 8) {
-                    return formatterDay.format(new Date(date * 1000));
+                    return getInstance().formatterDay.format(new Date(date * 1000));
                 } else if(dayDiff > -7 && dayDiff <= -1) {
-                    return formatterWeek.format(new Date(date * 1000));
+                    return getInstance().formatterWeek.format(new Date(date * 1000));
                 } else {
-                    return formatterMonth.format(new Date(date * 1000));
+                    return getInstance().formatterMonth.format(new Date(date * 1000));
                 }
             }
         } catch (Exception e) {
@@ -792,6 +800,7 @@ public static String stringForMessageListDate(long date) {
     public static String formatShortNumber(int number, int[] rounded) {
         String K = "";
         int lastDec = 0;
+        int KCount = 0;
         while (number / 1000 > 0) {
             K += "K";
             lastDec = (number % 1000) / 100;
@@ -805,7 +814,11 @@ public static String formatShortNumber(int number, int[] rounded) {
             rounded[0] = (int) value;
         }
         if (lastDec != 0 && K.length() > 0) {
-            return String.format(Locale.US, "%d.%d%s", number, lastDec, K);
+            if (K.length() == 2) {
+                return String.format(Locale.US, "%d.%dM", number, lastDec);
+            } else {
+                return String.format(Locale.US, "%d.%d%s", number, lastDec, K);
+            }
         }
         return String.format(Locale.US, "%d%s", number, K);
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/LruCache.java b/TMessagesProj/src/main/java/org/telegram/messenger/LruCache.java
index 7e5280832..d1bed2cda 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/LruCache.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/LruCache.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java b/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
index 1860a397b..50ec51e5a 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MediaController.java
@@ -3,11 +3,12 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
 
+import android.Manifest;
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
@@ -17,6 +18,7 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
 import android.database.ContentObserver;
 import android.database.Cursor;
 import android.graphics.BitmapFactory;
@@ -62,6 +64,7 @@
 import java.io.FileOutputStream;
 import java.lang.ref.WeakReference;
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import java.nio.channels.FileChannel;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -273,6 +276,7 @@ public PhotoEntry(int bucketId, int imageId, long dateTaken, String path, int or
     private ArrayList<MessageObject> shuffledPlaylist = new ArrayList<>();
     private int currentPlaylistNum;
     private boolean downloadingCurrentMessage;
+    private boolean playMusicAgain;
     private AudioInfo audioInfo;
 
     private AudioRecord audioRecorder = null;
@@ -310,10 +314,22 @@ public void run() {
                     recordBuffers.remove(0);
                 } else {
                     buffer = ByteBuffer.allocateDirect(recordBufferSize);
+                    buffer.order(ByteOrder.nativeOrder());
                 }
                 buffer.rewind();
                 int len = audioRecorder.read(buffer, buffer.capacity());
                 if (len > 0) {
+                    double sum = 0;
+                    try {
+                        for (int i = 0; i < len / 2; i++) {
+                            short peak = buffer.getShort();
+                            sum += peak * peak;
+                        }
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    buffer.position(0);
+                    final double amplitude = Math.sqrt(sum / len / 2);
                     buffer.limit(len);
                     final ByteBuffer finalBuffer = buffer;
                     final boolean flush = len != buffer.capacity();
@@ -351,7 +367,7 @@ public void run() {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.recordProgressChanged, System.currentTimeMillis() - recordStartTime);
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.recordProgressChanged, System.currentTimeMillis() - recordStartTime, amplitude);
                         }
                     });
                 } else {
@@ -493,6 +509,7 @@ public MediaController() {
             }
             for (int a = 0; a < 5; a++) {
                 ByteBuffer buffer = ByteBuffer.allocateDirect(4096);
+                buffer.order(ByteOrder.nativeOrder());
                 recordBuffers.add(buffer);
             }
             for (int a = 0; a < 3; a++) {
@@ -525,13 +542,18 @@ public MediaController() {
         shuffleMusic = preferences.getBoolean("shuffleMusic", false);
         repeatMode = preferences.getInt("repeatMode", 0);
 
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileDidFailedLoad);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileDidLoaded);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileLoadProgressChanged);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.FileUploadProgressChanged);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.messagesDeleted);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.removeAllMessagesFromDialog);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.musicDidLoaded);
+        AndroidUtilities.runOnUIThread(new Runnable() {
+            @Override
+            public void run() {
+                NotificationCenter.getInstance().addObserver(MediaController.this, NotificationCenter.FileDidFailedLoad);
+                NotificationCenter.getInstance().addObserver(MediaController.this, NotificationCenter.FileDidLoaded);
+                NotificationCenter.getInstance().addObserver(MediaController.this, NotificationCenter.FileLoadProgressChanged);
+                NotificationCenter.getInstance().addObserver(MediaController.this, NotificationCenter.FileUploadProgressChanged);
+                NotificationCenter.getInstance().addObserver(MediaController.this, NotificationCenter.messagesDeleted);
+                NotificationCenter.getInstance().addObserver(MediaController.this, NotificationCenter.removeAllMessagesFromDialog);
+                NotificationCenter.getInstance().addObserver(MediaController.this, NotificationCenter.musicDidLoaded);
+            }
+        });
 
         BroadcastReceiver networkStateReceiver = new BroadcastReceiver() {
             @Override
@@ -647,13 +669,14 @@ private void stopProgressTimer() {
     }
 
     public void cleanup() {
-        clenupPlayer(false, true);
+        cleanupPlayer(false, true);
         if (currentGifDrawable != null) {
             currentGifDrawable.recycle();
             currentGifDrawable = null;
         }
         currentMediaCell = null;
         audioInfo = null;
+        playMusicAgain = false;
         currentGifMessageObject = null;
         photoDownloadQueue.clear();
         audioDownloadQueue.clear();
@@ -1050,6 +1073,7 @@ public void didReceivedNotification(int id, Object... args) {
             if (downloadingCurrentMessage && playingMessageObject != null) {
                 String file = FileLoader.getAttachFileName(playingMessageObject.messageOwner.media.document);
                 if (file.equals(fileName)) {
+                    playMusicAgain = true;
                     playAudio(playingMessageObject);
                 }
             }
@@ -1098,7 +1122,8 @@ public void didReceivedNotification(int id, Object... args) {
             try {
                 ArrayList<SendMessagesHelper.DelayedMessage> delayedMessages = SendMessagesHelper.getInstance().getDelayedMessages(fileName);
                 if (delayedMessages != null) {
-                    for (SendMessagesHelper.DelayedMessage delayedMessage : delayedMessages) {
+                    for (int a = 0; a < delayedMessages.size(); a++) {
+                        SendMessagesHelper.DelayedMessage delayedMessage = delayedMessages.get(a);
                         if (delayedMessage.encryptedChat == null) {
                             long dialog_id = delayedMessage.obj.getDialogId();
                             Long lastTime = typingTimes.get(dialog_id);
@@ -1126,13 +1151,13 @@ public void didReceivedNotification(int id, Object... args) {
                 }
                 ArrayList<Integer> markAsDeletedMessages = (ArrayList<Integer>) args[0];
                 if (markAsDeletedMessages.contains(playingMessageObject.getId())) {
-                    clenupPlayer(false, true);
+                    cleanupPlayer(false, true);
                 }
             }
         } else if (id == NotificationCenter.removeAllMessagesFromDialog) {
             long did = (Long) args[0];
             if (playingMessageObject != null && playingMessageObject.getDialogId() == did) {
-                clenupPlayer(false, true);
+                cleanupPlayer(false, true);
             }
         } else if (id == NotificationCenter.musicDidLoaded) {
             long did = (Long) args[0];
@@ -1240,7 +1265,7 @@ public void run() {
                                         audioTrackPlayer.setNotificationMarkerPosition(1);
                                     }
                                     if (finalBuffersWrited == 1) {
-                                        clenupPlayer(true, true);
+                                        cleanupPlayer(true, true);
                                     }
                                 }
                             }
@@ -1287,7 +1312,7 @@ public void onSensorChanged(SensorEvent event) {
         NotificationCenter.getInstance().postNotificationName(NotificationCenter.audioRouteChanged, useFrontSpeaker);
         MessageObject currentMessageObject = playingMessageObject;
         float progress = playingMessageObject.audioProgress;
-        clenupPlayer(false, true);
+        cleanupPlayer(false, true);
         currentMessageObject.audioProgress = progress;
         playAudio(currentMessageObject);
         ignoreProximity = false;
@@ -1332,41 +1357,46 @@ private void startProximitySensor() {
         }
     }
 
-    public void clenupPlayer(boolean notify, boolean stopService) {
+    public void cleanupPlayer(boolean notify, boolean stopService) {
         stopProximitySensor();
-        if (playingMessageObject != null) {
-            if (audioPlayer != null) {
+        if (audioPlayer != null) {
+            try {
+                audioPlayer.reset();
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+            try {
+                audioPlayer.stop();
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+            try {
+                audioPlayer.release();
+                audioPlayer = null;
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+        } else if (audioTrackPlayer != null) {
+            synchronized (playerObjectSync) {
                 try {
-                    audioPlayer.stop();
+                    audioTrackPlayer.pause();
+                    audioTrackPlayer.flush();
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 }
                 try {
-                    audioPlayer.release();
-                    audioPlayer = null;
+                    audioTrackPlayer.release();
+                    audioTrackPlayer = null;
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 }
-            } else if (audioTrackPlayer != null) {
-                synchronized (playerObjectSync) {
-                    try {
-                        audioTrackPlayer.pause();
-                        audioTrackPlayer.flush();
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
-                    }
-                    try {
-                        audioTrackPlayer.release();
-                        audioTrackPlayer = null;
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
-                    }
-                }
             }
-            stopProgressTimer();
-            lastProgress = 0;
-            buffersWrited = 0;
-            isPaused = false;
+        }
+        stopProgressTimer();
+        lastProgress = 0;
+        buffersWrited = 0;
+        isPaused = false;
+        if (playingMessageObject != null) {
             if (downloadingCurrentMessage) {
                 FileLoader.getInstance().cancelLoadFile(playingMessageObject.messageOwner.media.document);
             }
@@ -1465,6 +1495,7 @@ public boolean setPlaylist(ArrayList<MessageObject> messageObjects, MessageObjec
         if (playingMessageObject == current) {
             return playAudio(current);
         }
+        playMusicAgain = !playlist.isEmpty();
         playlist.clear();
         for (int a = messageObjects.size() - 1; a >= 0; a--) {
             MessageObject messageObject = messageObjects.get(a);
@@ -1494,7 +1525,7 @@ private void playNextMessage(boolean byStop) {
         ArrayList<MessageObject> currentPlayList = shuffleMusic ? shuffledPlaylist : playlist;
 
         if (byStop && repeatMode == 2) {
-            clenupPlayer(false, false);
+            cleanupPlayer(false, false);
             playAudio(currentPlayList.get(currentPlaylistNum));
             return;
         }
@@ -1546,6 +1577,7 @@ private void playNextMessage(boolean byStop) {
         if (currentPlaylistNum < 0 || currentPlaylistNum >= currentPlayList.size()) {
             return;
         }
+        playMusicAgain = true;
         playAudio(currentPlayList.get(currentPlaylistNum));
     }
 
@@ -1559,6 +1591,7 @@ public void playPreviousMessage() {
         if (currentPlaylistNum < 0 || currentPlaylistNum >= currentPlayList.size()) {
             return;
         }
+        playMusicAgain = true;
         playAudio(currentPlayList.get(currentPlaylistNum));
     }
 
@@ -1599,7 +1632,8 @@ public boolean playAudio(MessageObject messageObject) {
         if (audioTrackPlayer != null) {
             MusicPlayerService.setIgnoreAudioFocus();
         }
-        clenupPlayer(true, false);
+        cleanupPlayer(!playMusicAgain, false);
+        playMusicAgain = false;
         File file = null;
         if (messageObject.messageOwner.attachPath != null && messageObject.messageOwner.attachPath.length() > 0) {
             file = new File(messageObject.messageOwner.attachPath);
@@ -1659,7 +1693,7 @@ public void run() {
                     audioTrackPlayer.setPlaybackPositionUpdateListener(new AudioTrack.OnPlaybackPositionUpdateListener() {
                         @Override
                         public void onMarkerReached(AudioTrack audioTrack) {
-                            clenupPlayer(true, true);
+                            cleanupPlayer(true, true);
                         }
 
                         @Override
@@ -1695,7 +1729,7 @@ public void onCompletion(MediaPlayer mediaPlayer) {
                         if (!playlist.isEmpty() && playlist.size() > 1) {
                             playNextMessage(true);
                         } else {
-                            clenupPlayer(true, true);
+                            cleanupPlayer(true, true);
                         }
                     }
                 });
@@ -1716,6 +1750,7 @@ public void onCompletion(MediaPlayer mediaPlayer) {
                 }
             } catch (Exception e) {
                 FileLog.e("tmessages", e);
+                NotificationCenter.getInstance().postNotificationName(NotificationCenter.audioPlayStateChanged, playingMessageObject != null ? playingMessageObject.getId() : 0);
                 if (audioPlayer != null) {
                     audioPlayer.release();
                     audioPlayer = null;
@@ -1844,7 +1879,7 @@ public void toggleShuffleMusic() {
                 if (currentPlaylistNum == -1) {
                     playlist.clear();
                     shuffledPlaylist.clear();
-                    clenupPlayer(true, true);
+                    cleanupPlayer(true, true);
                 }
             }
         }
@@ -2448,50 +2483,52 @@ public void run() {
 
                 Cursor cursor = null;
                 try {
-                    cursor = MediaStore.Images.Media.query(ApplicationLoader.applicationContext.getContentResolver(), MediaStore.Images.Media.EXTERNAL_CONTENT_URI, projectionPhotos, "", null, MediaStore.Images.Media.DATE_TAKEN + " DESC");
-                    if (cursor != null) {
-                        int imageIdColumn = cursor.getColumnIndex(MediaStore.Images.Media._ID);
-                        int bucketIdColumn = cursor.getColumnIndex(MediaStore.Images.Media.BUCKET_ID);
-                        int bucketNameColumn = cursor.getColumnIndex(MediaStore.Images.Media.BUCKET_DISPLAY_NAME);
-                        int dataColumn = cursor.getColumnIndex(MediaStore.Images.Media.DATA);
-                        int dateColumn = cursor.getColumnIndex(MediaStore.Images.Media.DATE_TAKEN);
-                        int orientationColumn = cursor.getColumnIndex(MediaStore.Images.Media.ORIENTATION);
-
-                        while (cursor.moveToNext()) {
-                            int imageId = cursor.getInt(imageIdColumn);
-                            int bucketId = cursor.getInt(bucketIdColumn);
-                            String bucketName = cursor.getString(bucketNameColumn);
-                            String path = cursor.getString(dataColumn);
-                            long dateTaken = cursor.getLong(dateColumn);
-                            int orientation = cursor.getInt(orientationColumn);
-
-                            if (path == null || path.length() == 0) {
-                                continue;
-                            }
+                    if (Build.VERSION.SDK_INT < 23 || Build.VERSION.SDK_INT >= 23 && ApplicationLoader.applicationContext.checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
+                        cursor = MediaStore.Images.Media.query(ApplicationLoader.applicationContext.getContentResolver(), MediaStore.Images.Media.EXTERNAL_CONTENT_URI, projectionPhotos, null, null, MediaStore.Images.Media.DATE_TAKEN + " DESC");
+                        if (cursor != null) {
+                            int imageIdColumn = cursor.getColumnIndex(MediaStore.Images.Media._ID);
+                            int bucketIdColumn = cursor.getColumnIndex(MediaStore.Images.Media.BUCKET_ID);
+                            int bucketNameColumn = cursor.getColumnIndex(MediaStore.Images.Media.BUCKET_DISPLAY_NAME);
+                            int dataColumn = cursor.getColumnIndex(MediaStore.Images.Media.DATA);
+                            int dateColumn = cursor.getColumnIndex(MediaStore.Images.Media.DATE_TAKEN);
+                            int orientationColumn = cursor.getColumnIndex(MediaStore.Images.Media.ORIENTATION);
+
+                            while (cursor.moveToNext()) {
+                                int imageId = cursor.getInt(imageIdColumn);
+                                int bucketId = cursor.getInt(bucketIdColumn);
+                                String bucketName = cursor.getString(bucketNameColumn);
+                                String path = cursor.getString(dataColumn);
+                                long dateTaken = cursor.getLong(dateColumn);
+                                int orientation = cursor.getInt(orientationColumn);
+
+                                if (path == null || path.length() == 0) {
+                                    continue;
+                                }
 
-                            PhotoEntry photoEntry = new PhotoEntry(bucketId, imageId, dateTaken, path, orientation, false);
+                                PhotoEntry photoEntry = new PhotoEntry(bucketId, imageId, dateTaken, path, orientation, false);
 
-                            if (allPhotosAlbum == null) {
-                                allPhotosAlbum = new AlbumEntry(0, LocaleController.getString("AllPhotos", R.string.AllPhotos), photoEntry, false);
-                                albumsSorted.add(0, allPhotosAlbum);
-                            }
-                            if (allPhotosAlbum != null) {
-                                allPhotosAlbum.addPhoto(photoEntry);
-                            }
+                                if (allPhotosAlbum == null) {
+                                    allPhotosAlbum = new AlbumEntry(0, LocaleController.getString("AllPhotos", R.string.AllPhotos), photoEntry, false);
+                                    albumsSorted.add(0, allPhotosAlbum);
+                                }
+                                if (allPhotosAlbum != null) {
+                                    allPhotosAlbum.addPhoto(photoEntry);
+                                }
 
-                            AlbumEntry albumEntry = albums.get(bucketId);
-                            if (albumEntry == null) {
-                                albumEntry = new AlbumEntry(bucketId, bucketName, photoEntry, false);
-                                albums.put(bucketId, albumEntry);
-                                if (cameraAlbumId == null && cameraFolder != null && path != null && path.startsWith(cameraFolder)) {
-                                    albumsSorted.add(0, albumEntry);
-                                    cameraAlbumId = bucketId;
-                                } else {
-                                    albumsSorted.add(albumEntry);
+                                AlbumEntry albumEntry = albums.get(bucketId);
+                                if (albumEntry == null) {
+                                    albumEntry = new AlbumEntry(bucketId, bucketName, photoEntry, false);
+                                    albums.put(bucketId, albumEntry);
+                                    if (cameraAlbumId == null && cameraFolder != null && path != null && path.startsWith(cameraFolder)) {
+                                        albumsSorted.add(0, albumEntry);
+                                        cameraAlbumId = bucketId;
+                                    } else {
+                                        albumsSorted.add(albumEntry);
+                                    }
                                 }
-                            }
 
-                            albumEntry.addPhoto(photoEntry);
+                                albumEntry.addPhoto(photoEntry);
+                            }
                         }
                     }
                 } catch (Throwable e) {
@@ -2507,50 +2544,52 @@ public void run() {
                 }
 
                 try {
-                    albums.clear();
-                    AlbumEntry allVideosAlbum = null;
-                    cursor = MediaStore.Images.Media.query(ApplicationLoader.applicationContext.getContentResolver(), MediaStore.Video.Media.EXTERNAL_CONTENT_URI, projectionVideo, "", null, MediaStore.Video.Media.DATE_TAKEN + " DESC");
-                    if (cursor != null) {
-                        int imageIdColumn = cursor.getColumnIndex(MediaStore.Video.Media._ID);
-                        int bucketIdColumn = cursor.getColumnIndex(MediaStore.Video.Media.BUCKET_ID);
-                        int bucketNameColumn = cursor.getColumnIndex(MediaStore.Video.Media.BUCKET_DISPLAY_NAME);
-                        int dataColumn = cursor.getColumnIndex(MediaStore.Video.Media.DATA);
-                        int dateColumn = cursor.getColumnIndex(MediaStore.Video.Media.DATE_TAKEN);
-
-                        while (cursor.moveToNext()) {
-                            int imageId = cursor.getInt(imageIdColumn);
-                            int bucketId = cursor.getInt(bucketIdColumn);
-                            String bucketName = cursor.getString(bucketNameColumn);
-                            String path = cursor.getString(dataColumn);
-                            long dateTaken = cursor.getLong(dateColumn);
-
-                            if (path == null || path.length() == 0) {
-                                continue;
-                            }
+                    if (Build.VERSION.SDK_INT < 23 || Build.VERSION.SDK_INT >= 23 && ApplicationLoader.applicationContext.checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
+                        albums.clear();
+                        AlbumEntry allVideosAlbum = null;
+                        cursor = MediaStore.Images.Media.query(ApplicationLoader.applicationContext.getContentResolver(), MediaStore.Video.Media.EXTERNAL_CONTENT_URI, projectionVideo, null, null, MediaStore.Video.Media.DATE_TAKEN + " DESC");
+                        if (cursor != null) {
+                            int imageIdColumn = cursor.getColumnIndex(MediaStore.Video.Media._ID);
+                            int bucketIdColumn = cursor.getColumnIndex(MediaStore.Video.Media.BUCKET_ID);
+                            int bucketNameColumn = cursor.getColumnIndex(MediaStore.Video.Media.BUCKET_DISPLAY_NAME);
+                            int dataColumn = cursor.getColumnIndex(MediaStore.Video.Media.DATA);
+                            int dateColumn = cursor.getColumnIndex(MediaStore.Video.Media.DATE_TAKEN);
+
+                            while (cursor.moveToNext()) {
+                                int imageId = cursor.getInt(imageIdColumn);
+                                int bucketId = cursor.getInt(bucketIdColumn);
+                                String bucketName = cursor.getString(bucketNameColumn);
+                                String path = cursor.getString(dataColumn);
+                                long dateTaken = cursor.getLong(dateColumn);
+
+                                if (path == null || path.length() == 0) {
+                                    continue;
+                                }
 
-                            PhotoEntry photoEntry = new PhotoEntry(bucketId, imageId, dateTaken, path, 0, true);
+                                PhotoEntry photoEntry = new PhotoEntry(bucketId, imageId, dateTaken, path, 0, true);
 
-                            if (allVideosAlbum == null) {
-                                allVideosAlbum = new AlbumEntry(0, LocaleController.getString("AllVideo", R.string.AllVideo), photoEntry, true);
-                                videoAlbumsSorted.add(0, allVideosAlbum);
-                            }
-                            if (allVideosAlbum != null) {
-                                allVideosAlbum.addPhoto(photoEntry);
-                            }
+                                if (allVideosAlbum == null) {
+                                    allVideosAlbum = new AlbumEntry(0, LocaleController.getString("AllVideo", R.string.AllVideo), photoEntry, true);
+                                    videoAlbumsSorted.add(0, allVideosAlbum);
+                                }
+                                if (allVideosAlbum != null) {
+                                    allVideosAlbum.addPhoto(photoEntry);
+                                }
 
-                            AlbumEntry albumEntry = albums.get(bucketId);
-                            if (albumEntry == null) {
-                                albumEntry = new AlbumEntry(bucketId, bucketName, photoEntry, true);
-                                albums.put(bucketId, albumEntry);
-                                if (cameraAlbumVideoId == null && cameraFolder != null && path != null && path.startsWith(cameraFolder)) {
-                                    videoAlbumsSorted.add(0, albumEntry);
-                                    cameraAlbumVideoId = bucketId;
-                                } else {
-                                    videoAlbumsSorted.add(albumEntry);
+                                AlbumEntry albumEntry = albums.get(bucketId);
+                                if (albumEntry == null) {
+                                    albumEntry = new AlbumEntry(bucketId, bucketName, photoEntry, true);
+                                    albums.put(bucketId, albumEntry);
+                                    if (cameraAlbumVideoId == null && cameraFolder != null && path != null && path.startsWith(cameraFolder)) {
+                                        videoAlbumsSorted.add(0, albumEntry);
+                                        cameraAlbumVideoId = bucketId;
+                                    } else {
+                                        videoAlbumsSorted.add(albumEntry);
+                                    }
                                 }
-                            }
 
-                            albumEntry.addPhoto(photoEntry);
+                                albumEntry.addPhoto(photoEntry);
+                            }
                         }
                     }
                 } catch (Throwable e) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MessageKeyData.java b/TMessagesProj/src/main/java/org/telegram/messenger/MessageKeyData.java
index 3789758c8..ac218a10b 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MessageKeyData.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MessageKeyData.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MessageObject.java b/TMessagesProj/src/main/java/org/telegram/messenger/MessageObject.java
index 90a1ad977..a505091e1 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MessageObject.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MessageObject.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -21,8 +21,10 @@
 import android.text.util.Linkify;
 
 import org.telegram.tgnet.ConnectionsManager;
+import org.telegram.tgnet.TLObject;
 import org.telegram.tgnet.TLRPC;
 import org.telegram.ui.Components.TypefaceSpan;
+import org.telegram.ui.Components.URLSpanBotCommand;
 import org.telegram.ui.Components.URLSpanNoUnderline;
 import org.telegram.ui.Components.URLSpanNoUnderlineBold;
 import org.telegram.ui.Components.URLSpanReplacement;
@@ -76,6 +78,10 @@
     public ArrayList<TextLayoutBlock> textLayoutBlocks;
 
     public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> users, boolean generateLayout) {
+        this(message, users, null, generateLayout);
+    }
+
+    public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> users, AbstractMap<Integer, TLRPC.Chat> chats, boolean generateLayout) {
         if (textPaint == null) {
             textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
             textPaint.setColor(0xff000000);
@@ -87,7 +93,7 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
         messageOwner = message;
 
         if (message.replyMessage != null) {
-            replyMessageObject = new MessageObject(message.replyMessage, users, false);
+            replyMessageObject = new MessageObject(message.replyMessage, users, chats, false);
         }
 
         if (message instanceof TLRPC.TL_messageService) {
@@ -142,39 +148,56 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                         }
                     }
                 } else if (message.action instanceof TLRPC.TL_messageActionChatAddUser) {
-                    TLRPC.User whoUser = null;
-                    if (users != null) {
-                        whoUser = users.get(message.action.user_id);
-                    }
-                    if (whoUser == null) {
-                        whoUser = MessagesController.getInstance().getUser(message.action.user_id);
+                    int singleUserId = messageOwner.action.user_id;
+                    if (singleUserId == 0 && messageOwner.action.users.size() == 1) {
+                        singleUserId = messageOwner.action.users.get(0);
                     }
-                    if (message.to_id.channel_id != 0) {
-                        if (whoUser != null && whoUser.id != UserConfig.getClientUserId()) {
-                            messageText = replaceWithLink(LocaleController.getString("ChannelAddedBy", R.string.ChannelAddedBy), "un1", whoUser);
-                        } else {
-                            messageText = LocaleController.getString("ChannelJoined", R.string.ChannelJoined);
+                    if (singleUserId != 0) {
+                        TLRPC.User whoUser = null;
+                        if (users != null) {
+                            whoUser = users.get(singleUserId);
                         }
-                    } else {
-                        if (whoUser != null && fromUser != null) {
-                            if (whoUser.id == fromUser.id) {
-                                if (isOut()) {
-                                    messageText = LocaleController.getString("ActionAddUserSelfYou", R.string.ActionAddUserSelfYou);
+                        if (whoUser == null) {
+                            whoUser = MessagesController.getInstance().getUser(singleUserId);
+                        }
+                        if (message.to_id.channel_id != 0 && !isMegagroup()) {
+                            if (whoUser != null && whoUser.id != UserConfig.getClientUserId()) {
+                                if (isMegagroup()) {
+                                    messageText = replaceWithLink(LocaleController.getString("MegaAddedBy", R.string.MegaAddedBy), "un1", whoUser);
                                 } else {
-                                    messageText = replaceWithLink(LocaleController.getString("ActionAddUserSelf", R.string.ActionAddUserSelf), "un1", fromUser);
+                                    messageText = replaceWithLink(LocaleController.getString("ChannelAddedBy", R.string.ChannelAddedBy), "un1", whoUser);
                                 }
                             } else {
-                                if (isOut()) {
-                                    messageText = replaceWithLink(LocaleController.getString("ActionYouAddUser", R.string.ActionYouAddUser), "un2", whoUser);
-                                } else if (message.action.user_id == UserConfig.getClientUserId()) {
-                                    messageText = replaceWithLink(LocaleController.getString("ActionAddUserYou", R.string.ActionAddUserYou), "un1", fromUser);
+                                messageText = LocaleController.getString("ChannelJoined", R.string.ChannelJoined);
+                            }
+                        } else {
+                            if (whoUser != null && fromUser != null) {
+                                if (whoUser.id == fromUser.id) {
+                                    if (isOut()) {
+                                        messageText = LocaleController.getString("ActionAddUserSelfYou", R.string.ActionAddUserSelfYou);
+                                    } else {
+                                        messageText = replaceWithLink(LocaleController.getString("ActionAddUserSelf", R.string.ActionAddUserSelf), "un1", fromUser);
+                                    }
                                 } else {
-                                    messageText = replaceWithLink(LocaleController.getString("ActionAddUser", R.string.ActionAddUser), "un2", whoUser);
-                                    messageText = replaceWithLink(messageText, "un1", fromUser);
+                                    if (isOut()) {
+                                        messageText = replaceWithLink(LocaleController.getString("ActionYouAddUser", R.string.ActionYouAddUser), "un2", whoUser);
+                                    } else if (singleUserId == UserConfig.getClientUserId()) {
+                                        messageText = replaceWithLink(LocaleController.getString("ActionAddUserYou", R.string.ActionAddUserYou), "un1", fromUser);
+                                    } else {
+                                        messageText = replaceWithLink(LocaleController.getString("ActionAddUser", R.string.ActionAddUser), "un2", whoUser);
+                                        messageText = replaceWithLink(messageText, "un1", fromUser);
+                                    }
                                 }
+                            } else {
+                                messageText = LocaleController.getString("ActionAddUser", R.string.ActionAddUser).replace("un2", "").replace("un1", "");
                             }
+                        }
+                    } else {
+                        if (isOut()) {
+                            messageText = replaceWithLink(LocaleController.getString("ActionYouAddUser", R.string.ActionYouAddUser), "un2", message.action.users, users);
                         } else {
-                            messageText = LocaleController.getString("ActionAddUser", R.string.ActionAddUser).replace("un2", "").replace("un1", "");
+                            messageText = replaceWithLink(LocaleController.getString("ActionAddUser", R.string.ActionAddUser), "un2", message.action.users, users);
+                            messageText = replaceWithLink(messageText, "un1", fromUser);
                         }
                     }
                 } else if (message.action instanceof TLRPC.TL_messageActionChatJoinedByLink) {
@@ -188,7 +211,7 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                         messageText = LocaleController.getString("ActionInviteUser", R.string.ActionInviteUser).replace("un1", "");
                     }
                 } else if (message.action instanceof TLRPC.TL_messageActionChatEditPhoto) {
-                    if (message.to_id.channel_id != 0) {
+                    if (message.to_id.channel_id != 0 && !isMegagroup()) {
                         messageText = LocaleController.getString("ActionChannelChangedPhoto", R.string.ActionChannelChangedPhoto);
                     } else {
                         if (isOut()) {
@@ -202,7 +225,7 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                         }
                     }
                 } else if (message.action instanceof TLRPC.TL_messageActionChatEditTitle) {
-                    if (message.to_id.channel_id != 0) {
+                    if (message.to_id.channel_id != 0 && !isMegagroup()) {
                         messageText = LocaleController.getString("ActionChannelChangedTitle", R.string.ActionChannelChangedTitle).replace("un2", message.action.title);
                     } else {
                         if (isOut()) {
@@ -216,7 +239,7 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                         }
                     }
                 } else if (message.action instanceof TLRPC.TL_messageActionChatDeletePhoto) {
-                    if (message.to_id.channel_id != 0) {
+                    if (message.to_id.channel_id != 0 && !isMegagroup()) {
                         messageText = LocaleController.getString("ActionChannelRemovedPhoto", R.string.ActionChannelRemovedPhoto);
                     } else {
                         if (isOut()) {
@@ -252,7 +275,13 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                         }
                     }
                 } else if (message.action instanceof TLRPC.TL_messageActionLoginUnknownLocation) {
-                    String date = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.formatterYear.format(((long) message.date) * 1000), LocaleController.formatterDay.format(((long) message.date) * 1000));
+                    String date;
+                    long time = ((long) message.date) * 1000;
+                    if (LocaleController.getInstance().formatterDay != null && LocaleController.getInstance().formatterYear != null) {
+                        date = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.getInstance().formatterYear.format(time), LocaleController.getInstance().formatterDay.format(time));
+                    } else {
+                        date = "" + message.date;
+                    }
                     TLRPC.User to_user = UserConfig.getCurrentUser();
                     if (to_user == null) {
                         if (users != null) {
@@ -314,7 +343,15 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
                 } else if (message.action instanceof TLRPC.TL_messageActionCreatedBroadcastList) {
                     messageText = LocaleController.formatString("YouCreatedBroadcastList", R.string.YouCreatedBroadcastList);
                 } else if (message.action instanceof TLRPC.TL_messageActionChannelCreate) {
-                    messageText = LocaleController.getString("ActionCreateChannel", R.string.ActionCreateChannel);
+                    if (isMegagroup()) {
+                        messageText = LocaleController.getString("ActionCreateMega", R.string.ActionCreateMega);
+                    } else {
+                        messageText = LocaleController.getString("ActionCreateChannel", R.string.ActionCreateChannel);
+                    }
+                } else if (message.action instanceof TLRPC.TL_messageActionChatMigrateTo) {
+                    messageText = LocaleController.getString("ActionMigrateFromGroup", R.string.ActionMigrateFromGroup);
+                } else if (message.action instanceof TLRPC.TL_messageActionChannelMigrateFrom) {
+                    messageText = LocaleController.getString("ActionMigrateFromGroup", R.string.ActionMigrateFromGroup);
                 }
             }
         } else if (!isMediaEmpty()) {
@@ -352,6 +389,9 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
         } else {
             messageText = message.message;
         }
+        if (messageText == null) {
+            messageText = "";
+        }
         if (generateLayout) {
             messageText = Emoji.replaceEmoji(messageText, textPaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
         }
@@ -359,7 +399,7 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
         if (message instanceof TLRPC.TL_message || message instanceof TLRPC.TL_messageForwarded_old2) {
             if (isMediaEmpty()) {
                 contentType = type = 0;
-                if (messageText.length() == 0) {
+                if (messageText == null || messageText.length() == 0) {
                     messageText = "Empty message";
                 }
             } else if (message.media instanceof TLRPC.TL_messageMediaPhoto) {
@@ -420,8 +460,10 @@ public MessageObject(TLRPC.Message message, AbstractMap<Integer, TLRPC.User> use
         int dateYear = rightNow.get(Calendar.YEAR);
         int dateMonth = rightNow.get(Calendar.MONTH);
         dateKey = String.format("%d_%02d_%02d", dateYear, dateMonth, dateDay);
-        if (contentType == 1 || contentType == 2 || contentType == 0) {
+        if (contentType == 1 || contentType == 2 || contentType == 0 || contentType == 8) {
             monthKey = String.format("%d_%02d", dateYear, dateMonth);
+        } else if (contentType == 9) {
+            //dateKey = "0_0_0";
         }
 
         if (messageOwner.message != null && messageOwner.id < 0 && messageOwner.message.length() > 6 && messageOwner.media instanceof TLRPC.TL_messageMediaVideo) {
@@ -512,18 +554,72 @@ public void generateThumbs(boolean update) {
         }
     }
 
-    public CharSequence replaceWithLink(CharSequence source, String param, TLRPC.User user) {
+    public CharSequence replaceWithLink(CharSequence source, String param, ArrayList<Integer> uids, AbstractMap<Integer, TLRPC.User> usersDict) {
         int start = TextUtils.indexOf(source, param);
         if (start >= 0) {
-            String name = UserObject.getUserName(user);
-            URLSpanNoUnderlineBold span = new URLSpanNoUnderlineBold("" + user.id);
+            SpannableStringBuilder names = new SpannableStringBuilder("");
+            for (int a = 0; a < uids.size(); a++) {
+                TLRPC.User user = null;
+                if (usersDict != null) {
+                    user = usersDict.get(uids.get(a));
+                }
+                if (user == null) {
+                    user = MessagesController.getInstance().getUser(uids.get(a));
+                }
+                if (user != null) {
+                    String name = UserObject.getUserName(user);
+                    start = names.length();
+                    if (names.length() != 0) {
+                        names.append(", ");
+                    }
+                    names.append(name);
+                    names.setSpan(new URLSpanNoUnderlineBold("" + user.id), start, start + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+                }
+            }
+            return TextUtils.replace(source, new String[]{param}, new CharSequence[]{names});
+        }
+        return source;
+    }
+
+    public CharSequence replaceWithLink(CharSequence source, String param, TLObject object) {
+        int start = TextUtils.indexOf(source, param);
+        if (start >= 0) {
+            String name;
+            int id;
+            if (object instanceof TLRPC.User) {
+                name = UserObject.getUserName((TLRPC.User) object);
+                id = ((TLRPC.User) object).id;
+            } else if (object instanceof TLRPC.Chat) {
+                name = ((TLRPC.Chat) object).title;
+                id = -((TLRPC.Chat) object).id;
+            } else {
+                name = "";
+                id = 0;
+            }
             SpannableStringBuilder builder = new SpannableStringBuilder(TextUtils.replace(source, new String[]{param}, new String[]{name}));
-            builder.setSpan(span, start, start + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+            builder.setSpan(new URLSpanNoUnderlineBold("" + id), start, start + name.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
             return builder;
         }
         return source;
     }
 
+    public String getExtension() {
+        String fileName = getFileName();
+        int idx = fileName.lastIndexOf(".");
+        String ext = null;
+        if (idx != -1) {
+            ext = fileName.substring(idx + 1);
+        }
+        if (ext == null || ext.length() == 0) {
+            ext = messageOwner.media.document.mime_type;
+        }
+        if (ext == null) {
+            ext = "";
+        }
+        ext = ext.toUpperCase();
+        return ext;
+    }
+
     public String getFileName() {
         if (messageOwner.media instanceof TLRPC.TL_messageMediaVideo) {
             return FileLoader.getAttachFileName(messageOwner.media.video);
@@ -623,8 +719,13 @@ public void generateLinkDescription() {
         if (messageOwner.media instanceof TLRPC.TL_messageMediaWebPage && messageOwner.media.webpage instanceof TLRPC.TL_webPage && messageOwner.media.webpage.description != null) {
             linkDescription = Spannable.Factory.getInstance().newSpannable(messageOwner.media.webpage.description);
             if (containsUrls(linkDescription)) {
-                Linkify.addLinks((Spannable) linkDescription, Linkify.WEB_URLS);
+                try {
+                    Linkify.addLinks((Spannable) linkDescription, Linkify.WEB_URLS);
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
             }
+            linkDescription = Emoji.replaceEmoji(linkDescription, textPaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
         }
     }
 
@@ -640,12 +741,12 @@ public void generateCaption() {
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 }
-                addUsernamesAndHashtags(caption);
+                addUsernamesAndHashtags(caption, true);
             }
         }
     }
 
-    private static void addUsernamesAndHashtags(CharSequence charSequence) {
+    private static void addUsernamesAndHashtags(CharSequence charSequence, boolean botCommands) {
         try {
             if (urlPattern == null) {
                 urlPattern = Pattern.compile("(^|\\s)/[a-zA-Z@\\d_]{1,255}|(^|\\s)@[a-zA-Z\\d_]{5,32}|(^|\\s)#[\\w\\.]+");
@@ -657,15 +758,29 @@ private static void addUsernamesAndHashtags(CharSequence charSequence) {
                 if (charSequence.charAt(start) != '@' && charSequence.charAt(start) != '#' && charSequence.charAt(start) != '/') {
                     start++;
                 }
-                URLSpanNoUnderline url = new URLSpanNoUnderline(charSequence.subSequence(start, end).toString());
-                ((Spannable) charSequence).setSpan(url, start, end, 0);
+                URLSpanNoUnderline url = null;
+                if (charSequence.charAt(start) == '/') {
+                    if (botCommands) {
+                        url = new URLSpanBotCommand(charSequence.subSequence(start, end).toString());
+                    }
+                } else {
+                    url = new URLSpanNoUnderline(charSequence.subSequence(start, end).toString());
+                }
+                if (url != null) {
+                    ((Spannable) charSequence).setSpan(url, start, end, 0);
+                }
             }
         } catch (Exception e) {
             FileLog.e("tmessages", e);
         }
     }
 
+
     public static void addLinks(CharSequence messageText) {
+        addLinks(messageText, true);
+    }
+
+    public static void addLinks(CharSequence messageText, boolean botCommands) {
         if (messageText instanceof Spannable && containsUrls(messageText)) {
             if (messageText.length() < 100) {
                 try {
@@ -680,7 +795,7 @@ public static void addLinks(CharSequence messageText) {
                     FileLog.e("tmessages", e);
                 }
             }
-            addUsernamesAndHashtags(messageText);
+            addUsernamesAndHashtags(messageText, botCommands);
         }
     }
 
@@ -728,11 +843,13 @@ private void generateLayout() {
                     spannable.setSpan(new TypefaceSpan(AndroidUtilities.getTypeface("fonts/rmedium.ttf")), entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                 } else if (entity instanceof TLRPC.TL_messageEntityItalic) {
                     spannable.setSpan(new TypefaceSpan(AndroidUtilities.getTypeface("fonts/ritalic.ttf")), entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                } else if (entity instanceof TLRPC.TL_messageEntityCode) {
+                } else if (entity instanceof TLRPC.TL_messageEntityCode || entity instanceof TLRPC.TL_messageEntityPre) {
                     spannable.setSpan(new TypefaceSpan(Typeface.MONOSPACE), entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                 } else if (!useManualParse) {
                     String url = messageOwner.message.substring(entity.offset, entity.offset + entity.length);
-                    if (entity instanceof TLRPC.TL_messageEntityBotCommand || entity instanceof TLRPC.TL_messageEntityHashtag || entity instanceof TLRPC.TL_messageEntityMention) {
+                    if (entity instanceof TLRPC.TL_messageEntityBotCommand) {
+                        spannable.setSpan(new URLSpanBotCommand(url), entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+                    } else if (entity instanceof TLRPC.TL_messageEntityHashtag || entity instanceof TLRPC.TL_messageEntityMention) {
                         spannable.setSpan(new URLSpanNoUnderline(url), entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                     } else if (entity instanceof TLRPC.TL_messageEntityEmail) {
                         spannable.setSpan(new URLSpanReplacement("mailto:" + url), entity.offset, entity.offset + entity.length, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
@@ -815,6 +932,14 @@ private void generateLayout() {
                     FileLog.e("tmessages", e);
                     continue;
                 }
+                if (a == blocksCount - 1) {
+                    currentBlockLinesCount = Math.max(currentBlockLinesCount, block.textLayout.getLineCount());
+                    try {
+                        textHeight = Math.max(textHeight, (int) (block.textYOffset + block.textLayout.getHeight()));
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                }
             }
 
             textLayoutBlocks.add(block);
@@ -849,7 +974,7 @@ private void generateLayout() {
 
             if (currentBlockLinesCount > 1) {
                 float textRealMaxWidth = 0, textRealMaxWidthWithLeft = 0, lineWidth, lineLeft;
-                for (int n = 0; n < currentBlockLinesCount; ++n) {
+                for (int n = 0; n < currentBlockLinesCount; n++) {
                     try {
                         lineWidth = block.textLayout.getLineWidth(n);
                     } catch (Exception e) {
@@ -903,23 +1028,23 @@ private void generateLayout() {
     }
 
     public boolean isOut() {
-        return (messageOwner.flags & TLRPC.MESSAGE_FLAG_OUT) != 0;
+        return messageOwner.out;
     }
 
     public boolean isOutOwner() {
-        return (messageOwner.flags & TLRPC.MESSAGE_FLAG_OUT) != 0 && messageOwner.from_id > 0;
+        return messageOwner.out && messageOwner.from_id > 0;
     }
 
     public boolean isUnread() {
-        return (messageOwner.flags & TLRPC.MESSAGE_FLAG_UNREAD) != 0;
+        return messageOwner.unread;
     }
 
     public boolean isContentUnread() {
-        return (messageOwner.flags & TLRPC.MESSAGE_FLAG_CONTENT_UNREAD) != 0;
+        return messageOwner.media_unread;
     }
 
     public void setIsRead() {
-        messageOwner.flags &= ~TLRPC.MESSAGE_FLAG_UNREAD;
+        messageOwner.unread = false;
     }
 
     public int getUnradFlags() {
@@ -928,17 +1053,17 @@ public int getUnradFlags() {
 
     public static int getUnreadFlags(TLRPC.Message message) {
         int flags = 0;
-        if ((message.flags & TLRPC.MESSAGE_FLAG_UNREAD) == 0) {
+        if (!message.unread) {
             flags |= 1;
         }
-        if ((message.flags & TLRPC.MESSAGE_FLAG_CONTENT_UNREAD) == 0) {
+        if (!message.media_unread) {
             flags |= 2;
         }
         return flags;
     }
 
     public void setContentIsRead() {
-        messageOwner.flags &= ~TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
+        messageOwner.media_unread = false;
     }
 
     public int getId() {
@@ -946,66 +1071,73 @@ public int getId() {
     }
 
     public boolean isSecretPhoto() {
-        return messageOwner instanceof TLRPC.TL_message_secret && messageOwner.media instanceof TLRPC.TL_messageMediaPhoto && messageOwner.ttl != 0 && messageOwner.ttl <= 60;
+        return messageOwner instanceof TLRPC.TL_message_secret && messageOwner.media instanceof TLRPC.TL_messageMediaPhoto && messageOwner.ttl > 0 && messageOwner.ttl <= 60;
     }
 
     public boolean isSecretMedia() {
         return messageOwner instanceof TLRPC.TL_message_secret &&
-                (messageOwner.media instanceof TLRPC.TL_messageMediaPhoto && messageOwner.ttl != 0 && messageOwner.ttl <= 60 ||
+                (messageOwner.media instanceof TLRPC.TL_messageMediaPhoto && messageOwner.ttl > 0 && messageOwner.ttl <= 60 ||
                         messageOwner.media instanceof TLRPC.TL_messageMediaAudio ||
                         messageOwner.media instanceof TLRPC.TL_messageMediaVideo);
     }
 
     public static void setUnreadFlags(TLRPC.Message message, int flag) {
-        if ((flag & 1) == 0) {
-            message.flags |= TLRPC.MESSAGE_FLAG_UNREAD;
-        } else {
-            message.flags &= ~TLRPC.MESSAGE_FLAG_UNREAD;
-        }
-        if ((flag & 2) == 0) {
-            message.flags |= TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
-        } else {
-            message.flags &= ~TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
-        }
+        message.unread = (flag & 1) == 0;
+        message.media_unread = (flag & 2) == 0;
     }
 
     public static boolean isUnread(TLRPC.Message message) {
-        return (message.flags & TLRPC.MESSAGE_FLAG_UNREAD) != 0;
+        return message.unread;
     }
 
     public static boolean isContentUnread(TLRPC.Message message) {
-        return (message.flags & TLRPC.MESSAGE_FLAG_CONTENT_UNREAD) != 0;
+        return message.media_unread;
     }
 
     public boolean isImportant() {
         return isImportant(messageOwner);
     }
 
+    public boolean isMegagroup() {
+        return isMegagroup(messageOwner);
+    }
+
     public static boolean isImportant(TLRPC.Message message) {
-        return message.to_id.channel_id != 0 && (message.from_id <= 0 || (message.flags & TLRPC.MESSAGE_FLAG_MENTION) != 0 || (message.flags & TLRPC.MESSAGE_FLAG_OUT) != 0 || (message.flags & TLRPC.MESSAGE_FLAG_HAS_FROM_ID) == 0);
+        if (isMegagroup(message)) {
+            return message.from_id <= 0;
+        }
+        return message.to_id.channel_id != 0 && (message.from_id <= 0 || message.mentioned || message.out || (message.flags & TLRPC.MESSAGE_FLAG_HAS_FROM_ID) == 0);
+    }
+
+    public static boolean isMegagroup(TLRPC.Message message) {
+        return (message.flags & TLRPC.MESSAGE_FLAG_MEGAGROUP) != 0;
     }
 
     public static boolean isOut(TLRPC.Message message) {
-        return (message.flags & TLRPC.MESSAGE_FLAG_OUT) != 0;
+        return message.out;
     }
 
     public long getDialogId() {
-        if (messageOwner.dialog_id == 0) {
-            if (messageOwner.to_id.chat_id != 0) {
-                if (messageOwner.to_id.chat_id < 0) {
-                    messageOwner.dialog_id = AndroidUtilities.makeBroadcastId(messageOwner.to_id.chat_id);
+        return getDialogId(messageOwner);
+    }
+
+    public static long getDialogId(TLRPC.Message message) {
+        if (message.dialog_id == 0 && message.to_id != null) {
+            if (message.to_id.chat_id != 0) {
+                if (message.to_id.chat_id < 0) {
+                    message.dialog_id = AndroidUtilities.makeBroadcastId(message.to_id.chat_id);
                 } else {
-                    messageOwner.dialog_id = -messageOwner.to_id.chat_id;
+                    message.dialog_id = -message.to_id.chat_id;
                 }
-            } else if (messageOwner.to_id.channel_id != 0) {
-                messageOwner.dialog_id = -messageOwner.to_id.channel_id;
-            } else if (isOut()) {
-                messageOwner.dialog_id = messageOwner.to_id.user_id;
+            } else if (message.to_id.channel_id != 0) {
+                message.dialog_id = -message.to_id.channel_id;
+            } else if (isOut(message)) {
+                message.dialog_id = message.to_id.user_id;
             } else {
-                messageOwner.dialog_id = messageOwner.from_id;
+                message.dialog_id = message.from_id;
             }
         }
-        return messageOwner.dialog_id;
+        return message.dialog_id;
     }
 
     public boolean isSending() {
@@ -1237,6 +1369,9 @@ public boolean canDeleteMessage(TLRPC.Chat chat) {
     }
 
     public static boolean canDeleteMessage(TLRPC.Message message, TLRPC.Chat chat) {
+        if (message.id < 0) {
+            return true;
+        }
         if (chat == null && message.to_id.channel_id != 0) {
             chat = MessagesController.getInstance().getChat(message.to_id.channel_id);
         }
@@ -1244,13 +1379,13 @@ public static boolean canDeleteMessage(TLRPC.Message message, TLRPC.Chat chat) {
             if (message.id == 1) {
                 return false;
             }
-            if ((chat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0) {
+            if (chat.creator) {
                 return true;
-            } else if ((chat.flags & TLRPC.CHAT_FLAG_USER_IS_EDITOR) != 0) {
+            } else if (chat.editor) {
                 if (isOut(message) || message.from_id > 0) {
                     return true;
                 }
-            } else if ((chat.flags & TLRPC.CHAT_FLAG_USER_IS_MODERATOR) != 0) {
+            } else if (chat.moderator) {
                 if (message.from_id > 0) {
                     return true;
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MessagesController.java b/TMessagesProj/src/main/java/org/telegram/messenger/MessagesController.java
index 0e66ce9b6..2a8e3a3a6 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MessagesController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MessagesController.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -11,6 +11,7 @@
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
+import android.content.Context;
 import android.content.DialogInterface;
 import android.content.SharedPreferences;
 import android.content.pm.PackageInfo;
@@ -21,6 +22,7 @@
 import android.util.SparseIntArray;
 import android.widget.Toast;
 
+import org.telegram.SQLite.SQLiteCursor;
 import org.telegram.messenger.query.BotQuery;
 import org.telegram.messenger.query.StickersQuery;
 import org.telegram.tgnet.ConnectionsManager;
@@ -37,6 +39,7 @@
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Semaphore;
 
@@ -47,14 +50,15 @@
     private ConcurrentHashMap<Integer, TLRPC.User> users = new ConcurrentHashMap<>(100, 1.0f, 2);
     private ConcurrentHashMap<String, TLRPC.User> usersByUsernames = new ConcurrentHashMap<>(100, 1.0f, 2);
 
+    private ArrayList<Integer> joiningToChannels = new ArrayList<>();
+
     private HashMap<Integer, TLRPC.ExportedChatInvite> exportedChats = new HashMap<>();
 
     public ArrayList<TLRPC.Dialog> dialogs = new ArrayList<>();
     public ArrayList<TLRPC.Dialog> dialogsServerOnly = new ArrayList<>();
     public ArrayList<TLRPC.Dialog> dialogsGroupsOnly = new ArrayList<>();
-    public int currentChannelDialogsCount;
-    public int currentDialogsCount;
     public int nextDialogsCacheOffset;
+    public ConcurrentHashMap<Long, Integer> dialogs_read_inbox_max = new ConcurrentHashMap<>(100, 1.0f, 2);
     public ConcurrentHashMap<Long, TLRPC.Dialog> dialogs_dict = new ConcurrentHashMap<>(100, 1.0f, 2);
     public HashMap<Long, MessageObject> dialogMessage = new HashMap<>();
     public HashMap<Integer, MessageObject> dialogMessagesByIds = new HashMap<>();
@@ -79,9 +83,6 @@
     private HashMap<Integer, Long> updatesStartWaitTimeChannels = new HashMap<>();
     private HashMap<Integer, Integer> channelsPts = new HashMap<>();
     private HashMap<Integer, Boolean> gettingDifferenceChannels = new HashMap<>();
-    public boolean loadingChannels = false;
-    public int totalChannelsCount = 0;
-    public boolean channelsEndReached = false;
 
     private ArrayList<TLRPC.Updates> updatesQueueSeq = new ArrayList<>();
     private ArrayList<TLRPC.Updates> updatesQueuePts = new ArrayList<>();
@@ -92,6 +93,8 @@
     private ArrayList<Integer> loadingFullUsers = new ArrayList<>();
     private ArrayList<Integer> loadedFullUsers = new ArrayList<>();
     private ArrayList<Integer> loadingFullChats = new ArrayList<>();
+    private ArrayList<Integer> loadingFullParticipants = new ArrayList<>();
+    private ArrayList<Integer> loadedFullParticipants = new ArrayList<>();
     private ArrayList<Integer> loadedFullChats = new ArrayList<>();
 
     private HashMap<Long, ArrayList<Integer>> reloadingMessages = new HashMap<>();
@@ -102,9 +105,9 @@
     private Runnable currentDeleteTaskRunnable = null;
 
     public boolean loadingDialogs = false;
+    private boolean migratingDialogs = false;
     public boolean dialogsEndReached = false;
     public boolean gettingDifference = false;
-    public boolean gettingDifferenceAgain = false;
     public boolean updatingState = false;
     public boolean firstGettingTask = false;
     public boolean registeringForPush = false;
@@ -119,6 +122,8 @@
     public int fontSize = AndroidUtilities.dp(16);
     public int maxGroupCount = 200;
     public int maxBroadcastCount = 100;
+    public int maxMegagroupCount = 1000;
+    public int minGroupConvertSize = 200;
     public int groupBigSize;
     private ArrayList<TLRPC.TL_disabledFeature> disabledFeatures = new ArrayList<>();
 
@@ -144,6 +149,7 @@
     public static final int UPDATE_MASK_NEW_MESSAGE = 2048;
     public static final int UPDATE_MASK_SEND_STATE = 4096;
     public static final int UPDATE_MASK_CHANNEL = 8192;
+    public static final int UPDATE_MASK_CHAT_ADMINS = 16384;
     public static final int UPDATE_MASK_ALL = UPDATE_MASK_AVATAR | UPDATE_MASK_STATUS | UPDATE_MASK_NAME | UPDATE_MASK_CHAT_AVATAR | UPDATE_MASK_CHAT_NAME | UPDATE_MASK_CHAT_MEMBERS | UPDATE_MASK_USER_PRINT | UPDATE_MASK_USER_PHONE | UPDATE_MASK_READ_DIALOG_MESSAGE | UPDATE_MASK_PHONE;
 
     public static class PrintingUser {
@@ -181,7 +187,7 @@ public MessagesController() {
 
         preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
         maxGroupCount = preferences.getInt("maxGroupCount", 200);
-        maxBroadcastCount = preferences.getInt("maxBroadcastCount", 100);
+        maxMegagroupCount = preferences.getInt("maxMegagroupCount", 1000);
         groupBigSize = preferences.getInt("groupBigSize", 10);
         fontSize = preferences.getInt("fons_size", AndroidUtilities.isTablet() ? 18 : 16);
         String disabledFeaturesString = preferences.getString("disabledFeatures", null);
@@ -208,7 +214,8 @@ public void updateConfig(final TLRPC.TL_config config) {
         AndroidUtilities.runOnUIThread(new Runnable() { //TODO use new config params
             @Override
             public void run() {
-                maxBroadcastCount = config.broadcast_size_max;
+                //maxBroadcastCount = config.broadcast_size_max;
+                maxMegagroupCount = config.megagroup_size_max;
                 maxGroupCount = config.chat_size_max;
                 groupBigSize = config.chat_big_size;
                 disabledFeatures = config.disabled_features;
@@ -216,7 +223,8 @@ public void run() {
                 SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
                 SharedPreferences.Editor editor = preferences.edit();
                 editor.putInt("maxGroupCount", maxGroupCount);
-                editor.putInt("maxBroadcastCount", maxBroadcastCount);
+                //editor.putInt("maxBroadcastCount", maxBroadcastCount);
+                editor.putInt("maxMegagroupCount", maxMegagroupCount);
                 editor.putInt("groupBigSize", groupBigSize);
                 try {
                     SerializedData data = new SerializedData();
@@ -415,10 +423,10 @@ public void run() {
             }
         } else if (id == NotificationCenter.messageReceivedByServer) {
             Integer msgId = (Integer) args[0];
+            Integer newMsgId = (Integer) args[1];
             Long did = (Long) args[3];
             MessageObject obj = dialogMessage.get(did);
             if (obj != null && obj.getId() == msgId) {
-                Integer newMsgId = (Integer) args[1];
                 obj.messageOwner.id = newMsgId;
                 obj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SENT;
                 TLRPC.Dialog dialog = dialogs_dict.get(did);
@@ -429,6 +437,10 @@ public void run() {
                 }
                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
             }
+            obj = dialogMessagesByIds.remove(msgId);
+            if (obj != null) {
+                dialogMessagesByIds.put(newMsgId, obj);
+            }
         }
     }
 
@@ -441,8 +453,10 @@ public void cleanUp() {
         StickersQuery.cleanup();
 
         dialogs_dict.clear();
+        dialogs_read_inbox_max.clear();
         exportedChats.clear();
         dialogs.clear();
+        joiningToChannels.clear();
         channelViewsToSend.clear();
         channelViewsToReload.clear();
         dialogsServerOnly.clear();
@@ -456,9 +470,7 @@ public void cleanUp() {
         printingStringsTypes.clear();
         onlinePrivacy.clear();
         lastPrintingStringCount = 0;
-        currentChannelDialogsCount = 0;
         nextDialogsCacheOffset = 0;
-        currentDialogsCount = 0;
         updatesQueueSeq.clear();
         updatesQueuePts.clear();
         updatesQueueQts.clear();
@@ -468,6 +480,8 @@ public void cleanUp() {
         loadedFullUsers.clear();
         reloadingMessages.clear();
         loadingFullChats.clear();
+        loadingFullParticipants.clear();
+        loadedFullParticipants.clear();
         loadedFullChats.clear();
 
         updatesStartWaitTimeSeq = 0;
@@ -479,7 +493,6 @@ public void cleanUp() {
         loadingDialogs = false;
         dialogsEndReached = false;
         gettingDifference = false;
-        gettingDifferenceAgain = false;
         loadingBlockedUsers = false;
         firstGettingTask = false;
         updatingState = false;
@@ -493,6 +506,7 @@ public void cleanUp() {
         Utilities.stageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
+                ConnectionsManager.getInstance().setIsUpdating(false);
                 updatesQueueChannels.clear();
                 updatesStartWaitTimeChannels.clear();
                 gettingDifferenceChannels.clear();
@@ -502,10 +516,6 @@ public void run() {
             }
         });
 
-        loadingChannels = false;
-        totalChannelsCount = 0;
-        channelsEndReached = false;
-
         if (currentDeleteTaskRunnable != null) {
             Utilities.stageQueue.cancelRunnable(currentDeleteTaskRunnable);
             currentDeleteTaskRunnable = null;
@@ -682,7 +692,7 @@ public void loadFullChat(final int chat_id, final int classGuid, boolean force)
         }
         loadingFullChats.add(chat_id);
         TLObject request;
-        TLRPC.Chat chat = getChat(chat_id);
+        final TLRPC.Chat chat = getChat(chat_id);
         if (ChatObject.isChannel(chat_id)) {
             TLRPC.TL_channels_getFullChannel req = new TLRPC.TL_channels_getFullChannel();
             req.channel = getInputChannel(chat_id);
@@ -697,11 +707,15 @@ public void loadFullChat(final int chat_id, final int classGuid, boolean force)
             public void run(TLObject response, final TLRPC.TL_error error) {
                 if (error == null) {
                     final TLRPC.TL_messages_chatFull res = (TLRPC.TL_messages_chatFull) response;
+                    if (chat != null && chat.megagroup) {
+                        res.full_chat.unread_important_count = Math.max(res.full_chat.unread_important_count, res.full_chat.unread_count);
+                    }
                     MessagesStorage.getInstance().putUsersAndChats(res.users, res.chats, true, true);
                     MessagesStorage.getInstance().updateChatInfo(res.full_chat, false);
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
+                            applyDialogNotificationsSettings(-chat_id, res.full_chat.notify_settings);
                             for (int a = 0; a < res.full_chat.bot_info.size(); a++) {
                                 TLRPC.BotInfo botInfo = res.full_chat.bot_info.get(a);
                                 BotQuery.putBotInfo(botInfo);
@@ -716,7 +730,7 @@ public void run() {
 
                             putUsers(res.users, false);
                             putChats(res.chats, false);
-                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, res.full_chat, classGuid);
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, res.full_chat, classGuid, false);
                         }
                     });
                 } else {
@@ -752,6 +766,7 @@ public void run(final TLObject response, TLRPC.TL_error error) {
                         @Override
                         public void run() {
                             TLRPC.TL_userFull userFull = (TLRPC.TL_userFull) response;
+                            applyDialogNotificationsSettings(user.id, userFull.notify_settings);
                             if (userFull.bot_info instanceof TLRPC.TL_botInfo) {
                                 BotQuery.putBotInfo(userFull.bot_info);
                             }
@@ -762,7 +777,7 @@ public void run() {
                             users.add(userFull.user);
                             putUsers(users, false);
                             MessagesStorage.getInstance().putUsersAndChats(users, null, false, true);
-                            if (!names.equals(userFull.user.first_name + userFull.user.last_name + userFull.user.username)) {
+                            if (names != null && !names.equals(userFull.user.first_name + userFull.user.last_name + userFull.user.username)) {
                                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.updateInterfaces, UPDATE_MASK_NAME);
                             }
                             if (userFull.bot_info instanceof TLRPC.TL_botInfo) {
@@ -784,9 +799,12 @@ public void run() {
     }
 
     private void reloadMessages(final ArrayList<Integer> mids, final long dialog_id) {
+        if (mids.isEmpty()) {
+            return;
+        }
         TLObject request;
         final ArrayList<Integer> result = new ArrayList<>();
-        TLRPC.Chat chat = ChatObject.getChatByDialog(dialog_id);
+        final TLRPC.Chat chat = ChatObject.getChatByDialog(dialog_id);
         if (ChatObject.isChannel(chat)) {
             TLRPC.TL_channels_getMessages req = new TLRPC.TL_channels_getMessages();
             req.channel = getInputChannel(chat);
@@ -818,19 +836,32 @@ private void reloadMessages(final ArrayList<Integer> mids, final long dialog_id)
             public void run(TLObject response, TLRPC.TL_error error) {
                 if (error == null) {
                     TLRPC.messages_Messages messagesRes = (TLRPC.messages_Messages) response;
-                    ImageLoader.saveMessagesThumbs(messagesRes.messages);
-                    MessagesStorage.getInstance().putMessages(messagesRes, dialog_id, -1, 0, 0, false);
+
+                    final HashMap<Integer, TLRPC.User> usersLocal = new HashMap<>();
+                    for (int a = 0; a < messagesRes.users.size(); a++) {
+                        TLRPC.User u = messagesRes.users.get(a);
+                        usersLocal.put(u.id, u);
+                    }
+                    final HashMap<Integer, TLRPC.Chat> chatsLocal = new HashMap<>();
+                    for (int a = 0; a < messagesRes.chats.size(); a++) {
+                        TLRPC.Chat c = messagesRes.chats.get(a);
+                        chatsLocal.put(c.id, c);
+                    }
 
                     final ArrayList<MessageObject> objects = new ArrayList<>();
                     ArrayList<Integer> messagesToReload = null;
-                    for (TLRPC.Message message : messagesRes.messages) {
-                        message.dialog_id = dialog_id;
-                        final HashMap<Integer, TLRPC.User> usersLocal = new HashMap<>();
-                        for (TLRPC.User u : messagesRes.users) {
-                            usersLocal.put(u.id, u);
+                    for (int a = 0; a < messagesRes.messages.size(); a++) {
+                        TLRPC.Message message = messagesRes.messages.get(a);
+                        if (chat != null && chat.megagroup) {
+                            message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
                         }
-                        objects.add(new MessageObject(message, usersLocal, true));
+                        message.dialog_id = dialog_id;
+                        objects.add(new MessageObject(message, usersLocal, chatsLocal, true));
                     }
+
+                    ImageLoader.saveMessagesThumbs(messagesRes.messages);
+                    MessagesStorage.getInstance().putMessages(messagesRes, dialog_id, -1, 0, 0, false);
+
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
@@ -871,7 +902,7 @@ protected void processNewChannelDifferenceParams(int pts, int pts_count, int cha
                 if (gettingDifferenceChannel == null) {
                     gettingDifferenceChannel = false;
                 }
-                if (gettingDifferenceChannel || updatesStartWaitTime == null || updatesStartWaitTime + 1500 > System.currentTimeMillis()) {
+                if (gettingDifferenceChannel || updatesStartWaitTime == null || Math.abs(System.currentTimeMillis() - updatesStartWaitTime) <= 1500) {
                     FileLog.e("tmessages", "ADD CHANNEL UPDATE TO QUEUE pts = " + pts + " pts_count = " + pts_count);
                     if (updatesStartWaitTime == null) {
                         updatesStartWaitTimeChannels.put(channelId, System.currentTimeMillis());
@@ -901,7 +932,7 @@ protected void processNewDifferenceParams(int seq, int pts, int date, int pts_co
                 MessagesStorage.lastPtsValue = pts;
                 MessagesStorage.getInstance().saveDiffParams(MessagesStorage.lastSeqValue, MessagesStorage.lastPtsValue, MessagesStorage.lastDateValue, MessagesStorage.lastQtsValue);
             } else if (MessagesStorage.lastPtsValue != pts) {
-                if (gettingDifference || updatesStartWaitTimePts == 0 || updatesStartWaitTimePts + 1500 > System.currentTimeMillis()) {
+                if (gettingDifference || updatesStartWaitTimePts == 0 || Math.abs(System.currentTimeMillis() - updatesStartWaitTimePts) <= 1500) {
                     FileLog.e("tmessages", "ADD UPDATE TO QUEUE pts = " + pts + " pts_count = " + pts_count);
                     if (updatesStartWaitTimePts == 0) {
                         updatesStartWaitTimePts = System.currentTimeMillis();
@@ -924,7 +955,7 @@ protected void processNewDifferenceParams(int seq, int pts, int date, int pts_co
                 }
                 MessagesStorage.getInstance().saveDiffParams(MessagesStorage.lastSeqValue, MessagesStorage.lastPtsValue, MessagesStorage.lastDateValue, MessagesStorage.lastQtsValue);
             } else if (MessagesStorage.lastSeqValue != seq) {
-                if (gettingDifference || updatesStartWaitTimeSeq == 0 || updatesStartWaitTimeSeq + 1500 > System.currentTimeMillis()) {
+                if (gettingDifference || updatesStartWaitTimeSeq == 0 || Math.abs(System.currentTimeMillis() - updatesStartWaitTimeSeq) <= 1500) {
                     FileLog.e("tmessages", "ADD UPDATE TO QUEUE seq = " + seq);
                     if (updatesStartWaitTimeSeq == 0) {
                         updatesStartWaitTimeSeq = System.currentTimeMillis();
@@ -1226,7 +1257,7 @@ public void uploadAndApplyUserAvatar(TLRPC.PhotoSize bigPhoto) {
     }
 
     public void deleteMessages(ArrayList<Integer> messages, ArrayList<Long> randoms, TLRPC.EncryptedChat encryptedChat, final int channelId) {
-        if (messages == null) {
+        if (messages == null || messages.isEmpty()) {
             return;
         }
         if (channelId == 0) {
@@ -1287,30 +1318,43 @@ public void run(TLObject response, TLRPC.TL_error error) {
         }
     }
 
-    public void deleteDialog(final long did, int offset, final boolean onlyHistory) {
+    public void deleteDialog(final long did, final int onlyHistory) {
+        deleteDialog(did, true, onlyHistory, 0);
+    }
+
+    private void deleteDialog(final long did, final boolean first, final int onlyHistory, final int max_id) {
         int lower_part = (int) did;
         int high_id = (int) (did >> 32);
+        int max_id_delete = max_id;
 
-        if (offset == 0) {
+        if (onlyHistory == 2) {
+            MessagesStorage.getInstance().deleteDialog(did, onlyHistory);
+            return;
+        }
+
+        if (first) {
             TLRPC.Dialog dialog = dialogs_dict.get(did);
             if (dialog != null) {
-                if (!onlyHistory) {
+                if (max_id_delete == 0) {
+                    max_id_delete = Math.max(0, dialog.top_message);
+                }
+                if (onlyHistory == 0) {
                     dialogs.remove(dialog);
                     if (dialogsServerOnly.remove(dialog)) {
-                        if (dialog instanceof TLRPC.TL_dialog) {
-                            currentDialogsCount--;
-                        } else if (dialog instanceof TLRPC.TL_dialogChannel) {
-                            currentChannelDialogsCount--;
+                        if (dialog instanceof TLRPC.TL_dialogChannel) {
                             Utilities.stageQueue.postRunnable(new Runnable() {
                                 @Override
                                 public void run() {
                                     channelsPts.remove(-(int) did);
+                                    shortPollChannels.delete(-(int) did);
+                                    needShortPollChannels.delete(-(int) did);
                                 }
                             });
                         }
                     }
                     dialogsGroupsOnly.remove(dialog);
                     dialogs_dict.remove(did);
+                    dialogs_read_inbox_max.remove(did);
                     nextDialogsCacheOffset--;
                 } else {
                     dialog.unread_count = 0;
@@ -1327,10 +1371,7 @@ public void run() {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            NotificationsController.getInstance().processReadMessages(null, did, 0, Integer.MAX_VALUE, false);
-                            HashMap<Long, Integer> dialogsToUpdate = new HashMap<>();
-                            dialogsToUpdate.put(did, 0);
-                            NotificationsController.getInstance().processDialogsUpdateRead(dialogsToUpdate);
+                            NotificationsController.getInstance().removeNotificationsForDialog(did);
                         }
                     });
                 }
@@ -1349,22 +1390,23 @@ public void run() {
                 return;
             }
             TLRPC.TL_messages_deleteHistory req = new TLRPC.TL_messages_deleteHistory();
-            req.offset = offset;
             req.peer = peer;
+            req.max_id = max_id_delete;
+            final int max_id_delete_final = max_id_delete;
             ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
                 @Override
                 public void run(TLObject response, TLRPC.TL_error error) {
                     if (error == null) {
                         TLRPC.TL_messages_affectedHistory res = (TLRPC.TL_messages_affectedHistory) response;
                         if (res.offset > 0) {
-                            deleteDialog(did, res.offset, onlyHistory);
+                            deleteDialog(did, false, onlyHistory, max_id_delete_final);
                         }
                         processNewDifferenceParams(-1, res.pts, -1, res.pts_count);
                     }
                 }
-            });
+            }, ConnectionsManager.RequestFlagInvokeAfter);
         } else {
-            if (onlyHistory) {
+            if (onlyHistory == 1) {
                 SecretChatHelper.getInstance().sendClearHistoryMessage(getEncryptedChat(high_id), null);
             } else {
                 SecretChatHelper.getInstance().declineSecretChat(high_id);
@@ -1372,12 +1414,43 @@ public void run(TLObject response, TLRPC.TL_error error) {
         }
     }
 
+    public void loadChannelParticipants(final Integer chat_id) {
+        if (loadingFullParticipants.contains(chat_id) || loadedFullParticipants.contains(chat_id)) {
+            return;
+        }
+        loadingFullParticipants.add(chat_id);
+
+        final TLRPC.TL_channels_getParticipants req = new TLRPC.TL_channels_getParticipants();
+        req.channel = MessagesController.getInputChannel(chat_id);
+        req.filter = new TLRPC.TL_channelParticipantsRecent();
+        req.offset = 0;
+        req.limit = 32;
+        ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (error == null) {
+                            TLRPC.TL_channels_channelParticipants res = (TLRPC.TL_channels_channelParticipants) response;
+                            putUsers(res.users, false);
+                            MessagesStorage.getInstance().putUsersAndChats(res.users, null, true, true);
+                            MessagesStorage.getInstance().updateChannelUsers(chat_id, res.participants);
+                            loadedFullParticipants.add(chat_id);
+                        }
+                        loadingFullParticipants.remove(chat_id);
+                    }
+                });
+            }
+        });
+    }
+
     public void loadChatInfo(final int chat_id, Semaphore semaphore, boolean force) {
-        MessagesStorage.getInstance().loadChatInfo(chat_id, semaphore, force);
+        MessagesStorage.getInstance().loadChatInfo(chat_id, semaphore, force, false);
     }
 
-    public void processChatInfo(int chat_id, final TLRPC.ChatFull info, final ArrayList<TLRPC.User> usersArr, final boolean fromCache, boolean force) {
-        if (fromCache && chat_id > 0) {
+    public void processChatInfo(int chat_id, final TLRPC.ChatFull info, final ArrayList<TLRPC.User> usersArr, final boolean fromCache, boolean force, final boolean byChannelUsers) {
+        if (fromCache && chat_id > 0 && !byChannelUsers) {
             loadFullChat(chat_id, 0, force);
         }
         if (info != null) {
@@ -1385,7 +1458,7 @@ public void processChatInfo(int chat_id, final TLRPC.ChatFull info, final ArrayL
                 @Override
                 public void run() {
                     putUsers(usersArr, fromCache);
-                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info);
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info, 0, byChannelUsers);
                 }
             });
         }
@@ -1398,7 +1471,7 @@ public void updateTimerProc() {
 
         if (UserConfig.isClientActivated()) {
             if (ConnectionsManager.getInstance().getPauseTime() == 0 && ApplicationLoader.isScreenOn && !ApplicationLoader.mainInterfacePaused) {
-                if (statusSettingState != 1 && (lastStatusUpdateTime == 0 || lastStatusUpdateTime <= System.currentTimeMillis() - 55000 || offlineSent)) {
+                if (statusSettingState != 1 && (lastStatusUpdateTime == 0 || Math.abs(System.currentTimeMillis() - lastStatusUpdateTime) >= 55000 || offlineSent)) {
                     statusSettingState = 1;
 
                     if (statusRequest != 0) {
@@ -1423,7 +1496,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                         }
                     });
                 }
-            } else if (statusSettingState != 2 && !offlineSent && ConnectionsManager.getInstance().getPauseTime() <= System.currentTimeMillis() - 2000) {
+            } else if (statusSettingState != 2 && !offlineSent && Math.abs(System.currentTimeMillis() - ConnectionsManager.getInstance().getPauseTime()) >= 2000) {
                 statusSettingState = 2;
                 if (statusRequest != 0) {
                     ConnectionsManager.getInstance().cancelRequest(statusRequest, true);
@@ -1464,7 +1537,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                 }
             }
         }
-        if ((channelViewsToSend.size() != 0 || channelViewsToReload.size() != 0) && lastViewsCheckTime <= System.currentTimeMillis() - 5000) {
+        if ((channelViewsToSend.size() != 0 || channelViewsToReload.size() != 0) && Math.abs(System.currentTimeMillis() - lastViewsCheckTime) >= 5000) {
             lastViewsCheckTime = System.currentTimeMillis();
             for (int b = 0; b < 2; b++) {
                 SparseArray<ArrayList<Integer>> array = b == 0 ? channelViewsToSend : channelViewsToReload;
@@ -1537,7 +1610,7 @@ public void run() {
                 int timeout = shortPollChannels.get(key);
                 if (timeout < System.currentTimeMillis() / 1000) {
                     shortPollChannels.delete(key);
-                    if (needShortPollChannels.indexOfKey(key) > 0) {
+                    if (needShortPollChannels.indexOfKey(key) >= 0) {
                         getChannelDifference(key);
                     }
                 }
@@ -1659,10 +1732,14 @@ private void updatePrintingStrings() {
                     }
                 }
                 if (label.length() != 0) {
-                    if (arr.size() > 2) {
-                        newPrintingStrings.put(key, String.format("%s %s", label, LocaleController.formatPluralString("AndMoreTyping", arr.size() - 2)));
+                    if (count == 1) {
+                        newPrintingStrings.put(key, String.format("%s %s", label, LocaleController.getString("IsTyping", R.string.IsTyping)));
                     } else {
-                        newPrintingStrings.put(key, String.format("%s %s", label, LocaleController.getString("AreTyping", R.string.AreTyping)));
+                        if (arr.size() > 2) {
+                            newPrintingStrings.put(key, String.format("%s %s", label, LocaleController.formatPluralString("AndMoreTyping", arr.size() - 2)));
+                        } else {
+                            newPrintingStrings.put(key, String.format("%s %s", label, LocaleController.getString("AreTyping", R.string.AreTyping)));
+                        }
                     }
                     newPrintingStringsTypes.put(key, 0);
                 }
@@ -1708,7 +1785,13 @@ public void sendTyping(final long dialog_id, final int action, int classGuid) {
 
             TLRPC.TL_messages_setTyping req = new TLRPC.TL_messages_setTyping();
             req.peer = getInputPeer(lower_part);
-            if (req.peer == null || req.peer instanceof TLRPC.TL_inputPeerChannel) {
+            if (req.peer instanceof TLRPC.TL_inputPeerChannel) {
+                TLRPC.Chat chat = MessagesController.getInstance().getChat(req.peer.channel_id);
+                if (chat == null || !chat.megagroup) {
+                    return;
+                }
+            }
+            if (req.peer == null) {
                 return;
             }
             if (action == 0) {
@@ -1775,10 +1858,14 @@ public void run() {
         }
     }
 
-    public void loadMessages(final long dialog_id, final int count, final int max_id, boolean fromCache, int midDate, final int classGuid, final int load_type, final int last_message_id, final int important) {
+    public void loadMessages(final long dialog_id, final int count, final int max_id, boolean fromCache, int midDate, final int classGuid, final int load_type, final int last_message_id, final int important, final int loadIndex) {
+        loadMessages(dialog_id, count, max_id, fromCache, midDate, classGuid, load_type, last_message_id, important, loadIndex, 0, 0, 0, false);
+    }
+
+    public void loadMessages(final long dialog_id, final int count, final int max_id, boolean fromCache, int midDate, final int classGuid, final int load_type, final int last_message_id, final int important, final int loadIndex, final int first_unread, final int unread_count, final int last_date, final boolean queryFromServer) {
         int lower_part = (int) dialog_id;
         if (fromCache || lower_part == 0) {
-            MessagesStorage.getInstance().getMessages(dialog_id, count, max_id, midDate, classGuid, load_type, important);
+            MessagesStorage.getInstance().getMessages(dialog_id, count, max_id, midDate, classGuid, load_type, important, loadIndex);
         } else {
             TLObject request;
             if (important == 2) {
@@ -1788,6 +1875,8 @@ public void loadMessages(final long dialog_id, final int count, final int max_id
                     req.add_offset = -count / 2;
                 } else if (load_type == 1) {
                     req.add_offset = -count - 1;
+                } else if (load_type == 2 && max_id != 0) {
+                    req.add_offset = -count + 6;
                 } else {
                     if (max_id != 0) {
                         req.add_offset = -1;
@@ -1804,6 +1893,8 @@ public void loadMessages(final long dialog_id, final int count, final int max_id
                     req.add_offset = -count / 2;
                 } else if (load_type == 1) {
                     req.add_offset = -count - 1;
+                } else if (load_type == 2 && max_id != 0) {
+                    req.add_offset = -count + 6;
                 } else {
                     req.add_offset = 0;
                 }
@@ -1819,7 +1910,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                         if (res.messages.size() > count) {
                             res.messages.remove(0);
                         }
-                        processLoadedMessages(res, dialog_id, count, max_id, false, classGuid, 0, last_message_id, 0, 0, load_type, important, false);
+                        processLoadedMessages(res, dialog_id, count, max_id, false, classGuid, first_unread, last_message_id, unread_count, last_date, load_type, important, false, loadIndex, queryFromServer);
                     }
                 }
             });
@@ -1828,11 +1919,12 @@ public void run(TLObject response, TLRPC.TL_error error) {
     }
 
     public void processLoadedMessages(final TLRPC.messages_Messages messagesRes, final long dialog_id, final int count, final int max_id, final boolean isCache, final int classGuid,
-                                      final int first_unread, final int last_message_id, final int unread_count, final int last_date, final int load_type, final int important, final boolean isEnd) {
+                                      final int first_unread, final int last_message_id, final int unread_count, final int last_date, final int load_type, final int important, final boolean isEnd, final int loadIndex, final boolean queryFromServer) {
         Utilities.stageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
                 boolean createDialog = false;
+                boolean isMegagroup = false;
                 if (messagesRes instanceof TLRPC.TL_messages_channelMessages) {
                     int channelId = -(int) dialog_id;
                     Integer channelPts = channelsPts.get(channelId);
@@ -1844,6 +1936,13 @@ public void run() {
                             getChannelDifference(channelId);
                         }
                     }
+                    for (int a = 0; a < messagesRes.chats.size(); a++) {
+                        TLRPC.Chat chat = messagesRes.chats.get(a);
+                        if (chat.id == channelId) {
+                            isMegagroup = chat.megagroup;
+                            break;
+                        }
+                    }
                 }
                 int lower_id = (int) dialog_id;
                 int high_id = (int) (dialog_id >> 32);
@@ -1854,27 +1953,39 @@ public void run() {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            loadMessages(dialog_id, count, max_id, false, 0, classGuid, load_type, last_message_id, important);
+                            loadMessages(dialog_id, count, load_type == 2 && queryFromServer ? first_unread : max_id, false, 0, classGuid, load_type, last_message_id, important, loadIndex, first_unread, unread_count, last_date, queryFromServer);
                         }
                     });
                     return;
                 }
                 final HashMap<Integer, TLRPC.User> usersDict = new HashMap<>();
-                for (TLRPC.User u : messagesRes.users) {
+                final HashMap<Integer, TLRPC.Chat> chatsDict = new HashMap<>();
+                for (int a = 0; a < messagesRes.users.size(); a++) {
+                    TLRPC.User u = messagesRes.users.get(a);
                     usersDict.put(u.id, u);
                 }
+                for (int a = 0; a < messagesRes.chats.size(); a++) {
+                    TLRPC.Chat c = messagesRes.chats.get(a);
+                    chatsDict.put(c.id, c);
+                }
                 int size = messagesRes.messages.size();
                 if (!isCache) {
                     for (int a = 0; a < size; a++) {
                         TLRPC.Message message = messagesRes.messages.get(a);
-                        if (!isCache && message.from_id <= 0 && (message.flags & TLRPC.MESSAGE_FLAG_OUT) == 0) {
-                            message.flags |= TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
+                        if (!isCache && message.from_id <= 0 && !message.out) {
+                            message.media_unread = true;
+                        }
+                        if (isMegagroup) {
+                            message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
                         }
                         if (message.action instanceof TLRPC.TL_messageActionChatDeleteUser) {
                             TLRPC.User user = usersDict.get(message.action.user_id);
-                            if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                            if (user != null && user.bot) {
                                 message.reply_markup = new TLRPC.TL_replyKeyboardHide();
                             }
+                        } else if (message.action instanceof TLRPC.TL_messageActionChatMigrateTo || message.action instanceof TLRPC.TL_messageActionChannelCreate) {
+                            message.unread = false;
+                            message.media_unread = false;
                         }
                     }
                     MessagesStorage.getInstance().putMessages(messagesRes, dialog_id, load_type, max_id, important, createDialog);
@@ -1885,7 +1996,7 @@ public void run() {
                 for (int a = 0; a < size; a++) {
                     TLRPC.Message message = messagesRes.messages.get(a);
                     message.dialog_id = dialog_id;
-                    objects.add(new MessageObject(message, usersDict, true));
+                    objects.add(new MessageObject(message, usersDict, chatsDict, true));
                     if (isCache) {
                         if (message.media instanceof TLRPC.TL_messageMediaUnsupported) {
                             if (message.media.bytes.length == 0 || message.media.bytes.length == 1 && message.media.bytes[0] < TLRPC.LAYER) {
@@ -1903,7 +2014,19 @@ public void run() {
                     public void run() {
                         putUsers(messagesRes.users, isCache);
                         putChats(messagesRes.chats, isCache);
-                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.messagesDidLoaded, dialog_id, count, objects, isCache, first_unread, last_message_id, unread_count, last_date, load_type, messagesRes.collapsed, isEnd);
+                        int first_unread_final = Integer.MAX_VALUE;
+                        if (queryFromServer && load_type == 2) {
+                            for (int a = 0; a < messagesRes.messages.size(); a++) {
+                                TLRPC.Message message = messagesRes.messages.get(a);
+                                if (!message.out && message.id > first_unread && message.id < first_unread_final) {
+                                    first_unread_final = message.id;
+                                }
+                            }
+                        }
+                        if (first_unread_final == Integer.MAX_VALUE) {
+                            first_unread_final = first_unread;
+                        }
+                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.messagesDidLoaded, dialog_id, count, objects, isCache, first_unread_final, last_message_id, unread_count, last_date, load_type, messagesRes.collapsed, isEnd, classGuid, loadIndex);
                         if (messagesToReload != null) {
                             reloadMessages(messagesToReload, dialog_id);
                         }
@@ -1913,35 +2036,231 @@ public void run() {
         });
     }
 
-    public void loadDialogs(final int offset, final int serverOffset, final int count, boolean fromCache) {
+    public void loadDialogs(final int offset, final int count, boolean fromCache) {
         if (loadingDialogs) {
             return;
         }
         loadingDialogs = true;
         NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
-
+        FileLog.e("tmessages", "load cacheOffset = " + offset + " count = " + count + " cache = " + fromCache);
         if (fromCache) {
-            MessagesStorage.getInstance().getDialogs(nextDialogsCacheOffset, offset, serverOffset, count);
+            MessagesStorage.getInstance().getDialogs(offset == 0 ? 0 : nextDialogsCacheOffset, count);
         } else {
             TLRPC.TL_messages_getDialogs req = new TLRPC.TL_messages_getDialogs();
-            req.offset = serverOffset;
             req.limit = count;
+            boolean found = false;
+            for (int a = dialogs.size() - 1; a >= 0; a--) {
+                TLRPC.Dialog dialog = dialogs.get(a);
+                int lower_id = (int) dialog.id;
+                int high_id = (int) (dialog.id >> 32);
+                if (lower_id != 0 && high_id != 1 && dialog.top_message > 0) {
+                    MessageObject message = dialogMessage.get(dialog.id);
+                    if (message != null && message.getId() > 0) {
+                        req.offset_date = message.messageOwner.date;
+                        req.offset_id = message.messageOwner.id;
+                        int id;
+                        if (message.messageOwner.to_id.channel_id != 0) {
+                            id = -message.messageOwner.to_id.channel_id;
+                        } else if (message.messageOwner.to_id.chat_id != 0) {
+                            id = -message.messageOwner.to_id.chat_id;
+                        } else {
+                            id = message.messageOwner.to_id.user_id;
+                        }
+                        req.offset_peer = MessagesController.getInputPeer(id);
+                        found = true;
+                        break;
+                    }
+                }
+            }
+            if (!found) {
+                req.offset_peer = new TLRPC.TL_inputPeerEmpty();
+            }
             ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
                 @Override
                 public void run(TLObject response, TLRPC.TL_error error) {
                     if (error == null) {
                         final TLRPC.messages_Dialogs dialogsRes = (TLRPC.messages_Dialogs) response;
-                        processLoadedDialogs(dialogsRes, null, 0, offset, serverOffset, count, false, false);
+                        processLoadedDialogs(dialogsRes, null, 0, count, false, false, false);
                     }
                 }
             });
         }
     }
 
-    public void processLoadedDialogs(final TLRPC.messages_Dialogs dialogsRes, final ArrayList<TLRPC.EncryptedChat> encChats, final int cacheOffset, final int offset, final int serverOffset, final int count, final boolean isCache, final boolean resetEnd) {
+    private void migrateDialogs(final int offset, final int offsetDate, final int offsetUser, final int offsetChat, final int offsetChannel, final long accessPeer) {
+        if (migratingDialogs || offset == -1) {
+            return;
+        }
+        migratingDialogs = true;
+
+        TLRPC.TL_messages_getDialogs req = new TLRPC.TL_messages_getDialogs();
+        req.limit = 100;
+        req.offset_id = offset;
+        req.offset_date = offsetDate;
+        if (offset == 0) {
+            req.offset_peer = new TLRPC.TL_inputPeerEmpty();
+        } else {
+            if (offsetChannel != 0) {
+                req.offset_peer = new TLRPC.TL_inputPeerChannel();
+                req.offset_peer.channel_id = offsetChannel;
+            } else if (offsetUser != 0) {
+                req.offset_peer = new TLRPC.TL_inputPeerUser();
+                req.offset_peer.user_id = offsetUser;
+            } else {
+                req.offset_peer = new TLRPC.TL_inputPeerChat();
+                req.offset_peer.chat_id = offsetChat;
+            }
+            req.offset_peer.access_hash = accessPeer;
+        }
+        ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+            @Override
+            public void run(TLObject response, TLRPC.TL_error error) {
+                if (error == null) {
+                    final TLRPC.messages_Dialogs dialogsRes = (TLRPC.messages_Dialogs) response;
+                    MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                int offsetId;
+                                if (dialogsRes.dialogs.size() == 100) {
+                                    TLRPC.Message lastMessage = null;
+                                    for (int a = 0; a < dialogsRes.messages.size(); a++) {
+                                        TLRPC.Message message = dialogsRes.messages.get(a);
+                                        if (lastMessage == null || message.date < lastMessage.date) {
+                                            lastMessage = message;
+                                        }
+                                    }
+                                    offsetId = lastMessage.id;
+                                    UserConfig.migrateOffsetDate = lastMessage.date;
+                                    if (lastMessage.to_id.channel_id != 0) {
+                                        UserConfig.migrateOffsetChannelId = lastMessage.to_id.channel_id;
+                                        UserConfig.migrateOffsetChatId = 0;
+                                        UserConfig.migrateOffsetUserId = 0;
+                                        for (int a = 0; a < dialogsRes.chats.size(); a++) {
+                                            TLRPC.Chat chat = dialogsRes.chats.get(a);
+                                            if (chat.id == UserConfig.migrateOffsetChannelId) {
+                                                UserConfig.migrateOffsetAccess = chat.access_hash;
+                                                break;
+                                            }
+                                        }
+                                    } else if (lastMessage.to_id.chat_id != 0) {
+                                        UserConfig.migrateOffsetChatId = lastMessage.to_id.chat_id;
+                                        UserConfig.migrateOffsetChannelId = 0;
+                                        UserConfig.migrateOffsetUserId = 0;
+                                        for (int a = 0; a < dialogsRes.chats.size(); a++) {
+                                            TLRPC.Chat chat = dialogsRes.chats.get(a);
+                                            if (chat.id == UserConfig.migrateOffsetChatId) {
+                                                UserConfig.migrateOffsetAccess = chat.access_hash;
+                                                break;
+                                            }
+                                        }
+                                    } else if (lastMessage.to_id.user_id != 0) {
+                                        UserConfig.migrateOffsetUserId = lastMessage.to_id.user_id;
+                                        UserConfig.migrateOffsetChatId = 0;
+                                        UserConfig.migrateOffsetChannelId = 0;
+                                        for (int a = 0; a < dialogsRes.users.size(); a++) {
+                                            TLRPC.User user = dialogsRes.users.get(a);
+                                            if (user.id == UserConfig.migrateOffsetUserId) {
+                                                UserConfig.migrateOffsetAccess = user.access_hash;
+                                                break;
+                                            }
+                                        }
+                                    }
+                                } else {
+                                    offsetId = -1;
+                                }
+
+                                StringBuilder dids = new StringBuilder(dialogsRes.dialogs.size() * 12);
+                                HashMap<Long, TLRPC.Dialog> dialogHashMap = new HashMap<>();
+                                for (int a = 0; a < dialogsRes.dialogs.size(); a++) {
+                                    TLRPC.Dialog dialog = dialogsRes.dialogs.get(a);
+                                    if (dialog.peer.channel_id != 0) {
+                                        dialog.id = -dialog.peer.channel_id;
+                                    } else if (dialog.peer.chat_id != 0) {
+                                        dialog.id = -dialog.peer.chat_id;
+                                    } else {
+                                        dialog.id = dialog.peer.user_id;
+                                    }
+                                    if (dids.length() > 0) {
+                                        dids.append(",");
+                                    }
+                                    dids.append(dialog.id);
+                                    dialogHashMap.put(dialog.id, dialog);
+                                }
+                                SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized(String.format(Locale.US, "SELECT did FROM dialogs WHERE did IN (%s)", dids.toString()));
+                                while (cursor.next()) {
+                                    long did = cursor.longValue(0);
+                                    TLRPC.Dialog dialog = dialogHashMap.remove(did);
+                                    if (dialog != null) {
+                                        dialogsRes.dialogs.remove(dialog);
+                                        for (int a = 0; a < dialogsRes.messages.size(); a++) {
+                                            TLRPC.Message message = dialogsRes.messages.get(a);
+                                            if (MessageObject.getDialogId(message) != did) {
+                                                continue;
+                                            }
+                                            dialogsRes.messages.remove(a);
+                                            a--;
+                                            if (message.id == dialog.top_message) {
+                                                dialog.top_message = 0;
+                                            }
+                                            if (message.id == dialog.top_not_important_message) {
+                                                dialog.top_not_important_message = 0;
+                                            }
+                                            if (dialog.top_message == 0 && dialog.top_not_important_message == 0) {
+                                                break;
+                                            }
+                                        }
+                                    }
+                                }
+                                cursor.dispose();
+                                cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT min(date) FROM dialogs WHERE date != 0 AND did >> 32 IN (0, -1)");
+                                if (cursor.next()) {
+                                    int date = Math.max(1441062000, cursor.intValue(0));
+                                    for (int a = 0; a < dialogsRes.messages.size(); a++) {
+                                        TLRPC.Message message = dialogsRes.messages.get(a);
+                                        if (message.date < date) {
+                                            offsetId = -1;
+                                            dialogsRes.messages.remove(a);
+                                            a--;
+                                            TLRPC.Dialog dialog = dialogHashMap.remove(MessageObject.getDialogId(message));
+                                            if (dialog != null) {
+                                                dialogsRes.dialogs.remove(dialog);
+                                            }
+                                        }
+                                    }
+                                }
+                                cursor.dispose();
+
+                                MessagesController.getInstance().processLoadedDialogs(dialogsRes, null, offsetId, 0, false, false, true);
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                                AndroidUtilities.runOnUIThread(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        migratingDialogs = false;
+                                    }
+                                });
+                            }
+                        }
+                    });
+                } else {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            migratingDialogs = false;
+                        }
+                    });
+                }
+            }
+        });
+
+    }
+
+    public void processLoadedDialogs(final TLRPC.messages_Dialogs dialogsRes, final ArrayList<TLRPC.EncryptedChat> encChats, final int offset, final int count, final boolean isCache, final boolean resetEnd, final boolean migrate) {
         Utilities.stageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
+                FileLog.e("tmessages", "loaded from " + isCache + " count " + dialogsRes.dialogs.size());
                 if (isCache && dialogsRes.dialogs.size() == 0) {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
@@ -1952,29 +2271,12 @@ public void run() {
                                 dialogsEndReached = false;
                             }
                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
-                            loadDialogs(offset, serverOffset, count, false);
+                            loadDialogs(0, count, false);
                         }
                     });
                     return;
                 }
-                if (!UserConfig.channelsLoaded && !loadingChannels) {
-                    loadingChannels = true;
-                    TLRPC.TL_channels_getDialogs req = new TLRPC.TL_channels_getDialogs();
-                    req.offset = 0;
-                    req.limit = 100;
-                    ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
-                        @Override
-                        public void run(TLObject response, TLRPC.TL_error error) {
-                            if (error == null) {
-                                loadingChannels = false;
-                                UserConfig.channelsLoaded = true;
-                                UserConfig.saveConfig(false);
-                                final TLRPC.messages_Dialogs dialogsRes = (TLRPC.messages_Dialogs) response;
-                                processLoadedDialogs(dialogsRes, null, 0, 0, 0, 100, false, false);
-                            }
-                        }
-                    });
-                }
+
                 final HashMap<Long, TLRPC.Dialog> new_dialogs_dict = new HashMap<>();
                 final HashMap<Long, MessageObject> new_dialogMessage = new HashMap<>();
                 final HashMap<Integer, TLRPC.User> usersDict = new HashMap<>();
@@ -1989,23 +2291,31 @@ public void run(TLObject response, TLRPC.TL_error error) {
                     chatsDict.put(c.id, c);
                 }
                 if (isCache) {
-                    nextDialogsCacheOffset = cacheOffset + count;
+                    nextDialogsCacheOffset = offset + count;
                 }
 
                 for (int a = 0; a < dialogsRes.messages.size(); a++) {
                     TLRPC.Message message = dialogsRes.messages.get(a);
                     if (message.to_id.channel_id != 0) {
                         TLRPC.Chat chat = chatsDict.get(message.to_id.channel_id);
-                        if (chat != null && (chat.flags & TLRPC.CHAT_FLAG_USER_LEFT) != 0) {
+                        if (chat != null && chat.left && !chat.megagroup) {
+                            continue;
+                        }
+                        if (chat != null && chat.megagroup) {
+                            message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                        }
+                    } else if (message.to_id.chat_id != 0) {
+                        TLRPC.Chat chat = chatsDict.get(message.to_id.chat_id);
+                        if (chat != null && chat.migrated_to != null) {
                             continue;
                         }
                     }
-                    if (!isCache && message.from_id <= 0 && (message.flags & TLRPC.MESSAGE_FLAG_OUT) == 0) {
-                        message.flags |= TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
+                    if (!isCache && message.from_id <= 0 && !message.out) {
+                        message.media_unread = true;
                     }
-                    MessageObject messageObject = new MessageObject(message, usersDict, false);
+                    MessageObject messageObject = new MessageObject(message, usersDict, chatsDict, false);
                     MessageObject currentMessage = new_dialogMessage.get(messageObject.getDialogId());
-                    if (currentMessage == null || messageObject.isImportant()) {
+                    if (currentMessage == null || messageObject.isMegagroup() || messageObject.isImportant()) {
                         new_dialogMessage.put(messageObject.getDialogId(), messageObject);
                     }
                 }
@@ -2026,10 +2336,19 @@ public void run(TLObject response, TLRPC.TL_error error) {
                     }
                     if (d instanceof TLRPC.TL_dialogChannel) {
                         TLRPC.Chat chat = chatsDict.get(-(int) d.id);
-                        if (chat != null && (chat.flags & TLRPC.CHAT_FLAG_USER_LEFT) != 0) {
+                        if (chat != null && chat.megagroup) {
+                            d.top_message = Math.max(d.top_message, d.top_not_important_message);
+                            d.unread_count = Math.max(d.unread_count, d.unread_not_important_count);
+                        }
+                        if (chat != null && chat.left && !chat.megagroup) {
                             continue;
                         }
                         channelsPts.put(-(int) d.id, d.pts);
+                    } else if ((int) d.id < 0) {
+                        TLRPC.Chat chat = chatsDict.get(-(int) d.id);
+                        if (chat != null && chat.migrated_to != null) {
+                            continue;
+                        }
                     }
                     if (d.last_message_date == 0) {
                         MessageObject mess = new_dialogMessage.get(d.id);
@@ -2038,6 +2357,12 @@ public void run(TLObject response, TLRPC.TL_error error) {
                         }
                     }
                     new_dialogs_dict.put(d.id, d);
+
+                    Integer value = dialogs_read_inbox_max.get(d.id);
+                    if (value == null) {
+                        value = 0;
+                    }
+                    dialogs_read_inbox_max.put(d.id, Math.max(value, d.read_inbox_max_id));
                 }
 
                 if (!isCache) {
@@ -2047,9 +2372,12 @@ public void run(TLObject response, TLRPC.TL_error error) {
                         TLRPC.Message message = dialogsRes.messages.get(a);
                         if (message.action instanceof TLRPC.TL_messageActionChatDeleteUser) {
                             TLRPC.User user = usersDict.get(message.action.user_id);
-                            if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                            if (user != null && user.bot) {
                                 message.reply_markup = new TLRPC.TL_replyKeyboardHide();
                             }
+                        } else if (message.action instanceof TLRPC.TL_messageActionChatMigrateTo || message.action instanceof TLRPC.TL_messageActionChannelCreate) {
+                            message.unread = false;
+                            message.media_unread = false;
                         }
                     }
                     MessagesStorage.getInstance().putDialogs(dialogsRes);
@@ -2064,20 +2392,29 @@ public void run() {
                         putUsers(dialogsRes.users, isCache);
                         putChats(dialogsRes.chats, isCache);
                         if (encChats != null) {
-                            for (TLRPC.EncryptedChat encryptedChat : encChats) {
+                            for (int a = 0; a < encChats.size(); a++) {
+                                TLRPC.EncryptedChat encryptedChat = encChats.get(a);
                                 if (encryptedChat instanceof TLRPC.TL_encryptedChat && AndroidUtilities.getMyLayerVersion(encryptedChat.layer) < SecretChatHelper.CURRENT_SECRET_CHAT_LAYER) {
                                     SecretChatHelper.getInstance().sendNotifyLayerMessage(encryptedChat, null);
                                 }
                                 putEncryptedChat(encryptedChat, true);
                             }
                         }
-                        loadingDialogs = false;
+                        if (!migrate) {
+                            loadingDialogs = false;
+                        }
+                        boolean added = false;
 
+                        int lastDialogDate = migrate && !dialogs.isEmpty() ? dialogs.get(dialogs.size() - 1).last_message_date : 0;
                         for (HashMap.Entry<Long, TLRPC.Dialog> pair : new_dialogs_dict.entrySet()) {
                             Long key = pair.getKey();
                             TLRPC.Dialog value = pair.getValue();
+                            if (migrate && lastDialogDate != 0 && value.last_message_date < lastDialogDate) {
+                                continue;
+                            }
                             TLRPC.Dialog currentDialog = dialogs_dict.get(key);
                             if (currentDialog == null) {
+                                added = true;
                                 dialogs_dict.put(key, value);
                                 MessageObject messageObject = new_dialogMessage.get(value.id);
                                 dialogMessage.put(key, messageObject);
@@ -2111,8 +2448,6 @@ public void run() {
                         dialogs.clear();
                         dialogsServerOnly.clear();
                         dialogsGroupsOnly.clear();
-                        currentDialogsCount = 0;
-                        currentChannelDialogsCount = 0;
                         dialogs.addAll(dialogs_dict.values());
                         Collections.sort(dialogs, new Comparator<TLRPC.Dialog>() {
                             @Override
@@ -2131,30 +2466,104 @@ public int compare(TLRPC.Dialog tl_dialog, TLRPC.Dialog tl_dialog2) {
 
                             int high_id = (int) (d.id >> 32);
                             if ((int) d.id != 0 && high_id != 1) {
-                                dialogsServerOnly.add(d);
                                 if (d instanceof TLRPC.TL_dialog) {
                                     if (d.id < 0) {
+                                        if (migrate) {
+                                            TLRPC.Chat chat = chatsDict.get(-(int) d.id);
+                                            if (chat != null && chat.migrated_to != null) {
+                                                dialogs.remove(a);
+                                                a--;
+                                                continue;
+                                            }
+                                        }
                                         dialogsGroupsOnly.add(d);
                                     }
-                                    currentDialogsCount++;
                                 } else if (d instanceof TLRPC.TL_dialogChannel) {
-                                    currentChannelDialogsCount++;
+                                    int lower_id = (int) d.id;
+                                    TLRPC.Chat chat = getChat(-lower_id);
+                                    if (chat != null && (chat.megagroup && chat.editor || chat.creator)) {
+                                        dialogsGroupsOnly.add(d);
+                                    }
                                 }
+                                dialogsServerOnly.add(d);
                             }
                         }
 
-                        dialogsEndReached = (dialogsRes.dialogs.size() == 0 || dialogsRes.dialogs.size() != count) && !isCache;
+                        if (!migrate) {
+                            dialogsEndReached = (dialogsRes.dialogs.size() == 0 || dialogsRes.dialogs.size() != count) && !isCache;
+                        }
                         NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
-                        generateUpdateMessage();
+
+                        if (migrate) {
+                            UserConfig.migrateOffsetId = offset;
+                            UserConfig.saveConfig(false);
+                            migratingDialogs = false;
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.needReloadRecentDialogsSearch);
+                        } else {
+                            generateUpdateMessage();
+                            if (!added && isCache) {
+                                loadDialogs(0, count, false);
+                            }
+                        }
+                        migrateDialogs(UserConfig.migrateOffsetId, UserConfig.migrateOffsetDate, UserConfig.migrateOffsetUserId, UserConfig.migrateOffsetChatId, UserConfig.migrateOffsetChannelId, UserConfig.migrateOffsetAccess);
                     }
                 });
             }
         });
     }
 
+    private void applyDialogNotificationsSettings(long dialog_id, TLRPC.PeerNotifySettings notify_settings) {
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
+        int currentValue = preferences.getInt("notify2_" + dialog_id, 0);
+        int currentValue2 = preferences.getInt("notifyuntil_" + dialog_id, 0);
+        SharedPreferences.Editor editor = null;
+        TLRPC.Dialog dialog = dialogs_dict.get(dialog_id);
+        if (dialog != null) {
+            dialog.notify_settings = notify_settings;
+        }
+        if (notify_settings.mute_until > ConnectionsManager.getInstance().getCurrentTime()) {
+            int until = 0;
+            if (notify_settings.mute_until > ConnectionsManager.getInstance().getCurrentTime() + 60 * 60 * 24 * 365) {
+                if (currentValue != 2) {
+                    editor = preferences.edit();
+                    editor.putInt("notify2_" + dialog_id, 2);
+                    if (dialog != null) {
+                        dialog.notify_settings.mute_until = Integer.MAX_VALUE;
+                    }
+                }
+            } else {
+                if (currentValue != 3 || currentValue2 != notify_settings.mute_until) {
+                    until = notify_settings.mute_until;
+                    editor = preferences.edit();
+                    editor.putInt("notify2_" + dialog_id, 3);
+                    editor.putInt("notifyuntil_" + dialog_id, notify_settings.mute_until);
+                    if (dialog != null) {
+                        dialog.notify_settings.mute_until = until;
+                    }
+                }
+            }
+            MessagesStorage.getInstance().setDialogFlags(dialog_id, ((long) until << 32) | 1);
+            NotificationsController.getInstance().removeNotificationsForDialog(dialog_id);
+        } else {
+            if (currentValue != 0) {
+                if (dialog != null) {
+                    dialog.notify_settings.mute_until = 0;
+                }
+                editor = preferences.edit();
+                editor.remove("notify2_" + dialog_id);
+            }
+            MessagesStorage.getInstance().setDialogFlags(dialog_id, 0);
+        }
+        if (editor != null) {
+            editor.commit();
+            NotificationCenter.getInstance().postNotificationName(NotificationCenter.notificationsSettingsUpdated);
+        }
+    }
+
     private void applyDialogsNotificationsSettings(ArrayList<TLRPC.Dialog> dialogs) {
         SharedPreferences.Editor editor = null;
-        for (TLRPC.Dialog dialog : dialogs) {
+        for (int a = 0; a < dialogs.size(); a++) {
+            TLRPC.Dialog dialog = dialogs.get(a);
             if (dialog.peer != null && dialog.notify_settings instanceof TLRPC.TL_peerNotifySettings) {
                 if (editor == null) {
                     SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
@@ -2176,6 +2585,8 @@ private void applyDialogsNotificationsSettings(ArrayList<TLRPC.Dialog> dialogs)
                         editor.putInt("notify2_" + dialog_id, 3);
                         editor.putInt("notifyuntil_" + dialog_id, dialog.notify_settings.mute_until);
                     }
+                } else {
+                    editor.remove("notify2_" + dialog_id);
                 }
             }
         }
@@ -2223,11 +2634,16 @@ public void run() {
                     TLRPC.Message message = dialogsRes.messages.get(a);
                     if (message.to_id.channel_id != 0) {
                         TLRPC.Chat chat = chatsDict.get(message.to_id.channel_id);
-                        if (chat != null && (chat.flags & TLRPC.CHAT_FLAG_USER_LEFT) != 0) {
+                        if (chat != null && chat.left && !chat.megagroup) {
+                            continue;
+                        }
+                    } else if (message.to_id.chat_id != 0) {
+                        TLRPC.Chat chat = chatsDict.get(message.to_id.chat_id);
+                        if (chat != null && chat.migrated_to != null) {
                             continue;
                         }
                     }
-                    MessageObject messageObject = new MessageObject(message, usersDict, false);
+                    MessageObject messageObject = new MessageObject(message, usersDict, chatsDict, false);
                     new_dialogMessage.put(messageObject.getDialogId(), messageObject);
                 }
                 for (int a = 0; a < dialogsRes.dialogs.size(); a++) {
@@ -2243,7 +2659,12 @@ public void run() {
                     }
                     if (d instanceof TLRPC.TL_dialogChannel) {
                         TLRPC.Chat chat = chatsDict.get(-(int) d.id);
-                        if (chat != null && (chat.flags & TLRPC.CHAT_FLAG_USER_LEFT) != 0) {
+                        if (chat != null && chat.left && !chat.megagroup) {
+                            continue;
+                        }
+                    } else if ((int) d.id < 0) {
+                        TLRPC.Chat chat = chatsDict.get(-(int) d.id);
+                        if (chat != null && chat.migrated_to != null) {
                             continue;
                         }
                     }
@@ -2255,6 +2676,12 @@ public void run() {
                     }
                     new_dialogs_dict.put(d.id, d);
                     dialogsToUpdate.put(d.id, d.unread_count);
+
+                    Integer value = dialogs_read_inbox_max.get(d.id);
+                    if (value == null) {
+                        value = 0;
+                    }
+                    dialogs_read_inbox_max.put(d.id, Math.max(value, d.read_inbox_max_id));
                 }
 
                 AndroidUtilities.runOnUIThread(new Runnable() {
@@ -2303,8 +2730,6 @@ public void run() {
                         dialogs.clear();
                         dialogsServerOnly.clear();
                         dialogsGroupsOnly.clear();
-                        currentDialogsCount = 0;
-                        currentChannelDialogsCount = 0;
                         dialogs.addAll(dialogs_dict.values());
                         Collections.sort(dialogs, new Comparator<TLRPC.Dialog>() {
                             @Override
@@ -2327,9 +2752,12 @@ public int compare(TLRPC.Dialog dialog, TLRPC.Dialog dialog2) {
                                     if (d.id < 0) {
                                         dialogsGroupsOnly.add(d);
                                     }
-                                    currentDialogsCount++;
                                 } else if (d instanceof TLRPC.TL_dialogChannel) {
-                                    currentChannelDialogsCount++;
+                                    int lower_id = (int) d.id;
+                                    TLRPC.Chat chat = getChat(-lower_id);
+                                    if (chat != null && (chat.megagroup && chat.editor || chat.creator)) {
+                                        dialogsGroupsOnly.add(d);
+                                    }
                                 }
                             }
                         }
@@ -2415,12 +2843,12 @@ public void markMessageAsRead(final long dialog_id, final long random_id, int tt
         MessagesStorage.getInstance().createTaskForSecretChat(chat.id, time, time, 0, random_ids);
     }
 
-    public void markDialogAsRead(final long dialog_id, final int max_id, final int max_positive_id, final int offset, final int max_date, final boolean was, final boolean popup) {
+    public void markDialogAsRead(final long dialog_id, final int max_id, final int max_positive_id, final int max_date, final boolean was, final boolean popup) {
         int lower_part = (int) dialog_id;
         int high_id = (int) (dialog_id >> 32);
 
         if (lower_part != 0) {
-            if (max_positive_id == 0 && offset == 0 || high_id == 1) {
+            if (max_positive_id == 0 || high_id == 1) {
                 return;
             }
             TLRPC.InputPeer inputPeer = getInputPeer(lower_part);
@@ -2436,39 +2864,42 @@ public void markDialogAsRead(final long dialog_id, final int max_id, final int m
                 TLRPC.TL_messages_readHistory request = new TLRPC.TL_messages_readHistory();
                 request.peer = inputPeer;
                 request.max_id = max_positive_id;
-                request.offset = offset;
                 req = request;
             }
+            Integer value = dialogs_read_inbox_max.get(dialog_id);
+            if (value == null) {
+                value = 0;
+            }
+            dialogs_read_inbox_max.put(dialog_id, Math.max(value, max_positive_id));
 
-            if (offset == 0) {
-                MessagesStorage.getInstance().processPendingRead(dialog_id, messageId, max_date, false);
-                MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        AndroidUtilities.runOnUIThread(new Runnable() {
-                            @Override
-                            public void run() {
-                                TLRPC.Dialog dialog = dialogs_dict.get(dialog_id);
-                                if (dialog != null) {
-                                    dialog.unread_count = 0;
-                                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.updateInterfaces, UPDATE_MASK_READ_DIALOG_MESSAGE);
-                                }
-                                if (!popup) {
-                                    NotificationsController.getInstance().processReadMessages(null, dialog_id, 0, max_positive_id, false);
-                                    HashMap<Long, Integer> dialogsToUpdate = new HashMap<>();
-                                    dialogsToUpdate.put(dialog_id, 0);
-                                    NotificationsController.getInstance().processDialogsUpdateRead(dialogsToUpdate);
-                                } else {
-                                    NotificationsController.getInstance().processReadMessages(null, dialog_id, 0, max_positive_id, true);
-                                    HashMap<Long, Integer> dialogsToUpdate = new HashMap<>();
-                                    dialogsToUpdate.put(dialog_id, -1);
-                                    NotificationsController.getInstance().processDialogsUpdateRead(dialogsToUpdate);
-                                }
+            MessagesStorage.getInstance().processPendingRead(dialog_id, messageId, max_date, false);
+            MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+                @Override
+                public void run() {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            TLRPC.Dialog dialog = dialogs_dict.get(dialog_id);
+                            if (dialog != null) {
+                                dialog.unread_count = 0;
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.updateInterfaces, UPDATE_MASK_READ_DIALOG_MESSAGE);
                             }
-                        });
-                    }
-                });
-            }
+                            if (!popup) {
+                                NotificationsController.getInstance().processReadMessages(null, dialog_id, 0, max_positive_id, false);
+                                HashMap<Long, Integer> dialogsToUpdate = new HashMap<>();
+                                dialogsToUpdate.put(dialog_id, 0);
+                                NotificationsController.getInstance().processDialogsUpdateRead(dialogsToUpdate);
+                            } else {
+                                NotificationsController.getInstance().processReadMessages(null, dialog_id, 0, max_positive_id, true);
+                                HashMap<Long, Integer> dialogsToUpdate = new HashMap<>();
+                                dialogsToUpdate.put(dialog_id, -1);
+                                NotificationsController.getInstance().processDialogsUpdateRead(dialogsToUpdate);
+                            }
+                        }
+                    });
+                }
+            });
+
             if (max_positive_id != Integer.MAX_VALUE) {
                 final long messageIdFinal = messageId;
                 ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
@@ -2476,11 +2907,8 @@ public void run() {
                     public void run(TLObject response, TLRPC.TL_error error) {
                         if (error == null) {
                             MessagesStorage.getInstance().processPendingRead(dialog_id, messageIdFinal, max_date, true);
-                            if (response instanceof TLRPC.TL_messages_affectedHistory) {
-                                TLRPC.TL_messages_affectedHistory res = (TLRPC.TL_messages_affectedHistory) response;
-                                if (res.offset > 0) {
-                                    markDialogAsRead(dialog_id, 0, max_positive_id, res.offset, max_date, was, popup);
-                                }
+                            if (response instanceof TLRPC.TL_messages_affectedMessages) {
+                                TLRPC.TL_messages_affectedMessages res = (TLRPC.TL_messages_affectedMessages) response;
                                 processNewDifferenceParams(-1, res.pts, -1, res.pts_count);
                             }
                         }
@@ -2630,18 +3058,15 @@ public void run() {
                     });
                 }
             });
-        } else if (type == ChatObject.CHAT_TYPE_CHANNEL) {
+        } else if (type == ChatObject.CHAT_TYPE_CHANNEL || type == ChatObject.CHAT_TYPE_MEGAGROUP) {
             TLRPC.TL_channels_createChannel req = new TLRPC.TL_channels_createChannel();
             req.title = title;
             req.about = about;
-            for (Integer uid : selectedContacts) {
-                TLRPC.User user = getUser(uid);
-                if (user == null) {
-                    continue;
-                }
-                req.users.add(getInputUser(user));
+            if (type == ChatObject.CHAT_TYPE_MEGAGROUP) {
+                req.megagroup = true;
+            } else {
+                req.broadcast = true;
             }
-            req.flags = 1;
             return ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
                 @Override
                 public void run(TLObject response, TLRPC.TL_error error) {
@@ -2674,7 +3099,71 @@ public void run() {
         return 0;
     }
 
-    public void addUsersToChannel(int chat_id, ArrayList<TLRPC.InputUser> users) {
+    public void convertToMegaGroup(final Context context, int chat_id) {
+        TLRPC.TL_messages_migrateChat req = new TLRPC.TL_messages_migrateChat();
+        req.chat_id = chat_id;
+        final ProgressDialog progressDialog = new ProgressDialog(context);
+        progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
+        progressDialog.setCanceledOnTouchOutside(false);
+        progressDialog.setCancelable(false);
+        final int reqId = ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+            @Override
+            public void run(TLObject response, TLRPC.TL_error error) {
+                if (error == null) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (!((Activity) context).isFinishing()) {
+                                try {
+                                    progressDialog.dismiss();
+                                } catch (Exception e) {
+                                    FileLog.e("tmessages", e);
+                                }
+                            }
+                        }
+                    });
+                    TLRPC.Updates updates = (TLRPC.Updates) response;
+                    processUpdates((TLRPC.Updates) response, false);
+                } else {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (!((Activity) context).isFinishing()) {
+                                try {
+                                    progressDialog.dismiss();
+                                } catch (Exception e) {
+                                    FileLog.e("tmessages", e);
+                                }
+                                AlertDialog.Builder builder = new AlertDialog.Builder(context);
+                                builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                                builder.setMessage(LocaleController.getString("ErrorOccurred", R.string.ErrorOccurred));
+                                builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
+                                builder.show().setCanceledOnTouchOutside(true);
+                            }
+                        }
+                    });
+                }
+            }
+        });
+        progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, LocaleController.getString("Cancel", R.string.Cancel), new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                ConnectionsManager.getInstance().cancelRequest(reqId, true);
+                try {
+                    dialog.dismiss();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+        try {
+            progressDialog.show();
+        } catch (Exception e) {
+            //don't promt
+        }
+    }
+
+    public void addUsersToChannel(int chat_id, ArrayList<TLRPC.InputUser> users, final BaseFragment fragment) {
         if (users == null || users.isEmpty()) {
             return;
         }
@@ -2688,8 +3177,10 @@ public void run(TLObject response, final TLRPC.TL_error error) {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            if (error.text.equals("PEER_FLOOD")) {
-                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.spamErrorReceived, 1);
+                            if (fragment != null) {
+                                AlertsCreator.showAddUserAlert(error.text, fragment, true);
+                            } else if (error.text.equals("PEER_FLOOD")) {
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.needShowAlert, 1);
                             }
                         }
                     });
@@ -2736,7 +3227,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                         public void run() {
                             info.about = about;
                             MessagesStorage.getInstance().updateChatInfo(info, false);
-                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info);
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info, 0, false);
                         }
                     });
                 }
@@ -2774,9 +3265,12 @@ public void run() {
     }
 
     public void sendBotStart(final TLRPC.User user, String botHash) {
+        if (user == null) {
+            return;
+        }
         TLRPC.TL_messages_startBot req = new TLRPC.TL_messages_startBot();
         req.bot = getInputUser(user);
-        req.chat_id = 0;
+        req.peer = getInputPeer(user.id);
         req.start_param = botHash;
         req.random_id = Utilities.random.nextLong();
         ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
@@ -2790,6 +3284,34 @@ public void run(TLObject response, TLRPC.TL_error error) {
         });
     }
 
+    public void toggleAdminMode(final int chat_id, boolean enabled) {
+        TLRPC.TL_messages_toggleChatAdmins req = new TLRPC.TL_messages_toggleChatAdmins();
+        req.chat_id = chat_id;
+        req.enabled = enabled;
+        ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+            @Override
+            public void run(TLObject response, TLRPC.TL_error error) {
+                if (error == null) {
+                    processUpdates((TLRPC.Updates) response, false);
+                    loadFullChat(chat_id, 0, true);
+                }
+            }
+        });
+    }
+
+    public void toggleUserAdmin(final int chat_id, int user_id, boolean admin) {
+        TLRPC.TL_messages_editChatAdmin req = new TLRPC.TL_messages_editChatAdmin();
+        req.chat_id = chat_id;
+        req.user_id = getInputUser(user_id);
+        req.is_admin = admin;
+        ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+            @Override
+            public void run(TLObject response, TLRPC.TL_error error) {
+
+            }
+        });
+    }
+
     public void addUserToChat(final int chat_id, final TLRPC.User user, final TLRPC.ChatFull info, int count_fwd, String botHash, final BaseFragment fragment) {
         if (user == null) {
             return;
@@ -2799,18 +3321,31 @@ public void addUserToChat(final int chat_id, final TLRPC.User user, final TLRPC.
             TLObject request;
 
             final boolean isChannel = ChatObject.isChannel(chat_id);
+            final boolean isMegagroup = isChannel && MessagesController.getInstance().getChat(chat_id).megagroup;
             final TLRPC.InputUser inputUser = getInputUser(user);
-            if (botHash == null) {
+            if (botHash == null || isChannel && !isMegagroup) {
                 if (isChannel) {
                     if (inputUser instanceof TLRPC.TL_inputUserSelf) {
+                        if (joiningToChannels.contains(chat_id)) {
+                            return;
+                        }
                         TLRPC.TL_channels_joinChannel req = new TLRPC.TL_channels_joinChannel();
                         req.channel = getInputChannel(chat_id);
                         request = req;
+                        joiningToChannels.add(chat_id);
                     } else {
-                        TLRPC.TL_channels_inviteToChannel req = new TLRPC.TL_channels_inviteToChannel();
-                        req.channel = getInputChannel(chat_id);
-                        req.users.add(inputUser);
-                        request = req;
+                        if (user.bot && !isMegagroup) {
+                            TLRPC.TL_channels_editAdmin req = new TLRPC.TL_channels_editAdmin();
+                            req.channel = getInputChannel(chat_id);
+                            req.user_id = MessagesController.getInputUser(user);
+                            req.role = new TLRPC.TL_channelRoleEditor();
+                            request = req;
+                        } else {
+                            TLRPC.TL_channels_inviteToChannel req = new TLRPC.TL_channels_inviteToChannel();
+                            req.channel = getInputChannel(chat_id);
+                            req.users.add(inputUser);
+                            request = req;
+                        }
                     }
                 } else {
                     TLRPC.TL_messages_addChatUser req = new TLRPC.TL_messages_addChatUser();
@@ -2822,7 +3357,12 @@ public void addUserToChat(final int chat_id, final TLRPC.User user, final TLRPC.
             } else {
                 TLRPC.TL_messages_startBot req = new TLRPC.TL_messages_startBot();
                 req.bot = inputUser;
-                req.chat_id = chat_id;
+                if (isChannel) {
+                    req.peer = getInputPeer(-chat_id);
+                } else {
+                    req.peer = new TLRPC.TL_inputPeerChat();
+                    req.peer.chat_id = chat_id;
+                }
                 req.start_param = botHash;
                 req.random_id = Utilities.random.nextLong();
                 request = req;
@@ -2831,15 +3371,23 @@ public void addUserToChat(final int chat_id, final TLRPC.User user, final TLRPC.
             ConnectionsManager.getInstance().sendRequest(request, new RequestDelegate() {
                 @Override
                 public void run(TLObject response, final TLRPC.TL_error error) {
+                    if (isChannel && inputUser instanceof TLRPC.TL_inputUserSelf) {
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                joiningToChannels.remove((Integer) chat_id);
+                            }
+                        });
+                    }
                     if (error != null) {
                         AndroidUtilities.runOnUIThread(new Runnable() {
                             @Override
                             public void run() {
                                 if (fragment != null) {
-                                    AlertsCreator.showAddUserAlert(error.text, fragment);
+                                    AlertsCreator.showAddUserAlert(error.text, fragment, isChannel && !isMegagroup);
                                 } else {
                                     if (error.text.equals("PEER_FLOOD")) {
-                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.spamErrorReceived, 1);
+                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.needShowAlert, 1);
                                     }
                                 }
                             }
@@ -2849,7 +3397,7 @@ public void run() {
                     processUpdates((TLRPC.Updates) response, false);
                     if (isChannel) {
                         if (inputUser instanceof TLRPC.TL_inputUserSelf) {
-                            generateJoinMessage(chat_id);
+                            generateJoinMessage(chat_id, true);
                         }
                         AndroidUtilities.runOnUIThread(new Runnable() {
                             @Override
@@ -2865,7 +3413,7 @@ public void run() {
             });
         } else {
             if (info instanceof TLRPC.TL_chatFull) {
-                for (TLRPC.TL_chatParticipant p : info.participants.participants) {
+                for (TLRPC.ChatParticipant p : info.participants.participants) {
                     if (p.user_id == user.id) {
                         return;
                     }
@@ -2883,7 +3431,7 @@ public void run() {
                 newPart.date = ConnectionsManager.getInstance().getCurrentTime();
                 info.participants.participants.add(0, newPart);
                 MessagesStorage.getInstance().updateChatInfo(info, true);
-                NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info);
+                NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info, 0, false);
                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.updateInterfaces, UPDATE_MASK_CHAT_MEMBERS);
             }
         }
@@ -2900,7 +3448,7 @@ public void deleteUserFromChat(final int chat_id, final TLRPC.User user, final T
             final boolean isChannel = ChatObject.isChannel(chat);
             if (isChannel) {
                 if (inputUser instanceof TLRPC.TL_inputUserSelf) {
-                    if ((chat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0) {
+                    if (chat.creator) {
                         TLRPC.TL_channels_deleteChannel req = new TLRPC.TL_channels_deleteChannel();
                         req.channel = getInputChannel(chat);
                         request = req;
@@ -2929,7 +3477,7 @@ public void run(TLObject response, TLRPC.TL_error error) {
                         AndroidUtilities.runOnUIThread(new Runnable() {
                             @Override
                             public void run() {
-                                MessagesController.getInstance().deleteDialog(-chat_id, 0, false);
+                                MessagesController.getInstance().deleteDialog(-chat_id, 0);
                             }
                         });
                     }
@@ -2947,7 +3495,7 @@ public void run() {
                         }, 1000);
                     }
                 }
-            });
+            }, ConnectionsManager.RequestFlagInvokeAfter);
         } else {
             if (info instanceof TLRPC.TL_chatFull) {
                 TLRPC.Chat chat = getChat(chat_id);
@@ -2958,7 +3506,7 @@ public void run() {
 
                 boolean changed = false;
                 for (int a = 0; a < info.participants.participants.size(); a++) {
-                    TLRPC.TL_chatParticipant p = info.participants.participants.get(a);
+                    TLRPC.ChatParticipant p = info.participants.participants.get(a);
                     if (p.user_id == user.id) {
                         info.participants.participants.remove(a);
                         changed = true;
@@ -2967,7 +3515,7 @@ public void run() {
                 }
                 if (changed) {
                     MessagesStorage.getInstance().updateChatInfo(info, true);
-                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info);
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, info, 0, false);
                 }
                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.updateInterfaces, UPDATE_MASK_CHAT_MEMBERS);
             }
@@ -3142,16 +3690,16 @@ public void registerForPush(final String regid) {
             req.app_version = "App version unknown";
         }
 
-        if (req.lang_code == null || req.lang_code.length() == 0) {
+        if (req.lang_code == null || req.lang_code.trim().length() == 0) {
             req.lang_code = "en";
         }
-        if (req.device_model == null || req.device_model.length() == 0) {
+        if (req.device_model == null || req.device_model.trim().length() == 0) {
             req.device_model = "Android unknown";
         }
-        if (req.app_version == null || req.app_version.length() == 0) {
+        if (req.app_version == null || req.app_version.trim().length() == 0) {
             req.app_version = "App version unknown";
         }
-        if (req.system_version == null || req.system_version.length() == 0) {
+        if (req.system_version == null || req.system_version.trim().length() == 0) {
             req.system_version = "SDK Unknown";
         }
 
@@ -3272,6 +3820,7 @@ private void processChannelsUpdatesQueue(int channelId, int state) {
         Integer channelPts = channelsPts.get(channelId);
         if (updatesQueue.isEmpty() || channelPts == null) {
             updatesQueueChannels.remove(channelId);
+            return;
         }
         Collections.sort(updatesQueue, new Comparator<TLRPC.Updates>() {
             @Override
@@ -3300,7 +3849,7 @@ public int compare(TLRPC.Updates updates, TLRPC.Updates updates2) {
                 a--;
             } else if (updateState == 1) {
                 Long updatesStartWaitTime = updatesStartWaitTimeChannels.get(channelId);
-                if (updatesStartWaitTime != null && (anyProceed || updatesStartWaitTime + 1500 > System.currentTimeMillis())) {
+                if (updatesStartWaitTime != null && (anyProceed || Math.abs(System.currentTimeMillis() - updatesStartWaitTime) <= 1500)) {
                     FileLog.e("tmessages", "HOLE IN CHANNEL " + channelId + " UPDATES QUEUE - will wait more time");
                     if (anyProceed) {
                         updatesStartWaitTimeChannels.put(channelId, System.currentTimeMillis());
@@ -3371,7 +3920,7 @@ public int compare(TLRPC.Updates updates, TLRPC.Updates updates2) {
                     updatesQueue.remove(a);
                     a--;
                 } else if (updateState == 1) {
-                    if (getUpdatesStartTime(type) != 0 && (anyProceed || getUpdatesStartTime(type) + 1500 > System.currentTimeMillis())) {
+                    if (getUpdatesStartTime(type) != 0 && (anyProceed || Math.abs(System.currentTimeMillis() - getUpdatesStartTime(type)) <= 1500)) {
                         FileLog.e("tmessages", "HOLE IN UPDATES QUEUE - will wait more time");
                         if (anyProceed) {
                             setUpdatesStartTime(type, System.currentTimeMillis());
@@ -3404,7 +3953,7 @@ public void run() {
                 } else {
                     needShortPollChannels.put(channelId, 0);
                     if (shortPollChannels.indexOfKey(channelId) < 0) {
-                        getChannelDifference(channelId);
+                        getChannelDifference(channelId, 2);
                     }
                 }
             }
@@ -3412,17 +3961,26 @@ public void run() {
     }
 
     public void getChannelDifference(final int channelId) {
-        getChannelDifference(channelId, false);
+        getChannelDifference(channelId, 0);
     }
 
-    public void getChannelDifference(final int channelId, boolean newDialog) {
+    public void getChannelDifference(final int channelId, final int newDialogType) {
         Boolean gettingDifferenceChannel = gettingDifferenceChannels.get(channelId);
         if (gettingDifferenceChannel == null) {
             gettingDifferenceChannel = false;
         }
+        if (gettingDifferenceChannel) {
+            return;
+        }
+        int limit = 100;
         Integer channelPts;
-        if (newDialog) {
+        if (newDialogType == 1) {
+            channelPts = channelsPts.get(channelId);
+            if (channelPts != null) {
+                return;
+            }
             channelPts = 1;
+            limit = 1;
         } else {
             channelPts = channelsPts.get(channelId);
             if (channelPts == null) {
@@ -3430,8 +3988,12 @@ public void getChannelDifference(final int channelId, boolean newDialog) {
                 if (channelPts != 0) {
                     channelsPts.put(channelId, channelPts);
                 }
+                if (channelPts == 0 && newDialogType == 2) {
+                    channelPts = 1;
+                    limit = 1;
+                }
             }
-            if (channelPts == 0 || gettingDifferenceChannel) {
+            if (channelPts == 0) {
                 return;
             }
         }
@@ -3440,7 +4002,7 @@ public void getChannelDifference(final int channelId, boolean newDialog) {
         req.channel = getInputChannel(channelId);
         req.filter = new TLRPC.TL_channelMessagesFilterEmpty();
         req.pts = channelPts;
-        req.limit = newDialog ? 1 : 100;
+        req.limit = limit;
         FileLog.e("tmessages", "start getChannelDifference with pts = " + channelPts + " channelId = " + channelId);
         ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
             @Override
@@ -3450,9 +4012,19 @@ public void run(TLObject response, TLRPC.TL_error error) {
                     final TLRPC.updates_ChannelDifference res = (TLRPC.updates_ChannelDifference) response;
 
                     final HashMap<Integer, TLRPC.User> usersDict = new HashMap<>();
-                    for (TLRPC.User user : res.users) {
+                    for (int a = 0; a < res.users.size(); a++) {
+                        TLRPC.User user = res.users.get(a);
                         usersDict.put(user.id, user);
                     }
+                    TLRPC.Chat channel = null;
+                    for (int a = 0; a < res.chats.size(); a++) {
+                        TLRPC.Chat chat = res.chats.get(a);
+                        if (chat.id == channelId) {
+                            channel = chat;
+                            break;
+                        }
+                    }
+                    final TLRPC.Chat channelFinal = channel;
 
                     final ArrayList<TLRPC.TL_updateMessageID> msgUpdates = new ArrayList<>();
                     if (!res.other_updates.isEmpty()) {
@@ -3513,22 +4085,29 @@ public void run() {
                                             final ArrayList<MessageObject> pushMessages = new ArrayList<>();
                                             for (int a = 0; a < res.new_messages.size(); a++) {
                                                 TLRPC.Message message = res.new_messages.get(a);
-                                                if (message.to_id.channel_id != 0 && (message.flags & TLRPC.MESSAGE_FLAG_OUT) == 0) {
-                                                    message.flags |= TLRPC.MESSAGE_FLAG_UNREAD;
-                                                    if (message.from_id <= 0) {
-                                                        message.flags |= TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
+                                                if (!message.out) {
+                                                    message.unread = true;
+                                                    if (message.from_id <= 0 || channelFinal != null && channelFinal.megagroup) {
+                                                        message.media_unread = true;
                                                     }
                                                 }
-                                                if (message.action instanceof TLRPC.TL_messageActionChatDeleteUser) {
-                                                    TLRPC.User user = usersDict.get(message.action.user_id);
-                                                    if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0) {
-                                                        message.reply_markup = new TLRPC.TL_replyKeyboardHide();
-                                                    }
+                                                if (channelFinal != null && channelFinal.megagroup) {
+                                                    message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                                                }
+
+                                                long dialog_id = -channelId;
+                                                Integer value = dialogs_read_inbox_max.get(dialog_id);
+                                                if (value == null) {
+                                                    value = MessagesStorage.getInstance().getChannelReadInboxMax(channelId);
                                                 }
 
                                                 MessageObject obj = new MessageObject(message, usersDict, true);
+                                                if (channelFinal != null && channelFinal.left || value >= obj.getId()) {
+                                                    obj.setIsRead();
+                                                    obj.setContentIsRead();
+                                                }
 
-                                                if (!obj.isOut() && obj.isUnread()) {
+                                                if (!obj.isOut() && obj.isContentUnread()) {
                                                     pushMessages.add(obj);
                                                 }
 
@@ -3578,9 +4157,32 @@ public void run() {
                                         MessagesStorage.getInstance().saveChannelPts(channelId, res.pts);
                                     } else if (res instanceof TLRPC.TL_updates_channelDifferenceTooLong) {
                                         for (int a = 0; a < res.messages.size(); a++) {
-                                            res.messages.get(a).dialog_id = -channelId;
+                                            TLRPC.Message message = res.messages.get(a);
+                                            message.dialog_id = -channelId;
+                                            if (!message.out) {
+                                                message.unread = true;
+                                                if (message.from_id <= 0 || channelFinal != null && channelFinal.megagroup) {
+                                                    message.media_unread = true;
+                                                }
+                                            }
+                                            if (channelFinal != null && channelFinal.megagroup) {
+                                                message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                                            }
+
+                                            if (channelFinal != null && channelFinal.left || res.read_inbox_max_id >= message.id) {
+                                                message.unread = false;
+                                                message.media_unread = false;
+                                            }
+                                            if (channelFinal != null && channelFinal.megagroup) {
+                                                message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                                            }
                                         }
-                                        MessagesStorage.getInstance().overwriteChannel(channelId, (TLRPC.TL_updates_channelDifferenceTooLong) res);
+                                        MessagesStorage.getInstance().putUsersAndChats(res.users, res.chats, true, true);
+                                        if (channelFinal.megagroup) {
+                                            res.unread_important_count = Math.max(res.unread_count, res.unread_important_count);
+                                            res.top_important_message = Math.max(res.top_important_message, res.top_message);
+                                        }
+                                        MessagesStorage.getInstance().overwriteChannel(channelId, (TLRPC.TL_updates_channelDifferenceTooLong) res, newDialogType);
                                     }
                                     gettingDifferenceChannels.remove(channelId);
                                     channelsPts.put(channelId, res.pts);
@@ -3588,7 +4190,7 @@ public void run() {
                                     if ((res.flags & 2) != 0) {
                                         shortPollChannels.put(channelId, (int) (System.currentTimeMillis() / 1000) + res.timeout);
                                     }
-                                    if ((res.flags & 1) == 0) {
+                                    if (!res.isFinal) {
                                         getChannelDifference(channelId);
                                     }
                                     FileLog.e("tmessages", "received channel difference with pts = " + res.pts + " channelId = " + channelId);
@@ -3642,19 +4244,23 @@ public void getDifference(int pts, int date, int qts, boolean slice) {
         ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
             @Override
             public void run(TLObject response, TLRPC.TL_error error) {
-                gettingDifferenceAgain = false;
                 if (error == null) {
                     final TLRPC.updates_Difference res = (TLRPC.updates_Difference) response;
 
                     if (res instanceof TLRPC.TL_updates_differenceSlice) {
-                        gettingDifferenceAgain = true;
                         getDifference(res.intermediate_state.pts, res.intermediate_state.date, res.intermediate_state.qts, true);
                     }
 
                     final HashMap<Integer, TLRPC.User> usersDict = new HashMap<>();
-                    for (TLRPC.User user : res.users) {
+                    final HashMap<Integer, TLRPC.Chat> chatsDict = new HashMap<>();
+                    for (int a = 0; a < res.users.size(); a++) {
+                        TLRPC.User user = res.users.get(a);
                         usersDict.put(user.id, user);
                     }
+                    for (int a = 0; a < res.chats.size(); a++) {
+                        TLRPC.Chat chat = res.chats.get(a);
+                        chatsDict.put(chat.id, chat);
+                    }
 
                     final ArrayList<TLRPC.TL_updateMessageID> msgUpdates = new ArrayList<>();
                     if (!res.other_updates.isEmpty()) {
@@ -3726,12 +4332,15 @@ public void run() {
 
                                             if (message.action instanceof TLRPC.TL_messageActionChatDeleteUser) {
                                                 TLRPC.User user = usersDict.get(message.action.user_id);
-                                                if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                                                if (user != null && user.bot) {
                                                     message.reply_markup = new TLRPC.TL_replyKeyboardHide();
                                                 }
+                                            } else if (message.action instanceof TLRPC.TL_messageActionChatMigrateTo || message.action instanceof TLRPC.TL_messageActionChannelCreate) {
+                                                message.unread = false;
+                                                message.media_unread = false;
                                             }
 
-                                            MessageObject obj = new MessageObject(message, usersDict, true);
+                                            MessageObject obj = new MessageObject(message, usersDict, chatsDict, true);
 
                                             if (!obj.isOut() && obj.isUnread()) {
                                                 pushMessages.add(obj);
@@ -3832,9 +4441,9 @@ public void run() {
         });
     }
 
-    public void generateJoinMessage(final int chat_id) {
+    public void generateJoinMessage(final int chat_id, boolean ignoreLeft) {
         TLRPC.Chat chat = getChat(chat_id);
-        if (chat == null || !ChatObject.isChannel(chat_id)) {
+        if (chat == null || !ChatObject.isChannel(chat_id) || chat.megagroup || (chat.left || chat.kicked) && !ignoreLeft) {
             return;
         }
 
@@ -3847,7 +4456,7 @@ public void generateJoinMessage(final int chat_id) {
         message.to_id.channel_id = chat_id;
         message.dialog_id = -chat_id;
         message.action = new TLRPC.TL_messageActionChatAddUser();
-        message.action.user_id = UserConfig.getClientUserId();
+        message.action.users.add(UserConfig.getClientUserId());
         UserConfig.saveConfig(false);
 
         final ArrayList<MessageObject> pushMessages = new ArrayList<>();
@@ -3879,12 +4488,16 @@ public void run() {
         });
     }
 
+    public void convertGroup() {
+
+    }
+
     public void checkChannelInviter(final int chat_id) {
         AndroidUtilities.runOnUIThread(new Runnable() {
             @Override
             public void run() {
-                TLRPC.Chat chat = getChat(chat_id);
-                if (chat == null || !ChatObject.isChannel(chat_id) || (chat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0) {
+                final TLRPC.Chat chat = getChat(chat_id);
+                if (chat == null || !ChatObject.isChannel(chat_id) || chat.creator) {
                     return;
                 }
                 TLRPC.TL_channels_getParticipant req = new TLRPC.TL_channels_getParticipant();
@@ -3895,6 +4508,9 @@ public void run() {
                     public void run(TLObject response, TLRPC.TL_error error) {
                         final TLRPC.TL_channels_channelParticipant res = (TLRPC.TL_channels_channelParticipant) response;
                         if (res != null && res.participant instanceof TLRPC.TL_channelParticipantSelf && res.participant.inviter_id != UserConfig.getClientUserId()) {
+                            if (chat.megagroup && MessagesStorage.getInstance().isMigratedChat(chat.id)) {
+                                return;
+                            }
                             AndroidUtilities.runOnUIThread(new Runnable() {
                                 @Override
                                 public void run() {
@@ -3904,15 +4520,25 @@ public void run() {
                             MessagesStorage.getInstance().putUsersAndChats(res.users, null, true, true);
 
                             TLRPC.TL_messageService message = new TLRPC.TL_messageService();
-                            message.flags = TLRPC.MESSAGE_FLAG_UNREAD | TLRPC.MESSAGE_FLAG_HAS_FROM_ID | TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
+                            message.media_unread = true;
+                            message.unread = true;
+                            message.flags = TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
+                            if (chat.megagroup) {
+                                message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                            }
                             message.local_id = message.id = UserConfig.getNewMessageId();
-                            message.date = ConnectionsManager.getInstance().getCurrentTime();
-                            message.from_id = -chat_id;
+                            message.date = res.participant.date;
+                            message.action = new TLRPC.TL_messageActionChatAddUser();
+                            if (chat.megagroup) {
+                                message.from_id = res.participant.inviter_id;
+                                message.action.users.add(UserConfig.getClientUserId());
+                            } else {
+                                message.from_id = -chat_id;
+                                message.action.users.add(res.participant.inviter_id);
+                            }
                             message.to_id = new TLRPC.TL_peerChannel();
                             message.to_id.channel_id = chat_id;
                             message.dialog_id = -chat_id;
-                            message.action = new TLRPC.TL_messageActionChatAddUser();
-                            message.action.user_id = res.participant.inviter_id;
                             UserConfig.saveConfig(false);
 
                             final ArrayList<MessageObject> pushMessages = new ArrayList<>();
@@ -4028,7 +4654,7 @@ public void processUpdates(final TLRPC.Updates updates, boolean fromQueue) {
                     TLRPC.TL_message message = new TLRPC.TL_message();
                     message.id = updates.id;
                     if (updates instanceof TLRPC.TL_updateShortMessage) {
-                        if ((updates.flags & TLRPC.MESSAGE_FLAG_OUT) != 0) {
+                        if (updates.out) {
                             message.from_id = UserConfig.getClientUserId();
                         } else {
                             message.from_id = user_id;
@@ -4042,6 +4668,10 @@ public void processUpdates(final TLRPC.Updates updates, boolean fromQueue) {
                         message.to_id.chat_id = updates.chat_id;
                         message.dialog_id = -updates.chat_id;
                     }
+                    message.out = updates.out;
+                    message.unread = updates.unread;
+                    message.mentioned = updates.mentioned;
+                    message.media_unread = updates.media_unread;
                     message.entities = updates.entities;
                     message.message = updates.message;
                     message.date = updates.date;
@@ -4057,7 +4687,7 @@ public void processUpdates(final TLRPC.Updates updates, boolean fromQueue) {
                     ArrayList<TLRPC.Message> arr = new ArrayList<>();
                     arr.add(message);
                     if (updates instanceof TLRPC.TL_updateShortMessage) {
-                        final boolean printUpdate = (updates.flags & TLRPC.MESSAGE_FLAG_OUT) == 0 && updatePrintingUsersWithNewMessages(updates.user_id, objArr);
+                        final boolean printUpdate = !updates.out && updatePrintingUsersWithNewMessages(updates.user_id, objArr);
                         if (printUpdate) {
                             updatePrintingStrings();
                         }
@@ -4105,7 +4735,7 @@ public void run() {
                     MessagesStorage.getInstance().putMessages(arr, false, true, false, 0);
                 } else if (MessagesStorage.lastPtsValue != updates.pts) {
                     FileLog.e("tmessages", "need get diff short message, pts: " + MessagesStorage.lastPtsValue + " " + updates.pts + " count = " + updates.pts_count);
-                    if (gettingDifference || updatesStartWaitTimePts == 0 || updatesStartWaitTimePts + 1500 > System.currentTimeMillis()) {
+                    if (gettingDifference || updatesStartWaitTimePts == 0 || Math.abs(System.currentTimeMillis() - updatesStartWaitTimePts) <= 1500) {
                         if (updatesStartWaitTimePts == 0) {
                             updatesStartWaitTimePts = System.currentTimeMillis();
                         }
@@ -4161,7 +4791,7 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                         }
                     } else if (MessagesStorage.lastPtsValue != updatesNew.pts) {
                         FileLog.e("tmessages", update + " need get diff, pts: " + MessagesStorage.lastPtsValue + " " + updatesNew.pts + " count = " + updatesNew.pts_count);
-                        if (gettingDifference || updatesStartWaitTimePts == 0 || updatesStartWaitTimePts != 0 && updatesStartWaitTimePts + 1500 > System.currentTimeMillis()) {
+                        if (gettingDifference || updatesStartWaitTimePts == 0 || updatesStartWaitTimePts != 0 && Math.abs(System.currentTimeMillis() - updatesStartWaitTimePts) <= 1500) {
                             if (updatesStartWaitTimePts == 0) {
                                 updatesStartWaitTimePts = System.currentTimeMillis();
                             }
@@ -4192,7 +4822,7 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                         needReceivedQueue = true;
                     } else if (MessagesStorage.lastPtsValue != updatesNew.pts) {
                         FileLog.e("tmessages", update + " need get diff, qts: " + MessagesStorage.lastQtsValue + " " + updatesNew.pts);
-                        if (gettingDifference || updatesStartWaitTimeQts == 0 || updatesStartWaitTimeQts != 0 && updatesStartWaitTimeQts + 1500 > System.currentTimeMillis()) {
+                        if (gettingDifference || updatesStartWaitTimeQts == 0 || updatesStartWaitTimeQts != 0 && Math.abs(System.currentTimeMillis() - updatesStartWaitTimeQts) <= 1500) {
                             if (updatesStartWaitTimeQts == 0) {
                                 updatesStartWaitTimeQts = System.currentTimeMillis();
                             }
@@ -4202,7 +4832,7 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                             needGetDiff = true;
                         }
                     }
-                } else if(getUpdateType(update) == 2) {
+                } else if (getUpdateType(update) == 2) {
                     int channelId;
                     if (update instanceof TLRPC.TL_updateNewChannelMessage) {
                         channelId = ((TLRPC.TL_updateNewChannelMessage) update).message.to_id.channel_id;
@@ -4252,7 +4882,7 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                         if (gettingDifferenceChannel == null) {
                             gettingDifferenceChannel = false;
                         }
-                        if (gettingDifferenceChannel || updatesStartWaitTime == null || updatesStartWaitTime + 1500 > System.currentTimeMillis()) {
+                        if (gettingDifferenceChannel || updatesStartWaitTime == null || Math.abs(System.currentTimeMillis() - updatesStartWaitTime) <= 1500) {
                             if (updatesStartWaitTime == null) {
                                 updatesStartWaitTimeChannels.put(channelId, System.currentTimeMillis());
                             }
@@ -4299,7 +4929,7 @@ public int compare(TLRPC.Update lhs, TLRPC.Update rhs) {
                     FileLog.e("tmessages", "need get diff TL_updates, seq: " + MessagesStorage.lastSeqValue + " " + updates.seq);
                 }
 
-                if (gettingDifference || updatesStartWaitTimeSeq == 0 || updatesStartWaitTimeSeq + 1500 > System.currentTimeMillis()) {
+                if (gettingDifference || updatesStartWaitTimeSeq == 0 || Math.abs(System.currentTimeMillis() - updatesStartWaitTimeSeq) <= 1500) {
                     if (updatesStartWaitTimeSeq == 0) {
                         updatesStartWaitTimeSeq = System.currentTimeMillis();
                     }
@@ -4428,26 +5058,36 @@ public void run() {
 
         int interfaceUpdateMask = 0;
 
-        for (TLRPC.Update update : updates) {
+        for (int c = 0; c < updates.size(); c++) {
+            TLRPC.Update update = updates.get(c);
             if (update instanceof TLRPC.TL_updateNewMessage || update instanceof TLRPC.TL_updateNewChannelMessage) {
                 TLRPC.Message message;
                 if (update instanceof TLRPC.TL_updateNewMessage) {
                     message = ((TLRPC.TL_updateNewMessage) update).message;
                 } else {
                     message = ((TLRPC.TL_updateNewChannelMessage) update).message;
-                    if (message.to_id.channel_id != 0 && (message.flags & TLRPC.MESSAGE_FLAG_OUT) == 0) {
-                        message.flags |= TLRPC.MESSAGE_FLAG_UNREAD;
-                        if (message.from_id <= 0) {
-                            message.flags |= TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
-                        }
-                    }
                 }
                 if (checkForUsers) {
-                    if (message.to_id.chat_id != 0 && chatsDict.get(message.to_id.chat_id) == null && getChat(message.to_id.chat_id) == null) {
-                        return false;
-                    }
-                    if (message.to_id.channel_id != 0 && chatsDict.get(message.to_id.channel_id) == null && getChat(message.to_id.channel_id) == null) {
-                        return false;
+                    int chat_id = 0;
+                    if (message.to_id.channel_id != 0) {
+                        chat_id = message.to_id.channel_id;
+                    } else if (message.to_id.chat_id != 0) {
+                        chat_id = message.to_id.chat_id;
+                    }
+                    if (chat_id != 0) {
+                        TLRPC.Chat chat = chatsDict.get(chat_id);
+                        if (chat == null) {
+                            chat = getChat(chat_id);
+                        }
+                        if (chat == null) {
+                            return false;
+                        }
+                        if (chat.megagroup) {
+                            message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                        }
+                        if (chat.left) {
+                            continue;
+                        }
                     }
                     if (message.from_id > 0) {
                         TLRPC.User user = getUser(message.from_id);
@@ -4460,9 +5100,38 @@ public void run() {
                         }
                     }
                 }
+                if (message.action instanceof TLRPC.TL_messageActionChatDeleteUser) {
+                    TLRPC.User user = usersDict.get(message.action.user_id);
+                    if (user != null && user.bot) {
+                        message.reply_markup = new TLRPC.TL_replyKeyboardHide();
+                    } else if (message.action.user_id == UserConfig.getClientUserId()) {
+                        continue;
+                    }
+                } else if (message.action instanceof TLRPC.TL_messageActionChatMigrateTo || message.action instanceof TLRPC.TL_messageActionChannelCreate) {
+                    message.unread = false;
+                    message.media_unread = false;
+                }
+                if (update instanceof TLRPC.TL_updateNewChannelMessage) {
+                    if (message.to_id.channel_id != 0 && !message.out) {
+                        message.unread = true;
+                        if (message.from_id <= 0 || (message.flags & TLRPC.MESSAGE_FLAG_MEGAGROUP) != 0) {
+                            message.media_unread = true;
+                        }
+                    }
+
+                    long dialog_id = -update.channel_id;
+                    Integer value = dialogs_read_inbox_max.get(dialog_id);
+                    if (value == null) {
+                        value = MessagesStorage.getInstance().getChannelReadInboxMax(update.channel_id);
+                    }
+                    if (value >= message.id) {
+                        message.unread = false;
+                        message.media_unread = false;
+                    }
+                }
                 messagesArr.add(message);
                 ImageLoader.saveMessageThumbs(message);
-                MessageObject obj = new MessageObject(message, usersDict, true);
+                MessageObject obj = new MessageObject(message, usersDict, chatsDict, true);
                 if (obj.type == 11) {
                     interfaceUpdateMask |= UPDATE_MASK_CHAT_AVATAR;
                 } else if (obj.type == 10) {
@@ -4579,12 +5248,13 @@ public void run() {
                 interfaceUpdateMask |= UPDATE_MASK_PHONE;
                 updatesOnMainThread.add(update);
             } else if (update instanceof TLRPC.TL_updateContactRegistered) {
-                if (enableJoined && usersDict.containsKey(update.user_id)) {
+                if (enableJoined && usersDict.containsKey(update.user_id) && !MessagesStorage.getInstance().isDialogHasMessages(update.user_id)) {
                     TLRPC.TL_messageService newMessage = new TLRPC.TL_messageService();
                     newMessage.action = new TLRPC.TL_messageActionUserJoined();
                     newMessage.local_id = newMessage.id = UserConfig.getNewMessageId();
                     UserConfig.saveConfig(false);
-                    newMessage.flags = TLRPC.MESSAGE_FLAG_UNREAD | TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
+                    newMessage.unread = false;
+                    newMessage.flags = TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
                     newMessage.date = update.date;
                     newMessage.from_id = update.user_id;
                     newMessage.to_id = new TLRPC.TL_peerUser();
@@ -4592,14 +5262,13 @@ public void run() {
                     newMessage.dialog_id = update.user_id;
 
                     messagesArr.add(newMessage);
-                    MessageObject obj = new MessageObject(newMessage, usersDict, true);
+                    MessageObject obj = new MessageObject(newMessage, usersDict, chatsDict, true);
                     ArrayList<MessageObject> arr = messages.get(newMessage.dialog_id);
                     if (arr == null) {
                         arr = new ArrayList<>();
                         messages.put(newMessage.dialog_id, arr);
                     }
                     arr.add(obj);
-                    pushMessages.add(obj);
                 }
             } else if (update instanceof TLRPC.TL_updateContactLink) {
                 if (update.my_link instanceof TLRPC.TL_contactLinkContact) {
@@ -4632,7 +5301,8 @@ public void run() {
                 newMessage.action.address = update.location;
                 newMessage.local_id = newMessage.id = UserConfig.getNewMessageId();
                 UserConfig.saveConfig(false);
-                newMessage.flags = TLRPC.MESSAGE_FLAG_UNREAD | TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
+                newMessage.unread = true;
+                newMessage.flags = TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
                 newMessage.date = update.date;
                 newMessage.from_id = 777000;
                 newMessage.to_id = new TLRPC.TL_peerUser();
@@ -4640,7 +5310,7 @@ public void run() {
                 newMessage.dialog_id = 777000;
 
                 messagesArr.add(newMessage);
-                MessageObject obj = new MessageObject(newMessage, usersDict, true);
+                MessageObject obj = new MessageObject(newMessage, usersDict, chatsDict, true);
                 ArrayList<MessageObject> arr = messages.get(newMessage.dialog_id);
                 if (arr == null) {
                     arr = new ArrayList<>();
@@ -4663,7 +5333,7 @@ public void run() {
                     for (TLRPC.Message message : decryptedMessages) {
                         ImageLoader.saveMessageThumbs(message);
                         messagesArr.add(message);
-                        MessageObject obj = new MessageObject(message, usersDict, true);
+                        MessageObject obj = new MessageObject(message, usersDict, chatsDict, true);
                         arr.add(obj);
                         pushMessages.add(obj);
                     }
@@ -4701,9 +5371,9 @@ public void run() {
                 markAsReadEncrypted.put(update.chat_id, Math.max(update.max_date, update.date));
                 tasks.add((TLRPC.TL_updateEncryptedMessagesRead) update);
             } else if (update instanceof TLRPC.TL_updateChatParticipantAdd) {
-                MessagesStorage.getInstance().updateChatInfo(update.chat_id, update.user_id, false, update.inviter_id, update.version);
+                MessagesStorage.getInstance().updateChatInfo(update.chat_id, update.user_id, 0, update.inviter_id, update.version);
             } else if (update instanceof TLRPC.TL_updateChatParticipantDelete) {
-                MessagesStorage.getInstance().updateChatInfo(update.chat_id, update.user_id, true, 0, update.version);
+                MessagesStorage.getInstance().updateChatInfo(update.chat_id, update.user_id, 1, 0, update.version);
             } else if (update instanceof TLRPC.TL_updateDcOptions) {
                 ConnectionsManager.getInstance().updateDcSettings();
             } else if (update instanceof TLRPC.TL_updateEncryption) {
@@ -4738,10 +5408,15 @@ public void run() {
             } else if (update instanceof TLRPC.TL_updateNotifySettings) {
                 updatesOnMainThread.add(update);
             } else if (update instanceof TLRPC.TL_updateServiceNotification) {
+                TLRPC.TL_updateServiceNotification notification = (TLRPC.TL_updateServiceNotification) update;
+                if (notification.popup && notification.message != null && notification.message.length() > 0) {
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.needShowAlert, 2, notification.message);
+                }
                 TLRPC.TL_message newMessage = new TLRPC.TL_message();
                 newMessage.local_id = newMessage.id = UserConfig.getNewMessageId();
                 UserConfig.saveConfig(false);
-                newMessage.flags = TLRPC.MESSAGE_FLAG_UNREAD | TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
+                newMessage.unread = true;
+                newMessage.flags = TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
                 newMessage.date = ConnectionsManager.getInstance().getCurrentTime();
                 newMessage.from_id = 777000;
                 newMessage.to_id = new TLRPC.TL_peerUser();
@@ -4749,10 +5424,10 @@ public void run() {
                 newMessage.dialog_id = 777000;
                 newMessage.media = update.media;
                 newMessage.flags |= TLRPC.MESSAGE_FLAG_HAS_MEDIA;
-                newMessage.message = ((TLRPC.TL_updateServiceNotification) update).message;
+                newMessage.message = notification.message;
 
                 messagesArr.add(newMessage);
-                MessageObject obj = new MessageObject(newMessage, usersDict, true);
+                MessageObject obj = new MessageObject(newMessage, usersDict, chatsDict, true);
                 ArrayList<MessageObject> arr = messages.get(newMessage.dialog_id);
                 if (arr == null) {
                     arr = new ArrayList<>();
@@ -4777,6 +5452,13 @@ public void run() {
                 long message_id = update.max_id;
                 message_id |= ((long) update.channel_id) << 32;
                 markAsReadMessagesInbox.put(-update.channel_id, message_id);
+
+                long dialog_id = -update.channel_id;
+                Integer value = dialogs_read_inbox_max.get(dialog_id);
+                if (value == null) {
+                    value = MessagesStorage.getInstance().getChannelReadInboxMax(update.channel_id);
+                }
+                dialogs_read_inbox_max.put(dialog_id, Math.max(value, update.max_id));
             } else if (update instanceof TLRPC.TL_updateDeleteChannelMessages) {
                 ArrayList<Integer> arrayList = deletedMessages.get(update.channel_id);
                 if (arrayList == null) {
@@ -4793,6 +5475,16 @@ public void run() {
                     channelViews.put(update.channel_id, array);
                 }
                 array.put(update.id, update.views);
+            } else if (update instanceof TLRPC.TL_updateChatParticipantAdmin) {
+                MessagesStorage.getInstance().updateChatInfo(update.chat_id, update.user_id, 2, update.is_admin ? 1 : 0, update.version);
+            } else if (update instanceof TLRPC.TL_updateChatAdmins) {
+                updatesOnMainThread.add(update);
+            } else if (update instanceof TLRPC.TL_updateStickerSets) {
+                updatesOnMainThread.add(update);
+            } else if (update instanceof TLRPC.TL_updateStickerSetsOrder) {
+                updatesOnMainThread.add(update);
+            } else if (update instanceof TLRPC.TL_updateNewStickerSet) {
+                updatesOnMainThread.add(update);
             }
         }
         if (!messages.isEmpty()) {
@@ -4831,15 +5523,6 @@ public void run() {
         }
 
         if (!messagesArr.isEmpty()) {
-            for (int a = 0; a < messagesArr.size(); a++) {
-                TLRPC.Message message = messagesArr.get(a);
-                if (message.action instanceof TLRPC.TL_messageActionChatDeleteUser) {
-                    TLRPC.User user = usersDict.get(message.action.user_id);
-                    if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0) {
-                        message.reply_markup = new TLRPC.TL_replyKeyboardHide();
-                    }
-                }
-            }
             MessagesStorage.getInstance().putMessages(messagesArr, true, true, false, MediaController.getInstance().getAutodownloadMask());
         }
 
@@ -4847,7 +5530,7 @@ public void run() {
             MessagesStorage.getInstance().putChannelViews(channelViews, true);
         }
         if (channelsGroups.size() != 0) {
-            MessagesStorage.getInstance().applyNewChannelsGroups(channelsGroups);
+            //MessagesStorage.getInstance().applyNewChannelsGroups(channelsGroups); TODO
         }
 
         AndroidUtilities.runOnUIThread(new Runnable() {
@@ -4859,7 +5542,8 @@ public void run() {
                     ArrayList<TLRPC.User> dbUsers = new ArrayList<>();
                     ArrayList<TLRPC.User> dbUsersStatus = new ArrayList<>();
                     SharedPreferences.Editor editor = null;
-                    for (TLRPC.Update update : updatesOnMainThread) {
+                    for (int a = 0; a < updatesOnMainThread.size(); a++) {
+                        final TLRPC.Update update = updatesOnMainThread.get(a);
                         final TLRPC.User toDbUser = new TLRPC.User();
                         toDbUser.id = update.user_id;
                         final TLRPC.User currentUser = getUser(update.user_id);
@@ -4956,6 +5640,7 @@ public void run() {
                                         }
                                     }
                                     MessagesStorage.getInstance().setDialogFlags(dialog_id, ((long) until << 32) | 1);
+                                    NotificationsController.getInstance().removeNotificationsForDialog(dialog_id);
                                 } else {
                                     if (dialog != null) {
                                         dialog.notify_settings.mute_until = 0;
@@ -4967,11 +5652,26 @@ public void run() {
                         } else if (update instanceof TLRPC.TL_updateChannel) {
                             TLRPC.Dialog dialog = dialogs_dict.get(-(long) update.channel_id);
                             TLRPC.Chat chat = getChat(update.channel_id);
-                            if (dialog == null && chat instanceof TLRPC.TL_channel && (chat.flags & TLRPC.CHAT_FLAG_USER_LEFT) == 0) {
-                                getChannelDifference(update.channel_id, true);
+                            if (dialog == null && chat instanceof TLRPC.TL_channel && !chat.left) {
+                                Utilities.stageQueue.postRunnable(new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        getChannelDifference(update.channel_id, 1);
+                                    }
+                                });
+                            } else if (chat.left && dialog != null) {
+                                deleteDialog(dialog.id, 0);
                             }
                             updateMask |= UPDATE_MASK_CHANNEL;
                             loadFullChat(update.channel_id, 0, true);
+                        } else if (update instanceof TLRPC.TL_updateChatAdmins) {
+                            updateMask |= UPDATE_MASK_CHAT_ADMINS;
+                        } else if (update instanceof TLRPC.TL_updateStickerSets) {
+                            StickersQuery.loadStickers(false, true);
+                        } else if (update instanceof TLRPC.TL_updateStickerSetsOrder) {
+                            StickersQuery.reorderStickers(update.order);
+                        } else if (update instanceof TLRPC.TL_updateNewStickerSet) {
+                            StickersQuery.addNewStickerSet(update.stickerset);
                         }
                     }
                     if (editor != null) {
@@ -5071,6 +5771,9 @@ public void run() {
                             for (int a = 0; a < deletedMessages.size(); a++) {
                                 int key = deletedMessages.keyAt(a);
                                 ArrayList<Integer> arrayList = deletedMessages.get(key);
+                                if (arrayList == null) {
+                                    continue;
+                                }
                                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.messagesDeleted, arrayList, key);
                                 if (key == 0) {
                                     for (int b = 0; b < arrayList.size(); b++) {
@@ -5092,6 +5795,7 @@ public void run() {
                                     }
                                 }
                             }
+                            NotificationsController.getInstance().removeDeletedMessagesFromNotifications(deletedMessages);
                         }
                         if (updateMask != 0) {
                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.updateInterfaces, updateMask);
@@ -5105,7 +5809,7 @@ public void run() {
             MessagesStorage.getInstance().putWebPages(webPages);
         }
         if (markAsReadMessagesInbox.size() != 0 || markAsReadMessagesOutbox.size() != 0 || !markAsReadEncrypted.isEmpty()) {
-            if (markAsReadMessagesInbox.size() != 0 || markAsReadMessagesOutbox.size() != 0) {
+            if (markAsReadMessagesInbox.size() != 0) {
                 MessagesStorage.getInstance().updateDialogsWithReadMessages(markAsReadMessagesInbox, true);
             }
             MessagesStorage.getInstance().markMessagesAsRead(markAsReadMessagesInbox, markAsReadMessagesOutbox, markAsReadEncrypted, true);
@@ -5200,7 +5904,7 @@ protected void updateInterfaceWithMessages(final long uid, final ArrayList<Messa
         for (int a = 0; a < messages.size(); a++) {
             MessageObject message = messages.get(a);
             if (lastMessage == null || (!isEncryptedChat && message.getId() > lastMessage.getId() || (isEncryptedChat || message.getId() < 0 && lastMessage.getId() < 0) && message.getId() < lastMessage.getId()) || message.messageOwner.date > lastMessage.messageOwner.date) {
-                if (message.messageOwner.to_id.channel_id == 0 || message.isImportant()) {
+                if (message.messageOwner.to_id.channel_id == 0 || message.isMegagroup() || message.isImportant()) {
                     lastMessage = message;
                 }
                 if (message.messageOwner.to_id.channel_id != 0) {
@@ -5215,13 +5919,29 @@ protected void updateInterfaceWithMessages(final long uid, final ArrayList<Messa
             return;
         }
         TLRPC.Dialog dialog = dialogs_dict.get(uid);
+        if (lastMessage.messageOwner.action instanceof TLRPC.TL_messageActionChatMigrateTo) {
+            if (dialog != null) {
+                dialogs.remove(dialog);
+                dialogsServerOnly.remove(dialog);
+                dialogsGroupsOnly.remove(dialog);
+                dialogs_dict.remove(dialog.id);
+                dialogs_read_inbox_max.remove(dialog.id);
+                nextDialogsCacheOffset--;
+                dialogMessage.remove(dialog.id);
+                dialogMessagesByIds.remove(dialog.top_message);
+                dialog.top_message = 0;
+                NotificationsController.getInstance().removeNotificationsForDialog(dialog.id);
+                NotificationCenter.getInstance().postNotificationName(NotificationCenter.needReloadRecentDialogsSearch);
+            }
+            return;
+        }
 
         boolean changed = false;
 
         if (dialog == null) {
             if (!isBroadcast) {
                 TLRPC.Chat chat = getChat(channelId);
-                if (chat != null && (chat.flags & TLRPC.CHAT_FLAG_USER_LEFT) != 0) {
+                if (chat != null && chat.left) {
                     return;
                 }
                 if (!ChatObject.isChannel(chat)) {
@@ -5243,23 +5963,9 @@ protected void updateInterfaceWithMessages(final long uid, final ArrayList<Messa
                 changed = true;
             }
         } else {
-            boolean change = false;
-            if (dialog.top_message > 0 && lastMessage.getId() > 0 && lastMessage.getId() > dialog.top_message ||
-                    dialog.top_message < 0 && lastMessage.getId() < 0 && lastMessage.getId() < dialog.top_message) {
-                change = true;
-            } else {
-                MessageObject currentDialogMessage = dialogMessage.get(uid);
-                if (currentDialogMessage != null) {
-                    if (currentDialogMessage.isSending() && lastMessage.isSending()) {
-                        change = true;
-                    } else if (dialog.last_message_date < lastMessage.messageOwner.date || dialog.last_message_date == lastMessage.messageOwner.date && lastMessage.isSending()) {
-                        change = true;
-                    }
-                } else {
-                    change = true;
-                }
-            }
-            if (change) {
+            if ((dialog.top_message > 0 && lastMessage.getId() > 0 && lastMessage.getId() > dialog.top_message) ||
+                    (dialog.top_message < 0 && lastMessage.getId() < 0 && lastMessage.getId() < dialog.top_message) ||
+                    !dialogMessage.containsKey(uid) || dialog.top_message < 0 || dialog.last_message_date <= lastMessage.messageOwner.date) {
                 dialog.top_message = lastMessage.getId();
                 if (!isBroadcast) {
                     dialog.last_message_date = lastMessage.messageOwner.date;
@@ -5275,8 +5981,6 @@ protected void updateInterfaceWithMessages(final long uid, final ArrayList<Messa
         if (changed) {
             dialogsServerOnly.clear();
             dialogsGroupsOnly.clear();
-            currentDialogsCount = 0;
-            currentChannelDialogsCount = 0;
             Collections.sort(dialogs, new Comparator<TLRPC.Dialog>() {
                 @Override
                 public int compare(TLRPC.Dialog tl_dialog, TLRPC.Dialog tl_dialog2) {
@@ -5289,7 +5993,8 @@ public int compare(TLRPC.Dialog tl_dialog, TLRPC.Dialog tl_dialog2) {
                     }
                 }
             });
-            for (TLRPC.Dialog d : dialogs) {
+            for (int a = 0; a < dialogs.size(); a++) {
+                TLRPC.Dialog d = dialogs.get(a);
                 int high_id = (int) (d.id >> 32);
                 if ((int) d.id != 0 && high_id != 1) {
                     dialogsServerOnly.add(d);
@@ -5297,9 +6002,12 @@ public int compare(TLRPC.Dialog tl_dialog, TLRPC.Dialog tl_dialog2) {
                         if (d.id < 0) {
                             dialogsGroupsOnly.add(d);
                         }
-                        currentDialogsCount++;
                     } else if (d instanceof TLRPC.TL_dialogChannel) {
-                        currentChannelDialogsCount++;
+                        int lower_id = (int) d.id;
+                        TLRPC.Chat chat = getChat(-lower_id);
+                        if (chat != null && (chat.megagroup && chat.editor || chat.creator)) {
+                            dialogsGroupsOnly.add(d);
+                        }
                     }
                 }
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MessagesStorage.java b/TMessagesProj/src/main/java/org/telegram/messenger/MessagesStorage.java
index cf6b51926..560328f2c 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MessagesStorage.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MessagesStorage.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -80,7 +80,7 @@ public DispatchQueue getStorageQueue() {
     }
 
     public void openDatabase() {
-        cacheFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "cache4.db");
+        cacheFile = new File(ApplicationLoader.getFilesDirFixed(), "cache4.db");
 
         boolean createTable = false;
         //cacheFile.delete();
@@ -146,6 +146,7 @@ public void openDatabase() {
                 database.executeFast("CREATE TABLE chats(uid INTEGER PRIMARY KEY, name TEXT, data BLOB)").stepThis().dispose();
                 database.executeFast("CREATE TABLE enc_chats(uid INTEGER PRIMARY KEY, user INTEGER, name TEXT, data BLOB, g BLOB, authkey BLOB, ttl INTEGER, layer INTEGER, seq_in INTEGER, seq_out INTEGER, use_count INTEGER, exchange_id INTEGER, key_date INTEGER, fprint INTEGER, fauthkey BLOB, khash BLOB)").stepThis().dispose();
                 database.executeFast("CREATE TABLE chat_settings_v2(uid INTEGER PRIMARY KEY, info BLOB)").stepThis().dispose();
+                database.executeFast("CREATE TABLE channel_users_v2(did INTEGER, uid INTEGER, date INTEGER, data BLOB, PRIMARY KEY(did, uid))").stepThis().dispose();
                 database.executeFast("CREATE TABLE contacts(uid INTEGER PRIMARY KEY, mutual INTEGER)").stepThis().dispose();
                 database.executeFast("CREATE TABLE pending_read(uid INTEGER PRIMARY KEY, max_id INTEGER)").stepThis().dispose();
                 database.executeFast("CREATE TABLE wallpapers(uid INTEGER PRIMARY KEY, data BLOB)").stepThis().dispose();
@@ -164,7 +165,7 @@ public void openDatabase() {
                 database.executeFast("CREATE TABLE bot_info(uid INTEGER PRIMARY KEY, info BLOB)").stepThis().dispose();
 
                 //version
-                database.executeFast("PRAGMA user_version = 23").stepThis().dispose();
+                database.executeFast("PRAGMA user_version = 27").stepThis().dispose();
 
                 //database.executeFast("CREATE TABLE secret_holes(uid INTEGER, seq_in INTEGER, seq_out INTEGER, data BLOB, PRIMARY KEY (uid, seq_in, seq_out));").stepThis().dispose();
                 //database.executeFast("CREATE TABLE attach_data(uid INTEGER, id INTEGER, data BLOB, PRIMARY KEY (uid, id))").stepThis().dispose();
@@ -198,7 +199,7 @@ public void openDatabase() {
                     }
                 }
                 int version = database.executeInt("PRAGMA user_version");
-                if (version < 23) {
+                if (version < 27) {
                     updateDbToLastVersion(version);
                 }
             }
@@ -460,7 +461,22 @@ public void run() {
                         database.executeFast("CREATE TABLE IF NOT EXISTS media_holes_v2(uid INTEGER, type INTEGER, start INTEGER, end INTEGER, PRIMARY KEY(uid, type, start));").stepThis().dispose();
                         database.executeFast("CREATE INDEX IF NOT EXISTS uid_end_media_holes_v2 ON media_holes_v2(uid, type, end);").stepThis().dispose();
                         database.executeFast("PRAGMA user_version = 23").stepThis().dispose();
-                        //version = 23;
+                        version = 23;
+                    }
+                    if (version == 23) {
+                        database.executeFast("DELETE FROM sent_files_v2 WHERE 1").stepThis().dispose();
+                        database.executeFast("PRAGMA user_version = 24").stepThis().dispose();
+                        version = 24;
+                    }
+                    if (version == 24) {
+                        database.executeFast("DELETE FROM media_holes_v2 WHERE uid != 0 AND type >= 0 AND start IN (0, 1)").stepThis().dispose();
+                        database.executeFast("PRAGMA user_version = 25").stepThis().dispose();
+                        version = 25;
+                    }
+                    if (version == 25 || version == 26) {
+                        database.executeFast("CREATE TABLE IF NOT EXISTS channel_users_v2(did INTEGER, uid INTEGER, date INTEGER, data BLOB, PRIMARY KEY(did, uid))").stepThis().dispose();
+                        database.executeFast("PRAGMA user_version = 27").stepThis().dispose();
+                        //version = 27;
                     }
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -613,8 +629,8 @@ public void run() {
                     final ArrayList<TLRPC.Chat> chats = new ArrayList<>();
                     final ArrayList<TLRPC.EncryptedChat> encryptedChats = new ArrayList<>();
                     if (ids.length() > 0) {
-                        ArrayList<Integer> userIds = new ArrayList<>();
-                        ArrayList<Integer> chatIds = new ArrayList<>();
+                        ArrayList<Integer> usersToLoad = new ArrayList<>();
+                        ArrayList<Integer> chatsToLoad = new ArrayList<>();
                         ArrayList<Integer> encryptedChatIds = new ArrayList<>();
 
                         cursor = database.queryFinalized("SELECT read_state, data, send_state, mid, date, uid FROM messages WHERE uid IN (" + ids.toString() + ") AND out = 0 AND read_state IN(0,2) ORDER BY date DESC LIMIT 50");
@@ -633,12 +649,12 @@ public void run() {
 
                                 if (lower_id != 0) {
                                     if (lower_id < 0) {
-                                        if (!chatIds.contains(-lower_id)) {
-                                            chatIds.add(-lower_id);
+                                        if (!chatsToLoad.contains(-lower_id)) {
+                                            chatsToLoad.add(-lower_id);
                                         }
                                     } else {
-                                        if (!userIds.contains(lower_id)) {
-                                            userIds.add(lower_id);
+                                        if (!usersToLoad.contains(lower_id)) {
+                                            usersToLoad.add(lower_id);
                                         }
                                     }
                                 } else {
@@ -646,28 +662,7 @@ public void run() {
                                         encryptedChatIds.add(high_id);
                                     }
                                 }
-
-                                if (!userIds.contains(message.from_id)) {
-                                    userIds.add(message.from_id);
-                                }
-                                if (message.action != null && message.action.user_id != 0 && !userIds.contains(message.action.user_id)) {
-                                    userIds.add(message.action.user_id);
-                                }
-                                if (message.media != null && message.media.user_id != 0 && !userIds.contains(message.media.user_id)) {
-                                    userIds.add(message.media.user_id);
-                                }
-                                if (message.media != null && message.media.audio != null && message.media.audio.user_id != 0 && !userIds.contains(message.media.audio.user_id)) {
-                                    userIds.add(message.media.audio.user_id);
-                                }
-                                if (message.fwd_from_id instanceof TLRPC.TL_peerUser) {
-                                    if (!userIds.contains(message.fwd_from_id.user_id)) {
-                                        userIds.add(message.fwd_from_id.user_id);
-                                    }
-                                } else if (message.fwd_from_id instanceof TLRPC.TL_peerChannel) {
-                                    if (!chatIds.contains(message.fwd_from_id.channel_id)) {
-                                        chatIds.add(message.fwd_from_id.channel_id);
-                                    }
-                                }
+                                addUsersAndChatsFromMessage(message, usersToLoad, chatsToLoad);
                                 message.send_state = cursor.intValue(2);
                                 if (message.to_id.channel_id == 0 && !MessageObject.isUnread(message) && lower_id != 0 || message.id > 0) {
                                     message.send_state = 0;
@@ -681,15 +676,33 @@ public void run() {
                         cursor.dispose();
 
                         if (!encryptedChatIds.isEmpty()) {
-                            getEncryptedChatsInternal(TextUtils.join(",", encryptedChatIds), encryptedChats, userIds);
+                            getEncryptedChatsInternal(TextUtils.join(",", encryptedChatIds), encryptedChats, usersToLoad);
                         }
 
-                        if (!userIds.isEmpty()) {
-                            getUsersInternal(TextUtils.join(",", userIds), users);
+                        if (!usersToLoad.isEmpty()) {
+                            getUsersInternal(TextUtils.join(",", usersToLoad), users);
                         }
 
-                        if (!chatIds.isEmpty()) {
-                            getChatsInternal(TextUtils.join(",", chatIds), chats);
+                        if (!chatsToLoad.isEmpty()) {
+                            getChatsInternal(TextUtils.join(",", chatsToLoad), chats);
+                            for (int a = 0; a < chats.size(); a++) {
+                                TLRPC.Chat chat = chats.get(a);
+                                if (chat != null && (chat.left || chat.migrated_to != null)) {
+                                    long did = -chat.id;
+                                    database.executeFast("UPDATE dialogs SET unread_count = 0, unread_count_i = 0 WHERE did = " + did).stepThis().dispose();
+                                    database.executeFast(String.format(Locale.US, "UPDATE messages SET read_state = 3 WHERE uid = %d AND mid > 0 AND read_state IN(0,2) AND out = 0", did)).stepThis().dispose();
+                                    chats.remove(a);
+                                    a--;
+                                    pushDialogs.remove((long) -chat.id);
+                                    for (int b = 0; b < messages.size(); b++) {
+                                        TLRPC.Message message = messages.get(b);
+                                        if (message.dialog_id == -chat.id) {
+                                            messages.remove(b);
+                                            b--;
+                                        }
+                                    }
+                                }
+                            }
                         }
                     }
                     Collections.reverse(messages);
@@ -952,30 +965,12 @@ public void run() {
         });
     }
 
-    public void deleteDialog(final long did, final boolean messagesOnly) {
+    public void deleteDialog(final long did, final int messagesOnly) {
         storageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
                 try {
-                    if (!messagesOnly) {
-                        database.executeFast("DELETE FROM dialogs WHERE did = " + did).stepThis().dispose();
-                        database.executeFast("DELETE FROM chat_settings_v2 WHERE uid = " + did).stepThis().dispose();
-                        database.executeFast("DELETE FROM search_recent WHERE did = " + did).stepThis().dispose();
-                        int lower_id = (int)did;
-                        int high_id = (int)(did >> 32);
-                        if (lower_id != 0) {
-                            if (high_id == 1) {
-                                database.executeFast("DELETE FROM chats WHERE uid = " + lower_id).stepThis().dispose();
-                            } else if (lower_id < 0) {
-                                //database.executeFast("DELETE FROM chats WHERE uid = " + (-lower_id)).stepThis().dispose();
-                            }
-                        } else {
-                            database.executeFast("DELETE FROM enc_chats WHERE uid = " + high_id).stepThis().dispose();
-                            //database.executeFast("DELETE FROM secret_holes WHERE uid = " + high_id).stepThis().dispose();
-                        }
-                    }
-
-                    if ((int) did == 0) {
+                    if ((int) did == 0 || messagesOnly == 2) {
                         SQLiteCursor cursor = database.queryFinalized("SELECT data FROM messages WHERE uid = " + did);
                         ArrayList<File> filesToDelete = new ArrayList<>();
                         try {
@@ -1024,11 +1019,77 @@ public void run() {
                             FileLog.e("tmessages", e);
                         }
                         cursor.dispose();
-                        FileLoader.getInstance().deleteFiles(filesToDelete);
+                        FileLoader.getInstance().deleteFiles(filesToDelete, messagesOnly);
                     }
 
-                    database.executeFast("UPDATE dialogs SET unread_count = 0 WHERE did = " + did).stepThis().dispose();
+                    if (messagesOnly == 0) {
+                        database.executeFast("DELETE FROM dialogs WHERE did = " + did).stepThis().dispose();
+                        database.executeFast("DELETE FROM chat_settings_v2 WHERE uid = " + did).stepThis().dispose();
+                        database.executeFast("DELETE FROM channel_users_v2 WHERE did = " + did).stepThis().dispose();
+                        database.executeFast("DELETE FROM search_recent WHERE did = " + did).stepThis().dispose();
+                        int lower_id = (int)did;
+                        int high_id = (int)(did >> 32);
+                        if (lower_id != 0) {
+                            if (high_id == 1) {
+                                database.executeFast("DELETE FROM chats WHERE uid = " + lower_id).stepThis().dispose();
+                            } else if (lower_id < 0) {
+                                //database.executeFast("DELETE FROM chats WHERE uid = " + (-lower_id)).stepThis().dispose();
+                            }
+                        } else {
+                            database.executeFast("DELETE FROM enc_chats WHERE uid = " + high_id).stepThis().dispose();
+                            //database.executeFast("DELETE FROM secret_holes WHERE uid = " + high_id).stepThis().dispose();
+                        }
+                    } else if (messagesOnly == 2) {
+                        SQLiteCursor cursor = database.queryFinalized("SELECT last_mid_i, last_mid FROM dialogs WHERE did = " + did);
+                        ArrayList<TLRPC.Message> arrayList = new ArrayList<>();
+                        if (cursor.next()) {
+                            long last_mid_i = cursor.longValue(0);
+                            long last_mid = cursor.longValue(1);
+                            SQLiteCursor cursor2 = database.queryFinalized("SELECT data FROM messages WHERE uid = " + did + " AND mid IN (" + last_mid_i + "," + last_mid + ")");
+                            try {
+                                while (cursor2.next()) {
+                                    NativeByteBuffer data = new NativeByteBuffer(cursor2.byteArrayLength(0));
+                                    if (data != null && cursor2.byteBufferValue(0, data) != 0) {
+                                        TLRPC.Message message = TLRPC.Message.TLdeserialize(data, data.readInt32(false), false);
+                                        if (message == null) {
+                                            continue;
+                                        }
+                                        arrayList.add(message);
+                                    }
+                                    data.reuse();
+                                }
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                            cursor2.dispose();
+
+                            database.executeFast("DELETE FROM messages WHERE uid = " + did + " AND mid != " + last_mid_i + " AND mid != " + last_mid).stepThis().dispose();
+                            database.executeFast("DELETE FROM channel_group WHERE uid = " + did).stepThis().dispose();
+                            database.executeFast("DELETE FROM messages_holes WHERE uid = " + did).stepThis().dispose();
+                            database.executeFast("DELETE FROM messages_imp_holes WHERE uid = " + did).stepThis().dispose();
+                            database.executeFast("DELETE FROM bot_keyboard WHERE uid = " + did).stepThis().dispose();
+                            database.executeFast("DELETE FROM media_counts_v2 WHERE uid = " + did).stepThis().dispose();
+                            database.executeFast("DELETE FROM media_v2 WHERE uid = " + did).stepThis().dispose();
+                            database.executeFast("DELETE FROM media_holes_v2 WHERE uid = " + did).stepThis().dispose();
+                            BotQuery.clearBotKeyboard(did, null);
+
+                            SQLitePreparedStatement state5 = database.executeFast("REPLACE INTO messages_holes VALUES(?, ?, ?)");
+                            SQLitePreparedStatement state6 = database.executeFast("REPLACE INTO media_holes_v2 VALUES(?, ?, ?, ?)");
+                            SQLitePreparedStatement state7 = database.executeFast("REPLACE INTO messages_imp_holes VALUES(?, ?, ?)");
+                            SQLitePreparedStatement state8 = database.executeFast("REPLACE INTO channel_group VALUES(?, ?, ?, ?)");
+                            createFirstHoles(did, state5, state6, state7, state8, arrayList);
+                            state5.dispose();
+                            state6.dispose();
+                            state7.dispose();
+                            state8.dispose();
+                        }
+                        cursor.dispose();
+                        return;
+                    }
+
+                    database.executeFast("UPDATE dialogs SET unread_count = 0, unread_count_i = 0 WHERE did = " + did).stepThis().dispose();
                     database.executeFast("DELETE FROM messages WHERE uid = " + did).stepThis().dispose();
+                    database.executeFast("DELETE FROM channel_group WHERE uid = " + did).stepThis().dispose();
                     database.executeFast("DELETE FROM bot_keyboard WHERE uid = " + did).stepThis().dispose();
                     database.executeFast("DELETE FROM media_counts_v2 WHERE uid = " + did).stepThis().dispose();
                     database.executeFast("DELETE FROM media_v2 WHERE uid = " + did).stepThis().dispose();
@@ -1235,7 +1296,6 @@ public void run() {
     private void updateDialogsWithReadMessagesInternal(final ArrayList<Integer> messages, final SparseArray<Long> inbox) {
         try {
             HashMap<Long, Integer> dialogsToUpdate = new HashMap<>();
-            StringBuilder dialogsToReload = new StringBuilder();
 
             if (messages != null && !messages.isEmpty()) {
                 String ids = TextUtils.join(",", messages);
@@ -1253,10 +1313,6 @@ private void updateDialogsWithReadMessagesInternal(final ArrayList<Integer> mess
                     Integer currentCount = dialogsToUpdate.get(uid);
                     if (currentCount == null) {
                         dialogsToUpdate.put(uid, 1);
-                        if (dialogsToReload.length() != 0) {
-                            dialogsToReload.append(",");
-                        }
-                        dialogsToReload.append(uid);
                     } else {
                         dialogsToUpdate.put(uid, currentCount + 1);
                     }
@@ -1266,35 +1322,24 @@ private void updateDialogsWithReadMessagesInternal(final ArrayList<Integer> mess
                 for (int b = 0; b < inbox.size(); b++) {
                     int key = inbox.keyAt(b);
                     long messageId = inbox.get(key);
-                    SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT COUNT(mid) FROM messages WHERE uid = %d AND mid <= %d AND read_state IN(0,2) AND out = 0", key, messageId));
+                    SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT COUNT(mid) FROM messages WHERE uid = %d AND mid > %d AND read_state IN(0,2) AND out = 0", key, messageId));
                     if (cursor.next()) {
                         int count = cursor.intValue(0);
-                        if (count != 0) {
-                            dialogsToUpdate.put((long) key, count);
-                            if (dialogsToReload.length() != 0) {
-                                dialogsToReload.append(",");
-                            }
-                            dialogsToReload.append(key);
-                        }
+                        dialogsToUpdate.put((long) key, count);
                     }
                     cursor.dispose();
-                }
-            }
 
-            if (dialogsToReload.length() > 0) {
-                SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT did, unread_count FROM dialogs WHERE did IN(%s)", dialogsToReload.toString()));
-                while (cursor.next()) {
-                    long did = cursor.longValue(0);
-                    int count = cursor.intValue(1);
-                    Integer currentCount = dialogsToUpdate.get(did);
-                    if (currentCount != null) {
-                        dialogsToUpdate.put(did, Math.max(0, count - currentCount));
-                    } else {
-                        dialogsToUpdate.remove(did);
-                    }
+                    SQLitePreparedStatement state = database.executeFast("UPDATE dialogs SET inbox_max = max((SELECT inbox_max FROM dialogs WHERE did = ?), ?) WHERE did = ?");
+                    state.requery();
+                    state.bindLong(1, key);
+                    state.bindInteger(2, (int) messageId);
+                    state.bindLong(3, key);
+                    state.step();
+                    state.dispose();
                 }
-                cursor.dispose();
+            }
 
+            if (!dialogsToUpdate.isEmpty()) {
                 database.beginTransaction();
                 SQLitePreparedStatement state = database.executeFast("UPDATE dialogs SET unread_count = ? WHERE did = ?");
                 for (HashMap.Entry<Long, Integer> entry : dialogsToUpdate.entrySet()) {
@@ -1353,7 +1398,7 @@ public void run() {
                         AndroidUtilities.runOnUIThread(new Runnable() {
                             @Override
                             public void run() {
-                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, finalInfo);
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, finalInfo, 0, false);
                             }
                         });
 
@@ -1373,6 +1418,40 @@ public void run() {
         });
     }
 
+    public void updateChannelUsers(final int channel_id, final ArrayList<TLRPC.ChannelParticipant> participants) {
+        storageQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    long did = -channel_id;
+                    database.executeFast("DELETE FROM channel_users_v2 WHERE did = " + did).stepThis().dispose();
+                    database.beginTransaction();
+                    SQLitePreparedStatement state = database.executeFast("REPLACE INTO channel_users_v2 VALUES(?, ?, ?, ?)");
+                    NativeByteBuffer data;
+                    int date = (int) (System.currentTimeMillis() / 1000);
+                    for (int a = 0; a < participants.size(); a++) {
+                        TLRPC.ChannelParticipant participant = participants.get(a);
+                        state.requery();
+                        state.bindLong(1, did);
+                        state.bindInteger(2, participant.user_id);
+                        state.bindInteger(3, date);
+                        data = new NativeByteBuffer(participant.getObjectSize());
+                        participant.serializeToStream(data);
+                        state.bindByteBuffer(4, data);
+                        data.reuse();
+                        state.step();
+                        date--;
+                    }
+                    state.dispose();
+                    database.commitTransaction();
+                    loadChatInfo(channel_id, null, false, true);
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+    }
+
     public void updateChatInfo(final TLRPC.ChatFull info, final boolean ifExist) {
         storageQueue.postRunnable(new Runnable() {
             @Override
@@ -1430,7 +1509,7 @@ public void run() {
         });
     }
 
-    public void updateChatInfo(final int chat_id, final int user_id, final boolean deleted, final int invited_id, final int version) {
+    public void updateChatInfo(final int chat_id, final int user_id, final int what, final int invited_id, final int version) {
         storageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
@@ -1447,16 +1526,16 @@ public void run() {
                     }
                     cursor.dispose();
                     if (info instanceof TLRPC.TL_chatFull) {
-                        if (deleted) {
+                        if (what == 1) {
                             for (int a = 0; a < info.participants.participants.size(); a++) {
-                                TLRPC.TL_chatParticipant participant = info.participants.participants.get(a);
+                                TLRPC.ChatParticipant participant = info.participants.participants.get(a);
                                 if (participant.user_id == user_id) {
                                     info.participants.participants.remove(a);
                                     break;
                                 }
                             }
-                        } else {
-                            for (TLRPC.TL_chatParticipant part : info.participants.participants) {
+                        } else if (what == 0) {
+                            for (TLRPC.ChatParticipant part : info.participants.participants) {
                                 if (part.user_id == user_id) {
                                     return;
                                 }
@@ -1466,6 +1545,26 @@ public void run() {
                             participant.inviter_id = invited_id;
                             participant.date = ConnectionsManager.getInstance().getCurrentTime();
                             info.participants.participants.add(participant);
+                        } else if (what == 2) {
+                            for (int a = 0; a < info.participants.participants.size(); a++) {
+                                TLRPC.ChatParticipant participant = info.participants.participants.get(a);
+                                if (participant.user_id == user_id) {
+                                    TLRPC.ChatParticipant newParticipant;
+                                    if (invited_id == 1) {
+                                        newParticipant = new TLRPC.TL_chatParticipantAdmin();
+                                        newParticipant.user_id = participant.user_id;
+                                        newParticipant.date = participant.date;
+                                        newParticipant.inviter_id = participant.inviter_id;
+                                    } else {
+                                        newParticipant = new TLRPC.TL_chatParticipant();
+                                        newParticipant.user_id = participant.user_id;
+                                        newParticipant.date = participant.date;
+                                        newParticipant.inviter_id = participant.inviter_id;
+                                    }
+                                    info.participants.participants.set(a, newParticipant);
+                                    break;
+                                }
+                            }
                         }
                         info.participants.version = version;
 
@@ -1473,7 +1572,7 @@ public void run() {
                         AndroidUtilities.runOnUIThread(new Runnable() {
                             @Override
                             public void run() {
-                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, finalInfo);
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatInfoDidLoaded, finalInfo, 0, false);
                             }
                         });
 
@@ -1493,7 +1592,46 @@ public void run() {
         });
     }
 
-    public void loadChatInfo(final int chat_id, final Semaphore semaphore, final boolean force) {
+    public boolean isMigratedChat(final int chat_id) {
+        final Semaphore semaphore = new Semaphore(0);
+        final boolean result[] = new boolean[1];
+        storageQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    SQLiteCursor cursor = database.queryFinalized("SELECT info FROM chat_settings_v2 WHERE uid = " + chat_id);
+                    TLRPC.ChatFull info = null;
+                    ArrayList<TLRPC.User> loadedUsers = new ArrayList<>();
+                    if (cursor.next()) {
+                        NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(0));
+                        if (data != null && cursor.byteBufferValue(0, data) != 0) {
+                            info = TLRPC.ChatFull.TLdeserialize(data, data.readInt32(false), false);
+                        }
+                        data.reuse();
+                    }
+                    cursor.dispose();
+                    result[0] = info instanceof TLRPC.TL_channelFull && info.migrated_from_chat_id != 0;
+                    if (semaphore != null) {
+                        semaphore.release();
+                    }
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                } finally {
+                    if (semaphore != null) {
+                        semaphore.release();
+                    }
+                }
+            }
+        });
+        try {
+            semaphore.acquire();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return result[0];
+    }
+
+    public void loadChatInfo(final int chat_id, final Semaphore semaphore, final boolean force, final boolean byChannelUsers) {
         storageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
@@ -1513,7 +1651,7 @@ public void run() {
                     if (info instanceof TLRPC.TL_chatFull) {
                         StringBuilder usersToLoad = new StringBuilder();
                         for (int a = 0; a < info.participants.participants.size(); a++) {
-                            TLRPC.TL_chatParticipant c = info.participants.participants.get(a);
+                            TLRPC.ChatParticipant c = info.participants.participants.get(a);
                             if (usersToLoad.length() != 0) {
                                 usersToLoad.append(",");
                             }
@@ -1522,11 +1660,53 @@ public void run() {
                         if (usersToLoad.length() != 0) {
                             getUsersInternal(usersToLoad.toString(), loadedUsers);
                         }
+                    } else if (info instanceof TLRPC.TL_channelFull) {
+                        cursor = database.queryFinalized("SELECT us.data, us.status, cu.data, cu.date FROM channel_users_v2 as cu LEFT JOIN users as us ON us.uid = cu.uid WHERE cu.did = " + (-chat_id) + " ORDER BY cu.date DESC");
+                        info.participants = new TLRPC.TL_chatParticipants();
+                        while (cursor.next()) {
+                            try {
+                                NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(0));
+                                NativeByteBuffer data2 = new NativeByteBuffer(cursor.byteArrayLength(2));
+                                if (data != null && cursor.byteBufferValue(0, data) != 0 && data2 != null && cursor.byteBufferValue(2, data2) != 0) {
+                                    TLRPC.User user = TLRPC.User.TLdeserialize(data, data.readInt32(false), false);
+                                    TLRPC.ChannelParticipant participant = TLRPC.ChannelParticipant.TLdeserialize(data2, data2.readInt32(false), false);
+                                    if (user != null && participant != null) {
+                                        if (user.status != null) {
+                                            user.status.expires = cursor.intValue(1);
+                                        }
+                                        loadedUsers.add(user);
+                                        participant.date = cursor.intValue(3);
+                                        TLRPC.TL_chatChannelParticipant chatChannelParticipant = new TLRPC.TL_chatChannelParticipant();
+                                        chatChannelParticipant.user_id = participant.user_id;
+                                        chatChannelParticipant.date = participant.date;
+                                        chatChannelParticipant.inviter_id = participant.inviter_id;
+                                        chatChannelParticipant.channelParticipant = participant;
+                                        info.participants.participants.add(chatChannelParticipant);
+                                    }
+                                }
+                                data.reuse();
+                                data2.reuse();
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                        }
+                        cursor.dispose();
+                        StringBuilder usersToLoad = new StringBuilder();
+                        for (int a = 0; a < info.bot_info.size(); a++) {
+                            TLRPC.BotInfo botInfo = info.bot_info.get(a);
+                            if (usersToLoad.length() != 0) {
+                                usersToLoad.append(",");
+                            }
+                            usersToLoad.append(botInfo.user_id);
+                        }
+                        if (usersToLoad.length() != 0) {
+                            getUsersInternal(usersToLoad.toString(), loadedUsers);
+                        }
                     }
                     if (semaphore != null) {
                         semaphore.release();
                     }
-                    MessagesController.getInstance().processChatInfo(chat_id, info, loadedUsers, true, force);
+                    MessagesController.getInstance().processChatInfo(chat_id, info, loadedUsers, true, force, byChannelUsers);
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 } finally {
@@ -1557,7 +1737,7 @@ public void run() {
                         int lower_id = (int) dialog_id;
 
                         if (lower_id != 0) {
-                            state = database.executeFast("UPDATE messages SET read_state = read_state | 1 WHERE uid = ? AND mid > 0 AND mid <= ? AND read_state IN(0,2) AND out = 0");
+                            state = database.executeFast("UPDATE messages SET read_state = read_state | 1 WHERE uid = ? AND mid <= ? AND read_state IN(0,2) AND out = 0");
                             state.requery();
                             state.bindLong(1, dialog_id);
                             state.bindLong(2, max_id);
@@ -1572,9 +1752,18 @@ public void run() {
                             state.dispose();
                         }
 
-                        state = database.executeFast("UPDATE dialogs SET unread_count = 0 WHERE did = ?");
+                        int currentMaxId = 0;
+                        SQLiteCursor cursor = database.queryFinalized("SELECT inbox_max FROM dialogs WHERE did = " + dialog_id);
+                        if (cursor.next()) {
+                            currentMaxId = cursor.intValue(0);
+                        }
+                        cursor.dispose();
+                        currentMaxId = Math.max(currentMaxId, (int) max_id);
+
+                        state = database.executeFast("UPDATE dialogs SET unread_count = 0, unread_count_i = 0, inbox_max = ? WHERE did = ?");
                         state.requery();
-                        state.bindLong(1, dialog_id);
+                        state.bindInteger(1, currentMaxId);
+                        state.bindLong(2, dialog_id);
                         state.step();
                         state.dispose();
 
@@ -1587,10 +1776,11 @@ public void run() {
         });
     }
 
-    public void putContacts(final ArrayList<TLRPC.TL_contact> contacts, final boolean deleteAll) {
+    public void putContacts(ArrayList<TLRPC.TL_contact> contacts, final boolean deleteAll) {
         if (contacts.isEmpty()) {
             return;
         }
+        final ArrayList<TLRPC.TL_contact> contactsCopy = new ArrayList<>(contacts);
         storageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
@@ -1600,7 +1790,8 @@ public void run() {
                     }
                     database.beginTransaction();
                     SQLitePreparedStatement state = database.executeFast("REPLACE INTO contacts VALUES(?, ?)");
-                    for (TLRPC.TL_contact contact : contacts) {
+                    for (int a = 0; a < contactsCopy.size(); a++) {
+                        TLRPC.TL_contact contact = contactsCopy.get(a);
                         state.requery();
                         state.bindInteger(1, contact.user_id);
                         state.bindInteger(2, contact.mutual ? 1 : 0);
@@ -1779,11 +1970,11 @@ public void run() {
                     ArrayList<TLRPC.Chat> chats = new ArrayList<>();
                     ArrayList<TLRPC.EncryptedChat> encryptedChats = new ArrayList<>();
 
-                    ArrayList<Integer> userIds = new ArrayList<>();
-                    ArrayList<Integer> chatIds = new ArrayList<>();
+                    ArrayList<Integer> usersToLoad = new ArrayList<>();
+                    ArrayList<Integer> chatsToLoad = new ArrayList<>();
                     ArrayList<Integer> broadcastIds = new ArrayList<>();
                     ArrayList<Integer> encryptedChatIds = new ArrayList<>();
-                    SQLiteCursor cursor = database.queryFinalized("SELECT m.read_state, m.data, m.send_state, m.mid, m.date, r.random_id, m.uid, s.seq_in, s.seq_out FROM messages as m LEFT JOIN randoms as r ON r.mid = m.mid LEFT JOIN messages_seq as s ON m.mid = s.mid WHERE m.mid < 0 AND m.send_state = 1 ORDER BY m.mid DESC LIMIT " + count);
+                    SQLiteCursor cursor = database.queryFinalized("SELECT m.read_state, m.data, m.send_state, m.mid, m.date, r.random_id, m.uid, s.seq_in, s.seq_out, m.ttl FROM messages as m LEFT JOIN randoms as r ON r.mid = m.mid LEFT JOIN messages_seq as s ON m.mid = s.mid WHERE m.mid < 0 AND m.send_state = 1 ORDER BY m.mid DESC LIMIT " + count);
                     while (cursor.next()) {
                         NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(1));
                         if (data != null && cursor.byteBufferValue(1, data) != 0) {
@@ -1798,6 +1989,7 @@ public void run() {
                                 message.dialog_id = cursor.longValue(6);
                                 message.seq_in = cursor.intValue(7);
                                 message.seq_out = cursor.intValue(8);
+                                message.ttl = cursor.intValue(9);
                                 messages.add(message);
                                 messageHashMap.put(message.id, message);
 
@@ -1811,12 +2003,12 @@ public void run() {
                                         }
                                     } else {
                                         if (lower_id < 0) {
-                                            if (!chatIds.contains(-lower_id)) {
-                                                chatIds.add(-lower_id);
+                                            if (!chatsToLoad.contains(-lower_id)) {
+                                                chatsToLoad.add(-lower_id);
                                             }
                                         } else {
-                                            if (!userIds.contains(lower_id)) {
-                                                userIds.add(lower_id);
+                                            if (!usersToLoad.contains(lower_id)) {
+                                                usersToLoad.add(lower_id);
                                             }
                                         }
                                     }
@@ -1826,27 +2018,8 @@ public void run() {
                                     }
                                 }
 
-                                if (!userIds.contains(message.from_id)) {
-                                    userIds.add(message.from_id);
-                                }
-                                if (message.action != null && message.action.user_id != 0 && !userIds.contains(message.action.user_id)) {
-                                    userIds.add(message.action.user_id);
-                                }
-                                if (message.media != null && message.media.user_id != 0 && !userIds.contains(message.media.user_id)) {
-                                    userIds.add(message.media.user_id);
-                                }
-                                if (message.media != null && message.media.audio != null && message.media.audio.user_id != 0 && !userIds.contains(message.media.audio.user_id)) {
-                                    userIds.add(message.media.audio.user_id);
-                                }
-                                if (message.fwd_from_id instanceof TLRPC.TL_peerUser) {
-                                    if (!userIds.contains(message.fwd_from_id.user_id)) {
-                                        userIds.add(message.fwd_from_id.user_id);
-                                    }
-                                } else if (message.fwd_from_id instanceof TLRPC.TL_peerChannel) {
-                                    if (!chatIds.contains(message.fwd_from_id.channel_id)) {
-                                        chatIds.add(message.fwd_from_id.channel_id);
-                                    }
-                                }
+                                addUsersAndChatsFromMessage(message, usersToLoad, chatsToLoad);
+
                                 message.send_state = cursor.intValue(2);
                                 if (message.to_id.channel_id == 0 && !MessageObject.isUnread(message) && lower_id != 0 || message.id > 0) {
                                     message.send_state = 0;
@@ -1862,22 +2035,24 @@ public void run() {
 
 
                     if (!encryptedChatIds.isEmpty()) {
-                        getEncryptedChatsInternal(TextUtils.join(",", encryptedChatIds), encryptedChats, userIds);
+                        getEncryptedChatsInternal(TextUtils.join(",", encryptedChatIds), encryptedChats, usersToLoad);
                     }
 
-                    if (!userIds.isEmpty()) {
-                        getUsersInternal(TextUtils.join(",", userIds), users);
+                    if (!usersToLoad.isEmpty()) {
+                        getUsersInternal(TextUtils.join(",", usersToLoad), users);
                     }
 
-                    if (!chatIds.isEmpty() || !broadcastIds.isEmpty()) {
+                    if (!chatsToLoad.isEmpty() || !broadcastIds.isEmpty()) {
                         StringBuilder stringToLoad = new StringBuilder();
-                        for (Integer cid : chatIds) {
+                        for (int a = 0; a < chatsToLoad.size(); a++) {
+                            Integer cid = chatsToLoad.get(a);
                             if (stringToLoad.length() != 0) {
                                 stringToLoad.append(",");
                             }
                             stringToLoad.append(cid);
                         }
-                        for (Integer cid : broadcastIds) {
+                        for (int a = 0; a < broadcastIds.size(); a++) {
+                            Integer cid = broadcastIds.get(a);
                             if (stringToLoad.length() != 0) {
                                 stringToLoad.append(",");
                             }
@@ -1894,7 +2069,7 @@ public void run() {
         });
     }
 
-    public void getMessages(final long dialog_id, final int count, final int max_id, final int minDate, final int classGuid, final int load_type, final int important) {
+    public void getMessages(final long dialog_id, final int count, final int max_id, final int minDate, final int classGuid, final int load_type, final int important, final int loadIndex) {
         storageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
@@ -1904,8 +2079,10 @@ public void run() {
                 int offset_query = 0;
                 int min_unread_id = 0;
                 int last_message_id = 0;
+                boolean queryFromServer = false;
                 int max_unread_date = 0;
                 long messageMaxId = max_id;
+                int max_id_query = max_id;
                 int channelId = 0;
                 if (important != 0) {
                     channelId = -(int) dialog_id;
@@ -1915,18 +2092,62 @@ public void run() {
                 }
                 boolean isEnd = false;
                 try {
-                    ArrayList<Integer> loadedUsers = new ArrayList<>();
-                    ArrayList<Integer> fromUser = new ArrayList<>();
+                    ArrayList<Integer> usersToLoad = new ArrayList<>();
                     ArrayList<Integer> chatsToLoad = new ArrayList<>();
                     ArrayList<Long> replyMessages = new ArrayList<>();
                     HashMap<Integer, ArrayList<TLRPC.Message>> replyMessageOwners = new HashMap<>();
 
                     SQLiteCursor cursor;
-                    int lower_id = (int)dialog_id;
+                    int lower_id = (int) dialog_id;
                     if (lower_id != 0) {
                         String imp = important == 2 ? " AND imp = 1 " : "";
                         String holesTable = important == 2 ? "messages_imp_holes" : "messages_holes";
 
+                        if (load_type != 1 && load_type != 3 && minDate == 0) {
+                            if (load_type == 2) {
+                                cursor = database.queryFinalized("SELECT inbox_max, unread_count, date FROM dialogs WHERE did = " + dialog_id);
+                                if (cursor.next()) {
+                                    messageMaxId = max_id_query = min_unread_id = cursor.intValue(0);
+                                    count_unread = cursor.intValue(1);
+                                    max_unread_date = cursor.intValue(2);
+                                    queryFromServer = true;
+                                    if (messageMaxId != 0 && channelId != 0) {
+                                        messageMaxId |= ((long) channelId) << 32;
+                                    }
+                                }
+                                cursor.dispose();
+                                if (!queryFromServer) {
+                                    cursor = database.queryFinalized(String.format(Locale.US, "SELECT min(mid), max(date) FROM messages WHERE uid = %d AND out = 0 AND read_state IN(0,2) AND mid > 0" + imp, dialog_id));
+                                    if (cursor.next()) {
+                                        min_unread_id = cursor.intValue(0);
+                                        max_unread_date = cursor.intValue(1);
+                                    }
+                                    cursor.dispose();
+                                    if (min_unread_id != 0) {
+                                        cursor = database.queryFinalized(String.format(Locale.US, "SELECT COUNT(*) FROM messages WHERE uid = %d AND mid >= %d " + imp + "AND out = 0 AND read_state IN(0,2)", dialog_id, min_unread_id));
+                                        if (cursor.next()) {
+                                            count_unread = cursor.intValue(0);
+                                        }
+                                        cursor.dispose();
+                                    }
+                                }
+                            }
+
+                            if (count_query > count_unread || count_unread < 4) {
+                                count_query = Math.max(count_query, count_unread + 10);
+                                if (count_unread < 4) {
+                                    count_unread = 0;
+                                    min_unread_id = 0;
+                                    messageMaxId = 0;
+                                    last_message_id = 0;
+                                    queryFromServer = false;
+                                }
+                            } else {
+                                offset_query = count_unread - count_query;
+                                count_query += 10;
+                            }
+                        }
+
                         cursor = database.queryFinalized(String.format(Locale.US, "SELECT start FROM " + holesTable + " WHERE uid = %d AND start IN (0, 1)", dialog_id));
                         if (cursor.next()) {
                             isEnd = cursor.intValue(0) == 1;
@@ -1949,24 +2170,24 @@ public void run() {
                             cursor.dispose();
                         }
 
-                        if (load_type == 3) {
+                        if (load_type == 3 || queryFromServer && load_type == 2) {
                             cursor = database.queryFinalized(String.format(Locale.US, "SELECT max(mid) FROM messages WHERE uid = %d AND mid > 0", dialog_id));
                             if (cursor.next()) {
                                 last_message_id = cursor.intValue(0);
                             }
                             cursor.dispose();
 
-                            boolean containMessage = false;
-                            cursor = database.queryFinalized(String.format(Locale.US, "SELECT mid FROM messages WHERE mid = %d", messageMaxId));
+                            boolean containMessage = true;
+                            cursor = database.queryFinalized(String.format(Locale.US, "SELECT start FROM " + holesTable + " WHERE uid = %d AND start < %d AND end > %d", dialog_id, max_id_query, max_id_query));
                             if (cursor.next()) {
-                                containMessage = true;
+                                containMessage = false;
                             }
                             cursor.dispose();
 
                             if (containMessage) {
                                 long holeMessageMaxId = 0;
                                 long holeMessageMinId = 1;
-                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT start FROM " + holesTable + " WHERE uid = %d AND start >= %d ORDER BY start ASC LIMIT 1", dialog_id, max_id));
+                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT start FROM " + holesTable + " WHERE uid = %d AND start >= %d ORDER BY start ASC LIMIT 1", dialog_id, max_id_query));
                                 if (cursor.next()) {
                                     holeMessageMaxId = cursor.intValue(0);
                                     if (channelId != 0) {
@@ -1974,7 +2195,7 @@ public void run() {
                                     }
                                 }
                                 cursor.dispose();
-                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT end FROM " + holesTable + " WHERE uid = %d AND end <= %d ORDER BY end DESC LIMIT 1", dialog_id, max_id));
+                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT end FROM " + holesTable + " WHERE uid = %d AND end <= %d ORDER BY end DESC LIMIT 1", dialog_id, max_id_query));
                                 if (cursor.next()) {
                                     holeMessageMinId = cursor.intValue(0);
                                     if (channelId != 0) {
@@ -2004,7 +2225,7 @@ public void run() {
                             }
                         } else if (load_type == 1) {
                             long holeMessageId = 0;
-                            cursor = database.queryFinalized(String.format(Locale.US, "SELECT start FROM " + holesTable + " WHERE uid = %d AND start >= %d ORDER BY start ASC LIMIT 1", dialog_id, max_id));
+                            cursor = database.queryFinalized(String.format(Locale.US, "SELECT start, end FROM " + holesTable + " WHERE uid = %d AND start >= %d AND start != 1 AND end != 1 ORDER BY start ASC LIMIT 1", dialog_id, max_id));
                             if (cursor.next()) {
                                 holeMessageId = cursor.intValue(0);
                                 if (channelId != 0) {
@@ -2037,39 +2258,11 @@ public void run() {
                                 cursor = database.queryFinalized(String.format(Locale.US, "SELECT m.read_state, m.data, m.send_state, m.mid, m.date, r.random_id, m.replydata, m.media FROM messages as m LEFT JOIN randoms as r ON r.mid = m.mid WHERE m.uid = %d AND m.date <= %d " + imp + "ORDER BY m.date DESC, m.mid DESC LIMIT %d,%d", dialog_id, minDate, offset_query, count_query));
                             }
                         } else {
-                            if (load_type == 2) {
-                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT max(mid) FROM messages WHERE uid = %d AND mid > 0", dialog_id));
-                                if (cursor.next()) {
-                                    last_message_id = cursor.intValue(0);
-                                }
-                                cursor.dispose();
-
-                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT min(mid), max(date) FROM messages WHERE uid = %d AND out = 0 AND read_state IN(0,2) AND mid > 0" + imp, dialog_id));
-                                if (cursor.next()) {
-                                    min_unread_id = cursor.intValue(0);
-                                    max_unread_date = cursor.intValue(1);
-                                }
-                                cursor.dispose();
-                                if (min_unread_id != 0) {
-                                    cursor = database.queryFinalized(String.format(Locale.US, "SELECT COUNT(*) FROM messages WHERE uid = %d AND mid >= %d " + imp + "AND out = 0 AND read_state IN(0,2)", dialog_id, min_unread_id));
-                                    if (cursor.next()) {
-                                        count_unread = cursor.intValue(0);
-                                    }
-                                    cursor.dispose();
-                                }
-                            }
-
-                            if (count_query > count_unread || count_unread < 4) {
-                                count_query = Math.max(count_query, count_unread + 10);
-                                if (count_unread < 4) {
-                                    count_unread = 0;
-                                    min_unread_id = 0;
-                                    last_message_id = 0;
-                                }
-                            } else {
-                                offset_query = count_unread - count_query;
-                                count_query += 10;
+                            cursor = database.queryFinalized(String.format(Locale.US, "SELECT max(mid) FROM messages WHERE uid = %d AND mid > 0", dialog_id));
+                            if (cursor.next()) {
+                                last_message_id = cursor.intValue(0);
                             }
+                            cursor.dispose();
 
                             long holeMessageId = 0;
                             cursor = database.queryFinalized(String.format(Locale.US, "SELECT max(end) FROM " + holesTable + " WHERE uid = %d", dialog_id));
@@ -2146,25 +2339,9 @@ public void run() {
                                     message.views = cursor.intValue(7);
                                 }
                                 res.messages.add(message);
-                                fromUser.add(message.from_id);
-                                if (message.action != null && message.action.user_id != 0) {
-                                    fromUser.add(message.action.user_id);
-                                }
-                                if (message.media != null && message.media.user_id != 0) {
-                                    fromUser.add(message.media.user_id);
-                                }
-                                if (message.media != null && message.media.audio != null && message.media.audio.user_id != 0) {
-                                    fromUser.add(message.media.audio.user_id);
-                                }
-                                if (message.fwd_from_id instanceof TLRPC.TL_peerUser) {
-                                    if (!fromUser.contains(message.fwd_from_id.user_id)) {
-                                        fromUser.add(message.fwd_from_id.user_id);
-                                    }
-                                } else if (message.fwd_from_id instanceof TLRPC.TL_peerChannel) {
-                                    if (!chatsToLoad.contains(message.fwd_from_id.channel_id)) {
-                                        chatsToLoad.add(message.fwd_from_id.channel_id);
-                                    }
-                                }
+
+                                addUsersAndChatsFromMessage(message, usersToLoad, chatsToLoad);
+
                                 if (message.reply_to_msg_id != 0) {
                                     boolean ok = false;
                                     if (!cursor.isNull(6)) {
@@ -2172,25 +2349,7 @@ public void run() {
                                         if (data2 != null && cursor.byteBufferValue(6, data2) != 0) {
                                             message.replyMessage = TLRPC.Message.TLdeserialize(data2, data2.readInt32(false), false);
                                             if (message.replyMessage != null) {
-                                                fromUser.add(message.replyMessage.from_id);
-                                                if (message.replyMessage.action != null && message.replyMessage.action.user_id != 0) {
-                                                    fromUser.add(message.replyMessage.action.user_id);
-                                                }
-                                                if (message.replyMessage.media != null && message.replyMessage.media.user_id != 0) {
-                                                    fromUser.add(message.replyMessage.media.user_id);
-                                                }
-                                                if (message.replyMessage.media != null && message.replyMessage.media.audio != null && message.replyMessage.media.audio.user_id != 0) {
-                                                    fromUser.add(message.replyMessage.media.audio.user_id);
-                                                }
-                                                if (message.replyMessage.fwd_from_id instanceof TLRPC.TL_peerUser) {
-                                                    if (!fromUser.contains(message.replyMessage.fwd_from_id.user_id)) {
-                                                        fromUser.add(message.replyMessage.fwd_from_id.user_id);
-                                                    }
-                                                } else if (message.replyMessage.fwd_from_id instanceof TLRPC.TL_peerChannel) {
-                                                    if (!chatsToLoad.contains(message.replyMessage.fwd_from_id.channel_id)) {
-                                                        chatsToLoad.add(message.replyMessage.fwd_from_id.channel_id);
-                                                    }
-                                                }
+                                                addUsersAndChatsFromMessage(message.replyMessage, usersToLoad, chatsToLoad);
                                                 ok = true;
                                             }
                                         }
@@ -2213,7 +2372,7 @@ public void run() {
                                     }
                                 }
                                 message.send_state = cursor.intValue(2);
-                                if (message.to_id.channel_id == 0 && !MessageObject.isUnread(message) && lower_id != 0 || message.id > 0) {
+                                if (message.id > 0 && message.send_state != 0) {
                                     message.send_state = 0;
                                 }
                                 if (lower_id == 0 && !cursor.isNull(5)) {
@@ -2236,10 +2395,6 @@ public void run() {
                         cursor.dispose();
                     }
 
-                    if (load_type == 3 && res.messages.size() == 1) {
-                        res.messages.clear();
-                    }
-
                     Collections.sort(res.messages, new Comparator<TLRPC.Message>() {
                         @Override
                         public int compare(TLRPC.Message lhs, TLRPC.Message rhs) {
@@ -2266,6 +2421,20 @@ public int compare(TLRPC.Message lhs, TLRPC.Message rhs) {
                         }
                     });
 
+                    if ((load_type == 3 || load_type == 2 && queryFromServer) && !res.messages.isEmpty()) {
+                        int minId = res.messages.get(res.messages.size() - 1).id;
+                        int maxId = res.messages.get(0).id;
+                        if (!(minId <= max_id_query && maxId >= max_id_query)) {
+                            replyMessages.clear();
+                            usersToLoad.clear();
+                            chatsToLoad.clear();
+                            res.messages.clear();
+                        }
+                    }
+                    if (load_type == 3 && res.messages.size() == 1) {
+                        res.messages.clear();
+                    }
+
                     if (important == 2 && !res.messages.isEmpty()) {
                         if (max_id != 0) {
                             cursor = database.queryFinalized(String.format(Locale.US, "SELECT start, end, count FROM channel_group WHERE uid = %d AND ((start >= %d AND end <= %d) OR (start = %d))", dialog_id, res.messages.get(res.messages.size() - 1).id, res.messages.get(0).id, res.messages.get(0).id));
@@ -2291,25 +2460,9 @@ public int compare(TLRPC.Message lhs, TLRPC.Message rhs) {
                                 message.id = cursor.intValue(1);
                                 message.date = cursor.intValue(2);
                                 message.dialog_id = dialog_id;
-                                fromUser.add(message.from_id);
-                                if (message.action != null && message.action.user_id != 0) {
-                                    fromUser.add(message.action.user_id);
-                                }
-                                if (message.media != null && message.media.user_id != 0) {
-                                    fromUser.add(message.media.user_id);
-                                }
-                                if (message.media != null && message.media.audio != null && message.media.audio.user_id != 0) {
-                                    fromUser.add(message.media.audio.user_id);
-                                }
-                                if (message.fwd_from_id instanceof TLRPC.TL_peerUser) {
-                                    if (!fromUser.contains(message.fwd_from_id.user_id)) {
-                                        fromUser.add(message.fwd_from_id.user_id);
-                                    }
-                                } else if (message.fwd_from_id instanceof TLRPC.TL_peerChannel) {
-                                    if (!chatsToLoad.contains(message.fwd_from_id.channel_id)) {
-                                        chatsToLoad.add(message.fwd_from_id.channel_id);
-                                    }
-                                }
+
+                                addUsersAndChatsFromMessage(message, usersToLoad, chatsToLoad);
+
                                 ArrayList<TLRPC.Message> arrayList = replyMessageOwners.get(message.id);
                                 if (arrayList != null) {
                                     for (TLRPC.Message m : arrayList) {
@@ -2322,18 +2475,8 @@ public int compare(TLRPC.Message lhs, TLRPC.Message rhs) {
                         cursor.dispose();
                     }
 
-                    StringBuilder usersToLoad = new StringBuilder();
-                    for (int uid : fromUser) {
-                        if (!loadedUsers.contains(uid)) {
-                            if (usersToLoad.length() != 0) {
-                                usersToLoad.append(",");
-                            }
-                            usersToLoad.append(uid);
-                            loadedUsers.add(uid);
-                        }
-                    }
-                    if (usersToLoad.length() != 0) {
-                        getUsersInternal(usersToLoad.toString(), res.users);
+                    if (!usersToLoad.isEmpty()) {
+                        getUsersInternal(TextUtils.join(",", usersToLoad), res.users);
                     }
                     if (!chatsToLoad.isEmpty()) {
                         getChatsInternal(TextUtils.join(",", chatsToLoad), res.chats);
@@ -2345,7 +2488,7 @@ public int compare(TLRPC.Message lhs, TLRPC.Message rhs) {
                     res.collapsed.clear();
                     FileLog.e("tmessages", e);
                 } finally {
-                    MessagesController.getInstance().processLoadedMessages(res, dialog_id, count_query, max_id, true, classGuid, min_unread_id, last_message_id, count_unread, max_unread_date, load_type, important, isEnd);
+                    MessagesController.getInstance().processLoadedMessages(res, dialog_id, count_query, max_id, true, classGuid, min_unread_id, last_message_id, count_unread, max_unread_date, load_type, important, isEnd, loadIndex, queryFromServer);
                 }
             }
         });
@@ -2605,6 +2748,31 @@ public void run() {
         });
     }
 
+    public boolean isDialogHasMessages(final long did) {
+        final Semaphore semaphore = new Semaphore(0);
+        final boolean result[] = new boolean[1];
+        storageQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT mid FROM messages WHERE uid = %d LIMIT 1", did));
+                    result[0] = cursor.next();
+                    cursor.dispose();
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                } finally {
+                    semaphore.release();
+                }
+            }
+        });
+        try {
+            semaphore.acquire();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return result[0];
+    }
+
     public void getEncryptedChat(final int chat_id, final Semaphore semaphore, final ArrayList<TLObject> result) {
         if (semaphore == null || result == null) {
             return;
@@ -2978,7 +3146,7 @@ public void run() {
 
     private int getMessageMediaType(TLRPC.Message message) {
         if (message instanceof TLRPC.TL_message_secret && (
-                message.media instanceof TLRPC.TL_messageMediaPhoto && message.ttl != 0 && message.ttl <= 60 ||
+                message.media instanceof TLRPC.TL_messageMediaPhoto && message.ttl > 0 && message.ttl <= 60 ||
                 message.media instanceof TLRPC.TL_messageMediaAudio ||
                 message.media instanceof TLRPC.TL_messageMediaVideo)) {
             return 1;
@@ -3073,14 +3241,23 @@ public void run() {
         });
     }
 
-    public void overwriteChannel(final int channel_id, final TLRPC.TL_updates_channelDifferenceTooLong difference) {
+    public void overwriteChannel(final int channel_id, final TLRPC.TL_updates_channelDifferenceTooLong difference, final int newDialogType) {
         storageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
                 try {
+                    boolean checkInvite = false;
                     final long did = -channel_id;
+                    if (newDialogType != 0) {
+                        SQLiteCursor cursor = database.queryFinalized("SELECT pts FROM dialogs WHERE did = " + did);
+                        if (!cursor.next()) {
+                            checkInvite = true;
+                        }
+                        cursor.dispose();
+                    }
 
                     database.executeFast("DELETE FROM messages WHERE uid = " + did).stepThis().dispose();
+                    database.executeFast("DELETE FROM channel_group WHERE uid = " + did).stepThis().dispose();
                     database.executeFast("DELETE FROM bot_keyboard WHERE uid = " + did).stepThis().dispose();
                     database.executeFast("DELETE FROM media_counts_v2 WHERE uid = " + did).stepThis().dispose();
                     database.executeFast("DELETE FROM media_v2 WHERE uid = " + did).stepThis().dispose();
@@ -3114,6 +3291,13 @@ public void run() {
                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.removeAllMessagesFromDialog, did, true);
                         }
                     });
+                    if (checkInvite) {
+                        if (newDialogType == 1) {
+                            MessagesController.getInstance().checkChannelInviter(channel_id);
+                        } else {
+                            MessagesController.getInstance().generateJoinMessage(channel_id, false);
+                        }
+                    }
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 }
@@ -3169,6 +3353,7 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
             StringBuilder messageMediaIds = null;
             HashMap<Long, Integer> mediaTypes = null;
             StringBuilder messageIds = new StringBuilder();
+            HashMap<Long, Integer> dialogsReadMax = new HashMap<>();
             HashMap<Long, Long> messagesIdsMap = new HashMap<>();
             HashMap<Long, Long> messagesIdsMapNotImportant = new HashMap<>();
 
@@ -3196,15 +3381,27 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
                 }
 
                 if ((message.to_id.channel_id == 0 && MessageObject.isUnread(message) || MessageObject.isContentUnread(message)) && !MessageObject.isOut(message)) {
-                    if (messageIds.length() > 0) {
-                        messageIds.append(",");
+                    Integer currentMaxId = dialogsReadMax.get(message.dialog_id);
+                    if (currentMaxId == null) {
+                        SQLiteCursor cursor = database.queryFinalized("SELECT inbox_max FROM dialogs WHERE did = " + message.dialog_id);
+                        if (cursor.next()) {
+                            currentMaxId = cursor.intValue(0);
+                        } else {
+                            currentMaxId = 0;
+                        }
+                        cursor.dispose();
+                        dialogsReadMax.put(message.dialog_id, currentMaxId);
                     }
-
-                    messageIds.append(messageId);
-                    if (message.to_id.channel_id == 0 || MessageObject.isImportant(message)) {
-                        messagesIdsMap.put(messageId, message.dialog_id);
-                    } else if (message.to_id.channel_id != 0) {
-                        messagesIdsMapNotImportant.put(messageId, message.dialog_id);
+                    if (message.id < 0 || currentMaxId < message.id) {
+                        if (messageIds.length() > 0) {
+                            messageIds.append(",");
+                        }
+                        messageIds.append(messageId);
+                        if (message.to_id.channel_id == 0 || MessageObject.isMegagroup(message) || MessageObject.isImportant(message)) {
+                            messagesIdsMap.put(messageId, message.dialog_id);
+                        } else if (message.to_id.channel_id != 0) {
+                            messagesIdsMapNotImportant.put(messageId, message.dialog_id);
+                        }
                     }
                 }
                 if (SharedMediaQuery.canAddMessageToMedia(message)) {
@@ -3220,7 +3417,7 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
                     messagesMediaIdsMap.put(messageId, message.dialog_id);
                     mediaTypes.put(messageId, SharedMediaQuery.getMediaType(message));
                 }
-                if (message.reply_markup != null && ((message.reply_markup.flags & 4) == 0 || (message.flags & 16) != 0)) {
+                if (message.reply_markup != null && (!message.reply_markup.selective || message.mentioned)) {
                     TLRPC.Message oldMessage = botKeyboards.get(message.dialog_id);
                     if (oldMessage == null || oldMessage.id < message.id) {
                         botKeyboards.put(message.dialog_id, message);
@@ -3308,14 +3505,14 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
 
                 if (updateDialog) {
                     TLRPC.Message lastMessage;
-                    if (message.to_id.channel_id == 0 || MessageObject.isImportant(message)) {
+                    if (message.to_id.channel_id == 0 || MessageObject.isMegagroup(message) || MessageObject.isImportant(message)) {
                         lastMessage = messagesMap.get(message.dialog_id);
-                        if (lastMessage == null || message.date > lastMessage.date) {
+                        if (lastMessage == null || message.date > lastMessage.date || message.id > 0 && lastMessage.id > 0 && message.id > lastMessage.id || message.id < 0 && lastMessage.id < 0 && message.id < lastMessage.id) {
                             messagesMap.put(message.dialog_id, message);
                         }
                     } else if (message.to_id.channel_id != 0) {
-                        lastMessage = messagesMap.get(message.dialog_id);
-                        if (lastMessage == null || message.date > lastMessage.date) {
+                        lastMessage = messagesMapNotImportant.get(message.dialog_id);
+                        if (lastMessage == null || message.date > lastMessage.date || message.id > 0 && lastMessage.id > 0 && message.id > lastMessage.id || message.id < 0 && lastMessage.id < 0 && message.id < lastMessage.id) {
                             messagesMapNotImportant.put(message.dialog_id, message);
                         }
                     }
@@ -3366,7 +3563,7 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
 
                 data.reuse();
 
-                if ((message.to_id.channel_id == 0 || MessageObject.isImportant(message)) && message.date >= ConnectionsManager.getInstance().getCurrentTime() - 60 * 60 * 24 && downloadMask != 0) {
+                if ((message.to_id.channel_id == 0 || MessageObject.isImportant(message)) && message.date >= ConnectionsManager.getInstance().getCurrentTime() - 60 * 60 && downloadMask != 0) {
                     if (message.media instanceof TLRPC.TL_messageMediaAudio || message.media instanceof TLRPC.TL_messageMediaPhoto || message.media instanceof TLRPC.TL_messageMediaVideo || message.media instanceof TLRPC.TL_messageMediaDocument) {
                         int type = 0;
                         long id = 0;
@@ -3443,7 +3640,7 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
                     channelId = messageNotImportant.to_id.channel_id;
                 }
 
-                SQLiteCursor cursor = database.queryFinalized("SELECT date, unread_count, last_mid_i, unread_count_i, pts, date_i, last_mid FROM dialogs WHERE did = " + key);
+                SQLiteCursor cursor = database.queryFinalized("SELECT date, unread_count, last_mid_i, unread_count_i, pts, date_i, last_mid, inbox_max FROM dialogs WHERE did = " + key);
                 int dialog_date = 0;
                 int last_mid = 0;
                 int old_unread_count = 0;
@@ -3451,6 +3648,7 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
                 int old_unread_count_i = 0;
                 int pts = channelId != 0 ? 1 : 0;
                 int dialog_date_i = 0;
+                int inbox_max = 0;
                 if (cursor.next()) {
                     dialog_date = cursor.intValue(0);
                     old_unread_count = cursor.intValue(1);
@@ -3459,13 +3657,12 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
                     pts = cursor.intValue(4);
                     dialog_date_i = cursor.intValue(5);
                     last_mid = cursor.intValue(6);
+                    inbox_max = cursor.intValue(7);
                 } else if (channelId != 0) {
                     MessagesController.getInstance().checkChannelInviter(channelId);
                 }
                 cursor.dispose();
 
-                state.requery();
-
                 Integer unread_count = messagesCounts.get(key);
                 if (unread_count == null) {
                     unread_count = 0;
@@ -3496,6 +3693,7 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
                     messageIdNotImportant |= ((long) channelId) << 32;
                 }
 
+                state.requery();
                 state.bindLong(1, key);
                 if (message != null && (!doNotUpdateDialogDate || dialog_date == 0)) {
                     state.bindInteger(2, message.date);
@@ -3504,7 +3702,7 @@ private void putMessagesInternal(final ArrayList<TLRPC.Message> messages, final
                 }
                 state.bindInteger(3, old_unread_count + unread_count);
                 state.bindLong(4, messageId);
-                state.bindInteger(5, 0);
+                state.bindInteger(5, inbox_max);
                 state.bindInteger(6, 0);
                 state.bindLong(7, messageIdNotImportant);
                 state.bindInteger(8, unread_count_i + old_unread_count_i);
@@ -3983,6 +4181,7 @@ public void run() {
     private void markMessagesAsDeletedInternal(final ArrayList<Integer> messages, int channelId) {
         try {
             String ids;
+            int unread_count = 0;
             if (channelId != 0) {
                 StringBuilder builder = new StringBuilder(messages.size());
                 for (int a = 0; a < messages.size(); a++) {
@@ -3997,12 +4196,15 @@ private void markMessagesAsDeletedInternal(final ArrayList<Integer> messages, in
             } else {
                 ids = TextUtils.join(",", messages);
             }
-            SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT uid, data FROM messages WHERE mid IN(%s)", ids));
+            SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT uid, data, read_state FROM messages WHERE mid IN(%s)", ids));
             ArrayList<File> filesToDelete = new ArrayList<>();
             try {
                 while (cursor.next()) {
                     long did = cursor.longValue(0);
-                    if ((int)did != 0) {
+                    if (channelId != 0 && cursor.intValue(2) == 0) {
+                        unread_count++;
+                    }
+                    if ((int) did != 0) {
                         continue;
                     }
                     NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(1));
@@ -4049,7 +4251,19 @@ private void markMessagesAsDeletedInternal(final ArrayList<Integer> messages, in
                 FileLog.e("tmessages", e);
             }
             cursor.dispose();
-            FileLoader.getInstance().deleteFiles(filesToDelete);
+            FileLoader.getInstance().deleteFiles(filesToDelete, 0);
+
+            if (channelId != 0 && unread_count != 0) {
+                long did = -channelId;
+                SQLitePreparedStatement state = database.executeFast("UPDATE dialogs SET unread_count = ((SELECT unread_count FROM dialogs WHERE did = ?) - ?) WHERE did = ?");
+                state.requery();
+                state.bindLong(1, did);
+                state.bindInteger(2, unread_count);
+                state.bindLong(3, did);
+                state.step();
+                state.dispose();
+            }
+
             database.executeFast(String.format(Locale.US, "DELETE FROM messages WHERE mid IN(%s)", ids)).stepThis().dispose();
             database.executeFast(String.format(Locale.US, "DELETE FROM bot_keyboard WHERE mid IN(%s)", ids)).stepThis().dispose();
             database.executeFast(String.format(Locale.US, "DELETE FROM messages_seq WHERE mid IN(%s)", ids)).stepThis().dispose();
@@ -4068,31 +4282,23 @@ private void updateDialogsWithDeletedMessagesInternal(final ArrayList<Integer> m
         try {
             String ids;
             if (!messages.isEmpty()) {
-
+                SQLitePreparedStatement state;
+                ArrayList<Long> dialogsToUpdate = new ArrayList<>();
                 if (channelId != 0) {
-                    StringBuilder builder = new StringBuilder(messages.size());
-                    for (int a = 0; a < messages.size(); a++) {
-                        long messageId = messages.get(a);
-                        messageId |= ((long) channelId) << 32;
-                        if (builder.length() > 0) {
-                            builder.append(',');
-                        }
-                        builder.append(messageId);
-                    }
-                    ids = builder.toString();
+                    dialogsToUpdate.add((long) -channelId);
+                    state = database.executeFast("UPDATE dialogs SET last_mid = (SELECT mid FROM messages WHERE uid = ? AND date = (SELECT MAX(date) FROM messages WHERE uid = ? )) WHERE did = ?");
                 } else {
                     ids = TextUtils.join(",", messages);
+                    SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT did FROM dialogs WHERE last_mid IN(%s)", ids));
+                    while (cursor.next()) {
+                        dialogsToUpdate.add(cursor.longValue(0));
+                    }
+                    cursor.dispose();
+                    state = database.executeFast("UPDATE dialogs SET unread_count = 0, unread_count_i = 0, last_mid = (SELECT mid FROM messages WHERE uid = ? AND date = (SELECT MAX(date) FROM messages WHERE uid = ? AND date != 0)) WHERE did = ?");
                 }
-
-                SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT did FROM dialogs WHERE last_mid IN(%s)", ids));
-                ArrayList<Long> dialogsToUpdate = new ArrayList<>();
-                while (cursor.next()) {
-                    dialogsToUpdate.add(cursor.longValue(0));
-                }
-                cursor.dispose();
                 database.beginTransaction();
-                SQLitePreparedStatement state = database.executeFast("UPDATE dialogs SET unread_count = 0, last_mid = (SELECT mid FROM messages WHERE uid = ? AND date = (SELECT MAX(date) FROM messages WHERE uid = ? )) WHERE did = ?");
-                for (long did : dialogsToUpdate) {
+                for (int a = 0; a < dialogsToUpdate.size(); a++) {
+                    long did = dialogsToUpdate.get(a);
                     state.requery();
                     state.bindLong(1, did);
                     state.bindLong(2, did);
@@ -4112,7 +4318,7 @@ private void updateDialogsWithDeletedMessagesInternal(final ArrayList<Integer> m
             ArrayList<Integer> usersToLoad = new ArrayList<>();
             ArrayList<Integer> chatsToLoad = new ArrayList<>();
             ArrayList<Integer> encryptedToLoad = new ArrayList<>();
-            SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT d.did, d.last_mid, d.unread_count, d.date, m.data, m.read_state, m.mid, m.send_state, m.date, d.last_mid_i, d.unread_count_i, d.pts FROM dialogs as d LEFT JOIN messages as m ON d.last_mid = m.mid WHERE d.did IN(%s)", ids));
+            SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT d.did, d.last_mid, d.unread_count, d.date, m.data, m.read_state, m.mid, m.send_state, m.date, d.last_mid_i, d.unread_count_i, d.pts, d.inbox_max FROM dialogs as d LEFT JOIN messages as m ON d.last_mid = m.mid WHERE d.did IN(%s)", ids));
             while (cursor.next()) {
                 TLRPC.Dialog dialog;
                 if (channelId == 0) {
@@ -4122,6 +4328,7 @@ private void updateDialogsWithDeletedMessagesInternal(final ArrayList<Integer> m
                 }
                 dialog.id = cursor.longValue(0);
                 dialog.top_message = cursor.intValue(1);
+                dialog.read_inbox_max_id = cursor.intValue(13);
                 dialog.unread_count = cursor.intValue(2);
                 dialog.last_message_date = cursor.intValue(3);
                 dialog.pts = cursor.intValue(11);
@@ -4143,29 +4350,7 @@ private void updateDialogsWithDeletedMessagesInternal(final ArrayList<Integer> m
                     message.dialog_id = dialog.id;
                     dialogs.messages.add(message);
 
-                    if (message.from_id > 0) {
-                        if (!usersToLoad.contains(message.from_id)) {
-                            usersToLoad.add(message.from_id);
-                        }
-                    } else {
-                        if (!chatsToLoad.contains(-message.from_id)) {
-                            chatsToLoad.add(-message.from_id);
-                        }
-                    }
-                    if (message.action != null && message.action.user_id != 0) {
-                        if (!usersToLoad.contains(message.action.user_id)) {
-                            usersToLoad.add(message.action.user_id);
-                        }
-                    }
-                    if (message.fwd_from_id instanceof TLRPC.TL_peerUser) {
-                        if (!usersToLoad.contains(message.fwd_from_id.user_id)) {
-                            usersToLoad.add(message.fwd_from_id.user_id);
-                        }
-                    } else if (message.fwd_from_id instanceof TLRPC.TL_peerChannel) {
-                        if (!chatsToLoad.contains(message.fwd_from_id.channel_id)) {
-                            chatsToLoad.add(message.fwd_from_id.channel_id);
-                        }
-                    }
+                    addUsersAndChatsFromMessage(message, usersToLoad, chatsToLoad);
                 }
                 data.reuse();
 
@@ -4433,7 +4618,7 @@ private void closeHolesInTable(String table, long did, int minId, int maxId) thr
                     } else if (minId <= hole.start + 1) {
                         if (hole.start != maxId) {
                             try {
-                                database.executeFast(String.format(Locale.US, "UPDATE " + table + " SET start = %d WHERE uid = %d AND start = %d AND end = %d", maxId, did, hole.start, hole.end)).stepThis().dispose(); //TODO check
+                                database.executeFast(String.format(Locale.US, "UPDATE " + table + " SET start = %d WHERE uid = %d AND start = %d AND end = %d", maxId, did, hole.start, hole.end)).stepThis().dispose();
                             } catch (Exception e) {
                                 FileLog.e("tmessages", e);
                             }
@@ -4460,10 +4645,6 @@ private void closeHolesInTable(String table, long did, int minId, int maxId) thr
         }
     }
 
-    public void applyNewChannelsGroups(SparseArray<ArrayList<TLRPC.TL_messageGroup>> channelsGroups) {
-        //TODO ?
-    }
-
     public void putMessages(final TLRPC.messages_Messages messages, final long dialog_id, final int load_type, final int max_id, final int important, final boolean createDialog) {
         storageQueue.postRunnable(new Runnable() {
             @Override
@@ -4517,9 +4698,9 @@ public void run() {
                         if (important != 0) {
                             closeHolesInTable("messages_imp_holes", dialog_id, minId, max_id);
                         }
-                    } else if (load_type == 1 || messages.collapsed.isEmpty()) {
+                    } else if (load_type == 1) {
                         int maxId = messages.messages.get(0).id;
-                        if (important != 2) {
+                        if (important != 2 || messages.collapsed.isEmpty()) {
                             closeHolesInTable("messages_holes", dialog_id, max_id, maxId);
                             closeHolesInMedia(dialog_id, max_id, maxId, -1);
                         }
@@ -4634,7 +4815,7 @@ public void run() {
                         }
                         data.reuse();
 
-                        if (message.reply_markup != null && ((message.reply_markup.flags & 4) == 0 || (message.flags & 16) != 0)) {
+                        if (load_type == 0 && message.reply_markup != null && (!message.reply_markup.selective || message.mentioned)) {
                             if (botKeyboard == null || botKeyboard.id < message.id) {
                                 botKeyboard = message;
                             }
@@ -4713,7 +4894,62 @@ public void run() {
         });
     }
 
-    public void getDialogs(final int cacheOffset, final int offset, final int serverOffset, final int count) {
+    public static void addUsersAndChatsFromMessage(TLRPC.Message message, ArrayList<Integer> usersToLoad, ArrayList<Integer> chatsToLoad) {
+        if (message.from_id != 0) {
+            if (message.from_id > 0) {
+                if (!usersToLoad.contains(message.from_id)) {
+                    usersToLoad.add(message.from_id);
+                }
+            } else {
+                if (!chatsToLoad.contains(-message.from_id)) {
+                    chatsToLoad.add(-message.from_id);
+                }
+            }
+        }
+        if (message.action != null) {
+            if (message.action.user_id != 0 && !usersToLoad.contains(message.action.user_id)) {
+                usersToLoad.add(message.action.user_id);
+            }
+            if (message.action.channel_id != 0 && !chatsToLoad.contains(message.action.channel_id)) {
+                chatsToLoad.add(message.action.channel_id);
+            }
+            if (message.action.chat_id != 0 && !chatsToLoad.contains(message.action.chat_id)) {
+                chatsToLoad.add(message.action.chat_id);
+            }
+            if (!message.action.users.isEmpty()) {
+                for (int a = 0; a < message.action.users.size(); a++) {
+                    Integer uid = message.action.users.get(a);
+                    if (!usersToLoad.contains(uid)) {
+                        usersToLoad.add(uid);
+                    }
+                }
+            }
+        }
+        if (message.media != null) {
+            if (message.media.user_id != 0 && !usersToLoad.contains(message.media.user_id)) {
+                usersToLoad.add(message.media.user_id);
+            }
+            if (message.media.audio != null && message.media.audio.user_id != 0 &&  !usersToLoad.contains(message.media.audio.user_id)) {
+                usersToLoad.add(message.media.audio.user_id);
+            }
+        }
+        if (message.fwd_from_id instanceof TLRPC.TL_peerUser) {
+            if (!usersToLoad.contains(message.fwd_from_id.user_id)) {
+                usersToLoad.add(message.fwd_from_id.user_id);
+            }
+        } else if (message.fwd_from_id instanceof TLRPC.TL_peerChannel) {
+            if (!chatsToLoad.contains(message.fwd_from_id.channel_id)) {
+                chatsToLoad.add(message.fwd_from_id.channel_id);
+            }
+        }
+        if (message.ttl < 0) {
+            if (!chatsToLoad.contains(-message.ttl)) {
+                chatsToLoad.add(-message.ttl);
+            }
+        }
+    }
+
+    public void getDialogs(final int offset, final int count) {
         storageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
@@ -4724,7 +4960,7 @@ public void run() {
                     usersToLoad.add(UserConfig.getClientUserId());
                     ArrayList<Integer> chatsToLoad = new ArrayList<>();
                     ArrayList<Integer> encryptedToLoad = new ArrayList<>();
-                    SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT d.did, d.last_mid, d.unread_count, d.date, m.data, m.read_state, m.mid, m.send_state, s.flags, m.date, d.last_mid_i, d.unread_count_i, d.pts FROM dialogs as d LEFT JOIN messages as m ON d.last_mid = m.mid LEFT JOIN dialog_settings as s ON d.did = s.did ORDER BY d.date DESC LIMIT %d,%d", cacheOffset, count));
+                    SQLiteCursor cursor = database.queryFinalized(String.format(Locale.US, "SELECT d.did, d.last_mid, d.unread_count, d.date, m.data, m.read_state, m.mid, m.send_state, s.flags, m.date, d.last_mid_i, d.unread_count_i, d.pts, d.inbox_max FROM dialogs as d LEFT JOIN messages as m ON d.last_mid = m.mid LEFT JOIN dialog_settings as s ON d.did = s.did ORDER BY d.date DESC LIMIT %d,%d", offset, count));
                     while (cursor.next()) {
                         TLRPC.Dialog dialog;
                         int pts = cursor.intValue(12);
@@ -4739,6 +4975,7 @@ public void run() {
                         dialog.unread_count = cursor.intValue(2);
                         dialog.last_message_date = cursor.intValue(3);
                         dialog.pts = pts;
+                        dialog.read_inbox_max_id = cursor.intValue(13);
                         dialog.top_not_important_message = cursor.intValue(10);
                         dialog.unread_not_important_count = cursor.intValue(11);
                         long flags = cursor.longValue(8);
@@ -4766,29 +5003,7 @@ public void run() {
                                 message.dialog_id = dialog.id;
                                 dialogs.messages.add(message);
 
-                                if (message.from_id > 0) {
-                                    if (!usersToLoad.contains(message.from_id)) {
-                                        usersToLoad.add(message.from_id);
-                                    }
-                                } else {
-                                    if (!chatsToLoad.contains(-message.from_id)) {
-                                        chatsToLoad.add(-message.from_id);
-                                    }
-                                }
-                                if (message.action != null && message.action.user_id != 0) {
-                                    if (!usersToLoad.contains(message.action.user_id)) {
-                                        usersToLoad.add(message.action.user_id);
-                                    }
-                                }
-                                if (message.fwd_from_id instanceof TLRPC.TL_peerUser) {
-                                    if (!usersToLoad.contains(message.fwd_from_id.user_id)) {
-                                        usersToLoad.add(message.fwd_from_id.user_id);
-                                    }
-                                } else if (message.fwd_from_id instanceof TLRPC.TL_peerChannel) {
-                                    if (!chatsToLoad.contains(message.fwd_from_id.channel_id)) {
-                                        chatsToLoad.add(message.fwd_from_id.channel_id);
-                                    }
-                                }
+                                addUsersAndChatsFromMessage(message, usersToLoad, chatsToLoad);
                             }
                         }
                         data.reuse();
@@ -4829,19 +5044,107 @@ public void run() {
                     if (!usersToLoad.isEmpty()) {
                         getUsersInternal(TextUtils.join(",", usersToLoad), dialogs.users);
                     }
-                    MessagesController.getInstance().processLoadedDialogs(dialogs, encryptedChats, cacheOffset, offset, serverOffset, count, true, false);
+                    MessagesController.getInstance().processLoadedDialogs(dialogs, encryptedChats, offset, count, true, false, false);
                 } catch (Exception e) {
                     dialogs.dialogs.clear();
                     dialogs.users.clear();
                     dialogs.chats.clear();
                     encryptedChats.clear();
                     FileLog.e("tmessages", e);
-                    MessagesController.getInstance().processLoadedDialogs(dialogs, encryptedChats, 0, 0, 0, 100, true, true);
+                    MessagesController.getInstance().processLoadedDialogs(dialogs, encryptedChats, 0, 100, true, true, false);
                 }
             }
         });
     }
 
+    public static void createFirstHoles(long did, SQLitePreparedStatement state5, SQLitePreparedStatement state6, SQLitePreparedStatement state7, SQLitePreparedStatement state8, ArrayList<TLRPC.Message> arrayList) throws Exception {
+        int impMessageId = 0;
+        int notImpMessageId = 0;
+        for (int a = 0; a < arrayList.size(); a++) {
+            TLRPC.Message message = arrayList.get(a);
+
+            if (MessageObject.isImportant(message)) {
+                state7.requery();
+                state7.bindLong(1, did);
+                state7.bindInteger(2, message.id == 1 ? 1 : 0);
+                state7.bindInteger(3, message.id);
+                state7.step();
+                impMessageId = Math.max(message.id, impMessageId);
+            } else {
+                notImpMessageId = Math.max(message.id, notImpMessageId);
+            }
+        }
+
+        if (impMessageId != 0 && notImpMessageId == 0) {
+            notImpMessageId = impMessageId;
+            impMessageId = 0;
+        }
+
+        if (arrayList.size() == 1) {
+            int messageId = arrayList.get(0).id;
+
+            state5.requery();
+            state5.bindLong(1, did);
+            state5.bindInteger(2, messageId == 1 ? 1 : 0);
+            state5.bindInteger(3, messageId);
+            state5.step();
+
+            for (int b = 0; b < SharedMediaQuery.MEDIA_TYPES_COUNT; b++) {
+                state6.requery();
+                state6.bindLong(1, did);
+                state6.bindInteger(2, b);
+                state6.bindInteger(3, messageId == 1 ? 1 : 0);
+                state6.bindInteger(4, messageId);
+                state6.step();
+            }
+        } else if (arrayList.size() == 2) {
+            int firstId = arrayList.get(0).id;
+            int lastId = arrayList.get(1).id;
+            if (firstId > lastId) {
+                int temp = firstId;
+                firstId = lastId;
+                lastId = temp;
+            }
+
+            state5.requery();
+            state5.bindLong(1, did);
+            state5.bindInteger(2, firstId == 1 ? 1 : 0);
+            state5.bindInteger(3, firstId);
+            state5.step();
+
+            state5.requery();
+            state5.bindLong(1, did);
+            state5.bindInteger(2, firstId);
+            state5.bindInteger(3, lastId);
+            state5.step();
+
+            for (int b = 0; b < SharedMediaQuery.MEDIA_TYPES_COUNT; b++) {
+                state6.requery();
+                state6.bindLong(1, did);
+                state6.bindInteger(2, b);
+                state6.bindInteger(3, firstId == 1 ? 1 : 0);
+                state6.bindInteger(4, firstId);
+                state6.step();
+
+                state6.requery();
+                state6.bindLong(1, did);
+                state6.bindInteger(2, b);
+                state6.bindInteger(3, firstId);
+                state6.bindInteger(4, lastId);
+                state6.step();
+            }
+
+            if (impMessageId != 0 && impMessageId < notImpMessageId) {
+                state8.requery();
+                state8.bindLong(1, did);
+                state8.bindInteger(2, impMessageId);
+                state8.bindInteger(3, Integer.MAX_VALUE);
+                state8.bindInteger(4, notImpMessageId - impMessageId);
+                state8.step();
+            }
+        }
+    }
+
     private void putDialogsInternal(final TLRPC.messages_Dialogs dialogs) {
         try {
             database.beginTransaction();
@@ -4864,7 +5167,7 @@ private void putDialogsInternal(final TLRPC.messages_Dialogs dialogs) {
                 SQLitePreparedStatement state5 = database.executeFast("REPLACE INTO messages_holes VALUES(?, ?, ?)");
                 SQLitePreparedStatement state6 = database.executeFast("REPLACE INTO media_holes_v2 VALUES(?, ?, ?, ?)");
                 SQLitePreparedStatement state7 = database.executeFast("REPLACE INTO messages_imp_holes VALUES(?, ?, ?)");
-                SQLitePreparedStatement state8 = null;
+                SQLitePreparedStatement state8 = database.executeFast("REPLACE INTO channel_group VALUES(?, ?, ?, ?)");
 
                 for (int a = 0; a < dialogs.dialogs.size(); a++) {
                     TLRPC.Dialog dialog = dialogs.dialogs.get(a);
@@ -4880,19 +5183,20 @@ private void putDialogsInternal(final TLRPC.messages_Dialogs dialogs) {
                     }
                     int messageDate = 0;
                     int messageDateI = 0;
-                    int impMessageId = 0;
-                    int notImpMessageId = 0;
+
+                    boolean isMegagroup = false;
                     ArrayList<TLRPC.Message> arrayList = new_dialogMessage.get(dialog.id);
                     if (arrayList != null) {
                         for (int b = 0; b < arrayList.size(); b++) {
                             TLRPC.Message message = arrayList.get(b);
-                            if (MessageObject.isImportant(message) || message.to_id.channel_id == 0) {
-                                messageDate = message.date;
+                            if (message.to_id.channel_id == 0 || MessageObject.isImportant(message)) {
+                                messageDate = Math.max(message.date, messageDate);
                             } else {
-                                messageDateI = message.date;
+                                messageDateI = Math.max(message.date, messageDateI);
                             }
+                            isMegagroup = MessageObject.isMegagroup(message);
 
-                            if (message.reply_markup != null && ((message.reply_markup.flags & 4) == 0 || (message.flags & 16) != 0)) {
+                            if (message.reply_markup != null && (!message.reply_markup.selective || message.mentioned)) {
                                 BotQuery.putBotKeyboard(dialog.id, message);
                             }
 
@@ -4922,17 +5226,6 @@ private void putDialogsInternal(final TLRPC.messages_Dialogs dialogs) {
                             state.bindInteger(10, MessageObject.isImportant(message) ? 1 : 0);
                             state.step();
 
-                            if (MessageObject.isImportant(message)) {
-                                state7.requery();
-                                state7.bindLong(1, dialog.id);
-                                state7.bindInteger(2, message.id == 1 ? 1 : 0);
-                                state7.bindInteger(3, message.id);
-                                state7.step();
-                                impMessageId = message.id;
-                            } else {
-                                notImpMessageId = message.id;
-                            }
-
                             if (SharedMediaQuery.canAddMessageToMedia(message)) {
                                 state3.requery();
                                 state3.bindLong(1, messageId);
@@ -4944,75 +5237,17 @@ private void putDialogsInternal(final TLRPC.messages_Dialogs dialogs) {
                             }
                             data.reuse();
                         }
-                        if (impMessageId != 0 && notImpMessageId == 0) {
-                            notImpMessageId = impMessageId;
-                            impMessageId = 0;
-                        }
 
-                        if (notImpMessageId != 0 && impMessageId == 0) {
-                            state5.requery();
-                            state5.bindLong(1, dialog.id);
-                            state5.bindInteger(2, notImpMessageId == 1 ? 1 : 0);
-                            state5.bindInteger(3, notImpMessageId);
-                            state5.step();
-
-                            for (int b = 0; b < SharedMediaQuery.MEDIA_TYPES_COUNT; b++) {
-                                state6.requery();
-                                state6.bindLong(1, dialog.id);
-                                state6.bindInteger(2, b);
-                                state6.bindInteger(3, notImpMessageId == 1 ? 1 : 0);
-                                state6.bindInteger(4, notImpMessageId);
-                                state6.step();
-                            }
-                        } else {
-                            int firstId = impMessageId > notImpMessageId ? notImpMessageId : impMessageId;
-                            int lastId = impMessageId > notImpMessageId ? impMessageId : notImpMessageId;
-
-                            state5.requery();
-                            state5.bindLong(1, dialog.id);
-                            state5.bindInteger(2, firstId == 1 ? 1 : 0);
-                            state5.bindInteger(3, firstId);
-                            state5.step();
-
-                            state5.requery();
-                            state5.bindLong(1, dialog.id);
-                            state5.bindInteger(2, firstId);
-                            state5.bindInteger(3, lastId);
-                            state5.step();
-
-                            for (int b = 0; b < SharedMediaQuery.MEDIA_TYPES_COUNT; b++) {
-                                state6.requery();
-                                state6.bindLong(1, dialog.id);
-                                state6.bindInteger(2, b);
-                                state6.bindInteger(3, firstId == 1 ? 1 : 0);
-                                state6.bindInteger(4, firstId);
-                                state6.step();
-
-                                state6.requery();
-                                state6.bindLong(1, dialog.id);
-                                state6.bindInteger(2, b);
-                                state6.bindInteger(3, firstId);
-                                state6.bindInteger(4, lastId);
-                                state6.step();
-                            }
-
-                            if (impMessageId < notImpMessageId) {
-                                if (state8 == null) {
-                                    state8 = database.executeFast("REPLACE INTO channel_group VALUES(?, ?, ?, ?)");
-                                }
-                                state8.requery();
-                                state8.bindLong(1, dialog.id);
-                                state8.bindInteger(2, impMessageId);
-                                state8.bindInteger(3, Integer.MAX_VALUE);
-                                state8.bindInteger(4, notImpMessageId - impMessageId);
-                                state8.step();
-                            }
-                        }
+                        createFirstHoles(dialog.id, state5, state6, state7, state8, arrayList);
                     }
 
                     long topMessage = dialog.top_message;
                     long topMessageI = dialog.top_not_important_message;
                     if (dialog.peer.channel_id != 0) {
+                        if (isMegagroup) {
+                            topMessage = topMessageI = Math.max(topMessage, topMessageI);
+                            messageDate = messageDateI = Math.max(messageDate, messageDateI);
+                        }
                         topMessage |= ((long) dialog.peer.channel_id) << 32;
                         topMessageI |= ((long) dialog.peer.channel_id) << 32;
                     }
@@ -5044,9 +5279,7 @@ private void putDialogsInternal(final TLRPC.messages_Dialogs dialogs) {
                 state5.dispose();
                 state6.dispose();
                 state7.dispose();
-                if (state8 != null) {
-                    state8.dispose();
-                }
+                state8.dispose();
             }
 
             putUsersInternal(dialogs.users);
@@ -5071,6 +5304,36 @@ public void run() {
         });
     }
 
+    public int getChannelReadInboxMax(final int channelId) {
+        final Semaphore semaphore = new Semaphore(0);
+        final Integer[] max = new Integer[] {0};
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                SQLiteCursor cursor = null;
+                try {
+                    cursor = database.queryFinalized("SELECT inbox_max FROM dialogs WHERE did = " + (-channelId));
+                    if (cursor.next()) {
+                        max[0] = cursor.intValue(0);
+                    }
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                } finally {
+                    if (cursor != null) {
+                        cursor.dispose();
+                    }
+                }
+                semaphore.release();
+            }
+        });
+        try {
+            semaphore.acquire();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return max[0];
+    }
+
     public int getChannelPtsSync(final int channelId) {
         final Semaphore semaphore = new Semaphore(0);
         final Integer[] pts = new Integer[] {0};
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MusicPlayerReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/MusicPlayerReceiver.java
index 3f6314f68..cb910e5a0 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MusicPlayerReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MusicPlayerReceiver.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -60,7 +60,7 @@ public void onReceive(Context context, Intent intent) {
             } else if (intent.getAction().equals(MusicPlayerService.NOTIFY_NEXT)) {
                 MediaController.getInstance().playNextMessage();
             } else if (intent.getAction().equals(MusicPlayerService.NOTIFY_CLOSE)) {
-                MediaController.getInstance().clenupPlayer(true, true);
+                MediaController.getInstance().cleanupPlayer(true, true);
             } else if (intent.getAction().equals(MusicPlayerService.NOTIFY_PREVIOUS)) {
                 MediaController.getInstance().playPreviousMessage();
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/MusicPlayerService.java b/TMessagesProj/src/main/java/org/telegram/messenger/MusicPlayerService.java
index 2aca07dd3..a6717ee0a 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/MusicPlayerService.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/MusicPlayerService.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -246,6 +246,7 @@ public void onDestroy() {
             metadataEditor.clear();
             metadataEditor.apply();
             audioManager.unregisterRemoteControlClient(remoteControlClient);
+            audioManager.abandonAudioFocus(this);
         }
         try {
             TelephonyManager mgr = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/NativeCrashManager.java b/TMessagesProj/src/main/java/org/telegram/messenger/NativeCrashManager.java
index cbfdc225a..a31184866 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/NativeCrashManager.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/NativeCrashManager.java
@@ -1,19 +1,20 @@
 package org.telegram.messenger;
 
 import android.app.Activity;
+import android.net.Uri;
 import android.util.Log;
 
 import net.hockeyapp.android.Constants;
-
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.entity.mime.MultipartEntity;
-import org.apache.http.entity.mime.content.FileBody;
-import org.apache.http.impl.client.DefaultHttpClient;
+import net.hockeyapp.android.utils.SimpleMultipartEntity;
 
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.FilenameFilter;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
 import java.util.Date;
 import java.util.UUID;
 
@@ -24,7 +25,7 @@ public static void handleDumpFiles(Activity activity) {
         for (String dumpFilename : filenames) {
             String logFilename = createLogFile();
             if (logFilename != null) {
-                uploadDumpAndLog(activity, BuildVars.HOCKEY_APP_HASH, dumpFilename, logFilename);
+                uploadDumpAndLog(activity, BuildVars.DEBUG_VERSION ? BuildVars.HOCKEY_APP_HASH_DEBUG : BuildVars.HOCKEY_APP_HASH, dumpFilename, logFilename);
             }
         }
     }
@@ -61,17 +62,29 @@ public static void uploadDumpAndLog(final Activity activity, final String identi
             @Override
             public void run() {
                 try {
-                    DefaultHttpClient httpClient = new DefaultHttpClient();
-                    HttpPost httpPost = new HttpPost("https://rink.hockeyapp.net/api/2/apps/" + identifier + "/crashes/upload");
-                    MultipartEntity entity = new MultipartEntity();
-                    File dumpFile = new File(Constants.FILES_PATH, dumpFilename);
-                    entity.addPart("attachment0", new FileBody(dumpFile));
-                    File logFile = new File(Constants.FILES_PATH, logFilename);
-                    entity.addPart("log", new FileBody(logFile));
-                    httpPost.setEntity(entity);
-                    httpClient.execute(httpPost);
-                } catch (Exception e) {
-                    FileLog.e("tmessages", e);
+                    SimpleMultipartEntity entity = new SimpleMultipartEntity();
+                    entity.writeFirstBoundaryIfNeeds();
+
+                    Uri attachmentUri = Uri.fromFile(new File(Constants.FILES_PATH, dumpFilename));
+                    InputStream input = activity.getContentResolver().openInputStream(attachmentUri);
+                    entity.addPart("attachment0", attachmentUri.getLastPathSegment(), input, false);
+
+                    attachmentUri = Uri.fromFile(new File(Constants.FILES_PATH, logFilename));
+                    input = activity.getContentResolver().openInputStream(attachmentUri);
+                    entity.addPart("log", attachmentUri.getLastPathSegment(), input, false);
+
+                    entity.writeLastBoundaryIfNeeds();
+
+                    HttpURLConnection urlConnection = (HttpURLConnection) new URL("https://rink.hockeyapp.net/api/2/apps/" + identifier + "/crashes/upload").openConnection();
+                    urlConnection.setDoOutput(true);
+                    urlConnection.setRequestMethod("POST");
+                    urlConnection.setRequestProperty("Content-Type", entity.getContentType());
+                    urlConnection.setRequestProperty("Content-Length", String.valueOf(entity.getContentLength()));
+                    urlConnection.getOutputStream().write(entity.getOutputStream().toByteArray());
+
+                    urlConnection.connect();
+                } catch (IOException e) {
+                    e.printStackTrace();
                 } finally {
                     activity.deleteFile(logFilename);
                     activity.deleteFile(dumpFilename);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/NativeLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/NativeLoader.java
index b24812c58..d7d39d55a 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/NativeLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/NativeLoader.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -23,7 +23,7 @@
 
 public class NativeLoader {
 
-    private final static int LIB_VERSION = 12;
+    private final static int LIB_VERSION = 15;
     private final static String LIB_NAME = "tmessages." + LIB_VERSION;
     private final static String LIB_SO_NAME = "lib" + LIB_NAME + ".so";
     private final static String LOCALE_LIB_SO_NAME = "lib" + LIB_NAME + "loc.so";
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationCenter.java b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationCenter.java
index 79176988b..72694ab58 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationCenter.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationCenter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -63,7 +63,7 @@
     public static final int botKeyboardDidLoaded = totalEvents++;
     public static final int chatSearchResultsAvailable = totalEvents++;
     public static final int musicDidLoaded = totalEvents++;
-    public static final int spamErrorReceived = totalEvents++;
+    public static final int needShowAlert = totalEvents++;
     public static final int didUpdatedMessagesViews = totalEvents++;
     public static final int needReloadRecentDialogsSearch = totalEvents++;
 
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationRepeat.java b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationRepeat.java
index 0b2668d94..78dd91d05 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationRepeat.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationRepeat.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationsController.java b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationsController.java
index daee1a18c..cb9cb3bf2 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationsController.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationsController.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -51,7 +51,7 @@
     private DispatchQueue notificationsQueue = new DispatchQueue("notificationsQueue");
     private ArrayList<MessageObject> pushMessages = new ArrayList<>();
     private ArrayList<MessageObject> delayedPushMessages = new ArrayList<>();
-    private HashMap<Integer, MessageObject> pushMessagesDict = new HashMap<>();
+    private HashMap<Long, MessageObject> pushMessagesDict = new HashMap<>();
     private HashMap<Long, Point> smartNotificationsDialogs = new HashMap<>();
     private NotificationManagerCompat notificationManager = null;
     private HashMap<Long, Integer> pushDialogs = new HashMap<>();
@@ -141,38 +141,539 @@ public void run() {
     }
 
     public void cleanup() {
-        openned_dialog_id = 0;
-        total_unread_count = 0;
-        personal_count = 0;
-        pushMessages.clear();
-        pushMessagesDict.clear();
-        pushDialogs.clear();
         popupMessages.clear();
-        wearNotificationsIds.clear();
-        autoNotificationsIds.clear();
-        delayedPushMessages.clear();
-        notifyCheck = false;
-        lastBadgeCount = 0;
-        try {
-            if (notificationDelayWakelock.isHeld()) {
-                notificationDelayWakelock.release();
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                openned_dialog_id = 0;
+                total_unread_count = 0;
+                personal_count = 0;
+                pushMessages.clear();
+                pushMessagesDict.clear();
+                pushDialogs.clear();
+                wearNotificationsIds.clear();
+                autoNotificationsIds.clear();
+                delayedPushMessages.clear();
+                notifyCheck = false;
+                lastBadgeCount = 0;
+                try {
+                    if (notificationDelayWakelock.isHeld()) {
+                        notificationDelayWakelock.release();
+                    }
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+                setBadge(0);
+                SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
+                SharedPreferences.Editor editor = preferences.edit();
+                editor.clear();
+                editor.commit();
             }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-        setBadge(0);
-        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
-        SharedPreferences.Editor editor = preferences.edit();
-        editor.clear();
-        editor.commit();
+        });
     }
 
     public void setInChatSoundEnabled(boolean value) {
         inChatSoundEnabled = value;
     }
 
-    public void setOpennedDialogId(long dialog_id) {
-        openned_dialog_id = dialog_id;
+    public void setOpennedDialogId(final long dialog_id) {
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                openned_dialog_id = dialog_id;
+            }
+        });
+    }
+
+    public void setLastOnlineFromOtherDevice(final int time) {
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                FileLog.e("tmessages", "set last online from other device = " + time);
+                lastOnlineFromOtherDevice = time;
+            }
+        });
+    }
+
+    public void removeNotificationsForDialog(long did) {
+        NotificationsController.getInstance().processReadMessages(null, did, 0, Integer.MAX_VALUE, false);
+        HashMap<Long, Integer> dialogsToUpdate = new HashMap<>();
+        dialogsToUpdate.put(did, 0);
+        NotificationsController.getInstance().processDialogsUpdateRead(dialogsToUpdate);
+    }
+
+    public void removeDeletedMessagesFromNotifications(final SparseArray<ArrayList<Integer>> deletedMessages) {
+        final ArrayList<MessageObject> popupArray = popupMessages.isEmpty() ? null : new ArrayList<>(popupMessages);
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                int old_unread_count = total_unread_count;
+                SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
+                for (int a = 0; a < deletedMessages.size(); a++) {
+                    int key = deletedMessages.keyAt(a);
+                    long dialog_id = -key;
+                    ArrayList<Integer> mids = deletedMessages.get(key);
+                    Integer currentCount = pushDialogs.get(dialog_id);
+                    if (currentCount == null) {
+                        currentCount = 0;
+                    }
+                    Integer newCount = currentCount;
+                    for (int b = 0; b < mids.size(); b++) {
+                        long mid = mids.get(b);
+                        mid |= ((long) key) << 32;
+                        MessageObject messageObject = pushMessagesDict.get(mid);
+                        if (messageObject != null) {
+                            pushMessagesDict.remove(mid);
+                            delayedPushMessages.remove(messageObject);
+                            pushMessages.remove(messageObject);
+                            if (isPersonalMessage(messageObject)) {
+                                personal_count--;
+                            }
+                            if (popupArray != null) {
+                                popupArray.remove(messageObject);
+                            }
+                            newCount--;
+                        }
+                    }
+                    if (newCount <= 0) {
+                        newCount = 0;
+                        smartNotificationsDialogs.remove(dialog_id);
+                    }
+                    if (!newCount.equals(currentCount)) {
+                        total_unread_count -= currentCount;
+                        total_unread_count += newCount;
+                        pushDialogs.put(dialog_id, newCount);
+                    }
+                    if (newCount == 0) {
+                        pushDialogs.remove(dialog_id);
+                        pushDialogsOverrideMention.remove(dialog_id);
+                        if (popupArray != null && pushMessages.isEmpty() && !popupArray.isEmpty()) {
+                            popupArray.clear();
+                        }
+                    }
+                }
+                if (popupArray != null) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            popupMessages = popupArray;
+                        }
+                    });
+                }
+                if (old_unread_count != total_unread_count) {
+                    if (!notifyCheck) {
+                        delayedPushMessages.clear();
+                        showOrUpdateNotification(notifyCheck);
+                    } else {
+                        scheduleNotificationDelay(lastOnlineFromOtherDevice > ConnectionsManager.getInstance().getCurrentTime());
+                    }
+                }
+                notifyCheck = false;
+                if (preferences.getBoolean("badgeNumber", true)) {
+                    setBadge(total_unread_count);
+                }
+            }
+        });
+    }
+
+    public void processReadMessages(final SparseArray<Long> inbox, final long dialog_id, final int max_date, final int max_id, final boolean isPopup) {
+        final ArrayList<MessageObject> popupArray = popupMessages.isEmpty() ? null : new ArrayList<>(popupMessages);
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                int oldCount = popupArray != null ? popupArray.size() : 0;
+                if (inbox != null) {
+                    for (int b = 0; b < inbox.size(); b++) {
+                        int key = inbox.keyAt(b);
+                        long messageId = inbox.get(key);
+                        for (int a = 0; a < pushMessages.size(); a++) {
+                            MessageObject messageObject = pushMessages.get(a);
+                            if (messageObject.getDialogId() == key && messageObject.getId() <= (int) messageId) {
+                                if (isPersonalMessage(messageObject)) {
+                                    personal_count--;
+                                }
+                                if (popupArray != null) {
+                                    popupArray.remove(messageObject);
+                                }
+                                long mid = messageObject.messageOwner.id;
+                                if (messageObject.messageOwner.to_id.channel_id != 0) {
+                                    mid |= ((long) messageObject.messageOwner.to_id.channel_id) << 32;
+                                }
+                                pushMessagesDict.remove(mid);
+                                delayedPushMessages.remove(messageObject);
+                                pushMessages.remove(a);
+                                a--;
+                            }
+                        }
+                    }
+                    if (popupArray != null && pushMessages.isEmpty() && !popupArray.isEmpty()) {
+                        popupArray.clear();
+                    }
+                }
+                if (dialog_id != 0 && (max_id != 0 || max_date != 0)) {
+                    for (int a = 0; a < pushMessages.size(); a++) {
+                        MessageObject messageObject = pushMessages.get(a);
+                        if (messageObject.getDialogId() == dialog_id) {
+                            boolean remove = false;
+                            if (max_date != 0) {
+                                if (messageObject.messageOwner.date <= max_date) {
+                                    remove = true;
+                                }
+                            } else {
+                                if (!isPopup) {
+                                    if (messageObject.getId() <= max_id || max_id < 0) {
+                                        remove = true;
+                                    }
+                                } else {
+                                    if (messageObject.getId() == max_id || max_id < 0) {
+                                        remove = true;
+                                    }
+                                }
+                            }
+                            if (remove) {
+                                if (isPersonalMessage(messageObject)) {
+                                    personal_count--;
+                                }
+                                pushMessages.remove(a);
+                                delayedPushMessages.remove(messageObject);
+                                if (popupArray != null) {
+                                    popupArray.remove(messageObject);
+                                }
+                                long mid = messageObject.messageOwner.id;
+                                if (messageObject.messageOwner.to_id.channel_id != 0) {
+                                    mid |= ((long) messageObject.messageOwner.to_id.channel_id) << 32;
+                                }
+                                pushMessagesDict.remove(mid);
+                                a--;
+                            }
+                        }
+                    }
+                    if (popupArray != null && pushMessages.isEmpty() && !popupArray.isEmpty()) {
+                        popupArray.clear();
+                    }
+                }
+                if (popupArray != null && oldCount != popupArray.size()) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            popupMessages = popupArray;
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.pushMessagesUpdated);
+                        }
+                    });
+                }
+            }
+        });
+    }
+
+    public void processNewMessages(final ArrayList<MessageObject> messageObjects, final boolean isLast) {
+        if (messageObjects.isEmpty()) {
+            return;
+        }
+        final ArrayList<MessageObject> popupArray = new ArrayList<>(popupMessages);
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                boolean added = false;
+
+                int oldCount = popupArray.size();
+                HashMap<Long, Boolean> settingsCache = new HashMap<>();
+                SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
+                int popup = 0;
+
+                for (int a = 0; a < messageObjects.size(); a++) {
+                    MessageObject messageObject = messageObjects.get(a);
+                    long mid = messageObject.messageOwner.id;
+                    if (messageObject.messageOwner.to_id.channel_id != 0) {
+                        mid |= ((long) messageObject.messageOwner.to_id.channel_id) << 32;
+                    }
+                    if (pushMessagesDict.containsKey(mid)) {
+                        continue;
+                    }
+                    long dialog_id = messageObject.getDialogId();
+                    long original_dialog_id = dialog_id;
+                    if (dialog_id == openned_dialog_id && ApplicationLoader.isScreenOn) {
+                        playInChatSound();
+                        continue;
+                    }
+                    if (messageObject.messageOwner.mentioned) {
+                        dialog_id = messageObject.messageOwner.from_id;
+                    }
+                    if (isPersonalMessage(messageObject)) {
+                        personal_count++;
+                    }
+                    added = true;
+
+                    Boolean value = settingsCache.get(dialog_id);
+                    boolean isChat = (int)dialog_id < 0;
+                    popup = (int)dialog_id == 0 ? 0 : preferences.getInt(isChat ? "popupGroup" : "popupAll", 0);
+                    if (value == null) {
+                        int notifyOverride = getNotifyOverride(preferences, dialog_id);
+                        value = !(notifyOverride == 2 || (!preferences.getBoolean("EnableAll", true) || isChat && !preferences.getBoolean("EnableGroup", true)) && notifyOverride == 0);
+                        settingsCache.put(dialog_id, value);
+                    }
+                    if (value) {
+                        if (popup != 0) {
+                            popupArray.add(0, messageObject);
+                        }
+                        delayedPushMessages.add(messageObject);
+                        pushMessages.add(0, messageObject);
+                        pushMessagesDict.put(mid, messageObject);
+                        if (original_dialog_id != dialog_id) {
+                            pushDialogsOverrideMention.put(original_dialog_id, 1);
+                        }
+                    }
+                }
+
+                if (added) {
+                    notifyCheck = isLast;
+                }
+
+                if (!popupArray.isEmpty() && oldCount != popupArray.size() && !AndroidUtilities.needShowPasscode(false)) {
+                    final int popupFinal = popup;
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            popupMessages = popupArray;
+                            if (ApplicationLoader.mainInterfacePaused || !ApplicationLoader.isScreenOn && !UserConfig.isWaitingForPasscodeEnter) {
+                                MessageObject messageObject = messageObjects.get(0);
+                                if (popupFinal == 3 || popupFinal == 1 && ApplicationLoader.isScreenOn || popupFinal == 2 && !ApplicationLoader.isScreenOn) {
+                                    Intent popupIntent = new Intent(ApplicationLoader.applicationContext, PopupNotificationActivity.class);
+                                    popupIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION | Intent.FLAG_ACTIVITY_NO_USER_ACTION | Intent.FLAG_FROM_BACKGROUND);
+                                    ApplicationLoader.applicationContext.startActivity(popupIntent);
+                                }
+                            }
+                        }
+                    });
+                }
+            }
+        });
+    }
+
+    public void processDialogsUpdateRead(final HashMap<Long, Integer> dialogsToUpdate) {
+        final ArrayList<MessageObject> popupArray = popupMessages.isEmpty() ? null : new ArrayList<>(popupMessages);
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                int old_unread_count = total_unread_count;
+                SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
+                for (HashMap.Entry<Long, Integer> entry : dialogsToUpdate.entrySet()) {
+                    long dialog_id = entry.getKey();
+
+                    int notifyOverride = getNotifyOverride(preferences, dialog_id);
+                    if (notifyCheck) {
+                        Integer override = pushDialogsOverrideMention.get(dialog_id);
+                        if (override != null && override == 1) {
+                            pushDialogsOverrideMention.put(dialog_id, 0);
+                            notifyOverride = 1;
+                        }
+                    }
+                    boolean canAddValue = !(notifyOverride == 2 || (!preferences.getBoolean("EnableAll", true) || ((int)dialog_id < 0) && !preferences.getBoolean("EnableGroup", true)) && notifyOverride == 0);
+
+                    Integer currentCount = pushDialogs.get(dialog_id);
+                    Integer newCount = entry.getValue();
+                    if (newCount == 0) {
+                        smartNotificationsDialogs.remove(dialog_id);
+                    }
+
+                    if (newCount < 0) {
+                        if (currentCount == null) {
+                            continue;
+                        }
+                        newCount = currentCount + newCount;
+                    }
+                    if (canAddValue || newCount == 0) {
+                        if (currentCount != null) {
+                            total_unread_count -= currentCount;
+                        }
+                    }
+                    if (newCount == 0) {
+                        pushDialogs.remove(dialog_id);
+                        pushDialogsOverrideMention.remove(dialog_id);
+                        for (int a = 0; a < pushMessages.size(); a++) {
+                            MessageObject messageObject = pushMessages.get(a);
+                            if (messageObject.getDialogId() == dialog_id) {
+                                if (isPersonalMessage(messageObject)) {
+                                    personal_count--;
+                                }
+                                pushMessages.remove(a);
+                                a--;
+                                delayedPushMessages.remove(messageObject);
+                                long mid = messageObject.messageOwner.id;
+                                if (messageObject.messageOwner.to_id.channel_id != 0) {
+                                    mid |= ((long) messageObject.messageOwner.to_id.channel_id) << 32;
+                                }
+                                pushMessagesDict.remove(mid);
+                                if (popupArray != null) {
+                                    popupArray.remove(messageObject);
+                                }
+                            }
+                        }
+                        if (popupArray != null && pushMessages.isEmpty() && !popupArray.isEmpty()) {
+                            popupArray.clear();
+                        }
+                    } else if (canAddValue) {
+                        total_unread_count += newCount;
+                        pushDialogs.put(dialog_id, newCount);
+                    }
+                }
+                if (popupArray != null) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            popupMessages = popupArray;
+                        }
+                    });
+                }
+                if (old_unread_count != total_unread_count) {
+                    if (!notifyCheck) {
+                        delayedPushMessages.clear();
+                        showOrUpdateNotification(notifyCheck);
+                    } else {
+                        scheduleNotificationDelay(lastOnlineFromOtherDevice > ConnectionsManager.getInstance().getCurrentTime());
+                    }
+                }
+                notifyCheck = false;
+                if (preferences.getBoolean("badgeNumber", true)) {
+                    setBadge(total_unread_count);
+                }
+            }
+        });
+    }
+
+    public void processLoadedUnreadMessages(final HashMap<Long, Integer> dialogs, final ArrayList<TLRPC.Message> messages, final ArrayList<TLRPC.User> users, final ArrayList<TLRPC.Chat> chats, final ArrayList<TLRPC.EncryptedChat> encryptedChats) {
+        MessagesController.getInstance().putUsers(users, true);
+        MessagesController.getInstance().putChats(chats, true);
+        MessagesController.getInstance().putEncryptedChats(encryptedChats, true);
+
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                pushDialogs.clear();
+                pushMessages.clear();
+                pushMessagesDict.clear();
+                total_unread_count = 0;
+                personal_count = 0;
+                SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
+                HashMap<Long, Boolean> settingsCache = new HashMap<>();
+
+                if (messages != null) {
+                    for (TLRPC.Message message : messages) {
+                        long mid = message.id;
+                        if (message.to_id.channel_id != 0) {
+                            mid |= ((long) message.to_id.channel_id) << 32;
+                        }
+                        if (pushMessagesDict.containsKey(mid)) {
+                            continue;
+                        }
+                        MessageObject messageObject = new MessageObject(message, null, false);
+                        if (isPersonalMessage(messageObject)) {
+                            personal_count++;
+                        }
+                        long dialog_id = messageObject.getDialogId();
+                        long original_dialog_id = dialog_id;
+                        if (messageObject.messageOwner.mentioned) {
+                            dialog_id = messageObject.messageOwner.from_id;
+                        }
+                        Boolean value = settingsCache.get(dialog_id);
+                        if (value == null) {
+                            int notifyOverride = getNotifyOverride(preferences, dialog_id);
+                            value = !(notifyOverride == 2 || (!preferences.getBoolean("EnableAll", true) || ((int) dialog_id < 0) && !preferences.getBoolean("EnableGroup", true)) && notifyOverride == 0);
+                            settingsCache.put(dialog_id, value);
+                        }
+                        if (!value || dialog_id == openned_dialog_id && ApplicationLoader.isScreenOn) {
+                            continue;
+                        }
+                        pushMessagesDict.put(mid, messageObject);
+                        pushMessages.add(0, messageObject);
+                        if (original_dialog_id != dialog_id) {
+                            pushDialogsOverrideMention.put(original_dialog_id, 1);
+                        }
+                    }
+                }
+                for (HashMap.Entry<Long, Integer> entry : dialogs.entrySet()) {
+                    long dialog_id = entry.getKey();
+                    Boolean value = settingsCache.get(dialog_id);
+                    if (value == null) {
+                        int notifyOverride = getNotifyOverride(preferences, dialog_id);
+                        Integer override = pushDialogsOverrideMention.get(dialog_id);
+                        if (override != null && override == 1) {
+                            pushDialogsOverrideMention.put(dialog_id, 0);
+                            notifyOverride = 1;
+                        }
+                        value = !(notifyOverride == 2 || (!preferences.getBoolean("EnableAll", true) || ((int) dialog_id < 0) && !preferences.getBoolean("EnableGroup", true)) && notifyOverride == 0);
+                        settingsCache.put(dialog_id, value);
+                    }
+                    if (!value) {
+                        continue;
+                    }
+                    int count = entry.getValue();
+                    pushDialogs.put(dialog_id, count);
+                    total_unread_count += count;
+                }
+                if (total_unread_count == 0) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            popupMessages.clear();
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.pushMessagesUpdated);
+                        }
+                    });
+                }
+                showOrUpdateNotification(SystemClock.uptimeMillis() / 1000 < 60);
+
+                if (preferences.getBoolean("badgeNumber", true)) {
+                    setBadge(total_unread_count);
+                }
+            }
+        });
+    }
+
+    public void setBadgeEnabled(boolean enabled) {
+        setBadge(enabled ? total_unread_count : 0);
+    }
+
+    private void setBadge(final int count) {
+        notificationsQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                if (lastBadgeCount == count) {
+                    return;
+                }
+                lastBadgeCount = count;
+                try {
+                    ContentValues cv = new ContentValues();
+                    cv.put("tag", "org.telegram.messenger/org.telegram.ui.LaunchActivity");
+                    cv.put("count", count);
+                    ApplicationLoader.applicationContext.getContentResolver().insert(Uri.parse("content://com.teslacoilsw.notifier/unread_count"), cv);
+                } catch (Throwable e) {
+                    //ignore
+                }
+                try {
+                    if (launcherClassName == null) {
+                        launcherClassName = getLauncherClassName(ApplicationLoader.applicationContext);
+                    }
+                    if (launcherClassName == null) {
+                        return;
+                    }
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                Intent intent = new Intent("android.intent.action.BADGE_COUNT_UPDATE");
+                                intent.putExtra("badge_count", count);
+                                intent.putExtra("badge_count_package_name", ApplicationLoader.applicationContext.getPackageName());
+                                intent.putExtra("badge_count_class_name", launcherClassName);
+                                ApplicationLoader.applicationContext.sendBroadcast(intent);
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                        }
+                    });
+                } catch (Throwable e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
     }
 
     private String getStringForMessage(MessageObject messageObject, boolean shortMessage) {
@@ -230,7 +731,7 @@ private String getStringForMessage(MessageObject messageObject, boolean shortMes
                         } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionUserUpdatedPhoto) {
                             msg = LocaleController.formatString("NotificationContactNewPhoto", R.string.NotificationContactNewPhoto, name);
                         } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionLoginUnknownLocation) {
-                            String date = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.formatterYear.format(((long) messageObject.messageOwner.date) * 1000), LocaleController.formatterDay.format(((long) messageObject.messageOwner.date) * 1000));
+                            String date = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.getInstance().formatterYear.format(((long) messageObject.messageOwner.date) * 1000), LocaleController.getInstance().formatterDay.format(((long) messageObject.messageOwner.date) * 1000));
                             msg = LocaleController.formatString("NotificationUnrecognizedDevice", R.string.NotificationUnrecognizedDevice, UserConfig.getCurrentUser().first_name, date, messageObject.messageOwner.action.title, messageObject.messageOwner.action.address);
                         }
                     } else {
@@ -270,35 +771,54 @@ private String getStringForMessage(MessageObject messageObject, boolean shortMes
                 if (preferences.getBoolean("EnablePreviewGroup", true)) {
                     if (messageObject.messageOwner instanceof TLRPC.TL_messageService) {
                         if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChatAddUser) {
-                            if (messageObject.messageOwner.to_id.channel_id != 0) {
-                                TLRPC.User user = MessagesController.getInstance().getUser(messageObject.messageOwner.action.user_id);
-                                if (user != null) {
-                                    name = UserObject.getUserName(user);
+                            int singleUserId = messageObject.messageOwner.action.user_id;
+                            if (singleUserId == 0 && messageObject.messageOwner.action.users.size() == 1) {
+                                singleUserId = messageObject.messageOwner.action.users.get(0);
+                            }
+                            if (singleUserId != 0) {
+                                if (messageObject.messageOwner.to_id.channel_id != 0 && !messageObject.isMegagroup()) {
+                                    TLRPC.User user = MessagesController.getInstance().getUser(singleUserId);
+                                    if (user != null) {
+                                        name = UserObject.getUserName(user);
+                                    } else {
+                                        name = "";
+                                    }
+                                    msg = LocaleController.formatString("ChannelAddedByNotification", R.string.ChannelAddedByNotification, name, chat.title);
                                 } else {
-                                    name = "";
+                                    if (singleUserId == UserConfig.getClientUserId()) {
+                                        msg = LocaleController.formatString("NotificationInvitedToGroup", R.string.NotificationInvitedToGroup, name, chat.title);
+                                    } else {
+                                        TLRPC.User u2 = MessagesController.getInstance().getUser(singleUserId);
+                                        if (u2 == null) {
+                                            return null;
+                                        }
+                                        if (from_id == u2.id) {
+                                            msg = LocaleController.formatString("NotificationGroupAddSelf", R.string.NotificationGroupAddSelf, name, chat.title);
+                                        } else {
+                                            msg = LocaleController.formatString("NotificationGroupAddMember", R.string.NotificationGroupAddMember, name, chat.title, UserObject.getUserName(u2));
+                                        }
+                                    }
                                 }
-                                msg = LocaleController.formatString("ChannelAddedByNotification", R.string.ChannelAddedByNotification, name, chat.title);
                             } else {
-                                if (messageObject.messageOwner.action.user_id == UserConfig.getClientUserId()) {
-                                    msg = LocaleController.formatString("NotificationInvitedToGroup", R.string.NotificationInvitedToGroup, name, chat.title);
-                                } else {
-                                    TLRPC.User u2 = MessagesController.getInstance().getUser(messageObject.messageOwner.action.user_id);
-                                    if (u2 == null) {
-                                        return null;
-                                    }
-                                    if (from_id == u2.id) {
-                                        msg = LocaleController.formatString("NotificationGroupAddSelf", R.string.NotificationGroupAddSelf, name, chat.title);
-                                    } else {
-                                        msg = LocaleController.formatString("NotificationGroupAddMember", R.string.NotificationGroupAddMember, name, chat.title, UserObject.getUserName(u2));
+                                StringBuilder names = new StringBuilder("");
+                                for (int a = 0; a < messageObject.messageOwner.action.users.size(); a++) {
+                                    TLRPC.User user = MessagesController.getInstance().getUser(messageObject.messageOwner.action.users.get(a));
+                                    if (user != null) {
+                                        String name2 = UserObject.getUserName(user);
+                                        if (names.length() != 0) {
+                                            names.append(", ");
+                                        }
+                                        names.append(name2);
                                     }
                                 }
+                                msg = LocaleController.formatString("NotificationGroupAddMember", R.string.NotificationGroupAddMember, name, chat.title, names.toString());
                             }
                         } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChatJoinedByLink) {
                             msg = LocaleController.formatString("NotificationInvitedToGroupByLink", R.string.NotificationInvitedToGroupByLink, name, chat.title);
                         } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChatEditTitle) {
                             msg = LocaleController.formatString("NotificationEditedGroupName", R.string.NotificationEditedGroupName, name, messageObject.messageOwner.action.title);
                         } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChatEditPhoto || messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChatDeletePhoto) {
-                            if (messageObject.messageOwner.to_id.channel_id != 0) {
+                            if (messageObject.messageOwner.to_id.channel_id != 0 && !messageObject.isMegagroup()) {
                                 msg = LocaleController.formatString("ChannelPhotoEditNotification", R.string.ChannelPhotoEditNotification, chat.title);
                             } else {
                                 msg = LocaleController.formatString("NotificationEditedGroupPhoto", R.string.NotificationEditedGroupPhoto, name, chat.title);
@@ -319,9 +839,13 @@ private String getStringForMessage(MessageObject messageObject, boolean shortMes
                             msg = messageObject.messageText.toString();
                         } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChannelCreate) {
                             msg = messageObject.messageText.toString();
+                        } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChatMigrateTo) {
+                            msg = LocaleController.formatString("ActionMigrateFromGroupNotify", R.string.ActionMigrateFromGroupNotify, chat.title);
+                        } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChannelMigrateFrom) {
+                            msg = LocaleController.formatString("ActionMigrateFromGroupNotify", R.string.ActionMigrateFromGroupNotify, messageObject.messageOwner.action.title);
                         }
                     } else {
-                        if (ChatObject.isChannel(chat)) {
+                        if (ChatObject.isChannel(chat) && !chat.megagroup) {
                             if (from_id < 0) {
                                 if (messageObject.isMediaEmpty()) {
                                     if (!shortMessage && messageObject.messageOwner.message != null && messageObject.messageOwner.message.length() != 0) {
@@ -420,6 +944,119 @@ private void scheduleNotificationRepeat() {
         }
     }
 
+    private static String getLauncherClassName(Context context) {
+        try {
+            PackageManager pm = context.getPackageManager();
+
+            Intent intent = new Intent(Intent.ACTION_MAIN);
+            intent.addCategory(Intent.CATEGORY_LAUNCHER);
+
+            List<ResolveInfo> resolveInfos = pm.queryIntentActivities(intent, 0);
+            for (ResolveInfo resolveInfo : resolveInfos) {
+                String pkgName = resolveInfo.activityInfo.applicationInfo.packageName;
+                if (pkgName.equalsIgnoreCase(context.getPackageName())) {
+                    return resolveInfo.activityInfo.name;
+                }
+            }
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+        return null;
+    }
+
+    private boolean isPersonalMessage(MessageObject messageObject) {
+        return messageObject.messageOwner.to_id != null && messageObject.messageOwner.to_id.chat_id == 0 && messageObject.messageOwner.to_id.channel_id == 0
+                && (messageObject.messageOwner.action == null || messageObject.messageOwner.action instanceof TLRPC.TL_messageActionEmpty);
+    }
+
+    private int getNotifyOverride(SharedPreferences preferences, long dialog_id) {
+        int notifyOverride = preferences.getInt("notify2_" + dialog_id, 0);
+        if (notifyOverride == 3) {
+            int muteUntil = preferences.getInt("notifyuntil_" + dialog_id, 0);
+            if (muteUntil >= ConnectionsManager.getInstance().getCurrentTime()) {
+                notifyOverride = 2;
+            }
+        }
+        return notifyOverride;
+    }
+
+    private void dismissNotification() {
+        try {
+            notificationManager.cancel(1);
+            pushMessages.clear();
+            pushMessagesDict.clear();
+            for (HashMap.Entry<Long, Integer> entry : autoNotificationsIds.entrySet()) {
+                notificationManager.cancel(entry.getValue());
+            }
+            autoNotificationsIds.clear();
+            for (HashMap.Entry<Long, Integer> entry : wearNotificationsIds.entrySet()) {
+                notificationManager.cancel(entry.getValue());
+            }
+            wearNotificationsIds.clear();
+            AndroidUtilities.runOnUIThread(new Runnable() {
+                @Override
+                public void run() {
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.pushMessagesUpdated);
+                }
+            });
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    private void playInChatSound() {
+        if (!inChatSoundEnabled) {
+            return;
+        }
+        try {
+            if (audioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT) {
+                return;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+
+        try {
+            SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
+            int notifyOverride = getNotifyOverride(preferences, openned_dialog_id);
+            if (notifyOverride == 2) {
+                return;
+            }
+            notificationsQueue.postRunnable(new Runnable() {
+                @Override
+                public void run() {
+                    if (Math.abs(System.currentTimeMillis() - lastSoundPlay) <= 500) {
+                        return;
+                    }
+                    try {
+                        if (soundPool == null) {
+                            soundPool = new SoundPool(2, AudioManager.STREAM_SYSTEM, 0);
+                            soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() {
+                                @Override
+                                public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
+                                    if (status == 0) {
+                                        soundPool.play(sampleId, 1.0f, 1.0f, 1, 0, 1.0f);
+                                    }
+                                }
+                            });
+                        }
+                        if (soundIn == 0 && !soundInLoaded) {
+                            soundInLoaded = true;
+                            soundIn = soundPool.load(ApplicationLoader.applicationContext, R.raw.sound_in, 1);
+                        }
+                        if (soundIn != 0) {
+                            soundPool.play(soundIn, 1.0f, 1.0f, 1, 0, 1.0f);
+                        }
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                }
+            });
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
     private void scheduleNotificationDelay(boolean onlineReason) {
         try {
             FileLog.e("tmessages", "delay notification start, onlineReason = " + onlineReason);
@@ -433,21 +1070,16 @@ private void scheduleNotificationDelay(boolean onlineReason) {
     }
 
     protected void repeatNotificationMaybe() {
-        int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
-        if (hour >= 11 && hour <= 22) {
-            notificationManager.cancel(1);
-            showOrUpdateNotification(true);
-        } else {
-            scheduleNotificationRepeat();
-        }
-    }
-
-    public void setLastOnlineFromOtherDevice(final int time) {
-        AndroidUtilities.runOnUIThread(new Runnable() {
+        notificationsQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
-                FileLog.e("tmessages", "set last online from other device = " + time);
-                lastOnlineFromOtherDevice = time;
+                int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
+                if (hour >= 11 && hour <= 22) {
+                    notificationManager.cancel(1);
+                    showOrUpdateNotification(true);
+                } else {
+                    scheduleNotificationRepeat();
+                }
             }
         });
     }
@@ -464,7 +1096,7 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
 
             long dialog_id = lastMessageObject.getDialogId();
             long override_dialog_id = dialog_id;
-            if ((lastMessageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_MENTION) != 0) {
+            if (lastMessageObject.messageOwner.mentioned) {
                 override_dialog_id = lastMessageObject.messageOwner.from_id;
             }
             int mid = lastMessageObject.getId();
@@ -614,7 +1246,7 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
                             if (chat.photo != null && chat.photo.photo_small != null && chat.photo.photo_small.volume_id != 0 && chat.photo.photo_small.local_id != 0) {
                                 photoPath = chat.photo.photo_small;
                             }
-                        } else {
+                        } else if (user != null) {
                             if (user.photo != null && user.photo.photo_small != null && user.photo.photo_small.volume_id != 0 && user.photo.photo_small.local_id != 0) {
                                 photoPath = user.photo.photo_small;
                             }
@@ -630,7 +1262,7 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
 
             String name;
             boolean replace = true;
-            if ((int)dialog_id == 0 || pushDialogs.size() > 1 || AndroidUtilities.needShowPasscode(false) || UserConfig.isWaitingForPasscodeEnter) {
+            if ((int) dialog_id == 0 || pushDialogs.size() > 1 || AndroidUtilities.needShowPasscode(false) || UserConfig.isWaitingForPasscodeEnter) {
                 name = LocaleController.getString("AppName", R.string.AppName);
                 replace = false;
             } else {
@@ -770,7 +1402,7 @@ private void showOrUpdateNotification(boolean notifyAboutLast) {
     }
 
     @SuppressLint("InlinedApi")
-    public void showExtraNotifications(NotificationCompat.Builder notificationBuilder, boolean notifyAboutLast) {
+    private void showExtraNotifications(NotificationCompat.Builder notificationBuilder, boolean notifyAboutLast) {
         if (Build.VERSION.SDK_INT < 18) {
             return;
         }
@@ -820,10 +1452,24 @@ public void showExtraNotifications(NotificationCompat.Builder notificationBuilde
                     continue;
                 }
             }
-            if (chat != null) {
-                name = chat.title;
+            TLRPC.FileLocation photoPath = null;
+            if (AndroidUtilities.needShowPasscode(false) || UserConfig.isWaitingForPasscodeEnter) {
+                name = LocaleController.getString("AppName", R.string.AppName);
             } else {
-                name = UserObject.getUserName(user);
+                if (chat != null) {
+                    name = chat.title;
+                } else {
+                    name = UserObject.getUserName(user);
+                }
+                if (chat != null) {
+                    if (chat.photo != null && chat.photo.photo_small != null && chat.photo.photo_small.volume_id != 0 && chat.photo.photo_small.local_id != 0) {
+                        photoPath = chat.photo.photo_small;
+                    }
+                } else {
+                    if (user.photo != null && user.photo.photo_small != null && user.photo.photo_small.volume_id != 0 && user.photo.photo_small.local_id != 0) {
+                        photoPath = user.photo.photo_small;
+                    }
+                }
             }
 
             Integer notificationIdWear = oldIdsWear.get(dialog_id);
@@ -852,7 +1498,7 @@ public void showExtraNotifications(NotificationCompat.Builder notificationBuilde
 
             NotificationCompat.Action wearReplyAction = null;
 
-            if (!ChatObject.isChannel(chat)) {
+            if (!ChatObject.isChannel(chat) && !AndroidUtilities.needShowPasscode(false) && !UserConfig.isWaitingForPasscodeEnter) {
                 Intent msgReplyIntent = new Intent();
                 msgReplyIntent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES);
                 msgReplyIntent.setAction("org.telegram.messenger.ACTION_MESSAGE_REPLY");
@@ -889,22 +1535,11 @@ public void showExtraNotifications(NotificationCompat.Builder notificationBuilde
                     message = message.replace(name + ": ", "").replace(name + " ", "");
                 }
                 if (text.length() > 0) {
-                    text += "\n\n";
-                }
-                text += message;
-
-                unreadConvBuilder.addMessage(message);
-            }
-
-            TLRPC.FileLocation photoPath = null;
-            if (chat != null) {
-                if (chat.photo != null && chat.photo.photo_small != null && chat.photo.photo_small.volume_id != 0 && chat.photo.photo_small.local_id != 0) {
-                    photoPath = chat.photo.photo_small;
-                }
-            } else {
-                if (user.photo != null && user.photo.photo_small != null && user.photo.photo_small.volume_id != 0 && user.photo.photo_small.local_id != 0) {
-                    photoPath = user.photo.photo_small;
+                    text += "\n\n";
                 }
+                text += message;
+
+                unreadConvBuilder.addMessage(message);
             }
 
             Intent intent = new Intent(ApplicationLoader.applicationContext, LaunchActivity.class);
@@ -953,143 +1588,6 @@ public void showExtraNotifications(NotificationCompat.Builder notificationBuilde
         }
     }
 
-    private void dismissNotification() {
-        try {
-            notificationManager.cancel(1);
-            pushMessages.clear();
-            pushMessagesDict.clear();
-            for (HashMap.Entry<Long, Integer> entry : autoNotificationsIds.entrySet()) {
-                notificationManager.cancel(entry.getValue());
-            }
-            autoNotificationsIds.clear();
-            for (HashMap.Entry<Long, Integer> entry : wearNotificationsIds.entrySet()) {
-                notificationManager.cancel(entry.getValue());
-            }
-            wearNotificationsIds.clear();
-            NotificationCenter.getInstance().postNotificationName(NotificationCenter.pushMessagesUpdated);
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-    }
-
-    public void processReadMessages(SparseArray<Long> inbox, long dialog_id, int max_date, int max_id, boolean isPopup) {
-        int oldCount = popupMessages.size();
-        if (inbox != null) {
-            for (int b = 0; b < inbox.size(); b++) {
-                int key = inbox.keyAt(b);
-                long messageId = inbox.get(key);
-                for (int a = 0; a < pushMessages.size(); a++) {
-                    MessageObject messageObject = pushMessages.get(a);
-                    if (messageObject.getDialogId() == key && messageObject.getId() <= (int) messageId) {
-                        if (isPersonalMessage(messageObject)) {
-                            personal_count--;
-                        }
-                        popupMessages.remove(messageObject);
-                        pushMessagesDict.remove(messageObject.getId());
-                        delayedPushMessages.remove(messageObject);
-                        pushMessages.remove(a);
-                        a--;
-                    }
-                }
-            }
-            if (pushMessages.isEmpty() && !popupMessages.isEmpty()) {
-                popupMessages.clear();
-            }
-        }
-        if (dialog_id != 0 && (max_id != 0 || max_date != 0)) {
-            for (int a = 0; a < pushMessages.size(); a++) {
-                MessageObject messageObject = pushMessages.get(a);
-                if (messageObject.getDialogId() == dialog_id) {
-                    boolean remove = false;
-                    if (max_date != 0) {
-                        if (messageObject.messageOwner.date <= max_date) {
-                            remove = true;
-                        }
-                    } else {
-                        if (!isPopup) {
-                            if (messageObject.getId() <= max_id || max_id < 0) {
-                                remove = true;
-                            }
-                        } else {
-                            if (messageObject.getId() == max_id || max_id < 0) {
-                                remove = true;
-                            }
-                        }
-                    }
-                    if (remove) {
-                        if (isPersonalMessage(messageObject)) {
-                            personal_count--;
-                        }
-                        pushMessages.remove(a);
-                        delayedPushMessages.remove(messageObject);
-                        popupMessages.remove(messageObject);
-                        pushMessagesDict.remove(messageObject.getId());
-                        a--;
-                    }
-                }
-            }
-            if (pushMessages.isEmpty() && !popupMessages.isEmpty()) {
-                popupMessages.clear();
-            }
-        }
-        if (oldCount != popupMessages.size()) {
-            NotificationCenter.getInstance().postNotificationName(NotificationCenter.pushMessagesUpdated);
-        }
-    }
-
-    private void playInChatSound() {
-        if (!inChatSoundEnabled) {
-            return;
-        }
-        try {
-            if (audioManager.getRingerMode() == AudioManager.RINGER_MODE_SILENT) {
-                return;
-            }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-
-        try {
-            SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
-            int notifyOverride = getNotifyOverride(preferences, openned_dialog_id);
-            if (notifyOverride == 2) {
-                return;
-            }
-            notificationsQueue.postRunnable(new Runnable() {
-                @Override
-                public void run() {
-                    if (lastSoundPlay > System.currentTimeMillis() - 500) {
-                        return;
-                    }
-                    try {
-                        if (soundPool == null) {
-                            soundPool = new SoundPool(2, AudioManager.STREAM_SYSTEM, 0);
-                            soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() {
-                                @Override
-                                public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
-                                    if (status == 0) {
-                                        soundPool.play(sampleId, 1.0f, 1.0f, 1, 0, 1.0f);
-                                    }
-                                }
-                            });
-                        }
-                        if (soundIn == 0 && !soundInLoaded) {
-                            soundInLoaded = true;
-                            soundIn = soundPool.load(ApplicationLoader.applicationContext, R.raw.sound_in, 1);
-                        }
-                        if (soundIn != 0) {
-                            soundPool.play(soundIn, 1.0f, 1.0f, 1, 0, 1.0f);
-                        }
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
-                    }
-                }
-            });
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-    }
-
     public void playOutChatSound() {
         if (!inChatSoundEnabled) {
             return;
@@ -1105,7 +1603,7 @@ public void playOutChatSound() {
             @Override
             public void run() {
                 try {
-                    if (lastSoundOutPlay > System.currentTimeMillis() - 100) {
+                    if (Math.abs(System.currentTimeMillis() - lastSoundOutPlay) <= 100) {
                         return;
                     }
                     lastSoundOutPlay = System.currentTimeMillis();
@@ -1134,300 +1632,6 @@ public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
         });
     }
 
-    private int getNotifyOverride(SharedPreferences preferences, long dialog_id) {
-        int notifyOverride = preferences.getInt("notify2_" + dialog_id, 0);
-        if (notifyOverride == 3) {
-            int muteUntil = preferences.getInt("notifyuntil_" + dialog_id, 0);
-            if (muteUntil >= ConnectionsManager.getInstance().getCurrentTime()) {
-                notifyOverride = 2;
-            }
-        }
-        return notifyOverride;
-    }
-
-    public void processNewMessages(ArrayList<MessageObject> messageObjects, boolean isLast) {
-        if (messageObjects.isEmpty()) {
-            return;
-        }
-        boolean added = false;
-
-        int oldCount = popupMessages.size();
-        HashMap<Long, Boolean> settingsCache = new HashMap<>();
-        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
-        int popup = 0;
-
-        for (int a = 0; a < messageObjects.size(); a++) {
-            MessageObject messageObject = messageObjects.get(a);
-            if (pushMessagesDict.containsKey(messageObject.getId())) {
-                continue;
-            }
-            long dialog_id = messageObject.getDialogId();
-            long original_dialog_id = dialog_id;
-            if (dialog_id == openned_dialog_id && ApplicationLoader.isScreenOn) {
-                playInChatSound();
-                continue;
-            }
-            if ((messageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_MENTION) != 0) {
-                dialog_id = messageObject.messageOwner.from_id;
-            }
-            if (isPersonalMessage(messageObject)) {
-                personal_count++;
-            }
-            added = true;
-
-            Boolean value = settingsCache.get(dialog_id);
-            boolean isChat = (int)dialog_id < 0;
-            popup = (int)dialog_id == 0 ? 0 : preferences.getInt(isChat ? "popupGroup" : "popupAll", 0);
-            if (value == null) {
-                int notifyOverride = getNotifyOverride(preferences, dialog_id);
-                value = !(notifyOverride == 2 || (!preferences.getBoolean("EnableAll", true) || isChat && !preferences.getBoolean("EnableGroup", true)) && notifyOverride == 0);
-                settingsCache.put(dialog_id, value);
-            }
-            if (value) {
-                if (popup != 0) {
-                    popupMessages.add(0, messageObject);
-                }
-                delayedPushMessages.add(messageObject);
-                pushMessages.add(0, messageObject);
-                pushMessagesDict.put(messageObject.getId(), messageObject);
-                if (original_dialog_id != dialog_id) {
-                    pushDialogsOverrideMention.put(original_dialog_id, 1);
-                }
-            }
-        }
-
-        if (added) {
-            notifyCheck = isLast;
-        }
-
-        if (!popupMessages.isEmpty() && oldCount != popupMessages.size() && !AndroidUtilities.needShowPasscode(false) && !UserConfig.isWaitingForPasscodeEnter) {
-            if (ApplicationLoader.mainInterfacePaused || !ApplicationLoader.isScreenOn) {
-                MessageObject messageObject = messageObjects.get(0);
-                if (popup == 3 || popup == 1 && ApplicationLoader.isScreenOn || popup == 2 && !ApplicationLoader.isScreenOn) {
-                    Intent popupIntent = new Intent(ApplicationLoader.applicationContext, PopupNotificationActivity.class);
-                    popupIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION | Intent.FLAG_ACTIVITY_NO_USER_ACTION | Intent.FLAG_FROM_BACKGROUND);
-                    ApplicationLoader.applicationContext.startActivity(popupIntent);
-                }
-            }
-        }
-    }
-
-    public void processDialogsUpdateRead(final HashMap<Long, Integer> dialogsToUpdate) {
-        int old_unread_count = total_unread_count;
-        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
-        for (HashMap.Entry<Long, Integer> entry : dialogsToUpdate.entrySet()) {
-            long dialog_id = entry.getKey();
-
-            int notifyOverride = getNotifyOverride(preferences, dialog_id);
-            if (notifyCheck) {
-                Integer override = pushDialogsOverrideMention.get(dialog_id);
-                if (override != null && override == 1) {
-                    pushDialogsOverrideMention.put(dialog_id, 0);
-                    notifyOverride = 1;
-                }
-            }
-            boolean canAddValue = !(notifyOverride == 2 || (!preferences.getBoolean("EnableAll", true) || ((int)dialog_id < 0) && !preferences.getBoolean("EnableGroup", true)) && notifyOverride == 0);
-
-            Integer currentCount = pushDialogs.get(dialog_id);
-            Integer newCount = entry.getValue();
-            if (newCount == 0) {
-                smartNotificationsDialogs.remove(dialog_id);
-            }
-
-            if (newCount < 0) {
-                if (currentCount == null) {
-                    continue;
-                }
-                newCount = currentCount + newCount;
-            }
-            if (canAddValue || newCount == 0) {
-                if (currentCount != null) {
-                    total_unread_count -= currentCount;
-                }
-            }
-            if (newCount == 0) {
-                pushDialogs.remove(dialog_id);
-                pushDialogsOverrideMention.remove(dialog_id);
-                for (int a = 0; a < pushMessages.size(); a++) {
-                    MessageObject messageObject = pushMessages.get(a);
-                    if (messageObject.getDialogId() == dialog_id) {
-                        if (isPersonalMessage(messageObject)) {
-                            personal_count--;
-                        }
-                        pushMessages.remove(a);
-                        a--;
-                        delayedPushMessages.remove(messageObject);
-                        pushMessagesDict.remove(messageObject.getId());
-                        popupMessages.remove(messageObject);
-                    }
-                }
-                if (pushMessages.isEmpty() && !popupMessages.isEmpty()) {
-                    popupMessages.clear();
-                }
-            } else if (canAddValue) {
-                total_unread_count += newCount;
-                pushDialogs.put(dialog_id, newCount);
-            }
-        }
-        if (old_unread_count != total_unread_count) {
-            if (!notifyCheck) {
-                delayedPushMessages.clear();
-                showOrUpdateNotification(notifyCheck);
-            } else {
-                scheduleNotificationDelay(lastOnlineFromOtherDevice > ConnectionsManager.getInstance().getCurrentTime());
-            }
-        }
-        notifyCheck = false;
-        if (preferences.getBoolean("badgeNumber", true)) {
-            setBadge(total_unread_count);
-        }
-    }
-
-    public void processLoadedUnreadMessages(HashMap<Long, Integer> dialogs, ArrayList<TLRPC.Message> messages, ArrayList<TLRPC.User> users, ArrayList<TLRPC.Chat> chats, ArrayList<TLRPC.EncryptedChat> encryptedChats) {
-        MessagesController.getInstance().putUsers(users, true);
-        MessagesController.getInstance().putChats(chats, true);
-        MessagesController.getInstance().putEncryptedChats(encryptedChats, true);
-
-        pushDialogs.clear();
-        pushMessages.clear();
-        pushMessagesDict.clear();
-        total_unread_count = 0;
-        personal_count = 0;
-        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Context.MODE_PRIVATE);
-        HashMap<Long, Boolean> settingsCache = new HashMap<>();
-
-        if (messages != null) {
-            for (TLRPC.Message message : messages) {
-                if (pushMessagesDict.containsKey(message.id)) {
-                    continue;
-                }
-                MessageObject messageObject = new MessageObject(message, null, false);
-                if (isPersonalMessage(messageObject)) {
-                    personal_count++;
-                }
-                long dialog_id = messageObject.getDialogId();
-                long original_dialog_id = dialog_id;
-                if ((messageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_MENTION) != 0) {
-                    dialog_id = messageObject.messageOwner.from_id;
-                }
-                Boolean value = settingsCache.get(dialog_id);
-                if (value == null) {
-                    int notifyOverride = getNotifyOverride(preferences, dialog_id);
-                    value = !(notifyOverride == 2 || (!preferences.getBoolean("EnableAll", true) || ((int) dialog_id < 0) && !preferences.getBoolean("EnableGroup", true)) && notifyOverride == 0);
-                    settingsCache.put(dialog_id, value);
-                }
-                if (!value || dialog_id == openned_dialog_id && ApplicationLoader.isScreenOn) {
-                    continue;
-                }
-                pushMessagesDict.put(messageObject.getId(), messageObject);
-                pushMessages.add(0, messageObject);
-                if (original_dialog_id != dialog_id) {
-                    pushDialogsOverrideMention.put(original_dialog_id, 1);
-                }
-            }
-        }
-        for (HashMap.Entry<Long, Integer> entry : dialogs.entrySet()) {
-            long dialog_id = entry.getKey();
-            Boolean value = settingsCache.get(dialog_id);
-            if (value == null) {
-                int notifyOverride = getNotifyOverride(preferences, dialog_id);
-                Integer override = pushDialogsOverrideMention.get(dialog_id);
-                if (override != null && override == 1) {
-                    pushDialogsOverrideMention.put(dialog_id, 0);
-                    notifyOverride = 1;
-                }
-                value = !(notifyOverride == 2 || (!preferences.getBoolean("EnableAll", true) || ((int) dialog_id < 0) && !preferences.getBoolean("EnableGroup", true)) && notifyOverride == 0);
-                settingsCache.put(dialog_id, value);
-            }
-            if (!value) {
-                continue;
-            }
-            int count = entry.getValue();
-            pushDialogs.put(dialog_id, count);
-            total_unread_count += count;
-        }
-        if (total_unread_count == 0) {
-            popupMessages.clear();
-            NotificationCenter.getInstance().postNotificationName(NotificationCenter.pushMessagesUpdated);
-        }
-        showOrUpdateNotification(SystemClock.uptimeMillis() / 1000 < 60);
-
-        if (preferences.getBoolean("badgeNumber", true)) {
-            setBadge(total_unread_count);
-        }
-    }
-
-    public void setBadgeEnabled(boolean enabled) {
-        setBadge(enabled ? total_unread_count : 0);
-    }
-
-    private void setBadge(final int count) {
-        notificationsQueue.postRunnable(new Runnable() {
-            @Override
-            public void run() {
-                if (lastBadgeCount == count) {
-                    return;
-                }
-                lastBadgeCount = count;
-                try {
-                    ContentValues cv = new ContentValues();
-                    cv.put("tag", "org.telegram.messenger/org.telegram.ui.LaunchActivity");
-                    cv.put("count", count);
-                    ApplicationLoader.applicationContext.getContentResolver().insert(Uri.parse("content://com.teslacoilsw.notifier/unread_count"), cv);
-                } catch (Throwable e) {
-                     //ignore
-                }
-                try {
-                    launcherClassName = getLauncherClassName(ApplicationLoader.applicationContext);
-                    if (launcherClassName == null) {
-                        return;
-                    }
-                    AndroidUtilities.runOnUIThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            try {
-                                Intent intent = new Intent("android.intent.action.BADGE_COUNT_UPDATE");
-                                intent.putExtra("badge_count", count);
-                                intent.putExtra("badge_count_package_name", ApplicationLoader.applicationContext.getPackageName());
-                                intent.putExtra("badge_count_class_name", launcherClassName);
-                                ApplicationLoader.applicationContext.sendBroadcast(intent);
-                            } catch (Exception e) {
-                                FileLog.e("tmessages", e);
-                            }
-                        }
-                    });
-                } catch (Throwable e) {
-                    FileLog.e("tmessages", e);
-                }
-            }
-        });
-    }
-
-    public static String getLauncherClassName(Context context) {
-        try {
-            PackageManager pm = context.getPackageManager();
-
-            Intent intent = new Intent(Intent.ACTION_MAIN);
-            intent.addCategory(Intent.CATEGORY_LAUNCHER);
-
-            List<ResolveInfo> resolveInfos = pm.queryIntentActivities(intent, 0);
-            for (ResolveInfo resolveInfo : resolveInfos) {
-                String pkgName = resolveInfo.activityInfo.applicationInfo.packageName;
-                if (pkgName.equalsIgnoreCase(context.getPackageName())) {
-                    return resolveInfo.activityInfo.name;
-                }
-            }
-        } catch (Throwable e) {
-            FileLog.e("tmessages", e);
-        }
-        return null;
-    }
-
-    private boolean isPersonalMessage(MessageObject messageObject) {
-        return messageObject.messageOwner.to_id != null && messageObject.messageOwner.to_id.chat_id == 0 && messageObject.messageOwner.to_id.channel_id == 0
-                && (messageObject.messageOwner.action == null || messageObject.messageOwner.action instanceof TLRPC.TL_messageActionEmpty);
-    }
-
     public static void updateServerNotificationsSettings(long dialog_id) {
         NotificationCenter.getInstance().postNotificationName(NotificationCenter.notificationsSettingsUpdated);
         if ((int)dialog_id == 0) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationsService.java b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationsService.java
index 5195ef7d8..857577cfd 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/NotificationsService.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/NotificationsService.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/ScreenReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/ScreenReceiver.java
index 22feeb4b2..099167152 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/ScreenReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/ScreenReceiver.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/SecretChatHelper.java b/TMessagesProj/src/main/java/org/telegram/messenger/SecretChatHelper.java
index 6a2081348..da18258e6 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/SecretChatHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/SecretChatHelper.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -80,7 +80,9 @@ protected void processPendingEncMessages() {
         newMsg.action.encryptedAction = decryptedMessage;
         newMsg.local_id = newMsg.id = UserConfig.getNewMessageId();
         newMsg.from_id = UserConfig.getClientUserId();
-        newMsg.flags = TLRPC.MESSAGE_FLAG_UNREAD | TLRPC.MESSAGE_FLAG_OUT | TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
+        newMsg.unread = true;
+        newMsg.out = true;
+        newMsg.flags = TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
         newMsg.dialog_id = ((long) encryptedChat.id) << 32;
         newMsg.to_id = new TLRPC.TL_peerUser();
         newMsg.send_state = MessageObject.MESSAGE_SEND_STATE_SENDING;
@@ -869,7 +871,8 @@ public void run() {
                 newMessage.to_id = new TLRPC.TL_peerUser();
                 newMessage.random_id = random_id;
                 newMessage.to_id.user_id = UserConfig.getClientUserId();
-                newMessage.flags = TLRPC.MESSAGE_FLAG_UNREAD | TLRPC.MESSAGE_FLAG_HAS_MEDIA | TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
+                newMessage.unread = true;
+                newMessage.flags = TLRPC.MESSAGE_FLAG_HAS_MEDIA | TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
                 newMessage.dialog_id = ((long) chat.id) << 32;
                 if (decryptedMessage.media instanceof TLRPC.TL_decryptedMessageMediaEmpty) {
                     newMessage.media = new TLRPC.TL_messageMediaEmpty();
@@ -969,6 +972,9 @@ public void run() {
                     newMessage.media.document.size = file.size;
                     newMessage.media.document.key = decryptedMessage.media.key;
                     newMessage.media.document.iv = decryptedMessage.media.iv;
+                    if (newMessage.media.document.mime_type == null) {
+                        newMessage.media.document.mime_type = "";
+                    }
                     byte[] thumb = ((TLRPC.TL_decryptedMessageMediaDocument) decryptedMessage.media).thumb;
                     if (thumb != null && thumb.length != 0 && thumb.length <= 6000 && decryptedMessage.media.thumb_w <= 100 && decryptedMessage.media.thumb_h <= 100) {
                         newMessage.media.document.thumb = new TLRPC.TL_photoCachedSize();
@@ -993,6 +999,9 @@ public void run() {
                     newMessage.media.document.dc_id = decryptedMessage.media.dc_id;
                     newMessage.media.document.size = decryptedMessage.media.size;
                     newMessage.media.document.thumb = ((TLRPC.TL_decryptedMessageMediaExternalDocument) decryptedMessage.media).thumb;
+                    if (newMessage.media.document.mime_type == null) {
+                        newMessage.media.document.mime_type = "";
+                    }
                 } else if (decryptedMessage.media instanceof TLRPC.TL_decryptedMessageMediaAudio) {
                     if (decryptedMessage.media.key == null || decryptedMessage.media.key.length != 32 || decryptedMessage.media.iv == null || decryptedMessage.media.iv.length != 32) {
                         return null;
@@ -1037,7 +1046,8 @@ public void run() {
                     }
                     newMessage.local_id = newMessage.id = UserConfig.getNewMessageId();
                     UserConfig.saveConfig(false);
-                    newMessage.flags = TLRPC.MESSAGE_FLAG_UNREAD | TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
+                    newMessage.unread = true;
+                    newMessage.flags = TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
                     newMessage.date = date;
                     newMessage.from_id = from_id;
                     newMessage.to_id = new TLRPC.TL_peerUser();
@@ -1068,7 +1078,7 @@ public void run() {
                                     });
                                 }
                             });
-                            MessagesStorage.getInstance().deleteDialog(did, true);
+                            MessagesStorage.getInstance().deleteDialog(did, 1);
                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.removeAllMessagesFromDialog, did, false);
                         }
@@ -1233,7 +1243,24 @@ public void run() {
                 } else if (serviceMessage.action instanceof TLRPC.TL_decryptedMessageActionNoop) {
                     //do nothing
                 } else if (serviceMessage.action instanceof TLRPC.TL_decryptedMessageActionResend) {
-
+                    final TLRPC.TL_encryptedChatDiscarded newChat = new TLRPC.TL_encryptedChatDiscarded();
+                    newChat.id = chat.id;
+                    newChat.user_id = chat.user_id;
+                    newChat.auth_key = chat.auth_key;
+                    newChat.key_create_date = chat.key_create_date;
+                    newChat.key_use_count_in = chat.key_use_count_in;
+                    newChat.key_use_count_out = chat.key_use_count_out;
+                    newChat.seq_in = chat.seq_in;
+                    newChat.seq_out = chat.seq_out;
+                    MessagesStorage.getInstance().updateEncryptedChat(newChat);
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            MessagesController.getInstance().putEncryptedChat(newChat, false);
+                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.encryptedChatUpdated, newChat);
+                        }
+                    });
+                    declineSecretChat(chat.id);
                 } else {
                     return null;
                 }
@@ -1337,6 +1364,10 @@ public int compare(TLRPC.TL_decryptedMessageHolder lhs, TLRPC.TL_decryptedMessag
                         chat.seq_in = 1;
                     }
                 }
+                if (layer.random_bytes.length < 15) {
+                    FileLog.e("tmessages", "got random bytes less than needed");
+                    return null;
+                }
                 FileLog.e("tmessages", "current chat in_seq = " + chat.seq_in + " out_seq = " + chat.seq_out);
                 FileLog.e("tmessages", "got message with in_seq = " + layer.in_seq_no + " out_seq = " + layer.out_seq_no);
                 if (layer.out_seq_no < chat.seq_in) {
@@ -1349,7 +1380,7 @@ public int compare(TLRPC.TL_decryptedMessageHolder lhs, TLRPC.TL_decryptedMessag
                         arr = new ArrayList<>();
                         secretHolesQueue.put(chat.id, arr);
                     }
-                    if (arr.size() >= 10) {
+                    if (arr.size() >= 4) {
                         secretHolesQueue.remove(chat.id);
                         final TLRPC.TL_encryptedChatDiscarded newChat = new TLRPC.TL_encryptedChatDiscarded();
                         newChat.id = chat.id;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java b/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
index c38b98dbe..5d541918e 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/SendMessagesHelper.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -143,6 +143,10 @@ public void didReceivedNotification(int id, final Object... args) {
                         arr.remove(a);
                         a--;
                     } else if (encryptedFile != null && message.sendEncryptedRequest != null) {
+                        if (message.sendEncryptedRequest.media instanceof TLRPC.TL_decryptedMessageMediaVideo) {
+                            long size = (Long) args[5];
+                            message.sendEncryptedRequest.media.size = (int) size;
+                        }
                         message.sendEncryptedRequest.media.key = (byte[]) args[3];
                         message.sendEncryptedRequest.media.iv = (byte[]) args[4];
                         SecretChatHelper.getInstance().performSendEncryptedRequest(message.sendEncryptedRequest, message.obj.messageOwner, message.encryptedChat, encryptedFile, message.originalPath);
@@ -246,7 +250,8 @@ public void didReceivedNotification(int id, final Object... args) {
             String file = (String) args[1];
             ArrayList<DelayedMessage> arr = delayedMessages.get(path);
             if (arr != null) {
-                for (final DelayedMessage message : arr) {
+                for (int a = 0; a < arr.size(); a++) {
+                    final DelayedMessage message = arr.get(a);
                     if (message.type == 0) {
                         String md5 = Utilities.MD5(message.httpLocation) + ".jpg";
                         final File cacheFile = new File(FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE), md5);
@@ -289,6 +294,7 @@ public void run() {
                                         Bitmap bitmap = ImageLoader.loadBitmap(cacheFile.getAbsolutePath(), null, 90, 90, true);
                                         if (bitmap != null) {
                                             message.documentLocation.thumb = ImageLoader.scaleAndSaveImage(bitmap, 90, 90, 55, message.sendEncryptedRequest != null);
+                                            bitmap.recycle();
                                         }
                                     } catch (Exception e) {
                                         message.documentLocation.thumb = null;
@@ -497,6 +503,9 @@ public void sendSticker(TLRPC.Document document, long peer, MessageObject replyi
                     newDocument.size = document.size;
                     newDocument.dc_id = document.dc_id;
                     newDocument.attributes = document.attributes;
+                    if (newDocument.mime_type == null) {
+                        newDocument.mime_type = "";
+                    }
                     document = newDocument;
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -517,7 +526,7 @@ public void sendSticker(TLRPC.Document document, long peer, MessageObject replyi
     }
 
     public void sendMessage(TLRPC.User user, long peer, MessageObject reply_to_msg, boolean asAdmin) {
-        sendMessage(null, null, null, null, null, null, user, null, null, null, peer, false, null, reply_to_msg, null, true, asAdmin);
+        sendMessage(null, null, null, null, null, user, null, null, null, peer, null, reply_to_msg, null, true, asAdmin, null);
     }
 
     public void sendMessage(ArrayList<MessageObject> messages, final long peer, boolean asAdmin) {
@@ -526,11 +535,15 @@ public void sendMessage(ArrayList<MessageObject> messages, final long peer, bool
         }
         int lower_id = (int) peer;
         final TLRPC.Peer to_id = MessagesController.getPeer((int) peer);
+        boolean isMegagroup = false;
         if (lower_id > 0) {
             TLRPC.User sendToUser = MessagesController.getInstance().getUser(lower_id);
             if (sendToUser == null) {
                 return;
             }
+        } else {
+            TLRPC.Chat chat = MessagesController.getInstance().getChat(-lower_id);
+            isMegagroup = ChatObject.isChannel(chat) && chat.megagroup;
         }
 
         ArrayList<MessageObject> objArr = new ArrayList<>();
@@ -538,7 +551,8 @@ public void sendMessage(ArrayList<MessageObject> messages, final long peer, bool
         ArrayList<Long> randomIds = new ArrayList<>();
         ArrayList<Integer> ids = new ArrayList<>();
         HashMap<Long, TLRPC.Message> messagesByRandomIds = new HashMap<>();
-        TLRPC.InputPeer inputPeer = MessagesController.getInputPeer((int) peer);
+        TLRPC.InputPeer inputPeer = MessagesController.getInputPeer(lower_id);
+        long lastDialogId = 0;
         for (int a = 0; a < messages.size(); a++) {
             MessageObject msgObj = messages.get(a);
             if (msgObj.getId() <= 0) {
@@ -563,6 +577,9 @@ public void sendMessage(ArrayList<MessageObject> messages, final long peer, bool
             if (newMsg.media != null) {
                 newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_MEDIA;
             }
+            if (isMegagroup) {
+                newMsg.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+            }
             newMsg.message = msgObj.messageOwner.message;
             newMsg.fwd_msg_id = msgObj.getId();
             newMsg.attachPath = msgObj.messageOwner.attachPath;
@@ -574,8 +591,8 @@ public void sendMessage(ArrayList<MessageObject> messages, final long peer, bool
                 newMsg.attachPath = "";
             }
             newMsg.local_id = newMsg.id = UserConfig.getNewMessageId();
-            newMsg.flags |= TLRPC.MESSAGE_FLAG_OUT;
-            if (asAdmin && to_id.channel_id != 0) {
+            newMsg.out = true;
+            if (asAdmin && to_id.channel_id != 0 && !isMegagroup) {
                 newMsg.from_id = -to_id.channel_id;
             } else {
                 newMsg.from_id = UserConfig.getClientUserId();
@@ -589,10 +606,10 @@ public void sendMessage(ArrayList<MessageObject> messages, final long peer, bool
             ids.add(newMsg.fwd_msg_id);
             newMsg.date = ConnectionsManager.getInstance().getCurrentTime();
             if (newMsg.media instanceof TLRPC.TL_messageMediaAudio) {
-                newMsg.flags |= TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
+                newMsg.media_unread = true;
             }
             if (inputPeer instanceof TLRPC.TL_inputPeerChannel) {
-                if (asAdmin) {
+                if (asAdmin && !isMegagroup) {
                     newMsg.views = 1;
                     newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_VIEWS;
                 }
@@ -601,18 +618,22 @@ public void sendMessage(ArrayList<MessageObject> messages, final long peer, bool
                     newMsg.views = msgObj.messageOwner.views;
                     newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_VIEWS;
                 }
-                newMsg.flags |= TLRPC.MESSAGE_FLAG_UNREAD;
+                newMsg.unread = true;
             }
             newMsg.dialog_id = peer;
             newMsg.to_id = to_id;
+            if (msgObj.messageOwner.to_id instanceof TLRPC.TL_peerChannel) {
+                newMsg.ttl = -msgObj.messageOwner.to_id.channel_id;
+            }
             MessageObject newMsgObj = new MessageObject(newMsg, null, true);
             newMsgObj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SENDING;
             objArr.add(newMsgObj);
             arr.add(newMsg);
 
             putToSendingMessages(newMsg);
+            boolean differentDialog = false;
 
-            if (arr.size() == 100 || a == messages.size() - 1) {
+            if (arr.size() == 100 || a == messages.size() - 1 || a != messages.size() - 1 && messages.get(a + 1).getDialogId() != msgObj.getDialogId()) {
                 MessagesStorage.getInstance().putMessages(new ArrayList<>(arr), false, true, false, 0);
                 MessagesController.getInstance().updateInterfaceWithMessages(peer, objArr);
                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
@@ -627,12 +648,13 @@ public void sendMessage(ArrayList<MessageObject> messages, final long peer, bool
                 }
                 req.random_id = randomIds;
                 req.id = ids;
-                if (asAdmin && req.to_peer.channel_id != 0) {
-                    req.flags |= 16;
+                if (asAdmin && req.to_peer.channel_id != 0 && !isMegagroup) {
+                    req.broadcast = true;
                 }
 
                 final ArrayList<TLRPC.Message> newMsgObjArr = arr;
                 final HashMap<Long, TLRPC.Message> messagesByRandomIdsFinal = messagesByRandomIds;
+                final boolean isMegagroupFinal = isMegagroup;
                 ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
                     @Override
                     public void run(TLObject response, final TLRPC.TL_error error) {
@@ -647,7 +669,8 @@ public void run(TLObject response, final TLRPC.TL_error error) {
                                     a--;
                                 }
                             }
-                            for (TLRPC.Update update : updates.updates) {
+                            for (int a = 0; a < updates.updates.size(); a++) {
+                                TLRPC.Update update = updates.updates.get(a);
                                 if (update instanceof TLRPC.TL_updateNewMessage || update instanceof TLRPC.TL_updateNewChannelMessage) {
                                     TLRPC.Message message;
                                     if (update instanceof TLRPC.TL_updateNewMessage) {
@@ -656,6 +679,9 @@ public void run(TLObject response, final TLRPC.TL_error error) {
                                     } else {
                                         message = ((TLRPC.TL_updateNewChannelMessage) update).message;
                                         MessagesController.getInstance().processNewChannelDifferenceParams(update.pts, update.pts_count, message.to_id.channel_id);
+                                        if (isMegagroupFinal) {
+                                            message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                                        }
                                     }
                                     Long random_id = newMessagesByIds.get(message.id);
                                     if (random_id != null) {
@@ -696,7 +722,7 @@ public void run() {
                                 @Override
                                 public void run() {
                                     if (error.text.equals("PEER_FLOOD")) {
-                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.spamErrorReceived, 0);
+                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.needShowAlert, 0);
                                     }
                                 }
                             });
@@ -730,40 +756,41 @@ public void run() {
         }
     }
 
-    public void sendMessage(MessageObject message, boolean asAdmin) {
-        sendMessage(null, null, null, null, null, message, null, null, null, null, message.getDialogId(), true, message.messageOwner.attachPath, null, null, true, asAdmin);
+    public void sendMessage(MessageObject retryMessageObject, boolean asAdmin) {
+        sendMessage(null, null, null, null, null, null, null, null, null, retryMessageObject.getDialogId(), retryMessageObject.messageOwner.attachPath, null, null, true, asAdmin, retryMessageObject);
     }
 
     public void sendMessage(TLRPC.TL_document document, String originalPath, String path, long peer, MessageObject reply_to_msg, boolean asAdmin) {
-        sendMessage(null, null, null, null, null, null, null, document, null, originalPath, peer, false, path, reply_to_msg, null, true, asAdmin);
+        sendMessage(null, null, null, null, null, null, document, null, originalPath, peer, path, reply_to_msg, null, true, asAdmin, null);
     }
 
     public void sendMessage(String message, long peer, MessageObject reply_to_msg, TLRPC.WebPage webPage, boolean searchLinks, boolean asAdmin) {
-        sendMessage(message, null, null, null, null, null, null, null, null, null, peer, false, null, reply_to_msg, webPage, searchLinks, asAdmin);
+        sendMessage(message, null, null, null, null, null, null, null, null, peer, null, reply_to_msg, webPage, searchLinks, asAdmin, null);
     }
 
     public void sendMessage(TLRPC.MessageMedia location, long peer, MessageObject reply_to_msg, boolean asAdmin) {
-        sendMessage(null, location, null, null, null, null, null, null, null, null, peer, false, null, reply_to_msg, null, true, asAdmin);
+        sendMessage(null, location, null, null, null, null, null, null, null, peer, null, reply_to_msg, null, true, asAdmin, null);
     }
 
     public void sendMessage(TLRPC.TL_photo photo, String originalPath, String path, long peer, MessageObject reply_to_msg, boolean asAdmin) {
-        sendMessage(null, null, photo, null, null, null, null, null, null, originalPath, peer, false, path, reply_to_msg, null, true, asAdmin);
+        sendMessage(null, null, photo, null, null, null, null, null, originalPath, peer, path, reply_to_msg, null, true, asAdmin, null);
     }
 
     public void sendMessage(TLRPC.TL_video video, VideoEditedInfo videoEditedInfo, String originalPath, String path, long peer, MessageObject reply_to_msg, boolean asAdmin) {
-        sendMessage(null, null, null, video, videoEditedInfo, null, null, null, null, originalPath, peer, false, path, reply_to_msg, null, true, asAdmin);
+        sendMessage(null, null, null, video, videoEditedInfo, null, null, null, originalPath, peer, path, reply_to_msg, null, true, asAdmin, null);
     }
 
     public void sendMessage(TLRPC.TL_audio audio, String path, long peer, MessageObject reply_to_msg, boolean asAdmin) {
-        sendMessage(null, null, null, null, null, null, null, null, audio, null, peer, false, path, reply_to_msg, null, true, asAdmin);
+        sendMessage(null, null, null, null, null, null, null, audio, null, peer, path, reply_to_msg, null, true, asAdmin, null);
     }
 
-    private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_photo photo, TLRPC.TL_video video, VideoEditedInfo videoEditedInfo, MessageObject msgObj, TLRPC.User user, TLRPC.TL_document document, TLRPC.TL_audio audio, String originalPath, long peer, boolean retry, String path, MessageObject reply_to_msg, TLRPC.WebPage webPage, boolean searchLinks, boolean asAdmin) {
+    private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_photo photo, TLRPC.TL_video video, VideoEditedInfo videoEditedInfo, TLRPC.User user, TLRPC.TL_document document, TLRPC.TL_audio audio, String originalPath, long peer, String path, MessageObject reply_to_msg, TLRPC.WebPage webPage, boolean searchLinks, boolean asAdmin, MessageObject retryMessageObject) {
         if (peer == 0) {
             return;
         }
 
         TLRPC.Message newMsg = null;
+        MessageObject newMsgObj = null;
         int type = -1;
         int lower_id = (int) peer;
         int high_id = (int) (peer >> 32);
@@ -773,267 +800,252 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
         if (lower_id == 0) {
             encryptedChat = MessagesController.getInstance().getEncryptedChat(high_id);
             if (encryptedChat == null) {
-                if (msgObj != null) {
-                    MessagesStorage.getInstance().markMessageAsSendError(msgObj.messageOwner);
-                    msgObj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SEND_ERROR;
-                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.messageSendError, msgObj.getId());
-                    processSentMessage(msgObj.getId());
+                if (retryMessageObject != null) {
+                    MessagesStorage.getInstance().markMessageAsSendError(retryMessageObject.messageOwner);
+                    retryMessageObject.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SEND_ERROR;
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.messageSendError, retryMessageObject.getId());
+                    processSentMessage(retryMessageObject.getId());
                 }
                 return;
             }
+        } else if (asAdmin && sendToPeer instanceof TLRPC.TL_inputPeerChannel) {
+            TLRPC.Chat chat = MessagesController.getInstance().getChat(sendToPeer.channel_id);
+            if (chat.megagroup) {
+                asAdmin = false;
+            }
         }
 
-        if (retry) {
-            newMsg = msgObj.messageOwner;
+        try {
+            if (retryMessageObject != null) {
+                newMsg = retryMessageObject.messageOwner;
 
-            if (msgObj.type == 0) {
-                if (msgObj.isForwarded()) {
+                if (retryMessageObject.isForwarded()) {
                     type = 4;
                 } else {
-                    message = newMsg.message;
-                    type = 0;
+                    if (retryMessageObject.type == 0) {
+                        message = newMsg.message;
+                        type = 0;
+                    } else if (retryMessageObject.type == 4) {
+                        location = newMsg.media;
+                        type = 1;
+                    } else if (retryMessageObject.type == 1) {
+                        photo = (TLRPC.TL_photo) newMsg.media.photo;
+                        type = 2;
+                    } else if (retryMessageObject.type == 3) {
+                        type = 3;
+                        video = (TLRPC.TL_video) newMsg.media.video;
+                    } else if (retryMessageObject.type == 12) {
+                        user = new TLRPC.TL_userRequest_old2();
+                        user.phone = newMsg.media.phone_number;
+                        user.first_name = newMsg.media.first_name;
+                        user.last_name = newMsg.media.last_name;
+                        user.id = newMsg.media.user_id;
+                        type = 6;
+                    } else if (retryMessageObject.type == 8 || retryMessageObject.type == 9 || retryMessageObject.type == 13) {
+                        document = (TLRPC.TL_document) newMsg.media.document;
+                        type = 7;
+                    } else if (retryMessageObject.type == 2) {
+                        audio = (TLRPC.TL_audio) newMsg.media.audio;
+                        type = 8;
+                    }
                 }
-            } else if (msgObj.type == 4) {
-                location = newMsg.media;
-                type = 1;
-            } else if (msgObj.type == 1) {
-                if (msgObj.isForwarded()) {
-                    type = 4;
-                } else {
-                    photo = (TLRPC.TL_photo) newMsg.media.photo;
+            } else {
+                if (message != null) {
+                    if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
+                        newMsg = new TLRPC.TL_message_secret();
+                    } else {
+                        newMsg = new TLRPC.TL_message();
+                    }
+                    if (encryptedChat != null || webPage == null) {
+                        newMsg.media = new TLRPC.TL_messageMediaEmpty();
+                    } else {
+                        newMsg.media = new TLRPC.TL_messageMediaWebPage();
+                        newMsg.media.webpage = webPage;
+                    }
+                    type = 0;
+                    newMsg.message = message;
+                } else if (location != null) {
+                    if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
+                        newMsg = new TLRPC.TL_message_secret();
+                    } else {
+                        newMsg = new TLRPC.TL_message();
+                    }
+                    newMsg.media = location;
+                    newMsg.message = "";
+                    type = 1;
+                } else if (photo != null) {
+                    if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
+                        newMsg = new TLRPC.TL_message_secret();
+                    } else {
+                        newMsg = new TLRPC.TL_message();
+                    }
+                    newMsg.media = new TLRPC.TL_messageMediaPhoto();
+                    newMsg.media.caption = photo.caption != null ? photo.caption : "";
+                    newMsg.media.photo = photo;
                     type = 2;
-                }
-            } else if (msgObj.type == 3) {
-                if (msgObj.isForwarded()) {
-                    type = 4;
-                } else {
+                    newMsg.message = "-1";
+                    if (path != null && path.length() > 0 && path.startsWith("http")) {
+                        newMsg.attachPath = path;
+                    } else {
+                        TLRPC.FileLocation location1 = photo.sizes.get(photo.sizes.size() - 1).location;
+                        newMsg.attachPath = FileLoader.getPathToAttach(location1, true).toString();
+                    }
+                } else if (video != null) {
+                    if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
+                        newMsg = new TLRPC.TL_message_secret();
+                    } else {
+                        newMsg = new TLRPC.TL_message();
+                    }
+                    newMsg.media = new TLRPC.TL_messageMediaVideo();
+                    newMsg.media.caption = video.caption != null ? video.caption : "";
+                    newMsg.media.video = video;
                     type = 3;
-                    video = (TLRPC.TL_video) newMsg.media.video;
-                }
-            } else if (msgObj.type == 12) {
-                user = new TLRPC.TL_userRequest_old2();
-                user.phone = newMsg.media.phone_number;
-                user.first_name = newMsg.media.first_name;
-                user.last_name = newMsg.media.last_name;
-                user.id = newMsg.media.user_id;
-                type = 6;
-            } else if (msgObj.type == 8 || msgObj.type == 9 || msgObj.type == 13) {
-                document = (TLRPC.TL_document) newMsg.media.document;
-                type = 7;
-            } else if (msgObj.type == 2) {
-                audio = (TLRPC.TL_audio) newMsg.media.audio;
-                type = 8;
-            }
-        } else {
-            if (message != null) {
-                if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
-                    newMsg = new TLRPC.TL_message_secret();
-                } else {
-                    newMsg = new TLRPC.TL_message();
-                }
-                if (encryptedChat != null || webPage == null) {
-                    newMsg.media = new TLRPC.TL_messageMediaEmpty();
-                } else {
-                    newMsg.media = new TLRPC.TL_messageMediaWebPage();
-                    newMsg.media.webpage = webPage;
-                }
-                type = 0;
-                newMsg.message = message;
-            } else if (location != null) {
-                if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
-                    newMsg = new TLRPC.TL_message_secret();
-                } else {
-                    newMsg = new TLRPC.TL_message();
-                }
-                newMsg.media = location;
-                newMsg.message = "";
-                type = 1;
-            } else if (photo != null) {
-                if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
-                    newMsg = new TLRPC.TL_message_secret();
-                } else {
-                    newMsg = new TLRPC.TL_message();
-                }
-                newMsg.media = new TLRPC.TL_messageMediaPhoto();
-                newMsg.media.caption = photo.caption != null ? photo.caption : "";
-                newMsg.media.photo = photo;
-                type = 2;
-                newMsg.message = "-1";
-                if (path != null && path.length() > 0 && path.startsWith("http")) {
+                    if (videoEditedInfo == null) {
+                        newMsg.message = "-1";
+                    } else {
+                        newMsg.message = videoEditedInfo.getString();
+                    }
+                    newMsg.attachPath = path;
+                } else if (user != null) {
+                    if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
+                        newMsg = new TLRPC.TL_message_secret();
+                    } else {
+                        newMsg = new TLRPC.TL_message();
+                    }
+                    newMsg.media = new TLRPC.TL_messageMediaContact();
+                    newMsg.media.phone_number = user.phone;
+                    newMsg.media.first_name = user.first_name;
+                    newMsg.media.last_name = user.last_name;
+                    newMsg.media.user_id = user.id;
+                    if (newMsg.media.first_name == null) {
+                        user.first_name = newMsg.media.first_name = "";
+                    }
+                    if (newMsg.media.last_name == null) {
+                        user.last_name = newMsg.media.last_name = "";
+                    }
+                    newMsg.message = "";
+                    type = 6;
+                } else if (document != null) {
+                    if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
+                        newMsg = new TLRPC.TL_message_secret();
+                    } else {
+                        newMsg = new TLRPC.TL_message();
+                    }
+                    newMsg.media = new TLRPC.TL_messageMediaDocument();
+                    newMsg.media.document = document;
+                    type = 7;
+                    newMsg.message = "-1";
+                    newMsg.attachPath = path;
+                } else if (audio != null) {
+                    if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
+                        newMsg = new TLRPC.TL_message_secret();
+                    } else {
+                        newMsg = new TLRPC.TL_message();
+                    }
+                    newMsg.media = new TLRPC.TL_messageMediaAudio();
+                    newMsg.media.audio = audio;
+                    type = 8;
+                    newMsg.message = "-1";
                     newMsg.attachPath = path;
-                } else {
-                    TLRPC.FileLocation location1 = photo.sizes.get(photo.sizes.size() - 1).location;
-                    newMsg.attachPath = FileLoader.getPathToAttach(location1, true).toString();
                 }
-            } else if (video != null) {
-                if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
-                    newMsg = new TLRPC.TL_message_secret();
-                } else {
-                    newMsg = new TLRPC.TL_message();
+                if (newMsg.attachPath == null) {
+                    newMsg.attachPath = "";
                 }
-                newMsg.media = new TLRPC.TL_messageMediaVideo();
-                newMsg.media.caption = video.caption != null ? video.caption : "";
-                newMsg.media.video = video;
-                type = 3;
-                if (videoEditedInfo == null) {
-                    newMsg.message = "-1";
-                } else {
-                    newMsg.message = videoEditedInfo.getString();
-                }
-                newMsg.attachPath = path;
-            } else if (msgObj != null) {
-                newMsg = new TLRPC.TL_message();
-                newMsg.flags |= TLRPC.MESSAGE_FLAG_FWD;
-                if (msgObj.isForwarded()) {
-                    newMsg.fwd_from_id = msgObj.messageOwner.fwd_from_id;
-                    newMsg.fwd_date = msgObj.messageOwner.fwd_date;
-                } else {
-                    newMsg.fwd_from_id = new TLRPC.TL_peerUser();
-                    newMsg.fwd_from_id.user_id = msgObj.messageOwner.from_id;
-                    newMsg.fwd_date = msgObj.messageOwner.date;
-                }
-                newMsg.media = msgObj.messageOwner.media;
-                newMsg.message = msgObj.messageOwner.message;
-                newMsg.fwd_msg_id = msgObj.getId();
-                newMsg.attachPath = msgObj.messageOwner.attachPath;
-                type = 4;
-            } else if (user != null) {
-                if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
-                    newMsg = new TLRPC.TL_message_secret();
-                } else {
-                    newMsg = new TLRPC.TL_message();
-                }
-                newMsg.media = new TLRPC.TL_messageMediaContact();
-                newMsg.media.phone_number = user.phone;
-                newMsg.media.first_name = user.first_name;
-                newMsg.media.last_name = user.last_name;
-                newMsg.media.user_id = user.id;
-                if (newMsg.media.first_name == null) {
-                    user.first_name = newMsg.media.first_name = "";
-                }
-                if (newMsg.media.last_name == null) {
-                    user.last_name = newMsg.media.last_name = "";
-                }
-                newMsg.message = "";
-                type = 6;
-            } else if (document != null) {
-                if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
-                    newMsg = new TLRPC.TL_message_secret();
+                newMsg.local_id = newMsg.id = UserConfig.getNewMessageId();
+                newMsg.out = true;
+                if (asAdmin && sendToPeer != null && sendToPeer.channel_id != 0) {
+                    newMsg.from_id = -sendToPeer.channel_id;
                 } else {
-                    newMsg = new TLRPC.TL_message();
-                }
-                newMsg.media = new TLRPC.TL_messageMediaDocument();
-                newMsg.media.document = document;
-                type = 7;
-                newMsg.message = "-1";
-                newMsg.attachPath = path;
-            } else if (audio != null) {
-                if (encryptedChat != null && AndroidUtilities.getPeerLayerVersion(encryptedChat.layer) >= 17) {
-                    newMsg = new TLRPC.TL_message_secret();
-                } else {
-                    newMsg = new TLRPC.TL_message();
+                    newMsg.from_id = UserConfig.getClientUserId();
+                    newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
                 }
-                newMsg.media = new TLRPC.TL_messageMediaAudio();
-                newMsg.media.audio = audio;
-                type = 8;
-                newMsg.message = "-1";
-                newMsg.attachPath = path;
-            }
-            if (newMsg.attachPath == null) {
-                newMsg.attachPath = "";
+                UserConfig.saveConfig(false);
             }
-            newMsg.local_id = newMsg.id = UserConfig.getNewMessageId();
-            newMsg.flags |= TLRPC.MESSAGE_FLAG_OUT;
-            if (asAdmin && sendToPeer != null && sendToPeer.channel_id != 0) {
-                newMsg.from_id = -sendToPeer.channel_id;
-            } else {
-                newMsg.from_id = UserConfig.getClientUserId();
-                newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_FROM_ID;
+            if (newMsg.random_id == 0) {
+                newMsg.random_id = getNextRandomId();
             }
-            UserConfig.saveConfig(false);
-        }
-        if (newMsg.random_id == 0) {
-            newMsg.random_id = getNextRandomId();
-        }
-        newMsg.date = ConnectionsManager.getInstance().getCurrentTime();
-        newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_MEDIA;
-        if (encryptedChat == null && high_id != 1 && newMsg.media instanceof TLRPC.TL_messageMediaAudio) {
-            newMsg.flags |= TLRPC.MESSAGE_FLAG_CONTENT_UNREAD;
-        }
-        if (sendToPeer instanceof TLRPC.TL_inputPeerChannel) {
-            if (asAdmin) {
-                newMsg.views = 1;
-                newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_VIEWS;
+            newMsg.date = ConnectionsManager.getInstance().getCurrentTime();
+            newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_MEDIA;
+            if (encryptedChat == null && high_id != 1 && newMsg.media instanceof TLRPC.TL_messageMediaAudio) {
+                newMsg.media_unread = true;
             }
-        } else {
-            newMsg.flags |= TLRPC.MESSAGE_FLAG_UNREAD;
-        }
-        newMsg.dialog_id = peer;
-        if (reply_to_msg != null) {
-            newMsg.flags |= TLRPC.MESSAGE_FLAG_REPLY;
-            newMsg.reply_to_msg_id = reply_to_msg.getId();
-        }
-        if (lower_id != 0) {
-            if (high_id == 1) {
-                if (currentChatInfo == null) {
-                    MessagesStorage.getInstance().markMessageAsSendError(newMsg);
-                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.messageSendError, newMsg.id);
-                    processSentMessage(newMsg.id);
-                    return;
-                }
-                sendToPeers = new ArrayList<>();
-                for (TLRPC.TL_chatParticipant participant : currentChatInfo.participants.participants) {
-                    TLRPC.User sendToUser = MessagesController.getInstance().getUser(participant.user_id);
-                    TLRPC.InputUser peerUser = MessagesController.getInputUser(sendToUser);
-                    if (peerUser != null) {
-                        sendToPeers.add(peerUser);
-                    }
-                }
-                newMsg.to_id = new TLRPC.TL_peerChat();
-                newMsg.to_id.chat_id = lower_id;
+            if (sendToPeer instanceof TLRPC.TL_inputPeerChannel) {
+                if (asAdmin) {
+                    newMsg.views = 1;
+                    newMsg.flags |= TLRPC.MESSAGE_FLAG_HAS_VIEWS;
+                }
+                TLRPC.Chat chat = MessagesController.getInstance().getChat(sendToPeer.channel_id);
+                if (chat != null && chat.megagroup) {
+                    newMsg.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                }
             } else {
-                newMsg.to_id = MessagesController.getPeer(lower_id);
-                if (lower_id > 0) {
-                    TLRPC.User sendToUser = MessagesController.getInstance().getUser(lower_id);
-                    if (sendToUser == null) {
+                newMsg.unread = true;
+            }
+            newMsg.dialog_id = peer;
+            if (reply_to_msg != null) {
+                newMsg.flags |= TLRPC.MESSAGE_FLAG_REPLY;
+                newMsg.reply_to_msg_id = reply_to_msg.getId();
+            }
+            if (lower_id != 0) {
+                if (high_id == 1) {
+                    if (currentChatInfo == null) {
+                        MessagesStorage.getInstance().markMessageAsSendError(newMsg);
+                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.messageSendError, newMsg.id);
                         processSentMessage(newMsg.id);
                         return;
                     }
-                    if ((sendToUser.flags & TLRPC.USER_FLAG_BOT) != 0) {
-                        newMsg.flags &= ~TLRPC.MESSAGE_FLAG_UNREAD;
+                    sendToPeers = new ArrayList<>();
+                    for (TLRPC.ChatParticipant participant : currentChatInfo.participants.participants) {
+                        TLRPC.User sendToUser = MessagesController.getInstance().getUser(participant.user_id);
+                        TLRPC.InputUser peerUser = MessagesController.getInputUser(sendToUser);
+                        if (peerUser != null) {
+                            sendToPeers.add(peerUser);
+                        }
+                    }
+                    newMsg.to_id = new TLRPC.TL_peerChat();
+                    newMsg.to_id.chat_id = lower_id;
+                } else {
+                    newMsg.to_id = MessagesController.getPeer(lower_id);
+                    if (lower_id > 0) {
+                        TLRPC.User sendToUser = MessagesController.getInstance().getUser(lower_id);
+                        if (sendToUser == null) {
+                            processSentMessage(newMsg.id);
+                            return;
+                        }
+                        if (sendToUser.bot) {
+                            newMsg.unread = false;
+                        }
                     }
                 }
-            }
-        } else {
-            newMsg.to_id = new TLRPC.TL_peerUser();
-            if (encryptedChat.participant_id == UserConfig.getClientUserId()) {
-                newMsg.to_id.user_id = encryptedChat.admin_id;
             } else {
-                newMsg.to_id.user_id = encryptedChat.participant_id;
-            }
-            newMsg.ttl = encryptedChat.ttl;
-            if (newMsg.ttl != 0) {
-                if (newMsg.media instanceof TLRPC.TL_messageMediaAudio) {
-                    newMsg.ttl = Math.max(encryptedChat.ttl, newMsg.media.audio.duration + 1);
-                } else if (newMsg.media instanceof TLRPC.TL_messageMediaVideo) {
-                    newMsg.ttl = Math.max(encryptedChat.ttl, newMsg.media.video.duration + 1);
+                newMsg.to_id = new TLRPC.TL_peerUser();
+                if (encryptedChat.participant_id == UserConfig.getClientUserId()) {
+                    newMsg.to_id.user_id = encryptedChat.admin_id;
+                } else {
+                    newMsg.to_id.user_id = encryptedChat.participant_id;
+                }
+                newMsg.ttl = encryptedChat.ttl;
+                if (newMsg.ttl != 0) {
+                    if (newMsg.media instanceof TLRPC.TL_messageMediaAudio) {
+                        newMsg.ttl = Math.max(encryptedChat.ttl, newMsg.media.audio.duration + 1);
+                    } else if (newMsg.media instanceof TLRPC.TL_messageMediaVideo) {
+                        newMsg.ttl = Math.max(encryptedChat.ttl, newMsg.media.video.duration + 1);
+                    }
                 }
             }
-        }
 
-        MessageObject newMsgObj = new MessageObject(newMsg, null, true);
-        newMsgObj.replyMessageObject = reply_to_msg;
-        newMsgObj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SENDING;
+            newMsgObj = new MessageObject(newMsg, null, true);
+            newMsgObj.replyMessageObject = reply_to_msg;
+            newMsgObj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SENDING;
 
-        ArrayList<MessageObject> objArr = new ArrayList<>();
-        objArr.add(newMsgObj);
-        ArrayList<TLRPC.Message> arr = new ArrayList<>();
-        arr.add(newMsg);
-        MessagesStorage.getInstance().putMessages(arr, false, true, false, 0);
-        MessagesController.getInstance().updateInterfaceWithMessages(peer, objArr);
-        NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
+            ArrayList<MessageObject> objArr = new ArrayList<>();
+            objArr.add(newMsgObj);
+            ArrayList<TLRPC.Message> arr = new ArrayList<>();
+            arr.add(newMsg);
+            MessagesStorage.getInstance().putMessages(arr, false, true, false, 0);
+            MessagesController.getInstance().updateInterfaceWithMessages(peer, objArr);
+            NotificationCenter.getInstance().postNotificationName(NotificationCenter.dialogsNeedReload);
 
-        try {
             if (type == 0) {
                 if (encryptedChat == null) {
                     if (sendToPeers != null) {
@@ -1053,14 +1065,14 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                         reqSend.peer = sendToPeer;
                         reqSend.random_id = newMsg.random_id;
                         if (asAdmin && sendToPeer instanceof TLRPC.TL_inputPeerChannel) {
-                            reqSend.flags |= 16;
+                            reqSend.broadcast = true;
                         }
                         if (reply_to_msg != null) {
                             reqSend.flags |= 1;
                             reqSend.reply_to_msg_id = reply_to_msg.getId();
                         }
                         if (!searchLinks) {
-                            reqSend.flags |= 2;
+                            reqSend.no_webpage = true;
                         }
                         performSendMessageRequest(reqSend, newMsgObj.messageOwner, null);
                     }
@@ -1214,7 +1226,7 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                         request.random_id = newMsg.random_id;
                         request.media = inputMedia;
                         if (asAdmin && sendToPeer instanceof TLRPC.TL_inputPeerChannel) {
-                            request.flags |= 16;
+                            request.broadcast = true;
                         }
                         if (reply_to_msg != null) {
                             request.flags |= 1;
@@ -1435,22 +1447,32 @@ private void sendMessage(String message, TLRPC.MessageMedia location, TLRPC.TL_p
                     }
                 }
             } else if (type == 4) {
-                TLRPC.TL_messages_forwardMessage reqSend = new TLRPC.TL_messages_forwardMessage(); //TODO remove
-                reqSend.peer = sendToPeer;
-                reqSend.random_id = newMsg.random_id;
-                if (msgObj.getId() >= 0) {
-                    reqSend.id = msgObj.getId();
+                TLRPC.TL_messages_forwardMessages reqSend = new TLRPC.TL_messages_forwardMessages();
+                reqSend.to_peer = sendToPeer;
+                if (retryMessageObject.messageOwner.ttl != 0) {
+                    reqSend.from_peer = MessagesController.getInputPeer(retryMessageObject.messageOwner.ttl);
+                } else {
+                    reqSend.from_peer = new TLRPC.TL_inputPeerEmpty();
+                }
+                reqSend.random_id.add(newMsg.random_id);
+                if (retryMessageObject.getId() >= 0) {
+                    reqSend.id.add(retryMessageObject.getId());
                 } else {
-                    reqSend.id = msgObj.messageOwner.fwd_msg_id;
+                    reqSend.id.add(retryMessageObject.messageOwner.fwd_msg_id);
+                }
+                if (asAdmin && reqSend.to_peer.channel_id != 0) {
+                    reqSend.broadcast = true;
                 }
                 performSendMessageRequest(reqSend, newMsgObj.messageOwner, null);
             }
         } catch (Exception e) {
             FileLog.e("tmessages", e);
-            MessagesStorage.getInstance().markMessageAsSendError(newMsgObj.messageOwner);
-            newMsgObj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SEND_ERROR;
-            NotificationCenter.getInstance().postNotificationName(NotificationCenter.messageSendError, newMsgObj.getId());
-            processSentMessage(newMsgObj.getId());
+            MessagesStorage.getInstance().markMessageAsSendError(newMsg);
+            if (newMsgObj != null) {
+                newMsgObj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SEND_ERROR;
+            }
+            NotificationCenter.getInstance().postNotificationName(NotificationCenter.messageSendError, newMsg.id);
+            processSentMessage(newMsg.id);
         }
     }
 
@@ -1597,6 +1619,8 @@ public void run(TLObject response, final TLRPC.TL_error error) {
                         newMsgObj.local_id = newMsgObj.id = res.id;
                         newMsgObj.date = res.date;
                         newMsgObj.entities = res.entities;
+                        newMsgObj.out = res.out;
+                        newMsgObj.unread = res.unread;
                         if (res.media != null) {
                             newMsgObj.media = res.media;
                             newMsgObj.flags |= TLRPC.MESSAGE_FLAG_HAS_MEDIA;
@@ -1621,6 +1645,9 @@ public void run(TLObject response, final TLRPC.TL_error error) {
                                 TLRPC.TL_updateNewChannelMessage newMessage = (TLRPC.TL_updateNewChannelMessage) update;
                                 sentMessages.add(newMessage.message);
                                 newMsgObj.id = newMessage.message.id;
+                                if ((newMsgObj.flags & TLRPC.MESSAGE_FLAG_MEGAGROUP) != 0) {
+                                    newMessage.message.flags |= TLRPC.MESSAGE_FLAG_MEGAGROUP;
+                                }
                                 processSentMessage(newMsgObj, newMessage.message, originalPath);
                                 MessagesController.getInstance().processNewChannelDifferenceParams(newMessage.pts, newMessage.pts_count, newMessage.message.to_id.channel_id);
                                 ok = true;
@@ -1673,7 +1700,7 @@ public void run() {
                         @Override
                         public void run() {
                             if (error.text.equals("PEER_FLOOD")) {
-                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.spamErrorReceived, 0);
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.needShowAlert, 0);
                             }
                         }
                     });
@@ -1718,7 +1745,7 @@ private void processSentMessage(TLRPC.Message newMsg, TLRPC.Message sentMessage,
             MessagesStorage.getInstance().putSentFile(originalPath, sentMessage.media.photo, 0);
 
             for (TLRPC.PhotoSize size : sentMessage.media.photo.sizes) {
-                if (size == null || size instanceof TLRPC.TL_photoSizeEmpty || size.type == null) {
+                if (size == null || size.location == null || size instanceof TLRPC.TL_photoSizeEmpty || size.type == null) {
                     continue;
                 }
                 for (TLRPC.PhotoSize size2 : newMsg.media.photo.sizes) {
@@ -1754,7 +1781,7 @@ private void processSentMessage(TLRPC.Message newMsg, TLRPC.Message sentMessage,
 
             TLRPC.PhotoSize size2 = newMsg.media.video.thumb;
             TLRPC.PhotoSize size = sentMessage.media.video.thumb;
-            if (size2.location != null && size2.location.volume_id == Integer.MIN_VALUE && size.location != null && !(size instanceof TLRPC.TL_photoSizeEmpty) && !(size2 instanceof TLRPC.TL_photoSizeEmpty)) {
+            if (size2 != null && size2.location != null && size2.location.volume_id == Integer.MIN_VALUE && size != null && size.location != null && !(size instanceof TLRPC.TL_photoSizeEmpty) && !(size2 instanceof TLRPC.TL_photoSizeEmpty)) {
                 String fileName = size2.location.volume_id + "_" + size2.location.local_id;
                 String fileName2 = size.location.volume_id + "_" + size.location.local_id;
                 if (!fileName.equals(fileName2)) {
@@ -1785,7 +1812,7 @@ private void processSentMessage(TLRPC.Message newMsg, TLRPC.Message sentMessage,
 
             TLRPC.PhotoSize size2 = newMsg.media.document.thumb;
             TLRPC.PhotoSize size = sentMessage.media.document.thumb;
-            if (size2.location != null && size2.location.volume_id == Integer.MIN_VALUE && size.location != null && !(size instanceof TLRPC.TL_photoSizeEmpty) && !(size2 instanceof TLRPC.TL_photoSizeEmpty)) {
+            if (size2 != null && size2.location != null && size2.location.volume_id == Integer.MIN_VALUE && size != null && size.location != null && !(size instanceof TLRPC.TL_photoSizeEmpty) && !(size2 instanceof TLRPC.TL_photoSizeEmpty)) {
                 String fileName = size2.location.volume_id + "_" + size2.location.local_id;
                 String fileName2 = size.location.volume_id + "_" + size.location.local_id;
                 if (!fileName.equals(fileName2)) {
@@ -1795,7 +1822,7 @@ private void processSentMessage(TLRPC.Message newMsg, TLRPC.Message sentMessage,
                     ImageLoader.getInstance().replaceImageInCache(fileName, fileName2, size.location);
                     size2.location = size.location;
                 }
-            } else if (MessageObject.isStickerMessage(sentMessage) && size2.location != null) {
+            } else if (MessageObject.isStickerMessage(sentMessage) && size2 != null && size2.location != null) {
                 size.location = size2.location;
             }
 
@@ -1837,6 +1864,8 @@ private void processSentMessage(TLRPC.Message newMsg, TLRPC.Message sentMessage,
             }
         } else if (sentMessage.media instanceof TLRPC.TL_messageMediaContact && newMsg.media instanceof TLRPC.TL_messageMediaContact) {
             newMsg.media = sentMessage.media;
+        } else if (sentMessage.media instanceof TLRPC.TL_messageMediaWebPage) {
+            newMsg.media = sentMessage.media;
         }
     }
 
@@ -2007,6 +2036,7 @@ private static boolean prepareSendingDocumentInternal(String path, String origin
                     if (bitmap != null) {
                         fileName.file_name = "animation.gif";
                         document.thumb = ImageLoader.scaleAndSaveImage(bitmap, 90, 90, 55, isEncrypted);
+                        bitmap.recycle();
                     }
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -2018,7 +2048,7 @@ private static boolean prepareSendingDocumentInternal(String path, String origin
                     bmOptions.inJustDecodeBounds = true;
                     RandomAccessFile file = new RandomAccessFile(path, "r");
                     ByteBuffer buffer = file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, path.length());
-                    Utilities.loadWebpImage(buffer, buffer.limit(), bmOptions);
+                    Utilities.loadWebpImage(null, buffer, buffer.limit(), bmOptions, true);
                     file.close();
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -2223,6 +2253,7 @@ public void run() {
                                     Bitmap bitmap = ImageLoader.loadBitmap(thumbFile.getAbsolutePath(), null, 90, 90, true);
                                     if (bitmap != null) {
                                         document.thumb = ImageLoader.scaleAndSaveImage(bitmap, 90, 90, 55, isEncrypted);
+                                        bitmap.recycle();
                                     }
                                 } catch (Exception e) {
                                     FileLog.e("tmessages", e);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/SmsListener.java b/TMessagesProj/src/main/java/org/telegram/messenger/SmsListener.java
index 53ae12959..bb7fad473 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/SmsListener.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/SmsListener.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/TgChooserTargetService.java b/TMessagesProj/src/main/java/org/telegram/messenger/TgChooserTargetService.java
new file mode 100644
index 000000000..fea43faaa
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/TgChooserTargetService.java
@@ -0,0 +1,177 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.messenger;
+
+import android.annotation.TargetApi;
+import android.content.ComponentName;
+import android.content.IntentFilter;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.BitmapShader;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.Shader;
+import android.graphics.drawable.Icon;
+import android.os.Build;
+import android.os.Bundle;
+import android.service.chooser.ChooserTarget;
+import android.service.chooser.ChooserTargetService;
+import android.text.TextUtils;
+
+import org.telegram.SQLite.SQLiteCursor;
+import org.telegram.tgnet.TLRPC;
+import org.telegram.ui.LaunchActivity;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.Semaphore;
+
+@TargetApi(Build.VERSION_CODES.M)
+public class TgChooserTargetService extends ChooserTargetService {
+
+    private Paint roundPaint;
+    private RectF bitmapRect;
+
+    @Override
+    public List<ChooserTarget> onGetChooserTargets(ComponentName targetActivityName, IntentFilter matchedFilter) {
+        final List<ChooserTarget> targets = new ArrayList<>();
+        if (!UserConfig.isClientActivated()) {
+            return targets;
+        }
+        ImageLoader imageLoader = ImageLoader.getInstance();
+        final Semaphore semaphore = new Semaphore(0);
+        final ComponentName componentName = new ComponentName(getPackageName(), LaunchActivity.class.getCanonicalName());
+        MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                ArrayList<Integer> dialogs = new ArrayList<>();
+                ArrayList<TLRPC.Chat> chats = new ArrayList<>();
+                ArrayList<TLRPC.User> users = new ArrayList<>();
+                try {
+                    ArrayList<Integer> usersToLoad = new ArrayList<>();
+                    usersToLoad.add(UserConfig.getClientUserId());
+                    ArrayList<Integer> chatsToLoad = new ArrayList<>();
+                    SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized(String.format(Locale.US, "SELECT did FROM dialogs ORDER BY date DESC LIMIT %d,%d", 0, 30));
+                    while (cursor.next()) {
+                        long id = cursor.longValue(0);
+
+                        int lower_id = (int) id;
+                        int high_id = (int) (id >> 32);
+                        if (lower_id != 0) {
+                            if (high_id == 1) {
+                                continue;
+                            } else {
+                                if (lower_id > 0) {
+                                    if (!usersToLoad.contains(lower_id)) {
+                                        usersToLoad.add(lower_id);
+                                    }
+                                } else {
+                                    if (!chatsToLoad.contains(-lower_id)) {
+                                        chatsToLoad.add(-lower_id);
+                                    }
+                                }
+                            }
+                        } else {
+                            continue;
+                        }
+                        dialogs.add(lower_id);
+                        if (dialogs.size() == 8) {
+                            break;
+                        }
+                    }
+                    cursor.dispose();
+                    if (!chatsToLoad.isEmpty()) {
+                        MessagesStorage.getInstance().getChatsInternal(TextUtils.join(",", chatsToLoad), chats);
+                    }
+                    if (!usersToLoad.isEmpty()) {
+                        MessagesStorage.getInstance().getUsersInternal(TextUtils.join(",", usersToLoad), users);
+                    }
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+                for (int a = 0; a < dialogs.size(); a++) {
+                    Bundle extras = new Bundle();
+                    Icon icon = null;
+                    String name = null;
+                    int id = dialogs.get(a);
+                    if (id > 0) {
+                        for (int b = 0; b < users.size(); b++) {
+                            TLRPC.User user = users.get(b);
+                            if (user.id == id) {
+                                if (!user.bot) {
+                                    extras.putLong("dialogId", (long) id);
+                                    if (user.photo != null && user.photo.photo_small != null) {
+                                        icon = createRoundBitmap(FileLoader.getPathToAttach(user.photo.photo_small, true));
+                                    }
+                                    name = ContactsController.formatName(user.first_name, user.last_name);
+                                }
+                                break;
+                            }
+                        }
+                    } else {
+                        for (int b = 0; b < chats.size(); b++) {
+                            TLRPC.Chat chat = chats.get(b);
+                            if (chat.id == -id) {
+                                if (!ChatObject.isNotInChat(chat) && (!ChatObject.isChannel(chat) || chat.megagroup)) {
+                                    extras.putLong("dialogId", (long) id);
+                                    if (chat.photo != null && chat.photo.photo_small != null) {
+                                        icon = createRoundBitmap(FileLoader.getPathToAttach(chat.photo.photo_small, true));
+                                    }
+                                    name = chat.title;
+                                }
+                                break;
+                            }
+                        }
+                    }
+                    if (name != null) {
+                        if (icon == null) {
+                            icon = Icon.createWithResource(ApplicationLoader.applicationContext, R.drawable.logo_avatar);
+                        }
+                        targets.add(new ChooserTarget(name, icon, 1.0f, componentName, extras));
+                    }
+                }
+                semaphore.release();
+            }
+        });
+        try {
+            semaphore.acquire();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+        return targets;
+    }
+
+    private Icon createRoundBitmap(File path) {
+        try {
+            Bitmap bitmap = BitmapFactory.decodeFile(path.toString());
+            if (bitmap != null) {
+                Bitmap result = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);
+                result.eraseColor(Color.TRANSPARENT);
+                Canvas canvas = new Canvas(result);
+                BitmapShader shader = new BitmapShader(bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
+                if (roundPaint == null) {
+                    roundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+                    bitmapRect = new RectF();
+                }
+                roundPaint.setShader(shader);
+                bitmapRect.set(0, 0, bitmap.getWidth(), bitmap.getHeight());
+                canvas.drawRoundRect(bitmapRect, bitmap.getWidth(), bitmap.getHeight(), roundPaint);
+                return Icon.createWithBitmap(result);
+            }
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+        return null;
+    }
+
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/UserConfig.java b/TMessagesProj/src/main/java/org/telegram/messenger/UserConfig.java
index eb8acd4d9..ffaa8848c 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/UserConfig.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/UserConfig.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -38,9 +38,16 @@
     public static int autoLockIn = 60 * 60;
     public static int lastPauseTime = 0;
     public static boolean isWaitingForPasscodeEnter = false;
+    public static boolean useFingerprint = true;
     public static int lastUpdateVersion;
     public static int lastContactsSyncTime;
-    public static boolean channelsLoaded = false;
+
+    public static int migrateOffsetId = -1;
+    public static int migrateOffsetDate = -1;
+    public static int migrateOffsetUserId = -1;
+    public static int migrateOffsetChatId = -1;
+    public static int migrateOffsetChannelId = -1;
+    public static long migrateOffsetAccess = -1;
 
     public static int getNewMessageId() {
         int id;
@@ -78,7 +85,16 @@ public static void saveConfig(boolean withFile, File oldFile) {
                 editor.putInt("lastPauseTime", lastPauseTime);
                 editor.putInt("lastUpdateVersion", lastUpdateVersion);
                 editor.putInt("lastContactsSyncTime", lastContactsSyncTime);
-                editor.putBoolean("channelsLoaded", channelsLoaded);
+                editor.putBoolean("useFingerprint", useFingerprint);
+
+                editor.putInt("migrateOffsetId", migrateOffsetId);
+                if (migrateOffsetId != -1) {
+                    editor.putInt("migrateOffsetDate", migrateOffsetDate);
+                    editor.putInt("migrateOffsetUserId", migrateOffsetUserId);
+                    editor.putInt("migrateOffsetChatId", migrateOffsetChatId);
+                    editor.putInt("migrateOffsetChannelId", migrateOffsetChannelId);
+                    editor.putLong("migrateOffsetAccess", migrateOffsetAccess);
+                }
 
                 if (currentUser != null) {
                     if (withFile) {
@@ -128,7 +144,7 @@ public static void setCurrentUser(TLRPC.User user) {
 
     public static void loadConfig() {
         synchronized (sync) {
-            final File configFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "user.dat");
+            final File configFile = new File(ApplicationLoader.getFilesDirFixed(), "user.dat");
             if (configFile.exists()) {
                 try {
                     SerializedData data = new SerializedData(configFile);
@@ -207,9 +223,19 @@ public void run() {
                 passcodeType = preferences.getInt("passcodeType", 0);
                 autoLockIn = preferences.getInt("autoLockIn", 60 * 60);
                 lastPauseTime = preferences.getInt("lastPauseTime", 0);
+                useFingerprint = preferences.getBoolean("useFingerprint", true);
                 lastUpdateVersion = preferences.getInt("lastUpdateVersion", 511);
                 lastContactsSyncTime = preferences.getInt("lastContactsSyncTime", (int) (System.currentTimeMillis() / 1000) - 23 * 60 * 60);
-                channelsLoaded = preferences.getBoolean("channelsLoaded", false);
+
+                migrateOffsetId = preferences.getInt("migrateOffsetId", 0);
+                if (migrateOffsetId != -1) {
+                    migrateOffsetDate = preferences.getInt("migrateOffsetDate", 0);
+                    migrateOffsetUserId = preferences.getInt("migrateOffsetUserId", 0);
+                    migrateOffsetChatId = preferences.getInt("migrateOffsetChatId", 0);
+                    migrateOffsetChannelId = preferences.getInt("migrateOffsetChannelId", 0);
+                    migrateOffsetAccess = preferences.getLong("migrateOffsetAccess", 0);
+                }
+
                 String user = preferences.getString("user", null);
                 if (user != null) {
                     byte[] userBytes = Base64.decode(user, Base64.DEFAULT);
@@ -274,13 +300,19 @@ public static void clearConfig() {
         lastBroadcastId = -1;
         saveIncomingPhotos = false;
         blockedUsersLoaded = false;
-        channelsLoaded = false;
+        migrateOffsetId = -1;
+        migrateOffsetDate = -1;
+        migrateOffsetUserId = -1;
+        migrateOffsetChatId = -1;
+        migrateOffsetChannelId = -1;
+        migrateOffsetAccess = -1;
         appLocked = false;
         passcodeType = 0;
         passcodeHash = "";
         passcodeSalt = new byte[0];
         autoLockIn = 60 * 60;
         lastPauseTime = 0;
+        useFingerprint = true;
         isWaitingForPasscodeEnter = false;
         lastUpdateVersion = BuildVars.BUILD_VERSION;
         lastContactsSyncTime = (int) (System.currentTimeMillis() / 1000) - 23 * 60 * 60;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/UserObject.java b/TMessagesProj/src/main/java/org/telegram/messenger/UserObject.java
index 882339fbd..525c2ed81 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/UserObject.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/UserObject.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -14,15 +14,15 @@
 public class UserObject {
 
     public static boolean isDeleted(TLRPC.User user) {
-        return user == null || user instanceof TLRPC.TL_userDeleted_old2 || user instanceof TLRPC.TL_userEmpty || (user.flags & TLRPC.USER_FLAG_DELETED) != 0;
+        return user == null || user instanceof TLRPC.TL_userDeleted_old2 || user instanceof TLRPC.TL_userEmpty || user.deleted;
     }
 
     public static boolean isContact(TLRPC.User user) {
-        return user instanceof TLRPC.TL_userContact_old2 || (user.flags & TLRPC.USER_FLAG_CONTACT) != 0 || (user.flags & TLRPC.USER_FLAG_MUTUAL_CONTACT) != 0;
+        return user instanceof TLRPC.TL_userContact_old2 || user.contact || user.mutual_contact;
     }
 
     public static boolean isUserSelf(TLRPC.User user) {
-        return user instanceof TLRPC.TL_userSelf_old3 || (user.flags & TLRPC.USER_FLAG_SELF) != 0;
+        return user instanceof TLRPC.TL_userSelf_old3 || user.self;
     }
 
     public static String getUserName(TLRPC.User user) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
index ab94d2ad5..b8a415250 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/Utilities.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -46,17 +46,11 @@
     }
 
     public native static void loadBitmap(String path, Bitmap bitmap, int scale, int width, int height, int stride);
-
     public native static int pinBitmap(Bitmap bitmap);
-
     public native static void blurBitmap(Object bitmap, int radius, int unpin);
-
     public native static void calcCDT(ByteBuffer hsvBuffer, int width, int height, ByteBuffer buffer);
-
-    public native static Bitmap loadWebpImage(ByteBuffer buffer, int len, BitmapFactory.Options options);
-
+    public native static boolean loadWebpImage(Bitmap bitmap, ByteBuffer buffer, int len, BitmapFactory.Options options, boolean unpin);
     public native static int convertVideoFrame(ByteBuffer src, ByteBuffer dest, int destFormat, int width, int height, int padding, int swap);
-
     private native static void aesIgeEncryption(ByteBuffer buffer, byte[] key, byte[] iv, boolean encrypt, int offset, int length);
 
     public static void aesIgeEncryption(ByteBuffer buffer, byte[] key, byte[] iv, boolean encrypt, boolean changeIv, int offset, int length) {
@@ -155,6 +149,11 @@ public static boolean isGoodPrime(byte[] prime, int g) {
             }
         }
 
+        String hex = bytesToHex(prime);
+        if (hex.equals("C71CAEB9C6B1C9048E6C522F70F13F73980D40238E3E21C14934D037563D930F48198A0AA7C14058229493D22530F4DBFA336F6E0AC925139543AED44CCE7C3720FD51F69458705AC68CD4FE6B6B13ABDC9746512969328454F18FAF8C595F642477FE96BB2A941D5BCD1D4AC8CC49880708FA9B378E3C4F3A9060BEE67CF9A4A4A695811051907E162753B56B0F6B410DBA74D8A84B2A14B3144E0EF1284754FD17ED950D5965B4B9DD46582DB1178D169C6BC465B0D6FF9CA3928FEF5B9AE4E418FC15E83EBEA0F87FA9FF5EED70050DED2849F47BF959D956850CE929851F0D8115F635B105EE2E4E15D04B2454BF6F4FADF034B10403119CD8E3B92FCC5B")) {
+            return true;
+        }
+
         BigInteger dhBI2 = dhBI.subtract(BigInteger.valueOf(1)).divide(BigInteger.valueOf(2));
         return !(!dhBI.isProbablePrime(30) || !dhBI2.isProbablePrime(30));
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/VideoEditedInfo.java b/TMessagesProj/src/main/java/org/telegram/messenger/VideoEditedInfo.java
index cc258b89d..39bccc1e2 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/VideoEditedInfo.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/VideoEditedInfo.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/VideoEncodingService.java b/TMessagesProj/src/main/java/org/telegram/messenger/VideoEncodingService.java
index 82bc00181..9176c2f12 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/VideoEncodingService.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/VideoEncodingService.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/WearReplyReceiver.java b/TMessagesProj/src/main/java/org/telegram/messenger/WearReplyReceiver.java
index 15b393445..f19e894fa 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/WearReplyReceiver.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/WearReplyReceiver.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger;
@@ -32,6 +32,6 @@ public void onReceive(Context context, Intent intent) {
             return;
         }
         SendMessagesHelper.getInstance().sendMessage(text.toString(), dialog_id, null, null, true, false);
-        MessagesController.getInstance().markDialogAsRead(dialog_id, max_id, max_id, 0, 0, true, false);
+        MessagesController.getInstance().markDialogAsRead(dialog_id, max_id, max_id, 0, true, false);
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/query/BotQuery.java b/TMessagesProj/src/main/java/org/telegram/messenger/query/BotQuery.java
index 91f46880b..c4678265d 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/query/BotQuery.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/query/BotQuery.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/query/MessagesSearchQuery.java b/TMessagesProj/src/main/java/org/telegram/messenger/query/MessagesSearchQuery.java
index 4d9145287..9ae9d3f30 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/query/MessagesSearchQuery.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/query/MessagesSearchQuery.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -20,18 +20,19 @@
 
 import java.util.ArrayList;
 
+@SuppressWarnings("unchecked")
 public class MessagesSearchQuery {
 
     private static int reqId;
     private static int lastReqId;
-    private static boolean messagesSearchEndReached;
+    private static boolean messagesSearchEndReached[] = new boolean[] {false, false};
     private static ArrayList<MessageObject> searchResultMessages = new ArrayList<>();
     private static String lastSearchQuery;
     private static int lastReturnedNum;
 
     private static int getMask() {
         int mask = 0;
-        if (lastReturnedNum < searchResultMessages.size() - 1) {
+        if (lastReturnedNum < searchResultMessages.size() - 1 || !messagesSearchEndReached[0] || !messagesSearchEndReached[1]) {
             mask |= 1;
         }
         if (lastReturnedNum > 0) {
@@ -40,25 +41,37 @@ private static int getMask() {
         return mask;
     }
 
-    public static void searchMessagesInChat(String query, long dialog_id, final int guid, int direction) {
+    public static void searchMessagesInChat(String query, final long dialog_id, final long mergeDialogId, final int guid, int direction) {
         if (reqId != 0) {
             ConnectionsManager.getInstance().cancelRequest(reqId, true);
             reqId = 0;
         }
         int max_id = 0;
+        long queryWithDialog = dialog_id;
         if (query == null || query.length() == 0) {
             if (direction == 1) {
                 lastReturnedNum++;
                 if (lastReturnedNum < searchResultMessages.size()) {
-                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatSearchResultsAvailable, guid, searchResultMessages.get(lastReturnedNum).getId(), getMask());
+                    MessageObject messageObject = searchResultMessages.get(lastReturnedNum);
+                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatSearchResultsAvailable, guid, messageObject.getId(), getMask(), messageObject.getDialogId());
                     return;
                 } else {
-                    if (messagesSearchEndReached) {
+                    if (messagesSearchEndReached[0] && mergeDialogId == 0 || messagesSearchEndReached[1]) {
                         lastReturnedNum--;
                         return;
                     }
                     query = lastSearchQuery;
-                    max_id = searchResultMessages.get(searchResultMessages.size() - 1).getId();
+                    MessageObject messageObject = searchResultMessages.get(searchResultMessages.size() - 1);
+                    if (messageObject.getDialogId() == dialog_id && !messagesSearchEndReached[0]) {
+                        max_id = messageObject.getId();
+                        queryWithDialog = dialog_id;
+                    } else {
+                        if (messageObject.getDialogId() == mergeDialogId) {
+                            max_id = messageObject.getId();
+                        }
+                        queryWithDialog = mergeDialogId;
+                        messagesSearchEndReached[1] = false;
+                    }
                 }
             } else if (direction == 2) {
                 lastReturnedNum--;
@@ -66,15 +79,22 @@ public static void searchMessagesInChat(String query, long dialog_id, final int
                     lastReturnedNum = 0;
                     return;
                 }
-                NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatSearchResultsAvailable, guid, searchResultMessages.get(lastReturnedNum).getId(), getMask());
+                if (lastReturnedNum >= searchResultMessages.size()) {
+                    lastReturnedNum = searchResultMessages.size() - 1;
+                }
+                MessageObject messageObject = searchResultMessages.get(lastReturnedNum);
+                NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatSearchResultsAvailable, guid, messageObject.getId(), getMask(), messageObject.getDialogId());
                 return;
             } else {
                 return;
             }
         }
+        if (messagesSearchEndReached[0] && !messagesSearchEndReached[1] && mergeDialogId != 0) {
+            queryWithDialog = mergeDialogId;
+        }
         final TLRPC.TL_messages_search req = new TLRPC.TL_messages_search();
         req.limit = 21;
-        int lower_part = (int) dialog_id;
+        int lower_part = (int) queryWithDialog;
         req.peer = MessagesController.getInputPeer(lower_part);
         if (req.peer == null) {
             return;
@@ -84,19 +104,21 @@ public static void searchMessagesInChat(String query, long dialog_id, final int
         req.filter = new TLRPC.TL_inputMessagesFilterEmpty();
         final int currentReqId = ++lastReqId;
         lastSearchQuery = query;
+        final long queryWithDialogFinal = queryWithDialog;
         reqId = ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
             @Override
             public void run(final TLObject response, final TLRPC.TL_error error) {
                 AndroidUtilities.runOnUIThread(new Runnable() {
                     @Override
                     public void run() {
+                        reqId = 0;
                         if (currentReqId == lastReqId) {
                             if (error == null) {
                                 TLRPC.messages_Messages res = (TLRPC.messages_Messages) response;
                                 MessagesStorage.getInstance().putUsersAndChats(res.users, res.chats, true, true);
                                 MessagesController.getInstance().putUsers(res.users, false);
                                 MessagesController.getInstance().putChats(res.chats, false);
-                                if (req.max_id == 0) {
+                                if (req.max_id == 0 && queryWithDialogFinal == dialog_id) {
                                     lastReturnedNum = 0;
                                     searchResultMessages.clear();
                                 }
@@ -106,17 +128,27 @@ public void run() {
                                     added = true;
                                     searchResultMessages.add(new MessageObject(message, null, false));
                                 }
-                                messagesSearchEndReached = res.messages.size() != 21;
+                                messagesSearchEndReached[queryWithDialogFinal == dialog_id ? 0 : 1] = res.messages.size() != 21;
+                                if (mergeDialogId == 0) {
+                                    messagesSearchEndReached[1] = messagesSearchEndReached[0];
+                                }
                                 if (searchResultMessages.isEmpty()) {
-                                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatSearchResultsAvailable, guid, 0, getMask());
+                                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatSearchResultsAvailable, guid, 0, getMask(), (long) 0);
                                 } else {
                                     if (added) {
-                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatSearchResultsAvailable, guid, searchResultMessages.get(lastReturnedNum).getId(), getMask());
+                                        if (lastReturnedNum >= searchResultMessages.size()) {
+                                            lastReturnedNum = searchResultMessages.size() - 1;
+                                        }
+                                        MessageObject messageObject = searchResultMessages.get(lastReturnedNum);
+                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.chatSearchResultsAvailable, guid, messageObject.getId(), getMask(), messageObject.getDialogId());
                                     }
                                 }
+                                if (queryWithDialogFinal == dialog_id && messagesSearchEndReached[0] && mergeDialogId != 0) {
+                                    messagesSearchEndReached[1] = false;
+                                    searchMessagesInChat(lastSearchQuery, dialog_id, mergeDialogId, guid, 0);
+                                }
                             }
                         }
-                        reqId = 0;
                     }
                 });
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/query/ReplyMessageQuery.java b/TMessagesProj/src/main/java/org/telegram/messenger/query/ReplyMessageQuery.java
index 50d7a5ad0..554d421c8 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/query/ReplyMessageQuery.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/query/ReplyMessageQuery.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -82,39 +82,7 @@ public void run() {
                             message.id = cursor.intValue(1);
                             message.date = cursor.intValue(2);
                             message.dialog_id = dialog_id;
-                            if (message.from_id > 0) {
-                                if (!usersToLoad.contains(message.from_id)) {
-                                    usersToLoad.add(message.from_id);
-                                }
-                            } else {
-                                if (!chatsToLoad.contains(-message.from_id)) {
-                                    chatsToLoad.add(-message.from_id);
-                                }
-                            }
-                            if (message.action != null && message.action.user_id != 0) {
-                                if (!usersToLoad.contains(message.action.user_id)) {
-                                    usersToLoad.add(message.action.user_id);
-                                }
-                            }
-                            if (message.media != null && message.media.user_id != 0) {
-                                if (!usersToLoad.contains(message.media.user_id)) {
-                                    usersToLoad.add(message.media.user_id);
-                                }
-                            }
-                            if (message.media != null && message.media.audio != null && message.media.audio.user_id != 0) {
-                                if (!usersToLoad.contains(message.media.audio.user_id)) {
-                                    usersToLoad.add(message.media.audio.user_id);
-                                }
-                            }
-                            if (message.fwd_from_id instanceof TLRPC.TL_peerUser) {
-                                if (!usersToLoad.contains(message.fwd_from_id.user_id)) {
-                                    usersToLoad.add(message.fwd_from_id.user_id);
-                                }
-                            } else if (message.fwd_from_id instanceof TLRPC.TL_peerChannel) {
-                                if (!chatsToLoad.contains(message.fwd_from_id.channel_id)) {
-                                    chatsToLoad.add(message.fwd_from_id.channel_id);
-                                }
-                            }
+                            MessagesStorage.addUsersAndChatsFromMessage(message, usersToLoad, chatsToLoad);
                             result.add(message);
                             replyMessages.remove((Integer) message.id);
                         }
@@ -206,9 +174,15 @@ public void run() {
     }
 
     private static void broadcastReplyMessages(final ArrayList<TLRPC.Message> result, final HashMap<Integer, ArrayList<MessageObject>> replyMessageOwners, final ArrayList<TLRPC.User> users, final ArrayList<TLRPC.Chat> chats, final long dialog_id, final boolean isCache) {
-        final HashMap<Integer, TLRPC.User> usersHashMap = new HashMap<>();
-        for (TLRPC.User user : users) {
-            usersHashMap.put(user.id, user);
+        final HashMap<Integer, TLRPC.User> usersDict = new HashMap<>();
+        for (int a = 0; a < users.size(); a++) {
+            TLRPC.User user = users.get(a);
+            usersDict.put(user.id, user);
+        }
+        final HashMap<Integer, TLRPC.Chat> chatsDict = new HashMap<>();
+        for (int a = 0; a < chats.size(); a++) {
+            TLRPC.Chat chat = chats.get(a);
+            chatsDict.put(chat.id, chat);
         }
         AndroidUtilities.runOnUIThread(new Runnable() {
             @Override
@@ -216,11 +190,13 @@ public void run() {
                 MessagesController.getInstance().putUsers(users, isCache);
                 MessagesController.getInstance().putChats(chats, isCache);
                 boolean changed = false;
-                for (TLRPC.Message message : result) {
+                for (int a = 0; a < result.size(); a++) {
+                    TLRPC.Message message = result.get(a);
                     ArrayList<MessageObject> arrayList = replyMessageOwners.get(message.id);
                     if (arrayList != null) {
-                        MessageObject messageObject = new MessageObject(message, usersHashMap, false);
-                        for (MessageObject m : arrayList) {
+                        MessageObject messageObject = new MessageObject(message, usersDict, chatsDict, false);
+                        for (int b = 0; b < arrayList.size(); b++) {
+                            MessageObject m = arrayList.get(b);
                             m.replyMessageObject = messageObject;
                         }
                         changed = true;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/query/SharedMediaQuery.java b/TMessagesProj/src/main/java/org/telegram/messenger/query/SharedMediaQuery.java
index 9c31b1a47..f90134ef0 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/query/SharedMediaQuery.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/query/SharedMediaQuery.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.query;
@@ -37,7 +37,8 @@
     public final static int MEDIA_FILE = 1;
     public final static int MEDIA_AUDIO = 2;
     public final static int MEDIA_URL = 3;
-    public final static int MEDIA_TYPES_COUNT = 4;
+    public final static int MEDIA_MUSIC = 4;
+    public final static int MEDIA_TYPES_COUNT = 5;
 
     public static void loadMedia(final long uid, final int offset, final int count, final int max_id, final int type, final boolean fromCache, final int classGuid) {
         final boolean isChannel = (int) uid < 0 && ChatObject.isChannel(-(int) uid);
@@ -58,6 +59,8 @@ public static void loadMedia(final long uid, final int offset, final int count,
                 req.filter = new TLRPC.TL_inputMessagesFilterAudio();
             } else if (type == MEDIA_URL) {
                 req.filter = new TLRPC.TL_inputMessagesFilterUrl();
+            } else if (type == MEDIA_MUSIC) {
+                req.filter = new TLRPC.TL_inputMessagesFilterAudioDocuments();
             }
             req.q = "";
             req.peer = MessagesController.getInputPeer(lower_part);
@@ -101,6 +104,8 @@ public static void getMediaCount(final long uid, final int type, final int class
                 req.filter = new TLRPC.TL_inputMessagesFilterAudio();
             } else if (type == MEDIA_URL) {
                 req.filter = new TLRPC.TL_inputMessagesFilterUrl();
+            } else if (type == MEDIA_MUSIC) {
+                req.filter = new TLRPC.TL_inputMessagesFilterAudioDocuments();
             }
             req.q = "";
             req.peer = MessagesController.getInputPeer(lower_part);
@@ -144,6 +149,8 @@ public static int getMediaType(TLRPC.Message message) {
         } else if (message.media instanceof TLRPC.TL_messageMediaDocument) {
             if (MessageObject.isStickerMessage(message)) {
                 return -1;
+            } else if (MessageObject.isMusicMessage(message)) {
+                return MEDIA_MUSIC;
             } else {
                 return MEDIA_FILE;
             }
@@ -190,13 +197,15 @@ private static void processLoadedMedia(final TLRPC.messages_Messages res, final
                 putMediaDatabase(uid, type, res.messages, max_id, topReached);
             }
 
-            final HashMap<Integer, TLRPC.User> usersLocal = new HashMap<>();
-            for (TLRPC.User u : res.users) {
-                usersLocal.put(u.id, u);
+            final HashMap<Integer, TLRPC.User> usersDict = new HashMap<>();
+            for (int a = 0; a < res.users.size(); a++) {
+                TLRPC.User u = res.users.get(a);
+                usersDict.put(u.id, u);
             }
             final ArrayList<MessageObject> objects = new ArrayList<>();
-            for (TLRPC.Message message : res.messages) {
-                objects.add(new MessageObject(message, usersLocal, true));
+            for (int a = 0; a < res.messages.size(); a++) {
+                TLRPC.Message message = res.messages.get(a);
+                objects.add(new MessageObject(message, usersDict, true));
             }
 
             AndroidUtilities.runOnUIThread(new Runnable() {
@@ -266,37 +275,6 @@ public void run() {
                         }
                         cursor.dispose();
 
-                        /*cursor = MessagesStorage.getInstance().getDatabase().queryFinalized(String.format(Locale.US, "SELECT data, send_state, date FROM messages WHERE uid = %d ORDER BY mid ASC LIMIT %d", uid, 1000));
-                        ArrayList<TLRPC.Message> photos = new ArrayList<>();
-                        ArrayList<TLRPC.Message> docs = new ArrayList<>();
-                        while (cursor.next()) {
-                            NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(1));
-                            if (data != null && cursor.byteBufferValue(1, data) != 0) {
-                                TLRPC.Message message = (TLRPC.Message) TLClassStore.Instance().TLdeserialize(data, data.readInt32());
-                                MessageObject.setIsUnread(message, cursor.intValue(0) != 1);
-                                message.date = cursor.intValue(2);
-                                message.send_state = cursor.intValue(1);
-                                message.dialog_id = uid;
-                                if (message.ttl > 60 && message.media instanceof TLRPC.TL_messageMediaPhoto || message.media instanceof TLRPC.TL_messageMediaVideo) {
-                                    photos.add(message);
-                                } else if (message.media instanceof TLRPC.TL_messageMediaDocument) {
-                                    docs.add(message);
-                                }
-                            }
-                            data.reuse();
-                        }
-                        cursor.dispose();
-                        if (!photos.isEmpty() || !docs.isEmpty()) {
-                            MessagesStorage.getInstance().getDatabase().beginTransaction();
-                            if (!photos.isEmpty()) {
-                                putMediaDatabaseInternal(uid, MEDIA_PHOTOVIDEO, photos);
-                            }
-                            if (docs.isEmpty()) {
-                                putMediaDatabaseInternal(uid, MEDIA_FILE, docs);
-                            }
-                            MessagesStorage.getInstance().getDatabase().commitTransaction();
-                        }*/
-
                         if (count != -1) {
                             putMediaCountDatabase(uid, type, count);
                         }
@@ -367,9 +345,9 @@ public void run() {
                             }
                             cursor.dispose();
                             if (holeMessageId > 1) {
-                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND mid < %d AND mid >= %d AND type = %d ORDER BY date DESC, mid DESC LIMIT %d", uid, messageMaxId, holeMessageId, type, countToLoad));
+                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND mid > 0 AND mid < %d AND mid >= %d AND type = %d ORDER BY date DESC, mid DESC LIMIT %d", uid, messageMaxId, holeMessageId, type, countToLoad));
                             } else {
-                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND mid < %d AND type = %d ORDER BY date DESC, mid DESC LIMIT %d", uid, messageMaxId, type, countToLoad));
+                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND mid > 0 AND mid < %d AND type = %d ORDER BY date DESC, mid DESC LIMIT %d", uid, messageMaxId, type, countToLoad));
                             }
                         } else {
                             long holeMessageId = 0;
@@ -382,9 +360,9 @@ public void run() {
                             }
                             cursor.dispose();
                             if (holeMessageId > 1) {
-                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND type = %d AND mid >= %d ORDER BY date DESC, mid DESC LIMIT %d,%d", uid, type, holeMessageId, offset, countToLoad));
+                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND mid >= %d AND type = %d ORDER BY date DESC, mid DESC LIMIT %d,%d", uid, holeMessageId, type, offset, countToLoad));
                             } else {
-                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND type = %d ORDER BY date DESC, mid DESC LIMIT %d,%d", uid, type, offset, countToLoad));
+                                cursor = database.queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND mid > 0 AND type = %d ORDER BY date DESC, mid DESC LIMIT %d,%d", uid, type, offset, countToLoad));
                             }
                         }
                     } else {
@@ -500,7 +478,7 @@ public static void loadMusic(final long uid, final int max_id) {
             public void run() {
                 final ArrayList<MessageObject> arrayList = new ArrayList<>();
                 try {
-                    SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND mid < %d AND type = %d ORDER BY date DESC, mid DESC LIMIT 1000", uid, max_id, MEDIA_FILE));
+                    SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized(String.format(Locale.US, "SELECT data, mid FROM media_v2 WHERE uid = %d AND mid < %d AND type = %d ORDER BY date DESC, mid DESC LIMIT 1000", uid, max_id, MEDIA_MUSIC));
 
                     while (cursor.next()) {
                         NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(0));
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/query/StickersQuery.java b/TMessagesProj/src/main/java/org/telegram/messenger/query/StickersQuery.java
index 378d72a0e..a0fbd5151 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/query/StickersQuery.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/query/StickersQuery.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -33,11 +33,13 @@
 import org.telegram.ui.Components.StickersAlert;
 
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
 import java.util.HashMap;
 
 public class StickersQuery {
 
-    private static String loadHash;
+    private static int loadHash;
     private static int loadDate;
     private static ArrayList<TLRPC.TL_messages_stickerSet> stickerSets = new ArrayList<>();
     private static HashMap<Long, TLRPC.TL_messages_stickerSet> stickerSetsById = new HashMap<>();
@@ -49,7 +51,7 @@
     private static boolean stickersLoaded;
 
     public static void cleanup() {
-        loadHash = null;
+        loadHash = 0;
         loadDate = 0;
         allStickers.clear();
         stickerSets.clear();
@@ -74,7 +76,7 @@ public static boolean isLoadingStickers() {
         if (document != null) {
             long setId = getStickerSetId(document);
             TLRPC.TL_messages_stickerSet stickerSet = stickerSetsById.get(setId);
-            if (stickerSet != null && (stickerSet.set.flags & 2) != 0) {
+            if (stickerSet != null && stickerSet.set.disabled) {
                 return null;
             }
         }
@@ -98,6 +100,59 @@ public static String getEmojiForSticker(long id) {
         return value != null ? value : "";
     }
 
+    public static void reorderStickers(final ArrayList<Long> order) {
+        Collections.sort(stickerSets, new Comparator<TLRPC.TL_messages_stickerSet>() {
+            @Override
+            public int compare(TLRPC.TL_messages_stickerSet lhs, TLRPC.TL_messages_stickerSet rhs) {
+                int index1 = order.indexOf(lhs.set.id);
+                int index2 = order.indexOf(rhs.set.id);
+                if (index1 > index2) {
+                    return 1;
+                } else if (index1 < index2) {
+                    return -1;
+                }
+                return 0;
+            }
+        });
+        loadHash = calcStickersHash(stickerSets);
+        NotificationCenter.getInstance().postNotificationName(NotificationCenter.stickersDidLoaded);
+        StickersQuery.loadStickers(false, true);
+    }
+
+    public static void calcNewHash() {
+        loadHash = calcStickersHash(stickerSets);
+    }
+
+    public static void addNewStickerSet(final TLRPC.TL_messages_stickerSet set) {
+        if (!stickerSetsById.containsKey(set.set.id)) {
+            stickerSets.add(0, set);
+            stickerSetsById.put(set.set.id, set);
+            for (int a = 0; a < set.documents.size(); a++) {
+                TLRPC.Document document = set.documents.get(a);
+                stickersById.put(document.id, document);
+            }
+            for (int a = 0; a < set.packs.size(); a++) {
+                TLRPC.TL_stickerPack stickerPack = set.packs.get(a);
+                stickerPack.emoticon = stickerPack.emoticon.replace("\uFE0F", "");
+                ArrayList<TLRPC.Document> arrayList = allStickers.get(stickerPack.emoticon);
+                if (arrayList == null) {
+                    arrayList = new ArrayList<>();
+                    allStickers.put(stickerPack.emoticon, arrayList);
+                }
+                for (int c = 0; c < stickerPack.documents.size(); c++) {
+                    Long id = stickerPack.documents.get(c);
+                    if (!stickersByEmoji.containsKey(id)) {
+                        stickersByEmoji.put(id, stickerPack.emoticon);
+                    }
+                    arrayList.add(stickersById.get(id));
+                }
+            }
+            loadHash = calcStickersHash(stickerSets);
+            NotificationCenter.getInstance().postNotificationName(NotificationCenter.stickersDidLoaded);
+        }
+        StickersQuery.loadStickers(false, true);
+    }
+
     public static void loadStickers(boolean cache, boolean force) {
         if (loadingStickers) {
             return;
@@ -109,7 +164,7 @@ public static void loadStickers(boolean cache, boolean force) {
                 public void run() {
                     ArrayList<TLRPC.TL_messages_stickerSet> newStickerArray = null;
                     int date = 0;
-                    String hash = null;
+                    int hash = 0;
                     SQLiteCursor cursor = null;
                     try {
                         cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT data, date, hash FROM stickers_v2 WHERE 1");
@@ -124,7 +179,7 @@ public void run() {
                                 }
                             }
                             date = cursor.intValue(1);
-                            hash = cursor.stringValue(2);
+                            hash = calcStickersHash(newStickerArray);
                             data.reuse();
                         }
                     } catch (Throwable e) {
@@ -138,8 +193,8 @@ public void run() {
                 }
             });
         } else {
-            TLRPC.TL_messages_getAllStickers req = new TLRPC.TL_messages_getAllStickers();
-            req.hash = loadHash == null || force ? "" : loadHash;
+            final TLRPC.TL_messages_getAllStickers req = new TLRPC.TL_messages_getAllStickers();
+            req.hash = force ? 0 : loadHash;
             ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
                 @Override
                 public void run(final TLObject response, final TLRPC.TL_error error) {
@@ -156,7 +211,9 @@ public void run() {
 
                                     TLRPC.TL_messages_stickerSet oldSet = stickerSetsById.get(stickerSet.id);
                                     if (oldSet != null && oldSet.set.hash == stickerSet.hash) {
-                                        oldSet.set.flags = stickerSet.flags;
+                                        oldSet.set.disabled = stickerSet.disabled;
+                                        oldSet.set.installed = stickerSet.installed;
+                                        oldSet.set.official = stickerSet.official;
                                         newStickerSets.put(oldSet.set.id, oldSet);
                                         newStickerArray.add(oldSet);
 
@@ -192,7 +249,7 @@ public void run() {
                                     });
                                 }
                             } else {
-                                processLoadedStickers(null, false, (int) (System.currentTimeMillis() / 1000), error == null ? "" : null);
+                                processLoadedStickers(null, false, (int) (System.currentTimeMillis() / 1000), req.hash);
                             }
                         }
                     });
@@ -201,29 +258,37 @@ public void run() {
         }
     }
 
-    private static void putStickersToCache(final ArrayList<TLRPC.TL_messages_stickerSet> stickers, final int date, final String hash) {
+    private static void putStickersToCache(final ArrayList<TLRPC.TL_messages_stickerSet> stickers, final int date, final int hash) {
         MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
             @Override
             public void run() {
                 try {
-                    SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("REPLACE INTO stickers_v2 VALUES(?, ?, ?, ?)");
-                    state.requery();
-                    int size = 4;
-                    for (int a = 0; a < stickers.size(); a++) {
-                        size += stickers.get(a).getObjectSize();
-                    }
-                    NativeByteBuffer data = new NativeByteBuffer(size);
-                    data.writeInt32(stickers.size());
-                    for (int a = 0; a < stickers.size(); a++) {
-                        stickers.get(a).serializeToStream(data);
+                    if (stickers != null) {
+                        SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("REPLACE INTO stickers_v2 VALUES(?, ?, ?, ?)");
+                        state.requery();
+                        int size = 4;
+                        for (int a = 0; a < stickers.size(); a++) {
+                            size += stickers.get(a).getObjectSize();
+                        }
+                        NativeByteBuffer data = new NativeByteBuffer(size);
+                        data.writeInt32(stickers.size());
+                        for (int a = 0; a < stickers.size(); a++) {
+                            stickers.get(a).serializeToStream(data);
+                        }
+                        state.bindInteger(1, 1);
+                        state.bindByteBuffer(2, data);
+                        state.bindInteger(3, date);
+                        state.bindInteger(4, hash);
+                        state.step();
+                        data.reuse();
+                        state.dispose();
+                    } else {
+                        SQLitePreparedStatement state = MessagesStorage.getInstance().getDatabase().executeFast("UPDATE stickers_v2 SET date = ?");
+                        state.requery();
+                        state.bindInteger(1, date);
+                        state.step();
+                        state.dispose();
                     }
-                    state.bindInteger(1, 1);
-                    state.bindByteBuffer(2, data);
-                    state.bindInteger(3, date);
-                    state.bindString(4, hash);
-                    state.step();
-                    data.reuse();
-                    state.dispose();
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 }
@@ -232,7 +297,8 @@ public void run() {
     }
 
     public static long getStickerSetId(TLRPC.Document document) {
-        for (TLRPC.DocumentAttribute attribute : document.attributes) {
+        for (int a = 0; a < document.attributes.size(); a++) {
+            TLRPC.DocumentAttribute attribute = document.attributes.get(a);
             if (attribute instanceof TLRPC.TL_documentAttributeSticker) {
                 if (attribute.stickerset instanceof TLRPC.TL_inputStickerSetID) {
                     return attribute.stickerset.id;
@@ -243,7 +309,19 @@ public static long getStickerSetId(TLRPC.Document document) {
         return -1;
     }
 
-    private static void processLoadedStickers(final ArrayList<TLRPC.TL_messages_stickerSet> res, final boolean cache, final int date, final String hash) {
+    private static int calcStickersHash(ArrayList<TLRPC.TL_messages_stickerSet> sets) {
+        long acc = 0;
+        for (int a = 0; a < sets.size(); a++) {
+            TLRPC.StickerSet set = sets.get(a).set;
+            if (set.disabled) {
+                continue;
+            }
+            acc = ((acc * 20261) + 0x80000000L + set.hash) % 0x80000000L;
+        }
+        return (int) acc;
+    }
+
+    private static void processLoadedStickers(final ArrayList<TLRPC.TL_messages_stickerSet> res, final boolean cache, final int date, final int hash) {
         AndroidUtilities.runOnUIThread(new Runnable() {
             @Override
             public void run() {
@@ -254,11 +332,11 @@ public void run() {
         Utilities.stageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
-                if (cache && (res == null || date < (int) (System.currentTimeMillis() / 1000 - 60 * 60)) || !cache && res == null && hash == null) {
+                if (cache && (res == null || date < (int) (System.currentTimeMillis() / 1000 - 60 * 60)) || !cache && res == null && hash == 0) {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            if (res != null && hash != null) {
+                            if (res != null && hash != 0) {
                                 loadHash = hash;
                             }
                             loadStickers(false, false);
@@ -291,7 +369,7 @@ public void run() {
                                 }
                                 stickersByIdNew.put(document.id, document);
                             }
-                            if ((stickerSet.set.flags & 2) == 0) {
+                            if (!stickerSet.set.disabled) {
                                 for (int b = 0; b < stickerSet.packs.size(); b++) {
                                     TLRPC.TL_stickerPack stickerPack = stickerSet.packs.get(b);
                                     if (stickerPack == null || stickerPack.emoticon == null) {
@@ -333,6 +411,14 @@ public void run() {
                     } catch (Throwable e) {
                         FileLog.e("tmessages", e);
                     }
+                } else if (!cache) {
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            loadDate = date;
+                        }
+                    });
+                    putStickersToCache(null, date, 0);
                 }
             }
         });
@@ -433,11 +519,26 @@ public static void removeStickersSet(final Context context, TLRPC.StickerSet sti
         stickerSetID.access_hash = stickerSet.access_hash;
         stickerSetID.id = stickerSet.id;
         if (hide != 0) {
-            if (hide == 1) {
-                stickerSet.flags |= 2;
-            } else {
-                stickerSet.flags &= ~2;
+            stickerSet.disabled = hide == 1;
+            for (int a = 0; a < stickerSets.size(); a++) {
+                TLRPC.TL_messages_stickerSet set = stickerSets.get(a);
+                if (set.set.id == stickerSet.id) {
+                    stickerSets.remove(a);
+                    if (hide == 2) {
+                        stickerSets.add(0, set);
+                    } else {
+                        for (int b = stickerSets.size() - 1; b >= 0; b--) {
+                            if (stickerSets.get(b).set.disabled) {
+                                continue;
+                            }
+                            stickerSets.add(b + 1, set);
+                            break;
+                        }
+                    }
+                    break;
+                }
             }
+            loadHash = calcStickersHash(stickerSets);
             NotificationCenter.getInstance().postNotificationName(NotificationCenter.stickersDidLoaded);
             TLRPC.TL_messages_installStickerSet req = new TLRPC.TL_messages_installStickerSet();
             req.stickerset = stickerSetID;
@@ -448,7 +549,7 @@ public void run(TLObject response, final TLRPC.TL_error error) {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            loadStickers(false, true);
+                            loadStickers(false, false);
                         }
                     }, 1000);
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/util/MessageThreadUtil.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/util/MessageThreadUtil.java
index b0b64ed73..a9d59b1fe 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/support/util/MessageThreadUtil.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/util/MessageThreadUtil.java
@@ -20,9 +20,6 @@
 import android.os.Looper;
 import android.util.Log;
 
-import org.telegram.messenger.support.util.ThreadUtil;
-import org.telegram.messenger.support.util.TileList;
-
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
 
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/RecyclerView.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/RecyclerView.java
index 3ace50994..f780729bf 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/RecyclerView.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/RecyclerView.java
@@ -58,8 +58,13 @@
 import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityManager;
 import android.view.animation.Interpolator;
+import android.widget.AbsListView;
+import android.widget.EdgeEffect;
+
+import org.telegram.messenger.FileLog;
 
 import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -312,6 +317,7 @@ public void run() {
     private int mLayoutOrScrollCounter = 0;
 
     private int topGlowOffset = 0;
+    private int glowColor = 0;
     private EdgeEffectCompat mLeftGlow, mTopGlow, mRightGlow, mBottomGlow;
 
     ItemAnimator mItemAnimator = new DefaultItemAnimator();
@@ -1852,6 +1858,7 @@ void ensureLeftGlow() {
         } else {
             mLeftGlow.setSize(getMeasuredHeight(), getMeasuredWidth());
         }
+        applyEdgeEffectColor(mLeftGlow);
     }
 
     void ensureRightGlow() {
@@ -1865,6 +1872,7 @@ void ensureRightGlow() {
         } else {
             mRightGlow.setSize(getMeasuredHeight(), getMeasuredWidth());
         }
+        applyEdgeEffectColor(mRightGlow);
     }
 
     void ensureTopGlow() {
@@ -1878,7 +1886,7 @@ void ensureTopGlow() {
         } else {
             mTopGlow.setSize(getMeasuredWidth(), getMeasuredHeight());
         }
-
+        applyEdgeEffectColor(mTopGlow);
     }
 
     void ensureBottomGlow() {
@@ -1892,6 +1900,22 @@ void ensureBottomGlow() {
         } else {
             mBottomGlow.setSize(getMeasuredWidth(), getMeasuredHeight());
         }
+        applyEdgeEffectColor(mBottomGlow);
+    }
+
+    void applyEdgeEffectColor(EdgeEffectCompat edgeEffectCompat) {
+        if (Build.VERSION.SDK_INT >= 21 && glowColor != 0) {
+            try {
+                Field field = EdgeEffectCompat.class.getDeclaredField("mEdgeEffect");
+                field.setAccessible(true);
+                EdgeEffect edgeEffect = (EdgeEffect) field.get(edgeEffectCompat);
+                if (edgeEffect != null) {
+                    edgeEffect.setColor(glowColor);
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+        }
     }
 
     void invalidateGlows() {
@@ -3141,6 +3165,10 @@ public void setTopGlowOffset(int offset) {
         topGlowOffset = offset;
     }
 
+    public void setGlowColor(int color) {
+        glowColor = color;
+    }
+
     void markItemDecorInsetsDirty() {
         final int childCount = mChildHelper.getUnfilteredChildCount();
         for (int i = 0; i < childCount; i++) {
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/helper/ItemTouchHelper.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/helper/ItemTouchHelper.java
index 4d80b8437..3aece7ccb 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/helper/ItemTouchHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/helper/ItemTouchHelper.java
@@ -1357,7 +1357,7 @@ public float getInterpolation(float t) {
         /**
          * Drag scroll speed keeps accelerating until this many milliseconds before being capped.
          */
-        private static final long DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS = 2000;
+        private static final long DRAG_SCROLL_ACCELERATION_LIMIT_TIME_MS = 500;
 
         private int mCachedMaxScrollSpeed = -1;
 
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/helper/ItemTouchUIUtilImpl.java b/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/helper/ItemTouchUIUtilImpl.java
index 21c225cf4..f0d631f5d 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/helper/ItemTouchUIUtilImpl.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/support/widget/helper/ItemTouchUIUtilImpl.java
@@ -26,18 +26,18 @@
  * public API, which is not desired in this case.
  */
 class ItemTouchUIUtilImpl {
-    final static int item_touch_helper_previous_elevation = 123;
+
     static class Lollipop extends Honeycomb {
         @Override
         public void onDraw(Canvas c, RecyclerView recyclerView, View view,
-                float dX, float dY, int actionState, boolean isCurrentlyActive) {
+                           float dX, float dY, int actionState, boolean isCurrentlyActive) {
             if (isCurrentlyActive) {
-                Object originalElevation = view.getTag(item_touch_helper_previous_elevation);
+                Object originalElevation = view.getTag();
                 if (originalElevation == null) {
                     originalElevation = ViewCompat.getElevation(view);
                     float newElevation = 1f + findMaxElevation(recyclerView, view);
                     ViewCompat.setElevation(view, newElevation);
-                    view.setTag(item_touch_helper_previous_elevation, originalElevation);
+                    view.setTag(originalElevation);
                 }
             }
             super.onDraw(c, recyclerView, view, dX, dY, actionState, isCurrentlyActive);
@@ -61,11 +61,11 @@ private float findMaxElevation(RecyclerView recyclerView, View itemView) {
 
         @Override
         public void clearView(View view) {
-            final Object tag = view.getTag(item_touch_helper_previous_elevation);
+            final Object tag = view.getTag();
             if (tag != null && tag instanceof Float) {
                 ViewCompat.setElevation(view, (Float) tag);
             }
-            view.setTag(item_touch_helper_previous_elevation, null);
+            view.setTag(null);
             super.clearView(view);
         }
     }
@@ -85,14 +85,14 @@ public void onSelected(View view) {
 
         @Override
         public void onDraw(Canvas c, RecyclerView recyclerView, View view,
-                float dX, float dY, int actionState, boolean isCurrentlyActive) {
+                           float dX, float dY, int actionState, boolean isCurrentlyActive) {
             ViewCompat.setTranslationX(view, dX);
             ViewCompat.setTranslationY(view, dY);
         }
 
         @Override
         public void onDrawOver(Canvas c, RecyclerView recyclerView,
-                View view, float dX, float dY, int actionState, boolean isCurrentlyActive) {
+                               View view, float dX, float dY, int actionState, boolean isCurrentlyActive) {
 
         }
     }
@@ -100,7 +100,7 @@ public void onDrawOver(Canvas c, RecyclerView recyclerView,
     static class Gingerbread implements ItemTouchUIUtil {
 
         private void draw(Canvas c, RecyclerView parent, View view,
-                float dX, float dY) {
+                          float dX, float dY) {
             c.save();
             c.translate(dX, dY);
             parent.drawChild(c, view, 0);
@@ -119,7 +119,7 @@ public void onSelected(View view) {
 
         @Override
         public void onDraw(Canvas c, RecyclerView recyclerView, View view,
-                float dX, float dY, int actionState, boolean isCurrentlyActive) {
+                           float dX, float dY, int actionState, boolean isCurrentlyActive) {
             if (actionState != ItemTouchHelper.ACTION_STATE_DRAG) {
                 draw(c, recyclerView, view, dX, dY);
             }
@@ -127,8 +127,8 @@ public void onDraw(Canvas c, RecyclerView recyclerView, View view,
 
         @Override
         public void onDrawOver(Canvas c, RecyclerView recyclerView,
-                View view, float dX, float dY,
-                int actionState, boolean isCurrentlyActive) {
+                               View view, float dX, float dY,
+                               int actionState, boolean isCurrentlyActive) {
             if (actionState == ItemTouchHelper.ACTION_STATE_DRAG) {
                 draw(c, recyclerView, view, dX, dY);
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/MP4Builder.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/MP4Builder.java
index c2c8bd625..eae9c50b8 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/video/MP4Builder.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/MP4Builder.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.video;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/Mp4Movie.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/Mp4Movie.java
index 7571c5c03..fcdc92232 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/video/Mp4Movie.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/Mp4Movie.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.video;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/Sample.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/Sample.java
index 566c7ef2c..ca0850bc0 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/video/Sample.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/Sample.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.video;
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/video/Track.java b/TMessagesProj/src/main/java/org/telegram/messenger/video/Track.java
index fe7c937c4..421a52a55 100644
--- a/TMessagesProj/src/main/java/org/telegram/messenger/video/Track.java
+++ b/TMessagesProj/src/main/java/org/telegram/messenger/video/Track.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.messenger.video;
@@ -109,8 +109,6 @@ public Track(int id, MediaFormat format, boolean isAudio) throws Exception {
                     avcConfigurationBox.setSequenceParameterSets(spsArray);
                     avcConfigurationBox.setPictureParameterSets(ppsArray);
                 }
-                //ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(spsBytes);
-                //SeqParameterSet seqParameterSet = SeqParameterSet.read(byteArrayInputStream);
 
                 avcConfigurationBox.setAvcLevelIndication(13);
                 avcConfigurationBox.setAvcProfileIndication(100);
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/ImageLoader.java b/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/ImageLoader.java
deleted file mode 100644
index f5225e60a..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/ImageLoader.java
+++ /dev/null
@@ -1,507 +0,0 @@
-/**
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.telegram.messenger.volley.toolbox;
-
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-import android.os.Handler;
-import android.os.Looper;
-import android.widget.ImageView;
-import android.widget.ImageView.ScaleType;
-import org.telegram.messenger.volley.Request;
-import org.telegram.messenger.volley.RequestQueue;
-import org.telegram.messenger.volley.Response.ErrorListener;
-import org.telegram.messenger.volley.Response.Listener;
-import org.telegram.messenger.volley.VolleyError;
-
-import java.util.HashMap;
-import java.util.LinkedList;
-
-/**
- * Helper that handles loading and caching images from remote URLs.
- *
- * The simple way to use this class is to call {@link ImageLoader#get(String, ImageListener)}
- * and to pass in the default image listener provided by
- * {@link ImageLoader#getImageListener(ImageView, int, int)}. Note that all function calls to
- * this class must be made from the main thead, and all responses will be delivered to the main
- * thread as well.
- */
-public class ImageLoader {
-    /** RequestQueue for dispatching ImageRequests onto. */
-    private final RequestQueue mRequestQueue;
-
-    /** Amount of time to wait after first response arrives before delivering all responses. */
-    private int mBatchResponseDelayMs = 100;
-
-    /** The cache implementation to be used as an L1 cache before calling into volley. */
-    private final ImageCache mCache;
-
-    /**
-     * HashMap of Cache keys -> BatchedImageRequest used to track in-flight requests so
-     * that we can coalesce multiple requests to the same URL into a single network request.
-     */
-    private final HashMap<String, BatchedImageRequest> mInFlightRequests =
-            new HashMap<String, BatchedImageRequest>();
-
-    /** HashMap of the currently pending responses (waiting to be delivered). */
-    private final HashMap<String, BatchedImageRequest> mBatchedResponses =
-            new HashMap<String, BatchedImageRequest>();
-
-    /** Handler to the main thread. */
-    private final Handler mHandler = new Handler(Looper.getMainLooper());
-
-    /** Runnable for in-flight response delivery. */
-    private Runnable mRunnable;
-
-    /**
-     * Simple cache adapter interface. If provided to the ImageLoader, it
-     * will be used as an L1 cache before dispatch to Volley. Implementations
-     * must not block. Implementation with an LruCache is recommended.
-     */
-    public interface ImageCache {
-        public Bitmap getBitmap(String url);
-        public void putBitmap(String url, Bitmap bitmap);
-    }
-
-    /**
-     * Constructs a new ImageLoader.
-     * @param queue The RequestQueue to use for making image requests.
-     * @param imageCache The cache to use as an L1 cache.
-     */
-    public ImageLoader(RequestQueue queue, ImageCache imageCache) {
-        mRequestQueue = queue;
-        mCache = imageCache;
-    }
-
-    /**
-     * The default implementation of ImageListener which handles basic functionality
-     * of showing a default image until the network response is received, at which point
-     * it will switch to either the actual image or the error image.
-     * @param view The imageView that the listener is associated with.
-     * @param defaultImageResId Default image resource ID to use, or 0 if it doesn't exist.
-     * @param errorImageResId Error image resource ID to use, or 0 if it doesn't exist.
-     */
-    public static ImageListener getImageListener(final ImageView view,
-            final int defaultImageResId, final int errorImageResId) {
-        return new ImageListener() {
-            @Override
-            public void onErrorResponse(VolleyError error) {
-                if (errorImageResId != 0) {
-                    view.setImageResource(errorImageResId);
-                }
-            }
-
-            @Override
-            public void onResponse(ImageContainer response, boolean isImmediate) {
-                if (response.getBitmap() != null) {
-                    view.setImageBitmap(response.getBitmap());
-                } else if (defaultImageResId != 0) {
-                    view.setImageResource(defaultImageResId);
-                }
-            }
-        };
-    }
-
-    /**
-     * Interface for the response handlers on image requests.
-     *
-     * The call flow is this:
-     * 1. Upon being  attached to a request, onResponse(response, true) will
-     * be invoked to reflect any cached data that was already available. If the
-     * data was available, response.getBitmap() will be non-null.
-     *
-     * 2. After a network response returns, only one of the following cases will happen:
-     *   - onResponse(response, false) will be called if the image was loaded.
-     *   or
-     *   - onErrorResponse will be called if there was an error loading the image.
-     */
-    public interface ImageListener extends ErrorListener {
-        /**
-         * Listens for non-error changes to the loading of the image request.
-         *
-         * @param response Holds all information pertaining to the request, as well
-         * as the bitmap (if it is loaded).
-         * @param isImmediate True if this was called during ImageLoader.get() variants.
-         * This can be used to differentiate between a cached image loading and a network
-         * image loading in order to, for example, run an animation to fade in network loaded
-         * images.
-         */
-        public void onResponse(ImageContainer response, boolean isImmediate);
-    }
-
-    /**
-     * Checks if the item is available in the cache.
-     * @param requestUrl The url of the remote image
-     * @param maxWidth The maximum width of the returned image.
-     * @param maxHeight The maximum height of the returned image.
-     * @return True if the item exists in cache, false otherwise.
-     */
-    public boolean isCached(String requestUrl, int maxWidth, int maxHeight) {
-        return isCached(requestUrl, maxWidth, maxHeight, ScaleType.CENTER_INSIDE);
-    }
-
-    /**
-     * Checks if the item is available in the cache.
-     *
-     * @param requestUrl The url of the remote image
-     * @param maxWidth   The maximum width of the returned image.
-     * @param maxHeight  The maximum height of the returned image.
-     * @param scaleType  The scaleType of the imageView.
-     * @return True if the item exists in cache, false otherwise.
-     */
-    public boolean isCached(String requestUrl, int maxWidth, int maxHeight, ScaleType scaleType) {
-        throwIfNotOnMainThread();
-
-        String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);
-        return mCache.getBitmap(cacheKey) != null;
-    }
-
-    /**
-     * Returns an ImageContainer for the requested URL.
-     *
-     * The ImageContainer will contain either the specified default bitmap or the loaded bitmap.
-     * If the default was returned, the {@link ImageLoader} will be invoked when the
-     * request is fulfilled.
-     *
-     * @param requestUrl The URL of the image to be loaded.
-     */
-    public ImageContainer get(String requestUrl, final ImageListener listener) {
-        return get(requestUrl, listener, 0, 0);
-    }
-
-    /**
-     * Equivalent to calling {@link #get(String, ImageListener, int, int, ScaleType)} with
-     * {@code Scaletype == ScaleType.CENTER_INSIDE}.
-     */
-    public ImageContainer get(String requestUrl, ImageListener imageListener,
-            int maxWidth, int maxHeight) {
-        return get(requestUrl, imageListener, maxWidth, maxHeight, ScaleType.CENTER_INSIDE);
-    }
-
-    /**
-     * Issues a bitmap request with the given URL if that image is not available
-     * in the cache, and returns a bitmap container that contains all of the data
-     * relating to the request (as well as the default image if the requested
-     * image is not available).
-     * @param requestUrl The url of the remote image
-     * @param imageListener The listener to call when the remote image is loaded
-     * @param maxWidth The maximum width of the returned image.
-     * @param maxHeight The maximum height of the returned image.
-     * @param scaleType The ImageViews ScaleType used to calculate the needed image size.
-     * @return A container object that contains all of the properties of the request, as well as
-     *     the currently available image (default if remote is not loaded).
-     */
-    public ImageContainer get(String requestUrl, ImageListener imageListener,
-            int maxWidth, int maxHeight, ScaleType scaleType) {
-
-        // only fulfill requests that were initiated from the main thread.
-        throwIfNotOnMainThread();
-
-        final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);
-
-        // Try to look up the request in the cache of remote images.
-        Bitmap cachedBitmap = mCache.getBitmap(cacheKey);
-        if (cachedBitmap != null) {
-            // Return the cached bitmap.
-            ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null);
-            imageListener.onResponse(container, true);
-            return container;
-        }
-
-        // The bitmap did not exist in the cache, fetch it!
-        ImageContainer imageContainer =
-                new ImageContainer(null, requestUrl, cacheKey, imageListener);
-
-        // Update the caller to let them know that they should use the default bitmap.
-        imageListener.onResponse(imageContainer, true);
-
-        // Check to see if a request is already in-flight.
-        BatchedImageRequest request = mInFlightRequests.get(cacheKey);
-        if (request != null) {
-            // If it is, add this request to the list of listeners.
-            request.addContainer(imageContainer);
-            return imageContainer;
-        }
-
-        // The request is not already in flight. Send the new request to the network and
-        // track it.
-        Request<Bitmap> newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,
-                cacheKey);
-
-        mRequestQueue.add(newRequest);
-        mInFlightRequests.put(cacheKey,
-                new BatchedImageRequest(newRequest, imageContainer));
-        return imageContainer;
-    }
-
-    protected Request<Bitmap> makeImageRequest(String requestUrl, int maxWidth, int maxHeight,
-            ScaleType scaleType, final String cacheKey) {
-        return new ImageRequest(requestUrl, new Listener<Bitmap>() {
-            @Override
-            public void onResponse(Bitmap response) {
-                onGetImageSuccess(cacheKey, response);
-            }
-        }, maxWidth, maxHeight, scaleType, Config.RGB_565, new ErrorListener() {
-            @Override
-            public void onErrorResponse(VolleyError error) {
-                onGetImageError(cacheKey, error);
-            }
-        });
-    }
-
-    /**
-     * Sets the amount of time to wait after the first response arrives before delivering all
-     * responses. Batching can be disabled entirely by passing in 0.
-     * @param newBatchedResponseDelayMs The time in milliseconds to wait.
-     */
-    public void setBatchedResponseDelay(int newBatchedResponseDelayMs) {
-        mBatchResponseDelayMs = newBatchedResponseDelayMs;
-    }
-
-    /**
-     * Handler for when an image was successfully loaded.
-     * @param cacheKey The cache key that is associated with the image request.
-     * @param response The bitmap that was returned from the network.
-     */
-    protected void onGetImageSuccess(String cacheKey, Bitmap response) {
-        // cache the image that was fetched.
-        mCache.putBitmap(cacheKey, response);
-
-        // remove the request from the list of in-flight requests.
-        BatchedImageRequest request = mInFlightRequests.remove(cacheKey);
-
-        if (request != null) {
-            // Update the response bitmap.
-            request.mResponseBitmap = response;
-
-            // Send the batched response
-            batchResponse(cacheKey, request);
-        }
-    }
-
-    /**
-     * Handler for when an image failed to load.
-     * @param cacheKey The cache key that is associated with the image request.
-     */
-    protected void onGetImageError(String cacheKey, VolleyError error) {
-        // Notify the requesters that something failed via a null result.
-        // Remove this request from the list of in-flight requests.
-        BatchedImageRequest request = mInFlightRequests.remove(cacheKey);
-
-        if (request != null) {
-            // Set the error for this request
-            request.setError(error);
-
-            // Send the batched response
-            batchResponse(cacheKey, request);
-        }
-    }
-
-    /**
-     * Container object for all of the data surrounding an image request.
-     */
-    public class ImageContainer {
-        /**
-         * The most relevant bitmap for the container. If the image was in cache, the
-         * Holder to use for the final bitmap (the one that pairs to the requested URL).
-         */
-        private Bitmap mBitmap;
-
-        private final ImageListener mListener;
-
-        /** The cache key that was associated with the request */
-        private final String mCacheKey;
-
-        /** The request URL that was specified */
-        private final String mRequestUrl;
-
-        /**
-         * Constructs a BitmapContainer object.
-         * @param bitmap The final bitmap (if it exists).
-         * @param requestUrl The requested URL for this container.
-         * @param cacheKey The cache key that identifies the requested URL for this container.
-         */
-        public ImageContainer(Bitmap bitmap, String requestUrl,
-                String cacheKey, ImageListener listener) {
-            mBitmap = bitmap;
-            mRequestUrl = requestUrl;
-            mCacheKey = cacheKey;
-            mListener = listener;
-        }
-
-        /**
-         * Releases interest in the in-flight request (and cancels it if no one else is listening).
-         */
-        public void cancelRequest() {
-            if (mListener == null) {
-                return;
-            }
-
-            BatchedImageRequest request = mInFlightRequests.get(mCacheKey);
-            if (request != null) {
-                boolean canceled = request.removeContainerAndCancelIfNecessary(this);
-                if (canceled) {
-                    mInFlightRequests.remove(mCacheKey);
-                }
-            } else {
-                // check to see if it is already batched for delivery.
-                request = mBatchedResponses.get(mCacheKey);
-                if (request != null) {
-                    request.removeContainerAndCancelIfNecessary(this);
-                    if (request.mContainers.size() == 0) {
-                        mBatchedResponses.remove(mCacheKey);
-                    }
-                }
-            }
-        }
-
-        /**
-         * Returns the bitmap associated with the request URL if it has been loaded, null otherwise.
-         */
-        public Bitmap getBitmap() {
-            return mBitmap;
-        }
-
-        /**
-         * Returns the requested URL for this container.
-         */
-        public String getRequestUrl() {
-            return mRequestUrl;
-        }
-    }
-
-    /**
-     * Wrapper class used to map a Request to the set of active ImageContainer objects that are
-     * interested in its results.
-     */
-    private class BatchedImageRequest {
-        /** The request being tracked */
-        private final Request<?> mRequest;
-
-        /** The result of the request being tracked by this item */
-        private Bitmap mResponseBitmap;
-
-        /** Error if one occurred for this response */
-        private VolleyError mError;
-
-        /** List of all of the active ImageContainers that are interested in the request */
-        private final LinkedList<ImageContainer> mContainers = new LinkedList<ImageContainer>();
-
-        /**
-         * Constructs a new BatchedImageRequest object
-         * @param request The request being tracked
-         * @param container The ImageContainer of the person who initiated the request.
-         */
-        public BatchedImageRequest(Request<?> request, ImageContainer container) {
-            mRequest = request;
-            mContainers.add(container);
-        }
-
-        /**
-         * Set the error for this response
-         */
-        public void setError(VolleyError error) {
-            mError = error;
-        }
-
-        /**
-         * Get the error for this response
-         */
-        public VolleyError getError() {
-            return mError;
-        }
-
-        /**
-         * Adds another ImageContainer to the list of those interested in the results of
-         * the request.
-         */
-        public void addContainer(ImageContainer container) {
-            mContainers.add(container);
-        }
-
-        /**
-         * Detatches the bitmap container from the request and cancels the request if no one is
-         * left listening.
-         * @param container The container to remove from the list
-         * @return True if the request was canceled, false otherwise.
-         */
-        public boolean removeContainerAndCancelIfNecessary(ImageContainer container) {
-            mContainers.remove(container);
-            if (mContainers.size() == 0) {
-                mRequest.cancel();
-                return true;
-            }
-            return false;
-        }
-    }
-
-    /**
-     * Starts the runnable for batched delivery of responses if it is not already started.
-     * @param cacheKey The cacheKey of the response being delivered.
-     * @param request The BatchedImageRequest to be delivered.
-     */
-    private void batchResponse(String cacheKey, BatchedImageRequest request) {
-        mBatchedResponses.put(cacheKey, request);
-        // If we don't already have a batch delivery runnable in flight, make a new one.
-        // Note that this will be used to deliver responses to all callers in mBatchedResponses.
-        if (mRunnable == null) {
-            mRunnable = new Runnable() {
-                @Override
-                public void run() {
-                    for (BatchedImageRequest bir : mBatchedResponses.values()) {
-                        for (ImageContainer container : bir.mContainers) {
-                            // If one of the callers in the batched request canceled the request
-                            // after the response was received but before it was delivered,
-                            // skip them.
-                            if (container.mListener == null) {
-                                continue;
-                            }
-                            if (bir.getError() == null) {
-                                container.mBitmap = bir.mResponseBitmap;
-                                container.mListener.onResponse(container, false);
-                            } else {
-                                container.mListener.onErrorResponse(bir.getError());
-                            }
-                        }
-                    }
-                    mBatchedResponses.clear();
-                    mRunnable = null;
-                }
-
-            };
-            // Post the runnable.
-            mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);
-        }
-    }
-
-    private void throwIfNotOnMainThread() {
-        if (Looper.myLooper() != Looper.getMainLooper()) {
-            throw new IllegalStateException("ImageLoader must be invoked from the main thread.");
-        }
-    }
-    /**
-     * Creates a cache key for use with the L1 cache.
-     * @param url The URL of the request.
-     * @param maxWidth The max-width of the output.
-     * @param maxHeight The max-height of the output.
-     * @param scaleType The scaleType of the imageView.
-     */
-    private static String getCacheKey(String url, int maxWidth, int maxHeight, ScaleType scaleType) {
-        return new StringBuilder(url.length() + 12).append("#W").append(maxWidth)
-                .append("#H").append(maxHeight).append("#S").append(scaleType.ordinal()).append(url)
-                .toString();
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/ImageRequest.java b/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/ImageRequest.java
deleted file mode 100644
index 2b3ae2cd9..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/ImageRequest.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.telegram.messenger.volley.toolbox;
-
-import org.telegram.messenger.volley.DefaultRetryPolicy;
-import org.telegram.messenger.volley.NetworkResponse;
-import org.telegram.messenger.volley.ParseError;
-import org.telegram.messenger.volley.Request;
-import org.telegram.messenger.volley.Response;
-import org.telegram.messenger.volley.VolleyLog;
-
-import android.graphics.Bitmap;
-import android.graphics.Bitmap.Config;
-import android.graphics.BitmapFactory;
-import android.widget.ImageView.ScaleType;
-
-/**
- * A canned request for getting an image at a given URL and calling
- * back with a decoded Bitmap.
- */
-public class ImageRequest extends Request<Bitmap> {
-    /** Socket timeout in milliseconds for image requests */
-    private static final int IMAGE_TIMEOUT_MS = 1000;
-
-    /** Default number of retries for image requests */
-    private static final int IMAGE_MAX_RETRIES = 2;
-
-    /** Default backoff multiplier for image requests */
-    private static final float IMAGE_BACKOFF_MULT = 2f;
-
-    private final Response.Listener<Bitmap> mListener;
-    private final Config mDecodeConfig;
-    private final int mMaxWidth;
-    private final int mMaxHeight;
-    private ScaleType mScaleType;
-
-    /** Decoding lock so that we don't decode more than one image at a time (to avoid OOM's) */
-    private static final Object sDecodeLock = new Object();
-
-    /**
-     * Creates a new image request, decoding to a maximum specified width and
-     * height. If both width and height are zero, the image will be decoded to
-     * its natural size. If one of the two is nonzero, that dimension will be
-     * clamped and the other one will be set to preserve the image's aspect
-     * ratio. If both width and height are nonzero, the image will be decoded to
-     * be fit in the rectangle of dimensions width x height while keeping its
-     * aspect ratio.
-     *
-     * @param url URL of the image
-     * @param listener Listener to receive the decoded bitmap
-     * @param maxWidth Maximum width to decode this bitmap to, or zero for none
-     * @param maxHeight Maximum height to decode this bitmap to, or zero for
-     *            none
-     * @param scaleType The ImageViews ScaleType used to calculate the needed image size.
-     * @param decodeConfig Format to decode the bitmap to
-     * @param errorListener Error listener, or null to ignore errors
-     */
-    public ImageRequest(String url, Response.Listener<Bitmap> listener, int maxWidth, int maxHeight,
-            ScaleType scaleType, Config decodeConfig, Response.ErrorListener errorListener) {
-        super(Method.GET, url, errorListener); 
-        setRetryPolicy(
-                new DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES, IMAGE_BACKOFF_MULT));
-        mListener = listener;
-        mDecodeConfig = decodeConfig;
-        mMaxWidth = maxWidth;
-        mMaxHeight = maxHeight;
-        mScaleType = scaleType;
-    }
-
-    /**
-     * For API compatibility with the pre-ScaleType variant of the constructor. Equivalent to
-     * the normal constructor with {@code ScaleType.CENTER_INSIDE}.
-     */
-    @Deprecated
-    public ImageRequest(String url, Response.Listener<Bitmap> listener, int maxWidth, int maxHeight,
-            Config decodeConfig, Response.ErrorListener errorListener) {
-        this(url, listener, maxWidth, maxHeight,
-                ScaleType.CENTER_INSIDE, decodeConfig, errorListener);
-    }
-    @Override
-    public Priority getPriority() {
-        return Priority.LOW;
-    }
-
-    /**
-     * Scales one side of a rectangle to fit aspect ratio.
-     *
-     * @param maxPrimary Maximum size of the primary dimension (i.e. width for
-     *        max width), or zero to maintain aspect ratio with secondary
-     *        dimension
-     * @param maxSecondary Maximum size of the secondary dimension, or zero to
-     *        maintain aspect ratio with primary dimension
-     * @param actualPrimary Actual size of the primary dimension
-     * @param actualSecondary Actual size of the secondary dimension
-     * @param scaleType The ScaleType used to calculate the needed image size.
-     */
-    private static int getResizedDimension(int maxPrimary, int maxSecondary, int actualPrimary,
-            int actualSecondary, ScaleType scaleType) {
-
-        // If no dominant value at all, just return the actual.
-        if ((maxPrimary == 0) && (maxSecondary == 0)) {
-            return actualPrimary;
-        }
-
-        // If ScaleType.FIT_XY fill the whole rectangle, ignore ratio.
-        if (scaleType == ScaleType.FIT_XY) {
-            if (maxPrimary == 0) {
-                return actualPrimary;
-            }
-            return maxPrimary;
-        }
-
-        // If primary is unspecified, scale primary to match secondary's scaling ratio.
-        if (maxPrimary == 0) {
-            double ratio = (double) maxSecondary / (double) actualSecondary;
-            return (int) (actualPrimary * ratio);
-        }
-
-        if (maxSecondary == 0) {
-            return maxPrimary;
-        }
-
-        double ratio = (double) actualSecondary / (double) actualPrimary;
-        int resized = maxPrimary;
-
-        // If ScaleType.CENTER_CROP fill the whole rectangle, preserve aspect ratio.
-        if (scaleType == ScaleType.CENTER_CROP) {
-            if ((resized * ratio) < maxSecondary) {
-                resized = (int) (maxSecondary / ratio);
-            }
-            return resized;
-        }
-
-        if ((resized * ratio) > maxSecondary) {
-            resized = (int) (maxSecondary / ratio);
-        }
-        return resized;
-    }
-
-    @Override
-    protected Response<Bitmap> parseNetworkResponse(NetworkResponse response) {
-        // Serialize all decode on a global lock to reduce concurrent heap usage.
-        synchronized (sDecodeLock) {
-            try {
-                return doParse(response);
-            } catch (OutOfMemoryError e) {
-                VolleyLog.e("Caught OOM for %d byte image, url=%s", response.data.length, getUrl());
-                return Response.error(new ParseError(e));
-            }
-        }
-    }
-
-    /**
-     * The real guts of parseNetworkResponse. Broken out for readability.
-     */
-    private Response<Bitmap> doParse(NetworkResponse response) {
-        byte[] data = response.data;
-        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();
-        Bitmap bitmap = null;
-        if (mMaxWidth == 0 && mMaxHeight == 0) {
-            decodeOptions.inPreferredConfig = mDecodeConfig;
-            bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);
-        } else {
-            // If we have to resize this image, first get the natural bounds.
-            decodeOptions.inJustDecodeBounds = true;
-            BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);
-            int actualWidth = decodeOptions.outWidth;
-            int actualHeight = decodeOptions.outHeight;
-
-            // Then compute the dimensions we would ideally like to decode to.
-            int desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight,
-                    actualWidth, actualHeight, mScaleType);
-            int desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth,
-                    actualHeight, actualWidth, mScaleType);
-
-            // Decode to the nearest power of two scaling factor.
-            decodeOptions.inJustDecodeBounds = false;
-            // TODO(ficus): Do we need this or is it okay since API 8 doesn't support it?
-            // decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED;
-            decodeOptions.inSampleSize =
-                findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);
-            Bitmap tempBitmap =
-                BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);
-
-            // If necessary, scale down to the maximal acceptable size.
-            if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth ||
-                    tempBitmap.getHeight() > desiredHeight)) {
-                bitmap = Bitmap.createScaledBitmap(tempBitmap,
-                        desiredWidth, desiredHeight, true);
-                tempBitmap.recycle();
-            } else {
-                bitmap = tempBitmap;
-            }
-        }
-
-        if (bitmap == null) {
-            return Response.error(new ParseError(response));
-        } else {
-            return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));
-        }
-    }
-
-    @Override
-    protected void deliverResponse(Bitmap response) {
-        mListener.onResponse(response);
-    }
-
-    /**
-     * Returns the largest power-of-two divisor for use in downscaling a bitmap
-     * that will not result in the scaling past the desired dimensions.
-     *
-     * @param actualWidth Actual width of the bitmap
-     * @param actualHeight Actual height of the bitmap
-     * @param desiredWidth Desired width of the bitmap
-     * @param desiredHeight Desired height of the bitmap
-     */
-    // Visible for testing.
-    static int findBestSampleSize(
-            int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) {
-        double wr = (double) actualWidth / desiredWidth;
-        double hr = (double) actualHeight / desiredHeight;
-        double ratio = Math.min(wr, hr);
-        float n = 1.0f;
-        while ((n * 2) <= ratio) {
-            n *= 2;
-        }
-
-        return (int) n;
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/NetworkImageView.java b/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/NetworkImageView.java
deleted file mode 100644
index 465596a4c..000000000
--- a/TMessagesProj/src/main/java/org/telegram/messenger/volley/toolbox/NetworkImageView.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/**
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.telegram.messenger.volley.toolbox;
-
-import android.content.Context;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import android.view.ViewGroup.LayoutParams;
-import android.widget.ImageView;
-
-import org.telegram.messenger.volley.VolleyError;
-import org.telegram.messenger.volley.toolbox.ImageLoader.ImageContainer;
-import org.telegram.messenger.volley.toolbox.ImageLoader.ImageListener;
-
-/**
- * Handles fetching an image from a URL as well as the life-cycle of the
- * associated request.
- */
-public class NetworkImageView extends ImageView {
-    /** The URL of the network image to load */
-    private String mUrl;
-
-    /**
-     * Resource ID of the image to be used as a placeholder until the network image is loaded.
-     */
-    private int mDefaultImageId;
-
-    /**
-     * Resource ID of the image to be used if the network response fails.
-     */
-    private int mErrorImageId;
-
-    /** Local copy of the ImageLoader. */
-    private ImageLoader mImageLoader;
-
-    /** Current ImageContainer. (either in-flight or finished) */
-    private ImageContainer mImageContainer;
-
-    public NetworkImageView(Context context) {
-        this(context, null);
-    }
-
-    public NetworkImageView(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-    }
-
-    public NetworkImageView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-    }
-
-    /**
-     * Sets URL of the image that should be loaded into this view. Note that calling this will
-     * immediately either set the cached image (if available) or the default image specified by
-     * {@link NetworkImageView#setDefaultImageResId(int)} on the view.
-     *
-     * NOTE: If applicable, {@link NetworkImageView#setDefaultImageResId(int)} and
-     * {@link NetworkImageView#setErrorImageResId(int)} should be called prior to calling
-     * this function.
-     *
-     * @param url The URL that should be loaded into this ImageView.
-     * @param imageLoader ImageLoader that will be used to make the request.
-     */
-    public void setImageUrl(String url, ImageLoader imageLoader) {
-        mUrl = url;
-        mImageLoader = imageLoader;
-        // The URL has potentially changed. See if we need to load it.
-        loadImageIfNecessary(false);
-    }
-
-    /**
-     * Sets the default image resource ID to be used for this view until the attempt to load it
-     * completes.
-     */
-    public void setDefaultImageResId(int defaultImage) {
-        mDefaultImageId = defaultImage;
-    }
-
-    /**
-     * Sets the error image resource ID to be used for this view in the event that the image
-     * requested fails to load.
-     */
-    public void setErrorImageResId(int errorImage) {
-        mErrorImageId = errorImage;
-    }
-
-    /**
-     * Loads the image for the view if it isn't already loaded.
-     * @param isInLayoutPass True if this was invoked from a layout pass, false otherwise.
-     */
-    void loadImageIfNecessary(final boolean isInLayoutPass) {
-        int width = getWidth();
-        int height = getHeight();
-        ScaleType scaleType = getScaleType();
-
-        boolean wrapWidth = false, wrapHeight = false;
-        if (getLayoutParams() != null) {
-            wrapWidth = getLayoutParams().width == LayoutParams.WRAP_CONTENT;
-            wrapHeight = getLayoutParams().height == LayoutParams.WRAP_CONTENT;
-        }
-
-        // if the view's bounds aren't known yet, and this is not a wrap-content/wrap-content
-        // view, hold off on loading the image.
-        boolean isFullyWrapContent = wrapWidth && wrapHeight;
-        if (width == 0 && height == 0 && !isFullyWrapContent) {
-            return;
-        }
-
-        // if the URL to be loaded in this view is empty, cancel any old requests and clear the
-        // currently loaded image.
-        if (TextUtils.isEmpty(mUrl)) {
-            if (mImageContainer != null) {
-                mImageContainer.cancelRequest();
-                mImageContainer = null;
-            }
-            setDefaultImageOrNull();
-            return;
-        }
-
-        // if there was an old request in this view, check if it needs to be canceled.
-        if (mImageContainer != null && mImageContainer.getRequestUrl() != null) {
-            if (mImageContainer.getRequestUrl().equals(mUrl)) {
-                // if the request is from the same URL, return.
-                return;
-            } else {
-                // if there is a pre-existing request, cancel it if it's fetching a different URL.
-                mImageContainer.cancelRequest();
-                setDefaultImageOrNull();
-            }
-        }
-
-        // Calculate the max image width / height to use while ignoring WRAP_CONTENT dimens.
-        int maxWidth = wrapWidth ? 0 : width;
-        int maxHeight = wrapHeight ? 0 : height;
-
-        // The pre-existing content of this view didn't match the current URL. Load the new image
-        // from the network.
-        ImageContainer newContainer = mImageLoader.get(mUrl,
-                new ImageListener() {
-                    @Override
-                    public void onErrorResponse(VolleyError error) {
-                        if (mErrorImageId != 0) {
-                            setImageResource(mErrorImageId);
-                        }
-                    }
-
-                    @Override
-                    public void onResponse(final ImageContainer response, boolean isImmediate) {
-                        // If this was an immediate response that was delivered inside of a layout
-                        // pass do not set the image immediately as it will trigger a requestLayout
-                        // inside of a layout. Instead, defer setting the image by posting back to
-                        // the main thread.
-                        if (isImmediate && isInLayoutPass) {
-                            post(new Runnable() {
-                                @Override
-                                public void run() {
-                                    onResponse(response, false);
-                                }
-                            });
-                            return;
-                        }
-
-                        if (response.getBitmap() != null) {
-                            setImageBitmap(response.getBitmap());
-                        } else if (mDefaultImageId != 0) {
-                            setImageResource(mDefaultImageId);
-                        }
-                    }
-                }, maxWidth, maxHeight, scaleType);
-
-        // update the ImageContainer to be the new bitmap container.
-        mImageContainer = newContainer;
-    }
-
-    private void setDefaultImageOrNull() {
-        if(mDefaultImageId != 0) {
-            setImageResource(mDefaultImageId);
-        }
-        else {
-            setImageBitmap(null);
-        }
-    }
-
-    @Override
-    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        super.onLayout(changed, left, top, right, bottom);
-        loadImageIfNecessary(true);
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        if (mImageContainer != null) {
-            // If the view was bound to an image request, cancel it and clear
-            // out the image from the view.
-            mImageContainer.cancelRequest();
-            setImageBitmap(null);
-            // also clear out the container so we can reload the image if necessary.
-            mImageContainer = null;
-        }
-        super.onDetachedFromWindow();
-    }
-
-    @Override
-    protected void drawableStateChanged() {
-        super.drawableStateChanged();
-        invalidate();
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/tgnet/ConnectionsManager.java b/TMessagesProj/src/main/java/org/telegram/tgnet/ConnectionsManager.java
index f3c6fb82f..79a94952d 100644
--- a/TMessagesProj/src/main/java/org/telegram/tgnet/ConnectionsManager.java
+++ b/TMessagesProj/src/main/java/org/telegram/tgnet/ConnectionsManager.java
@@ -27,6 +27,7 @@
 import java.net.NetworkInterface;
 import java.util.Enumeration;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
 
 public class ConnectionsManager {
 
@@ -57,7 +58,7 @@
     private int lastClassGuid = 1;
     private boolean isUpdating = false;
     private int connectionState = native_getConnectionState();
-    private volatile int lastRequestToken = 1;
+    private AtomicInteger lastRequestToken = new AtomicInteger(1);
     private PowerManager.WakeLock wakeLock = null;
 
     private static volatile ConnectionsManager Instance = null;
@@ -114,11 +115,11 @@ public int sendRequest(TLObject object, RequestDelegate completionBlock, QuickAc
     }
 
     public int sendRequest(final TLObject object, final RequestDelegate onComplete, final QuickAckDelegate onQuickAck, final int flags, final int datacenterId, final int connetionType, final boolean immediate) {
-        final int requestToken = lastRequestToken++;
+        final int requestToken = lastRequestToken.getAndIncrement();
         Utilities.stageQueue.postRunnable(new Runnable() {
             @Override
             public void run() {
-                FileLog.d("tmessages", "send request " + object);
+                FileLog.d("tmessages", "send request " + object + " with token = " + requestToken);
                 NativeByteBuffer buffer = new NativeByteBuffer(object.getObjectSize());
                 object.serializeToStream(buffer);
                 object.freeResources();
@@ -196,8 +197,8 @@ private void checkConnection() {
         native_setNetworkAvailable(isNetworkOnline());
     }
 
-    public void init(int version, int layer, int apiId, String deviceModel, String systemVersion, String appVersion, String langCode, String configPath, int userId) {
-        native_init(version, layer, apiId, deviceModel, systemVersion, appVersion, langCode, configPath, userId);
+    public void init(int version, int layer, int apiId, String deviceModel, String systemVersion, String appVersion, String langCode, String configPath, String logPath, int userId) {
+        native_init(version, layer, apiId, deviceModel, systemVersion, appVersion, langCode, configPath, logPath, userId);
         checkConnection();
         BroadcastReceiver networkStateReceiver = new BroadcastReceiver() {
             @Override
@@ -363,7 +364,7 @@ public void run() {
     public static native void native_applyDatacenterAddress(int datacenterId, String ipAddress, int port);
     public static native int native_getConnectionState();
     public static native void native_setUserId(int id);
-    public static native void native_init(int version, int layer, int apiId, String deviceModel, String systemVersion, String appVersion, String langCode, String configPath, int userId);
+    public static native void native_init(int version, int layer, int apiId, String deviceModel, String systemVersion, String appVersion, String langCode, String configPath, String logPath, int userId);
     public static native void native_setJava(boolean useJavaByteBuffers);
 
     public int generateClassGuid() {
diff --git a/TMessagesProj/src/main/java/org/telegram/tgnet/SerializedData.java b/TMessagesProj/src/main/java/org/telegram/tgnet/SerializedData.java
index ceb89e13d..17c205e75 100644
--- a/TMessagesProj/src/main/java/org/telegram/tgnet/SerializedData.java
+++ b/TMessagesProj/src/main/java/org/telegram/tgnet/SerializedData.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/tgnet/TLClassStore.java b/TMessagesProj/src/main/java/org/telegram/tgnet/TLClassStore.java
index 17d515539..fe562afda 100644
--- a/TMessagesProj/src/main/java/org/telegram/tgnet/TLClassStore.java
+++ b/TMessagesProj/src/main/java/org/telegram/tgnet/TLClassStore.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/tgnet/TLObject.java b/TMessagesProj/src/main/java/org/telegram/tgnet/TLObject.java
index d7cb63b07..f320783be 100644
--- a/TMessagesProj/src/main/java/org/telegram/tgnet/TLObject.java
+++ b/TMessagesProj/src/main/java/org/telegram/tgnet/TLObject.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/tgnet/TLRPC.java b/TMessagesProj/src/main/java/org/telegram/tgnet/TLRPC.java
index b77764e81..43e27e932 100644
--- a/TMessagesProj/src/main/java/org/telegram/tgnet/TLRPC.java
+++ b/TMessagesProj/src/main/java/org/telegram/tgnet/TLRPC.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -23,36 +23,38 @@
     public static final int USER_FLAG_UNUSED                = 0x00000080;
     public static final int USER_FLAG_UNUSED2               = 0x00000100;
     public static final int USER_FLAG_UNUSED3               = 0x00000200;
-    public static final int USER_FLAG_SELF                  = 0x00000400;
-    public static final int USER_FLAG_CONTACT               = 0x00000800;
-    public static final int USER_FLAG_MUTUAL_CONTACT        = 0x00001000;
-    public static final int USER_FLAG_DELETED               = 0x00002000;
-    public static final int USER_FLAG_BOT                   = 0x00004000;
-    public static final int USER_FLAG_BOT_READING_HISTORY   = 0x00008000;
-    public static final int USER_FLAG_BOT_CANT_JOIN_GROUP   = 0x00010000;
-
-    public static final int CHAT_FLAG_ADMIN                 = 0x00000001;
-    public static final int CHAT_FLAG_USER_KICKED           = 0x00000002;
-    public static final int CHAT_FLAG_USER_LEFT             = 0x00000004;
-    public static final int CHAT_FLAG_USER_IS_EDITOR        = 0x00000008;
-    public static final int CHAT_FLAG_USER_IS_MODERATOR     = 0x00000010;
-    public static final int CHAT_FLAG_IS_BROADCAST          = 0x00000020;
+    //public static final int USER_FLAG_SELF                  = 0x00000400;
+    //public static final int USER_FLAG_CONTACT               = 0x00000800;
+    //public static final int USER_FLAG_MUTUAL_CONTACT        = 0x00001000;
+    //public static final int USER_FLAG_DELETED               = 0x00002000;
+    //public static final int USER_FLAG_BOT                   = 0x00004000;
+    //public static final int USER_FLAG_BOT_READING_HISTORY   = 0x00008000;
+    //public static final int USER_FLAG_BOT_CANT_JOIN_GROUP   = 0x00010000;
+	//public static final int USER_FLAG_VERIFIED   			  = 0x00020000;
+
+    //public static final int CHAT_FLAG_CREATOR               = 0x00000001;
+    //public static final int CHAT_FLAG_USER_KICKED           = 0x00000002;
+    //public static final int CHAT_FLAG_USER_LEFT             = 0x00000004;
+    //public static final int CHAT_FLAG_USER_IS_EDITOR        = 0x00000008;
+    //public static final int CHAT_FLAG_USER_IS_MODERATOR     = 0x00000010;
+    //public static final int CHAT_FLAG_IS_BROADCAST          = 0x00000020;
     public static final int CHAT_FLAG_IS_PUBLIC             = 0x00000040;
-    public static final int CHAT_FLAG_IS_VERIFIED           = 0x00000080;
+    //public static final int CHAT_FLAG_IS_VERIFIED           = 0x00000080;
 
-    public static final int MESSAGE_FLAG_UNREAD             = 0x00000001;
-    public static final int MESSAGE_FLAG_OUT                = 0x00000002;
+    //public static final int MESSAGE_FLAG_UNREAD             = 0x00000001;
+    //public static final int MESSAGE_FLAG_OUT                = 0x00000002;
     public static final int MESSAGE_FLAG_FWD                = 0x00000004;
     public static final int MESSAGE_FLAG_REPLY              = 0x00000008;
-    public static final int MESSAGE_FLAG_MENTION            = 0x00000010;
-    public static final int MESSAGE_FLAG_CONTENT_UNREAD     = 0x00000020;
+    //public static final int MESSAGE_FLAG_MENTION            = 0x00000010;
+    //public static final int MESSAGE_FLAG_CONTENT_UNREAD     = 0x00000020;
     public static final int MESSAGE_FLAG_HAS_MARKUP         = 0x00000040;
     public static final int MESSAGE_FLAG_HAS_ENTITIES       = 0x00000080;
     public static final int MESSAGE_FLAG_HAS_FROM_ID        = 0x00000100;
     public static final int MESSAGE_FLAG_HAS_MEDIA          = 0x00000200;
     public static final int MESSAGE_FLAG_HAS_VIEWS          = 0x00000400;
+	public static final int MESSAGE_FLAG_MEGAGROUP          = 0x80000000;
 
-    public static final int LAYER = 38;
+    public static final int LAYER = 43;
 
     public static class ChatPhoto extends TLObject {
 		public FileLocation photo_small;
@@ -103,6 +105,34 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
+	public static class TL_help_termsOfService extends TLObject {
+		public static int constructor = 0xf1ee3e90;
+
+		public String text;
+
+		public static TL_help_termsOfService TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			if (TL_help_termsOfService.constructor != constructor) {
+				if (exception) {
+					throw new RuntimeException(String.format("can't parse magic %x in TL_help_termsOfService", constructor));
+				} else {
+					return null;
+				}
+			}
+			TL_help_termsOfService result = new TL_help_termsOfService();
+			result.readParams(stream, exception);
+			return result;
+		}
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			text = stream.readString(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeString(text);
+		}
+	}
+
 	public static class NotifyPeer extends TLObject {
 		public Peer peer;
 
@@ -1700,6 +1730,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 	public static class ChatInvite extends TLObject {
 		public int flags;
+		public boolean channel;
+		public boolean broadcast;
+		public boolean isPublic;
+		public boolean megagroup;
 		public String title;
 		public Chat chat;
 
@@ -1729,11 +1763,19 @@ public static ChatInvite TLdeserialize(AbstractSerializedData stream, int constr
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			channel = (flags & 1) != 0;
+			broadcast = (flags & 2) != 0;
+			isPublic = (flags & 4) != 0;
+			megagroup = (flags & 8) != 0;
 			title = stream.readString(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = channel ? (flags | 1) : (flags &~ 1);
+			flags = broadcast ? (flags | 2) : (flags &~ 2);
+			flags = isPublic ? (flags | 4) : (flags &~ 4);
+			flags = megagroup ? (flags | 8) : (flags &~ 8);
 			stream.writeInt32(flags);
 			stream.writeString(title);
 		}
@@ -3161,6 +3203,9 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 	public static class ReplyMarkup extends TLObject {
 		public int flags;
+		public boolean selective;
+		public boolean resize;
+		public boolean single_use;
 		public ArrayList<TL_keyboardButtonRow> rows = new ArrayList<>();
 
 		public static ReplyMarkup TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
@@ -3192,10 +3237,12 @@ public static ReplyMarkup TLdeserialize(AbstractSerializedData stream, int const
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			selective = (flags & 4) != 0;
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = selective ? (flags | 4) : (flags &~ 4);
 			stream.writeInt32(flags);
 		}
 	}
@@ -3206,6 +3253,9 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			resize = (flags & 1) != 0;
+			single_use = (flags & 2) != 0;
+			selective = (flags & 4) != 0;
 			int magic = stream.readInt32(exception);
 			if (magic != 0x1cb5c415) {
 				if (exception) {
@@ -3225,6 +3275,9 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = resize ? (flags | 1) : (flags &~ 1);
+			flags = single_use ? (flags | 2) : (flags &~ 2);
+			flags = selective ? (flags | 4) : (flags &~ 4);
 			stream.writeInt32(flags);
 			stream.writeInt32(0x1cb5c415);
 			int count = rows.size();
@@ -3241,10 +3294,14 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			single_use = (flags & 2) != 0;
+			selective = (flags & 4) != 0;
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = single_use ? (flags | 2) : (flags &~ 2);
+			flags = selective ? (flags | 4) : (flags &~ 4);
 			stream.writeInt32(flags);
 		}
 	}
@@ -3493,132 +3550,223 @@ public void serializeToStream(AbstractSerializedData stream) {
         }
     }
 
-    public static class ChatFull extends TLObject {
-        public int id;
-        public ChatParticipants participants;
-        public Photo chat_photo;
-        public PeerNotifySettings notify_settings;
-        public ExportedChatInvite exported_invite;
-        public ArrayList<BotInfo> bot_info = new ArrayList<>();
-        public int flags;
-        public String about;
-        public int participants_count;
-        public int admins_count;
-        public int kicked_count;
-        public int read_inbox_max_id;
-        public int unread_count;
-        public int unread_important_count;
+	public static class ChatFull extends TLObject {
+		public int flags;
+		public boolean can_view_participants;
+		public int id;
+		public String about;
+		public int participants_count;
+		public int admins_count;
+		public int kicked_count;
+		public int read_inbox_max_id;
+		public int unread_count;
+		public int unread_important_count;
+		public Photo chat_photo;
+		public PeerNotifySettings notify_settings;
+		public ExportedChatInvite exported_invite;
+		public ChatParticipants participants;
+		public ArrayList<BotInfo> bot_info = new ArrayList<>();
+		public int migrated_from_chat_id;
+		public int migrated_from_max_id;
+
+		public static ChatFull TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			ChatFull result = null;
+			switch(constructor) {
+				case 0xfab31aa3:
+					result = new TL_channelFull_old();
+					break;
+				case 0x2e02a614:
+					result = new TL_chatFull();
+					break;
+				case 0x9e341ddf:
+					result = new TL_channelFull();
+					break;
+			}
+			if (result == null && exception) {
+				throw new RuntimeException(String.format("can't parse magic %x in ChatFull", constructor));
+			}
+			if (result != null) {
+				result.readParams(stream, exception);
+			}
+			return result;
+		}
+	}
 
-        public static ChatFull TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-            ChatFull result = null;
-            switch(constructor) {
-                case 0x2e02a614:
-                    result = new TL_chatFull();
-                    break;
-                case 0xfab31aa3:
-                    result = new TL_channelFull();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in ChatFull", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
+	public static class TL_channelFull_old extends TL_channelFull {
+		public static int constructor = 0xfab31aa3;
 
-    public static class TL_chatFull extends ChatFull {
-        public static int constructor = 0x2e02a614;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			can_view_participants = (flags & 8) != 0;
+			id = stream.readInt32(exception);
+			about = stream.readString(exception);
+			if ((flags & 1) != 0) {
+				participants_count = stream.readInt32(exception);
+			}
+			if ((flags & 2) != 0) {
+				admins_count = stream.readInt32(exception);
+			}
+			if ((flags & 4) != 0) {
+				kicked_count = stream.readInt32(exception);
+			}
+			read_inbox_max_id = stream.readInt32(exception);
+			unread_count = stream.readInt32(exception);
+			unread_important_count = stream.readInt32(exception);
+			chat_photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+			notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
+			exported_invite = ExportedChatInvite.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            participants = ChatParticipants.TLdeserialize(stream, stream.readInt32(exception), exception);
-            chat_photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
-            notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
-            exported_invite = ExportedChatInvite.TLdeserialize(stream, stream.readInt32(exception), exception);
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                BotInfo object = BotInfo.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                bot_info.add(object);
-            }
-        }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = can_view_participants ? (flags | 8) : (flags &~ 8);
+			stream.writeInt32(flags);
+			stream.writeInt32(id);
+			stream.writeString(about);
+			if ((flags & 1) != 0) {
+				stream.writeInt32(participants_count);
+			}
+			if ((flags & 2) != 0) {
+				stream.writeInt32(admins_count);
+			}
+			if ((flags & 4) != 0) {
+				stream.writeInt32(kicked_count);
+			}
+			stream.writeInt32(read_inbox_max_id);
+			stream.writeInt32(unread_count);
+			stream.writeInt32(unread_important_count);
+			chat_photo.serializeToStream(stream);
+			notify_settings.serializeToStream(stream);
+			exported_invite.serializeToStream(stream);
+		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            participants.serializeToStream(stream);
-            chat_photo.serializeToStream(stream);
-            notify_settings.serializeToStream(stream);
-            exported_invite.serializeToStream(stream);
-            stream.writeInt32(0x1cb5c415);
-            int count = bot_info.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                bot_info.get(a).serializeToStream(stream);
-            }
-        }
-    }
+	public static class TL_chatFull extends ChatFull {
+		public static int constructor = 0x2e02a614;
 
-    public static class TL_channelFull extends ChatFull {
-        public static int constructor = 0xfab31aa3;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			id = stream.readInt32(exception);
+			participants = ChatParticipants.TLdeserialize(stream, stream.readInt32(exception), exception);
+			chat_photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+			notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
+			exported_invite = ExportedChatInvite.TLdeserialize(stream, stream.readInt32(exception), exception);
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				BotInfo object = BotInfo.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				bot_info.add(object);
+			}
+		}
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            id = stream.readInt32(exception);
-            about = stream.readString(exception);
-            if ((flags & 1) != 0) {
-                participants_count = stream.readInt32(exception);
-            }
-            if ((flags & 2) != 0) {
-                admins_count = stream.readInt32(exception);
-            }
-            if ((flags & 4) != 0) {
-                kicked_count = stream.readInt32(exception);
-            }
-            read_inbox_max_id = stream.readInt32(exception);
-            unread_count = stream.readInt32(exception);
-            unread_important_count = stream.readInt32(exception);
-            chat_photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
-            notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
-            exported_invite = ExportedChatInvite.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(id);
+			participants.serializeToStream(stream);
+			chat_photo.serializeToStream(stream);
+			notify_settings.serializeToStream(stream);
+			exported_invite.serializeToStream(stream);
+			stream.writeInt32(0x1cb5c415);
+			int count = bot_info.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				bot_info.get(a).serializeToStream(stream);
+			}
+		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(id);
-            stream.writeString(about);
-            if ((flags & 1) != 0) {
-                stream.writeInt32(participants_count);
-            }
-            if ((flags & 2) != 0) {
-                stream.writeInt32(admins_count);
-            }
-            if ((flags & 4) != 0) {
-                stream.writeInt32(kicked_count);
-            }
-            stream.writeInt32(read_inbox_max_id);
-            stream.writeInt32(unread_count);
-            stream.writeInt32(unread_important_count);
-            chat_photo.serializeToStream(stream);
-            notify_settings.serializeToStream(stream);
-            exported_invite.serializeToStream(stream);
-        }
-    }
+	public static class TL_channelFull extends ChatFull {
+		public static int constructor = 0x9e341ddf;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			can_view_participants = (flags & 8) != 0;
+			id = stream.readInt32(exception);
+			about = stream.readString(exception);
+			if ((flags & 1) != 0) {
+				participants_count = stream.readInt32(exception);
+			}
+			if ((flags & 2) != 0) {
+				admins_count = stream.readInt32(exception);
+			}
+			if ((flags & 4) != 0) {
+				kicked_count = stream.readInt32(exception);
+			}
+			read_inbox_max_id = stream.readInt32(exception);
+			unread_count = stream.readInt32(exception);
+			unread_important_count = stream.readInt32(exception);
+			chat_photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+			notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
+			exported_invite = ExportedChatInvite.TLdeserialize(stream, stream.readInt32(exception), exception);
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				BotInfo object = BotInfo.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				bot_info.add(object);
+			}
+			if ((flags & 16) != 0) {
+				migrated_from_chat_id = stream.readInt32(exception);
+			}
+			if ((flags & 16) != 0) {
+				migrated_from_max_id = stream.readInt32(exception);
+			}
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = can_view_participants ? (flags | 8) : (flags &~8);
+			stream.writeInt32(flags);
+			stream.writeInt32(id);
+			stream.writeString(about);
+			if ((flags & 1) != 0) {
+				stream.writeInt32(participants_count);
+			}
+			if ((flags & 2) != 0) {
+				stream.writeInt32(admins_count);
+			}
+			if ((flags & 4) != 0) {
+				stream.writeInt32(kicked_count);
+			}
+			stream.writeInt32(read_inbox_max_id);
+			stream.writeInt32(unread_count);
+			stream.writeInt32(unread_important_count);
+			chat_photo.serializeToStream(stream);
+			notify_settings.serializeToStream(stream);
+			exported_invite.serializeToStream(stream);
+			stream.writeInt32(0x1cb5c415);
+			int count = bot_info.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				bot_info.get(a).serializeToStream(stream);
+			}
+			if ((flags & 16) != 0) {
+				stream.writeInt32(migrated_from_chat_id);
+			}
+			if ((flags & 16) != 0) {
+				stream.writeInt32(migrated_from_max_id);
+			}
+		}
+	}
 
 	public static class TL_inputPeerNotifySettings extends TLObject {
 		public static int constructor = 0x46a2ce98;
@@ -4010,7 +4158,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(flags);
 			stream.writeInt64(id);
             stream.writeString(url);
-            stream.writeString(display_url);
+			stream.writeString(display_url);
 			if ((flags & 1) != 0) {
 				stream.writeString(type);
 			}
@@ -4037,8 +4185,8 @@ public void serializeToStream(AbstractSerializedData stream) {
 			}
 			if ((flags & 64) != 0) {
 				stream.writeInt32(embed_height);
-            }
-            if ((flags & 128) != 0) {
+			}
+			if ((flags & 128) != 0) {
 				stream.writeInt32(duration);
 			}
 			if ((flags & 256) != 0) {
@@ -4063,12 +4211,12 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
                 site_name = stream.readString(exception);
 			}
             if ((flags & 4) != 0) {
-                title = stream.readString(exception);
+				title = stream.readString(exception);
             }
             if ((flags & 8) != 0) {
                 description = stream.readString(exception);
             }
-            if ((flags & 16) != 0) {
+			if ((flags & 16) != 0) {
                 photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
             }
             if ((flags & 32) != 0) {
@@ -4078,7 +4226,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
                 embed_type = stream.readString(exception);
             }
             if ((flags & 64) != 0) {
-                embed_width = stream.readInt32(exception);
+				embed_width = stream.readInt32(exception);
 			}
             if ((flags & 64) != 0) {
                 embed_height = stream.readInt32(exception);
@@ -4135,7 +4283,7 @@ public void serializeToStream(AbstractSerializedData stream) {
             }
             if ((flags & 512) != 0) {
                 document.serializeToStream(stream);
-            }
+			}
         }
     }
 
@@ -4465,6 +4613,14 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public UserStatus status;
 		public boolean inactive;
         public int flags;
+		public boolean self;
+		public boolean contact;
+		public boolean mutual_contact;
+		public boolean deleted;
+		public boolean bot;
+		public boolean bot_chat_history;
+		public boolean bot_nochats;
+		public boolean verified;
 		public int bot_info_version;
 
 		public static User TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
@@ -4496,7 +4652,7 @@ public static User TLdeserialize(AbstractSerializedData stream, int constructor,
 					break;
 				case 0x75cf7a8:
 					result = new TL_userForeign_old2();
-                    break;
+					break;
                 case 0xd9ccc4ef:
 					result = new TL_userRequest_old2();
                     break;
@@ -4520,7 +4676,7 @@ public static User TLdeserialize(AbstractSerializedData stream, int constructor,
         }
     }
 
-    public static class TL_userContact_old2 extends User {
+	public static class TL_userContact_old2 extends User {
 		public static int constructor = 0xcab35e18;
 
 
@@ -4538,7 +4694,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
             stream.writeInt32(id);
-            stream.writeString(first_name);
+			stream.writeString(first_name);
 			stream.writeString(last_name);
             stream.writeString(username);
 			stream.writeInt64(access_hash);
@@ -4552,7 +4708,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public static int constructor = 0xf2fb8319;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
+		public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt32(exception);
 			first_name = stream.readString(exception);
             last_name = stream.readString(exception);
@@ -4580,16 +4736,16 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt32(exception);
-            first_name = stream.readString(exception);
+			first_name = stream.readString(exception);
 			last_name = stream.readString(exception);
             phone = stream.readString(exception);
-            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+			photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
             status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
 			inactive = stream.readBool(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			stream.writeInt32(id);
             stream.writeString(first_name);
 			stream.writeString(last_name);
@@ -4638,8 +4794,8 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 		}
 
         public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
+			stream.writeInt32(constructor);
+			stream.writeInt32(id);
 			stream.writeString(first_name);
 			stream.writeString(last_name);
 			stream.writeString(username);
@@ -4655,7 +4811,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
         }
 
         public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			stream.writeInt32(id);
 		}
 	}
@@ -4725,8 +4881,8 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
+			stream.writeInt32(constructor);
+			stream.writeInt32(id);
             stream.writeString(first_name);
             stream.writeString(last_name);
 			stream.writeString(username);
@@ -4744,7 +4900,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt32(exception);
 			first_name = stream.readString(exception);
 			last_name = stream.readString(exception);
-            username = stream.readString(exception);
+			username = stream.readString(exception);
 			access_hash = stream.readInt64(exception);
             phone = stream.readString(exception);
             photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -4787,7 +4943,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
+			id = stream.readInt32(exception);
 			first_name = stream.readString(exception);
 			last_name = stream.readString(exception);
 			username = stream.readString(exception);
@@ -4816,6 +4972,14 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			self = (flags & 1024) != 0;
+			contact = (flags & 2048) != 0;
+			mutual_contact = (flags & 4096) != 0;
+			deleted = (flags & 8192) != 0;
+			bot = (flags & 16384) != 0;
+			bot_chat_history = (flags & 32768) != 0;
+			bot_nochats = (flags & 65536) != 0;
+			verified = (flags & 131072) != 0;
 			id = stream.readInt32(exception);
 			if ((flags & 1) != 0) {
 				access_hash = stream.readInt64(exception);
@@ -4839,12 +5003,20 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 				status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
 			}
 			if ((flags & 16384) != 0) {
-                bot_info_version = stream.readInt32(exception);
+				bot_info_version = stream.readInt32(exception);
 			}
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = self ? (flags | 1024) : (flags &~ 1024);
+			flags = contact ? (flags | 2048) : (flags &~ 2048);
+			flags = mutual_contact ? (flags | 4096) : (flags &~ 4096);
+			flags = deleted ? (flags | 8192) : (flags &~ 8192);
+			flags = bot ? (flags | 16384) : (flags &~ 16384);
+			flags = bot_chat_history ? (flags | 32768) : (flags &~ 32768);
+			flags = bot_nochats ? (flags | 65536) : (flags &~ 65536);
+			flags = verified ? (flags | 131072) : (flags &~ 131072);
 			stream.writeInt32(flags);
 			stream.writeInt32(id);
 			if ((flags & 1) != 0) {
@@ -4926,57 +5098,69 @@ public void serializeToStream(AbstractSerializedData stream) {
         }
     }
 
-    public static class ChannelParticipantsFilter extends TLObject {
+	public static class ChannelParticipantsFilter extends TLObject {
 
-        public static ChannelParticipantsFilter TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-            ChannelParticipantsFilter result = null;
-            switch(constructor) {
-                case 0xb4608969:
-                    result = new TL_channelParticipantsAdmins();
-                    break;
-                case 0xde3f3c79:
-                    result = new TL_channelParticipantsRecent();
-                    break;
-                case 0x3c37bb7a:
-                    result = new TL_channelParticipantsKicked();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in ChannelParticipantsFilter", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
+		public static ChannelParticipantsFilter TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			ChannelParticipantsFilter result = null;
+			switch(constructor) {
+				case 0xb4608969:
+					result = new TL_channelParticipantsAdmins();
+					break;
+				case 0xde3f3c79:
+					result = new TL_channelParticipantsRecent();
+					break;
+				case 0x3c37bb7a:
+					result = new TL_channelParticipantsKicked();
+					break;
+				case 0xb0d1865b:
+					result = new TL_channelParticipantsBots();
+					break;
+			}
+			if (result == null && exception) {
+				throw new RuntimeException(String.format("can't parse magic %x in ChannelParticipantsFilter", constructor));
+			}
+			if (result != null) {
+				result.readParams(stream, exception);
+			}
+			return result;
+		}
+	}
 
-    public static class TL_channelParticipantsAdmins extends ChannelParticipantsFilter {
-        public static int constructor = 0xb4608969;
+	public static class TL_channelParticipantsAdmins extends ChannelParticipantsFilter {
+		public static int constructor = 0xb4608969;
 
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
 
-    public static class TL_channelParticipantsRecent extends ChannelParticipantsFilter {
-        public static int constructor = 0xde3f3c79;
+	public static class TL_channelParticipantsRecent extends ChannelParticipantsFilter {
+		public static int constructor = 0xde3f3c79;
 
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
 
-    public static class TL_channelParticipantsKicked extends ChannelParticipantsFilter {
-        public static int constructor = 0x3c37bb7a;
+	public static class TL_channelParticipantsKicked extends ChannelParticipantsFilter {
+		public static int constructor = 0x3c37bb7a;
 
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
+
+	public static class TL_channelParticipantsBots extends ChannelParticipantsFilter {
+		public static int constructor = 0xb0d1865b;
+
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
 
 	public static class GeoChatMessage extends TLObject {
 		public int chat_id;
@@ -5075,203 +5259,253 @@ public void serializeToStream(AbstractSerializedData stream) {
 	public static class MessageAction extends TLObject {
 		public String title;
 		public String address;
+		public DecryptedMessageAction encryptedAction;
+		public ArrayList<Integer> users = new ArrayList<>();
+		public int channel_id;
+		public Photo photo;
+		public int chat_id;
 		public int user_id;
+		public UserProfilePhoto newUserPhoto;
 		public int inviter_id;
-		public DecryptedMessageAction encryptedAction;
 		public int ttl;
-		public UserProfilePhoto newUserPhoto;
-		public Photo photo;
-		public ArrayList<Integer> users = new ArrayList<>();
 
 		public static MessageAction TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
 			MessageAction result = null;
 			switch(constructor) {
-				case 0xc7d53de:
-					result = new TL_messageActionGeoChatCheckin();
+				case 0x555555F5:
+					result = new TL_messageActionLoginUnknownLocation();
 					break;
-				case 0x55555557:
-					result = new TL_messageActionCreatedBroadcastList();
+				case 0x555555F7:
+					result = new TL_messageEncryptedAction();
 					break;
-                case 0xb5a1ce5a:
-					result = new TL_messageActionChatEditTitle();
+				case 0xa6638b9a:
+					result = new TL_messageActionChatCreate();
 					break;
-				case 0x555555F5:
-					result = new TL_messageActionLoginUnknownLocation();
+				case 0x51bdb021:
+					result = new TL_messageActionChatMigrateTo();
 					break;
-				case 0x5e3cfc4b:
+				case 0x7fcb13a8:
+					result = new TL_messageActionChatEditPhoto();
+					break;
+				case 0xb055eaee:
+					result = new TL_messageActionChannelMigrateFrom();
+					break;
+				case 0x488a7337:
 					result = new TL_messageActionChatAddUser();
 					break;
-				case 0xf89cf5e8:
-					result = new TL_messageActionChatJoinedByLink();
+				case 0xb2ae9b0c:
+					result = new TL_messageActionChatDeleteUser();
+					break;
+				case 0x55555557:
+					result = new TL_messageActionCreatedBroadcastList();
 					break;
 				case 0x55555550:
 					result = new TL_messageActionUserJoined();
 					break;
-				case 0x555555F7:
-					result = new TL_messageEncryptedAction();
+				case 0x55555551:
+					result = new TL_messageActionUserUpdatedPhoto();
+					break;
+				case 0xc7d53de:
+					result = new TL_messageActionGeoChatCheckin();
+					break;
+				case 0xf89cf5e8:
+					result = new TL_messageActionChatJoinedByLink();
+					break;
+				case 0x5e3cfc4b:
+					result = new TL_messageActionChatAddUser_old();
 					break;
 				case 0x55555552:
 					result = new TL_messageActionTTLChange();
 					break;
-				case 0x55555551:
-					result = new TL_messageActionUserUpdatedPhoto();
-					break;
-				case 0xb6aef7b0:
-					result = new TL_messageActionEmpty();
+				case 0x95d2ac92:
+					result = new TL_messageActionChannelCreate();
 					break;
 				case 0x95e3fbef:
 					result = new TL_messageActionChatDeletePhoto();
 					break;
-                case 0x95d2ac92:
-                    result = new TL_messageActionChannelCreate();
-                    break;
-				case 0xb2ae9b0c:
-					result = new TL_messageActionChatDeleteUser();
-					break;
-				case 0x7fcb13a8:
-					result = new TL_messageActionChatEditPhoto();
+				case 0xb5a1ce5a:
+					result = new TL_messageActionChatEditTitle();
 					break;
-				case 0xa6638b9a:
-					result = new TL_messageActionChatCreate();
+				case 0xb6aef7b0:
+					result = new TL_messageActionEmpty();
 					break;
 				case 0x6f038ebc:
 					result = new TL_messageActionGeoChatCreate();
-                    break;
-            }
-            if (result == null && exception) {
+					break;
+			}
+			if (result == null && exception) {
 				throw new RuntimeException(String.format("can't parse magic %x in MessageAction", constructor));
 			}
 			if (result != null) {
-                result.readParams(stream, exception);
+				result.readParams(stream, exception);
 			}
 			return result;
 		}
 	}
 
-	public static class TL_messageActionGeoChatCheckin extends MessageAction {
-		public static int constructor = 0xc7d53de;
+	public static class TL_messageActionLoginUnknownLocation extends MessageAction {
+		public static int constructor = 0x555555F5;
 
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			title = stream.readString(exception);
+			address = stream.readString(exception);
+		}
+
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			stream.writeString(title);
+			stream.writeString(address);
 		}
 	}
 
-    public static class TL_messageActionChannelCreate extends MessageAction {
-        public static int constructor = 0x95d2ac92;
-
-
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            title = stream.readString(exception);
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeString(title);
-        }
-    }
+	public static class TL_messageEncryptedAction extends MessageAction {
+		public static int constructor = 0x555555F7;
 
-	public static class TL_messageActionCreatedBroadcastList extends MessageAction {
-        public static int constructor = 0x55555557;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			encryptedAction = DecryptedMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			encryptedAction.serializeToStream(stream);
 		}
 	}
 
-	public static class TL_messageActionChatEditTitle extends MessageAction {
-		public static int constructor = 0xb5a1ce5a;
+	public static class TL_messageActionChatCreate extends MessageAction {
+		public static int constructor = 0xa6638b9a;
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			title = stream.readString(exception);
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				users.add(stream.readInt32(exception));
+			}
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeString(title);
+			stream.writeInt32(0x1cb5c415);
+			int count = users.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt32(users.get(a));
+			}
 		}
 	}
 
-	public static class TL_messageActionLoginUnknownLocation extends MessageAction {
-		public static int constructor = 0x555555F5;
+	public static class TL_messageActionChatMigrateTo extends MessageAction {
+		public static int constructor = 0x51bdb021;
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            title = stream.readString(exception);
-			address = stream.readString(exception);
+			channel_id = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-			stream.writeString(title);
-			stream.writeString(address);
+			stream.writeInt32(channel_id);
 		}
 	}
 
-	public static class TL_messageActionChatAddUser extends MessageAction {
-		public static int constructor = 0x5e3cfc4b;
+	public static class TL_messageActionChatEditPhoto extends MessageAction {
+		public static int constructor = 0x7fcb13a8;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-			user_id = stream.readInt32(exception);
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
 		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-			stream.writeInt32(user_id);
+			photo.serializeToStream(stream);
 		}
 	}
 
-	public static class TL_messageActionChatJoinedByLink extends MessageAction {
-		public static int constructor = 0xf89cf5e8;
+	public static class TL_messageActionChannelMigrateFrom extends MessageAction {
+		public static int constructor = 0xb055eaee;
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-			inviter_id = stream.readInt32(exception);
+			title = stream.readString(exception);
+			chat_id = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-			stream.writeInt32(inviter_id);
+			stream.writeString(title);
+			stream.writeInt32(chat_id);
 		}
 	}
 
-	public static class TL_messageActionUserJoined extends MessageAction {
-		public static int constructor = 0x55555550;
+	public static class TL_messageActionChatAddUser extends MessageAction {
+		public static int constructor = 0x488a7337;
+
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				users.add(stream.readInt32(exception));
+			}
+		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			stream.writeInt32(0x1cb5c415);
+			int count = users.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt32(users.get(a));
+			}
 		}
 	}
 
-	public static class TL_messageEncryptedAction extends MessageAction {
-        public static int constructor = 0x555555F7;
+	public static class TL_messageActionChatDeleteUser extends MessageAction {
+		public static int constructor = 0xb2ae9b0c;
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            encryptedAction = DecryptedMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
+			user_id = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-			encryptedAction.serializeToStream(stream);
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
 		}
 	}
 
-	public static class TL_messageActionTTLChange extends MessageAction {
-		public static int constructor = 0x55555552;
+	public static class TL_messageActionCreatedBroadcastList extends MessageAction {
+		public static int constructor = 0x55555557;
 
 
-		public void readParams(AbstractSerializedData stream, boolean exception) {
-			ttl = stream.readInt32(exception);
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
 		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+	public static class TL_messageActionUserJoined extends MessageAction {
+		public static int constructor = 0x55555550;
+
+
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-			stream.writeInt32(ttl);
 		}
 	}
 
@@ -5280,35 +5514,40 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            newUserPhoto = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+			newUserPhoto = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			newUserPhoto.serializeToStream(stream);
 		}
 	}
 
-	public static class TL_messageActionEmpty extends MessageAction {
-		public static int constructor = 0xb6aef7b0;
+	public static class TL_messageActionGeoChatCheckin extends MessageAction {
+		public static int constructor = 0xc7d53de;
 
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 		}
 	}
 
-	public static class TL_messageActionChatDeletePhoto extends MessageAction {
-		public static int constructor = 0x95e3fbef;
+	public static class TL_messageActionChatJoinedByLink extends MessageAction {
+		public static int constructor = 0xf89cf5e8;
 
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			inviter_id = stream.readInt32(exception);
+		}
+
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			stream.writeInt32(inviter_id);
 		}
 	}
 
-	public static class TL_messageActionChatDeleteUser extends MessageAction {
-		public static int constructor = 0xb2ae9b0c;
+	public static class TL_messageActionChatAddUser_old extends TL_messageActionChatAddUser {
+		public static int constructor = 0x5e3cfc4b;
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
@@ -5321,48 +5560,63 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
-	public static class TL_messageActionChatEditPhoto extends MessageAction {
-		public static int constructor = 0x7fcb13a8;
+	public static class TL_messageActionTTLChange extends MessageAction {
+		public static int constructor = 0x55555552;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			ttl = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-			photo.serializeToStream(stream);
+			stream.writeInt32(constructor);
+			stream.writeInt32(ttl);
 		}
 	}
 
-	public static class TL_messageActionChatCreate extends MessageAction {
-		public static int constructor = 0xa6638b9a;
+	public static class TL_messageActionChannelCreate extends MessageAction {
+		public static int constructor = 0x95d2ac92;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
+		public void readParams(AbstractSerializedData stream, boolean exception) {
 			title = stream.readString(exception);
-			int magic = stream.readInt32(exception);
-			if (magic != 0x1cb5c415) {
-				if (exception) {
-					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-				}
-				return;
-			}
-			int count = stream.readInt32(exception);
-			for (int a = 0; a < count; a++) {
-				users.add(stream.readInt32(exception));
-			}
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-            stream.writeString(title);
-            stream.writeInt32(0x1cb5c415);
-			int count = users.size();
-			stream.writeInt32(count);
-			for (int a = 0; a < count; a++) {
-				stream.writeInt32(users.get(a));
-			}
+			stream.writeString(title);
+		}
+	}
+
+	public static class TL_messageActionChatDeletePhoto extends MessageAction {
+		public static int constructor = 0x95e3fbef;
+
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
+
+	public static class TL_messageActionChatEditTitle extends MessageAction {
+		public static int constructor = 0xb5a1ce5a;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			title = stream.readString(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeString(title);
+		}
+	}
+
+	public static class TL_messageActionEmpty extends MessageAction {
+		public static int constructor = 0xb6aef7b0;
+
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
 		}
 	}
 
@@ -5375,10 +5629,80 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			address = stream.readString(exception);
 		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeString(title);
-            stream.writeString(address);
+			stream.writeString(address);
+		}
+	}
+
+	public static class ReportReason extends TLObject {
+		public String text;
+
+		public static ReportReason TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			ReportReason result = null;
+			switch(constructor) {
+				case 0x58dbcab8:
+					result = new TL_inputReportReasonSpam();
+					break;
+				case 0x1e22c78d:
+					result = new TL_inputReportReasonViolence();
+					break;
+				case 0xe1746d0a:
+					result = new TL_inputReportReasonOther();
+					break;
+				case 0x2e59d922:
+					result = new TL_inputReportReasonPornography();
+					break;
+			}
+			if (result == null && exception) {
+				throw new RuntimeException(String.format("can't parse magic %x in ReportReason", constructor));
+			}
+			if (result != null) {
+				result.readParams(stream, exception);
+			}
+			return result;
+		}
+	}
+
+	public static class TL_inputReportReasonSpam extends ReportReason {
+		public static int constructor = 0x58dbcab8;
+
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
+
+	public static class TL_inputReportReasonViolence extends ReportReason {
+		public static int constructor = 0x1e22c78d;
+
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
+
+	public static class TL_inputReportReasonOther extends ReportReason {
+		public static int constructor = 0xe1746d0a;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			text = stream.readString(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeString(text);
+		}
+	}
+
+	public static class TL_inputReportReasonPornography extends ReportReason {
+		public static int constructor = 0x2e59d922;
+
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
 		}
 	}
 
@@ -5688,12 +6012,12 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public void readParams(AbstractSerializedData stream, boolean exception) {
             id = stream.readInt64(exception);
 			access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
+			user_id = stream.readInt32(exception);
             date = stream.readInt32(exception);
 			duration = stream.readInt32(exception);
 			size = stream.readInt32(exception);
             thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
+			dc_id = stream.readInt32(exception);
             w = stream.readInt32(exception);
 			h = stream.readInt32(exception);
 		}
@@ -5702,7 +6026,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt64(id);
 			stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
+			stream.writeInt32(user_id);
 			stream.writeInt32(date);
 			stream.writeInt32(duration);
 			stream.writeInt32(size);
@@ -5721,14 +6045,14 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt64(exception);
             access_hash = stream.readInt64(exception);
             user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
+			date = stream.readInt32(exception);
 			caption = stream.readString(exception);
 			duration = stream.readInt32(exception);
-            size = stream.readInt32(exception);
-            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
+			size = stream.readInt32(exception);
+			thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+			dc_id = stream.readInt32(exception);
 			w = stream.readInt32(exception);
-            h = stream.readInt32(exception);
+			h = stream.readInt32(exception);
             key = stream.readByteArray(exception);
 			iv = stream.readByteArray(exception);
 		}
@@ -5737,12 +6061,12 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt64(id);
             stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
+			stream.writeInt32(user_id);
 			stream.writeInt32(date);
 			stream.writeString(caption);
-            stream.writeInt32(duration);
-            stream.writeInt32(size);
-            thumb.serializeToStream(stream);
+			stream.writeInt32(duration);
+			stream.writeInt32(size);
+			thumb.serializeToStream(stream);
 			stream.writeInt32(dc_id);
 			stream.writeInt32(w);
 			stream.writeInt32(h);
@@ -5756,27 +6080,27 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
+			id = stream.readInt64(exception);
 			access_hash = stream.readInt64(exception);
-            user_id = stream.readInt32(exception);
+			user_id = stream.readInt32(exception);
             date = stream.readInt32(exception);
 			caption = stream.readString(exception);
 			duration = stream.readInt32(exception);
-            size = stream.readInt32(exception);
+			size = stream.readInt32(exception);
 			thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
 			dc_id = stream.readInt32(exception);
 			w = stream.readInt32(exception);
 			h = stream.readInt32(exception);
-        }
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(id);
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt64(id);
 			stream.writeInt64(access_hash);
-            stream.writeInt32(user_id);
+			stream.writeInt32(user_id);
             stream.writeInt32(date);
-            stream.writeString(caption);
-            stream.writeInt32(duration);
+			stream.writeString(caption);
+			stream.writeInt32(duration);
 			stream.writeInt32(size);
             thumb.serializeToStream(stream);
 			stream.writeInt32(dc_id);
@@ -5786,16 +6110,16 @@ public void serializeToStream(AbstractSerializedData stream) {
 	}
 
 	public static class TL_video_old2 extends TL_video {
-        public static int constructor = 0x388fa391;
+		public static int constructor = 0x388fa391;
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
+			id = stream.readInt64(exception);
 			access_hash = stream.readInt64(exception);
             user_id = stream.readInt32(exception);
             date = stream.readInt32(exception);
 			caption = stream.readString(exception);
-            duration = stream.readInt32(exception);
+			duration = stream.readInt32(exception);
             mime_type = stream.readString(exception);
 			size = stream.readInt32(exception);
 			thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -5810,7 +6134,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt64(access_hash);
             stream.writeInt32(user_id);
             stream.writeInt32(date);
-            stream.writeString(caption);
+			stream.writeString(caption);
 			stream.writeInt32(duration);
 			stream.writeString(mime_type);
 			stream.writeInt32(size);
@@ -5827,7 +6151,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt64(exception);
-        }
+		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
@@ -5939,14 +6263,14 @@ public static TL_inputAppEvent TLdeserialize(AbstractSerializedData stream, int
 		public void readParams(AbstractSerializedData stream, boolean exception) {
             time = stream.readDouble(exception);
             type = stream.readString(exception);
-            peer = stream.readInt64(exception);
+			peer = stream.readInt64(exception);
 			data = stream.readString(exception);
 		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeDouble(time);
-            stream.writeString(type);
+			stream.writeString(type);
 			stream.writeInt64(peer);
 			stream.writeString(data);
 		}
@@ -5976,7 +6300,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
             pts = stream.readInt32(exception);
 			pts_count = stream.readInt32(exception);
 			offset = stream.readInt32(exception);
-        }
+		}
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
@@ -6037,12 +6361,12 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt64(exception);
 			access_hash = stream.readInt64(exception);
             user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
+			date = stream.readInt32(exception);
 			file_name = stream.readString(exception);
 			mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
-            thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
-            dc_id = stream.readInt32(exception);
+			size = stream.readInt32(exception);
+			thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
+			dc_id = stream.readInt32(exception);
             key = stream.readByteArray(exception);
 			iv = stream.readByteArray(exception);
 		}
@@ -6050,7 +6374,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt64(id);
-            stream.writeInt64(access_hash);
+			stream.writeInt64(access_hash);
 			stream.writeInt32(user_id);
 			stream.writeInt32(date);
 			stream.writeString(file_name);
@@ -6077,9 +6401,9 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
             size = stream.readInt32(exception);
             thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
 			dc_id = stream.readInt32(exception);
-        }
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeInt64(id);
             stream.writeInt64(access_hash);
@@ -6492,7 +6816,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-            stream.writeString(phone_number);
+			stream.writeString(phone_number);
 			stream.writeString(first_name);
 			stream.writeString(last_name);
 		}
@@ -6531,7 +6855,7 @@ public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(0x1cb5c415);
 			int count = attributes.size();
 			stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
+			for (int a = 0; a < count; a++) {
                 attributes.get(a).serializeToStream(stream);
 			}
 		}
@@ -6563,7 +6887,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
-            id.serializeToStream(stream);
+			id.serializeToStream(stream);
 		}
 	}
 
@@ -6581,8 +6905,8 @@ public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
 			id.serializeToStream(stream);
 			stream.writeString(caption);
-        }
-    }
+		}
+	}
 
     public static class TL_inputMediaGeoPoint extends InputMedia {
 		public static int constructor = 0xf9c44144;
@@ -6741,7 +7065,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
             file.serializeToStream(stream);
             stream.writeString(mime_type);
-            stream.writeInt32(0x1cb5c415);
+			stream.writeInt32(0x1cb5c415);
 			int count = attributes.size();
 			stream.writeInt32(count);
 			for (int a = 0; a < count; a++) {
@@ -6978,8 +7302,8 @@ public static EncryptedMessage TLdeserialize(AbstractSerializedData stream, int
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			random_id = stream.readInt64(exception);
-            chat_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
+			chat_id = stream.readInt32(exception);
+			date = stream.readInt32(exception);
 			bytes = stream.readByteArray(exception);
 		}
 
@@ -7075,7 +7399,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			short_name = stream.readString(exception);
 		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeString(short_name);
 		}
@@ -7329,976 +7653,1085 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
-    public static class Update extends TLObject {
-        public int chat_id;
-        public int user_id;
-        public int inviter_id;
-        public int date;
-        public int version;
-        public PeerNotifySettings notify_settings;
-        public int channel_id;
-        public SendMessageAction action;
-        public boolean blocked;
-        public long auth_key_id;
-        public String device;
-        public String location;
-        public int max_id;
-        public int qts;
-        public int pts;
-        public int pts_count;
-        public int id;
-        public long random_id;
-        public ArrayList<TL_dcOption> dc_options = new ArrayList<>();
-        public ChatParticipants participants;
-        public TL_privacyKeyStatusTimestamp key;
-        public ArrayList<PrivacyRule> rules = new ArrayList<>();
-        public UserStatus status;
-        public int views;
-        public String type;
-        public MessageMedia media;
-        public boolean popup;
-        public ContactLink my_link;
-        public ContactLink foreign_link;
-        public TL_messageGroup group;
-        public String first_name;
-        public String last_name;
-        public String username;
-        public ArrayList<Integer> messages = new ArrayList<>();
-        public String phone;
-        public WebPage webpage;
-        public EncryptedChat chat;
-        public int max_date;
-        public UserProfilePhoto photo;
-        public boolean previous;
-
-        public static Update TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-            Update result = null;
-            switch(constructor) {
-                case 0xea4b0e5c:
-                    result = new TL_updateChatParticipantAdd();
-                    break;
-                case 0xbec268ef:
-                    result = new TL_updateNotifySettings();
-                    break;
-                case 0xb6d45656:
-                    result = new TL_updateChannel();
-                    break;
-                case 0x6e5f8c22:
-                    result = new TL_updateChatParticipantDelete();
-                    break;
-                case 0x5c486927:
-                    result = new TL_updateUserTyping();
-                    break;
-                case 0x80ece81a:
-                    result = new TL_updateUserBlocked();
-                    break;
-                case 0x8f06529a:
-                    result = new TL_updateNewAuthorization();
-                    break;
-                case 0x2575bbb9:
-                    result = new TL_updateContactRegistered();
-                    break;
-                case 0x4214f37f:
-                    result = new TL_updateReadChannelInbox();
-                    break;
-                case 0x12bcbd9a:
-                    result = new TL_updateNewEncryptedMessage();
-                    break;
-                case 0x62ba04d9:
-                    result = new TL_updateNewChannelMessage();
-                    break;
-                case 0x4e90bfd6:
-                    result = new TL_updateMessageID();
-                    break;
-                case 0x8e5e9873:
-                    result = new TL_updateDcOptions();
-                    break;
-                case 0x7761198:
-                    result = new TL_updateChatParticipants();
-                    break;
-                case 0xee3b272a:
-                    result = new TL_updatePrivacy();
-                    break;
-                case 0x1710f156:
-                    result = new TL_updateEncryptedChatTyping();
-                    break;
-                case 0x5a68e3f7:
-                    result = new TL_updateNewGeoChatMessage();
-                    break;
-                case 0x1bfbd823:
-                    result = new TL_updateUserStatus();
-                    break;
-                case 0x98a12b4b:
-                    result = new TL_updateChannelMessageViews();
-                    break;
-                case 0x60946422:
-                    result = new TL_updateChannelTooLong();
-                    break;
-                case 0x382dd3e4:
-                    result = new TL_updateServiceNotification();
-                    break;
-                case 0x9d2e67c5:
-                    result = new TL_updateContactLink();
-                    break;
-                case 0x9961fd5c:
-                    result = new TL_updateReadHistoryInbox();
-                    break;
-                case 0xc36c1e3c:
-                    result = new TL_updateChannelGroup();
-                    break;
-                case 0xa7332b73:
-                    result = new TL_updateUserName();
-                    break;
-                case 0xc37521c9:
-                    result = new TL_updateDeleteChannelMessages();
-                    break;
-                case 0x12b9417b:
-                    result = new TL_updateUserPhone();
-                    break;
-                case 0x7f891213:
-                    result = new TL_updateWebPage();
-                    break;
-                case 0xb4a2e88d:
-                    result = new TL_updateEncryption();
-                    break;
-                case 0x1f2b0afd:
-                    result = new TL_updateNewMessage();
-                    break;
-                case 0x38fe25b7:
-                    result = new TL_updateEncryptedMessagesRead();
-                    break;
-                case 0x68c13933:
-                    result = new TL_updateReadMessagesContents();
-                    break;
-                case 0xa20db0e5:
-                    result = new TL_updateDeleteMessages();
-                    break;
-                case 0x9a65ea1f:
-                    result = new TL_updateChatUserTyping();
-                    break;
-                case 0x95313b0c:
-                    result = new TL_updateUserPhoto();
-                    break;
-                case 0x2f2f21bf:
-                    result = new TL_updateReadHistoryOutbox();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in Update", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_updateChatParticipantAdd extends Update {
-        public static int constructor = 0xea4b0e5c;
-
-
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            chat_id = stream.readInt32(exception);
-            user_id = stream.readInt32(exception);
-            inviter_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            version = stream.readInt32(exception);
-        }
+	public static class Update extends TLObject {
+		public int chat_id;
+		public int user_id;
+		public int inviter_id;
+		public int date;
+		public int version;
+		public PeerNotifySettings notify_settings;
+		public int channel_id;
+		public SendMessageAction action;
+		public boolean blocked;
+		public long auth_key_id;
+		public String device;
+		public String location;
+		public int max_id;
+		public int qts;
+		public boolean enabled;
+		public int pts;
+		public int pts_count;
+		public int id;
+		public long random_id;
+		public ArrayList<TL_dcOption> dc_options = new ArrayList<>();
+		public ChatParticipants participants;
+		public TL_privacyKeyStatusTimestamp key;
+		public ArrayList<PrivacyRule> rules = new ArrayList<>();
+		public UserStatus status;
+		public int views;
+		public String type;
+		public MessageMedia media;
+		public boolean popup;
+		public boolean is_admin;
+		public TL_messages_stickerSet stickerset;
+		public ContactLink my_link;
+		public ContactLink foreign_link;
+		public TL_messageGroup group;
+		public String first_name;
+		public String last_name;
+		public String username;
+		public ArrayList<Integer> messages = new ArrayList<>();
+		public String phone;
+		public WebPage webpage;
+		public ArrayList<Long> order = new ArrayList<>();
+		public EncryptedChat chat;
+		public int max_date;
+		public UserProfilePhoto photo;
+		public boolean previous;
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(chat_id);
-            stream.writeInt32(user_id);
-            stream.writeInt32(inviter_id);
-            stream.writeInt32(date);
-            stream.writeInt32(version);
-        }
-    }
+		public static Update TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			Update result = null;
+			switch(constructor) {
+				case 0xea4b0e5c:
+					result = new TL_updateChatParticipantAdd();
+					break;
+				case 0x43ae3dec:
+					result = new TL_updateStickerSets();
+					break;
+				case 0xbec268ef:
+					result = new TL_updateNotifySettings();
+					break;
+				case 0xb6d45656:
+					result = new TL_updateChannel();
+					break;
+				case 0x6e5f8c22:
+					result = new TL_updateChatParticipantDelete();
+					break;
+				case 0x5c486927:
+					result = new TL_updateUserTyping();
+					break;
+				case 0x80ece81a:
+					result = new TL_updateUserBlocked();
+					break;
+				case 0x8f06529a:
+					result = new TL_updateNewAuthorization();
+					break;
+				case 0x2575bbb9:
+					result = new TL_updateContactRegistered();
+					break;
+				case 0x4214f37f:
+					result = new TL_updateReadChannelInbox();
+					break;
+				case 0x12bcbd9a:
+					result = new TL_updateNewEncryptedMessage();
+					break;
+				case 0x6e947941:
+					result = new TL_updateChatAdmins();
+					break;
+				case 0x62ba04d9:
+					result = new TL_updateNewChannelMessage();
+					break;
+				case 0x4e90bfd6:
+					result = new TL_updateMessageID();
+					break;
+				case 0x8e5e9873:
+					result = new TL_updateDcOptions();
+					break;
+				case 0x7761198:
+					result = new TL_updateChatParticipants();
+					break;
+				case 0xee3b272a:
+					result = new TL_updatePrivacy();
+					break;
+				case 0x1710f156:
+					result = new TL_updateEncryptedChatTyping();
+					break;
+				case 0x5a68e3f7:
+					result = new TL_updateNewGeoChatMessage();
+					break;
+				case 0x1bfbd823:
+					result = new TL_updateUserStatus();
+					break;
+				case 0x98a12b4b:
+					result = new TL_updateChannelMessageViews();
+					break;
+				case 0x60946422:
+					result = new TL_updateChannelTooLong();
+					break;
+				case 0x382dd3e4:
+					result = new TL_updateServiceNotification();
+					break;
+				case 0xb6901959:
+					result = new TL_updateChatParticipantAdmin();
+					break;
+				case 0x688a30aa:
+					result = new TL_updateNewStickerSet();
+					break;
+				case 0x9d2e67c5:
+					result = new TL_updateContactLink();
+					break;
+				case 0x9961fd5c:
+					result = new TL_updateReadHistoryInbox();
+					break;
+				case 0xc36c1e3c:
+					result = new TL_updateChannelGroup();
+					break;
+				case 0xa7332b73:
+					result = new TL_updateUserName();
+					break;
+				case 0xc37521c9:
+					result = new TL_updateDeleteChannelMessages();
+					break;
+				case 0x12b9417b:
+					result = new TL_updateUserPhone();
+					break;
+				case 0x7f891213:
+					result = new TL_updateWebPage();
+					break;
+				case 0xb4a2e88d:
+					result = new TL_updateEncryption();
+					break;
+				case 0x1f2b0afd:
+					result = new TL_updateNewMessage();
+					break;
+				case 0xf0dfb451:
+					result = new TL_updateStickerSetsOrder();
+					break;
+				case 0x38fe25b7:
+					result = new TL_updateEncryptedMessagesRead();
+					break;
+				case 0x68c13933:
+					result = new TL_updateReadMessagesContents();
+					break;
+				case 0xa20db0e5:
+					result = new TL_updateDeleteMessages();
+					break;
+				case 0x9a65ea1f:
+					result = new TL_updateChatUserTyping();
+					break;
+				case 0x95313b0c:
+					result = new TL_updateUserPhoto();
+					break;
+				case 0x2f2f21bf:
+					result = new TL_updateReadHistoryOutbox();
+					break;
+			}
+			if (result == null && exception) {
+				throw new RuntimeException(String.format("can't parse magic %x in Update", constructor));
+			}
+			if (result != null) {
+				result.readParams(stream, exception);
+			}
+			return result;
+		}
+	}
 
-    public static class TL_updateNotifySettings extends Update {
-        public static int constructor = 0xbec268ef;
+	public static class TL_updateChatParticipantAdd extends Update {
+		public static int constructor = 0xea4b0e5c;
 
-        public NotifyPeer peer;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            peer = NotifyPeer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			chat_id = stream.readInt32(exception);
+			user_id = stream.readInt32(exception);
+			inviter_id = stream.readInt32(exception);
+			date = stream.readInt32(exception);
+			version = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            peer.serializeToStream(stream);
-            notify_settings.serializeToStream(stream);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+			stream.writeInt32(user_id);
+			stream.writeInt32(inviter_id);
+			stream.writeInt32(date);
+			stream.writeInt32(version);
+		}
+	}
 
-    public static class TL_updateChannel extends Update {
-        public static int constructor = 0xb6d45656;
+	public static class TL_updateStickerSets extends Update {
+		public static int constructor = 0x43ae3dec;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            channel_id = stream.readInt32(exception);
-        }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(channel_id);
-        }
-    }
+	public static class TL_updateNotifySettings extends Update {
+		public static int constructor = 0xbec268ef;
 
-    public static class TL_updateChatParticipantDelete extends Update {
-        public static int constructor = 0x6e5f8c22;
+		public NotifyPeer peer;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			peer = NotifyPeer.TLdeserialize(stream, stream.readInt32(exception), exception);
+			notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            chat_id = stream.readInt32(exception);
-            user_id = stream.readInt32(exception);
-            version = stream.readInt32(exception);
-        }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			peer.serializeToStream(stream);
+			notify_settings.serializeToStream(stream);
+		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(chat_id);
-            stream.writeInt32(user_id);
-            stream.writeInt32(version);
-        }
-    }
+	public static class TL_updateChannel extends Update {
+		public static int constructor = 0xb6d45656;
 
-    public static class TL_updateUserTyping extends Update {
-        public static int constructor = 0x5c486927;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			channel_id = stream.readInt32(exception);
+		}
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-            action = SendMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(channel_id);
+		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
-            action.serializeToStream(stream);
-        }
-    }
+	public static class TL_updateChatParticipantDelete extends Update {
+		public static int constructor = 0x6e5f8c22;
 
-    public static class TL_updateUserBlocked extends Update {
-        public static int constructor = 0x80ece81a;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			chat_id = stream.readInt32(exception);
+			user_id = stream.readInt32(exception);
+			version = stream.readInt32(exception);
+		}
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-            blocked = stream.readBool(exception);
-        }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+			stream.writeInt32(user_id);
+			stream.writeInt32(version);
+		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
-            stream.writeBool(blocked);
-        }
-    }
+	public static class TL_updateUserTyping extends Update {
+		public static int constructor = 0x5c486927;
 
-    public static class TL_updateNewAuthorization extends Update {
-        public static int constructor = 0x8f06529a;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			action = SendMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            auth_key_id = stream.readInt64(exception);
-            date = stream.readInt32(exception);
-            device = stream.readString(exception);
-            location = stream.readString(exception);
-        }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			action.serializeToStream(stream);
+		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt64(auth_key_id);
-            stream.writeInt32(date);
-            stream.writeString(device);
-            stream.writeString(location);
-        }
-    }
+	public static class TL_updateUserBlocked extends Update {
+		public static int constructor = 0x80ece81a;
 
-    public static class TL_updateContactRegistered extends Update {
-        public static int constructor = 0x2575bbb9;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			blocked = stream.readBool(exception);
+		}
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-        }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			stream.writeBool(blocked);
+		}
+	}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
-            stream.writeInt32(date);
-        }
-    }
+	public static class TL_updateNewAuthorization extends Update {
+		public static int constructor = 0x8f06529a;
 
-    public static class TL_updateReadChannelInbox extends Update {
-        public static int constructor = 0x4214f37f;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			auth_key_id = stream.readInt64(exception);
+			date = stream.readInt32(exception);
+			device = stream.readString(exception);
+			location = stream.readString(exception);
+		}
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            channel_id = stream.readInt32(exception);
-            max_id = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(channel_id);
-            stream.writeInt32(max_id);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt64(auth_key_id);
+			stream.writeInt32(date);
+			stream.writeString(device);
+			stream.writeString(location);
+		}
+	}
 
-    public static class TL_updateNewEncryptedMessage extends Update {
-        public static int constructor = 0x12bcbd9a;
+	public static class TL_updateContactRegistered extends Update {
+		public static int constructor = 0x2575bbb9;
 
-        public EncryptedMessage message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            message = EncryptedMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
-            qts = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			date = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            message.serializeToStream(stream);
-            stream.writeInt32(qts);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			stream.writeInt32(date);
+		}
+	}
 
-    public static class TL_updateNewChannelMessage extends Update {
-        public static int constructor = 0x62ba04d9;
+	public static class TL_updateReadChannelInbox extends Update {
+		public static int constructor = 0x4214f37f;
 
-        public Message message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            message = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			channel_id = stream.readInt32(exception);
+			max_id = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            message.serializeToStream(stream);
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(channel_id);
+			stream.writeInt32(max_id);
+		}
+	}
 
-    public static class TL_updateMessageID extends Update {
-        public static int constructor = 0x4e90bfd6;
+	public static class TL_updateNewEncryptedMessage extends Update {
+		public static int constructor = 0x12bcbd9a;
 
+		public EncryptedMessage message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
-            random_id = stream.readInt64(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			message = EncryptedMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+			qts = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
-            stream.writeInt64(random_id);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			message.serializeToStream(stream);
+			stream.writeInt32(qts);
+		}
+	}
 
-    public static class TL_updateDcOptions extends Update {
-        public static int constructor = 0x8e5e9873;
+	public static class TL_updateChatAdmins extends Update {
+		public static int constructor = 0x6e947941;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                TL_dcOption object = TL_dcOption.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                dc_options.add(object);
-            }
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			chat_id = stream.readInt32(exception);
+			enabled = stream.readBool(exception);
+			version = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(0x1cb5c415);
-            int count = dc_options.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                dc_options.get(a).serializeToStream(stream);
-            }
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+			stream.writeBool(enabled);
+			stream.writeInt32(version);
+		}
+	}
 
-    public static class TL_updateChatParticipants extends Update {
-        public static int constructor = 0x7761198;
+	public static class TL_updateNewChannelMessage extends Update {
+		public static int constructor = 0x62ba04d9;
 
+		public Message message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            participants = ChatParticipants.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			message = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            participants.serializeToStream(stream);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			message.serializeToStream(stream);
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+		}
+	}
 
-    public static class TL_updatePrivacy extends Update {
-        public static int constructor = 0xee3b272a;
+	public static class TL_updateMessageID extends Update {
+		public static int constructor = 0x4e90bfd6;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            key = TL_privacyKeyStatusTimestamp.TLdeserialize(stream, stream.readInt32(exception), exception);
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                PrivacyRule object = PrivacyRule.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                rules.add(object);
-            }
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			id = stream.readInt32(exception);
+			random_id = stream.readInt64(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            key.serializeToStream(stream);
-            stream.writeInt32(0x1cb5c415);
-            int count = rules.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                rules.get(a).serializeToStream(stream);
-            }
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(id);
+			stream.writeInt64(random_id);
+		}
+	}
 
-    public static class TL_updateEncryptedChatTyping extends Update {
-        public static int constructor = 0x1710f156;
+	public static class TL_updateDcOptions extends Update {
+		public static int constructor = 0x8e5e9873;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            chat_id = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				TL_dcOption object = TL_dcOption.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				dc_options.add(object);
+			}
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(chat_id);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(0x1cb5c415);
+			int count = dc_options.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				dc_options.get(a).serializeToStream(stream);
+			}
+		}
+	}
 
-    public static class TL_updateNewGeoChatMessage extends Update {
-        public static int constructor = 0x5a68e3f7;
+	public static class TL_updateChatParticipants extends Update {
+		public static int constructor = 0x7761198;
 
-        public GeoChatMessage message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            message = GeoChatMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			participants = ChatParticipants.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            message.serializeToStream(stream);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			participants.serializeToStream(stream);
+		}
+	}
 
-    public static class TL_updateUserStatus extends Update {
-        public static int constructor = 0x1bfbd823;
+	public static class TL_updatePrivacy extends Update {
+		public static int constructor = 0xee3b272a;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-            status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			key = TL_privacyKeyStatusTimestamp.TLdeserialize(stream, stream.readInt32(exception), exception);
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				PrivacyRule object = PrivacyRule.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				rules.add(object);
+			}
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
-            status.serializeToStream(stream);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			key.serializeToStream(stream);
+			stream.writeInt32(0x1cb5c415);
+			int count = rules.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				rules.get(a).serializeToStream(stream);
+			}
+		}
+	}
 
-    public static class TL_updateChannelMessageViews extends Update {
-        public static int constructor = 0x98a12b4b;
+	public static class TL_updateEncryptedChatTyping extends Update {
+		public static int constructor = 0x1710f156;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            channel_id = stream.readInt32(exception);
-            id = stream.readInt32(exception);
-            views = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			chat_id = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(channel_id);
-            stream.writeInt32(id);
-            stream.writeInt32(views);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+		}
+	}
 
-    public static class TL_updateChannelTooLong extends Update {
-        public static int constructor = 0x60946422;
+	public static class TL_updateNewGeoChatMessage extends Update {
+		public static int constructor = 0x5a68e3f7;
 
+		public GeoChatMessage message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            channel_id = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			message = GeoChatMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(channel_id);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			message.serializeToStream(stream);
+		}
+	}
 
-    public static class TL_updateServiceNotification extends Update {
-        public static int constructor = 0x382dd3e4;
+	public static class TL_updateUserStatus extends Update {
+		public static int constructor = 0x1bfbd823;
 
-        public String message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            type = stream.readString(exception);
-            message = stream.readString(exception);
-            media = MessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
-            popup = stream.readBool(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			status = UserStatus.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeString(type);
-            stream.writeString(message);
-            media.serializeToStream(stream);
-            stream.writeBool(popup);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			status.serializeToStream(stream);
+		}
+	}
 
-    public static class TL_updateContactLink extends Update {
-        public static int constructor = 0x9d2e67c5;
+	public static class TL_updateChannelMessageViews extends Update {
+		public static int constructor = 0x98a12b4b;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-            my_link = ContactLink.TLdeserialize(stream, stream.readInt32(exception), exception);
-            foreign_link = ContactLink.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			channel_id = stream.readInt32(exception);
+			id = stream.readInt32(exception);
+			views = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
-            my_link.serializeToStream(stream);
-            foreign_link.serializeToStream(stream);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(channel_id);
+			stream.writeInt32(id);
+			stream.writeInt32(views);
+		}
+	}
 
-    public static class TL_updateReadHistoryInbox extends Update {
-        public static int constructor = 0x9961fd5c;
+	public static class TL_updateChannelTooLong extends Update {
+		public static int constructor = 0x60946422;
 
-        public Peer peer;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            peer = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            max_id = stream.readInt32(exception);
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			channel_id = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            peer.serializeToStream(stream);
-            stream.writeInt32(max_id);
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(channel_id);
+		}
+	}
 
-    public static class TL_updateChannelGroup extends Update {
-        public static int constructor = 0xc36c1e3c;
+	public static class TL_updateServiceNotification extends Update {
+		public static int constructor = 0x382dd3e4;
 
+		public String message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            channel_id = stream.readInt32(exception);
-            group = TL_messageGroup.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			type = stream.readString(exception);
+			message = stream.readString(exception);
+			media = MessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
+			popup = stream.readBool(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(channel_id);
-            group.serializeToStream(stream);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeString(type);
+			stream.writeString(message);
+			media.serializeToStream(stream);
+			stream.writeBool(popup);
+		}
+	}
 
-    public static class TL_updateUserName extends Update {
-        public static int constructor = 0xa7332b73;
+	public static class TL_updateChatParticipantAdmin extends Update {
+		public static int constructor = 0xb6901959;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-            first_name = stream.readString(exception);
-            last_name = stream.readString(exception);
-            username = stream.readString(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			chat_id = stream.readInt32(exception);
+			user_id = stream.readInt32(exception);
+			is_admin = stream.readBool(exception);
+			version = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
-            stream.writeString(first_name);
-            stream.writeString(last_name);
-            stream.writeString(username);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+			stream.writeInt32(user_id);
+			stream.writeBool(is_admin);
+			stream.writeInt32(version);
+		}
+	}
 
-    public static class TL_updateDeleteChannelMessages extends Update {
-        public static int constructor = 0xc37521c9;
+	public static class TL_updateNewStickerSet extends Update {
+		public static int constructor = 0x688a30aa;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            channel_id = stream.readInt32(exception);
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                messages.add(stream.readInt32(exception));
-            }
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			stickerset = TL_messages_stickerSet.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(channel_id);
-            stream.writeInt32(0x1cb5c415);
-            int count = messages.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                stream.writeInt32(messages.get(a));
-            }
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stickerset.serializeToStream(stream);
+		}
+	}
 
-    public static class TL_updateUserPhone extends Update {
-        public static int constructor = 0x12b9417b;
+	public static class TL_updateContactLink extends Update {
+		public static int constructor = 0x9d2e67c5;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-            phone = stream.readString(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			my_link = ContactLink.TLdeserialize(stream, stream.readInt32(exception), exception);
+			foreign_link = ContactLink.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
-            stream.writeString(phone);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			my_link.serializeToStream(stream);
+			foreign_link.serializeToStream(stream);
+		}
+	}
 
-    public static class TL_updateWebPage extends Update {
-        public static int constructor = 0x7f891213;
+	public static class TL_updateReadHistoryInbox extends Update {
+		public static int constructor = 0x9961fd5c;
 
+		public Peer peer;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            webpage = WebPage.TLdeserialize(stream, stream.readInt32(exception), exception);
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			peer = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
+			max_id = stream.readInt32(exception);
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            webpage.serializeToStream(stream);
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			peer.serializeToStream(stream);
+			stream.writeInt32(max_id);
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+		}
+	}
 
-    public static class TL_updateEncryption extends Update {
-        public static int constructor = 0xb4a2e88d;
+	public static class TL_updateChannelGroup extends Update {
+		public static int constructor = 0xc36c1e3c;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            chat = EncryptedChat.TLdeserialize(stream, stream.readInt32(exception), exception);
-            date = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			channel_id = stream.readInt32(exception);
+			group = TL_messageGroup.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            chat.serializeToStream(stream);
-            stream.writeInt32(date);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(channel_id);
+			group.serializeToStream(stream);
+		}
+	}
 
-    public static class TL_updateNewMessage extends Update {
-        public static int constructor = 0x1f2b0afd;
+	public static class TL_updateUserName extends Update {
+		public static int constructor = 0xa7332b73;
 
-        public Message message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            message = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			first_name = stream.readString(exception);
+			last_name = stream.readString(exception);
+			username = stream.readString(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            message.serializeToStream(stream);
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			stream.writeString(first_name);
+			stream.writeString(last_name);
+			stream.writeString(username);
+		}
+	}
 
-    public static class TL_updateEncryptedMessagesRead extends Update {
-        public static int constructor = 0x38fe25b7;
+	public static class TL_updateDeleteChannelMessages extends Update {
+		public static int constructor = 0xc37521c9;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            chat_id = stream.readInt32(exception);
-            max_date = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			channel_id = stream.readInt32(exception);
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				messages.add(stream.readInt32(exception));
+			}
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(chat_id);
-            stream.writeInt32(max_date);
-            stream.writeInt32(date);
-        }
-    }
-
-    public static class TL_updateReadMessagesContents extends Update {
-        public static int constructor = 0x68c13933;
-
-
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                messages.add(stream.readInt32(exception));
-            }
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(0x1cb5c415);
-            int count = messages.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                stream.writeInt32(messages.get(a));
-            }
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-        }
-    }
-
-    public static class TL_updateDeleteMessages extends Update {
-        public static int constructor = 0xa20db0e5;
-
-
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                messages.add(stream.readInt32(exception));
-            }
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(0x1cb5c415);
-            int count = messages.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                stream.writeInt32(messages.get(a));
-            }
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-        }
-    }
-
-    public static class TL_updateChatUserTyping extends Update {
-        public static int constructor = 0x9a65ea1f;
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(channel_id);
+			stream.writeInt32(0x1cb5c415);
+			int count = messages.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt32(messages.get(a));
+			}
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+		}
+	}
 
+	public static class TL_updateUserPhone extends Update {
+		public static int constructor = 0x12b9417b;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            chat_id = stream.readInt32(exception);
-            user_id = stream.readInt32(exception);
-            action = SendMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
-        }
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(chat_id);
-            stream.writeInt32(user_id);
-            action.serializeToStream(stream);
-        }
-    }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			phone = stream.readString(exception);
+		}
 
-    public static class TL_updateUserPhoto extends Update {
-        public static int constructor = 0x95313b0c;
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			stream.writeString(phone);
+		}
+	}
 
+	public static class TL_updateWebPage extends Update {
+		public static int constructor = 0x7f891213;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            user_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-            previous = stream.readBool(exception);
-        }
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
-            stream.writeInt32(date);
-            photo.serializeToStream(stream);
-            stream.writeBool(previous);
-        }
-    }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			webpage = WebPage.TLdeserialize(stream, stream.readInt32(exception), exception);
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+		}
 
-    public static class TL_updateReadHistoryOutbox extends Update {
-        public static int constructor = 0x2f2f21bf;
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			webpage.serializeToStream(stream);
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+		}
+	}
 
-        public Peer peer;
+	public static class TL_updateEncryption extends Update {
+		public static int constructor = 0xb4a2e88d;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            peer = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            max_id = stream.readInt32(exception);
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-        }
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            peer.serializeToStream(stream);
-            stream.writeInt32(max_id);
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-        }
-    }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			chat = EncryptedChat.TLdeserialize(stream, stream.readInt32(exception), exception);
+			date = stream.readInt32(exception);
+		}
 
-    public static class TL_contacts_suggested extends TLObject {
-        public static int constructor = 0x5649dcc5;
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			chat.serializeToStream(stream);
+			stream.writeInt32(date);
+		}
+	}
 
-        public ArrayList<TL_contactSuggested> results = new ArrayList<>();
-        public ArrayList<User> users = new ArrayList<>();
+	public static class TL_updateNewMessage extends Update {
+		public static int constructor = 0x1f2b0afd;
 
-        public static TL_contacts_suggested TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-            if (TL_contacts_suggested.constructor != constructor) {
-                if (exception) {
-                    throw new RuntimeException(String.format("can't parse magic %x in TL_contacts_suggested", constructor));
-                } else {
-                    return null;
-                }
-            }
-            TL_contacts_suggested result = new TL_contacts_suggested();
-            result.readParams(stream, exception);
-            return result;
-        }
+		public Message message;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                TL_contactSuggested object = TL_contactSuggested.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                results.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                users.add(object);
-            }
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			message = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(0x1cb5c415);
-            int count = results.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                results.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = users.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                users.get(a).serializeToStream(stream);
-            }
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			message.serializeToStream(stream);
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+		}
+	}
 
-	public static class TL_receivedNotifyMessage extends TLObject {
-		public static int constructor = 0xa384b779;
+	public static class TL_updateStickerSetsOrder extends Update {
+		public static int constructor = 0xf0dfb451;
 
-		public int id;
-		public int flags;
 
-		public static TL_receivedNotifyMessage TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-			if (TL_receivedNotifyMessage.constructor != constructor) {
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
 				if (exception) {
-					throw new RuntimeException(String.format("can't parse magic %x in TL_receivedNotifyMessage", constructor));
-				} else {
-					return null;
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
 				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				order.add(stream.readInt64(exception));
+			}
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(0x1cb5c415);
+			int count = order.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt64(order.get(a));
 			}
-			TL_receivedNotifyMessage result = new TL_receivedNotifyMessage();
-			result.readParams(stream, exception);
-			return result;
 		}
+	}
+
+	public static class TL_updateEncryptedMessagesRead extends Update {
+		public static int constructor = 0x38fe25b7;
+
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-			id = stream.readInt32(exception);
-			flags = stream.readInt32(exception);
+			chat_id = stream.readInt32(exception);
+			max_date = stream.readInt32(exception);
+			date = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-			stream.writeInt32(id);
-			stream.writeInt32(flags);
+			stream.writeInt32(chat_id);
+			stream.writeInt32(max_date);
+			stream.writeInt32(date);
+		}
+	}
+
+	public static class TL_updateReadMessagesContents extends Update {
+		public static int constructor = 0x68c13933;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				messages.add(stream.readInt32(exception));
+			}
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(0x1cb5c415);
+			int count = messages.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt32(messages.get(a));
+			}
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+		}
+	}
+
+	public static class TL_updateDeleteMessages extends Update {
+		public static int constructor = 0xa20db0e5;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				messages.add(stream.readInt32(exception));
+			}
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(0x1cb5c415);
+			int count = messages.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt32(messages.get(a));
+			}
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+		}
+	}
+
+	public static class TL_updateChatUserTyping extends Update {
+		public static int constructor = 0x9a65ea1f;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			chat_id = stream.readInt32(exception);
+			user_id = stream.readInt32(exception);
+			action = SendMessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+			stream.writeInt32(user_id);
+			action.serializeToStream(stream);
+		}
+	}
+
+	public static class TL_updateUserPhoto extends Update {
+		public static int constructor = 0x95313b0c;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			date = stream.readInt32(exception);
+			photo = UserProfilePhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+			previous = stream.readBool(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			stream.writeInt32(date);
+			photo.serializeToStream(stream);
+			stream.writeBool(previous);
+		}
+	}
+
+	public static class TL_updateReadHistoryOutbox extends Update {
+		public static int constructor = 0x2f2f21bf;
+
+		public Peer peer;
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			peer = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
+			max_id = stream.readInt32(exception);
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			peer.serializeToStream(stream);
+			stream.writeInt32(max_id);
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+		}
+	}
+
+    public static class TL_contacts_suggested extends TLObject {
+        public static int constructor = 0x5649dcc5;
+
+        public ArrayList<TL_contactSuggested> results = new ArrayList<>();
+        public ArrayList<User> users = new ArrayList<>();
+
+        public static TL_contacts_suggested TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+            if (TL_contacts_suggested.constructor != constructor) {
+                if (exception) {
+                    throw new RuntimeException(String.format("can't parse magic %x in TL_contacts_suggested", constructor));
+                } else {
+                    return null;
+                }
+            }
+            TL_contacts_suggested result = new TL_contacts_suggested();
+            result.readParams(stream, exception);
+            return result;
+        }
+
+        public void readParams(AbstractSerializedData stream, boolean exception) {
+            int magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+                if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            int count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                TL_contactSuggested object = TL_contactSuggested.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                results.add(object);
+            }
+            magic = stream.readInt32(exception);
+            if (magic != 0x1cb5c415) {
+				if (exception) {
+                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+                }
+                return;
+            }
+            count = stream.readInt32(exception);
+            for (int a = 0; a < count; a++) {
+                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+                if (object == null) {
+                    return;
+                }
+                users.add(object);
+            }
+        }
+
+        public void serializeToStream(AbstractSerializedData stream) {
+            stream.writeInt32(constructor);
+            stream.writeInt32(0x1cb5c415);
+            int count = results.size();
+            stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+                results.get(a).serializeToStream(stream);
+            }
+            stream.writeInt32(0x1cb5c415);
+            count = users.size();
+            stream.writeInt32(count);
+            for (int a = 0; a < count; a++) {
+                users.get(a).serializeToStream(stream);
+            }
+        }
+    }
+
+	public static class TL_receivedNotifyMessage extends TLObject {
+		public static int constructor = 0xa384b779;
+
+		public int id;
+		public int flags;
+
+		public static TL_receivedNotifyMessage TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			if (TL_receivedNotifyMessage.constructor != constructor) {
+				if (exception) {
+					throw new RuntimeException(String.format("can't parse magic %x in TL_receivedNotifyMessage", constructor));
+				} else {
+					return null;
+				}
+			}
+			TL_receivedNotifyMessage result = new TL_receivedNotifyMessage();
+			result.readParams(stream, exception);
+			return result;
+		}
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			id = stream.readInt32(exception);
+			flags = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(id);
+			stream.writeInt32(flags);
 		}
 	}
 
@@ -8321,7 +8754,7 @@ public static InputEncryptedFile TLdeserialize(AbstractSerializedData stream, in
 				case 0x1837c364:
 					result = new TL_inputEncryptedFileEmpty();
                     break;
-                case 0x64bd0306:
+				case 0x64bd0306:
 					result = new TL_inputEncryptedFileUploaded();
 					break;
 			}
@@ -8340,11 +8773,11 @@ public static InputEncryptedFile TLdeserialize(AbstractSerializedData stream, in
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt64(exception);
+			id = stream.readInt64(exception);
 			access_hash = stream.readInt64(exception);
 		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt64(id);
 			stream.writeInt64(access_hash);
@@ -8407,15 +8840,9 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public static messages_AllStickers TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
 			messages_AllStickers result = null;
 			switch(constructor) {
-				case 0xd51dafdb:
+				case 0xedfd405f:
 					result = new TL_messages_allStickers();
 					break;
-				case 0xdcef3102:
-					result = new TL_messages_allStickers_old();
-					break;
-				case 0x5ce352ec:
-					result = new TL_messages_allStickers_old2();
-					break;
 				case 0xe86602c3:
 					result = new TL_messages_allStickersNotModified();
 					break;
@@ -8431,11 +8858,12 @@ public static messages_AllStickers TLdeserialize(AbstractSerializedData stream,
 	}
 
 	public static class TL_messages_allStickers extends messages_AllStickers {
-		public static int constructor = 0xd51dafdb;
+		public static int constructor = 0xedfd405f;
 
+		public int hash;
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-			hash = stream.readString(exception);
+			hash = stream.readInt32(exception);
 			int magic = stream.readInt32(exception);
 			if (magic != 0x1cb5c415) {
 				if (exception) {
@@ -8455,7 +8883,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-			stream.writeString(hash);
+			stream.writeInt32(hash);
 			stream.writeInt32(0x1cb5c415);
 			int count = sets.size();
 			stream.writeInt32(count);
@@ -8465,141 +8893,8 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
-	public static class TL_messages_allStickers_old extends TL_messages_allStickers {
-		public static int constructor = 0xdcef3102;
-
-
-		public void readParams(AbstractSerializedData stream, boolean exception) {
-			hash = stream.readString(exception);
-			int magic = stream.readInt32(exception);
-			if (magic != 0x1cb5c415) {
-				if (exception) {
-					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-				}
-				return;
-			}
-			int count = stream.readInt32(exception);
-			for (int a = 0; a < count; a++) {
-				TL_stickerPack object = TL_stickerPack.TLdeserialize(stream, stream.readInt32(exception), exception);
-				if (object == null) {
-					return;
-				}
-				packs.add(object);
-			}
-			magic = stream.readInt32(exception);
-			if (magic != 0x1cb5c415) {
-				if (exception) {
-					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-				}
-				return;
-			}
-			count = stream.readInt32(exception);
-			for (int a = 0; a < count; a++) {
-				Document object = Document.TLdeserialize(stream, stream.readInt32(exception), exception);
-				if (object == null) {
-					return;
-				}
-				documents.add(object);
-			}
-		}
-
-		public void serializeToStream(AbstractSerializedData stream) {
-			stream.writeInt32(constructor);
-			stream.writeString(hash);
-			stream.writeInt32(0x1cb5c415);
-			int count = packs.size();
-			stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-				packs.get(a).serializeToStream(stream);
-			}
-			stream.writeInt32(0x1cb5c415);
-			count = documents.size();
-			stream.writeInt32(count);
-			for (int a = 0; a < count; a++) {
-				documents.get(a).serializeToStream(stream);
-			}
-		}
-	}
-
-	public static class TL_messages_allStickers_old2 extends TL_messages_allStickers {
-		public static int constructor = 0x5ce352ec;
-
-
-		public void readParams(AbstractSerializedData stream, boolean exception) {
-			hash = stream.readString(exception);
-			int magic = stream.readInt32(exception);
-			if (magic != 0x1cb5c415) {
-				if (exception) {
-					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-				}
-				return;
-			}
-			int count = stream.readInt32(exception);
-			for (int a = 0; a < count; a++) {
-				TL_stickerPack object = TL_stickerPack.TLdeserialize(stream, stream.readInt32(exception), exception);
-				if (object == null) {
-					return;
-				}
-				packs.add(object);
-			}
-			magic = stream.readInt32(exception);
-			if (magic != 0x1cb5c415) {
-				if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-				}
-				return;
-			}
-			count = stream.readInt32(exception);
-			for (int a = 0; a < count; a++) {
-                StickerSet object = StickerSet.TLdeserialize(stream, stream.readInt32(exception), exception);
-				if (object == null) {
-					return;
-				}
-				sets.add(object);
-			}
-			magic = stream.readInt32(exception);
-			if (magic != 0x1cb5c415) {
-				if (exception) {
-					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-				}
-				return;
-			}
-			count = stream.readInt32(exception);
-			for (int a = 0; a < count; a++) {
-				Document object = Document.TLdeserialize(stream, stream.readInt32(exception), exception);
-				if (object == null) {
-					return;
-				}
-				documents.add(object);
-			}
-		}
-
-		public void serializeToStream(AbstractSerializedData stream) {
-			stream.writeInt32(constructor);
-			stream.writeString(hash);
-			stream.writeInt32(0x1cb5c415);
-			int count = packs.size();
-			stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-				packs.get(a).serializeToStream(stream);
-			}
-			stream.writeInt32(0x1cb5c415);
-			count = sets.size();
-			stream.writeInt32(count);
-			for (int a = 0; a < count; a++) {
-				sets.get(a).serializeToStream(stream);
-			}
-			stream.writeInt32(0x1cb5c415);
-			count = documents.size();
-			stream.writeInt32(count);
-			for (int a = 0; a < count; a++) {
-				documents.get(a).serializeToStream(stream);
-			}
-		}
-	}
-
-	public static class TL_messages_allStickersNotModified extends messages_AllStickers {
-		public static int constructor = 0xe86602c3;
+	public static class TL_messages_allStickersNotModified extends messages_AllStickers {
+		public static int constructor = 0xe86602c3;
 
 
 		public void serializeToStream(AbstractSerializedData stream) {
@@ -8890,7 +9185,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
     }
 
-    public static class TL_decryptedMessageActionNoop extends DecryptedMessageAction {
+	public static class TL_decryptedMessageActionNoop extends DecryptedMessageAction {
 		public static int constructor = 0xa82fdd63;
 
 
@@ -8974,8 +9269,8 @@ public static UserProfilePhoto TLdeserialize(AbstractSerializedData stream, int
 			switch(constructor) {
 				case 0x4f11bae1:
 					result = new TL_userProfilePhotoEmpty();
-                    break;
-                case 0xd559d8c8:
+					break;
+				case 0xd559d8c8:
                     result = new TL_userProfilePhoto();
 					break;
 				case 0x990d1493:
@@ -9194,11 +9489,11 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
             offset = stream.readInt32(exception);
-            length = stream.readInt32(exception);
+			length = stream.readInt32(exception);
         }
 
         public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			stream.writeInt32(offset);
 			stream.writeInt32(length);
 		}
@@ -9313,7 +9608,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
             user_id = stream.readInt32(exception);
             date = stream.readInt32(exception);
 			caption = stream.readString(exception);
-            geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
+			geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
 			int magic = stream.readInt32(exception);
 			if (magic != 0x1cb5c415) {
 				if (exception) {
@@ -9354,7 +9649,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
             id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
+			access_hash = stream.readInt64(exception);
 			date = stream.readInt32(exception);
 			int magic = stream.readInt32(exception);
 			if (magic != 0x1cb5c415) {
@@ -9375,10 +9670,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt64(id);
+			stream.writeInt64(id);
 			stream.writeInt64(access_hash);
 			stream.writeInt32(date);
-            stream.writeInt32(0x1cb5c415);
+			stream.writeInt32(0x1cb5c415);
             int count = sizes.size();
 			stream.writeInt32(count);
 			for (int a = 0; a < count; a++) {
@@ -9438,7 +9733,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt64(exception);
 		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt64(id);
 		}
@@ -9449,7 +9744,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
+			id = stream.readInt32(exception);
             access_hash = stream.readInt64(exception);
 			date = stream.readInt32(exception);
 			admin_id = stream.readInt32(exception);
@@ -9487,7 +9782,7 @@ public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
 			stream.writeInt32(id);
 			stream.writeInt64(access_hash);
-            stream.writeInt32(date);
+			stream.writeInt32(date);
 			stream.writeInt32(admin_id);
 			stream.writeInt32(participant_id);
 			stream.writeByteArray(g_a);
@@ -9504,13 +9799,13 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			date = stream.readInt32(exception);
 			admin_id = stream.readInt32(exception);
             participant_id = stream.readInt32(exception);
-            g_a_or_b = stream.readByteArray(exception);
+			g_a_or_b = stream.readByteArray(exception);
 			key_fingerprint = stream.readInt64(exception);
         }
 
 		public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt32(id);
+			stream.writeInt32(id);
 			stream.writeInt64(access_hash);
 			stream.writeInt32(date);
 			stream.writeInt32(admin_id);
@@ -9525,7 +9820,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
+			id = stream.readInt32(exception);
 			access_hash = stream.readInt64(exception);
 			date = stream.readInt32(exception);
 			admin_id = stream.readInt32(exception);
@@ -9537,13 +9832,13 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt32(id);
+			stream.writeInt32(id);
 			stream.writeInt64(access_hash);
 			stream.writeInt32(date);
 			stream.writeInt32(admin_id);
 			stream.writeInt32(participant_id);
 			stream.writeByteArray(g_a_or_b);
-            stream.writeByteArray(nonce);
+			stream.writeByteArray(nonce);
 			stream.writeInt64(key_fingerprint);
 		}
 	}
@@ -9569,7 +9864,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt32(exception);
 			access_hash = stream.readInt64(exception);
-            date = stream.readInt32(exception);
+			date = stream.readInt32(exception);
 			admin_id = stream.readInt32(exception);
 			participant_id = stream.readInt32(exception);
 		}
@@ -9688,7 +9983,7 @@ public static TL_contact TLdeserialize(AbstractSerializedData stream, int constr
 				}
 			}
             TL_contact result = new TL_contact();
-            result.readParams(stream, exception);
+			result.readParams(stream, exception);
 			return result;
 		}
 
@@ -9705,7 +10000,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 	}
 
 	public static class TL_config extends TLObject {
-		public static int constructor = 0x4e32b894;
+		public static int constructor = 0x6cb6e65e;
 
 		public int date;
 		public int expires;
@@ -9713,7 +10008,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public int this_dc;
 		public ArrayList<TL_dcOption> dc_options = new ArrayList<>();
 		public int chat_size_max;
-		public int broadcast_size_max;
+		public int megagroup_size_max;
 		public int forwarded_count_max;
 		public int online_update_period_ms;
 		public int offline_blur_timeout_ms;
@@ -9732,7 +10027,7 @@ public static TL_config TLdeserialize(AbstractSerializedData stream, int constru
 					throw new RuntimeException(String.format("can't parse magic %x in TL_config", constructor));
 				} else {
 					return null;
-                }
+				}
 			}
 			TL_config result = new TL_config();
 			result.readParams(stream, exception);
@@ -9760,11 +10055,11 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 				dc_options.add(object);
 			}
 			chat_size_max = stream.readInt32(exception);
-            broadcast_size_max = stream.readInt32(exception);
+			megagroup_size_max = stream.readInt32(exception);
 			forwarded_count_max = stream.readInt32(exception);
 			online_update_period_ms = stream.readInt32(exception);
 			offline_blur_timeout_ms = stream.readInt32(exception);
-            offline_idle_timeout_ms = stream.readInt32(exception);
+			offline_idle_timeout_ms = stream.readInt32(exception);
 			online_cloud_timeout_ms = stream.readInt32(exception);
 			notify_cloud_delay_ms = stream.readInt32(exception);
 			notify_default_delay_ms = stream.readInt32(exception);
@@ -9791,7 +10086,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt32(date);
-            stream.writeInt32(expires);
+			stream.writeInt32(expires);
 			stream.writeBool(test_mode);
 			stream.writeInt32(this_dc);
 			stream.writeInt32(0x1cb5c415);
@@ -9801,7 +10096,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 				dc_options.get(a).serializeToStream(stream);
 			}
 			stream.writeInt32(chat_size_max);
-			stream.writeInt32(broadcast_size_max);
+			stream.writeInt32(megagroup_size_max);
 			stream.writeInt32(forwarded_count_max);
 			stream.writeInt32(online_update_period_ms);
 			stream.writeInt32(offline_blur_timeout_ms);
@@ -9858,8 +10153,8 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt64(id);
 			stream.writeInt64(access_hash);
-        }
-    }
+		}
+	}
 
     public static class TL_inputAudioEmpty extends InputAudio {
 		public static int constructor = 0xd95adc84;
@@ -9978,8 +10273,8 @@ public static InputChannel TLdeserialize(AbstractSerializedData stream, int cons
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
-        }
-    }
+		}
+	}
 
     public static class TL_inputChannel extends InputChannel {
         public static int constructor = 0xafeb712e;
@@ -9988,14 +10283,14 @@ public void serializeToStream(AbstractSerializedData stream) {
         public void readParams(AbstractSerializedData stream, boolean exception) {
             channel_id = stream.readInt32(exception);
             access_hash = stream.readInt64(exception);
-        }
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
             stream.writeInt32(channel_id);
             stream.writeInt64(access_hash);
-        }
-    }
+		}
+	}
 
     public static class TL_messageRange extends TLObject {
         public static int constructor = 0xae30253;
@@ -10065,346 +10360,359 @@ public void serializeToStream(AbstractSerializedData stream) {
         }
     }
 
-    public static class updates_ChannelDifference extends TLObject {
-        public int flags;
-        public int pts;
-        public int timeout;
-        public ArrayList<Message> new_messages = new ArrayList<>();
-        public ArrayList<Update> other_updates = new ArrayList<>();
-        public ArrayList<Chat> chats = new ArrayList<>();
-        public ArrayList<User> users = new ArrayList<>();
-        public int top_message;
-        public int top_important_message;
-        public int read_inbox_max_id;
-        public int unread_count;
-        public int unread_important_count;
-        public ArrayList<Message> messages = new ArrayList<>();
+	public static class updates_ChannelDifference extends TLObject {
+		public int flags;
+		public boolean isFinal;
+		public int pts;
+		public int timeout;
+		public ArrayList<Message> new_messages = new ArrayList<>();
+		public ArrayList<Update> other_updates = new ArrayList<>();
+		public ArrayList<Chat> chats = new ArrayList<>();
+		public ArrayList<User> users = new ArrayList<>();
+		public int top_message;
+		public int top_important_message;
+		public int read_inbox_max_id;
+		public int unread_count;
+		public int unread_important_count;
+		public ArrayList<Message> messages = new ArrayList<>();
 
-        public static updates_ChannelDifference TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-            updates_ChannelDifference result = null;
-            switch(constructor) {
-                case 0x3e11affb:
-                    result = new TL_updates_channelDifferenceEmpty();
-                    break;
-                case 0x2064674e:
-                    result = new TL_updates_channelDifference();
-                    break;
-                case 0x5e167646:
-                    result = new TL_updates_channelDifferenceTooLong();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in updates_ChannelDifference", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
+		public static updates_ChannelDifference TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			updates_ChannelDifference result = null;
+			switch(constructor) {
+				case 0x3e11affb:
+					result = new TL_updates_channelDifferenceEmpty();
+					break;
+				case 0x2064674e:
+					result = new TL_updates_channelDifference();
+					break;
+				case 0x5e167646:
+					result = new TL_updates_channelDifferenceTooLong();
+					break;
+			}
+			if (result == null && exception) {
+				throw new RuntimeException(String.format("can't parse magic %x in updates_ChannelDifference", constructor));
+			}
+			if (result != null) {
+				result.readParams(stream, exception);
+			}
+			return result;
+		}
+	}
 
-    public static class TL_updates_channelDifferenceEmpty extends updates_ChannelDifference {
-        public static int constructor = 0x3e11affb;
+	public static class TL_updates_channelDifferenceEmpty extends updates_ChannelDifference {
+		public static int constructor = 0x3e11affb;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            pts = stream.readInt32(exception);
-            if ((flags & 2) != 0) {
-                timeout = stream.readInt32(exception);
-            }
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			isFinal = (flags & 1) != 0;
+			pts = stream.readInt32(exception);
+			if ((flags & 2) != 0) {
+				timeout = stream.readInt32(exception);
+			}
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(pts);
-            if ((flags & 2) != 0) {
-                stream.writeInt32(timeout);
-            }
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = isFinal ? (flags | 1) : (flags &~ 1);
+			stream.writeInt32(flags);
+			stream.writeInt32(pts);
+			if ((flags & 2) != 0) {
+				stream.writeInt32(timeout);
+			}
+		}
+	}
 
-    public static class TL_updates_channelDifference extends updates_ChannelDifference {
-        public static int constructor = 0x2064674e;
+	public static class TL_updates_channelDifference extends updates_ChannelDifference {
+		public static int constructor = 0x2064674e;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            pts = stream.readInt32(exception);
-            if ((flags & 2) != 0) {
-                timeout = stream.readInt32(exception);
-            }
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                new_messages.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                other_updates.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                chats.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                users.add(object);
-            }
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			isFinal = (flags & 1) != 0;
+			pts = stream.readInt32(exception);
+			if ((flags & 2) != 0) {
+				timeout = stream.readInt32(exception);
+			}
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				new_messages.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				other_updates.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				chats.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				users.add(object);
+			}
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(pts);
-            if ((flags & 2) != 0) {
-                stream.writeInt32(timeout);
-            }
-            stream.writeInt32(0x1cb5c415);
-            int count = new_messages.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                new_messages.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = other_updates.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                other_updates.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = chats.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                chats.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = users.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                users.get(a).serializeToStream(stream);
-            }
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = isFinal ? (flags | 1) : (flags &~ 1);
+			stream.writeInt32(flags);
+			stream.writeInt32(pts);
+			if ((flags & 2) != 0) {
+				stream.writeInt32(timeout);
+			}
+			stream.writeInt32(0x1cb5c415);
+			int count = new_messages.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				new_messages.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = other_updates.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				other_updates.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = chats.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				chats.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = users.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				users.get(a).serializeToStream(stream);
+			}
+		}
+	}
 
-    public static class TL_updates_channelDifferenceTooLong extends updates_ChannelDifference {
-        public static int constructor = 0x5e167646;
+	public static class TL_updates_channelDifferenceTooLong extends updates_ChannelDifference {
+		public static int constructor = 0x5e167646;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            pts = stream.readInt32(exception);
-            if ((flags & 2) != 0) {
-                timeout = stream.readInt32(exception);
-            }
-            top_message = stream.readInt32(exception);
-            top_important_message = stream.readInt32(exception);
-            read_inbox_max_id = stream.readInt32(exception);
-            unread_count = stream.readInt32(exception);
-            unread_important_count = stream.readInt32(exception);
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                messages.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                chats.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                users.add(object);
-            }
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(pts);
-            if ((flags & 2) != 0) {
-                stream.writeInt32(timeout);
-            }
-            stream.writeInt32(top_message);
-            stream.writeInt32(top_important_message);
-            stream.writeInt32(read_inbox_max_id);
-            stream.writeInt32(unread_count);
-            stream.writeInt32(unread_important_count);
-            stream.writeInt32(0x1cb5c415);
-            int count = messages.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                messages.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = chats.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                chats.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = users.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                users.get(a).serializeToStream(stream);
-            }
-        }
-    }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			isFinal = (flags & 1) != 0;
+			pts = stream.readInt32(exception);
+			if ((flags & 2) != 0) {
+				timeout = stream.readInt32(exception);
+			}
+			top_message = stream.readInt32(exception);
+			top_important_message = stream.readInt32(exception);
+			read_inbox_max_id = stream.readInt32(exception);
+			unread_count = stream.readInt32(exception);
+			unread_important_count = stream.readInt32(exception);
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Message object = Message.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				messages.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				chats.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				users.add(object);
+			}
+		}
 
-    public static class ChannelMessagesFilter extends TLObject {
-        public int flags;
-        public ArrayList<TL_messageRange> ranges = new ArrayList<>();
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = isFinal ? (flags | 1) : (flags &~ 1);
+			stream.writeInt32(flags);
+			stream.writeInt32(pts);
+			if ((flags & 2) != 0) {
+				stream.writeInt32(timeout);
+			}
+			stream.writeInt32(top_message);
+			stream.writeInt32(top_important_message);
+			stream.writeInt32(read_inbox_max_id);
+			stream.writeInt32(unread_count);
+			stream.writeInt32(unread_important_count);
+			stream.writeInt32(0x1cb5c415);
+			int count = messages.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				messages.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = chats.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				chats.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = users.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				users.get(a).serializeToStream(stream);
+			}
+		}
+	}
 
-        public static ChannelMessagesFilter TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-            ChannelMessagesFilter result = null;
-            switch(constructor) {
-                case 0x94d42ee7:
-                    result = new TL_channelMessagesFilterEmpty();
-                    break;
-                case 0xcd77d957:
-                    result = new TL_channelMessagesFilter();
-                    break;
-                case 0xfa01232e:
-                    result = new TL_channelMessagesFilterCollapsed();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in ChannelMessagesFilter", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
+	public static class ChannelMessagesFilter extends TLObject {
+		public int flags;
+		public boolean important_only;
+		public boolean exclude_new_messages;
+		public ArrayList<TL_messageRange> ranges = new ArrayList<>();
 
-    public static class TL_channelMessagesFilterEmpty extends ChannelMessagesFilter {
-        public static int constructor = 0x94d42ee7;
+		public static ChannelMessagesFilter TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			ChannelMessagesFilter result = null;
+			switch(constructor) {
+				case 0x94d42ee7:
+					result = new TL_channelMessagesFilterEmpty();
+					break;
+				case 0xcd77d957:
+					result = new TL_channelMessagesFilter();
+					break;
+				case 0xfa01232e:
+					result = new TL_channelMessagesFilterCollapsed();
+					break;
+			}
+			if (result == null && exception) {
+				throw new RuntimeException(String.format("can't parse magic %x in ChannelMessagesFilter", constructor));
+			}
+			if (result != null) {
+				result.readParams(stream, exception);
+			}
+			return result;
+		}
+	}
 
+	public static class TL_channelMessagesFilterEmpty extends ChannelMessagesFilter {
+		public static int constructor = 0x94d42ee7;
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
 
-    public static class TL_channelMessagesFilter extends ChannelMessagesFilter {
-        public static int constructor = 0xcd77d957;
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
 
+	public static class TL_channelMessagesFilter extends ChannelMessagesFilter {
+		public static int constructor = 0xcd77d957;
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                TL_messageRange object = TL_messageRange.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                ranges.add(object);
-            }
-        }
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(0x1cb5c415);
-            int count = ranges.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                ranges.get(a).serializeToStream(stream);
-            }
-        }
-    }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			important_only = (flags & 1) != 0;
+			exclude_new_messages = (flags & 2) != 0;
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				TL_messageRange object = TL_messageRange.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				ranges.add(object);
+			}
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = important_only ? (flags | 1) : (flags &~ 1);
+			flags = exclude_new_messages ? (flags | 2) : (flags &~ 2);
+			stream.writeInt32(flags);
+			stream.writeInt32(0x1cb5c415);
+			int count = ranges.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				ranges.get(a).serializeToStream(stream);
+			}
+		}
+	}
 
-    public static class TL_channelMessagesFilterCollapsed extends ChannelMessagesFilter {
-        public static int constructor = 0xfa01232e;
+	public static class TL_channelMessagesFilterCollapsed extends ChannelMessagesFilter {
+		public static int constructor = 0xfa01232e;
 
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
 
     public static class TL_contacts_resolvedPeer extends TLObject {
         public static int constructor = 0x7f077ad9;
@@ -10422,7 +10730,7 @@ public static TL_contacts_resolvedPeer TLdeserialize(AbstractSerializedData stre
                 }
             }
             TL_contacts_resolvedPeer result = new TL_contacts_resolvedPeer();
-            result.readParams(stream, exception);
+			result.readParams(stream, exception);
             return result;
         }
 
@@ -10784,11 +11092,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 	public static class ChatParticipants extends TLObject {
 		public int flags;
 		public int chat_id;
-		public TL_chatParticipant self_participant;
-		public int admin_id;
-		public ArrayList<TL_chatParticipant> participants = new ArrayList<>();
+		public ChatParticipant self_participant;
+		public ArrayList<ChatParticipant> participants = new ArrayList<>();
 		public int version;
-		public int channel_id;
+		public int admin_id;
 
 		public static ChatParticipants TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
 			ChatParticipants result = null;
@@ -10796,9 +11103,12 @@ public static ChatParticipants TLdeserialize(AbstractSerializedData stream, int
 				case 0xfc900c2b:
 					result = new TL_chatParticipantsForbidden();
 					break;
-				case 0x7841b415:
+				case 0x3f460fed:
 					result = new TL_chatParticipants();
 					break;
+				case 0x7841b415:
+					result = new TL_chatParticipants_old();
+					break;
 				case 0xfd2bb8a:
 					result = new TL_chatParticipantsForbidden_old();
 					break;
@@ -10821,7 +11131,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
 			chat_id = stream.readInt32(exception);
 			if ((flags & 1) != 0) {
-				self_participant = TL_chatParticipant.TLdeserialize(stream, stream.readInt32(exception), exception);
+				self_participant = ChatParticipant.TLdeserialize(stream, stream.readInt32(exception), exception);
 			}
 		}
 
@@ -10836,6 +11146,43 @@ public void serializeToStream(AbstractSerializedData stream) {
 	}
 
 	public static class TL_chatParticipants extends ChatParticipants {
+		public static int constructor = 0x3f460fed;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			chat_id = stream.readInt32(exception);
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				ChatParticipant object = ChatParticipant.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				participants.add(object);
+			}
+			version = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+			stream.writeInt32(0x1cb5c415);
+			int count = participants.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				participants.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(version);
+		}
+	}
+
+	public static class TL_chatParticipants_old extends TL_chatParticipants {
 		public static int constructor = 0x7841b415;
 
 
@@ -10851,7 +11198,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			}
 			int count = stream.readInt32(exception);
 			for (int a = 0; a < count; a++) {
-				TL_chatParticipant object = TL_chatParticipant.TLdeserialize(stream, stream.readInt32(exception), exception);
+				ChatParticipant object = ChatParticipant.TLdeserialize(stream, stream.readInt32(exception), exception);
 				if (object == null) {
 					return;
 				}
@@ -10868,7 +11215,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			int count = participants.size();
 			stream.writeInt32(count);
 			for (int a = 0; a < count; a++) {
-                participants.get(a).serializeToStream(stream);
+				participants.get(a).serializeToStream(stream);
 			}
 			stream.writeInt32(version);
 		}
@@ -10878,7 +11225,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public static int constructor = 0xfd2bb8a;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
+		public void readParams(AbstractSerializedData stream, boolean exception) {
 			chat_id = stream.readInt32(exception);
 		}
 
@@ -10986,8 +11333,8 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(thumb_w);
 			stream.writeInt32(thumb_h);
 			stream.writeString(file_name);
-            stream.writeString(mime_type);
-            stream.writeInt32(size);
+			stream.writeString(mime_type);
+			stream.writeInt32(size);
 			stream.writeByteArray(key);
 			stream.writeByteArray(iv);
 		}
@@ -11001,9 +11348,9 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt64(exception);
 			access_hash = stream.readInt64(exception);
-            date = stream.readInt32(exception);
+			date = stream.readInt32(exception);
 			mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
+			size = stream.readInt32(exception);
             thumb = PhotoSize.TLdeserialize(stream, stream.readInt32(exception), exception);
 			dc_id = stream.readInt32(exception);
 			int magic = stream.readInt32(exception);
@@ -11047,7 +11394,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
             duration = stream.readInt32(exception);
-            size = stream.readInt32(exception);
+			size = stream.readInt32(exception);
 			key = stream.readByteArray(exception);
 			iv = stream.readByteArray(exception);
 		}
@@ -11066,7 +11413,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
-            lat = stream.readDouble(exception);
+			lat = stream.readDouble(exception);
 			_long = stream.readDouble(exception);
 		}
 
@@ -11083,8 +11430,8 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			duration = stream.readInt32(exception);
-            mime_type = stream.readString(exception);
-            size = stream.readInt32(exception);
+			mime_type = stream.readString(exception);
+			size = stream.readInt32(exception);
 			key = stream.readByteArray(exception);
 			iv = stream.readByteArray(exception);
 		}
@@ -11093,7 +11440,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt32(duration);
             stream.writeString(mime_type);
-            stream.writeInt32(size);
+			stream.writeInt32(size);
 			stream.writeByteArray(key);
 			stream.writeByteArray(iv);
 		}
@@ -11138,7 +11485,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
             phone_number = stream.readString(exception);
-            first_name = stream.readString(exception);
+			first_name = stream.readString(exception);
 			last_name = stream.readString(exception);
 			user_id = stream.readInt32(exception);
 		}
@@ -11146,7 +11493,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeString(phone_number);
-            stream.writeString(first_name);
+			stream.writeString(first_name);
 			stream.writeString(last_name);
 			stream.writeInt32(user_id);
 		}
@@ -11163,7 +11510,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			thumb_h = stream.readInt32(exception);
 			w = stream.readInt32(exception);
 			h = stream.readInt32(exception);
-            size = stream.readInt32(exception);
+			size = stream.readInt32(exception);
 			key = stream.readByteArray(exception);
 			iv = stream.readByteArray(exception);
 		}
@@ -11175,7 +11522,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(thumb_h);
 			stream.writeInt32(w);
             stream.writeInt32(h);
-            stream.writeInt32(size);
+			stream.writeInt32(size);
 			stream.writeByteArray(key);
 			stream.writeByteArray(iv);
 		}
@@ -11199,7 +11546,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			stream.writeByteArray(thumb);
 			stream.writeInt32(thumb_w);
 			stream.writeInt32(thumb_h);
@@ -11212,35 +11559,79 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
-	public static class TL_chatParticipant extends TLObject {
-		public static int constructor = 0xc8d7493e;
-
+	public static class ChatParticipant extends TLObject {
 		public int user_id;
 		public int inviter_id;
 		public int date;
 
-		public static TL_chatParticipant TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-			if (TL_chatParticipant.constructor != constructor) {
-				if (exception) {
-					throw new RuntimeException(String.format("can't parse magic %x in TL_chatParticipant", constructor));
-				} else {
-					return null;
-				}
+		public static ChatParticipant TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			ChatParticipant result = null;
+			switch(constructor) {
+				case 0xc8d7493e:
+					result = new TL_chatParticipant();
+					break;
+				case 0xda13538a:
+					result = new TL_chatParticipantCreator();
+					break;
+				case 0xe2d6e436:
+					result = new TL_chatParticipantAdmin();
+					break;
+			}
+			if (result == null && exception) {
+				throw new RuntimeException(String.format("can't parse magic %x in ChatParticipant", constructor));
+			}
+			if (result != null) {
+				result.readParams(stream, exception);
 			}
-			TL_chatParticipant result = new TL_chatParticipant();
-			result.readParams(stream, exception);
 			return result;
 		}
+	}
+
+	public static class TL_chatParticipant extends ChatParticipant {
+		public static int constructor = 0xc8d7493e;
+
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			user_id = stream.readInt32(exception);
-            inviter_id = stream.readInt32(exception);
-            date = stream.readInt32(exception);
+			inviter_id = stream.readInt32(exception);
+			date = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(user_id);
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+			stream.writeInt32(inviter_id);
+			stream.writeInt32(date);
+		}
+	}
+
+	public static class TL_chatParticipantCreator extends ChatParticipant {
+		public static int constructor = 0xda13538a;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
+		}
+	}
+
+	public static class TL_chatParticipantAdmin extends ChatParticipant {
+		public static int constructor = 0xe2d6e436;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user_id = stream.readInt32(exception);
+			inviter_id = stream.readInt32(exception);
+			date = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(user_id);
 			stream.writeInt32(inviter_id);
 			stream.writeInt32(date);
 		}
@@ -11248,14 +11639,26 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 	public static class Chat extends TLObject {
 		public int flags;
+		public boolean creator;
+		public boolean kicked;
+		public boolean admins_enabled;
+		public boolean admin;
+		public boolean deactivated;
 		public int id;
 		public String title;
 		public ChatPhoto photo;
 		public int participants_count;
 		public int date;
 		public int version;
+		public boolean editor;
+		public boolean moderator;
+		public boolean broadcast;
+		public boolean verified;
+		public boolean megagroup;
+		public boolean left;
 		public long access_hash;
 		public String username;
+		public InputChannel migrated_to;
 		public String address;
 		public String venue;
 		public GeoPoint geo;
@@ -11264,24 +11667,27 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public static Chat TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
 			Chat result = null;
 			switch(constructor) {
-                case 0x7312bc48:
-					result = new TL_chat();
+				case 0x7312bc48:
+					result = new TL_chat_old2();
 					break;
 				case 0x7328bdb:
 					result = new TL_chatForbidden();
 					break;
-                case 0x678e9587:
-                    result = new TL_channel();
-                    break;
-                case 0xfb0ccc41:
+				case 0x678e9587:
+					result = new TL_channel();
+					break;
+				case 0xfb0ccc41:
 					result = new TL_chatForbidden_old();
 					break;
-				case 0x75eaea5a:
-					result = new TL_geoChat();
+				case 0xd91cdd54:
+					result = new TL_chat();
 					break;
 				case 0x9ba2d800:
 					result = new TL_chatEmpty();
 					break;
+				case 0x75eaea5a:
+					result = new TL_geoChat();
+					break;
 				case 0x2d85832c:
 					result = new TL_channelForbidden();
 					break;
@@ -11299,95 +11705,164 @@ public static Chat TLdeserialize(AbstractSerializedData stream, int constructor,
 		}
 	}
 
-	public static class TL_chat extends Chat {
+	public static class TL_chat_old2 extends TL_chat {
 		public static int constructor = 0x7312bc48;
 
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			creator = (flags & 1) != 0;
+			kicked = (flags & 2) != 0;
+			left = (flags & 4) != 0;
+			admins_enabled = (flags & 8) != 0;
+			admin = (flags & 16) != 0;
+			deactivated = (flags & 32) != 0;
+			id = stream.readInt32(exception);
+			title = stream.readString(exception);
+			photo = ChatPhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+			participants_count = stream.readInt32(exception);
+			date = stream.readInt32(exception);
+			version = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = creator ? (flags | 1) : (flags &~ 1);
+			flags = kicked ? (flags | 2) : (flags &~ 2);
+			flags = left ? (flags | 4) : (flags &~ 4);
+			flags = admins_enabled ? (flags | 8) : (flags &~ 8);
+			flags = admin ? (flags | 16) : (flags &~ 16);
+			flags = deactivated ? (flags | 32) : (flags &~ 32);
+			stream.writeInt32(flags);
+			stream.writeInt32(id);
+			stream.writeString(title);
+			photo.serializeToStream(stream);
+			stream.writeInt32(participants_count);
+			stream.writeInt32(date);
+			stream.writeInt32(version);
+		}
+	}
+
+	public static class TL_chatForbidden extends Chat {
+		public static int constructor = 0x7328bdb;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			id = stream.readInt32(exception);
+			title = stream.readString(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(id);
+			stream.writeString(title);
+		}
+	}
+
+	public static class TL_channel extends Chat {
+		public static int constructor = 0x678e9587;
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
+			flags = stream.readInt32(exception);
+			creator = (flags & 1) != 0;
+			kicked = (flags & 2) != 0;
+			left = (flags & 4) != 0;
+			editor = (flags & 8) != 0;
+			moderator = (flags & 16) != 0;
+			broadcast = (flags & 32) != 0;
+			verified = (flags & 128) != 0;
+			megagroup = (flags & 256) != 0;
 			id = stream.readInt32(exception);
+			access_hash = stream.readInt64(exception);
 			title = stream.readString(exception);
+			if ((flags & 64) != 0) {
+				username = stream.readString(exception);
+			}
 			photo = ChatPhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-			participants_count = stream.readInt32(exception);
 			date = stream.readInt32(exception);
 			version = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = creator ? (flags | 1) : (flags &~ 1);
+			flags = kicked ? (flags | 2) : (flags &~ 2);
+			flags = left ? (flags | 4) : (flags &~ 4);
+			flags = editor ? (flags | 8) : (flags &~ 8);
+			flags = moderator ? (flags | 16) : (flags &~ 16);
+			flags = broadcast ? (flags | 32) : (flags &~ 32);
+			flags = verified ? (flags | 128) : (flags &~ 128);
+			flags = megagroup ? (flags | 256) : (flags &~ 256);
 			stream.writeInt32(flags);
-            stream.writeInt32(id);
+			stream.writeInt32(id);
+			stream.writeInt64(access_hash);
 			stream.writeString(title);
+			if ((flags & 64) != 0) {
+				stream.writeString(username);
+			}
 			photo.serializeToStream(stream);
-			stream.writeInt32(participants_count);
 			stream.writeInt32(date);
 			stream.writeInt32(version);
 		}
 	}
 
-	public static class TL_chatForbidden extends Chat {
-		public static int constructor = 0x7328bdb;
+	public static class TL_chatForbidden_old extends TL_chatForbidden {
+		public static int constructor = 0xfb0ccc41;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
+		public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt32(exception);
 			title = stream.readString(exception);
+			date = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			stream.writeInt32(id);
 			stream.writeString(title);
+			stream.writeInt32(date);
 		}
 	}
 
-    public static class TL_channel extends Chat {
-        public static int constructor = 0x678e9587;
-
-
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            id = stream.readInt32(exception);
-            access_hash = stream.readInt64(exception);
-            title = stream.readString(exception);
-            if ((flags & 64) != 0) {
-                username = stream.readString(exception);
-            }
-            photo = ChatPhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
-            date = stream.readInt32(exception);
-            version = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(id);
-            stream.writeInt64(access_hash);
-            stream.writeString(title);
-            if ((flags & 64) != 0) {
-                stream.writeString(username);
-            }
-            photo.serializeToStream(stream);
-            stream.writeInt32(date);
-            stream.writeInt32(version);
-        }
-    }
-
-	public static class TL_chatForbidden_old extends TL_chatForbidden {
-		public static int constructor = 0xfb0ccc41;
-
+	public static class TL_chat extends Chat {
+		public static int constructor = 0xd91cdd54;
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			creator = (flags & 1) != 0;
+			kicked = (flags & 2) != 0;
+			left = (flags & 4) != 0;
+			admins_enabled = (flags & 8) != 0;
+			admin = (flags & 16) != 0;
+			deactivated = (flags & 32) != 0;
 			id = stream.readInt32(exception);
 			title = stream.readString(exception);
+			photo = ChatPhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+			participants_count = stream.readInt32(exception);
 			date = stream.readInt32(exception);
-        }
+			version = stream.readInt32(exception);
+			if ((flags & 64) != 0) {
+				migrated_to = InputChannel.TLdeserialize(stream, stream.readInt32(exception), exception);
+			}
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = creator ? (flags | 1) : (flags &~ 1);
+			flags = kicked ? (flags | 2) : (flags &~ 2);
+			flags = left ? (flags | 4) : (flags &~ 4);
+			flags = admins_enabled ? (flags | 8) : (flags &~ 8);
+			flags = admin ? (flags | 16) : (flags &~ 16);
+			flags = deactivated ? (flags | 32) : (flags &~ 32);
+			stream.writeInt32(flags);
 			stream.writeInt32(id);
 			stream.writeString(title);
+			photo.serializeToStream(stream);
+			stream.writeInt32(participants_count);
 			stream.writeInt32(date);
+			stream.writeInt32(version);
+			if ((flags & 64) != 0) {
+				migrated_to.serializeToStream(stream);
+			}
 		}
 	}
 
@@ -11402,9 +11877,9 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			address = stream.readString(exception);
 			venue = stream.readString(exception);
 			geo = GeoPoint.TLdeserialize(stream, stream.readInt32(exception), exception);
-            photo = ChatPhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
+			photo = ChatPhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
 			participants_count = stream.readInt32(exception);
-            date = stream.readInt32(exception);
+			date = stream.readInt32(exception);
 			checked_in = stream.readBool(exception);
 			version = stream.readInt32(exception);
 		}
@@ -11418,7 +11893,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeString(venue);
 			geo.serializeToStream(stream);
 			photo.serializeToStream(stream);
-            stream.writeInt32(participants_count);
+			stream.writeInt32(participants_count);
 			stream.writeInt32(date);
 			stream.writeBool(checked_in);
 			stream.writeInt32(version);
@@ -11430,14 +11905,14 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
-            id = stream.readInt32(exception);
+			id = stream.readInt32(exception);
 			access_hash = stream.readInt64(exception);
 			title = stream.readString(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(id);
+			stream.writeInt32(constructor);
+			stream.writeInt32(id);
 			stream.writeInt64(access_hash);
 			stream.writeString(title);
 		}
@@ -11446,14 +11921,13 @@ public void serializeToStream(AbstractSerializedData stream) {
 	public static class TL_chat_old extends TL_chat {
 		public static int constructor = 0x6e9c9bc7;
 
-
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			id = stream.readInt32(exception);
 			title = stream.readString(exception);
 			photo = ChatPhoto.TLdeserialize(stream, stream.readInt32(exception), exception);
 			participants_count = stream.readInt32(exception);
 			date = stream.readInt32(exception);
-            flags |= stream.readBool(exception) ? CHAT_FLAG_USER_LEFT : 0;
+			left = stream.readBool(exception);
 			version = stream.readInt32(exception);
 		}
 
@@ -11462,9 +11936,9 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(id);
 			stream.writeString(title);
 			photo.serializeToStream(stream);
-            stream.writeInt32(participants_count);
+			stream.writeInt32(participants_count);
 			stream.writeInt32(date);
-			stream.writeBool((flags & CHAT_FLAG_USER_LEFT) != 0);
+			stream.writeBool(left);
 			stream.writeInt32(version);
 		}
 	}
@@ -11475,6 +11949,9 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public String title;
 		public String short_name;
 		public int flags;
+		public boolean installed;
+		public boolean disabled;
+		public boolean official;
 		public int count;
 		public int hash;
 
@@ -11524,21 +12001,27 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
-            id = stream.readInt64(exception);
-            access_hash = stream.readInt64(exception);
-            title = stream.readString(exception);
-            short_name = stream.readString(exception);
+			installed = (flags & 1) != 0;
+			disabled = (flags & 2) != 0;
+			official = (flags & 4) != 0;
+			id = stream.readInt64(exception);
+			access_hash = stream.readInt64(exception);
+			title = stream.readString(exception);
+			short_name = stream.readString(exception);
 			count = stream.readInt32(exception);
 			hash = stream.readInt32(exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt64(id);
-            stream.writeInt64(access_hash);
-            stream.writeString(title);
-            stream.writeString(short_name);
+			flags = installed ? (flags | 1) : (flags &~ 1);
+			flags = disabled ? (flags | 2) : (flags &~ 2);
+			flags = official ? (flags | 4) : (flags &~ 4);
+			stream.writeInt32(flags);
+			stream.writeInt64(id);
+			stream.writeInt64(access_hash);
+			stream.writeString(title);
+			stream.writeString(short_name);
 			stream.writeInt32(count);
 			stream.writeInt32(hash);
 		}
@@ -12379,467 +12862,489 @@ public static TL_userFull TLdeserialize(AbstractSerializedData stream, int const
 					return null;
 				}
 			}
-			TL_userFull result = new TL_userFull();
-			result.readParams(stream, exception);
-			return result;
-		}
-
-		public void readParams(AbstractSerializedData stream, boolean exception) {
-			user = User.TLdeserialize(stream, stream.readInt32(exception), exception);
-            link = TL_contacts_link.TLdeserialize(stream, stream.readInt32(exception), exception);
-			profile_photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
-            notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
-            blocked = stream.readBool(exception);
-			bot_info = BotInfo.TLdeserialize(stream, stream.readInt32(exception), exception);
+			TL_userFull result = new TL_userFull();
+			result.readParams(stream, exception);
+			return result;
+		}
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			user = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+            link = TL_contacts_link.TLdeserialize(stream, stream.readInt32(exception), exception);
+			profile_photo = Photo.TLdeserialize(stream, stream.readInt32(exception), exception);
+			notify_settings = PeerNotifySettings.TLdeserialize(stream, stream.readInt32(exception), exception);
+            blocked = stream.readBool(exception);
+			bot_info = BotInfo.TLdeserialize(stream, stream.readInt32(exception), exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+            user.serializeToStream(stream);
+			link.serializeToStream(stream);
+            profile_photo.serializeToStream(stream);
+			notify_settings.serializeToStream(stream);
+			stream.writeBool(blocked);
+			bot_info.serializeToStream(stream);
+		}
+	}
+
+	public static class Updates extends TLObject {
+		public ArrayList<Update> updates = new ArrayList<>();
+		public ArrayList<User> users = new ArrayList<>();
+		public ArrayList<Chat> chats = new ArrayList<>();
+		public int date;
+		public int seq;
+		public int flags;
+		public boolean unread;
+		public boolean out;
+		public boolean mentioned;
+		public boolean media_unread;
+		public int id;
+		public int user_id;
+		public String message;
+		public int pts;
+		public int pts_count;
+		public Peer fwd_from_id;
+		public int fwd_date;
+		public int reply_to_msg_id;
+		public ArrayList<MessageEntity> entities = new ArrayList<>();
+		public MessageMedia media;
+		public Update update;
+		public int from_id;
+		public int chat_id;
+		public int seq_start;
+
+		public static Updates TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
+			Updates result = null;
+			switch(constructor) {
+				case 0x74ae4240:
+					result = new TL_updates();
+					break;
+				case 0xf7d91a46:
+					result = new TL_updateShortMessage();
+					break;
+				case 0x11f1331c:
+					result = new TL_updateShortSentMessage();
+					break;
+				case 0x78d4dec1:
+					result = new TL_updateShort();
+					break;
+				case 0xcac7fdd2:
+					result = new TL_updateShortChatMessage();
+					break;
+				case 0x725b04c3:
+					result = new TL_updatesCombined();
+					break;
+				case 0xe317af7e:
+					result = new TL_updatesTooLong();
+					break;
+			}
+			if (result == null && exception) {
+				throw new RuntimeException(String.format("can't parse magic %x in Updates", constructor));
+			}
+			if (result != null) {
+				result.readParams(stream, exception);
+			}
+			return result;
+		}
+	}
+
+	public static class TL_updates extends Updates {
+		public static int constructor = 0x74ae4240;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				updates.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				users.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				chats.add(object);
+			}
+			date = stream.readInt32(exception);
+			seq = stream.readInt32(exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(0x1cb5c415);
+			int count = updates.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				updates.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = users.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				users.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = chats.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				chats.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(date);
+			stream.writeInt32(seq);
+		}
+	}
+
+	public static class TL_updateShortMessage extends Updates {
+		public static int constructor = 0xf7d91a46;
+
+
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
+			id = stream.readInt32(exception);
+			user_id = stream.readInt32(exception);
+			message = stream.readString(exception);
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+			date = stream.readInt32(exception);
+			if ((flags & 4) != 0) {
+				fwd_from_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
+			}
+			if ((flags & 4) != 0) {
+				fwd_date = stream.readInt32(exception);
+			}
+			if ((flags & 8) != 0) {
+				reply_to_msg_id = stream.readInt32(exception);
+			}
+			if ((flags & 128) != 0) {
+				int magic = stream.readInt32(exception);
+				if (magic != 0x1cb5c415) {
+					if (exception) {
+						throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+					}
+					return;
+				}
+				int count = stream.readInt32(exception);
+				for (int a = 0; a < count; a++) {
+					MessageEntity object = MessageEntity.TLdeserialize(stream, stream.readInt32(exception), exception);
+					if (object == null) {
+						return;
+					}
+					entities.add(object);
+				}
+			}
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-            user.serializeToStream(stream);
-			link.serializeToStream(stream);
-            profile_photo.serializeToStream(stream);
-			notify_settings.serializeToStream(stream);
-			stream.writeBool(blocked);
-			bot_info.serializeToStream(stream);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
+			stream.writeInt32(flags);
+			stream.writeInt32(id);
+			stream.writeInt32(user_id);
+			stream.writeString(message);
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+			stream.writeInt32(date);
+			if ((flags & 4) != 0) {
+				fwd_from_id.serializeToStream(stream);
+			}
+			if ((flags & 4) != 0) {
+				stream.writeInt32(fwd_date);
+			}
+			if ((flags & 8) != 0) {
+				stream.writeInt32(reply_to_msg_id);
+			}
+			if ((flags & 128) != 0) {
+				stream.writeInt32(0x1cb5c415);
+				int count = entities.size();
+				stream.writeInt32(count);
+				for (int a = 0; a < count; a++) {
+					entities.get(a).serializeToStream(stream);
+				}
+			}
 		}
 	}
 
-    public static class Updates extends TLObject {
-        public ArrayList<Update> updates = new ArrayList<>();
-        public ArrayList<User> users = new ArrayList<>();
-        public ArrayList<Chat> chats = new ArrayList<>();
-        public int date;
-        public int seq;
-        public int flags;
-        public int id;
-        public int user_id;
-        public String message;
-        public int pts;
-        public int pts_count;
-        public Peer fwd_from_id;
-        public int fwd_date;
-        public int reply_to_msg_id;
-        public ArrayList<MessageEntity> entities = new ArrayList<>();
-        public MessageMedia media;
-        public Update update;
-        public int from_id;
-        public int chat_id;
-        public int seq_start;
-
-        public static Updates TLdeserialize(AbstractSerializedData stream, int constructor, boolean exception) {
-            Updates result = null;
-            switch(constructor) {
-                case 0x74ae4240:
-                    result = new TL_updates();
-                    break;
-                case 0xf7d91a46:
-                    result = new TL_updateShortMessage();
-                    break;
-                case 0x11f1331c:
-                    result = new TL_updateShortSentMessage();
-                    break;
-                case 0x78d4dec1:
-                    result = new TL_updateShort();
-                    break;
-                case 0xcac7fdd2:
-                    result = new TL_updateShortChatMessage();
-                    break;
-                case 0x725b04c3:
-                    result = new TL_updatesCombined();
-                    break;
-                case 0xe317af7e:
-                    result = new TL_updatesTooLong();
-                    break;
-            }
-            if (result == null && exception) {
-                throw new RuntimeException(String.format("can't parse magic %x in Updates", constructor));
-            }
-            if (result != null) {
-                result.readParams(stream, exception);
-            }
-            return result;
-        }
-    }
-
-    public static class TL_updates extends Updates {
-        public static int constructor = 0x74ae4240;
-
-
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                updates.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                users.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                chats.add(object);
-            }
-            date = stream.readInt32(exception);
-            seq = stream.readInt32(exception);
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(0x1cb5c415);
-            int count = updates.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                updates.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = users.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                users.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = chats.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                chats.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(date);
-            stream.writeInt32(seq);
-        }
-    }
-
-    public static class TL_updateShortMessage extends Updates {
-        public static int constructor = 0xf7d91a46;
-
-
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            id = stream.readInt32(exception);
-            user_id = stream.readInt32(exception);
-            message = stream.readString(exception);
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            if ((flags & 4) != 0) {
-                fwd_from_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            }
-            if ((flags & 4) != 0) {
-                fwd_date = stream.readInt32(exception);
-            }
-            if ((flags & 8) != 0) {
-                reply_to_msg_id = stream.readInt32(exception);
-            }
-            if ((flags & 128) != 0) {
-                int magic = stream.readInt32(exception);
-                if (magic != 0x1cb5c415) {
-                    if (exception) {
-                        throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                    }
-                    return;
-                }
-                int count = stream.readInt32(exception);
-                for (int a = 0; a < count; a++) {
-                    MessageEntity object = MessageEntity.TLdeserialize(stream, stream.readInt32(exception), exception);
-                    if (object == null) {
-                        return;
-                    }
-                    entities.add(object);
-                }
-            }
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(id);
-            stream.writeInt32(user_id);
-            stream.writeString(message);
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-            stream.writeInt32(date);
-            if ((flags & 4) != 0) {
-                fwd_from_id.serializeToStream(stream);
-            }
-            if ((flags & 4) != 0) {
-                stream.writeInt32(fwd_date);
-            }
-            if ((flags & 8) != 0) {
-                stream.writeInt32(reply_to_msg_id);
-            }
-            if ((flags & 128) != 0) {
-                stream.writeInt32(0x1cb5c415);
-                int count = entities.size();
-                stream.writeInt32(count);
-                for (int a = 0; a < count; a++) {
-                    entities.get(a).serializeToStream(stream);
-                }
-            }
-        }
-    }
-
-    public static class TL_updateShortSentMessage extends Updates {
-        public static int constructor = 0x11f1331c;
+	public static class TL_updateShortSentMessage extends Updates {
+		public static int constructor = 0x11f1331c;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            id = stream.readInt32(exception);
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            if ((flags & 512) != 0) {
-                media = MessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
-            } else {
-				media = new TL_messageMediaEmpty();
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			id = stream.readInt32(exception);
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+			date = stream.readInt32(exception);
+			if ((flags & 512) != 0) {
+				media = MessageMedia.TLdeserialize(stream, stream.readInt32(exception), exception);
 			}
-            if ((flags & 128) != 0) {
-                int magic = stream.readInt32(exception);
-                if (magic != 0x1cb5c415) {
-                    if (exception) {
-                        throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                    }
-                    return;
-                }
-                int count = stream.readInt32(exception);
-                for (int a = 0; a < count; a++) {
-                    MessageEntity object = MessageEntity.TLdeserialize(stream, stream.readInt32(exception), exception);
-                    if (object == null) {
-                        return;
-                    }
-                    entities.add(object);
-                }
-            }
-        }
+			if ((flags & 128) != 0) {
+				int magic = stream.readInt32(exception);
+				if (magic != 0x1cb5c415) {
+					if (exception) {
+						throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+					}
+					return;
+				}
+				int count = stream.readInt32(exception);
+				for (int a = 0; a < count; a++) {
+					MessageEntity object = MessageEntity.TLdeserialize(stream, stream.readInt32(exception), exception);
+					if (object == null) {
+						return;
+					}
+					entities.add(object);
+				}
+			}
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(id);
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-            stream.writeInt32(date);
-            if ((flags & 512) != 0) {
-                media.serializeToStream(stream);
-            }
-            if ((flags & 128) != 0) {
-                stream.writeInt32(0x1cb5c415);
-                int count = entities.size();
-                stream.writeInt32(count);
-                for (int a = 0; a < count; a++) {
-                    entities.get(a).serializeToStream(stream);
-                }
-            }
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			stream.writeInt32(flags);
+			stream.writeInt32(id);
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+			stream.writeInt32(date);
+			if ((flags & 512) != 0) {
+				media.serializeToStream(stream);
+			}
+			if ((flags & 128) != 0) {
+				stream.writeInt32(0x1cb5c415);
+				int count = entities.size();
+				stream.writeInt32(count);
+				for (int a = 0; a < count; a++) {
+					entities.get(a).serializeToStream(stream);
+				}
+			}
+		}
+	}
 
-    public static class TL_updateShort extends Updates {
-        public static int constructor = 0x78d4dec1;
+	public static class TL_updateShort extends Updates {
+		public static int constructor = 0x78d4dec1;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            update = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
-            date = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			update = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
+			date = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            update.serializeToStream(stream);
-            stream.writeInt32(date);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			update.serializeToStream(stream);
+			stream.writeInt32(date);
+		}
+	}
 
-    public static class TL_updateShortChatMessage extends Updates {
-        public static int constructor = 0xcac7fdd2;
+	public static class TL_updateShortChatMessage extends Updates {
+		public static int constructor = 0xcac7fdd2;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            flags = stream.readInt32(exception);
-            id = stream.readInt32(exception);
-            from_id = stream.readInt32(exception);
-            chat_id = stream.readInt32(exception);
-            message = stream.readString(exception);
-            pts = stream.readInt32(exception);
-            pts_count = stream.readInt32(exception);
-            date = stream.readInt32(exception);
-            if ((flags & 4) != 0) {
-                fwd_from_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            }
-            if ((flags & 4) != 0) {
-                fwd_date = stream.readInt32(exception);
-            }
-            if ((flags & 8) != 0) {
-                reply_to_msg_id = stream.readInt32(exception);
-            }
-            if ((flags & 128) != 0) {
-                int magic = stream.readInt32(exception);
-                if (magic != 0x1cb5c415) {
-                    if (exception) {
-                        throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                    }
-                    return;
-                }
-                int count = stream.readInt32(exception);
-                for (int a = 0; a < count; a++) {
-                    MessageEntity object = MessageEntity.TLdeserialize(stream, stream.readInt32(exception), exception);
-                    if (object == null) {
-                        return;
-                    }
-                    entities.add(object);
-                }
-            }
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			flags = stream.readInt32(exception);
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
+			id = stream.readInt32(exception);
+			from_id = stream.readInt32(exception);
+			chat_id = stream.readInt32(exception);
+			message = stream.readString(exception);
+			pts = stream.readInt32(exception);
+			pts_count = stream.readInt32(exception);
+			date = stream.readInt32(exception);
+			if ((flags & 4) != 0) {
+				fwd_from_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
+			}
+			if ((flags & 4) != 0) {
+				fwd_date = stream.readInt32(exception);
+			}
+			if ((flags & 8) != 0) {
+				reply_to_msg_id = stream.readInt32(exception);
+			}
+			if ((flags & 128) != 0) {
+				int magic = stream.readInt32(exception);
+				if (magic != 0x1cb5c415) {
+					if (exception) {
+						throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+					}
+					return;
+				}
+				int count = stream.readInt32(exception);
+				for (int a = 0; a < count; a++) {
+					MessageEntity object = MessageEntity.TLdeserialize(stream, stream.readInt32(exception), exception);
+					if (object == null) {
+						return;
+					}
+					entities.add(object);
+				}
+			}
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeInt32(id);
-            stream.writeInt32(from_id);
-            stream.writeInt32(chat_id);
-            stream.writeString(message);
-            stream.writeInt32(pts);
-            stream.writeInt32(pts_count);
-            stream.writeInt32(date);
-            if ((flags & 4) != 0) {
-                fwd_from_id.serializeToStream(stream);
-            }
-            if ((flags & 4) != 0) {
-                stream.writeInt32(fwd_date);
-            }
-            if ((flags & 8) != 0) {
-                stream.writeInt32(reply_to_msg_id);
-            }
-            if ((flags & 128) != 0) {
-                stream.writeInt32(0x1cb5c415);
-                int count = entities.size();
-                stream.writeInt32(count);
-                for (int a = 0; a < count; a++) {
-                    entities.get(a).serializeToStream(stream);
-                }
-            }
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
+			stream.writeInt32(flags);
+			stream.writeInt32(id);
+			stream.writeInt32(from_id);
+			stream.writeInt32(chat_id);
+			stream.writeString(message);
+			stream.writeInt32(pts);
+			stream.writeInt32(pts_count);
+			stream.writeInt32(date);
+			if ((flags & 4) != 0) {
+				fwd_from_id.serializeToStream(stream);
+			}
+			if ((flags & 4) != 0) {
+				stream.writeInt32(fwd_date);
+			}
+			if ((flags & 8) != 0) {
+				stream.writeInt32(reply_to_msg_id);
+			}
+			if ((flags & 128) != 0) {
+				stream.writeInt32(0x1cb5c415);
+				int count = entities.size();
+				stream.writeInt32(count);
+				for (int a = 0; a < count; a++) {
+					entities.get(a).serializeToStream(stream);
+				}
+			}
+		}
+	}
 
-    public static class TL_updatesCombined extends Updates {
-        public static int constructor = 0x725b04c3;
+	public static class TL_updatesCombined extends Updates {
+		public static int constructor = 0x725b04c3;
 
 
-        public void readParams(AbstractSerializedData stream, boolean exception) {
-            int magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            int count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                updates.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                users.add(object);
-            }
-            magic = stream.readInt32(exception);
-            if (magic != 0x1cb5c415) {
-                if (exception) {
-                    throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
-                }
-                return;
-            }
-            count = stream.readInt32(exception);
-            for (int a = 0; a < count; a++) {
-                Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
-                if (object == null) {
-                    return;
-                }
-                chats.add(object);
-            }
-            date = stream.readInt32(exception);
-            seq_start = stream.readInt32(exception);
-            seq = stream.readInt32(exception);
-        }
+		public void readParams(AbstractSerializedData stream, boolean exception) {
+			int magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			int count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Update object = Update.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				updates.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				User object = User.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				users.add(object);
+			}
+			magic = stream.readInt32(exception);
+			if (magic != 0x1cb5c415) {
+				if (exception) {
+					throw new RuntimeException(String.format("wrong Vector magic, got %x", magic));
+				}
+				return;
+			}
+			count = stream.readInt32(exception);
+			for (int a = 0; a < count; a++) {
+				Chat object = Chat.TLdeserialize(stream, stream.readInt32(exception), exception);
+				if (object == null) {
+					return;
+				}
+				chats.add(object);
+			}
+			date = stream.readInt32(exception);
+			seq_start = stream.readInt32(exception);
+			seq = stream.readInt32(exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(0x1cb5c415);
-            int count = updates.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                updates.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = users.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                users.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = chats.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                chats.get(a).serializeToStream(stream);
-            }
-            stream.writeInt32(date);
-            stream.writeInt32(seq_start);
-            stream.writeInt32(seq);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(0x1cb5c415);
+			int count = updates.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				updates.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = users.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				users.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = chats.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				chats.get(a).serializeToStream(stream);
+			}
+			stream.writeInt32(date);
+			stream.writeInt32(seq_start);
+			stream.writeInt32(seq);
+		}
+	}
 
-    public static class TL_updatesTooLong extends Updates {
-        public static int constructor = 0xe317af7e;
+	public static class TL_updatesTooLong extends Updates {
+		public static int constructor = 0xe317af7e;
 
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+		}
+	}
 
 	public static class WallPaper extends TLObject {
 		public int id;
@@ -13252,7 +13757,7 @@ public static TL_accountDaysTTL TLdeserialize(AbstractSerializedData stream, int
 			TL_accountDaysTTL result = new TL_accountDaysTTL();
 			result.readParams(stream, exception);
 			return result;
-        }
+		}
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			days = stream.readInt32(exception);
@@ -13491,6 +13996,8 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public static int constructor = 0x5d8c6cc;
 
 		public int flags;
+		public boolean ipv6;
+		public boolean media_only;
 		public int id;
 		public String ip_address;
 		public int port;
@@ -13510,6 +14017,8 @@ public static TL_dcOption TLdeserialize(AbstractSerializedData stream, int const
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			ipv6 = (flags & 1) != 0;
+			media_only = (flags & 2) != 0;
 			id = stream.readInt32(exception);
 			ip_address = stream.readString(exception);
 			port = stream.readInt32(exception);
@@ -13518,6 +14027,8 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeInt32(flags);
+			flags = ipv6 ? (flags | 1) : (flags &~ 1);
+			flags = media_only ? (flags | 2) : (flags &~ 2);
 			stream.writeInt32(id);
 			stream.writeString(ip_address);
 			stream.writeInt32(port);
@@ -13551,7 +14062,7 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 			layer = stream.readInt32(exception);
             in_seq_no = stream.readInt32(exception);
             out_seq_no = stream.readInt32(exception);
-            message = DecryptedMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
+			message = DecryptedMessage.TLdeserialize(stream, stream.readInt32(exception), exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
@@ -13950,7 +14461,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
 			return TL_auth_authorization.TLdeserialize(stream, constructor, exception);
-        }
+		}
 
         public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
@@ -13970,7 +14481,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 		public String phone_code;
 
 		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return TL_auth_authorization.TLdeserialize(stream, constructor, exception);
+			return TL_auth_authorization.TLdeserialize(stream, constructor, exception);
         }
 
         public void serializeToStream(AbstractSerializedData stream) {
@@ -14099,7 +14610,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-            stream.writeInt32(token_type);
+			stream.writeInt32(token_type);
             stream.writeString(token);
 			stream.writeString(device_model);
 			stream.writeString(system_version);
@@ -14254,6 +14765,23 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
+	public static class TL_account_reportPeer extends TLObject {
+		public static int constructor = 0xae189d5f;
+
+		public InputPeer peer;
+		public ReportReason reason;
+
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Bool.TLdeserialize(stream, constructor, exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			peer.serializeToStream(stream);
+			reason.serializeToStream(stream);
+		}
+	}
+
 	public static class TL_users_getFullUser extends TLObject {
 		public static int constructor = 0xca30a5b1;
 
@@ -14483,22 +15011,26 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
-    public static class TL_messages_getDialogs extends TLObject {
-        public static int constructor = 0x859b3d3c;
+	public static class TL_messages_getDialogs extends TLObject {
+		public static int constructor = 0x6b47f94d;
 
-        public int offset;
-        public int limit;
+		public int offset_date;
+		public int offset_id;
+		public InputPeer offset_peer;
+		public int limit;
 
-        public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return messages_Dialogs.TLdeserialize(stream, constructor, exception);
-        }
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return messages_Dialogs.TLdeserialize(stream, constructor, exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(offset);
-            stream.writeInt32(limit);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(offset_date);
+			stream.writeInt32(offset_id);
+			offset_peer.serializeToStream(stream);
+			stream.writeInt32(limit);
+		}
+	}
 
     public static class TL_messages_getHistory extends TLObject {
         public static int constructor = 0x8a8ec2da;
@@ -14519,76 +15051,150 @@ public void serializeToStream(AbstractSerializedData stream) {
             peer.serializeToStream(stream);
             stream.writeInt32(offset_id);
             stream.writeInt32(add_offset);
-            stream.writeInt32(limit);
+			stream.writeInt32(limit);
             stream.writeInt32(max_id);
             stream.writeInt32(min_id);
         }
     }
 
-    public static class TL_messages_search extends TLObject {
-        public static int constructor = 0xd4569248;
+	public static class TL_messages_search extends TLObject {
+		public static int constructor = 0xd4569248;
 
-        public int flags;
-        public InputPeer peer;
-        public String q;
-        public MessagesFilter filter;
-        public int min_date;
-        public int max_date;
-        public int offset;
-        public int max_id;
-        public int limit;
+		public int flags;
+		public boolean important_only;
+		public InputPeer peer;
+		public String q;
+		public MessagesFilter filter;
+		public int min_date;
+		public int max_date;
+		public int offset;
+		public int max_id;
+		public int limit;
 
-        public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return messages_Messages.TLdeserialize(stream, constructor, exception);
-        }
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return messages_Messages.TLdeserialize(stream, constructor, exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            peer.serializeToStream(stream);
-            stream.writeString(q);
-            filter.serializeToStream(stream);
-            stream.writeInt32(min_date);
-            stream.writeInt32(max_date);
-            stream.writeInt32(offset);
-            stream.writeInt32(max_id);
-            stream.writeInt32(limit);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = important_only ? (flags | 1) : (flags &~ 1);
+			stream.writeInt32(flags);
+			peer.serializeToStream(stream);
+			stream.writeString(q);
+			filter.serializeToStream(stream);
+			stream.writeInt32(min_date);
+			stream.writeInt32(max_date);
+			stream.writeInt32(offset);
+			stream.writeInt32(max_id);
+			stream.writeInt32(limit);
+		}
+	}
 
 	public static class TL_messages_readHistory extends TLObject {
-		public static int constructor = 0xb04f2510;
+		public static int constructor = 0xe306d3a;
 
 		public InputPeer peer;
 		public int max_id;
-		public int offset;
 
 		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-			return TL_messages_affectedHistory.TLdeserialize(stream, constructor, exception);
+			return TL_messages_affectedMessages.TLdeserialize(stream, constructor, exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			peer.serializeToStream(stream);
 			stream.writeInt32(max_id);
-			stream.writeInt32(offset);
 		}
 	}
 
 	public static class TL_messages_deleteHistory extends TLObject {
-		public static int constructor = 0xf4f8fb61;
+		public static int constructor = 0xb7c13bd9;
 
 		public InputPeer peer;
-		public int offset;
+		public int max_id;
 
 		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
 			return TL_messages_affectedHistory.TLdeserialize(stream, constructor, exception);
 		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
+		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			peer.serializeToStream(stream);
-			stream.writeInt32(offset);
+			stream.writeInt32(max_id);
+		}
+	}
+
+	public static class TL_messages_toggleChatAdmins extends TLObject {
+		public static int constructor = 0xec8bd9e1;
+
+		public int chat_id;
+		public boolean enabled;
+
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Updates.TLdeserialize(stream, constructor, exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+			stream.writeBool(enabled);
+		}
+	}
+
+	public static class TL_messages_editChatAdmin extends TLObject {
+		public static int constructor = 0xa9e69f2e;
+
+		public int chat_id;
+		public InputUser user_id;
+		public boolean is_admin;
+
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Bool.TLdeserialize(stream, constructor, exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+			user_id.serializeToStream(stream);
+			stream.writeBool(is_admin);
+		}
+	}
+
+	public static class TL_messages_migrateChat extends TLObject {
+		public static int constructor = 0x15a3b8e3;
+
+		public int chat_id;
+
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Updates.TLdeserialize(stream, constructor, exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(chat_id);
+		}
+	}
+
+	public static class TL_messages_searchGlobal extends TLObject {
+		public static int constructor = 0x9e3cacb0;
+
+		public String q;
+		public int offset_date;
+		public InputPeer offset_peer;
+		public int offset_id;
+		public int limit;
+
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return messages_Messages.TLdeserialize(stream, constructor, exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeString(q);
+			stream.writeInt32(offset_date);
+			offset_peer.serializeToStream(stream);
+			stream.writeInt32(offset_id);
+			stream.writeInt32(limit);
 		}
 	}
 
@@ -14649,52 +15255,57 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			peer.serializeToStream(stream);
-			action.serializeToStream(stream);
+			action.serializeToStream(stream);
+		}
+	}
+
+	public static class TL_messages_sendMessage extends TLObject {
+		public static int constructor = 0xfa88427a;
+
+		public int flags;
+		public boolean no_webpage;
+		public boolean broadcast;
+		public InputPeer peer;
+		public int reply_to_msg_id;
+		public String message;
+		public long random_id;
+		public ReplyMarkup reply_markup;
+		public ArrayList<MessageEntity> entities = new ArrayList<>();
+
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Updates.TLdeserialize(stream, constructor, exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = no_webpage ? (flags | 2) : (flags &~ 2);
+			flags = broadcast ? (flags | 16) : (flags &~ 16);
+			stream.writeInt32(flags);
+			peer.serializeToStream(stream);
+			if ((flags & 1) != 0) {
+				stream.writeInt32(reply_to_msg_id);
+			}
+			stream.writeString(message);
+			stream.writeInt64(random_id);
+			if ((flags & 4) != 0) {
+				reply_markup.serializeToStream(stream);
+			}
+			if ((flags & 8) != 0) {
+				stream.writeInt32(0x1cb5c415);
+				int count = entities.size();
+				stream.writeInt32(count);
+				for (int a = 0; a < count; a++) {
+					entities.get(a).serializeToStream(stream);
+				}
+			}
 		}
 	}
 
-    public static class TL_messages_sendMessage extends TLObject {
-        public static int constructor = 0xfa88427a;
-
-        public int flags;
-        public InputPeer peer;
-        public int reply_to_msg_id;
-        public String message;
-        public long random_id;
-        public ReplyMarkup reply_markup;
-        public ArrayList<MessageEntity> entities = new ArrayList<>();
-
-        public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return Updates.TLdeserialize(stream, constructor, exception);
-        }
-
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            peer.serializeToStream(stream);
-            if ((flags & 1) != 0) {
-                stream.writeInt32(reply_to_msg_id);
-            }
-            stream.writeString(message);
-            stream.writeInt64(random_id);
-            if ((flags & 4) != 0) {
-                reply_markup.serializeToStream(stream);
-            }
-            if ((flags & 8) != 0) {
-                stream.writeInt32(0x1cb5c415);
-                int count = entities.size();
-                stream.writeInt32(count);
-                for (int a = 0; a < count; a++) {
-                    entities.get(a).serializeToStream(stream);
-                }
-            }
-        }
-    }
-
 	public static class TL_messages_sendMedia extends TLObject {
 		public static int constructor = 0xc8f16791;
 
 		public int flags;
+		public boolean broadcast;
 		public InputPeer peer;
 		public int reply_to_msg_id;
 		public InputMedia media;
@@ -14707,6 +15318,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = broadcast ? (flags | 16) : (flags &~ 16);
 			stream.writeInt32(flags);
 			peer.serializeToStream(stream);
 			if ((flags & 1) != 0) {
@@ -14720,38 +15332,40 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
-    public static class TL_messages_forwardMessages extends TLObject {
-        public static int constructor = 0x708e0195;
+	public static class TL_messages_forwardMessages extends TLObject {
+		public static int constructor = 0x708e0195;
 
-        public int flags;
-        public InputPeer from_peer;
-        public ArrayList<Integer> id = new ArrayList<>();
-        public ArrayList<Long> random_id = new ArrayList<>();
-        public InputPeer to_peer;
+		public int flags;
+		public boolean broadcast;
+		public InputPeer from_peer;
+		public ArrayList<Integer> id = new ArrayList<>();
+		public ArrayList<Long> random_id = new ArrayList<>();
+		public InputPeer to_peer;
 
-        public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return Updates.TLdeserialize(stream, constructor, exception);
-        }
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Updates.TLdeserialize(stream, constructor, exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            from_peer.serializeToStream(stream);
-            stream.writeInt32(0x1cb5c415);
-            int count = id.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                stream.writeInt32(id.get(a));
-            }
-            stream.writeInt32(0x1cb5c415);
-            count = random_id.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                stream.writeInt64(random_id.get(a));
-            }
-            to_peer.serializeToStream(stream);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = broadcast ? (flags | 16) : (flags &~ 16);
+			stream.writeInt32(flags);
+			from_peer.serializeToStream(stream);
+			stream.writeInt32(0x1cb5c415);
+			int count = id.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt32(id.get(a));
+			}
+			stream.writeInt32(0x1cb5c415);
+			count = random_id.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt64(random_id.get(a));
+			}
+			to_peer.serializeToStream(stream);
+		}
+	}
 
 	public static class TL_messages_reportSpam extends TLObject {
 		public static int constructor = 0xcf1592db;
@@ -14815,7 +15429,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
-            stream.writeInt32(chat_id);
+			stream.writeInt32(chat_id);
             stream.writeString(title);
         }
     }
@@ -14943,7 +15557,7 @@ public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
             channel.serializeToStream(stream);
             filter.serializeToStream(stream);
-            stream.writeInt32(pts);
+			stream.writeInt32(pts);
             stream.writeInt32(limit);
         }
     }
@@ -15127,7 +15741,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
             user_id.serializeToStream(stream);
-            stream.writeInt32(offset);
+			stream.writeInt32(offset);
 			stream.writeInt64(max_id);
 			stream.writeInt32(limit);
 		}
@@ -15146,7 +15760,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
-            peer.serializeToStream(stream);
+			peer.serializeToStream(stream);
 			stream.writeInt32(id);
 			stream.writeInt64(random_id);
 		}
@@ -15177,7 +15791,7 @@ public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(count);
             for (int a = 0; a < count; a++) {
                 stream.writeInt64(random_id.get(a));
-            }
+			}
 			stream.writeString(message);
 			media.serializeToStream(stream);
 		}
@@ -15262,7 +15876,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-            peer.serializeToStream(stream);
+			peer.serializeToStream(stream);
 			stream.writeString(title);
 			stream.writeString(address);
 		}
@@ -15346,7 +15960,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			peer.serializeToStream(stream);
 			stream.writeBool(typing);
 		}
@@ -15365,7 +15979,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-            peer.serializeToStream(stream);
+			peer.serializeToStream(stream);
 			stream.writeString(message);
 			stream.writeInt64(random_id);
 		}
@@ -15405,7 +16019,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
 			stream.writeString(title);
-            geo_point.serializeToStream(stream);
+			geo_point.serializeToStream(stream);
 			stream.writeString(address);
 			stream.writeString(venue);
 		}
@@ -15460,7 +16074,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
-            peer.serializeToStream(stream);
+			peer.serializeToStream(stream);
 			stream.writeByteArray(g_b);
 			stream.writeInt64(key_fingerprint);
 		}
@@ -15509,7 +16123,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			peer.serializeToStream(stream);
 			stream.writeInt32(max_date);
 		}
@@ -15626,7 +16240,7 @@ public TLObject deserializeResponse(AbstractSerializedData stream, int construct
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
+			stream.writeInt32(constructor);
 			stream.writeString(q);
 			stream.writeInt32(limit);
 		}
@@ -15779,18 +16393,18 @@ public void serializeToStream(AbstractSerializedData stream) {
 	}
 
 	public static class TL_messages_getAllStickers extends TLObject {
-		public static int constructor = 0xaa3bc868;
+		public static int constructor = 0x1c9618b1;
 
-		public String hash;
+		public int hash;
 
 		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
 			return messages_AllStickers.TLdeserialize(stream, constructor, exception);
 		}
 
 		public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-			stream.writeString(hash);
-        }
+			stream.writeInt32(constructor);
+			stream.writeInt32(hash);
+		}
 	}
 
 	public static class TL_account_updateDeviceLocked extends TLObject {
@@ -16031,26 +16645,26 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
-    public static class TL_messages_startBot extends TLObject {
-        public static int constructor = 0x1b3e0ffc;
+	public static class TL_messages_startBot extends TLObject {
+		public static int constructor = 0xe6df7378;
 
-        public InputUser bot;
-        public int chat_id;
-        public long random_id;
-        public String start_param;
+		public InputUser bot;
+		public InputPeer peer;
+		public long random_id;
+		public String start_param;
 
-        public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return Updates.TLdeserialize(stream, constructor, exception);
-        }
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Updates.TLdeserialize(stream, constructor, exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            bot.serializeToStream(stream);
-            stream.writeInt32(chat_id);
-            stream.writeInt64(random_id);
-            stream.writeString(start_param);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			bot.serializeToStream(stream);
+			peer.serializeToStream(stream);
+			stream.writeInt64(random_id);
+			stream.writeString(start_param);
+		}
+	}
 
     public static class TL_messages_getMessagesViews extends TLObject {
         public static int constructor = 0xc4c8a55d;
@@ -16072,7 +16686,7 @@ public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
             peer.serializeToStream(stream);
             stream.writeInt32(0x1cb5c415);
-            int count = id.size();
+			int count = id.size();
             stream.writeInt32(count);
             for (int a = 0; a < count; a++) {
                 stream.writeInt32(id.get(a));
@@ -16102,22 +16716,57 @@ public void serializeToStream(AbstractSerializedData stream) {
 		}
 	}
 
-    public static class TL_channels_getDialogs extends TLObject {
-        public static int constructor = 0xa9d3d249;
+	public static class TL_help_getTermsOfService extends TLObject {
+		public static int constructor = 0x37d78f83;
 
-        public int offset;
-        public int limit;
+		public String lang_code;
 
-        public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return messages_Dialogs.TLdeserialize(stream, constructor, exception);
-        }
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return TL_help_termsOfService.TLdeserialize(stream, constructor, exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(offset);
-            stream.writeInt32(limit);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeString(lang_code);
+		}
+	}
+
+	public static class TL_messages_reorderStickerSets extends TLObject {
+		public static int constructor = 0x9fcfbc30;
+
+		public ArrayList<Long> order = new ArrayList<>();
+
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Bool.TLdeserialize(stream, constructor, exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(0x1cb5c415);
+			int count = order.size();
+			stream.writeInt32(count);
+			for (int a = 0; a < count; a++) {
+				stream.writeInt64(order.get(a));
+			}
+		}
+	}
+
+	public static class TL_channels_getDialogs extends TLObject {
+		public static int constructor = 0xa9d3d249;
+
+		public int offset;
+		public int limit;
+
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return messages_Dialogs.TLdeserialize(stream, constructor, exception);
+		}
+
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			stream.writeInt32(offset);
+			stream.writeInt32(limit);
+		}
+	}
 
     public static class TL_channels_getImportantHistory extends TLObject {
         public static int constructor = 0xddb929cb;
@@ -16319,31 +16968,28 @@ public void serializeToStream(AbstractSerializedData stream) {
         }
     }
 
-    public static class TL_channels_createChannel extends TLObject {
-        public static int constructor = 0x5521d844;
+	public static class TL_channels_createChannel extends TLObject {
+		public static int constructor = 0xf4893d7f;
 
-        public int flags;
-        public String title;
-        public String about;
-        public ArrayList<InputUser> users = new ArrayList<>();
+		public int flags;
+		public boolean broadcast;
+		public boolean megagroup;
+		public String title;
+		public String about;
 
-        public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return Updates.TLdeserialize(stream, constructor, exception);
-        }
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Updates.TLdeserialize(stream, constructor, exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            stream.writeInt32(flags);
-            stream.writeString(title);
-            stream.writeString(about);
-            stream.writeInt32(0x1cb5c415);
-            int count = users.size();
-            stream.writeInt32(count);
-            for (int a = 0; a < count; a++) {
-                users.get(a).serializeToStream(stream);
-            }
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			flags = broadcast ? (flags | 1) : (flags &~ 1);
+			flags = megagroup ? (flags | 2) : (flags &~ 2);
+			stream.writeInt32(flags);
+			stream.writeString(title);
+			stream.writeString(about);
+		}
+	}
 
     public static class TL_channels_editAbout extends TLObject {
         public static int constructor = 0x13e27f1e;
@@ -16362,24 +17008,24 @@ public void serializeToStream(AbstractSerializedData stream) {
         }
     }
 
-    public static class TL_channels_editAdmin extends TLObject {
-        public static int constructor = 0x52b16962;
+	public static class TL_channels_editAdmin extends TLObject {
+		public static int constructor = 0xeb7611d0;
 
-        public InputChannel channel;
-        public InputUser user_id;
-        public ChannelParticipantRole role;
+		public InputChannel channel;
+		public InputUser user_id;
+		public ChannelParticipantRole role;
 
-        public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
-            return Bool.TLdeserialize(stream, constructor, exception);
-        }
+		public TLObject deserializeResponse(AbstractSerializedData stream, int constructor, boolean exception) {
+			return Updates.TLdeserialize(stream, constructor, exception);
+		}
 
-        public void serializeToStream(AbstractSerializedData stream) {
-            stream.writeInt32(constructor);
-            channel.serializeToStream(stream);
-            user_id.serializeToStream(stream);
-            role.serializeToStream(stream);
-        }
-    }
+		public void serializeToStream(AbstractSerializedData stream) {
+			stream.writeInt32(constructor);
+			channel.serializeToStream(stream);
+			user_id.serializeToStream(stream);
+			role.serializeToStream(stream);
+		}
+	}
 
     public static class TL_channels_editTitle extends TLObject {
         public static int constructor = 0x566decd0;
@@ -16644,6 +17290,10 @@ public static EncryptedChat TLdeserialize(AbstractSerializedData stream, int con
         public String message;
         public MessageMedia media;
         public int flags;
+		public boolean mentioned;
+		public boolean media_unread;
+		public boolean out;
+		public boolean unread;
         public ArrayList<MessageEntity> entities = new ArrayList<>();
         public ReplyMarkup reply_markup;
 		public int views;
@@ -16737,6 +17387,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
 			id = stream.readInt32(exception);
 			from_id = stream.readInt32(exception);
 			to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -16747,6 +17401,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
 			stream.writeInt32(flags);
 			stream.writeInt32(id);
 			stream.writeInt32(from_id);
@@ -16761,6 +17419,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
 			id = stream.readInt32(exception);
 			if ((flags & 256) != 0) {
 				from_id = stream.readInt32(exception);
@@ -16822,6 +17484,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
 			stream.writeInt32(flags);
 			stream.writeInt32(id);
 			if ((flags & 256) != 0) {
@@ -16869,6 +17535,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
             flags = stream.readInt32(exception);
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
             id = stream.readInt32(exception);
 			fwd_from_id = new TL_peerUser();
 			fwd_from_id.user_id = stream.readInt32(exception);
@@ -16889,6 +17559,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
             stream.writeInt32(flags);
             stream.writeInt32(id);
             stream.writeInt32(fwd_from_id.user_id);
@@ -16911,6 +17585,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception) | MESSAGE_FLAG_HAS_FROM_ID;
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
 			id = stream.readInt32(exception);
 			from_id = stream.readInt32(exception);
 			to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -16961,6 +17639,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
 			stream.writeInt32(flags);
 			stream.writeInt32(id);
 			stream.writeInt32(from_id);
@@ -17003,6 +17685,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
             flags = stream.readInt32(exception) | MESSAGE_FLAG_HAS_FROM_ID | MESSAGE_FLAG_HAS_MEDIA;
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
             id = stream.readInt32(exception);
             from_id = stream.readInt32(exception);
             to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -17049,6 +17735,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
             stream.writeInt32(flags);
             stream.writeInt32(id);
             stream.writeInt32(from_id);
@@ -17089,6 +17779,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
 		public void readParams(AbstractSerializedData stream, boolean exception) {
 			flags = stream.readInt32(exception);
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
 			id = stream.readInt32(exception);
 			if ((flags & 256) != 0) {
 				from_id = stream.readInt32(exception);
@@ -17107,6 +17801,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
 		public void serializeToStream(AbstractSerializedData stream) {
 			stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
 			stream.writeInt32(flags);
 			stream.writeInt32(id);
 			if ((flags & 256) != 0) {
@@ -17124,6 +17822,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
             flags = stream.readInt32(exception) | MESSAGE_FLAG_HAS_FROM_ID | MESSAGE_FLAG_HAS_MEDIA;
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
             id = stream.readInt32(exception);
             from_id = stream.readInt32(exception);
             to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -17153,6 +17855,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
             stream.writeInt32(flags);
             stream.writeInt32(id);
             stream.writeInt32(from_id);
@@ -17184,6 +17890,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
             flags = stream.readInt32(exception) | MESSAGE_FLAG_HAS_FROM_ID | MESSAGE_FLAG_HAS_MEDIA;
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
             id = stream.readInt32(exception);
             from_id = stream.readInt32(exception);
             to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -17210,6 +17920,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
             stream.writeInt32(flags);
             stream.writeInt32(id);
             stream.writeInt32(from_id);
@@ -17239,6 +17953,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
             flags = stream.readInt32(exception) | MESSAGE_FLAG_HAS_FROM_ID | MESSAGE_FLAG_HAS_MEDIA;
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
             id = stream.readInt32(exception);
             from_id = stream.readInt32(exception);
             to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -17252,6 +17970,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
             stream.writeInt32(flags);
             stream.writeInt32(id);
             stream.writeInt32(from_id);
@@ -17271,8 +17993,8 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
             id = stream.readInt32(exception);
             from_id = stream.readInt32(exception);
             to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            flags |= stream.readBool(exception) ? MESSAGE_FLAG_OUT : 0;
-            flags |= stream.readBool(exception) ? MESSAGE_FLAG_UNREAD : 0;
+			out = stream.readBool(exception);
+			unread = stream.readBool(exception);
             flags |= MESSAGE_FLAG_HAS_FROM_ID;
             date = stream.readInt32(exception);
             action = MessageAction.TLdeserialize(stream, stream.readInt32(exception), exception);
@@ -17283,8 +18005,8 @@ public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(id);
             stream.writeInt32(from_id);
             to_id.serializeToStream(stream);
-            stream.writeBool((flags & MESSAGE_FLAG_OUT) != 0);
-            stream.writeBool((flags & MESSAGE_FLAG_UNREAD) != 0);
+            stream.writeBool(out);
+            stream.writeBool(unread);
             stream.writeInt32(date);
             action.serializeToStream(stream);
         }
@@ -17301,8 +18023,8 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
             fwd_date = stream.readInt32(exception);
             from_id = stream.readInt32(exception);
             to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            flags |= stream.readBool(exception) ? MESSAGE_FLAG_OUT : 0;
-            flags |= stream.readBool(exception) ? MESSAGE_FLAG_UNREAD : 0;
+			out = stream.readBool(exception);
+			unread = stream.readBool(exception);
             flags |= MESSAGE_FLAG_FWD | MESSAGE_FLAG_HAS_FROM_ID | MESSAGE_FLAG_HAS_MEDIA;
             date = stream.readInt32(exception);
             message = stream.readString(exception);
@@ -17322,8 +18044,8 @@ public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(fwd_date);
             stream.writeInt32(from_id);
             to_id.serializeToStream(stream);
-            stream.writeBool((flags & MESSAGE_FLAG_OUT) != 0);
-            stream.writeBool((flags & MESSAGE_FLAG_UNREAD) != 0);
+			stream.writeBool(out);
+			stream.writeBool(unread);
             stream.writeInt32(date);
             stream.writeString(message);
             media.serializeToStream(stream);
@@ -17341,8 +18063,8 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
             id = stream.readInt32(exception);
             from_id = stream.readInt32(exception);
             to_id = Peer.TLdeserialize(stream, stream.readInt32(exception), exception);
-            flags |= stream.readBool(exception) ? MESSAGE_FLAG_OUT : 0;
-            flags |= stream.readBool(exception) ? MESSAGE_FLAG_UNREAD : 0;
+			out = stream.readBool(exception);
+			unread = stream.readBool(exception);
             flags |= MESSAGE_FLAG_HAS_FROM_ID | MESSAGE_FLAG_HAS_MEDIA;
             date = stream.readInt32(exception);
             message = stream.readString(exception);
@@ -17357,8 +18079,8 @@ public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(id);
             stream.writeInt32(from_id);
             to_id.serializeToStream(stream);
-            stream.writeBool((flags & MESSAGE_FLAG_OUT) != 0);
-            stream.writeBool((flags & MESSAGE_FLAG_UNREAD) != 0);
+			stream.writeBool(out);
+			stream.writeBool(unread);
             stream.writeInt32(date);
             stream.writeString(message);
             media.serializeToStream(stream);
@@ -17371,6 +18093,10 @@ public void serializeToStream(AbstractSerializedData stream) {
 
         public void readParams(AbstractSerializedData stream, boolean exception) {
             flags = stream.readInt32(exception) | MESSAGE_FLAG_HAS_FROM_ID | MESSAGE_FLAG_HAS_MEDIA;
+			unread = (flags & 1) != 0;
+			out = (flags & 2) != 0;
+			mentioned = (flags & 16) != 0;
+			media_unread = (flags & 32) != 0;
             id = stream.readInt32(exception);
             ttl = stream.readInt32(exception);
             from_id = stream.readInt32(exception);
@@ -17385,6 +18111,10 @@ public void readParams(AbstractSerializedData stream, boolean exception) {
 
         public void serializeToStream(AbstractSerializedData stream) {
             stream.writeInt32(constructor);
+			flags = unread ? (flags | 1) : (flags &~ 1);
+			flags = out ? (flags | 2) : (flags &~ 2);
+			flags = mentioned ? (flags | 16) : (flags &~ 16);
+			flags = media_unread ? (flags | 32) : (flags &~ 32);
             stream.writeInt32(flags);
             stream.writeInt32(id);
             stream.writeInt32(ttl);
@@ -17483,6 +18213,14 @@ public void serializeToStream(AbstractSerializedData stream) {
     }
     //TL_dialog end
 
+	//ChatParticipant start
+	public static class TL_chatChannelParticipant extends ChatParticipant {
+		public static int constructor = 0xc8d7493e;
+
+		public TLRPC.ChannelParticipant channelParticipant;
+	}
+	//ChatParticipant end
+
     //Chat start
     public static class TL_chatEmpty extends Chat {
         public static int constructor = 0x9ba2d800;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBar.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBar.java
index 82cb6c55b..016d389e0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBar.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBar.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.ActionBar;
@@ -22,10 +22,15 @@
 import android.widget.TextView;
 
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.AnimationCompat.AnimatorListenerAdapterProxy;
+import org.telegram.messenger.AnimationCompat.AnimatorSetProxy;
+import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
 import org.telegram.messenger.ApplicationLoader;
 import org.telegram.messenger.R;
 import org.telegram.ui.Components.LayoutHelper;
 
+import java.util.ArrayList;
+
 public class ActionBar extends FrameLayout {
 
     public static class ActionBarMenuOnItemClick {
@@ -45,6 +50,8 @@ public boolean canOpenMenu() {
     private ActionBarMenu menu;
     private ActionBarMenu actionMode;
     private boolean occupyStatusBar = Build.VERSION.SDK_INT >= 21;
+    private boolean actionModeVisible;
+    private boolean addToContainer = true;
 
     private boolean allowOverlayTitle;
     private CharSequence lastTitle;
@@ -55,7 +62,6 @@ public boolean canOpenMenu() {
     private boolean isBackOverlayVisible;
     protected BaseFragment parentFragment;
     public ActionBarMenuOnItemClick actionBarMenuOnItemClick;
-    private int extraHeight;
 
     public ActionBar(Context context) {
         super(context);
@@ -68,6 +74,7 @@ private void createBackButtonImage() {
         backButtonImageView = new ImageView(getContext());
         backButtonImageView.setScaleType(ImageView.ScaleType.CENTER);
         backButtonImageView.setBackgroundResource(itemsBackgroundResourceId);
+        backButtonImageView.setPadding(AndroidUtilities.dp(1), 0, 0, 0);
         addView(backButtonImageView, LayoutHelper.createFrame(54, 54, Gravity.LEFT | Gravity.TOP));
 
         backButtonImageView.setOnClickListener(new OnClickListener() {
@@ -90,6 +97,9 @@ public void setBackButtonDrawable(Drawable drawable) {
         }
         backButtonImageView.setVisibility(drawable == null ? GONE : VISIBLE);
         backButtonImageView.setImageDrawable(drawable);
+        if (drawable instanceof BackDrawable) {
+            ((BackDrawable) drawable).setRotation(isActionModeShowed() ? 1 : 0, false);
+        }
     }
 
     public void setBackButtonImage(int resource) {
@@ -111,7 +121,15 @@ private void createSubtitleTextView() {
         subTitleTextView.setLines(1);
         subTitleTextView.setMaxLines(1);
         subTitleTextView.setEllipsize(TextUtils.TruncateAt.END);
-        addView(subTitleTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP));
+        addView(subTitleTextView, 0, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP));
+    }
+
+    public void setAddToContainer(boolean value) {
+        addToContainer = value;
+    }
+
+    public boolean getAddToContainer() {
+        return addToContainer;
     }
 
     public void setSubtitle(CharSequence value) {
@@ -136,7 +154,7 @@ private void createTitleTextView() {
         titleTextView.setEllipsize(TextUtils.TruncateAt.END);
         titleTextView.setTextColor(0xffffffff);
         titleTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        addView(titleTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP));
+        addView(titleTextView, 0, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP));
     }
 
     public void setTitle(CharSequence value) {
@@ -174,12 +192,7 @@ public ActionBarMenu createMenu() {
             return menu;
         }
         menu = new ActionBarMenu(getContext(), this);
-        addView(menu);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)menu.getLayoutParams();
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.RIGHT;
-        menu.setLayoutParams(layoutParams);
+        addView(menu, 0, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.RIGHT));
         return menu;
     }
 
@@ -192,8 +205,8 @@ public ActionBarMenu createActionMode() {
             return actionMode;
         }
         actionMode = new ActionBarMenu(getContext(), this);
-        actionMode.setBackgroundResource(R.drawable.editheader);
-        addView(actionMode);
+        actionMode.setBackgroundColor(0xffffffff);
+        addView(actionMode, indexOfChild(backButtonImageView));
         actionMode.setPadding(0, occupyStatusBar ? AndroidUtilities.statusBarHeight : 0, 0, 0);
         FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)actionMode.getLayoutParams();
         layoutParams.height = LayoutHelper.MATCH_PARENT;
@@ -218,34 +231,95 @@ public ActionBarMenu createActionMode() {
     }
 
     public void showActionMode() {
-        if (actionMode == null) {
+        if (actionMode == null || actionModeVisible) {
             return;
         }
-        actionMode.setVisibility(VISIBLE);
-        if (occupyStatusBar && actionModeTop != null) {
-            actionModeTop.setVisibility(VISIBLE);
-        }
-        if (titleTextView != null) {
-            titleTextView.setVisibility(INVISIBLE);
-        }
-        if (subTitleTextView != null) {
-            subTitleTextView.setVisibility(INVISIBLE);
+        actionModeVisible = true;
+        if (Build.VERSION.SDK_INT >= 14) {
+            ArrayList<Object> animators = new ArrayList<>();
+            animators.add(ObjectAnimatorProxy.ofFloat(actionMode, "alpha", 0.0f, 1.0f));
+            if (occupyStatusBar && actionModeTop != null) {
+                animators.add(ObjectAnimatorProxy.ofFloat(actionModeTop, "alpha", 0.0f, 1.0f));
+            }
+            AnimatorSetProxy animatorSetProxy = new AnimatorSetProxy();
+            animatorSetProxy.playTogether(animators);
+            animatorSetProxy.setDuration(200);
+            animatorSetProxy.addListener(new AnimatorListenerAdapterProxy() {
+                @Override
+                public void onAnimationStart(Object animation) {
+                    actionMode.setVisibility(VISIBLE);
+                    if (occupyStatusBar && actionModeTop != null) {
+                        actionModeTop.setVisibility(VISIBLE);
+                    }
+                }
+
+                @Override
+                public void onAnimationEnd(Object animation) {
+                    if (titleTextView != null) {
+                        titleTextView.setVisibility(INVISIBLE);
+                    }
+                    if (subTitleTextView != null) {
+                        subTitleTextView.setVisibility(INVISIBLE);
+                    }
+                    if (menu != null) {
+                        menu.setVisibility(INVISIBLE);
+                    }
+                }
+            });
+            animatorSetProxy.start();
+        } else {
+            actionMode.setVisibility(VISIBLE);
+            if (occupyStatusBar && actionModeTop != null) {
+                actionModeTop.setVisibility(VISIBLE);
+            }
+            if (titleTextView != null) {
+                titleTextView.setVisibility(INVISIBLE);
+            }
+            if (subTitleTextView != null) {
+                subTitleTextView.setVisibility(INVISIBLE);
+            }
+            if (menu != null) {
+                menu.setVisibility(INVISIBLE);
+            }
         }
         if (backButtonImageView != null) {
-            backButtonImageView.setVisibility(INVISIBLE);
-        }
-        if (menu != null) {
-            menu.setVisibility(INVISIBLE);
+            Drawable drawable = backButtonImageView.getDrawable();
+            if (drawable instanceof BackDrawable) {
+                ((BackDrawable) drawable).setRotation(1, true);
+            }
+            backButtonImageView.setBackgroundResource(R.drawable.bar_selector_mode);
         }
     }
 
     public void hideActionMode() {
-        if (actionMode == null) {
+        if (actionMode == null || !actionModeVisible) {
             return;
         }
-        actionMode.setVisibility(INVISIBLE);
-        if (occupyStatusBar && actionModeTop != null) {
-            actionModeTop.setVisibility(INVISIBLE);
+        actionModeVisible = false;
+        if (Build.VERSION.SDK_INT >= 14) {
+            ArrayList<Object> animators = new ArrayList<>();
+            animators.add(ObjectAnimatorProxy.ofFloat(actionMode, "alpha", 0.0f));
+            if (occupyStatusBar && actionModeTop != null) {
+                animators.add(ObjectAnimatorProxy.ofFloat(actionModeTop, "alpha", 0.0f));
+            }
+            AnimatorSetProxy animatorSetProxy = new AnimatorSetProxy();
+            animatorSetProxy.playTogether(animators);
+            animatorSetProxy.setDuration(200);
+            animatorSetProxy.addListener(new AnimatorListenerAdapterProxy() {
+                @Override
+                public void onAnimationEnd(Object animation) {
+                    actionMode.setVisibility(INVISIBLE);
+                    if (occupyStatusBar && actionModeTop != null) {
+                        actionModeTop.setVisibility(INVISIBLE);
+                    }
+                }
+            });
+            animatorSetProxy.start();
+        } else {
+            actionMode.setVisibility(INVISIBLE);
+            if (occupyStatusBar && actionModeTop != null) {
+                actionModeTop.setVisibility(INVISIBLE);
+            }
         }
         if (titleTextView != null) {
             titleTextView.setVisibility(VISIBLE);
@@ -253,12 +327,16 @@ public void hideActionMode() {
         if (subTitleTextView != null) {
             subTitleTextView.setVisibility(VISIBLE);
         }
-        if (backButtonImageView != null) {
-            backButtonImageView.setVisibility(VISIBLE);
-        }
         if (menu != null) {
             menu.setVisibility(VISIBLE);
         }
+        if (backButtonImageView != null) {
+            Drawable drawable = backButtonImageView.getDrawable();
+            if (drawable instanceof BackDrawable) {
+                ((BackDrawable) drawable).setRotation(0, true);
+            }
+            backButtonImageView.setBackgroundResource(itemsBackgroundResourceId);
+        }
     }
 
     public void showActionModeTop() {
@@ -275,7 +353,7 @@ public void showActionModeTop() {
     }
 
     public boolean isActionModeShowed() {
-        return actionMode != null && actionMode.getVisibility() == VISIBLE;
+        return actionMode != null && actionModeVisible;
     }
 
     protected void onSearchFieldVisibilityChanged(boolean visible) {
@@ -288,7 +366,7 @@ protected void onSearchFieldVisibilityChanged(boolean visible) {
         }
         Drawable drawable = backButtonImageView.getDrawable();
         if (drawable != null && drawable instanceof MenuDrawable) {
-            ((MenuDrawable)drawable).setRotation(visible ? 1 : 0, true);
+            ((MenuDrawable) drawable).setRotation(visible ? 1 : 0, true);
         }
     }
 
@@ -313,7 +391,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         int actionBarHeight = getCurrentActionBarHeight();
         int actionBarHeightSpec = MeasureSpec.makeMeasureSpec(actionBarHeight, MeasureSpec.EXACTLY);
 
-        setMeasuredDimension(width, actionBarHeight + extraHeight + (occupyStatusBar ? AndroidUtilities.statusBarHeight : 0));
+        setMeasuredDimension(width, actionBarHeight + (occupyStatusBar ? AndroidUtilities.statusBarHeight : 0));
 
         int textLeft;
         if (backButtonImageView != null && backButtonImageView.getVisibility() != GONE) {
@@ -474,17 +552,6 @@ public boolean isSearchFieldVisible() {
         return isSearchFieldVisible;
     }
 
-    public void setExtraHeight(int value, boolean layout) {
-        extraHeight = value;
-        if (layout) {
-            requestLayout();
-        }
-    }
-
-    public int getExtraHeight() {
-        return extraHeight;
-    }
-
     public void setOccupyStatusBar(boolean value) {
         occupyStatusBar = value;
         if (actionMode != null) {
@@ -526,4 +593,9 @@ public static int getCurrentActionBarHeight() {
             return AndroidUtilities.dp(56);
         }
     }
+
+    @Override
+    public boolean hasOverlappingRendering() {
+        return false;
+    }
 }
\ No newline at end of file
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarLayout.java
index 5a70d96c2..fdf6f29e0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarLayout.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarLayout.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.ActionBar;
@@ -59,7 +59,6 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
             if (child instanceof ActionBar) {
                 return super.drawChild(canvas, child, drawingTime);
             } else {
-                //boolean wasActionBar = false;
                 int actionBarHeight = 0;
                 int childCount = getChildCount();
                 for (int a = 0; a < childCount; a++) {
@@ -70,24 +69,10 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
                     if (view instanceof ActionBar && view.getVisibility() == VISIBLE) {
                         if (((ActionBar) view).getCastShadows()) {
                             actionBarHeight = view.getMeasuredHeight();
-                            //wasActionBar = true;
                         }
                         break;
                     }
                 }
-                /*if (!wasActionBar) {
-                    if (child instanceof ViewGroup) {
-                        ViewGroup viewGroup = (ViewGroup) child;
-                        childCount = viewGroup.getChildCount();
-                        for (int a = 0; a < childCount; a++) {
-                            View possibleActionBar = viewGroup.getChildAt(a);
-                            if (possibleActionBar instanceof ActionBar) {
-                                actionBarHeight = possibleActionBar.getMeasuredHeight();
-                                break;
-                            }
-                        }
-                    }
-                }*/
                 boolean result = super.drawChild(canvas, child, drawingTime);
                 if (actionBarHeight != 0 && headerShadowDrawable != null) {
                     headerShadowDrawable.setBounds(0, actionBarHeight, getMeasuredWidth(), actionBarHeight + headerShadowDrawable.getIntrinsicHeight());
@@ -96,6 +81,11 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
                 return result;
             }
         }
+
+        @Override
+        public boolean hasOverlappingRendering() {
+            return false;
+        }
     }
 
     private static Drawable headerShadowDrawable;
@@ -129,6 +119,7 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
     private boolean useAlphaAnimations;
     private View backgroundView;
     private boolean removeActionBarExtraHeight;
+    private Runnable animationRunnable;
 
     private float animationProgress = 0.0f;
     private long lastFrameTime;
@@ -257,7 +248,7 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
         }
 
         final int restoreCount = canvas.save();
-        if (!transitionAnimationInProgress) {
+        if (!transitionAnimationInProgress && clipLeft != 0 && clipRight != 0) {
             canvas.clipRect(clipLeft, 0, clipRight, getHeight());
         }
         final boolean result = super.drawChild(canvas, child, drawingTime);
@@ -312,7 +303,7 @@ private void onSlideAnimationEnd(final boolean backAnimation) {
                     parent.removeView(lastFragment.fragmentView);
                 }
             }
-            if (lastFragment.needAddActionBar() && lastFragment.actionBar != null) {
+            if (lastFragment.actionBar != null && lastFragment.actionBar.getAddToContainer()) {
                 ViewGroup parent = (ViewGroup) lastFragment.actionBar.getParent();
                 if (parent != null) {
                     parent.removeView(lastFragment.actionBar);
@@ -320,7 +311,6 @@ private void onSlideAnimationEnd(final boolean backAnimation) {
             }
         }
         containerViewBack.setVisibility(View.GONE);
-        //AndroidUtilities.unlockOrientation(parentActivity);
         startedTracking = false;
         animationInProgress = false;
 
@@ -350,7 +340,7 @@ private void prepareForMoving(MotionEvent ev) {
         if (parent != null) {
             parent.removeView(fragmentView);
         }
-        if (lastFragment.needAddActionBar() && lastFragment.actionBar != null) {
+        if (lastFragment.actionBar != null && lastFragment.actionBar.getAddToContainer()) {
             parent = (ViewGroup) lastFragment.actionBar.getParent();
             if (parent != null) {
                 parent.removeView(lastFragment.actionBar);
@@ -370,8 +360,6 @@ private void prepareForMoving(MotionEvent ev) {
             fragmentView.setBackgroundColor(0xffffffff);
         }
         lastFragment.onResume();
-
-        //AndroidUtilities.lockOrientation(parentActivity);
     }
 
     public boolean onTouchEvent(MotionEvent ev) {
@@ -516,6 +504,10 @@ private void onAnimationEndCheck(boolean byCheck) {
             }
             currentAnimation = null;
         }
+        if (animationRunnable != null) {
+            AndroidUtilities.cancelRunOnUIThread(animationRunnable);
+            animationRunnable = null;
+        }
         ViewProxy.setAlpha(this, 1.0f);
         ViewProxy.setAlpha(containerView, 1.0f);
         ViewProxy.setScaleX(containerView, 1.0f);
@@ -548,7 +540,7 @@ private void presentFragmentInternalRemoveOld(boolean removeLast, final BaseFrag
                     parent.removeView(fragment.fragmentView);
                 }
             }
-            if (fragment.needAddActionBar() && fragment.actionBar != null) {
+            if (fragment.actionBar != null && fragment.actionBar.getAddToContainer()) {
                 ViewGroup parent = (ViewGroup) fragment.actionBar.getParent();
                 if (parent != null) {
                     parent.removeView(fragment.actionBar);
@@ -570,17 +562,18 @@ private void startLayoutAnimation(final boolean open, final boolean first) {
         if (first) {
             animationProgress = 0.0f;
             lastFrameTime = System.nanoTime() / 1000000;
-            if (Build.VERSION.SDK_INT >= 11) {
-                if (open) {
-                    containerView.setLayerType(LAYER_TYPE_HARDWARE, null);
-                } else {
-                    containerViewBack.setLayerType(LAYER_TYPE_HARDWARE, null);
-                }
+            if (Build.VERSION.SDK_INT > 15) {
+                containerView.setLayerType(LAYER_TYPE_HARDWARE, null);
+                containerViewBack.setLayerType(LAYER_TYPE_HARDWARE, null);
             }
         }
-        AndroidUtilities.runOnUIThread(new Runnable() {
+        AndroidUtilities.runOnUIThread(animationRunnable = new Runnable() {
             @Override
             public void run() {
+                if (animationRunnable != this) {
+                    return;
+                }
+                animationRunnable = null;
                 if (first) {
                     transitionAnimationStartTime = System.currentTimeMillis();
                 }
@@ -632,7 +625,7 @@ public boolean presentFragment(final BaseFragment fragment, final boolean remove
                 parent.removeView(fragmentView);
             }
         }
-        if (fragment.needAddActionBar() && fragment.actionBar != null) {
+        if (fragment.actionBar != null && fragment.actionBar.getAddToContainer()) {
             if (removeActionBarExtraHeight) {
                 fragment.actionBar.setOccupyStatusBar(false);
             }
@@ -663,7 +656,6 @@ public boolean presentFragment(final BaseFragment fragment, final boolean remove
         setInnerTranslationX(0);
 
         bringChildToFront(containerView);
-
         if (!needAnimation) {
             presentFragmentInternalRemoveOld(removeLast, currentFragment);
             if (backgroundView != null) {
@@ -680,7 +672,7 @@ public boolean presentFragment(final BaseFragment fragment, final boolean remove
                 onOpenAnimationEndRunnable = new Runnable() {
                     @Override
                     public void run() {
-                        fragment.onOpenAnimationEnd();
+                        fragment.onTransitionAnimationEnd(true, false);
                         fragment.onBecomeFullyVisible();
                     }
                 };
@@ -691,7 +683,7 @@ public void run() {
                     animators.add(ObjectAnimatorProxy.ofFloat(backgroundView, "alpha", 0.0f, 1.0f));
                 }
 
-                fragment.onOpenAnimationStart();
+                fragment.onTransitionAnimationStart(true, false);
                 currentAnimation = new AnimatorSetProxy();
                 currentAnimation.playTogether(animators);
                 currentAnimation.setInterpolator(accelerateDecelerateInterpolator);
@@ -714,50 +706,44 @@ public void onAnimationCancel(Object animation) {
                 onOpenAnimationEndRunnable = new Runnable() {
                     @Override
                     public void run() {
-                        if (Build.VERSION.SDK_INT >= 18) {
+                        if (Build.VERSION.SDK_INT > 15) {
                             containerView.setLayerType(LAYER_TYPE_NONE, null);
+                            containerViewBack.setLayerType(LAYER_TYPE_NONE, null);
                         }
                         presentFragmentInternalRemoveOld(removeLast, currentFragment);
-                        fragment.onOpenAnimationEnd();
+                        fragment.onTransitionAnimationEnd(true, false);
                         fragment.onBecomeFullyVisible();
                         ViewProxy.setTranslationX(containerView, 0);
                     }
                 };
-                ViewProxy.setAlpha(containerView, 0.0f);
-                ViewProxy.setTranslationX(containerView, 48.0f);
-                fragment.onOpenAnimationStart();
-                startLayoutAnimation(true, true);
-                /*currentAnimation = new AnimatorSetProxy();
-                currentAnimation.playTogether(
-                        ObjectAnimatorProxy.ofFloat(containerView, "alpha", 0.0f, 1.0f),
-                        ObjectAnimatorProxy.ofFloat(containerView, "translationX", AndroidUtilities.dp(48), 0));
-                currentAnimation.setInterpolator(decelerateInterpolator);
-                currentAnimation.setDuration(200);
-                currentAnimation.addListener(new AnimatorListenerAdapterProxy() {
+                fragment.onTransitionAnimationStart(true, false);
+                AnimatorSetProxy animation = fragment.onCustomTransitionAnimation(true, new Runnable() {
                     @Override
-                    public void onAnimationStart(Object animation) {
-                        transitionAnimationStartTime = System.currentTimeMillis();
-                    }
-
-                    @Override
-                    public void onAnimationEnd(Object animation) {
-                        onAnimationEndCheck(false);
-                    }
-
-                    @Override
-                    public void onAnimationCancel(Object animation) {
+                    public void run() {
                         onAnimationEndCheck(false);
                     }
                 });
-                currentAnimation.start();*/
+                if (animation == null) {
+                    ViewProxy.setAlpha(containerView, 0.0f);
+                    ViewProxy.setTranslationX(containerView, 48.0f);
+                    startLayoutAnimation(true, true);
+                } else {
+                    if (Build.VERSION.SDK_INT > 15) {
+                        //containerView.setLayerType(LAYER_TYPE_HARDWARE, null);
+                        //containerViewBack.setLayerType(LAYER_TYPE_HARDWARE, null);
+                    }
+                    ViewProxy.setAlpha(containerView, 1.0f);
+                    ViewProxy.setTranslationX(containerView, 0.0f);
+                    currentAnimation = animation;
+                }
             }
         } else {
             if (backgroundView != null) {
                 ViewProxy.setAlpha(backgroundView, 1.0f);
                 backgroundView.setVisibility(VISIBLE);
             }
-            fragment.onOpenAnimationStart();
-            fragment.onOpenAnimationEnd();
+            fragment.onTransitionAnimationStart(true, false);
+            fragment.onTransitionAnimationEnd(true, false);
             fragment.onBecomeFullyVisible();
         }
         return true;
@@ -836,7 +822,7 @@ public void closeLastFragment(boolean animated) {
                     parent.removeView(fragmentView);
                 }
             }
-            if (previousFragment.needAddActionBar() && previousFragment.actionBar != null) {
+            if (previousFragment.actionBar != null && previousFragment.actionBar.getAddToContainer()) {
                 if (removeActionBarExtraHeight) {
                     previousFragment.actionBar.setOccupyStatusBar(false);
                 }
@@ -852,7 +838,8 @@ public void closeLastFragment(boolean animated) {
             layoutParams.width = LayoutHelper.MATCH_PARENT;
             layoutParams.height = LayoutHelper.MATCH_PARENT;
             fragmentView.setLayoutParams(layoutParams);
-            previousFragment.onOpenAnimationStart();
+            previousFragment.onTransitionAnimationStart(true, true);
+            currentFragment.onTransitionAnimationStart(false, false);
             previousFragment.onResume();
             currentActionBar = previousFragment.actionBar;
             if (!previousFragment.hasOwnBackground && fragmentView.getBackground() == null) {
@@ -870,42 +857,35 @@ public void closeLastFragment(boolean animated) {
                 onCloseAnimationEndRunnable = new Runnable() {
                     @Override
                     public void run() {
-                        if (Build.VERSION.SDK_INT >= 18) {
+                        if (Build.VERSION.SDK_INT > 15) {
+                            containerView.setLayerType(LAYER_TYPE_NONE, null);
                             containerViewBack.setLayerType(LAYER_TYPE_NONE, null);
                         }
                         closeLastFragmentInternalRemoveOld(currentFragment);
                         ViewProxy.setTranslationX(containerViewBack, 0);
-                        previousFragmentFinal.onOpenAnimationEnd();
+                        currentFragment.onTransitionAnimationEnd(false, false);
+                        previousFragmentFinal.onTransitionAnimationEnd(true, true);
                         previousFragmentFinal.onBecomeFullyVisible();
                     }
                 };
-                startLayoutAnimation(false, true);
-
-                /*currentAnimation = new AnimatorSetProxy();
-                currentAnimation.playTogether(
-                        ObjectAnimatorProxy.ofFloat(containerViewBack, "alpha", 1.0f, 0.0f),
-                        ObjectAnimatorProxy.ofFloat(containerViewBack, "translationX", 0, AndroidUtilities.dp(48)));
-                currentAnimation.setInterpolator(decelerateInterpolator);
-                currentAnimation.setDuration(200);
-                currentAnimation.addListener(new AnimatorListenerAdapterProxy() {
-                    @Override
-                    public void onAnimationStart(Object animation) {
-                        transitionAnimationStartTime = System.currentTimeMillis();
-                    }
-
-                    @Override
-                    public void onAnimationEnd(Object animation) {
-                        onAnimationEndCheck(false);
-                    }
-
+                AnimatorSetProxy animation = currentFragment.onCustomTransitionAnimation(false, new Runnable() {
                     @Override
-                    public void onAnimationCancel(Object animation) {
+                    public void run() {
                         onAnimationEndCheck(false);
                     }
                 });
-                currentAnimation.start();*/
+                if (animation == null) {
+                    startLayoutAnimation(false, true);
+                } else {
+                    if (Build.VERSION.SDK_INT > 15) {
+                        //containerView.setLayerType(LAYER_TYPE_HARDWARE, null);
+                        //containerViewBack.setLayerType(LAYER_TYPE_HARDWARE, null);
+                    }
+                    currentAnimation = animation;
+                }
             } else {
-                previousFragment.onOpenAnimationEnd();
+                currentFragment.onTransitionAnimationEnd(false, false);
+                previousFragment.onTransitionAnimationEnd(true, true);
                 previousFragment.onBecomeFullyVisible();
             }
         } else {
@@ -916,7 +896,7 @@ public void onAnimationCancel(Object animation) {
                 onCloseAnimationEndRunnable = new Runnable() {
                     @Override
                     public void run() {
-                        removeFragmentFromStack(currentFragment);
+                        removeFragmentFromStackInternal(currentFragment);
                         setVisibility(GONE);
                         if (backgroundView != null) {
                             backgroundView.setVisibility(GONE);
@@ -955,7 +935,7 @@ public void onAnimationCancel(Object animation) {
                 });
                 currentAnimation.start();
             } else {
-                removeFragmentFromStack(currentFragment);
+                removeFragmentFromStackInternal(currentFragment);
                 setVisibility(GONE);
                 if (backgroundView != null) {
                     backgroundView.setVisibility(GONE);
@@ -968,6 +948,22 @@ public void showLastFragment() {
         if (fragmentsStack.isEmpty()) {
             return;
         }
+        for (int a = 0; a < fragmentsStack.size() - 1; a++) {
+            BaseFragment previousFragment = fragmentsStack.get(a);
+            if (previousFragment.actionBar != null) {
+                ViewGroup parent = (ViewGroup) previousFragment.actionBar.getParent();
+                if (parent != null) {
+                    parent.removeView(previousFragment.actionBar);
+                }
+            }
+            if (previousFragment.fragmentView != null) {
+                ViewGroup parent = (ViewGroup) previousFragment.fragmentView.getParent();
+                if (parent != null) {
+                    previousFragment.onPause();
+                    parent.removeView(previousFragment.fragmentView);
+                }
+            }
+        }
         BaseFragment previousFragment = fragmentsStack.get(fragmentsStack.size() - 1);
         previousFragment.setParentLayout(this);
         View fragmentView = previousFragment.fragmentView;
@@ -979,7 +975,7 @@ public void showLastFragment() {
                 parent.removeView(fragmentView);
             }
         }
-        if (previousFragment.needAddActionBar() && previousFragment.actionBar != null) {
+        if (previousFragment.actionBar != null && previousFragment.actionBar.getAddToContainer()) {
             if (removeActionBarExtraHeight) {
                 previousFragment.actionBar.setOccupyStatusBar(false);
             }
@@ -1002,16 +998,24 @@ public void showLastFragment() {
         }
     }
 
-    public void removeFragmentFromStack(BaseFragment fragment) {
+    private void removeFragmentFromStackInternal(BaseFragment fragment) {
         fragment.onPause();
         fragment.onFragmentDestroy();
         fragment.setParentLayout(null);
         fragmentsStack.remove(fragment);
     }
 
+    public void removeFragmentFromStack(BaseFragment fragment) {
+        if (useAlphaAnimations && fragmentsStack.size() == 1 && AndroidUtilities.isTablet()) {
+            closeLastFragment(true);
+        } else {
+            removeFragmentFromStackInternal(fragment);
+        }
+    }
+
     public void removeAllFragments() {
         for (int a = 0; a < fragmentsStack.size(); a++) {
-            removeFragmentFromStack(fragmentsStack.get(a));
+            removeFragmentFromStackInternal(fragmentsStack.get(a));
             a--;
         }
     }
@@ -1136,4 +1140,9 @@ public void setTitleOverlayText(String text) {
             }
         }
     }
+
+    @Override
+    public boolean hasOverlappingRendering() {
+        return false;
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenu.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenu.java
index 74f6575e0..adfd31f8f 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenu.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenu.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.ActionBar;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenuItem.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenuItem.java
index 91ede040d..ff4513af0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenuItem.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarMenuItem.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.ActionBar;
@@ -288,7 +288,6 @@ public void toggleSubMenu() {
         }
         if (popupWindow == null) {
             popupWindow = new ActionBarPopupWindow(popupLayout, LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT);
-            //popupWindow.setBackgroundDrawable(new BitmapDrawable());
             if (Build.VERSION.SDK_INT >= 19) {
                 popupWindow.setAnimationStyle(0);
             } else {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarPopupWindow.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarPopupWindow.java
index 36f3dd0d0..4fe5781f0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarPopupWindow.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/ActionBarPopupWindow.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 //Thanks to https://github.com/JakeWharton/ActionBarSherlock/
@@ -90,13 +90,22 @@ public ActionBarPopupWindowLayout(Context context) {
             setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8));
             setWillNotDraw(false);
 
-            scrollView = new ScrollView(context);
-            scrollView.setVerticalScrollBarEnabled(false);
-            addView(scrollView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+            try {
+                scrollView = new ScrollView(context);
+                scrollView.setVerticalScrollBarEnabled(false);
+                addView(scrollView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+            } catch (Throwable e) {
+                FileLog.e("tmessages", e);
+            }
+
 
             linearLayout = new LinearLayout(context);
             linearLayout.setOrientation(LinearLayout.VERTICAL);
-            scrollView.addView(linearLayout, new ScrollView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+            if (scrollView != null) {
+                scrollView.addView(linearLayout, new ScrollView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
+            } else {
+                addView(linearLayout, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
+            }
         }
 
         public void setShowedFromBotton(boolean value) {
@@ -215,7 +224,9 @@ public View getItemAt(int index) {
         }
 
         public void scrollToTop() {
-            scrollView.scrollTo(0, 0);
+            if (scrollView != null) {
+                scrollView.scrollTo(0, 0);
+            }
         }
     }
 
@@ -374,6 +385,7 @@ public void dismiss() {
     }
 
     public void dismiss(boolean animated) {
+        setFocusable(false);
         if (animationEnabled && animated) {
             if (windowAnimatorSet != null) {
                 windowAnimatorSet.cancel();
@@ -414,7 +426,6 @@ public void onAnimationRepeat(Animator animation) {
             });
             windowAnimatorSet.start();
         } else {
-            setFocusable(false);
             try {
                 super.dismiss();
             } catch (Exception e) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BackDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BackDrawable.java
new file mode 100644
index 000000000..c19dd92a0
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BackDrawable.java
@@ -0,0 +1,130 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.ActionBar;
+
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.drawable.Drawable;
+import android.view.animation.DecelerateInterpolator;
+
+import org.telegram.messenger.AndroidUtilities;
+
+public class BackDrawable extends Drawable {
+
+    private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private boolean reverseAngle = false;
+    private long lastFrameTime;
+    private boolean animationInProgress;
+    private float finalRotation;
+    private float currentRotation;
+    private int currentAnimationTime;
+    private boolean alwaysClose;
+    private DecelerateInterpolator interpolator = new DecelerateInterpolator();
+
+    public BackDrawable(boolean close) {
+        super();
+        paint.setColor(0xffffffff);
+        paint.setStrokeWidth(AndroidUtilities.dp(2));
+        alwaysClose = close;
+    }
+
+    public void setRotation(float rotation, boolean animated) {
+        lastFrameTime = 0;
+        if (currentRotation == 1) {
+            reverseAngle = true;
+        } else if (currentRotation == 0) {
+            reverseAngle = false;
+        }
+        lastFrameTime = 0;
+        if (animated) {
+            if (currentRotation < rotation) {
+                currentAnimationTime = (int) (currentRotation * 300);
+            } else {
+                currentAnimationTime = (int) ((1.0f - currentRotation) * 300);
+            }
+            lastFrameTime = System.currentTimeMillis();
+            finalRotation = rotation;
+        } else {
+            finalRotation = currentRotation = rotation;
+        }
+        invalidateSelf();
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        if (currentRotation != finalRotation) {
+            if (lastFrameTime != 0) {
+                long dt = System.currentTimeMillis() - lastFrameTime;
+
+                currentAnimationTime += dt;
+                if (currentAnimationTime >= 300) {
+                    currentRotation = finalRotation;
+                } else {
+                    if (currentRotation < finalRotation) {
+                        currentRotation = interpolator.getInterpolation(currentAnimationTime / 300.0f) * finalRotation;
+                    } else {
+                        currentRotation = 1.0f - interpolator.getInterpolation(currentAnimationTime / 300.0f);
+                    }
+                }
+            }
+            lastFrameTime = System.currentTimeMillis();
+            invalidateSelf();
+        }
+
+        int rD = (int) ((117 - 255) * currentRotation);
+        int c = Color.rgb(255 + rD, 255 + rD, 255 + rD);
+        paint.setColor(c);
+
+        canvas.save();
+        canvas.translate(getIntrinsicWidth() / 2, getIntrinsicHeight() / 2);
+        float rotation = currentRotation;
+        if (!alwaysClose) {
+            canvas.rotate(currentRotation * (reverseAngle ? -225 : 135));
+        } else {
+            canvas.rotate(135 + currentRotation * (reverseAngle ? -180 : 180));
+            rotation = 1.0f;
+        }
+        canvas.drawLine(-AndroidUtilities.dp(7) - AndroidUtilities.dp(1) * rotation, 0, AndroidUtilities.dp(8), 0, paint);
+        float startYDiff = -AndroidUtilities.dp(0.5f);
+        float endYDiff = AndroidUtilities.dp(7) + AndroidUtilities.dp(1) * rotation;
+        float startXDiff = -AndroidUtilities.dp(7.0f) + AndroidUtilities.dp(7.0f) * rotation;
+        float endXDiff = AndroidUtilities.dp(0.5f) - AndroidUtilities.dp(0.5f) * rotation;
+        canvas.drawLine(startXDiff, -startYDiff, endXDiff, -endYDiff, paint);
+        canvas.drawLine(startXDiff, startYDiff, endXDiff, endYDiff, paint);
+        canvas.restore();
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+
+    }
+
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSPARENT;
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return AndroidUtilities.dp(24);
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return AndroidUtilities.dp(24);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BaseFragment.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BaseFragment.java
index 68103b395..3e62a22c7 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BaseFragment.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BaseFragment.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.ActionBar;
@@ -17,6 +17,7 @@
 import android.view.View;
 import android.view.ViewGroup;
 
+import org.telegram.messenger.AnimationCompat.AnimatorSetProxy;
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
 import org.telegram.tgnet.ConnectionsManager;
@@ -43,6 +44,14 @@ public BaseFragment(Bundle args) {
         classGuid = ConnectionsManager.getInstance().generateClassGuid();
     }
 
+    public ActionBar getActionBar() {
+        return actionBar;
+    }
+
+    public View getFragmentView() {
+        return fragmentView;
+    }
+
     public View createView(Context context) {
         return null;
     }
@@ -154,7 +163,7 @@ public void onPause() {
             actionBar.onPause();
         }
         try {
-            if (visibleDialog != null && visibleDialog.isShowing()) {
+            if (visibleDialog != null && visibleDialog.isShowing() && dismissDialogOnPause(visibleDialog)) {
                 visibleDialog.dismiss();
                 visibleDialog = null;
             }
@@ -175,6 +184,10 @@ public void onActivityResultFragment(int requestCode, int resultCode, Intent dat
 
     }
 
+    public void onRequestPermissionsResultFragment(int requestCode, String[] permissions, int[] grantResults) {
+
+    }
+
     public void saveSelfArgs(Bundle args) {
 
     }
@@ -208,6 +221,10 @@ public void startActivityForResult(final Intent intent, final int requestCode) {
         }
     }
 
+    public boolean dismissDialogOnPause(Dialog dialog) {
+        return true;
+    }
+
     public void onBeginSlide() {
         try {
             if (visibleDialog != null && visibleDialog.isShowing()) {
@@ -222,11 +239,11 @@ public void onBeginSlide() {
         }
     }
 
-    protected void onOpenAnimationEnd() {
+    protected void onTransitionAnimationStart(boolean isOpen, boolean backward) {
 
     }
 
-    protected void onOpenAnimationStart() {
+    protected void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
 
     }
 
@@ -234,12 +251,12 @@ protected void onBecomeFullyVisible() {
 
     }
 
-    public void onLowMemory() {
-
+    protected AnimatorSetProxy onCustomTransitionAnimation(boolean isOpen, final Runnable callback) {
+        return null;
     }
 
-    public boolean needAddActionBar() {
-        return true;
+    public void onLowMemory() {
+
     }
 
     public Dialog showDialog(Dialog dialog) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BottomSheet.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BottomSheet.java
index 1e9125554..5fdc15024 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BottomSheet.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/BottomSheet.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -31,6 +31,7 @@
 import android.view.ViewAnimationUtils;
 import android.view.ViewGroup;
 import android.view.Window;
+import android.view.WindowInsets;
 import android.view.WindowManager;
 import android.view.animation.AccelerateInterpolator;
 import android.view.animation.DecelerateInterpolator;
@@ -55,6 +56,7 @@
 
     private LinearLayout containerView;
     private FrameLayout container;
+    private Object lastInsets;
 
     private boolean dismissed;
     private int tag;
@@ -70,6 +72,8 @@
     private ColorDrawable backgroundDrawable = new ColorDrawable(0xff000000);
     private static Drawable shadowDrawable;
 
+    private boolean focusable;
+
     private Paint ciclePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
 
     private static int backgroundPaddingTop;
@@ -134,24 +138,24 @@ public View getRevealView() {
         }
     }
 
-    private static class BottomSheetCell extends FrameLayout {
+    public static class BottomSheetCell extends FrameLayout {
 
         private TextView textView;
         private ImageView imageView;
         private boolean isGrid;
 
-        public BottomSheetCell(Context context, boolean grid) {
+        public BottomSheetCell(Context context, int type) {
             super(context);
-            isGrid = grid;
+            isGrid = type == 1;
 
             setBackgroundResource(R.drawable.list_selector);
-            if (!grid) {
+            if (type != 1) {
                 setPadding(AndroidUtilities.dp(16), 0, AndroidUtilities.dp(16), 0);
             }
 
             imageView = new ImageView(context);
             imageView.setScaleType(ImageView.ScaleType.CENTER);
-            if (grid) {
+            if (type == 1) {
                 addView(imageView, LayoutHelper.createFrame(48, 48, Gravity.CENTER_HORIZONTAL | Gravity.TOP, 0, 8, 0, 0));
             } else {
                 addView(imageView, LayoutHelper.createFrame(24, 24, Gravity.CENTER_VERTICAL | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT)));
@@ -162,14 +166,20 @@ public BottomSheetCell(Context context, boolean grid) {
             textView.setSingleLine(true);
             textView.setGravity(Gravity.CENTER_HORIZONTAL);
             textView.setEllipsize(TextUtils.TruncateAt.END);
-            if (grid) {
+            if (type == 1) {
                 textView.setTextColor(0xff757575);
                 textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12);
                 addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP, 0, 60, 0, 0));
-            } else {
+            } else if (type == 0) {
                 textView.setTextColor(0xff212121);
                 textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
                 addView(textView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL));
+            } else if (type == 2) {
+                textView.setGravity(Gravity.CENTER);
+                textView.setTextColor(0xff212121);
+                textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+                textView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+                addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
             }
         }
 
@@ -178,6 +188,14 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
             super.onMeasure(isGrid ? MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(96), MeasureSpec.EXACTLY) : widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(isGrid ? 80 : 48), MeasureSpec.EXACTLY));
         }
 
+        public void setTextColor(int color) {
+            textView.setTextColor(color);
+        }
+
+        public void setGravity(int gravity) {
+            textView.setGravity(gravity);
+        }
+
         public void setTextAndIcon(CharSequence text, int icon) {
             textView.setText(text);
             if (icon != 0) {
@@ -193,10 +211,11 @@ public void setTextAndIcon(CharSequence text, int icon) {
         }
     }
 
-    public BottomSheet(Context context) {
+    public BottomSheet(Context context, boolean needFocus) {
         super(context);
 
         container = new FrameLayout(getContext()) {
+
             @Override
             protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                 int width = MeasureSpec.getSize(widthMeasureSpec);
@@ -225,7 +244,12 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                     if (child.getVisibility() == GONE || child == containerView) {
                         continue;
                     }
-                    measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
+                    if (lastInsets != null && Build.VERSION.SDK_INT >= 21) {
+                        WindowInsets wi = (WindowInsets) lastInsets;
+                        wi = wi.replaceSystemWindowInsets(wi.getSystemWindowInsetLeft(), wi.getSystemWindowInsetTop(), 0, wi.getSystemWindowInsetBottom());
+                        child.dispatchApplyWindowInsets(wi);
+                    }
+                    measureChildWithMargins(child, MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY), 0, MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY), 0);
                 }
             }
 
@@ -243,7 +267,7 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
                     if (child.getVisibility() == GONE || child == containerView) {
                         continue;
                     }
-                    final LayoutParams lp = (LayoutParams) child.getLayoutParams();
+                    final FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) child.getLayoutParams();
 
                     final int width = child.getMeasuredWidth();
                     final int height = child.getMeasuredHeight();
@@ -296,6 +320,20 @@ public boolean onTouch(View v, MotionEvent event) {
             }
         });
         container.setBackgroundDrawable(backgroundDrawable);
+        focusable = needFocus;
+        if (Build.VERSION.SDK_INT >= 21 && !focusable) {
+            container.setFitsSystemWindows(true);
+            container.setOnApplyWindowInsetsListener(new View.OnApplyWindowInsetsListener() {
+                @SuppressLint("NewApi")
+                @Override
+                public WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {
+                    lastInsets = insets;
+                    container.requestLayout();
+                    return insets.consumeSystemWindowInsets();
+                }
+            });
+            container.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
+        }
     }
 
     @Override
@@ -378,7 +416,7 @@ public boolean onTouch(View v, MotionEvent event) {
             FrameLayout rowLayout = null;
             int lastRowLayoutNum = 0;
             for (int a = 0; a < items.length; a++) {
-                BottomSheetCell cell = new BottomSheetCell(getContext(), isGrid);
+                BottomSheetCell cell = new BottomSheetCell(getContext(), isGrid ? 1 : 0);
                 cell.setTextAndIcon(items[a], itemIcons != null ? itemIcons[a] : 0);
                 if (isGrid) {
                     int row = a / 3;
@@ -418,15 +456,17 @@ public void onClick(View v) {
         }
 
         WindowManager.LayoutParams params = getWindow().getAttributes();
-        params.height = ViewGroup.LayoutParams.MATCH_PARENT;
         params.width = ViewGroup.LayoutParams.MATCH_PARENT;
         params.gravity = Gravity.TOP | Gravity.LEFT;
-        params.flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
-        params.dimAmount = 0;
-        params.flags &= ~WindowManager.LayoutParams.FLAG_DIM_BEHIND;
-        if (Build.VERSION.SDK_INT >= 21) {
-            params.flags |= WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
-            params.type = WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
+        if (!focusable) {
+            params.flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
+            params.dimAmount = 0;
+            params.flags &= ~WindowManager.LayoutParams.FLAG_DIM_BEHIND;
+        } else {
+            params.dimAmount = 0.2f;
+        }
+        if (Build.VERSION.SDK_INT < 21) {
+            params.height = ViewGroup.LayoutParams.MATCH_PARENT;
         }
         getWindow().setAttributes(params);
     }
@@ -434,6 +474,9 @@ public void onClick(View v) {
     @Override
     public void show() {
         super.show();
+        if (focusable) {
+            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
+        }
         dismissed = false;
         if (Build.VERSION.SDK_INT >= 21 || !useRevealAnimation) {
             containerView.setBackgroundDrawable(shadowDrawable);
@@ -590,7 +633,7 @@ private void startOpenAnimation() {
             AnimatorSetProxy animatorSetProxy = new AnimatorSetProxy();
             animatorSetProxy.playTogether(
                     ObjectAnimatorProxy.ofFloat(containerView, "translationY", 0),
-                    ObjectAnimatorProxy.ofInt(backgroundDrawable, "alpha", 51));
+                    ObjectAnimatorProxy.ofInt(backgroundDrawable, "alpha", focusable ? 0 : 51));
             animatorSetProxy.setDuration(200);
             animatorSetProxy.setStartDelay(20);
             animatorSetProxy.setInterpolator(new DecelerateInterpolator());
@@ -716,7 +759,11 @@ public void onAnimationCancel(Object animation) {
         private BottomSheet bottomSheet;
 
         public Builder(Context context) {
-            bottomSheet = new BottomSheet(context);
+            bottomSheet = new BottomSheet(context, false);
+        }
+
+        public Builder(Context context, boolean needFocus) {
+            bottomSheet = new BottomSheet(context, needFocus);
         }
 
         public Builder setItems(CharSequence[] items, final OnClickListener onClickListener) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/DrawerLayoutContainer.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/DrawerLayoutContainer.java
index d7f12cb23..985be1645 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/DrawerLayoutContainer.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/DrawerLayoutContainer.java
@@ -1,13 +1,14 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.ActionBar;
 
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.Context;
 import android.graphics.Canvas;
@@ -69,12 +70,14 @@ public DrawerLayoutContainer(Context context) {
 
         if (Build.VERSION.SDK_INT >= 21) {
             setFitsSystemWindows(true);
-            configureApplyInsets(this);
+            setOnApplyWindowInsetsListener(new InsetsListener());
+            setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
         }
 
         shadowLeft = getResources().getDrawable(R.drawable.menu_shadow);
     }
 
+    @SuppressLint("NewApi")
     private class InsetsListener implements View.OnApplyWindowInsetsListener {
         @Override
         public WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {
@@ -84,13 +87,7 @@ public WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {
         }
     }
 
-    private void configureApplyInsets(View drawerLayout) {
-        if (Build.VERSION.SDK_INT >= 21) {
-            drawerLayout.setOnApplyWindowInsetsListener(new InsetsListener());
-            drawerLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
-        }
-    }
-
+    @SuppressLint("NewApi")
     private void dispatchChildInsets(View child, Object insets, int drawerGravity) {
         WindowInsets wi = (WindowInsets) insets;
         if (drawerGravity == Gravity.LEFT) {
@@ -101,6 +98,7 @@ private void dispatchChildInsets(View child, Object insets, int drawerGravity) {
         child.dispatchApplyWindowInsets(wi);
     }
 
+    @SuppressLint("NewApi")
     private void applyMarginInsets(MarginLayoutParams lp, Object insets, int drawerGravity, boolean topOnly) {
         WindowInsets wi = (WindowInsets) insets;
         if (drawerGravity == Gravity.LEFT) {
@@ -413,6 +411,7 @@ public void requestLayout() {
         }
     }
 
+    @SuppressLint("NewApi")
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         int widthSize = MeasureSpec.getSize(widthMeasureSpec);
@@ -435,7 +434,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
             if (applyInsets) {
                 if (child.getFitsSystemWindows()) {
                     dispatchChildInsets(child, lastInsets, lp.gravity);
-                } else {
+                } else if (child.getTag() == null) {
                     applyMarginInsets(lp, lastInsets, lp.gravity, Build.VERSION.SDK_INT >= 21);
                 }
             }
@@ -460,6 +459,7 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
         }
         final int height = getHeight();
         final boolean drawingContent = child != drawerLayout;
+        int lastVisibleChild = 0;
         int clipLeft = 0, clipRight = getWidth();
 
         final int restoreCount = canvas.save();
@@ -467,6 +467,9 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
             final int childCount = getChildCount();
             for (int i = 0; i < childCount; i++) {
                 final View v = getChildAt(i);
+                if (v.getVisibility() == VISIBLE && v != drawerLayout) {
+                    lastVisibleChild = i;
+                }
                 if (v == child || v.getVisibility() != VISIBLE || v != drawerLayout || v.getHeight() < height) {
                     continue;
                 }
@@ -476,14 +479,18 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
                     clipLeft = vright;
                 }
             }
-            canvas.clipRect(clipLeft, 0, clipRight, getHeight());
+            if (clipLeft != 0) {
+                canvas.clipRect(clipLeft, 0, clipRight, getHeight());
+            }
         }
         final boolean result = super.drawChild(canvas, child, drawingTime);
         canvas.restoreToCount(restoreCount);
 
         if (scrimOpacity > 0 && drawingContent) {
-            scrimPaint.setColor((int) (((0x99000000 & 0xff000000) >>> 24) * scrimOpacity) << 24);
-            canvas.drawRect(clipLeft, 0, clipRight, getHeight(), scrimPaint);
+            if (indexOfChild(child) == lastVisibleChild) {
+                scrimPaint.setColor((int) (((0x99000000 & 0xff000000) >>> 24) * scrimOpacity) << 24);
+                canvas.drawRect(clipLeft, 0, clipRight, getHeight(), scrimPaint);
+            }
         } else if (shadowLeft != null) {
             final float alpha = Math.max(0, Math.min(drawerPosition / AndroidUtilities.dp(20), 1.0f));
             if (alpha != 0) {
@@ -494,4 +501,9 @@ protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
         }
         return result;
     }
+
+    @Override
+    public boolean hasOverlappingRendering() {
+        return false;
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/MenuDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/MenuDrawable.java
index c75bc7b42..46137f3bb 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/MenuDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ActionBar/MenuDrawable.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.ActionBar;
@@ -11,6 +11,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
+import android.graphics.PixelFormat;
 import android.graphics.drawable.Drawable;
 import android.view.animation.DecelerateInterpolator;
 
@@ -79,11 +80,11 @@ public void draw(Canvas canvas) {
         canvas.save();
         canvas.translate(getIntrinsicWidth() / 2, getIntrinsicHeight() / 2);
         canvas.rotate(currentRotation * (reverseAngle ? -180 : 180));
-        canvas.drawLine(-AndroidUtilities.dp(9), 0, AndroidUtilities.dp(9) - AndroidUtilities.dp(1) * currentRotation, 0, paint);
+        canvas.drawLine(-AndroidUtilities.dp(9), 0, AndroidUtilities.dp(9) - AndroidUtilities.dp(3.0f) * currentRotation, 0, paint);
         float endYDiff = AndroidUtilities.dp(5) * (1 - Math.abs(currentRotation)) - AndroidUtilities.dp(0.5f) * Math.abs(currentRotation);
-        float endXDiff = AndroidUtilities.dp(9) - AndroidUtilities.dp(0.5f) *  Math.abs(currentRotation);
-        float startYDiff = AndroidUtilities.dp(5) + AndroidUtilities.dp(3.5f) * Math.abs(currentRotation);
-        float startXDiff = -AndroidUtilities.dp(9) + AndroidUtilities.dp(8.5f) * Math.abs(currentRotation);
+        float endXDiff = AndroidUtilities.dp(9) - AndroidUtilities.dp(2.5f) * Math.abs(currentRotation);
+        float startYDiff = AndroidUtilities.dp(5) + AndroidUtilities.dp(2.0f) * Math.abs(currentRotation);
+        float startXDiff = -AndroidUtilities.dp(9) + AndroidUtilities.dp(7.5f) * Math.abs(currentRotation);
         canvas.drawLine(startXDiff, -startYDiff, endXDiff, -endYDiff, paint);
         canvas.drawLine(startXDiff, startYDiff, endXDiff, endYDiff, paint);
         canvas.restore();
@@ -101,7 +102,7 @@ public void setColorFilter(ColorFilter cf) {
 
     @Override
     public int getOpacity() {
-        return 0;
+        return PixelFormat.TRANSPARENT;
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseFragmentAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseFragmentAdapter.java
index 131961344..57bd70eba 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseFragmentAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseFragmentAdapter.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseLocationAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseLocationAdapter.java
index c80eb04b8..bfd0457ed 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseLocationAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseLocationAdapter.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapter.java
index 011144e6e..f659249b0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
@@ -41,7 +41,7 @@
     protected HashMap<String, HashtagObject> hashtagsByText;
     protected boolean hashtagsLoadedFromDb = false;
 
-    public void queryServerSearch(final String query, final boolean allowChats) {
+    public void queryServerSearch(final String query, final boolean allowChats, final boolean allowBots) {
         if (reqId != 0) {
             ConnectionsManager.getInstance().cancelRequest(reqId, true);
             reqId = 0;
@@ -72,6 +72,9 @@ public void run() {
                                     }
                                 }
                                 for (int a = 0; a < res.users.size(); a++) {
+                                    if (!allowBots && res.users.get(a).bot) {
+                                        continue;
+                                    }
                                     globalSearch.add(res.users.get(a));
                                 }
                                 lastFoundUsername = query;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapterRecycler.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapterRecycler.java
index edd0b8614..5f343e675 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapterRecycler.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSearchAdapterRecycler.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSectionsAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSectionsAdapter.java
index f9b75addc..a6b493290 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSectionsAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/BaseSectionsAdapter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java
index afe18248d..91049dbe5 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ChatActivityAdapter.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ContactsAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ContactsAdapter.java
index 4fcff0663..c63eaf620 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ContactsAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/ContactsAdapter.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
@@ -238,7 +238,7 @@ public View getItemView(int section, int position, View convertView, ViewGroup p
             }
         } else if (type == 0) {
             if (convertView == null) {
-                convertView = new UserCell(mContext, 58);
+                convertView = new UserCell(mContext, 58, 1);
                 ((UserCell) convertView).setStatusColors(0xffa8a8a8, 0xff3b84c0);
             }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/CountryAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/CountryAdapter.java
index 3c577880d..216f27c8d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/CountryAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/CountryAdapter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/CountrySearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/CountrySearchAdapter.java
index b7da3404d..0282d9df7 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/CountrySearchAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/CountrySearchAdapter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsAdapter.java
index bb4bcad60..4b08cea02 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsAdapter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
@@ -46,7 +46,7 @@ public void setOpenedDialogId(long id) {
 
     public boolean isDataSetChanged() {
         int current = currentCount;
-        return current != getItemCount();
+        return current != getItemCount() || current == 1;
     }
 
     private ArrayList<TLRPC.Dialog> getDialogsArray() {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsSearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsSearchAdapter.java
index 6fcf25d82..8774e3199 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsSearchAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DialogsSearchAdapter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
@@ -16,6 +16,7 @@
 import org.telegram.SQLite.SQLiteCursor;
 import org.telegram.SQLite.SQLitePreparedStatement;
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.ChatObject;
 import org.telegram.messenger.ContactsController;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.MessageObject;
@@ -128,15 +129,29 @@ private void searchMessagesInternal(final String query) {
             }
             return;
         }
-        final TLRPC.TL_messages_search req = new TLRPC.TL_messages_search();
+
+        final TLRPC.TL_messages_searchGlobal req = new TLRPC.TL_messages_searchGlobal();
         req.limit = 20;
-        req.peer = new TLRPC.TL_inputPeerEmpty();
         req.q = query;
         if (lastMessagesSearchString != null && query.equals(lastMessagesSearchString) && !searchResultMessages.isEmpty()) {
-            req.max_id = searchResultMessages.get(searchResultMessages.size() - 1).getId();
+            MessageObject lastMessage = searchResultMessages.get(searchResultMessages.size() - 1);
+            req.offset_id = lastMessage.getId();
+            req.offset_date = lastMessage.messageOwner.date;
+            int id;
+            if (lastMessage.messageOwner.to_id.channel_id != 0) {
+                id = -lastMessage.messageOwner.to_id.channel_id;
+            } else if (lastMessage.messageOwner.to_id.chat_id != 0) {
+                id = -lastMessage.messageOwner.to_id.chat_id;
+            } else {
+                id = lastMessage.messageOwner.to_id.user_id;
+            }
+            req.offset_peer = MessagesController.getInputPeer(id);
+        } else {
+            req.offset_date = 0;
+            req.offset_id = 0;
+            req.offset_peer = new TLRPC.TL_inputPeerEmpty();
         }
         lastMessagesSearchString = query;
-        req.filter = new TLRPC.TL_inputMessagesFilterEmpty();
         final int currentReqId = ++lastReqId;
         if (delegate != null) {
             delegate.searchStateChanged(true);
@@ -153,7 +168,7 @@ public void run() {
                                 MessagesStorage.getInstance().putUsersAndChats(res.users, res.chats, true, true);
                                 MessagesController.getInstance().putUsers(res.users, false);
                                 MessagesController.getInstance().putChats(res.chats, false);
-                                if (req.max_id == 0) {
+                                if (req.offset_id == 0) {
                                     searchResultMessages.clear();
                                 }
                                 for (TLRPC.Message message : res.messages) {
@@ -178,7 +193,7 @@ public boolean hasRecentRearch() {
     }
 
     public boolean isRecentSearchDisplayed() {
-        return (lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty();
+        return needMessagesSearch != 2 && (lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty();
     }
 
     public void loadRecentSearch() {
@@ -258,7 +273,14 @@ public void run() {
                             } else {
                                 did = AndroidUtilities.makeBroadcastId(chat.id);
                             }
-                            hashMap.get(did).object = chat;
+                            if (chat.migrated_to != null) {
+                                RecentSearchObject recentSearchObject = hashMap.remove(did);
+                                if (recentSearchObject != null) {
+                                    arrayList.remove(recentSearchObject);
+                                }
+                            } else {
+                                hashMap.get(did).object = chat;
+                            }
                         }
                     }
 
@@ -391,7 +413,7 @@ public void run() {
                     int resultCount = 0;
 
                     HashMap<Long, DialogSearchResult> dialogsResult = new HashMap<>();
-                    SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT did, date FROM dialogs ORDER BY date DESC LIMIT 200");
+                    SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT did, date FROM dialogs ORDER BY date DESC LIMIT 400");
                     while (cursor.next()) {
                         long id = cursor.longValue(0);
                         DialogSearchResult dialogSearchResult = new DialogSearchResult();
@@ -481,16 +503,18 @@ public void run() {
                                     NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(0));
                                     if (data != null && cursor.byteBufferValue(0, data) != 0) {
                                         TLRPC.Chat chat = TLRPC.Chat.TLdeserialize(data, data.readInt32(false), false);
-                                        long dialog_id;
-                                        if (chat.id > 0) {
-                                            dialog_id = -chat.id;
-                                        } else {
-                                            dialog_id = AndroidUtilities.makeBroadcastId(chat.id);
+                                        if (!(chat == null || chat.deactivated || ChatObject.isChannel(chat) && ChatObject.isNotInChat(chat))) {
+                                            long dialog_id;
+                                            if (chat.id > 0) {
+                                                dialog_id = -chat.id;
+                                            } else {
+                                                dialog_id = AndroidUtilities.makeBroadcastId(chat.id);
+                                            }
+                                            DialogSearchResult dialogSearchResult = dialogsResult.get(dialog_id);
+                                            dialogSearchResult.name = AndroidUtilities.generateSearchName(chat.title, null, q);
+                                            dialogSearchResult.object = chat;
+                                            resultCount++;
                                         }
-                                        DialogSearchResult dialogSearchResult = dialogsResult.get(dialog_id);
-                                        dialogSearchResult.name = AndroidUtilities.generateSearchName(chat.title, null, q);
-                                        dialogSearchResult.object = chat;
-                                        resultCount++;
                                     }
                                     data.reuse();
                                     break;
@@ -589,7 +613,8 @@ public int compare(DialogSearchResult lhs, DialogSearchResult rhs) {
                     ArrayList<TLObject> resultArray = new ArrayList<>();
                     ArrayList<CharSequence> resultArrayNames = new ArrayList<>();
 
-                    for (DialogSearchResult dialogSearchResult : searchResults) {
+                    for (int a = 0; a < searchResults.size(); a++) {
+                        DialogSearchResult dialogSearchResult = searchResults.get(a);
                         resultArray.add(dialogSearchResult.object);
                         resultArrayNames.add(dialogSearchResult.name);
                     }
@@ -776,7 +801,7 @@ public void run() {
 
     @Override
     public int getItemCount() {
-        if ((lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
+        if (needMessagesSearch != 2 && (lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
             return recentSearchObjects.size() + 1;
         }
         if (!searchResultHashtags.isEmpty()) {
@@ -795,9 +820,21 @@ public int getItemCount() {
     }
 
     public Object getItem(int i) {
-        if ((lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
+        if (needMessagesSearch != 2 && (lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
             if (i > 0 && i - 1 < recentSearchObjects.size()) {
-                return recentSearchObjects.get(i - 1).object;
+                TLObject object = recentSearchObjects.get(i - 1).object;
+                if (object instanceof TLRPC.User) {
+                    TLRPC.User user = MessagesController.getInstance().getUser(((TLRPC.User) object).id);
+                    if (user != null) {
+                        object = user;
+                    }
+                } else if (object instanceof TLRPC.Chat) {
+                    TLRPC.Chat chat = MessagesController.getInstance().getChat(((TLRPC.Chat) object).id);
+                    if (chat != null) {
+                        object = chat;
+                    }
+                }
+                return object;
             } else {
                 return null;
             }
@@ -880,7 +917,7 @@ public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
                     user = MessagesController.getInstance().getUser(encryptedChat.user_id);
                 }
 
-                if ((lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
+                if (needMessagesSearch != 2 && (lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
                     isRecent = true;
                     cell.useSeparator = position != getItemCount() - 1;
                 } else {
@@ -914,7 +951,7 @@ public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
             }
             case 1: {
                 GreySectionCell cell = (GreySectionCell) holder.itemView;
-                if ((lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
+                if (needMessagesSearch != 2 && (lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
                     cell.setText(LocaleController.getString("Recent", R.string.Recent).toUpperCase());
                 } else if (!searchResultHashtags.isEmpty()) {
                     cell.setText(LocaleController.getString("Hashtags", R.string.Hashtags).toUpperCase());
@@ -946,7 +983,7 @@ public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
 
     @Override
     public int getItemViewType(int i) {
-        if ((lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
+        if (needMessagesSearch != 2 && (lastSearchText == null || lastSearchText.length() == 0) && !recentSearchObjects.isEmpty()) {
             return i == 0 ? 1 : 0;
         }
         if (!searchResultHashtags.isEmpty()) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DrawerLayoutAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DrawerLayoutAdapter.java
index e46e504af..efc5c3d3a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DrawerLayoutAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/DrawerLayoutAdapter.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivityAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivityAdapter.java
index a0efeae93..dbdadeba7 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivityAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivityAdapter.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivitySearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivitySearchAdapter.java
index bc030a09c..94669e132 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivitySearchAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/LocationActivitySearchAdapter.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java
index 370c02687..939f86f3c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/MentionsAdapter.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -166,8 +166,9 @@ public void searchUsernameOrHashtag(String text, int position, ArrayList<Message
             }
             String usernameString = result.toString().toLowerCase();
             ArrayList<TLRPC.User> newResult = new ArrayList<>();
-            if (info instanceof TLRPC.TL_chatFull) {
-                for (TLRPC.TL_chatParticipant chatParticipant : info.participants.participants) {
+            if (info.participants != null) {
+                for (int a = 0; a < info.participants.participants.size(); a++) {
+                    TLRPC.ChatParticipant chatParticipant = info.participants.participants.get(a);
                     TLRPC.User user = MessagesController.getInstance().getUser(chatParticipant.user_id);
                     if (user == null || UserObject.isUserSelf(user)) {
                         continue;
@@ -220,11 +221,13 @@ public int compare(TLRPC.User lhs, TLRPC.User rhs) {
             ArrayList<TLRPC.User> newResultUsers = new ArrayList<>();
             String command = result.toString().toLowerCase();
             for (HashMap.Entry<Integer, TLRPC.BotInfo> entry : botInfo.entrySet()) {
-                for (TLRPC.TL_botCommand botCommand : entry.getValue().commands) {
+                TLRPC.BotInfo botInfo = entry.getValue();
+                for (int a = 0; a < botInfo.commands.size(); a++) {
+                    TLRPC.TL_botCommand botCommand = botInfo.commands.get(a);
                     if (botCommand != null && botCommand.command != null && botCommand.command.startsWith(command)) {
                         newResult.add("/" + botCommand.command);
                         newResultHelp.add(botCommand.description);
-                        newResultUsers.add(MessagesController.getInstance().getUser(entry.getValue().user_id));
+                        newResultUsers.add(MessagesController.getInstance().getUser(botInfo.user_id));
                     }
                 }
             }
@@ -311,8 +314,12 @@ public Object getItem(int i) {
             if (i < 0 || i >= searchResultCommands.size()) {
                 return null;
             }
-            if (searchResultCommandsUsers != null && botsCount != 1) {
-                return String.format("%s@%s", searchResultCommands.get(i), searchResultCommandsUsers.get(i).username);
+            if (searchResultCommandsUsers != null && (botsCount != 1 || info instanceof TLRPC.TL_channelFull)) {
+                if (searchResultCommandsUsers.get(i) != null) {
+                    return String.format("%s@%s", searchResultCommands.get(i), searchResultCommandsUsers.get(i) != null ? searchResultCommandsUsers.get(i).username : "");
+                } else {
+                    return String.format("%s", searchResultCommands.get(i));
+                }
             }
             return searchResultCommands.get(i);
         }
@@ -338,7 +345,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
         } else if (searchResultHashtags != null) {
             ((MentionCell) view).setText(searchResultHashtags.get(i));
         }  else if (searchResultCommands != null) {
-            ((MentionCell) view).setBotCommand(searchResultCommands.get(i), searchResultCommandsHelp.get(i), searchResultCommandsUsers.get(i));
+            ((MentionCell) view).setBotCommand(searchResultCommands.get(i), searchResultCommandsHelp.get(i), searchResultCommandsUsers != null ? searchResultCommandsUsers.get(i) : null);
         }
         return view;
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/PhotoAttachAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/PhotoAttachAdapter.java
index 633a1cef0..b2bebdebe 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/PhotoAttachAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/PhotoAttachAdapter.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -41,6 +41,12 @@ public PhotoAttachAdapter(Context context) {
 
     public void clearSelectedPhotos() {
         if (!selectedPhotos.isEmpty()) {
+            for (HashMap.Entry<Integer, MediaController.PhotoEntry> entry : selectedPhotos.entrySet()) {
+                MediaController.PhotoEntry photoEntry = entry.getValue();
+                photoEntry.imagePath = null;
+                photoEntry.thumbPath = null;
+                photoEntry.caption = null;
+            }
             selectedPhotos.clear();
             delegate.selectedPhotosChanged();
             notifyDataSetChanged();
@@ -57,54 +63,44 @@ public void setDelegate(PhotoAttachAdapterDelegate photoAttachAdapterDelegate) {
 
     @Override
     public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
-        //if (position != 0) {
-            PhotoAttachPhotoCell cell = (PhotoAttachPhotoCell) holder.itemView;
-            MediaController.PhotoEntry photoEntry = MediaController.allPhotosAlbumEntry.photos.get(position/* - 1*/);
-            cell.setPhotoEntry(photoEntry, position == MediaController.allPhotosAlbumEntry.photos.size());
-            cell.setChecked(selectedPhotos.containsKey(photoEntry.imageId), false);
-        //}
+        PhotoAttachPhotoCell cell = (PhotoAttachPhotoCell) holder.itemView;
+        MediaController.PhotoEntry photoEntry = MediaController.allPhotosAlbumEntry.photos.get(position);
+        cell.setPhotoEntry(photoEntry, position == MediaController.allPhotosAlbumEntry.photos.size() - 1);
+        cell.setChecked(selectedPhotos.containsKey(photoEntry.imageId), false);
+        cell.getImageView().setTag(position);
+        cell.setTag(position);
     }
 
     @Override
     public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        View view;
-        /*if (viewType == 0) {
-            view = new PhotoAttachCameraCell(mContext);
-        } else {*/
-            PhotoAttachPhotoCell cell = new PhotoAttachPhotoCell(mContext);
-            /*cell.setOnCheckClickLisnener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    onItemClick((PhotoAttachPhotoCell) v.getParent());
+        PhotoAttachPhotoCell cell = new PhotoAttachPhotoCell(mContext);
+        cell.setDelegate(new PhotoAttachPhotoCell.PhotoAttachPhotoCellDelegate() {
+            @Override
+            public void onCheckClick(PhotoAttachPhotoCell v) {
+                MediaController.PhotoEntry photoEntry = v.getPhotoEntry();
+                if (selectedPhotos.containsKey(photoEntry.imageId)) {
+                    selectedPhotos.remove(photoEntry.imageId);
+                    v.setChecked(false, true);
+                    photoEntry.imagePath = null;
+                    photoEntry.thumbPath = null;
+                    v.setPhotoEntry(photoEntry, v.getTag() == MediaController.allPhotosAlbumEntry.photos.size() - 1);
+                } else {
+                    selectedPhotos.put(photoEntry.imageId, photoEntry);
+                    v.setChecked(true, true);
                 }
-            });
-            view = cell;*/
-        //}
+                delegate.selectedPhotosChanged();
+            }
+        });
         return new Holder(cell);
     }
 
-    public void onItemClick(PhotoAttachPhotoCell cell) {
-        MediaController.PhotoEntry photoEntry = cell.getPhotoEntry();
-        if (selectedPhotos.containsKey(photoEntry.imageId)) {
-            selectedPhotos.remove(photoEntry.imageId);
-            cell.setChecked(false, true);
-        } else {
-            selectedPhotos.put(photoEntry.imageId, photoEntry);
-            cell.setChecked(true, true);
-        }
-        delegate.selectedPhotosChanged();
-    }
-
     @Override
     public int getItemCount() {
-        return /*1 + */(MediaController.allPhotosAlbumEntry != null ? MediaController.allPhotosAlbumEntry.photos.size() : 0);
+        return (MediaController.allPhotosAlbumEntry != null ? MediaController.allPhotosAlbumEntry.photos.size() : 0);
     }
 
     @Override
     public int getItemViewType(int position) {
-        //if (position == 0) {
-            return 0;
-        //}
-        //return 1;
+        return 0;
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java
index 09fd654b6..3d734d623 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/SearchAdapter.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
@@ -43,13 +43,15 @@
     private boolean useUserCell;
     private boolean onlyMutual;
     private boolean allowChats;
+    private boolean allowBots;
 
-    public SearchAdapter(Context context, HashMap<Integer, TLRPC.User> arg1, boolean usernameSearch, boolean mutual, boolean chats) {
+    public SearchAdapter(Context context, HashMap<Integer, TLRPC.User> arg1, boolean usernameSearch, boolean mutual, boolean chats, boolean bots) {
         mContext = context;
         ignoreUsers = arg1;
         onlyMutual = mutual;
         allowUsernameSearch = usernameSearch;
         allowChats = chats;
+        allowBots = bots;
     }
 
     public void setCheckedMap(HashMap<Integer, ?> map) {
@@ -72,7 +74,7 @@ public void searchDialogs(final String query) {
             searchResult.clear();
             searchResultNames.clear();
             if (allowUsernameSearch) {
-                queryServerSearch(null, allowChats);
+                queryServerSearch(null, allowChats, allowBots);
             }
             notifyDataSetChanged();
         } else {
@@ -97,7 +99,7 @@ private void processSearch(final String query) {
             @Override
             public void run() {
                 if (allowUsernameSearch) {
-                    queryServerSearch(query, allowChats);
+                    queryServerSearch(query, allowChats, allowBots);
                 }
                 final ArrayList<TLRPC.TL_contact> contactsCopy = new ArrayList<>();
                 contactsCopy.addAll(ContactsController.getInstance().contacts);
@@ -122,9 +124,10 @@ public void run() {
                         ArrayList<TLRPC.User> resultArray = new ArrayList<>();
                         ArrayList<CharSequence> resultArrayNames = new ArrayList<>();
 
-                        for (TLRPC.TL_contact contact : contactsCopy) {
+                        for (int a = 0; a < contactsCopy.size(); a++) {
+                            TLRPC.TL_contact contact = contactsCopy.get(a);
                             TLRPC.User user = MessagesController.getInstance().getUser(contact.user_id);
-                            if (user.id == UserConfig.getClientUserId() || onlyMutual && (user.flags & TLRPC.USER_FLAG_MUTUAL_CONTACT) == 0) {
+                            if (user.id == UserConfig.getClientUserId() || onlyMutual && !user.mutual_contact) {
                                 continue;
                             }
 
@@ -235,7 +238,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
         } else {
             if (view == null) {
                 if (useUserCell) {
-                    view = new UserCell(mContext, 1);
+                    view = new UserCell(mContext, 1, 1);
                     if (checkedMap != null) {
                         ((UserCell) view).setChecked(false, false);
                     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/StickersAdapter.java b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/StickersAdapter.java
index 4bbe6a5e6..326e207a2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Adapters/StickersAdapter.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Adapters/StickersAdapter.java
@@ -3,12 +3,13 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Adapters;
 
 import android.content.Context;
+import android.text.TextUtils;
 import android.view.View;
 import android.view.ViewGroup;
 
@@ -87,8 +88,18 @@ private boolean checkStickerFilesExistAndDownload() {
     }
 
     public void loadStikersForEmoji(CharSequence emoji) {
-        boolean search = emoji != null && emoji.length() > 0 && emoji.length() <= 4;
+        boolean search = emoji != null && emoji.length() > 0 && emoji.length() <= 14;
         if (search) {
+            int length = emoji.length();
+            for (int a = 0; a < length; a++) {
+                if (a < length - 1 && emoji.charAt(a) == 0xD83C && emoji.charAt(a + 1) >= 0xDFFB && emoji.charAt(a + 1) <= 0xDFFF) {
+                    emoji = TextUtils.concat(emoji.subSequence(0, a), emoji.subSequence(a + 2, emoji.length()));
+                    break;
+                } else if (emoji.charAt(a) == 0xfe0f) {
+                    emoji = TextUtils.concat(emoji.subSequence(0, a), emoji.subSequence(a + 1, emoji.length()));
+                    length--;
+                }
+            }
             lastSticker = emoji.toString();
             HashMap<String, ArrayList<TLRPC.Document>> allStickers = StickersQuery.getAllStickers();
             if (allStickers != null) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/AudioPlayerActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/AudioPlayerActivity.java
index 1b4c9edf8..d0498c332 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/AudioPlayerActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/AudioPlayerActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/AudioSelectActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/AudioSelectActivity.java
index 286929828..e36481087 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/AudioSelectActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/AudioSelectActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -77,7 +77,7 @@ public void onFragmentDestroy() {
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.closeChats);
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.audioDidReset);
         if (playingAudio != null && MediaController.getInstance().isPlayingAudio(playingAudio)) {
-            MediaController.getInstance().clenupPlayer(true, true);
+            MediaController.getInstance().cleanupPlayer(true, true);
         }
     }
 
@@ -217,7 +217,7 @@ public void run() {
                         File file = new File(audioEntry.path);
 
                         TLRPC.TL_message message = new TLRPC.TL_message();
-                        message.flags = TLRPC.MESSAGE_FLAG_OUT;
+                        message.out = true;
                         message.id = id;
                         message.to_id = new TLRPC.TL_peerUser();
                         message.to_id.user_id = message.from_id = UserConfig.getClientUserId();
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/BlockedUsersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/BlockedUsersActivity.java
index c5d1bf60d..60da89d32 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/BlockedUsersActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/BlockedUsersActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -263,7 +263,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
             int type = getItemViewType(i);
             if (type == 0) {
                 if (view == null) {
-                    view = new UserCell(mContext, 1);
+                    view = new UserCell(mContext, 1, 0);
                 }
                 TLRPC.User user = MessagesController.getInstance().getUser(MessagesController.getInstance().blockedUsers.get(i));
                 if (user != null) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/CacheControlActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/CacheControlActivity.java
new file mode 100644
index 000000000..2d31df1fc
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/CacheControlActivity.java
@@ -0,0 +1,659 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui;
+
+import android.app.Activity;
+import android.app.AlarmManager;
+import android.app.AlertDialog;
+import android.app.PendingIntent;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.ListView;
+
+import org.telegram.SQLite.SQLiteCursor;
+import org.telegram.SQLite.SQLiteDatabase;
+import org.telegram.SQLite.SQLitePreparedStatement;
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.ClearCacheService;
+import org.telegram.messenger.FileLoader;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.ImageLoader;
+import org.telegram.messenger.LocaleController;
+import org.telegram.messenger.MessagesStorage;
+import org.telegram.messenger.R;
+import org.telegram.messenger.Utilities;
+import org.telegram.messenger.query.BotQuery;
+import org.telegram.tgnet.NativeByteBuffer;
+import org.telegram.tgnet.TLRPC;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.ActionBar.BottomSheet;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.CheckBoxCell;
+import org.telegram.ui.Cells.TextInfoPrivacyCell;
+import org.telegram.ui.Cells.TextSettingsCell;
+import org.telegram.ui.Components.LayoutHelper;
+
+import java.io.File;
+import java.util.ArrayList;
+
+public class CacheControlActivity extends BaseFragment {
+
+    private ListAdapter listAdapter;
+
+    private int databaseRow;
+    private int databaseInfoRow;
+    private int keepMediaRow;
+    private int keepMediaInfoRow;
+    private int cacheRow;
+    private int cacheInfoRow;
+    private int rowCount;
+
+    private long databaseSize = -1;
+    private long cacheSize = -1;
+    private long documentsSize = -1;
+    private long audioSize = -1;
+    private long musicSize = -1;
+    private long photoSize = -1;
+    private long videoSize = -1;
+    private long totalSize = -1;
+    private boolean clear[] = new boolean[6];
+    private boolean calculating = true;
+
+    private volatile boolean canceled = false;
+
+    @Override
+    public boolean onFragmentCreate() {
+        super.onFragmentCreate();
+
+        rowCount = 0;
+        keepMediaRow = rowCount++;
+        keepMediaInfoRow = rowCount++;
+        cacheRow = rowCount++;
+        cacheInfoRow = rowCount++;
+
+        databaseRow = rowCount++;
+        databaseInfoRow = rowCount++;
+
+        File file = new File(ApplicationLoader.getFilesDirFixed(), "cache4.db");
+        databaseSize = file.length();
+
+        Utilities.globalQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                cacheSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_CACHE), 0);
+                if (canceled) {
+                    return;
+                }
+                photoSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_IMAGE), 0);
+                if (canceled) {
+                    return;
+                }
+                videoSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_VIDEO), 0);
+                if (canceled) {
+                    return;
+                }
+                documentsSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_DOCUMENT), 1);
+                if (canceled) {
+                    return;
+                }
+                musicSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_DOCUMENT), 2);
+                if (canceled) {
+                    return;
+                }
+                audioSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_AUDIO), 0);
+                totalSize = cacheSize + videoSize + audioSize + photoSize + documentsSize + musicSize;
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        calculating = false;
+                        if (listAdapter != null) {
+                            listAdapter.notifyDataSetChanged();
+                        }
+                    }
+                });
+            }
+        });
+
+        return true;
+    }
+
+    @Override
+    public void onFragmentDestroy() {
+        super.onFragmentDestroy();
+        canceled = true;
+    }
+
+    /*private long getDirectorySize2(File dir) {
+        long size = 0;
+        if (dir.isDirectory()) {
+            File[] array = dir.listFiles();
+            if (array != null) {
+                for (int a = 0; a < array.length; a++) {
+                    File file = array[a];
+                    if (file.isDirectory()) {
+                        size += getDirectorySize2(file);
+                    } else {
+                        size += file.length();
+                        FileLog.e("tmessages", "" + file + " size = " + file.length());
+                    }
+                }
+            }
+        } else if (dir.isFile()) {
+            FileLog.e("tmessages", "" + dir + " size = " + dir.length());
+            size += dir.length();
+        }
+        return size;
+    }*/
+
+    private long getDirectorySize(File dir, int documentsMusicType) {
+        if (dir == null || canceled) {
+            return 0;
+        }
+        long size = 0;
+        if (dir.isDirectory()) {
+            try {
+                File[] array = dir.listFiles();
+                if (array != null) {
+                    for (int a = 0; a < array.length; a++) {
+                        if (canceled) {
+                            return 0;
+                        }
+                        File file = array[a];
+                        if (documentsMusicType == 1 || documentsMusicType == 2) {
+                            String name = file.getName().toLowerCase();
+                            if (name.endsWith(".mp3") || name.endsWith(".m4a")) {
+                                if (documentsMusicType == 1) {
+                                    continue;
+                                }
+                            } else if (documentsMusicType == 2) {
+                                continue;
+                            }
+                        }
+                        if (file.isDirectory()) {
+                            size += getDirectorySize(file, documentsMusicType);
+                        } else {
+                            size += file.length();
+                        }
+                    }
+                }
+            } catch (Throwable e) {
+                FileLog.e("tmessages", e);
+            }
+        } else if (dir.isFile()) {
+            size += dir.length();
+        }
+        return size;
+    }
+
+    private void cleanupFolders() {
+        final ProgressDialog progressDialog = new ProgressDialog(getParentActivity());
+        progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
+        progressDialog.setCanceledOnTouchOutside(false);
+        progressDialog.setCancelable(false);
+        progressDialog.show();
+        Utilities.globalQueue.postRunnable(new Runnable() {
+            @Override
+            public void run() {
+                boolean imagesCleared = false;
+                for (int a = 0; a < 6; a++) {
+                    if (!clear[a]) {
+                        continue;
+                    }
+                    int type = -1;
+                    int documentsMusicType = 0;
+                    if (a == 0) {
+                        type = FileLoader.MEDIA_DIR_IMAGE;
+                    } else if (a == 1) {
+                        type = FileLoader.MEDIA_DIR_VIDEO;
+                    } else if (a == 2) {
+                        type = FileLoader.MEDIA_DIR_DOCUMENT;
+                        documentsMusicType = 1;
+                    } else if (a == 3) {
+                        type = FileLoader.MEDIA_DIR_DOCUMENT;
+                        documentsMusicType = 2;
+                    } else if (a == 4) {
+                        type = FileLoader.MEDIA_DIR_AUDIO;
+                    } else if (a == 5) {
+                        type = FileLoader.MEDIA_DIR_CACHE;
+                    }
+                    if (type == -1) {
+                        continue;
+                    }
+                    File file = FileLoader.getInstance().checkDirectory(type);
+                    if (file != null) {
+                        try {
+                            File[] array = file.listFiles();
+                            if (array != null) {
+                                for (int b = 0; b < array.length; b++) {
+                                    if (documentsMusicType == 1 || documentsMusicType == 2) {
+                                        String name = array[b].getName().toLowerCase();
+                                        if (name.endsWith(".mp3") || name.endsWith(".m4a")) {
+                                            if (documentsMusicType == 1) {
+                                                continue;
+                                            }
+                                        } else if (documentsMusicType == 2) {
+                                            continue;
+                                        }
+                                    }
+                                    if (array[b].isFile()) {
+                                        array[b].delete();
+                                    }
+                                }
+                            }
+                        } catch (Throwable e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+                    if (type == FileLoader.MEDIA_DIR_CACHE) {
+                        cacheSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_CACHE), documentsMusicType);
+                        imagesCleared = true;
+                    } else if (type == FileLoader.MEDIA_DIR_AUDIO) {
+                        audioSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_AUDIO), documentsMusicType);
+                    } else if (type == FileLoader.MEDIA_DIR_DOCUMENT) {
+                        if (documentsMusicType == 1) {
+                            documentsSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_DOCUMENT), documentsMusicType);
+                        } else {
+                            musicSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_DOCUMENT), documentsMusicType);
+                        }
+                    } else if (type == FileLoader.MEDIA_DIR_IMAGE) {
+                        imagesCleared = true;
+                        photoSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_IMAGE), documentsMusicType);
+                    } else if (type == FileLoader.MEDIA_DIR_VIDEO) {
+                        videoSize = getDirectorySize(FileLoader.getInstance().checkDirectory(FileLoader.MEDIA_DIR_VIDEO), documentsMusicType);
+                    }
+                }
+                final boolean imagesClearedFinal = imagesCleared;
+                totalSize = cacheSize + videoSize + audioSize + photoSize + documentsSize + musicSize;
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (imagesClearedFinal) {
+                            ImageLoader.getInstance().clearMemory();
+                        }
+                        if (listAdapter != null) {
+                            listAdapter.notifyDataSetChanged();
+                        }
+                        try {
+                            progressDialog.dismiss();
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    @Override
+    public View createView(Context context) {
+        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setAllowOverlayTitle(true);
+        actionBar.setTitle(LocaleController.getString("CacheSettings", R.string.CacheSettings));
+        actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+            @Override
+            public void onItemClick(int id) {
+                if (id == -1) {
+                    finishFragment();
+                }
+            }
+        });
+
+        listAdapter = new ListAdapter(context);
+
+        fragmentView = new FrameLayout(context);
+        FrameLayout frameLayout = (FrameLayout) fragmentView;
+        frameLayout.setBackgroundColor(0xfff0f0f0);
+
+        ListView listView = new ListView(context);
+        listView.setDivider(null);
+        listView.setDividerHeight(0);
+        listView.setVerticalScrollBarEnabled(false);
+        listView.setDrawSelectorOnTop(true);
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        listView.setAdapter(listAdapter);
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(final AdapterView<?> adapterView, View view, final int i, long l) {
+                if (i == keepMediaRow) {
+                    BottomSheet.Builder builder = new BottomSheet.Builder(getParentActivity());
+                    builder.setItems(new CharSequence[]{LocaleController.formatPluralString("Weeks", 1), LocaleController.formatPluralString("Months", 1), LocaleController.getString("KeepMediaForever", R.string.KeepMediaForever)}, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, final int which) {
+                            SharedPreferences.Editor editor = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE).edit();
+                            editor.putInt("keep_media", which).commit();
+                            if (listAdapter != null) {
+                                listAdapter.notifyDataSetChanged();
+                            }
+                            PendingIntent pintent = PendingIntent.getService(ApplicationLoader.applicationContext, 0, new Intent(ApplicationLoader.applicationContext, ClearCacheService.class), 0);
+                            AlarmManager alarmManager = (AlarmManager) ApplicationLoader.applicationContext.getSystemService(Context.ALARM_SERVICE);
+                            if (which == 2) {
+                                alarmManager.cancel(pintent);
+                            } else {
+                                alarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, AlarmManager.INTERVAL_DAY, AlarmManager.INTERVAL_DAY, pintent);
+                            }
+                        }
+                    });
+                    showDialog(builder.create());
+
+                } else if (i == databaseRow) {
+                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                    builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                    builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                    builder.setMessage(LocaleController.getString("LocalDatabaseClear", R.string.LocalDatabaseClear));
+                    builder.setPositiveButton(LocaleController.getString("CacheClear", R.string.CacheClear), new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            final ProgressDialog progressDialog = new ProgressDialog(getParentActivity());
+                            progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
+                            progressDialog.setCanceledOnTouchOutside(false);
+                            progressDialog.setCancelable(false);
+                            progressDialog.show();
+                            MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+                                @Override
+                                public void run() {
+                                    try {
+                                        SQLiteDatabase database = MessagesStorage.getInstance().getDatabase();
+                                        ArrayList<Long> dialogsToCleanup = new ArrayList<>();
+                                        SQLiteCursor cursor = database.queryFinalized("SELECT did FROM dialogs WHERE 1");
+                                        StringBuilder ids = new StringBuilder();
+                                        while (cursor.next()) {
+                                            long did = cursor.longValue(0);
+                                            int lower_id = (int) did;
+                                            int high_id = (int) (did >> 32);
+                                            if (lower_id != 0 && high_id != 1) {
+                                                dialogsToCleanup.add(did);
+                                            }
+                                        }
+                                        cursor.dispose();
+
+                                        SQLitePreparedStatement state5 = database.executeFast("REPLACE INTO messages_holes VALUES(?, ?, ?)");
+                                        SQLitePreparedStatement state6 = database.executeFast("REPLACE INTO media_holes_v2 VALUES(?, ?, ?, ?)");
+                                        SQLitePreparedStatement state7 = database.executeFast("REPLACE INTO messages_imp_holes VALUES(?, ?, ?)");
+                                        SQLitePreparedStatement state8 = database.executeFast("REPLACE INTO channel_group VALUES(?, ?, ?, ?)");
+
+                                        database.beginTransaction();
+                                        for (int a = 0; a < dialogsToCleanup.size(); a++) {
+                                            Long did = dialogsToCleanup.get(a);
+                                            int messagesCount = 0;
+                                            cursor = database.queryFinalized("SELECT COUNT(mid) FROM messages WHERE uid = " + did);
+                                            if (cursor.next()) {
+                                                messagesCount = cursor.intValue(0);
+                                            }
+                                            cursor.dispose();
+                                            if (messagesCount <= 2) {
+                                                continue;
+                                            }
+
+                                            cursor = database.queryFinalized("SELECT last_mid_i, last_mid FROM dialogs WHERE did = " + did);
+                                            ArrayList<TLRPC.Message> arrayList = new ArrayList<>();
+                                            if (cursor.next()) {
+                                                long last_mid_i = cursor.longValue(0);
+                                                long last_mid = cursor.longValue(1);
+                                                SQLiteCursor cursor2 = database.queryFinalized("SELECT data FROM messages WHERE uid = " + did + " AND mid IN (" + last_mid_i + "," + last_mid + ")");
+                                                try {
+                                                    while (cursor2.next()) {
+                                                        NativeByteBuffer data = new NativeByteBuffer(cursor2.byteArrayLength(0));
+                                                        if (data != null && cursor2.byteBufferValue(0, data) != 0) {
+                                                            TLRPC.Message message = TLRPC.Message.TLdeserialize(data, data.readInt32(false), false);
+                                                            if (message == null) {
+                                                                continue;
+                                                            }
+                                                            arrayList.add(message);
+                                                        }
+                                                        data.reuse();
+                                                    }
+                                                } catch (Exception e) {
+                                                    FileLog.e("tmessages", e);
+                                                }
+                                                cursor2.dispose();
+
+                                                database.executeFast("DELETE FROM messages WHERE uid = " + did + " AND mid != " + last_mid_i + " AND mid != " + last_mid).stepThis().dispose();
+                                                database.executeFast("DELETE FROM channel_group WHERE uid = " + did).stepThis().dispose();
+                                                database.executeFast("DELETE FROM messages_holes WHERE uid = " + did).stepThis().dispose();
+                                                database.executeFast("DELETE FROM messages_imp_holes WHERE uid = " + did).stepThis().dispose();
+                                                database.executeFast("DELETE FROM bot_keyboard WHERE uid = " + did).stepThis().dispose();
+                                                database.executeFast("DELETE FROM media_counts_v2 WHERE uid = " + did).stepThis().dispose();
+                                                database.executeFast("DELETE FROM media_v2 WHERE uid = " + did).stepThis().dispose();
+                                                database.executeFast("DELETE FROM media_holes_v2 WHERE uid = " + did).stepThis().dispose();
+                                                BotQuery.clearBotKeyboard(did, null);
+                                                MessagesStorage.createFirstHoles(did, state5, state6, state7, state8, arrayList);
+                                            }
+                                            cursor.dispose();
+                                        }
+                                        state5.dispose();
+                                        state6.dispose();
+                                        state7.dispose();
+                                        state8.dispose();
+                                        database.commitTransaction();
+                                        database.executeFast("VACUUM").stepThis().dispose();
+                                    } catch (Exception e) {
+                                        FileLog.e("tmessages", e);
+                                    } finally {
+                                        AndroidUtilities.runOnUIThread(new Runnable() {
+                                            @Override
+                                            public void run() {
+                                                try {
+                                                    progressDialog.dismiss();
+                                                } catch (Exception e) {
+                                                    FileLog.e("tmessages", e);
+                                                }
+                                                if (listAdapter != null) {
+                                                    File file = new File(ApplicationLoader.getFilesDirFixed(), "cache4.db");
+                                                    databaseSize = file.length();
+                                                    listAdapter.notifyDataSetChanged();
+                                                }
+                                            }
+                                        });
+                                    }
+                                }
+                            });
+                        }
+                    });
+                    showDialog(builder.create());
+                } else if (i == cacheRow) {
+                    if (totalSize <= 0 || getParentActivity() == null) {
+                        return;
+                    }
+                    BottomSheet.Builder builder = new BottomSheet.Builder(getParentActivity());
+                    builder.setApplyTopPaddings(false);
+                    LinearLayout linearLayout = new LinearLayout(getParentActivity());
+                    linearLayout.setOrientation(LinearLayout.VERTICAL);
+                    for (int a = 0; a < 6; a++) {
+                        long size = 0;
+                        String name = null;
+                        if (a == 0) {
+                            size = photoSize;
+                            name = LocaleController.getString("LocalPhotoCache", R.string.LocalPhotoCache);
+                        } else if (a == 1) {
+                            size = videoSize;
+                            name = LocaleController.getString("LocalVideoCache", R.string.LocalVideoCache);
+                        } else if (a == 2) {
+                            size = documentsSize;
+                            name = LocaleController.getString("LocalDocumentCache", R.string.LocalDocumentCache);
+                        } else if (a == 3) {
+                            size = musicSize;
+                            name = LocaleController.getString("LocalMusicCache", R.string.LocalMusicCache);
+                        } else if (a == 4) {
+                            size = audioSize;
+                            name = LocaleController.getString("LocalAudioCache", R.string.LocalAudioCache);
+                        } else if (a == 5) {
+                            size = cacheSize;
+                            name = LocaleController.getString("LocalCache", R.string.LocalCache);
+                        }
+                        if (size > 0) {
+                            clear[a] = true;
+                            CheckBoxCell checkBoxCell = new CheckBoxCell(getParentActivity());
+                            checkBoxCell.setTag(a);
+                            checkBoxCell.setBackgroundResource(R.drawable.list_selector);
+                            linearLayout.addView(checkBoxCell, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
+                            checkBoxCell.setText(name, AndroidUtilities.formatFileSize(size), true, true);
+                            checkBoxCell.setOnClickListener(new View.OnClickListener() {
+                                @Override
+                                public void onClick(View v) {
+                                    CheckBoxCell cell = (CheckBoxCell) v;
+                                    int num = (Integer) cell.getTag();
+                                    clear[num] = !clear[num];
+                                    cell.setChecked(clear[num], true);
+                                }
+                            });
+                        } else {
+                            clear[a] = false;
+                        }
+                    }
+                    BottomSheet.BottomSheetCell cell = new BottomSheet.BottomSheetCell(getParentActivity(), 2);
+                    cell.setBackgroundResource(R.drawable.list_selector);
+                    cell.setTextAndIcon(LocaleController.getString("ClearMediaCache", R.string.ClearMediaCache).toUpperCase(), 0);
+                    cell.setTextColor(0xffcd5a5a);
+                    cell.setOnClickListener(new View.OnClickListener() {
+                        @Override
+                        public void onClick(View v) {
+                            try {
+                                if (visibleDialog != null) {
+                                    visibleDialog.dismiss();
+                                }
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                            cleanupFolders();
+                        }
+                    });
+                    linearLayout.addView(cell, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 48));
+                    builder.setCustomView(linearLayout);
+                    showDialog(builder.create());
+                }
+            }
+        });
+
+        return fragmentView;
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+    }
+
+    private class ListAdapter extends BaseFragmentAdapter {
+        private Context mContext;
+
+        public ListAdapter(Context context) {
+            mContext = context;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            return i == databaseRow || i == cacheRow && totalSize > 0 || i == keepMediaRow;
+        }
+
+        @Override
+        public int getCount() {
+            return rowCount;
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return false;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            int type = getItemViewType(i);
+            if (type == 0) {
+                if (view == null) {
+                    view = new TextSettingsCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                TextSettingsCell textCell = (TextSettingsCell) view;
+                if (i == databaseRow) {
+                    textCell.setTextAndValue(LocaleController.getString("LocalDatabase", R.string.LocalDatabase), AndroidUtilities.formatFileSize(databaseSize), false);
+                } else if (i == cacheRow) {
+                    if (calculating) {
+                        textCell.setTextAndValue(LocaleController.getString("ClearMediaCache", R.string.ClearMediaCache), LocaleController.getString("CalculatingSize", R.string.CalculatingSize), false);
+                    } else {
+                        textCell.setTextAndValue(LocaleController.getString("ClearMediaCache", R.string.ClearMediaCache), totalSize == 0 ? LocaleController.getString("CacheEmpty", R.string.CacheEmpty) : AndroidUtilities.formatFileSize(totalSize), false);
+                    }
+                } else if (i == keepMediaRow) {
+                    SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
+                    int keepMedia = preferences.getInt("keep_media", 2);
+                    String value;
+                    if (keepMedia == 0) {
+                        value = LocaleController.formatPluralString("Weeks", 1);
+                    } else if (keepMedia == 1) {
+                        value = LocaleController.formatPluralString("Months", 1);
+                    } else {
+                        value = LocaleController.getString("KeepMediaForever", R.string.KeepMediaForever);
+                    }
+                    textCell.setTextAndValue(LocaleController.getString("KeepMedia", R.string.KeepMedia), value, false);
+                }
+            } else if (type == 1) {
+                if (view == null) {
+                    view = new TextInfoPrivacyCell(mContext);
+                }
+                if (i == databaseInfoRow) {
+                    ((TextInfoPrivacyCell) view).setText(LocaleController.getString("LocalDatabaseInfo", R.string.LocalDatabaseInfo));
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                } else if (i == cacheInfoRow) {
+                    ((TextInfoPrivacyCell) view).setText("");
+                    view.setBackgroundResource(R.drawable.greydivider);
+                } else if (i == keepMediaInfoRow) {
+                    ((TextInfoPrivacyCell) view).setText(AndroidUtilities.replaceTags(LocaleController.getString("KeepMediaInfo", R.string.KeepMediaInfo)));
+                    view.setBackgroundResource(R.drawable.greydivider);
+                }
+            }
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            if (i == databaseRow || i == cacheRow || i == keepMediaRow) {
+                return 0;
+            } else if (i == databaseInfoRow || i == cacheInfoRow || i == keepMediaInfoRow) {
+                return 1;
+            }
+            return 0;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 2;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/AboutLinkCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AboutLinkCell.java
new file mode 100644
index 000000000..c34b34058
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AboutLinkCell.java
@@ -0,0 +1,187 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.text.Layout;
+import android.text.Spannable;
+import android.text.SpannableStringBuilder;
+import android.text.StaticLayout;
+import android.text.TextPaint;
+import android.text.style.ClickableSpan;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.Emoji;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.LocaleController;
+import org.telegram.messenger.MessageObject;
+import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.LinkPath;
+import org.telegram.ui.Components.URLSpanNoUnderline;
+
+public class AboutLinkCell extends FrameLayout {
+
+    private StaticLayout textLayout;
+    private TextPaint textPaint;
+    private Paint urlPaint;
+    private String oldText;
+    private int textX;
+    private int textY;
+    private SpannableStringBuilder stringBuilder;
+
+    private ImageView imageView;
+
+    private ClickableSpan pressedLink;
+    private LinkPath urlPath = new LinkPath();
+
+    private AboutLinkCellDelegate delegate;
+
+    public interface AboutLinkCellDelegate {
+        void didPressUrl(String url);
+    }
+
+    public AboutLinkCell(Context context) {
+        super(context);
+
+        textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
+        textPaint.setTextSize(AndroidUtilities.dp(16));
+        textPaint.setColor(0xff000000);
+        textPaint.linkColor = 0xff316f9f;
+
+        urlPaint = new Paint();
+        urlPaint.setColor(0x33316f9f);
+
+        imageView = new ImageView(context);
+        imageView.setScaleType(ImageView.ScaleType.CENTER);
+        addView(imageView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 16, 5, LocaleController.isRTL ? 16 : 0, 0));
+        setWillNotDraw(false);
+    }
+
+    public void setDelegate(AboutLinkCellDelegate botHelpCellDelegate) {
+        delegate = botHelpCellDelegate;
+    }
+
+    private void resetPressedLink() {
+        if (pressedLink != null) {
+            pressedLink = null;
+        }
+        invalidate();
+    }
+
+    public void setTextAndIcon(String text, int resId) {
+        if (text == null || text.length() == 0) {
+            setVisibility(GONE);
+            return;
+        }
+        if (text != null && oldText != null && text.equals(oldText)) {
+            return;
+        }
+        oldText = text;
+        stringBuilder = new SpannableStringBuilder(oldText);
+        MessageObject.addLinks(stringBuilder, false);
+        Emoji.replaceEmoji(stringBuilder, textPaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
+        requestLayout();
+        if (resId == 0) {
+            imageView.setImageDrawable(null);
+        } else {
+            imageView.setImageResource(resId);
+        }
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        float x = event.getX();
+        float y = event.getY();
+
+        boolean result = false;
+        if (textLayout != null) {
+            if (event.getAction() == MotionEvent.ACTION_DOWN || pressedLink != null && event.getAction() == MotionEvent.ACTION_UP) {
+                if (event.getAction() == MotionEvent.ACTION_DOWN) {
+                    resetPressedLink();
+                    try {
+                        int x2 = (int) (x - textX);
+                        int y2 = (int) (y - textY);
+                        final int line = textLayout.getLineForVertical(y2);
+                        final int off = textLayout.getOffsetForHorizontal(line, x2);
+
+                        final float left = textLayout.getLineLeft(line);
+                        if (left <= x2 && left + textLayout.getLineWidth(line) >= x2) {
+                            Spannable buffer = (Spannable) textLayout.getText();
+                            ClickableSpan[] link = buffer.getSpans(off, off, ClickableSpan.class);
+                            if (link.length != 0) {
+                                resetPressedLink();
+                                pressedLink = link[0];
+                                result = true;
+                                try {
+                                    int start = buffer.getSpanStart(pressedLink);
+                                    urlPath.setCurrentLayout(textLayout, start);
+                                    textLayout.getSelectionPath(start, buffer.getSpanEnd(pressedLink), urlPath);
+                                } catch (Exception e) {
+                                    FileLog.e("tmessages", e);
+                                }
+                            } else {
+                                resetPressedLink();
+                            }
+                        } else {
+                            resetPressedLink();
+                        }
+                    } catch (Exception e) {
+                        resetPressedLink();
+                        FileLog.e("tmessages", e);
+                    }
+                } else if (pressedLink != null) {
+                    try {
+                        if (pressedLink instanceof URLSpanNoUnderline) {
+                            String url = ((URLSpanNoUnderline) pressedLink).getURL();
+                            if (url.startsWith("@") || url.startsWith("#") || url.startsWith("/")) {
+                                if (delegate != null) {
+                                    delegate.didPressUrl(url);
+                                }
+                            }
+                        } else {
+                            pressedLink.onClick(this);
+                        }
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                    resetPressedLink();
+                    result = true;
+                }
+            } else if (event.getAction() == MotionEvent.ACTION_CANCEL) {
+                resetPressedLink();
+            }
+        }
+        return result || super.onTouchEvent(event);
+    }
+
+    @SuppressLint("DrawAllocation")
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        textLayout = new StaticLayout(stringBuilder, textPaint, MeasureSpec.getSize(widthMeasureSpec) - AndroidUtilities.dp(71 + 16), Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
+        super.onMeasure(MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(textLayout.getHeight() + AndroidUtilities.dp(16), MeasureSpec.EXACTLY));
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        canvas.save();
+        canvas.translate(textX = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 71), textY = AndroidUtilities.dp(8));
+        if (pressedLink != null) {
+            canvas.drawPath(urlPath, urlPaint);
+        }
+        textLayout.draw(canvas);
+        canvas.restore();
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/AddMemberCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AddMemberCell.java
deleted file mode 100644
index a8157c9f0..000000000
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/AddMemberCell.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * This is the source code of Telegram for Android v. 2.x
- * It is licensed under GNU GPL v. 2 or later.
- * You should have received a copy of the license in this archive (see LICENSE).
- *
- * Copyright Nikolai Kudashov, 2013-2015.
- */
-
-package org.telegram.ui.Cells;
-
-import android.content.Context;
-import android.view.Gravity;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-
-import org.telegram.messenger.AndroidUtilities;
-import org.telegram.messenger.LocaleController;
-import org.telegram.messenger.R;
-import org.telegram.ui.Components.LayoutHelper;
-import org.telegram.ui.Components.SimpleTextView;
-
-public class AddMemberCell extends FrameLayout {
-
-    private SimpleTextView textView;
-
-    public AddMemberCell(Context context) {
-        super(context);
-
-        ImageView imageView = new ImageView(context);
-        imageView.setImageResource(R.drawable.addmember);
-        imageView.setScaleType(ImageView.ScaleType.CENTER);
-        addView(imageView, LayoutHelper.createFrame(48, 48, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 68, 8, LocaleController.isRTL ? 68 : 0, 0));
-
-        textView = new SimpleTextView(context);
-        textView.setTextColor(0xff212121);
-        textView.setTextSize(17);
-        textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP);
-        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 20, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 28 : 129, 22.5f, LocaleController.isRTL ? 129 : 28, 0));
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64), MeasureSpec.EXACTLY));
-    }
-
-    public void setText(String text) {
-        textView.setText(text);
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioCell.java
index 27d770638..b0c88b3a6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/AudioCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/BaseCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/BaseCell.java
index 92505cdb2..147128959 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/BaseCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/BaseCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -33,11 +33,11 @@ public void run() {
         public void run() {
             if (checkingForLongPress && getParent() != null && currentPressCount == pressCount) {
                 checkingForLongPress = false;
+                performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
+                onLongPress();
                 MotionEvent event = MotionEvent.obtain(0, 0, MotionEvent.ACTION_CANCEL, 0, 0, 0);
                 onTouchEvent(event);
                 event.recycle();
-                performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
-                onLongPress();
             }
         }
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/BotHelpCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/BotHelpCell.java
index fcb5e997e..39363f137 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/BotHelpCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/BotHelpCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -22,6 +22,7 @@
 import android.view.View;
 
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.Emoji;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.MessageObject;
 import org.telegram.messenger.FileLog;
@@ -97,6 +98,7 @@ public void setText(String text) {
         stringBuilder.append(text);
         MessageObject.addLinks(stringBuilder);
         stringBuilder.setSpan(new TypefaceSpan(AndroidUtilities.getTypeface("fonts/rmedium.ttf")), 0, help.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        Emoji.replaceEmoji(stringBuilder, textPaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
         textLayout = new StaticLayout(stringBuilder, textPaint, width, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
         width = 0;
         height = textLayout.getHeight() + AndroidUtilities.dp(4 + 18);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatActionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatActionCell.java
index b08d2349f..d944b1f37 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatActionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatActionCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatAudioCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatAudioCell.java
index 6163d997b..e1f5f33dd 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatAudioCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatAudioCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -144,6 +144,7 @@ private void didPressedButton() {
                 invalidate();
             }
         } else if (buttonState == 2) {
+            radialProgress.setProgress(0, false);
             FileLoader.getInstance().loadFile(currentMessageObject.messageOwner.media.audio, true);
             buttonState = 3;
             radialProgress.setBackground(getDrawableForCurrentState(), true, false);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatBaseCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatBaseCell.java
index fb48e4c5b..c6a212cf8 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatBaseCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatBaseCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -48,9 +48,10 @@
         void didPressedCancelSendButton(ChatBaseCell cell);
         void didLongPressed(ChatBaseCell cell);
         void didPressReplyMessage(ChatBaseCell cell, int id);
-        void didPressUrl(MessageObject messageObject, ClickableSpan url);
+        void didPressUrl(MessageObject messageObject, ClickableSpan url, boolean longPress);
         void needOpenWebView(String url, String title, String originalUrl, int w, int h);
         void didClickedImage(ChatBaseCell cell);
+        void didPressShare(ChatBaseCell cell);
         boolean canPerformActions();
     }
 
@@ -69,6 +70,7 @@
     private boolean wasLayout = false;
     protected boolean isAvatarVisible = false;
     protected boolean drawBackground = true;
+    protected boolean allowAssistant = false;
     protected MessageObject currentMessageObject;
 
     private static TextPaint timePaintIn;
@@ -103,6 +105,11 @@
     private boolean replyPressed = false;
     private TLRPC.FileLocation currentReplyPhoto;
 
+    private boolean drawShareButton;
+    private boolean sharePressed;
+    private int shareStartX;
+    private int shareStartY;
+
     private StaticLayout nameLayout;
     protected int nameWidth;
     private float nameOffsetX = 0;
@@ -117,11 +124,16 @@
 
     private StaticLayout timeLayout;
     protected int timeWidth;
+    private int timeTextWidth;
     private int timeX;
     private TextPaint currentTimePaint;
     private String currentTimeString;
     protected boolean drawTime = true;
 
+    private StaticLayout viewsLayout;
+    private int viewsTextWidth;
+    private String currentViewsString;
+
     private TLRPC.User currentUser;
     private TLRPC.Chat currentChat;
     private TLRPC.FileLocation currentPhoto;
@@ -226,6 +238,10 @@ public void setCheckPressed(boolean value, boolean pressed) {
         invalidate();
     }
 
+    public void setAllowAssistant(boolean value) {
+        allowAssistant = value;
+    }
+
     protected boolean isUserDataChanged() {
         if (currentMessageObject == null || currentUser == null && currentChat == null) {
             return false;
@@ -296,27 +312,11 @@ protected boolean isUserDataChanged() {
     }
 
     protected void measureTime(MessageObject messageObject) {
-        if (!media) {
-            if (messageObject.isOutOwner()) {
-                currentTimePaint = timePaintOut;
-            } else {
-                currentTimePaint = timePaintIn;
-            }
-        } else {
-            currentTimePaint = timeMediaPaint;
-        }
-        String timeString = LocaleController.formatterDay.format((long) (messageObject.messageOwner.date) * 1000);
+        currentTimeString = LocaleController.getInstance().formatterDay.format((long) (messageObject.messageOwner.date) * 1000);
+        timeTextWidth = timeWidth = (int) Math.ceil(timeMediaPaint.measureText(currentTimeString));
         if ((messageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_HAS_VIEWS) != 0) {
-            currentTimeString = String.format("%s   ", LocaleController.formatShortNumber(messageObject.messageOwner.views, null)) + timeString;
-        } else {
-            currentTimeString = timeString;
-        }
-        timeWidth = (int) Math.ceil(currentTimePaint.measureText(currentTimeString));
-        if ((messageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_HAS_VIEWS) != 0) {
-            timeWidth += ResourceLoader.viewsCountDrawable.getIntrinsicWidth() + AndroidUtilities.dp(4);
-        }
-        if ((messageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_HAS_VIEWS) != 0 && (messageObject.isSending() || messageObject.isSendError())) {
-            currentTimeString = timeString;
+            currentViewsString = String.format("%s", LocaleController.formatShortNumber(Math.max(1, messageObject.messageOwner.views), null));
+            timeWidth += (int) Math.ceil(timeMediaPaint.measureText(currentViewsString)) + ResourceLoader.viewsCountDrawable.getIntrinsicWidth() + AndroidUtilities.dp(10);
         }
     }
 
@@ -329,6 +329,7 @@ public void setMessageObject(MessageObject messageObject) {
         isCheckPressed = true;
         isAvatarVisible = false;
         wasLayout = false;
+        drawShareButton = false;
         replyNameLayout = null;
         replyTextLayout = null;
         replyNameWidth = 0;
@@ -351,6 +352,9 @@ public void setMessageObject(MessageObject messageObject) {
             currentUser = MessagesController.getInstance().getUser(messageObject.messageOwner.from_id);
         } else if (messageObject.messageOwner.from_id < 0) {
             currentChat = MessagesController.getInstance().getChat(-messageObject.messageOwner.from_id);
+            if (messageObject.messageOwner.to_id.channel_id != 0 && (messageObject.messageOwner.reply_to_msg_id == 0 || messageObject.type != 13)) {
+                drawShareButton = true;
+            }
         }
         if (isChat && !messageObject.isOutOwner() && messageObject.messageOwner.from_id > 0) {
             isAvatarVisible = true;
@@ -385,18 +389,12 @@ public void setMessageObject(MessageObject messageObject) {
             currentTimePaint = timeMediaPaint;
         }
 
-        String timeString = LocaleController.formatterDay.format((long) (currentMessageObject.messageOwner.date) * 1000);
-        if ((currentMessageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_HAS_VIEWS) != 0) {
-            currentTimeString = String.format("%s   ", LocaleController.formatShortNumber(currentMessageObject.messageOwner.views, null)) + timeString;
-        } else {
-            currentTimeString = timeString;
-        }
-        timeWidth = (int)Math.ceil(currentTimePaint.measureText(currentTimeString));
-        if ((currentMessageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_HAS_VIEWS) != 0) {
-            timeWidth += ResourceLoader.viewsCountDrawable.getIntrinsicWidth() + AndroidUtilities.dp(4);
-        }
-        if ((currentMessageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_HAS_VIEWS) != 0 && (currentMessageObject.isSending() || currentMessageObject.isSendError())) {
-            currentTimeString = timeString;
+        currentTimeString = LocaleController.getInstance().formatterDay.format((long) (messageObject.messageOwner.date) * 1000);
+        timeTextWidth = timeWidth = (int)Math.ceil(currentTimePaint.measureText(currentTimeString));
+        if ((messageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_HAS_VIEWS) != 0) {
+            currentViewsString = String.format("%s", LocaleController.formatShortNumber(Math.max(1, messageObject.messageOwner.views), null));
+            viewsTextWidth = (int) Math.ceil(currentTimePaint.measureText(currentViewsString));
+            timeWidth += viewsTextWidth + ResourceLoader.viewsCountDrawable.getIntrinsicWidth() + AndroidUtilities.dp(10);
         }
 
         namesOffset = 0;
@@ -410,15 +408,22 @@ public void setMessageObject(MessageObject messageObject) {
                 currentNameString = "DELETED";
             }
             nameWidth = getMaxNameWidth();
+            if (nameWidth < 0) {
+                nameWidth = AndroidUtilities.dp(100);
+            }
 
             CharSequence nameStringFinal = TextUtils.ellipsize(currentNameString.replace("\n", " "), namePaint, nameWidth - AndroidUtilities.dp(12), TextUtils.TruncateAt.END);
-            nameLayout = new StaticLayout(nameStringFinal, namePaint, nameWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
-            if (nameLayout.getLineCount() > 0) {
-                nameWidth = (int)Math.ceil(nameLayout.getLineWidth(0));
-                namesOffset += AndroidUtilities.dp(19);
-                nameOffsetX = nameLayout.getLineLeft(0);
-            } else {
-                nameWidth = 0;
+            try {
+                nameLayout = new StaticLayout(nameStringFinal, namePaint, nameWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
+                if (nameLayout != null && nameLayout.getLineCount() > 0) {
+                    nameWidth = (int)Math.ceil(nameLayout.getLineWidth(0));
+                    namesOffset += AndroidUtilities.dp(19);
+                    nameOffsetX = nameLayout.getLineLeft(0);
+                } else {
+                    nameWidth = 0;
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
             }
         } else {
             currentNameString = null;
@@ -592,16 +597,16 @@ public boolean onTouchEvent(MotionEvent event) {
                 if (isAvatarVisible && avatarImage.isInsideImage(x, y)) {
                     avatarPressed = true;
                     result = true;
-                } else if (drawForwardedName && forwardedNameLayout != null) {
-                    if (x >= forwardNameX && x <= forwardNameX + forwardedNameWidth && y >= forwardNameY && y <= forwardNameY + AndroidUtilities.dp(32)) {
-                        forwardNamePressed = true;
-                        result = true;
-                    }
-                } else if (currentMessageObject.isReply()) {
-                    if (x >= replyStartX && x <= replyStartX + Math.max(replyNameWidth, replyTextWidth) && y >= replyStartY && y <= replyStartY + AndroidUtilities.dp(35)) {
-                        replyPressed = true;
-                        result = true;
-                    }
+                } else if (drawForwardedName && forwardedNameLayout != null && x >= forwardNameX && x <= forwardNameX + forwardedNameWidth && y >= forwardNameY && y <= forwardNameY + AndroidUtilities.dp(32)) {
+                    forwardNamePressed = true;
+                    result = true;
+                } else if (currentMessageObject.isReply() && x >= replyStartX && x <= replyStartX + Math.max(replyNameWidth, replyTextWidth) && y >= replyStartY && y <= replyStartY + AndroidUtilities.dp(35)) {
+                    replyPressed = true;
+                    result = true;
+                } else if (drawShareButton && x >= shareStartX && x <= shareStartX + AndroidUtilities.dp(40) && y >= shareStartY && y <= shareStartY + AndroidUtilities.dp(32)) {
+                    sharePressed = true;
+                    result = true;
+                    invalidate();
                 }
                 if (result) {
                     startCheckLongPress();
@@ -661,6 +666,21 @@ public boolean onTouchEvent(MotionEvent event) {
                         replyPressed = false;
                     }
                 }
+            } else if (sharePressed) {
+                if (event.getAction() == MotionEvent.ACTION_UP) {
+                    sharePressed = false;
+                    playSoundEffect(SoundEffectConstants.CLICK);
+                    if (delegate != null) {
+                        delegate.didPressShare(this);
+                    }
+                } else if (event.getAction() == MotionEvent.ACTION_CANCEL) {
+                    sharePressed = false;
+                } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
+                    if (!(x >= shareStartX && x <= shareStartX + AndroidUtilities.dp(40) && y >= shareStartY && y <= shareStartY + AndroidUtilities.dp(32))) {
+                        sharePressed = false;
+                    }
+                }
+                invalidate();
             }
         }
         return result;
@@ -678,7 +698,7 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
             layoutWidth = getMeasuredWidth();
             layoutHeight = getMeasuredHeight();
 
-            timeLayout = new StaticLayout(currentTimeString, currentTimePaint, timeWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
+            timeLayout = new StaticLayout(currentTimeString, currentTimePaint, timeTextWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
             if (!media) {
                 if (!currentMessageObject.isOutOwner()) {
                     timeX = backgroundWidth - AndroidUtilities.dp(9) - timeWidth + (isChat && currentMessageObject.messageOwner.from_id > 0 ? AndroidUtilities.dp(52) : 0);
@@ -693,6 +713,12 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
                 }
             }
 
+            if ((currentMessageObject.messageOwner.flags & TLRPC.MESSAGE_FLAG_HAS_VIEWS) != 0) {
+                viewsLayout = new StaticLayout(currentViewsString, currentTimePaint, viewsTextWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
+            } else {
+                viewsLayout = null;
+            }
+
             if (isAvatarVisible) {
                 avatarImage.setImageCoords(AndroidUtilities.dp(6), layoutHeight - AndroidUtilities.dp(45), AndroidUtilities.dp(42), AndroidUtilities.dp(42));
             }
@@ -773,6 +799,11 @@ protected void onDraw(Canvas canvas) {
 
         onAfterBackgroundDraw(canvas);
 
+        if (drawShareButton) {
+            ResourceLoader.shareDrawable[ApplicationLoader.isCustomTheme() ? 1 : 0][sharePressed ? 1 : 0].setBounds(shareStartX = currentBackgroundDrawable.getBounds().right + AndroidUtilities.dp(8), shareStartY = layoutHeight - AndroidUtilities.dp(41), currentBackgroundDrawable.getBounds().right + AndroidUtilities.dp(40), layoutHeight - AndroidUtilities.dp(9));
+            ResourceLoader.shareDrawable[ApplicationLoader.isCustomTheme() ? 1 : 0][sharePressed ? 1 : 0].draw(canvas);
+        }
+
         if (drawName && nameLayout != null) {
             canvas.save();
             if (media) {
@@ -899,6 +930,13 @@ protected void onDraw(Canvas canvas) {
                     } else {
                         setDrawableBounds(ResourceLoader.viewsMediaCountDrawable, timeX, layoutHeight - AndroidUtilities.dp(10) - timeLayout.getHeight());
                         ResourceLoader.viewsMediaCountDrawable.draw(canvas);
+
+                        if (viewsLayout != null) {
+                            canvas.save();
+                            canvas.translate(timeX + ResourceLoader.viewsMediaCountDrawable.getIntrinsicWidth() + AndroidUtilities.dp(3), layoutHeight - AndroidUtilities.dp(12.0f) - timeLayout.getHeight());
+                            viewsLayout.draw(canvas);
+                            canvas.restore();
+                        }
                     }
                 }
 
@@ -929,6 +967,13 @@ protected void onDraw(Canvas canvas) {
                             setDrawableBounds(ResourceLoader.viewsOutCountDrawable, timeX, layoutHeight - AndroidUtilities.dp(4.5f) - timeLayout.getHeight());
                             ResourceLoader.viewsOutCountDrawable.draw(canvas);
                         }
+
+                        if (viewsLayout != null) {
+                            canvas.save();
+                            canvas.translate(timeX + ResourceLoader.viewsOutCountDrawable.getIntrinsicWidth() + AndroidUtilities.dp(3), layoutHeight - AndroidUtilities.dp(6.5f) - timeLayout.getHeight());
+                            viewsLayout.draw(canvas);
+                            canvas.restore();
+                        }
                     }
                 }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatContactCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatContactCell.java
index cf183af2a..125a5c55c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatContactCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatContactCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -198,6 +198,9 @@ public void setMessageObject(MessageObject messageObject) {
 
             String currentNameString = ContactsController.formatName(messageObject.messageOwner.media.first_name, messageObject.messageOwner.media.last_name);
             int nameWidth = Math.min((int) Math.ceil(namePaint.measureText(currentNameString)), maxWidth);
+            if (maxWidth < 0) {
+                maxWidth = AndroidUtilities.dp(100);
+            }
 
             CharSequence stringFinal = TextUtils.ellipsize(currentNameString.replace("\n", " "), namePaint, nameWidth, TextUtils.TruncateAt.END);
             nameLayout = new StaticLayout(stringFinal, namePaint, nameWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatLoadingCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatLoadingCell.java
index 1e1a7e609..732ae8909 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatLoadingCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatLoadingCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
index 91f7e7009..c5ea4e225 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMediaCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -38,6 +38,7 @@
 import org.telegram.ui.Components.RadialProgress;
 import org.telegram.ui.Components.ResourceLoader;
 import org.telegram.ui.Components.StaticLayoutEx;
+import org.telegram.ui.Components.URLSpanBotCommand;
 import org.telegram.ui.PhotoViewer;
 import org.telegram.ui.Components.GifDrawable;
 import org.telegram.messenger.ImageReceiver;
@@ -89,6 +90,7 @@
 
     private StaticLayout nameLayout;
     private int nameWidth = 0;
+    private int nameOffsetX = 0;
     private String currentNameString;
 
     private ChatMediaCellDelegate mediaDelegate = null;
@@ -180,7 +182,11 @@ public boolean onTouchEvent(MotionEvent event) {
                             if (left <= x2 && left + nameLayout.getLineWidth(line) >= x2) {
                                 Spannable buffer = (Spannable) currentMessageObject.caption;
                                 ClickableSpan[] link = buffer.getSpans(off, off, ClickableSpan.class);
-                                if (link.length != 0) {
+                                boolean ignore = false;
+                                if (link.length == 0 || link.length != 0 && link[0] instanceof URLSpanBotCommand && !URLSpanBotCommand.enabled) {
+                                    ignore = true;
+                                }
+                                if (!ignore) {
                                     resetPressedLink();
                                     pressedLink = link[0];
                                     linkPreviewPressed = true;
@@ -204,7 +210,7 @@ public boolean onTouchEvent(MotionEvent event) {
                         }
                     } else if (linkPreviewPressed) {
                         try {
-                            delegate.didPressUrl(currentMessageObject, pressedLink);
+                            delegate.didPressUrl(currentMessageObject, pressedLink, false);
                         } catch (Exception e) {
                             FileLog.e("tmessages", e);
                         }
@@ -444,7 +450,7 @@ private boolean isPhotoDataChanged(MessageObject object) {
             }
             double lat = object.messageOwner.media.geo.lat;
             double lon = object.messageOwner.media.geo._long;
-            String url = String.format(Locale.US, "https://maps.googleapis.com/maps/api/staticmap?center=%f,%f&zoom=13&size=100x100&maptype=roadmap&scale=%d&markers=color:red|size:big|%f,%f&sensor=false", lat, lon, Math.min(2, (int) Math.ceil(AndroidUtilities.density)), lat, lon);
+            String url = String.format(Locale.US, "https://maps.googleapis.com/maps/api/staticmap?center=%f,%f&zoom=15&size=100x100&maptype=roadmap&scale=%d&markers=color:red|size:big|%f,%f&sensor=false", lat, lon, Math.min(2, (int) Math.ceil(AndroidUtilities.density)), lat, lon);
             if (!url.equals(currentUrl)) {
                 return true;
             }
@@ -463,6 +469,7 @@ private boolean isPhotoDataChanged(MessageObject object) {
     public void setMessageObject(MessageObject messageObject) {
         boolean dataChanged = currentMessageObject == messageObject && (isUserDataChanged() || photoNotSet);
         if (currentMessageObject != messageObject || isPhotoDataChanged(messageObject) || dataChanged) {
+            drawForwardedName = (messageObject.type == 3 || messageObject.type == 1) && messageObject.messageOwner.fwd_from_id != null && messageObject.messageOwner.fwd_from_id.channel_id != 0;
             media = messageObject.type != 9;
             cancelLoading = false;
             additionHeight = 0;
@@ -491,25 +498,15 @@ public void setMessageObject(MessageObject messageObject) {
                 if (currentNameString == null || !currentNameString.equals(name)) {
                     currentNameString = name;
                     nameLayout = StaticLayoutEx.createStaticLayout(currentNameString, namePaint, maxWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false, TextUtils.TruncateAt.END, maxWidth, 1);
-                    if (nameLayout.getLineCount() > 0) {
+                    if (nameLayout != null && nameLayout.getLineCount() > 0) {
                         nameWidth = Math.min(maxWidth, (int) Math.ceil(nameLayout.getLineWidth(0)));
+                        nameOffsetX = (int) Math.ceil(-nameLayout.getLineLeft(0));
                     } else {
                         nameWidth = maxWidth;
                     }
                 }
 
-                String fileName = messageObject.getFileName();
-                int idx = fileName.lastIndexOf(".");
-                String ext = null;
-                if (idx != -1) {
-                    ext = fileName.substring(idx + 1);
-                }
-                if (ext == null || ext.length() == 0) {
-                    ext = messageObject.messageOwner.media.document.mime_type;
-                }
-                ext = ext.toUpperCase();
-
-                String str = AndroidUtilities.formatFileSize(messageObject.messageOwner.media.document.size) + " " + ext;
+                String str = AndroidUtilities.formatFileSize(messageObject.messageOwner.media.document.size) + " " + messageObject.getExtension();
 
                 if (currentInfoString == null || !currentInfoString.equals(str)) {
                     currentInfoString = str;
@@ -548,7 +545,7 @@ public void setMessageObject(MessageObject messageObject) {
                 currentNameString = null;
                 infoLayout = null;
                 nameLayout = null;
-                updateSecretTimeText();
+                updateSecretTimeText(messageObject);
             }
             if (messageObject.type == 9) { //doc
                 photoWidth = AndroidUtilities.dp(86);
@@ -592,12 +589,12 @@ public void setMessageObject(MessageObject messageObject) {
                         }
                     }
                     backgroundWidth = photoWidth + AndroidUtilities.dp(21) + maxWidth;
-                    currentUrl = String.format(Locale.US, "https://maps.googleapis.com/maps/api/staticmap?center=%f,%f&zoom=13&size=72x72&maptype=roadmap&scale=%d&markers=color:red|size:big|%f,%f&sensor=false", lat, lon, Math.min(2, (int) Math.ceil(AndroidUtilities.density)), lat, lon);
+                    currentUrl = String.format(Locale.US, "https://maps.googleapis.com/maps/api/staticmap?center=%f,%f&zoom=15&size=72x72&maptype=roadmap&scale=%d&markers=color:red|size:big|%f,%f&sensor=false", lat, lon, Math.min(2, (int) Math.ceil(AndroidUtilities.density)), lat, lon);
                 } else {
                     photoWidth = AndroidUtilities.dp(200);
                     photoHeight = AndroidUtilities.dp(100);
                     backgroundWidth = photoWidth + AndroidUtilities.dp(12);
-                    currentUrl = String.format(Locale.US, "https://maps.googleapis.com/maps/api/staticmap?center=%f,%f&zoom=13&size=200x100&maptype=roadmap&scale=%d&markers=color:red|size:big|%f,%f&sensor=false", lat, lon, Math.min(2, (int) Math.ceil(AndroidUtilities.density)), lat, lon);
+                    currentUrl = String.format(Locale.US, "https://maps.googleapis.com/maps/api/staticmap?center=%f,%f&zoom=15&size=200x100&maptype=roadmap&scale=%d&markers=color:red|size:big|%f,%f&sensor=false", lat, lon, Math.min(2, (int) Math.ceil(AndroidUtilities.density)), lat, lon);
                 }
 
                 photoImage.setNeedsQualityThumb(false);
@@ -749,14 +746,18 @@ public void setMessageObject(MessageObject messageObject) {
                     backgroundWidth += AndroidUtilities.dp(9);
                 }
                 if (messageObject.caption != null) {
-                    nameLayout = new StaticLayout(messageObject.caption, MessageObject.textPaint, photoWidth - AndroidUtilities.dp(10), Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
-                    if (nameLayout.getLineCount() > 0) {
-                        captionHeight = nameLayout.getHeight();
-                        additionHeight += captionHeight + AndroidUtilities.dp(9);
-                        float lastLineWidth = nameLayout.getLineWidth(nameLayout.getLineCount() - 1) + nameLayout.getLineLeft(nameLayout.getLineCount() - 1);
-                        if (photoWidth - AndroidUtilities.dp(8) - lastLineWidth < timeWidthTotal) {
-                            additionHeight += AndroidUtilities.dp(14);
+                    try {
+                        nameLayout = new StaticLayout(messageObject.caption, MessageObject.textPaint, photoWidth - AndroidUtilities.dp(10), Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
+                        if (nameLayout != null && nameLayout.getLineCount() > 0) {
+                            captionHeight = nameLayout.getHeight();
+                            additionHeight += captionHeight + AndroidUtilities.dp(9);
+                            float lastLineWidth = nameLayout.getLineWidth(nameLayout.getLineCount() - 1) + nameLayout.getLineLeft(nameLayout.getLineCount() - 1);
+                            if (photoWidth - AndroidUtilities.dp(8) - lastLineWidth < timeWidthTotal) {
+                                additionHeight += AndroidUtilities.dp(14);
+                            }
                         }
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
                     }
                 }
 
@@ -814,11 +815,20 @@ public void setMessageObject(MessageObject messageObject) {
             }
             super.setMessageObject(messageObject);
 
+            if (drawForwardedName) {
+                namesOffset += AndroidUtilities.dp(5);
+            }
+
             invalidate();
         }
         updateButtonState(dataChanged);
     }
 
+    @Override
+    protected int getMaxNameWidth() {
+        return backgroundWidth - AndroidUtilities.dp(14);
+    }
+
     @Override
     public ImageReceiver getPhotoImage() {
         return photoImage;
@@ -936,12 +946,13 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
         deleteProgressRect.set(buttonX + AndroidUtilities.dp(3), buttonY + AndroidUtilities.dp(3), buttonX + AndroidUtilities.dp(45), buttonY + AndroidUtilities.dp(45));
     }
 
-    private void updateSecretTimeText() {
-        if (currentMessageObject == null || currentMessageObject.isOut()) {
+    private void updateSecretTimeText(MessageObject messageObject) {
+        if (messageObject == null || messageObject.isOut()) {
             return;
         }
-        String str = currentMessageObject.getSecretTimeString();
+        String str = messageObject.getSecretTimeString();
         if (str == null) {
+            infoLayout = null;
             return;
         }
         if (currentInfoString == null || !currentInfoString.equals(str)) {
@@ -1054,7 +1065,7 @@ protected void onAfterBackgroundDraw(Canvas canvas) {
                     int offset = AndroidUtilities.dp(2);
                     invalidate((int) deleteProgressRect.left - offset, (int) deleteProgressRect.top - offset, (int) deleteProgressRect.right + offset * 2, (int) deleteProgressRect.bottom + offset * 2);
                 }
-                updateSecretTimeText();
+                updateSecretTimeText(currentMessageObject);
             }
         }
 
@@ -1067,7 +1078,11 @@ protected void onAfterBackgroundDraw(Canvas canvas) {
                 if (pressedLink != null) {
                     canvas.drawPath(urlPath, urlPaint);
                 }
-                nameLayout.draw(canvas);
+                try {
+                    nameLayout.draw(canvas);
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
                 canvas.restore();
             }
             if (infoLayout != null && (buttonState == 1 || buttonState == 0 || buttonState == 3 || currentMessageObject.isSecretPhoto())) {
@@ -1090,7 +1105,7 @@ protected void onAfterBackgroundDraw(Canvas canvas) {
                 locationAddressPaint.setColor(currentMessageObject.isOutOwner() ? 0xff70b15c : 0xff999999);
 
                 canvas.save();
-                canvas.translate(photoImage.getImageX() + photoImage.getImageWidth() + AndroidUtilities.dp(10), photoImage.getImageY() + AndroidUtilities.dp(3));
+                canvas.translate(nameOffsetX + photoImage.getImageX() + photoImage.getImageWidth() + AndroidUtilities.dp(10), photoImage.getImageY() + AndroidUtilities.dp(3));
                 nameLayout.draw(canvas);
                 canvas.restore();
 
@@ -1103,7 +1118,7 @@ protected void onAfterBackgroundDraw(Canvas canvas) {
             }
         } else if (nameLayout != null) {
             canvas.save();
-            canvas.translate(photoImage.getImageX() + photoImage.getImageWidth() + AndroidUtilities.dp(10), photoImage.getImageY() + AndroidUtilities.dp(8));
+            canvas.translate(nameOffsetX + photoImage.getImageX() + photoImage.getImageWidth() + AndroidUtilities.dp(10), photoImage.getImageY() + AndroidUtilities.dp(8));
             nameLayout.draw(canvas);
             canvas.restore();
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
index 5e8767bc6..44847b75e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMessageCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -25,6 +25,7 @@
 import android.text.style.ClickableSpan;
 import android.view.MotionEvent;
 import android.view.SoundEffectConstants;
+import android.view.ViewStructure;
 
 import org.telegram.messenger.AndroidUtilities;
 import org.telegram.messenger.ImageLoader;
@@ -38,6 +39,8 @@
 import org.telegram.ui.Components.RadialProgress;
 import org.telegram.ui.Components.ResourceLoader;
 import org.telegram.ui.Components.StaticLayoutEx;
+import org.telegram.ui.Components.URLSpanBotCommand;
+import org.telegram.ui.Components.URLSpanNoUnderline;
 
 import java.io.File;
 import java.util.Locale;
@@ -114,7 +117,11 @@ public boolean onTouchEvent(MotionEvent event) {
                             if (left <= x && left + block.textLayout.getLineWidth(line) >= x) {
                                 Spannable buffer = (Spannable) currentMessageObject.messageText;
                                 ClickableSpan[] link = buffer.getSpans(off, off, ClickableSpan.class);
-                                if (link.length != 0) {
+                                boolean ignore = false;
+                                if (link.length == 0 || link.length != 0 && link[0] instanceof URLSpanBotCommand && !URLSpanBotCommand.enabled) {
+                                    ignore = true;
+                                }
+                                if (!ignore) {
                                     if (event.getAction() == MotionEvent.ACTION_DOWN) {
                                         resetPressedLink();
                                         pressedLink = link[0];
@@ -130,7 +137,7 @@ public boolean onTouchEvent(MotionEvent event) {
                                     } else {
                                         if (link[0] == pressedLink) {
                                             try {
-                                                delegate.didPressUrl(currentMessageObject, pressedLink);
+                                                delegate.didPressUrl(currentMessageObject, pressedLink, false);
                                             } catch (Exception e) {
                                                 FileLog.e("tmessages", e);
                                             }
@@ -174,7 +181,11 @@ public boolean onTouchEvent(MotionEvent event) {
                                     if (left <= x && left + descriptionLayout.getLineWidth(line) >= x) {
                                         Spannable buffer = (Spannable) currentMessageObject.linkDescription;
                                         ClickableSpan[] link = buffer.getSpans(off, off, ClickableSpan.class);
-                                        if (link.length != 0) {
+                                        boolean ignore = false;
+                                        if (link.length == 0 || link.length != 0 && link[0] instanceof URLSpanBotCommand && !URLSpanBotCommand.enabled) {
+                                            ignore = true;
+                                        }
+                                        if (!ignore) {
                                             resetPressedLink();
                                             pressedLink = link[0];
                                             linkPreviewPressed = true;
@@ -350,6 +361,18 @@ protected void onAttachedToWindow() {
         }
     }
 
+    @Override
+    protected void onLongPress() {
+        if (pressedLink instanceof URLSpanNoUnderline) {
+            URLSpanNoUnderline url = (URLSpanNoUnderline) pressedLink;
+            if (url.getURL().startsWith("/")) {
+                delegate.didPressUrl(currentMessageObject, pressedLink, true);
+                return;
+            }
+        }
+        super.onLongPress();
+    }
+
     @Override
     public void setMessageObject(MessageObject messageObject) {
         boolean dataChanged = currentMessageObject == messageObject && (isUserDataChanged() || photoNotSet);
@@ -381,7 +404,7 @@ public void setMessageObject(MessageObject messageObject) {
                     maxWidth = AndroidUtilities.getMinTabletSide() - AndroidUtilities.dp(122);
                     drawName = true;
                 } else {
-                    drawName = messageObject.messageOwner.to_id.channel_id != 0;
+                    drawName = messageObject.messageOwner.to_id.channel_id != 0 && !messageObject.isOutOwner();
                     maxWidth = AndroidUtilities.getMinTabletSide() - AndroidUtilities.dp(80);
                 }
             } else {
@@ -390,7 +413,7 @@ public void setMessageObject(MessageObject messageObject) {
                     drawName = true;
                 } else {
                     maxWidth = Math.min(AndroidUtilities.displaySize.x, AndroidUtilities.displaySize.y) - AndroidUtilities.dp(80);
-                    drawName = messageObject.messageOwner.to_id.channel_id != 0;
+                    drawName = messageObject.messageOwner.to_id.channel_id != 0 && !messageObject.isOutOwner();
                 }
             }
 
@@ -509,17 +532,18 @@ public void setMessageObject(MessageObject messageObject) {
                     }
                 }
 
+                boolean authorIsRTL = false;
                 if (webPage.author != null) {
                     try {
                         if (linkPreviewHeight != 0) {
                             linkPreviewHeight += AndroidUtilities.dp(2);
                             totalHeight += AndroidUtilities.dp(2);
                         }
-                        int width = Math.min((int) Math.ceil(replyNamePaint.measureText(webPage.author)), linkPreviewMaxWidth);
+                        //int width = Math.min((int) Math.ceil(replyNamePaint.measureText(webPage.author)), linkPreviewMaxWidth);
                         if (restLinesCount == 3 && (!isSmallImage || webPage.description == null)) {
-                            authorLayout = new StaticLayout(webPage.author, replyNamePaint, width, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
+                            authorLayout = new StaticLayout(webPage.author, replyNamePaint, linkPreviewMaxWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
                         } else {
-                            authorLayout = generateStaticLayout(webPage.author, replyNamePaint, width, linkPreviewMaxWidth - AndroidUtilities.dp(48 + 2), restLinesCount, 1);
+                            authorLayout = generateStaticLayout(webPage.author, replyNamePaint, linkPreviewMaxWidth, linkPreviewMaxWidth - AndroidUtilities.dp(48 + 2), restLinesCount, 1);
                             restLinesCount -= authorLayout.getLineCount();
                         }
                         int height = authorLayout.getLineBottom(authorLayout.getLineCount() - 1);
@@ -527,6 +551,13 @@ public void setMessageObject(MessageObject messageObject) {
                         totalHeight += height;
                         int lineLeft = (int) authorLayout.getLineLeft(0);
                         authorX = -lineLeft;
+                        int width;
+                        if (lineLeft != 0) {
+                            width = authorLayout.getWidth() - lineLeft;
+                            authorIsRTL = true;
+                        } else {
+                            width = (int) Math.ceil(authorLayout.getLineWidth(0));
+                        }
                         maxChildWidth = Math.max(maxChildWidth, width + additinalWidth);
                         maxWebWidth = Math.max(maxWebWidth, width + additinalWidth);
                     } catch (Exception e) {
@@ -552,19 +583,31 @@ public void setMessageObject(MessageObject messageObject) {
                         int height = descriptionLayout.getLineBottom(descriptionLayout.getLineCount() - 1);
                         linkPreviewHeight += height;
                         totalHeight += height;
+
+                        boolean hasRTL = false;
                         for (int a = 0; a < descriptionLayout.getLineCount(); a++) {
                             int lineLeft = (int) Math.ceil(descriptionLayout.getLineLeft(a));
-                            if (descriptionX == 0) {
-                                descriptionX = -lineLeft;
-                            } else {
-                                descriptionX = Math.max(descriptionX, -lineLeft);
+                            if (lineLeft != 0) {
+                                hasRTL = true;
+                                if (descriptionX == 0) {
+                                    descriptionX = -lineLeft;
+                                } else {
+                                    descriptionX = Math.max(descriptionX, -lineLeft);
+                                }
+                            }
+                        }
+
+                        for (int a = 0; a < descriptionLayout.getLineCount(); a++) {
+                            int lineLeft = (int) Math.ceil(descriptionLayout.getLineLeft(a));
+                            if (lineLeft == 0 && descriptionX != 0) {
+                                descriptionX = 0;
                             }
 
                             int width;
                             if (lineLeft != 0) {
                                 width = descriptionLayout.getWidth() - lineLeft;
                             } else {
-                                width = (int) Math.ceil(descriptionLayout.getLineWidth(a));
+                                width = hasRTL ? descriptionLayout.getWidth() : (int) Math.ceil(descriptionLayout.getLineWidth(a));
                             }
                             if (a < restLines || lineLeft != 0 && isSmallImage) {
                                 width += AndroidUtilities.dp(48 + 2);
@@ -573,6 +616,9 @@ public void setMessageObject(MessageObject messageObject) {
                                 if (titleIsRTL) {
                                     titleX += (width + additinalWidth - maxWebWidth);
                                 }
+                                if (authorIsRTL) {
+                                    authorX += (width + additinalWidth - maxWebWidth);
+                                }
                                 maxWebWidth = width + additinalWidth;
                             }
                             maxChildWidth = Math.max(maxChildWidth, width + additinalWidth);
@@ -960,4 +1006,12 @@ public void onProgressDownload(String fileName, float progress) {
             updateButtonState(false);
         }
     }
+
+    @Override
+    public void onProvideStructure(ViewStructure structure) {
+        super.onProvideStructure(structure);
+        if (allowAssistant && Build.VERSION.SDK_INT >= 23) {
+            structure.setText(currentMessageObject.messageText);
+        }
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMusicCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMusicCell.java
index 24ab61f16..c79310643 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMusicCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatMusicCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -158,6 +158,7 @@ private void didPressedButton() {
                 invalidate();
             }
         } else if (buttonState == 2) {
+            radialProgress.setProgress(0, false);
             FileLoader.getInstance().loadFile(currentMessageObject.messageOwner.media.document, true, false);
             buttonState = 3;
             radialProgress.setBackground(getDrawableForCurrentState(), true, false);
@@ -234,7 +235,7 @@ public void updateButtonState(boolean animated) {
             File cacheFile = null;
             if (currentMessageObject.messageOwner.attachPath != null && currentMessageObject.messageOwner.attachPath.length() > 0) {
                 cacheFile = new File(currentMessageObject.messageOwner.attachPath);
-                if(!cacheFile.exists()) {
+                if (!cacheFile.exists()) {
                     cacheFile = null;
                 }
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatUnreadCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatUnreadCell.java
index 0d8e34908..32e75f701 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatUnreadCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ChatUnreadCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/CheckBoxCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/CheckBoxCell.java
new file mode 100644
index 000000000..b0d15c581
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/CheckBoxCell.java
@@ -0,0 +1,103 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.LocaleController;
+import org.telegram.ui.Components.CheckBoxSquare;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class CheckBoxCell extends FrameLayout {
+
+    private TextView textView;
+    private TextView valueTextView;
+    private CheckBoxSquare checkBox;
+    private static Paint paint;
+    private boolean needDivider;
+
+    public CheckBoxCell(Context context) {
+        super(context);
+
+        if (paint == null) {
+            paint = new Paint();
+            paint.setColor(0xffd9d9d9);
+            paint.setStrokeWidth(1);
+        }
+
+        textView = new TextView(context);
+        textView.setTextColor(0xff212121);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        textView.setLines(1);
+        textView.setMaxLines(1);
+        textView.setSingleLine(true);
+        textView.setEllipsize(TextUtils.TruncateAt.END);
+        textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, (LocaleController.isRTL ? 17 : 46), 0, (LocaleController.isRTL ? 46 : 17), 0));
+
+        valueTextView = new TextView(context);
+        valueTextView.setTextColor(0xff2f8cc9);
+        valueTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        valueTextView.setLines(1);
+        valueTextView.setMaxLines(1);
+        valueTextView.setSingleLine(true);
+        valueTextView.setEllipsize(TextUtils.TruncateAt.END);
+        valueTextView.setGravity((LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL);
+        addView(valueTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP, 17, 0, 17, 0));
+
+        checkBox = new CheckBoxSquare(context);
+        addView(checkBox, LayoutHelper.createFrame(18, 18, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, (LocaleController.isRTL ? 0 : 17), 15, (LocaleController.isRTL ? 17 : 0), 0));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), AndroidUtilities.dp(48) + (needDivider ? 1 : 0));
+
+        int availableWidth = getMeasuredWidth() - getPaddingLeft() - getPaddingRight() - AndroidUtilities.dp(34);
+
+        valueTextView.measure(MeasureSpec.makeMeasureSpec(availableWidth / 2, MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
+        textView.measure(MeasureSpec.makeMeasureSpec(availableWidth - valueTextView.getMeasuredWidth() - AndroidUtilities.dp(8), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
+        checkBox.measure(MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(18), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(18), MeasureSpec.EXACTLY));
+    }
+
+    public void setTextColor(int color) {
+        textView.setTextColor(color);
+    }
+
+    public void setText(String text, String value, boolean checked, boolean divider) {
+        textView.setText(text);
+        checkBox.setChecked(checked, false);
+        valueTextView.setText(value);
+        needDivider = divider;
+        setWillNotDraw(!divider);
+    }
+
+    public void setChecked(boolean checked, boolean animated) {
+        checkBox.setChecked(checked, animated);
+    }
+
+    public boolean isChecked() {
+        return checkBox.isChecked();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (needDivider) {
+            canvas.drawLine(getPaddingLeft(), getHeight() - 1, getWidth() - getPaddingRight(), getHeight() - 1, paint);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DialogCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DialogCell.java
index da248b15c..618c6ce68 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DialogCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DialogCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -21,6 +21,7 @@
 
 import org.telegram.messenger.AndroidUtilities;
 import org.telegram.PhoneFormat.PhoneFormat;
+import org.telegram.messenger.ChatObject;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.MessageObject;
 import org.telegram.messenger.UserObject;
@@ -40,7 +41,6 @@
 
     private static TextPaint namePaint;
     private static TextPaint nameEncryptedPaint;
-    private static TextPaint nameUnknownPaint;
     private static TextPaint messagePaint;
     private static TextPaint messagePrintingPaint;
     private static TextPaint timePaint;
@@ -52,9 +52,12 @@
     private static Drawable errorDrawable;
     private static Drawable lockDrawable;
     private static Drawable countDrawable;
+    private static Drawable countDrawableGrey;
     private static Drawable groupDrawable;
     private static Drawable broadcastDrawable;
+    private static Drawable botDrawable;
     private static Drawable muteDrawable;
+    private static Drawable verifiedDrawable;
 
     private static Paint linePaint;
     private static Paint backPaint;
@@ -85,6 +88,7 @@
     private boolean drawNameLock;
     private boolean drawNameGroup;
     private boolean drawNameBroadcast;
+    private boolean drawNameBot;
     private int nameMuteLeft;
     private int nameLockLeft;
     private int nameLockTop;
@@ -114,6 +118,8 @@
     private int countWidth;
     private StaticLayout countLayout;
 
+    private boolean drawVerified;
+
     private int avatarTop = AndroidUtilities.dp(10);
 
     private boolean isSelected;
@@ -132,11 +138,6 @@ public DialogCell(Context context) {
             nameEncryptedPaint.setColor(0xff00a60e);
             nameEncryptedPaint.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
 
-            nameUnknownPaint = new TextPaint(TextPaint.ANTI_ALIAS_FLAG);
-            nameUnknownPaint.setTextSize(AndroidUtilities.dp(17));
-            nameUnknownPaint.setColor(0xff4d83b3);
-            nameUnknownPaint.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-
             messagePaint = new TextPaint(TextPaint.ANTI_ALIAS_FLAG);
             messagePaint.setTextSize(AndroidUtilities.dp(16));
             messagePaint.setColor(0xff8f8f8f);
@@ -167,9 +168,12 @@ public DialogCell(Context context) {
             clockDrawable = getResources().getDrawable(R.drawable.msg_clock);
             errorDrawable = getResources().getDrawable(R.drawable.dialogs_warning);
             countDrawable = getResources().getDrawable(R.drawable.dialogs_badge);
+            countDrawableGrey = getResources().getDrawable(R.drawable.dialogs_badge2);
             groupDrawable = getResources().getDrawable(R.drawable.list_group);
             broadcastDrawable = getResources().getDrawable(R.drawable.list_broadcast);
             muteDrawable = getResources().getDrawable(R.drawable.mute_grey);
+            verifiedDrawable = getResources().getDrawable(R.drawable.check_list);
+            botDrawable = getResources().getDrawable(R.drawable.bot_list);
         }
 
         setBackgroundResource(R.drawable.list_selector);
@@ -258,6 +262,8 @@ public void buildLayout() {
         drawNameGroup = false;
         drawNameBroadcast = false;
         drawNameLock = false;
+        drawNameBot = false;
+        drawVerified = false;
 
         if (encryptedChat != null) {
             drawNameLock = true;
@@ -271,13 +277,14 @@ public void buildLayout() {
             }
         } else {
             if (chat != null) {
-                if (chat.id < 0 || chat instanceof TLRPC.TL_channel || chat instanceof TLRPC.TL_channelForbidden) {
+                if (chat.id < 0 || ChatObject.isChannel(chat) && !chat.megagroup) {
                     drawNameBroadcast = true;
                     nameLockTop = AndroidUtilities.dp(16.5f);
                 } else {
                     drawNameGroup = true;
                     nameLockTop = AndroidUtilities.dp(17.5f);
                 }
+                drawVerified = chat.verified;
 
                 if (!LocaleController.isRTL) {
                     nameLockLeft = AndroidUtilities.dp(AndroidUtilities.leftBaseline);
@@ -292,6 +299,20 @@ public void buildLayout() {
                 } else {
                     nameLeft = AndroidUtilities.dp(14);
                 }
+                if (user != null) {
+                    if (user.bot) {
+                        drawNameBot = true;
+                        nameLockTop = AndroidUtilities.dp(16.5f);
+                        if (!LocaleController.isRTL) {
+                            nameLockLeft = AndroidUtilities.dp(AndroidUtilities.leftBaseline);
+                            nameLeft = AndroidUtilities.dp(AndroidUtilities.leftBaseline + 4) + botDrawable.getIntrinsicWidth();
+                        } else {
+                            nameLockLeft = getMeasuredWidth() - AndroidUtilities.dp(AndroidUtilities.leftBaseline) - botDrawable.getIntrinsicWidth();
+                            nameLeft = AndroidUtilities.dp(14);
+                        }
+                    }
+                    drawVerified = user.verified;
+                }
             }
         }
 
@@ -357,7 +378,7 @@ public void buildLayout() {
                     messageString = message.messageText;
                     currentMessagePaint = messagePrintingPaint;
                 } else {
-                    if (chat != null && chat.id > 0) {
+                    if (chat != null && chat.id > 0 && fromChat == null) {
                         String name;
                         if (message.isOutOwner()) {
                             name = LocaleController.getString("FromYou", R.string.FromYou);
@@ -375,11 +396,11 @@ public void buildLayout() {
                                 mess = mess.substring(0, 150);
                             }
                             mess = mess.replace("\n", " ");
-                            messageString = Emoji.replaceEmoji(AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>%s:</c> <c#ff808080>%s</c>", name, mess), AndroidUtilities.FLAG_TAG_COLOR), messagePaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
+                            messageString = Emoji.replaceEmoji(AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>%s:</c> <c#ff808080>%s</c>", name.replace("\n", ""), mess), AndroidUtilities.FLAG_TAG_COLOR), messagePaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
                         } else {
                             if (message.messageOwner.media != null && !message.isMediaEmpty()) {
                                 currentMessagePaint = messagePrintingPaint;
-                                messageString = Emoji.replaceEmoji(AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>%s:</c> <c#ff4d83b3>%s</c>", name, message.messageText), AndroidUtilities.FLAG_TAG_COLOR), messagePaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
+                                messageString = Emoji.replaceEmoji(AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>%s:</c> <c#ff4d83b3>%s</c>", name.replace("\n", ""), message.messageText), AndroidUtilities.FLAG_TAG_COLOR), messagePaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
                             } else {
                                 if (message.messageOwner.message != null) {
                                     String mess = message.messageOwner.message;
@@ -387,7 +408,7 @@ public void buildLayout() {
                                         mess = mess.substring(0, 150);
                                     }
                                     mess = mess.replace("\n", " ");
-                                    messageString = Emoji.replaceEmoji(AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>%s:</c> <c#ff808080>%s</c>", name, mess), AndroidUtilities.FLAG_TAG_COLOR), messagePaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
+                                    messageString = Emoji.replaceEmoji(AndroidUtilities.replaceTags(String.format("<c#ff4d83b3>%s:</c> <c#ff808080>%s</c>", name.replace("\n", ""), mess), AndroidUtilities.FLAG_TAG_COLOR), messagePaint.getFontMetricsInt(), AndroidUtilities.dp(20), false);
                                 }
                             }
                         }
@@ -460,7 +481,6 @@ public void buildLayout() {
                     if (user.phone != null && user.phone.length() != 0) {
                         nameString = PhoneFormat.getInstance().format("+" + user.phone);
                     } else {
-                        currentNamePaint = nameUnknownPaint;
                         nameString = UserObject.getUserName(user);
                     }
                 }
@@ -489,6 +509,8 @@ public void buildLayout() {
             nameWidth -= AndroidUtilities.dp(4) + groupDrawable.getIntrinsicWidth();
         } else if (drawNameBroadcast) {
             nameWidth -= AndroidUtilities.dp(4) + broadcastDrawable.getIntrinsicWidth();
+        } else if (drawNameBot) {
+            nameWidth -= AndroidUtilities.dp(4) + botDrawable.getIntrinsicWidth();
         }
         if (drawClock) {
             int w = clockDrawable.getIntrinsicWidth() + AndroidUtilities.dp(5);
@@ -522,12 +544,18 @@ public void buildLayout() {
             }
         }
 
-        if (dialogMuted) {
+        if (dialogMuted && !drawVerified) {
             int w = AndroidUtilities.dp(6) + muteDrawable.getIntrinsicWidth();
             nameWidth -= w;
             if (LocaleController.isRTL) {
                 nameLeft += w;
             }
+        } else if (drawVerified) {
+            int w = AndroidUtilities.dp(6) + verifiedDrawable.getIntrinsicWidth();
+            nameWidth -= w;
+            if (LocaleController.isRTL) {
+                nameLeft += w;
+            }
         }
 
         nameWidth = Math.max(AndroidUtilities.dp(12), nameWidth);
@@ -598,8 +626,10 @@ public void buildLayout() {
             if (nameLayout != null && nameLayout.getLineCount() > 0) {
                 left = nameLayout.getLineLeft(0);
                 widthpx = Math.ceil(nameLayout.getLineWidth(0));
-                if (dialogMuted) {
+                if (dialogMuted && !drawVerified) {
                     nameMuteLeft = (int) (nameLeft + (nameWidth - widthpx) - AndroidUtilities.dp(6) - muteDrawable.getIntrinsicWidth());
+                } else if (drawVerified) {
+                    nameMuteLeft = (int) (nameLeft + (nameWidth - widthpx) - AndroidUtilities.dp(6) - verifiedDrawable.getIntrinsicWidth());
                 }
                 if (left == 0) {
                     if (widthpx < nameWidth) {
@@ -625,7 +655,7 @@ public void buildLayout() {
                         nameLeft -= (nameWidth - widthpx);
                     }
                 }
-                if (dialogMuted) {
+                if (dialogMuted || drawVerified) {
                     nameMuteLeft = (int) (nameLeft + left + AndroidUtilities.dp(6));
                 }
             }
@@ -662,7 +692,7 @@ public void setDialogSelected(boolean value) {
     public void checkCurrentDialogIndex() {
         if (index < getDialogsArray().size()) {
             TLRPC.Dialog dialog = getDialogsArray().get(index);
-            if (currentDialogId != dialog.id || message != null && message.getId() != dialog.top_message || unreadCount != dialog.unread_count) {
+            if (currentDialogId != dialog.id || message != null && message.getId() != dialog.top_message || unreadCount != dialog.unread_count || message == null && MessagesController.getInstance().dialogMessage.get(dialog.id) != null) {
                 currentDialogId = dialog.id;
                 update(0);
             }
@@ -750,6 +780,12 @@ public void update(int mask) {
             } else {
                 if (lower_id < 0) {
                     chat = MessagesController.getInstance().getChat(-lower_id);
+                    if (!isDialogCell && chat != null && chat.migrated_to != null) {
+                        TLRPC.Chat chat2 = MessagesController.getInstance().getChat(chat.migrated_to.channel_id);
+                        if (chat2 != null) {
+                            chat = chat2;
+                        }
+                    }
                 } else {
                     user = MessagesController.getInstance().getUser(lower_id);
                 }
@@ -803,6 +839,9 @@ protected void onDraw(Canvas canvas) {
         } else if (drawNameBroadcast) {
             setDrawableBounds(broadcastDrawable, nameLockLeft, nameLockTop);
             broadcastDrawable.draw(canvas);
+        } else if (drawNameBot) {
+            setDrawableBounds(botDrawable, nameLockLeft, nameLockTop);
+            botDrawable.draw(canvas);
         }
 
         if (nameLayout != null) {
@@ -839,17 +878,25 @@ protected void onDraw(Canvas canvas) {
             }
         }
 
-        if (dialogMuted) {
+        if (dialogMuted && !drawVerified) {
             setDrawableBounds(muteDrawable, nameMuteLeft, AndroidUtilities.dp(16.5f));
             muteDrawable.draw(canvas);
+        } else if (drawVerified) {
+            setDrawableBounds(verifiedDrawable, nameMuteLeft, AndroidUtilities.dp(16.5f));
+            verifiedDrawable.draw(canvas);
         }
 
         if (drawError) {
             setDrawableBounds(errorDrawable, errorLeft, errorTop);
             errorDrawable.draw(canvas);
         } else if (drawCount) {
-            setDrawableBounds(countDrawable, countLeft - AndroidUtilities.dp(5.5f), countTop, countWidth + AndroidUtilities.dp(11), countDrawable.getIntrinsicHeight());
-            countDrawable.draw(canvas);
+            if (dialogMuted) {
+                setDrawableBounds(countDrawableGrey, countLeft - AndroidUtilities.dp(5.5f), countTop, countWidth + AndroidUtilities.dp(11), countDrawable.getIntrinsicHeight());
+                countDrawableGrey.draw(canvas);
+            } else {
+                setDrawableBounds(countDrawable, countLeft - AndroidUtilities.dp(5.5f), countTop, countWidth + AndroidUtilities.dp(11), countDrawable.getIntrinsicHeight());
+                countDrawable.draw(canvas);
+            }
             canvas.save();
             canvas.translate(countLeft, countTop + AndroidUtilities.dp(4));
             countLayout.draw(canvas);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DividerCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DividerCell.java
index 6db8d6a06..350417ceb 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DividerCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DividerCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerActionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerActionCell.java
index e9faabc65..282256d2f 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerActionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerActionCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -15,6 +15,7 @@
 import android.widget.TextView;
 
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.FileLog;
 import org.telegram.ui.Components.LayoutHelper;
 
 public class DrawerActionCell extends FrameLayout {
@@ -42,7 +43,11 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
     }
 
     public void setTextAndIcon(String text, int resId) {
-        textView.setText(text);
-        textView.setCompoundDrawablesWithIntrinsicBounds(resId, 0, 0, 0);
+        try {
+            textView.setText(text);
+            textView.setCompoundDrawablesWithIntrinsicBounds(resId, 0, 0, 0);
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerProfileCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerProfileCell.java
index f50a52ea9..d62ff2f76 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerProfileCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/DrawerProfileCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/EmptyCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/EmptyCell.java
index 0458b98f2..53b3ca3a2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/EmptyCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/EmptyCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/GreySectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/GreySectionCell.java
index 3495fa683..61e752237 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/GreySectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/GreySectionCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java
index f26c8e573..6c6ee1387 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HashtagSearchCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HeaderCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HeaderCell.java
index 46836e465..f59140098 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/HeaderCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/HeaderCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LastSeenRadioCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LastSeenRadioCell.java
new file mode 100644
index 000000000..e26e0ea49
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LastSeenRadioCell.java
@@ -0,0 +1,87 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.LocaleController;
+import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.RadioButton;
+
+public class LastSeenRadioCell extends FrameLayout {
+
+    private TextView textView;
+    private RadioButton radioButton;
+    private static Paint paint;
+    private boolean needDivider;
+
+    public LastSeenRadioCell(Context context) {
+        super(context);
+
+        if (paint == null) {
+            paint = new Paint();
+            paint.setColor(0xffd9d9d9);
+            paint.setStrokeWidth(1);
+        }
+
+        textView = new TextView(context);
+        textView.setTextColor(0xff212121);
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        textView.setLines(1);
+        textView.setMaxLines(1);
+        textView.setSingleLine(true);
+        textView.setEllipsize(TextUtils.TruncateAt.END);
+        textView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
+        addView(textView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, 17, 0, 17, 0));
+
+        radioButton = new RadioButton(context);
+        radioButton.setSize(AndroidUtilities.dp(20));
+        radioButton.setColor(0xffb3b3b3, 0xff37a9f0);
+        addView(radioButton, LayoutHelper.createFrame(22, 22, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP, (LocaleController.isRTL ? 18 : 0), 13, (LocaleController.isRTL ? 0 : 18), 0));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), AndroidUtilities.dp(48) + (needDivider ? 1 : 0));
+
+        int availableWidth = getMeasuredWidth() - getPaddingLeft() - getPaddingRight() - AndroidUtilities.dp(34);
+        radioButton.measure(MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(22), MeasureSpec.AT_MOST), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(22), MeasureSpec.EXACTLY));
+        textView.measure(MeasureSpec.makeMeasureSpec(availableWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
+    }
+
+    public void setTextColor(int color) {
+        textView.setTextColor(color);
+    }
+
+    public void setText(String text, boolean checked, boolean divider) {
+        textView.setText(text);
+        radioButton.setChecked(checked, false);
+        needDivider = divider;
+        setWillNotDraw(!divider);
+    }
+
+    public void setChecked(boolean checked, boolean animated) {
+        radioButton.setChecked(checked, animated);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (needDivider) {
+            canvas.drawLine(getPaddingLeft(), getHeight() - 1, getWidth() - getPaddingRight(), getHeight() - 1, paint);
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LetterSectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LetterSectionCell.java
index 3cae8a321..62e414eaa 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LetterSectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LetterSectionCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LoadingCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LoadingCell.java
index 6da6b9db5..6d8ba1d42 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LoadingCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LoadingCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationCell.java
index a3bbf7ed2..548202dde 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationLoadingCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationLoadingCell.java
index dbed1458b..84ab570d9 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationLoadingCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationLoadingCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationPoweredCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationPoweredCell.java
index 3b3393f35..6b0b0677d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationPoweredCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/LocationPoweredCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java
index 7674c25ec..f952ae1a3 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/MentionCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoAttachCameraCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoAttachCameraCell.java
index 69c255ea0..13e32de29 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoAttachCameraCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoAttachCameraCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoAttachPhotoCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoAttachPhotoCell.java
index b4ce6e08b..859195970 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoAttachPhotoCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoAttachPhotoCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -9,7 +9,10 @@
 package org.telegram.ui.Cells;
 
 import android.content.Context;
+import android.graphics.Rect;
 import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.SoundEffectConstants;
 import android.view.View;
 import android.widget.FrameLayout;
 
@@ -27,6 +30,13 @@
     private FrameLayout checkFrame;
     private CheckBox checkBox;
     private boolean isLast;
+    private boolean pressed;
+    private static Rect rect = new Rect();
+    private PhotoAttachPhotoCellDelegate delegate;
+
+    public interface PhotoAttachPhotoCellDelegate {
+        void onCheckClick(PhotoAttachPhotoCell v);
+    }
 
     private MediaController.PhotoEntry photoEntry;
 
@@ -35,10 +45,8 @@ public PhotoAttachPhotoCell(Context context) {
 
         imageView = new BackupImageView(context);
         addView(imageView, LayoutHelper.createFrame(80, 80));
-
         checkFrame = new FrameLayout(context);
-        //addView(checkFrame, LayoutHelper.createFrame(42, 42, Gravity.LEFT | Gravity.TOP, 38, 0, 0, 0));
-        addView(checkFrame, LayoutHelper.createFrame(80, 80, Gravity.LEFT | Gravity.TOP, 0, 0, 0, 0));
+        addView(checkFrame, LayoutHelper.createFrame(42, 42, Gravity.LEFT | Gravity.TOP, 38, 0, 0, 0));
 
         checkBox = new CheckBox(context, R.drawable.checkbig);
         checkBox.setSize(30);
@@ -58,7 +66,16 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         return photoEntry;
     }
 
+    public BackupImageView getImageView() {
+        return imageView;
+    }
+
+    public CheckBox getCheckBox() {
+        return checkBox;
+    }
+
     public void setPhotoEntry(MediaController.PhotoEntry entry, boolean last) {
+        pressed = false;
         photoEntry = entry;
         isLast = last;
         if (photoEntry.thumbPath != null) {
@@ -81,6 +98,44 @@ public void setChecked(boolean value, boolean animated) {
 
     public void setOnCheckClickLisnener(OnClickListener onCheckClickLisnener) {
         checkFrame.setOnClickListener(onCheckClickLisnener);
-        imageView.setOnClickListener(onCheckClickLisnener);
+    }
+
+    public void setDelegate(PhotoAttachPhotoCellDelegate delegate) {
+        this.delegate = delegate;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        boolean result = false;
+
+        checkFrame.getHitRect(rect);
+        if (event.getAction() == MotionEvent.ACTION_DOWN) {
+            if (rect.contains((int) event.getX(), (int) event.getY())) {
+                pressed = true;
+                invalidate();
+                result = true;
+            }
+        } else if (pressed) {
+            if (event.getAction() == MotionEvent.ACTION_UP) {
+                getParent().requestDisallowInterceptTouchEvent(true);
+                pressed = false;
+                playSoundEffect(SoundEffectConstants.CLICK);
+                delegate.onCheckClick(this);
+                invalidate();
+            } else if (event.getAction() == MotionEvent.ACTION_CANCEL) {
+                pressed = false;
+                invalidate();
+            } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
+                if (!(rect.contains((int) event.getX(), (int) event.getY()))) {
+                    pressed = false;
+                    invalidate();
+                }
+            }
+        }
+        if (!result) {
+            result = super.onTouchEvent(event);
+        }
+
+        return result;
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoEditToolCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoEditToolCell.java
index afc6128bb..8e16a1cc5 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoEditToolCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoEditToolCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerAlbumsCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerAlbumsCell.java
index 458ffa321..fc45e904d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerAlbumsCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerAlbumsCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerPhotoCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerPhotoCell.java
index cda365f6b..620d2312c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerPhotoCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerPhotoCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -13,6 +13,10 @@
 import android.widget.FrameLayout;
 
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.AnimationCompat.AnimatorListenerAdapterProxy;
+import org.telegram.messenger.AnimationCompat.AnimatorSetProxy;
+import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
+import org.telegram.messenger.AnimationCompat.ViewProxy;
 import org.telegram.messenger.R;
 import org.telegram.ui.Components.BackupImageView;
 import org.telegram.ui.Components.CheckBox;
@@ -23,6 +27,7 @@
     public BackupImageView photoImage;
     public FrameLayout checkFrame;
     public CheckBox checkBox;
+    private AnimatorSetProxy animator;
     public int itemWidth;
 
     public PhotoPickerPhotoCell(Context context) {
@@ -39,11 +44,44 @@ public PhotoPickerPhotoCell(Context context) {
         checkBox.setCheckOffset(AndroidUtilities.dp(1));
         checkBox.setDrawBackground(true);
         checkBox.setColor(0xff3ccaef);
-        addView(checkBox, LayoutHelper.createFrame(30, 30, Gravity.RIGHT | Gravity.TOP, 0, 6, 6, 0));
+        addView(checkBox, LayoutHelper.createFrame(30, 30, Gravity.RIGHT | Gravity.TOP, 0, 4, 4, 0));
     }
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         super.onMeasure(MeasureSpec.makeMeasureSpec(itemWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(itemWidth, MeasureSpec.EXACTLY));
     }
+
+    public void setChecked(final boolean checked, boolean animated) {
+        checkBox.setChecked(checked, animated);
+        if (animator != null) {
+            animator.cancel();
+            animator = null;
+        }
+        if (animated) {
+            if (checked) {
+                setBackgroundColor(0xff0A0A0A);
+            }
+            animator = new AnimatorSetProxy();
+            animator.playTogether(ObjectAnimatorProxy.ofFloat(photoImage, "scaleX", checked ? 0.85f : 1.0f),
+                    ObjectAnimatorProxy.ofFloat(photoImage, "scaleY", checked ? 0.85f : 1.0f));
+            animator.setDuration(200);
+            animator.addListener(new AnimatorListenerAdapterProxy() {
+                @Override
+                public void onAnimationEnd(Object animation) {
+                    if (animator.equals(animation)) {
+                        animator = null;
+                        if (!checked) {
+                            setBackgroundColor(0);
+                        }
+                    }
+                }
+            });
+            animator.start();
+        } else {
+            setBackgroundColor(checked ? 0xff0A0A0A : 0);
+            ViewProxy.setScaleX(photoImage, checked ? 0.85f : 1.0f);
+            ViewProxy.setScaleY(photoImage, checked ? 0.85f : 1.0f);
+        }
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerSearchCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerSearchCell.java
index 7a81c153b..0b71286e4 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerSearchCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/PhotoPickerSearchCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ProfileSearchCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ProfileSearchCell.java
index 09a7283c3..1b44732dc 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ProfileSearchCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ProfileSearchCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -21,6 +21,7 @@
 
 import org.telegram.PhoneFormat.PhoneFormat;
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.ChatObject;
 import org.telegram.messenger.ImageReceiver;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.MessagesController;
@@ -40,9 +41,12 @@
     private static TextPaint offlinePaint;
     private static TextPaint countPaint;
     private static Drawable lockDrawable;
+    private static Drawable botDrawable;
     private static Drawable broadcastDrawable;
     private static Drawable groupDrawable;
     private static Drawable countDrawable;
+    private static Drawable countDrawableGrey;
+    private static Drawable checkDrawable;
     private static Paint linePaint;
 
     private CharSequence currentName;
@@ -53,7 +57,7 @@
     private TLRPC.User user = null;
     private TLRPC.Chat chat = null;
     private TLRPC.EncryptedChat encryptedChat = null;
-    long dialog_id;
+    private long dialog_id;
 
     private String lastName = null;
     private int lastStatus = 0;
@@ -68,6 +72,7 @@
     private boolean drawNameLock;
     private boolean drawNameBroadcast;
     private boolean drawNameGroup;
+    private boolean drawNameBot;
     private int nameLockLeft;
     private int nameLockTop;
 
@@ -78,6 +83,8 @@
     private int countWidth;
     private StaticLayout countLayout;
 
+    private boolean drawCheck;
+
     private int onlineLeft;
     private StaticLayout onlineLayout;
 
@@ -115,6 +122,9 @@ public ProfileSearchCell(Context context) {
             lockDrawable = getResources().getDrawable(R.drawable.list_secret);
             groupDrawable = getResources().getDrawable(R.drawable.list_group);
             countDrawable = getResources().getDrawable(R.drawable.dialogs_badge);
+            countDrawableGrey = getResources().getDrawable(R.drawable.dialogs_badge2);
+            checkDrawable = getResources().getDrawable(R.drawable.check_list);
+            botDrawable = getResources().getDrawable(R.drawable.bot_list);
         }
 
         avatarImage = new ImageReceiver(this);
@@ -182,6 +192,8 @@ public void buildLayout() {
         drawNameBroadcast = false;
         drawNameLock = false;
         drawNameGroup = false;
+        drawCheck = false;
+        drawNameBot = false;
 
         if (encryptedChat != null) {
             drawNameLock = true;
@@ -202,9 +214,15 @@ public void buildLayout() {
                     nameLockTop = AndroidUtilities.dp(28.5f);
                 } else {
                     dialog_id = -chat.id;
-                    drawNameGroup = true;
-                    nameLockTop = AndroidUtilities.dp(30);
+                    if (ChatObject.isChannel(chat) && !chat.megagroup) {
+                        drawNameBroadcast = true;
+                        nameLockTop = AndroidUtilities.dp(28.5f);
+                    } else {
+                        drawNameGroup = true;
+                        nameLockTop = AndroidUtilities.dp(30);
+                    }
                 }
+                drawCheck = chat.verified;
                 if (!LocaleController.isRTL) {
                     nameLockLeft = AndroidUtilities.dp(AndroidUtilities.leftBaseline);
                     nameLeft = AndroidUtilities.dp(AndroidUtilities.leftBaseline + 4) + (drawNameGroup ? groupDrawable.getIntrinsicWidth() : broadcastDrawable.getIntrinsicWidth());
@@ -219,6 +237,20 @@ public void buildLayout() {
                 } else {
                     nameLeft = AndroidUtilities.dp(11);
                 }
+                if (user.bot) {
+                    drawNameBot = true;
+                    if (!LocaleController.isRTL) {
+                        nameLockLeft = AndroidUtilities.dp(AndroidUtilities.leftBaseline);
+                        nameLeft = AndroidUtilities.dp(AndroidUtilities.leftBaseline + 4) + botDrawable.getIntrinsicWidth();
+                    } else {
+                        nameLockLeft = getMeasuredWidth() - AndroidUtilities.dp(AndroidUtilities.leftBaseline + 2) - botDrawable.getIntrinsicWidth();
+                        nameLeft = AndroidUtilities.dp(11);
+                    }
+                    nameLockTop = AndroidUtilities.dp(16.5f);
+                } else {
+                    nameLockTop = AndroidUtilities.dp(17);
+                }
+                drawCheck = user.verified;
             }
         }
 
@@ -259,6 +291,8 @@ public void buildLayout() {
             nameWidth -= AndroidUtilities.dp(6) + broadcastDrawable.getIntrinsicWidth();
         } else if (drawNameGroup) {
             nameWidth -= AndroidUtilities.dp(6) + groupDrawable.getIntrinsicWidth();
+        } else if (drawNameBot) {
+            nameWidth -= AndroidUtilities.dp(6) + botDrawable.getIntrinsicWidth();
         }
 
         if (drawCount) {
@@ -301,7 +335,7 @@ public void buildLayout() {
             if (subLabel != null) {
                 onlineString = subLabel;
             } else if (user != null) {
-                if ((user.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                if (user.bot) {
                     onlineString = LocaleController.getString("Bot", R.string.Bot);
                 } else {
                     onlineString = LocaleController.formatUserStatus(user);
@@ -315,7 +349,7 @@ public void buildLayout() {
             CharSequence onlineStringFinal = TextUtils.ellipsize(onlineString, currentOnlinePaint, onlineWidth - AndroidUtilities.dp(12), TextUtils.TruncateAt.END);
             onlineLayout = new StaticLayout(onlineStringFinal, currentOnlinePaint, onlineWidth, Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
             nameTop = AndroidUtilities.dp(13);
-            if (subLabel != null) {
+            if (subLabel != null && !drawNameBot) {
                 nameLockTop -= AndroidUtilities.dp(12);
             }
         } else {
@@ -480,6 +514,9 @@ protected void onDraw(Canvas canvas) {
         } else if (drawNameBroadcast) {
             setDrawableBounds(broadcastDrawable, nameLockLeft, nameLockTop);
             broadcastDrawable.draw(canvas);
+        } else if (drawNameBot) {
+            setDrawableBounds(botDrawable, nameLockLeft, nameLockTop);
+            botDrawable.draw(canvas);
         }
 
         if (nameLayout != null) {
@@ -487,6 +524,14 @@ protected void onDraw(Canvas canvas) {
             canvas.translate(nameLeft, nameTop);
             nameLayout.draw(canvas);
             canvas.restore();
+            if (drawCheck) {
+                if (LocaleController.isRTL) {
+                    setDrawableBounds(checkDrawable, nameLeft - AndroidUtilities.dp(4) - checkDrawable.getIntrinsicWidth(), nameLockTop);
+                } else {
+                    setDrawableBounds(checkDrawable, nameLeft + (int) nameLayout.getLineWidth(0) + AndroidUtilities.dp(4), nameLockTop);
+                }
+                checkDrawable.draw(canvas);
+            }
         }
 
         if (onlineLayout != null) {
@@ -497,8 +542,13 @@ protected void onDraw(Canvas canvas) {
         }
 
         if (countLayout != null) {
-            setDrawableBounds(countDrawable, countLeft - AndroidUtilities.dp(5.5f), countTop, countWidth + AndroidUtilities.dp(11), countDrawable.getIntrinsicHeight());
-            countDrawable.draw(canvas);
+            if (MessagesController.getInstance().isDialogMuted(dialog_id)) {
+                setDrawableBounds(countDrawableGrey, countLeft - AndroidUtilities.dp(5.5f), countTop, countWidth + AndroidUtilities.dp(11), countDrawableGrey.getIntrinsicHeight());
+                countDrawableGrey.draw(canvas);
+            } else {
+                setDrawableBounds(countDrawable, countLeft - AndroidUtilities.dp(5.5f), countTop, countWidth + AndroidUtilities.dp(11), countDrawable.getIntrinsicHeight());
+                countDrawable.draw(canvas);
+            }
             canvas.save();
             canvas.translate(countLeft, countTop + AndroidUtilities.dp(4));
             countLayout.draw(canvas);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/RadioButtonCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/RadioButtonCell.java
index d27164def..1192e1c1a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/RadioButtonCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/RadioButtonCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SendLocationCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SendLocationCell.java
index ab3b1eba3..d6fe28335 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SendLocationCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SendLocationCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java
index 01210d647..44ef5ff86 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SessionCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowBottomSectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowBottomSectionCell.java
index b7a4d0dfa..e391e8d67 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowBottomSectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowBottomSectionCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowSectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowSectionCell.java
index b3f238861..006463546 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowSectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShadowSectionCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -23,6 +23,6 @@ public ShadowSectionCell(Context context) {
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(12), MeasureSpec.EXACTLY));
+        super.onMeasure(MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(12), MeasureSpec.EXACTLY));
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShareDialogCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShareDialogCell.java
new file mode 100644
index 000000000..ffce4466b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/ShareDialogCell.java
@@ -0,0 +1,101 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Cells;
+
+import android.content.Context;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.widget.FrameLayout;
+import android.widget.TextView;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.ContactsController;
+import org.telegram.messenger.MessagesController;
+import org.telegram.messenger.R;
+import org.telegram.tgnet.TLRPC;
+import org.telegram.ui.Components.AvatarDrawable;
+import org.telegram.ui.Components.BackupImageView;
+import org.telegram.ui.Components.CheckBox;
+import org.telegram.ui.Components.LayoutHelper;
+
+public class ShareDialogCell extends FrameLayout {
+
+    private BackupImageView imageView;
+    private TextView nameTextView;
+    private CheckBox checkBox;
+    private AvatarDrawable avatarDrawable = new AvatarDrawable();
+
+    public ShareDialogCell(Context context) {
+        super(context);
+
+        imageView = new BackupImageView(context);
+        imageView.setRoundRadius(AndroidUtilities.dp(27));
+        addView(imageView, LayoutHelper.createFrame(54, 54, Gravity.TOP | Gravity.CENTER_HORIZONTAL, 0, 7, 0, 0));
+
+        nameTextView = new TextView(context);
+        nameTextView.setTextColor(0xff212121);
+        nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12);
+        nameTextView.setMaxLines(2);
+        nameTextView.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL);
+        nameTextView.setLines(2);
+        nameTextView.setEllipsize(TextUtils.TruncateAt.END);
+        addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP, 6, 64, 6, 0));
+
+        checkBox = new CheckBox(context, R.drawable.round_check2);
+        checkBox.setSize(24);
+        checkBox.setCheckOffset(AndroidUtilities.dp(1));
+        checkBox.setVisibility(VISIBLE);
+        checkBox.setColor(0xff3ec1f9);
+        addView(checkBox, LayoutHelper.createFrame(24, 24, Gravity.CENTER_HORIZONTAL | Gravity.TOP, 17, 39, 0, 0));
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(100), MeasureSpec.EXACTLY));
+    }
+
+    public void setDialog(TLRPC.Dialog dialog, boolean checked, CharSequence name) {
+        int lower_id = (int) dialog.id;
+        TLRPC.FileLocation photo = null;
+        if (lower_id > 0) {
+            TLRPC.User user = MessagesController.getInstance().getUser(lower_id);
+            if (name != null) {
+                nameTextView.setText(name);
+            } else if (user != null) {
+                nameTextView.setText(ContactsController.formatName(user.first_name, user.last_name));
+            } else {
+                nameTextView.setText("");
+            }
+            avatarDrawable.setInfo(user);
+            if (user != null && user.photo != null) {
+                photo = user.photo.photo_small;
+            }
+        } else {
+            TLRPC.Chat chat = MessagesController.getInstance().getChat(-lower_id);
+            if (name != null) {
+                nameTextView.setText(name);
+            } else if (chat != null) {
+                nameTextView.setText(chat.title);
+            } else {
+                nameTextView.setText("");
+            }
+            avatarDrawable.setInfo(chat);
+            if (chat != null && chat.photo != null) {
+                photo = chat.photo.photo_small;
+            }
+        }
+        imageView.setImage(photo, "50_50", avatarDrawable);
+        checkBox.setChecked(checked, false);
+    }
+
+    public void setChecked(boolean checked, boolean animated) {
+        checkBox.setChecked(checked, animated);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedDocumentCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedDocumentCell.java
index a970671ab..9baed23c3 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedDocumentCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedDocumentCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -204,7 +204,7 @@ public void setDocument(MessageObject document, boolean divider) {
         loaded = false;
         loading = false;
 
-        if (document != null && document.messageOwner.media != null) {
+        if (document != null && document.messageOwner.media != null && document.messageOwner.media.document != null) {
             int idx;
             String name = FileLoader.getDocumentFileName(document.messageOwner.media.document);
             placeholderImabeView.setVisibility(VISIBLE);
@@ -220,7 +220,7 @@ public void setDocument(MessageObject document, boolean divider) {
                 thumbImageView.setImage(document.messageOwner.media.document.thumb.location, "40_40", (Drawable) null);
             }
             long date = (long) document.messageOwner.date * 1000;
-            dateTextView.setText(String.format("%s, %s", AndroidUtilities.formatFileSize(document.messageOwner.media.document.size), LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.formatterYear.format(new Date(date)), LocaleController.formatterDay.format(new Date(date)))));
+            dateTextView.setText(String.format("%s, %s", AndroidUtilities.formatFileSize(document.messageOwner.media.document.size), LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.getInstance().formatterYear.format(new Date(date)), LocaleController.getInstance().formatterDay.format(new Date(date)))));
         } else {
             nameTextView.setText("");
             extTextView.setText("");
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedLinkCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedLinkCell.java
index 69b0bb2bb..915a3866f 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedLinkCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedLinkCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedMediaSectionCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedMediaSectionCell.java
index 09495fc0b..b4631b4d6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedMediaSectionCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedMediaSectionCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedPhotoVideoCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedPhotoVideoCell.java
index 7748c7353..4ab37ad3c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedPhotoVideoCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/SharedPhotoVideoCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -19,6 +19,10 @@
 import android.widget.TextView;
 
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.AnimationCompat.AnimatorListenerAdapterProxy;
+import org.telegram.messenger.AnimationCompat.AnimatorSetProxy;
+import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
+import org.telegram.messenger.AnimationCompat.ViewProxy;
 import org.telegram.messenger.MessageObject;
 import org.telegram.messenger.ApplicationLoader;
 import org.telegram.messenger.FileLoader;
@@ -51,21 +55,26 @@
         private LinearLayout videoInfoContainer;
         private View selector;
         private CheckBox checkBox;
+        private FrameLayoutFixed container;
+        private AnimatorSetProxy animator;
 
         public PhotoVideoView(Context context) {
             super(context);
 
+            container = new FrameLayoutFixed(context);
+            addView(container, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+
             imageView = new BackupImageView(context);
             imageView.getImageReceiver().setNeedsQualityThumb(true);
             imageView.getImageReceiver().setShouldGenerateQualityThumb(true);
-            addView(imageView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+            container.addView(imageView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
             videoInfoContainer = new LinearLayout(context);
             videoInfoContainer.setOrientation(LinearLayout.HORIZONTAL);
             videoInfoContainer.setBackgroundResource(R.drawable.phototime);
             videoInfoContainer.setPadding(AndroidUtilities.dp(3), 0, AndroidUtilities.dp(3), 0);
             videoInfoContainer.setGravity(Gravity.CENTER_VERTICAL);
-            addView(videoInfoContainer, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 16, Gravity.BOTTOM | Gravity.LEFT));
+            container.addView(videoInfoContainer, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 16, Gravity.BOTTOM | Gravity.LEFT));
 
             ImageView imageView1 = new ImageView(context);
             imageView1.setImageResource(R.drawable.ic_video);
@@ -83,7 +92,7 @@ public PhotoVideoView(Context context) {
 
             checkBox = new CheckBox(context, R.drawable.round_check2);
             checkBox.setVisibility(INVISIBLE);
-            addView(checkBox, LayoutHelper.createFrame(22, 22, Gravity.RIGHT | Gravity.TOP, 0, 6, 6, 0));
+            addView(checkBox, LayoutHelper.createFrame(22, 22, Gravity.RIGHT | Gravity.TOP, 0, 2, 2, 0));
         }
 
         @Override
@@ -93,6 +102,51 @@ public boolean onTouchEvent(MotionEvent event) {
             }
             return super.onTouchEvent(event);
         }
+
+        public void setChecked(final boolean checked, boolean animated) {
+            if (checkBox.getVisibility() != VISIBLE) {
+                checkBox.setVisibility(VISIBLE);
+            }
+            checkBox.setChecked(checked, animated);
+            if (animator != null) {
+                animator.cancel();
+                animator = null;
+            }
+            if (animated) {
+                if (checked) {
+                    setBackgroundColor(0xfff5f5f5);
+                }
+                animator = new AnimatorSetProxy();
+                animator.playTogether(ObjectAnimatorProxy.ofFloat(container, "scaleX", checked ? 0.85f : 1.0f),
+                        ObjectAnimatorProxy.ofFloat(container, "scaleY", checked ? 0.85f : 1.0f));
+                animator.setDuration(200);
+                animator.addListener(new AnimatorListenerAdapterProxy() {
+                    @Override
+                    public void onAnimationEnd(Object animation) {
+                        if (animator.equals(animation)) {
+                            animator = null;
+                            if (!checked) {
+                                setBackgroundColor(0);
+                            }
+                        }
+                    }
+                });
+                animator.start();
+            } else {
+                setBackgroundColor(checked ? 0xfff5f5f5 : 0);
+                ViewProxy.setScaleX(container, checked ? 0.85f : 1.0f);
+                ViewProxy.setScaleY(container, checked ? 0.85f : 1.0f);
+            }
+        }
+
+        @Override
+        public void clearAnimation() {
+            super.clearAnimation();
+            if (animator != null) {
+                animator.cancel();
+                animator = null;
+            }
+        }
     }
 
     public SharedPhotoVideoCell(Context context) {
@@ -134,6 +188,7 @@ public void setDelegate(SharedPhotoVideoCellDelegate delegate) {
 
     public void setItemsCount(int count) {
         for (int a = 0; a < photoVideoViews.length; a++) {
+            photoVideoViews[a].clearAnimation();
             photoVideoViews[a].setVisibility(a < count ? VISIBLE : INVISIBLE);
         }
         itemsCount = count;
@@ -158,10 +213,7 @@ public void setIsFirst(boolean first) {
     }
 
     public void setChecked(int a, boolean checked, boolean animated) {
-        if (photoVideoViews[a].checkBox.getVisibility() != VISIBLE) {
-            photoVideoViews[a].checkBox.setVisibility(VISIBLE);
-        }
-        photoVideoViews[a].checkBox.setChecked(checked, animated);
+        photoVideoViews[a].setChecked(checked, animated);
     }
 
     public void setItem(int a, int index, MessageObject messageObject) {
@@ -195,6 +247,7 @@ public void setItem(int a, int index, MessageObject messageObject) {
                 photoVideoView.imageView.setImageResource(R.drawable.photo_placeholder_in);
             }
         } else {
+            photoVideoViews[a].clearAnimation();
             photoVideoViews[a].setVisibility(INVISIBLE);
             messageObjects[a] = null;
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerCell.java
index 5b4d57a52..af2d4bafc 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerCell.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -45,7 +45,7 @@ public void setPressed(boolean pressed) {
     }
 
     public void setSticker(TLRPC.Document document, int side) {
-        if (document != null) {
+        if (document != null && document.thumb != null) {
             imageView.setImage(document.thumb.location, null, "webp", null);
         }
         if (side == -1) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java
index c6c8d9418..d450fe343 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerEmojiCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -57,7 +57,9 @@ public StickerEmojiCell(Context context) {
     public void setSticker(TLRPC.Document document, boolean showEmoji) {
         if (document != null) {
             sticker = document;
-            imageView.setImage(document.thumb.location, null, "webp", null);
+            if (document.thumb != null) {
+                imageView.setImage(document.thumb.location, null, "webp", null);
+            }
 
             if (showEmoji) {
                 boolean set = false;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerSetCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerSetCell.java
index 6e0437d3a..83838a2db 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerSetCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/StickerSetCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -11,9 +11,12 @@
 import android.content.Context;
 import android.graphics.Canvas;
 import android.graphics.Paint;
+import android.graphics.Rect;
+import android.os.Build;
 import android.text.TextUtils;
 import android.util.TypedValue;
 import android.view.Gravity;
+import android.view.MotionEvent;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
 import android.widget.TextView;
@@ -36,6 +39,7 @@
     private boolean needDivider;
     private ImageView optionsButton;
     private TLRPC.TL_messages_stickerSet stickersSet;
+    private Rect rect = new Rect();
 
     private static Paint paint;
 
@@ -70,7 +74,15 @@ public StickerSetCell(Context context) {
         imageView.setAspectFit(true);
         addView(imageView, LayoutHelper.createFrame(48, 48, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 12, 8, LocaleController.isRTL ? 12 : 0, 0));
 
-        optionsButton = new ImageView(context);
+        optionsButton = new ImageView(context) {
+            @Override
+            public boolean onTouchEvent(MotionEvent event) {
+                if (event.getAction() == MotionEvent.ACTION_UP) {
+                    StickerSetCell.this.getParent().requestDisallowInterceptTouchEvent(true);
+                }
+                return super.onTouchEvent(event);
+            }
+        };
         optionsButton.setBackgroundResource(R.drawable.bar_selector_grey);
         optionsButton.setImageResource(R.drawable.doc_actions_b);
         optionsButton.setScaleType(ImageView.ScaleType.CENTER);
@@ -90,7 +102,7 @@ public StickerSetCell(Context context) {
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64) + (needDivider ? 1 : 0), MeasureSpec.EXACTLY));
+        super.onMeasure(MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64) + (needDivider ? 1 : 0), MeasureSpec.EXACTLY));
     }
 
     public void setStickersSet(TLRPC.TL_messages_stickerSet set, boolean divider) {
@@ -98,7 +110,7 @@ public void setStickersSet(TLRPC.TL_messages_stickerSet set, boolean divider) {
         stickersSet = set;
 
         textView.setText(stickersSet.set.title);
-        if ((stickersSet.set.flags & 2) != 0) {
+        if (stickersSet.set.disabled) {
             ViewProxy.setAlpha(textView, 0.5f);
             ViewProxy.setAlpha(valueTextView, 0.5f);
             ViewProxy.setAlpha(imageView, 0.5f);
@@ -127,6 +139,20 @@ public void setOnOptionsClick(OnClickListener listener) {
         return stickersSet;
     }
 
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (Build.VERSION.SDK_INT >= 21 && getBackground() != null) {
+            optionsButton.getHitRect(rect);
+            if (rect.contains((int) event.getX(), (int) event.getY())) {
+                return true;
+            }
+            if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {
+                getBackground().setHotspot(event.getX(), event.getY());
+            }
+        }
+        return super.onTouchEvent(event);
+    }
+
     @Override
     protected void onDraw(Canvas canvas) {
         if (needDivider) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextBlockCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextBlockCell.java
index 082d38c0d..3361937f5 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextBlockCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextBlockCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCell.java
index 0ff9885e6..9b786feba 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -28,8 +28,6 @@
     private ImageView imageView;
     private ImageView valueImageView;
 
-    private boolean multiline;
-
     public TextCell(Context context) {
         super(context);
 
@@ -63,7 +61,7 @@ public TextCell(Context context) {
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, multiline ?  MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED) : MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(48), MeasureSpec.EXACTLY));
+        super.onMeasure(MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(48), MeasureSpec.EXACTLY));
     }
 
     public void setTextColor(int color) {
@@ -83,27 +81,7 @@ public void setTextAndIcon(String text, int resId) {
         imageView.setVisibility(VISIBLE);
         valueTextView.setVisibility(INVISIBLE);
         valueImageView.setVisibility(INVISIBLE);
-        if (multiline) {
-            imageView.setPadding(0, 0, 0, 0);
-        } else {
-            imageView.setPadding(0, AndroidUtilities.dp(7), 0, 0);
-        }
-    }
-
-    public void setMultiline(boolean value) {
-        if (multiline == value) {
-            return;
-        }
-        multiline = value;
-        if (value) {
-            textView.setSingleLine(false);
-            textView.setPadding(0, AndroidUtilities.dp(6), 0, AndroidUtilities.dp(6));
-        } else {
-            textView.setLines(1);
-            textView.setMaxLines(1);
-            textView.setSingleLine(true);
-        }
-        requestLayout();
+        imageView.setPadding(0, AndroidUtilities.dp(7), 0, 0);
     }
 
     public void setTextAndValue(String text, String value) {
@@ -120,10 +98,6 @@ public void setTextAndValueDrawable(String text, Drawable drawable) {
         valueImageView.setImageDrawable(drawable);
         valueTextView.setVisibility(INVISIBLE);
         imageView.setVisibility(INVISIBLE);
-        if (multiline) {
-            imageView.setPadding(0, 0, 0, 0);
-        } else {
-            imageView.setPadding(0, AndroidUtilities.dp(7), 0, 0);
-        }
+        imageView.setPadding(0, AndroidUtilities.dp(7), 0, 0);
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCheckCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCheckCell.java
index abc2cf855..159dfeed8 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCheckCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextCheckCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextColorCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextColorCell.java
index e53356c55..87624c6f2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextColorCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextColorCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -30,7 +30,7 @@
     private boolean needDivider;
     private int currentColor;
 
-    private static Drawable colorDrawable;
+    private Drawable colorDrawable;
     private static Paint paint;
 
     public TextColorCell(Context context) {
@@ -40,10 +40,10 @@ public TextColorCell(Context context) {
             paint = new Paint();
             paint.setColor(0xffd9d9d9);
             paint.setStrokeWidth(1);
-
-            colorDrawable = getResources().getDrawable(R.drawable.switch_to_on2);
         }
 
+        colorDrawable = getResources().getDrawable(R.drawable.switch_to_on2);
+
         textView = new TextView(context);
         textView.setTextColor(0xff212121);
         textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
@@ -65,6 +65,7 @@ public void setTextAndColor(String text, int color, boolean divider) {
         currentColor = color;
         colorDrawable.setColorFilter(new PorterDuffColorFilter(color, PorterDuff.Mode.MULTIPLY));
         setWillNotDraw(!needDivider && currentColor == 0);
+        invalidate();
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailCell.java
index eaac8ac81..bfc6e3cbb 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -54,7 +54,7 @@ public TextDetailCell(Context context) {
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, View.MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64), View.MeasureSpec.EXACTLY));
+        super.onMeasure(MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64), View.MeasureSpec.EXACTLY));
     }
 
     public void setTextAndValue(String text, String value) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailSettingsCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailSettingsCell.java
index 83ccaf93d..75dced8d2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailSettingsCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextDetailSettingsCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoCell.java
index f8dec50bd..778f9c60b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoPrivacyCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoPrivacyCell.java
index c48542b97..9fdc79c31 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoPrivacyCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextInfoPrivacyCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextSettingsCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextSettingsCell.java
index 8c14d5337..363a126ae 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextSettingsCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/TextSettingsCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/UserCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/UserCell.java
index 8e374535b..c0c84ca69 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/UserCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/UserCell.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Cells;
@@ -25,6 +25,7 @@
 import org.telegram.ui.Components.AvatarDrawable;
 import org.telegram.ui.Components.BackupImageView;
 import org.telegram.ui.Components.CheckBox;
+import org.telegram.ui.Components.CheckBoxSquare;
 import org.telegram.ui.Components.LayoutHelper;
 import org.telegram.ui.Components.SimpleTextView;
 
@@ -35,6 +36,7 @@
     private SimpleTextView statusTextView;
     private ImageView imageView;
     private CheckBox checkBox;
+    private CheckBoxSquare checkBoxBig;
 
     private AvatarDrawable avatarDrawable;
     private TLObject currentObject = null;
@@ -50,7 +52,7 @@
     private int statusColor = 0xffa8a8a8;
     private int statusOnlineColor = 0xff3b84c0;
 
-    public UserCell(Context context, int padding) {
+    public UserCell(Context context, int padding, int checkbox) {
         super(context);
 
         avatarDrawable = new AvatarDrawable();
@@ -75,9 +77,14 @@ public UserCell(Context context, int padding) {
         imageView.setVisibility(GONE);
         addView(imageView, LayoutHelper.createFrame(LayoutParams.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL, LocaleController.isRTL ? 0 : 16, 0, LocaleController.isRTL ? 16 : 0, 0));
 
-        checkBox = new CheckBox(context, R.drawable.round_check2);
-        checkBox.setVisibility(INVISIBLE);
-        addView(checkBox, LayoutHelper.createFrame(22, 22, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 37 + padding, 38, LocaleController.isRTL ? 37 + padding : 0, 0));
+        if (checkbox == 2) {
+            checkBoxBig = new CheckBoxSquare(context);
+            addView(checkBoxBig, LayoutHelper.createFrame(18, 18, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.CENTER_VERTICAL, LocaleController.isRTL ? 19 : 0, 0, LocaleController.isRTL ? 0 : 19, 0));
+        } else if (checkbox == 1) {
+            checkBox = new CheckBox(context, R.drawable.round_check2);
+            checkBox.setVisibility(INVISIBLE);
+            addView(checkBox, LayoutHelper.createFrame(22, 22, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.TOP, LocaleController.isRTL ? 0 : 37 + padding, 38, LocaleController.isRTL ? 37 + padding : 0, 0));
+        }
     }
 
     public void setData(TLObject user, CharSequence name, CharSequence status, int resId) {
@@ -98,15 +105,28 @@ public void setData(TLObject user, CharSequence name, CharSequence status, int r
     }
 
     public void setChecked(boolean checked, boolean animated) {
-        if (checkBox.getVisibility() != VISIBLE) {
-            checkBox.setVisibility(VISIBLE);
+        if (checkBox != null) {
+            if (checkBox.getVisibility() != VISIBLE) {
+                checkBox.setVisibility(VISIBLE);
+            }
+            checkBox.setChecked(checked, animated);
+        } else if (checkBoxBig != null) {
+            if (checkBoxBig.getVisibility() != VISIBLE) {
+                checkBoxBig.setVisibility(VISIBLE);
+            }
+            checkBoxBig.setChecked(checked, animated);
+        }
+    }
+
+    public void setCheckDisabled(boolean disabled) {
+        if (checkBoxBig != null) {
+            checkBoxBig.setDisabled(disabled);
         }
-        checkBox.setChecked(checked, animated);
     }
 
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64), MeasureSpec.EXACTLY));
+        super.onMeasure(MeasureSpec.makeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(64), MeasureSpec.EXACTLY));
     }
 
     public void setStatusColors(int color, int onlineColor) {
@@ -191,9 +211,9 @@ public void update(int mask) {
             statusTextView.setTextColor(statusColor);
             statusTextView.setText(currrntStatus);
         } else if (currentUser != null) {
-            if ((currentUser.flags & TLRPC.USER_FLAG_BOT) != 0) {
+            if (currentUser.bot) {
                 statusTextView.setTextColor(statusColor);
-                if ((currentUser.flags & TLRPC.USER_FLAG_BOT_READING_HISTORY) != 0) {
+                if (currentUser.bot_chat_history) {
                     statusTextView.setText(LocaleController.getString("BotStatusRead", R.string.BotStatusRead));
                 } else {
                     statusTextView.setText(LocaleController.getString("BotStatusCantRead", R.string.BotStatusCantRead));
@@ -215,4 +235,9 @@ public void update(int mask) {
         }
         avatarImageView.setImage(photo, "50_50", avatarDrawable);
     }
+
+    @Override
+    public boolean hasOverlappingRendering() {
+        return false;
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Cells/WallpaperCell.java b/TMessagesProj/src/main/java/org/telegram/ui/Cells/WallpaperCell.java
index e5eb52b80..273d6f05f 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Cells/WallpaperCell.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Cells/WallpaperCell.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangeChatNameActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangeChatNameActivity.java
index ac1fcbdb2..b41071a8c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangeChatNameActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangeChatNameActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -137,9 +137,18 @@ public void onResume() {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        firstNameField.requestFocus();
-        AndroidUtilities.showKeyboard(firstNameField);
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            AndroidUtilities.runOnUIThread(new Runnable() {
+                @Override
+                public void run() {
+                    if (firstNameField != null) {
+                        firstNameField.requestFocus();
+                        AndroidUtilities.showKeyboard(firstNameField);
+                    }
+                }
+            }, 100);
+        }
     }
 
     private void saveName() {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangeNameActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangeNameActivity.java
index 9c1c9712e..180dc6646 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangeNameActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangeNameActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -185,8 +185,17 @@ public void run(TLObject response, TLRPC.TL_error error) {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        firstNameField.requestFocus();
-        AndroidUtilities.showKeyboard(firstNameField);
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            AndroidUtilities.runOnUIThread(new Runnable() {
+                @Override
+                public void run() {
+                    if (firstNameField != null) {
+                        firstNameField.requestFocus();
+                        AndroidUtilities.showKeyboard(firstNameField);
+                    }
+                }
+            }, 100);
+        }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneActivity.java
index 5e3ba8e2a..3a6e6d64e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneActivity.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -56,6 +56,7 @@
 import org.telegram.messenger.AnimationCompat.AnimatorSetProxy;
 import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
 import org.telegram.messenger.AnimationCompat.ViewProxy;
+import org.telegram.ui.Components.HintEditText;
 import org.telegram.ui.Components.LayoutHelper;
 import org.telegram.ui.Components.SlideView;
 import org.telegram.ui.Components.TypefaceSpan;
@@ -175,9 +176,10 @@ public boolean onBackPressed() {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        super.onOpenAnimationEnd();
-        views[currentViewNum].onShow();
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            views[currentViewNum].onShow();
+        }
     }
 
     public void needShowAlert(final String text) {
@@ -258,7 +260,7 @@ public void onAnimationEnd(Object animation) {
     public class PhoneView extends SlideView implements AdapterView.OnItemSelectedListener {
 
         private EditText codeField;
-        private EditText phoneField;
+        private HintEditText phoneField;
         private TextView countryButton;
 
         private int countryState = 0;
@@ -266,6 +268,7 @@ public void onAnimationEnd(Object animation) {
         private ArrayList<String> countriesArray = new ArrayList<>();
         private HashMap<String, String> countriesMap = new HashMap<>();
         private HashMap<String, String> codesMap = new HashMap<>();
+        private HashMap<String, String> phoneFormatMap = new HashMap<>();
 
         private boolean ignoreSelection = false;
         private boolean ignoreOnTextChange = false;
@@ -286,14 +289,7 @@ public PhoneView(Context context) {
             countryButton.setEllipsize(TextUtils.TruncateAt.END);
             countryButton.setGravity(Gravity.LEFT | Gravity.CENTER_HORIZONTAL);
             countryButton.setBackgroundResource(R.drawable.spinner_states);
-            addView(countryButton);
-            LayoutParams layoutParams = (LayoutParams) countryButton.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.leftMargin = AndroidUtilities.dp(20);
-            layoutParams.rightMargin = AndroidUtilities.dp(20);
-            layoutParams.bottomMargin = AndroidUtilities.dp(14);
-            countryButton.setLayoutParams(layoutParams);
+            addView(countryButton, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 20, 0, 20, 14));
             countryButton.setOnClickListener(new OnClickListener() {
                 @Override
                 public void onClick(View view) {
@@ -302,7 +298,14 @@ public void onClick(View view) {
                         @Override
                         public void didSelectCountry(String name) {
                             selectCountry(name);
+                            AndroidUtilities.runOnUIThread(new Runnable() {
+                                @Override
+                                public void run() {
+                                    AndroidUtilities.showKeyboard(phoneField);
+                                }
+                            }, 300);
                             phoneField.requestFocus();
+                            phoneField.setSelection(phoneField.length());
                         }
                     });
                     presentFragment(fragment);
@@ -312,34 +315,17 @@ public void didSelectCountry(String name) {
             View view = new View(context);
             view.setPadding(AndroidUtilities.dp(12), 0, AndroidUtilities.dp(12), 0);
             view.setBackgroundColor(0xffdbdbdb);
-            addView(view);
-            layoutParams = (LayoutParams) view.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = 1;
-            layoutParams.leftMargin = AndroidUtilities.dp(24);
-            layoutParams.rightMargin = AndroidUtilities.dp(24);
-            layoutParams.topMargin = AndroidUtilities.dp(-17.5f);
-            view.setLayoutParams(layoutParams);
+            addView(view, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 1, 24, -17.5f, 24, 0));
 
             LinearLayout linearLayout = new LinearLayout(context);
             linearLayout.setOrientation(HORIZONTAL);
-            addView(linearLayout);
-            layoutParams = (LayoutParams) linearLayout.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.topMargin = AndroidUtilities.dp(20);
-            linearLayout.setLayoutParams(layoutParams);
+            addView(linearLayout, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, 0, 20, 0, 0));
 
             TextView textView = new TextView(context);
             textView.setText("+");
             textView.setTextColor(0xff212121);
             textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
-            linearLayout.addView(textView);
-            layoutParams = (LayoutParams) textView.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.leftMargin = AndroidUtilities.dp(24);
-            textView.setLayoutParams(layoutParams);
+            linearLayout.addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, 24, 0, 0, 0));
 
             codeField = new EditText(context);
             codeField.setInputType(InputType.TYPE_CLASS_PHONE);
@@ -351,15 +337,9 @@ public void didSelectCountry(String name) {
             codeField.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);
             codeField.setImeOptions(EditorInfo.IME_ACTION_NEXT | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
             InputFilter[] inputFilters = new InputFilter[1];
-            inputFilters[0] = new InputFilter.LengthFilter(4);
+            inputFilters[0] = new InputFilter.LengthFilter(5);
             codeField.setFilters(inputFilters);
-            linearLayout.addView(codeField);
-            layoutParams = (LayoutParams) codeField.getLayoutParams();
-            layoutParams.width = AndroidUtilities.dp(55);
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.rightMargin = AndroidUtilities.dp(16);
-            layoutParams.leftMargin = AndroidUtilities.dp(-9);
-            codeField.setLayoutParams(layoutParams);
+            linearLayout.addView(codeField, LayoutHelper.createLinear(55, 36, -9, 0, 16, 0));
             codeField.addTextChangedListener(new TextWatcher() {
                 @Override
                 public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
@@ -382,26 +362,57 @@ public void afterTextChanged(Editable editable) {
                     codeField.setText(text);
                     if (text.length() == 0) {
                         countryButton.setText(LocaleController.getString("ChooseCountry", R.string.ChooseCountry));
+                        phoneField.setHintText(null);
                         countryState = 1;
                     } else {
-                        String country = codesMap.get(text);
+                        String country;
+                        boolean ok = false;
+                        String textToSet = null;
+                        if (text.length() > 4) {
+                            ignoreOnTextChange = true;
+                            for (int a = 4; a >= 1; a--) {
+                                String sub = text.substring(0, a);
+                                country = codesMap.get(sub);
+                                if (country != null) {
+                                    ok = true;
+                                    textToSet = text.substring(a, text.length()) + phoneField.getText().toString();
+                                    codeField.setText(text = sub);
+                                    break;
+                                }
+                            }
+                            if (!ok) {
+                                ignoreOnTextChange = true;
+                                textToSet = text.substring(1, text.length()) + phoneField.getText().toString();
+                                codeField.setText(text = text.substring(0, 1));
+                            }
+                        }
+                        country = codesMap.get(text);
                         if (country != null) {
                             int index = countriesArray.indexOf(country);
                             if (index != -1) {
                                 ignoreSelection = true;
                                 countryButton.setText(countriesArray.get(index));
-
-                                updatePhoneField();
+                                String hint = phoneFormatMap.get(text);
+                                phoneField.setHintText(hint != null ? hint.replace('X', '–') : null);
                                 countryState = 0;
                             } else {
                                 countryButton.setText(LocaleController.getString("WrongCountry", R.string.WrongCountry));
+                                phoneField.setHintText(null);
                                 countryState = 2;
                             }
                         } else {
                             countryButton.setText(LocaleController.getString("WrongCountry", R.string.WrongCountry));
+                            phoneField.setHintText(null);
                             countryState = 2;
                         }
-                        codeField.setSelection(codeField.getText().length());
+                        if (!ok) {
+                            codeField.setSelection(codeField.getText().length());
+                        }
+                        if (textToSet != null) {
+                            phoneField.requestFocus();
+                            phoneField.setText(textToSet);
+                            phoneField.setSelection(phoneField.length());
+                        }
                     }
                 }
             });
@@ -410,13 +421,14 @@ public void afterTextChanged(Editable editable) {
                 public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
                     if (i == EditorInfo.IME_ACTION_NEXT) {
                         phoneField.requestFocus();
+                        phoneField.setSelection(phoneField.length());
                         return true;
                     }
                     return false;
                 }
             });
 
-            phoneField = new EditText(context);
+            phoneField = new HintEditText(context);
             phoneField.setInputType(InputType.TYPE_CLASS_PHONE);
             phoneField.setTextColor(0xff212121);
             phoneField.setHintTextColor(0xff979797);
@@ -426,43 +438,25 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             phoneField.setMaxLines(1);
             phoneField.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);
             phoneField.setImeOptions(EditorInfo.IME_ACTION_NEXT | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
-            linearLayout.addView(phoneField);
-            layoutParams = (LayoutParams) phoneField.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.rightMargin = AndroidUtilities.dp(24);
-            phoneField.setLayoutParams(layoutParams);
+            linearLayout.addView(phoneField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 0, 0, 24, 0));
             phoneField.addTextChangedListener(new TextWatcher() {
+
+                private int characterAction = -1;
+                private int actionPosition;
+
                 @Override
                 public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-                    if (ignoreOnPhoneChange) {
-                        return;
-                    }
-                    if (count == 1 && after == 0 && s.length() > 1) {
-                        String phoneChars = "0123456789";
-                        String str = s.toString();
-                        String substr = str.substring(start, start + 1);
-                        if (!phoneChars.contains(substr)) {
-                            ignoreOnPhoneChange = true;
-                            StringBuilder builder = new StringBuilder(str);
-                            int toDelete = 0;
-                            for (int a = start; a >= 0; a--) {
-                                substr = str.substring(a, a + 1);
-                                if(phoneChars.contains(substr)) {
-                                    break;
-                                }
-                                toDelete++;
-                            }
-                            builder.delete(Math.max(0, start - toDelete), start + 1);
-                            str = builder.toString();
-                            if (PhoneFormat.strip(str).length() == 0) {
-                                phoneField.setText("");
-                            } else {
-                                phoneField.setText(str);
-                                updatePhoneField();
-                            }
-                            ignoreOnPhoneChange = false;
+                    if (count == 0 && after == 1) {
+                        characterAction = 1;
+                    } else if (count == 1 && after == 0) {
+                        if (s.charAt(start) == ' ' && start > 0) {
+                            characterAction = 3;
+                            actionPosition = start - 1;
+                        } else {
+                            characterAction = 2;
                         }
+                    } else {
+                        characterAction = -1;
                     }
                 }
 
@@ -476,7 +470,47 @@ public void afterTextChanged(Editable s) {
                     if (ignoreOnPhoneChange) {
                         return;
                     }
-                    updatePhoneField();
+                    int start = phoneField.getSelectionStart();
+                    String phoneChars = "0123456789";
+                    String str = phoneField.getText().toString();
+                    if (characterAction == 3) {
+                        str = str.substring(0, actionPosition) + str.substring(actionPosition + 1, str.length());
+                        start--;
+                    }
+                    StringBuilder builder = new StringBuilder(str.length());
+                    for (int a = 0; a < str.length(); a++) {
+                        String ch = str.substring(a, a + 1);
+                        if (phoneChars.contains(ch)) {
+                            builder.append(ch);
+                        }
+                    }
+                    ignoreOnPhoneChange = true;
+                    String hint = phoneField.getHintText();
+                    if (hint != null) {
+                        for (int a = 0; a < builder.length(); a++) {
+                            if (a < hint.length()) {
+                                if (hint.charAt(a) == ' ') {
+                                    builder.insert(a, ' ');
+                                    a++;
+                                    if (start == a && characterAction != 2 && characterAction != 3) {
+                                        start++;
+                                    }
+                                }
+                            } else {
+                                builder.insert(a, ' ');
+                                if (start == a + 1 && characterAction != 2 && characterAction != 3) {
+                                    start++;
+                                }
+                                break;
+                            }
+                        }
+                    }
+                    phoneField.setText(builder);
+                    if (start >= 0) {
+                        phoneField.setSelection(start <= phoneField.length() ? start : phoneField.length());
+                    }
+                    phoneField.onTextChange();
+                    ignoreOnPhoneChange = false;
                 }
             });
             phoneField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
@@ -496,16 +530,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             textView.setGravity(Gravity.LEFT);
             textView.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
-            addView(textView);
-            layoutParams = (LayoutParams) textView.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.leftMargin = AndroidUtilities.dp(24);
-            layoutParams.rightMargin = AndroidUtilities.dp(24);
-            layoutParams.topMargin = AndroidUtilities.dp(28);
-            layoutParams.bottomMargin = AndroidUtilities.dp(10);
-            layoutParams.gravity = Gravity.LEFT;
-            textView.setLayoutParams(layoutParams);
+            addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT, 24, 28, 24, 10));
 
             HashMap<String, String> languageMap = new HashMap<>();
             try {
@@ -516,6 +541,9 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
                     countriesArray.add(0, args[2]);
                     countriesMap.put(args[2], args[0]);
                     codesMap.put(args[0], args[2]);
+                    if (args.length > 3) {
+                        phoneFormatMap.put(args[0], args[3]);
+                    }
                     languageMap.put(args[1], args[2]);
                 }
                 reader.close();
@@ -553,12 +581,14 @@ public int compare(String lhs, String rhs) {
             }
             if (codeField.length() == 0) {
                 countryButton.setText(LocaleController.getString("ChooseCountry", R.string.ChooseCountry));
+                phoneField.setHintText(null);
                 countryState = 1;
             }
 
             if (codeField.length() != 0) {
                 AndroidUtilities.showKeyboard(phoneField);
                 phoneField.requestFocus();
+                phoneField.setSelection(phoneField.length());
             } else {
                 AndroidUtilities.showKeyboard(codeField);
                 codeField.requestFocus();
@@ -569,39 +599,15 @@ public void selectCountry(String name) {
             int index = countriesArray.indexOf(name);
             if (index != -1) {
                 ignoreOnTextChange = true;
-                codeField.setText(countriesMap.get(name));
+                String code = countriesMap.get(name);
+                codeField.setText(code);
                 countryButton.setText(name);
+                String hint = phoneFormatMap.get(code);
+                phoneField.setHintText(hint != null ? hint.replace('X', '–') : null);
                 countryState = 0;
             }
         }
 
-        private void updatePhoneField() {
-            ignoreOnPhoneChange = true;
-            try {
-                String codeText = codeField.getText().toString();
-                String phone = PhoneFormat.getInstance().format("+" + codeText + phoneField.getText().toString());
-                int idx = phone.indexOf(" ");
-                if (idx != -1) {
-                    String resultCode = PhoneFormat.stripExceptNumbers(phone.substring(0, idx));
-                    if (!codeText.equals(resultCode)) {
-                        phone = PhoneFormat.getInstance().format(phoneField.getText().toString()).trim();
-                        phoneField.setText(phone);
-                        int len = phoneField.length();
-                        phoneField.setSelection(phoneField.length());
-                    } else {
-                        phoneField.setText(phone.substring(idx).trim());
-                        int len = phoneField.length();
-                        phoneField.setSelection(phoneField.length());
-                    }
-                } else {
-                    phoneField.setSelection(phoneField.length());
-                }
-            } catch (Exception e) {
-                FileLog.e("tmessages", e);
-            }
-            ignoreOnPhoneChange = false;
-        }
-
         @Override
         public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
             if (ignoreSelection) {
@@ -611,7 +617,6 @@ public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l)
             ignoreOnTextChange = true;
             String str = countriesArray.get(i);
             codeField.setText(countriesMap.get(str));
-            updatePhoneField();
         }
 
         @Override
@@ -685,8 +690,14 @@ public void run() {
         public void onShow() {
             super.onShow();
             if (phoneField != null) {
-                AndroidUtilities.showKeyboard(phoneField);
-                phoneField.setSelection(phoneField.length());
+                if (codeField.length() != 0) {
+                    AndroidUtilities.showKeyboard(phoneField);
+                    phoneField.requestFocus();
+                    phoneField.setSelection(phoneField.length());
+                } else {
+                    AndroidUtilities.showKeyboard(codeField);
+                    codeField.requestFocus();
+                }
             }
         }
 
@@ -712,6 +723,7 @@ public String getHeaderName() {
         private volatile int codeTime = 15000;
         private double lastCurrentTime;
         private double lastCodeTime;
+        private boolean ignoreOnTextChange;
         private boolean waitingForSms = false;
         private boolean nextPressed = false;
         private String lastError = "";
@@ -754,6 +766,27 @@ public LoginActivitySmsView(Context context) {
             layoutParams.leftMargin = AndroidUtilities.dp(24);
             layoutParams.rightMargin = AndroidUtilities.dp(24);
             codeField.setLayoutParams(layoutParams);
+            codeField.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    if (ignoreOnTextChange) {
+                        return;
+                    }
+                    if (codeField.length() == 5) {
+                        onNextPressed();
+                    }
+                }
+            });
             codeField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
                 @Override
                 public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
@@ -1050,6 +1083,7 @@ public void didReceivedNotification(int id, final Object... args) {
                     return;
                 }
                 if (codeField != null) {
+                    ignoreOnTextChange = true;
                     codeField.setText("" + args[0]);
                     onNextPressed();
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneHelpActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneHelpActivity.java
index 3107c6ae2..ccc9104a1 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneHelpActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangePhoneHelpActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChangeUsernameActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChangeUsernameActivity.java
index 905a31b8d..874e197e0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChangeUsernameActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChangeUsernameActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -385,8 +385,10 @@ public void onClick(DialogInterface dialog, int which) {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        firstNameField.requestFocus();
-        AndroidUtilities.showKeyboard(firstNameField);
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            firstNameField.requestFocus();
+            AndroidUtilities.showKeyboard(firstNameField);
+        }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChannelCreateActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChannelCreateActivity.java
index 7ee04976e..891e63fe5 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChannelCreateActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChannelCreateActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -155,7 +155,6 @@ public void run() {
                     });
                 }
             });
-
         } else {
             if (currentStep == 1) {
                 canCreatePublic = args.getBoolean("canCreatePublic", true);
@@ -308,7 +307,7 @@ public void onClick(DialogInterface dialog, int which) {
                                 result.add(user);
                             }
                         }
-                        MessagesController.getInstance().addUsersToChannel(chatId, result);
+                        MessagesController.getInstance().addUsersToChannel(chatId, result, null);
                         NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
                         Bundle args2 = new Bundle();
                         args2.putInt("chat_id", chatId);
@@ -656,7 +655,7 @@ public void onClick(View v) {
             actionBar.setTitle(LocaleController.getString("ChannelAddMembers", R.string.ChannelAddMembers));
             actionBar.setSubtitle(LocaleController.formatPluralString("Members", selectedContacts.size()));
 
-            searchListViewAdapter = new SearchAdapter(context, null, false, false, false);
+            searchListViewAdapter = new SearchAdapter(context, null, false, false, false, false);
             searchListViewAdapter.setCheckedMap(selectedContacts);
             searchListViewAdapter.setUseUserCell(true);
             listViewAdapter = new ContactsAdapter(context, 1, false, null, false);
@@ -841,9 +840,11 @@ public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                         ChipSpan span = createAndPutChipForUser(user);
                         if (span != null) {
                             span.uid = user.id;
-                            return;
                         }
                         ignoreChange = false;
+                        if (span == null) {
+                            return;
+                        }
                     }
                     actionBar.setSubtitle(LocaleController.formatPluralString("Members", selectedContacts.size()));
                     if (searching || searchWas) {
@@ -997,8 +998,8 @@ public void restoreSelfArgs(Bundle args) {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        if (currentStep != 1) {
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen && currentStep != 1) {
             nameTextView.requestFocus();
             AndroidUtilities.showKeyboard(nameTextView);
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChannelEditActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChannelEditActivity.java
index ccbafce95..d7b2d9497 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChannelEditActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChannelEditActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -118,7 +118,7 @@ public void run() {
                 return false;
             }
             if (info == null) {
-                MessagesStorage.getInstance().loadChatInfo(chatId, semaphore, false);
+                MessagesStorage.getInstance().loadChatInfo(chatId, semaphore, false, false);
                 try {
                     semaphore.acquire();
                 } catch (Exception e) {
@@ -132,7 +132,7 @@ public void run() {
         wasPrivate = currentChat.username == null || currentChat.username.length() == 0;
         avatarUpdater.parentFragment = this;
         avatarUpdater.delegate = this;
-        allowComments = (currentChat.flags & TLRPC.CHAT_FLAG_IS_BROADCAST) == 0;
+        allowComments = !currentChat.broadcast;
         return super.onFragmentCreate();
     }
 
@@ -178,14 +178,16 @@ public void onItemClick(int id) {
                         AndroidUtilities.shakeView(nameTextView, 2, 0);
                         return;
                     }
-                    if ((currentChat.username == null && userNameTextView.length() != 0) || (currentChat.username != null && !currentChat.username.equalsIgnoreCase(userNameTextView.getText().toString()))) {
-                        if (userNameTextView.length() != 0 && !lastNameAvailable) {
-                            Vibrator v = (Vibrator) getParentActivity().getSystemService(Context.VIBRATOR_SERVICE);
-                            if (v != null) {
-                                v.vibrate(200);
+                    if (userNameTextView != null) {
+                        if ((currentChat.username == null && userNameTextView.length() != 0) || (currentChat.username != null && !currentChat.username.equalsIgnoreCase(userNameTextView.getText().toString()))) {
+                            if (userNameTextView.length() != 0 && !lastNameAvailable) {
+                                Vibrator v = (Vibrator) getParentActivity().getSystemService(Context.VIBRATOR_SERVICE);
+                                if (v != null) {
+                                    v.vibrate(200);
+                                }
+                                AndroidUtilities.shakeView(checkTextView, 2, 0);
+                                return;
                             }
-                            AndroidUtilities.shakeView(checkTextView, 2, 0);
-                            return;
                         }
                     }
 
@@ -211,7 +213,7 @@ public void onClick(DialogInterface dialog, int which) {
                         progressDialog.show();
                         return;
                     }
-                    boolean currentAllowComments = (currentChat.flags & TLRPC.CHAT_FLAG_IS_BROADCAST) == 0;
+                    boolean currentAllowComments = !currentChat.broadcast;
                     if (allowComments != currentAllowComments) {
                         MessagesController.getInstance().toogleChannelComments(chatId, allowComments);
                     }
@@ -221,9 +223,11 @@ public void onClick(DialogInterface dialog, int which) {
                     if (info != null && !info.about.equals(descriptionTextView.getText().toString())) {
                         MessagesController.getInstance().updateChannelAbout(chatId, descriptionTextView.getText().toString(), info);
                     }
-                    String oldUserName = currentChat.username != null ? currentChat.username : "";
-                    if (!oldUserName.equals(userNameTextView.getText().toString())) {
-                        MessagesController.getInstance().updateChannelUserName(chatId, userNameTextView.getText().toString());
+                    if (userNameTextView != null) {
+                        String oldUserName = currentChat.username != null ? currentChat.username : "";
+                        if (!oldUserName.equals(userNameTextView.getText().toString())) {
+                            MessagesController.getInstance().updateChannelUserName(chatId, userNameTextView.getText().toString());
+                        }
                     }
                     if (uploadedAvatar != null) {
                         MessagesController.getInstance().changeChatAvatar(chatId, uploadedAvatar);
@@ -299,7 +303,11 @@ public void onClick(DialogInterface dialogInterface, int i) {
         });
 
         nameTextView = new EditText(context);
-        nameTextView.setHint(LocaleController.getString("EnterChannelName", R.string.EnterChannelName));
+        if (currentChat.megagroup) {
+            nameTextView.setHint(LocaleController.getString("GroupName", R.string.GroupName));
+        } else {
+            nameTextView.setHint(LocaleController.getString("EnterChannelName", R.string.EnterChannelName));
+        }
         nameTextView.setMaxLines(4);
         nameTextView.setGravity(Gravity.CENTER_VERTICAL | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
         nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
@@ -382,90 +390,95 @@ public void afterTextChanged(Editable editable) {
         });
 
         TextInfoPrivacyCell infoCell = new TextInfoPrivacyCell(context);
-        infoCell.setText(LocaleController.getString("DescriptionInfo", R.string.DescriptionInfo));
+        if (currentChat.megagroup) {
+            infoCell.setText(LocaleController.getString("DescriptionInfoMega", R.string.DescriptionInfoMega));
+        } else {
+            infoCell.setText(LocaleController.getString("DescriptionInfo", R.string.DescriptionInfo));
+        }
         infoCell.setBackgroundResource(R.drawable.greydivider);
         linearLayout.addView(infoCell, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
 
-
-        linearLayout2 = new LinearLayout(context);
-        linearLayout2.setOrientation(LinearLayout.VERTICAL);
-        linearLayout2.setBackgroundColor(0xffffffff);
-        linearLayout2.setPadding(0, 0, 0, AndroidUtilities.dp(7));
-        linearLayout.addView(linearLayout2, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
-
-        LinearLayout publicContainer = new LinearLayout(context);
-        publicContainer.setOrientation(LinearLayout.HORIZONTAL);
-        linearLayout2.addView(publicContainer, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 17, 7, 17, 0));
-
-        EditText editText = new EditText(context);
-        editText.setText("telegram.me/");
-        editText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
-        editText.setHintTextColor(0xff979797);
-        editText.setTextColor(0xff212121);
-        editText.setMaxLines(1);
-        editText.setLines(1);
-        editText.setEnabled(false);
-        editText.setBackgroundDrawable(null);
-        editText.setPadding(0, 0, 0, 0);
-        editText.setSingleLine(true);
-        editText.setInputType(InputType.TYPE_TEXT_FLAG_MULTI_LINE | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT);
-        editText.setImeOptions(EditorInfo.IME_ACTION_DONE);
-        publicContainer.addView(editText, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, 36));
-
-        userNameTextView = new EditText(context);
-        userNameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
-        userNameTextView.setHintTextColor(0xff979797);
-        userNameTextView.setTextColor(0xff212121);
-        userNameTextView.setMaxLines(1);
-        userNameTextView.setLines(1);
-        userNameTextView.setBackgroundDrawable(null);
-        userNameTextView.setPadding(0, 0, 0, 0);
-        userNameTextView.setSingleLine(true);
-        userNameTextView.setText(currentChat.username);
-        userNameTextView.setInputType(InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS | InputType.TYPE_TEXT_FLAG_MULTI_LINE | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT);
-        userNameTextView.setImeOptions(EditorInfo.IME_ACTION_DONE);
-        userNameTextView.setHint(LocaleController.getString("ChannelUsernamePlaceholder", R.string.ChannelUsernamePlaceholder));
-        userNameTextView.setOnFocusChangeListener(new View.OnFocusChangeListener() {
-            @Override
-            public void onFocusChange(View v, boolean hasFocus) {
-                if (wasPrivate && hasFocus && !privateAlertShown) {
-                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
-                    builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-                    builder.setMessage(LocaleController.getString("ChannelWasPrivateAlert", R.string.ChannelWasPrivateAlert));
-                    builder.setPositiveButton(LocaleController.getString("Close", R.string.Close), null);
-                    showDialog(builder.create());
+        if (!currentChat.megagroup) {
+            linearLayout2 = new LinearLayout(context);
+            linearLayout2.setOrientation(LinearLayout.VERTICAL);
+            linearLayout2.setBackgroundColor(0xffffffff);
+            linearLayout2.setPadding(0, 0, 0, AndroidUtilities.dp(7));
+            linearLayout.addView(linearLayout2, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
+
+            LinearLayout publicContainer = new LinearLayout(context);
+            publicContainer.setOrientation(LinearLayout.HORIZONTAL);
+            linearLayout2.addView(publicContainer, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 17, 7, 17, 0));
+
+            EditText editText = new EditText(context);
+            editText.setText("telegram.me/");
+            editText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
+            editText.setHintTextColor(0xff979797);
+            editText.setTextColor(0xff212121);
+            editText.setMaxLines(1);
+            editText.setLines(1);
+            editText.setEnabled(false);
+            editText.setBackgroundDrawable(null);
+            editText.setPadding(0, 0, 0, 0);
+            editText.setSingleLine(true);
+            editText.setInputType(InputType.TYPE_TEXT_FLAG_MULTI_LINE | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT);
+            editText.setImeOptions(EditorInfo.IME_ACTION_DONE);
+            publicContainer.addView(editText, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, 36));
+
+            userNameTextView = new EditText(context);
+            userNameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
+            userNameTextView.setHintTextColor(0xff979797);
+            userNameTextView.setTextColor(0xff212121);
+            userNameTextView.setMaxLines(1);
+            userNameTextView.setLines(1);
+            userNameTextView.setBackgroundDrawable(null);
+            userNameTextView.setPadding(0, 0, 0, 0);
+            userNameTextView.setSingleLine(true);
+            userNameTextView.setText(currentChat.username);
+            userNameTextView.setInputType(InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS | InputType.TYPE_TEXT_FLAG_MULTI_LINE | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT);
+            userNameTextView.setImeOptions(EditorInfo.IME_ACTION_DONE);
+            userNameTextView.setHint(LocaleController.getString("ChannelUsernamePlaceholder", R.string.ChannelUsernamePlaceholder));
+            userNameTextView.setOnFocusChangeListener(new View.OnFocusChangeListener() {
+                @Override
+                public void onFocusChange(View v, boolean hasFocus) {
+                    if (wasPrivate && hasFocus && !privateAlertShown) {
+                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                        builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                        builder.setMessage(LocaleController.getString("ChannelWasPrivateAlert", R.string.ChannelWasPrivateAlert));
+                        builder.setPositiveButton(LocaleController.getString("Close", R.string.Close), null);
+                        showDialog(builder.create());
+                    }
                 }
-            }
-        });
-        AndroidUtilities.clearCursorDrawable(userNameTextView);
-        publicContainer.addView(userNameTextView, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36));
-        userNameTextView.addTextChangedListener(new TextWatcher() {
-            @Override
-            public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
+            });
+            AndroidUtilities.clearCursorDrawable(userNameTextView);
+            publicContainer.addView(userNameTextView, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36));
+            userNameTextView.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
 
-            }
+                }
 
-            @Override
-            public void onTextChanged(CharSequence charSequence, int i, int i2, int i3) {
-                checkUserName(userNameTextView.getText().toString(), false);
-            }
+                @Override
+                public void onTextChanged(CharSequence charSequence, int i, int i2, int i3) {
+                    checkUserName(userNameTextView.getText().toString(), false);
+                }
 
-            @Override
-            public void afterTextChanged(Editable editable) {
+                @Override
+                public void afterTextChanged(Editable editable) {
 
-            }
-        });
+                }
+            });
 
-        checkTextView = new TextView(context);
-        checkTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15);
-        checkTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-        checkTextView.setVisibility(View.GONE);
-        linearLayout2.addView(checkTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, 17, 3, 17, 7));
+            checkTextView = new TextView(context);
+            checkTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15);
+            checkTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
+            checkTextView.setVisibility(View.GONE);
+            linearLayout2.addView(checkTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, 17, 3, 17, 7));
 
-        infoCell = new TextInfoPrivacyCell(context);
-        infoCell.setBackgroundResource(R.drawable.greydivider);
-        infoCell.setText(LocaleController.getString("ChannelUsernameHelp", R.string.ChannelUsernameHelp));
-        linearLayout.addView(infoCell, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
+            infoCell = new TextInfoPrivacyCell(context);
+            infoCell.setBackgroundResource(R.drawable.greydivider);
+            infoCell.setText(LocaleController.getString("ChannelUsernameHelp", R.string.ChannelUsernameHelp));
+            linearLayout.addView(infoCell, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
+        }
 
 
         /*frameLayout = new FrameLayoutFixed(context);
@@ -496,13 +509,21 @@ public void onClick(View v) {
         TextSettingsCell textCell = new TextSettingsCell(context);
         textCell.setTextColor(0xffed3d39);
         textCell.setBackgroundResource(R.drawable.list_selector);
-        textCell.setText(LocaleController.getString("ChannelDelete", R.string.ChannelDelete), false);
+        if (currentChat.megagroup) {
+            textCell.setText(LocaleController.getString("DeleteMega", R.string.DeleteMega), false);
+        } else {
+            textCell.setText(LocaleController.getString("ChannelDelete", R.string.ChannelDelete), false);
+        }
         frameLayout.addView(textCell, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
         textCell.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
                 AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
-                builder.setMessage(LocaleController.getString("ChannelDeleteAlert", R.string.ChannelDeleteAlert));
+                if (currentChat.megagroup) {
+                    builder.setMessage(LocaleController.getString("MegaDeleteAlert", R.string.MegaDeleteAlert));
+                } else {
+                    builder.setMessage(LocaleController.getString("ChannelDeleteAlert", R.string.ChannelDeleteAlert));
+                }
                 builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
                 builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                     @Override
@@ -524,7 +545,11 @@ public void onClick(DialogInterface dialogInterface, int i) {
 
         infoCell = new TextInfoPrivacyCell(context);
         infoCell.setBackgroundResource(R.drawable.greydivider_bottom);
-        infoCell.setText(LocaleController.getString("ChannelDeleteInfo", R.string.ChannelDeleteInfo));
+        if (currentChat.megagroup) {
+            infoCell.setText(LocaleController.getString("MegaDeleteInfo", R.string.MegaDeleteInfo));
+        } else {
+            infoCell.setText(LocaleController.getString("ChannelDeleteInfo", R.string.ChannelDeleteInfo));
+        }
         linearLayout.addView(infoCell, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT));
 
         nameTextView.setText(currentChat.title);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChannelIntroActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChannelIntroActivity.java
index f9cdacdda..51ff8c81e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChannelIntroActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChannelIntroActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChannelUsersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChannelUsersActivity.java
index 21f160389..f75aeace6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChannelUsersActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChannelUsersActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -57,8 +57,10 @@
     private int chatId;
     private int type;
     private boolean loadingUsers;
+    private boolean firstLoaded;
     private boolean isAdmin;
     private boolean isPublic;
+    private boolean isMegagroup;
     private int participantsStartRow;
 
     public ChannelUsersActivity(Bundle args) {
@@ -66,9 +68,12 @@ public ChannelUsersActivity(Bundle args) {
         chatId = arguments.getInt("chat_id");
         type = arguments.getInt("type");
         TLRPC.Chat chat = MessagesController.getInstance().getChat(chatId);
-        if (chat != null && (chat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0) {
-            isAdmin = true;
-            isPublic = (chat.flags & TLRPC.CHAT_FLAG_IS_PUBLIC) != 0;
+        if (chat != null) {
+            if (chat.creator) {
+                isAdmin = true;
+                isPublic = (chat.flags & TLRPC.CHAT_FLAG_IS_PUBLIC) != 0;
+            }
+            isMegagroup = chat.megagroup;
         }
         if (type == 0) {
             participantsStartRow = 0;
@@ -121,7 +126,11 @@ public void onItemClick(int id) {
 
         emptyView = new EmptyTextProgressView(context);
         if (type == 0) {
-            emptyView.setText(LocaleController.getString("NoBlocked", R.string.NoBlocked));
+            if (isMegagroup) {
+                emptyView.setText(LocaleController.getString("NoBlockedGroup", R.string.NoBlockedGroup));
+            } else {
+                emptyView.setText(LocaleController.getString("NoBlocked", R.string.NoBlocked));
+            }
         }
         frameLayout.addView(emptyView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
@@ -139,7 +148,6 @@ public void onItemClick(int id) {
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
             public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
-
                 if (type == 2) {
                     if (isAdmin) {
                         if (i == 0) {
@@ -171,7 +179,10 @@ public void didSelectContact(TLRPC.User user, String param) {
                             args.putBoolean("destroyAfterSelect", true);
                             args.putBoolean("returnAsResult", true);
                             args.putBoolean("needForwardCount", false);
-                            args.putBoolean("allowUsernameSearch", false);
+                            args.putBoolean("allowUsernameSearch", true);
+                            if (isMegagroup) {
+                                args.putBoolean("allowBots", false);
+                            }
                             args.putString("selectAlertString", LocaleController.getString("ChannelAddUserAdminAlert", R.string.ChannelAddUserAdminAlert));
                             ContactsActivity fragment = new ContactsActivity(args);
                             fragment.setDelegate(new ContactsActivity.ContactsActivityDelegate() {
@@ -196,7 +207,7 @@ public void didSelectContact(TLRPC.User user, String param) {
             }
         });
 
-        if (isAdmin) {
+        if (isAdmin || isMegagroup && type == 0) {
             listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
                 @Override
                 public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, long l) {
@@ -281,18 +292,19 @@ public void setUserChannelRole(TLRPC.User user, TLRPC.ChannelParticipantRole rol
         ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
             @Override
             public void run(TLObject response, final TLRPC.TL_error error) {
-                if (response instanceof TLRPC.TL_boolTrue) {
+                if (error == null) {
+                    MessagesController.getInstance().processUpdates((TLRPC.Updates) response, false);
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
                             MessagesController.getInstance().loadFullChat(chatId, 0, true);
                         }
                     }, 1000);
-                } else if (error != null) {
+                } else {
                     AndroidUtilities.runOnUIThread(new Runnable() {
                         @Override
                         public void run() {
-                            AlertsCreator.showAddUserAlert(error.text, ChannelUsersActivity.this);
+                            AlertsCreator.showAddUserAlert(error.text, ChannelUsersActivity.this, !isMegagroup);
                         }
                     });
                 }
@@ -330,7 +342,7 @@ private void getChannelParticipants(int offset, int count) {
             return;
         }
         loadingUsers = true;
-        if (emptyView != null) {
+        if (emptyView != null && !firstLoaded) {
             emptyView.showProgress();
         }
         if (listViewAdapter != null) {
@@ -422,6 +434,7 @@ public int compare(TLRPC.ChannelParticipant lhs, TLRPC.ChannelParticipant rhs) {
                             }
                         }
                         loadingUsers = false;
+                        firstLoaded = true;
                         if (emptyView != null) {
                             emptyView.showTextView();
                         }
@@ -487,7 +500,7 @@ public boolean isEnabled(int i) {
 
         @Override
         public int getCount() {
-            if (participants.isEmpty() && type == 0 || loadingUsers) {
+            if (participants.isEmpty() && type == 0 || loadingUsers && !firstLoaded) {
                 return 0;
             }
             return participants.size() + participantsStartRow + 1;
@@ -513,7 +526,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
             int viewType = getItemViewType(i);
             if (viewType == 0) {
                 if (view == null) {
-                    view = new UserCell(mContext, 1);
+                    view = new UserCell(mContext, 1, 0);
                     view.setBackgroundColor(0xffffffff);
                 }
                 UserCell userCell = (UserCell) view;
@@ -541,19 +554,27 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                     view = new TextInfoPrivacyCell(mContext);
                 }
                 if (type == 0) {
-                    ((TextInfoPrivacyCell) view).setText(LocaleController.getString("UnblockText", R.string.UnblockText));
+                    ((TextInfoPrivacyCell) view).setText(String.format("%1$s\n\n%2$s", LocaleController.getString("NoBlockedGroup", R.string.NoBlockedGroup), LocaleController.getString("UnblockText", R.string.UnblockText)));
                     view.setBackgroundResource(R.drawable.greydivider_bottom);
                 } else if (type == 1) {
                     if (i == 1 && isAdmin) {
-                        ((TextInfoPrivacyCell) view).setText(LocaleController.getString("ChannelAdminsInfo", R.string.ChannelAdminsInfo));
+                        if (isMegagroup) {
+                            ((TextInfoPrivacyCell) view).setText(LocaleController.getString("MegaAdminsInfo", R.string.MegaAdminsInfo));
+                        } else {
+                            ((TextInfoPrivacyCell) view).setText(LocaleController.getString("ChannelAdminsInfo", R.string.ChannelAdminsInfo));
+                        }
                         view.setBackgroundResource(R.drawable.greydivider);
                     } else {
                         ((TextInfoPrivacyCell) view).setText("");
                         view.setBackgroundResource(R.drawable.greydivider_bottom);
                     }
                 } else if (type == 2) {
-                    if ((!isPublic && i == 2 || i == 1) &&isAdmin) {
-                        ((TextInfoPrivacyCell) view).setText(LocaleController.getString("ChannelMembersInfo", R.string.ChannelMembersInfo));
+                    if ((!isPublic && i == 2 || i == 1) && isAdmin) {
+                        if (isMegagroup) {
+                            ((TextInfoPrivacyCell) view).setText("");
+                        } else {
+                            ((TextInfoPrivacyCell) view).setText(LocaleController.getString("ChannelMembersInfo", R.string.ChannelMembersInfo));
+                        }
                         view.setBackgroundResource(R.drawable.greydivider);
                     } else {
                         ((TextInfoPrivacyCell) view).setText("");
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
index 6f5dce4e9..2bb16fd35 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ChatActivity.java
@@ -1,13 +1,14 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
 
+import android.Manifest;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.Dialog;
@@ -60,6 +61,7 @@
 import org.telegram.messenger.SecretChatHelper;
 import org.telegram.messenger.SendMessagesHelper;
 import org.telegram.messenger.UserObject;
+import org.telegram.messenger.Utilities;
 import org.telegram.messenger.VideoEditedInfo;
 import org.telegram.messenger.query.BotQuery;
 import org.telegram.messenger.query.MessagesSearchQuery;
@@ -81,6 +83,8 @@
 import org.telegram.messenger.NotificationCenter;
 import org.telegram.messenger.R;
 import org.telegram.messenger.UserConfig;
+import org.telegram.ui.ActionBar.ActionBarLayout;
+import org.telegram.ui.ActionBar.BackDrawable;
 import org.telegram.ui.ActionBar.BottomSheet;
 import org.telegram.ui.Adapters.MentionsAdapter;
 import org.telegram.ui.Adapters.StickersAdapter;
@@ -108,16 +112,20 @@
 import org.telegram.ui.Components.ChatActivityEnterView;
 import org.telegram.messenger.ImageReceiver;
 import org.telegram.ui.Components.ChatAttachView;
+import org.telegram.ui.Components.PlayerView;
 import org.telegram.ui.Components.FrameLayoutFixed;
 import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.NumberTextView;
 import org.telegram.ui.Components.RadioButton;
 import org.telegram.ui.Components.RecordStatusDrawable;
 import org.telegram.ui.Components.RecyclerListView;
 import org.telegram.ui.Components.ResourceLoader;
 import org.telegram.ui.Components.SendingFileExDrawable;
+import org.telegram.ui.Components.ShareFrameLayout;
 import org.telegram.ui.Components.SizeNotifierFrameLayout;
 import org.telegram.ui.Components.TimerDrawable;
 import org.telegram.ui.Components.TypingDotsDrawable;
+import org.telegram.ui.Components.URLSpanBotCommand;
 import org.telegram.ui.Components.URLSpanNoUnderline;
 import org.telegram.ui.Components.URLSpanReplacement;
 import org.telegram.ui.Components.WebFrameLayout;
@@ -128,7 +136,9 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.concurrent.Semaphore;
+import java.util.regex.Matcher;
 
+@SuppressWarnings("unchecked")
 public class ChatActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate, DialogsActivity.MessagesActivityDelegate,
         PhotoViewer.PhotoViewerProvider {
 
@@ -143,7 +153,7 @@
     private Dialog closeChatDialog;
     private FrameLayout progressView;
     private FrameLayout bottomOverlay;
-    private ChatActivityEnterView chatActivityEnterView;
+    protected ChatActivityEnterView chatActivityEnterView;
     private ImageView timeItem;
     private View timeItem2;
     private TimerDrawable timerDrawable;
@@ -171,7 +181,7 @@
     private FrameLayout avatarContainer;
     private TextView bottomOverlayText;
     private TextView secretViewStatusTextView;
-    private TextView selectedMessagesCountTextView;
+    private NumberTextView selectedMessagesCountTextView;
     private RecyclerListView stickersListView;
     private StickersAdapter stickersAdapter;
     private FrameLayout stickersPanel;
@@ -189,6 +199,11 @@
     private LinearLayout reportSpamView;
     private TextView addToContactsButton;
     private TextView reportSpamButton;
+    private FrameLayout reportSpamContainer;
+    private PlayerView playerView;
+
+    private ObjectAnimatorProxy pagedownButtonAnimation;
+    private AnimatorSetProxy replyButtonAnimation;
 
     private TLRPC.User reportSpamUser;
 
@@ -210,47 +225,51 @@
     private TLRPC.FileLocation replyImageLocation;
     private int linkSearchRequestId;
     private TLRPC.WebPage foundWebPage;
+    private ArrayList<CharSequence> foundUrls;
     private String pendingLinkSearchString;
     private Runnable pendingWebPageTimeoutRunnable;
     private Runnable waitingForCharaterEnterRunnable;
 
-    private boolean openAnimationEnded = false;
+    private boolean openAnimationEnded;
 
-    private int readWithDate = 0;
-    private int readWithMid = 0;
-    private boolean scrollToTopOnResume = false;
-    private boolean scrollToTopUnReadOnResume = false;
+    private int readWithDate;
+    private int readWithMid;
+    private boolean scrollToTopOnResume;
+    private boolean scrollToTopUnReadOnResume;
     private long dialog_id;
-    private boolean isBroadcast = false;
-    private HashMap<Integer, MessageObject> selectedMessagesIds = new HashMap<>();
-    private HashMap<Integer, MessageObject> selectedMessagesCanCopyIds = new HashMap<>();
-    private int cantDeleteMessagesCount = 0;
-
-    private HashMap<Integer, MessageObject> messagesDict = new HashMap<>();
+    private int lastLoadIndex;
+    private boolean isBroadcast;
+    private HashMap<Integer, MessageObject>[] selectedMessagesIds = new HashMap[]{new HashMap<>(), new HashMap<>()};
+    private HashMap<Integer, MessageObject>[] selectedMessagesCanCopyIds = new HashMap[]{new HashMap<>(), new HashMap<>()};
+    private int cantDeleteMessagesCount;
+    private ArrayList<Integer> waitingForLoad = new ArrayList<>();
+
+    private HashMap<Integer, MessageObject>[] messagesDict = new HashMap[]{new HashMap<>(), new HashMap<>()};
     private HashMap<String, ArrayList<MessageObject>> messagesByDays = new HashMap<>();
     protected ArrayList<MessageObject> messages = new ArrayList<>();
-    private int maxMessageId = Integer.MAX_VALUE;
-    private int minMessageId = Integer.MIN_VALUE;
-    private int maxDate = Integer.MIN_VALUE;
-    private boolean endReached = false;
-    private boolean cacheEndReached = false;
-    private boolean loading = false;
+    private int maxMessageId[] = new int[] {Integer.MAX_VALUE, Integer.MAX_VALUE};
+    private int minMessageId[] = new int[] {Integer.MIN_VALUE, Integer.MIN_VALUE};
+    private int maxDate[] = new int[] {Integer.MIN_VALUE, Integer.MIN_VALUE};
+    private int minDate[] = new int[2];
+    private boolean endReached[] = new boolean[2];
+    private boolean cacheEndReached[] = new boolean[2];
+    private boolean forwardEndReached[] = new boolean[] {true, true};
+    private boolean loading;
     private boolean firstLoading = true;
-    private int loadsCount = 0;
+    private int loadsCount;
+    private int last_message_id = 0;
+    private long mergeDialogId;
 
-    private int startLoadFromMessageId = 0;
+    private int startLoadFromMessageId;
     private boolean needSelectFromMessageId;
-    private int returnToMessageId = 0;
+    private int returnToMessageId;
 
-    private int minDate = 0;
     private boolean first = true;
-    private int unread_to_load = 0;
-    private int first_unread_id = 0;
-    private int last_message_id = 0;
-    private boolean forward_end_reached = true;
-    private boolean loadingForward = false;
-    private MessageObject unreadMessageObject = null;
-    private MessageObject scrollToMessage = null;
+    private int unread_to_load;
+    private int first_unread_id;
+    private boolean loadingForward;
+    private MessageObject unreadMessageObject;
+    private MessageObject scrollToMessage;
     private int highlightMessageId = Integer.MAX_VALUE;
     private int scrollToMessagePosition = -10000;
 
@@ -313,10 +332,12 @@
 
     RecyclerListView.OnItemLongClickListener onItemLongClickListener = new RecyclerListView.OnItemLongClickListener() {
         @Override
-        public void onItemClick(View view, int position) {
+        public boolean onItemClick(View view, int position) {
             if (!actionBar.isActionModeShowed()) {
                 createMenu(view, false);
+                return true;
             }
+            return false;
         }
     };
 
@@ -341,6 +362,7 @@ public boolean onFragmentCreate() {
         final int userId = arguments.getInt("user_id", 0);
         final int encId = arguments.getInt("enc_id", 0);
         startLoadFromMessageId = arguments.getInt("message_id", 0);
+        int migrated_to = arguments.getInt("migrated_to", 0);
         scrollToTopOnResume = arguments.getBoolean("scrollToTopOnResume", false);
 
         if (chatId != 0) {
@@ -372,8 +394,12 @@ public void run() {
                 dialog_id = AndroidUtilities.makeBroadcastId(chatId);
             }
             if (ChatObject.isChannel(currentChat)) {
-                SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
-                channelMessagesImportant = preferences.getInt("important_" + dialog_id, 2);
+                if (!currentChat.megagroup) {
+                    SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
+                    channelMessagesImportant = preferences.getInt("important_" + dialog_id, 2);
+                } else {
+                    channelMessagesImportant = 1;
+                }
                 MessagesController.getInstance().startShortPoll(chatId, false);
             }
         } else if (userId != 0) {
@@ -444,8 +470,8 @@ public void run() {
                 }
             }
             dialog_id = ((long) encId) << 32;
-            maxMessageId = Integer.MIN_VALUE;
-            minMessageId = Integer.MAX_VALUE;
+            maxMessageId[0] = maxMessageId[1] = Integer.MIN_VALUE;
+            minMessageId[0] = minMessageId[1] = Integer.MAX_VALUE;
             MediaController.getInstance().startMediaObserver();
         } else {
             return false;
@@ -497,9 +523,16 @@ public void run() {
 
         if (startLoadFromMessageId != 0) {
             needSelectFromMessageId = true;
-            MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, startLoadFromMessageId, !cacheEndReached, 0, classGuid, 3, 0, channelMessagesImportant);
+            waitingForLoad.add(lastLoadIndex);
+            if (migrated_to != 0) {
+                mergeDialogId = migrated_to;
+                MessagesController.getInstance().loadMessages(mergeDialogId, AndroidUtilities.isTablet() ? 30 : 20, startLoadFromMessageId, true, 0, classGuid, 3, 0, 0, lastLoadIndex++);
+            } else {
+                MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, startLoadFromMessageId, true, 0, classGuid, 3, 0, channelMessagesImportant, lastLoadIndex++);
+            }
         } else {
-            MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, 0, !cacheEndReached, 0, classGuid, 2, 0, channelMessagesImportant);
+            waitingForLoad.add(lastLoadIndex);
+            MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, 0, true, 0, classGuid, 2, 0, channelMessagesImportant, lastLoadIndex++);
         }
 
         if (currentChat != null) {
@@ -517,14 +550,17 @@ public void run() {
             }
         }
 
-        if (userId != 0 && (currentUser.flags & TLRPC.USER_FLAG_BOT) != 0) {
+        URLSpanBotCommand.enabled = false;
+        if (userId != 0 && currentUser.bot) {
             BotQuery.loadBotInfo(userId, true, classGuid);
+            URLSpanBotCommand.enabled = true;
         } else if (info instanceof TLRPC.TL_chatFull) {
             for (int a = 0; a < info.participants.participants.size(); a++) {
-                TLRPC.TL_chatParticipant participant = info.participants.participants.get(a);
+                TLRPC.ChatParticipant participant = info.participants.participants.get(a);
                 TLRPC.User user = MessagesController.getInstance().getUser(participant.user_id);
-                if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                if (user != null && user.bot) {
                     BotQuery.loadBotInfo(user.id, true, classGuid);
+                    URLSpanBotCommand.enabled = true;
                 }
             }
         }
@@ -622,12 +658,21 @@ public void onFragmentDestroy() {
     @Override
     public View createView(Context context) {
 
-        for (int a = 0; a < 8; a++) {
-            chatMessageCellsCache.add(new ChatMessageCell(context));
+        if (chatMessageCellsCache.isEmpty()) {
+            for (int a = 0; a < 8; a++) {
+                chatMessageCellsCache.add(new ChatMessageCell(context));
+            }
+        }
+        if (chatMediaCellsCache.isEmpty()) {
+            for (int a = 0; a < 4; a++) {
+                chatMediaCellsCache.add(new ChatMediaCell(context));
+            }
         }
-        for (int a = 0; a < 4; a++) {
-            chatMediaCellsCache.add(new ChatMediaCell(context));
+        for (int a = 1; a >= 0; a--) {
+            selectedMessagesIds[a].clear();
+            selectedMessagesCanCopyIds[a].clear();
         }
+        cantDeleteMessagesCount = 0;
 
         lastPrintString = null;
         lastStatus = null;
@@ -637,49 +682,62 @@ public View createView(Context context) {
 
         ResourceLoader.loadRecources(context);
 
-        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setBackButtonDrawable(new BackDrawable(false));
         actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
             @Override
             public void onItemClick(final int id) {
                 if (id == -1) {
-                    finishFragment();
-                } else if (id == -2) {
-                    selectedMessagesIds.clear();
-                    selectedMessagesCanCopyIds.clear();
-                    cantDeleteMessagesCount = 0;
-                    actionBar.hideActionMode();
-                    updateVisibleRows();
-                } else if (id == copy) {
-                    String str = "";
-                    ArrayList<Integer> ids = new ArrayList<>(selectedMessagesCanCopyIds.keySet());
-                    if (currentEncryptedChat == null) {
-                        Collections.sort(ids);
+                    if (actionBar.isActionModeShowed()) {
+                        for (int a = 1; a >= 0; a--) {
+                            selectedMessagesIds[a].clear();
+                            selectedMessagesCanCopyIds[a].clear();
+                        }
+                        cantDeleteMessagesCount = 0;
+                        actionBar.hideActionMode();
+                        updateVisibleRows();
                     } else {
-                        Collections.sort(ids, Collections.reverseOrder());
+                        finishFragment();
                     }
-                    for (Integer messageId : ids) {
-                        MessageObject messageObject = selectedMessagesCanCopyIds.get(messageId);
-                        if (str.length() != 0) {
-                            str += "\n";
-                        }
-                        if (messageObject.messageOwner.message != null) {
-                            str += messageObject.messageOwner.message;
+                } else if (id == copy) {
+                    String str = "";
+                    for (int a = 1; a >= 0; a--) {
+                        ArrayList<Integer> ids = new ArrayList<>(selectedMessagesCanCopyIds[a].keySet());
+                        if (currentEncryptedChat == null) {
+                            Collections.sort(ids);
                         } else {
-                            str += messageObject.messageText;
+                            Collections.sort(ids, Collections.reverseOrder());
+                        }
+                        for (int b = 0; b < ids.size(); b++) {
+                            Integer messageId = ids.get(b);
+                            MessageObject messageObject = selectedMessagesCanCopyIds[a].get(messageId);
+                            if (str.length() != 0) {
+                                str += "\n";
+                            }
+                            if (messageObject.messageOwner.message != null) {
+                                str += messageObject.messageOwner.message;
+                            } else {
+                                str += messageObject.messageText;
+                            }
                         }
                     }
                     if (str.length() != 0) {
-                        if (Build.VERSION.SDK_INT < 11) {
-                            android.text.ClipboardManager clipboard = (android.text.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
-                            clipboard.setText(str);
-                        } else {
-                            android.content.ClipboardManager clipboard = (android.content.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
-                            android.content.ClipData clip = android.content.ClipData.newPlainText("label", str);
-                            clipboard.setPrimaryClip(clip);
+                        try {
+                            if (Build.VERSION.SDK_INT < 11) {
+                                android.text.ClipboardManager clipboard = (android.text.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                                clipboard.setText(str);
+                            } else {
+                                android.content.ClipboardManager clipboard = (android.content.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                                android.content.ClipData clip = android.content.ClipData.newPlainText("label", str);
+                                clipboard.setPrimaryClip(clip);
+                            }
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
                         }
                     }
-                    selectedMessagesIds.clear();
-                    selectedMessagesCanCopyIds.clear();
+                    for (int a = 1; a >= 0; a--) {
+                        selectedMessagesIds[a].clear();
+                        selectedMessagesCanCopyIds[a].clear();
+                    }
                     cantDeleteMessagesCount = 0;
                     actionBar.hideActionMode();
                     updateVisibleRows();
@@ -688,30 +746,32 @@ public void onItemClick(final int id) {
                         return;
                     }
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
-                    builder.setMessage(LocaleController.formatString("AreYouSureDeleteMessages", R.string.AreYouSureDeleteMessages, LocaleController.formatPluralString("messages", selectedMessagesIds.size())));
+                    builder.setMessage(LocaleController.formatString("AreYouSureDeleteMessages", R.string.AreYouSureDeleteMessages, LocaleController.formatPluralString("messages", selectedMessagesIds[0].size() + selectedMessagesIds[1].size())));
                     builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
                     builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                         @Override
                         public void onClick(DialogInterface dialogInterface, int i) {
-                            ArrayList<Integer> ids = new ArrayList<>(selectedMessagesIds.keySet());
-                            ArrayList<Long> random_ids = null;
-                            int channelId = 0;
-                            if (!ids.isEmpty()) {
-                                MessageObject msg = selectedMessagesIds.get(ids.get(0));
-                                if (channelId == 0 && msg.messageOwner.to_id.channel_id != 0) {
-                                    channelId = msg.messageOwner.to_id.channel_id;
+                            for (int a = 1; a >= 0; a--) {
+                                ArrayList<Integer> ids = new ArrayList<>(selectedMessagesIds[a].keySet());
+                                ArrayList<Long> random_ids = null;
+                                int channelId = 0;
+                                if (!ids.isEmpty()) {
+                                    MessageObject msg = selectedMessagesIds[a].get(ids.get(0));
+                                    if (channelId == 0 && msg.messageOwner.to_id.channel_id != 0) {
+                                        channelId = msg.messageOwner.to_id.channel_id;
+                                    }
                                 }
-                            }
-                            if (currentEncryptedChat != null) {
-                                random_ids = new ArrayList<>();
-                                for (HashMap.Entry<Integer, MessageObject> entry : selectedMessagesIds.entrySet()) {
-                                    MessageObject msg = entry.getValue();
-                                    if (msg.messageOwner.random_id != 0 && msg.type != 10) {
-                                        random_ids.add(msg.messageOwner.random_id);
+                                if (currentEncryptedChat != null) {
+                                    random_ids = new ArrayList<>();
+                                    for (HashMap.Entry<Integer, MessageObject> entry : selectedMessagesIds[a].entrySet()) {
+                                        MessageObject msg = entry.getValue();
+                                        if (msg.messageOwner.random_id != 0 && msg.type != 10) {
+                                            random_ids.add(msg.messageOwner.random_id);
+                                        }
                                     }
                                 }
+                                MessagesController.getInstance().deleteMessages(ids, random_ids, currentEncryptedChat, channelId);
                             }
-                            MessagesController.getInstance().deleteMessages(ids, random_ids, currentEncryptedChat, channelId);
                             actionBar.hideActionMode();
                         }
                     });
@@ -751,16 +811,16 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             if (id != clear_history) {
                                 if (isChat) {
                                     if (ChatObject.isNotInChat(currentChat)) {
-                                        MessagesController.getInstance().deleteDialog(dialog_id, 0, false);
+                                        MessagesController.getInstance().deleteDialog(dialog_id, 0);
                                     } else {
                                         MessagesController.getInstance().deleteUserFromChat((int) -dialog_id, MessagesController.getInstance().getUser(UserConfig.getClientUserId()), null);
                                     }
                                 } else {
-                                    MessagesController.getInstance().deleteDialog(dialog_id, 0, false);
+                                    MessagesController.getInstance().deleteDialog(dialog_id, 0);
                                 }
                                 finishFragment();
                             } else {
-                                MessagesController.getInstance().deleteDialog(dialog_id, 0, true);
+                                MessagesController.getInstance().deleteDialog(dialog_id, 1);
                             }
                         }
                     });
@@ -793,15 +853,18 @@ public void onClick(DialogInterface dialogInterface, int i) {
                 } else if (id == mute) {
                     toggleMute(false);
                 } else if (id == reply) {
-                    if (selectedMessagesIds.size() == 1) {
-                        ArrayList<Integer> ids = new ArrayList<>(selectedMessagesIds.keySet());
-                        MessageObject messageObject = messagesDict.get(ids.get(0));
-                        if (messageObject != null && messageObject.messageOwner.id > 0) {
-                            showReplyPanel(true, messageObject, null, null, false, true);
+                    MessageObject messageObject = null;
+                    for (int a = 1; a >= 0; a--) {
+                        if (messageObject == null && selectedMessagesIds[a].size() == 1) {
+                            ArrayList<Integer> ids = new ArrayList<>(selectedMessagesIds[a].keySet());
+                            messageObject = messagesDict[a].get(ids.get(0));
                         }
+                        selectedMessagesIds[a].clear();
+                        selectedMessagesCanCopyIds[a].clear();
+                    }
+                    if (messageObject != null && messageObject.messageOwner.id > 0) {
+                        showReplyPanel(true, messageObject, null, null, false, true);
                     }
-                    selectedMessagesIds.clear();
-                    selectedMessagesCanCopyIds.clear();
                     cantDeleteMessagesCount = 0;
                     actionBar.hideActionMode();
                     updateVisibleRows();
@@ -823,8 +886,17 @@ public void didPressedButton(int button) {
                                         ArrayList<String> photos = new ArrayList<>();
                                         ArrayList<String> captions = new ArrayList<>();
                                         for (HashMap.Entry<Integer, MediaController.PhotoEntry> entry : selectedPhotos.entrySet()) {
-                                            photos.add(entry.getValue().path);
-                                            captions.add("");
+                                            MediaController.PhotoEntry photoEntry = entry.getValue();
+                                            if (photoEntry.imagePath != null) {
+                                                photos.add(photoEntry.imagePath);
+                                                captions.add(photoEntry.caption != null ? photoEntry.caption.toString() : null);
+                                            } else if (photoEntry.path != null) {
+                                                photos.add(photoEntry.path);
+                                                captions.add(photoEntry.caption != null ? photoEntry.caption.toString() : null);
+                                            }
+                                            photoEntry.imagePath = null;
+                                            photoEntry.thumbPath = null;
+                                            photoEntry.caption = null;
                                         }
                                         SendMessagesHelper.prepareSendingPhotos(photos, null, dialog_id, replyingMessageObject, captions, chatActivityEnterView == null || chatActivityEnterView.asAdmin());
                                         showReplyPanel(false, null, null, null, false, true);
@@ -876,6 +948,9 @@ public View getRevealView() {
                         builder.setCustomView(chatAttachView);
                         chatAttachViewSheet = builder.create();
                     }
+                    if (Build.VERSION.SDK_INT == 21 || Build.VERSION.SDK_INT == 22) {
+                        chatActivityEnterView.closeKeyboard();
+                    }
 
                     chatAttachView.init(ChatActivity.this);
                     showDialog(chatAttachViewSheet);
@@ -886,14 +961,15 @@ public View getRevealView() {
                 } else if (id == search) {
                     openSearchWithText(null);
                 } else if (id == search_up) {
-                    MessagesSearchQuery.searchMessagesInChat(null, dialog_id, classGuid, 1);
+                    MessagesSearchQuery.searchMessagesInChat(null, dialog_id, mergeDialogId, classGuid, 1);
                 } else if (id == search_down) {
-                    MessagesSearchQuery.searchMessagesInChat(null, dialog_id, classGuid, 2);
+                    MessagesSearchQuery.searchMessagesInChat(null, dialog_id, mergeDialogId, classGuid, 2);
                 } else if (id == open_channel_profile) {
                     Bundle args = new Bundle();
                     args.putInt("chat_id", currentChat.id);
                     ProfileActivity fragment = new ProfileActivity(args);
                     fragment.setChatInfo(info);
+                    fragment.setPlayProfileAnimation(true);
                     presentFragment(fragment);
                 }
             }
@@ -902,7 +978,7 @@ public View getRevealView() {
         avatarContainer = new FrameLayoutFixed(context);
         avatarContainer.setBackgroundResource(R.drawable.bar_selector);
         avatarContainer.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), 0);
-        actionBar.addView(avatarContainer, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 56, 0, 40, 0));
+        actionBar.addView(avatarContainer, 0, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 56, 0, 40, 0));
         avatarContainer.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
@@ -913,12 +989,15 @@ public void onClick(View v) {
                         if (currentEncryptedChat != null) {
                             args.putLong("dialog_id", dialog_id);
                         }
-                        presentFragment(new ProfileActivity(args));
+                        ProfileActivity fragment = new ProfileActivity(args);
+                        fragment.setPlayProfileAnimation(true);
+                        presentFragment(fragment);
                     } else if (currentChat != null) {
                         Bundle args = new Bundle();
                         args.putInt("chat_id", currentChat.id);
                         ProfileActivity fragment = new ProfileActivity(args);
                         fragment.setChatInfo(info);
+                        fragment.setPlayProfileAnimation(true);
                         presentFragment(fragment);
                     }
                 } else {
@@ -933,7 +1012,7 @@ public void onClick(View v) {
                 if (info != null) {
                     count = info.participants.participants.size();
                 }
-                if (count == 0 || (currentChat.flags & TLRPC.CHAT_FLAG_USER_LEFT) != 0 || currentChat instanceof TLRPC.TL_chatForbidden || info != null && info.participants instanceof TLRPC.TL_chatParticipantsForbidden) {
+                if (count == 0 || currentChat.deactivated || currentChat.left || currentChat instanceof TLRPC.TL_chatForbidden || info != null && info.participants instanceof TLRPC.TL_chatParticipantsForbidden) {
                     avatarContainer.setEnabled(false);
                 }
             }
@@ -981,7 +1060,7 @@ public void onClick(View v) {
         onlineTextView.setEllipsize(TextUtils.TruncateAt.END);
         onlineTextView.setGravity(Gravity.LEFT);
 
-        if (ChatObject.isChannel(currentChat)) {
+        if (ChatObject.isChannel(currentChat) && !currentChat.megagroup && !(currentChat instanceof TLRPC.TL_channelForbidden)) {
             radioButton = new RadioButton(context);
             radioButton.setChecked(channelMessagesImportant == 1, false);
             radioButton.setVisibility(View.GONE);
@@ -1022,7 +1101,7 @@ public void onSearchCollapse() {
                     searchDownItem.setVisibility(View.GONE);
                     highlightMessageId = Integer.MAX_VALUE;
                     updateVisibleRows();
-                    scrollToLastMessage();
+                    scrollToLastMessage(false);
                 }
 
                 @Override
@@ -1042,7 +1121,7 @@ public void run() {
                 @Override
                 public void onSearchPressed(EditText editText) {
                     updateSearchButtons(0);
-                    MessagesSearchQuery.searchMessagesInChat(editText.getText().toString(), dialog_id, classGuid, 0);
+                    MessagesSearchQuery.searchMessagesInChat(editText.getText().toString(), dialog_id, mergeDialogId, classGuid, 0);
                 }
             });
             searchItem.getSearchField().setHint(LocaleController.getString("Search", R.string.Search));
@@ -1055,7 +1134,7 @@ public void onSearchPressed(EditText editText) {
         }
 
         headerItem = menu.addItem(0, R.drawable.ic_ab_other);
-        if (channelMessagesImportant != 0) {
+        if (channelMessagesImportant != 0 && !currentChat.megagroup) {
             headerItem.addSubItem(open_channel_profile, LocaleController.getString("OpenChannelProfile", R.string.OpenChannelProfile), 0);
         }
         if (searchItem != null) {
@@ -1076,7 +1155,7 @@ public void onSearchPressed(EditText editText) {
             }
         }
         muteItem = headerItem.addSubItem(mute, null, 0);
-        if (currentUser != null && currentEncryptedChat == null && (currentUser.flags & TLRPC.USER_FLAG_BOT) != 0) {
+        if (currentUser != null && currentEncryptedChat == null && currentUser.bot) {
             headerItem.addSubItem(bot_settings, LocaleController.getString("BotSettings", R.string.BotSettings), 0);
             headerItem.addSubItem(bot_help, LocaleController.getString("BotHelp", R.string.BotHelp), 0);
             updateBotButtons();
@@ -1094,18 +1173,12 @@ public void onSearchPressed(EditText editText) {
         actionModeViews.clear();
 
         final ActionBarMenu actionMode = actionBar.createActionMode();
-        actionModeViews.add(actionMode.addItem(-2, R.drawable.ic_ab_back_grey, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
 
-        selectedMessagesCountTextView = new TextView(actionMode.getContext());
+        selectedMessagesCountTextView = new NumberTextView(actionMode.getContext());
         selectedMessagesCountTextView.setTextSize(18);
         selectedMessagesCountTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
         selectedMessagesCountTextView.setTextColor(0xff737373);
-        selectedMessagesCountTextView.setSingleLine(true);
-        selectedMessagesCountTextView.setLines(1);
-        selectedMessagesCountTextView.setEllipsize(TextUtils.TruncateAt.END);
-        selectedMessagesCountTextView.setPadding(AndroidUtilities.dp(11), 0, 0, AndroidUtilities.dp(2));
-        selectedMessagesCountTextView.setGravity(Gravity.CENTER_VERTICAL);
-        actionMode.addView(selectedMessagesCountTextView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f));
+        actionMode.addView(selectedMessagesCountTextView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f, 65, 0, 0, 0));
         selectedMessagesCountTextView.setOnTouchListener(new View.OnTouchListener() {
             @Override
             public boolean onTouch(View v, MotionEvent event) {
@@ -1114,25 +1187,18 @@ public boolean onTouch(View v, MotionEvent event) {
         });
 
         if (currentEncryptedChat == null) {
-            actionModeViews.add(actionMode.addItem(copy, R.drawable.ic_ab_fwd_copy, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
             if (!isBroadcast) {
                 actionModeViews.add(actionMode.addItem(reply, R.drawable.ic_ab_reply, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
             }
+            actionModeViews.add(actionMode.addItem(copy, R.drawable.ic_ab_fwd_copy, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
             actionModeViews.add(actionMode.addItem(forward, R.drawable.ic_ab_fwd_forward, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
             actionModeViews.add(actionMode.addItem(delete, R.drawable.ic_ab_fwd_delete, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
         } else {
             actionModeViews.add(actionMode.addItem(copy, R.drawable.ic_ab_fwd_copy, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
             actionModeViews.add(actionMode.addItem(delete, R.drawable.ic_ab_fwd_delete, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
         }
-        actionMode.getItem(copy).setVisibility(selectedMessagesCanCopyIds.size() != 0 ? View.VISIBLE : View.GONE);
+        actionMode.getItem(copy).setVisibility(selectedMessagesCanCopyIds[0].size() + selectedMessagesCanCopyIds[1].size() != 0 ? View.VISIBLE : View.GONE);
         actionMode.getItem(delete).setVisibility(cantDeleteMessagesCount == 0 ? View.VISIBLE : View.GONE);
-        if (actionMode.getItem(reply) != null) {
-            boolean allowChatActions = true;
-            if (isBroadcast || currentChat != null && (ChatObject.isNotInChat(currentChat) || ChatObject.isChannel(currentChat) && (currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) == 0 && (currentChat.flags & TLRPC.CHAT_FLAG_USER_IS_EDITOR) == 0)) {
-                allowChatActions = false;
-            }
-            actionMode.getItem(reply).setVisibility(allowChatActions && selectedMessagesIds.size() == 1 ? View.VISIBLE : View.GONE);
-        }
         checkActionBarMenu();
 
         fragmentView = new SizeNotifierFrameLayout(context) {
@@ -1145,6 +1211,7 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                 int heightSize = MeasureSpec.getSize(heightMeasureSpec);
 
                 setMeasuredDimension(widthSize, heightSize);
+                heightSize -= getPaddingTop();
 
                 int keyboardSize = getKeyboardHeight();
 
@@ -1162,18 +1229,22 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                     if (child.getVisibility() == GONE || child == chatActivityEnterView) {
                         continue;
                     }
-                    if (child == chatListView || child == progressView) {
-                        int contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY);
-                        int contentHeightSpec = MeasureSpec.makeMeasureSpec(Math.max(AndroidUtilities.dp(10), heightSize - inputFieldHeight + AndroidUtilities.dp(2)), MeasureSpec.EXACTLY);
-                        child.measure(contentWidthSpec, contentHeightSpec);
-                    } else if (child == emptyViewContainer) {
-                        int contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY);
-                        int contentHeightSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY);
-                        child.measure(contentWidthSpec, contentHeightSpec);
-                    } else if (chatActivityEnterView.isPopupView(child)) {
-                        child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getLayoutParams().height, MeasureSpec.EXACTLY));
-                    } else {
-                        measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
+                    try {
+                        if (child == chatListView || child == progressView) {
+                            int contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY);
+                            int contentHeightSpec = MeasureSpec.makeMeasureSpec(Math.max(AndroidUtilities.dp(10), heightSize - inputFieldHeight + AndroidUtilities.dp(2)), MeasureSpec.EXACTLY);
+                            child.measure(contentWidthSpec, contentHeightSpec);
+                        } else if (child == emptyViewContainer) {
+                            int contentWidthSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY);
+                            int contentHeightSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY);
+                            child.measure(contentWidthSpec, contentHeightSpec);
+                        } else if (chatActivityEnterView.isPopupView(child)) {
+                            child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getLayoutParams().height, MeasureSpec.EXACTLY));
+                        } else {
+                            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
+                        }
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
                     }
                 }
             }
@@ -1220,7 +1291,7 @@ protected void onLayout(boolean changed, int l, int t, int r, int b) {
 
                     switch (verticalGravity) {
                         case Gravity.TOP:
-                            childTop = lp.topMargin;
+                            childTop = lp.topMargin + getPaddingTop();
                             break;
                         case Gravity.CENTER_VERTICAL:
                             childTop = ((b - paddingBottom) - t - height) / 2 + lp.topMargin - lp.bottomMargin;
@@ -1349,11 +1420,11 @@ public boolean onTouch(View v, MotionEvent event) {
             @Override
             protected void onLayout(boolean changed, int l, int t, int r, int b) {
                 super.onLayout(changed, l, t, r, b);
-                if (chatAdapter.isBot) {
+                if (chatAdapter.isBot/* || ChatObject.isChannel(currentChat) && currentChat.megagroup*/) {
                     int childCount = getChildCount();
                     for (int a = 0; a < childCount; a++) {
                         View child = getChildAt(a);
-                        if (child instanceof BotHelpCell) {
+                        if (child instanceof BotHelpCell/* || child instanceof ChatMigrateCell*/) {
                             int height = b - t;
                             int top = height / 2 - child.getMeasuredHeight() / 2;
                             if (child.getTop() > top) {
@@ -1395,27 +1466,12 @@ public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
 
             @Override
             public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
+                checkScrollForLoad();
                 int firstVisibleItem = chatLayoutManager.findFirstVisibleItemPosition();
                 int visibleItemCount = firstVisibleItem == RecyclerView.NO_POSITION ? 0 : Math.abs(chatLayoutManager.findLastVisibleItemPosition() - firstVisibleItem) + 1;
                 if (visibleItemCount > 0) {
                     int totalItemCount = chatAdapter.getItemCount();
-                    if (firstVisibleItem <= 10) {
-                        if (!endReached && !loading) {
-                            if (messagesByDays.size() != 0) {
-                                MessagesController.getInstance().loadMessages(dialog_id, 20, maxMessageId, !cacheEndReached, minDate, classGuid, 0, 0, channelMessagesImportant);
-                            } else {
-                                MessagesController.getInstance().loadMessages(dialog_id, 20, 0, !cacheEndReached, minDate, classGuid, 0, 0, channelMessagesImportant);
-                            }
-                            loading = true;
-                        }
-                    }
-                    if (firstVisibleItem + visibleItemCount >= totalItemCount - 6) {
-                        if (!forward_end_reached && !loadingForward) {
-                            MessagesController.getInstance().loadMessages(dialog_id, 20, minMessageId, !cacheEndReached, maxDate, classGuid, 1, 0, channelMessagesImportant);
-                            loadingForward = true;
-                        }
-                    }
-                    if (firstVisibleItem + visibleItemCount == totalItemCount && forward_end_reached) {
+                    if (firstVisibleItem + visibleItemCount == totalItemCount && forwardEndReached[0]) {
                         showPagedownButton(false, true);
                     }
                 }
@@ -1464,6 +1520,9 @@ public void run() {
                                 AndroidUtilities.cancelRunOnUIThread(openSecretPhotoRunnable);
                                 openSecretPhotoRunnable = null;
                             }
+                            chatListView.setOnItemClickListener(onItemClickListener);
+                            chatListView.setOnItemLongClickListener(onItemLongClickListener);
+                            chatListView.setLongClickable(true);
                         }
                     }
                 }
@@ -1550,19 +1609,43 @@ public void run() {
         reportSpamView.setBackgroundResource(R.drawable.blockpanel);
         contentView.addView(reportSpamView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 50, Gravity.TOP | Gravity.LEFT));
 
+        addToContactsButton = new TextView(context);
+        addToContactsButton.setTextColor(0xff4a82b5);
+        addToContactsButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        addToContactsButton.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        addToContactsButton.setSingleLine(true);
+        addToContactsButton.setMaxLines(1);
+        addToContactsButton.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0);
+        addToContactsButton.setGravity(Gravity.CENTER);
+        addToContactsButton.setText(LocaleController.getString("AddContactChat", R.string.AddContactChat));
+        reportSpamView.addView(addToContactsButton, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0.5f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
+        addToContactsButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Bundle args = new Bundle();
+                args.putInt("user_id", currentUser.id);
+                args.putBoolean("addContact", true);
+                presentFragment(new ContactAddActivity(args));
+            }
+        });
+
+        reportSpamContainer = new FrameLayout(context);
+        reportSpamView.addView(reportSpamContainer, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0.5f, Gravity.LEFT | Gravity.TOP));
+
         reportSpamButton = new TextView(context);
         reportSpamButton.setTextColor(0xffcf5957);
         reportSpamButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
         reportSpamButton.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
         reportSpamButton.setSingleLine(true);
         reportSpamButton.setMaxLines(1);
-        reportSpamButton.setGravity(Gravity.CENTER);
         reportSpamButton.setText(LocaleController.getString("ReportSpam", R.string.ReportSpam));
-        reportSpamView.addView(reportSpamButton, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0.5f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
+        reportSpamButton.setGravity(Gravity.CENTER);
+        reportSpamButton.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(50), 0);
+        reportSpamContainer.addView(reportSpamButton, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.LEFT | Gravity.TOP));
         reportSpamButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                if (reportSpamUser == null) {
+                if (reportSpamUser == null || getParentActivity() == null) {
                     return;
                 }
                 AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
@@ -1575,6 +1658,9 @@ public void onClick(View v) {
                 builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                     @Override
                     public void onClick(DialogInterface dialogInterface, int i) {
+                        if (reportSpamUser == null) {
+                            return;
+                        }
                         TLRPC.TL_messages_reportSpam req = new TLRPC.TL_messages_reportSpam();
                         req.peer = new TLRPC.TL_inputPeerUser();
                         req.peer.user_id = reportSpamUser.id;
@@ -1602,22 +1688,16 @@ public void run() {
             }
         });
 
-        addToContactsButton = new TextView(context);
-        addToContactsButton.setTextColor(0xff4a82b5);
-        addToContactsButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
-        addToContactsButton.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        addToContactsButton.setSingleLine(true);
-        addToContactsButton.setMaxLines(1);
-        addToContactsButton.setGravity(Gravity.CENTER);
-        addToContactsButton.setText(LocaleController.getString("AddContactChat", R.string.AddContactChat));
-        reportSpamView.addView(addToContactsButton, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0.5f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
-        addToContactsButton.setOnClickListener(new View.OnClickListener() {
+        ImageView closeReportSpam = new ImageView(context);
+        closeReportSpam.setImageResource(R.drawable.delete_reply);
+        closeReportSpam.setScaleType(ImageView.ScaleType.CENTER);
+        reportSpamContainer.addView(closeReportSpam, LayoutHelper.createFrame(48, 48, Gravity.RIGHT | Gravity.TOP));
+        closeReportSpam.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                Bundle args = new Bundle();
-                args.putInt("user_id", currentUser.id);
-                args.putBoolean("addContact", true);
-                presentFragment(new ContactAddActivity(args));
+                SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
+                preferences.edit().putBoolean("spam_" + dialog_id, true).commit();
+                updateSpamView();
             }
         });
 
@@ -1761,12 +1841,27 @@ public void onClick(DialogInterface dialogInterface, int i) {
             });
         }
 
+        pagedownButton = new ImageView(context);
+        pagedownButton.setVisibility(View.INVISIBLE);
+        pagedownButton.setImageResource(R.drawable.pagedown);
+        contentView.addView(pagedownButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.RIGHT | Gravity.BOTTOM, 0, 0, 6, 4));
+        pagedownButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                if (returnToMessageId > 0) {
+                    scrollToMessageId(returnToMessageId, 0, true, 0);
+                } else {
+                    scrollToLastMessage(true);
+                }
+            }
+        });
+
         chatActivityEnterView = new ChatActivityEnterView(getParentActivity(), contentView, this, true);
         chatActivityEnterView.setDialogId(dialog_id);
         chatActivityEnterView.addToAttachLayout(menuItem);
         chatActivityEnterView.setId(id_chat_compose_panel);
         chatActivityEnterView.setBotsCount(botsCount, hasBotsCommands);
-        contentView.addView(chatActivityEnterView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM));
+        contentView.addView(chatActivityEnterView, contentView.getChildCount() - 1, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM));
         chatActivityEnterView.setDelegate(new ChatActivityEnterView.ChatActivityEnterViewDelegate() {
             @Override
             public void onMessageSend(String message) {
@@ -1802,7 +1897,7 @@ public void run() {
                                 }
                             }
                         };
-                        AndroidUtilities.runOnUIThread(waitingForCharaterEnterRunnable, 3000);
+                        AndroidUtilities.runOnUIThread(waitingForCharaterEnterRunnable, AndroidUtilities.WEB_URL == null ? 3000 : 1000);
                     }
                 }
             }
@@ -2013,7 +2108,7 @@ public void onClick(View view) {
                 }
                 AlertDialog.Builder builder = null;
                 if (currentUser != null && userBlocked) {
-                    if ((currentUser.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                    if (currentUser.bot) {
                         String botUserLast = botUser;
                         botUser = null;
                         MessagesController.getInstance().unblockUser(currentUser.id);
@@ -2032,7 +2127,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                     }
-                } else if (currentUser != null && botUser != null) {
+                } else if (currentUser != null && currentUser.bot && botUser != null) {
                     if (botUser.length() != 0) {
                         MessagesController.getInstance().sendBotStart(currentUser, botUser);
                     } else {
@@ -2041,7 +2136,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     botUser = null;
                     updateBottomOverlay();
                 } else {
-                    if (ChatObject.isChannel(currentChat)) {
+                    if (ChatObject.isChannel(currentChat) && !currentChat.megagroup && !(currentChat instanceof TLRPC.TL_channelForbidden)) {
                         if (ChatObject.isNotInChat(currentChat)) {
                             MessagesController.getInstance().addUserToChat(currentChat.id, UserConfig.getCurrentUser(), null, 0, null, null);
                         } else {
@@ -2053,7 +2148,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                             @Override
                             public void onClick(DialogInterface dialogInterface, int i) {
-                                MessagesController.getInstance().deleteDialog(dialog_id, 0, false);
+                                MessagesController.getInstance().deleteDialog(dialog_id, 0);
                                 finishFragment();
                             }
                         });
@@ -2072,30 +2167,20 @@ public void onClick(DialogInterface dialogInterface, int i) {
         bottomOverlayChatText.setTextColor(0xff3e6fa1);
         bottomOverlayChat.addView(bottomOverlayChatText, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER));
 
-        pagedownButton = new ImageView(context);
-        pagedownButton.setVisibility(View.INVISIBLE);
-        pagedownButton.setImageResource(R.drawable.pagedown);
-        contentView.addView(pagedownButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.RIGHT | Gravity.BOTTOM, 0, 0, 6, 4));
-        pagedownButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                if (returnToMessageId > 0) {
-                    scrollToMessageId(returnToMessageId, 0, true);
-                } else {
-                    scrollToLastMessage();
-                }
-            }
-        });
-
+        chatAdapter.updateRows();
         if (loading && messages.isEmpty()) {
-            progressView.setVisibility(View.VISIBLE);
+            progressView.setVisibility(chatAdapter.botInfoRow == -1 ? View.VISIBLE : View.INVISIBLE);
             chatListView.setEmptyView(null);
         } else {
             progressView.setVisibility(View.INVISIBLE);
             chatListView.setEmptyView(emptyViewContainer);
         }
 
-        chatActivityEnterView.setButtons(botButtons);
+        chatActivityEnterView.setButtons(userBlocked ? null : botButtons);
+
+        if (!AndroidUtilities.isTablet() || AndroidUtilities.isSmallTablet()) {
+            contentView.addView(playerView = new PlayerView(context, this), LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 39, Gravity.TOP | Gravity.LEFT, 0, -36, 0, 0));
+        }
 
         updateContactStatus();
         updateBottomOverlay();
@@ -2105,31 +2190,41 @@ public void onClick(View view) {
         return fragmentView;
     }
 
-    private boolean searchForHttpInText(CharSequence string) {
-        int len = string.length();
-        int seqLen = 0;
-        for (int a = 0; a < len; a++) {
-            char ch = string.charAt(a);
-            if (seqLen == 0 && (ch == 'h' || ch == 'H')) {
-                seqLen++;
-            } else if ((seqLen == 1 || seqLen == 2) && (ch == 't' || ch == 'T')) {
-                seqLen++;
-            } else if (seqLen == 3 && (ch == 'p' || ch == 'P')) {
-                seqLen++;
-            } else if (seqLen == 4 && (ch == 's' || ch == 'S')) {
-                seqLen++;
-            } else if ((seqLen == 4 || seqLen == 5) && ch == ':') {
-                seqLen++;
-            } else if ((seqLen == 5 || seqLen == 6 || seqLen == 7) && ch == '/') {
-                if (seqLen == 6 || seqLen == 7) {
-                    return true;
+    private void checkScrollForLoad() {
+        if (chatLayoutManager == null || paused) {
+            return;
+        }
+        int firstVisibleItem = chatLayoutManager.findFirstVisibleItemPosition();
+        int visibleItemCount = firstVisibleItem == RecyclerView.NO_POSITION ? 0 : Math.abs(chatLayoutManager.findLastVisibleItemPosition() - firstVisibleItem) + 1;
+        if (visibleItemCount > 0) {
+            int totalItemCount = chatAdapter.getItemCount();
+            if (firstVisibleItem <= 25 && !loading) {
+                if (!endReached[0]) {
+                    loading = true;
+                    waitingForLoad.add(lastLoadIndex);
+                    if (messagesByDays.size() != 0) {
+                        MessagesController.getInstance().loadMessages(dialog_id, 50, maxMessageId[0], !cacheEndReached[0], minDate[0], classGuid, 0, 0, channelMessagesImportant, lastLoadIndex++);
+                    } else {
+                        MessagesController.getInstance().loadMessages(dialog_id, 50, 0, !cacheEndReached[0], minDate[0], classGuid, 0, 0, channelMessagesImportant, lastLoadIndex++);
+                    }
+                } else if (mergeDialogId != 0 && !endReached[1]) {
+                    loading = true;
+                    waitingForLoad.add(lastLoadIndex);
+                    MessagesController.getInstance().loadMessages(mergeDialogId, 50, maxMessageId[1], !cacheEndReached[1], minDate[1], classGuid, 0, 0, 0, lastLoadIndex++);
+                }
+            }
+            if (!loadingForward && firstVisibleItem + visibleItemCount >= totalItemCount - 10) {
+                if (mergeDialogId != 0 && !forwardEndReached[1]) {
+                    waitingForLoad.add(lastLoadIndex);
+                    MessagesController.getInstance().loadMessages(mergeDialogId, 50, minMessageId[1], true, maxDate[1], classGuid, 1, 0, 0, lastLoadIndex++);
+                    loadingForward = true;
+                } else if (!forwardEndReached[0]) {
+                    waitingForLoad.add(lastLoadIndex);
+                    MessagesController.getInstance().loadMessages(dialog_id, 50, minMessageId[0], true, maxDate[0], classGuid, 1, 0, channelMessagesImportant, lastLoadIndex++);
+                    loadingForward = true;
                 }
-                seqLen++;
-            } else if (seqLen != 0) {
-                seqLen = 0;
             }
         }
-        return false;
     }
 
     private void processSelectedAttach(int which) {
@@ -2174,6 +2269,10 @@ private void processSelectedAttach(int which) {
                 FileLog.e("tmessages", e);
             }
         } else if (which == attach_gallery) {
+            if (Build.VERSION.SDK_INT >= 23 && getParentActivity().checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                getParentActivity().requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, 4);
+                return;
+            }
             PhotoAlbumPickerActivity fragment = new PhotoAlbumPickerActivity(false, ChatActivity.this);
             fragment.setDelegate(new PhotoAlbumPickerActivity.PhotoAlbumPickerActivityDelegate() {
                 @Override
@@ -2247,6 +2346,10 @@ public void didSelectLocation(TLRPC.MessageMedia location) {
             });
             presentFragment(fragment);
         } else if (which == attach_document) {
+            if (Build.VERSION.SDK_INT >= 23 && getParentActivity().checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                getParentActivity().requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, 4);
+                return;
+            }
             DocumentSelectActivity fragment = new DocumentSelectActivity();
             fragment.setDelegate(new DocumentSelectActivity.DocumentSelectActivityDelegate() {
                 @Override
@@ -2269,6 +2372,10 @@ public void startDocumentSelectActivity() {
             });
             presentFragment(fragment);
         } else if (which == attach_audio) {
+            if (Build.VERSION.SDK_INT >= 23 && getParentActivity().checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                getParentActivity().requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, 4);
+                return;
+            }
             AudioSelectActivity fragment = new AudioSelectActivity();
             fragment.setDelegate(new AudioSelectActivity.AudioSelectActivityDelegate() {
                 @Override
@@ -2279,6 +2386,12 @@ public void didSelectAudio(ArrayList<MessageObject> audios) {
             });
             presentFragment(fragment);
         } else if (which == attach_contact) {
+            if (Build.VERSION.SDK_INT >= 23) {
+                if (getParentActivity().checkSelfPermission(Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+                    getParentActivity().requestPermissions(new String[]{Manifest.permission.READ_CONTACTS}, 5);
+                    return;
+                }
+            }
             try {
                 Intent intent = new Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI);
                 intent.setType(ContactsContract.CommonDataKinds.Phone.CONTENT_TYPE);
@@ -2289,14 +2402,15 @@ public void didSelectAudio(ArrayList<MessageObject> audios) {
         }
     }
 
-    private void searchLinks(CharSequence charSequence, boolean force) {
+    @Override
+    public boolean dismissDialogOnPause(Dialog dialog) {
+        return !(dialog == chatAttachViewSheet && PhotoViewer.getInstance().isVisible()) && super.dismissDialogOnPause(dialog);
+    }
+
+    private void searchLinks(final CharSequence charSequence, boolean force) {
         if (currentEncryptedChat != null) {
             return;
         }
-        if (linkSearchRequestId != 0) {
-            ConnectionsManager.getInstance().cancelRequest(linkSearchRequestId, true);
-            linkSearchRequestId = 0;
-        }
         if (force && foundWebPage != null) {
             if (foundWebPage.url != null) {
                 int index = TextUtils.indexOf(charSequence, foundWebPage.url);
@@ -2317,48 +2431,107 @@ private void searchLinks(CharSequence charSequence, boolean force) {
             pendingLinkSearchString = null;
             showReplyPanel(false, null, null, foundWebPage, false, true);
         }
-        if (charSequence.length() < 13 || !searchForHttpInText(charSequence)) {
-            return;
-        }
-        final TLRPC.TL_messages_getWebPagePreview req = new TLRPC.TL_messages_getWebPagePreview();
-        if (charSequence instanceof String) {
-            req.message = (String) charSequence;
-        } else {
-            req.message = charSequence.toString();
-        }
-        linkSearchRequestId = ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+        Utilities.searchQueue.postRunnable(new Runnable() {
             @Override
-            public void run(final TLObject response, final TLRPC.TL_error error) {
-                AndroidUtilities.runOnUIThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        linkSearchRequestId = 0;
-                        if (error == null) {
-                            if (response instanceof TLRPC.TL_messageMediaWebPage) {
-                                foundWebPage = ((TLRPC.TL_messageMediaWebPage) response).webpage;
-                                if (foundWebPage instanceof TLRPC.TL_webPage || foundWebPage instanceof TLRPC.TL_webPagePending) {
-                                    if (foundWebPage instanceof TLRPC.TL_webPagePending) {
-                                        pendingLinkSearchString = req.message;
-                                    }
-                                    showReplyPanel(true, null, null, foundWebPage, false, true);
-                                } else {
-                                    if (foundWebPage != null) {
-                                        showReplyPanel(false, null, null, foundWebPage, false, true);
-                                        foundWebPage = null;
-                                    }
+            public void run() {
+                if (linkSearchRequestId != 0) {
+                    ConnectionsManager.getInstance().cancelRequest(linkSearchRequestId, true);
+                    linkSearchRequestId = 0;
+                }
+                ArrayList<CharSequence> urls = null;
+                CharSequence textToCheck;
+                try {
+                    Matcher m = AndroidUtilities.WEB_URL.matcher(charSequence);
+                    while (m.find()) {
+                        if (urls == null) {
+                            urls = new ArrayList<>();
+                        }
+                        urls.add(charSequence.subSequence(m.start(), m.end()));
+                    }
+                    if (urls != null && foundUrls != null && urls.size() == foundUrls.size()) {
+                        boolean clear = true;
+                        for (int a = 0; a < urls.size(); a++) {
+                            if (!TextUtils.equals(urls.get(a), foundUrls.get(a))) {
+                                clear = false;
+                            }
+                        }
+                        if (clear) {
+                            return;
+                        }
+                    }
+                    foundUrls = urls;
+                    if (urls == null) {
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (foundWebPage != null) {
+                                    showReplyPanel(false, null, null, foundWebPage, false, true);
+                                    foundWebPage = null;
                                 }
-                            } else {
+                            }
+                        });
+                        return;
+                    }
+                    textToCheck = TextUtils.join(" ", urls);
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                    String text = charSequence.toString().toLowerCase();
+                    if (charSequence.length() < 13 || !text.contains("http://") && !text.contains("https://")) {
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
                                 if (foundWebPage != null) {
                                     showReplyPanel(false, null, null, foundWebPage, false, true);
                                     foundWebPage = null;
                                 }
                             }
-                        }
+                        });
+                        return;
+                    }
+                    textToCheck = charSequence;
+                }
+
+                final TLRPC.TL_messages_getWebPagePreview req = new TLRPC.TL_messages_getWebPagePreview();
+                if (textToCheck instanceof String) {
+                    req.message = (String) textToCheck;
+                } else {
+                    req.message = textToCheck.toString();
+                }
+                linkSearchRequestId = ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+                    @Override
+                    public void run(final TLObject response, final TLRPC.TL_error error) {
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                linkSearchRequestId = 0;
+                                if (error == null) {
+                                    if (response instanceof TLRPC.TL_messageMediaWebPage) {
+                                        foundWebPage = ((TLRPC.TL_messageMediaWebPage) response).webpage;
+                                        if (foundWebPage instanceof TLRPC.TL_webPage || foundWebPage instanceof TLRPC.TL_webPagePending) {
+                                            if (foundWebPage instanceof TLRPC.TL_webPagePending) {
+                                                pendingLinkSearchString = req.message;
+                                            }
+                                            showReplyPanel(true, null, null, foundWebPage, false, true);
+                                        } else {
+                                            if (foundWebPage != null) {
+                                                showReplyPanel(false, null, null, foundWebPage, false, true);
+                                                foundWebPage = null;
+                                            }
+                                        }
+                                    } else {
+                                        if (foundWebPage != null) {
+                                            showReplyPanel(false, null, null, foundWebPage, false, true);
+                                            foundWebPage = null;
+                                        }
+                                    }
+                                }
+                            }
+                        });
                     }
                 });
+                ConnectionsManager.getInstance().bindRequestToGuid(linkSearchRequestId, classGuid);
             }
         });
-        ConnectionsManager.getInstance().bindRequestToGuid(linkSearchRequestId, classGuid);
     }
 
     private void forwardMessages(ArrayList<MessageObject> arrayList, boolean fromMyName) {
@@ -2375,10 +2548,20 @@ private void forwardMessages(ArrayList<MessageObject> arrayList, boolean fromMyN
     }
 
     public void showReplyPanel(boolean show, MessageObject messageObject, ArrayList<MessageObject> messageObjects, TLRPC.WebPage webPage, boolean cancel, boolean animated) {
+        if (chatActivityEnterView == null) {
+            return;
+        }
         if (show) {
             if (messageObject == null && messageObjects == null && webPage == null) {
                 return;
             }
+            boolean openKeyboard = false;
+            if (messageObject != null && messageObject.getDialogId() != dialog_id) {
+                messageObjects = new ArrayList<>();
+                messageObjects.add(messageObject);
+                messageObject = null;
+                openKeyboard = true;
+            }
             if (messageObject != null) {
                 String name;
                 if (messageObject.messageOwner.from_id > 0) {
@@ -2477,7 +2660,7 @@ public void showReplyPanel(boolean show, MessageObject messageObject, ArrayList<
                     }
                 }
                 replyNameTextView.setText(userNames);
-                if (type == -1 || type == 0) {
+                if (type == -1 || type == 0 || type == 10 || type == 11) {
                     if (messageObjects.size() == 1 && messageObjects.get(0).messageText != null) {
                         String mess = messageObjects.get(0).messageText.toString();
                         if (mess.length() > 150) {
@@ -2529,6 +2712,8 @@ public void showReplyPanel(boolean show, MessageObject messageObject, ArrayList<
                         replyNameTextView.setText(webPage.site_name);
                     } else if (webPage.title != null) {
                         replyNameTextView.setText(webPage.title);
+                    } else {
+                        replyNameTextView.setText(LocaleController.getString("LinkPreview", R.string.LinkPreview));
                     }
                     if (webPage.description != null) {
                         replyObjectTextView.setText(webPage.description);
@@ -2558,7 +2743,7 @@ public void showReplyPanel(boolean show, MessageObject messageObject, ArrayList<
             }
             replyNameTextView.setLayoutParams(layoutParams1);
             replyObjectTextView.setLayoutParams(layoutParams2);
-            chatActivityEnterView.showTopView(animated);
+            chatActivityEnterView.showTopView(animated, openKeyboard);
         } else {
             if (replyingMessageObject == null && forwardingMessages == null && foundWebPage == null) {
                 return;
@@ -2607,36 +2792,48 @@ private boolean sendSecretMessageRead(MessageObject messageObject) {
     private void clearChatData() {
         messages.clear();
         messagesByDays.clear();
-        messagesDict.clear();
-        progressView.setVisibility(View.VISIBLE);
+        waitingForLoad.clear();
+
+        progressView.setVisibility(chatAdapter.botInfoRow == -1 ? View.VISIBLE : View.INVISIBLE);
         chatListView.setEmptyView(null);
-        if (currentEncryptedChat == null) {
-            maxMessageId = Integer.MAX_VALUE;
-            minMessageId = Integer.MIN_VALUE;
-        } else {
-            maxMessageId = Integer.MIN_VALUE;
-            minMessageId = Integer.MAX_VALUE;
+        for (int a = 0; a < 2; a++) {
+            messagesDict[a].clear();
+            if (currentEncryptedChat == null) {
+                maxMessageId[a] = Integer.MAX_VALUE;
+                minMessageId[a] = Integer.MIN_VALUE;
+            } else {
+                maxMessageId[a] = Integer.MIN_VALUE;
+                minMessageId[a] = Integer.MAX_VALUE;
+            }
+            maxDate[a] = Integer.MIN_VALUE;
+            minDate[a] = 0;
+            endReached[a] = false;
+            cacheEndReached[a] = false;
+            forwardEndReached[a] = true;
         }
-        maxDate = Integer.MIN_VALUE;
-        minDate = 0;
-        forward_end_reached = true;
         first = true;
         firstLoading = true;
         loading = true;
-        endReached = false;
-        cacheEndReached = false;
         waitingForImportantLoad = false;
         startLoadFromMessageId = 0;
+        last_message_id = 0;
         needSelectFromMessageId = false;
         chatAdapter.notifyDataSetChanged();
     }
 
-    private void scrollToLastMessage() {
-        if (forward_end_reached && first_unread_id == 0 && startLoadFromMessageId == 0) {
-            chatLayoutManager.scrollToPositionWithOffset(messages.size() - 1, -100000 - chatListView.getPaddingTop());
+    private void scrollToLastMessage(boolean pagedown) {
+        if (forwardEndReached[0] && first_unread_id == 0 && startLoadFromMessageId == 0) {
+            if (pagedown && chatLayoutManager.findLastCompletelyVisibleItemPosition() == chatAdapter.getItemCount() - 1) {
+                showPagedownButton(false, true);
+                highlightMessageId = Integer.MAX_VALUE;
+                updateVisibleRows();
+            } else {
+                chatLayoutManager.scrollToPositionWithOffset(messages.size() - 1, -100000 - chatListView.getPaddingTop());
+            }
         } else {
             clearChatData();
-            MessagesController.getInstance().loadMessages(dialog_id, 30, 0, !cacheEndReached, 0, classGuid, 0, 0, channelMessagesImportant);
+            waitingForLoad.add(lastLoadIndex);
+            MessagesController.getInstance().loadMessages(dialog_id, 30, 0, true, 0, classGuid, 0, 0, channelMessagesImportant, lastLoadIndex++);
         }
     }
 
@@ -2672,6 +2869,7 @@ private void toggleMute(boolean instant) {
                     dialog.notify_settings.mute_until = Integer.MAX_VALUE;
                 }
                 NotificationsController.updateServerNotificationsSettings(dialog_id);
+                NotificationsController.getInstance().removeNotificationsForDialog(dialog_id);
             } else {
                 showDialog(AlertsCreator.createMuteAlert(getParentActivity(), dialog_id));
             }
@@ -2689,16 +2887,13 @@ private void toggleMute(boolean instant) {
         }
     }
 
-    private void scrollToMessageId(int id, int fromMessageId, boolean select) {
-        returnToMessageId = fromMessageId;
-        needSelectFromMessageId = select;
-
-        MessageObject object = messagesDict.get(id);
+    private void scrollToMessageId(int id, int fromMessageId, boolean select, int loadIndex) {
+        MessageObject object = messagesDict[loadIndex].get(id);
         boolean query = false;
         if (object != null) {
             int index = messages.indexOf(object);
             if (index != -1) {
-                if (needSelectFromMessageId) {
+                if (select) {
                     highlightMessageId = id;
                 } else {
                     highlightMessageId = Integer.MAX_VALUE;
@@ -2707,10 +2902,30 @@ private void scrollToMessageId(int id, int fromMessageId, boolean select) {
                 if (messages.get(messages.size() - 1) == object) {
                     chatLayoutManager.scrollToPositionWithOffset(0, -chatListView.getPaddingTop() - AndroidUtilities.dp(7) + yOffset);
                 } else {
-                    chatLayoutManager.scrollToPositionWithOffset(messages.size() - messages.indexOf(object), -chatListView.getPaddingTop() - AndroidUtilities.dp(7) + yOffset);
+                    chatLayoutManager.scrollToPositionWithOffset(chatAdapter.messagesStartRow + messages.size() - messages.indexOf(object) - 1, -chatListView.getPaddingTop() - AndroidUtilities.dp(7) + yOffset);
                 }
                 updateVisibleRows();
-                showPagedownButton(true, true);
+                boolean found = false;
+                int count = chatListView.getChildCount();
+                for (int a = 0; a < count; a++) {
+                    View view = chatListView.getChildAt(a);
+                    if (view instanceof ChatBaseCell) {
+                        ChatBaseCell cell = (ChatBaseCell) view;
+                        if (cell.getMessageObject() != null && cell.getMessageObject().getId() == object.getId()) {
+                            found = true;
+                            break;
+                        }
+                    } else if (view instanceof ChatActionCell) {
+                        ChatActionCell cell = (ChatActionCell) view;
+                        if (cell.getMessageObject() != null && cell.getMessageObject().getId() == object.getId()) {
+                            found = true;
+                            break;
+                        }
+                    }
+                }
+                if (!found) {
+                    showPagedownButton(true, true);
+                }
             } else {
                 query = true;
             }
@@ -2719,41 +2934,22 @@ private void scrollToMessageId(int id, int fromMessageId, boolean select) {
         }
 
         if (query) {
-            messagesDict.clear();
-            messagesByDays.clear();
-            messages.clear();
-            if (currentEncryptedChat == null) {
-                maxMessageId = Integer.MAX_VALUE;
-                minMessageId = Integer.MIN_VALUE;
-            } else {
-                maxMessageId = Integer.MIN_VALUE;
-                minMessageId = Integer.MAX_VALUE;
-            }
-            maxDate = Integer.MIN_VALUE;
-            endReached = false;
-            cacheEndReached = false;
-            loading = false;
-            firstLoading = true;
+            clearChatData();
             loadsCount = 0;
-            minDate = 0;
-            first = true;
             unread_to_load = 0;
             first_unread_id = 0;
-            last_message_id = 0;
-            forward_end_reached = true;
             loadingForward = false;
             unreadMessageObject = null;
             scrollToMessage = null;
             highlightMessageId = Integer.MAX_VALUE;
             scrollToMessagePosition = -10000;
-            loading = true;
             startLoadFromMessageId = id;
-            MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, startLoadFromMessageId, !cacheEndReached, 0, classGuid, 3, 0, channelMessagesImportant);
-            chatAdapter.notifyDataSetChanged();
-            progressView.setVisibility(View.VISIBLE);
-            chatListView.setEmptyView(null);
+            waitingForLoad.add(lastLoadIndex);
+            MessagesController.getInstance().loadMessages(loadIndex == 0 ? dialog_id : mergeDialogId, AndroidUtilities.isTablet() ? 30 : 20, startLoadFromMessageId, true, 0, classGuid, 3, 0, loadIndex == 0 ? channelMessagesImportant : 0, lastLoadIndex++);
             emptyViewContainer.setVisibility(View.INVISIBLE);
         }
+        returnToMessageId = fromMessageId;
+        needSelectFromMessageId = select;
     }
 
     private void showPagedownButton(boolean show, boolean animated) {
@@ -2761,26 +2957,40 @@ private void showPagedownButton(boolean show, boolean animated) {
             return;
         }
         if (show) {
-            if (pagedownButton.getVisibility() == View.INVISIBLE) {
+            if (pagedownButton.getTag() == null) {
+                if (pagedownButtonAnimation != null) {
+                    pagedownButtonAnimation.cancel();
+                    pagedownButtonAnimation = null;
+                }
                 if (animated) {
+                    if (ViewProxy.getTranslationY(pagedownButton) == 0) {
+                        ViewProxy.setTranslationY(pagedownButton, AndroidUtilities.dp(100));
+                    }
                     pagedownButton.setVisibility(View.VISIBLE);
-                    ViewProxy.setAlpha(pagedownButton, 0);
-                    ObjectAnimatorProxy.ofFloatProxy(pagedownButton, "alpha", 1.0f).setDuration(200).start();
+                    pagedownButton.setTag(1);
+                    pagedownButtonAnimation = ObjectAnimatorProxy.ofFloatProxy(pagedownButton, "translationY", 0).setDuration(200).start();
                 } else {
                     pagedownButton.setVisibility(View.VISIBLE);
                 }
             }
         } else {
             returnToMessageId = 0;
-            if (pagedownButton.getVisibility() == View.VISIBLE) {
+            if (pagedownButton.getTag() != null) {
+                pagedownButton.setTag(null);
+                if (pagedownButtonAnimation != null) {
+                    pagedownButtonAnimation.cancel();
+                    pagedownButtonAnimation = null;
+                }
                 if (animated) {
-                    ObjectAnimatorProxy.ofFloatProxy(pagedownButton, "alpha", 0.0f).setDuration(200).addListener(new AnimatorListenerAdapterProxy() {
+                    pagedownButtonAnimation = ObjectAnimatorProxy.ofFloatProxy(pagedownButton, "translationY", AndroidUtilities.dp(100)).setDuration(200).addListener(new AnimatorListenerAdapterProxy() {
                         @Override
                         public void onAnimationEnd(Object animation) {
+                            pagedownButton.clearAnimation();
                             pagedownButton.setVisibility(View.INVISIBLE);
                         }
                     }).start();
                 } else {
+                    pagedownButton.clearAnimation();
                     pagedownButton.setVisibility(View.INVISIBLE);
                 }
             }
@@ -2857,12 +3067,13 @@ private void checkActionBarMenu() {
     }
 
     private int updateOnlineCount() {
+        onlineCount = 0;
         if (!(info instanceof TLRPC.TL_chatFull)) {
             return 0;
         }
-        onlineCount = 0;
         int currentTime = ConnectionsManager.getInstance().getCurrentTime();
-        for (TLRPC.TL_chatParticipant participant : info.participants.participants) {
+        for (int a = 0; a < info.participants.participants.size(); a++) {
+            TLRPC.ChatParticipant participant = info.participants.participants.get(a);
             TLRPC.User user = MessagesController.getInstance().getUser(participant.user_id);
             if (user != null && user.status != null && (user.status.expires > currentTime || user.id == UserConfig.getClientUserId()) && user.status.expires > 10000) {
                 onlineCount++;
@@ -3002,40 +3213,90 @@ private int getMessageType(MessageObject messageObject) {
     }
 
     private void addToSelectedMessages(MessageObject messageObject) {
-        if (selectedMessagesIds.containsKey(messageObject.getId())) {
-            selectedMessagesIds.remove(messageObject.getId());
+        int index = messageObject.getDialogId() == dialog_id ? 0 : 1;
+        if (selectedMessagesIds[index].containsKey(messageObject.getId())) {
+            selectedMessagesIds[index].remove(messageObject.getId());
             if (messageObject.type == 0) {
-                selectedMessagesCanCopyIds.remove(messageObject.getId());
+                selectedMessagesCanCopyIds[index].remove(messageObject.getId());
             }
             if (!messageObject.canDeleteMessage(currentChat)) {
                 cantDeleteMessagesCount--;
             }
         } else {
-            selectedMessagesIds.put(messageObject.getId(), messageObject);
+            selectedMessagesIds[index].put(messageObject.getId(), messageObject);
             if (messageObject.type == 0) {
-                selectedMessagesCanCopyIds.put(messageObject.getId(), messageObject);
+                selectedMessagesCanCopyIds[index].put(messageObject.getId(), messageObject);
             }
             if (!messageObject.canDeleteMessage(currentChat)) {
                 cantDeleteMessagesCount++;
             }
         }
         if (actionBar.isActionModeShowed()) {
-            if (selectedMessagesIds.isEmpty()) {
+            if (selectedMessagesIds[0].isEmpty() && selectedMessagesIds[1].isEmpty()) {
                 actionBar.hideActionMode();
-            }
-            actionBar.createActionMode().getItem(copy).setVisibility(selectedMessagesCanCopyIds.size() != 0 ? View.VISIBLE : View.GONE);
-            actionBar.createActionMode().getItem(delete).setVisibility(cantDeleteMessagesCount == 0 ? View.VISIBLE : View.GONE);
-            if (actionBar.createActionMode().getItem(reply) != null) {
-                boolean allowChatActions = true;
-                if (isBroadcast || currentChat != null && (ChatObject.isNotInChat(currentChat) || ChatObject.isChannel(currentChat) && (currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) == 0 && (currentChat.flags & TLRPC.CHAT_FLAG_USER_IS_EDITOR) == 0)) {
-                    allowChatActions = false;
-                }
-                actionBar.createActionMode().getItem(reply).setVisibility(allowChatActions && selectedMessagesIds.size() == 1 ? View.VISIBLE : View.GONE);
-            }
-        }
-    }
-
-    private void processRowSelect(View view) {
+            } else {
+                int copyVisible = actionBar.createActionMode().getItem(copy).getVisibility();
+                actionBar.createActionMode().getItem(copy).setVisibility(selectedMessagesCanCopyIds[0].size() + selectedMessagesCanCopyIds[1].size() != 0 ? View.VISIBLE : View.GONE);
+                int newCopyVisible = actionBar.createActionMode().getItem(copy).getVisibility();
+                actionBar.createActionMode().getItem(delete).setVisibility(cantDeleteMessagesCount == 0 ? View.VISIBLE : View.GONE);
+                final ActionBarMenuItem replyItem = actionBar.createActionMode().getItem(reply);
+                if (replyItem != null) {
+                    boolean allowChatActions = true;
+                    if (isBroadcast || currentChat != null && (ChatObject.isNotInChat(currentChat) || ChatObject.isChannel(currentChat) && !currentChat.creator && !currentChat.editor && !currentChat.megagroup)) {
+                        allowChatActions = false;
+                    }
+                    final int newVisibility = allowChatActions && selectedMessagesIds[0].size() + selectedMessagesIds[1].size() == 1 ? View.VISIBLE : View.GONE;
+                    if (replyItem.getVisibility() != newVisibility) {
+                        if (replyButtonAnimation != null) {
+                            replyButtonAnimation.cancel();
+                            replyButtonAnimation = null;
+                        }
+                        if (copyVisible != newCopyVisible) {
+                            if (newVisibility == View.VISIBLE) {
+                                ViewProxy.setAlpha(replyItem, 1.0f);
+                                ViewProxy.setScaleX(replyItem, 1.0f);
+                            } else {
+                                ViewProxy.setAlpha(replyItem, 0.0f);
+                                ViewProxy.setScaleX(replyItem, 0.0f);
+                            }
+                            replyItem.setVisibility(newVisibility);
+                            replyItem.clearAnimation();
+                        } else {
+                            replyButtonAnimation = new AnimatorSetProxy();
+                            ViewProxy.setPivotX(replyItem, AndroidUtilities.dp(54));
+                            if (newVisibility == View.VISIBLE) {
+                                replyItem.setVisibility(newVisibility);
+                                replyButtonAnimation.playTogether(
+                                        ObjectAnimatorProxy.ofFloat(replyItem, "alpha", 1.0f),
+                                        ObjectAnimatorProxy.ofFloat(replyItem, "scaleX", 1.0f)
+                                );
+                            } else {
+                                replyButtonAnimation.playTogether(
+                                        ObjectAnimatorProxy.ofFloat(replyItem, "alpha", 0.0f),
+                                        ObjectAnimatorProxy.ofFloat(replyItem, "scaleX", 0.0f)
+                                );
+                            }
+                            replyButtonAnimation.setDuration(100);
+                            replyButtonAnimation.addListener(new AnimatorListenerAdapterProxy() {
+                                @Override
+                                public void onAnimationEnd(Object animation) {
+                                    if (replyButtonAnimation.equals(animation)) {
+                                        replyItem.clearAnimation();
+                                        if (newVisibility == View.GONE) {
+                                            replyItem.setVisibility(View.GONE);
+                                        }
+                                    }
+                                }
+                            });
+                            replyButtonAnimation.start();
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void processRowSelect(View view) {
         MessageObject message = null;
         if (view instanceof ChatBaseCell) {
             message = ((ChatBaseCell) view).getMessageObject();
@@ -3057,8 +3318,8 @@ private void updateActionModeTitle() {
         if (!actionBar.isActionModeShowed()) {
             return;
         }
-        if (!selectedMessagesIds.isEmpty()) {
-            selectedMessagesCountTextView.setText(String.format("%d", selectedMessagesIds.size()));
+        if (!selectedMessagesIds[0].isEmpty() || !selectedMessagesIds[1].isEmpty()) {
+            selectedMessagesCountTextView.setNumber(selectedMessagesIds[0].size() + selectedMessagesIds[1].size(), true);
         }
     }
 
@@ -3082,7 +3343,7 @@ private void updateTitle() {
     }
 
     private void updateBotButtons() {
-        if (headerItem == null || currentUser == null || currentEncryptedChat != null || (currentUser.flags & TLRPC.USER_FLAG_BOT) == 0) {
+        if (headerItem == null || currentUser == null || currentEncryptedChat != null || !currentUser.bot) {
             return;
         }
         boolean hasHelp = false;
@@ -3138,13 +3399,13 @@ private void updateSubtitle() {
         if (printString != null) {
             printString = TextUtils.replace(printString, new String[]{"..."}, new String[]{""});
         }
-        if (printString == null || printString.length() == 0 || ChatObject.isChannel(currentChat)) {
+        if (printString == null || printString.length() == 0 || ChatObject.isChannel(currentChat) && !currentChat.megagroup) {
             setTypingAnimation(false);
             if (currentChat != null) {
                 if (ChatObject.isChannel(currentChat)) {
-                    if ((currentChat.flags & TLRPC.CHAT_FLAG_IS_BROADCAST) == 0) {
+                    if (!currentChat.broadcast && !currentChat.megagroup && !(currentChat instanceof TLRPC.TL_channelForbidden)) {
                         onlineTextView.setText(LocaleController.getString("ShowDiscussion", R.string.ShowDiscussion));
-                        if (radioButton.getVisibility() != View.VISIBLE) {
+                        if (radioButton != null && radioButton.getVisibility() != View.VISIBLE) {
                             radioButton.setVisibility(View.VISIBLE);
                             onlineTextView.setLayoutParams(LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM, 74, 0, 0, 4));
                         }
@@ -3155,13 +3416,17 @@ private void updateSubtitle() {
                             String text = LocaleController.formatPluralString("Members", result[0]).replace(String.format("%d", result[0]), shortNumber);
                             onlineTextView.setText(text);
                         } else {
-                            if ((currentChat.flags & TLRPC.CHAT_FLAG_IS_PUBLIC) != 0) {
-                                onlineTextView.setText(LocaleController.getString("ChannelPublic", R.string.ChannelPublic).toLowerCase());
+                            if (currentChat.megagroup) {
+                                onlineTextView.setText(LocaleController.getString("Loading", R.string.Loading).toLowerCase());
                             } else {
-                                onlineTextView.setText(LocaleController.getString("ChannelPrivate", R.string.ChannelPrivate).toLowerCase());
+                                if ((currentChat.flags & TLRPC.CHAT_FLAG_IS_PUBLIC) != 0) {
+                                    onlineTextView.setText(LocaleController.getString("ChannelPublic", R.string.ChannelPublic).toLowerCase());
+                                } else {
+                                    onlineTextView.setText(LocaleController.getString("ChannelPrivate", R.string.ChannelPrivate).toLowerCase());
+                                }
                             }
                         }
-                        if (radioButton.getVisibility() != View.GONE) {
+                        if (radioButton != null && radioButton.getVisibility() != View.GONE) {
                             radioButton.setVisibility(View.GONE);
                             onlineTextView.setLayoutParams(LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.BOTTOM, 54, 0, 0, 4));
                         }
@@ -3191,7 +3456,7 @@ private void updateSubtitle() {
                 String newStatus;
                 if (currentUser.id == 333000 || currentUser.id == 777000) {
                     newStatus = LocaleController.getString("ServiceNotifications", R.string.ServiceNotifications);
-                } else if ((currentUser.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                } else if (currentUser.bot) {
                     newStatus = LocaleController.getString("Bot", R.string.Bot);
                 } else {
                     newStatus = LocaleController.formatUserStatus(currentUser);
@@ -3528,7 +3793,7 @@ public void restoreSelfArgs(Bundle args) {
 
     private void removeUnreadPlane() {
         if (unreadMessageObject != null) {
-            forward_end_reached = true;
+            forwardEndReached[0] = forwardEndReached[1] = true;
             first_unread_id = 0;
             last_message_id = 0;
             unread_to_load = 0;
@@ -3545,12 +3810,18 @@ public boolean processSendingText(String text) {
         return chatActivityEnterView.processSendingText(text);
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     public void didReceivedNotification(int id, final Object... args) {
         if (id == NotificationCenter.messagesDidLoaded) {
-            long did = (Long) args[0];
-            if (did == dialog_id) {
+            int guid = (Integer) args[11];
+            if (guid == classGuid) {
+                int queryLoadIndex = (Integer) args[12];
+                int index = waitingForLoad.indexOf(queryLoadIndex);
+                if (index == -1) {
+                    return;
+                } else {
+                    waitingForLoad.remove(index);
+                }
                 if (waitingForImportantLoad) {
                     int startLoadFrom = startLoadFromMessageId;
                     clearChatData();
@@ -3558,6 +3829,8 @@ public void didReceivedNotification(int id, final Object... args) {
                 }
 
                 loadsCount++;
+                long did = (Long) args[0];
+                int loadIndex = did == dialog_id ? 0 : 1;
                 int count = (Integer) args[1];
                 boolean isCache = (Boolean) args[3];
                 int fnid = (Integer) args[4];
@@ -3583,26 +3856,33 @@ public void didReceivedNotification(int id, final Object... args) {
                 }
                 int newRowsCount = 0;
 
-                forward_end_reached = startLoadFromMessageId == 0 && last_message_id == 0;
+                forwardEndReached[loadIndex] = startLoadFromMessageId == 0 && last_message_id == 0;
+                if ((load_type == 1 || load_type == 3) && loadIndex == 1) {
+                    endReached[0] = cacheEndReached[0] = true;
+                    forwardEndReached[0] = false;
+                    minMessageId[0] = 0;
+                }
 
                 if (loadsCount == 1 && messArr.size() > 20) {
                     loadsCount++;
                 }
 
                 if (firstLoading) {
-                    if (!forward_end_reached) {
+                    if (!forwardEndReached[loadIndex]) {
                         messages.clear();
                         messagesByDays.clear();
-                        messagesDict.clear();
-                        if (currentEncryptedChat == null) {
-                            maxMessageId = Integer.MAX_VALUE;
-                            minMessageId = Integer.MIN_VALUE;
-                        } else {
-                            maxMessageId = Integer.MIN_VALUE;
-                            minMessageId = Integer.MAX_VALUE;
+                        for (int a = 0; a < 2; a++) {
+                            messagesDict[a].clear();
+                            if (currentEncryptedChat == null) {
+                                maxMessageId[a] = Integer.MAX_VALUE;
+                                minMessageId[a] = Integer.MIN_VALUE;
+                            } else {
+                                maxMessageId[a] = Integer.MIN_VALUE;
+                                minMessageId[a] = Integer.MAX_VALUE;
+                            }
+                            maxDate[a] = Integer.MIN_VALUE;
+                            minDate[a] = 0;
                         }
-                        maxDate = Integer.MIN_VALUE;
-                        minDate = 0;
                     }
                     firstLoading = false;
                 }
@@ -3611,41 +3891,45 @@ public void didReceivedNotification(int id, final Object... args) {
                     Collections.reverse(messArr);
                 }
                 ReplyMessageQuery.loadReplyMessagesForMessages(messArr, dialog_id);
-
                 for (int a = 0; a < messArr.size(); a++) {
                     MessageObject obj = messArr.get(a);
-                    if (messagesDict.containsKey(obj.getId())) {
+                    if (messagesDict[loadIndex].containsKey(obj.getId())) {
                         continue;
                     }
-
+                    if (loadIndex == 1) {
+                        obj.setIsRead();
+                    }
+                    if (loadIndex == 0 && channelMessagesImportant != 0 && obj.getId() == 1) {
+                        endReached[loadIndex] = true;
+                        cacheEndReached[loadIndex] = true;
+                    }
                     if (obj.getId() > 0) {
-                        maxMessageId = Math.min(obj.getId(), maxMessageId);
-                        minMessageId = Math.max(obj.getId(), minMessageId);
+                        maxMessageId[loadIndex] = Math.min(obj.getId(), maxMessageId[loadIndex]);
+                        minMessageId[loadIndex] = Math.max(obj.getId(), minMessageId[loadIndex]);
                     } else if (currentEncryptedChat != null) {
-                        maxMessageId = Math.max(obj.getId(), maxMessageId);
-                        minMessageId = Math.min(obj.getId(), minMessageId);
+                        maxMessageId[loadIndex] = Math.max(obj.getId(), maxMessageId[loadIndex]);
+                        minMessageId[loadIndex] = Math.min(obj.getId(), minMessageId[loadIndex]);
                     }
                     if (obj.messageOwner.date != 0) {
-                        maxDate = Math.max(maxDate, obj.messageOwner.date);
-                        if (minDate == 0 || obj.messageOwner.date < minDate) {
-                            minDate = obj.messageOwner.date;
+                        maxDate[loadIndex] = Math.max(maxDate[loadIndex], obj.messageOwner.date);
+                        if (minDate[loadIndex] == 0 || obj.messageOwner.date < minDate[loadIndex]) {
+                            minDate[loadIndex] = obj.messageOwner.date;
                         }
                     }
 
-                    if (obj.type < 0) {
+                    if (obj.type < 0 || loadIndex == 1 && obj.messageOwner.action instanceof TLRPC.TL_messageActionChatMigrateTo) {
                         continue;
                     }
 
                     if (!obj.isOut() && obj.isUnread()) {
                         wasUnread = true;
                     }
-                    messagesDict.put(obj.getId(), obj);
+                    messagesDict[loadIndex].put(obj.getId(), obj);
                     ArrayList<MessageObject> dayArray = messagesByDays.get(obj.dateKey);
 
                     if (dayArray == null) {
                         dayArray = new ArrayList<>();
                         messagesByDays.put(obj.dateKey, dayArray);
-
                         TLRPC.Message dateMsg = new TLRPC.Message();
                         dateMsg.message = LocaleController.formatDateChat(obj.messageOwner.date);
                         dateMsg.id = 0;
@@ -3698,12 +3982,12 @@ public void didReceivedNotification(int id, final Object... args) {
                         dateMsg.id = 0;
                         MessageObject dateObj = new MessageObject(dateMsg, null, false);
                         dateObj.contentType = dateObj.type = 6;
-                        boolean dateAdded = true;
-                        if (a != messArr.size() - 1) {
-                            MessageObject next = messArr.get(a + 1);
-                            dateAdded = !next.dateKey.equals(obj.dateKey);
-                        }
-                        messages.add(messages.size() - (dateAdded ? 0 : 1), dateObj);
+                        //boolean dateAdded = true;
+                        //if (a != messArr.size() - 1) {
+                        //    MessageObject next = messArr.get(a + 1);
+                        //    dateAdded = !next.dateKey.equals(obj.dateKey);
+                        //}
+                        messages.add(messages.size() - 1, dateObj);
                         unreadMessageObject = dateObj;
                         scrollToMessage = unreadMessageObject;
                         scrollToMessagePosition = -10000;
@@ -3722,11 +4006,11 @@ public void didReceivedNotification(int id, final Object... args) {
                     }
 
                     if (obj.getId() == last_message_id) {
-                        forward_end_reached = true;
+                        forwardEndReached[loadIndex] = true;
                     }
                 }
 
-                if (forward_end_reached) {
+                if (forwardEndReached[loadIndex] && loadIndex != 1) {
                     first_unread_id = 0;
                     last_message_id = 0;
                 }
@@ -3739,26 +4023,39 @@ public void didReceivedNotification(int id, final Object... args) {
 
                 if (load_type == 1) {
                     if (messArr.size() != count && !isCache) {
-                        forward_end_reached = true;
-                        first_unread_id = 0;
-                        last_message_id = 0;
+                        forwardEndReached[loadIndex] = true;
+                        if (loadIndex != 1) {
+                            first_unread_id = 0;
+                            last_message_id = 0;
+                            chatAdapter.notifyItemRemoved(chatAdapter.getItemCount() - 1);
+                            newRowsCount--;
+                        }
                         startLoadFromMessageId = 0;
-                        chatAdapter.notifyItemRemoved(chatAdapter.getItemCount() - 1);
-                        newRowsCount--;
                     }
                     if (newRowsCount != 0) {
+                        int firstVisPos = chatLayoutManager.findLastVisibleItemPosition();
+                        int top = 0;
+                        if (firstVisPos != chatLayoutManager.getItemCount() - 1) {
+                            firstVisPos = RecyclerView.NO_POSITION;
+                        } else {
+                            View firstVisView = chatListView.getChildAt(chatListView.getChildCount() - 1);
+                            top = ((firstVisView == null) ? 0 : firstVisView.getTop()) - chatListView.getPaddingTop();
+                        }
                         chatAdapter.notifyItemRangeInserted(chatAdapter.getItemCount() - 1, newRowsCount);
+                        if (firstVisPos != RecyclerView.NO_POSITION) {
+                            chatLayoutManager.scrollToPositionWithOffset(firstVisPos, top);
+                        }
                     }
                     loadingForward = false;
                 } else {
-                    if (messArr.size() < count) {
+                    if (messArr.size() < count && load_type != 3) {
                         if (isCache) {
                             if (currentEncryptedChat != null || isBroadcast) {
-                                endReached = true;
+                                endReached[loadIndex] = true;
                             }
-                            cacheEndReached = true;
+                            cacheEndReached[loadIndex] = true;
                         } else {
-                            endReached = true;
+                            endReached[loadIndex] = true;
                         }
                     }
                     loading = false;
@@ -3779,7 +4076,7 @@ public void didReceivedNotification(int id, final Object... args) {
                                     if (messages.get(messages.size() - 1) == scrollToMessage || messages.get(messages.size() - 2) == scrollToMessage) {
                                         chatLayoutManager.scrollToPositionWithOffset((chatAdapter.isBot ? 1 : 0), -chatListView.getPaddingTop() - AndroidUtilities.dp(7) + yOffset);
                                     } else {
-                                        chatLayoutManager.scrollToPositionWithOffset(messages.size() - messages.indexOf(scrollToMessage) + (chatAdapter.isBot ? 1 : 0), -chatListView.getPaddingTop() - AndroidUtilities.dp(7) + yOffset);
+                                        chatLayoutManager.scrollToPositionWithOffset(chatAdapter.messagesStartRow + messages.size() - messages.indexOf(scrollToMessage) - 1, -chatListView.getPaddingTop() - AndroidUtilities.dp(7) + yOffset);
                                     }
                                 }
                                 chatListView.invalidate();
@@ -3787,25 +4084,27 @@ public void didReceivedNotification(int id, final Object... args) {
                                     showPagedownButton(true, true);
                                 }
                                 scrollToMessagePosition = -10000;
+                                scrollToMessage = null;
                             } else {
                                 moveScrollToLastMessage();
                             }
                         } else {
                             if (newRowsCount != 0) {
-                                if (endReached) {
+                                boolean end = false;
+                                if (endReached[loadIndex] && (loadIndex == 0 && mergeDialogId == 0 || loadIndex == 1)) {
+                                    end = true;
                                     chatAdapter.notifyItemRangeChanged(chatAdapter.isBot ? 1 : 0, 2);
                                 }
                                 int firstVisPos = chatLayoutManager.findLastVisibleItemPosition();
-                                if (firstVisPos == RecyclerView.NO_POSITION) {
-                                    firstVisPos = 0;
-                                }
                                 View firstVisView = chatListView.getChildAt(chatListView.getChildCount() - 1);
                                 int top = ((firstVisView == null) ? 0 : firstVisView.getTop()) - chatListView.getPaddingTop();
-                                if (newRowsCount - (endReached ? 1 : 0) > 0) {
-                                    chatAdapter.notifyItemRangeInserted((chatAdapter.isBot ? 2 : 1), newRowsCount - (endReached ? 1 : 0));
+                                if (newRowsCount - (end ? 1 : 0) > 0) {
+                                    chatAdapter.notifyItemRangeInserted((chatAdapter.isBot ? 2 : 1) + (end ? 0 : 1), newRowsCount - (end ? 1 : 0));
+                                }
+                                if (firstVisPos != -1) {
+                                    chatLayoutManager.scrollToPositionWithOffset(firstVisPos + newRowsCount - (end ? 1 : 0), top);
                                 }
-                                chatLayoutManager.scrollToPositionWithOffset(firstVisPos + newRowsCount - (endReached ? 1 : 0), top);
-                            } else if (endReached) {
+                            } else if (endReached[loadIndex] && (loadIndex == 0 && mergeDialogId == 0 || loadIndex == 1)) {
                                 chatAdapter.notifyItemRemoved(chatAdapter.isBot ? 1 : 0);
                             }
                         }
@@ -3818,7 +4117,9 @@ public void didReceivedNotification(int id, final Object... args) {
                         }
 
                         if (first) {
-                            chatListView.setEmptyView(emptyViewContainer);
+                            if (chatListView != null) {
+                                chatListView.setEmptyView(emptyViewContainer);
+                            }
                         }
                     } else {
                         scrollToTopOnResume = true;
@@ -3829,29 +4130,42 @@ public void didReceivedNotification(int id, final Object... args) {
                 }
 
                 if (first && messages.size() > 0) {
-                    final boolean wasUnreadFinal = wasUnread;
-                    final int last_unread_date_final = last_unread_date;
-                    final int lastid = messages.get(0).getId();
-                    AndroidUtilities.runOnUIThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            if (last_message_id != 0) {
-                                MessagesController.getInstance().markDialogAsRead(dialog_id, lastid, last_message_id, 0, last_unread_date_final, wasUnreadFinal, false);
-                            } else {
-                                MessagesController.getInstance().markDialogAsRead(dialog_id, lastid, minMessageId, 0, maxDate, wasUnreadFinal, false);
+                    if (loadIndex == 0) {
+                        final boolean wasUnreadFinal = wasUnread;
+                        final int last_unread_date_final = last_unread_date;
+                        final int lastid = messages.get(0).getId();
+                        AndroidUtilities.runOnUIThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (last_message_id != 0) {
+                                    MessagesController.getInstance().markDialogAsRead(dialog_id, lastid, last_message_id, last_unread_date_final, wasUnreadFinal, false);
+                                } else {
+                                    MessagesController.getInstance().markDialogAsRead(dialog_id, lastid, minMessageId[0], maxDate[0], wasUnreadFinal, false);
+                                }
                             }
-                        }
-                    }, 700);
+                        }, 700);
+                    }
                     first = false;
                 }
-                if (messages.isEmpty() && currentEncryptedChat == null && currentUser != null && (currentUser.flags & TLRPC.USER_FLAG_BOT) != 0 && botUser == null) {
+                if (messages.isEmpty() && currentEncryptedChat == null && currentUser != null && currentUser.bot && botUser == null) {
                     botUser = "";
                     updateBottomOverlay();
                 }
 
-                if (progressView != null) {
-                    progressView.setVisibility(View.INVISIBLE);
+                if (newRowsCount == 0 && currentEncryptedChat != null && !endReached[0]) {
+                    first = true;
+                    if (chatListView != null) {
+                        chatListView.setEmptyView(null);
+                    }
+                    if (emptyViewContainer != null) {
+                        emptyViewContainer.setVisibility(View.INVISIBLE);
+                    }
+                } else {
+                    if (progressView != null) {
+                        progressView.setVisibility(View.INVISIBLE);
+                    }
                 }
+                checkScrollForLoad();
             }
         } else if (id == NotificationCenter.emojiDidLoaded) {
             if (chatListView != null) {
@@ -3929,7 +4243,8 @@ public void run() {
                 }
 
                 ReplyMessageQuery.loadReplyMessagesForMessages(arr, dialog_id);
-                if (!forward_end_reached) {
+                boolean reloadMegagroup = false;
+                if (!forwardEndReached[0]) {
                     int currentMaxDate = Integer.MIN_VALUE;
                     int currentMinMsgId = Integer.MIN_VALUE;
                     if (currentEncryptedChat != null) {
@@ -3937,17 +4252,44 @@ public void run() {
                     }
                     boolean currentMarkAsRead = false;
 
-                    for (MessageObject obj : arr) {
+                    for (int a = 0; a < arr.size(); a++) {
+                        MessageObject obj = arr.get(a);
                         if (currentEncryptedChat != null && obj.messageOwner.action != null && obj.messageOwner.action instanceof TLRPC.TL_messageEncryptedAction &&
                                 obj.messageOwner.action.encryptedAction instanceof TLRPC.TL_decryptedMessageActionSetMessageTTL && timerDrawable != null) {
                             TLRPC.TL_decryptedMessageActionSetMessageTTL action = (TLRPC.TL_decryptedMessageActionSetMessageTTL) obj.messageOwner.action.encryptedAction;
                             timerDrawable.setTime(action.ttl_seconds);
                         }
+                        if (obj.messageOwner.action instanceof TLRPC.TL_messageActionChatMigrateTo) {
+                            final Bundle bundle = new Bundle();
+                            bundle.putInt("chat_id", obj.messageOwner.action.channel_id);
+                            final BaseFragment lastFragment = parentLayout.fragmentsStack.size() > 0 ? parentLayout.fragmentsStack.get(parentLayout.fragmentsStack.size() - 1) : null;
+                            final int channel_id = obj.messageOwner.action.channel_id;
+                            AndroidUtilities.runOnUIThread(new Runnable() {
+                                @Override
+                                public void run() {
+                                    ActionBarLayout parentLayout = ChatActivity.this.parentLayout;
+                                    if (lastFragment != null) {
+                                        NotificationCenter.getInstance().removeObserver(lastFragment, NotificationCenter.closeChats);
+                                    }
+                                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
+                                    parentLayout.presentFragment(new ChatActivity(bundle), true);
+                                    AndroidUtilities.runOnUIThread(new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            MessagesController.getInstance().loadFullChat(channel_id, 0, true);
+                                        }
+                                    }, 1000);
+                                }
+                            });
+                            return;
+                        } else if (currentChat != null && currentChat.megagroup && (obj.messageOwner.action instanceof TLRPC.TL_messageActionChatAddUser || obj.messageOwner.action instanceof TLRPC.TL_messageActionChatDeleteUser)) {
+                            reloadMegagroup = true;
+                        }
                         if (obj.isOut() && obj.isSending()) {
-                            scrollToLastMessage();
+                            scrollToLastMessage(false);
                             return;
                         }
-                        if (messagesDict.containsKey(obj.getId())) {
+                        if (messagesDict[0].containsKey(obj.getId())) {
                             continue;
                         }
                         currentMaxDate = Math.max(currentMaxDate, obj.messageOwner.date);
@@ -3975,7 +4317,7 @@ public void run() {
                             readWithMid = currentMinMsgId;
                         } else {
                             if (messages.size() > 0) {
-                                MessagesController.getInstance().markDialogAsRead(dialog_id, messages.get(0).getId(), currentMinMsgId, 0, currentMaxDate, true, false);
+                                MessagesController.getInstance().markDialogAsRead(dialog_id, messages.get(0).getId(), currentMinMsgId, currentMaxDate, true, false);
                             }
                         }
                     }
@@ -3985,17 +4327,44 @@ public void run() {
                     boolean unreadUpdated = true;
                     int oldCount = messages.size();
                     int addedCount = 0;
-                    for (MessageObject obj : arr) {
+                    for (int a = 0; a < arr.size(); a++) {
+                        MessageObject obj = arr.get(a);
                         if (currentEncryptedChat != null && obj.messageOwner.action != null && obj.messageOwner.action instanceof TLRPC.TL_messageEncryptedAction &&
                                 obj.messageOwner.action.encryptedAction instanceof TLRPC.TL_decryptedMessageActionSetMessageTTL && timerDrawable != null) {
                             TLRPC.TL_decryptedMessageActionSetMessageTTL action = (TLRPC.TL_decryptedMessageActionSetMessageTTL) obj.messageOwner.action.encryptedAction;
                             timerDrawable.setTime(action.ttl_seconds);
                         }
-                        if (messagesDict.containsKey(obj.getId())) {
+                        if (messagesDict[0].containsKey(obj.getId())) {
                             continue;
                         }
-                        if (minDate == 0 || obj.messageOwner.date < minDate) {
-                            minDate = obj.messageOwner.date;
+                        if (obj.messageOwner.action instanceof TLRPC.TL_messageActionChatMigrateTo) {
+                            final Bundle bundle = new Bundle();
+                            bundle.putInt("chat_id", obj.messageOwner.action.channel_id);
+                            final BaseFragment lastFragment = parentLayout.fragmentsStack.size() > 0 ? parentLayout.fragmentsStack.get(parentLayout.fragmentsStack.size() - 1) : null;
+                            final int channel_id = obj.messageOwner.action.channel_id;
+                            AndroidUtilities.runOnUIThread(new Runnable() {
+                                @Override
+                                public void run() {
+                                    ActionBarLayout parentLayout = ChatActivity.this.parentLayout;
+                                    if (lastFragment != null) {
+                                        NotificationCenter.getInstance().removeObserver(lastFragment, NotificationCenter.closeChats);
+                                    }
+                                    NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
+                                    parentLayout.presentFragment(new ChatActivity(bundle), true);
+                                    AndroidUtilities.runOnUIThread(new Runnable() {
+                                        @Override
+                                        public void run() {
+                                            MessagesController.getInstance().loadFullChat(channel_id, 0, true);
+                                        }
+                                    }, 1000);
+                                }
+                            });
+                            return;
+                        } else if (currentChat != null && currentChat.megagroup && (obj.messageOwner.action instanceof TLRPC.TL_messageActionChatAddUser || obj.messageOwner.action instanceof TLRPC.TL_messageActionChatDeleteUser)) {
+                            reloadMegagroup = true;
+                        }
+                        if (minDate[0] == 0 || obj.messageOwner.date < minDate[0]) {
+                            minDate[0] = obj.messageOwner.date;
                         }
 
                         if (obj.isOut()) {
@@ -4004,19 +4373,18 @@ public void run() {
                         }
 
                         if (obj.getId() > 0) {
-                            maxMessageId = Math.min(obj.getId(), maxMessageId);
-                            minMessageId = Math.max(obj.getId(), minMessageId);
+                            maxMessageId[0] = Math.min(obj.getId(), maxMessageId[0]);
+                            minMessageId[0] = Math.max(obj.getId(), minMessageId[0]);
                         } else if (currentEncryptedChat != null) {
-                            maxMessageId = Math.max(obj.getId(), maxMessageId);
-                            minMessageId = Math.min(obj.getId(), minMessageId);
+                            maxMessageId[0] = Math.max(obj.getId(), maxMessageId[0]);
+                            minMessageId[0] = Math.min(obj.getId(), minMessageId[0]);
                         }
-                        maxDate = Math.max(maxDate, obj.messageOwner.date);
-                        messagesDict.put(obj.getId(), obj);
+                        maxDate[0] = Math.max(maxDate[0], obj.messageOwner.date);
+                        messagesDict[0].put(obj.getId(), obj);
                         ArrayList<MessageObject> dayArray = messagesByDays.get(obj.dateKey);
                         if (dayArray == null) {
                             dayArray = new ArrayList<>();
                             messagesByDays.put(obj.dateKey, dayArray);
-
                             TLRPC.Message dateMsg = new TLRPC.Message();
                             dateMsg.message = LocaleController.formatDateChat(obj.messageOwner.date);
                             dateMsg.id = 0;
@@ -4091,13 +4459,13 @@ public void run() {
                         if (lastVisible == RecyclerView.NO_POSITION) {
                             lastVisible = 0;
                         }
-                        if (endReached) {
+                        if (endReached[0]) {
                             lastVisible++;
                         }
                         if (chatAdapter.isBot) {
                             oldCount++;
                         }
-                        if (lastVisible == oldCount || hasFromMe) {
+                        if (lastVisible >= oldCount || hasFromMe) {
                             if (!firstLoading) {
                                 if (paused) {
                                     scrollToTopOnResume = true;
@@ -4115,10 +4483,10 @@ public void run() {
                     if (markAsRead) {
                         if (paused) {
                             readWhenResume = true;
-                            readWithDate = maxDate;
-                            readWithMid = minMessageId;
+                            readWithDate = maxDate[0];
+                            readWithMid = minMessageId[0];
                         } else {
-                            MessagesController.getInstance().markDialogAsRead(dialog_id, messages.get(0).getId(), minMessageId, 0, maxDate, true, false);
+                            MessagesController.getInstance().markDialogAsRead(dialog_id, messages.get(0).getId(), minMessageId[0], maxDate[0], true, false);
                         }
                     }
                 }
@@ -4130,6 +4498,9 @@ public void run() {
                     updateTitle();
                     checkAndUpdateAvatar();
                 }
+                if (reloadMegagroup) {
+                    MessagesController.getInstance().loadFullChat(currentChat.id, 0, true);
+                }
             }
         } else if (id == NotificationCenter.closeChats) {
             if (args != null && args.length > 0) {
@@ -4186,35 +4557,43 @@ public void run() {
         } else if (id == NotificationCenter.messagesDeleted) {
             ArrayList<Integer> markAsDeletedMessages = (ArrayList<Integer>) args[0];
             int channelId = (Integer) args[1];
+            int loadIndex = 0;
             if (ChatObject.isChannel(currentChat)) {
-                if (channelId == 0 || channelId != currentChat.id) {
+                if (channelId == 0 && mergeDialogId != 0) {
+                    loadIndex = 1;
+                } else if (channelId == currentChat.id) {
+                    loadIndex = 0;
+                } else {
                     return;
                 }
             } else if (channelId != 0) {
                 return;
             }
             boolean updated = false;
-            for (Integer ids : markAsDeletedMessages) {
-                MessageObject obj = messagesDict.get(ids);
+            for (int a = 0; a < markAsDeletedMessages.size(); a++) {
+                Integer ids = markAsDeletedMessages.get(a);
+                MessageObject obj = messagesDict[loadIndex].get(ids);
                 if (obj != null) {
                     int index = messages.indexOf(obj);
                     if (index != -1) {
                         messages.remove(index);
-                        messagesDict.remove(ids);
+                        messagesDict[loadIndex].remove(ids);
                         ArrayList<MessageObject> dayArr = messagesByDays.get(obj.dateKey);
-                        dayArr.remove(obj);
-                        if (dayArr.isEmpty()) {
-                            messagesByDays.remove(obj.dateKey);
-                            if (index >= 0 && index < messages.size()) { //TODO fix it
-                                messages.remove(index);
+                        if (dayArr != null) {
+                            dayArr.remove(obj);
+                            if (dayArr.isEmpty()) {
+                                messagesByDays.remove(obj.dateKey);
+                                if (index >= 0 && index < messages.size()) {
+                                    messages.remove(index);
+                                }
                             }
+                            updated = true;
                         }
-                        updated = true;
                     }
                 }
             }
             if (messages.isEmpty()) {
-                if (!endReached && !loading) {
+                if (!endReached[0] && !loading) {
                     if (progressView != null) {
                         progressView.setVisibility(View.INVISIBLE);
                     }
@@ -4222,15 +4601,16 @@ public void run() {
                         chatListView.setEmptyView(null);
                     }
                     if (currentEncryptedChat == null) {
-                        maxMessageId = Integer.MAX_VALUE;
-                        minMessageId = Integer.MIN_VALUE;
+                        maxMessageId[0] = maxMessageId[1] = Integer.MAX_VALUE;
+                        minMessageId[0] = minMessageId[1] = Integer.MIN_VALUE;
                     } else {
-                        maxMessageId = Integer.MIN_VALUE;
-                        minMessageId = Integer.MAX_VALUE;
+                        maxMessageId[0] = maxMessageId[1] = Integer.MIN_VALUE;
+                        minMessageId[0] = minMessageId[1] = Integer.MAX_VALUE;
                     }
-                    maxDate = Integer.MIN_VALUE;
-                    minDate = 0;
-                    MessagesController.getInstance().loadMessages(dialog_id, 30, 0, !cacheEndReached, minDate, classGuid, 0, 0, channelMessagesImportant);
+                    maxDate[0] = maxDate[1] = Integer.MIN_VALUE;
+                    minDate[0] = minDate[1] = 0;
+                    waitingForLoad.add(lastLoadIndex);
+                    MessagesController.getInstance().loadMessages(dialog_id, 30, 0, !cacheEndReached[0], minDate[0], classGuid, 0, 0, channelMessagesImportant, lastLoadIndex++);
                     loading = true;
                 } else {
                     if (botButtons != null) {
@@ -4239,7 +4619,7 @@ public void run() {
                             chatActivityEnterView.setButtons(null, false);
                         }
                     }
-                    if (currentEncryptedChat == null && currentUser != null && (currentUser.flags & TLRPC.USER_FLAG_BOT) != 0 && botUser == null) {
+                    if (currentEncryptedChat == null && currentUser != null && currentUser.bot && botUser == null) {
                         botUser = "";
                         updateBottomOverlay();
                     }
@@ -4251,9 +4631,26 @@ public void run() {
             }
         } else if (id == NotificationCenter.messageReceivedByServer) {
             Integer msgId = (Integer) args[0];
-            MessageObject obj = messagesDict.get(msgId);
+            MessageObject obj = messagesDict[0].get(msgId);
             if (obj != null) {
                 Integer newMsgId = (Integer) args[1];
+                if (!newMsgId.equals(msgId) && messagesDict[0].containsKey(newMsgId)) {
+                    MessageObject removed = messagesDict[0].remove(msgId);
+                    if (removed != null) {
+                        int index = messages.indexOf(removed);
+                        messages.remove(index);
+                        ArrayList<MessageObject> dayArr = messagesByDays.get(removed.dateKey);
+                        dayArr.remove(obj);
+                        if (dayArr.isEmpty()) {
+                            messagesByDays.remove(obj.dateKey);
+                            if (index >= 0 && index < messages.size()) {
+                                messages.remove(index);
+                            }
+                        }
+                        chatAdapter.notifyDataSetChanged();
+                    }
+                    return;
+                }
                 TLRPC.Message newMsgObj = (TLRPC.Message) args[2];
                 boolean mediaUpdated = false;
                 try {
@@ -4265,27 +4662,15 @@ public void run() {
                     obj.messageOwner.media = newMsgObj.media;
                     obj.generateThumbs(true);
                 }
-                int oldCount = messagesDict.size();
-                MessageObject removed = messagesDict.remove(msgId);
-                messagesDict.put(newMsgId, obj);
+                messagesDict[0].remove(msgId);
+                messagesDict[0].put(newMsgId, obj);
                 obj.messageOwner.id = newMsgId;
                 obj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SENT;
                 ArrayList<MessageObject> messArr = new ArrayList<>();
                 messArr.add(obj);
                 ReplyMessageQuery.loadReplyMessagesForMessages(messArr, dialog_id);
-                updateVisibleRows();
-                if (oldCount != messagesDict.size()) {
-                    int index = messages.indexOf(removed);
-                    messages.remove(index);
-                    ArrayList<MessageObject> dayArr = messagesByDays.get(removed.dateKey);
-                    dayArr.remove(obj);
-                    if (dayArr.isEmpty()) {
-                        messagesByDays.remove(obj.dateKey);
-                        if (index >= 0 && index < messages.size()) {
-                            messages.remove(index);
-                        }
-                    }
-                    chatAdapter.notifyDataSetChanged();
+                if (chatAdapter != null) {
+                    chatAdapter.updateRowWithMessageObject(obj);
                 }
                 if (mediaUpdated && chatLayoutManager.findLastVisibleItemPosition() >= messages.size() - 1) {
                     moveScrollToLastMessage();
@@ -4294,14 +4679,16 @@ public void run() {
             }
         } else if (id == NotificationCenter.messageReceivedByAck) {
             Integer msgId = (Integer) args[0];
-            MessageObject obj = messagesDict.get(msgId);
+            MessageObject obj = messagesDict[0].get(msgId);
             if (obj != null) {
                 obj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SENT;
-                updateVisibleRows();
+                if (chatAdapter != null) {
+                    chatAdapter.updateRowWithMessageObject(obj);
+                }
             }
         } else if (id == NotificationCenter.messageSendError) {
             Integer msgId = (Integer) args[0];
-            MessageObject obj = messagesDict.get(msgId);
+            MessageObject obj = messagesDict[0].get(msgId);
             if (obj != null) {
                 obj.messageOwner.send_state = MessageObject.MESSAGE_SEND_STATE_SEND_ERROR;
                 updateVisibleRows();
@@ -4309,6 +4696,22 @@ public void run() {
         } else if (id == NotificationCenter.chatInfoDidLoaded) {
             TLRPC.ChatFull chatFull = (TLRPC.ChatFull) args[0];
             if (currentChat != null && chatFull.id == currentChat.id) {
+                if (chatFull instanceof TLRPC.TL_channelFull) {
+                    if (currentChat.megagroup) {
+                        int lastDate = 0;
+                        if (chatFull.participants != null) {
+                            for (int a = 0; a < chatFull.participants.participants.size(); a++) {
+                                lastDate = Math.max(chatFull.participants.participants.get(a).date, lastDate);
+                            }
+                        }
+                        if (lastDate == 0 || Math.abs(System.currentTimeMillis() / 1000 - lastDate) > 60 * 60) {
+                            MessagesController.getInstance().loadChannelParticipants(currentChat.id);
+                        }
+                    }
+                    if (chatFull.participants == null && info != null) {
+                        chatFull.participants = info.participants;
+                    }
+                }
                 info = chatFull;
                 if (mentionsAdapter != null) {
                     mentionsAdapter.setChatInfo(info);
@@ -4322,14 +4725,38 @@ public void run() {
                     hasBotsCommands = false;
                     botInfo.clear();
                     botsCount = 0;
+                    URLSpanBotCommand.enabled = false;
                     for (int a = 0; a < info.participants.participants.size(); a++) {
-                        TLRPC.TL_chatParticipant participant = info.participants.participants.get(a);
+                        TLRPC.ChatParticipant participant = info.participants.participants.get(a);
                         TLRPC.User user = MessagesController.getInstance().getUser(participant.user_id);
-                        if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                        if (user != null && user.bot) {
+                            URLSpanBotCommand.enabled = true;
                             botsCount++;
                             BotQuery.loadBotInfo(user.id, true, classGuid);
                         }
                     }
+                    if (chatListView != null) {
+                        chatListView.invalidateViews();
+                    }
+                } else if (info instanceof TLRPC.TL_channelFull) {
+                    hasBotsCommands = false;
+                    botInfo.clear();
+                    botsCount = 0;
+                    URLSpanBotCommand.enabled = !info.bot_info.isEmpty();
+                    botsCount = info.bot_info.size();
+                    for (int a = 0; a < info.bot_info.size(); a++) {
+                        TLRPC.BotInfo bot = info.bot_info.get(a);
+                        if (!bot.commands.isEmpty()) {
+                            hasBotsCommands = true;
+                        }
+                        botInfo.put(bot.user_id, bot);
+                    }
+                    if (chatListView != null) {
+                        chatListView.invalidateViews();
+                    }
+                    if (mentionsAdapter != null) {
+                        mentionsAdapter.setBotInfo(botInfo);
+                    }
                 }
                 if (chatActivityEnterView != null) {
                     chatActivityEnterView.setBotsCount(botsCount, hasBotsCommands);
@@ -4337,6 +4764,13 @@ public void run() {
                 if (mentionsAdapter != null) {
                     mentionsAdapter.setBotsCount(botsCount);
                 }
+                if (ChatObject.isChannel(currentChat) && mergeDialogId == 0 && info.migrated_from_chat_id != 0) {
+                    mergeDialogId = -info.migrated_from_chat_id;
+                    maxMessageId[1] = info.migrated_from_max_id;
+                    if (chatAdapter != null) {
+                        chatAdapter.notifyDataSetChanged();
+                    }
+                }
             }
         } else if (id == NotificationCenter.chatInfoCantLoad) {
             int chatId = (Integer) args[0];
@@ -4386,22 +4820,19 @@ public void run() {
                 updateVisibleRows();
             }
         } else if (id == NotificationCenter.audioDidReset || id == NotificationCenter.audioPlayStateChanged) {
-            Integer mid = (Integer) args[0];
             if (chatListView != null) {
                 int count = chatListView.getChildCount();
                 for (int a = 0; a < count; a++) {
                     View view = chatListView.getChildAt(a);
                     if (view instanceof ChatAudioCell) {
                         ChatAudioCell cell = (ChatAudioCell) view;
-                        if (cell.getMessageObject() != null && cell.getMessageObject().getId() == mid) {
+                        if (cell.getMessageObject() != null) {
                             cell.updateButtonState(false);
-                            break;
                         }
                     } else if (view instanceof ChatMusicCell) {
                         ChatMusicCell cell = (ChatMusicCell) view;
-                        if (cell.getMessageObject() != null && cell.getMessageObject().getId() == mid) {
+                        if (cell.getMessageObject() != null) {
                             cell.updateButtonState(false);
-                            break;
                         }
                     }
                 }
@@ -4436,21 +4867,23 @@ public void run() {
         } else if (id == NotificationCenter.removeAllMessagesFromDialog) {
             long did = (Long) args[0];
             if (dialog_id == did) {
-                boolean reload = (Boolean) args[1];
                 messages.clear();
+                waitingForLoad.clear();
                 messagesByDays.clear();
-                messagesDict.clear();
-                if (currentEncryptedChat == null) {
-                    maxMessageId = Integer.MAX_VALUE;
-                    minMessageId = Integer.MIN_VALUE;
-                } else {
-                    maxMessageId = Integer.MIN_VALUE;
-                    minMessageId = Integer.MAX_VALUE;
+                for (int a = 1; a >= 0; a--) {
+                    messagesDict[a].clear();
+                    if (currentEncryptedChat == null) {
+                        maxMessageId[a] = Integer.MAX_VALUE;
+                        minMessageId[a] = Integer.MIN_VALUE;
+                    } else {
+                        maxMessageId[a] = Integer.MIN_VALUE;
+                        minMessageId[a] = Integer.MAX_VALUE;
+                    }
+                    maxDate[a] = Integer.MIN_VALUE;
+                    minDate[a] = 0;
+                    selectedMessagesIds[a].clear();
+                    selectedMessagesCanCopyIds[a].clear();
                 }
-                maxDate = Integer.MIN_VALUE;
-                minDate = 0;
-                selectedMessagesIds.clear();
-                selectedMessagesCanCopyIds.clear();
                 cantDeleteMessagesCount = 0;
                 actionBar.hideActionMode();
 
@@ -4458,25 +4891,26 @@ public void run() {
                     botButtons = null;
                     chatActivityEnterView.setButtons(null, false);
                 }
-                if (currentEncryptedChat == null && currentUser != null && (currentUser.flags & TLRPC.USER_FLAG_BOT) != 0 && botUser == null) {
+                if (currentEncryptedChat == null && currentUser != null && currentUser.bot && botUser == null) {
                     botUser = "";
                     updateBottomOverlay();
                 }
-                if (reload) {
-                    if (progressView != null) {
-                        progressView.setVisibility(View.VISIBLE);
-                        chatListView.setEmptyView(null);
+                if ((Boolean) args[1]) {
+                    progressView.setVisibility(chatAdapter.botInfoRow == -1 ? View.VISIBLE : View.INVISIBLE);
+                    chatListView.setEmptyView(null);
+                    for (int a = 0; a < 2; a++) {
+                        endReached[a] = false;
+                        cacheEndReached[a] = false;
+                        forwardEndReached[a] = true;
                     }
-                    forward_end_reached = true;
                     first = true;
                     firstLoading = true;
                     loading = true;
-                    endReached = false;
-                    cacheEndReached = false;
                     waitingForImportantLoad = false;
                     startLoadFromMessageId = 0;
                     needSelectFromMessageId = false;
-                    MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, 0, !cacheEndReached, 0, classGuid, 2, 0, channelMessagesImportant);
+                    waitingForLoad.add(lastLoadIndex);
+                    MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, 0, true, 0, classGuid, 2, 0, channelMessagesImportant, lastLoadIndex++);
                 } else {
                     if (progressView != null) {
                         progressView.setVisibility(View.INVISIBLE);
@@ -4503,7 +4937,7 @@ public void run() {
             MessageObject messageObject = (MessageObject) args[0];
             long finalSize = (Long) args[2];
             if (finalSize != 0 && dialog_id == messageObject.getDialogId()) {
-                MessageObject currentObject = messagesDict.get(messageObject.getId());
+                MessageObject currentObject = messagesDict[0].get(messageObject.getId());
                 if (currentObject != null) {
                     currentObject.messageOwner.media.video.size = (int) finalSize;
                     updateVisibleRows();
@@ -4516,7 +4950,7 @@ public void run() {
                 int key = mids.keyAt(i);
                 ArrayList<Integer> arr = mids.get(key);
                 for (Integer mid : arr) {
-                    MessageObject messageObject = messagesDict.get(mid);
+                    MessageObject messageObject = messagesDict[0].get(mid);
                     if (messageObject != null) {
                         messageObject.messageOwner.destroyTime = key;
                         changed = true;
@@ -4529,30 +4963,26 @@ public void run() {
         } else if (id == NotificationCenter.audioDidStarted) {
             MessageObject messageObject = (MessageObject) args[0];
             sendSecretMessageRead(messageObject);
-
-            int mid = messageObject.getId();
             if (chatListView != null) {
                 int count = chatListView.getChildCount();
                 for (int a = 0; a < count; a++) {
                     View view = chatListView.getChildAt(a);
                     if (view instanceof ChatAudioCell) {
                         ChatAudioCell cell = (ChatAudioCell) view;
-                        if (cell.getMessageObject() != null && cell.getMessageObject().getId() == mid) {
+                        if (cell.getMessageObject() != null) {
                             cell.updateButtonState(false);
-                            break;
                         }
                     } else if (view instanceof ChatMusicCell) {
                         ChatMusicCell cell = (ChatMusicCell) view;
-                        if (cell.getMessageObject() != null && cell.getMessageObject().getId() == mid) {
+                        if (cell.getMessageObject() != null) {
                             cell.updateButtonState(false);
-                            break;
                         }
                     }
                 }
             }
         } else if (id == NotificationCenter.updateMessageMedia) {
             MessageObject messageObject = (MessageObject) args[0];
-            MessageObject existMessageObject = messagesDict.get(messageObject.getId());
+            MessageObject existMessageObject = messagesDict[0].get(messageObject.getId());
             if (existMessageObject != null) {
                 existMessageObject.messageOwner.media = messageObject.messageOwner.media;
                 existMessageObject.messageOwner.attachPath = messageObject.messageOwner.attachPath;
@@ -4560,31 +4990,34 @@ public void run() {
             }
             updateVisibleRows();
         } else if (id == NotificationCenter.replaceMessagesObjects) {
-            if (dialog_id == (long) args[0]) {
-                boolean changed = false;
-                boolean mediaUpdated = false;
-                ArrayList<MessageObject> messageObjects = (ArrayList<MessageObject>) args[1];
-                for (MessageObject messageObject : messageObjects) {
-                    MessageObject old = messagesDict.get(messageObject.getId());
-                    if (old != null) {
-                        if (!mediaUpdated && messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaWebPage) {
-                            mediaUpdated = true;
-                        }
-                        messagesDict.put(old.getId(), messageObject);
-                        int index = messages.indexOf(old);
-                        if (index >= 0) {
-                            messages.set(index, messageObject);
-                            if (chatAdapter != null) {
-                                chatAdapter.notifyItemChanged(chatAdapter.messagesStartRow + messages.size() - index - 1);
-                            }
-                            changed = true;
+            long did = (long) args[0];
+            if (did != dialog_id && did != mergeDialogId) {
+                return;
+            }
+            int loadIndex = did == dialog_id ? 0 : 1;
+            boolean changed = false;
+            boolean mediaUpdated = false;
+            ArrayList<MessageObject> messageObjects = (ArrayList<MessageObject>) args[1];
+            for (MessageObject messageObject : messageObjects) {
+                MessageObject old = messagesDict[loadIndex].get(messageObject.getId());
+                if (old != null) {
+                    if (!mediaUpdated && messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaWebPage) {
+                        mediaUpdated = true;
+                    }
+                    messagesDict[loadIndex].put(old.getId(), messageObject);
+                    int index = messages.indexOf(old);
+                    if (index >= 0) {
+                        messages.set(index, messageObject);
+                        if (chatAdapter != null) {
+                            chatAdapter.notifyItemChanged(chatAdapter.messagesStartRow + messages.size() - index - 1);
                         }
+                        changed = true;
                     }
                 }
-                if (changed) {
-                    if (mediaUpdated && chatLayoutManager.findLastVisibleItemPosition() >= messages.size() - (chatAdapter.isBot ? 2 : 1)) {
-                        moveScrollToLastMessage();
-                    }
+            }
+            if (changed && chatLayoutManager != null) {
+                if (mediaUpdated && chatLayoutManager.findLastVisibleItemPosition() >= messages.size() - (chatAdapter.isBot ? 2 : 1)) {
+                    moveScrollToLastMessage();
                 }
             }
         } else if (id == NotificationCenter.notificationsSettingsUpdated) {
@@ -4600,8 +5033,13 @@ public void run() {
         } else if (id == NotificationCenter.didReceivedWebpages) {
             ArrayList<TLRPC.Message> arrayList = (ArrayList<TLRPC.Message>) args[0];
             boolean updated = false;
-            for (TLRPC.Message message : arrayList) {
-                MessageObject currentMessage = messagesDict.get(message.id);
+            for (int a = 0; a < arrayList.size(); a++) {
+                TLRPC.Message message = arrayList.get(a);
+                long did = MessageObject.getDialogId(message);
+                if (did != dialog_id && did != mergeDialogId) {
+                    continue;
+                }
+                MessageObject currentMessage = messagesDict[did == dialog_id ? 0 : 1].get(message.id);
                 if (currentMessage != null) {
                     currentMessage.messageOwner.media = new TLRPC.TL_messageMediaWebPage();
                     currentMessage.messageOwner.media.webpage = message.media.webpage;
@@ -4628,8 +5066,9 @@ public void run() {
         } else if (id == NotificationCenter.messagesReadContent) {
             ArrayList<Long> arrayList = (ArrayList<Long>) args[0];
             boolean updated = false;
-            for (long mid : arrayList) {
-                MessageObject currentMessage = messagesDict.get((int) mid);
+            for (int a = 0; a < arrayList.size(); a++) {
+                long mid = arrayList.get(a);
+                MessageObject currentMessage = messagesDict[0].get((int) mid);
                 if (currentMessage != null) {
                     currentMessage.setContentIsRead();
                     updated = true;
@@ -4662,7 +5101,7 @@ public void run() {
         } else if (id == NotificationCenter.botKeyboardDidLoaded) {
             if (dialog_id == (Long) args[1]) {
                 TLRPC.Message message = (TLRPC.Message) args[0];
-                if (message != null) {
+                if (message != null && !userBlocked) {
                     botButtons = new MessageObject(message, null, false);
                     if (chatActivityEnterView != null) {
                         if (botButtons.messageOwner.reply_markup instanceof TLRPC.TL_replyKeyboardForceReply) {
@@ -4694,8 +5133,9 @@ public void run() {
         } else if (id == NotificationCenter.chatSearchResultsAvailable) {
             if (classGuid == (Integer) args[0]) {
                 int messageId = (Integer) args[1];
+                long did = (Long) args[3];
                 if (messageId != 0) {
-                    scrollToMessageId(messageId, 0, true);
+                    scrollToMessageId(messageId, 0, true, did == dialog_id ? 0 : 1);
                 }
                 updateSearchButtons((Integer) args[2]);
             }
@@ -4706,7 +5146,7 @@ public void run() {
                 boolean updated = false;
                 for (int a = 0; a < array.size(); a++) {
                     int messageId = array.keyAt(a);
-                    MessageObject messageObject = messagesDict.get(messageId);
+                    MessageObject messageObject = messagesDict[0].get(messageId);
                     if (messageObject != null) {
                         int newValue = array.get(messageId);
                         if (newValue > messageObject.messageOwner.views) {
@@ -4732,33 +5172,37 @@ private void updateSearchButtons(int mask) {
     }
 
     @Override
-    protected void onOpenAnimationStart() {
-        NotificationCenter.getInstance().setAnimationInProgress(true);
-        openAnimationEnded = false;
+    public void onTransitionAnimationStart(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            NotificationCenter.getInstance().setAnimationInProgress(true);
+            openAnimationEnded = false;
+        }
     }
 
     @Override
-    protected void onOpenAnimationEnd() {
-        NotificationCenter.getInstance().setAnimationInProgress(false);
-        openAnimationEnded = true;
-        int count = chatListView.getChildCount();
-        for (int a = 0; a < count; a++) {
-            View view = chatListView.getChildAt(a);
-            if (view instanceof ChatMediaCell) {
-                ChatMediaCell cell = (ChatMediaCell) view;
-                cell.setAllowedToSetPhoto(true);
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            NotificationCenter.getInstance().setAnimationInProgress(false);
+            openAnimationEnded = true;
+            int count = chatListView.getChildCount();
+            for (int a = 0; a < count; a++) {
+                View view = chatListView.getChildAt(a);
+                if (view instanceof ChatMediaCell) {
+                    ChatMediaCell cell = (ChatMediaCell) view;
+                    cell.setAllowedToSetPhoto(true);
+                }
             }
-        }
 
-        if (currentUser != null) {
-            MessagesController.getInstance().loadFullUser(MessagesController.getInstance().getUser(currentUser.id), classGuid);
+            if (currentUser != null) {
+                MessagesController.getInstance().loadFullUser(currentUser, classGuid);
+            }
         }
     }
 
     @Override
     protected void onDialogDismiss(Dialog dialog) {
         if (closeChatDialog != null && dialog == closeChatDialog) {
-            MessagesController.getInstance().deleteDialog(dialog_id, 0, false);
+            MessagesController.getInstance().deleteDialog(dialog_id, 0);
             finishFragment();
         }
     }
@@ -4768,7 +5212,7 @@ private void updateBottomOverlay() {
             return;
         }
         if (currentChat != null) {
-            if (ChatObject.isChannel(currentChat)) {
+            if (ChatObject.isChannel(currentChat) && !currentChat.megagroup && !(currentChat instanceof TLRPC.TL_channelForbidden)) {
                 if (ChatObject.isNotInChat(currentChat)) {
                     bottomOverlayChatText.setText(LocaleController.getString("ChannelJoin", R.string.ChannelJoin));
                 } else {
@@ -4783,12 +5227,22 @@ private void updateBottomOverlay() {
             }
         } else {
             if (userBlocked) {
-                if ((currentUser.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                if (currentUser.bot) {
                     bottomOverlayChatText.setText(LocaleController.getString("BotUnblock", R.string.BotUnblock));
                 } else {
                     bottomOverlayChatText.setText(LocaleController.getString("Unblock", R.string.Unblock));
                 }
-            } else if (botUser != null) {
+                if (botButtons != null) {
+                    botButtons = null;
+                    if (chatActivityEnterView != null) {
+                        if (replyingMessageObject != null && botReplyButtons == replyingMessageObject) {
+                            botReplyButtons = null;
+                            showReplyPanel(false, null, null, null, false, true);
+                        }
+                        chatActivityEnterView.setButtons(botButtons, false);
+                    }
+                }
+            } else if (botUser != null && currentUser.bot) {
                 bottomOverlayChatText.setText(LocaleController.getString("BotStart", R.string.BotStart));
                 chatActivityEnterView.hidePopup(false);
                 if (getParentActivity() != null) {
@@ -4805,7 +5259,7 @@ private void updateBottomOverlay() {
             chatActivityEnterView.setFieldFocused(false);
             chatActivityEnterView.setVisibility(View.INVISIBLE);
         } else {
-            if (botUser != null) {
+            if (botUser != null && currentUser.bot) {
                 bottomOverlayChat.setVisibility(View.VISIBLE);
                 chatActivityEnterView.setVisibility(View.INVISIBLE);
             } else {
@@ -4832,7 +5286,7 @@ private void updateSpamView() {
                     } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChatCreate) {
                         reportSpamUser = MessagesController.getInstance().getUser(messageObject.messageOwner.from_id);
                     } else if (messageObject.messageOwner.action instanceof TLRPC.TL_messageActionChatAddUser) {
-                        if (messageObject.messageOwner.action.user_id == UserConfig.getClientUserId()) {
+                        if (messageObject.messageOwner.action.user_id == UserConfig.getClientUserId() || messageObject.messageOwner.action.users.contains(UserConfig.getClientUserId())) {
                             reportSpamUser = MessagesController.getInstance().getUser(messageObject.messageOwner.from_id);
                         }
                     }
@@ -4842,21 +5296,24 @@ private void updateSpamView() {
                 }
                 if (reportSpamUser != null) {
                     addToContactsButton.setVisibility(View.GONE);
-                    reportSpamButton.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 1.0f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
+                    reportSpamButton.setPadding(AndroidUtilities.dp(50), 0, AndroidUtilities.dp(50), 0);
+                    reportSpamContainer.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 1.0f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
                 }
             } else if (currentUser != null) {
-                if ((currentUser.flags & TLRPC.USER_FLAG_BOT) == 0 &&
+                if (!currentUser.bot &&
                     currentUser.id / 1000 != 333 && currentUser.id / 1000 != 777
                         && !UserObject.isDeleted(currentUser)
                         && !userBlocked
                         && !ContactsController.getInstance().isLoadingContacts()
                         && (currentUser.phone == null || currentUser.phone.length() == 0 || ContactsController.getInstance().contactsDict.get(currentUser.id) == null)) {
                     if (currentUser.phone != null && currentUser.phone.length() != 0) {
+                        reportSpamButton.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(50), 0);
                         addToContactsButton.setVisibility(View.VISIBLE);
-                        reportSpamButton.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0.5f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
+                        reportSpamContainer.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0.5f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
                     } else {
+                        reportSpamButton.setPadding(AndroidUtilities.dp(50), 0, AndroidUtilities.dp(50), 0);
                         addToContactsButton.setVisibility(View.GONE);
-                        reportSpamButton.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 1.0f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
+                        reportSpamContainer.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 1.0f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
                     }
                     reportSpamUser = currentUser;
                 }
@@ -4875,11 +5332,13 @@ private void updateSpamView() {
         if (reportSpamUser != null) {
             if (reportSpamView.getVisibility() != View.VISIBLE) {
                 reportSpamView.setVisibility(View.VISIBLE);
+                reportSpamView.setTag(1);
                 chatListView.setTopGlowOffset(AndroidUtilities.dp(48));
                 chatListView.setPadding(0, AndroidUtilities.dp(52), 0, AndroidUtilities.dp(3));
             }
         } else if (reportSpamView.getVisibility() != View.GONE) {
             reportSpamView.setVisibility(View.GONE);
+            reportSpamView.setTag(null);
             chatListView.setPadding(0, AndroidUtilities.dp(4), 0, AndroidUtilities.dp(3));
             chatListView.setTopGlowOffset(0);
             chatLayoutManager.scrollToPositionWithOffset(messages.size() - 1, -100000 - chatListView.getPaddingTop());
@@ -4908,17 +5367,19 @@ private void updateContactStatus() {
                 chatListView.setPadding(0, AndroidUtilities.dp(4), 0, AndroidUtilities.dp(3));
             } else {
                 addContactItem.setVisibility(View.VISIBLE);
-                reportSpamView.setVisibility(View.VISIBLE);
-                chatListView.setTopGlowOffset(AndroidUtilities.dp(48));
-                chatListView.setPadding(0, AndroidUtilities.dp(52), 0, AndroidUtilities.dp(3));
+                if (reportSpamView.getTag() != null) {
+                    reportSpamView.setVisibility(View.VISIBLE);
+                    chatListView.setPadding(0, AndroidUtilities.dp(52), 0, AndroidUtilities.dp(3));
+                    chatListView.setTopGlowOffset(AndroidUtilities.dp(48));
+                }
                 if (currentUser.phone != null && currentUser.phone.length() != 0) {
                     addContactItem.setText(LocaleController.getString("AddToContacts", R.string.AddToContacts));
                     addToContactsButton.setVisibility(View.VISIBLE);
-                    reportSpamButton.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0.5f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
+                    reportSpamContainer.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 0.5f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
                 } else {
                     addContactItem.setText(LocaleController.getString("ShareMyContactInfo", R.string.ShareMyContactInfo));
                     addToContactsButton.setVisibility(View.GONE);
-                    reportSpamButton.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 1.0f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
+                    reportSpamContainer.setLayoutParams(LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, 1.0f, Gravity.LEFT | Gravity.TOP, 0, 0, 0, AndroidUtilities.dp(1)));
                 }
             }
         }
@@ -4967,8 +5428,9 @@ public void onResume() {
                 }
             }
             readWhenResume = false;
-            MessagesController.getInstance().markDialogAsRead(dialog_id, messages.get(0).getId(), readWithMid, 0, readWithDate, true, false);
+            MessagesController.getInstance().markDialogAsRead(dialog_id, messages.get(0).getId(), readWithMid, readWithDate, true, false);
         }
+        checkScrollForLoad();
         if (wasPaused) {
             wasPaused = false;
             if (chatAdapter != null) {
@@ -4983,6 +5445,18 @@ public void onResume() {
             if (lastMessageText != null) {
                 preferences.edit().remove("dialog_" + dialog_id).commit();
                 chatActivityEnterView.setFieldText(lastMessageText);
+                if (getArguments().getBoolean("hasUrl", false)) {
+                    chatActivityEnterView.setSelection(lastMessageText.indexOf('\n') + 1);
+                    AndroidUtilities.runOnUIThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (chatActivityEnterView != null) {
+                                chatActivityEnterView.setFieldFocused(true);
+                                chatActivityEnterView.openKeyboard();
+                            }
+                        }
+                    }, 700);
+                }
             }
         } else {
             preferences.edit().remove("dialog_" + dialog_id).commit();
@@ -5112,28 +5586,30 @@ public boolean onPreDraw() {
                     } else {
                         selectedMessagesCountTextView.setTextSize(20);
                     }
+
+                    int padding = (ActionBar.getCurrentActionBarHeight() - AndroidUtilities.dp(48)) / 2;
+                    if (avatarContainer.getPaddingTop() != padding) {
+                        avatarContainer.setPadding(avatarContainer.getPaddingLeft(), padding, avatarContainer.getPaddingRight(), padding);
+                    }
+                    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) avatarContainer.getLayoutParams();
+                    if (layoutParams.topMargin != (Build.VERSION.SDK_INT >= 21 ? AndroidUtilities.statusBarHeight : 0)) {
+                        layoutParams.topMargin = (Build.VERSION.SDK_INT >= 21 ? AndroidUtilities.statusBarHeight : 0);
+                        avatarContainer.setLayoutParams(layoutParams);
+                    }
                     if (AndroidUtilities.isTablet()) {
                         if (AndroidUtilities.isSmallTablet() && ApplicationLoader.applicationContext.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
-                            actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+                            actionBar.setBackButtonDrawable(new BackDrawable(false));
+                            if (playerView != null && playerView.getParent() == null) {
+                                ((ViewGroup) fragmentView).addView(playerView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 39, Gravity.TOP | Gravity.LEFT, 0, -36, 0, 0));
+                            }
                         } else {
-                            actionBar.setBackButtonImage(R.drawable.ic_close_white);
-                        }
-                    }
-                    int padding = (ActionBar.getCurrentActionBarHeight() - AndroidUtilities.dp(48)) / 2;
-                    avatarContainer.setPadding(avatarContainer.getPaddingLeft(), padding, avatarContainer.getPaddingRight(), padding);
-                    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) avatarContainer.getLayoutParams();
-                    layoutParams.topMargin = (Build.VERSION.SDK_INT >= 21 ? AndroidUtilities.statusBarHeight : 0);
-                    avatarContainer.setLayoutParams(layoutParams);
-                    if (!resume) {
-                        int firstVisPos = chatLayoutManager.findLastVisibleItemPosition();
-                        if (firstVisPos == RecyclerView.NO_POSITION) {
-                            firstVisPos = 0;
+                            actionBar.setBackButtonDrawable(new BackDrawable(true));
+                            if (playerView != null && playerView.getParent() != null) {
+                                fragmentView.setPadding(0, 0, 0, 0);
+                                ((ViewGroup) fragmentView).removeView(playerView);
+                            }
                         }
-                        View firstVisView = chatListView.getChildAt(chatListView.getChildCount() - 1);
-                        int top = ((firstVisView == null) ? 0 : firstVisView.getTop()) - chatListView.getPaddingTop();
-                        chatListView.setAdapter(null);
-                        chatListView.setAdapter(chatAdapter);
-                        chatLayoutManager.scrollToPositionWithOffset(firstVisPos, top);
+                        return false;
                     }
                     return true;
                 }
@@ -5207,11 +5683,12 @@ private void switchImportantMode(MessageObject searchBeforeMessage) {
         SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
         preferences.edit().putInt("important_" + dialog_id, channelMessagesImportant).commit();
         waitingForImportantLoad = true;
+        waitingForLoad.add(lastLoadIndex);
         if (messageObject != null) {
             startLoadFromMessageId = messageObject.getId();
-            MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, startLoadFromMessageId, !cacheEndReached, 0, classGuid, 3, 0, channelMessagesImportant);
+            MessagesController.getInstance().loadMessages(dialog_id, AndroidUtilities.isTablet() ? 30 : 20, startLoadFromMessageId, true, 0, classGuid, 3, 0, channelMessagesImportant, lastLoadIndex++);
         } else {
-            MessagesController.getInstance().loadMessages(dialog_id, 30, 0, !cacheEndReached, 0, classGuid, 0, 0, channelMessagesImportant);
+            MessagesController.getInstance().loadMessages(dialog_id, 30, 0, true, 0, classGuid, 0, 0, channelMessagesImportant, lastLoadIndex++);
         }
     }
 
@@ -5237,13 +5714,15 @@ private void createMenu(View v, boolean single) {
 
         selectedObject = null;
         forwaringMessage = null;
-        selectedMessagesCanCopyIds.clear();
-        selectedMessagesIds.clear();
+        for (int a = 1; a >= 0; a--) {
+            selectedMessagesCanCopyIds[a].clear();
+            selectedMessagesIds[a].clear();
+        }
         cantDeleteMessagesCount = 0;
         actionBar.hideActionMode();
 
         boolean allowChatActions = true;
-        if (isBroadcast || currentChat != null && (ChatObject.isNotInChat(currentChat) || ChatObject.isChannel(currentChat) && (currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) == 0 && (currentChat.flags & TLRPC.CHAT_FLAG_USER_IS_EDITOR) == 0)) {
+        if (type == 1 && message.getDialogId() == mergeDialogId || message.getId() < 0 || isBroadcast || currentChat != null && (ChatObject.isNotInChat(currentChat) || ChatObject.isChannel(currentChat) && !currentChat.creator && !currentChat.editor && !currentChat.megagroup)) {
             allowChatActions = false;
         }
 
@@ -5380,11 +5859,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
             for (int a = 0; a < actionModeViews.size(); a++) {
                 View view = actionModeViews.get(a);
                 AndroidUtilities.clearDrawableAnimation(view);
-                if (a < 1) {
-                    animators.add(ObjectAnimatorProxy.ofFloat(view, "translationX", -AndroidUtilities.dp(56), 0));
-                } else {
-                    animators.add(ObjectAnimatorProxy.ofFloat(view, "scaleY", 0.1f, 1.0f));
-                }
+                animators.add(ObjectAnimatorProxy.ofFloat(view, "scaleY", 0.1f, 1.0f));
             }
             animatorSet.playTogether(animators);
             animatorSet.setDuration(250);
@@ -5392,7 +5867,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
         }
 
         addToSelectedMessages(message);
-        updateActionModeTitle();
+        selectedMessagesCountTextView.setNumber(1, false);
         updateVisibleRows();
     }
 
@@ -5460,10 +5935,12 @@ public void onClick(DialogInterface dialogInterface, int i) {
             if (path == null || path.length() == 0) {
                 path = FileLoader.getPathToMessage(selectedObject.messageOwner).toString();
             }
-            if (selectedObject.type == 3) {
-                MediaController.saveFile(path, getParentActivity(), 1, null);
-            } else if (selectedObject.type == 1) {
-                MediaController.saveFile(path, getParentActivity(), 0, null);
+            if (selectedObject.type == 3 || selectedObject.type == 1) {
+                if (Build.VERSION.SDK_INT >= 23 && getParentActivity().checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                    getParentActivity().requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 4);
+                    return;
+                }
+                MediaController.saveFile(path, getParentActivity(), selectedObject.type == 3 ? 1 : 0, null);
             } else if (selectedObject.type == 8 || selectedObject.type == 9 || selectedObject.type == 14) {
                 Intent intent = new Intent(Intent.ACTION_SEND);
                 intent.setType(selectedObject.messageOwner.media.document.mime_type);
@@ -5516,6 +5993,10 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(new File(path)));
                     getParentActivity().startActivityForResult(Intent.createChooser(intent, LocaleController.getString("ShareFile", R.string.ShareFile)), 500);
                 } else {
+                    if (Build.VERSION.SDK_INT >= 23 && getParentActivity().checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                        getParentActivity().requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 4);
+                        return;
+                    }
                     MediaController.saveFile(path, getParentActivity(), 0, null);
                 }
             }
@@ -5524,6 +6005,10 @@ public void onClick(DialogInterface dialogInterface, int i) {
         } else if (option == 9) {
             StickersQuery.loadStickers(this, selectedObject.getInputStickerSet());
         } else if (option == 10) {
+            if (Build.VERSION.SDK_INT >= 23 && getParentActivity().checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                getParentActivity().requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 4);
+                return;
+            }
             String fileName = FileLoader.getDocumentFileName(selectedObject.messageOwner.media.document);
             if (fileName == null || fileName.length() == 0) {
                 fileName = selectedObject.getFileName();
@@ -5545,22 +6030,25 @@ public void onClick(DialogInterface dialogInterface, int i) {
 
     @Override
     public void didSelectDialog(DialogsActivity activity, long did, boolean param) {
-        if (dialog_id != 0 && (forwaringMessage != null || !selectedMessagesIds.isEmpty())) {
+        if (dialog_id != 0 && (forwaringMessage != null || !selectedMessagesIds[0].isEmpty() || !selectedMessagesIds[1].isEmpty())) {
             ArrayList<MessageObject> fmessages = new ArrayList<>();
             if (forwaringMessage != null) {
                 fmessages.add(forwaringMessage);
                 forwaringMessage = null;
             } else {
-                ArrayList<Integer> ids = new ArrayList<>(selectedMessagesIds.keySet());
-                Collections.sort(ids);
-                for (Integer id : ids) {
-                    MessageObject message = selectedMessagesIds.get(id);
-                    if (message != null && id > 0) {
-                        fmessages.add(message);
+                for (int a = 1; a >= 0; a--) {
+                    ArrayList<Integer> ids = new ArrayList<>(selectedMessagesIds[a].keySet());
+                    Collections.sort(ids);
+                    for (int b = 0; b < ids.size(); b++) {
+                        Integer id = ids.get(b);
+                        MessageObject message = selectedMessagesIds[a].get(id);
+                        if (message != null && id > 0) {
+                            fmessages.add(message);
+                        }
                     }
+                    selectedMessagesCanCopyIds[a].clear();
+                    selectedMessagesIds[a].clear();
                 }
-                selectedMessagesCanCopyIds.clear();
-                selectedMessagesIds.clear();
                 cantDeleteMessagesCount = 0;
                 actionBar.hideActionMode();
             }
@@ -5602,8 +6090,10 @@ public void didSelectDialog(DialogsActivity activity, long did, boolean param) {
     @Override
     public boolean onBackPressed() {
         if (actionBar.isActionModeShowed()) {
-            selectedMessagesIds.clear();
-            selectedMessagesCanCopyIds.clear();
+            for (int a = 1; a >= 0; a--) {
+                selectedMessagesIds[a].clear();
+                selectedMessagesCanCopyIds[a].clear();
+            }
             actionBar.hideActionMode();
             cantDeleteMessagesCount = 0;
             updateVisibleRows();
@@ -5656,7 +6146,8 @@ private void updateVisibleRows() {
                 boolean disableSelection = false;
                 boolean selected = false;
                 if (actionBar.isActionModeShowed()) {
-                    if (selectedMessagesIds.containsKey(cell.getMessageObject().getId())) {
+                    MessageObject messageObject = cell.getMessageObject();
+                    if (selectedMessagesIds[messageObject.getDialogId() == dialog_id ? 0 : 1].containsKey(messageObject.getId())) {
                         view.setBackgroundColor(0x6633b5e5);
                         selected = true;
                     } else {
@@ -5702,7 +6193,7 @@ private void openSearchWithText(String text) {
         if (text != null) {
             searchItem.getSearchField().setText(text);
             searchItem.getSearchField().setSelection(searchItem.getSearchField().length());
-            MessagesSearchQuery.searchMessagesInChat(text, dialog_id, classGuid, 0);
+            MessagesSearchQuery.searchMessagesInChat(text, dialog_id, mergeDialogId, classGuid, 0);
         }
     }
 
@@ -5777,7 +6268,8 @@ public void setPhotoChecked(int index) {
     }
 
     @Override
-    public void cancelButtonPressed() {
+    public boolean cancelButtonPressed() {
+        return true;
     }
 
     @Override
@@ -5794,7 +6286,7 @@ public int getSelectedCount() {
         private Context mContext;
         private boolean isBot;
         private int rowCount;
-        private int botInfoRow;
+        private int botInfoRow = -1;
         private int loadingUpRow;
         private int loadingDownRow;
         private int messagesStartRow;
@@ -5802,18 +6294,18 @@ public int getSelectedCount() {
 
         public ChatActivityAdapter(Context context) {
             mContext = context;
-            isBot = currentUser != null && (currentUser.flags & TLRPC.USER_FLAG_BOT) != 0;
+            isBot = currentUser != null && currentUser.bot;
         }
 
         public void updateRows() {
             rowCount = 0;
-            if (currentUser != null && (currentUser.flags & TLRPC.USER_FLAG_BOT) != 0) {
+            if (currentUser != null && currentUser.bot) {
                 botInfoRow = rowCount++;
             } else {
                 botInfoRow = -1;
             }
             if (!messages.isEmpty()) {
-                if (!endReached) {
+                if (!endReached[0] || mergeDialogId != 0 && !endReached[1]) {
                     loadingUpRow = rowCount++;
                 } else {
                     loadingUpRow = -1;
@@ -5821,7 +6313,7 @@ public void updateRows() {
                 messagesStartRow = rowCount;
                 rowCount += messages.size();
                 messagesEndRow = rowCount;
-                if (!forward_end_reached) {
+                if (!forwardEndReached[0] || mergeDialogId != 0 && !forwardEndReached[1]) {
                     loadingDownRow = rowCount++;
                 } else {
                     loadingDownRow = -1;
@@ -5890,7 +6382,7 @@ public void didPressUrl(String url) {
                             fragment.setSearchString(url);
                             presentFragment(fragment);
                         } else if (url.startsWith("/")) {
-                            chatActivityEnterView.setCommand(null, url);
+                            chatActivityEnterView.setCommand(null, url, false, false);
                         }
                     }
                 });
@@ -5899,7 +6391,24 @@ public void didPressUrl(String url) {
             }
 
             if (view instanceof ChatBaseCell) {
+                if (currentEncryptedChat == null) {
+                    ((ChatBaseCell) view).setAllowAssistant(true);
+                }
                 ((ChatBaseCell) view).setDelegate(new ChatBaseCell.ChatBaseCellDelegate() {
+                    @Override
+                    public void didPressShare(ChatBaseCell cell) {
+                        if (getParentActivity() == null) {
+                            return;
+                        }
+                        if (chatActivityEnterView != null) {
+                            chatActivityEnterView.closeKeyboard();
+                        }
+                        BottomSheet.Builder builder = new BottomSheet.Builder(mContext, true);
+                        builder.setCustomView(new ShareFrameLayout(mContext, builder.create(), cell.getMessageObject())).setApplyTopPaddings(false);
+                        builder.setUseFullWidth(false);
+                        showDialog(builder.create());
+                    }
+
                     @Override
                     public void didPressedChannelAvatar(ChatBaseCell cell, TLRPC.Chat chat) {
                         if (actionBar.isActionModeShowed()) {
@@ -5922,7 +6431,9 @@ public void didPressedUserAvatar(ChatBaseCell cell, TLRPC.User user) {
                         if (user != null && user.id != UserConfig.getClientUserId()) {
                             Bundle args = new Bundle();
                             args.putInt("user_id", user.id);
-                            presentFragment(new ProfileActivity(args));
+                            ProfileActivity fragment = new ProfileActivity(args);
+                            fragment.setPlayProfileAnimation(currentUser != null && currentUser.id == user.id);
+                            presentFragment(fragment);
                         }
                     }
 
@@ -5945,7 +6456,7 @@ public boolean canPerformActions() {
                     }
 
                     @Override
-                    public void didPressUrl(MessageObject messageObject, final ClickableSpan url) {
+                    public void didPressUrl(MessageObject messageObject, final ClickableSpan url, boolean longPress) {
                         if (url instanceof URLSpanNoUnderline) {
                             String str = ((URLSpanNoUnderline) url).getURL();
                             if (str.startsWith("@")) {
@@ -5959,7 +6470,9 @@ public void didPressUrl(MessageObject messageObject, final ClickableSpan url) {
                                     presentFragment(fragment);
                                 }
                             } else if (str.startsWith("/")) {
-                                chatActivityEnterView.setCommand(messageObject, str);
+                                if (URLSpanBotCommand.enabled) {
+                                    chatActivityEnterView.setCommand(messageObject, str, longPress, currentChat != null && currentChat.megagroup);
+                                }
                             }
                         } else if (url instanceof URLSpanReplacement) {
                             AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
@@ -5997,7 +6510,7 @@ public void didPressReplyMessage(ChatBaseCell cell, int id) {
                             channelMessagesImportant = 1;
                             radioButton.setChecked(channelMessagesImportant == 1, false);
                         }
-                        scrollToMessageId(id, cell.getMessageObject().getId(), true);
+                        scrollToMessageId(id, messageObject.getId(), true, messageObject.getDialogId() == mergeDialogId ? 1 : 0);
                     }
 
                     @Override
@@ -6011,7 +6524,7 @@ public void didClickedImage(ChatBaseCell cell) {
                         }
                         if (message.type == 1 || message.type == 0) {
                             PhotoViewer.getInstance().setParentActivity(getParentActivity());
-                            PhotoViewer.getInstance().openPhoto(message, ChatActivity.this);
+                            PhotoViewer.getInstance().openPhoto(message, message.contentType == 1 ? dialog_id : 0, message.contentType == 1 ? mergeDialogId : 0, ChatActivity.this);
                         } else if (message.type == 3) {
                             sendSecretMessageRead(message);
                             try {
@@ -6166,7 +6679,7 @@ public boolean needPlayMusic(MessageObject messageObject) {
                     public void didClickedImage(ChatActionCell cell) {
                         MessageObject message = cell.getMessageObject();
                         PhotoViewer.getInstance().setParentActivity(getParentActivity());
-                        PhotoViewer.getInstance().openPhoto(message, ChatActivity.this);
+                        PhotoViewer.getInstance().openPhoto(message, 0, 0, ChatActivity.this);
                     }
 
                     @Override
@@ -6176,10 +6689,19 @@ public void didLongPressed(ChatActionCell cell) {
 
                     @Override
                     public void needOpenUserProfile(int uid) {
-                        if (uid != UserConfig.getClientUserId()) {
+                        if (uid < 0) {
+                            Bundle args = new Bundle();
+                            args.putInt("chat_id", -uid);
+                            presentFragment(new ChatActivity(args), true);
+                        } else if (uid != UserConfig.getClientUserId()) {
                             Bundle args = new Bundle();
                             args.putInt("user_id", uid);
-                            presentFragment(new ProfileActivity(args));
+                            if (currentEncryptedChat != null && uid == currentUser.id) {
+                                args.putLong("dialog_id", dialog_id);
+                            }
+                            ProfileActivity fragment = new ProfileActivity(args);
+                            fragment.setPlayProfileAnimation(currentUser != null && currentUser.id == uid);
+                            presentFragment(fragment);
                         }
                     }
                 });
@@ -6203,7 +6725,7 @@ public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
                 boolean selected = false;
                 boolean disableSelection = false;
                 if (actionBar.isActionModeShowed()) {
-                    if (selectedMessagesIds.containsKey(message.getId())) {
+                    if (selectedMessagesIds[message.getDialogId() == dialog_id ? 0 : 1].containsKey(message.getId())) {
                         view.setBackgroundColor(0x6633b5e5);
                         selected = true;
                     } else {
@@ -6285,49 +6807,81 @@ public void removeMessageObject(MessageObject messageObject) {
         @Override
         public void notifyDataSetChanged() {
             updateRows();
-            super.notifyDataSetChanged();
+            try {
+                super.notifyDataSetChanged();
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
 
         @Override
         public void notifyItemChanged(int position) {
             updateRows();
-            super.notifyItemChanged(position);
+            try {
+                super.notifyItemChanged(position);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
 
         @Override
         public void notifyItemRangeChanged(int positionStart, int itemCount) {
             updateRows();
+            try {
             super.notifyItemRangeChanged(positionStart, itemCount);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
 
         @Override
         public void notifyItemInserted(int position) {
             updateRows();
-            super.notifyItemInserted(position);
+            try {
+                super.notifyItemInserted(position);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
 
         @Override
         public void notifyItemMoved(int fromPosition, int toPosition) {
             updateRows();
-            super.notifyItemMoved(fromPosition, toPosition);
+            try {
+                super.notifyItemMoved(fromPosition, toPosition);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
 
         @Override
         public void notifyItemRangeInserted(int positionStart, int itemCount) {
             updateRows();
-            super.notifyItemRangeInserted(positionStart, itemCount);
+            try {
+                super.notifyItemRangeInserted(positionStart, itemCount);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
 
         @Override
         public void notifyItemRemoved(int position) {
             updateRows();
-            super.notifyItemRemoved(position);
+            try {
+                super.notifyItemRemoved(position);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
 
         @Override
         public void notifyItemRangeRemoved(int positionStart, int itemCount) {
             updateRows();
-            super.notifyItemRangeRemoved(positionStart, itemCount);
+            try {
+                super.notifyItemRangeRemoved(positionStart, itemCount);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
         }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/AlertsCreator.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/AlertsCreator.java
index 8d50b48e3..fbba44e9a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/AlertsCreator.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/AlertsCreator.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -70,6 +70,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             editor.putInt("notifyuntil_" + dialog_id, untilTime);
                             flags = ((long) untilTime << 32) | 1;
                         }
+                        NotificationsController.getInstance().removeNotificationsForDialog(dialog_id);
                         MessagesStorage.getInstance().setDialogFlags(dialog_id, flags);
                         editor.commit();
                         TLRPC.Dialog dialog = MessagesController.getInstance().dialogs_dict.get(dialog_id);
@@ -84,7 +85,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
         return builder.create();
     }
 
-    public static void showAddUserAlert(String error, final BaseFragment fragment) {
+    public static void showAddUserAlert(String error, final BaseFragment fragment, boolean isChannel) {
         if (error == null || fragment == null || fragment.getParentActivity() == null) {
             return;
         }
@@ -97,7 +98,7 @@ public static void showAddUserAlert(String error, final BaseFragment fragment) {
                     @Override
                     public void onClick(DialogInterface dialogInterface, int i) {
                         try {
-                            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://telegram.org/faq#can-39t-send-messages-to-non-contacts"));
+                            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(LocaleController.getString("NobodyLikesSpamUrl", R.string.NobodyLikesSpamUrl)));
                             intent.putExtra(Browser.EXTRA_APPLICATION_ID, fragment.getParentActivity().getPackageName());
                             fragment.getParentActivity().startActivity(intent);
                         } catch (Exception e) {
@@ -107,14 +108,41 @@ public void onClick(DialogInterface dialogInterface, int i) {
                 });
                 break;
             case "USER_BLOCKED":
+            case "USER_BOT":
             case "USER_ID_INVALID":
-                builder.setMessage(LocaleController.getString("ChannelUserCantAdd", R.string.ChannelUserCantAdd));
+                if (isChannel) {
+                    builder.setMessage(LocaleController.getString("ChannelUserCantAdd", R.string.ChannelUserCantAdd));
+                } else {
+                    builder.setMessage(LocaleController.getString("GroupUserCantAdd", R.string.GroupUserCantAdd));
+                }
                 break;
             case "USERS_TOO_MUCH":
-                builder.setMessage(LocaleController.getString("ChannelUserAddLimit", R.string.ChannelUserAddLimit));
+                if (isChannel) {
+                    builder.setMessage(LocaleController.getString("ChannelUserAddLimit", R.string.ChannelUserAddLimit));
+                } else {
+                    builder.setMessage(LocaleController.getString("GroupUserAddLimit", R.string.GroupUserAddLimit));
+                }
                 break;
             case "USER_NOT_MUTUAL_CONTACT":
-                builder.setMessage(LocaleController.getString("ChannelUserLeftError", R.string.ChannelUserLeftError));
+                if (isChannel) {
+                    builder.setMessage(LocaleController.getString("ChannelUserLeftError", R.string.ChannelUserLeftError));
+                } else {
+                    builder.setMessage(LocaleController.getString("GroupUserLeftError", R.string.GroupUserLeftError));
+                }
+                break;
+            case "ADMINS_TOO_MUCH":
+                if (isChannel) {
+                    builder.setMessage(LocaleController.getString("ChannelUserCantAdmin", R.string.ChannelUserCantAdmin));
+                } else {
+                    builder.setMessage(LocaleController.getString("GroupUserCantAdmin", R.string.GroupUserCantAdmin));
+                }
+                break;
+            case "BOTS_TOO_MUCH":
+                if (isChannel) {
+                    builder.setMessage(LocaleController.getString("ChannelUserCantBot", R.string.ChannelUserCantBot));
+                } else {
+                    builder.setMessage(LocaleController.getString("GroupUserCantBot", R.string.GroupUserCantBot));
+                }
                 break;
         }
         builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarDrawable.java
index 8e23920b6..12cc66f7a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarDrawable.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
@@ -11,6 +11,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
+import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
@@ -22,18 +23,15 @@
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
 import org.telegram.tgnet.TLRPC;
-import org.telegram.messenger.UserConfig;
 import org.telegram.messenger.ApplicationLoader;
 
-import java.util.Locale;
-
 public class AvatarDrawable extends Drawable {
 
     private static Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
     private static TextPaint namePaint;
     private static TextPaint namePaintSmall;
-    private static int[] arrColors = {0xffe56555, 0xfff28c48, 0xffeec764, 0xff76c84d, 0xff5fbed5, 0xff549cdd, 0xff8e85ee, 0xfff2749a};
-    private static int[] arrColorsProfiles = {0xffd86f65, 0xfff69d61, 0xfffabb3c, 0xff67b35d, 0xff56a2bb, 0xff5c98cd, 0xff8c79d2, 0xfff37fa6};
+    private static int[] arrColors = {0xffe56555, 0xfff28c48, 0xff8e85ee, 0xff76c84d, 0xff5fbed5, 0xff549cdd, 0xff8e85ee, 0xfff2749a};
+    private static int[] arrColorsProfiles = {0xffd86f65, 0xfff69d61, 0xff8c79d2, 0xff67b35d, 0xff56a2bb, 0xff5c98cd, 0xff8c79d2, 0xfff37fa6};
     private static int[] arrColorsProfilesBack = {0xffca6056, 0xfff18944, 0xff7d6ac4, 0xff56a14c, 0xff4492ac, 0xff4c84b6, 0xff7d6ac4, 0xff4c84b6};
     private static int[] arrColorsProfilesText = {0xfff9cbc5, 0xfffdddc8, 0xffcdc4ed, 0xffc0edba, 0xffb8e2f0, 0xffb3d7f7, 0xffcdc4ed, 0xffb3d7f7};
     private static int[] arrColorsNames = {0xffca5650, 0xffd87b29, 0xff4e92cc, 0xff50b232, 0xff42b1a8, 0xff4e92cc, 0xff4e92cc, 0xff4e92cc};
@@ -94,6 +92,10 @@ public AvatarDrawable(TLRPC.Chat chat, boolean profile) {
         }
     }
 
+    public void setProfile(boolean value) {
+        isProfile = value;
+    }
+
     public void setSmallStyle(boolean value) {
         smallStyle = value;
     }
@@ -102,7 +104,7 @@ public static int getColorIndex(int id) {
         if (id >= 0 && id < 8) {
             return id;
         }
-        try {
+        /*try {
             String str;
             if (id >= 0) {
                 str = String.format(Locale.US, "%d%d", id, UserConfig.getClientUserId());
@@ -121,8 +123,8 @@ public static int getColorIndex(int id) {
             return Math.abs(b) % arrColors.length;
         } catch (Exception e) {
             FileLog.e("tmessages", e);
-        }
-        return id % arrColors.length;
+        }*/
+        return Math.abs(id % arrColors.length);
     }
 
     public static int getColorForId(int id) {
@@ -276,7 +278,7 @@ public void setColorFilter(ColorFilter cf) {
 
     @Override
     public int getOpacity() {
-        return 0;
+        return PixelFormat.TRANSPARENT;
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarUpdater.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarUpdater.java
index abda6c200..d740dfa5e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarUpdater.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/AvatarUpdater.java
@@ -1,18 +1,21 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
 
+import android.Manifest;
 import android.app.Activity;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.graphics.Bitmap;
 import android.media.ExifInterface;
 import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.provider.MediaStore;
 
@@ -73,6 +76,12 @@ public void openCamera() {
     }
 
     public void openGallery() {
+        if (Build.VERSION.SDK_INT >= 23 && parentFragment != null && parentFragment.getParentActivity() != null) {
+            if (parentFragment.getParentActivity().checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                parentFragment.getParentActivity().requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, 4);
+                return;
+            }
+        }
         PhotoAlbumPickerActivity fragment = new PhotoAlbumPickerActivity(true, null);
         fragment.setDelegate(new PhotoAlbumPickerActivity.PhotoAlbumPickerActivityDelegate() {
             @Override
@@ -179,6 +188,7 @@ private void processBitmap(Bitmap bitmap) {
         }
         smallPhoto = ImageLoader.scaleAndSaveImage(bitmap, 100, 100, 80, false);
         bigPhoto = ImageLoader.scaleAndSaveImage(bitmap, 800, 800, 80, false, 320, 320);
+        bitmap.recycle();
         if (bigPhoto != null && smallPhoto != null) {
             if (returnOnly) {
                 if (delegate != null) {
@@ -195,7 +205,7 @@ private void processBitmap(Bitmap bitmap) {
     }
 
     @Override
-    public void didFinishEdit(Bitmap bitmap, Bundle args) {
+    public void didFinishEdit(Bitmap bitmap) {
         processBitmap(bitmap);
     }
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/BackupImageView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/BackupImageView.java
index 4ff18a9bf..dc1e5f8a0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/BackupImageView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/BackupImageView.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/BotKeyboardView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/BotKeyboardView.java
index bbbe04648..d19b58993 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/BotKeyboardView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/BotKeyboardView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -88,7 +88,7 @@ public void setButtons(TLRPC.TL_replyKeyboardMarkup buttons) {
         buttonViews.clear();
 
         if (buttons != null && botButtons.rows.size() != 0) {
-            isFullSize = (buttons.flags & 1) == 0;
+            isFullSize = !buttons.resize;
             buttonHeight = !isFullSize ? 42 : (int) Math.max(42, (panelHeight - AndroidUtilities.dp(30) - (botButtons.rows.size() - 1) * AndroidUtilities.dp(10)) / botButtons.rows.size() / AndroidUtilities.density);
             for (int a = 0; a < buttons.rows.size(); a++) {
                 TLRPC.TL_keyboardButtonRow row = buttons.rows.get(a);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
index a121a040d..92d550966 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatActivityEnterView.java
@@ -1,17 +1,23 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
 
+import android.Manifest;
 import android.app.Activity;
 import android.content.Context;
 import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
 import android.media.AudioManager;
+import android.os.Build;
 import android.os.PowerManager;
 import android.text.Editable;
 import android.text.TextWatcher;
@@ -22,7 +28,8 @@
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
-import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.AccelerateInterpolator;
+import android.view.animation.DecelerateInterpolator;
 import android.view.inputmethod.EditorInfo;
 import android.widget.EditText;
 import android.widget.FrameLayout;
@@ -52,6 +59,7 @@
 import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
 import org.telegram.messenger.AnimationCompat.ViewProxy;
 import org.telegram.messenger.ApplicationLoader;
+import org.telegram.ui.StickersActivity;
 
 import java.util.Locale;
 
@@ -74,6 +82,7 @@
     private ImageView audioSendButton;
     private FrameLayout recordPanel;
     private LinearLayout slideText;
+    private RecordDot recordDot;
     private SizeNotifierFrameLayout sizeNotifierLayout;
     private LinearLayout attachButton;
     private ImageView botButton;
@@ -82,6 +91,7 @@
     private PopupWindow botKeyboardPopup;
     private BotKeyboardView botKeyboardView;
     private ImageView asAdminButton;
+    private RecordCircle recordCircle;
 
     private int currentPopupContentType = -1;
 
@@ -99,7 +109,7 @@
     private PowerManager.WakeLock mWakeLock;
     private AnimatorSetProxy runningAnimation;
     private AnimatorSetProxy runningAnimation2;
-    private ObjectAnimatorProxy runningAnimationAudio;
+    private AnimatorSetProxy runningAnimationAudio;
     private int runningAnimationType;
     private int audioInterfaceState;
 
@@ -149,6 +159,124 @@ public void run() {
         }
     };
 
+    private class RecordDot extends View {
+
+        private Drawable dotDrawable;
+        private float alpha;
+        private long lastUpdateTime;
+        private boolean isIncr;
+
+        public RecordDot(Context context) {
+            super(context);
+
+            dotDrawable = getResources().getDrawable(R.drawable.rec);
+        }
+
+        public void resetAlpha() {
+            alpha = 1.0f;
+            lastUpdateTime = System.currentTimeMillis();
+            isIncr = false;
+            invalidate();
+        }
+
+        @Override
+        protected void onDraw(Canvas canvas) {
+            dotDrawable.setBounds(0, 0, AndroidUtilities.dp(11), AndroidUtilities.dp(11));
+            dotDrawable.setAlpha(185 + (int) (70 * alpha));
+            long dt = (System.currentTimeMillis() - lastUpdateTime);
+            if (!isIncr) {
+                alpha -= dt / 200.0f;
+                if (alpha <= 0) {
+                    alpha = 0;
+                    isIncr = true;
+                }
+            } else {
+                alpha += dt / 200.0f;
+                if (alpha >= 1) {
+                    alpha = 1;
+                    isIncr = false;
+                }
+            }
+            lastUpdateTime = System.currentTimeMillis();
+            dotDrawable.draw(canvas);
+            invalidate();
+        }
+    }
+
+    private class RecordCircle extends View {
+
+        private Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        private Paint paintRecord = new Paint(Paint.ANTI_ALIAS_FLAG);
+        private Drawable micDrawable;
+        private float scale;
+        private float amplitude;
+        private float animateToAmplitude;
+        private float animateAmplitudeDiff;
+        private long lastUpdateTime;
+
+        public RecordCircle(Context context) {
+            super(context);
+            paint.setColor(0xff5795cc);
+            paintRecord.setColor(0x0d000000);
+            micDrawable = getResources().getDrawable(R.drawable.mic_pressed);
+        }
+
+        public void setAmplitude(double value) {
+            animateToAmplitude = (float) Math.min(100, value) / 100.0f;
+            animateAmplitudeDiff = (animateToAmplitude - amplitude) / 150.0f;
+            lastUpdateTime = System.currentTimeMillis();
+            invalidate();
+        }
+
+        public float getScale() {
+            return scale;
+        }
+
+        public void setScale(float value) {
+            scale = value;
+            invalidate();
+        }
+
+        @Override
+        protected void onDraw(Canvas canvas) {
+            int cx = getMeasuredWidth() / 2;
+            int cy = getMeasuredHeight() / 2;
+            float sc;
+            float alpha;
+            if (scale <= 0.5f) {
+                alpha = sc = scale / 0.5f;
+            } else if (scale <= 0.75f) {
+                sc = 1.0f - (scale - 0.5f) / 0.25f * 0.1f;
+                alpha = 1;
+            } else {
+                sc = 0.9f + (scale - 0.75f) / 0.25f * 0.1f;
+                alpha = 1;
+            }
+            long dt = System.currentTimeMillis() - lastUpdateTime;
+            if (animateToAmplitude != amplitude) {
+                amplitude += animateAmplitudeDiff * dt;
+                if (animateAmplitudeDiff > 0) {
+                    if (amplitude > animateToAmplitude) {
+                        amplitude = animateToAmplitude;
+                    }
+                } else {
+                    if (amplitude < animateToAmplitude) {
+                        amplitude = animateToAmplitude;
+                    }
+                }
+                invalidate();
+            }
+            lastUpdateTime = System.currentTimeMillis();
+            if (amplitude != 0) {
+                canvas.drawCircle(getMeasuredWidth() / 2.0f, getMeasuredHeight() / 2.0f, (AndroidUtilities.dp(42) + AndroidUtilities.dp(20) * amplitude) * scale, paintRecord);
+            }
+            canvas.drawCircle(getMeasuredWidth() / 2.0f, getMeasuredHeight() / 2.0f, AndroidUtilities.dp(42) * sc, paint);
+            micDrawable.setBounds(cx - micDrawable.getIntrinsicWidth() / 2, cy - micDrawable.getIntrinsicHeight() / 2, cx + micDrawable.getIntrinsicWidth() / 2, cy + micDrawable.getIntrinsicHeight() / 2);
+            micDrawable.setAlpha((int) (255 * alpha));
+            micDrawable.draw(canvas);
+        }
+    }
+
     public ChatActivityEnterView(Activity context, SizeNotifierFrameLayout parent, BaseFragment fragment, boolean isChat) {
         super(context);
         setBackgroundResource(R.drawable.compose_panel);
@@ -398,9 +526,8 @@ public void onClick(View v) {
         linearLayout.setBackgroundColor(0xffffffff);
         recordPanel.addView(linearLayout, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER_VERTICAL));
 
-        imageView = new ImageView(context);
-        imageView.setImageResource(R.drawable.rec);
-        linearLayout.addView(imageView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER_VERTICAL, 0, 1, 0, 0));
+        recordDot = new RecordDot(context);
+        linearLayout.addView(recordDot, LayoutHelper.createLinear(11, 11, Gravity.CENTER_VERTICAL, 0, 1, 0, 0));
 
         recordTimeText = new TextView(context);
         recordTimeText.setText("00:00");
@@ -413,7 +540,7 @@ public void onClick(View v) {
 
         audioSendButton = new ImageView(context);
         audioSendButton.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
-        audioSendButton.setImageResource(R.drawable.mic_button_states);
+        audioSendButton.setImageResource(R.drawable.mic);
         audioSendButton.setBackgroundColor(0xffffffff);
         audioSendButton.setSoundEffectsEnabled(false);
         audioSendButton.setPadding(0, 0, AndroidUtilities.dp(4), 0);
@@ -423,6 +550,13 @@ public void onClick(View v) {
             public boolean onTouch(View view, MotionEvent motionEvent) {
                 if (motionEvent.getAction() == MotionEvent.ACTION_DOWN) {
                     if (parentFragment != null) {
+                        if (Build.VERSION.SDK_INT >= 23) {
+                            if (parentActivity.checkSelfPermission(Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
+                                parentActivity.requestPermissions(new String[]{Manifest.permission.RECORD_AUDIO}, 3);
+                                return false;
+                            }
+                        }
+
                         String action;
                         TLRPC.Chat currentChat;
                         if ((int) dialog_id < 0) {
@@ -460,6 +594,7 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
                     FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) slideText.getLayoutParams();
                     if (startedDraggingX != -1) {
                         float dist = (x - startedDraggingX);
+                        ViewProxy.setTranslationX(recordCircle, dist);
                         params.leftMargin = AndroidUtilities.dp(30) + (int) dist;
                         slideText.setLayoutParams(params);
                         float alpha = 1.0f + dist / distCanMove;
@@ -483,6 +618,7 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
                     }
                     if (params.leftMargin > AndroidUtilities.dp(30)) {
                         params.leftMargin = AndroidUtilities.dp(30);
+                        ViewProxy.setTranslationX(recordCircle, 0);
                         slideText.setLayoutParams(params);
                         ViewProxy.setAlpha(slideText, 1);
                         startedDraggingX = -1;
@@ -493,6 +629,10 @@ public boolean onTouch(View view, MotionEvent motionEvent) {
             }
         });
 
+        recordCircle = new RecordCircle(context);
+        recordCircle.setVisibility(GONE);
+        sizeNotifierLayout.addView(recordCircle, LayoutHelper.createFrame(124, 124, Gravity.BOTTOM | Gravity.RIGHT, 0, 0, -36, -38));
+
         sendButton = new ImageView(context);
         sendButton.setVisibility(View.INVISIBLE);
         sendButton.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
@@ -551,7 +691,7 @@ public boolean asAdmin() {
         return isAsAdmin;
     }
 
-    public void showTopView(boolean animated) {
+    public void showTopView(boolean animated, final boolean openKeyboard) {
         if (topView == null || topViewShowed || getVisibility() != VISIBLE) {
             return;
         }
@@ -572,9 +712,9 @@ public void showTopView(boolean animated) {
                     currentTopViewAnimation.addListener(new AnimatorListenerAdapterProxy() {
                         @Override
                         public void onAnimationEnd(Object animation) {
-                            if (animation == currentTopViewAnimation) {
+                            if (currentTopViewAnimation != null && currentTopViewAnimation.equals(animation)) {
                                 setTopViewAnimation(1.0f);
-                                if (!forceShowSendButton) {
+                                if (!forceShowSendButton || openKeyboard) {
                                     openKeyboard();
                                 }
                                 currentTopViewAnimation = null;
@@ -585,7 +725,7 @@ public void onAnimationEnd(Object animation) {
                     currentTopViewAnimation.start();
                 } else {
                     setTopViewAnimation(1.0f);
-                    if (!forceShowSendButton) {
+                    if (!forceShowSendButton || openKeyboard) {
                         openKeyboard();
                     }
                 }
@@ -617,7 +757,7 @@ public void hideTopView(final boolean animated) {
                 currentTopViewAnimation.addListener(new AnimatorListenerAdapterProxy() {
                     @Override
                     public void onAnimationEnd(Object animation) {
-                        if (animation == currentTopViewAnimation) {
+                        if (currentTopViewAnimation != null && currentTopViewAnimation.equals(animation)) {
                             topView.setVisibility(GONE);
                             setTopViewAnimation(0.0f);
                             currentTopViewAnimation = null;
@@ -690,6 +830,7 @@ public void onDestroy() {
 
     public void onPause() {
         isPaused = true;
+        closeKeyboard();
     }
 
     public void onResume() {
@@ -710,8 +851,8 @@ public void setDialogId(long id) {
         dialog_id = id;
         if ((int) dialog_id < 0) {
             TLRPC.Chat currentChat = MessagesController.getInstance().getChat(-(int) dialog_id);
-            isAsAdmin = ChatObject.isChannel(currentChat) && ((currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0 || (currentChat.flags & TLRPC.CHAT_FLAG_USER_IS_EDITOR) != 0);
-            adminModeAvailable = isAsAdmin && (currentChat.flags & TLRPC.CHAT_FLAG_IS_BROADCAST) == 0;
+            isAsAdmin = ChatObject.isChannel(currentChat) && (currentChat.creator || currentChat.editor) && !currentChat.megagroup;
+            adminModeAvailable = isAsAdmin && !currentChat.broadcast;
             if (adminModeAvailable) {
                 SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
                 isAsAdmin = preferences.getBoolean("asadmin_" + dialog_id, true);
@@ -726,8 +867,9 @@ public void setDialogId(long id) {
 
     private void updateFieldHint() {
         boolean isChannel = false;
-        if ((int) dialog_id < 0 && ChatObject.isChannel(MessagesController.getInstance().getChat(-(int) dialog_id))) {
-            isChannel = true;
+        if ((int) dialog_id < 0) {
+            TLRPC.Chat chat = MessagesController.getInstance().getChat(-(int) dialog_id);
+            isChannel = ChatObject.isChannel(chat) && !chat.megagroup;
         }
         if (isChannel) {
             messageEditText.setHint(isAsAdmin ? LocaleController.getString("ChannelBroadcast", R.string.ChannelBroadcast) : LocaleController.getString("ChannelComment", R.string.ChannelComment));
@@ -807,9 +949,9 @@ public boolean processSendingText(String text) {
     }
 
     private String getTrimmedString(String src) {
-        String result = src.trim();
-        if (result.length() == 0) {
-            return result;
+        src = src.trim();
+        if (src.length() == 0) {
+            return src;
         }
         while (src.startsWith("\n")) {
             src = src.substring(1);
@@ -877,7 +1019,7 @@ public void onAnimationEnd(Object animation) {
                     runningAnimation.addListener(new AnimatorListenerAdapterProxy() {
                         @Override
                         public void onAnimationEnd(Object animation) {
-                            if (runningAnimation.equals(animation)) {
+                            if (runningAnimation != null && runningAnimation.equals(animation)) {
                                 sendButton.setVisibility(View.VISIBLE);
                                 audioSendButton.setVisibility(View.GONE);
                                 audioSendButton.clearAnimation();
@@ -952,7 +1094,7 @@ public void onAnimationEnd(Object animation) {
                 runningAnimation.addListener(new AnimatorListenerAdapterProxy() {
                     @Override
                     public void onAnimationEnd(Object animation) {
-                        if (runningAnimation.equals(animation)) {
+                        if (runningAnimation != null && runningAnimation.equals(animation)) {
                             sendButton.setVisibility(View.GONE);
                             sendButton.clearAnimation();
                             audioSendButton.setVisibility(View.VISIBLE);
@@ -1023,8 +1165,11 @@ private void updateAudioRecordIntefrace() {
             }
             AndroidUtilities.lockOrientation(parentActivity);
 
-            recordPanel.setVisibility(View.VISIBLE);
+            recordPanel.setVisibility(VISIBLE);
+            recordCircle.setVisibility(VISIBLE);
+            recordCircle.setAmplitude(0);
             recordTimeText.setText("00:00");
+            recordDot.resetAlpha();
             lastTimeString = null;
 
             FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) slideText.getLayoutParams();
@@ -1032,19 +1177,25 @@ private void updateAudioRecordIntefrace() {
             slideText.setLayoutParams(params);
             ViewProxy.setAlpha(slideText, 1);
             ViewProxy.setX(recordPanel, AndroidUtilities.displaySize.x);
+            ViewProxy.setTranslationX(recordCircle, 0);
             if (runningAnimationAudio != null) {
                 runningAnimationAudio.cancel();
             }
-            runningAnimationAudio = ObjectAnimatorProxy.ofFloatProxy(recordPanel, "translationX", 0).setDuration(300);
+            runningAnimationAudio = new AnimatorSetProxy();
+            runningAnimationAudio.playTogether(ObjectAnimatorProxy.ofFloat(recordPanel, "translationX", 0),
+                    ObjectAnimatorProxy.ofFloat(recordCircle, "scale", 1),
+                    ObjectAnimatorProxy.ofFloat(audioSendButton, "alpha", 0));
+            runningAnimationAudio.setDuration(300);
             runningAnimationAudio.addListener(new AnimatorListenerAdapterProxy() {
                 @Override
                 public void onAnimationEnd(Object animator) {
                     if (runningAnimationAudio != null && runningAnimationAudio.equals(animator)) {
                         ViewProxy.setX(recordPanel, 0);
+                        runningAnimationAudio = null;
                     }
                 }
             });
-            runningAnimationAudio.setInterpolator(new AccelerateDecelerateInterpolator());
+            runningAnimationAudio.setInterpolator(new DecelerateInterpolator());
             runningAnimationAudio.start();
         } else {
             if (mWakeLock != null) {
@@ -1064,7 +1215,11 @@ public void onAnimationEnd(Object animator) {
             if (runningAnimationAudio != null) {
                 runningAnimationAudio.cancel();
             }
-            runningAnimationAudio = ObjectAnimatorProxy.ofFloatProxy(recordPanel, "translationX", AndroidUtilities.displaySize.x).setDuration(300);
+            runningAnimationAudio = new AnimatorSetProxy();
+            runningAnimationAudio.playTogether(ObjectAnimatorProxy.ofFloat(recordPanel, "translationX", AndroidUtilities.displaySize.x),
+                    ObjectAnimatorProxy.ofFloat(recordCircle, "scale", 0.0f),
+                    ObjectAnimatorProxy.ofFloat(audioSendButton, "alpha", 1.0f));
+            runningAnimationAudio.setDuration(300);
             runningAnimationAudio.addListener(new AnimatorListenerAdapterProxy() {
                 @Override
                 public void onAnimationEnd(Object animator) {
@@ -1074,10 +1229,12 @@ public void onAnimationEnd(Object animator) {
                         slideText.setLayoutParams(params);
                         ViewProxy.setAlpha(slideText, 1);
                         recordPanel.setVisibility(View.GONE);
+                        recordCircle.setVisibility(View.GONE);
+                        runningAnimationAudio = null;
                     }
                 }
             });
-            runningAnimationAudio.setInterpolator(new AccelerateDecelerateInterpolator());
+            runningAnimationAudio.setInterpolator(new AccelerateInterpolator());
             runningAnimationAudio.start();
         }
     }
@@ -1086,22 +1243,33 @@ public void setDelegate(ChatActivityEnterViewDelegate delegate) {
         this.delegate = delegate;
     }
 
-    public void setCommand(MessageObject messageObject, String command) {
+    public void setCommand(MessageObject messageObject, String command, boolean longPress, boolean username) {
         if (command == null || getVisibility() != VISIBLE) {
             return;
         }
-        TLRPC.User user = messageObject != null && (int) dialog_id < 0 ? MessagesController.getInstance().getUser(messageObject.messageOwner.from_id) : null;
-        if (botCount != 1 && user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0 && !command.contains("@")) {
-            SendMessagesHelper.getInstance().sendMessage(String.format(Locale.US, "%s@%s", command, user.username), dialog_id, null, null, false, asAdmin());
+        if (longPress) {
+            String text = messageEditText.getText().toString();
+            TLRPC.User user = messageObject != null && (int) dialog_id < 0 ? MessagesController.getInstance().getUser(messageObject.messageOwner.from_id) : null;
+            if ((botCount != 1 || username) && user != null && user.bot && !command.contains("@")) {
+                text = String.format(Locale.US, "%s@%s", command, user.username) + " " + text.replaceFirst("^/[a-zA-Z@\\d_]{1,255}(\\s|$)", "");
+            } else {
+                text = command + " " + text.replaceFirst("^/[a-zA-Z@\\d_]{1,255}(\\s|$)", "");
+            }
+            ignoreTextChange = true;
+            messageEditText.setText(text);
+            messageEditText.setSelection(messageEditText.getText().length());
+            ignoreTextChange = false;
+            if (!keyboardVisible && currentPopupContentType == -1) {
+                openKeyboard();
+            }
         } else {
-            SendMessagesHelper.getInstance().sendMessage(command, dialog_id, null, null, false, asAdmin());
+            TLRPC.User user = messageObject != null && (int) dialog_id < 0 ? MessagesController.getInstance().getUser(messageObject.messageOwner.from_id) : null;
+            if ((botCount != 1 || username) && user != null && user.bot && !command.contains("@")) {
+                SendMessagesHelper.getInstance().sendMessage(String.format(Locale.US, "%s@%s", command, user.username), dialog_id, null, null, false, asAdmin());
+            } else {
+                SendMessagesHelper.getInstance().sendMessage(command, dialog_id, null, null, false, asAdmin());
+            }
         }
-        /*String text = messageEditText.getText().toString();
-        text = command + " " + text.replaceFirst("^/[a-zA-Z@\\d_]{1,255}(\\s|$)", "");
-        ignoreTextChange = true;
-        messageEditText.setText(text);
-        messageEditText.setSelection(messageEditText.getText().length());
-        ignoreTextChange = false;*/
     }
 
     public void setFieldText(String text) {
@@ -1117,6 +1285,13 @@ public void setFieldText(String text) {
         }
     }
 
+    public void setSelection(int start) {
+        if (messageEditText == null) {
+            return;
+        }
+        messageEditText.setSelection(start, messageEditText.length());
+    }
+
     public int getCursorPosition() {
         if (messageEditText == null) {
             return 0;
@@ -1239,7 +1414,7 @@ public void didPressedButton(CharSequence text) {
                     if (replyingMessageObject != null) {
                         openKeyboardInternal();
                         setButtons(botMessageObject, false);
-                    } else if ((botButtonsMessageObject.messageOwner.reply_markup.flags & 2) != 0) {
+                    } else if (botButtonsMessageObject.messageOwner.reply_markup.single_use) {
                         openKeyboardInternal();
                         SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
                         preferences.edit().putInt("answered_" + dialog_id, botButtonsMessageObject.getId()).commit();
@@ -1259,7 +1434,7 @@ public void didPressedButton(CharSequence text) {
         if (botReplyMarkup != null) {
             SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
             boolean keyboardHidden = preferences.getInt("hidekeyboard_" + dialog_id, 0) == messageObject.getId();
-            if (botButtonsMessageObject != replyingMessageObject && (botReplyMarkup.flags & 2) != 0) {
+            if (botButtonsMessageObject != replyingMessageObject && botReplyMarkup.single_use) {
                 if (preferences.getInt("answered_" + dialog_id, 0) == messageObject.getId()) {
                     return;
                 }
@@ -1283,6 +1458,10 @@ public boolean isPopupView(View view) {
         return view == botKeyboardView || view == emojiView;
     }
 
+    public boolean isRecordCircle(View view) {
+        return view == recordCircle;
+    }
+
     private void showPopup(int show, int contentType) {
         if (show == 1) {
             if (contentType == 0 && emojiView == null) {
@@ -1307,7 +1486,7 @@ public void onEmojiSelected(String symbol) {
                         }
                         try {
                             innerTextChange = 2;
-                            CharSequence localCharSequence = Emoji.replaceEmoji(symbol/* + "\uFE0F"*/, messageEditText.getPaint().getFontMetricsInt(), AndroidUtilities.dp(20), false);
+                            CharSequence localCharSequence = Emoji.replaceEmoji(symbol, messageEditText.getPaint().getFontMetricsInt(), AndroidUtilities.dp(20), false);
                             messageEditText.setText(messageEditText.getText().insert(i, localCharSequence));
                             int j = i + localCharSequence.length();
                             messageEditText.setSelection(j, j);
@@ -1324,6 +1503,13 @@ public void onStickerSelected(TLRPC.Document sticker) {
                             delegate.onMessageSend(null);
                         }
                     }
+
+                    @Override
+                    public void onStickersSettingsClick() {
+                        if (parentFragment != null) {
+                            parentFragment.presentFragment(new StickersActivity());
+                        }
+                    }
                 });
                 sizeNotifierLayout.addView(emojiView);
             }
@@ -1378,6 +1564,7 @@ public void onStickerSelected(TLRPC.Document sticker) {
             if (emojiButton != null) {
                 emojiButton.setImageResource(R.drawable.ic_msg_panel_smiles);
             }
+            currentPopupContentType = -1;
             if (emojiView != null) {
                 emojiView.setVisibility(GONE);
             }
@@ -1422,6 +1609,10 @@ public void openKeyboard() {
         AndroidUtilities.showKeyboard(messageEditText);
     }
 
+    public void closeKeyboard() {
+        AndroidUtilities.hideKeyboard(messageEditText);
+    }
+
     public boolean isPopupShowing() {
         return emojiView != null && emojiView.getVisibility() == VISIBLE || botKeyboardView != null && botKeyboardView.getVisibility() == VISIBLE;
     }
@@ -1522,6 +1713,9 @@ public void didReceivedNotification(int id, Object... args) {
                     recordTimeText.setText(str);
                 }
             }
+            if (recordCircle != null) {
+                recordCircle.setAmplitude((Double) args[1]);
+            }
         } else if (id == NotificationCenter.closeChats) {
             if (messageEditText != null && messageEditText.isFocused()) {
                 AndroidUtilities.hideKeyboard(messageEditText);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatAttachView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatAttachView.java
index 763d7bd04..448b02c3c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatAttachView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChatAttachView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -8,12 +8,15 @@
 
 package org.telegram.ui.Components;
 
+import android.Manifest;
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
 import android.animation.ObjectAnimator;
 import android.annotation.SuppressLint;
 import android.content.Context;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
 import android.os.Build;
 import android.text.TextUtils;
 import android.util.TypedValue;
@@ -27,19 +30,23 @@
 import android.widget.TextView;
 
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.AnimationCompat.ViewProxy;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.MediaController;
+import org.telegram.messenger.MessageObject;
 import org.telegram.messenger.NotificationCenter;
 import org.telegram.messenger.support.widget.LinearLayoutManager;
 import org.telegram.messenger.R;
+import org.telegram.tgnet.TLRPC;
 import org.telegram.ui.Adapters.PhotoAttachAdapter;
 import org.telegram.ui.Cells.PhotoAttachPhotoCell;
 import org.telegram.ui.ChatActivity;
+import org.telegram.ui.PhotoViewer;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 
-public class ChatAttachView extends FrameLayout implements NotificationCenter.NotificationCenterDelegate {
+public class ChatAttachView extends FrameLayout implements NotificationCenter.NotificationCenterDelegate, PhotoViewer.PhotoViewerProvider {
 
     public interface ChatAttachViewDelegate {
         void didPressedButton(int button);
@@ -132,14 +139,30 @@ public void selectedPhotosChanged() {
             }
         });
         attachPhotoRecyclerView.setOnItemClickListener(new RecyclerListView.OnItemClickListener() {
+            @SuppressWarnings("unchecked")
             @Override
             public void onItemClick(View view, int position) {
-                photoAttachAdapter.onItemClick((PhotoAttachPhotoCell) view);
+                if (baseFragment == null || baseFragment.getParentActivity() == null) {
+                    return;
+                }
+                ArrayList<Object> arrayList = (ArrayList) MediaController.allPhotosAlbumEntry.photos;
+                if (position < 0 || position >= arrayList.size()) {
+                    return;
+                }
+                PhotoViewer.getInstance().setParentActivity(baseFragment.getParentActivity());
+                PhotoViewer.getInstance().openPhotoForSelect(arrayList, position, 0, ChatAttachView.this, baseFragment);
+                AndroidUtilities.hideKeyboard(baseFragment.getFragmentView().findFocus());
             }
         });
 
         views[9] = progressView = new EmptyTextProgressView(context);
-        progressView.setText(LocaleController.getString("NoPhotos", R.string.NoPhotos));
+        if (Build.VERSION.SDK_INT >= 23 && getContext().checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+            progressView.setText(LocaleController.getString("PermissionStorage", R.string.PermissionStorage));
+            progressView.setTextSize(16);
+        } else {
+            progressView.setText(LocaleController.getString("NoPhotos", R.string.NoPhotos));
+            progressView.setTextSize(20);
+        }
         addView(progressView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 80));
         attachPhotoRecyclerView.setEmptyView(progressView);
 
@@ -245,6 +268,14 @@ public void updatePhotosButton() {
             sendPhotosButton.imageView.setImageResource(R.drawable.attach_send2);
             sendPhotosButton.textView.setText(LocaleController.formatString("SendItems", R.string.SendItems, String.format("(%d)", count)));
         }
+
+        if (Build.VERSION.SDK_INT >= 23 && getContext().checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+            progressView.setText(LocaleController.getString("PermissionStorage", R.string.PermissionStorage));
+            progressView.setTextSize(16);
+        } else {
+            progressView.setText(LocaleController.getString("NoPhotos", R.string.NoPhotos));
+            progressView.setTextSize(20);
+        }
     }
 
     public void setDelegate(ChatAttachViewDelegate chatAttachViewDelegate) {
@@ -332,6 +363,14 @@ public void onAnimationEnd(Animator animation) {
     }
 
     public void init(ChatActivity parentFragment) {
+        if (MediaController.allPhotosAlbumEntry != null) {
+            for (int a = 0; a < Math.min(100, MediaController.allPhotosAlbumEntry.photos.size()); a++) {
+                MediaController.PhotoEntry photoEntry = MediaController.allPhotosAlbumEntry.photos.get(a);
+                photoEntry.caption = null;
+                photoEntry.imagePath = null;
+                photoEntry.thumbPath = null;
+            }
+        }
         attachPhotoLayoutManager.scrollToPositionWithOffset(0, 1000000);
         photoAttachAdapter.clearSelectedPhotos();
         baseFragment = parentFragment;
@@ -346,4 +385,142 @@ public void onDestroy() {
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.albumsDidLoaded);
         baseFragment = null;
     }
+
+    private PhotoAttachPhotoCell getCellForIndex(int index) {
+        int count = attachPhotoRecyclerView.getChildCount();
+        for (int a = 0; a < count; a++) {
+            View view = attachPhotoRecyclerView.getChildAt(a);
+            if (view instanceof PhotoAttachPhotoCell) {
+                PhotoAttachPhotoCell cell = (PhotoAttachPhotoCell) view;
+                int num = (Integer) cell.getImageView().getTag();
+                if (num < 0 || num >= MediaController.allPhotosAlbumEntry.photos.size()) {
+                    continue;
+                }
+                if (num == index) {
+                    return cell;
+                }
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public PhotoViewer.PlaceProviderObject getPlaceForPhoto(MessageObject messageObject, TLRPC.FileLocation fileLocation, int index) {
+        PhotoAttachPhotoCell cell = getCellForIndex(index);
+        if (cell != null) {
+            int coords[] = new int[2];
+            cell.getImageView().getLocationInWindow(coords);
+            PhotoViewer.PlaceProviderObject object = new PhotoViewer.PlaceProviderObject();
+            object.viewX = coords[0];
+            object.viewY = coords[1] - (Build.VERSION.SDK_INT >= 21 ? AndroidUtilities.statusBarHeight : 0);
+            object.parentView = attachPhotoRecyclerView;
+            object.imageReceiver = cell.getImageView().getImageReceiver();
+            object.thumb = object.imageReceiver.getBitmap();
+            object.scale = ViewProxy.getScaleX(cell.getImageView());
+            object.clipBottomAddition = (Build.VERSION.SDK_INT >= 21 ? 0 : -AndroidUtilities.statusBarHeight);
+            cell.getCheckBox().setVisibility(View.GONE);
+            return object;
+        }
+        return null;
+    }
+
+    @Override
+    public void updatePhotoAtIndex(int index) {
+        PhotoAttachPhotoCell cell = getCellForIndex(index);
+        if (cell != null) {
+            cell.getImageView().setOrientation(0, true);
+            MediaController.PhotoEntry photoEntry = MediaController.allPhotosAlbumEntry.photos.get(index);
+            if (photoEntry.thumbPath != null) {
+                cell.getImageView().setImage(photoEntry.thumbPath, null, cell.getContext().getResources().getDrawable(R.drawable.nophotos));
+            } else if (photoEntry.path != null) {
+                cell.getImageView().setOrientation(photoEntry.orientation, true);
+                cell.getImageView().setImage("thumb://" + photoEntry.imageId + ":" + photoEntry.path, null, cell.getContext().getResources().getDrawable(R.drawable.nophotos));
+            } else {
+                cell.getImageView().setImageResource(R.drawable.nophotos);
+            }
+        }
+    }
+
+    @Override
+    public Bitmap getThumbForPhoto(MessageObject messageObject, TLRPC.FileLocation fileLocation, int index) {
+        PhotoAttachPhotoCell cell = getCellForIndex(index);
+        if (cell != null) {
+            return cell.getImageView().getImageReceiver().getBitmap();
+        }
+        return null;
+    }
+
+    @Override
+    public void willSwitchFromPhoto(MessageObject messageObject, TLRPC.FileLocation fileLocation, int index) {
+        PhotoAttachPhotoCell cell = getCellForIndex(index);
+        if (cell != null) {
+            cell.getCheckBox().setVisibility(View.VISIBLE);
+        }
+    }
+
+    @Override
+    public void willHidePhotoViewer() {
+        int count = attachPhotoRecyclerView.getChildCount();
+        for (int a = 0; a < count; a++) {
+            View view = attachPhotoRecyclerView.getChildAt(a);
+            if (view instanceof PhotoAttachPhotoCell) {
+                PhotoAttachPhotoCell cell = (PhotoAttachPhotoCell) view;
+                if (cell.getCheckBox().getVisibility() != VISIBLE) {
+                    cell.getCheckBox().setVisibility(VISIBLE);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean isPhotoChecked(int index) {
+        return !(index < 0 || index >= MediaController.allPhotosAlbumEntry.photos.size()) && photoAttachAdapter.getSelectedPhotos().containsKey(MediaController.allPhotosAlbumEntry.photos.get(index).imageId);
+    }
+
+    @Override
+    public void setPhotoChecked(int index) {
+        boolean add = true;
+        if (index < 0 || index >= MediaController.allPhotosAlbumEntry.photos.size()) {
+            return;
+        }
+        MediaController.PhotoEntry photoEntry = MediaController.allPhotosAlbumEntry.photos.get(index);
+        if (photoAttachAdapter.getSelectedPhotos().containsKey(photoEntry.imageId)) {
+            photoAttachAdapter.getSelectedPhotos().remove(photoEntry.imageId);
+            add = false;
+        } else {
+            photoAttachAdapter.getSelectedPhotos().put(photoEntry.imageId, photoEntry);
+        }
+        int count = attachPhotoRecyclerView.getChildCount();
+        for (int a = 0; a < count; a++) {
+            View view = attachPhotoRecyclerView.getChildAt(a);
+            int num = (Integer) view.getTag();
+            if (num == index) {
+                ((PhotoAttachPhotoCell) view).setChecked(add, false);
+                break;
+            }
+        }
+        updatePhotosButton();
+    }
+
+    @Override
+    public boolean cancelButtonPressed() {
+        return false;
+    }
+
+    @Override
+    public void sendButtonPressed(int index) {
+        if (photoAttachAdapter.getSelectedPhotos().isEmpty()) {
+            if (index < 0 || index >= MediaController.allPhotosAlbumEntry.photos.size()) {
+                return;
+            }
+            MediaController.PhotoEntry photoEntry = MediaController.allPhotosAlbumEntry.photos.get(index);
+            photoAttachAdapter.getSelectedPhotos().put(photoEntry.imageId, photoEntry);
+        }
+        delegate.didPressedButton(7);
+    }
+
+    @Override
+    public int getSelectedCount() {
+        return photoAttachAdapter.getSelectedPhotos().size();
+    }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CheckBox.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CheckBox.java
index 6a0f06278..52af2a112 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/CheckBox.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CheckBox.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/CheckBoxSquare.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/CheckBoxSquare.java
new file mode 100644
index 000000000..1148bbb79
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/CheckBoxSquare.java
@@ -0,0 +1,183 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.RectF;
+import android.view.View;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
+
+public class CheckBoxSquare extends View {
+
+    private static Paint eraser;
+    private static Paint checkPaint;
+    private static Paint backgroundPaint;
+    private static RectF rectF;
+
+    private Bitmap drawBitmap;
+    private Canvas drawCanvas;
+
+    private float progress;
+    private ObjectAnimatorProxy checkAnimator;
+
+    private boolean attachedToWindow;
+    private boolean isChecked;
+    private boolean isDisabled;
+
+    private int color = 0xff43a0df;
+
+    private final static float progressBounceDiff = 0.2f;
+
+    public CheckBoxSquare(Context context) {
+        super(context);
+        if (checkPaint == null) {
+            checkPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            checkPaint.setColor(0xffffffff);
+            checkPaint.setStyle(Paint.Style.STROKE);
+            checkPaint.setStrokeWidth(AndroidUtilities.dp(2));
+            eraser = new Paint(Paint.ANTI_ALIAS_FLAG);
+            eraser.setColor(0);
+            eraser.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
+            backgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            rectF = new RectF();
+        }
+
+        drawBitmap = Bitmap.createBitmap(AndroidUtilities.dp(18), AndroidUtilities.dp(18), Bitmap.Config.ARGB_4444);
+        drawCanvas = new Canvas(drawBitmap);
+    }
+
+    @Override
+    public void setVisibility(int visibility) {
+        super.setVisibility(visibility);
+        if (visibility == VISIBLE && drawBitmap == null) {
+
+        }
+    }
+
+    public void setProgress(float value) {
+        if (progress == value) {
+            return;
+        }
+        progress = value;
+        invalidate();
+    }
+
+    public float getProgress() {
+        return progress;
+    }
+
+    public void setColor(int value) {
+        color = value;
+    }
+
+    private void cancelCheckAnimator() {
+        if (checkAnimator != null) {
+            checkAnimator.cancel();
+        }
+    }
+
+    private void animateToCheckedState(boolean newCheckedState) {
+        checkAnimator = ObjectAnimatorProxy.ofFloatProxy(this, "progress", newCheckedState ? 1 : 0);
+        checkAnimator.setDuration(300);
+        checkAnimator.start();
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        attachedToWindow = true;
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        attachedToWindow = false;
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+    }
+
+    public void setChecked(boolean checked, boolean animated) {
+        if (checked == isChecked) {
+            return;
+        }
+        isChecked = checked;
+        if (attachedToWindow && animated) {
+            animateToCheckedState(checked);
+        } else {
+            cancelCheckAnimator();
+            setProgress(checked ? 1.0f : 0.0f);
+        }
+    }
+
+    public void setDisabled(boolean disabled) {
+        isDisabled = disabled;
+        invalidate();
+    }
+
+    public boolean isChecked() {
+        return isChecked;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (getVisibility() != VISIBLE) {
+            return;
+        }
+
+        float checkProgress;
+        float bounceProgress;
+        if (progress <= 0.5f) {
+            bounceProgress = checkProgress = progress / 0.5f;
+            int rD = (int) ((Color.red(color) - 0x73) * checkProgress);
+            int gD = (int) ((Color.green(color) - 0x73) * checkProgress);
+            int bD = (int) ((Color.blue(color) - 0x73) * checkProgress);
+            int c = Color.rgb(0x73 + rD, 0x73 + gD, 0x73 + bD);
+            backgroundPaint.setColor(c);
+        } else {
+            bounceProgress = 2.0f - progress / 0.5f;
+            checkProgress = 1.0f;
+            backgroundPaint.setColor(color);
+        }
+        if (isDisabled) {
+            backgroundPaint.setColor(0xffb0b0b0);
+        }
+        float bounce = AndroidUtilities.dp(1) * bounceProgress;
+        rectF.set(bounce, bounce, AndroidUtilities.dp(18) - bounce, AndroidUtilities.dp(18) - bounce);
+
+        drawBitmap.eraseColor(0);
+        drawCanvas.drawRoundRect(rectF, AndroidUtilities.dp(2), AndroidUtilities.dp(2), backgroundPaint);
+
+        if (checkProgress != 1) {
+            float rad = Math.min(AndroidUtilities.dp(7), AndroidUtilities.dp(7) * checkProgress + bounce);
+            rectF.set(AndroidUtilities.dp(2) + rad, AndroidUtilities.dp(2) + rad, AndroidUtilities.dp(16) - rad, AndroidUtilities.dp(16) - rad);
+            drawCanvas.drawRect(rectF, eraser);
+        }
+
+        if (progress > 0.5f) {
+            int endX = (int) (AndroidUtilities.dp(7.5f) - AndroidUtilities.dp(5) * (1.0f - bounceProgress));
+            int endY = (int) (AndroidUtilities.dpf2(13.5f) - AndroidUtilities.dp(5) * (1.0f - bounceProgress));
+            drawCanvas.drawLine(AndroidUtilities.dp(7.5f), (int) AndroidUtilities.dpf2(13.5f), endX, endY, checkPaint);
+            endX = (int) (AndroidUtilities.dpf2(6.5f) + AndroidUtilities.dp(9) * (1.0f - bounceProgress));
+            endY = (int) (AndroidUtilities.dpf2(13.5f) - AndroidUtilities.dp(9) * (1.0f - bounceProgress));
+            drawCanvas.drawLine((int) AndroidUtilities.dpf2(6.5f), (int) AndroidUtilities.dpf2(13.5f), endX, endY, checkPaint);
+        }
+        canvas.drawBitmap(drawBitmap, 0, 0, null);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChipSpan.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChipSpan.java
index c780bc7a6..c148376e4 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ChipSpan.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ChipSpan.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ClippingImageView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ClippingImageView.java
index 59ec72db5..a9ddcaacc 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ClippingImageView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ClippingImageView.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/DrawerPlayerView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/DrawerPlayerView.java
deleted file mode 100644
index cabb49243..000000000
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/DrawerPlayerView.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * This is the source code of Telegram for Android v. 2.x.x.
- * It is licensed under GNU GPL v. 2 or later.
- * You should have received a copy of the license in this archive (see LICENSE).
- *
- * Copyright Nikolai Kudashov, 2013-2015.
- */
-
-package org.telegram.ui.Components;
-
-import android.content.Context;
-import android.text.TextUtils;
-import android.util.TypedValue;
-import android.view.Gravity;
-import android.view.View;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.ListView;
-import android.widget.TextView;
-
-import org.telegram.messenger.AndroidUtilities;
-import org.telegram.messenger.MediaController;
-import org.telegram.messenger.MessageObject;
-import org.telegram.messenger.NotificationCenter;
-import org.telegram.messenger.R;
-
-public class DrawerPlayerView extends FrameLayout implements NotificationCenter.NotificationCenterDelegate {
-
-    private ImageView playButton;
-    private TextView titleTextView;
-    private ListView parentListView;
-    private MessageObject lastMessageObject;
-
-    public DrawerPlayerView(Context context, ListView listView) {
-        super(context);
-        parentListView = listView;
-
-        View shadow = new View(context);
-        shadow.setBackgroundResource(R.drawable.header_shadow_reverse);
-        addView(shadow, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 3));
-
-        FrameLayout frameLayout = new FrameLayout(context);
-        frameLayout.setBackgroundColor(0xffffffff);
-        addView(frameLayout, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 0, 3, 0, 0));
-
-        playButton = new ImageView(context);
-        playButton.setScaleType(ImageView.ScaleType.CENTER);
-        addView(playButton, LayoutHelper.createFrame(48, 48, Gravity.TOP | Gravity.LEFT, 2, 3, 0, 0));
-        playButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                if (MediaController.getInstance().isAudioPaused()) {
-                    MediaController.getInstance().playAudio(MediaController.getInstance().getPlayingMessageObject());
-                } else {
-                    MediaController.getInstance().pauseAudio(MediaController.getInstance().getPlayingMessageObject());
-                }
-            }
-        });
-
-        titleTextView = new TextView(context);
-        titleTextView.setTextColor(0xff15a5ed);
-        titleTextView.setMaxLines(1);
-        titleTextView.setLines(1);
-        titleTextView.setSingleLine(true);
-        titleTextView.setEllipsize(TextUtils.TruncateAt.END);
-        titleTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15);
-        titleTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        titleTextView.setGravity(Gravity.CENTER_VERTICAL);
-        addView(titleTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 48, Gravity.LEFT | Gravity.TOP, 72, 3, 8, 0));
-
-        checkPlayer();
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.audioDidReset);
-        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.audioPlayStateChanged);
-        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.audioDidStarted);
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.audioDidReset);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.audioPlayStateChanged);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.audioDidStarted);
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, AndroidUtilities.dp(51));
-    }
-
-    @Override
-    public void didReceivedNotification(int id, Object... args) {
-        if (id == NotificationCenter.audioDidStarted || id == NotificationCenter.audioPlayStateChanged || id == NotificationCenter.audioDidReset) {
-            checkPlayer();
-        }
-    }
-
-    private void checkPlayer() {
-        MessageObject messageObject = MediaController.getInstance().getPlayingMessageObject();
-        if (messageObject == null || !messageObject.isMusic()) {
-            lastMessageObject = null;
-            if (getVisibility() != GONE) {
-                setVisibility(GONE);
-                FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) parentListView.getLayoutParams();
-                layoutParams.bottomMargin = 0;
-                parentListView.setLayoutParams(layoutParams);
-            }
-        } else {
-            if (getVisibility() != VISIBLE) {
-                setVisibility(VISIBLE);
-                FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) parentListView.getLayoutParams();
-                layoutParams.bottomMargin = AndroidUtilities.dp(48);
-                parentListView.setLayoutParams(layoutParams);
-            }
-            if (MediaController.getInstance().isAudioPaused()) {
-                playButton.setImageResource(R.drawable.menu_play);
-            } else {
-                playButton.setImageResource(R.drawable.menu_pause);
-            }
-            if (lastMessageObject != messageObject) {
-                lastMessageObject = messageObject;
-                titleTextView.setText(String.format("%s - %s", messageObject.getMusicAuthor(), messageObject.getMusicTitle()));
-            }
-        }
-    }
-}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
index 0828ca98d..4b05d9946 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmojiView.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
@@ -12,15 +12,22 @@
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.database.DataSetObserver;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.support.v4.view.PagerAdapter;
 import android.support.v4.view.ViewPager;
 import android.util.TypedValue;
 import android.view.Gravity;
 import android.view.HapticFeedbackConstants;
+import android.view.KeyEvent;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.view.WindowManager;
 import android.widget.AbsListView;
 import android.widget.AdapterView;
 import android.widget.BaseAdapter;
@@ -28,11 +35,13 @@
 import android.widget.GridView;
 import android.widget.ImageView;
 import android.widget.LinearLayout;
+import android.widget.PopupWindow;
 import android.widget.TextView;
 
 import org.telegram.messenger.AndroidUtilities;
 import org.telegram.messenger.AnimationCompat.ViewProxy;
 import org.telegram.messenger.Emoji;
+import org.telegram.messenger.EmojiData;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.NotificationCenter;
 import org.telegram.messenger.query.StickersQuery;
@@ -43,6 +52,7 @@
 import org.telegram.ui.Cells.StickerEmojiCell;
 import org.telegram.ui.StickerPreviewViewer;
 
+import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -54,14 +64,420 @@
         boolean onBackspace();
         void onEmojiSelected(String emoji);
         void onStickerSelected(TLRPC.Document sticker);
+        void onStickersSettingsClick();
+    }
+
+    private static final Field superListenerField;
+    static {
+        Field f = null;
+        try {
+            f = PopupWindow.class.getDeclaredField("mOnScrollChangedListener");
+            f.setAccessible(true);
+        } catch (NoSuchFieldException e) {
+            /* ignored */
+        }
+        superListenerField = f;
+    }
+    private static final ViewTreeObserver.OnScrollChangedListener NOP = new ViewTreeObserver.OnScrollChangedListener() {
+        @Override
+        public void onScrollChanged() {
+            /* do nothing */
+        }
+    };
+
+    private class ImageViewEmoji extends ImageView {
+
+        private boolean touched;
+        private float lastX;
+        private float lastY;
+        private float touchedX;
+        private float touchedY;
+
+        public ImageViewEmoji(Context context) {
+            super(context);
+
+            setOnClickListener(new View.OnClickListener() {
+                public void onClick(View view) {
+                    sendEmoji(null);
+                }
+            });
+            setOnLongClickListener(new OnLongClickListener() {
+                @Override
+                public boolean onLongClick(View view) {
+                    String code = (String) view.getTag();
+                    if (EmojiData.emojiColoredMap.containsKey(code)) {
+                        touched = true;
+                        touchedX = lastX;
+                        touchedY = lastY;
+
+                        String color = emojiColor.get(code);
+                        if (color != null) {
+                            switch (color) {
+                                case "\uD83C\uDFFB":
+                                    pickerView.setSelection(1);
+                                    break;
+                                case "\uD83C\uDFFC":
+                                    pickerView.setSelection(2);
+                                    break;
+                                case "\uD83C\uDFFD":
+                                    pickerView.setSelection(3);
+                                    break;
+                                case "\uD83C\uDFFE":
+                                    pickerView.setSelection(4);
+                                    break;
+                                case "\uD83C\uDFFF":
+                                    pickerView.setSelection(5);
+                                    break;
+                            }
+                        } else {
+                            pickerView.setSelection(0);
+                        }
+                        view.getLocationOnScreen(location);
+                        int x = emojiSize * pickerView.getSelection() + AndroidUtilities.dp(4 * pickerView.getSelection() - (AndroidUtilities.isTablet() ? 5 : 1));
+                        if (location[0] - x < AndroidUtilities.dp(5)) {
+                            x += (location[0] - x) - AndroidUtilities.dp(5);
+                        } else if (location[0] - x + popupWidth > AndroidUtilities.displaySize.x - AndroidUtilities.dp(5)) {
+                            x += (location[0] - x + popupWidth) - (AndroidUtilities.displaySize.x - AndroidUtilities.dp(5));
+                        }
+                        int xOffset = -x;
+                        int yOffset = view.getTop() < 0 ? view.getTop() : 0;
+
+                        pickerView.setEmoji(code, AndroidUtilities.dp(AndroidUtilities.isTablet() ? 30 : 22) - xOffset + (int) AndroidUtilities.dpf2(0.5f));
+
+                        pickerViewPopup.setFocusable(true);
+                        pickerViewPopup.showAsDropDown(view, xOffset, -view.getMeasuredHeight() - popupHeight + (view.getMeasuredHeight() - emojiSize) / 2 - yOffset);
+                        view.getParent().requestDisallowInterceptTouchEvent(true);
+                        return true;
+                    }
+                    return false;
+                }
+            });
+            setBackgroundResource(R.drawable.list_selector);
+            setScaleType(ImageView.ScaleType.CENTER);
+        }
+
+        private void sendEmoji(String override) {
+            String code = override != null ? override : (String) getTag();
+            if (override == null) {
+                if (pager.getCurrentItem() != 0) {
+                    String color = emojiColor.get(code);
+                    if (color != null) {
+                        code += color;
+                    }
+                }
+                Integer count = emojiUseHistory.get(code);
+                if (count == null) {
+                    count = 0;
+                }
+                if (count == 0 && emojiUseHistory.size() > 50) {
+                    for (int a = recentEmoji.size() - 1; a >= 0; a--) {
+                        String emoji = recentEmoji.get(a);
+                        emojiUseHistory.remove(emoji);
+                        recentEmoji.remove(a);
+                        if (emojiUseHistory.size() <= 50) {
+                            break;
+                        }
+                    }
+                }
+                emojiUseHistory.put(code, ++count);
+                if (pager.getCurrentItem() != 0) {
+                    sortEmoji();
+                }
+                saveRecentEmoji();
+                adapters.get(0).notifyDataSetChanged();
+                if (listener != null) {
+                    listener.onEmojiSelected(Emoji.fixEmoji(code));
+                }
+            } else {
+                if (listener != null) {
+                    listener.onEmojiSelected(Emoji.fixEmoji(override));
+                }
+            }
+
+        }
+
+        @Override
+        public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+            setMeasuredDimension(View.MeasureSpec.getSize(widthMeasureSpec), View.MeasureSpec.getSize(widthMeasureSpec));
+        }
+
+        @Override
+        public boolean onTouchEvent(MotionEvent event) {
+            if (touched) {
+                if (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL) {
+                    if (pickerViewPopup != null && pickerViewPopup.isShowing()) {
+                        pickerViewPopup.dismiss();
+
+                        String color = null;
+                        switch (pickerView.getSelection()) {
+                            case 1:
+                                color = "\uD83C\uDFFB";
+                                break;
+                            case 2:
+                                color = "\uD83C\uDFFC";
+                                break;
+                            case 3:
+                                color = "\uD83C\uDFFD";
+                                break;
+                            case 4:
+                                color = "\uD83C\uDFFE";
+                                break;
+                            case 5:
+                                color = "\uD83C\uDFFF";
+                                break;
+                        }
+                        String code = (String) getTag();
+                        if (pager.getCurrentItem() != 0) {
+                            if (color != null) {
+                                emojiColor.put(code, color);
+                                code += color;
+                            } else {
+                                emojiColor.remove(code);
+                            }
+                            setImageDrawable(Emoji.getEmojiBigDrawable(code));
+                            sendEmoji(null);
+                            saveEmojiColors();
+                        } else {
+                            sendEmoji(code + (color != null ? color : ""));
+                        }
+                    }
+                    touched = false;
+                    touchedX = -10000;
+                    touchedY = -10000;
+                } else if (event.getAction() == MotionEvent.ACTION_MOVE) {
+                    boolean ignore = false;
+                    if (touchedX != -10000) {
+                        if (Math.abs(touchedX - event.getX()) > AndroidUtilities.getPixelsInCM(0.2f, true) || Math.abs(touchedY - event.getY()) > AndroidUtilities.getPixelsInCM(0.2f, false)) {
+                            touchedX = -10000;
+                            touchedY = -10000;
+                        } else {
+                            ignore = true;
+                        }
+                    }
+                    if (!ignore) {
+                        getLocationOnScreen(location);
+                        float x = location[0] + event.getX();
+                        pickerView.getLocationOnScreen(location);
+                        x -= location[0] + AndroidUtilities.dp(3);
+                        int position = (int) (x / (emojiSize + AndroidUtilities.dp(4)));
+                        if (position < 0) {
+                            position = 0;
+                        } else if (position > 5) {
+                            position = 5;
+                        }
+                        pickerView.setSelection(position);
+                    }
+                }
+            }
+            lastX = event.getX();
+            lastY = event.getY();
+            return super.onTouchEvent(event);
+        }
+    }
+
+    private class EmojiPopupWindow extends PopupWindow {
+
+        private ViewTreeObserver.OnScrollChangedListener mSuperScrollListener;
+        private ViewTreeObserver mViewTreeObserver;
+
+        public EmojiPopupWindow() {
+            super();
+            init();
+        }
+
+        public EmojiPopupWindow(Context context) {
+            super(context);
+            init();
+        }
+
+        public EmojiPopupWindow(int width, int height) {
+            super(width, height);
+            init();
+        }
+
+        public EmojiPopupWindow(View contentView) {
+            super(contentView);
+            init();
+        }
+
+        public EmojiPopupWindow(View contentView, int width, int height, boolean focusable) {
+            super(contentView, width, height, focusable);
+            init();
+        }
+
+        public EmojiPopupWindow(View contentView, int width, int height) {
+            super(contentView, width, height);
+            init();
+        }
+
+        private void init() {
+            if (superListenerField != null) {
+                try {
+                    mSuperScrollListener = (ViewTreeObserver.OnScrollChangedListener) superListenerField.get(this);
+                    superListenerField.set(this, NOP);
+                } catch (Exception e) {
+                    mSuperScrollListener = null;
+                }
+            }
+        }
+
+        private void unregisterListener() {
+            if (mSuperScrollListener != null && mViewTreeObserver != null) {
+                if (mViewTreeObserver.isAlive()) {
+                    mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
+                }
+                mViewTreeObserver = null;
+            }
+        }
+
+        private void registerListener(View anchor) {
+            if (mSuperScrollListener != null) {
+                ViewTreeObserver vto = (anchor.getWindowToken() != null) ? anchor.getViewTreeObserver() : null;
+                if (vto != mViewTreeObserver) {
+                    if (mViewTreeObserver != null && mViewTreeObserver.isAlive()) {
+                        mViewTreeObserver.removeOnScrollChangedListener(mSuperScrollListener);
+                    }
+                    if ((mViewTreeObserver = vto) != null) {
+                        vto.addOnScrollChangedListener(mSuperScrollListener);
+                    }
+                }
+            }
+        }
+
+        @Override
+        public void showAsDropDown(View anchor, int xoff, int yoff) {
+            try {
+                super.showAsDropDown(anchor, xoff, yoff);
+                registerListener(anchor);
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+        }
+
+        @Override
+        public void update(View anchor, int xoff, int yoff, int width, int height) {
+            super.update(anchor, xoff, yoff, width, height);
+            registerListener(anchor);
+        }
+
+        @Override
+        public void update(View anchor, int width, int height) {
+            super.update(anchor, width, height);
+            registerListener(anchor);
+        }
+
+        @Override
+        public void showAtLocation(View parent, int gravity, int x, int y) {
+            super.showAtLocation(parent, gravity, x, y);
+            unregisterListener();
+        }
+
+        @Override
+        public void dismiss() {
+            setFocusable(false);
+            try {
+                super.dismiss();
+            } catch (Exception e) {
+                //don't promt
+            }
+            unregisterListener();
+        }
+    }
+
+    private class EmojiColorPickerView extends View {
+
+        private Drawable backgroundDrawable;
+        private Drawable arrowDrawable;
+        private String currentEmoji;
+        private int arrowX;
+        private int selection;
+        private Paint rectPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+        private RectF rect = new RectF();
+
+        public void setEmoji(String emoji, int arrowPosition) {
+            currentEmoji = emoji;
+            arrowX = arrowPosition;
+            rectPaint.setColor(0x2f000000);
+            invalidate();
+        }
+
+        public String getEmoji() {
+            return currentEmoji;
+        }
+
+        public void setSelection(int position) {
+            if (selection == position) {
+                return;
+            }
+            selection = position;
+            invalidate();
+        }
+
+        public int getSelection() {
+            return selection;
+        }
+
+        public EmojiColorPickerView(Context context) {
+            super(context);
+
+            backgroundDrawable = getResources().getDrawable(R.drawable.stickers_back_all);
+            arrowDrawable = getResources().getDrawable(R.drawable.stickers_back_arrow);
+        }
+
+        @Override
+        protected void onDraw(Canvas canvas) {
+            backgroundDrawable.setBounds(0, 0, getMeasuredWidth(), AndroidUtilities.dp(AndroidUtilities.isTablet() ? 60 : 52));
+            backgroundDrawable.draw(canvas);
+
+            arrowDrawable.setBounds(arrowX - AndroidUtilities.dp(9), AndroidUtilities.dp(AndroidUtilities.isTablet() ? 55.5f : 47.5f), arrowX + AndroidUtilities.dp(9), AndroidUtilities.dp((AndroidUtilities.isTablet() ? 55.5f : 47.5f) + 8));
+            arrowDrawable.draw(canvas);
+
+            if (currentEmoji != null) {
+                String code;
+                for (int a = 0; a < 6; a++) {
+                    int x = emojiSize * a + AndroidUtilities.dp(5 + 4 * a);
+                    int y = AndroidUtilities.dp(9);
+                    if (selection == a) {
+                        rect.set(x, y - (int) AndroidUtilities.dpf2(3.5f), x + emojiSize, y + emojiSize + AndroidUtilities.dp(3));
+                        canvas.drawRoundRect(rect, AndroidUtilities.dp(4), AndroidUtilities.dp(4), rectPaint);
+                    }
+                    code = currentEmoji;
+                    if (a != 0) {
+                        code += "\uD83C";
+                        switch (a) {
+                            case 1:
+                                code += "\uDFFB";
+                                break;
+                            case 2:
+                                code += "\uDFFC";
+                                break;
+                            case 3:
+                                code += "\uDFFD";
+                                break;
+                            case 4:
+                                code += "\uDFFE";
+                                break;
+                            case 5:
+                                code += "\uDFFF";
+                                break;
+                        }
+                    }
+                    Drawable drawable = Emoji.getEmojiBigDrawable(code);
+                    if (drawable != null) {
+                        drawable.setBounds(x, y, x + emojiSize, y + emojiSize);
+                        drawable.draw(canvas);
+                    }
+                }
+            }
+        }
     }
 
     private ArrayList<EmojiGridAdapter> adapters = new ArrayList<>();
-    private HashMap<Long, Integer> emojiUseHistory = new HashMap<>();
-    private ArrayList<Long> recentEmoji = new ArrayList<>();
+    private HashMap<String, Integer> emojiUseHistory = new HashMap<>();
+    private static HashMap<String, String> emojiColor = new HashMap<>();
+    private ArrayList<String> recentEmoji = new ArrayList<>();
     private HashMap<Long, Integer> stickersUseHistory = new HashMap<>();
     private ArrayList<TLRPC.Document> recentStickers = new ArrayList<>();
-    private HashMap<Long, Integer> stickerSetsUseCount = new HashMap<>();
     private ArrayList<TLRPC.TL_messages_stickerSet> stickerSets = new ArrayList<>();
 
     private int[] icons = {
@@ -86,6 +502,12 @@
     private AdapterView.OnItemClickListener stickersOnItemClickListener;
     private Runnable openStickerPreviewRunnable;
     private StickerEmojiCell currentStickerPreviewCell;
+    private EmojiColorPickerView pickerView;
+    private EmojiPopupWindow pickerViewPopup;
+    private int popupWidth;
+    private int popupHeight;
+    private int emojiSize;
+    private int location[] = new int[2];
 
     private int startX;
     private int startY;
@@ -102,7 +524,7 @@ public EmojiView(boolean needStickers, Context context) {
 
         showStickers = needStickers;
 
-        for (int i = 0; i < Emoji.data.length + 1; i++) {
+        for (int i = 0; i < EmojiData.dataColored.length + 1; i++) {
             GridView gridView = new GridView(context);
             if (AndroidUtilities.isTablet()) {
                 gridView.setColumnWidth(AndroidUtilities.dp(60));
@@ -274,15 +696,6 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long i)
                     }
                     stickersUseHistory.put(document.id, ++count);
 
-                    long id = StickersQuery.getStickerSetId(document);
-                    if (id != -1) {
-                        count = stickerSetsUseCount.get(id);
-                        if (count == null) {
-                            count = 0;
-                        }
-                        stickerSetsUseCount.put(id, ++count);
-                    }
-
                     saveRecentStickers();
                     if (listener != null) {
                         listener.onStickerSelected(document);
@@ -384,6 +797,12 @@ public void onPageSelected(int page) {
                         return;
                     }
                     int index = page - (recentStickers.isEmpty() ? 1 : 2);
+                    if (index == stickerSets.size()) {
+                        if (listener != null) {
+                            listener.onStickersSettingsClick();
+                        }
+                        return;
+                    }
                     if (index >= stickerSets.size()) {
                         index = stickerSets.size() - 1;
                     }
@@ -508,11 +927,26 @@ public boolean onTouchEvent(MotionEvent event) {
 
         addView(pager, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.LEFT | Gravity.TOP, 0, 48, 0, 0));
 
-        loadRecents();
+        emojiSize = AndroidUtilities.dp(AndroidUtilities.isTablet() ? 40 : 32);
+        pickerView = new EmojiColorPickerView(context);
+        pickerViewPopup = new EmojiPopupWindow(pickerView, popupWidth = AndroidUtilities.dp((AndroidUtilities.isTablet() ? 40 : 32) * 6 + 10 + 4 * 5), popupHeight = AndroidUtilities.dp(AndroidUtilities.isTablet() ? 64 : 56));
+        pickerViewPopup.setOutsideTouchable(true);
+        pickerViewPopup.setClippingEnabled(true);
+        pickerViewPopup.setInputMethodMode(EmojiPopupWindow.INPUT_METHOD_NOT_NEEDED);
+        pickerViewPopup.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED);
+        pickerViewPopup.getContentView().setFocusableInTouchMode(true);
+        pickerViewPopup.getContentView().setOnKeyListener(new OnKeyListener() {
+            @Override
+            public boolean onKey(View v, int keyCode, KeyEvent event) {
+                if (keyCode == KeyEvent.KEYCODE_MENU && event.getRepeatCount() == 0 && event.getAction() == KeyEvent.ACTION_UP && pickerViewPopup != null && pickerViewPopup.isShowing()) {
+                    pickerViewPopup.dismiss();
+                    return true;
+                }
+                return false;
+            }
+        });
 
-        if (Emoji.data[0] == null || Emoji.data[0].length == 0) {
-            pager.setCurrentItem(1);
-        }
+        loadRecents();
     }
 
     private void onPageScrolled(int position, int width, int positionOffsetPixels) {
@@ -581,7 +1015,7 @@ private String convert(long paramLong) {
     private void saveRecentEmoji() {
         SharedPreferences preferences = getContext().getSharedPreferences("emoji", Activity.MODE_PRIVATE);
         StringBuilder stringBuilder = new StringBuilder();
-        for (HashMap.Entry<Long, Integer> entry : emojiUseHistory.entrySet()) {
+        for (HashMap.Entry<String, Integer> entry : emojiUseHistory.entrySet()) {
             if (stringBuilder.length() != 0) {
                 stringBuilder.append(",");
             }
@@ -589,13 +1023,13 @@ private void saveRecentEmoji() {
             stringBuilder.append("=");
             stringBuilder.append(entry.getValue());
         }
-        preferences.edit().putString("emojis", stringBuilder.toString()).commit();
+        preferences.edit().putString("emojis2", stringBuilder.toString()).commit();
     }
 
-    private void saveRecentStickers() {
-        SharedPreferences.Editor editor = getContext().getSharedPreferences("emoji", Activity.MODE_PRIVATE).edit();
+    private void saveEmojiColors() {
+        SharedPreferences preferences = getContext().getSharedPreferences("emoji", Activity.MODE_PRIVATE);
         StringBuilder stringBuilder = new StringBuilder();
-        for (HashMap.Entry<Long, Integer> entry : stickersUseHistory.entrySet()) {
+        for (HashMap.Entry<String, String> entry : emojiColor.entrySet()) {
             if (stringBuilder.length() != 0) {
                 stringBuilder.append(",");
             }
@@ -603,25 +1037,13 @@ private void saveRecentStickers() {
             stringBuilder.append("=");
             stringBuilder.append(entry.getValue());
         }
-        editor.putString("stickers", stringBuilder.toString());
-
-        ArrayList<Long> toRemove = null;
-        for (HashMap.Entry<Long, Integer> entry : stickerSetsUseCount.entrySet()) {
-            if (!StickersQuery.isStickerPackInstalled(entry.getKey())) {
-                if (toRemove == null) {
-                    toRemove = new ArrayList<>();
-                }
-                toRemove.add(entry.getKey());
-            }
-        }
-        if (toRemove != null) {
-            for (int a = 0; a < toRemove.size(); a++) {
-                stickerSetsUseCount.remove(toRemove.get(a));
-            }
-        }
+        preferences.edit().putString("color", stringBuilder.toString()).commit();
+    }
 
-        stringBuilder.setLength(0);
-        for (HashMap.Entry<Long, Integer> entry : stickerSetsUseCount.entrySet()) {
+    private void saveRecentStickers() {
+        SharedPreferences.Editor editor = getContext().getSharedPreferences("emoji", Activity.MODE_PRIVATE).edit();
+        StringBuilder stringBuilder = new StringBuilder();
+        for (HashMap.Entry<Long, Integer> entry : stickersUseHistory.entrySet()) {
             if (stringBuilder.length() != 0) {
                 stringBuilder.append(",");
             }
@@ -629,19 +1051,19 @@ private void saveRecentStickers() {
             stringBuilder.append("=");
             stringBuilder.append(entry.getValue());
         }
-        editor.putString("sets", stringBuilder.toString());
+        editor.putString("stickers", stringBuilder.toString());
 
         editor.commit();
     }
 
     private void sortEmoji() {
         recentEmoji.clear();
-        for (HashMap.Entry<Long, Integer> entry : emojiUseHistory.entrySet()) {
+        for (HashMap.Entry<String, Integer> entry : emojiUseHistory.entrySet()) {
             recentEmoji.add(entry.getKey());
         }
-        Collections.sort(recentEmoji, new Comparator<Long>() {
+        Collections.sort(recentEmoji, new Comparator<String>() {
             @Override
-            public int compare(Long lhs, Long rhs) {
+            public int compare(String lhs, String rhs) {
                 Integer count1 = emojiUseHistory.get(lhs);
                 Integer count2 = emojiUseHistory.get(rhs);
                 if (count1 == null) {
@@ -715,33 +1137,15 @@ private void updateStickerTabs() {
         ArrayList<TLRPC.TL_messages_stickerSet> packs = StickersQuery.getStickerSets();
         for (int a = 0; a < packs.size(); a++) {
             TLRPC.TL_messages_stickerSet pack = packs.get(a);
-            if ((pack.set.flags & 2) != 0 || pack.documents == null || pack.documents.isEmpty()) {
+            if (pack.set.disabled || pack.documents == null || pack.documents.isEmpty()) {
                 continue;
             }
             stickerSets.add(pack);
         }
-        Collections.sort(stickerSets, new Comparator<TLRPC.TL_messages_stickerSet>() {
-            @Override
-            public int compare(TLRPC.TL_messages_stickerSet lhs, TLRPC.TL_messages_stickerSet rhs) {
-                Integer count1 = stickerSetsUseCount.get(lhs.set.id);
-                Integer count2 = stickerSetsUseCount.get(rhs.set.id);
-                if (count1 == null) {
-                    count1 = 0;
-                }
-                if (count2 == null) {
-                    count2 = 0;
-                }
-                if (count1 > count2) {
-                    return -1;
-                } else if (count1 < count2) {
-                    return 1;
-                }
-                return 0;
-            }
-        });
         for (int a = 0; a < stickerSets.size(); a++) {
             scrollSlidingTabStrip.addStickerTab(stickerSets.get(a).documents.get(0));
         }
+        scrollSlidingTabStrip.addIconTab(R.drawable.ic_settings);
         scrollSlidingTabStrip.updateTabStyles();
     }
 
@@ -749,50 +1153,71 @@ public void loadRecents() {
         String str;
         SharedPreferences preferences = getContext().getSharedPreferences("emoji", Activity.MODE_PRIVATE);
 
-        if (preferences.contains("recents")) {
-            try {
-                str = preferences.getString("recents", "");
+        try {
+            emojiUseHistory.clear();
+            if (preferences.contains("emojis")) {
+                str = preferences.getString("emojis", "");
                 if (str != null && str.length() > 0) {
                     String[] args = str.split(",");
-                    for (int i = 0; i < args.length; i++) {
-                        emojiUseHistory.put(Long.parseLong(args[i]), args.length - i);
+                    for (String arg : args) {
+                        String[] args2 = arg.split("=");
+                        long value = Long.parseLong(args2[0]);
+                        String string = "";
+                        for (int a = 0; a < 4; a++) {
+                            char ch = (char) value;
+                            string = String.valueOf(ch) + string;
+                            value >>= 16;
+                            if (value == 0) {
+                                break;
+                            }
+                        }
+                        if (string.length() > 0) {
+                            emojiUseHistory.put(string, Integer.parseInt(args2[1]));
+                        }
                     }
                 }
-            } catch (Exception e) {
-                FileLog.e("tmessages", e);
-            }
-            sortEmoji();
-            preferences.edit().remove("recents").commit();
-            saveRecentEmoji();
-            adapters.get(0).notifyDataSetChanged();
-        } else {
-            try {
-                emojiUseHistory.clear();
-                str = preferences.getString("emojis", "");
+                preferences.edit().remove("emojis").commit();
+                saveRecentEmoji();
+            } else {
+                str = preferences.getString("emojis2", "");
                 if (str != null && str.length() > 0) {
                     String[] args = str.split(",");
                     for (String arg : args) {
                         String[] args2 = arg.split("=");
-                        emojiUseHistory.put(Long.parseLong(args2[0]), Integer.parseInt(args2[1]));
+                        emojiUseHistory.put(args2[0], Integer.parseInt(args2[1]));
                     }
                 }
-                if (emojiUseHistory.isEmpty()) {
-                    long[] newRecent = new long[]{0x00000000D83DDE02L, 0x00000000D83DDE18L, 0x0000000000002764L, 0x00000000D83DDE0DL, 0x00000000D83DDE0AL, 0x00000000D83DDE01L,
-                            0x00000000D83DDC4DL, 0x000000000000263AL, 0x00000000D83DDE14L, 0x00000000D83DDE04L, 0x00000000D83DDE2DL, 0x00000000D83DDC8BL,
-                            0x00000000D83DDE12L, 0x00000000D83DDE33L, 0x00000000D83DDE1CL, 0x00000000D83DDE48L, 0x00000000D83DDE09L, 0x00000000D83DDE03L,
-                            0x00000000D83DDE22L, 0x00000000D83DDE1DL, 0x00000000D83DDE31L, 0x00000000D83DDE21L, 0x00000000D83DDE0FL, 0x00000000D83DDE1EL,
-                            0x00000000D83DDE05L, 0x00000000D83DDE1AL, 0x00000000D83DDE4AL, 0x00000000D83DDE0CL, 0x00000000D83DDE00L, 0x00000000D83DDE0BL,
-                            0x00000000D83DDE06L, 0x00000000D83DDC4CL, 0x00000000D83DDE10L, 0x00000000D83DDE15L};
-                    for (int i = 0; i < newRecent.length; i++) {
-                        emojiUseHistory.put(newRecent[i], newRecent.length - i);
-                    }
-                    saveRecentEmoji();
+            }
+            if (emojiUseHistory.isEmpty()) {
+                String[] newRecent = new String[]{
+                        "\uD83D\uDE02", "\uD83D\uDE18", "\u2764", "\uD83D\uDE0D", "\uD83D\uDE0A", "\uD83D\uDE01",
+                        "\uD83D\uDC4D", "\u263A", "\uD83D\uDE14", "\uD83D\uDE04", "\uD83D\uDE2D", "\uD83D\uDC8B",
+                        "\uD83D\uDE12", "\uD83D\uDE33", "\uD83D\uDE1C", "\uD83D\uDE48", "\uD83D\uDE09", "\uD83D\uDE03",
+                        "\uD83D\uDE22", "\uD83D\uDE1D", "\uD83D\uDE31", "\uD83D\uDE21", "\uD83D\uDE0F", "\uD83D\uDE1E",
+                        "\uD83D\uDE05", "\uD83D\uDE1A", "\uD83D\uDE4A", "\uD83D\uDE0C", "\uD83D\uDE00", "\uD83D\uDE0B",
+                        "\uD83D\uDE06", "\uD83D\uDC4C", "\uD83D\uDE10", "\uD83D\uDE15"};
+                for (int i = 0; i < newRecent.length; i++) {
+                    emojiUseHistory.put(newRecent[i], newRecent.length - i);
                 }
-                sortEmoji();
-                adapters.get(0).notifyDataSetChanged();
-            } catch (Exception e) {
-                FileLog.e("tmessages", e);
+                saveRecentEmoji();
             }
+            sortEmoji();
+            adapters.get(0).notifyDataSetChanged();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+
+        try {
+            str = preferences.getString("color", "");
+            if (str != null && str.length() > 0) {
+                String[] args = str.split(",");
+                for (String arg : args) {
+                    String[] args2 = arg.split("=");
+                    emojiColor.put(args2[0], args2[1]);
+                }
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
         }
 
         if (showStickers) {
@@ -806,16 +1231,6 @@ public void loadRecents() {
                         stickersUseHistory.put(Long.parseLong(args2[0]), Integer.parseInt(args2[1]));
                     }
                 }
-
-                stickerSetsUseCount.clear();
-                str = preferences.getString("sets", "");
-                if (str != null && str.length() > 0) {
-                    String[] args = str.split(",");
-                    for (String arg : args) {
-                        String[] args2 = arg.split("=");
-                        stickerSetsUseCount.put(Long.parseLong(args2[0]), Integer.parseInt(args2[1]));
-                    }
-                }
                 sortStickers();
                 updateStickerTabs();
             } catch (Exception e) {
@@ -913,6 +1328,9 @@ protected void onDetachedFromWindow() {
         if (stickersGridAdapter != null) {
             NotificationCenter.getInstance().removeObserver(this, NotificationCenter.stickersDidLoaded);
         }
+        if (pickerViewPopup != null && pickerViewPopup.isShowing()) {
+            pickerViewPopup.dismiss();
+        }
     }
 
     @Override
@@ -1080,7 +1498,7 @@ public int getCount() {
             if (emojiPage == -1) {
                 return recentEmoji.size();
             }
-            return Emoji.data[emojiPage].length;
+            return EmojiData.dataColored[emojiPage].length;
         }
 
         public Object getItem(int i) {
@@ -1093,51 +1511,22 @@ public long getItemId(int position) {
         }
 
         public View getView(int i, View view, ViewGroup paramViewGroup) {
-            ImageView imageView = (ImageView)view;
+            ImageViewEmoji imageView = (ImageViewEmoji) view;
             if (imageView == null) {
-                imageView = new ImageView(getContext()) {
-                    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-                        setMeasuredDimension(View.MeasureSpec.getSize(widthMeasureSpec), View.MeasureSpec.getSize(widthMeasureSpec));
-                    }
-                };
-                imageView.setOnClickListener(new View.OnClickListener() {
-                    public void onClick(View view) {
-                        Long code = (Long) view.getTag();
-                        Integer count = emojiUseHistory.get(code);
-                        if (count == null) {
-                            count = 0;
-                        }
-                        if (count == 0 && emojiUseHistory.size() > 50) {
-                            for (int a = recentEmoji.size() - 1; a >= 0; a--) {
-                                Long emoji = recentEmoji.get(a);
-                                emojiUseHistory.remove(emoji);
-                                recentEmoji.remove(a);
-                                if (emojiUseHistory.size() <= 50) {
-                                    break;
-                                }
-                            }
-                        }
-                        emojiUseHistory.put(code, ++count);
-                        if (pager.getCurrentItem() != 0) {
-                            sortEmoji();
-                        }
-                        saveRecentEmoji();
-                        adapters.get(0).notifyDataSetChanged();
-                        if (listener != null) {
-                            listener.onEmojiSelected(convert((Long)view.getTag()));
-                        }
-                    }
-                });
-                imageView.setBackgroundResource(R.drawable.list_selector);
-                imageView.setScaleType(ImageView.ScaleType.CENTER);
+                imageView = new ImageViewEmoji(getContext());
             }
-            long code;
+            String code;
+            String coloredCode;
             if (emojiPage == -1) {
-                code = recentEmoji.get(i);
+                coloredCode = code = recentEmoji.get(i);
             } else {
-                code = Emoji.data[emojiPage][i];
+                coloredCode = code = EmojiData.dataColored[emojiPage][i];
+                String color = emojiColor.get(code);
+                if (color != null) {
+                    coloredCode += color;
+                }
             }
-            imageView.setImageDrawable(Emoji.getEmojiBigDrawable(code));
+            imageView.setImageDrawable(Emoji.getEmojiBigDrawable(coloredCode));
             imageView.setTag(code);
             return imageView;
         }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmptyTextProgressView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmptyTextProgressView.java
index 371ace6ad..124ae677d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/EmptyTextProgressView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/EmptyTextProgressView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -66,6 +66,10 @@ public void setText(String text) {
         textView.setText(text);
     }
 
+    public void setTextSize(int size) {
+        textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, size);
+    }
+
     public void setShowAtCenter(boolean value) {
         showAtCenter = value;
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundDetector.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundDetector.java
index 26323f5e9..1db8f6328 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundDetector.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ForegroundDetector.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/FrameLayoutFixed.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/FrameLayoutFixed.java
index cd169b3f9..282a71c36 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/FrameLayoutFixed.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/FrameLayoutFixed.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
@@ -151,7 +151,11 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
             }
         } catch (Exception e) {
             FileLog.e("tmessages", e);
-            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            try {
+                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            } catch (Exception e2) {
+                FileLog.e("tmessages", e2);
+            }
         }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/HintEditText.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/HintEditText.java
new file mode 100644
index 000000000..7b6266a18
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/HintEditText.java
@@ -0,0 +1,73 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.widget.EditText;
+
+import org.telegram.messenger.AndroidUtilities;
+
+public class HintEditText extends EditText {
+
+    private String hintText;
+    private float textOffset;
+    private float spaceSize;
+    private float numberSize;
+    private Paint paint = new Paint();
+    private Rect rect = new Rect();
+
+    public HintEditText(Context context) {
+        super(context);
+        paint.setColor(0xff979797);
+    }
+
+    public String getHintText() {
+        return hintText;
+    }
+
+    public void setHintText(String value) {
+        hintText = value;
+        onTextChange();
+        setText(getText());
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+        onTextChange();
+    }
+
+    public void onTextChange() {
+        textOffset = (length() > 0 ? getPaint().measureText(getText(), 0, length()) : 0);
+        spaceSize = getPaint().measureText(" ");
+        numberSize = getPaint().measureText("1");
+        invalidate();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        if (hintText != null && length() < hintText.length()) {
+            int top = getMeasuredHeight() / 2;
+            float offsetX = textOffset;
+            for (int a = length(); a < hintText.length(); a++) {
+                if (hintText.charAt(a) == ' ') {
+                    offsetX += spaceSize;
+                } else {
+                    rect.set((int) offsetX + AndroidUtilities.dp(1), top, (int) (offsetX + numberSize) - AndroidUtilities.dp(1), top + AndroidUtilities.dp(2));
+                    canvas.drawRect(rect, paint);
+                    offsetX += numberSize;
+                }
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/IdenticonDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/IdenticonDrawable.java
index 394b6af40..0d0e70d8b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/IdenticonDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/IdenticonDrawable.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java
index c1a65b6cc..fc22433fd 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/LayoutHelper.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -11,6 +11,7 @@
 import android.widget.FrameLayout;
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
+import android.widget.ScrollView;
 
 import org.telegram.messenger.AndroidUtilities;
 
@@ -23,6 +24,10 @@ private static int getSize(float size) {
         return (int) (size < 0 ? size : AndroidUtilities.dp(size));
     }
 
+    public static FrameLayout.LayoutParams createScroll(int width, int height, int gravity) {
+        return new ScrollView.LayoutParams(getSize(width), getSize(height), gravity);
+    }
+
     public static FrameLayout.LayoutParams createFrame(int width, float height, int gravity, float leftMargin, float topMargin, float rightMargin, float bottomMargin) {
         FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(getSize(width), getSize(height), gravity);
         layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
@@ -100,7 +105,7 @@ private static int getSize(float size) {
         return layoutParams;
     }
 
-    public static LinearLayout.LayoutParams createLinear(int width, int height, int leftMargin, int topMargin, int rightMargin, int bottomMargin) {
+    public static LinearLayout.LayoutParams createLinear(int width, int height, float leftMargin, float topMargin, float rightMargin, float bottomMargin) {
         LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(getSize(width), getSize(height));
         layoutParams.setMargins(AndroidUtilities.dp(leftMargin), AndroidUtilities.dp(topMargin), AndroidUtilities.dp(rightMargin), AndroidUtilities.dp(bottomMargin));
         return layoutParams;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/LetterDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/LetterDrawable.java
index 4dcbfaa0d..aef713cce 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/LetterDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/LetterDrawable.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -11,6 +11,7 @@
 import android.graphics.Canvas;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
+import android.graphics.PixelFormat;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.text.Layout;
@@ -93,7 +94,7 @@ public void setColorFilter(ColorFilter cf) {
 
     @Override
     public int getOpacity() {
-        return 0;
+        return PixelFormat.TRANSPARENT;
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/LetterSectionsListView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/LetterSectionsListView.java
index fbac8a24a..60a26421c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/LetterSectionsListView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/LetterSectionsListView.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/LineProgressView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/LineProgressView.java
index 9b7db2ce6..26e73d7b2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/LineProgressView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/LineProgressView.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/LinkPath.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/LinkPath.java
index c597ccafe..8d2edc3a6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/LinkPath.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/LinkPath.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/MapPlaceholderDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/MapPlaceholderDrawable.java
index c522342d4..7c4ba414f 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/MapPlaceholderDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/MapPlaceholderDrawable.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/NumberTextView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/NumberTextView.java
new file mode 100644
index 000000000..505f3cc76
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/NumberTextView.java
@@ -0,0 +1,167 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Typeface;
+import android.text.Layout;
+import android.text.StaticLayout;
+import android.text.TextPaint;
+import android.view.View;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.AnimationCompat.AnimatorListenerAdapterProxy;
+import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
+
+import java.util.ArrayList;
+import java.util.Locale;
+
+public class NumberTextView extends View {
+
+    private ArrayList<StaticLayout> letters = new ArrayList<>();
+    private ArrayList<StaticLayout> oldLetters = new ArrayList<>();
+    private TextPaint textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG);
+    private ObjectAnimatorProxy animator;
+    private float progress = 0.0f;
+    private int currentNumber = 1;
+
+    public NumberTextView(Context context) {
+        super(context);
+    }
+
+    public void setProgress(float value) {
+        if (progress == value) {
+            return;
+        }
+        progress = value;
+        invalidate();
+    }
+
+    public float getProgress() {
+        return progress;
+    }
+
+    public void setNumber(int number, boolean animated) {
+        if (currentNumber == number && animated) {
+            return;
+        }
+        if (animator != null) {
+            animator.cancel();
+            animator = null;
+        }
+        oldLetters.clear();
+        oldLetters.addAll(letters);
+        letters.clear();
+        String oldText = String.format(Locale.US, "%d", currentNumber);
+        String text = String.format(Locale.US, "%d", number);
+        boolean forwardAnimation = number > currentNumber;
+        currentNumber = number;
+        progress = 0;
+        for (int a = 0; a < text.length(); a++) {
+            String ch = text.substring(a, a + 1);
+            String oldCh = !oldLetters.isEmpty() && a < oldText.length() ? oldText.substring(a, a + 1) : null;
+            if (oldCh != null && oldCh.equals(ch)) {
+                letters.add(oldLetters.get(a));
+                oldLetters.set(a, null);
+            } else {
+                StaticLayout layout = new StaticLayout(ch, textPaint, (int) Math.ceil(textPaint.measureText(ch)), Layout.Alignment.ALIGN_NORMAL, 1.0f, 0.0f, false);
+                letters.add(layout);
+            }
+        }
+        if (animated && !oldLetters.isEmpty()) {
+            animator = ObjectAnimatorProxy.ofFloatProxy(this, "progress", forwardAnimation ? -1 : 1, 0);
+            animator.setDuration(150);
+            animator.addListener(new AnimatorListenerAdapterProxy() {
+                @Override
+                public void onAnimationEnd(Object animation) {
+                    animator = null;
+                    oldLetters.clear();
+                }
+            });
+            animator.start();
+        }
+        invalidate();
+    }
+
+    public void setTextSize(int size) {
+        textPaint.setTextSize(AndroidUtilities.dp(size));
+        oldLetters.clear();
+        letters.clear();
+        setNumber(currentNumber, false);
+    }
+
+    public void setTextColor(int value) {
+        textPaint.setColor(value);
+        invalidate();
+    }
+
+    public void setTypeface(Typeface typeface) {
+        textPaint.setTypeface(typeface);
+        oldLetters.clear();
+        letters.clear();
+        setNumber(currentNumber, false);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (letters.isEmpty()) {
+            return;
+        }
+        float height = letters.get(0).getHeight();
+        canvas.save();
+        canvas.translate(getPaddingLeft(), (getMeasuredHeight() - height) / 2);
+        int count = Math.max(letters.size(), oldLetters.size());
+        for (int a = 0; a < count; a++) {
+            canvas.save();
+            StaticLayout old = a < oldLetters.size() ? oldLetters.get(a) : null;
+            StaticLayout layout = a < letters.size() ? letters.get(a) : null;
+            if (progress > 0) {
+                if (old != null) {
+                    textPaint.setAlpha((int) (255 * progress));
+                    canvas.save();
+                    canvas.translate(0, (progress - 1.0f) * height);
+                    old.draw(canvas);
+                    canvas.restore();
+                    if (layout != null) {
+                        textPaint.setAlpha((int) (255 * (1.0f - progress)));
+                        canvas.translate(0, progress * height);
+                    }
+                } else {
+                    textPaint.setAlpha(255);
+                }
+            } else if (progress < 0) {
+                if (old != null) {
+                    textPaint.setAlpha((int) (255 * -progress));
+                    canvas.save();
+                    canvas.translate(0, (1.0f + progress) * height);
+                    old.draw(canvas);
+                    canvas.restore();
+                }
+                if (layout != null) {
+                    if (a == count - 1 || old != null) {
+                        textPaint.setAlpha((int) (255 * (1.0f + progress)));
+                        canvas.translate(0, progress * height);
+                    } else {
+                        textPaint.setAlpha(255);
+                    }
+                }
+            } else if (layout != null) {
+                textPaint.setAlpha(255);
+            }
+            if (layout != null) {
+                layout.draw(canvas);
+            }
+            canvas.restore();
+            canvas.translate(layout != null ? layout.getLineWidth(0) : old.getLineWidth(0) + AndroidUtilities.dp(1), 0);
+        }
+        canvas.restore();
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PagerSlidingTabStrip.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PagerSlidingTabStrip.java
index 5daf22f1e..b633bd1bb 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PagerSlidingTabStrip.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PagerSlidingTabStrip.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PasscodeView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PasscodeView.java
index 3fa6f3754..584c4db4c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PasscodeView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PasscodeView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -9,7 +9,9 @@
 package org.telegram.ui.Components;
 
 import android.app.Activity;
+import android.app.AlertDialog;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.SharedPreferences;
 import android.content.res.Configuration;
 import android.graphics.Canvas;
@@ -19,6 +21,8 @@
 import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.os.Vibrator;
+import android.support.v4.hardware.fingerprint.FingerprintManagerCompat;
+import android.support.v4.os.CancellationSignal;
 import android.text.Editable;
 import android.text.InputFilter;
 import android.text.InputType;
@@ -38,6 +42,7 @@
 import android.widget.EditText;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
+import android.widget.RelativeLayout;
 import android.widget.TextView;
 
 import org.telegram.messenger.AndroidUtilities;
@@ -185,7 +190,7 @@ public void run() {
                     currentAnimation.addListener(new AnimatorListenerAdapterProxy() {
                         @Override
                         public void onAnimationEnd(Object animation) {
-                            if (animation.equals(currentAnimation)) {
+                            if (currentAnimation != null && currentAnimation.equals(animation)) {
                                 currentAnimation = null;
                             }
                         }
@@ -219,7 +224,7 @@ public void onAnimationEnd(Object animation) {
             currentAnimation.addListener(new AnimatorListenerAdapterProxy() {
                 @Override
                 public void onAnimationEnd(Object animation) {
-                    if (animation.equals(currentAnimation)) {
+                    if (currentAnimation != null && currentAnimation.equals(animation)) {
                         currentAnimation = null;
                     }
                 }
@@ -296,7 +301,7 @@ public void eraseLastCharacter() {
             currentAnimation.addListener(new AnimatorListenerAdapterProxy() {
                 @Override
                 public void onAnimationEnd(Object animation) {
-                    if (animation.equals(currentAnimation)) {
+                    if (currentAnimation != null && currentAnimation.equals(animation)) {
                         currentAnimation = null;
                     }
                 }
@@ -304,7 +309,7 @@ public void onAnimationEnd(Object animation) {
             currentAnimation.start();
         }
 
-        private void eraseAllCharacters(boolean animated) {
+        private void eraseAllCharacters(final boolean animated) {
             if (stringBuilder.length() == 0) {
                 return;
             }
@@ -342,7 +347,7 @@ private void eraseAllCharacters(boolean animated) {
                 currentAnimation.addListener(new AnimatorListenerAdapterProxy() {
                     @Override
                     public void onAnimationEnd(Object animation) {
-                        if (animation.equals(currentAnimation)) {
+                        if (currentAnimation != null && currentAnimation.equals(animation)) {
                             currentAnimation = null;
                         }
                     }
@@ -409,10 +414,19 @@ protected void onLayout(boolean changed, int left, int top, int right, int botto
     private ImageView checkImage;
     private int keyboardHeight = 0;
 
+    private CancellationSignal cancellationSignal;
+    private ImageView fingerprintImageView;
+    private TextView fingerprintStatusTextView;
+    private boolean selfCancelled;
+    private AlertDialog fingerprintDialog;
+
     private Rect rect = new Rect();
 
     private PasscodeViewDelegate delegate;
 
+    private final static int id_fingerprint_textview = 1000;
+    private final static int id_fingerprint_imageview = 1001;
+
     public PasscodeView(final Context context) {
         super(context);
 
@@ -497,7 +511,7 @@ public PasscodeView(final Context context) {
             @Override
             public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
                 if (i == EditorInfo.IME_ACTION_DONE) {
-                    processDone();
+                    processDone(false);
                     return true;
                 }
                 return false;
@@ -517,7 +531,7 @@ public void onTextChanged(CharSequence s, int start, int before, int count) {
             @Override
             public void afterTextChanged(Editable s) {
                 if (passwordEditText.length() == 4 && UserConfig.passcodeType == 0) {
-                    processDone();
+                    processDone(false);
                 }
             }
         });
@@ -561,7 +575,7 @@ public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
         checkImage.setOnClickListener(new OnClickListener() {
             @Override
             public void onClick(View v) {
-                processDone();
+                processDone(false);
             }
         });
 
@@ -707,7 +721,7 @@ public void onClick(View v) {
                             break;
                     }
                     if (passwordEditText2.lenght() == 4) {
-                        processDone();
+                        processDone(false);
                     }
                 }
             });
@@ -728,22 +742,24 @@ public void setDelegate(PasscodeViewDelegate delegate) {
         this.delegate = delegate;
     }
 
-    private void processDone() {
-        String password = "";
-        if (UserConfig.passcodeType == 0) {
-            password = passwordEditText2.getString();
-        } else if (UserConfig.passcodeType == 1) {
-            password = passwordEditText.getText().toString();
-        }
-        if (password.length() == 0) {
-            onPasscodeError();
-            return;
-        }
-        if (!UserConfig.checkPasscode(password)) {
-            passwordEditText.setText("");
-            passwordEditText2.eraseAllCharacters(true);
-            onPasscodeError();
-            return;
+    private void processDone(boolean fingerprint) {
+        if (!fingerprint) {
+            String password = "";
+            if (UserConfig.passcodeType == 0) {
+                password = passwordEditText2.getString();
+            } else if (UserConfig.passcodeType == 1) {
+                password = passwordEditText.getText().toString();
+            }
+            if (password.length() == 0) {
+                onPasscodeError();
+                return;
+            }
+            if (!UserConfig.checkPasscode(password)) {
+                passwordEditText.setText("");
+                passwordEditText2.eraseAllCharacters(true);
+                onPasscodeError();
+                return;
+            }
         }
         passwordEditText.clearFocus();
         AndroidUtilities.hideKeyboard(passwordEditText);
@@ -816,16 +832,148 @@ public void run() {
                 }
             }, 200);
         }
+        checkFingerprint();
+    }
+
+    public void onPause() {
+        if (fingerprintDialog != null) {
+            try {
+                if (fingerprintDialog.isShowing()) {
+                    fingerprintDialog.dismiss();
+                }
+                fingerprintDialog = null;
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+        }
+        try {
+            if (Build.VERSION.SDK_INT >= 23 && cancellationSignal != null) {
+                cancellationSignal.cancel();
+                cancellationSignal = null;
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
+    }
+
+    private void checkFingerprint() {
+        Activity parentActivity = (Activity) getContext();
+        if (Build.VERSION.SDK_INT >= 23 && parentActivity != null && UserConfig.useFingerprint && !ApplicationLoader.mainInterfacePaused) {
+            try {
+                if (fingerprintDialog != null && fingerprintDialog.isShowing()) {
+                    return;
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+            try {
+                FingerprintManagerCompat fingerprintManager = FingerprintManagerCompat.from(ApplicationLoader.applicationContext);
+                if (fingerprintManager.isHardwareDetected() && fingerprintManager.hasEnrolledFingerprints()) {
+                    RelativeLayout relativeLayout = new RelativeLayout(getContext());
+                    relativeLayout.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(16), AndroidUtilities.dp(24), AndroidUtilities.dp(8));
+
+                    TextView fingerprintTextView = new TextView(getContext());
+                    fingerprintTextView.setTextColor(0xff939393);
+                    fingerprintTextView.setId(id_fingerprint_textview);
+                    fingerprintTextView.setTextAppearance(android.R.style.TextAppearance_Material_Subhead);
+                    fingerprintTextView.setText(LocaleController.getString("FingerprintInfo", R.string.FingerprintInfo));
+                    relativeLayout.addView(fingerprintTextView);
+                    RelativeLayout.LayoutParams layoutParams = LayoutHelper.createRelative(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT);
+                    layoutParams.addRule(RelativeLayout.ALIGN_PARENT_TOP);
+                    layoutParams.addRule(RelativeLayout.ALIGN_PARENT_START);
+                    fingerprintTextView.setLayoutParams(layoutParams);
+
+                    fingerprintImageView = new ImageView(getContext());
+                    fingerprintImageView.setImageResource(R.drawable.ic_fp_40px);
+                    fingerprintImageView.setId(id_fingerprint_imageview);
+                    relativeLayout.addView(fingerprintImageView, LayoutHelper.createRelative(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, 0, 20, 0, 0, RelativeLayout.ALIGN_PARENT_START, RelativeLayout.BELOW, id_fingerprint_textview));
+
+                    fingerprintStatusTextView = new TextView(getContext());
+                    fingerprintStatusTextView.setGravity(Gravity.CENTER_VERTICAL);
+                    fingerprintStatusTextView.setText(LocaleController.getString("FingerprintHelp", R.string.FingerprintHelp));
+                    fingerprintStatusTextView.setTextAppearance(android.R.style.TextAppearance_Material_Body1);
+                    fingerprintStatusTextView.setTextColor(0x42000000);
+                    relativeLayout.addView(fingerprintStatusTextView);
+                    layoutParams = LayoutHelper.createRelative(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT);
+                    layoutParams.setMarginStart(AndroidUtilities.dp(16));
+                    layoutParams.addRule(RelativeLayout.ALIGN_BOTTOM, id_fingerprint_imageview);
+                    layoutParams.addRule(RelativeLayout.ALIGN_TOP, id_fingerprint_imageview);
+                    layoutParams.addRule(RelativeLayout.END_OF, id_fingerprint_imageview);
+                    fingerprintStatusTextView.setLayoutParams(layoutParams);
+
+                    AlertDialog.Builder builder = new AlertDialog.Builder(getContext());
+                    builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                    builder.setView(relativeLayout);
+                    builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                    builder.setOnDismissListener(new DialogInterface.OnDismissListener() {
+                        @Override
+                        public void onDismiss(DialogInterface dialog) {
+                            if (cancellationSignal != null) {
+                                selfCancelled = true;
+                                cancellationSignal.cancel();
+                                cancellationSignal = null;
+                            }
+                        }
+                    });
+                    if (fingerprintDialog != null) {
+                        try {
+                            if (fingerprintDialog.isShowing()) {
+                                fingerprintDialog.dismiss();
+                            }
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                    }
+                    fingerprintDialog = builder.show();
+
+                    cancellationSignal = new CancellationSignal();
+                    selfCancelled = false;
+                    fingerprintManager.authenticate(null, 0, cancellationSignal, new FingerprintManagerCompat.AuthenticationCallback() {
+                        @Override
+                        public void onAuthenticationError(int errMsgId, CharSequence errString) {
+                            if (!selfCancelled) {
+                                showFingerprintError(errString);
+                            }
+                        }
+
+                        @Override
+                        public void onAuthenticationHelp(int helpMsgId, CharSequence helpString) {
+                            showFingerprintError(helpString);
+                        }
+
+                        @Override
+                        public void onAuthenticationFailed() {
+                            showFingerprintError(LocaleController.getString("FingerprintNotRecognized", R.string.FingerprintNotRecognized));
+                        }
+
+                        @Override
+                        public void onAuthenticationSucceeded(FingerprintManagerCompat.AuthenticationResult result) {
+                            try {
+                                if (fingerprintDialog.isShowing()) {
+                                    fingerprintDialog.dismiss();
+                                }
+                            } catch (Exception e) {
+                                FileLog.e("tmessages", e);
+                            }
+                            fingerprintDialog = null;
+                            processDone(true);
+                        }
+                    }, null);
+                }
+            } catch (Throwable e) {
+                //ignore
+            }
+        }
     }
 
     public void onShow() {
+        Activity parentActivity = (Activity) getContext();
         if (UserConfig.passcodeType == 1) {
             if (passwordEditText != null) {
                 passwordEditText.requestFocus();
                 AndroidUtilities.showKeyboard(passwordEditText);
             }
         } else {
-            Activity parentActivity = (Activity) getContext();
             if (parentActivity != null) {
                 View currentFocus = parentActivity.getCurrentFocus();
                 if (currentFocus != null) {
@@ -834,6 +982,7 @@ public void onShow() {
                 }
             }
         }
+        checkFingerprint();
         if (getVisibility() == View.VISIBLE) {
             return;
         }
@@ -891,6 +1040,17 @@ public boolean onTouch(View v, MotionEvent event) {
         });
     }
 
+    private void showFingerprintError(CharSequence error) {
+        fingerprintImageView.setImageResource(R.drawable.ic_fingerprint_error);
+        fingerprintStatusTextView.setText(error);
+        fingerprintStatusTextView.setTextColor(0xfff4511e);
+        Vibrator v = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
+        if (v != null) {
+            v.vibrate(200);
+        }
+        AndroidUtilities.shakeView(fingerprintStatusTextView, 2, 0);
+    }
+
     @Override
     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
         int width = MeasureSpec.getSize(widthMeasureSpec);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoCropView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoCropView.java
index 6ea153f3b..f61de0265 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoCropView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoCropView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -348,8 +348,7 @@ public float getLimitHeight() {
     private Bitmap createBitmap(int x, int y, int w, int h) {
         Bitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
         Canvas canvas = new Canvas(bitmap);
-        Paint paint = new Paint();
-        paint.setFilterBitmap(true);
+        Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG | Paint.DITHER_FLAG);
 
         Matrix matrix = new Matrix();
         matrix.setTranslate(-bitmapToEdit.getWidth() / 2, -bitmapToEdit.getHeight() / 2);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoEditorSeekBar.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoEditorSeekBar.java
index 5258a6512..a6bf84430 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoEditorSeekBar.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoEditorSeekBar.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterBlurControl.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterBlurControl.java
index d93099272..137ddc70a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterBlurControl.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterBlurControl.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterView.java
index 3007ddb32..0c14662f9 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoFilterView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoViewerCaptionEnterView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoViewerCaptionEnterView.java
index a50558113..275ff641e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoViewerCaptionEnterView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PhotoViewerCaptionEnterView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -326,6 +326,11 @@ public void onEmojiSelected(String symbol) {
                     public void onStickerSelected(TLRPC.Document sticker) {
 
                     }
+
+                    @Override
+                    public void onStickersSettingsClick() {
+
+                    }
                 });
                 sizeNotifierLayout.addView(emojiView);
             }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PickerBottomLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PickerBottomLayout.java
index a05d17618..6004f7ad3 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PickerBottomLayout.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PickerBottomLayout.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
@@ -47,23 +47,13 @@ public PickerBottomLayout(Context context, boolean darkTheme) {
         cancelButton.setPadding(AndroidUtilities.dp(29), 0, AndroidUtilities.dp(29), 0);
         cancelButton.setText(LocaleController.getString("Cancel", R.string.Cancel).toUpperCase());
         cancelButton.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        addView(cancelButton);
-        LayoutParams layoutParams = (LayoutParams) cancelButton.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
-        cancelButton.setLayoutParams(layoutParams);
+        addView(cancelButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT));
 
         doneButton = new LinearLayout(context);
         doneButton.setOrientation(LinearLayout.HORIZONTAL);
         doneButton.setBackgroundResource(isDarkTheme ? R.drawable.bar_selector_picker : R.drawable.bar_selector_audio);
         doneButton.setPadding(AndroidUtilities.dp(29), 0, AndroidUtilities.dp(29), 0);
-        addView(doneButton);
-        layoutParams = (LayoutParams) doneButton.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.gravity = Gravity.TOP | Gravity.RIGHT;
-        doneButton.setLayoutParams(layoutParams);
+        addView(doneButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.RIGHT));
 
         doneButtonBadgeTextView = new TextView(context);
         doneButtonBadgeTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
@@ -73,13 +63,7 @@ public PickerBottomLayout(Context context, boolean darkTheme) {
         doneButtonBadgeTextView.setBackgroundResource(isDarkTheme ? R.drawable.photobadge : R.drawable.bluecounter);
         doneButtonBadgeTextView.setMinWidth(AndroidUtilities.dp(23));
         doneButtonBadgeTextView.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), AndroidUtilities.dp(1));
-        doneButton.addView(doneButtonBadgeTextView);
-        LinearLayout.LayoutParams layoutParams1 = (LinearLayout.LayoutParams) doneButtonBadgeTextView.getLayoutParams();
-        layoutParams1.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams1.height = AndroidUtilities.dp(23);
-        layoutParams1.rightMargin = AndroidUtilities.dp(10);
-        layoutParams1.gravity = Gravity.CENTER_VERTICAL;
-        doneButtonBadgeTextView.setLayoutParams(layoutParams1);
+        doneButton.addView(doneButtonBadgeTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, 23, Gravity.CENTER_VERTICAL, 0, 0, 10, 0));
 
         doneButtonTextView = new TextView(context);
         doneButtonTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
@@ -88,12 +72,7 @@ public PickerBottomLayout(Context context, boolean darkTheme) {
         doneButtonTextView.setCompoundDrawablePadding(AndroidUtilities.dp(8));
         doneButtonTextView.setText(LocaleController.getString("Send", R.string.Send).toUpperCase());
         doneButtonTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        doneButton.addView(doneButtonTextView);
-        layoutParams1 = (LinearLayout.LayoutParams) doneButtonTextView.getLayoutParams();
-        layoutParams1.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams1.gravity = Gravity.CENTER_VERTICAL;
-        layoutParams1.height = LayoutHelper.WRAP_CONTENT;
-        doneButtonTextView.setLayoutParams(layoutParams1);
+        doneButton.addView(doneButtonTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER_VERTICAL));
     }
 
     public void updateSelectedCount(int count, boolean disable) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PlayerView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PlayerView.java
new file mode 100644
index 000000000..3e3823037
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PlayerView.java
@@ -0,0 +1,257 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.os.Build;
+import android.text.SpannableStringBuilder;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.AnimationCompat.AnimatorListenerAdapterProxy;
+import org.telegram.messenger.AnimationCompat.AnimatorSetProxy;
+import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
+import org.telegram.messenger.AnimationCompat.ViewProxy;
+import org.telegram.messenger.MediaController;
+import org.telegram.messenger.MessageObject;
+import org.telegram.messenger.NotificationCenter;
+import org.telegram.messenger.R;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.AudioPlayerActivity;
+
+public class PlayerView extends FrameLayout implements NotificationCenter.NotificationCenterDelegate {
+
+    private ImageView playButton;
+    private TextView titleTextView;
+    private MessageObject lastMessageObject;
+    private AnimatorSetProxy animatorSet;
+    private float yPosition;
+    private BaseFragment fragment;
+    private float topPadding;
+    private boolean visible;
+
+    public PlayerView(Context context, BaseFragment parentFragment) {
+        super(context);
+
+        fragment = parentFragment;
+        visible = true;
+        ((ViewGroup) fragment.getFragmentView()).setClipToPadding(false);
+
+        setTag(1);
+        FrameLayout frameLayout = new FrameLayout(context);
+        frameLayout.setBackgroundColor(0xffffffff);
+        addView(frameLayout, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 36, Gravity.TOP | Gravity.LEFT, 0, 0, 0, 0));
+
+        View shadow = new View(context);
+        shadow.setBackgroundResource(R.drawable.header_shadow);
+        addView(shadow, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 3, Gravity.LEFT | Gravity.TOP, 0, 36, 0, 0));
+
+        playButton = new ImageView(context);
+        playButton.setScaleType(ImageView.ScaleType.CENTER);
+        addView(playButton, LayoutHelper.createFrame(36, 36, Gravity.TOP | Gravity.LEFT, 0, 0, 0, 0));
+        playButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (MediaController.getInstance().isAudioPaused()) {
+                    MediaController.getInstance().playAudio(MediaController.getInstance().getPlayingMessageObject());
+                } else {
+                    MediaController.getInstance().pauseAudio(MediaController.getInstance().getPlayingMessageObject());
+                }
+            }
+        });
+
+        titleTextView = new TextView(context);
+        titleTextView.setTextColor(0xff212121);
+        titleTextView.setMaxLines(1);
+        titleTextView.setLines(1);
+        titleTextView.setSingleLine(true);
+        titleTextView.setEllipsize(TextUtils.TruncateAt.END);
+        titleTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15);
+        titleTextView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
+        addView(titleTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 36, Gravity.LEFT | Gravity.TOP, 35, 0, 36, 0));
+
+        ImageView closeButton = new ImageView(context);
+        closeButton.setImageResource(R.drawable.miniplayer_close);
+        closeButton.setScaleType(ImageView.ScaleType.CENTER);
+        addView(closeButton, LayoutHelper.createFrame(36, 36, Gravity.RIGHT | Gravity.TOP));
+        closeButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                MediaController.getInstance().cleanupPlayer(true, true);
+            }
+        });
+
+        setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (fragment != null) {
+                    fragment.presentFragment(new AudioPlayerActivity());
+                }
+            }
+        });
+    }
+
+    public float getTopPadding() {
+        return topPadding;
+    }
+
+    public void setTopPadding(float value) {
+        topPadding = value;
+        if (fragment != null) {
+            View view = fragment.getFragmentView();
+            if (view != null) {
+                view.setPadding(0, (int) topPadding, 0, 0);
+            }
+        }
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        topPadding = 0;
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.audioDidReset);
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.audioPlayStateChanged);
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.audioDidStarted);
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.audioDidReset);
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.audioPlayStateChanged);
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.audioDidStarted);
+        checkPlayer(true);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, AndroidUtilities.dp(39));
+    }
+
+    @Override
+    public void didReceivedNotification(int id, Object... args) {
+        if (id == NotificationCenter.audioDidStarted || id == NotificationCenter.audioPlayStateChanged || id == NotificationCenter.audioDidReset) {
+            checkPlayer(false);
+        }
+    }
+
+    private void checkPlayer(boolean create) {
+        MessageObject messageObject = MediaController.getInstance().getPlayingMessageObject();
+        View fragmentView = fragment.getFragmentView();
+        if (!create && fragmentView != null) {
+            if (fragmentView.getParent() == null || ((View) fragmentView.getParent()).getVisibility() != VISIBLE) {
+                create = true;
+            }
+        }
+        if (messageObject == null || !messageObject.isMusic()) {
+            lastMessageObject = null;
+            if (visible) {
+                visible = false;
+                if (create && topPadding != 0) {
+                    clearAnimation();
+                    setVisibility(GONE);
+                    setTopPadding(0);
+                } else {
+                    if (animatorSet != null) {
+                        animatorSet.cancel();
+                        animatorSet = null;
+                    }
+                    animatorSet = new AnimatorSetProxy();
+                    animatorSet.playTogether(ObjectAnimatorProxy.ofFloat(this, "translationY", -AndroidUtilities.dp(36)),
+                            ObjectAnimatorProxy.ofFloat(this, "topPadding", 0));
+                    animatorSet.setDuration(200);
+                    animatorSet.addListener(new AnimatorListenerAdapterProxy() {
+                        @Override
+                        public void onAnimationEnd(Object animation) {
+                            if (animatorSet != null && animatorSet.equals(animation)) {
+                                clearAnimation();
+                                setVisibility(GONE);
+                                animatorSet = null;
+                            }
+                        }
+                    });
+                    animatorSet.start();
+                }
+            }
+        } else {
+            if (create && topPadding == 0) {
+                setTopPadding(AndroidUtilities.dp(36));
+                ViewProxy.setTranslationY(this, 0);
+                yPosition = 0;
+            }
+            if (!visible) {
+                if (!create) {
+                    if (animatorSet != null) {
+                        animatorSet.cancel();
+                        animatorSet = null;
+                    }
+                    animatorSet = new AnimatorSetProxy();
+                    animatorSet.playTogether(ObjectAnimatorProxy.ofFloat(this, "translationY", -AndroidUtilities.dp(36), 0),
+                            ObjectAnimatorProxy.ofFloat(this, "topPadding", AndroidUtilities.dp(36)));
+                    animatorSet.setDuration(200);
+                    animatorSet.addListener(new AnimatorListenerAdapterProxy() {
+                        @Override
+                        public void onAnimationEnd(Object animation) {
+                            if (animatorSet != null && animatorSet.equals(animation)) {
+                                animatorSet = null;
+                            }
+                        }
+                    });
+                    animatorSet.start();
+                }
+                visible = true;
+                setVisibility(VISIBLE);
+            }
+            if (MediaController.getInstance().isAudioPaused()) {
+                playButton.setImageResource(R.drawable.miniplayer_play);
+            } else {
+                playButton.setImageResource(R.drawable.miniplayer_pause);
+            }
+            if (lastMessageObject != messageObject) {
+                lastMessageObject = messageObject;
+                SpannableStringBuilder stringBuilder = new SpannableStringBuilder(String.format("%s - %s", messageObject.getMusicAuthor(), messageObject.getMusicTitle()));
+                TypefaceSpan span = new TypefaceSpan(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+                stringBuilder.setSpan(span, 0, messageObject.getMusicAuthor().length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);
+                titleTextView.setText(stringBuilder);
+            }
+        }
+    }
+
+    @Override
+    public void setTranslationY(float translationY) {
+        super.setTranslationY(translationY);
+        yPosition = translationY;
+        invalidate();
+    }
+
+    @Override
+    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
+        int restoreToCount = 0;
+        if (Build.VERSION.SDK_INT >= 11) {
+            restoreToCount = canvas.save();
+            if (yPosition < 0) {
+                canvas.clipRect(0, (int) -yPosition, child.getMeasuredWidth(), AndroidUtilities.dp(39));
+            }
+        }
+        final boolean result = super.drawChild(canvas, child, drawingTime);
+        if (Build.VERSION.SDK_INT >= 11) {
+            canvas.restoreToCount(restoreToCount);
+        }
+        return result;
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/Point.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/Point.java
index f22dde478..7e6fb2ba9 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/Point.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/Point.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/PopupAudioView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/PopupAudioView.java
index be0123392..71908c83a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/PopupAudioView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/PopupAudioView.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ProgressView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ProgressView.java
index 58b52ad5c..d5e7f3773 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ProgressView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ProgressView.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RadialProgress.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RadialProgress.java
index f9dca6b1c..ae01fcf1e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/RadialProgress.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/RadialProgress.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RadioButton.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RadioButton.java
index adb752df8..0e72542ca 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/RadioButton.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/RadioButton.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -9,16 +9,25 @@
 package org.telegram.ui.Components;
 
 import android.content.Context;
+import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffXfermode;
 import android.view.View;
 
 import org.telegram.messenger.AndroidUtilities;
 import org.telegram.messenger.AnimationCompat.ObjectAnimatorProxy;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.ImageLoader;
 
 public class RadioButton extends View {
 
+    private Bitmap bitmap;
+    private Canvas bitmapCanvas;
     private static Paint paint;
+    private static Paint eraser;
     private static Paint checkedPaint;
 
     private int checkedColor = 0xffd7e8f7;
@@ -26,14 +35,11 @@
 
     private float progress;
     private ObjectAnimatorProxy checkAnimator;
-    private boolean isCheckAnimation = true;
 
     private boolean attachedToWindow;
     private boolean isChecked;
     private int size = AndroidUtilities.dp(16);
 
-    private final static float progressBounceDiff = 0.2f;
-
     public RadioButton(Context context) {
         super(context);
         if (paint == null) {
@@ -41,6 +47,19 @@ public RadioButton(Context context) {
             paint.setStrokeWidth(AndroidUtilities.dp(2));
             paint.setStyle(Paint.Style.STROKE);
             checkedPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            eraser = new Paint(Paint.ANTI_ALIAS_FLAG);
+            eraser.setColor(0);
+            eraser.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));
+        }
+
+        try {
+            bitmap = Bitmap.createBitmap(AndroidUtilities.dp(size), AndroidUtilities.dp(size), Bitmap.Config.ARGB_4444);
+            if (ImageLoader.getInstance().runtimeHack != null) {
+                ImageLoader.getInstance().runtimeHack.trackFree(bitmap.getRowBytes() * bitmap.getHeight());
+            }
+            bitmapCanvas = new Canvas(bitmap);
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
         }
     }
 
@@ -57,6 +76,9 @@ public float getProgress() {
     }
 
     public void setSize(int value) {
+        if (size == value) {
+            return;
+        }
         size = value;
     }
 
@@ -72,9 +94,8 @@ private void cancelCheckAnimator() {
     }
 
     private void animateToCheckedState(boolean newCheckedState) {
-        isCheckAnimation = newCheckedState;
         checkAnimator = ObjectAnimatorProxy.ofFloatProxy(this, "progress", newCheckedState ? 1 : 0);
-        checkAnimator.setDuration(300);
+        checkAnimator.setDuration(200);
         checkAnimator.start();
     }
 
@@ -88,6 +109,11 @@ protected void onAttachedToWindow() {
     protected void onDetachedFromWindow() {
         super.onDetachedFromWindow();
         attachedToWindow = false;
+        if (bitmap != null && ImageLoader.getInstance().runtimeHack != null) {
+            ImageLoader.getInstance().runtimeHack.trackAlloc(bitmap.getRowBytes() * bitmap.getHeight());
+            bitmap.recycle();
+            bitmap = null;
+        }
     }
 
     public void setChecked(boolean checked, boolean animated) {
@@ -110,14 +136,53 @@ public boolean isChecked() {
 
     @Override
     protected void onDraw(Canvas canvas) {
-        if (getVisibility() != VISIBLE) {
-            return;
+        if (bitmap == null || bitmap.getWidth() != getMeasuredWidth()) {
+            if (bitmap != null) {
+                if (ImageLoader.getInstance().runtimeHack != null) {
+                    ImageLoader.getInstance().runtimeHack.trackAlloc(bitmap.getRowBytes() * bitmap.getHeight());
+                }
+                bitmap.recycle();
+            }
+            try {
+                bitmap = Bitmap.createBitmap(getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888);
+                if (ImageLoader.getInstance().runtimeHack != null) {
+                    ImageLoader.getInstance().runtimeHack.trackFree(bitmap.getRowBytes() * bitmap.getHeight());
+                }
+                bitmapCanvas = new Canvas(bitmap);
+            } catch (Throwable e) {
+                FileLog.e("tmessages", e);
+            }
+        }
+        float circleProgress;
+        float innerRad;
+        if (progress <= 0.5f) {
+            paint.setColor(color);
+            checkedPaint.setColor(color);
+            circleProgress = progress / 0.5f;
+        } else {
+            circleProgress = 2.0f - progress / 0.5f;
+            int r1 = Color.red(color);
+            int rD = (int) ((Color.red(checkedColor) - r1) * (1.0f - circleProgress));
+            int g1 = Color.green(color);
+            int gD = (int) ((Color.green(checkedColor) - g1) * (1.0f - circleProgress));
+            int b1 = Color.blue(color);
+            int bD = (int) ((Color.blue(checkedColor) - b1) * (1.0f - circleProgress));
+            int c = Color.rgb(r1 + rD, g1 + gD, b1 + bD);
+            paint.setColor(c);
+            checkedPaint.setColor(c);
         }
-        paint.setColor(isChecked ? checkedColor : color);
-        checkedPaint.setColor(checkedColor);
-        canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, size / 2 - AndroidUtilities.dp(1), paint);
-        if (isChecked) {
-            canvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, size / 4, checkedPaint);
+        if (bitmap != null) {
+            bitmap.eraseColor(0);
+            float rad = size / 2 - (1 + circleProgress) * AndroidUtilities.density;
+            bitmapCanvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, rad, paint);
+            if (progress <= 0.5f) {
+                bitmapCanvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, (rad - AndroidUtilities.dp(1)), checkedPaint);
+                bitmapCanvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, (rad - AndroidUtilities.dp(1)) * (1.0f - circleProgress), eraser);
+            } else {
+                bitmapCanvas.drawCircle(getMeasuredWidth() / 2, getMeasuredHeight() / 2, size / 4 + (rad - AndroidUtilities.dp(1) - size / 4) * circleProgress, checkedPaint);
+            }
+
+            canvas.drawBitmap(bitmap, 0, 0, null);
         }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecordStatusDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecordStatusDrawable.java
index a0ea38ac6..d8e9a39f1 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecordStatusDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecordStatusDrawable.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/Rect.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/Rect.java
index 9dde354b9..ef88d877b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/Rect.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/Rect.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
index dc0c32a29..1895f12d9 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/RecyclerListView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -40,6 +40,7 @@
     private boolean wasPressed;
     private boolean disallowInterceptTouchEvents;
     private boolean instantClick;
+    private Runnable clickRunnable;
 
     private static int[] attributes;
     private static boolean gotAttributes;
@@ -49,7 +50,7 @@
     }
 
     public interface OnItemLongClickListener {
-        void onItemClick(View view, int position);
+        boolean onItemClick(View view, int position);
     }
 
     public interface OnInterceptTouchListener {
@@ -69,9 +70,12 @@ public boolean onSingleTapUp(MotionEvent e) {
                             view.playSoundEffect(SoundEffectConstants.CLICK);
                             onItemClickListener.onItemClick(view, currentChildPosition);
                         }
-                        AndroidUtilities.runOnUIThread(new Runnable() {
+                        AndroidUtilities.runOnUIThread(clickRunnable = new Runnable() {
                             @Override
                             public void run() {
+                                if (this == clickRunnable) {
+                                    clickRunnable = null;
+                                }
                                 if (view != null) {
                                     view.setPressed(false);
                                     if (!instantClick) {
@@ -95,26 +99,29 @@ public void run() {
                 }
 
                 @Override
-                public void onLongPress(MotionEvent e) {
-                    if (currentChildView != null && onItemLongClickListener != null) {
-                        currentChildView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
-                        onItemLongClickListener.onItemClick(currentChildView, currentChildPosition);
+                public void onLongPress(MotionEvent event) {
+                    if (currentChildView != null) {
+                        if (onItemLongClickListener != null) {
+                            if (onItemLongClickListener.onItemClick(currentChildView, currentChildPosition)) {
+                                currentChildView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
+                            }
+                        }
                     }
                 }
             });
         }
 
         @Override
-        public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent e) {
-            int action = e.getActionMasked();
+        public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent event) {
+            int action = event.getActionMasked();
             boolean isScrollIdle = RecyclerListView.this.getScrollState() == RecyclerListView.SCROLL_STATE_IDLE;
 
             if ((action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) && currentChildView == null && isScrollIdle) {
-                currentChildView = view.findChildViewUnder(e.getX(), e.getY());
+                currentChildView = view.findChildViewUnder(event.getX(), event.getY());
                 currentChildPosition = -1;
                 if (currentChildView != null) {
                     currentChildPosition = view.getChildPosition(currentChildView);
-                    MotionEvent childEvent = MotionEvent.obtain(0, 0, e.getActionMasked(), e.getX() - currentChildView.getLeft(), e.getY() - currentChildView.getTop(), 0);
+                    MotionEvent childEvent = MotionEvent.obtain(0, 0, event.getActionMasked(), event.getX() - currentChildView.getLeft(), event.getY() - currentChildView.getTop(), 0);
                     if (currentChildView.onTouchEvent(childEvent)) {
                         interceptedByChild = true;
                     }
@@ -124,11 +131,11 @@ public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent e) {
 
             if (currentChildView != null && !interceptedByChild) {
                 try {
-                    if (e != null) {
-                        mGestureDetector.onTouchEvent(e);
+                    if (event != null) {
+                        mGestureDetector.onTouchEvent(event);
                     }
-                } catch (Exception ev) {
-                    FileLog.e("tmessages", ev);
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
                 }
             }
 
@@ -158,14 +165,32 @@ public void run() {
         }
 
         @Override
-        public void onTouchEvent(RecyclerView view, MotionEvent e) {
+        public void onTouchEvent(RecyclerView view, MotionEvent event) {
 
         }
 
         @Override
         public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) {
+            cancelClickRunnables(true);
+        }
+    }
 
+    public void cancelClickRunnables(boolean uncheck) {
+        if (selectChildRunnable != null) {
+            AndroidUtilities.cancelRunOnUIThread(selectChildRunnable);
+            selectChildRunnable = null;
+        }
+        if (currentChildView != null) {
+            if (uncheck) {
+                currentChildView.setPressed(false);
+            }
+            currentChildView = null;
+        }
+        if (clickRunnable != null) {
+            AndroidUtilities.cancelRunOnUIThread(clickRunnable);
+            clickRunnable = null;
         }
+        interceptedByChild = false;
     }
 
     private AdapterDataObserver observer = new AdapterDataObserver() {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ResourceLoader.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ResourceLoader.java
index 687a77d2c..3cec9627b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ResourceLoader.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ResourceLoader.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -37,6 +37,8 @@
     public static Drawable mediaBackgroundDrawable;
     public static Drawable clockChannelDrawable;
 
+    public static Drawable[][] shareDrawable = new Drawable[2][2];
+
     public static Drawable viewsCountDrawable;
     public static Drawable viewsOutCountDrawable;
     public static Drawable viewsMediaCountDrawable;
@@ -123,8 +125,22 @@ public static void loadRecources(Context context) {
             docMenuInDrawable = context.getResources().getDrawable(R.drawable.doc_actions_b);
             docMenuOutDrawable = context.getResources().getDrawable(R.drawable.doc_actions_g);
 
+            shareDrawable[0][0] = context.getResources().getDrawable(R.drawable.shareblue);
+            shareDrawable[0][1] = context.getResources().getDrawable(R.drawable.shareblue_pressed);
+            shareDrawable[1][0] = context.getResources().getDrawable(R.drawable.shareblack);
+            shareDrawable[1][1] = context.getResources().getDrawable(R.drawable.shareblack_pressed);
+
             geoInDrawable = context.getResources().getDrawable(R.drawable.location_b);
             geoOutDrawable = context.getResources().getDrawable(R.drawable.location_g);
+
+            context.getResources().getDrawable(R.drawable.attach_camera_states);
+            context.getResources().getDrawable(R.drawable.attach_gallery_states);
+            context.getResources().getDrawable(R.drawable.attach_video_states);
+            context.getResources().getDrawable(R.drawable.attach_audio_states);
+            context.getResources().getDrawable(R.drawable.attach_file_states);
+            context.getResources().getDrawable(R.drawable.attach_contact_states);
+            context.getResources().getDrawable(R.drawable.attach_location_states);
+            context.getResources().getDrawable(R.drawable.attach_hide_states);
         }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ScrollSlidingTabStrip.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ScrollSlidingTabStrip.java
index 40027e80e..30a0f5209 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/ScrollSlidingTabStrip.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ScrollSlidingTabStrip.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/Scroller.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/Scroller.java
index 56890bfb2..a42617994 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/Scroller.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/Scroller.java
@@ -369,7 +369,7 @@ public void fling(int startX, int startY, int velocityX, int velocityY,
 
             float dx = (float) (mFinalX - mStartX);
             float dy = (float) (mFinalY - mStartY);
-            float hyp = FloatMath.sqrt(dx * dx + dy * dy);
+            float hyp = (float) Math.sqrt(dx * dx + dy * dy);
 
             float ndx = dx / hyp;
             float ndy = dy / hyp;
@@ -386,7 +386,7 @@ public void fling(int startX, int startY, int velocityX, int velocityY,
         mMode = FLING_MODE;
         mFinished = false;
 
-        float velocity = FloatMath.sqrt(velocityX * velocityX + velocityY * velocityY);
+        float velocity = (float) Math.sqrt(velocityX * velocityX + velocityY * velocityY);
      
         mVelocity = velocity;
         float ALPHA = 800;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SectionsListView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SectionsListView.java
index 441938c38..b10564746 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SectionsListView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SectionsListView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SeekBar.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SeekBar.java
index 447644072..9b315e9e2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SeekBar.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SeekBar.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileDrawable.java
index cd4d6364a..8ad190ad0 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileDrawable.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileEx2Drawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileEx2Drawable.java
index 30aa88809..f6a46363c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileEx2Drawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileEx2Drawable.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileExDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileExDrawable.java
index f524a459e..563a8962e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileExDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SendingFileExDrawable.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/ShareFrameLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/ShareFrameLayout.java
new file mode 100644
index 000000000..c5acf3a09
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/ShareFrameLayout.java
@@ -0,0 +1,635 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.content.Context;
+import android.text.Editable;
+import android.text.InputType;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.util.TypedValue;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.inputmethod.EditorInfo;
+import android.widget.AdapterView;
+import android.widget.EditText;
+import android.widget.FrameLayout;
+import android.widget.GridView;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import org.telegram.SQLite.SQLiteCursor;
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.ChatObject;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.LocaleController;
+import org.telegram.messenger.MessageObject;
+import org.telegram.messenger.MessagesController;
+import org.telegram.messenger.MessagesStorage;
+import org.telegram.messenger.R;
+import org.telegram.messenger.SendMessagesHelper;
+import org.telegram.tgnet.NativeByteBuffer;
+import org.telegram.tgnet.TLObject;
+import org.telegram.tgnet.TLRPC;
+import org.telegram.ui.ActionBar.BottomSheet;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.ShareDialogCell;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Timer;
+import java.util.TimerTask;
+
+public class ShareFrameLayout extends FrameLayout {
+
+    private BottomSheet parentBottomSheet;
+    private TextView doneButtonBadgeTextView;
+    private TextView doneButtonTextView;
+    private LinearLayout doneButton;
+    private EditText nameTextView;
+    private GridView gridView;
+    private ShareDialogsAdapter listAdapter;
+    private ShareSearchAdapter searchAdapter;
+    private MessageObject sendingMessageObject;
+    private EmptyTextProgressView searchEmptyView;
+    private HashMap<Long, TLRPC.Dialog> selectedDialogs = new HashMap<>();
+
+    public ShareFrameLayout(Context context, BottomSheet bottomSheet, MessageObject messageObject) {
+        super(context);
+
+        parentBottomSheet = bottomSheet;
+        sendingMessageObject = messageObject;
+        searchAdapter = new ShareSearchAdapter(context);
+
+        FrameLayout frameLayout = new FrameLayout(context);
+        frameLayout.setBackgroundColor(0xffffffff);
+        addView(frameLayout, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 48, Gravity.LEFT | Gravity.TOP));
+
+        doneButton = new LinearLayout(context);
+        doneButton.setOrientation(LinearLayout.HORIZONTAL);
+        doneButton.setBackgroundResource(R.drawable.bar_selector_audio);
+        doneButton.setPadding(AndroidUtilities.dp(21), 0, AndroidUtilities.dp(21), 0);
+        frameLayout.addView(doneButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.RIGHT));
+        doneButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                ArrayList<MessageObject> arrayList = new ArrayList<>();
+                arrayList.add(sendingMessageObject);
+                for (HashMap.Entry<Long, TLRPC.Dialog> entry : selectedDialogs.entrySet()) {
+                    TLRPC.Dialog dialog = entry.getValue();
+                    boolean asAdmin = true;
+                    int lower_id = (int) dialog.id;
+                    if (lower_id < 0) {
+                        TLRPC.Chat chat = MessagesController.getInstance().getChat(-lower_id);
+                        if (chat.megagroup) {
+                            asAdmin = false;
+                        }
+                    }
+                    SendMessagesHelper.getInstance().sendMessage(arrayList, entry.getKey(), asAdmin);
+                }
+                parentBottomSheet.dismiss();
+            }
+        });
+
+        doneButtonBadgeTextView = new TextView(context);
+        doneButtonBadgeTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        doneButtonBadgeTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13);
+        doneButtonBadgeTextView.setTextColor(0xffffffff);
+        doneButtonBadgeTextView.setGravity(Gravity.CENTER);
+        doneButtonBadgeTextView.setBackgroundResource(R.drawable.bluecounter);
+        doneButtonBadgeTextView.setMinWidth(AndroidUtilities.dp(23));
+        doneButtonBadgeTextView.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), AndroidUtilities.dp(1));
+        doneButton.addView(doneButtonBadgeTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, 23, Gravity.CENTER_VERTICAL, 0, 0, 10, 0));
+
+        doneButtonTextView = new TextView(context);
+        doneButtonTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        doneButtonTextView.setTextColor(0xff19a7e8);
+        doneButtonTextView.setGravity(Gravity.CENTER);
+        doneButtonTextView.setCompoundDrawablePadding(AndroidUtilities.dp(8));
+        doneButtonTextView.setText(LocaleController.getString("Send", R.string.Send).toUpperCase());
+        doneButtonTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        doneButton.addView(doneButtonTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER_VERTICAL));
+
+        ImageView imageView = new ImageView(context);
+        imageView.setImageResource(R.drawable.search_share);
+        imageView.setScaleType(ImageView.ScaleType.CENTER);
+        imageView.setPadding(0, AndroidUtilities.dp(2), 0, 0);
+        frameLayout.addView(imageView, LayoutHelper.createFrame(48, 48, Gravity.LEFT | Gravity.CENTER_VERTICAL));
+
+        nameTextView = new EditText(context);
+        nameTextView.setHint(LocaleController.getString("ShareSendTo", R.string.ShareSendTo));
+        nameTextView.setMaxLines(1);
+        nameTextView.setSingleLine(true);
+        nameTextView.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);
+        nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
+        nameTextView.setBackgroundDrawable(null);
+        nameTextView.setHintTextColor(0xff979797);
+        nameTextView.setImeOptions(EditorInfo.IME_FLAG_NO_EXTRACT_UI);
+        nameTextView.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES);
+        AndroidUtilities.clearCursorDrawable(nameTextView);
+        nameTextView.setTextColor(0xff212121);
+        frameLayout.addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 48, 2, 96, 0));
+        nameTextView.addTextChangedListener(new TextWatcher() {
+            @Override
+            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+            }
+
+            @Override
+            public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+            }
+
+            @Override
+            public void afterTextChanged(Editable s) {
+                String text = nameTextView.getText().toString();
+                if (text.length() != 0) {
+                    if (gridView.getAdapter() != searchAdapter) {
+                        gridView.setAdapter(searchAdapter);
+                        searchAdapter.notifyDataSetChanged();
+                    }
+                    if (searchEmptyView != null) {
+                        searchEmptyView.setText(LocaleController.getString("NoResult", R.string.NoResult));
+                    }
+                } else {
+                    if (gridView.getAdapter() != listAdapter) {
+                        searchEmptyView.setText(LocaleController.getString("NoChats", R.string.NoChats));
+                        gridView.setAdapter(listAdapter);
+                        listAdapter.notifyDataSetChanged();
+                    }
+                }
+                if (searchAdapter != null) {
+                    searchAdapter.searchDialogs(text);
+                }
+            }
+        });
+
+        View lineView = new View(context);
+        lineView.setBackgroundResource(R.drawable.header_shadow);
+        addView(lineView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 3, Gravity.TOP | Gravity.LEFT, 0, 48, 0, 0));
+
+        setOnTouchListener(new OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                return true;
+            }
+        });
+
+        gridView = new GridView(context);
+        gridView.setDrawSelectorOnTop(true);
+        gridView.setPadding(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8));
+        gridView.setClipToPadding(false);
+        gridView.setStretchMode(GridView.STRETCH_COLUMN_WIDTH);
+        gridView.setHorizontalScrollBarEnabled(false);
+        gridView.setVerticalScrollBarEnabled(false);
+        gridView.setNumColumns(4);
+        gridView.setVerticalSpacing(AndroidUtilities.dp(4));
+        gridView.setHorizontalSpacing(AndroidUtilities.dp(4));
+        gridView.setSelector(R.drawable.list_selector);
+        addView(gridView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 0, 48, 0, 0));
+        gridView.setAdapter(listAdapter = new ShareDialogsAdapter(context));
+        AndroidUtilities.setListViewEdgeEffectColor(gridView, 0xfff5f6f7);
+        gridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
+                TLRPC.Dialog dialog;
+                if (gridView.getAdapter() == listAdapter) {
+                    dialog = listAdapter.getItem(i);
+                } else {
+                    dialog = searchAdapter.getItem(i);
+                }
+                ShareDialogCell cell = (ShareDialogCell) view;
+                if (selectedDialogs.containsKey(dialog.id)) {
+                    selectedDialogs.remove(dialog.id);
+                    cell.setChecked(false, true);
+                } else {
+                    selectedDialogs.put(dialog.id, dialog);
+                    cell.setChecked(true, true);
+                }
+                updateSelectedCount(selectedDialogs.size(), true);
+            }
+        });
+
+        searchEmptyView = new EmptyTextProgressView(context);
+        searchEmptyView.setShowAtCenter(true);
+        searchEmptyView.showTextView();
+        searchEmptyView.setText(LocaleController.getString("NoChats", R.string.NoChats));
+        gridView.setEmptyView(searchEmptyView);
+        addView(searchEmptyView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, 0, 48, 0, 0));
+
+        updateSelectedCount(selectedDialogs.size(), true);
+    }
+
+    public void updateSelectedCount(int count, boolean disable) {
+        if (count == 0) {
+            doneButtonBadgeTextView.setVisibility(View.GONE);
+            doneButtonTextView.setTextColor(0xffb3b3b3);
+            doneButton.setEnabled(false);
+        } else {
+            doneButtonTextView.setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, 0);
+            doneButtonBadgeTextView.setVisibility(View.VISIBLE);
+            doneButtonBadgeTextView.setText(String.format("%d", count));
+            doneButtonTextView.setTextColor(0xff3ec1f9);
+            doneButton.setEnabled(true);
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(310), MeasureSpec.EXACTLY));
+    }
+
+    private class ShareDialogsAdapter extends BaseFragmentAdapter {
+
+        private Context mContext;
+        private int currentCount;
+        private ArrayList<TLRPC.Dialog> dialogs = new ArrayList<>();
+
+        public ShareDialogsAdapter(Context context) {
+            mContext = context;
+            for (int a = 0; a < MessagesController.getInstance().dialogsServerOnly.size(); a++) {
+                TLRPC.Dialog dialog = MessagesController.getInstance().dialogsServerOnly.get(a);
+                int lower_id = (int) dialog.id;
+                int high_id = (int) (dialog.id >> 32);
+                if (lower_id != 0 && high_id != 1) {
+                    if (lower_id > 0) {
+                        dialogs.add(dialog);
+                    } else {
+                        TLRPC.Chat chat = MessagesController.getInstance().getChat(-lower_id);
+                        if (!(chat == null || ChatObject.isNotInChat(chat) || ChatObject.isChannel(chat) && !chat.creator && !chat.editor && !chat.megagroup)) {
+                            dialogs.add(dialog);
+                        }
+                    }
+                }
+            }
+        }
+
+        @Override
+        public int getCount() {
+            return dialogs.size();
+        }
+
+        public TLRPC.Dialog getItem(int i) {
+            if (i < 0 || i >= dialogs.size()) {
+                return null;
+            }
+            return dialogs.get(i);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            if (view == null) {
+                view = new ShareDialogCell(mContext);
+            }
+            ShareDialogCell cell = (ShareDialogCell) view;
+            TLRPC.Dialog dialog = getItem(i);
+            cell.setDialog(dialog, selectedDialogs.containsKey(dialog.id), null);
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            return 0;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 1;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return getCount() == 0;
+        }
+    }
+
+    public class ShareSearchAdapter extends BaseFragmentAdapter {
+
+        private Context mContext;
+        private Timer searchTimer;
+        private ArrayList<DialogSearchResult> searchResult = new ArrayList<>();
+        private String lastSearchText;
+        private int reqId = 0;
+        private int lastReqId;
+        private int lastSearchId = 0;
+
+        private class DialogSearchResult {
+            public TLRPC.Dialog dialog = new TLRPC.Dialog();
+            public TLObject object;
+            public int date;
+            public CharSequence name;
+        }
+
+        public ShareSearchAdapter(Context context) {
+            mContext = context;
+        }
+
+        private void searchDialogsInternal(final String query, final int searchId) {
+            MessagesStorage.getInstance().getStorageQueue().postRunnable(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        String search1 = query.trim().toLowerCase();
+                        if (search1.length() == 0) {
+                            lastSearchId = -1;
+                            updateSearchResults(new ArrayList<DialogSearchResult>(), lastSearchId);
+                            return;
+                        }
+                        String search2 = LocaleController.getInstance().getTranslitString(search1);
+                        if (search1.equals(search2) || search2.length() == 0) {
+                            search2 = null;
+                        }
+                        String search[] = new String[1 + (search2 != null ? 1 : 0)];
+                        search[0] = search1;
+                        if (search2 != null) {
+                            search[1] = search2;
+                        }
+
+                        ArrayList<Integer> usersToLoad = new ArrayList<>();
+                        ArrayList<Integer> chatsToLoad = new ArrayList<>();
+                        int resultCount = 0;
+
+                        HashMap<Long, DialogSearchResult> dialogsResult = new HashMap<>();
+                        SQLiteCursor cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT did, date FROM dialogs ORDER BY date DESC LIMIT 400");
+                        while (cursor.next()) {
+                            long id = cursor.longValue(0);
+                            DialogSearchResult dialogSearchResult = new DialogSearchResult();
+                            dialogSearchResult.date = cursor.intValue(1);
+                            dialogsResult.put(id, dialogSearchResult);
+
+                            int lower_id = (int) id;
+                            int high_id = (int) (id >> 32);
+                            if (lower_id != 0 && high_id != 1) {
+                                if (lower_id > 0) {
+                                    if (!usersToLoad.contains(lower_id)) {
+                                        usersToLoad.add(lower_id);
+                                    }
+                                } else {
+                                    if (!chatsToLoad.contains(-lower_id)) {
+                                        chatsToLoad.add(-lower_id);
+                                    }
+                                }
+                            }
+                        }
+                        cursor.dispose();
+
+                        if (!usersToLoad.isEmpty()) {
+                            cursor = MessagesStorage.getInstance().getDatabase().queryFinalized(String.format(Locale.US, "SELECT data, status, name FROM users WHERE uid IN(%s)", TextUtils.join(",", usersToLoad)));
+                            while (cursor.next()) {
+                                String name = cursor.stringValue(2);
+                                String tName = LocaleController.getInstance().getTranslitString(name);
+                                if (name.equals(tName)) {
+                                    tName = null;
+                                }
+                                String username = null;
+                                int usernamePos = name.lastIndexOf(";;;");
+                                if (usernamePos != -1) {
+                                    username = name.substring(usernamePos + 3);
+                                }
+                                int found = 0;
+                                for (String q : search) {
+                                    if (name.startsWith(q) || name.contains(" " + q) || tName != null && (tName.startsWith(q) || tName.contains(" " + q))) {
+                                        found = 1;
+                                    } else if (username != null && username.startsWith(q)) {
+                                        found = 2;
+                                    }
+                                    if (found != 0) {
+                                        NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(0));
+                                        if (data != null && cursor.byteBufferValue(0, data) != 0) {
+                                            TLRPC.User user = TLRPC.User.TLdeserialize(data, data.readInt32(false), false);
+                                            DialogSearchResult dialogSearchResult = dialogsResult.get((long) user.id);
+                                            if (user.status != null) {
+                                                user.status.expires = cursor.intValue(1);
+                                            }
+                                            if (found == 1) {
+                                                dialogSearchResult.name = AndroidUtilities.generateSearchName(user.first_name, user.last_name, q);
+                                            } else {
+                                                dialogSearchResult.name = AndroidUtilities.generateSearchName("@" + user.username, null, "@" + q);
+                                            }
+                                            dialogSearchResult.object = user;
+                                            dialogSearchResult.dialog.id = user.id;
+                                            resultCount++;
+                                        }
+                                        data.reuse();
+                                        break;
+                                    }
+                                }
+                            }
+                            cursor.dispose();
+                        }
+
+                        if (!chatsToLoad.isEmpty()) {
+                            cursor = MessagesStorage.getInstance().getDatabase().queryFinalized(String.format(Locale.US, "SELECT data, name FROM chats WHERE uid IN(%s)", TextUtils.join(",", chatsToLoad)));
+                            while (cursor.next()) {
+                                String name = cursor.stringValue(1);
+                                String tName = LocaleController.getInstance().getTranslitString(name);
+                                if (name.equals(tName)) {
+                                    tName = null;
+                                }
+                                for (int a = 0; a < search.length; a++) {
+                                    String q = search[a];
+                                    if (name.startsWith(q) || name.contains(" " + q) || tName != null && (tName.startsWith(q) || tName.contains(" " + q))) {
+                                        NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(0));
+                                        if (data != null && cursor.byteBufferValue(0, data) != 0) {
+                                            TLRPC.Chat chat = TLRPC.Chat.TLdeserialize(data, data.readInt32(false), false);
+                                            if (!(chat == null || ChatObject.isNotInChat(chat) || ChatObject.isChannel(chat) && !chat.creator && !chat.editor && !chat.megagroup)) {
+                                                DialogSearchResult dialogSearchResult = dialogsResult.get(-(long) chat.id);
+                                                dialogSearchResult.name = AndroidUtilities.generateSearchName(chat.title, null, q);
+                                                dialogSearchResult.object = chat;
+                                                dialogSearchResult.dialog.id = -chat.id;
+                                                resultCount++;
+                                            }
+                                        }
+                                        data.reuse();
+                                        break;
+                                    }
+                                }
+                            }
+                            cursor.dispose();
+                        }
+
+                        ArrayList<DialogSearchResult> searchResults = new ArrayList<>(resultCount);
+                        for (DialogSearchResult dialogSearchResult : dialogsResult.values()) {
+                            if (dialogSearchResult.object != null && dialogSearchResult.name != null) {
+                                searchResults.add(dialogSearchResult);
+                            }
+                        }
+
+                        cursor = MessagesStorage.getInstance().getDatabase().queryFinalized("SELECT u.data, u.status, u.name, u.uid FROM users as u INNER JOIN contacts as c ON u.uid = c.uid");
+                        while (cursor.next()) {
+                            int uid = cursor.intValue(3);
+                            if (dialogsResult.containsKey((long) uid)) {
+                                continue;
+                            }
+                            String name = cursor.stringValue(2);
+                            String tName = LocaleController.getInstance().getTranslitString(name);
+                            if (name.equals(tName)) {
+                                tName = null;
+                            }
+                            String username = null;
+                            int usernamePos = name.lastIndexOf(";;;");
+                            if (usernamePos != -1) {
+                                username = name.substring(usernamePos + 3);
+                            }
+                            int found = 0;
+                            for (String q : search) {
+                                if (name.startsWith(q) || name.contains(" " + q) || tName != null && (tName.startsWith(q) || tName.contains(" " + q))) {
+                                    found = 1;
+                                } else if (username != null && username.startsWith(q)) {
+                                    found = 2;
+                                }
+                                if (found != 0) {
+                                    NativeByteBuffer data = new NativeByteBuffer(cursor.byteArrayLength(0));
+                                    if (data != null && cursor.byteBufferValue(0, data) != 0) {
+                                        TLRPC.User user = TLRPC.User.TLdeserialize(data, data.readInt32(false), false);
+                                        DialogSearchResult dialogSearchResult = new DialogSearchResult();
+                                        if (user.status != null) {
+                                            user.status.expires = cursor.intValue(1);
+                                        }
+                                        dialogSearchResult.dialog.id = user.id;
+                                        dialogSearchResult.object = user;
+                                        if (found == 1) {
+                                            dialogSearchResult.name = AndroidUtilities.generateSearchName(user.first_name, user.last_name, q);
+                                        } else {
+                                            dialogSearchResult.name = AndroidUtilities.generateSearchName("@" + user.username, null, "@" + q);
+                                        }
+                                        searchResults.add(dialogSearchResult);
+                                    }
+                                    data.reuse();
+                                    break;
+                                }
+                            }
+                        }
+                        cursor.dispose();
+
+                        Collections.sort(searchResults, new Comparator<DialogSearchResult>() {
+                            @Override
+                            public int compare(DialogSearchResult lhs, DialogSearchResult rhs) {
+                                if (lhs.date < rhs.date) {
+                                    return 1;
+                                } else if (lhs.date > rhs.date) {
+                                    return -1;
+                                }
+                                return 0;
+                            }
+                        });
+
+                        updateSearchResults(searchResults, searchId);
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                }
+            });
+        }
+
+        private void updateSearchResults(final ArrayList<DialogSearchResult> result, final int searchId) {
+            AndroidUtilities.runOnUIThread(new Runnable() {
+                @Override
+                public void run() {
+                    if (searchId != lastSearchId) {
+                        return;
+                    }
+                    for (int a = 0; a < result.size(); a++) {
+                        DialogSearchResult obj = result.get(a);
+                        if (obj.object instanceof TLRPC.User) {
+                            TLRPC.User user = (TLRPC.User) obj.object;
+                            MessagesController.getInstance().putUser(user, true);
+                        } else if (obj.object instanceof TLRPC.Chat) {
+                            TLRPC.Chat chat = (TLRPC.Chat) obj.object;
+                            MessagesController.getInstance().putChat(chat, true);
+                        }
+                    }
+                    searchResult = result;
+                    notifyDataSetChanged();
+                }
+            });
+        }
+
+        public void searchDialogs(final String query) {
+            if (query != null && lastSearchText != null && query.equals(lastSearchText)) {
+                return;
+            }
+            lastSearchText = query;
+            try {
+                if (searchTimer != null) {
+                    searchTimer.cancel();
+                    searchTimer = null;
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+            if (query == null || query.length() == 0) {
+                searchResult.clear();
+                notifyDataSetChanged();
+            } else {
+                final int searchId = ++lastSearchId;
+                searchTimer = new Timer();
+                searchTimer.schedule(new TimerTask() {
+                    @Override
+                    public void run() {
+                        try {
+                            cancel();
+                            searchTimer.cancel();
+                            searchTimer = null;
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                        searchDialogsInternal(query, searchId);
+                    }
+                }, 200, 300);
+            }
+        }
+
+        @Override
+        public int getCount() {
+            return searchResult.size();
+        }
+
+        public TLRPC.Dialog getItem(int i) {
+            return searchResult.get(i).dialog;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            if (view == null) {
+                view = new ShareDialogCell(mContext);
+            }
+            ShareDialogCell cell = (ShareDialogCell) view;
+            DialogSearchResult result = searchResult.get(i);
+            cell.setDialog(result.dialog, selectedDialogs.containsKey(result.dialog.id), result.name);
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            return 0;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return getCount() == 0;
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SimpleTextView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SimpleTextView.java
index 2a1a0a8a3..eaf03eaf6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SimpleTextView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SimpleTextView.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/Size.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/Size.java
index 986c40703..a793a2053 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/Size.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/Size.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayout.java
index a77d0f36a..899c13d18 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayout.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayout.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayoutPhoto.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayoutPhoto.java
index b6a806bb2..80277abca 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayoutPhoto.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SizeNotifierFrameLayoutPhoto.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -11,6 +11,7 @@
 import android.content.Context;
 import android.graphics.Rect;
 import android.view.View;
+import android.view.WindowManager;
 import android.widget.FrameLayout;
 
 import org.telegram.messenger.AndroidUtilities;
@@ -20,6 +21,7 @@
     private Rect rect = new Rect();
     private int keyboardHeight;
     private SizeNotifierFrameLayoutPhotoDelegate delegate;
+    private WindowManager windowManager;
 
     public interface SizeNotifierFrameLayoutPhotoDelegate {
         void onSizeChanged(int keyboardHeight, boolean isWidthGreater);
@@ -43,7 +45,14 @@ public int getKeyboardHeight() {
         View rootView = getRootView();
         int usableViewHeight = rootView.getHeight() - AndroidUtilities.getViewInset(rootView);
         getWindowVisibleDisplayFrame(rect);
-        return (rect.bottom - rect.top) - usableViewHeight;
+        int top = rect.top;
+        int size = (rect.bottom - rect.top);
+
+        size = AndroidUtilities.displaySize.y - top - usableViewHeight;
+        if (size <= AndroidUtilities.dp(10)) {
+            size = 0;
+        }
+        return size;
     }
 
     public void notifyHeightChanged() {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SlideView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SlideView.java
index a1ae84c65..cc27b2e6a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SlideView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SlideView.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SlidingTabView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SlidingTabView.java
index 8e30cc027..859ee42b8 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SlidingTabView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SlidingTabView.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/SpannableStringLight.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/SpannableStringLight.java
index c64b07616..224d37233 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/SpannableStringLight.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/SpannableStringLight.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java
index f918c1b3c..cd464f6be 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/StaticLayoutEx.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/StickersAlert.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/StickersAlert.java
index 1e0ed7ec5..ecfe7a6db 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/StickersAlert.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/StickersAlert.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/TimerDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/TimerDrawable.java
index ea98120d6..6f363f28a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/TimerDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/TimerDrawable.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/TypefaceSpan.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/TypefaceSpan.java
index 9f86fe3b7..c0a4e6504 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/TypefaceSpan.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/TypefaceSpan.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/TypingDotsDrawable.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/TypingDotsDrawable.java
index 5ece5436d..48e801864 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/TypingDotsDrawable.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/TypingDotsDrawable.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanBotCommand.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanBotCommand.java
new file mode 100644
index 000000000..8310d65be
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanBotCommand.java
@@ -0,0 +1,27 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui.Components;
+
+import android.text.TextPaint;
+
+public class URLSpanBotCommand extends URLSpanNoUnderline {
+
+    public static boolean enabled = true;
+
+    public URLSpanBotCommand(String url) {
+        super(url);
+    }
+
+    @Override
+    public void updateDrawState(TextPaint ds) {
+        super.updateDrawState(ds);
+        ds.setColor(enabled ? 0xff316f9f : 0xff000000);
+        ds.setUnderlineText(false);
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderline.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderline.java
index 8debb5211..b2ff88819 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderline.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderline.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderlineBold.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderlineBold.java
index 7c1b06bc8..e1be75925 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderlineBold.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanNoUnderlineBold.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanReplacement.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanReplacement.java
index 3f38b1a48..764d0be23 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanReplacement.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/URLSpanReplacement.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoSeekBarView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoSeekBarView.java
index d7ac826c2..14c87235a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoSeekBarView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoSeekBarView.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoTimelineView.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoTimelineView.java
index b4cca99d4..3f9ba71cb 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoTimelineView.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/VideoTimelineView.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui.Components;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/Components/WebFrameLayout.java b/TMessagesProj/src/main/java/org/telegram/ui/Components/WebFrameLayout.java
index deeca0aaa..d51f48725 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/Components/WebFrameLayout.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/Components/WebFrameLayout.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -67,6 +67,9 @@ public WebFrameLayout(Context context, BottomSheet parentDialog, String title, S
 
         fullscreenVideoContainer = new FrameLayout(context);
         fullscreenVideoContainer.setBackgroundColor(0xff000000);
+        if (Build.VERSION.SDK_INT >= 21) {
+            fullscreenVideoContainer.setFitsSystemWindows(true);
+        }
         dialog.getContainer().addView(fullscreenVideoContainer, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
         fullscreenVideoContainer.setVisibility(INVISIBLE);
 
@@ -131,12 +134,16 @@ public void onClick(View v) {
         });
 
         View lineView = new View(context);
-        lineView.setBackgroundColor(0xffcdcdcd);
-        addView(lineView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 1, Gravity.TOP | Gravity.LEFT, 0, 40, 0, 0));
+        lineView.setBackgroundResource(R.drawable.header_shadow);
+        addView(lineView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 3, Gravity.TOP | Gravity.LEFT, 0, 40, 0, 0));
 
         webView = new WebView(context);
         webView.getSettings().setJavaScriptEnabled(true);
         webView.getSettings().setDomStorageEnabled(true);
+        if (Build.VERSION.SDK_INT >= 17) {
+            webView.getSettings().setMediaPlaybackRequiresUserGesture(false);
+        }
+
         String userAgent = webView.getSettings().getUserAgentString();
         if (userAgent != null) {
             userAgent = userAgent.replace("Android", "");
@@ -232,9 +239,14 @@ public void onOpenAnimationEnd() {
     @Override
     protected void onDetachedFromWindow() {
         super.onDetachedFromWindow();
-        webView.stopLoading();
-        webView.loadUrl("about:blank");
-        webView.destroy();
+        try {
+            removeView(webView);
+            webView.stopLoading();
+            webView.loadUrl("about:blank");
+            webView.destroy();
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ContactAddActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ContactAddActivity.java
index 1aafe718a..86c6f7810 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ContactAddActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ContactAddActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -297,8 +297,10 @@ public void onResume() {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        firstNameField.requestFocus();
-        AndroidUtilities.showKeyboard(firstNameField);
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            firstNameField.requestFocus();
+            AndroidUtilities.showKeyboard(firstNameField);
+        }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ContactsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ContactsActivity.java
index 14e342994..46922fd4e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ContactsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ContactsActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -77,6 +77,7 @@
     private boolean returnAsResult;
     private boolean createSecretChat;
     private boolean creatingChat = false;
+    private boolean allowBots = true;
     private boolean needForwardCount = true;
     private int chat_id;
     private String selectAlertString = null;
@@ -108,6 +109,7 @@ public boolean onFragmentCreate() {
             selectAlertString = arguments.getString("selectAlertString");
             allowUsernameSearch = arguments.getBoolean("allowUsernameSearch", true);
             needForwardCount = arguments.getBoolean("needForwardCount", true);
+            allowBots = arguments.getBoolean("allowBots", true);
             chat_id = arguments.getInt("chat_id", 0);
         } else {
             needPhonebook = true;
@@ -207,7 +209,7 @@ public void onTextChanged(EditText editText) {
         });
         item.getSearchField().setHint(LocaleController.getString("Search", R.string.Search));
 
-        searchListViewAdapter = new SearchAdapter(context, ignoreUsers, allowUsernameSearch, false, false);
+        searchListViewAdapter = new SearchAdapter(context, ignoreUsers, allowUsernameSearch, false, false, allowBots);
         listViewAdapter = new ContactsAdapter(context, onlyUsers ? 1 : 0, needPhonebook, ignoreUsers, chat_id != 0);
 
         fragmentView = new FrameLayout(context);
@@ -421,7 +423,7 @@ private void didSelectResult(final TLRPC.User user, boolean useAlert, String par
             if (getParentActivity() == null) {
                 return;
             }
-            if ((user.flags & TLRPC.USER_FLAG_BOT) != 0 && (user.flags & TLRPC.USER_FLAG_BOT_CANT_JOIN_GROUP) != 0) {
+            if (user.bot && user.bot_nochats) {
                 try {
                     Toast.makeText(getParentActivity(), LocaleController.getString("BotCantJoinGroups", R.string.BotCantJoinGroups), Toast.LENGTH_SHORT).show();
                 } catch (Exception e) {
@@ -433,7 +435,7 @@ private void didSelectResult(final TLRPC.User user, boolean useAlert, String par
             builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
             String message = LocaleController.formatStringSimple(selectAlertString, UserObject.getUserName(user));
             EditText editText = null;
-            if ((user.flags & TLRPC.USER_FLAG_BOT) == 0 && needForwardCount) {
+            if (!user.bot && needForwardCount) {
                 message = String.format("%s\n\n%s", message, LocaleController.getString("AddToTheGroupForwardCount", R.string.AddToTheGroupForwardCount));
                 editText = new EditText(getParentActivity());
                 if (android.os.Build.VERSION.SDK_INT < 11) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/CountrySelectActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/CountrySelectActivity.java
index b57c3cbe0..99b9da905 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/CountrySelectActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/CountrySelectActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -198,10 +198,10 @@ public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                 if (i < 0) {
                     return;
                 }
+                finishFragment();
                 if (country != null && delegate != null) {
                     delegate.didSelectCountry(country.name);
                 }
-                finishFragment();
             }
         });
 
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/DialogsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/DialogsActivity.java
index 601555b9a..8b41a837d 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/DialogsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/DialogsActivity.java
@@ -1,19 +1,24 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
 
+import android.Manifest;
 import android.animation.ObjectAnimator;
 import android.animation.StateListAnimator;
 import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.Activity;
 import android.app.AlertDialog;
+import android.app.Dialog;
 import android.content.Context;
 import android.content.DialogInterface;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.graphics.Outline;
 import android.os.Build;
@@ -35,13 +40,13 @@
 
 import org.telegram.messenger.AndroidUtilities;
 import org.telegram.messenger.ChatObject;
+import org.telegram.messenger.ImageLoader;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.MessageObject;
 import org.telegram.messenger.UserObject;
 import org.telegram.messenger.support.widget.LinearLayoutManager;
 import org.telegram.messenger.support.widget.RecyclerView;
 import org.telegram.messenger.FileLog;
-import org.telegram.tgnet.ConnectionsManager;
 import org.telegram.tgnet.TLRPC;
 import org.telegram.messenger.ContactsController;
 import org.telegram.messenger.MessagesController;
@@ -62,6 +67,7 @@
 import org.telegram.ui.ActionBar.ActionBarMenuItem;
 import org.telegram.ui.ActionBar.BaseFragment;
 import org.telegram.ui.ActionBar.MenuDrawable;
+import org.telegram.ui.Components.PlayerView;
 import org.telegram.ui.Components.EmptyTextProgressView;
 import org.telegram.ui.Components.LayoutHelper;
 import org.telegram.ui.Components.RecyclerListView;
@@ -81,12 +87,16 @@
     private ActionBarMenuItem passcodeItem;
     private ImageView floatingButton;
 
+    private AlertDialog permissionDialog;
+
     private int prevPosition;
     private int prevTop;
     private boolean scrollUpdated;
     private boolean floatingHidden;
     private final AccelerateDecelerateInterpolator floatingInterpolator = new AccelerateDecelerateInterpolator();
 
+    private boolean checkPermission = true;
+
     private String selectAlertString;
     private String selectAlertStringGroup;
     private String addToGroupAlertString;
@@ -140,7 +150,7 @@ public boolean onFragmentCreate() {
 
 
         if (!dialogsLoaded) {
-            MessagesController.getInstance().loadDialogs(0, 0, 100, true);
+            MessagesController.getInstance().loadDialogs(0, 100, true);
             ContactsController.getInstance().checkInviteText();
             dialogsLoaded = true;
         }
@@ -180,7 +190,7 @@ public View createView(final Context context) {
             passcodeItem = menu.addItem(1, R.drawable.lock_close);
             updatePasscodeButton();
         }
-        ActionBarMenuItem item = menu.addItem(0, R.drawable.ic_ab_search).setIsSearchField(true).setActionBarMenuItemSearchListener(new ActionBarMenuItem.ActionBarMenuItemSearchListener() {
+        final ActionBarMenuItem item = menu.addItem(0, R.drawable.ic_ab_search).setIsSearchField(true).setActionBarMenuItemSearchListener(new ActionBarMenuItem.ActionBarMenuItemSearchListener() {
             @Override
             public void onSearchExpand() {
                 searching = true;
@@ -241,7 +251,7 @@ public void onTextChanged(EditText editText) {
                 String text = editText.getText().toString();
                 if (text.length() != 0 || dialogsSearchAdapter != null && dialogsSearchAdapter.hasRecentRearch()) {
                     searchWas = true;
-                    if (dialogsSearchAdapter != null) {
+                    if (dialogsSearchAdapter != null && listView.getAdapter() != dialogsSearchAdapter) {
                         listView.setAdapter(dialogsSearchAdapter);
                         dialogsSearchAdapter.notifyDataSetChanged();
                     }
@@ -334,7 +344,9 @@ public void onItemClick(View view, int position) {
                             MessagesController.getInstance().putUsers(users, false);
                             MessagesStorage.getInstance().putUsersAndChats(users, null, false, true);
                         }
-                        dialogsSearchAdapter.putRecentSearch(dialog_id, (TLRPC.User) obj);
+                        if (!onlySelect) {
+                            dialogsSearchAdapter.putRecentSearch(dialog_id, (TLRPC.User) obj);
+                        }
                     } else if (obj instanceof TLRPC.Chat) {
                         if (dialogsSearchAdapter.isGlobalSearch(position)) {
                             ArrayList<TLRPC.Chat> chats = new ArrayList<>();
@@ -347,10 +359,14 @@ public void onItemClick(View view, int position) {
                         } else {
                             dialog_id = AndroidUtilities.makeBroadcastId(((TLRPC.Chat) obj).id);
                         }
-                        dialogsSearchAdapter.putRecentSearch(dialog_id, (TLRPC.Chat) obj);
+                        if (!onlySelect) {
+                            dialogsSearchAdapter.putRecentSearch(dialog_id, (TLRPC.Chat) obj);
+                        }
                     } else if (obj instanceof TLRPC.EncryptedChat) {
                         dialog_id = ((long) ((TLRPC.EncryptedChat) obj).id) << 32;
-                        dialogsSearchAdapter.putRecentSearch(dialog_id, (TLRPC.EncryptedChat) obj);
+                        if (!onlySelect) {
+                            dialogsSearchAdapter.putRecentSearch(dialog_id, (TLRPC.EncryptedChat) obj);
+                        }
                     } else if (obj instanceof MessageObject) {
                         MessageObject messageObject = (MessageObject) obj;
                         dialog_id = messageObject.getDialogId();
@@ -378,6 +394,13 @@ public void onItemClick(View view, int position) {
                             if (lower_part > 0) {
                                 args.putInt("user_id", lower_part);
                             } else if (lower_part < 0) {
+                                if (message_id != 0) {
+                                    TLRPC.Chat chat = MessagesController.getInstance().getChat(-lower_part);
+                                    if (chat != null && chat.migrated_to != null) {
+                                        args.putInt("migrated_to", lower_part);
+                                        lower_part = -chat.migrated_to.channel_id;
+                                    }
+                                }
                                 args.putInt("chat_id", -lower_part);
                             }
                         }
@@ -411,7 +434,7 @@ public void onItemClick(View view, int position) {
         });
         listView.setOnItemLongClickListener(new RecyclerListView.OnItemLongClickListener() {
             @Override
-            public void onItemClick(View view, int position) {
+            public boolean onItemClick(View view, int position) {
                 if (onlySelect || searching && searchWas || getParentActivity() == null) {
                     if (searchWas && searching || dialogsSearchAdapter.isRecentSearchDisplayed()) {
                         RecyclerView.Adapter adapter = listView.getAdapter();
@@ -433,16 +456,16 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 });
                                 builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
                                 showDialog(builder.create());
-                                return;
+                                return true;
                             }
                         }
                     }
-                    return;
+                    return false;
                 }
                 TLRPC.Dialog dialog;
                 ArrayList<TLRPC.Dialog> dialogs = getDialogsArray();
                 if (position < 0 || position >= dialogs.size()) {
-                    return;
+                    return false;
                 }
                 dialog = dialogs.get(position);
                 selectedDialog = dialog.id;
@@ -453,28 +476,53 @@ public void onClick(DialogInterface dialogInterface, int i) {
 
                 if (dialog instanceof TLRPC.TL_dialogChannel) {
                     final TLRPC.Chat chat = MessagesController.getInstance().getChat(-lower_id);
-                    if (chat == null) {
-                        return;
+                    CharSequence items[];
+                    if (chat != null && chat.megagroup) {
+                        items = new CharSequence[]{LocaleController.getString("ClearHistoryCache", R.string.ClearHistoryCache), chat == null || !chat.creator ? LocaleController.getString("LeaveMegaMenu", R.string.LeaveMegaMenu) : LocaleController.getString("DeleteMegaMenu", R.string.DeleteMegaMenu)};
+                    } else {
+                        items = new CharSequence[]{LocaleController.getString("ClearHistoryCache", R.string.ClearHistoryCache), chat == null || !chat.creator ? LocaleController.getString("LeaveChannelMenu", R.string.LeaveChannelMenu) : LocaleController.getString("ChannelDeleteMenu", R.string.ChannelDeleteMenu)};
                     }
-                    builder.setItems(new CharSequence[]{(chat.flags & TLRPC.CHAT_FLAG_ADMIN) == 0 ? LocaleController.getString("LeaveChannelMenu", R.string.LeaveChannelMenu) : LocaleController.getString("ChannelDeleteMenu", R.string.ChannelDeleteMenu)}, new DialogInterface.OnClickListener() {
+                    builder.setItems(items, new DialogInterface.OnClickListener() {
                         @Override
                         public void onClick(DialogInterface dialog, final int which) {
                             AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                             builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-                            if ((chat.flags & TLRPC.CHAT_FLAG_ADMIN) == 0) {
-                                builder.setMessage(LocaleController.getString("ChannelLeaveAlert", R.string.ChannelLeaveAlert));
+                            if (which == 0) {
+                                if (chat != null && chat.megagroup) {
+                                    builder.setMessage(LocaleController.getString("AreYouSureClearHistorySuper", R.string.AreYouSureClearHistorySuper));
+                                } else {
+                                    builder.setMessage(LocaleController.getString("AreYouSureClearHistoryChannel", R.string.AreYouSureClearHistoryChannel));
+                                }
+                                builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialogInterface, int i) {
+                                        MessagesController.getInstance().deleteDialog(selectedDialog, 2);
+                                    }
+                                });
                             } else {
-                                builder.setMessage(LocaleController.getString("ChannelDeleteAlert", R.string.ChannelDeleteAlert));
-                            }
-                            builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
-                                @Override
-                                public void onClick(DialogInterface dialogInterface, int i) {
-                                    MessagesController.getInstance().deleteUserFromChat((int) -selectedDialog, UserConfig.getCurrentUser(), null);
-                                    if (AndroidUtilities.isTablet()) {
-                                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats, selectedDialog);
+                                if (chat != null && chat.megagroup) {
+                                    if (!chat.creator) {
+                                        builder.setMessage(LocaleController.getString("MegaLeaveAlert", R.string.MegaLeaveAlert));
+                                    } else {
+                                        builder.setMessage(LocaleController.getString("MegaDeleteAlert", R.string.MegaDeleteAlert));
+                                    }
+                                } else {
+                                    if (chat == null || !chat.creator) {
+                                        builder.setMessage(LocaleController.getString("ChannelLeaveAlert", R.string.ChannelLeaveAlert));
+                                    } else {
+                                        builder.setMessage(LocaleController.getString("ChannelDeleteAlert", R.string.ChannelDeleteAlert));
                                     }
                                 }
-                            });
+                                builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialogInterface, int i) {
+                                        MessagesController.getInstance().deleteUserFromChat((int) -selectedDialog, UserConfig.getCurrentUser(), null);
+                                        if (AndroidUtilities.isTablet()) {
+                                            NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats, selectedDialog);
+                                        }
+                                    }
+                                });
+                            }
                             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
                             showDialog(builder.create());
                         }
@@ -482,7 +530,14 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     showDialog(builder.create());
                 } else {
                     final boolean isChat = lower_id < 0 && high_id != 1;
-                    builder.setItems(new CharSequence[]{LocaleController.getString("ClearHistory", R.string.ClearHistory), isChat ? LocaleController.getString("DeleteChat", R.string.DeleteChat) : LocaleController.getString("Delete", R.string.Delete)}, new DialogInterface.OnClickListener() {
+                    TLRPC.User user = null;
+                    if (!isChat && lower_id > 0 && high_id != 1) {
+                        user = MessagesController.getInstance().getUser(lower_id);
+                    }
+                    final boolean isBot = user != null && user.bot;
+                    builder.setItems(new CharSequence[]{LocaleController.getString("ClearHistory", R.string.ClearHistory),
+                            isChat ? LocaleController.getString("DeleteChat", R.string.DeleteChat) :
+                                    isBot ? LocaleController.getString("DeleteAndStop", R.string.DeleteAndStop) : LocaleController.getString("Delete", R.string.Delete)}, new DialogInterface.OnClickListener() {
                         @Override
                         public void onClick(DialogInterface dialog, final int which) {
                             AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
@@ -503,18 +558,21 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                         if (isChat) {
                                             TLRPC.Chat currentChat = MessagesController.getInstance().getChat((int) -selectedDialog);
                                             if (currentChat != null && ChatObject.isNotInChat(currentChat)) {
-                                                MessagesController.getInstance().deleteDialog(selectedDialog, 0, false);
+                                                MessagesController.getInstance().deleteDialog(selectedDialog, 0);
                                             } else {
                                                 MessagesController.getInstance().deleteUserFromChat((int) -selectedDialog, MessagesController.getInstance().getUser(UserConfig.getClientUserId()), null);
                                             }
                                         } else {
-                                            MessagesController.getInstance().deleteDialog(selectedDialog, 0, false);
+                                            MessagesController.getInstance().deleteDialog(selectedDialog, 0);
+                                        }
+                                        if (isBot) {
+                                            MessagesController.getInstance().blockUser((int) selectedDialog);
                                         }
                                         if (AndroidUtilities.isTablet()) {
                                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats, selectedDialog);
                                         }
                                     } else {
-                                        MessagesController.getInstance().deleteDialog(selectedDialog, 0, true);
+                                        MessagesController.getInstance().deleteDialog(selectedDialog, 1);
                                     }
                                 }
                             });
@@ -524,7 +582,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     });
                     showDialog(builder.create());
                 }
-
+                return true;
             }
         });
 
@@ -619,8 +677,8 @@ public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
                     return;
                 }
                 if (visibleItemCount > 0) {
-                    if (layoutManager.findLastVisibleItemPosition() == getDialogsArray().size()) {
-                        MessagesController.getInstance().loadDialogs(MessagesController.getInstance().dialogs.size(), MessagesController.getInstance().currentDialogsCount, 100, true);
+                    if (layoutManager.findLastVisibleItemPosition() >= getDialogsArray().size() - 10) {
+                        MessagesController.getInstance().loadDialogs(-1, 100, !MessagesController.getInstance().dialogsEndReached);
                     }
                 }
 
@@ -689,6 +747,10 @@ public void searchStateChanged(boolean search) {
             actionBar.openSearchField(searchString);
         }
 
+        if (!onlySelect && dialogsType == 0) {
+            frameLayout.addView(new PlayerView(context, this), LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 39, Gravity.TOP | Gravity.LEFT, 0, -36, 0, 0));
+        }
+
         return fragmentView;
     }
 
@@ -701,6 +763,57 @@ public void onResume() {
         if (dialogsSearchAdapter != null) {
             dialogsSearchAdapter.notifyDataSetChanged();
         }
+        if (checkPermission && !onlySelect && Build.VERSION.SDK_INT >= 23) {
+            Activity activity = getParentActivity();
+            if (activity != null) {
+                checkPermission = false;
+                if (activity.checkSelfPermission(Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED || activity.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                    if (activity.shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS)) {
+                        AlertDialog.Builder builder = new AlertDialog.Builder(activity);
+                        builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                        builder.setMessage(LocaleController.getString("PermissionContacts", R.string.PermissionContacts));
+                        builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
+                        showDialog(permissionDialog = builder.create());
+                    } else if (activity.shouldShowRequestPermissionRationale(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
+                        AlertDialog.Builder builder = new AlertDialog.Builder(activity);
+                        builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                        builder.setMessage(LocaleController.getString("PermissionStorage", R.string.PermissionStorage));
+                        builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
+                        showDialog(permissionDialog = builder.create());
+                    } else {
+                        askForPermissons();
+                    }
+                }
+            }
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.M)
+    private void askForPermissons() {
+        Activity activity = getParentActivity();
+        if (activity == null) {
+            return;
+        }
+        ArrayList<String> permissons = new ArrayList<>();
+        if (activity.checkSelfPermission(Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+            permissons.add(Manifest.permission.READ_CONTACTS);
+            permissons.add(Manifest.permission.WRITE_CONTACTS);
+            permissons.add(Manifest.permission.GET_ACCOUNTS);
+        }
+        if (activity.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+            permissons.add(Manifest.permission.READ_EXTERNAL_STORAGE);
+            permissons.add(Manifest.permission.WRITE_EXTERNAL_STORAGE);
+        }
+        String[] items = permissons.toArray(new String[permissons.size()]);
+        activity.requestPermissions(items, 1);
+    }
+
+    @Override
+    protected void onDialogDismiss(Dialog dialog) {
+        super.onDialogDismiss(dialog);
+        if (permissionDialog != null && dialog == permissionDialog && getParentActivity() != null) {
+            askForPermissons();
+        }
     }
 
     @Override
@@ -724,6 +837,25 @@ public void onGlobalLayout() {
         }
     }
 
+    @Override
+    public void onRequestPermissionsResultFragment(int requestCode, String[] permissions, int[] grantResults) {
+        if (requestCode == 1) {
+            for (int a = 0; a < permissions.length; a++) {
+                if (grantResults[a] != PackageManager.PERMISSION_GRANTED) {
+                    continue;
+                }
+                switch (permissions[a]) {
+                    case Manifest.permission.READ_CONTACTS:
+                        ContactsController.getInstance().readContacts();
+                        break;
+                    case Manifest.permission.WRITE_EXTERNAL_STORAGE:
+                        ImageLoader.getInstance().createMediaPaths();
+                        break;
+                }
+            }
+        }
+    }
+
     @Override
     @SuppressWarnings("unchecked")
     public void didReceivedNotification(int id, Object... args) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/DocumentSelectActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/DocumentSelectActivity.java
index a3ddf0d07..307908f52 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/DocumentSelectActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/DocumentSelectActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -14,17 +14,16 @@
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.res.Configuration;
 import android.os.Build;
 import android.os.Environment;
 import android.os.StatFs;
-import android.text.TextUtils;
-import android.view.Gravity;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
 import android.widget.AbsListView;
 import android.widget.AdapterView;
-import android.widget.LinearLayout;
 import android.widget.ListView;
 import android.widget.TextView;
 
@@ -33,6 +32,7 @@
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.R;
+import org.telegram.ui.ActionBar.BackDrawable;
 import org.telegram.ui.Adapters.BaseFragmentAdapter;
 import org.telegram.ui.ActionBar.ActionBar;
 import org.telegram.ui.ActionBar.ActionBarMenu;
@@ -41,6 +41,7 @@
 import org.telegram.ui.ActionBar.BaseFragment;
 import org.telegram.ui.Cells.SharedDocumentCell;
 import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.NumberTextView;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -61,7 +62,7 @@
 
     private ListView listView;
     private ListAdapter listAdapter;
-    private TextView selectedMessagesCountTextView;
+    private NumberTextView selectedMessagesCountTextView;
     private TextView emptyView;
 
     private File currentDir;
@@ -145,18 +146,20 @@ public View createView(Context context) {
             ApplicationLoader.applicationContext.registerReceiver(receiver, filter);
         }
 
-        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setBackButtonDrawable(new BackDrawable(false));
         actionBar.setAllowOverlayTitle(true);
         actionBar.setTitle(LocaleController.getString("SelectFile", R.string.SelectFile));
         actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
             @Override
             public void onItemClick(int id) {
                 if (id == -1) {
-                    finishFragment();
-                } else if (id == -2) {
-                    selectedFiles.clear();
-                    actionBar.hideActionMode();
-                    listView.invalidateViews();
+                    if (actionBar.isActionModeShowed()) {
+                        selectedFiles.clear();
+                        actionBar.hideActionMode();
+                        listView.invalidateViews();
+                    } else {
+                        finishFragment();
+                    }
                 } else if (id == done) {
                     if (delegate != null) {
                         ArrayList<String> files = new ArrayList<>();
@@ -170,29 +173,18 @@ public void onItemClick(int id) {
         actionModeViews.clear();
 
         final ActionBarMenu actionMode = actionBar.createActionMode();
-        actionModeViews.add(actionMode.addItem(-2, R.drawable.ic_ab_back_grey, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
 
-        selectedMessagesCountTextView = new TextView(actionMode.getContext());
+        selectedMessagesCountTextView = new NumberTextView(actionMode.getContext());
         selectedMessagesCountTextView.setTextSize(18);
         selectedMessagesCountTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
         selectedMessagesCountTextView.setTextColor(0xff737373);
-        selectedMessagesCountTextView.setSingleLine(true);
-        selectedMessagesCountTextView.setLines(1);
-        selectedMessagesCountTextView.setEllipsize(TextUtils.TruncateAt.END);
-        selectedMessagesCountTextView.setPadding(AndroidUtilities.dp(11), 0, 0, AndroidUtilities.dp(2));
-        selectedMessagesCountTextView.setGravity(Gravity.CENTER_VERTICAL);
         selectedMessagesCountTextView.setOnTouchListener(new View.OnTouchListener() {
             @Override
             public boolean onTouch(View v, MotionEvent event) {
                 return true;
             }
         });
-        actionMode.addView(selectedMessagesCountTextView);
-        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) selectedMessagesCountTextView.getLayoutParams();
-        layoutParams.weight = 1;
-        layoutParams.width = 0;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        selectedMessagesCountTextView.setLayoutParams(layoutParams);
+        actionMode.addView(selectedMessagesCountTextView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f, 65, 0, 0, 0));
 
         actionModeViews.add(actionMode.addItem(done, R.drawable.ic_ab_done_gray, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
 
@@ -244,18 +236,14 @@ public boolean onItemLongClick(AdapterView<?> parent, View view, int i, long id)
                         return false;
                     }
                     selectedFiles.put(file.toString(), item);
-                    selectedMessagesCountTextView.setText(String.format("%d", selectedFiles.size()));
+                    selectedMessagesCountTextView.setNumber(1, false);
                     if (Build.VERSION.SDK_INT >= 11) {
                         AnimatorSetProxy animatorSet = new AnimatorSetProxy();
                         ArrayList<Object> animators = new ArrayList<>();
                         for (int a = 0; a < actionModeViews.size(); a++) {
                             View view2 = actionModeViews.get(a);
                             AndroidUtilities.clearDrawableAnimation(view2);
-                            if (a < 1) {
-                                animators.add(ObjectAnimatorProxy.ofFloat(view2, "translationX", -AndroidUtilities.dp(56), 0));
-                            } else {
-                                animators.add(ObjectAnimatorProxy.ofFloat(view2, "scaleY", 0.1f, 1.0f));
-                            }
+                            animators.add(ObjectAnimatorProxy.ofFloat(view2, "scaleY", 0.1f, 1.0f));
                         }
                         animatorSet.playTogether(animators);
                         animatorSet.setDuration(250);
@@ -331,7 +319,7 @@ public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                         if (selectedFiles.isEmpty()) {
                             actionBar.hideActionMode();
                         } else {
-                            selectedMessagesCountTextView.setText(String.format("%d", selectedFiles.size()));
+                            selectedMessagesCountTextView.setNumber(selectedFiles.size(), true);
                         }
                         scrolling = false;
                         if (view instanceof SharedDocumentCell) {
@@ -359,6 +347,34 @@ public void onResume() {
         if (listAdapter != null) {
             listAdapter.notifyDataSetChanged();
         }
+        fixLayoutInternal();
+    }
+
+    @Override
+    public void onConfigurationChanged(android.content.res.Configuration newConfig) {
+        super.onConfigurationChanged(newConfig);
+        if (listView != null) {
+            ViewTreeObserver obs = listView.getViewTreeObserver();
+            obs.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
+                @Override
+                public boolean onPreDraw() {
+                    listView.getViewTreeObserver().removeOnPreDrawListener(this);
+                    fixLayoutInternal();
+                    return true;
+                }
+            });
+        }
+    }
+
+    private void fixLayoutInternal() {
+        if (selectedMessagesCountTextView == null) {
+            return;
+        }
+        if (!AndroidUtilities.isTablet() && ApplicationLoader.applicationContext.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
+            selectedMessagesCountTextView.setTextSize(18);
+        } else {
+            selectedMessagesCountTextView.setTextSize(20);
+        }
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
index 276323c46..73bb9d5b7 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -160,7 +160,7 @@ public void onItemClick(int id) {
         ActionBarMenu menu = actionBar.createMenu();
         menu.addItemWithWidth(done_button, R.drawable.ic_done, AndroidUtilities.dp(56));
 
-        searchListViewAdapter = new SearchAdapter(context, null, false, false, false);
+        searchListViewAdapter = new SearchAdapter(context, null, false, false, false, false);
         searchListViewAdapter.setCheckedMap(selectedContacts);
         searchListViewAdapter.setUseUserCell(true);
         listViewAdapter = new ContactsAdapter(context, 1, false, null, false);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateFinalActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateFinalActivity.java
index e9d157b18..af9162342 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateFinalActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/GroupCreateFinalActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -375,9 +375,11 @@ public void restoreSelfArgs(Bundle args) {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        nameTextView.requestFocus();
-        AndroidUtilities.showKeyboard(nameTextView);
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            nameTextView.requestFocus();
+            AndroidUtilities.showKeyboard(nameTextView);
+        }
     }
 
     @Override
@@ -448,7 +450,7 @@ public boolean isEnabled(int position) {
         @Override
         public View getView(int i, View view, ViewGroup viewGroup) {
             if (view == null) {
-                view = new UserCell(mContext, 1);
+                view = new UserCell(mContext, 1, 0);
             }
 
             TLRPC.User user = MessagesController.getInstance().getUser(selectedContacts.get(i));
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java
index 65af539ea..f8e8cafc2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/GroupInviteActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -178,9 +178,6 @@ public void onClick(DialogInterface dialogInterface, int i) {
     @Override
     public void didReceivedNotification(int id, Object... args) {
         if (id == NotificationCenter.chatInfoDidLoaded) {
-            if (args.length != 2) {
-                return;
-            }
             TLRPC.ChatFull info = (TLRPC.ChatFull) args[0];
             int guid = (int) args[1];
             if (info.id == chat_id && guid == classGuid) {
@@ -309,7 +306,8 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                     ((TextInfoPrivacyCell) view).setText("");
                     view.setBackgroundResource(R.drawable.greydivider_bottom);
                 } else if (i == linkInfoRow) {
-                    if (ChatObject.isChannel(chat_id)) {
+                    TLRPC.Chat chat = MessagesController.getInstance().getChat(chat_id);
+                    if (ChatObject.isChannel(chat) && !chat.megagroup) {
                         ((TextInfoPrivacyCell) view).setText(LocaleController.getString("ChannelLinkInfo", R.string.ChannelLinkInfo));
                     } else {
                         ((TextInfoPrivacyCell) view).setText(LocaleController.getString("LinkInfo", R.string.LinkInfo));
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/IdenticonActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/IdenticonActivity.java
index f695fda44..61b620d0c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/IdenticonActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/IdenticonActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/IntroActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/IntroActivity.java
index dd43638e3..60579ddf9 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/IntroActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/IntroActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -28,10 +28,13 @@
 import android.widget.TextView;
 
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.BuildConfig;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.R;
+import org.telegram.tgnet.ConnectionsManager;
 
 public class IntroActivity extends Activity {
+
     private ViewPager viewPager;
     private ImageView topImage1;
     private ImageView topImage2;
@@ -57,7 +60,7 @@ protected void onCreate(Bundle savedInstanceState) {
         }
 
         if (LocaleController.isRTL) {
-            icons = new int[] {
+            icons = new int[]{
                     R.drawable.intro7,
                     R.drawable.intro6,
                     R.drawable.intro5,
@@ -66,7 +69,7 @@ protected void onCreate(Bundle savedInstanceState) {
                     R.drawable.intro2,
                     R.drawable.intro1
             };
-            titles = new int[] {
+            titles = new int[]{
                     R.string.Page7Title,
                     R.string.Page6Title,
                     R.string.Page5Title,
@@ -75,7 +78,7 @@ protected void onCreate(Bundle savedInstanceState) {
                     R.string.Page2Title,
                     R.string.Page1Title
             };
-            messages = new int[] {
+            messages = new int[]{
                     R.string.Page7Message,
                     R.string.Page6Message,
                     R.string.Page5Message,
@@ -85,7 +88,7 @@ protected void onCreate(Bundle savedInstanceState) {
                     R.string.Page1Message
             };
         } else {
-            icons = new int[] {
+            icons = new int[]{
                     R.drawable.intro1,
                     R.drawable.intro2,
                     R.drawable.intro3,
@@ -94,7 +97,7 @@ protected void onCreate(Bundle savedInstanceState) {
                     R.drawable.intro6,
                     R.drawable.intro7
             };
-            titles = new int[] {
+            titles = new int[]{
                     R.string.Page1Title,
                     R.string.Page2Title,
                     R.string.Page3Title,
@@ -103,7 +106,7 @@ protected void onCreate(Bundle savedInstanceState) {
                     R.string.Page6Title,
                     R.string.Page7Title
             };
-            messages = new int[] {
+            messages = new int[]{
                     R.string.Page1Message,
                     R.string.Page2Message,
                     R.string.Page3Message,
@@ -113,18 +116,18 @@ protected void onCreate(Bundle savedInstanceState) {
                     R.string.Page7Message
             };
         }
-        viewPager = (ViewPager)findViewById(R.id.intro_view_pager);
+        viewPager = (ViewPager) findViewById(R.id.intro_view_pager);
         TextView startMessagingButton = (TextView) findViewById(R.id.start_messaging_button);
         startMessagingButton.setText(LocaleController.getString("StartMessaging", R.string.StartMessaging).toUpperCase());
         if (Build.VERSION.SDK_INT >= 21) {
             StateListAnimator animator = new StateListAnimator();
-            animator.addState(new int[] {android.R.attr.state_pressed}, ObjectAnimator.ofFloat(startMessagingButton, "translationZ", AndroidUtilities.dp(2), AndroidUtilities.dp(4)).setDuration(200));
-            animator.addState(new int[] {}, ObjectAnimator.ofFloat(startMessagingButton, "translationZ", AndroidUtilities.dp(4), AndroidUtilities.dp(2)).setDuration(200));
+            animator.addState(new int[]{android.R.attr.state_pressed}, ObjectAnimator.ofFloat(startMessagingButton, "translationZ", AndroidUtilities.dp(2), AndroidUtilities.dp(4)).setDuration(200));
+            animator.addState(new int[]{}, ObjectAnimator.ofFloat(startMessagingButton, "translationZ", AndroidUtilities.dp(4), AndroidUtilities.dp(2)).setDuration(200));
             startMessagingButton.setStateListAnimator(animator);
         }
-        topImage1 = (ImageView)findViewById(R.id.icon_image1);
-        topImage2 = (ImageView)findViewById(R.id.icon_image2);
-        bottomPages = (ViewGroup)findViewById(R.id.bottom_pages);
+        topImage1 = (ImageView) findViewById(R.id.icon_image1);
+        topImage2 = (ImageView) findViewById(R.id.icon_image2);
+        bottomPages = (ViewGroup) findViewById(R.id.bottom_pages);
         topImage2.setVisibility(View.GONE);
         viewPager.setAdapter(new IntroAdapter());
         viewPager.setPageMargin(0);
@@ -218,6 +221,15 @@ public void onClick(View view) {
                 finish();
             }
         });
+        if (BuildConfig.DEBUG) {
+            startMessagingButton.setOnLongClickListener(new View.OnLongClickListener() {
+                @Override
+                public boolean onLongClick(View v) {
+                    ConnectionsManager.getInstance().switchBackend();
+                    return true;
+                }
+            });
+        }
 
         justCreated = true;
     }
@@ -254,8 +266,8 @@ public int getCount() {
         @Override
         public Object instantiateItem(ViewGroup container, int position) {
             View view = View.inflate(container.getContext(), R.layout.intro_view_layout, null);
-            TextView headerTextView = (TextView)view.findViewById(R.id.header_text);
-            TextView messageTextView = (TextView)view.findViewById(R.id.message_text);
+            TextView headerTextView = (TextView) view.findViewById(R.id.header_text);
+            TextView messageTextView = (TextView) view.findViewById(R.id.message_text);
             container.addView(view, 0);
 
             headerTextView.setText(getString(titles[position]));
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LanguageSelectActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LanguageSelectActivity.java
index e98fb5f09..b6c0a4f6c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LanguageSelectActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LanguageSelectActivity.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LastSeenActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LastSeenActivity.java
index 319e0a410..33dc5a6ad 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LastSeenActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LastSeenActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -43,6 +43,7 @@
 import org.telegram.ui.ActionBar.BaseFragment;
 import org.telegram.ui.Adapters.BaseFragmentAdapter;
 import org.telegram.ui.Cells.HeaderCell;
+import org.telegram.ui.Cells.LastSeenRadioCell;
 import org.telegram.ui.Cells.TextInfoPrivacyCell;
 import org.telegram.ui.Cells.TextSettingsCell;
 import org.telegram.ui.Components.LayoutHelper;
@@ -57,6 +58,7 @@
     private int currentType = 0;
     private ArrayList<Integer> currentPlus;
     private ArrayList<Integer> currentMinus;
+    private int lastCheckedType = -1;
 
     private int lastSeenSectionRow;
     private int everybodyRow;
@@ -175,6 +177,7 @@ public void onItemClick(AdapterView<?> adapterView, View view, final int i, long
                         return;
                     }
                     doneButton.setVisibility(View.VISIBLE);
+                    lastCheckedType = currentType;
                     currentType = newType;
                     updateRows();
                 } else if (i == neverShareRow || i == alwaysShareRow) {
@@ -203,6 +206,7 @@ public void didSelectUsers(ArrayList<Integer> ids) {
                                     }
                                 }
                                 doneButton.setVisibility(View.VISIBLE);
+                                lastCheckedType = -1;
                                 listAdapter.notifyDataSetChanged();
                             }
                         });
@@ -387,6 +391,7 @@ private void updateRows() {
     @Override
     public void onResume() {
         super.onResume();
+        lastCheckedType = -1;
         if (listAdapter != null) {
             listAdapter.notifyDataSetChanged();
         }
@@ -438,13 +443,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                     view.setBackgroundColor(0xffffffff);
                 }
                 TextSettingsCell textCell = (TextSettingsCell) view;
-                if (i == everybodyRow) {
-                    textCell.setTextAndIcon(LocaleController.getString("LastSeenEverybody", R.string.LastSeenEverybody), currentType == 0 ? R.drawable.check_blue : 0, true);
-                } else if (i == myContactsRow) {
-                    textCell.setTextAndIcon(LocaleController.getString("LastSeenContacts", R.string.LastSeenContacts), currentType == 2 ? R.drawable.check_blue : 0, true);
-                } else if (i == nobodyRow) {
-                    textCell.setTextAndIcon(LocaleController.getString("LastSeenNobody", R.string.LastSeenNobody), currentType == 1 ? R.drawable.check_blue : 0, false);
-                } else if (i == alwaysShareRow) {
+                if (i == alwaysShareRow) {
                     String value;
                     if (currentPlus.size() != 0) {
                         value = LocaleController.formatPluralString("Users", currentPlus.size());
@@ -483,25 +482,49 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                 } else if (i == shareSectionRow) {
                     ((HeaderCell) view).setText(LocaleController.getString("AddExceptions", R.string.AddExceptions));
                 }
+            } else if (type == 3) {
+                if (view == null) {
+                    view = new LastSeenRadioCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                LastSeenRadioCell textCell = (LastSeenRadioCell) view;
+                int checkedType = 0;
+                if (i == everybodyRow) {
+                    textCell.setText(LocaleController.getString("LastSeenEverybody", R.string.LastSeenEverybody), lastCheckedType == 0, true);
+                    checkedType = 0;
+                } else if (i == myContactsRow) {
+                    textCell.setText(LocaleController.getString("LastSeenContacts", R.string.LastSeenContacts), lastCheckedType == 2, true);
+                    checkedType = 2;
+                } else if (i == nobodyRow) {
+                    textCell.setText(LocaleController.getString("LastSeenNobody", R.string.LastSeenNobody), lastCheckedType == 1, false);
+                    checkedType = 1;
+                }
+                if (lastCheckedType == checkedType) {
+                    textCell.setChecked(false, true);
+                } else if (currentType == checkedType) {
+                    textCell.setChecked(true, true);
+                }
             }
             return view;
         }
 
         @Override
         public int getItemViewType(int i) {
-            if (i == alwaysShareRow || i == neverShareRow || i == everybodyRow || i == myContactsRow || i == nobodyRow) {
+            if (i == alwaysShareRow || i == neverShareRow) {
                 return 0;
             } else if (i == shareDetailRow || i == lastSeenDetailRow) {
                 return 1;
             } else if (i == lastSeenSectionRow || i == shareSectionRow) {
                 return 2;
+            } else if (i == everybodyRow || i == myContactsRow || i == nobodyRow) {
+                return 3;
             }
             return 0;
         }
 
         @Override
         public int getViewTypeCount() {
-            return 3;
+            return 4;
         }
 
         @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LastSeenUsersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LastSeenUsersActivity.java
index 7dfb0d442..7d38fbd0c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LastSeenUsersActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LastSeenUsersActivity.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -273,7 +273,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
             int type = getItemViewType(i);
             if (type == 0) {
                 if (view == null) {
-                    view = new UserCell(mContext, 1);
+                    view = new UserCell(mContext, 1, 0);
                 }
                 TLRPC.User user = MessagesController.getInstance().getUser(uidArray.get(i));
                 ((UserCell)view).setData(user, null, user.phone != null && user.phone.length() != 0 ? PhoneFormat.getInstance().format("+" + user.phone) : LocaleController.getString("NumberUnknown", R.string.NumberUnknown), 0);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
index 312ada984..8a2753c8e 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LaunchActivity.java
@@ -1,13 +1,14 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
@@ -15,6 +16,7 @@
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.SharedPreferences;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.database.Cursor;
 import android.graphics.Point;
@@ -26,7 +28,6 @@
 import android.provider.ContactsContract;
 import android.support.annotation.NonNull;
 import android.view.ActionMode;
-import android.view.Gravity;
 import android.view.KeyEvent;
 import android.view.MotionEvent;
 import android.view.View;
@@ -46,6 +47,7 @@
 import org.telegram.PhoneFormat.PhoneFormat;
 import org.telegram.messenger.ChatObject;
 import org.telegram.messenger.ContactsController;
+import org.telegram.messenger.ImageLoader;
 import org.telegram.messenger.MessagesController;
 import org.telegram.messenger.MessagesStorage;
 import org.telegram.messenger.NativeCrashManager;
@@ -66,7 +68,6 @@
 import org.telegram.ui.ActionBar.ActionBarLayout;
 import org.telegram.ui.ActionBar.BaseFragment;
 import org.telegram.ui.ActionBar.DrawerLayoutContainer;
-import org.telegram.ui.Components.DrawerPlayerView;
 import org.telegram.ui.Components.LayoutHelper;
 import org.telegram.ui.Components.PasscodeView;
 
@@ -91,6 +92,7 @@
     private static ArrayList<BaseFragment> mainFragmentsStack = new ArrayList<>();
     private static ArrayList<BaseFragment> layerFragmentsStack = new ArrayList<>();
     private static ArrayList<BaseFragment> rightFragmentsStack = new ArrayList<>();
+    private ViewTreeObserver.OnGlobalLayoutListener onGlobalLayoutListener;
 
     private ActionBarLayout actionBarLayout;
     private ActionBarLayout layersActionBarLayout;
@@ -140,7 +142,6 @@ protected void onCreate(Bundle savedInstanceState) {
         setTheme(R.style.Theme_TMessages);
         getWindow().setBackgroundDrawableResource(R.drawable.transparent);
 
-
         super.onCreate(savedInstanceState);
 
         if (UserConfig.passcodeHash.length() != 0 && UserConfig.appLocked) {
@@ -260,22 +261,24 @@ public void onClick(View v) {
             drawerLayoutContainer.addView(actionBarLayout, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
         }
 
-        FrameLayout listViewContainer = new FrameLayout(this);
-        listViewContainer.setBackgroundColor(0xffffffff);
-        drawerLayoutContainer.setDrawerLayout(listViewContainer);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) listViewContainer.getLayoutParams();
-        Point screenSize = AndroidUtilities.getRealScreenSize();
-        layoutParams.width = AndroidUtilities.isTablet() ? AndroidUtilities.dp(320) : Math.min(screenSize.x, screenSize.y) - AndroidUtilities.dp(56);
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        listViewContainer.setLayoutParams(layoutParams);
-
-        ListView listView = new ListView(this);
+        ListView listView = new ListView(this) {
+            @Override
+            public boolean hasOverlappingRendering() {
+                return false;
+            }
+        };
+        listView.setBackgroundColor(0xffffffff);
         listView.setAdapter(drawerLayoutAdapter = new DrawerLayoutAdapter(this));
         listView.setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
         listView.setDivider(null);
         listView.setDividerHeight(0);
         listView.setVerticalScrollBarEnabled(false);
-        listViewContainer.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        drawerLayoutContainer.setDrawerLayout(listView);
+        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
+        Point screenSize = AndroidUtilities.getRealScreenSize();
+        layoutParams.width = AndroidUtilities.isTablet() ? AndroidUtilities.dp(320) : Math.min(screenSize.x, screenSize.y) - AndroidUtilities.dp(56);
+        layoutParams.height = LayoutHelper.MATCH_PARENT;
+        listView.setLayoutParams(layoutParams);
 
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
@@ -335,16 +338,6 @@ public void onItemClick(AdapterView<?> parent, View view, int position, long id)
             }
         });
 
-        DrawerPlayerView drawerPlayerView = new DrawerPlayerView(this, listView);
-        listViewContainer.addView(drawerPlayerView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 51, Gravity.LEFT | Gravity.BOTTOM));
-        drawerPlayerView.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                actionBarLayout.presentFragment(new AudioPlayerActivity());
-                drawerLayoutContainer.closeDrawer(false);
-            }
-        });
-
         drawerLayoutContainer.setParentActionBarLayout(actionBarLayout);
         actionBarLayout.setDrawerLayoutContainer(drawerLayoutContainer);
         actionBarLayout.init(mainFragmentsStack);
@@ -366,7 +359,7 @@ public void onClick(View v) {
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.mainUserInfoChanged);
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.closeOtherAppActivities);
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.didUpdatedConnectionState);
-        NotificationCenter.getInstance().addObserver(this, NotificationCenter.spamErrorReceived);
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.needShowAlert);
         if (Build.VERSION.SDK_INT < 14) {
             NotificationCenter.getInstance().addObserver(this, NotificationCenter.screenStateChanged);
         }
@@ -458,12 +451,20 @@ public void onClick(View v) {
             drawerLayoutContainer.setAllowOpenDrawer(allowOpen, false);
         }
 
-        /*if (BuildVars.DEBUG_VERSION) {
-            ViewServer.get(this).addWindow(this);
-        }*/
-
         handleIntent(getIntent(), false, savedInstanceState != null, false);
         needLayout();
+
+        final View view = getWindow().getDecorView().getRootView();
+        view.getViewTreeObserver().addOnGlobalLayoutListener(onGlobalLayoutListener = new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                int height = view.getMeasuredHeight();
+                if (height > AndroidUtilities.dp(100) && height < AndroidUtilities.displaySize.y && height + AndroidUtilities.dp(100) > AndroidUtilities.displaySize.y) {
+                    AndroidUtilities.displaySize.y = height;
+                    FileLog.e("tmessages", "fix display size y to " + AndroidUtilities.displaySize.y);
+                }
+            }
+        });
     }
 
     private void showPasscodeActivity() {
@@ -510,6 +511,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
             Integer push_chat_id = 0;
             Integer push_enc_id = 0;
             Integer open_settings = 0;
+            long dialogId = intent != null && intent.getExtras() != null ? intent.getExtras().getLong("dialogId", 0) : 0;
             boolean showDialogsList = false;
             boolean showPlayer = false;
 
@@ -661,7 +663,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                     }
                                 }
                                 if (sendingText != null) {
-                                    if (sendingText.contains("WhatsApp")) { //who needs this sent from ...?
+                                    if (sendingText.contains("WhatsApp")) { //remove unnecessary caption 'sent from WhatsApp' from photos forwarded from WhatsApp
                                         sendingText = null;
                                     }
                                 }
@@ -731,6 +733,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                             String botUser = null;
                             String botChat = null;
                             String message = null;
+                            boolean hasUrl = false;
                             String scheme = data.getScheme();
                             if (scheme != null) {
                                 if ((scheme.equals("http") || scheme.equals("https"))) {
@@ -744,8 +747,17 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                             } else if (path.startsWith("addstickers/")) {
                                                 sticker = path.replace("addstickers/", "");
                                             } else if (path.startsWith("msg/")) {
-                                                message = data.getQueryParameter("text");
-                                                message += " " + data.getQueryParameter("url");
+                                                message = data.getQueryParameter("url");
+                                                if (message == null) {
+                                                    message = "";
+                                                }
+                                                if (data.getQueryParameter("text") != null) {
+                                                    if (message.length() > 0) {
+                                                        hasUrl = true;
+                                                        message += "\n";
+                                                    }
+                                                    message += data.getQueryParameter("text");
+                                                }
                                             } else if (path.length() >= 5) {
                                                 username = data.getLastPathSegment();
                                                 botUser = data.getQueryParameter("start");
@@ -772,13 +784,22 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                                     } else if (url.startsWith("tg:msg") || url.startsWith("tg://msg")) {
                                         url = url.replace("tg:msg", "tg://telegram.org").replace("tg://msg", "tg://telegram.org");
                                         data = Uri.parse(url);
-                                        message = data.getQueryParameter("text");
-                                        message += " " + data.getQueryParameter("url");
+                                        message = data.getQueryParameter("url");
+                                        if (message == null) {
+                                            message = "";
+                                        }
+                                        if (data.getQueryParameter("text") != null) {
+                                            if (message.length() > 0) {
+                                                hasUrl = true;
+                                                message += "\n";
+                                            }
+                                            message += data.getQueryParameter("text");
+                                        }
                                     }
                                 }
                             }
                             if (username != null || group != null || sticker != null || message != null) {
-                                runLinkRequest(username, group, sticker, botUser, botChat, message, 0);
+                                runLinkRequest(username, group, sticker, botUser, botChat, message, hasUrl, 0);
                             } else {
                                 try {
                                     Cursor cursor = getContentResolver().query(intent.getData(), null, null, null, null);
@@ -882,30 +903,39 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
                 if (!AndroidUtilities.isTablet()) {
                     NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
                 }
-                Bundle args = new Bundle();
-                args.putBoolean("onlySelect", true);
-                args.putString("selectAlertString", LocaleController.getString("SendMessagesTo", R.string.SendMessagesTo));
-                args.putString("selectAlertStringGroup", LocaleController.getString("SendMessagesToGroup", R.string.SendMessagesToGroup));
-                DialogsActivity fragment = new DialogsActivity(args);
-                fragment.setDelegate(this);
-                boolean removeLast;
-                if (AndroidUtilities.isTablet()) {
-                    removeLast = layersActionBarLayout.fragmentsStack.size() > 0 && layersActionBarLayout.fragmentsStack.get(layersActionBarLayout.fragmentsStack.size() - 1) instanceof DialogsActivity;
-                } else {
-                    removeLast = actionBarLayout.fragmentsStack.size() > 1 && actionBarLayout.fragmentsStack.get(actionBarLayout.fragmentsStack.size() - 1) instanceof DialogsActivity;
-                }
-                actionBarLayout.presentFragment(fragment, removeLast, true, true);
-                pushOpened = true;
-                if (PhotoViewer.getInstance().isVisible()) {
-                    PhotoViewer.getInstance().closePhoto(false, true);
-                }
+                if (dialogId == 0) {
+                    Bundle args = new Bundle();
+                    args.putBoolean("onlySelect", true);
+                    if (contactsToSend != null) {
+                        args.putString("selectAlertString", LocaleController.getString("SendContactTo", R.string.SendMessagesTo));
+                        args.putString("selectAlertStringGroup", LocaleController.getString("SendContactToGroup", R.string.SendContactToGroup));
+                    } else {
+                        args.putString("selectAlertString", LocaleController.getString("SendMessagesTo", R.string.SendMessagesTo));
+                        args.putString("selectAlertStringGroup", LocaleController.getString("SendMessagesToGroup", R.string.SendMessagesToGroup));
+                    }
+                    DialogsActivity fragment = new DialogsActivity(args);
+                    fragment.setDelegate(this);
+                    boolean removeLast;
+                    if (AndroidUtilities.isTablet()) {
+                        removeLast = layersActionBarLayout.fragmentsStack.size() > 0 && layersActionBarLayout.fragmentsStack.get(layersActionBarLayout.fragmentsStack.size() - 1) instanceof DialogsActivity;
+                    } else {
+                        removeLast = actionBarLayout.fragmentsStack.size() > 1 && actionBarLayout.fragmentsStack.get(actionBarLayout.fragmentsStack.size() - 1) instanceof DialogsActivity;
+                    }
+                    actionBarLayout.presentFragment(fragment, removeLast, true, true);
+                    pushOpened = true;
+                    if (PhotoViewer.getInstance().isVisible()) {
+                        PhotoViewer.getInstance().closePhoto(false, true);
+                    }
 
-                drawerLayoutContainer.setAllowOpenDrawer(false, false);
-                if (AndroidUtilities.isTablet()) {
-                    actionBarLayout.showLastFragment();
-                    rightActionBarLayout.showLastFragment();
+                    drawerLayoutContainer.setAllowOpenDrawer(false, false);
+                    if (AndroidUtilities.isTablet()) {
+                        actionBarLayout.showLastFragment();
+                        rightActionBarLayout.showLastFragment();
+                    } else {
+                        drawerLayoutContainer.setAllowOpenDrawer(true, false);
+                    }
                 } else {
-                    drawerLayoutContainer.setAllowOpenDrawer(true, false);
+                    didSelectDialog(null, dialogId, false);
                 }
             } else if (open_settings != 0) {
                 actionBarLayout.presentFragment(new SettingsActivity(), false, true, true);
@@ -956,7 +986,7 @@ private boolean handleIntent(Intent intent, boolean isNew, boolean restore, bool
         return false;
     }
 
-    private void runLinkRequest(final String username, final String group, final String sticker, final String botUser, final String botChat, final String message, final int state) {
+    private void runLinkRequest(final String username, final String group, final String sticker, final String botUser, final String botChat, final String message, final boolean hasUrl, final int state) {
         final ProgressDialog progressDialog = new ProgressDialog(this);
         progressDialog.setMessage(LocaleController.getString("Loading", R.string.Loading));
         progressDialog.setCanceledOnTouchOutside(false);
@@ -986,7 +1016,7 @@ public void run() {
 
                                     if (botChat != null) {
                                         final TLRPC.User user = !res.users.isEmpty() ? res.users.get(0) : null;
-                                        if (user == null || (user.flags & TLRPC.USER_FLAG_BOT) != 0 && (user.flags & TLRPC.USER_FLAG_BOT_CANT_JOIN_GROUP) != 0) {
+                                        if (user == null || user.bot && user.bot_nochats) {
                                             try {
                                                 Toast.makeText(LaunchActivity.this, LocaleController.getString("BotCantJoinGroups", R.string.BotCantJoinGroups), Toast.LENGTH_SHORT).show();
                                             } catch (Exception e) {
@@ -1018,7 +1048,7 @@ public void didSelectDialog(DialogsActivity fragment, long did, boolean param) {
                                         } else {
                                             args.putInt("user_id", res.users.get(0).id);
                                         }
-                                        if (botUser != null) {
+                                        if (botUser != null && res.users.size() > 0 && res.users.get(0).bot) {
                                             args.putString("botUser", botUser);
                                         }
                                         ChatActivity fragment = new ChatActivity(args);
@@ -1068,7 +1098,7 @@ public void run() {
                                         } else {
                                             AlertDialog.Builder builder = new AlertDialog.Builder(LaunchActivity.this);
                                             builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-                                            if ((invite.flags & 1) != 0 || ChatObject.isChannel(invite.chat)) {
+                                            if (!invite.megagroup && invite.channel || ChatObject.isChannel(invite.chat) && !invite.chat.megagroup) {
                                                 builder.setMessage(LocaleController.formatString("ChannelJoinTo", R.string.ChannelJoinTo, invite.chat != null ? invite.chat.title : invite.title));
                                             } else {
                                                 builder.setMessage(LocaleController.formatString("JoinToGroup", R.string.JoinToGroup, invite.chat != null ? invite.chat.title : invite.title));
@@ -1076,7 +1106,7 @@ public void run() {
                                             builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                                                 @Override
                                                 public void onClick(DialogInterface dialogInterface, int i) {
-                                                    runLinkRequest(username, group, sticker, botUser, botChat, message, 1);
+                                                    runLinkRequest(username, group, sticker, botUser, botChat, message, hasUrl, 1);
                                                 }
                                             });
                                             builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
@@ -1085,7 +1115,11 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                     } else {
                                         AlertDialog.Builder builder = new AlertDialog.Builder(LaunchActivity.this);
                                         builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-                                        builder.setMessage(LocaleController.getString("JoinToGroupErrorNotExist", R.string.JoinToGroupErrorNotExist));
+                                        if (error.text.startsWith("FLOOD_WAIT")) {
+                                            builder.setMessage(LocaleController.getString("FloodWait", R.string.FloodWait));
+                                        } else {
+                                            builder.setMessage(LocaleController.getString("JoinToGroupErrorNotExist", R.string.JoinToGroupErrorNotExist));
+                                        }
                                         builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
                                         showAlertDialog(builder);
                                     }
@@ -1093,7 +1127,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                             }
                         });
                     }
-                });
+                }, ConnectionsManager.RequestFlagFailOnServerErrors);
             } else if (state == 1) {
                 TLRPC.TL_messages_importChatInvite req = new TLRPC.TL_messages_importChatInvite();
                 req.hash = group;
@@ -1117,21 +1151,24 @@ public void run() {
                                         if (actionBarLayout != null) {
                                             TLRPC.Updates updates = (TLRPC.Updates) response;
                                             if (!updates.chats.isEmpty()) {
+                                                TLRPC.Chat chat = updates.chats.get(0);
+                                                chat.left = false;
+                                                chat.kicked = false;
                                                 MessagesController.getInstance().putUsers(updates.users, false);
                                                 MessagesController.getInstance().putChats(updates.chats, false);
                                                 Bundle args = new Bundle();
-                                                int chat_id = updates.chats.get(0).id;
-                                                args.putInt("chat_id", chat_id);
+                                                args.putInt("chat_id", chat.id);
                                                 ChatActivity fragment = new ChatActivity(args);
                                                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
                                                 actionBarLayout.presentFragment(fragment, false, true, true);
-                                                MessagesController.getInstance().generateJoinMessage(chat_id);
                                             }
                                         }
                                     } else {
                                         AlertDialog.Builder builder = new AlertDialog.Builder(LaunchActivity.this);
                                         builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-                                        if (error.text.equals("USERS_TOO_MUCH")) {
+                                        if (error.text.startsWith("FLOOD_WAIT")) {
+                                            builder.setMessage(LocaleController.getString("FloodWait", R.string.FloodWait));
+                                        } else if (error.text.equals("USERS_TOO_MUCH")) {
                                             builder.setMessage(LocaleController.getString("JoinToGroupErrorFull", R.string.JoinToGroupErrorFull));
                                         } else {
                                             builder.setMessage(LocaleController.getString("JoinToGroupErrorNotExist", R.string.JoinToGroupErrorNotExist));
@@ -1143,7 +1180,7 @@ public void run() {
                             }
                         });
                     }
-                });
+                }, ConnectionsManager.RequestFlagFailOnServerErrors);
             }
         } else if (sticker != null) {
             if (!mainFragmentsStack.isEmpty()) {
@@ -1166,6 +1203,7 @@ public void didSelectDialog(DialogsActivity fragment, long did, boolean param) {
                     editor.commit();
                     Bundle args = new Bundle();
                     args.putBoolean("scrollToTopOnResume", true);
+                    args.putBoolean("hasUrl", hasUrl);
                     int lower_part = (int) did;
                     int high_id = (int) (did >> 32);
                     if (lower_part != 0) {
@@ -1184,7 +1222,7 @@ public void didSelectDialog(DialogsActivity fragment, long did, boolean param) {
                     actionBarLayout.presentFragment(new ChatActivity(args), true, false, true);
                 }
             });
-            presentFragment(fragment);
+            presentFragment(fragment, false, true);
         }
 
         if (requestId != 0) {
@@ -1236,7 +1274,7 @@ protected void onNewIntent(Intent intent) {
     }
 
     @Override
-    public void didSelectDialog(DialogsActivity messageFragment, long dialog_id, boolean param) {
+    public void didSelectDialog(DialogsActivity dialogsFragment, long dialog_id, boolean param) {
         if (dialog_id != 0) {
             int lower_part = (int)dialog_id;
             int high_id = (int)(dialog_id >> 32);
@@ -1265,24 +1303,21 @@ public void didSelectDialog(DialogsActivity messageFragment, long dialog_id, boo
                 if(android.os.Build.VERSION.SDK_INT >= 16) {
                     if (AndroidUtilities.isTablet()) {
                         actionBarLayout.presentFragment(fragment, false, true, true);
-                    }
-
-                    if (!AndroidUtilities.isTablet()) {
+                    } else {
                         actionBarLayout.addFragmentToStack(fragment, actionBarLayout.fragmentsStack.size() - 1);
                     }
 
-                    if (!fragment.openVideoEditor(videoPath, true, false)) {
+                    if (!fragment.openVideoEditor(videoPath, dialogsFragment != null, false) && dialogsFragment != null) {
                         if (!AndroidUtilities.isTablet()) {
-                            messageFragment.finishFragment(true);
+                            dialogsFragment.finishFragment(true);
                         }
                     }
                 } else {
-                    actionBarLayout.presentFragment(fragment, true);
+                    actionBarLayout.presentFragment(fragment, dialogsFragment != null, dialogsFragment == null, true);
                     SendMessagesHelper.prepareSendingVideo(videoPath, 0, 0, 0, 0, null, dialog_id, null, true);
                 }
             } else {
-
-                actionBarLayout.presentFragment(fragment, true);
+                actionBarLayout.presentFragment(fragment, dialogsFragment != null, dialogsFragment == null, true);
 
                 if (sendingText != null) {
                     SendMessagesHelper.prepareSendingText(sendingText, dialog_id, true);
@@ -1323,7 +1358,7 @@ private void onFinish() {
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.mainUserInfoChanged);
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.closeOtherAppActivities);
         NotificationCenter.getInstance().removeObserver(this, NotificationCenter.didUpdatedConnectionState);
-        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.spamErrorReceived);
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.needShowAlert);
         if (Build.VERSION.SDK_INT < 14) {
             NotificationCenter.getInstance().removeObserver(this, NotificationCenter.screenStateChanged);
         }
@@ -1339,13 +1374,13 @@ public boolean presentFragment(final BaseFragment fragment, final boolean remove
 
     public void needLayout() {
         if (AndroidUtilities.isTablet()) {
-
             RelativeLayout.LayoutParams relativeLayoutParams = (RelativeLayout.LayoutParams)layersActionBarLayout.getLayoutParams();
             relativeLayoutParams.leftMargin = (AndroidUtilities.displaySize.x - relativeLayoutParams.width) / 2;
             int y = (Build.VERSION.SDK_INT >= 21 ? AndroidUtilities.statusBarHeight : 0);
             relativeLayoutParams.topMargin = y + (AndroidUtilities.displaySize.y - relativeLayoutParams.height - y) / 2;
             layersActionBarLayout.setLayoutParams(relativeLayoutParams);
 
+
             if (!AndroidUtilities.isSmallTablet() || getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
                 tabletFullSize = false;
                 int leftWidth = AndroidUtilities.displaySize.x / 100 * 35;
@@ -1398,7 +1433,8 @@ public void needLayout() {
                     BaseFragment chatFragment = rightActionBarLayout.fragmentsStack.get(0);
                     chatFragment.onPause();
                     rightActionBarLayout.fragmentsStack.remove(0);
-                    actionBarLayout.addFragmentToStack(chatFragment);
+                    actionBarLayout.fragmentsStack.add(chatFragment);
+                    //actionBarLayout.addFragmentToStack(chatFragment);
                     if (passcodeView.getVisibility() != View.VISIBLE) {
                         actionBarLayout.showLastFragment();
                     }
@@ -1408,24 +1444,25 @@ public void needLayout() {
     }
 
     public void fixLayout() {
-        if (AndroidUtilities.isTablet()) {
-            if (actionBarLayout == null) {
-                return;
-            }
-            actionBarLayout.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
-                @Override
-                public void onGlobalLayout() {
-                    needLayout();
-                    if (actionBarLayout != null) {
-                        if (Build.VERSION.SDK_INT < 16) {
-                            actionBarLayout.getViewTreeObserver().removeGlobalOnLayoutListener(this);
-                        } else {
-                            actionBarLayout.getViewTreeObserver().removeOnGlobalLayoutListener(this);
-                        }
+        if (!AndroidUtilities.isTablet()) {
+            return;
+        }
+        if (actionBarLayout == null) {
+            return;
+        }
+        actionBarLayout.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                needLayout();
+                if (actionBarLayout != null) {
+                    if (Build.VERSION.SDK_INT < 16) {
+                        actionBarLayout.getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                    } else {
+                        actionBarLayout.getViewTreeObserver().removeOnGlobalLayoutListener(this);
                     }
                 }
-            });
-        }
+            }
+        });
     }
 
     @Override
@@ -1451,16 +1488,73 @@ protected void onActivityResult(int requestCode, int resultCode, Intent data) {
         }
     }
 
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        if (requestCode == 3 || requestCode == 4 || requestCode == 5) {
+            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+                if (requestCode == 4) {
+                    ImageLoader.getInstance().createMediaPaths();
+                } else if (requestCode == 5) {
+                    ContactsController.getInstance().readContacts();
+                }
+                return;
+            }
+            AlertDialog.Builder builder = new AlertDialog.Builder(this);
+            builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+            if (requestCode == 3) {
+                builder.setMessage(LocaleController.getString("PermissionNoAudio", R.string.PermissionNoAudio));
+            } else if (requestCode == 4) {
+                builder.setMessage(LocaleController.getString("PermissionStorage", R.string.PermissionStorage));
+            } else if (requestCode == 5) {
+                builder.setMessage(LocaleController.getString("PermissionContacts", R.string.PermissionContacts));
+            }
+            builder.setNegativeButton(LocaleController.getString("PermissionOpenSettings", R.string.PermissionOpenSettings), new DialogInterface.OnClickListener() {
+                @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+                @Override
+                public void onClick(DialogInterface dialog, int which) {
+                    try {
+                        Intent intent = new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+                        intent.setData(Uri.parse("package:" + ApplicationLoader.applicationContext.getPackageName()));
+                        startActivity(intent);
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                }
+            });
+            builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
+            builder.show();
+            return;
+        }
+        if (actionBarLayout.fragmentsStack.size() != 0) {
+            BaseFragment fragment = actionBarLayout.fragmentsStack.get(actionBarLayout.fragmentsStack.size() - 1);
+            fragment.onRequestPermissionsResultFragment(requestCode, permissions, grantResults);
+        }
+        if (AndroidUtilities.isTablet()) {
+            if (rightActionBarLayout.fragmentsStack.size() != 0) {
+                BaseFragment fragment = rightActionBarLayout.fragmentsStack.get(rightActionBarLayout.fragmentsStack.size() - 1);
+                fragment.onRequestPermissionsResultFragment(requestCode, permissions, grantResults);
+            }
+            if (layersActionBarLayout.fragmentsStack.size() != 0) {
+                BaseFragment fragment = layersActionBarLayout.fragmentsStack.get(layersActionBarLayout.fragmentsStack.size() - 1);
+                fragment.onRequestPermissionsResultFragment(requestCode, permissions, grantResults);
+            }
+        }
+    }
+
     @Override
     protected void onPause() {
         super.onPause();
+        ApplicationLoader.mainInterfacePaused = true;
         onPasscodePause();
         actionBarLayout.onPause();
         if (AndroidUtilities.isTablet()) {
             rightActionBarLayout.onPause();
             layersActionBarLayout.onPause();
         }
-        ApplicationLoader.mainInterfacePaused = true;
+        if (passcodeView != null) {
+            passcodeView.onPause();
+        }
         ConnectionsManager.getInstance().setAppPaused(true, false);
         AndroidUtilities.unregisterUpdates();
     }
@@ -1478,6 +1572,18 @@ protected void onDestroy() {
         } catch (Exception e) {
             FileLog.e("tmessages", e);
         }
+        try {
+            if (onGlobalLayoutListener != null) {
+                final View view = getWindow().getDecorView().getRootView();
+                if (Build.VERSION.SDK_INT < 16) {
+                    view.getViewTreeObserver().removeGlobalOnLayoutListener(onGlobalLayoutListener);
+                } else {
+                    view.getViewTreeObserver().removeOnGlobalLayoutListener(onGlobalLayoutListener);
+                }
+            }
+        } catch (Exception e) {
+            FileLog.e("tmessages", e);
+        }
         super.onDestroy();
         onFinish();
     }
@@ -1485,6 +1591,7 @@ protected void onDestroy() {
     @Override
     protected void onResume() {
         super.onResume();
+        ApplicationLoader.mainInterfacePaused = false;
         onPasscodeResume();
         if (passcodeView.getVisibility() != View.VISIBLE) {
             actionBarLayout.onResume();
@@ -1497,7 +1604,6 @@ protected void onResume() {
         }
         AndroidUtilities.checkForCrashes(this);
         AndroidUtilities.checkForUpdates(this);
-        ApplicationLoader.mainInterfacePaused = false;
         ConnectionsManager.getInstance().setAppPaused(false, false);
         updateCurrentConnectionState();
         if (PhotoViewer.getInstance().isVisible()) {
@@ -1559,27 +1665,31 @@ public void didReceivedNotification(int id, Object... args) {
                     onPasscodeResume();
                 }
             }
-        } else if (id == NotificationCenter.spamErrorReceived) {
+        } else if (id == NotificationCenter.needShowAlert) {
             final Integer reason = (Integer) args[0];
             AlertDialog.Builder builder = new AlertDialog.Builder(this);
             builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
             builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
-            builder.setNegativeButton(LocaleController.getString("MoreInfo", R.string.MoreInfo), new DialogInterface.OnClickListener() {
-                @Override
-                public void onClick(DialogInterface dialogInterface, int i) {
-                    try {
-                        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://telegram.org/faq#can-39t-send-messages-to-non-contacts"));
-                        intent.putExtra(Browser.EXTRA_APPLICATION_ID, getPackageName());
-                        startActivity(intent);
-                    } catch (Exception e) {
-                        FileLog.e("tmessages", e);
+            if (reason != 2) {
+                builder.setNegativeButton(LocaleController.getString("MoreInfo", R.string.MoreInfo), new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialogInterface, int i) {
+                        try {
+                            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(LocaleController.getString("NobodyLikesSpamUrl", R.string.NobodyLikesSpamUrl)));
+                            intent.putExtra(Browser.EXTRA_APPLICATION_ID, getPackageName());
+                            startActivity(intent);
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
                     }
-                }
-            });
+                });
+            }
             if (reason == 0) {
                 builder.setMessage(LocaleController.getString("NobodyLikesSpam1", R.string.NobodyLikesSpam1));
             } else if (reason == 1) {
                 builder.setMessage(LocaleController.getString("NobodyLikesSpam2", R.string.NobodyLikesSpam2));
+            } else if (reason == 2) {
+                builder.setMessage((String) args[1]);
             }
             if (!mainFragmentsStack.isEmpty()) {
                 mainFragmentsStack.get(mainFragmentsStack.size() - 1).showDialog(builder.create());
@@ -1734,6 +1844,9 @@ public void onLowMemory() {
     @Override
     public void onActionModeStarted(ActionMode mode) {
         super.onActionModeStarted(mode);
+        if (Build.VERSION.SDK_INT >= 23 && mode.getType() == ActionMode.TYPE_FLOATING) {
+            return;
+        }
         actionBarLayout.onActionModeStarted(mode);
         if (AndroidUtilities.isTablet()) {
             rightActionBarLayout.onActionModeStarted(mode);
@@ -1744,6 +1857,9 @@ public void onActionModeStarted(ActionMode mode) {
     @Override
     public void onActionModeFinished(ActionMode mode) {
         super.onActionModeFinished(mode);
+        if (Build.VERSION.SDK_INT >= 23 && mode.getType() == ActionMode.TYPE_FLOATING) {
+            return;
+        }
         actionBarLayout.onActionModeFinished(mode);
         if (AndroidUtilities.isTablet()) {
             rightActionBarLayout.onActionModeFinished(mode);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LocationActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LocationActivity.java
index c8a8efc75..d3cb22789 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LocationActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LocationActivity.java
@@ -1,18 +1,24 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
 
+import android.Manifest;
 import android.animation.AnimatorSet;
 import android.animation.ObjectAnimator;
 import android.animation.StateListAnimator;
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.AlertDialog;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.graphics.Outline;
 import android.location.Location;
 import android.location.LocationManager;
@@ -90,6 +96,8 @@
 
     private AnimatorSet animatorSet;
 
+    private boolean checkPermission = true;
+
     private boolean searching;
     private boolean searchWas;
 
@@ -117,11 +125,6 @@
         void didSelectLocation(TLRPC.MessageMedia location);
     }
 
-    @Override
-    public boolean needAddActionBar() {
-        return messageObject != null;
-    }
-
     @Override
     public boolean onFragmentCreate() {
         super.onFragmentCreate();
@@ -156,6 +159,7 @@ public View createView(Context context) {
         if (AndroidUtilities.isTablet()) {
             actionBar.setOccupyStatusBar(false);
         }
+        actionBar.setAddToContainer(messageObject != null);
 
         actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
             @Override
@@ -293,7 +297,7 @@ public void onClick(View view) {
                     if (userLocation != null) {
                         LatLng latLng = new LatLng(userLocation.getLatitude(), userLocation.getLongitude());
                         if (googleMap != null) {
-                            CameraUpdate position = CameraUpdateFactory.newLatLngZoom(latLng, googleMap.getMaxZoomLevel() - 8);
+                            CameraUpdate position = CameraUpdateFactory.newLatLngZoom(latLng, googleMap.getMaxZoomLevel() - 4);
                             googleMap.animateCamera(position);
                         }
                     }
@@ -333,7 +337,7 @@ public void onClick(View view) {
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
                 }
-                CameraUpdate position = CameraUpdateFactory.newLatLngZoom(latLng, googleMap.getMaxZoomLevel() - 8);
+                CameraUpdate position = CameraUpdateFactory.newLatLngZoom(latLng, googleMap.getMaxZoomLevel() - 4);
                 googleMap.moveCamera(position);
             }
 
@@ -372,8 +376,17 @@ public void onClick(View v) {
             locationButton.setOnClickListener(new View.OnClickListener() {
                 @Override
                 public void onClick(View v) {
+                    if (Build.VERSION.SDK_INT >= 23) {
+                        Activity activity = getParentActivity();
+                        if (activity != null) {
+                            if (activity.checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
+                                showPermissionAlert();
+                                return;
+                            }
+                        }
+                    }
                     if (myLocation != null && googleMap != null) {
-                        googleMap.animateCamera(CameraUpdateFactory.newLatLngZoom(new LatLng(myLocation.getLatitude(), myLocation.getLongitude()), googleMap.getMaxZoomLevel() - 8));
+                        googleMap.animateCamera(CameraUpdateFactory.newLatLngZoom(new LatLng(myLocation.getLatitude(), myLocation.getLongitude()), googleMap.getMaxZoomLevel() - 4));
                     }
                 }
             });
@@ -516,6 +529,15 @@ public boolean onInterceptTouchEvent(MotionEvent ev) {
             locationButton.setOnClickListener(new View.OnClickListener() {
                 @Override
                 public void onClick(View v) {
+                    if (Build.VERSION.SDK_INT >= 23) {
+                        Activity activity = getParentActivity();
+                        if (activity != null) {
+                            if (activity.checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
+                                showPermissionAlert();
+                                return;
+                            }
+                        }
+                    }
                     if (myLocation != null && googleMap != null) {
                         if (Build.VERSION.SDK_INT >= 11) {
                             AnimatorSet animatorSet = new AnimatorSet();
@@ -614,21 +636,50 @@ public void onMyLocationChange(Location location) {
         return fragmentView;
     }
 
+    private void showPermissionAlert() {
+        if (getParentActivity() == null) {
+            return;
+        }
+        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+        builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+        builder.setMessage(LocaleController.getString("PermissionNoLocation", R.string.PermissionNoLocation));
+        builder.setNegativeButton(LocaleController.getString("PermissionOpenSettings", R.string.PermissionOpenSettings), new DialogInterface.OnClickListener() {
+            @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                if (getParentActivity() == null) {
+                    return;
+                }
+                try {
+                    Intent intent = new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+                    intent.setData(Uri.parse("package:" + ApplicationLoader.applicationContext.getPackageName()));
+                    getParentActivity().startActivity(intent);
+                } catch (Exception e) {
+                    FileLog.e("tmessages", e);
+                }
+            }
+        });
+        builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
+        showDialog(builder.create());
+    }
+
     @Override
-    public void onOpenAnimationEnd() {
-        try {
-            if (mapView.getParent() instanceof ViewGroup) {
-                ViewGroup viewGroup = (ViewGroup) mapView.getParent();
-                viewGroup.removeView(mapView);
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen) {
+            try {
+                if (mapView.getParent() instanceof ViewGroup) {
+                    ViewGroup viewGroup = (ViewGroup) mapView.getParent();
+                    viewGroup.removeView(mapView);
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+            if (mapViewClip != null) {
+                mapViewClip.addView(mapView, 0, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, overScrollHeight + AndroidUtilities.dp(10), Gravity.TOP | Gravity.LEFT));
+                updateClipView(listView.getFirstVisiblePosition());
+            } else {
+                ((FrameLayout) fragmentView).addView(mapView, 0, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT));
             }
-        } catch (Exception e) {
-            FileLog.e("tmessages", e);
-        }
-        if (mapViewClip != null) {
-            mapViewClip.addView(mapView, 0, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, overScrollHeight + AndroidUtilities.dp(10), Gravity.TOP | Gravity.LEFT));
-            updateClipView(listView.getFirstVisiblePosition());
-        } else {
-            ((FrameLayout) fragmentView).addView(mapView, 0, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT));
         }
     }
 
@@ -820,7 +871,7 @@ private void positionMarker(Location location) {
                     googleMap.animateCamera(position);
                 } else {
                     firstWas = true;
-                    CameraUpdate position = CameraUpdateFactory.newLatLngZoom(latLng, googleMap.getMaxZoomLevel() - 8);
+                    CameraUpdate position = CameraUpdateFactory.newLatLngZoom(latLng, googleMap.getMaxZoomLevel() - 4);
                     googleMap.moveCamera(position);
                 }
             }
@@ -864,6 +915,15 @@ public void onResume() {
         }
         updateUserData();
         fixLayoutInternal(true);
+        if (checkPermission && Build.VERSION.SDK_INT >= 23) {
+            Activity activity = getParentActivity();
+            if (activity != null) {
+                checkPermission = false;
+                if (activity.checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
+                    activity.requestPermissions(new String[]{Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION}, 2);
+                }
+            }
+        }
     }
 
     @Override
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/LoginActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/LoginActivity.java
index e66f29f5b..475e0c09b 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/LoginActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/LoginActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -64,6 +64,7 @@
 import org.telegram.ui.ActionBar.ActionBar;
 import org.telegram.ui.ActionBar.ActionBarMenu;
 import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Components.HintEditText;
 import org.telegram.ui.Components.LayoutHelper;
 import org.telegram.ui.Components.SlideView;
 import org.telegram.ui.Components.TypefaceSpan;
@@ -129,12 +130,7 @@ public void onItemClick(int id) {
         scrollView.setFillViewport(true);
 
         FrameLayout frameLayout = new FrameLayout(context);
-        scrollView.addView(frameLayout);
-        ScrollView.LayoutParams layoutParams = (ScrollView.LayoutParams) frameLayout.getLayoutParams();
-        layoutParams.width = ScrollView.LayoutParams.MATCH_PARENT;
-        layoutParams.height = ScrollView.LayoutParams.WRAP_CONTENT;
-        layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
-        frameLayout.setLayoutParams(layoutParams);
+        scrollView.addView(frameLayout, LayoutHelper.createScroll(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | Gravity.LEFT));
 
         views[0] = new PhoneView(context);
         views[1] = new LoginActivitySmsView(context);
@@ -144,15 +140,7 @@ public void onItemClick(int id) {
 
         for (int a = 0; a < 5; a++) {
             views[a].setVisibility(a == 0 ? View.VISIBLE : View.GONE);
-            frameLayout.addView(views[a]);
-            FrameLayout.LayoutParams layoutParams1 = (FrameLayout.LayoutParams) views[a].getLayoutParams();
-            layoutParams1.width = LayoutHelper.MATCH_PARENT;
-            layoutParams1.height = a == 0 ? LayoutHelper.WRAP_CONTENT : LayoutHelper.MATCH_PARENT;
-            layoutParams1.leftMargin = AndroidUtilities.dp(AndroidUtilities.isTablet() ? 26 : 18);
-            layoutParams1.rightMargin = AndroidUtilities.dp(AndroidUtilities.isTablet() ? 26 : 18);
-            layoutParams1.topMargin = AndroidUtilities.dp(30);
-            layoutParams1.gravity = Gravity.TOP | Gravity.LEFT;
-            views[a].setLayoutParams(layoutParams1);
+            frameLayout.addView(views[a], LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, a == 0 ? LayoutHelper.WRAP_CONTENT : LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, AndroidUtilities.isTablet() ? 26 : 18, 30, AndroidUtilities.isTablet() ? 26 : 18, 0));
         }
 
         Bundle savedInstanceState = loadCurrentState();
@@ -396,7 +384,7 @@ public void needFinishActivity() {
     public class PhoneView extends SlideView implements AdapterView.OnItemSelectedListener {
 
         private EditText codeField;
-        private EditText phoneField;
+        private HintEditText phoneField;
         private TextView countryButton;
 
         private int countryState = 0;
@@ -404,13 +392,14 @@ public void needFinishActivity() {
         private ArrayList<String> countriesArray = new ArrayList<>();
         private HashMap<String, String> countriesMap = new HashMap<>();
         private HashMap<String, String> codesMap = new HashMap<>();
+        private HashMap<String, String> phoneFormatMap = new HashMap<>();
 
         private boolean ignoreSelection = false;
         private boolean ignoreOnTextChange = false;
         private boolean ignoreOnPhoneChange = false;
         private boolean nextPressed = false;
 
-        public PhoneView(Context context) {
+        public PhoneView(final Context context) {
             super(context);
 
             setOrientation(VERTICAL);
@@ -424,12 +413,7 @@ public PhoneView(Context context) {
             countryButton.setEllipsize(TextUtils.TruncateAt.END);
             countryButton.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_HORIZONTAL);
             countryButton.setBackgroundResource(R.drawable.spinner_states);
-            addView(countryButton);
-            LayoutParams layoutParams = (LayoutParams) countryButton.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.bottomMargin = AndroidUtilities.dp(14);
-            countryButton.setLayoutParams(layoutParams);
+            addView(countryButton, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 0, 0, 0, 14));
             countryButton.setOnClickListener(new OnClickListener() {
                 @Override
                 public void onClick(View view) {
@@ -438,7 +422,14 @@ public void onClick(View view) {
                         @Override
                         public void didSelectCountry(String name) {
                             selectCountry(name);
+                            AndroidUtilities.runOnUIThread(new Runnable() {
+                                @Override
+                                public void run() {
+                                    AndroidUtilities.showKeyboard(phoneField);
+                                }
+                            }, 300);
                             phoneField.requestFocus();
+                            phoneField.setSelection(phoneField.length());
                         }
                     });
                     presentFragment(fragment);
@@ -448,33 +439,17 @@ public void didSelectCountry(String name) {
             View view = new View(context);
             view.setPadding(AndroidUtilities.dp(12), 0, AndroidUtilities.dp(12), 0);
             view.setBackgroundColor(0xffdbdbdb);
-            addView(view);
-            layoutParams = (LayoutParams) view.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = 1;
-            layoutParams.topMargin = AndroidUtilities.dp(-17.5f);
-            layoutParams.leftMargin = AndroidUtilities.dp(4);
-            layoutParams.rightMargin = AndroidUtilities.dp(4);
-            view.setLayoutParams(layoutParams);
+            addView(view, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 1, 4, -17.5f, 4, 0));
 
             LinearLayout linearLayout = new LinearLayout(context);
             linearLayout.setOrientation(HORIZONTAL);
-            addView(linearLayout);
-            layoutParams = (LayoutParams) linearLayout.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.topMargin = AndroidUtilities.dp(20);
-            linearLayout.setLayoutParams(layoutParams);
+            addView(linearLayout, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.WRAP_CONTENT, 0, 20, 0, 0));
 
             TextView textView = new TextView(context);
             textView.setText("+");
             textView.setTextColor(0xff212121);
             textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
-            linearLayout.addView(textView);
-            layoutParams = (LayoutParams) textView.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            textView.setLayoutParams(layoutParams);
+            linearLayout.addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT));
 
             codeField = new EditText(context);
             codeField.setInputType(InputType.TYPE_CLASS_PHONE);
@@ -486,15 +461,9 @@ public void didSelectCountry(String name) {
             codeField.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);
             codeField.setImeOptions(EditorInfo.IME_ACTION_NEXT | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
             InputFilter[] inputFilters = new InputFilter[1];
-            inputFilters[0] = new InputFilter.LengthFilter(4);
+            inputFilters[0] = new InputFilter.LengthFilter(5);
             codeField.setFilters(inputFilters);
-            linearLayout.addView(codeField);
-            layoutParams = (LayoutParams) codeField.getLayoutParams();
-            layoutParams.width = AndroidUtilities.dp(55);
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.rightMargin = AndroidUtilities.dp(16);
-            layoutParams.leftMargin = AndroidUtilities.dp(-9);
-            codeField.setLayoutParams(layoutParams);
+            linearLayout.addView(codeField, LayoutHelper.createLinear(55, 36, -9, 0, 16, 0));
             codeField.addTextChangedListener(new TextWatcher() {
                 @Override
                 public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
@@ -517,26 +486,57 @@ public void afterTextChanged(Editable editable) {
                     codeField.setText(text);
                     if (text.length() == 0) {
                         countryButton.setText(LocaleController.getString("ChooseCountry", R.string.ChooseCountry));
+                        phoneField.setHintText(null);
                         countryState = 1;
                     } else {
-                        String country = codesMap.get(text);
+                        String country;
+                        boolean ok = false;
+                        String textToSet = null;
+                        if (text.length() > 4) {
+                            ignoreOnTextChange = true;
+                            for (int a = 4; a >= 1; a--) {
+                                String sub = text.substring(0, a);
+                                country = codesMap.get(sub);
+                                if (country != null) {
+                                    ok = true;
+                                    textToSet = text.substring(a, text.length()) + phoneField.getText().toString();
+                                    codeField.setText(text = sub);
+                                    break;
+                                }
+                            }
+                            if (!ok) {
+                                ignoreOnTextChange = true;
+                                textToSet = text.substring(1, text.length()) + phoneField.getText().toString();
+                                codeField.setText(text = text.substring(0, 1));
+                            }
+                        }
+                        country = codesMap.get(text);
                         if (country != null) {
                             int index = countriesArray.indexOf(country);
                             if (index != -1) {
                                 ignoreSelection = true;
                                 countryButton.setText(countriesArray.get(index));
-
-                                updatePhoneField();
+                                String hint = phoneFormatMap.get(text);
+                                phoneField.setHintText(hint != null ? hint.replace('X', '–') : null);
                                 countryState = 0;
                             } else {
                                 countryButton.setText(LocaleController.getString("WrongCountry", R.string.WrongCountry));
+                                phoneField.setHintText(null);
                                 countryState = 2;
                             }
                         } else {
                             countryButton.setText(LocaleController.getString("WrongCountry", R.string.WrongCountry));
+                            phoneField.setHintText(null);
                             countryState = 2;
                         }
-                        codeField.setSelection(codeField.getText().length());
+                        if (!ok) {
+                            codeField.setSelection(codeField.getText().length());
+                        }
+                        if (textToSet != null) {
+                            phoneField.requestFocus();
+                            phoneField.setText(textToSet);
+                            phoneField.setSelection(phoneField.length());
+                        }
                     }
                 }
             });
@@ -545,13 +545,14 @@ public void afterTextChanged(Editable editable) {
                 public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
                     if (i == EditorInfo.IME_ACTION_NEXT) {
                         phoneField.requestFocus();
+                        phoneField.setSelection(phoneField.length());
                         return true;
                     }
                     return false;
                 }
             });
 
-            phoneField = new EditText(context);
+            phoneField = new HintEditText(context);
             phoneField.setInputType(InputType.TYPE_CLASS_PHONE);
             phoneField.setTextColor(0xff212121);
             phoneField.setHintTextColor(0xff979797);
@@ -561,42 +562,25 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             phoneField.setMaxLines(1);
             phoneField.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);
             phoneField.setImeOptions(EditorInfo.IME_ACTION_NEXT | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
-            linearLayout.addView(phoneField);
-            layoutParams = (LayoutParams) phoneField.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            phoneField.setLayoutParams(layoutParams);
+            linearLayout.addView(phoneField, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 36));
             phoneField.addTextChangedListener(new TextWatcher() {
+
+                private int characterAction = -1;
+                private int actionPosition;
+
                 @Override
                 public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-                    if (ignoreOnPhoneChange) {
-                        return;
-                    }
-                    if (count == 1 && after == 0 && s.length() > 1) {
-                        String phoneChars = "0123456789";
-                        String str = s.toString();
-                        String substr = str.substring(start, start + 1);
-                        if (!phoneChars.contains(substr)) {
-                            ignoreOnPhoneChange = true;
-                            StringBuilder builder = new StringBuilder(str);
-                            int toDelete = 0;
-                            for (int a = start; a >= 0; a--) {
-                                substr = str.substring(a, a + 1);
-                                if (phoneChars.contains(substr)) {
-                                    break;
-                                }
-                                toDelete++;
-                            }
-                            builder.delete(Math.max(0, start - toDelete), start + 1);
-                            str = builder.toString();
-                            if (PhoneFormat.strip(str).length() == 0) {
-                                phoneField.setText("");
-                            } else {
-                                phoneField.setText(str);
-                                updatePhoneField();
-                            }
-                            ignoreOnPhoneChange = false;
+                    if (count == 0 && after == 1) {
+                        characterAction = 1;
+                    } else if (count == 1 && after == 0) {
+                        if (s.charAt(start) == ' ' && start > 0) {
+                            characterAction = 3;
+                            actionPosition = start - 1;
+                        } else {
+                            characterAction = 2;
                         }
+                    } else {
+                        characterAction = -1;
                     }
                 }
 
@@ -610,7 +594,47 @@ public void afterTextChanged(Editable s) {
                     if (ignoreOnPhoneChange) {
                         return;
                     }
-                    updatePhoneField();
+                    int start = phoneField.getSelectionStart();
+                    String phoneChars = "0123456789";
+                    String str = phoneField.getText().toString();
+                    if (characterAction == 3) {
+                        str = str.substring(0, actionPosition) + str.substring(actionPosition + 1, str.length());
+                        start--;
+                    }
+                    StringBuilder builder = new StringBuilder(str.length());
+                    for (int a = 0; a < str.length(); a++) {
+                        String ch = str.substring(a, a + 1);
+                        if (phoneChars.contains(ch)) {
+                            builder.append(ch);
+                        }
+                    }
+                    ignoreOnPhoneChange = true;
+                    String hint = phoneField.getHintText();
+                    if (hint != null) {
+                        for (int a = 0; a < builder.length(); a++) {
+                            if (a < hint.length()) {
+                                if (hint.charAt(a) == ' ') {
+                                    builder.insert(a, ' ');
+                                    a++;
+                                    if (start == a && characterAction != 2 && characterAction != 3) {
+                                        start++;
+                                    }
+                                }
+                            } else {
+                                builder.insert(a, ' ');
+                                if (start == a + 1 && characterAction != 2 && characterAction != 3) {
+                                    start++;
+                                }
+                                break;
+                            }
+                        }
+                    }
+                    phoneField.setText(builder);
+                    if (start >= 0) {
+                        phoneField.setSelection(start <= phoneField.length() ? start : phoneField.length());
+                    }
+                    phoneField.onTextChange();
+                    ignoreOnPhoneChange = false;
                 }
             });
             phoneField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
@@ -630,14 +654,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             textView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
             textView.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
-            addView(textView);
-            layoutParams = (LayoutParams) textView.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.topMargin = AndroidUtilities.dp(28);
-            layoutParams.bottomMargin = AndroidUtilities.dp(10);
-            layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-            textView.setLayoutParams(layoutParams);
+            addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, 0, 28, 0, 10));
 
             HashMap<String, String> languageMap = new HashMap<>();
             try {
@@ -648,6 +665,9 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
                     countriesArray.add(0, args[2]);
                     countriesMap.put(args[2], args[0]);
                     codesMap.put(args[0], args[2]);
+                    if (args.length > 3) {
+                        phoneFormatMap.put(args[0], args[3]);
+                    }
                     languageMap.put(args[1], args[2]);
                 }
                 reader.close();
@@ -685,12 +705,14 @@ public int compare(String lhs, String rhs) {
             }
             if (codeField.length() == 0) {
                 countryButton.setText(LocaleController.getString("ChooseCountry", R.string.ChooseCountry));
+                phoneField.setHintText(null);
                 countryState = 1;
             }
 
             if (codeField.length() != 0) {
                 AndroidUtilities.showKeyboard(phoneField);
                 phoneField.requestFocus();
+                phoneField.setSelection(phoneField.length());
             } else {
                 AndroidUtilities.showKeyboard(codeField);
                 codeField.requestFocus();
@@ -701,37 +723,15 @@ public void selectCountry(String name) {
             int index = countriesArray.indexOf(name);
             if (index != -1) {
                 ignoreOnTextChange = true;
-                codeField.setText(countriesMap.get(name));
+                String code = countriesMap.get(name);
+                codeField.setText(code);
                 countryButton.setText(name);
+                String hint = phoneFormatMap.get(code);
+                phoneField.setHintText(hint != null ? hint.replace('X', '–') : null);
                 countryState = 0;
             }
         }
 
-        private void updatePhoneField() {
-            ignoreOnPhoneChange = true;
-            try {
-                String codeText = codeField.getText().toString();
-                String phone = PhoneFormat.getInstance().format("+" + codeText + phoneField.getText().toString());
-                int idx = phone.indexOf(" ");
-                if (idx != -1) {
-                    String resultCode = PhoneFormat.stripExceptNumbers(phone.substring(0, idx));
-                    if (!codeText.equals(resultCode)) {
-                        phone = PhoneFormat.getInstance().format(phoneField.getText().toString()).trim();
-                        phoneField.setText(phone);
-                        phoneField.setSelection(phoneField.length());
-                    } else {
-                        phoneField.setText(phone.substring(idx).trim());
-                        phoneField.setSelection(phoneField.length());
-                    }
-                } else {
-                    phoneField.setSelection(phoneField.length());
-                }
-            } catch (Exception e) {
-                FileLog.e("tmessages", e);
-            }
-            ignoreOnPhoneChange = false;
-        }
-
         @Override
         public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
             if (ignoreSelection) {
@@ -741,7 +741,6 @@ public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l)
             ignoreOnTextChange = true;
             String str = countriesArray.get(i);
             codeField.setText(countriesMap.get(str));
-            updatePhoneField();
         }
 
         @Override
@@ -765,6 +764,7 @@ public void onNextPressed() {
                 needShowAlert(LocaleController.getString("AppName", R.string.AppName), LocaleController.getString("InvalidPhoneNumber", R.string.InvalidPhoneNumber));
                 return;
             }
+
             ConnectionsManager.getInstance().cleanUp();
             TLRPC.TL_auth_sendCode req = new TLRPC.TL_auth_sendCode();
             String phone = PhoneFormat.stripExceptNumbers("" + codeField.getText() + phoneField.getText());
@@ -827,8 +827,14 @@ public void run() {
         public void onShow() {
             super.onShow();
             if (phoneField != null) {
-                phoneField.requestFocus();
-                phoneField.setSelection(phoneField.length());
+                if (codeField.length() != 0) {
+                    AndroidUtilities.showKeyboard(phoneField);
+                    phoneField.requestFocus();
+                    phoneField.setSelection(phoneField.length());
+                } else {
+                    AndroidUtilities.showKeyboard(codeField);
+                    codeField.requestFocus();
+                }
             }
         }
 
@@ -880,6 +886,7 @@ public void restoreStateParams(Bundle bundle) {
         private volatile int codeTime = 15000;
         private double lastCurrentTime;
         private double lastCodeTime;
+        private boolean ignoreOnTextChange = false;
         private boolean waitingForSms = false;
         private boolean nextPressed = false;
         private String lastError = "";
@@ -894,12 +901,7 @@ public LoginActivitySmsView(Context context) {
             confirmTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             confirmTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
             confirmTextView.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
-            addView(confirmTextView);
-            LayoutParams layoutParams = (LayoutParams) confirmTextView.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-            confirmTextView.setLayoutParams(layoutParams);
+            addView(confirmTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
 
             codeField = new EditText(context);
             codeField.setTextColor(0xff212121);
@@ -911,13 +913,28 @@ public LoginActivitySmsView(Context context) {
             codeField.setInputType(InputType.TYPE_CLASS_PHONE);
             codeField.setMaxLines(1);
             codeField.setPadding(0, 0, 0, 0);
-            addView(codeField);
-            layoutParams = (LayoutParams) codeField.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.gravity = Gravity.CENTER_HORIZONTAL;
-            layoutParams.topMargin = AndroidUtilities.dp(20);
-            codeField.setLayoutParams(layoutParams);
+            addView(codeField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, Gravity.CENTER_HORIZONTAL, 0, 20, 0, 0));
+            codeField.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    if (ignoreOnTextChange) {
+                        return;
+                    }
+                    if (codeField.length() == 5) {
+                        onNextPressed();
+                    }
+                }
+            });
             codeField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
                 @Override
                 public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
@@ -934,13 +951,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             timeText.setTextColor(0xff757575);
             timeText.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             timeText.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            addView(timeText);
-            layoutParams = (LayoutParams) timeText.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-            layoutParams.topMargin = AndroidUtilities.dp(30);
-            timeText.setLayoutParams(layoutParams);
+            addView(timeText, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, 0, 30, 0, 0));
 
             problemText = new TextView(context);
             problemText.setText(LocaleController.getString("DidNotGetTheCode", R.string.DidNotGetTheCode));
@@ -950,13 +961,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             problemText.setTextColor(0xff4d83b3);
             problemText.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             problemText.setPadding(0, AndroidUtilities.dp(2), 0, AndroidUtilities.dp(12));
-            addView(problemText);
-            layoutParams = (LayoutParams) problemText.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-            layoutParams.topMargin = AndroidUtilities.dp(20);
-            problemText.setLayoutParams(layoutParams);
+            addView(problemText, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, 0, 20, 0, 0));
             problemText.setOnClickListener(new OnClickListener() {
                 @Override
                 public void onClick(View v) {
@@ -978,12 +983,7 @@ public void onClick(View v) {
 
             LinearLayout linearLayout = new LinearLayout(context);
             linearLayout.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_VERTICAL);
-            addView(linearLayout);
-            layoutParams = (LayoutParams) linearLayout.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = LayoutHelper.MATCH_PARENT;
-            layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            linearLayout.setLayoutParams(layoutParams);
+            addView(linearLayout, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
 
             TextView wrongNumber = new TextView(context);
             wrongNumber.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.CENTER_HORIZONTAL);
@@ -991,13 +991,7 @@ public void onClick(View v) {
             wrongNumber.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             wrongNumber.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             wrongNumber.setPadding(0, AndroidUtilities.dp(24), 0, 0);
-            linearLayout.addView(wrongNumber);
-            layoutParams = (LayoutParams) wrongNumber.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = Gravity.BOTTOM | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            layoutParams.bottomMargin = AndroidUtilities.dp(10);
-            wrongNumber.setLayoutParams(layoutParams);
+            linearLayout.addView(wrongNumber, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.BOTTOM | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), 0, 0, 0, 10));
             wrongNumber.setText(LocaleController.getString("WrongNumber", R.string.WrongNumber));
             wrongNumber.setOnClickListener(new OnClickListener() {
                 @Override
@@ -1296,6 +1290,7 @@ public void didReceivedNotification(int id, final Object... args) {
                     return;
                 }
                 if (codeField != null) {
+                    ignoreOnTextChange = true;
                     codeField.setText("" + args[0]);
                     onNextPressed();
                 }
@@ -1361,12 +1356,7 @@ public LoginActivityPasswordView(Context context) {
             confirmTextView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
             confirmTextView.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             confirmTextView.setText(LocaleController.getString("LoginPasswordText", R.string.LoginPasswordText));
-            addView(confirmTextView);
-            LayoutParams layoutParams = (LayoutParams) confirmTextView.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-            confirmTextView.setLayoutParams(layoutParams);
+            addView(confirmTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
 
             codeField = new EditText(context);
             codeField.setTextColor(0xff212121);
@@ -1381,13 +1371,7 @@ public LoginActivityPasswordView(Context context) {
             codeField.setTransformationMethod(PasswordTransformationMethod.getInstance());
             codeField.setTypeface(Typeface.DEFAULT);
             codeField.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            addView(codeField);
-            layoutParams = (LayoutParams) codeField.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.gravity = Gravity.CENTER_HORIZONTAL;
-            layoutParams.topMargin = AndroidUtilities.dp(20);
-            codeField.setLayoutParams(layoutParams);
+            addView(codeField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, Gravity.CENTER_HORIZONTAL, 0, 20, 0, 0));
             codeField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
                 @Override
                 public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
@@ -1406,12 +1390,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             cancelButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             cancelButton.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             cancelButton.setPadding(0, AndroidUtilities.dp(14), 0, 0);
-            addView(cancelButton);
-            layoutParams = (LayoutParams) cancelButton.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            cancelButton.setLayoutParams(layoutParams);
+            addView(cancelButton, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT)));
             cancelButton.setOnClickListener(new OnClickListener() {
                 @Override
                 public void onClick(View view) {
@@ -1479,13 +1458,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
             resetAccountButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             resetAccountButton.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             resetAccountButton.setPadding(0, AndroidUtilities.dp(14), 0, 0);
-            addView(resetAccountButton);
-            layoutParams = (LayoutParams) resetAccountButton.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            layoutParams.topMargin = AndroidUtilities.dp(34);
-            resetAccountButton.setLayoutParams(layoutParams);
+            addView(resetAccountButton, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), 0, 34, 0, 0));
             resetAccountButton.setOnClickListener(new OnClickListener() {
                 @Override
                 public void onClick(View view) {
@@ -1532,14 +1505,7 @@ public void run() {
             resetAccountText.setText(LocaleController.getString("ResetMyAccountText", R.string.ResetMyAccountText));
             resetAccountText.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             resetAccountText.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
-            addView(resetAccountText);
-            layoutParams = (LayoutParams) resetAccountText.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            layoutParams.bottomMargin = AndroidUtilities.dp(14);
-            layoutParams.topMargin = AndroidUtilities.dp(7);
-            resetAccountText.setLayoutParams(layoutParams);
+            addView(resetAccountText, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.TOP | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), 0, 7, 0, 14));
         }
 
         @Override
@@ -1731,12 +1697,7 @@ public LoginActivityRecoverView(Context context) {
             confirmTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
             confirmTextView.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             confirmTextView.setText(LocaleController.getString("RestoreEmailSentInfo", R.string.RestoreEmailSentInfo));
-            addView(confirmTextView);
-            LayoutParams layoutParams = (LayoutParams) confirmTextView.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            confirmTextView.setLayoutParams(layoutParams);
+            addView(confirmTextView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT)));
 
             codeField = new EditText(context);
             codeField.setTextColor(0xff212121);
@@ -1751,13 +1712,7 @@ public LoginActivityRecoverView(Context context) {
             codeField.setTransformationMethod(PasswordTransformationMethod.getInstance());
             codeField.setTypeface(Typeface.DEFAULT);
             codeField.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            addView(codeField);
-            layoutParams = (LayoutParams) codeField.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.gravity = Gravity.CENTER_HORIZONTAL;
-            layoutParams.topMargin = AndroidUtilities.dp(20);
-            codeField.setLayoutParams(layoutParams);
+            addView(codeField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, Gravity.CENTER_HORIZONTAL, 0, 20, 0, 0));
             codeField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
                 @Override
                 public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
@@ -1775,13 +1730,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             cancelButton.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             cancelButton.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             cancelButton.setPadding(0, AndroidUtilities.dp(14), 0, 0);
-            addView(cancelButton);
-            layoutParams = (LayoutParams) cancelButton.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = Gravity.BOTTOM | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            layoutParams.bottomMargin = AndroidUtilities.dp(14);
-            cancelButton.setLayoutParams(layoutParams);
+            addView(cancelButton, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.BOTTOM | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), 0, 0, 0, 14));
             cancelButton.setOnClickListener(new OnClickListener() {
                 @Override
                 public void onClick(View view) {
@@ -1965,13 +1914,7 @@ public LoginActivityRegisterView(Context context) {
             textView.setTextColor(0xff757575);
             textView.setGravity(LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
             textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
-            addView(textView);
-            LayoutParams layoutParams = (LayoutParams) textView.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.topMargin = AndroidUtilities.dp(8);
-            layoutParams.gravity = LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT;
-            textView.setLayoutParams(layoutParams);
+            addView(textView, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT, 0, 8, 0, 0));
 
             firstNameField = new EditText(context);
             firstNameField.setHintTextColor(0xff979797);
@@ -1982,12 +1925,7 @@ public LoginActivityRegisterView(Context context) {
             firstNameField.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
             firstNameField.setMaxLines(1);
             firstNameField.setInputType(InputType.TYPE_TEXT_FLAG_CAP_WORDS);
-            addView(firstNameField);
-            layoutParams = (LayoutParams) firstNameField.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.topMargin = AndroidUtilities.dp(26);
-            firstNameField.setLayoutParams(layoutParams);
+            addView(firstNameField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 0, 26, 0, 0));
             firstNameField.setOnEditorActionListener(new TextView.OnEditorActionListener() {
                 @Override
                 public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
@@ -2008,20 +1946,11 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             lastNameField.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
             lastNameField.setMaxLines(1);
             lastNameField.setInputType(InputType.TYPE_TEXT_FLAG_CAP_WORDS);
-            addView(lastNameField);
-            layoutParams = (LayoutParams) lastNameField.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = AndroidUtilities.dp(36);
-            layoutParams.topMargin = AndroidUtilities.dp(10);
-            lastNameField.setLayoutParams(layoutParams);
+            addView(lastNameField, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, 36, 0, 10, 0, 0));
 
             LinearLayout linearLayout = new LinearLayout(context);
             linearLayout.setGravity(Gravity.BOTTOM | Gravity.CENTER_VERTICAL);
-            addView(linearLayout);
-            layoutParams = (LayoutParams) linearLayout.getLayoutParams();
-            layoutParams.width = LayoutHelper.MATCH_PARENT;
-            layoutParams.height = LayoutHelper.MATCH_PARENT;
-            linearLayout.setLayoutParams(layoutParams);
+            addView(linearLayout, LayoutHelper.createLinear(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
             TextView wrongNumber = new TextView(context);
             wrongNumber.setText(LocaleController.getString("CancelRegistration", R.string.CancelRegistration));
@@ -2030,13 +1959,7 @@ public boolean onEditorAction(TextView textView, int i, KeyEvent keyEvent) {
             wrongNumber.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
             wrongNumber.setLineSpacing(AndroidUtilities.dp(2), 1.0f);
             wrongNumber.setPadding(0, AndroidUtilities.dp(24), 0, 0);
-            linearLayout.addView(wrongNumber);
-            layoutParams = (LayoutParams) wrongNumber.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.gravity = Gravity.BOTTOM | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT);
-            layoutParams.bottomMargin = AndroidUtilities.dp(10);
-            wrongNumber.setLayoutParams(layoutParams);
+            linearLayout.addView(wrongNumber, LayoutHelper.createLinear(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.BOTTOM | (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT), 0, 0, 0, 10));
             wrongNumber.setOnClickListener(new OnClickListener() {
                 @Override
                 public void onClick(View view) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ManageSpaceActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ManageSpaceActivity.java
new file mode 100644
index 000000000..2ab8d920d
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ManageSpaceActivity.java
@@ -0,0 +1,380 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui;
+
+import android.app.Activity;
+import android.content.Intent;
+import android.content.res.Configuration;
+import android.os.Build;
+import android.os.Bundle;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.RelativeLayout;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.LocaleController;
+import org.telegram.messenger.NotificationCenter;
+import org.telegram.messenger.R;
+import org.telegram.tgnet.ConnectionsManager;
+import org.telegram.ui.ActionBar.ActionBarLayout;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.ActionBar.DrawerLayoutContainer;
+import org.telegram.ui.Components.LayoutHelper;
+
+import java.util.ArrayList;
+
+public class ManageSpaceActivity extends Activity implements ActionBarLayout.ActionBarLayoutDelegate {
+
+    private boolean finished;
+    private int currentConnectionState;
+    private static ArrayList<BaseFragment> mainFragmentsStack = new ArrayList<>();
+    private static ArrayList<BaseFragment> layerFragmentsStack = new ArrayList<>();
+
+    private ActionBarLayout actionBarLayout;
+    private ActionBarLayout layersActionBarLayout;
+    protected DrawerLayoutContainer drawerLayoutContainer;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        ApplicationLoader.postInitApplication();
+
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        setTheme(R.style.Theme_TMessages);
+        getWindow().setBackgroundDrawableResource(R.drawable.transparent);
+
+        super.onCreate(savedInstanceState);
+
+        int resourceId = getResources().getIdentifier("status_bar_height", "dimen", "android");
+        if (resourceId > 0) {
+            AndroidUtilities.statusBarHeight = getResources().getDimensionPixelSize(resourceId);
+        }
+
+        actionBarLayout = new ActionBarLayout(this);
+
+        drawerLayoutContainer = new DrawerLayoutContainer(this);
+        drawerLayoutContainer.setAllowOpenDrawer(false, false);
+        setContentView(drawerLayoutContainer, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+
+        if (AndroidUtilities.isTablet()) {
+            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
+
+            RelativeLayout launchLayout = new RelativeLayout(this);
+            drawerLayoutContainer.addView(launchLayout);
+            FrameLayout.LayoutParams layoutParams1 = (FrameLayout.LayoutParams) launchLayout.getLayoutParams();
+            layoutParams1.width = LayoutHelper.MATCH_PARENT;
+            layoutParams1.height = LayoutHelper.MATCH_PARENT;
+            launchLayout.setLayoutParams(layoutParams1);
+
+            ImageView backgroundTablet = new ImageView(this);
+            backgroundTablet.setScaleType(ImageView.ScaleType.CENTER_CROP);
+            backgroundTablet.setImageResource(R.drawable.cats);
+            launchLayout.addView(backgroundTablet);
+            RelativeLayout.LayoutParams relativeLayoutParams = (RelativeLayout.LayoutParams) backgroundTablet.getLayoutParams();
+            relativeLayoutParams.width = LayoutHelper.MATCH_PARENT;
+            relativeLayoutParams.height = LayoutHelper.MATCH_PARENT;
+            backgroundTablet.setLayoutParams(relativeLayoutParams);
+
+            launchLayout.addView(actionBarLayout);
+            relativeLayoutParams = (RelativeLayout.LayoutParams) actionBarLayout.getLayoutParams();
+            relativeLayoutParams.width = LayoutHelper.MATCH_PARENT;
+            relativeLayoutParams.height = LayoutHelper.MATCH_PARENT;
+            actionBarLayout.setLayoutParams(relativeLayoutParams);
+
+            FrameLayout shadowTablet = new FrameLayout(this);
+            shadowTablet.setBackgroundColor(0x7F000000);
+            launchLayout.addView(shadowTablet);
+            relativeLayoutParams = (RelativeLayout.LayoutParams) shadowTablet.getLayoutParams();
+            relativeLayoutParams.width = LayoutHelper.MATCH_PARENT;
+            relativeLayoutParams.height = LayoutHelper.MATCH_PARENT;
+            shadowTablet.setLayoutParams(relativeLayoutParams);
+            shadowTablet.setOnTouchListener(new View.OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    if (!actionBarLayout.fragmentsStack.isEmpty() && event.getAction() == MotionEvent.ACTION_UP) {
+                        float x = event.getX();
+                        float y = event.getY();
+                        int location[] = new int[2];
+                        layersActionBarLayout.getLocationOnScreen(location);
+                        int viewX = location[0];
+                        int viewY = location[1];
+
+                        if (layersActionBarLayout.checkTransitionAnimation() || x > viewX && x < viewX + layersActionBarLayout.getWidth() && y > viewY && y < viewY + layersActionBarLayout.getHeight()) {
+                            return false;
+                        } else {
+                            if (!layersActionBarLayout.fragmentsStack.isEmpty()) {
+                                for (int a = 0; a < layersActionBarLayout.fragmentsStack.size() - 1; a++) {
+                                    layersActionBarLayout.removeFragmentFromStack(layersActionBarLayout.fragmentsStack.get(0));
+                                    a--;
+                                }
+                                layersActionBarLayout.closeLastFragment(true);
+                            }
+                            return true;
+                        }
+                    }
+                    return false;
+                }
+            });
+
+            shadowTablet.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+
+                }
+            });
+
+            layersActionBarLayout = new ActionBarLayout(this);
+            layersActionBarLayout.setRemoveActionBarExtraHeight(true);
+            layersActionBarLayout.setBackgroundView(shadowTablet);
+            layersActionBarLayout.setUseAlphaAnimations(true);
+            layersActionBarLayout.setBackgroundResource(R.drawable.boxshadow);
+            launchLayout.addView(layersActionBarLayout);
+            relativeLayoutParams = (RelativeLayout.LayoutParams)layersActionBarLayout.getLayoutParams();
+            relativeLayoutParams.width = AndroidUtilities.dp(530);
+            relativeLayoutParams.height = AndroidUtilities.dp(528);
+            layersActionBarLayout.setLayoutParams(relativeLayoutParams);
+            layersActionBarLayout.init(layerFragmentsStack);
+            layersActionBarLayout.setDelegate(this);
+            layersActionBarLayout.setDrawerLayoutContainer(drawerLayoutContainer);
+        } else {
+            drawerLayoutContainer.addView(actionBarLayout, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
+        }
+
+       // drawerLayoutContainer.setDrawerLayout(listView);
+
+        drawerLayoutContainer.setParentActionBarLayout(actionBarLayout);
+        actionBarLayout.setDrawerLayoutContainer(drawerLayoutContainer);
+        actionBarLayout.init(mainFragmentsStack);
+        actionBarLayout.setDelegate(this);
+
+        NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeOtherAppActivities, this);
+        currentConnectionState = ConnectionsManager.getInstance().getConnectionState();
+
+        handleIntent(getIntent(), false, savedInstanceState != null, false);
+        needLayout();
+    }
+
+    private boolean handleIntent(Intent intent, boolean isNew, boolean restore, boolean fromPassword) {
+        if (AndroidUtilities.isTablet()) {
+            if (layersActionBarLayout.fragmentsStack.isEmpty()) {
+                layersActionBarLayout.addFragmentToStack(new CacheControlActivity());
+            }
+        } else {
+            if (actionBarLayout.fragmentsStack.isEmpty()) {
+                actionBarLayout.addFragmentToStack(new CacheControlActivity());
+            }
+        }
+        actionBarLayout.showLastFragment();
+        if (AndroidUtilities.isTablet()) {
+            layersActionBarLayout.showLastFragment();
+        }
+        intent.setAction(null);
+        return false;
+    }
+
+    @Override
+    public boolean onPreIme() {
+        return false;
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        super.onNewIntent(intent);
+        handleIntent(intent, true, false, false);
+    }
+
+    private void onFinish() {
+        if (finished) {
+            return;
+        }
+        finished = true;
+    }
+
+    public void presentFragment(BaseFragment fragment) {
+        actionBarLayout.presentFragment(fragment);
+    }
+
+    public boolean presentFragment(final BaseFragment fragment, final boolean removeLast, boolean forceWithoutAnimation) {
+        return actionBarLayout.presentFragment(fragment, removeLast, forceWithoutAnimation, true);
+    }
+
+    public void needLayout() {
+        if (AndroidUtilities.isTablet()) {
+            RelativeLayout.LayoutParams relativeLayoutParams = (RelativeLayout.LayoutParams)layersActionBarLayout.getLayoutParams();
+            relativeLayoutParams.leftMargin = (AndroidUtilities.displaySize.x - relativeLayoutParams.width) / 2;
+            int y = (Build.VERSION.SDK_INT >= 21 ? AndroidUtilities.statusBarHeight : 0);
+            relativeLayoutParams.topMargin = y + (AndroidUtilities.displaySize.y - relativeLayoutParams.height - y) / 2;
+            layersActionBarLayout.setLayoutParams(relativeLayoutParams);
+
+
+            if (!AndroidUtilities.isSmallTablet() || getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
+                int leftWidth = AndroidUtilities.displaySize.x / 100 * 35;
+                if (leftWidth < AndroidUtilities.dp(320)) {
+                    leftWidth = AndroidUtilities.dp(320);
+                }
+
+                relativeLayoutParams = (RelativeLayout.LayoutParams) actionBarLayout.getLayoutParams();
+                relativeLayoutParams.width = leftWidth;
+                relativeLayoutParams.height = LayoutHelper.MATCH_PARENT;
+                actionBarLayout.setLayoutParams(relativeLayoutParams);
+
+                if (AndroidUtilities.isSmallTablet() && actionBarLayout.fragmentsStack.size() == 2) {
+                    BaseFragment chatFragment = actionBarLayout.fragmentsStack.get(1);
+                    chatFragment.onPause();
+                    actionBarLayout.fragmentsStack.remove(1);
+                    actionBarLayout.showLastFragment();
+                }
+            } else {
+                relativeLayoutParams = (RelativeLayout.LayoutParams) actionBarLayout.getLayoutParams();
+                relativeLayoutParams.width = LayoutHelper.MATCH_PARENT;
+                relativeLayoutParams.height = LayoutHelper.MATCH_PARENT;
+                actionBarLayout.setLayoutParams(relativeLayoutParams);
+            }
+        }
+    }
+
+    public void fixLayout() {
+        if (!AndroidUtilities.isTablet()) {
+            return;
+        }
+        if (actionBarLayout == null) {
+            return;
+        }
+        actionBarLayout.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                needLayout();
+                if (actionBarLayout != null) {
+                    if (Build.VERSION.SDK_INT < 16) {
+                        actionBarLayout.getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                    } else {
+                        actionBarLayout.getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                    }
+                }
+            }
+        });
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        actionBarLayout.onPause();
+        if (AndroidUtilities.isTablet()) {
+            layersActionBarLayout.onPause();
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        onFinish();
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        actionBarLayout.onResume();
+        if (AndroidUtilities.isTablet()) {
+            layersActionBarLayout.onResume();
+        }
+    }
+
+    @Override
+    public void onConfigurationChanged(android.content.res.Configuration newConfig) {
+        AndroidUtilities.checkDisplaySize();
+        super.onConfigurationChanged(newConfig);
+        fixLayout();
+    }
+
+    private void updateCurrentConnectionState() {
+        String text = null;
+        if (currentConnectionState == ConnectionsManager.ConnectionStateWaitingForNetwork) {
+            text = LocaleController.getString("WaitingForNetwork", R.string.WaitingForNetwork);
+        } else if (currentConnectionState == ConnectionsManager.ConnectionStateConnecting) {
+            text = LocaleController.getString("Connecting", R.string.Connecting);
+        } else if (currentConnectionState == ConnectionsManager.ConnectionStateUpdating) {
+            text = LocaleController.getString("Updating", R.string.Updating);
+        }
+        actionBarLayout.setTitleOverlayText(text);
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (PhotoViewer.getInstance().isVisible()) {
+            PhotoViewer.getInstance().closePhoto(true, false);
+        } else if (drawerLayoutContainer.isDrawerOpened()) {
+            drawerLayoutContainer.closeDrawer(false);
+        } else if (AndroidUtilities.isTablet()) {
+            if (layersActionBarLayout.getVisibility() == View.VISIBLE) {
+                layersActionBarLayout.onBackPressed();
+            } else {
+                actionBarLayout.onBackPressed();
+            }
+        } else {
+            actionBarLayout.onBackPressed();
+        }
+    }
+
+    @Override
+    public void onLowMemory() {
+        super.onLowMemory();
+        actionBarLayout.onLowMemory();
+        if (AndroidUtilities.isTablet()) {
+            layersActionBarLayout.onLowMemory();
+        }
+    }
+
+    @Override
+    public boolean needPresentFragment(BaseFragment fragment, boolean removeLast, boolean forceWithoutAnimation, ActionBarLayout layout) {
+        return true;
+    }
+
+    @Override
+    public boolean needAddFragmentToStack(BaseFragment fragment, ActionBarLayout layout) {
+        return true;
+    }
+
+    @Override
+    public boolean needCloseLastFragment(ActionBarLayout layout) {
+        if (AndroidUtilities.isTablet()) {
+            if (layout == actionBarLayout && layout.fragmentsStack.size() <= 1) {
+                onFinish();
+                finish();
+                return false;
+            } else if (layout == layersActionBarLayout && actionBarLayout.fragmentsStack.isEmpty() && layersActionBarLayout.fragmentsStack.size() == 1) {
+                onFinish();
+                finish();
+                return false;
+            }
+        } else {
+            if (layout.fragmentsStack.size() <= 1) {
+                onFinish();
+                finish();
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Override
+    public void onRebuildAllFragments(ActionBarLayout layout) {
+        if (AndroidUtilities.isTablet()) {
+            if (layout == layersActionBarLayout) {
+                actionBarLayout.rebuildAllFragmentViews(true);
+                actionBarLayout.showLastFragment();
+            }
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/MediaActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/MediaActivity.java
index d821ece68..69e76c953 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/MediaActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/MediaActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -59,6 +59,7 @@
 import org.telegram.ui.ActionBar.ActionBarMenuItem;
 import org.telegram.ui.ActionBar.ActionBarPopupWindow;
 import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.BackDrawable;
 import org.telegram.ui.ActionBar.BottomSheet;
 import org.telegram.ui.Adapters.BaseFragmentAdapter;
 import org.telegram.ui.Adapters.BaseSectionsAdapter;
@@ -73,6 +74,8 @@
 import org.telegram.ui.Components.BackupImageView;
 import org.telegram.ui.ActionBar.BaseFragment;
 import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.NumberTextView;
+import org.telegram.ui.Components.PlayerView;
 import org.telegram.ui.Components.SectionsListView;
 import org.telegram.ui.Components.WebFrameLayout;
 
@@ -83,12 +86,15 @@
 import java.util.Timer;
 import java.util.TimerTask;
 
+@SuppressWarnings("unchecked")
 public class MediaActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate, PhotoViewer.PhotoViewerProvider {
 
     private SharedPhotoVideoAdapter photoVideoAdapter;
     private SharedLinksAdapter linksAdapter;
     private SharedDocumentsAdapter documentsAdapter;
+    private SharedDocumentsAdapter audioAdapter;
     private MediaSearchAdapter documentsSearchAdapter;
+    private MediaSearchAdapter audioSearchAdapter;
     private MediaSearchAdapter linksSearchAdapter;
     private SectionsListView listView;
     private LinearLayout progressView;
@@ -98,17 +104,19 @@
     private TextView dropDown;
     private ActionBarMenuItem dropDownContainer;
     private ActionBarMenuItem searchItem;
-    private TextView selectedMessagesCountTextView;
+    private NumberTextView selectedMessagesCountTextView;
     private ActionBarPopupWindow.ActionBarPopupWindowLayout popupLayout;
     private ArrayList<SharedPhotoVideoCell> cellCache = new ArrayList<>(6);
 
     private boolean searchWas;
     private boolean searching;
 
-    private HashMap<Integer, MessageObject> selectedFiles = new HashMap<>();
+    private HashMap<Integer, MessageObject>[] selectedFiles = new HashMap[] {new HashMap<>(), new HashMap<>()};
     private int cantDeleteMessagesCount;
     private ArrayList<View> actionModeViews = new ArrayList<>();
     private boolean scrolling;
+    private long mergeDialogId;
+    protected TLRPC.ChatFull info = null;
 
     private long dialog_id;
     private int selectedMode;
@@ -116,16 +124,17 @@
 
     private class SharedMediaData {
         private ArrayList<MessageObject> messages = new ArrayList<>();
-        private HashMap<Integer, MessageObject> messagesDict = new HashMap<>();
+        private HashMap<Integer, MessageObject>[] messagesDict = new HashMap[] {new HashMap<>(), new HashMap<>()};
         private ArrayList<String> sections = new ArrayList<>();
         private HashMap<String, ArrayList<MessageObject>> sectionArrays = new HashMap<>();
         private int totalCount;
         private boolean loading;
-        private boolean endReached;
-        private int max_id;
+        private boolean endReached[] = new boolean[] {false, true};
+        private int max_id[] = new int[] {0, 0};
 
         public boolean addMessage(MessageObject messageObject, boolean isNew, boolean enc) {
-            if (messagesDict.containsKey(messageObject.getId())) {
+            int loadIndex = messageObject.getDialogId() == dialog_id ? 0 : 1;
+            if (messagesDict[loadIndex].containsKey(messageObject.getId())) {
                 return false;
             }
             ArrayList<MessageObject> messageObjects = sectionArrays.get(messageObject.monthKey);
@@ -145,19 +154,19 @@ public boolean addMessage(MessageObject messageObject, boolean isNew, boolean en
                 messageObjects.add(messageObject);
                 messages.add(messageObject);
             }
-            messagesDict.put(messageObject.getId(), messageObject);
+            messagesDict[loadIndex].put(messageObject.getId(), messageObject);
             if (!enc) {
                 if (messageObject.getId() > 0) {
-                    max_id = Math.min(messageObject.getId(), max_id);
+                    max_id[loadIndex] = Math.min(messageObject.getId(), max_id[loadIndex]);
                 }
             } else {
-                max_id = Math.max(messageObject.getId(), max_id);
+                max_id[loadIndex] = Math.max(messageObject.getId(), max_id[loadIndex]);
             }
             return true;
         }
 
-        public boolean deleteMessage(int mid) {
-            MessageObject messageObject = messagesDict.get(mid);
+        public boolean deleteMessage(int mid, int loadIndex) {
+            MessageObject messageObject = messagesDict[loadIndex].get(mid);
             if (messageObject == null) {
                 return false;
             }
@@ -167,7 +176,7 @@ public boolean deleteMessage(int mid) {
             }
             messageObjects.remove(messageObject);
             messages.remove(messageObject);
-            messagesDict.remove(messageObject.getId());
+            messagesDict[loadIndex].remove(messageObject.getId());
             if (messageObjects.isEmpty()) {
                 sectionArrays.remove(messageObject.monthKey);
                 sections.remove(messageObject.monthKey);
@@ -177,20 +186,21 @@ public boolean deleteMessage(int mid) {
         }
 
         public void replaceMid(int oldMid, int newMid) {
-            MessageObject obj = messagesDict.get(oldMid);
+            MessageObject obj = messagesDict[0].get(oldMid);
             if (obj != null) {
-                messagesDict.remove(oldMid);
-                messagesDict.put(newMid, obj);
+                messagesDict[0].remove(oldMid);
+                messagesDict[0].put(newMid, obj);
                 obj.messageOwner.id = newMid;
             }
         }
     }
 
-    private SharedMediaData sharedMediaData[] = new SharedMediaData[4];
+    private SharedMediaData sharedMediaData[] = new SharedMediaData[5];
 
     private final static int shared_media_item = 1;
     private final static int files_item = 2;
     private final static int links_item = 5;
+    private final static int music_item = 6;
     private final static int forward = 3;
     private final static int delete = 4;
 
@@ -208,7 +218,11 @@ public boolean onFragmentCreate() {
         dialog_id = getArguments().getLong("dialog_id", 0);
         for (int a = 0; a < sharedMediaData.length; a++) {
             sharedMediaData[a] = new SharedMediaData();
-            sharedMediaData[a].max_id = ((int)dialog_id) == 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE;
+            sharedMediaData[a].max_id[0] = ((int)dialog_id) == 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE;
+            if (mergeDialogId != 0 && info != null) {
+                sharedMediaData[a].max_id[1] = info.migrated_from_max_id;
+                sharedMediaData[a].endReached[1] = false;
+            }
         }
         sharedMediaData[0].loading = true;
         SharedMediaQuery.loadMedia(dialog_id, 0, 50, 0, SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
@@ -226,26 +240,31 @@ public void onFragmentDestroy() {
 
     @Override
     public View createView(Context context) {
-        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setBackButtonDrawable(new BackDrawable(false));
         actionBar.setTitle("");
         actionBar.setAllowOverlayTitle(false);
         actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
             @Override
             public void onItemClick(int id) {
                 if (id == -1) {
-                    if (Build.VERSION.SDK_INT < 11 && listView != null) {
-                        listView.setAdapter(null);
-                        listView = null;
-                        photoVideoAdapter = null;
-                        documentsAdapter = null;
-                        linksAdapter = null;
+                    if (actionBar.isActionModeShowed()) {
+                        for (int a = 1; a >= 0; a--) {
+                            selectedFiles[a].clear();
+                        }
+                        cantDeleteMessagesCount = 0;
+                        actionBar.hideActionMode();
+                        listView.invalidateViews();
+                    } else {
+                        if (Build.VERSION.SDK_INT < 11 && listView != null) {
+                            listView.setAdapter(null);
+                            listView = null;
+                            photoVideoAdapter = null;
+                            documentsAdapter = null;
+                            audioAdapter = null;
+                            linksAdapter = null;
+                        }
+                        finishFragment();
                     }
-                    finishFragment();
-                } else if (id == -2) {
-                    selectedFiles.clear();
-                    cantDeleteMessagesCount = 0;
-                    actionBar.hideActionMode();
-                    listView.invalidateViews();
                 } else if (id == shared_media_item) {
                     if (selectedMode == 0) {
                         return;
@@ -264,42 +283,50 @@ public void onItemClick(int id) {
                     }
                     selectedMode = 3;
                     switchToCurrentSelectedMode();
+                } else if (id == music_item) {
+                    if (selectedMode == 4) {
+                        return;
+                    }
+                    selectedMode = 4;
+                    switchToCurrentSelectedMode();
                 } else if (id == delete) {
                     if (getParentActivity() == null) {
                         return;
                     }
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
-                    builder.setMessage(LocaleController.formatString("AreYouSureDeleteMessages", R.string.AreYouSureDeleteMessages, LocaleController.formatPluralString("items", selectedFiles.size())));
+                    builder.setMessage(LocaleController.formatString("AreYouSureDeleteMessages", R.string.AreYouSureDeleteMessages, LocaleController.formatPluralString("items", selectedFiles[0].size() + selectedFiles[1].size())));
                     builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
                     builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
                         @Override
                         public void onClick(DialogInterface dialogInterface, int i) {
-                            ArrayList<Integer> ids = new ArrayList<>(selectedFiles.keySet());
-                            ArrayList<Long> random_ids = null;
-                            TLRPC.EncryptedChat currentEncryptedChat = null;
-                            int channelId = 0;
-                            if (!ids.isEmpty()) {
-                                MessageObject msg = selectedFiles.get(ids.get(0));
-                                if (channelId == 0 && msg.messageOwner.to_id.channel_id != 0) {
-                                    channelId = msg.messageOwner.to_id.channel_id;
+                            for (int a = 1; a >= 0; a--) {
+                                ArrayList<Integer> ids = new ArrayList<>(selectedFiles[a].keySet());
+                                ArrayList<Long> random_ids = null;
+                                TLRPC.EncryptedChat currentEncryptedChat = null;
+                                int channelId = 0;
+                                if (!ids.isEmpty()) {
+                                    MessageObject msg = selectedFiles[a].get(ids.get(0));
+                                    if (channelId == 0 && msg.messageOwner.to_id.channel_id != 0) {
+                                        channelId = msg.messageOwner.to_id.channel_id;
+                                    }
                                 }
-                            }
-                            if ((int) dialog_id == 0) {
-                                currentEncryptedChat = MessagesController.getInstance().getEncryptedChat((int) (dialog_id >> 32));
-                            }
-                            if (currentEncryptedChat != null) {
-                                random_ids = new ArrayList<>();
-                                for (HashMap.Entry<Integer, MessageObject> entry : selectedFiles.entrySet()) {
-                                    MessageObject msg = entry.getValue();
-                                    if (msg.messageOwner.random_id != 0 && msg.type != 10) {
-                                        random_ids.add(msg.messageOwner.random_id);
+                                if ((int) dialog_id == 0) {
+                                    currentEncryptedChat = MessagesController.getInstance().getEncryptedChat((int) (dialog_id >> 32));
+                                }
+                                if (currentEncryptedChat != null) {
+                                    random_ids = new ArrayList<>();
+                                    for (HashMap.Entry<Integer, MessageObject> entry : selectedFiles[a].entrySet()) {
+                                        MessageObject msg = entry.getValue();
+                                        if (msg.messageOwner.random_id != 0 && msg.type != 10) {
+                                            random_ids.add(msg.messageOwner.random_id);
+                                        }
                                     }
                                 }
+                                MessagesController.getInstance().deleteMessages(ids, random_ids, currentEncryptedChat, channelId);
+                                selectedFiles[a].clear();
                             }
-                            MessagesController.getInstance().deleteMessages(ids, random_ids, currentEncryptedChat, channelId);
                             actionBar.hideActionMode();
                             actionBar.closeSearchField();
-                            selectedFiles.clear();
                             cantDeleteMessagesCount = 0;
                         }
                     });
@@ -324,14 +351,16 @@ public void didSelectDialog(DialogsActivity fragment, long did, boolean param) {
                                 }
 
                                 ArrayList<MessageObject> fmessages = new ArrayList<>();
-                                ArrayList<Integer> ids = new ArrayList<>(selectedFiles.keySet());
-                                Collections.sort(ids);
-                                for (Integer id : ids) {
-                                    if (id > 0) {
-                                        fmessages.add(selectedFiles.get(id));
+                                for (int a = 1; a >= 0; a--) {
+                                    ArrayList<Integer> ids = new ArrayList<>(selectedFiles[a].keySet());
+                                    Collections.sort(ids);
+                                    for (Integer id : ids) {
+                                        if (id > 0) {
+                                            fmessages.add(selectedFiles[a].get(id));
+                                        }
                                     }
+                                    selectedFiles[a].clear();
                                 }
-                                selectedFiles.clear();
                                 cantDeleteMessagesCount = 0;
                                 actionBar.hideActionMode();
 
@@ -353,7 +382,9 @@ public void didSelectDialog(DialogsActivity fragment, long did, boolean param) {
             }
         });
 
-        selectedFiles.clear();
+        for (int a = 1; a >= 0; a--) {
+            selectedFiles[a].clear();
+        }
         cantDeleteMessagesCount = 0;
         actionModeViews.clear();
 
@@ -372,6 +403,8 @@ public void onSearchCollapse() {
                     documentsSearchAdapter.search(null);
                 } else if (selectedMode == 3) {
                     linksSearchAdapter.search(null);
+                } else if (selectedMode == 4) {
+                    audioSearchAdapter.search(null);
                 }
                 searching = false;
                 searchWas = false;
@@ -395,6 +428,11 @@ public void onTextChanged(EditText editText) {
                         return;
                     }
                     linksSearchAdapter.search(text);
+                } else if (selectedMode == 4) {
+                    if (audioSearchAdapter == null) {
+                        return;
+                    }
+                    audioSearchAdapter.search(text);
                 }
             }
         });
@@ -407,8 +445,9 @@ public void onTextChanged(EditText editText) {
         dropDownContainer.addSubItem(files_item, LocaleController.getString("DocumentsTitle", R.string.DocumentsTitle), 0);
         if ((int) dialog_id != 0) {
             dropDownContainer.addSubItem(links_item, LocaleController.getString("LinksTitle", R.string.LinksTitle), 0);
+            dropDownContainer.addSubItem(music_item, LocaleController.getString("AudioTitle", R.string.AudioTitle), 0);
         }
-        actionBar.addView(dropDownContainer, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, AndroidUtilities.isTablet() ? 64 : 56, 0, 40, 0));
+        actionBar.addView(dropDownContainer, 0, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT, AndroidUtilities.isTablet() ? 64 : 56, 0, 40, 0));
         dropDownContainer.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -430,24 +469,18 @@ public void onClick(View view) {
         dropDownContainer.addView(dropDown, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.CENTER_VERTICAL, 16, 0, 0, 0));
 
         final ActionBarMenu actionMode = actionBar.createActionMode();
-        actionModeViews.add(actionMode.addItem(-2, R.drawable.ic_ab_back_grey, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
 
-        selectedMessagesCountTextView = new TextView(actionMode.getContext());
+        selectedMessagesCountTextView = new NumberTextView(actionMode.getContext());
         selectedMessagesCountTextView.setTextSize(18);
         selectedMessagesCountTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
         selectedMessagesCountTextView.setTextColor(0xff737373);
-        selectedMessagesCountTextView.setSingleLine(true);
-        selectedMessagesCountTextView.setLines(1);
-        selectedMessagesCountTextView.setEllipsize(TextUtils.TruncateAt.END);
-        selectedMessagesCountTextView.setPadding(AndroidUtilities.dp(11), 0, 0, AndroidUtilities.dp(2));
-        selectedMessagesCountTextView.setGravity(Gravity.CENTER_VERTICAL);
         selectedMessagesCountTextView.setOnTouchListener(new View.OnTouchListener() {
             @Override
             public boolean onTouch(View v, MotionEvent event) {
                 return true;
             }
         });
-        actionMode.addView(selectedMessagesCountTextView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f));
+        actionMode.addView(selectedMessagesCountTextView, LayoutHelper.createLinear(0, LayoutHelper.MATCH_PARENT, 1.0f, 65, 0, 0, 0));
 
         if ((int) dialog_id != 0) {
             actionModeViews.add(actionMode.addItem(forward, R.drawable.ic_ab_fwd_forward, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
@@ -455,8 +488,10 @@ public boolean onTouch(View v, MotionEvent event) {
         actionModeViews.add(actionMode.addItem(delete, R.drawable.ic_ab_fwd_delete, R.drawable.bar_selector_mode, null, AndroidUtilities.dp(54)));
 
         photoVideoAdapter = new SharedPhotoVideoAdapter(context);
-        documentsAdapter = new SharedDocumentsAdapter(context);
+        documentsAdapter = new SharedDocumentsAdapter(context, 1);
+        audioAdapter = new SharedDocumentsAdapter(context, 4);
         documentsSearchAdapter = new MediaSearchAdapter(context, 1);
+        audioSearchAdapter = new MediaSearchAdapter(context, 4);
         linksSearchAdapter = new MediaSearchAdapter(context, 3);
         linksAdapter = new SharedLinksAdapter(context);
 
@@ -472,7 +507,7 @@ public boolean onTouch(View v, MotionEvent event) {
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
             public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
-                if (selectedMode == 1 && view instanceof SharedDocumentCell) {
+                if ((selectedMode == 1 || selectedMode == 4) && view instanceof SharedDocumentCell) {
                     MediaActivity.this.onItemClick(i, view, ((SharedDocumentCell) view).getDocument(), 0);
                 } else if (selectedMode == 3 && view instanceof SharedLinkCell) {
                     MediaActivity.this.onItemClick(i, view, ((SharedLinkCell) view).getMessage(), 0);
@@ -493,8 +528,7 @@ public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCoun
                 if (searching && searchWas) {
                     return;
                 }
-                if (visibleItemCount != 0 && firstVisibleItem + visibleItemCount > totalItemCount - 2 && !sharedMediaData[selectedMode].loading && !sharedMediaData[selectedMode].endReached) {
-                    sharedMediaData[selectedMode].loading = true;
+                if (visibleItemCount != 0 && firstVisibleItem + visibleItemCount > totalItemCount - 2 && !sharedMediaData[selectedMode].loading) {
                     int type;
                     if (selectedMode == 0) {
                         type = SharedMediaQuery.MEDIA_PHOTOVIDEO;
@@ -502,17 +536,25 @@ public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCoun
                         type = SharedMediaQuery.MEDIA_FILE;
                     } else if (selectedMode == 2) {
                         type = SharedMediaQuery.MEDIA_AUDIO;
+                    } else if (selectedMode == 4) {
+                        type = SharedMediaQuery.MEDIA_MUSIC;
                     } else {
                         type = SharedMediaQuery.MEDIA_URL;
                     }
-                    SharedMediaQuery.loadMedia(dialog_id, 0, 50, sharedMediaData[selectedMode].max_id, type, true, classGuid);
+                    if (!sharedMediaData[selectedMode].endReached[0]) {
+                        sharedMediaData[selectedMode].loading = true;
+                        SharedMediaQuery.loadMedia(dialog_id, 0, 50, sharedMediaData[selectedMode].max_id[0], type, true, classGuid);
+                    } else if (mergeDialogId != 0 && !sharedMediaData[selectedMode].endReached[1]) {
+                        sharedMediaData[selectedMode].loading = true;
+                        SharedMediaQuery.loadMedia(mergeDialogId, 0, 50, sharedMediaData[selectedMode].max_id[1], type, true, classGuid);
+                    }
                 }
             }
         });
         listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
             @Override
             public boolean onItemLongClick(AdapterView<?> parent, View view, int i, long id) {
-                if (selectedMode == 1 && view instanceof SharedDocumentCell) {
+                if ((selectedMode == 1 || selectedMode == 4) && view instanceof SharedDocumentCell) {
                     SharedDocumentCell cell = (SharedDocumentCell) view;
                     MessageObject message = cell.getDocument();
                     return MediaActivity.this.onItemLongClick(message, view, 0);
@@ -564,31 +606,42 @@ public boolean onTouch(View v, MotionEvent event) {
 
         switchToCurrentSelectedMode();
 
+        if (!AndroidUtilities.isTablet()) {
+            frameLayout.addView(new PlayerView(context, this), LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 39, Gravity.TOP | Gravity.LEFT, 0, -36, 0, 0));
+        }
+
         return fragmentView;
     }
 
-    @SuppressWarnings("unchecked")
     @Override
     public void didReceivedNotification(int id, Object... args) {
         if (id == NotificationCenter.mediaDidLoaded) {
             long uid = (Long) args[0];
             int guid = (Integer) args[3];
-            if (uid == dialog_id && guid == classGuid) {
+            if (guid == classGuid) {
                 int type = (Integer) args[4];
                 sharedMediaData[type].loading = false;
                 sharedMediaData[type].totalCount = (Integer) args[1];
                 ArrayList<MessageObject> arr = (ArrayList<MessageObject>) args[2];
                 boolean enc = ((int) dialog_id) == 0;
-                for (MessageObject message : arr) {
+                int loadIndex = uid == dialog_id ? 0 : 1;
+                for (int a = 0; a < arr.size(); a++) {
+                    MessageObject message = arr.get(a);
                     sharedMediaData[type].addMessage(message, false, enc);
                 }
-                sharedMediaData[type].endReached = (Boolean) args[5];
-                if (progressView != null) {
-                    progressView.setVisibility(View.GONE);
+                sharedMediaData[type].endReached[loadIndex] = (Boolean) args[5];
+                if (loadIndex == 0 && sharedMediaData[selectedMode].messages.isEmpty() && mergeDialogId != 0) {
+                    sharedMediaData[selectedMode].loading = true;
+                    SharedMediaQuery.loadMedia(mergeDialogId, 0, 50, sharedMediaData[selectedMode].max_id[1], type, true, classGuid);
                 }
-                if (selectedMode == type && listView != null) {
-                    if (listView.getEmptyView() == null) {
-                        listView.setEmptyView(emptyView);
+                if (!sharedMediaData[selectedMode].loading) {
+                    if (progressView != null) {
+                        progressView.setVisibility(View.GONE);
+                    }
+                    if (selectedMode == type && listView != null) {
+                        if (listView.getEmptyView() == null) {
+                            listView.setEmptyView(emptyView);
+                        }
                     }
                 }
                 scrolling = true;
@@ -600,12 +653,16 @@ public void didReceivedNotification(int id, Object... args) {
                     if (documentsAdapter != null) {
                         documentsAdapter.notifyDataSetChanged();
                     }
-                }  else if (selectedMode == 3 && type == 3) {
+                } else if (selectedMode == 3 && type == 3) {
                     if (linksAdapter != null) {
                         linksAdapter.notifyDataSetChanged();
                     }
+                } else if (selectedMode == 4 && type == 4) {
+                    if (audioAdapter != null) {
+                        audioAdapter.notifyDataSetChanged();
+                    }
                 }
-                if (selectedMode == 1 || selectedMode == 3) {
+                if (selectedMode == 1 || selectedMode == 3 || selectedMode == 4) {
                     searchItem.setVisibility(!sharedMediaData[selectedMode].messages.isEmpty() && !searching ? View.VISIBLE : View.GONE);
                 }
             }
@@ -615,8 +672,13 @@ public void didReceivedNotification(int id, Object... args) {
                 currentChat = MessagesController.getInstance().getChat(-(int) dialog_id);
             }
             int channelId = (Integer) args[1];
+            int loadIndex = 0;
             if (ChatObject.isChannel(currentChat)) {
-                if (channelId == 0 || channelId != currentChat.id) {
+                if (channelId == 0 && mergeDialogId != 0) {
+                    loadIndex = 1;
+                } else if (channelId == currentChat.id) {
+                    loadIndex = 0;
+                } else {
                     return;
                 }
             } else if (channelId != 0) {
@@ -626,7 +688,7 @@ public void didReceivedNotification(int id, Object... args) {
             boolean updated = false;
             for (Integer ids : markAsDeletedMessages) {
                 for (SharedMediaData data : sharedMediaData) {
-                    if (data.deleteMessage(ids)) {
+                    if (data.deleteMessage(ids, loadIndex)) {
                         updated = true;
                     }
                 }
@@ -642,7 +704,10 @@ public void didReceivedNotification(int id, Object... args) {
                 if (linksAdapter != null) {
                     linksAdapter.notifyDataSetChanged();
                 }
-                if (selectedMode == 1 || selectedMode == 3) {
+                if (audioAdapter != null) {
+                    audioAdapter.notifyDataSetChanged();
+                }
+                if (selectedMode == 1 || selectedMode == 3 || selectedMode == 4) {
                     searchItem.setVisibility(!sharedMediaData[selectedMode].messages.isEmpty() && !searching ? View.VISIBLE : View.GONE);
                 }
             }
@@ -675,7 +740,10 @@ public void didReceivedNotification(int id, Object... args) {
                     if (linksAdapter != null) {
                         linksAdapter.notifyDataSetChanged();
                     }
-                    if (selectedMode == 1 || selectedMode == 3) {
+                    if (audioAdapter != null) {
+                        audioAdapter.notifyDataSetChanged();
+                    }
+                    if (selectedMode == 1 || selectedMode == 3 || selectedMode == 4) {
                         searchItem.setVisibility(!sharedMediaData[selectedMode].messages.isEmpty() && !searching ? View.VISIBLE : View.GONE);
                     }
                 }
@@ -760,6 +828,8 @@ public void updatePhotoAtIndex(int index) {
                         object.parentView = listView;
                         object.imageReceiver = imageView.getImageReceiver();
                         object.thumb = object.imageReceiver.getBitmap();
+                        object.parentView.getLocationInWindow(coords);
+                        object.clipTopAddition = AndroidUtilities.dp(40);
                         return object;
                     }
                 }
@@ -786,7 +856,7 @@ public void willHidePhotoViewer() { }
     public void setPhotoChecked(int index) { }
 
     @Override
-    public void cancelButtonPressed() { }
+    public boolean cancelButtonPressed() { return true; }
 
     @Override
     public void sendButtonPressed(int index) { }
@@ -794,6 +864,13 @@ public void sendButtonPressed(int index) { }
     @Override
     public int getSelectedCount() { return 0; }
 
+    public void setChatInfo(TLRPC.ChatFull chatInfo) {
+        info = chatInfo;
+        if (info != null && info.migrated_from_chat_id != 0) {
+            mergeDialogId = -info.migrated_from_chat_id;
+        }
+    }
+
     private void switchToCurrentSelectedMode() {
         if (searching && searchWas) {
             if (listView != null) {
@@ -803,6 +880,9 @@ private void switchToCurrentSelectedMode() {
                 } else if (selectedMode == 3) {
                     listView.setAdapter(linksSearchAdapter);
                     linksSearchAdapter.notifyDataSetChanged();
+                } else if (selectedMode == 4) {
+                    listView.setAdapter(audioSearchAdapter);
+                    audioSearchAdapter.notifyDataSetChanged();
                 }
             }
             if (emptyTextView != null) {
@@ -829,15 +909,22 @@ private void switchToCurrentSelectedMode() {
                 }
                 listView.setVisibility(View.VISIBLE);
                 listView.setPadding(0, 0, 0, AndroidUtilities.dp(4));
-            } else if (selectedMode == 1) {
-                listView.setAdapter(documentsAdapter);
-                dropDown.setText(LocaleController.getString("DocumentsTitle", R.string.DocumentsTitle));
-                emptyImageView.setImageResource(R.drawable.tip2);
-                emptyTextView.setText(LocaleController.getString("NoSharedFiles", R.string.NoSharedFiles));
+            } else if (selectedMode == 1 || selectedMode == 4) {
+                if (selectedMode == 1) {
+                    listView.setAdapter(documentsAdapter);
+                    dropDown.setText(LocaleController.getString("DocumentsTitle", R.string.DocumentsTitle));
+                    emptyImageView.setImageResource(R.drawable.tip2);
+                    emptyTextView.setText(LocaleController.getString("NoSharedFiles", R.string.NoSharedFiles));
+                } else if (selectedMode == 4) {
+                    listView.setAdapter(audioAdapter);
+                    dropDown.setText(LocaleController.getString("AudioTitle", R.string.AudioTitle));
+                    emptyImageView.setImageResource(R.drawable.tip4);
+                    emptyTextView.setText(LocaleController.getString("NoSharedAudio", R.string.NoSharedAudio));
+                }
                 searchItem.setVisibility(!sharedMediaData[selectedMode].messages.isEmpty() ? View.VISIBLE : View.GONE);
-                if (!sharedMediaData[selectedMode].loading && !sharedMediaData[selectedMode].endReached && sharedMediaData[selectedMode].messages.isEmpty()) {
+                if (!sharedMediaData[selectedMode].loading && !sharedMediaData[selectedMode].endReached[0] && sharedMediaData[selectedMode].messages.isEmpty()) {
                     sharedMediaData[selectedMode].loading = true;
-                    SharedMediaQuery.loadMedia(dialog_id, 0, 50, 0, SharedMediaQuery.MEDIA_FILE, true, classGuid);
+                    SharedMediaQuery.loadMedia(dialog_id, 0, 50, 0, selectedMode == 1 ? SharedMediaQuery.MEDIA_FILE : SharedMediaQuery.MEDIA_MUSIC, true, classGuid);
                 }
                 listView.setVisibility(View.VISIBLE);
                 if (sharedMediaData[selectedMode].loading && sharedMediaData[selectedMode].messages.isEmpty()) {
@@ -855,7 +942,7 @@ private void switchToCurrentSelectedMode() {
                 emptyImageView.setImageResource(R.drawable.tip3);
                 emptyTextView.setText(LocaleController.getString("NoSharedLinks", R.string.NoSharedLinks));
                 searchItem.setVisibility(!sharedMediaData[3].messages.isEmpty() ? View.VISIBLE : View.GONE);
-                if (!sharedMediaData[selectedMode].loading && !sharedMediaData[selectedMode].endReached && sharedMediaData[selectedMode].messages.isEmpty()) {
+                if (!sharedMediaData[selectedMode].loading && !sharedMediaData[selectedMode].endReached[0] && sharedMediaData[selectedMode].messages.isEmpty()) {
                     sharedMediaData[selectedMode].loading = true;
                     SharedMediaQuery.loadMedia(dialog_id, 0, 50, 0, SharedMediaQuery.MEDIA_URL, true, classGuid);
                 }
@@ -877,23 +964,20 @@ private boolean onItemLongClick(MessageObject item, View view, int a) {
         if (actionBar.isActionModeShowed()) {
             return false;
         }
-        selectedFiles.put(item.getId(), item);
+        AndroidUtilities.hideKeyboard(getParentActivity().getCurrentFocus());
+        selectedFiles[item.getDialogId() == dialog_id ? 0 : 1].put(item.getId(), item);
         if (!item.canDeleteMessage(null)) {
             cantDeleteMessagesCount++;
         }
         actionBar.createActionMode().getItem(delete).setVisibility(cantDeleteMessagesCount == 0 ? View.VISIBLE : View.GONE);
-        selectedMessagesCountTextView.setText(String.format("%d", selectedFiles.size()));
+        selectedMessagesCountTextView.setNumber(1, false);
         if (Build.VERSION.SDK_INT >= 11) {
             AnimatorSetProxy animatorSet = new AnimatorSetProxy();
             ArrayList<Object> animators = new ArrayList<>();
             for (int i = 0; i < actionModeViews.size(); i++) {
                 View view2 = actionModeViews.get(i);
                 AndroidUtilities.clearDrawableAnimation(view2);
-                if (i < 1) {
-                    animators.add(ObjectAnimatorProxy.ofFloat(view2, "translationX", -AndroidUtilities.dp(56), 0));
-                } else {
-                    animators.add(ObjectAnimatorProxy.ofFloat(view2, "scaleY", 0.1f, 1.0f));
-                }
+                animators.add(ObjectAnimatorProxy.ofFloat(view2, "scaleY", 0.1f, 1.0f));
             }
             animatorSet.playTogether(animators);
             animatorSet.setDuration(250);
@@ -916,41 +1000,42 @@ private void onItemClick(int index, View view, MessageObject message, int a) {
             return;
         }
         if (actionBar.isActionModeShowed()) {
-            if (selectedFiles.containsKey(message.getId())) {
-                selectedFiles.remove(message.getId());
+            int loadIndex = message.getDialogId() == dialog_id ? 0 : 1;
+            if (selectedFiles[loadIndex].containsKey(message.getId())) {
+                selectedFiles[loadIndex].remove(message.getId());
                 if (!message.canDeleteMessage(null)) {
                     cantDeleteMessagesCount--;
                 }
             } else {
-                selectedFiles.put(message.getId(), message);
+                selectedFiles[loadIndex].put(message.getId(), message);
                 if (!message.canDeleteMessage(null)) {
                     cantDeleteMessagesCount++;
                 }
             }
-            if (selectedFiles.isEmpty()) {
+            if (selectedFiles[0].isEmpty() && selectedFiles[1].isEmpty()) {
                 actionBar.hideActionMode();
             } else {
-                selectedMessagesCountTextView.setText(String.format("%d", selectedFiles.size()));
+                selectedMessagesCountTextView.setNumber(selectedFiles[0].size() + selectedFiles[1].size(), true);
             }
             actionBar.createActionMode().getItem(delete).setVisibility(cantDeleteMessagesCount == 0 ? View.VISIBLE : View.GONE);
             scrolling = false;
             if (view instanceof SharedDocumentCell) {
-                ((SharedDocumentCell) view).setChecked(selectedFiles.containsKey(message.getId()), true);
+                ((SharedDocumentCell) view).setChecked(selectedFiles[loadIndex].containsKey(message.getId()), true);
             } else if (view instanceof SharedPhotoVideoCell) {
-                ((SharedPhotoVideoCell) view).setChecked(a, selectedFiles.containsKey(message.getId()), true);
+                ((SharedPhotoVideoCell) view).setChecked(a, selectedFiles[loadIndex].containsKey(message.getId()), true);
             } else if (view instanceof SharedLinkCell) {
-                ((SharedLinkCell) view).setChecked(selectedFiles.containsKey(message.getId()), true);
+                ((SharedLinkCell) view).setChecked(selectedFiles[loadIndex].containsKey(message.getId()), true);
             }
         } else {
             if (selectedMode == 0) {
                 PhotoViewer.getInstance().setParentActivity(getParentActivity());
-                PhotoViewer.getInstance().openPhoto(sharedMediaData[selectedMode].messages, index, this);
-            } else if (selectedMode == 1) {
+                PhotoViewer.getInstance().openPhoto(sharedMediaData[selectedMode].messages, index, dialog_id, mergeDialogId, this);
+            } else if (selectedMode == 1 || selectedMode == 4) {
                 if (view instanceof SharedDocumentCell) {
                     SharedDocumentCell cell = (SharedDocumentCell) view;
                     if (cell.isLoaded()) {
                         if (message.isMusic()) {
-                            if (MediaController.getInstance().setPlaylist(sharedMediaData[1].messages, message)) {
+                            if (MediaController.getInstance().setPlaylist(sharedMediaData[selectedMode].messages, message)) {
                                 return;
                             }
                         }
@@ -1056,6 +1141,12 @@ private void fixLayoutInternal() {
         WindowManager manager = (WindowManager) ApplicationLoader.applicationContext.getSystemService(Activity.WINDOW_SERVICE);
         int rotation = manager.getDefaultDisplay().getRotation();
 
+        if (!AndroidUtilities.isTablet() && ApplicationLoader.applicationContext.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
+            selectedMessagesCountTextView.setTextSize(18);
+        } else {
+            selectedMessagesCountTextView.setTextSize(20);
+        }
+
         if (AndroidUtilities.isTablet()) {
             columnsCount = 4;
             emptyTextView.setPadding(AndroidUtilities.dp(40), 0, AndroidUtilities.dp(40), AndroidUtilities.dp(128));
@@ -1104,7 +1195,7 @@ public boolean isRowEnabled(int section, int row) {
 
         @Override
         public int getSectionCount() {
-            return sharedMediaData[3].sections.size() + (sharedMediaData[3].sections.isEmpty() || sharedMediaData[3].endReached ? 0 : 1);
+            return sharedMediaData[3].sections.size() + (sharedMediaData[3].sections.isEmpty() || sharedMediaData[3].endReached[0] && sharedMediaData[3].endReached[1] ? 0 : 1);
         }
 
         @Override
@@ -1124,7 +1215,7 @@ public View getSectionHeaderView(int section, View convertView, ViewGroup parent
                 String name = sharedMediaData[3].sections.get(section);
                 ArrayList<MessageObject> messageObjects = sharedMediaData[3].sectionArrays.get(name);
                 MessageObject messageObject = messageObjects.get(0);
-                ((GreySectionCell) convertView).setText(LocaleController.formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
+                ((GreySectionCell) convertView).setText(LocaleController.getInstance().formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
             }
             return convertView;
         }
@@ -1139,7 +1230,7 @@ public View getItemView(int section, int position, View convertView, ViewGroup p
                         convertView = new GreySectionCell(mContext);
                     }
                     MessageObject messageObject = messageObjects.get(0);
-                    ((GreySectionCell) convertView).setText(LocaleController.formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
+                    ((GreySectionCell) convertView).setText(LocaleController.getInstance().formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
                 } else {
                     if (convertView == null) {
                         convertView = new SharedLinkCell(mContext);
@@ -1159,7 +1250,7 @@ public boolean canPerformActions() {
                     MessageObject messageObject = messageObjects.get(position - 1);
                     sharedLinkCell.setLink(messageObject, position != messageObjects.size() || section == sharedMediaData[3].sections.size() - 1 && sharedMediaData[3].loading);
                     if (actionBar.isActionModeShowed()) {
-                        sharedLinkCell.setChecked(selectedFiles.containsKey(messageObject.getId()), !scrolling);
+                        sharedLinkCell.setChecked(selectedFiles[messageObject.getDialogId() == dialog_id ? 0 : 1].containsKey(messageObject.getId()), !scrolling);
                     } else {
                         sharedLinkCell.setChecked(false, !scrolling);
                     }
@@ -1191,10 +1282,13 @@ public int getViewTypeCount() {
     }
 
     private class SharedDocumentsAdapter extends BaseSectionsAdapter {
+
         private Context mContext;
+        private int currentType;
 
-        public SharedDocumentsAdapter(Context context) {
+        public SharedDocumentsAdapter(Context context, int type) {
             mContext = context;
+            currentType = type;
         }
 
         @Override
@@ -1209,13 +1303,13 @@ public boolean isRowEnabled(int section, int row) {
 
         @Override
         public int getSectionCount() {
-            return sharedMediaData[1].sections.size() + (sharedMediaData[1].sections.isEmpty() || sharedMediaData[1].endReached ? 0 : 1);
+            return sharedMediaData[currentType].sections.size() + (sharedMediaData[currentType].sections.isEmpty() || sharedMediaData[currentType].endReached[0] && sharedMediaData[currentType].endReached[1] ? 0 : 1);
         }
 
         @Override
         public int getCountForSection(int section) {
-            if (section < sharedMediaData[1].sections.size()) {
-                return sharedMediaData[1].sectionArrays.get(sharedMediaData[1].sections.get(section)).size() + 1;
+            if (section < sharedMediaData[currentType].sections.size()) {
+                return sharedMediaData[currentType].sectionArrays.get(sharedMediaData[currentType].sections.get(section)).size() + 1;
             }
             return 1;
         }
@@ -1225,35 +1319,35 @@ public View getSectionHeaderView(int section, View convertView, ViewGroup parent
             if (convertView == null) {
                 convertView = new GreySectionCell(mContext);
             }
-            if (section < sharedMediaData[1].sections.size()) {
-                String name = sharedMediaData[1].sections.get(section);
-                ArrayList<MessageObject> messageObjects = sharedMediaData[1].sectionArrays.get(name);
+            if (section < sharedMediaData[currentType].sections.size()) {
+                String name = sharedMediaData[currentType].sections.get(section);
+                ArrayList<MessageObject> messageObjects = sharedMediaData[currentType].sectionArrays.get(name);
                 MessageObject messageObject = messageObjects.get(0);
-                ((GreySectionCell) convertView).setText(LocaleController.formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
+                ((GreySectionCell) convertView).setText(LocaleController.getInstance().formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
             }
             return convertView;
         }
 
         @Override
         public View getItemView(int section, int position, View convertView, ViewGroup parent) {
-            if (section < sharedMediaData[1].sections.size()) {
-                String name = sharedMediaData[1].sections.get(section);
-                ArrayList<MessageObject> messageObjects = sharedMediaData[1].sectionArrays.get(name);
+            if (section < sharedMediaData[currentType].sections.size()) {
+                String name = sharedMediaData[currentType].sections.get(section);
+                ArrayList<MessageObject> messageObjects = sharedMediaData[currentType].sectionArrays.get(name);
                 if (position == 0) {
                     if (convertView == null) {
                         convertView = new GreySectionCell(mContext);
                     }
                     MessageObject messageObject = messageObjects.get(0);
-                    ((GreySectionCell) convertView).setText(LocaleController.formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
+                    ((GreySectionCell) convertView).setText(LocaleController.getInstance().formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
                 } else {
                     if (convertView == null) {
                         convertView = new SharedDocumentCell(mContext);
                     }
                     SharedDocumentCell sharedDocumentCell = (SharedDocumentCell) convertView;
                     MessageObject messageObject = messageObjects.get(position - 1);
-                    sharedDocumentCell.setDocument(messageObject, position != messageObjects.size() || section == sharedMediaData[1].sections.size() - 1 && sharedMediaData[1].loading);
+                    sharedDocumentCell.setDocument(messageObject, position != messageObjects.size() || section == sharedMediaData[currentType].sections.size() - 1 && sharedMediaData[currentType].loading);
                     if (actionBar.isActionModeShowed()) {
-                        sharedDocumentCell.setChecked(selectedFiles.containsKey(messageObject.getId()), !scrolling);
+                        sharedDocumentCell.setChecked(selectedFiles[messageObject.getDialogId() == dialog_id ? 0 : 1].containsKey(messageObject.getId()), !scrolling);
                     } else {
                         sharedDocumentCell.setChecked(false, !scrolling);
                     }
@@ -1268,7 +1362,7 @@ public View getItemView(int section, int position, View convertView, ViewGroup p
 
         @Override
         public int getItemViewType(int section, int position) {
-            if (section < sharedMediaData[1].sections.size()) {
+            if (section < sharedMediaData[currentType].sections.size()) {
                 if (position == 0) {
                     return 0;
                 } else {
@@ -1303,7 +1397,7 @@ public boolean isRowEnabled(int section, int row) {
 
         @Override
         public int getSectionCount() {
-            return sharedMediaData[0].sections.size() + (sharedMediaData[0].sections.isEmpty() || sharedMediaData[0].endReached ? 0 : 1);
+            return sharedMediaData[0].sections.size() + (sharedMediaData[0].sections.isEmpty() || sharedMediaData[0].endReached[0] && sharedMediaData[0].endReached[1] ? 0 : 1);
         }
 
         @Override
@@ -1324,7 +1418,7 @@ public View getSectionHeaderView(int section, View convertView, ViewGroup parent
                 String name = sharedMediaData[0].sections.get(section);
                 ArrayList<MessageObject> messageObjects = sharedMediaData[0].sectionArrays.get(name);
                 MessageObject messageObject = messageObjects.get(0);
-                ((SharedMediaSectionCell) convertView).setText(LocaleController.formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
+                ((SharedMediaSectionCell) convertView).setText(LocaleController.getInstance().formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
             }
             return convertView;
         }
@@ -1339,7 +1433,7 @@ public View getItemView(int section, int position, View convertView, ViewGroup p
                         convertView = new SharedMediaSectionCell(mContext);
                     }
                     MessageObject messageObject = messageObjects.get(0);
-                    ((SharedMediaSectionCell) convertView).setText(LocaleController.formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
+                    ((SharedMediaSectionCell) convertView).setText(LocaleController.getInstance().formatterMonthYear.format((long) messageObject.messageOwner.date * 1000).toUpperCase());
                 } else {
                     SharedPhotoVideoCell cell;
                     if (convertView == null) {
@@ -1373,7 +1467,7 @@ public boolean didLongClickItem(SharedPhotoVideoCell cell, int index, MessageObj
                             cell.setItem(a, sharedMediaData[0].messages.indexOf(messageObject), messageObject);
 
                             if (actionBar.isActionModeShowed()) {
-                                cell.setChecked(a, selectedFiles.containsKey(messageObject.getId()), !scrolling);
+                                cell.setChecked(a, selectedFiles[messageObject.getDialogId() == dialog_id ? 0 : 1].containsKey(messageObject.getId()), !scrolling);
                             } else {
                                 cell.setChecked(a, false, !scrolling);
                             }
@@ -1423,8 +1517,8 @@ public MediaSearchAdapter(Context context, int type) {
             currentType = type;
         }
 
-        public void queryServerSearch(final String query, final int max_id) {
-            int uid = (int) dialog_id;
+        public void queryServerSearch(final String query, final int max_id, long did) {
+            int uid = (int) did;
             if (uid == 0) {
                 return;
             }
@@ -1446,6 +1540,8 @@ public void queryServerSearch(final String query, final int max_id) {
                 req.filter = new TLRPC.TL_inputMessagesFilterDocument();
             } else if (currentType == 3) {
                 req.filter = new TLRPC.TL_inputMessagesFilterUrl();
+            } else if (currentType == 4) {
+                req.filter = new TLRPC.TL_inputMessagesFilterAudioDocuments();
             }
             req.q = query;
             req.peer = MessagesController.getInputPeer(uid);
@@ -1459,7 +1555,11 @@ public void run(TLObject response, TLRPC.TL_error error) {
                     final ArrayList<MessageObject> messageObjects = new ArrayList<>();
                     if (error == null) {
                         TLRPC.messages_Messages res = (TLRPC.messages_Messages) response;
-                        for (TLRPC.Message message : res.messages) {
+                        for (int a = 0; a < res.messages.size(); a++) {
+                            TLRPC.Message message = res.messages.get(a);
+                            if (message.id > max_id) {
+                                continue;
+                            }
                             messageObjects.add(new MessageObject(message, null, false));
                         }
                     }
@@ -1513,14 +1613,14 @@ public void run() {
                     if (!sharedMediaData[currentType].messages.isEmpty()) {
                         if (currentType == 1) {
                             MessageObject messageObject = sharedMediaData[currentType].messages.get(sharedMediaData[currentType].messages.size() - 1);
-                            queryServerSearch(query, messageObject.getId());
-                        } else if (currentType == 3) {
-                            queryServerSearch(query, 0);
+                            queryServerSearch(query, messageObject.getId(), messageObject.getDialogId());
+                        } else if (currentType == 3 || currentType == 4) {
+                            queryServerSearch(query, 0, dialog_id);
                         }
                     }
                     if (currentType == 1) {
                         final ArrayList<MessageObject> copy = new ArrayList<>();
-                        copy.addAll(sharedMediaData[1].messages);
+                        copy.addAll(sharedMediaData[currentType].messages);
                         Utilities.searchQueue.postRunnable(new Runnable() {
                             @Override
                             public void run() {
@@ -1536,12 +1636,13 @@ public void run() {
                                 String search[] = new String[1 + (search2 != null ? 1 : 0)];
                                 search[0] = search1;
                                 if (search2 != null) {
-                                    search[1] = search2;
+                                    search[currentType] = search2;
                                 }
 
                                 ArrayList<MessageObject> resultArray = new ArrayList<>();
 
-                                for (MessageObject messageObject : copy) {
+                                for (int a = 0; a < copy.size(); a++) {
+                                    MessageObject messageObject = copy.get(a);
                                     for (String q : search) {
                                         String name = messageObject.getDocumentName();
                                         if (name == null || name.length() == 0) {
@@ -1625,7 +1726,7 @@ public boolean hasStableIds() {
 
         @Override
         public View getView(int i, View view, ViewGroup viewGroup) {
-            if (currentType == 1) {
+            if (currentType == 1 || currentType == 4) {
                 if (view == null) {
                     view = new SharedDocumentCell(mContext);
                 }
@@ -1633,7 +1734,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                 MessageObject messageObject = getItem(i);
                 sharedDocumentCell.setDocument(messageObject, i != getCount() - 1);
                 if (actionBar.isActionModeShowed()) {
-                    sharedDocumentCell.setChecked(selectedFiles.containsKey(messageObject.getId()), !scrolling);
+                    sharedDocumentCell.setChecked(selectedFiles[messageObject.getDialogId() == dialog_id ? 0 : 1].containsKey(messageObject.getId()), !scrolling);
                 } else {
                     sharedDocumentCell.setChecked(false, !scrolling);
                 }
@@ -1656,7 +1757,7 @@ public boolean canPerformActions() {
                 MessageObject messageObject = getItem(i);
                 sharedLinkCell.setLink(messageObject, i != getCount() - 1);
                 if (actionBar.isActionModeShowed()) {
-                    sharedLinkCell.setChecked(selectedFiles.containsKey(messageObject.getId()), !scrolling);
+                    sharedLinkCell.setChecked(selectedFiles[messageObject.getDialogId() == dialog_id ? 0 : 1].containsKey(messageObject.getId()), !scrolling);
                 } else {
                     sharedLinkCell.setChecked(false, !scrolling);
                 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/NotificationsSettingsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/NotificationsSettingsActivity.java
index 57d4d1e76..c170ba744 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/NotificationsSettingsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/NotificationsSettingsActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -52,6 +52,7 @@
 import org.telegram.ui.Components.LayoutHelper;
 
 public class NotificationsSettingsActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
+
     private ListView listView;
     private boolean reseting = false;
 
@@ -186,7 +187,7 @@ public void onItemClick(int id) {
         listView.setAdapter(new ListAdapter(context));
         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
             @Override
-            public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+            public void onItemClick(AdapterView<?> adapterView, final View view, final int i, long l) {
                 boolean enabled = false;
                 if (i == messageAlertRow || i == groupAlertRow) {
                     SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
@@ -356,7 +357,12 @@ public void onClick(DialogInterface dialogInterface, int i) {
                                 listView.invalidateViews();
                             }
                         });
-                        builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                        builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                ((TextCheckCell) view).setChecked(true);
+                            }
+                        });
                         showDialog(builder.create());
                     }
                 } else if (i == messageLedRow || i == groupLedRow) {
@@ -384,13 +390,15 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         public void onClick(DialogInterface dialogInterface, int which) {
                             final SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
                             SharedPreferences.Editor editor = preferences.edit();
+                            TextColorCell textCell = (TextColorCell) view;
                             if (i == messageLedRow) {
                                 editor.putInt("MessagesLed", colorPickerView.getColor());
+                                textCell.setTextAndColor(LocaleController.getString("LedColor", R.string.LedColor), colorPickerView.getColor(), true);
                             } else if (i == groupLedRow) {
                                 editor.putInt("GroupLed", colorPickerView.getColor());
+                                textCell.setTextAndColor(LocaleController.getString("LedColor", R.string.LedColor), colorPickerView.getColor(), true);
                             }
                             editor.commit();
-                            listView.invalidateViews();
                         }
                     });
                     builder.setNeutralButton(LocaleController.getString("LedDisabled", R.string.LedDisabled), new DialogInterface.OnClickListener() {
@@ -398,10 +406,13 @@ public void onClick(DialogInterface dialogInterface, int which) {
                         public void onClick(DialogInterface dialog, int which) {
                             final SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
                             SharedPreferences.Editor editor = preferences.edit();
+                            TextColorCell textCell = (TextColorCell) view;
                             if (i == messageLedRow) {
                                 editor.putInt("MessagesLed", 0);
+                                textCell.setTextAndColor(LocaleController.getString("LedColor", R.string.LedColor), 0, true);
                             } else if (i == groupLedRow) {
                                 editor.putInt("GroupLed", 0);
+                                textCell.setTextAndColor(LocaleController.getString("LedColor", R.string.LedColor), 0, true);
                             }
                             editor.commit();
                             listView.invalidateViews();
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PasscodeActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PasscodeActivity.java
index a6abe8cd4..a308df84c 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PasscodeActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PasscodeActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -15,6 +15,7 @@
 import android.graphics.Typeface;
 import android.os.Build;
 import android.os.Vibrator;
+import android.support.v4.hardware.fingerprint.FingerprintManagerCompat;
 import android.text.Editable;
 import android.text.InputFilter;
 import android.text.InputType;
@@ -76,6 +77,7 @@
     private int passcodeRow;
     private int changePasscodeRow;
     private int passcodeDetailRow;
+    private int fingerprintRow;
     private int autoLockRow;
     private int autoLockDetailRow;
     private int rowCount;
@@ -394,6 +396,10 @@ public void onClick(DialogInterface dialog, int which) {
                             }
                         });
                         showDialog(builder.create());
+                    } else if (i == fingerprintRow) {
+                        UserConfig.useFingerprint = !UserConfig.useFingerprint;
+                        UserConfig.saveConfig(false);
+                        ((TextCheckCell) view).setChecked(UserConfig.useFingerprint);
                     }
                 }
             });
@@ -440,9 +446,20 @@ private void updateRows() {
         changePasscodeRow = rowCount++;
         passcodeDetailRow = rowCount++;
         if (UserConfig.passcodeHash.length() > 0) {
+            try {
+                if (Build.VERSION.SDK_INT >= 23) {
+                    FingerprintManagerCompat fingerprintManager = FingerprintManagerCompat.from(ApplicationLoader.applicationContext);
+                    if (fingerprintManager.isHardwareDetected()) {
+                        fingerprintRow = rowCount++;
+                    }
+                }
+            } catch (Throwable e) {
+                FileLog.e("tmessages", e);
+            }
             autoLockRow = rowCount++;
             autoLockDetailRow = rowCount++;
         } else {
+            fingerprintRow = -1;
             autoLockRow = -1;
             autoLockDetailRow = -1;
         }
@@ -465,9 +482,8 @@ public boolean onPreDraw() {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        super.onOpenAnimationEnd();
-        if (type != 0) {
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen && type != 0) {
             AndroidUtilities.showKeyboard(passwordEditText);
         }
     }
@@ -599,7 +615,7 @@ public boolean areAllItemsEnabled() {
 
         @Override
         public boolean isEnabled(int i) {
-            return i == passcodeRow || i == autoLockRow || UserConfig.passcodeHash.length() != 0 && i == changePasscodeRow;
+            return i == passcodeRow || i == fingerprintRow || i == autoLockRow || UserConfig.passcodeHash.length() != 0 && i == changePasscodeRow;
         }
 
         @Override
@@ -634,6 +650,8 @@ public View getView(int i, View view, ViewGroup viewGroup) {
 
                 if (i == passcodeRow) {
                     textCell.setTextAndCheck(LocaleController.getString("Passcode", R.string.Passcode), UserConfig.passcodeHash.length() > 0, true);
+                } else if (i == fingerprintRow) {
+                    textCell.setTextAndCheck(LocaleController.getString("UnlockFingerprint", R.string.UnlockFingerprint), UserConfig.useFingerprint, true);
                 }
             } else if (viewType == 1) {
                 if (view == null) {
@@ -679,7 +697,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
 
         @Override
         public int getItemViewType(int i) {
-            if (i == passcodeRow) {
+            if (i == passcodeRow || i == fingerprintRow) {
                 return 0;
             } else if (i == changePasscodeRow || i == autoLockRow) {
                 return 1;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoAlbumPickerActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoAlbumPickerActivity.java
index aad3f361b..309949c36 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoAlbumPickerActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoAlbumPickerActivity.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoCropActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoCropActivity.java
index 34f2b0b97..b4cc7b0cb 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoCropActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoCropActivity.java
@@ -3,7 +3,7 @@
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -21,6 +21,7 @@
 import android.widget.FrameLayout;
 
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.Bitmaps;
 import org.telegram.messenger.ImageLoader;
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.LocaleController;
@@ -35,7 +36,7 @@
 public class PhotoCropActivity extends BaseFragment {
 
     public interface PhotoEditActivityDelegate {
-        void didFinishEdit(Bitmap bitmap, Bundle args);
+        void didFinishEdit(Bitmap bitmap);
     }
 
     private class PhotoCropView extends FrameLayout {
@@ -315,12 +316,12 @@ public Bitmap getBitmap() {
                 sizeY = imageToCrop.getHeight() - y;
             }
             try {
-                return Bitmap.createBitmap(imageToCrop, x, y, sizeX, sizeY);
+                return Bitmaps.createBitmap(imageToCrop, x, y, sizeX, sizeY);
             } catch (Throwable e) {
                 FileLog.e("tmessags", e);
                 System.gc();
                 try {
-                    return Bitmap.createBitmap(imageToCrop, x, y, sizeX, sizeY);
+                    return Bitmaps.createBitmap(imageToCrop, x, y, sizeX, sizeY);
                 } catch (Throwable e2) {
                     FileLog.e("tmessages", e2);
                 }
@@ -331,8 +332,12 @@ public Bitmap getBitmap() {
         @Override
         protected void onDraw(Canvas canvas) {
             if (drawable != null) {
-                drawable.setBounds(bitmapX, bitmapY, bitmapX + bitmapWidth, bitmapY + bitmapHeight);
-                drawable.draw(canvas);
+                try {
+                    drawable.setBounds(bitmapX, bitmapY, bitmapX + bitmapWidth, bitmapY + bitmapHeight);
+                    drawable.draw(canvas);
+                } catch (Throwable e) {
+                    FileLog.e("tmessages", e);
+                }
             }
             canvas.drawRect(bitmapX, bitmapY, bitmapX + bitmapWidth, rectY, halfPaint);
             canvas.drawRect(bitmapX, rectY, rectX, rectY + rectSizeY, halfPaint);
@@ -375,15 +380,6 @@ public PhotoCropActivity(Bundle args) {
         super(args);
     }
 
-    public PhotoCropActivity(Bundle args, Bitmap bitmap, String key) {
-        super(args);
-        imageToCrop = bitmap;
-        bitmapKey = key;
-        if (imageToCrop != null && key != null) {
-            ImageLoader.getInstance().incrementUseCount(key);
-        }
-    }
-
     @Override
     public boolean onFragmentCreate() {
         swipeBackEnabled = false;
@@ -418,7 +414,6 @@ public boolean onFragmentCreate() {
     @Override
     public void onFragmentDestroy() {
         super.onFragmentDestroy();
-        drawable = null;
         if (bitmapKey != null) {
             if (ImageLoader.getInstance().decrementUseCount(bitmapKey) && !ImageLoader.getInstance().isInCache(bitmapKey)) {
                 bitmapKey = null;
@@ -428,6 +423,7 @@ public void onFragmentDestroy() {
             imageToCrop.recycle();
             imageToCrop = null;
         }
+        drawable = null;
     }
 
     @Override
@@ -448,7 +444,7 @@ public void onItemClick(int id) {
                         if (bitmap == imageToCrop) {
                             sameBitmap = true;
                         }
-                        delegate.didFinishEdit(bitmap, getArguments());
+                        delegate.didFinishEdit(bitmap);
                         doneButtonPressed = true;
                     }
                     finishFragment();
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoPickerActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoPickerActivity.java
index 984b77f84..3961e1bd6 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoPickerActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoPickerActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -34,6 +34,7 @@
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.AnimationCompat.ViewProxy;
 import org.telegram.messenger.LocaleController;
 import org.telegram.messenger.MediaController;
 import org.telegram.messenger.MessagesStorage;
@@ -294,6 +295,9 @@ public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
                     if (i < 0 || i >= arrayList.size()) {
                         return;
                     }
+                    if (searchItem != null) {
+                        AndroidUtilities.hideKeyboard(searchItem.getSearchField());
+                    }
                     PhotoViewer.getInstance().setParentActivity(getParentActivity());
                     PhotoViewer.getInstance().openPhotoForSelect(arrayList, i, singlePhoto ? 1 : 0, PhotoPickerActivity.this, chatActivity);
                 }
@@ -498,9 +502,18 @@ private PhotoPickerPhotoCell getCellForIndex(int index) {
             PhotoViewer.PlaceProviderObject object = new PhotoViewer.PlaceProviderObject();
             object.viewX = coords[0];
             object.viewY = coords[1] - AndroidUtilities.statusBarHeight;
+            if (Build.VERSION.SDK_INT < 11) {
+                float scale = ViewProxy.getScaleX(cell.photoImage);
+                if (scale != 1) {
+                    int width = cell.photoImage.getMeasuredWidth();
+                    object.viewX += (width - width * scale) / 2;
+                    object.viewY += (width - width * scale) / 2;
+                }
+            }
             object.parentView = listView;
             object.imageReceiver = cell.photoImage.getImageReceiver();
             object.thumb = object.imageReceiver.getBitmap();
+            object.scale = ViewProxy.getScaleX(cell.photoImage);
             cell.checkBox.setVisibility(View.GONE);
             return object;
         }
@@ -646,7 +659,7 @@ public void setPhotoChecked(int index) {
             View view = listView.getChildAt(a);
             int num = (Integer) view.getTag();
             if (num == index) {
-                ((PhotoPickerPhotoCell) view).checkBox.setChecked(add, false);
+                ((PhotoPickerPhotoCell) view).setChecked(add, false);
                 break;
             }
         }
@@ -655,9 +668,10 @@ public void setPhotoChecked(int index) {
     }
 
     @Override
-    public void cancelButtonPressed() {
+    public boolean cancelButtonPressed() {
         delegate.actionButtonPressed(true);
         finishFragment();
+        return true;
     }
 
     @Override
@@ -692,9 +706,8 @@ public int getSelectedCount() {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        super.onOpenAnimationEnd();
-        if (searchItem != null) {
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen && searchItem != null) {
             AndroidUtilities.showKeyboard(searchItem.getSearchField());
         }
     }
@@ -1016,7 +1029,7 @@ public void onClick(View v) {
                                 } else {
                                     selectedPhotos.put(photoEntry.imageId, photoEntry);
                                 }
-                                ((PhotoPickerPhotoCell) v.getParent()).checkBox.setChecked(selectedPhotos.containsKey(photoEntry.imageId), true);
+                                ((PhotoPickerPhotoCell) v.getParent()).setChecked(selectedPhotos.containsKey(photoEntry.imageId), true);
                             } else {
                                 AndroidUtilities.hideKeyboard(getParentActivity().getCurrentFocus());
                                 MediaController.SearchImage photoEntry;
@@ -1033,7 +1046,7 @@ public void onClick(View v) {
                                 } else {
                                     selectedWebPhotos.put(photoEntry.id, photoEntry);
                                 }
-                                ((PhotoPickerPhotoCell) v.getParent()).checkBox.setChecked(selectedWebPhotos.containsKey(photoEntry.id), true);
+                                ((PhotoPickerPhotoCell) v.getParent()).setChecked(selectedWebPhotos.containsKey(photoEntry.id), true);
                             }
                             pickerBottomLayout.updateSelectedCount(selectedPhotos.size() + selectedWebPhotos.size(), true);
                             delegate.selectedPhotosChanged();
@@ -1062,7 +1075,7 @@ public void onClick(View v) {
                     } else {
                         imageView.setImageResource(R.drawable.nophotos);
                     }
-                    cell.checkBox.setChecked(selectedPhotos.containsKey(photoEntry.imageId), false);
+                    cell.setChecked(selectedPhotos.containsKey(photoEntry.imageId), false);
                     showing = PhotoViewer.getInstance().isShowingImage(photoEntry.path);
                 } else {
                     MediaController.SearchImage photoEntry;
@@ -1078,7 +1091,7 @@ public void onClick(View v) {
                     } else {
                         imageView.setImageResource(R.drawable.nophotos);
                     }
-                    cell.checkBox.setChecked(selectedWebPhotos.containsKey(photoEntry.id), false);
+                    cell.setChecked(selectedWebPhotos.containsKey(photoEntry.id), false);
                     showing = PhotoViewer.getInstance().isShowingImage(photoEntry.thumbUrl);
                 }
                 imageView.getImageReceiver().setVisible(!showing, true);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
index f484f9f42..b218a2f95 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PhotoViewer.java
@@ -1,19 +1,21 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
 
+import android.Manifest;
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Paint;
@@ -91,6 +93,7 @@
 import java.util.HashMap;
 import java.util.Locale;
 
+@SuppressWarnings("unchecked")
 public class PhotoViewer implements NotificationCenter.NotificationCenterDelegate, GestureDetector.OnGestureListener, GestureDetector.OnDoubleTapListener {
 
     private int classGuid;
@@ -167,11 +170,13 @@
 
     private int avatarsUserId;
     private long currentDialogId;
+    private long mergeDialogId;
     private int totalImagesCount;
+    private int totalImagesCountMerge;
     private boolean isFirstLoading;
     private boolean needSearchImageInArr;
     private boolean loadingMoreImages;
-    private boolean endReached;
+    private boolean endReached[] = new boolean[] {false, true};
     private boolean opennedFromMedia;
 
     private boolean draggingDown = false;
@@ -214,9 +219,9 @@
     private Scroller scroller = null;
 
     private ArrayList<MessageObject> imagesArrTemp = new ArrayList<>();
-    private HashMap<Integer, MessageObject> imagesByIdsTemp = new HashMap<>();
+    private HashMap<Integer, MessageObject>[] imagesByIdsTemp = new HashMap[] {new HashMap<>(), new HashMap<>()};
     private ArrayList<MessageObject> imagesArr = new ArrayList<>();
-    private HashMap<Integer, MessageObject> imagesByIds = new HashMap<>();
+    private HashMap<Integer, MessageObject>[] imagesByIds = new HashMap[] {new HashMap<>(), new HashMap<>()};
     private ArrayList<TLRPC.FileLocation> imagesArrLocations = new ArrayList<>();
     private ArrayList<TLRPC.Photo> avatarsArr = new ArrayList<>();
     private ArrayList<Integer> imagesArrLocationsSizes = new ArrayList<>();
@@ -406,6 +411,9 @@ public void onDraw(Canvas canvas) {
         public int index;
         public int size;
         public int radius;
+        public int clipBottomAddition;
+        public int clipTopAddition;
+        public float scale = 1.0f;
     }
 
     public static class EmptyPhotoViewerProvider implements PhotoViewerProvider {
@@ -440,8 +448,8 @@ public void setPhotoChecked(int index) {
         }
 
         @Override
-        public void cancelButtonPressed() {
-
+        public boolean cancelButtonPressed() {
+            return true;
         }
 
         @Override
@@ -473,7 +481,7 @@ public void updatePhotoAtIndex(int index) {
 
         void setPhotoChecked(int index);
 
-        void cancelButtonPressed();
+        boolean cancelButtonPressed();
 
         void sendButtonPressed(int index);
 
@@ -525,6 +533,9 @@ public FrameLayoutDrawer(Context context) {
         protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
             int widthSize = MeasureSpec.getSize(widthMeasureSpec);
             int heightSize = MeasureSpec.getSize(heightMeasureSpec);
+            if (heightSize > AndroidUtilities.displaySize.y - AndroidUtilities.statusBarHeight) {
+                heightSize = AndroidUtilities.displaySize.y - AndroidUtilities.statusBarHeight;
+            }
 
             setMeasuredDimension(widthSize, heightSize);
 
@@ -725,32 +736,40 @@ public void didReceivedNotification(int id, Object... args) {
             }
         } else if (id == NotificationCenter.mediaCountDidLoaded) {
             long uid = (Long) args[0];
-            if (uid == currentDialogId) {
-                if ((int) currentDialogId != 0 && (Boolean) args[2]) {
-                    SharedMediaQuery.getMediaCount(currentDialogId, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, false);
+            if (uid == currentDialogId || uid == mergeDialogId) {
+                if (uid == currentDialogId) {
+                    totalImagesCount = (Integer) args[1];
+                    /*if ((Boolean) args[2]) {
+                        SharedMediaQuery.getMediaCount(currentDialogId, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, false);
+                    }*/
+                } else if (uid == mergeDialogId) {
+                    totalImagesCountMerge = (Integer) args[1];
+                    /*if ((Boolean) args[2]) {
+                        SharedMediaQuery.getMediaCount(mergeDialogId, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, false);
+                    }*/
                 }
-                totalImagesCount = (Integer) args[1];
                 if (needSearchImageInArr && isFirstLoading) {
                     isFirstLoading = false;
                     loadingMoreImages = true;
-                    SharedMediaQuery.loadMedia(currentDialogId, 0, 100, 0, SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
+                    SharedMediaQuery.loadMedia(currentDialogId, 0, 80, 0, SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
                 } else if (!imagesArr.isEmpty()) {
                     if (opennedFromMedia) {
-                        actionBar.setTitle(LocaleController.formatString("Of", R.string.Of, currentIndex + 1, totalImagesCount));
+                        actionBar.setTitle(LocaleController.formatString("Of", R.string.Of, currentIndex + 1, totalImagesCount + totalImagesCountMerge));
                     } else {
-                        actionBar.setTitle(LocaleController.formatString("Of", R.string.Of, (totalImagesCount - imagesArr.size()) + currentIndex + 1, totalImagesCount));
+                        actionBar.setTitle(LocaleController.formatString("Of", R.string.Of, (totalImagesCount + totalImagesCountMerge - imagesArr.size()) + currentIndex + 1, totalImagesCount + totalImagesCountMerge));
                     }
                 }
             }
         } else if (id == NotificationCenter.mediaDidLoaded) {
             long uid = (Long) args[0];
             int guid = (Integer) args[3];
-            if (uid == currentDialogId && guid == classGuid) {
+            if ((uid == currentDialogId || uid == mergeDialogId) && guid == classGuid) {
                 loadingMoreImages = false;
+                int loadIndex = uid == currentDialogId ? 0 : 1;
                 ArrayList<MessageObject> arr = (ArrayList<MessageObject>) args[2];
-                endReached = (Boolean) args[5];
+                endReached[loadIndex] = (Boolean) args[5];
                 if (needSearchImageInArr) {
-                    if (arr.isEmpty()) {
+                    if (arr.isEmpty() && (loadIndex != 0 || mergeDialogId == 0)) {
                         needSearchImageInArr = false;
                         return;
                     }
@@ -759,9 +778,10 @@ public void didReceivedNotification(int id, Object... args) {
                     MessageObject currentMessage = imagesArr.get(currentIndex);
 
                     int added = 0;
-                    for (MessageObject message : arr) {
-                        if (!imagesByIdsTemp.containsKey(message.getId())) {
-                            imagesByIdsTemp.put(message.getId(), message);
+                    for (int a = 0; a < arr.size(); a++) {
+                        MessageObject message = arr.get(a);
+                        if (!imagesByIdsTemp[loadIndex].containsKey(message.getId())) {
+                            imagesByIdsTemp[loadIndex].put(message.getId(), message);
                             if (opennedFromMedia) {
                                 imagesArrTemp.add(message);
                                 if (message.getId() == currentMessage.getId()) {
@@ -777,17 +797,20 @@ public void didReceivedNotification(int id, Object... args) {
                             }
                         }
                     }
-                    if (added == 0) {
+                    if (added == 0 && (loadIndex != 0 || mergeDialogId == 0)) {
                         totalImagesCount = imagesArr.size();
+                        totalImagesCountMerge = 0;
                     }
 
                     if (foundIndex != -1) {
                         imagesArr.clear();
                         imagesArr.addAll(imagesArrTemp);
-                        imagesByIds.clear();
-                        imagesByIds.putAll(imagesByIdsTemp);
+                        for (int a = 0; a < 2; a++) {
+                            imagesByIds[a].clear();
+                            imagesByIds[a].putAll(imagesByIdsTemp[a]);
+                            imagesByIdsTemp[a].clear();
+                        }
                         imagesArrTemp.clear();
-                        imagesByIdsTemp.clear();
                         needSearchImageInArr = false;
                         currentIndex = -1;
                         if (foundIndex >= imagesArr.size()) {
@@ -795,31 +818,51 @@ public void didReceivedNotification(int id, Object... args) {
                         }
                         setImageIndex(foundIndex, true);
                     } else {
-                        if (!endReached || !arr.isEmpty() && added != 0) {
+                        int loadFromMaxId;
+                        if (opennedFromMedia) {
+                            loadFromMaxId = imagesArrTemp.isEmpty() ? 0 : imagesArrTemp.get(imagesArrTemp.size() - 1).getId();
+                            if (loadIndex == 0 && endReached[loadIndex] && mergeDialogId != 0) {
+                                loadIndex = 1;
+                                if (!imagesArrTemp.isEmpty() && imagesArrTemp.get(imagesArrTemp.size() - 1).getDialogId() != mergeDialogId) {
+                                    loadFromMaxId = 0;
+                                }
+                            }
+                        } else {
+                            loadFromMaxId = imagesArrTemp.isEmpty() ? 0 : imagesArrTemp.get(0).getId();
+                            if (loadIndex == 0 && endReached[loadIndex] && mergeDialogId != 0) {
+                                loadIndex = 1;
+                                if (!imagesArrTemp.isEmpty() && imagesArrTemp.get(0).getDialogId() != mergeDialogId) {
+                                    loadFromMaxId = 0;
+                                }
+                            }
+                        }
+
+                        if (!endReached[loadIndex]) {
                             loadingMoreImages = true;
                             if (opennedFromMedia) {
-                                SharedMediaQuery.loadMedia(currentDialogId, 0, 100, imagesArrTemp.get(imagesArrTemp.size() - 1).getId(), SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
+                                SharedMediaQuery.loadMedia(loadIndex == 0 ? currentDialogId : mergeDialogId, 0, 80, loadFromMaxId, SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
                             } else {
-                                SharedMediaQuery.loadMedia(currentDialogId, 0, 100, imagesArrTemp.get(0).getId(), SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
+                                SharedMediaQuery.loadMedia(loadIndex == 0 ? currentDialogId : mergeDialogId, 0, 80, loadFromMaxId, SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
                             }
                         }
                     }
                 } else {
                     int added = 0;
                     for (MessageObject message : arr) {
-                        if (!imagesByIds.containsKey(message.getId())) {
+                        if (!imagesByIds[loadIndex].containsKey(message.getId())) {
                             added++;
                             if (opennedFromMedia) {
                                 imagesArr.add(message);
                             } else {
                                 imagesArr.add(0, message);
                             }
-                            imagesByIds.put(message.getId(), message);
+                            imagesByIds[loadIndex].put(message.getId(), message);
                         }
                     }
                     if (opennedFromMedia) {
                         if (added == 0) {
                             totalImagesCount = imagesArr.size();
+                            totalImagesCountMerge = 0;
                         }
                     } else {
                         if (added != 0) {
@@ -828,6 +871,7 @@ public void didReceivedNotification(int id, Object... args) {
                             setImageIndex(index + added, true);
                         } else {
                             totalImagesCount = imagesArr.size();
+                            totalImagesCountMerge = 0;
                         }
                     }
                 }
@@ -856,6 +900,7 @@ public void setParentActivity(final Activity activity) {
         scroller = new Scroller(activity);
 
         windowView = new FrameLayoutTouchListener(activity) {
+
             @Override
             public boolean dispatchKeyEventPreIme(KeyEvent event) {
                 if (event != null && event.getKeyCode() == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_UP) {
@@ -906,6 +951,11 @@ public void onItemClick(int id) {
                     }
                     closePhoto(true, false);
                 } else if (id == gallery_menu_save) {
+                    if (Build.VERSION.SDK_INT >= 23 && parentActivity.checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
+                        parentActivity.requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 4);
+                        return;
+                    }
+
                     File f = null;
                     if (currentMessageObject != null) {
                         f = FileLoader.getPathToMessage(currentMessageObject.messageOwner);
@@ -1218,8 +1268,7 @@ public void onClick(View v) {
             @Override
             public void onClick(View view) {
                 if (placeProvider != null) {
-                    placeProvider.cancelButtonPressed();
-                    closePhoto(false, false);
+                    closePhoto(!placeProvider.cancelButtonPressed(), false);
                 }
             }
         });
@@ -1968,7 +2017,7 @@ private void toggleActionBar(boolean show, final boolean animated) {
                 currentActionBarAnimation.addListener(new AnimatorListenerAdapterProxy() {
                     @Override
                     public void onAnimationEnd(Object animation) {
-                        if (currentActionBarAnimation.equals(animation)) {
+                        if (currentActionBarAnimation != null && currentActionBarAnimation.equals(animation)) {
                             actionBar.setVisibility(View.GONE);
                             if (canShowBottom) {
                                 bottomLayout.clearAnimation();
@@ -2179,13 +2228,14 @@ private void onPhotoShow(final MessageObject messageObject, final TLRPC.FileLoca
         currentFileNames[1] = null;
         currentFileNames[2] = null;
         avatarsUserId = 0;
-        currentDialogId = 0;
         totalImagesCount = 0;
+        totalImagesCountMerge = 0;
         currentEditMode = 0;
         isFirstLoading = true;
         needSearchImageInArr = false;
         loadingMoreImages = false;
-        endReached = false;
+        endReached[0] = false;
+        endReached[1] = mergeDialogId == 0;
         opennedFromMedia = false;
         needCaptionLayout = false;
         canShowBottom = true;
@@ -2194,9 +2244,11 @@ private void onPhotoShow(final MessageObject messageObject, final TLRPC.FileLoca
         imagesArrLocationsSizes.clear();
         avatarsArr.clear();
         imagesArrLocals.clear();
-        imagesByIds.clear();
+        for (int a = 0; a < 2; a++) {
+            imagesByIds[a].clear();
+            imagesByIdsTemp[a].clear();
+        }
         imagesArrTemp.clear();
-        imagesByIdsTemp.clear();
         currentUserAvatarLocation = null;
         containerView.setPadding(0, 0, 0, 0);
         currentThumb = object != null ? object.thumb : null;
@@ -2243,8 +2295,7 @@ private void onPhotoShow(final MessageObject messageObject, final TLRPC.FileLoca
             imagesArr.add(messageObject);
             if (!(messageObject.messageOwner.media instanceof TLRPC.TL_messageMediaWebPage) && (messageObject.messageOwner.action == null || messageObject.messageOwner.action instanceof TLRPC.TL_messageActionEmpty)) {
                 needSearchImageInArr = true;
-                imagesByIds.put(messageObject.getId(), messageObject);
-                currentDialogId = messageObject.getDialogId();
+                imagesByIds[0].put(messageObject.getId(), messageObject);
                 menuItem.showSubItem(gallery_menu_showall);
             } else {
                 menuItem.hideSubItem(gallery_menu_showall);
@@ -2268,18 +2319,9 @@ private void onPhotoShow(final MessageObject messageObject, final TLRPC.FileLoca
                 Collections.reverse(imagesArr);
                 index = imagesArr.size() - index - 1;
             }
-            for (MessageObject message : imagesArr) {
-                imagesByIds.put(message.getId(), message);
-            }
-
-            if (messageObject.messageOwner.dialog_id != 0) {
-                currentDialogId = messageObject.messageOwner.dialog_id;
-            } else {
-                if (messageObject.messageOwner.to_id == null) {
-                    closePhoto(false, false);
-                    return;
-                }
-                currentDialogId = messageObject.getDialogId();
+            for (int a = 0; a < imagesArr.size(); a++) {
+                MessageObject message = imagesArr.get(a);
+                imagesByIds[message.getDialogId() == currentDialogId ? 0 : 1].put(message.getId(), message);
             }
             setImageIndex(index, true);
         } else if (photos != null) {
@@ -2313,6 +2355,9 @@ private void onPhotoShow(final MessageObject messageObject, final TLRPC.FileLoca
 
         if (currentDialogId != 0 && totalImagesCount == 0) {
             SharedMediaQuery.getMediaCount(currentDialogId, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
+            if (mergeDialogId != 0) {
+                SharedMediaQuery.getMediaCount(mergeDialogId, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
+            }
         } else if (avatarsUserId != 0) {
             MessagesController.getInstance().loadUserPhotos(avatarsUserId, 0, 80, 0, true, classGuid);
         }
@@ -2369,7 +2414,7 @@ private void setImageIndex(int index, boolean init) {
                 }
             }
             long date = (long) currentMessageObject.messageOwner.date * 1000;
-            String dateString = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.formatterYear.format(new Date(date)), LocaleController.formatterDay.format(new Date(date)));
+            String dateString = LocaleController.formatString("formatDateAtTime", R.string.formatDateAtTime, LocaleController.getInstance().formatterYear.format(new Date(date)), LocaleController.getInstance().formatterDay.format(new Date(date)));
             if (currentFileNames[0] != null && currentFileNames[0].endsWith("mp4")) {
                 dateTextView.setText(String.format("%s (%s)", dateString, AndroidUtilities.formatFileSize(currentMessageObject.messageOwner.media.video.size)));
             } else {
@@ -2378,21 +2423,37 @@ private void setImageIndex(int index, boolean init) {
             CharSequence caption = currentMessageObject.caption;
             setCurrentCaption(caption);
 
-            if (totalImagesCount != 0 && !needSearchImageInArr) {
+            if (totalImagesCount + totalImagesCountMerge != 0 && !needSearchImageInArr) {
                 if (opennedFromMedia) {
-                    if (imagesArr.size() < totalImagesCount && !loadingMoreImages && currentIndex > imagesArr.size() - 5) {
-                        MessageObject lastMessage = imagesArr.get(imagesArr.size() - 1);
-                        SharedMediaQuery.loadMedia(currentDialogId, 0, 100, lastMessage.getId(), SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
+                    if (imagesArr.size() < totalImagesCount + totalImagesCountMerge && !loadingMoreImages && currentIndex > imagesArr.size() - 5) {
+                        int loadFromMaxId = imagesArr.isEmpty() ? 0 : imagesArr.get(imagesArr.size() - 1).getId();
+                        int loadIndex = 0;
+                        if (endReached[loadIndex] && mergeDialogId != 0) {
+                            loadIndex = 1;
+                            if (!imagesArr.isEmpty() && imagesArr.get(imagesArr.size() - 1).getDialogId() != mergeDialogId) {
+                                loadFromMaxId = 0;
+                            }
+                        }
+
+                        SharedMediaQuery.loadMedia(loadIndex == 0 ? currentDialogId : mergeDialogId, 0, 80, loadFromMaxId, SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
                         loadingMoreImages = true;
                     }
-                    actionBar.setTitle(LocaleController.formatString("Of", R.string.Of, currentIndex + 1, totalImagesCount));
+                    actionBar.setTitle(LocaleController.formatString("Of", R.string.Of, currentIndex + 1, totalImagesCount + totalImagesCountMerge));
                 } else {
-                    if (imagesArr.size() < totalImagesCount && !loadingMoreImages && currentIndex < 5) {
-                        MessageObject lastMessage = imagesArr.get(0);
-                        SharedMediaQuery.loadMedia(currentDialogId, 0, 100, lastMessage.getId(), SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
+                    if (imagesArr.size() < totalImagesCount + totalImagesCountMerge && !loadingMoreImages && currentIndex < 5) {
+                        int loadFromMaxId = imagesArr.isEmpty() ? 0 : imagesArr.get(0).getId();
+                        int loadIndex = 0;
+                        if (endReached[loadIndex] && mergeDialogId != 0) {
+                            loadIndex = 1;
+                            if (!imagesArr.isEmpty() && imagesArr.get(0).getDialogId() != mergeDialogId) {
+                                loadFromMaxId = 0;
+                            }
+                        }
+
+                        SharedMediaQuery.loadMedia(loadIndex == 0 ? currentDialogId : mergeDialogId, 0, 80, loadFromMaxId, SharedMediaQuery.MEDIA_PHOTOVIDEO, true, classGuid);
                         loadingMoreImages = true;
                     }
-                    actionBar.setTitle(LocaleController.formatString("Of", R.string.Of, (totalImagesCount - imagesArr.size()) + currentIndex + 1, totalImagesCount));
+                    actionBar.setTitle(LocaleController.formatString("Of", R.string.Of, (totalImagesCount + totalImagesCountMerge - imagesArr.size()) + currentIndex + 1, totalImagesCount + totalImagesCountMerge));
                 }
             } else if (currentMessageObject.messageOwner.media instanceof TLRPC.TL_messageMediaWebPage) {
                 actionBar.setTitle(LocaleController.getString("AttachPhoto", R.string.AttachPhoto));
@@ -2750,16 +2811,16 @@ public boolean isShowingImage(String object) {
         return isVisible && !disableShowCheck && object != null && currentPathObject != null && object.equals(currentPathObject);
     }
 
-    public void openPhoto(final MessageObject messageObject, final PhotoViewerProvider provider) {
-        openPhoto(messageObject, null, null, null, 0, provider, null);
+    public void openPhoto(final MessageObject messageObject, long dialogId, long mergeDialogId, final PhotoViewerProvider provider) {
+        openPhoto(messageObject, null, null, null, 0, provider, null, dialogId, mergeDialogId);
     }
 
     public void openPhoto(final TLRPC.FileLocation fileLocation, final PhotoViewerProvider provider) {
-        openPhoto(null, fileLocation, null, null, 0, provider, null);
+        openPhoto(null, fileLocation, null, null, 0, provider, null, 0, 0);
     }
 
-    public void openPhoto(final ArrayList<MessageObject> messages, final int index, final PhotoViewerProvider provider) {
-        openPhoto(messages.get(index), null, messages, null, index, provider, null);
+    public void openPhoto(final ArrayList<MessageObject> messages, final int index, long dialogId, long mergeDialogId, final PhotoViewerProvider provider) {
+        openPhoto(messages.get(index), null, messages, null, index, provider, null, dialogId, mergeDialogId);
     }
 
     public void openPhotoForSelect(final ArrayList<Object> photos, final int index, int type, final PhotoViewerProvider provider, ChatActivity chatActivity) {
@@ -2767,7 +2828,7 @@ public void openPhotoForSelect(final ArrayList<Object> photos, final int index,
         if (pickerView != null) {
             pickerView.doneButtonTextView.setText(sendPhotoType == 1 ? LocaleController.getString("Set", R.string.Set).toUpperCase() : LocaleController.getString("Send", R.string.Send).toUpperCase());
         }
-        openPhoto(null, null, null, photos, index, provider, chatActivity);
+        openPhoto(null, null, null, photos, index, provider, chatActivity, 0, 0);
     }
 
     private boolean checkAnimation() {
@@ -2783,7 +2844,7 @@ private boolean checkAnimation() {
         return animationInProgress != 0;
     }
 
-    public void openPhoto(final MessageObject messageObject, final TLRPC.FileLocation fileLocation, final ArrayList<MessageObject> messages, final ArrayList<Object> photos, final int index, final PhotoViewerProvider provider, ChatActivity chatActivity) {
+    public void openPhoto(final MessageObject messageObject, final TLRPC.FileLocation fileLocation, final ArrayList<MessageObject> messages, final ArrayList<Object> photos, final int index, final PhotoViewerProvider provider, ChatActivity chatActivity, long dialogId, long mDialogId) {
         if (parentActivity == null || isVisible || provider == null && checkAnimation() || messageObject == null && fileLocation == null && messages == null && photos == null) {
             return;
         }
@@ -2803,19 +2864,11 @@ public void openPhoto(final MessageObject messageObject, final TLRPC.FileLocatio
         }
 
         try {
-            if (photos != null) {
-                windowLayoutParams.type = WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
-                windowLayoutParams.flags = 0;
-                windowLayoutParams.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
-                windowView.setFocusable(true);
-                containerView.setFocusable(true);
-            } else {
-                windowLayoutParams.type = WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
-                windowLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
-                windowLayoutParams.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED;
-                windowView.setFocusable(false);
-                containerView.setFocusable(false);
-            }
+            windowLayoutParams.type = WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
+            windowLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
+            windowLayoutParams.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED;
+            windowView.setFocusable(false);
+            containerView.setFocusable(false);
             wm.addView(windowView, windowLayoutParams);
         } catch (Exception e) {
             FileLog.e("tmessages", e);
@@ -2834,6 +2887,8 @@ public void openPhoto(final MessageObject messageObject, final TLRPC.FileLocatio
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.emojiDidLoaded);
 
         placeProvider = provider;
+        mergeDialogId = mDialogId;
+        currentDialogId = dialogId;
 
         if (velocityTracker == null) {
             velocityTracker = VelocityTracker.obtain();
@@ -2859,13 +2914,13 @@ public void openPhoto(final MessageObject messageObject, final TLRPC.FileLocatio
             ViewProxy.setAlpha(animatingImageView, 1.0f);
             ViewProxy.setPivotX(animatingImageView, 0.0f);
             ViewProxy.setPivotY(animatingImageView, 0.0f);
-            ViewProxy.setScaleX(animatingImageView, 1.0f);
-            ViewProxy.setScaleY(animatingImageView, 1.0f);
-            ViewProxy.setTranslationX(animatingImageView, object.viewX + drawRegion.left);
-            ViewProxy.setTranslationY(animatingImageView, object.viewY + drawRegion.top);
+            ViewProxy.setScaleX(animatingImageView, object.scale);
+            ViewProxy.setScaleY(animatingImageView, object.scale);
+            ViewProxy.setTranslationX(animatingImageView, object.viewX + drawRegion.left * object.scale);
+            ViewProxy.setTranslationY(animatingImageView, object.viewY + drawRegion.top * object.scale);
             final ViewGroup.LayoutParams layoutParams = animatingImageView.getLayoutParams();
-            layoutParams.width = drawRegion.right - drawRegion.left;
-            layoutParams.height = drawRegion.bottom - drawRegion.top;
+            layoutParams.width = (drawRegion.right - drawRegion.left);
+            layoutParams.height = (drawRegion.bottom - drawRegion.top);
             animatingImageView.setLayoutParams(layoutParams);
 
             float scaleX = (float) AndroidUtilities.displaySize.x / layoutParams.width;
@@ -2880,11 +2935,11 @@ public void openPhoto(final MessageObject messageObject, final TLRPC.FileLocatio
 
             int coords2[] = new int[2];
             object.parentView.getLocationInWindow(coords2);
-            int clipTop = coords2[1] - AndroidUtilities.statusBarHeight - (object.viewY + drawRegion.top);
+            int clipTop = coords2[1] - AndroidUtilities.statusBarHeight - (object.viewY + drawRegion.top) + object.clipTopAddition;
             if (clipTop < 0) {
                 clipTop = 0;
             }
-            int clipBottom = (object.viewY + drawRegion.top + layoutParams.height) - (coords2[1] + object.parentView.getHeight() - AndroidUtilities.statusBarHeight);
+            int clipBottom = (object.viewY + drawRegion.top + layoutParams.height) - (coords2[1] + object.parentView.getHeight() - AndroidUtilities.statusBarHeight) + object.clipBottomAddition;
             if (clipBottom < 0) {
                 clipBottom = 0;
             }
@@ -2895,9 +2950,9 @@ public void openPhoto(final MessageObject messageObject, final TLRPC.FileLocatio
             animationValues[0][1] = ViewProxy.getScaleY(animatingImageView);
             animationValues[0][2] = ViewProxy.getTranslationX(animatingImageView);
             animationValues[0][3] = ViewProxy.getTranslationY(animatingImageView);
-            animationValues[0][4] = clipHorizontal;
-            animationValues[0][5] = clipTop;
-            animationValues[0][6] = clipBottom;
+            animationValues[0][4] = clipHorizontal * object.scale;
+            animationValues[0][5] = clipTop * object.scale;
+            animationValues[0][6] = clipBottom * object.scale;
             animationValues[0][7] = animatingImageView.getRadius();
 
             animationValues[1][0] = scale;
@@ -2940,6 +2995,14 @@ public void run() {
                     if (hideAfterAnimation != null) {
                         hideAfterAnimation.imageReceiver.setVisible(false, true);
                     }
+                    if (photos != null) {
+                        windowLayoutParams.flags = 0;
+                        windowLayoutParams.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
+                        WindowManager wm = (WindowManager) parentActivity.getSystemService(Context.WINDOW_SERVICE);
+                        wm.updateViewLayout(windowView, windowLayoutParams);
+                        windowView.setFocusable(true);
+                        containerView.setFocusable(true);
+                    }
                 }
             };
 
@@ -2983,6 +3046,14 @@ public void run() {
                 }
             };
         } else {
+            if (photos != null) {
+                windowLayoutParams.flags = 0;
+                windowLayoutParams.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
+                wm.updateViewLayout(windowView, windowLayoutParams);
+                windowView.setFocusable(true);
+                containerView.setFocusable(true);
+            }
+
             backgroundDrawable.setAlpha(255);
             ViewProxy.setAlpha(containerView, 1.0f);
             onPhotoShow(messageObject, fileLocation, messages, photos, index, object);
@@ -3086,11 +3157,11 @@ public void closePhoto(boolean animated, boolean fromEditMode) {
 
                 int coords2[] = new int[2];
                 object.parentView.getLocationInWindow(coords2);
-                int clipTop = coords2[1] - AndroidUtilities.statusBarHeight - (object.viewY + drawRegion.top);
+                int clipTop = coords2[1] - AndroidUtilities.statusBarHeight - (object.viewY + drawRegion.top) + object.clipTopAddition;
                 if (clipTop < 0) {
                     clipTop = 0;
                 }
-                int clipBottom = (object.viewY + drawRegion.top + (drawRegion.bottom - drawRegion.top)) - (coords2[1] + object.parentView.getHeight() - AndroidUtilities.statusBarHeight);
+                int clipBottom = (object.viewY + drawRegion.top + (drawRegion.bottom - drawRegion.top)) - (coords2[1] + object.parentView.getHeight() - AndroidUtilities.statusBarHeight) + object.clipBottomAddition;
                 if (clipBottom < 0) {
                     clipBottom = 0;
                 }
@@ -3107,13 +3178,13 @@ public void closePhoto(boolean animated, boolean fromEditMode) {
                 animationValues[0][6] = 0;
                 animationValues[0][7] = 0;
 
-                animationValues[1][0] = 1;
-                animationValues[1][1] = 1;
-                animationValues[1][2] = object.viewX + drawRegion.left;
-                animationValues[1][3] = object.viewY + drawRegion.top;
-                animationValues[1][4] = clipHorizontal;
-                animationValues[1][5] = clipTop;
-                animationValues[1][6] = clipBottom;
+                animationValues[1][0] = object.scale;
+                animationValues[1][1] = object.scale;
+                animationValues[1][2] = object.viewX + drawRegion.left * object.scale;
+                animationValues[1][3] = object.viewY + drawRegion.top * object.scale;
+                animationValues[1][4] = clipHorizontal * object.scale;
+                animationValues[1][5] = clipTop * object.scale;
+                animationValues[1][6] = clipBottom * object.scale;
                 animationValues[1][7] = object.radius;
 
                 animatorSet.playTogether(
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PopupNotificationActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PopupNotificationActivity.java
index 9c0927b07..d6de85155 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PopupNotificationActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PopupNotificationActivity.java
@@ -1,19 +1,25 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
 
+import android.annotation.TargetApi;
 import android.app.Activity;
+import android.app.AlertDialog;
 import android.app.KeyguardManager;
 import android.content.Context;
+import android.content.DialogInterface;
 import android.content.Intent;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.PowerManager;
 import android.text.TextUtils;
@@ -76,6 +82,7 @@
     private ViewGroup centerView;
     private ViewGroup leftView;
     private ViewGroup rightView;
+    private RelativeLayout popupContainer;
     private ArrayList<ViewGroup> textViews = new ArrayList<>();
     private ArrayList<ViewGroup> imageViews = new ArrayList<>();
     private ArrayList<ViewGroup> audioViews = new ArrayList<>();
@@ -195,6 +202,8 @@ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
                     }
                     if (chatActivityEnterView.isPopupView(child)) {
                         child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getLayoutParams().height, MeasureSpec.EXACTLY));
+                    } else if (chatActivityEnterView.isRecordCircle(child)) {
+                        measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                     } else {
                         child.measure(MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(Math.max(AndroidUtilities.dp(10), heightSize + AndroidUtilities.dp(2)), MeasureSpec.EXACTLY));
                     }
@@ -255,6 +264,9 @@ protected void onLayout(boolean changed, int l, int t, int r, int b) {
                     }
                     if (chatActivityEnterView.isPopupView(child)) {
                         childTop = paddingBottom != 0 ? getMeasuredHeight() - paddingBottom : getMeasuredHeight();
+                    } else if (chatActivityEnterView.isRecordCircle(child)) {
+                        childTop = popupContainer.getTop() + popupContainer.getMeasuredHeight() - child.getMeasuredHeight() - lp.bottomMargin;
+                        childLeft = popupContainer.getLeft() + popupContainer.getMeasuredWidth() - child.getMeasuredWidth() - lp.rightMargin;
                     }
                     child.layout(childLeft, childTop, childLeft + width, childTop + height);
                 }
@@ -268,7 +280,7 @@ protected void onLayout(boolean changed, int l, int t, int r, int b) {
         RelativeLayout relativeLayout = new RelativeLayout(this);
         contentView.addView(relativeLayout, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
 
-        RelativeLayout popupContainer = new RelativeLayout(this);
+        popupContainer = new RelativeLayout(this);
         popupContainer.setBackgroundColor(0xffffffff);
         relativeLayout.addView(popupContainer, LayoutHelper.createRelative(LayoutHelper.MATCH_PARENT, 240, 12, 0, 12, 0, RelativeLayout.CENTER_IN_PARENT));
 
@@ -286,7 +298,7 @@ public void onMessageSend(String message) {
                 if (currentMessageNum >= 0 && currentMessageNum < NotificationsController.getInstance().popupMessages.size()) {
                     NotificationsController.getInstance().popupMessages.remove(currentMessageNum);
                 }
-                MessagesController.getInstance().markDialogAsRead(currentMessageObject.getDialogId(), currentMessageObject.getId(), Math.max(0, currentMessageObject.getId()), 0, currentMessageObject.messageOwner.date, true, true);
+                MessagesController.getInstance().markDialogAsRead(currentMessageObject.getDialogId(), currentMessageObject.getId(), Math.max(0, currentMessageObject.getId()), currentMessageObject.messageOwner.date, true, true);
                 currentMessageObject = null;
                 getNewMessage();
             }
@@ -426,6 +438,34 @@ protected void onNewIntent(Intent intent) {
         handleIntent(intent);
     }
 
+    @Override
+    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        if (requestCode == 3) {
+            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+                return;
+            }
+            AlertDialog.Builder builder = new AlertDialog.Builder(this);
+            builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+            builder.setMessage(LocaleController.getString("PermissionNoAudio", R.string.PermissionNoAudio));
+            builder.setNegativeButton(LocaleController.getString("PermissionOpenSettings", R.string.PermissionOpenSettings), new DialogInterface.OnClickListener() {
+                @TargetApi(Build.VERSION_CODES.GINGERBREAD)
+                @Override
+                public void onClick(DialogInterface dialog, int which) {
+                    try {
+                        Intent intent = new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+                        intent.setData(Uri.parse("package:" + ApplicationLoader.applicationContext.getPackageName()));
+                        startActivity(intent);
+                    } catch (Exception e) {
+                        FileLog.e("tmessages", e);
+                    }
+                }
+            });
+            builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), null);
+            builder.show();
+        }
+    }
+
     private void switchToNextMessage() {
         if (NotificationsController.getInstance().popupMessages.size() > 1) {
             if (currentMessageNum < NotificationsController.getInstance().popupMessages.size() - 1) {
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/PrivacySettingsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/PrivacySettingsActivity.java
index 57ad7f2db..5a2928e27 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/PrivacySettingsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/PrivacySettingsActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -323,7 +323,7 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                         value = formatRulesString();
                     }
                     textCell.setTextAndValue(LocaleController.getString("PrivacyLastSeen", R.string.PrivacyLastSeen), value, false);
-                }  else if (i == deleteAccountRow) {
+                } else if (i == deleteAccountRow) {
                     String value;
                     if (ContactsController.getInstance().getLoadingDeleteInfo()) {
                         value = LocaleController.getString("Loading", R.string.Loading);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ProfileActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ProfileActivity.java
index ab7f48277..15a08cf4f 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ProfileActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ProfileActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -11,33 +11,33 @@
 import android.animation.ObjectAnimator;
 import android.animation.StateListAnimator;
 import android.annotation.SuppressLint;
+import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.Dialog;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
+import android.content.SharedPreferences;
 import android.content.res.Configuration;
 import android.graphics.Bitmap;
-import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.Outline;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
-import android.support.annotation.NonNull;
 import android.text.TextUtils;
 import android.util.TypedValue;
 import android.view.Gravity;
+import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewOutlineProvider;
 import android.view.ViewTreeObserver;
 import android.view.animation.AccelerateInterpolator;
 import android.view.animation.DecelerateInterpolator;
-import android.widget.AbsListView;
-import android.widget.AdapterView;
 import android.widget.FrameLayout;
 import android.widget.ImageView;
-import android.widget.ListView;
 import android.widget.TextView;
 
 import org.telegram.messenger.AndroidUtilities;
@@ -54,7 +54,11 @@
 import org.telegram.messenger.query.BotQuery;
 import org.telegram.messenger.query.SharedMediaQuery;
 import org.telegram.messenger.ApplicationLoader;
+import org.telegram.messenger.support.widget.LinearLayoutManager;
+import org.telegram.messenger.support.widget.RecyclerView;
 import org.telegram.tgnet.ConnectionsManager;
+import org.telegram.tgnet.RequestDelegate;
+import org.telegram.tgnet.TLObject;
 import org.telegram.tgnet.TLRPC;
 import org.telegram.messenger.ContactsController;
 import org.telegram.messenger.FileLog;
@@ -64,24 +68,28 @@
 import org.telegram.messenger.MessageObject;
 import org.telegram.messenger.UserConfig;
 import org.telegram.messenger.Utilities;
-import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.ActionBar.BackDrawable;
 import org.telegram.messenger.AnimationCompat.ViewProxy;
-import org.telegram.ui.Cells.AddMemberCell;
+import org.telegram.ui.Cells.AboutLinkCell;
 import org.telegram.ui.Cells.DividerCell;
 import org.telegram.ui.Cells.EmptyCell;
+import org.telegram.ui.Cells.LoadingCell;
 import org.telegram.ui.Cells.ShadowSectionCell;
 import org.telegram.ui.Cells.TextCell;
 import org.telegram.ui.Cells.TextDetailCell;
+import org.telegram.ui.Cells.TextInfoPrivacyCell;
 import org.telegram.ui.Cells.UserCell;
 import org.telegram.ui.ActionBar.ActionBar;
 import org.telegram.ui.ActionBar.ActionBarMenu;
 import org.telegram.ui.ActionBar.ActionBarMenuItem;
+import org.telegram.ui.Components.AlertsCreator;
 import org.telegram.ui.Components.AvatarDrawable;
 import org.telegram.ui.Components.AvatarUpdater;
 import org.telegram.ui.Components.BackupImageView;
 import org.telegram.ui.ActionBar.BaseFragment;
 import org.telegram.ui.Components.IdenticonDrawable;
 import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.RecyclerListView;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -91,22 +99,39 @@
 
 public class ProfileActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate, DialogsActivity.MessagesActivityDelegate, PhotoViewer.PhotoViewerProvider {
 
-    private ListView listView;
+    private RecyclerListView listView;
+    private LinearLayoutManager layoutManager;
     private ListAdapter listAdapter;
     private BackupImageView avatarImage;
-    private TextView nameTextView;
-    private TextView onlineTextView;
+    private TextView nameTextView[] = new TextView[2];
+    private TextView onlineTextView[] = new TextView[2];
     private ImageView writeButton;
     private AnimatorSetProxy writeButtonAnimation;
+    private View extraHeightView;
+    private View shadowView;
+    private AvatarDrawable avatarDrawable;
+    private ActionBarMenuItem animatingItem;
     private int user_id;
     private int chat_id;
     private long dialog_id;
     private boolean creatingChat;
     private boolean userBlocked;
+    private long mergeDialogId;
+
+    private boolean loadingUsers;
+    private ArrayList<TLRPC.ChannelParticipant> participants = new ArrayList<>();
+    private HashMap<Integer, TLRPC.ChannelParticipant> participantsMap = new HashMap<>();
+    private boolean usersEndReached;
+
+    private boolean openAnimationInProgress;
+    private boolean playProfileAnimation;
+    private int extraHeight;
+    private int initialAnimationExtraHeight;
+    private float animationProgress;
 
     private AvatarUpdater avatarUpdater;
     private TLRPC.ChatFull info;
-    private TLRPC.TL_chatParticipant selectedUser;
+    private int selectedUser;
     private int onlineCount = -1;
     private ArrayList<Integer> sortedUsers;
 
@@ -115,17 +140,19 @@
     private TLRPC.BotInfo botInfo;
 
     private int totalMediaCount = -1;
+    private int totalMediaCountMerge = -1;
 
     private final static int add_contact = 1;
     private final static int block_contact = 2;
     private final static int share_contact = 3;
     private final static int edit_contact = 4;
     private final static int delete_contact = 5;
-    private final static int add_member = 6;
     private final static int leave_group = 7;
     private final static int edit_name = 8;
     private final static int invite_to_group = 9;
     private final static int share = 10;
+    private final static int set_admins = 11;
+    private final static int edit_channel = 12;
 
     private int overscrollRow;
     private int emptyRow;
@@ -137,11 +164,13 @@
     private int channelNameRow;
     private int settingsTimerRow;
     private int settingsKeyRow;
+    private int convertRow;
+    private int convertHelpRow;
     private int settingsNotificationsRow;
     private int sharedMediaRow;
     private int membersRow;
     private int managementRow;
-    private int blockedUsersRow = -1;
+    private int blockedUsersRow;
     private int leaveChannelRow;
     private int startSecretChatRow;
     private int sectionRow;
@@ -149,6 +178,7 @@
     private int botInfoRow;
     private int membersSectionRow;
     private int membersEndRow;
+    private int loadMoreMembersRow;
     private int addMemberRow;
     private int rowCount = 0;
 
@@ -175,11 +205,16 @@ public boolean onFragmentCreate() {
             NotificationCenter.getInstance().addObserver(this, NotificationCenter.encryptedChatUpdated);
             NotificationCenter.getInstance().addObserver(this, NotificationCenter.blockedUsersDidLoaded);
             NotificationCenter.getInstance().addObserver(this, NotificationCenter.botInfoDidLoaded);
+            if (currentEncryptedChat != null) {
+                NotificationCenter.getInstance().addObserver(this, NotificationCenter.didReceivedNewMessages);
+            }
             userBlocked = MessagesController.getInstance().blockedUsers.contains(user_id);
-            if ((user.flags & TLRPC.USER_FLAG_BOT) != 0) {
+            if (user.bot) {
                 BotQuery.loadBotInfo(user.id, true, classGuid);
             }
             MessagesController.getInstance().loadFullUser(MessagesController.getInstance().getUser(user_id), classGuid);
+            participants = null;
+            participantsMap = null;
         } else if (chat_id != 0) {
             currentChat = MessagesController.getInstance().getChat(chat_id);
             if (currentChat == null) {
@@ -203,13 +238,16 @@ public void run() {
                 }
             }
 
+            if (currentChat.megagroup) {
+                getChannelParticipants(true);
+            } else {
+                participants = null;
+                participantsMap = null;
+            }
             NotificationCenter.getInstance().addObserver(this, NotificationCenter.chatInfoDidLoaded);
 
             sortedUsers = new ArrayList<>();
             updateOnlineCount();
-            if (chat_id > 0) {
-                SharedMediaQuery.getMediaCount(-chat_id, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
-            }
 
             avatarUpdater = new AvatarUpdater();
             avatarUpdater.delegate = new AvatarUpdater.AvatarUpdaterDelegate() {
@@ -225,6 +263,17 @@ public void didUploadedPhoto(TLRPC.InputFile file, TLRPC.PhotoSize small, TLRPC.
             return false;
         }
 
+        if (dialog_id != 0) {
+            SharedMediaQuery.getMediaCount(dialog_id, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
+        } else if (user_id != 0) {
+            SharedMediaQuery.getMediaCount(user_id, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
+        } else if (chat_id > 0) {
+            SharedMediaQuery.getMediaCount(-chat_id, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
+            if (mergeDialogId != 0) {
+                SharedMediaQuery.getMediaCount(mergeDialogId, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
+            }
+        }
+
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.mediaCountDidLoaded);
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.updateInterfaces);
         NotificationCenter.getInstance().addObserver(this, NotificationCenter.closeChats);
@@ -246,6 +295,9 @@ public void onFragmentDestroy() {
             NotificationCenter.getInstance().removeObserver(this, NotificationCenter.blockedUsersDidLoaded);
             NotificationCenter.getInstance().removeObserver(this, NotificationCenter.botInfoDidLoaded);
             MessagesController.getInstance().cancelLoadFullUser(user_id);
+            if (currentEncryptedChat != null) {
+                NotificationCenter.getInstance().removeObserver(this, NotificationCenter.didReceivedNewMessages);
+            }
         } else if (chat_id != 0) {
             NotificationCenter.getInstance().removeObserver(this, NotificationCenter.chatInfoDidLoaded);
             avatarUpdater.clear();
@@ -254,10 +306,13 @@ public void onFragmentDestroy() {
 
     @Override
     public View createView(Context context) {
-        actionBar.setBackgroundColor(AvatarDrawable.getProfileBackColorForId(user_id != 0 || ChatObject.isChannel(chat_id) ? 5 : chat_id));
-        actionBar.setItemsBackground(AvatarDrawable.getButtonColorForId(user_id != 0 || ChatObject.isChannel(chat_id) ? 5 : chat_id));
-        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
-        actionBar.setExtraHeight(AndroidUtilities.dp(88), false);
+        actionBar.setBackgroundColor(AvatarDrawable.getProfileBackColorForId(user_id != 0 || ChatObject.isChannel(chat_id) && !currentChat.megagroup ? 5 : chat_id));
+        actionBar.setItemsBackground(AvatarDrawable.getButtonColorForId(user_id != 0 || ChatObject.isChannel(chat_id) && !currentChat.megagroup ? 5 : chat_id));
+        actionBar.setBackButtonDrawable(new BackDrawable(false));
+        actionBar.setCastShadows(false);
+        actionBar.setAddToContainer(false);
+        hasOwnBackground = true;
+        extraHeight = 88;
         if (AndroidUtilities.isTablet()) {
             actionBar.setOccupyStatusBar(false);
         }
@@ -274,7 +329,7 @@ public void onItemClick(final int id) {
                     if (user == null) {
                         return;
                     }
-                    if ((user.flags & TLRPC.USER_FLAG_BOT) == 0) {
+                    if (!user.bot) {
                         AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                         if (!userBlocked) {
                             builder.setMessage(LocaleController.getString("AreYouSureBlockContact", R.string.AreYouSureBlockContact));
@@ -307,11 +362,14 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     TLRPC.User user = MessagesController.getInstance().getUser(user_id);
                     Bundle args = new Bundle();
                     args.putInt("user_id", user.id);
+                    args.putBoolean("addContact", true);
                     presentFragment(new ContactAddActivity(args));
                 } else if (id == share_contact) {
                     Bundle args = new Bundle();
                     args.putBoolean("onlySelect", true);
                     args.putInt("dialogsType", 1);
+                    args.putString("selectAlertString", LocaleController.getString("SendContactTo", R.string.SendContactTo));
+                    args.putString("selectAlertStringGroup", LocaleController.getString("SendContactToGroup", R.string.SendContactToGroup));
                     DialogsActivity fragment = new DialogsActivity(args);
                     fragment.setDelegate(ProfileActivity.this);
                     presentFragment(fragment);
@@ -337,34 +395,18 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
                     showDialog(builder.create());
-                } else if (id == add_member) {
-                    openAddMember();
                 } else if (id == leave_group) {
-                    if (ChatObject.isChannel(chat_id)) {
-
-                    } else {
-                        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
-                        builder.setMessage(LocaleController.getString("AreYouSureDeleteAndExit", R.string.AreYouSureDeleteAndExit));
-                        builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-                        builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
-                            @Override
-                            public void onClick(DialogInterface dialogInterface, int i) {
-                                kickUser(null);
-                            }
-                        });
-                        builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                        showDialog(builder.create());
-                    }
+                    leaveChatPressed();
                 } else if (id == edit_name) {
                     Bundle args = new Bundle();
                     args.putInt("chat_id", chat_id);
-                    if (ChatObject.isChannel(chat_id)) {
-                        ChannelEditActivity fragment = new ChannelEditActivity(args);
-                        fragment.setInfo(info);
-                        presentFragment(fragment);
-                    } else {
-                        presentFragment(new ChangeChatNameActivity(args));
-                    }
+                    presentFragment(new ChangeChatNameActivity(args));
+                } else if (id == edit_channel) {
+                    Bundle args = new Bundle();
+                    args.putInt("chat_id", chat_id);
+                    ChannelEditActivity fragment = new ChannelEditActivity(args);
+                    fragment.setInfo(info);
+                    presentFragment(fragment);
                 } else if (id == invite_to_group) {
                     final TLRPC.User user = MessagesController.getInstance().getUser(user_id);
                     if (user == null) {
@@ -380,7 +422,7 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         public void didSelectDialog(DialogsActivity fragment, long did, boolean param) {
                             NotificationCenter.getInstance().removeObserver(ProfileActivity.this, NotificationCenter.closeChats);
                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
-                            MessagesController.getInstance().addUserToChat(-(int) did, user, null, 0, null, null);
+                            MessagesController.getInstance().addUserToChat(-(int) did, user, null, 0, null, ProfileActivity.this);
                             Bundle args = new Bundle();
                             args.putBoolean("scrollToTopOnResume", true);
                             args.putInt("chat_id", -(int) did);
@@ -406,6 +448,12 @@ public void didSelectDialog(DialogsActivity fragment, long did, boolean param) {
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
                     }
+                } else if (id == set_admins) {
+                    Bundle args = new Bundle();
+                    args.putInt("chat_id", chat_id);
+                    SetAdminsActivity fragment = new SetAdminsActivity(args);
+                    fragment.setChatInfo(info);
+                    presentFragment(fragment);
                 }
             }
         });
@@ -413,138 +461,62 @@ public void didSelectDialog(DialogsActivity fragment, long did, boolean param) {
         createActionBarMenu();
 
         listAdapter = new ListAdapter(context);
+        avatarDrawable = new AvatarDrawable();
+        avatarDrawable.setProfile(true);
 
         fragmentView = new FrameLayout(context) {
             @Override
-            protected boolean drawChild(@NonNull Canvas canvas, @NonNull View child, long drawingTime) {
-                if (child == listView) {
-                    boolean result = super.drawChild(canvas, child, drawingTime);
-                    if (parentLayout != null) {
-                        int actionBarHeight = 0;
-                        int childCount = getChildCount();
-                        for (int a = 0; a < childCount; a++) {
-                            View view = getChildAt(a);
-                            if (view == child) {
-                                continue;
-                            }
-                            if (view instanceof ActionBar && view.getVisibility() == VISIBLE) {
-                                if (((ActionBar) view).getCastShadows()) {
-                                    actionBarHeight = view.getMeasuredHeight();
-                                }
-                                break;
-                            }
-                        }
-                        parentLayout.drawHeaderShadow(canvas, actionBarHeight);
-                    }
-                    return result;
-                } else {
-                    return super.drawChild(canvas, child, drawingTime);
-                }
+            public boolean hasOverlappingRendering() {
+                return false;
             }
         };
         FrameLayout frameLayout = (FrameLayout) fragmentView;
 
-        avatarImage = new BackupImageView(context);
-        avatarImage.setRoundRadius(AndroidUtilities.dp(30));
-        actionBar.addView(avatarImage);
-        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) avatarImage.getLayoutParams();
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM;
-        layoutParams.width = AndroidUtilities.dp(60);
-        layoutParams.height = AndroidUtilities.dp(60);
-        layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(17);
-        layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(17) : 0;
-        layoutParams.bottomMargin = AndroidUtilities.dp(22);
-        avatarImage.setLayoutParams(layoutParams);
-        avatarImage.setOnClickListener(new View.OnClickListener() {
+        listView = new RecyclerListView(context) {
             @Override
-            public void onClick(View v) {
-                if (user_id != 0) {
-                    TLRPC.User user = MessagesController.getInstance().getUser(user_id);
-                    if (user.photo != null && user.photo.photo_big != null) {
-                        PhotoViewer.getInstance().setParentActivity(getParentActivity());
-                        PhotoViewer.getInstance().openPhoto(user.photo.photo_big, ProfileActivity.this);
-                    }
-                } else if (chat_id != 0) {
-                    TLRPC.Chat chat = MessagesController.getInstance().getChat(chat_id);
-                    if (chat.photo != null && chat.photo.photo_big != null) {
-                        PhotoViewer.getInstance().setParentActivity(getParentActivity());
-                        PhotoViewer.getInstance().openPhoto(chat.photo.photo_big, ProfileActivity.this);
-                    }
-                }
+            public boolean hasOverlappingRendering() {
+                return false;
             }
-        });
-
-        nameTextView = new TextView(context);
-        nameTextView.setTextColor(0xffffffff);
-        nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20);
-        nameTextView.setLines(1);
-        nameTextView.setMaxLines(1);
-        nameTextView.setSingleLine(true);
-        nameTextView.setEllipsize(TextUtils.TruncateAt.END);
-        nameTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
-        nameTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        actionBar.addView(nameTextView);
-        layoutParams = (FrameLayout.LayoutParams) nameTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 97);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 97 : 16);
-        layoutParams.bottomMargin = AndroidUtilities.dp(51);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM;
-        nameTextView.setLayoutParams(layoutParams);
-
-        onlineTextView = new TextView(context);
-        onlineTextView.setTextColor(AvatarDrawable.getProfileTextColorForId(user_id != 0 || ChatObject.isChannel(chat_id) ? 5 : chat_id));
-        onlineTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
-        onlineTextView.setLines(1);
-        onlineTextView.setMaxLines(1);
-        onlineTextView.setSingleLine(true);
-        onlineTextView.setEllipsize(TextUtils.TruncateAt.END);
-        onlineTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
-        actionBar.addView(onlineTextView);
-        layoutParams = (FrameLayout.LayoutParams) onlineTextView.getLayoutParams();
-        layoutParams.width = LayoutHelper.WRAP_CONTENT;
-        layoutParams.height = LayoutHelper.WRAP_CONTENT;
-        layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 97);
-        layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 97 : 16);
-        layoutParams.bottomMargin = AndroidUtilities.dp(30);
-        layoutParams.gravity = (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM;
-        onlineTextView.setLayoutParams(layoutParams);
-
-        listView = new ListView(context);
-        listView.setDivider(null);
-        listView.setDividerHeight(0);
+        };
+        listView.setBackgroundColor(0xffffffff);
         listView.setVerticalScrollBarEnabled(false);
-        AndroidUtilities.setListViewEdgeEffectColor(listView, AvatarDrawable.getProfileBackColorForId(user_id != 0 || ChatObject.isChannel(chat_id) ? 5 : chat_id));
-        frameLayout.addView(listView);
-        layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
-        layoutParams.width = LayoutHelper.MATCH_PARENT;
-        layoutParams.height = LayoutHelper.MATCH_PARENT;
-        layoutParams.gravity = Gravity.TOP;
-        listView.setLayoutParams(layoutParams);
+        listView.setItemAnimator(null);
+        listView.setLayoutAnimation(null);
+        layoutManager = new LinearLayoutManager(context) {
+            @Override
+            public boolean supportsPredictiveItemAnimations() {
+                return false;
+            }
+        };
+        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);
+        listView.setLayoutManager(layoutManager);
+        listView.setGlowColor(AvatarDrawable.getProfileBackColorForId(user_id != 0 || ChatObject.isChannel(chat_id) && !currentChat.megagroup ? 5 : chat_id));
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT, Gravity.TOP | Gravity.LEFT));
 
         listView.setAdapter(listAdapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+        listView.setOnItemClickListener(new RecyclerListView.OnItemClickListener() {
             @Override
-            public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+            public void onItemClick(View view, final int position) {
                 if (getParentActivity() == null) {
                     return;
                 }
-                if (i == sharedMediaRow) {
+                if (position == sharedMediaRow) {
                     Bundle args = new Bundle();
                     if (user_id != 0) {
                         args.putLong("dialog_id", dialog_id != 0 ? dialog_id : user_id);
                     } else {
                         args.putLong("dialog_id", -chat_id);
                     }
-                    presentFragment(new MediaActivity(args));
-                } else if (i == settingsKeyRow) {
+                    MediaActivity fragment = new MediaActivity(args);
+                    fragment.setChatInfo(info);
+                    presentFragment(fragment);
+                } else if (position == settingsKeyRow) {
                     Bundle args = new Bundle();
                     args.putInt("chat_id", (int) (dialog_id >> 32));
                     presentFragment(new IdenticonActivity(args));
-                } else if (i == settingsTimerRow) {
+                } else if (position == settingsTimerRow) {
                     showDialog(AndroidUtilities.buildTTLAlert(getParentActivity(), currentEncryptedChat).create());
-                } else if (i == settingsNotificationsRow) {
+                } else if (position == settingsNotificationsRow) {
                     Bundle args = new Bundle();
                     if (user_id != 0) {
                         args.putLong("dialog_id", dialog_id == 0 ? user_id : dialog_id);
@@ -552,7 +524,7 @@ public void onItemClick(AdapterView<?> adapterView, View view, final int i, long
                         args.putLong("dialog_id", -chat_id);
                     }
                     presentFragment(new ProfileNotificationsActivity(args));
-                } else if (i == startSecretChatRow) {
+                } else if (position == startSecretChatRow) {
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setMessage(LocaleController.getString("AreYouSureSecretChat", R.string.AreYouSureSecretChat));
                     builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
@@ -565,7 +537,33 @@ public void onClick(DialogInterface dialogInterface, int i) {
                     });
                     builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
                     showDialog(builder.create());
-                } else if (i == phoneRow) {
+                } else if (position == usernameRow) {
+                    final TLRPC.User user = MessagesController.getInstance().getUser(user_id);
+                    if (user == null || user.username == null) {
+                        return;
+                    }
+                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                    builder.setItems(new CharSequence[]{LocaleController.getString("Copy", R.string.Copy)}, new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            if (i == 0) {
+                                try {
+                                    if (Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.HONEYCOMB) {
+                                        android.text.ClipboardManager clipboard = (android.text.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                                        clipboard.setText("@" + user.username);
+                                    } else {
+                                        android.content.ClipboardManager clipboard = (android.content.ClipboardManager) ApplicationLoader.applicationContext.getSystemService(Context.CLIPBOARD_SERVICE);
+                                        android.content.ClipData clip = android.content.ClipData.newPlainText("label", "@" + user.username);
+                                        clipboard.setPrimaryClip(clip);
+                                    }
+                                } catch (Exception e) {
+                                    FileLog.e("tmessages", e);
+                                }
+                            }
+                        }
+                    });
+                    showDialog(builder.create());
+                } else if (position == phoneRow) {
                     final TLRPC.User user = MessagesController.getInstance().getUser(user_id);
                     if (user == null || user.phone == null || user.phone.length() == 0 || getParentActivity() == null) {
                         return;
@@ -600,49 +598,48 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     showDialog(builder.create());
-                } else if (i > emptyRowChat2 && i < membersEndRow) {
-                    int user_id = info.participants.participants.get(sortedUsers.get(i - emptyRowChat2 - 1)).user_id;
+                } else if (position > emptyRowChat2 && position < membersEndRow) {
+                    int user_id;
+                    if (participants != null) {
+                        user_id = participants.get(position - emptyRowChat2 - 1).user_id;
+                    } else {
+                        user_id = info.participants.participants.get(sortedUsers.get(position - emptyRowChat2 - 1)).user_id;
+                    }
                     if (user_id == UserConfig.getClientUserId()) {
                         return;
                     }
                     Bundle args = new Bundle();
                     args.putInt("user_id", user_id);
                     presentFragment(new ProfileActivity(args));
-                } else if (i == addMemberRow) {
+                } else if (position == addMemberRow) {
                     openAddMember();
-                } else if (i == channelNameRow) {
+                } else if (position == channelNameRow) {
                     try {
                         Intent intent = new Intent(Intent.ACTION_SEND);
                         intent.setType("text/plain");
-                        intent.putExtra(Intent.EXTRA_TEXT, "https://telegram.me/" + currentChat.username);
+                        if (info.about != null && info.about.length() > 0) {
+                            intent.putExtra(Intent.EXTRA_TEXT, currentChat.title + "\n" + info.about + "\nhttps://telegram.me/" + currentChat.username);
+                        } else {
+                            intent.putExtra(Intent.EXTRA_TEXT, currentChat.title + "\nhttps://telegram.me/" + currentChat.username);
+                        }
                         getParentActivity().startActivityForResult(Intent.createChooser(intent, LocaleController.getString("BotShare", R.string.BotShare)), 500);
                     } catch (Exception e) {
                         FileLog.e("tmessages", e);
                     }
-                } else if (i == leaveChannelRow) {
-                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
-                    builder.setMessage(ChatObject.isChannel(chat_id) ? LocaleController.getString("ChannelLeaveAlert", R.string.ChannelLeaveAlert) : LocaleController.getString("AreYouSureDeleteAndExit", R.string.AreYouSureDeleteAndExit));
-                    builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
-                    builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialogInterface, int i) {
-                            kickUser(null);
-                        }
-                    });
-                    builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
-                    showDialog(builder.create());
-                } else if (i == membersRow || i == blockedUsersRow || i == managementRow) {
+                } else if (position == leaveChannelRow) {
+                    leaveChatPressed();
+                } else if (position == membersRow || position == blockedUsersRow || position == managementRow) {
                     Bundle args = new Bundle();
                     args.putInt("chat_id", chat_id);
-                    if (i == blockedUsersRow) {
+                    if (position == blockedUsersRow) {
                         args.putInt("type", 0);
-                    } else if (i == managementRow) {
+                    } else if (position == managementRow) {
                         args.putInt("type", 1);
-                    } else if (i == membersRow) {
+                    } else if (position == membersRow) {
                         args.putInt("type", 2);
                     }
                     presentFragment(new ChannelUsersActivity(args));
-                } else if (i == channelInfoRow) {
+                } else if (position == channelInfoRow) {
                     AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                     builder.setItems(new CharSequence[]{LocaleController.getString("Copy", R.string.Copy)}, new DialogInterface.OnClickListener() {
                         @Override
@@ -662,69 +659,217 @@ public void onClick(DialogInterface dialogInterface, int i) {
                         }
                     });
                     showDialog(builder.create());
+                } else if (position == convertRow) {
+                    AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+                    builder.setMessage(LocaleController.getString("ConvertGroupAlert", R.string.ConvertGroupAlert));
+                    builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+                    builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            MessagesController.getInstance().convertToMegaGroup(getParentActivity(), chat_id);
+                        }
+                    });
+                    builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+                    showDialog(builder.create());
                 }
             }
         });
+
         if (chat_id != 0) {
-            listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
+            listView.setOnItemLongClickListener(new RecyclerListView.OnItemLongClickListener() {
                 @Override
-                public boolean onItemLongClick(AdapterView<?> adapterView, View view, int i, long l) {
-                    if (i > emptyRowChat2 && i < membersEndRow) {
+                public boolean onItemClick(View view, int position) {
+                    if (position > emptyRowChat2 && position < membersEndRow) {
                         if (getParentActivity() == null) {
                             return false;
                         }
-
-                        TLRPC.TL_chatParticipant user = info.participants.participants.get(sortedUsers.get(i - emptyRowChat2 - 1));
-                        if (user.user_id == UserConfig.getClientUserId()) {
-                            return false;
+                        boolean allowKick = false;
+                        boolean allowSetAdmin = false;
+                        TLRPC.ChannelParticipant channelParticipant = null;
+                        if (ChatObject.isChannel(currentChat)) {
+                            channelParticipant = participants.get(position - emptyRowChat2 - 1);
+                            if (channelParticipant.user_id != UserConfig.getClientUserId()) {
+                                if (currentChat.creator) {
+                                    allowKick = true;
+                                } else if (channelParticipant instanceof TLRPC.TL_channelParticipant) {
+                                    if (currentChat.editor || channelParticipant.inviter_id == UserConfig.getClientUserId()) {
+                                        allowKick = true;
+                                    }
+                                }
+                            }
+                            TLRPC.User u = MessagesController.getInstance().getUser(channelParticipant.user_id);
+                            allowSetAdmin = channelParticipant instanceof TLRPC.TL_channelParticipant && !u.bot;
+                            selectedUser = channelParticipant.user_id;
+                        } else {
+                            TLRPC.ChatParticipant user = info.participants.participants.get(sortedUsers.get(position - emptyRowChat2 - 1));
+                            if (user.user_id != UserConfig.getClientUserId()) {
+                                if (currentChat.creator) {
+                                    allowKick = true;
+                                } else if (user instanceof TLRPC.TL_chatParticipant) {
+                                    if (currentChat.admin && currentChat.admins_enabled || user.inviter_id == UserConfig.getClientUserId()) {
+                                        allowKick = true;
+                                    }
+                                }
+                            }
+                            selectedUser = user.user_id;
                         }
-                        if (info.participants.admin_id != UserConfig.getClientUserId() && user.inviter_id != UserConfig.getClientUserId()) {
+                        if (!allowKick) {
                             return false;
                         }
-                        selectedUser = user;
-
                         AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
-                        CharSequence[] items = new CharSequence[]{chat_id > 0 ? LocaleController.getString("KickFromGroup", R.string.KickFromGroup) : LocaleController.getString("KickFromBroadcast", R.string.KickFromBroadcast)};
-
-                        builder.setItems(items, new DialogInterface.OnClickListener() {
-                            @Override
-                            public void onClick(DialogInterface dialogInterface, int i) {
-                                if (i == 0) {
-                                    kickUser(selectedUser);
+                        if (currentChat.megagroup && currentChat.creator && allowSetAdmin) {
+                            final TLRPC.ChannelParticipant channelParticipantFinal = channelParticipant;
+                            CharSequence[] items = new CharSequence[]{LocaleController.getString("SetAsAdmin", R.string.SetAsAdmin), LocaleController.getString("KickFromGroup", R.string.KickFromGroup)};
+                            builder.setItems(items, new DialogInterface.OnClickListener() {
+                                @Override
+                                public void onClick(DialogInterface dialogInterface, int i) {
+                                    if (i == 0) {
+                                        int index = participants.indexOf(channelParticipantFinal);
+                                        if (index != -1) {
+                                            TLRPC.TL_channelParticipantEditor editor = new TLRPC.TL_channelParticipantEditor();
+                                            editor.inviter_id = UserConfig.getClientUserId();
+                                            editor.user_id = channelParticipantFinal.user_id;
+                                            editor.date = channelParticipantFinal.date;
+                                            participants.set(index, editor);
+                                        }
+                                        TLRPC.TL_channels_editAdmin req = new TLRPC.TL_channels_editAdmin();
+                                        req.channel = MessagesController.getInputChannel(chat_id);
+                                        req.user_id = MessagesController.getInputUser(selectedUser);
+                                        req.role = new TLRPC.TL_channelRoleEditor();
+                                        ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+                                            @Override
+                                            public void run(TLObject response, final TLRPC.TL_error error) {
+                                                if (error == null) {
+                                                    MessagesController.getInstance().processUpdates((TLRPC.Updates) response, false);
+                                                    AndroidUtilities.runOnUIThread(new Runnable() {
+                                                        @Override
+                                                        public void run() {
+                                                            MessagesController.getInstance().loadFullChat(chat_id, 0, true);
+                                                        }
+                                                    }, 1000);
+                                                } else {
+                                                    AndroidUtilities.runOnUIThread(new Runnable() {
+                                                        @Override
+                                                        public void run() {
+                                                            AlertsCreator.showAddUserAlert(error.text, ProfileActivity.this, false);
+                                                        }
+                                                    });
+                                                }
+                                            }
+                                        });
+                                    } else if (i == 1) {
+                                        kickUser(selectedUser);
+                                    }
                                 }
-                            }
-                        });
+                            });
+                        } else {
+                            CharSequence[] items = new CharSequence[]{chat_id > 0 ? LocaleController.getString("KickFromGroup", R.string.KickFromGroup) : LocaleController.getString("KickFromBroadcast", R.string.KickFromBroadcast)};
+                            builder.setItems(items, new DialogInterface.OnClickListener() {
+                                @Override
+                                public void onClick(DialogInterface dialogInterface, int i) {
+                                    if (i == 0) {
+                                        kickUser(selectedUser);
+                                    }
+                                }
+                            });
+                        }
                         showDialog(builder.create());
-
                         return true;
                     }
                     return false;
                 }
             });
         }
-        if (dialog_id != 0) {
-            SharedMediaQuery.getMediaCount(dialog_id, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
-        } else {
-            SharedMediaQuery.getMediaCount(user_id, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
-        }
 
         frameLayout.addView(actionBar);
 
+        extraHeightView = new View(context);
+        ViewProxy.setPivotY(extraHeightView, 0);
+        extraHeightView.setBackgroundColor(AvatarDrawable.getProfileBackColorForId(user_id != 0 || ChatObject.isChannel(chat_id) && !currentChat.megagroup ? 5 : chat_id));
+        frameLayout.addView(extraHeightView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 88));
+
+        shadowView = new View(context);
+        try {
+            shadowView.setBackgroundResource(R.drawable.header_shadow);
+        } catch (Throwable e) {
+            FileLog.e("tmessages", e);
+        }
+        frameLayout.addView(shadowView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 3));
+
+        avatarImage = new BackupImageView(context);
+        avatarImage.setRoundRadius(AndroidUtilities.dp(21));
+        ViewProxy.setPivotX(avatarImage, 0);
+        ViewProxy.setPivotY(avatarImage, 0);
+        frameLayout.addView(avatarImage, LayoutHelper.createFrame(42, 42, Gravity.TOP | Gravity.LEFT, 64, 0, 0, 0));
+        avatarImage.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (user_id != 0) {
+                    TLRPC.User user = MessagesController.getInstance().getUser(user_id);
+                    if (user.photo != null && user.photo.photo_big != null) {
+                        PhotoViewer.getInstance().setParentActivity(getParentActivity());
+                        PhotoViewer.getInstance().openPhoto(user.photo.photo_big, ProfileActivity.this);
+                    }
+                } else if (chat_id != 0) {
+                    TLRPC.Chat chat = MessagesController.getInstance().getChat(chat_id);
+                    if (chat.photo != null && chat.photo.photo_big != null) {
+                        PhotoViewer.getInstance().setParentActivity(getParentActivity());
+                        PhotoViewer.getInstance().openPhoto(chat.photo.photo_big, ProfileActivity.this);
+                    }
+                }
+            }
+        });
+
+        for (int a = 0; a < 2; a++) {
+            if (!playProfileAnimation && a == 0) {
+                continue;
+            }
+            nameTextView[a] = new TextView(context);
+            nameTextView[a].setTextColor(0xffffffff);
+            nameTextView[a].setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
+            nameTextView[a].setLines(1);
+            nameTextView[a].setMaxLines(1);
+            nameTextView[a].setSingleLine(true);
+            nameTextView[a].setEllipsize(TextUtils.TruncateAt.END);
+            nameTextView[a].setGravity(Gravity.LEFT);
+            nameTextView[a].setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+            nameTextView[a].setCompoundDrawablePadding(AndroidUtilities.dp(4));
+            ViewProxy.setPivotX(nameTextView[a], 0);
+            ViewProxy.setPivotY(nameTextView[a], 0);
+            frameLayout.addView(nameTextView[a], LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP, 118, 0, a == 0 ? 48 : 0, 0));
+
+            onlineTextView[a] = new TextView(context);
+            onlineTextView[a].setTextColor(AvatarDrawable.getProfileTextColorForId(user_id != 0 || ChatObject.isChannel(chat_id) && !currentChat.megagroup ? 5 : chat_id));
+            onlineTextView[a].setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+            onlineTextView[a].setLines(1);
+            onlineTextView[a].setMaxLines(1);
+            onlineTextView[a].setSingleLine(true);
+            onlineTextView[a].setEllipsize(TextUtils.TruncateAt.END);
+            onlineTextView[a].setGravity(Gravity.LEFT);
+            frameLayout.addView(onlineTextView[a], LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP, 118, 0, a == 0 ? 48 : 8, 0));
+        }
+
         if (user_id != 0 || chat_id >= 0 && !ChatObject.isLeftFromChat(currentChat)) {
             writeButton = new ImageView(context);
-            writeButton.setBackgroundResource(R.drawable.floating_user_states);
+            try {
+                writeButton.setBackgroundResource(R.drawable.floating_user_states);
+            } catch (Throwable e) {
+                FileLog.e("tmessages", e);
+            }
             writeButton.setScaleType(ImageView.ScaleType.CENTER);
             if (user_id != 0) {
                 writeButton.setImageResource(R.drawable.floating_message);
                 writeButton.setPadding(0, AndroidUtilities.dp(3), 0, 0);
             } else if (chat_id != 0) {
-                if (ChatObject.isChannel(currentChat) && (currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) == 0) {
+                boolean isChannel = ChatObject.isChannel(currentChat);
+                if (isChannel && !currentChat.creator && (!currentChat.megagroup || !currentChat.editor) || !isChannel && !currentChat.admin && !currentChat.creator && currentChat.admins_enabled) {
                     writeButton.setImageResource(R.drawable.floating_message);
+                    writeButton.setPadding(0, AndroidUtilities.dp(3), 0, 0);
                 } else {
                     writeButton.setImageResource(R.drawable.floating_camera);
                 }
             }
-            frameLayout.addView(writeButton);
+            frameLayout.addView(writeButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.RIGHT | Gravity.TOP, 0, 0, 16, 0));
             if (Build.VERSION.SDK_INT >= 21) {
                 StateListAnimator animator = new StateListAnimator();
                 animator.addState(new int[]{android.R.attr.state_pressed}, ObjectAnimator.ofFloat(writeButton, "translationZ", AndroidUtilities.dp(2), AndroidUtilities.dp(4)).setDuration(200));
@@ -738,13 +883,6 @@ public void getOutline(View view, Outline outline) {
                     }
                 });
             }
-            layoutParams = (FrameLayout.LayoutParams) writeButton.getLayoutParams();
-            layoutParams.width = LayoutHelper.WRAP_CONTENT;
-            layoutParams.height = LayoutHelper.WRAP_CONTENT;
-            layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? 16 : 0);
-            layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? 0 : 16);
-            layoutParams.gravity = (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT);
-            writeButton.setLayoutParams(layoutParams);
             writeButton.setOnClickListener(new View.OnClickListener() {
                 @Override
                 public void onClick(View v) {
@@ -752,22 +890,31 @@ public void onClick(View v) {
                         return;
                     }
                     if (user_id != 0) {
-                        TLRPC.User user = MessagesController.getInstance().getUser(user_id);
-                        if (user == null || user instanceof TLRPC.TL_userEmpty) {
-                            return;
-                        }
-                        NotificationCenter.getInstance().removeObserver(ProfileActivity.this, NotificationCenter.closeChats);
-                        NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
-                        Bundle args = new Bundle();
-                        args.putInt("user_id", user_id);
-                        presentFragment(new ChatActivity(args), true);
-                    } else if (chat_id != 0) {
-                        if (ChatObject.isChannel(currentChat) && (currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) == 0) {
+                        if (playProfileAnimation && parentLayout.fragmentsStack.get(parentLayout.fragmentsStack.size() - 2) instanceof ChatActivity) {
+                            finishFragment();
+                        } else {
+                            TLRPC.User user = MessagesController.getInstance().getUser(user_id);
+                            if (user == null || user instanceof TLRPC.TL_userEmpty) {
+                                return;
+                            }
                             NotificationCenter.getInstance().removeObserver(ProfileActivity.this, NotificationCenter.closeChats);
                             NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
                             Bundle args = new Bundle();
-                            args.putInt("chat_id", currentChat.id);
+                            args.putInt("user_id", user_id);
                             presentFragment(new ChatActivity(args), true);
+                        }
+                    } else if (chat_id != 0) {
+                        boolean isChannel = ChatObject.isChannel(currentChat);
+                        if (isChannel && !currentChat.creator && (!currentChat.megagroup || !currentChat.editor) || !isChannel && !currentChat.admin && !currentChat.creator && currentChat.admins_enabled) {
+                            if (playProfileAnimation && parentLayout.fragmentsStack.get(parentLayout.fragmentsStack.size() - 2) instanceof ChatActivity) {
+                                finishFragment();
+                            } else {
+                                NotificationCenter.getInstance().removeObserver(ProfileActivity.this, NotificationCenter.closeChats);
+                                NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
+                                Bundle args = new Bundle();
+                                args.putInt("chat_id", currentChat.id);
+                                presentFragment(new ChatActivity(args), true);
+                            }
                         } else {
                             AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                             CharSequence[] items;
@@ -796,22 +943,44 @@ public void onClick(DialogInterface dialogInterface, int i) {
                 }
             });
         }
+        needLayout();
 
-        listView.setOnScrollListener(new AbsListView.OnScrollListener() {
+        listView.setOnScrollListener(new RecyclerView.OnScrollListener() {
             @Override
-            public void onScrollStateChanged(AbsListView view, int scrollState) {
-
+            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
+                super.onScrollStateChanged(recyclerView, newState);
             }
 
             @Override
-            public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
+            public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
                 checkListViewScroll();
+                if (participants != null && loadMoreMembersRow != -1 && layoutManager.findLastVisibleItemPosition() > loadMoreMembersRow - 8) {
+                    getChannelParticipants(false);
+                }
             }
         });
 
         return fragmentView;
     }
 
+    private void leaveChatPressed() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
+        if (ChatObject.isChannel(chat_id) && !currentChat.megagroup) {
+            builder.setMessage(ChatObject.isChannel(chat_id) ? LocaleController.getString("ChannelLeaveAlert", R.string.ChannelLeaveAlert) : LocaleController.getString("AreYouSureDeleteAndExit", R.string.AreYouSureDeleteAndExit));
+        } else {
+            builder.setMessage(LocaleController.getString("AreYouSureDeleteAndExit", R.string.AreYouSureDeleteAndExit));
+        }
+        builder.setTitle(LocaleController.getString("AppName", R.string.AppName));
+        builder.setPositiveButton(LocaleController.getString("OK", R.string.OK), new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialogInterface, int i) {
+                kickUser(0);
+            }
+        });
+        builder.setNegativeButton(LocaleController.getString("Cancel", R.string.Cancel), null);
+        showDialog(builder.create());
+    }
+
     @Override
     public void saveSelfArgs(Bundle args) {
         if (chat_id != 0) {
@@ -838,14 +1007,67 @@ public void onActivityResultFragment(int requestCode, int resultCode, Intent dat
         }
     }
 
+    private void getChannelParticipants(boolean reload) {
+        if (loadingUsers || participants == null) {
+            return;
+        }
+        loadingUsers = true;
+        final int delay = Build.VERSION.SDK_INT >= 11 && !participants.isEmpty() && reload ? 300 : 0;
+
+        final TLRPC.TL_channels_getParticipants req = new TLRPC.TL_channels_getParticipants();
+        req.channel = MessagesController.getInputChannel(chat_id);
+        req.filter = new TLRPC.TL_channelParticipantsRecent();
+        req.offset = reload ? 0 : participants.size();
+        req.limit = 33;
+        int reqId = ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+            @Override
+            public void run(final TLObject response, final TLRPC.TL_error error) {
+                AndroidUtilities.runOnUIThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (error == null) {
+                            TLRPC.TL_channels_channelParticipants res = (TLRPC.TL_channels_channelParticipants) response;
+                            MessagesController.getInstance().putUsers(res.users, false);
+                            if (res.participants.size() == 33) {
+                                res.participants.remove(32);
+                            } else {
+                                usersEndReached = true;
+                            }
+                            if (req.offset == 0) {
+                                participants.clear();
+                                participantsMap.clear();
+                                MessagesStorage.getInstance().putUsersAndChats(res.users, null, true, true);
+                                MessagesStorage.getInstance().updateChannelUsers(chat_id, res.participants);
+                            }
+                            for (int a = 0; a < res.participants.size(); a++) {
+                                TLRPC.ChannelParticipant participant = res.participants.get(a);
+                                if (!participantsMap.containsKey(participant.user_id)) {
+                                    participants.add(participant);
+                                    participantsMap.put(participant.user_id, participant);
+                                }
+                            }
+                        }
+                        loadingUsers = false;
+                        updateRowsIds();
+                        if (listAdapter != null) {
+                            listAdapter.notifyDataSetChanged();
+                        }
+                    }
+                }, delay);
+            }
+        });
+        ConnectionsManager.getInstance().bindRequestToGuid(reqId, classGuid);
+    }
+
     private void openAddMember() {
         Bundle args = new Bundle();
         args.putBoolean("onlyUsers", true);
         args.putBoolean("destroyAfterSelect", true);
         args.putBoolean("returnAsResult", true);
+        args.putBoolean("needForwardCount", !ChatObject.isChannel(currentChat));
         //args.putBoolean("allowUsernameSearch", false);
         if (chat_id > 0) {
-            if ((currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0) {
+            if (currentChat.creator) {
                 args.putInt("chat_id", currentChat.id);
             }
             args.putString("selectAlertString", LocaleController.getString("AddToTheGroup", R.string.AddToTheGroup));
@@ -854,13 +1076,19 @@ private void openAddMember() {
         fragment.setDelegate(new ContactsActivity.ContactsActivityDelegate() {
             @Override
             public void didSelectContact(TLRPC.User user, String param) {
-                MessagesController.getInstance().addUserToChat(chat_id, user, info, param != null ? Utilities.parseInt(param) : 0, null, null);
+                MessagesController.getInstance().addUserToChat(chat_id, user, info, param != null ? Utilities.parseInt(param) : 0, null, ProfileActivity.this);
             }
         });
         if (info instanceof TLRPC.TL_chatFull) {
             HashMap<Integer, TLRPC.User> users = new HashMap<>();
-            for (TLRPC.TL_chatParticipant p : info.participants.participants) {
-                users.put(p.user_id, null);
+            for (int a = 0; a < info.participants.participants.size(); a++) {
+                users.put(info.participants.participants.get(a).user_id, null);
+            }
+            fragment.setIgnoreUsers(users);
+        } else if (participants != null) {
+            HashMap<Integer, TLRPC.User> users = new HashMap<>();
+            for (int a = 0; a < participants.size(); a++) {
+                users.put(participants.get(a).user_id, null);
             }
             fragment.setIgnoreUsers(users);
         }
@@ -868,17 +1096,17 @@ public void didSelectContact(TLRPC.User user, String param) {
     }
 
     private void checkListViewScroll() {
-        if (listView.getChildCount() == 0) {
+        if (listView.getChildCount() == 0 || openAnimationInProgress) {
             return;
         }
         int height = 0;
         View child = listView.getChildAt(0);
         if (child != null) {
-            if (listView.getFirstVisiblePosition() == 0) {
+            if (layoutManager.findFirstVisibleItemPosition() == 0) {
                 height = AndroidUtilities.dp(88) + (child.getTop() < 0 ? child.getTop() : 0);
             }
-            if (actionBar.getExtraHeight() != height) {
-                actionBar.setExtraHeight(height, true);
+            if (extraHeight != height) {
+                extraHeight = height;
                 needLayout();
             }
         }
@@ -886,118 +1114,150 @@ private void checkListViewScroll() {
 
     private void needLayout() {
         FrameLayout.LayoutParams layoutParams;
-        if (listView != null) {
+        int newTop = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight();
+        if (listView != null && !openAnimationInProgress) {
             layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
-            layoutParams.topMargin = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight();
-            listView.setLayoutParams(layoutParams);
+            if (layoutParams.topMargin != newTop) {
+                layoutParams.topMargin = newTop;
+                listView.setLayoutParams(layoutParams);
+                ViewProxy.setTranslationY(extraHeightView, newTop);
+            }
         }
 
         if (avatarImage != null) {
-            float diff = actionBar.getExtraHeight() / (float)AndroidUtilities.dp(88);
-            float diffm = 1.0f - diff;
-
-            int avatarSize = 42 + (int)(18 * diff);
-            int avatarX = 17 + (int)(47 * diffm);
-            int avatarY = AndroidUtilities.dp(22) - (int)((AndroidUtilities.dp(22) - (ActionBar.getCurrentActionBarHeight() - AndroidUtilities.dp(42)) / 2) * (1.0f - diff));
-            int nameX = 97 + (int)(21 * diffm);
-            int nameEndX = 16 + (int)(32 * diffm);
-            int nameY = avatarY + AndroidUtilities.dp(29 - 10 * diffm);
-            int statusY = avatarY + AndroidUtilities.dp(8 - 7 * diffm);
-            float scale = 1.0f - 0.12f * diffm;
+            float diff = extraHeight / (float) AndroidUtilities.dp(88);
+            ViewProxy.setScaleY(extraHeightView, diff);
+            ViewProxy.setTranslationY(shadowView, newTop + extraHeight);
+            listView.setTopGlowOffset(extraHeight);
 
             if (writeButton != null) {
-                layoutParams = (FrameLayout.LayoutParams) writeButton.getLayoutParams();
-                layoutParams.topMargin = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight() + actionBar.getExtraHeight() - AndroidUtilities.dp(29.5f);
-                writeButton.setLayoutParams(layoutParams);
-                /*ViewProxy.setAlpha(writeButton, diff);
-                writeButton.setVisibility(diff <= 0.02 ? View.GONE : View.VISIBLE);
-                if (writeButton.getVisibility() == View.GONE) {
-                    writeButton.clearAnimation();
-                }*/
-                final boolean setVisible = diff > 0.2f;
-                boolean currentVisible = writeButton.getTag() == null;
-                if (setVisible != currentVisible) {
-                    if (setVisible) {
-                        writeButton.setTag(null);
-                        writeButton.setVisibility(View.VISIBLE);
-                    } else {
-                        writeButton.setTag(0);
-                    }
-                    if (writeButtonAnimation != null) {
-                        AnimatorSetProxy old = writeButtonAnimation;
-                        writeButtonAnimation = null;
-                        old.cancel();
-                    }
-                    writeButtonAnimation = new AnimatorSetProxy();
-                    if (setVisible) {
-                        writeButtonAnimation.setInterpolator(new DecelerateInterpolator());
-                        writeButtonAnimation.playTogether(
-                                ObjectAnimatorProxy.ofFloat(writeButton, "scaleX", 1.0f),
-                                ObjectAnimatorProxy.ofFloat(writeButton, "scaleY", 1.0f),
-                                ObjectAnimatorProxy.ofFloat(writeButton, "alpha", 1.0f)
-                        );
-                    } else {
-                        writeButtonAnimation.setInterpolator(new AccelerateInterpolator());
-                        writeButtonAnimation.playTogether(
-                                ObjectAnimatorProxy.ofFloat(writeButton, "scaleX", 0.2f),
-                                ObjectAnimatorProxy.ofFloat(writeButton, "scaleY", 0.2f),
-                                ObjectAnimatorProxy.ofFloat(writeButton, "alpha", 0.0f)
-                        );
-                    }
-                    writeButtonAnimation.setDuration(150);
-                    writeButtonAnimation.addListener(new AnimatorListenerAdapterProxy() {
-                        @Override
-                        public void onAnimationEnd(Object animation) {
-                            if (writeButtonAnimation != null && writeButtonAnimation.equals(animation)) {
-                                writeButton.clearAnimation();
-                                writeButton.setVisibility(setVisible ? View.VISIBLE : View.GONE);
-                                writeButtonAnimation = null;
+                if (Build.VERSION.SDK_INT < 11) {
+                    layoutParams = (FrameLayout.LayoutParams) writeButton.getLayoutParams();
+                    layoutParams.topMargin = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight() + extraHeight - AndroidUtilities.dp(29.5f);
+                    writeButton.setLayoutParams(layoutParams);
+                } else {
+                    ViewProxy.setTranslationY(writeButton, (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight() + extraHeight - AndroidUtilities.dp(29.5f));
+                }
+
+                if (!openAnimationInProgress) {
+                    final boolean setVisible = diff > 0.2f;
+                    boolean currentVisible = writeButton.getTag() == null;
+                    if (setVisible != currentVisible) {
+                        if (setVisible) {
+                            writeButton.setTag(null);
+                            if (Build.VERSION.SDK_INT < 11) {
+                                writeButton.setVisibility(View.VISIBLE);
                             }
+                        } else {
+                            writeButton.setTag(0);
                         }
-                    });
-                    writeButtonAnimation.start();
-                }
-            }
-
-            avatarImage.setRoundRadius(AndroidUtilities.dp(avatarSize / 2));
-            layoutParams = (FrameLayout.LayoutParams) avatarImage.getLayoutParams();
-            layoutParams.width = AndroidUtilities.dp(avatarSize);
-            layoutParams.height = AndroidUtilities.dp(avatarSize);
-            layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(avatarX);
-            layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(avatarX) : 0;
-            layoutParams.bottomMargin = avatarY;
-            avatarImage.setLayoutParams(layoutParams);
-
-            ViewProxy.setPivotX(nameTextView, 0);
-            ViewProxy.setPivotY(nameTextView, 0);
-            ViewProxy.setScaleX(nameTextView, scale);
-            ViewProxy.setScaleY(nameTextView, scale);
-            layoutParams = (FrameLayout.LayoutParams) nameTextView.getLayoutParams();
-            layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? nameEndX : nameX);
-            layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? nameX : nameEndX);
-            layoutParams.bottomMargin = nameY;
-            nameTextView.setLayoutParams(layoutParams);
-
-            layoutParams = (FrameLayout.LayoutParams) onlineTextView.getLayoutParams();
-            layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? nameEndX : nameX);
-            layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? nameX : nameEndX);
-            layoutParams.bottomMargin = statusY;
-            onlineTextView.setLayoutParams(layoutParams);
-        }
-    }
-
-    private void fixLayout() {
-        if (fragmentView == null) {
-            return;
-        }
-        fragmentView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
-            @Override
-            public boolean onPreDraw() {
-                if (fragmentView != null) {
-                    needLayout();
-                    fragmentView.getViewTreeObserver().removeOnPreDrawListener(this);
+                        if (writeButtonAnimation != null) {
+                            AnimatorSetProxy old = writeButtonAnimation;
+                            writeButtonAnimation = null;
+                            old.cancel();
+                        }
+                        writeButtonAnimation = new AnimatorSetProxy();
+                        if (setVisible) {
+                            writeButtonAnimation.setInterpolator(new DecelerateInterpolator());
+                            writeButtonAnimation.playTogether(
+                                    ObjectAnimatorProxy.ofFloat(writeButton, "scaleX", 1.0f),
+                                    ObjectAnimatorProxy.ofFloat(writeButton, "scaleY", 1.0f),
+                                    ObjectAnimatorProxy.ofFloat(writeButton, "alpha", 1.0f)
+                            );
+                        } else {
+                            writeButtonAnimation.setInterpolator(new AccelerateInterpolator());
+                            writeButtonAnimation.playTogether(
+                                    ObjectAnimatorProxy.ofFloat(writeButton, "scaleX", 0.2f),
+                                    ObjectAnimatorProxy.ofFloat(writeButton, "scaleY", 0.2f),
+                                    ObjectAnimatorProxy.ofFloat(writeButton, "alpha", 0.0f)
+                            );
+                        }
+                        writeButtonAnimation.setDuration(150);
+                        writeButtonAnimation.addListener(new AnimatorListenerAdapterProxy() {
+                            @Override
+                            public void onAnimationEnd(Object animation) {
+                                if (writeButtonAnimation != null && writeButtonAnimation.equals(animation)) {
+                                    writeButton.clearAnimation();
+                                    if (Build.VERSION.SDK_INT < 11) {
+                                        writeButton.setVisibility(setVisible ? View.VISIBLE : View.GONE);
+                                    }
+                                    writeButtonAnimation = null;
+                                }
+                            }
+                        });
+                        writeButtonAnimation.start();
+                    }
                 }
-                return true;
+            }
+
+            float avatarY = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight() / 2.0f * (1.0f + diff) - 21 * AndroidUtilities.density + 27 * AndroidUtilities.density * diff;
+            if (Build.VERSION.SDK_INT < 11) {
+                layoutParams = (FrameLayout.LayoutParams) avatarImage.getLayoutParams();
+                layoutParams.height = layoutParams.width = (int) Math.ceil(AndroidUtilities.dp(42) * (42 + 18 * diff) / 42.0f);
+                layoutParams.leftMargin = (int) Math.ceil(AndroidUtilities.dp(64) - AndroidUtilities.dp(47) * diff);
+                layoutParams.topMargin = (int) Math.ceil(avatarY);
+                avatarImage.setLayoutParams(layoutParams);
+                avatarImage.setRoundRadius(layoutParams.height / 2);
+            } else {
+                ViewProxy.setScaleX(avatarImage, (42 + 18 * diff) / 42.0f);
+                ViewProxy.setScaleY(avatarImage, (42 + 18 * diff) / 42.0f);
+                ViewProxy.setTranslationX(avatarImage, -AndroidUtilities.dp(47) * diff);
+                ViewProxy.setTranslationY(avatarImage, (float) Math.ceil(avatarY));
+            }
+            for (int a = 0; a < 2; a++) {
+                if (nameTextView[a] == null) {
+                    continue;
+                }
+                ViewProxy.setTranslationX(nameTextView[a], -21 * AndroidUtilities.density * diff);
+                ViewProxy.setTranslationY(nameTextView[a], (float) Math.floor(avatarY) - (float) Math.ceil(AndroidUtilities.density) + (float) Math.floor(7 * AndroidUtilities.density * diff));
+                ViewProxy.setTranslationX(onlineTextView[a], -21 * AndroidUtilities.density * diff);
+                ViewProxy.setTranslationY(onlineTextView[a], (float) Math.floor(avatarY) + AndroidUtilities.dp(22) + (float) Math.floor(11 * AndroidUtilities.density) * diff);
+                ViewProxy.setScaleX(nameTextView[a], 1.0f + 0.12f * diff);
+                ViewProxy.setScaleY(nameTextView[a], 1.0f + 0.12f * diff);
+                if (a == 1 && !openAnimationInProgress) {
+                    int width;
+                    if (AndroidUtilities.isTablet()) {
+                        width = AndroidUtilities.dp(490);
+                    } else {
+                        width = AndroidUtilities.displaySize.x;
+                    }
+                    width = (int) (width - AndroidUtilities.dp(118 + 8 + 40 * (1.0f - diff)) - ViewProxy.getTranslationX(nameTextView[a]));
+                    float width2 = nameTextView[a].getPaint().measureText(nameTextView[a].getText().toString()) * ViewProxy.getScaleX(nameTextView[a]);
+                    Drawable[] drawables = nameTextView[a].getCompoundDrawables();
+                    for (int b = 0; b < drawables.length; b++) {
+                        if (drawables[b] != null) {
+                            width2 += drawables[b].getIntrinsicWidth() + AndroidUtilities.dp(4);
+                        }
+                    }
+                    layoutParams = (FrameLayout.LayoutParams) nameTextView[a].getLayoutParams();
+                    if (width < width2) {
+                        layoutParams.width = (int) Math.ceil(width / ViewProxy.getScaleX(nameTextView[a]));
+                    } else {
+                        layoutParams.width = LayoutHelper.WRAP_CONTENT;
+                    }
+                    nameTextView[a].setLayoutParams(layoutParams);
+
+                    layoutParams = (FrameLayout.LayoutParams) onlineTextView[a].getLayoutParams();
+                    layoutParams.rightMargin = (int) Math.ceil(ViewProxy.getTranslationX(onlineTextView[a]) + AndroidUtilities.dp(8) + AndroidUtilities.dp(40) * (1.0f - diff));
+                    onlineTextView[a].setLayoutParams(layoutParams);
+                }
+            }
+        }
+    }
+
+    private void fixLayout() {
+        if (fragmentView == null) {
+            return;
+        }
+        fragmentView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                if (fragmentView != null) {
+                    checkListViewScroll();
+                    needLayout();
+                    fragmentView.getViewTreeObserver().removeOnPreDrawListener(this);
+                }
+                return true;
             }
         });
     }
@@ -1008,25 +1268,35 @@ public void onConfigurationChanged(Configuration newConfig) {
         fixLayout();
     }
 
-    @Override
-    public boolean needAddActionBar() {
-        return false;
-    }
-
+    @SuppressWarnings("unchecked")
     @Override
     public void didReceivedNotification(int id, final Object... args) {
         if (id == NotificationCenter.updateInterfaces) {
-            int mask = (Integer)args[0];
+            int mask = (Integer) args[0];
             if (user_id != 0) {
                 if ((mask & MessagesController.UPDATE_MASK_AVATAR) != 0 || (mask & MessagesController.UPDATE_MASK_NAME) != 0 || (mask & MessagesController.UPDATE_MASK_STATUS) != 0) {
                     updateProfileData();
                 }
                 if ((mask & MessagesController.UPDATE_MASK_PHONE) != 0) {
                     if (listView != null) {
-                        listView.invalidateViews();
+                        ListAdapter.Holder holder = (ListAdapter.Holder) listView.findViewHolderForPosition(phoneRow);
+                        if (holder != null) {
+                            listAdapter.onBindViewHolder(holder, phoneRow);
+                        }
                     }
                 }
             } else if (chat_id != 0) {
+                if ((mask & MessagesController.UPDATE_MASK_CHAT_ADMINS) != 0) {
+                    TLRPC.Chat newChat = MessagesController.getInstance().getChat(chat_id);
+                    if (newChat != null) {
+                        currentChat = newChat;
+                        createActionBarMenu();
+                        updateRowsIds();
+                        if (listAdapter != null) {
+                            listAdapter.notifyDataSetChanged();
+                        }
+                    }
+                }
                 if ((mask & MessagesController.UPDATE_MASK_CHANNEL) != 0 || (mask & MessagesController.UPDATE_MASK_CHAT_AVATAR) != 0 || (mask & MessagesController.UPDATE_MASK_CHAT_NAME) != 0 || (mask & MessagesController.UPDATE_MASK_CHAT_MEMBERS) != 0 || (mask & MessagesController.UPDATE_MASK_STATUS) != 0) {
                     updateOnlineCount();
                     updateProfileData();
@@ -1052,20 +1322,30 @@ public void didReceivedNotification(int id, final Object... args) {
         } else if (id == NotificationCenter.contactsDidLoaded) {
             createActionBarMenu();
         } else if (id == NotificationCenter.mediaCountDidLoaded) {
-            long uid = (Long)args[0];
-            if (user_id != 0) {
-                if (uid > 0 && user_id == uid && dialog_id == 0 || dialog_id != 0 && dialog_id == uid) {
+            long uid = (Long) args[0];
+            long did = dialog_id;
+            if (did == 0) {
+                if (user_id != 0) {
+                    did = user_id;
+                } else if (chat_id != 0) {
+                    did = -chat_id;
+                }
+            }
+            if (uid == did || uid == mergeDialogId) {
+                if (uid == did) {
                     totalMediaCount = (Integer) args[1];
-                    if (listView != null) {
-                        listView.invalidateViews();
-                    }
+                } else {
+                    totalMediaCountMerge = (Integer) args[1];
                 }
-            } else if (chat_id != 0) {
-                int lower_part = (int)uid;
-                if (lower_part < 0 && chat_id == -lower_part) {
-                    totalMediaCount = (Integer)args[1];
-                    if (listView != null) {
-                        listView.invalidateViews();
+                if (listView != null) {
+                    int count = listView.getChildCount();
+                    for (int a = 0; a < count; a++) {
+                        View child = listView.getChildAt(a);
+                        ListAdapter.Holder holder = (ListAdapter.Holder) listView.getChildViewHolder(child);
+                        if (holder.getAdapterPosition() == sharedMediaRow) {
+                            listAdapter.onBindViewHolder(holder, sharedMediaRow);
+                            break;
+                        }
                     }
                 }
             }
@@ -1084,7 +1364,7 @@ public void run() {
                 });
             }
         } else if (id == NotificationCenter.encryptedChatUpdated) {
-            TLRPC.EncryptedChat chat = (TLRPC.EncryptedChat)args[0];
+            TLRPC.EncryptedChat chat = (TLRPC.EncryptedChat) args[0];
             if (currentEncryptedChat != null && chat.id == currentEncryptedChat.id) {
                 currentEncryptedChat = chat;
                 updateRowsIds();
@@ -1102,13 +1382,32 @@ public void run() {
         } else if (id == NotificationCenter.chatInfoDidLoaded) {
             TLRPC.ChatFull chatFull = (TLRPC.ChatFull) args[0];
             if (chatFull.id == chat_id) {
+                boolean byChannelUsers = (Boolean) args[2];
+                if (info instanceof TLRPC.TL_channelFull) {
+                    if (chatFull.participants == null && info != null) {
+                        chatFull.participants = info.participants;
+                    }
+                }
                 info = chatFull;
+                if (mergeDialogId == 0 && info.migrated_from_chat_id != 0) {
+                    mergeDialogId = -info.migrated_from_chat_id;
+                    SharedMediaQuery.getMediaCount(mergeDialogId, SharedMediaQuery.MEDIA_PHOTOVIDEO, classGuid, true);
+                }
+                fetchUsersFromChannelInfo();
                 updateOnlineCount();
                 updateRowsIds();
                 if (listAdapter != null) {
                     listAdapter.notifyDataSetChanged();
                     checkListViewScroll();
                 }
+                TLRPC.Chat newChat = MessagesController.getInstance().getChat(chat_id);
+                if (newChat != null) {
+                    currentChat = newChat;
+                    createActionBarMenu();
+                }
+                if (currentChat.megagroup && !byChannelUsers) {
+                    getChannelParticipants(true);
+                }
             }
         } else if (id == NotificationCenter.closeChats) {
             removeSelfFromStack();
@@ -1117,6 +1416,25 @@ public void run() {
             if (info.user_id == user_id) {
                 botInfo = info;
                 updateRowsIds();
+                if (listAdapter != null) {
+                    listAdapter.notifyDataSetChanged();
+                    checkListViewScroll();
+                }
+            }
+        } else if (id == NotificationCenter.didReceivedNewMessages) {
+            long did = (Long) args[0];
+            if (did == dialog_id) {
+                ArrayList<MessageObject> arr = (ArrayList<MessageObject>) args[1];
+                for (int a = 0; a < arr.size(); a++) {
+                    MessageObject obj = arr.get(a);
+                    if (currentEncryptedChat != null && obj.messageOwner.action != null && obj.messageOwner.action instanceof TLRPC.TL_messageEncryptedAction && obj.messageOwner.action.encryptedAction instanceof TLRPC.TL_decryptedMessageActionSetMessageTTL) {
+                        TLRPC.TL_decryptedMessageActionSetMessageTTL action = (TLRPC.TL_decryptedMessageActionSetMessageTTL) obj.messageOwner.action.encryptedAction;
+                        if (listAdapter != null) {
+                            listAdapter.notifyDataSetChanged();
+                            checkListViewScroll();
+                        }
+                    }
+                }
             }
         }
     }
@@ -1131,6 +1449,180 @@ public void onResume() {
         fixLayout();
     }
 
+    public void setPlayProfileAnimation(boolean value) {
+        SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("mainconfig", Activity.MODE_PRIVATE);
+        if (!AndroidUtilities.isTablet() && Build.VERSION.SDK_INT > 10 && preferences.getBoolean("view_animations", true)) {
+            playProfileAnimation = value;
+        }
+    }
+
+    @Override
+    protected void onTransitionAnimationStart(boolean isOpen, boolean backward) {
+        if (!backward && playProfileAnimation) {
+            openAnimationInProgress = true;
+        }
+        NotificationCenter.getInstance().setAnimationInProgress(true);
+    }
+
+    @Override
+    protected void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (!backward && playProfileAnimation) {
+            openAnimationInProgress = false;
+        }
+        NotificationCenter.getInstance().setAnimationInProgress(false);
+    }
+
+    public float getAnimationProgress() {
+        return animationProgress;
+    }
+
+    public void setAnimationProgress(float progress) {
+        animationProgress = progress;
+        ViewProxy.setAlpha(listView, progress);
+        ViewProxy.setTranslationX(listView, AndroidUtilities.dp(48) * (1.0f - progress));
+        int color = AvatarDrawable.getProfileBackColorForId(user_id != 0 || ChatObject.isChannel(chat_id) && !currentChat.megagroup ? 5 : chat_id);
+        int rD = (int) ((Color.red(color) - 0x54) * progress);
+        int gD = (int) ((Color.green(color) - 0x75) * progress);
+        int bD = (int) ((Color.blue(color) - 0x9e) * progress);
+        actionBar.setBackgroundColor(Color.rgb(0x54 + rD, 0x75 + gD, 0x9e + bD));
+        extraHeightView.setBackgroundColor(Color.rgb(0x54 + rD, 0x75 + gD, 0x9e + bD));
+        color = AvatarDrawable.getProfileTextColorForId(user_id != 0 || ChatObject.isChannel(chat_id) && !currentChat.megagroup ? 5 : chat_id);
+        rD = (int) ((Color.red(color) - 0xd7) * progress);
+        gD = (int) ((Color.green(color) - 0xe8) * progress);
+        bD = (int) ((Color.blue(color) - 0xf7) * progress);
+        for (int a = 0; a < 2; a++) {
+            if (onlineTextView[a] == null) {
+                continue;
+            }
+            onlineTextView[a].setTextColor(Color.rgb(0xd7 + rD, 0xe8 + gD, 0xf7 + bD));
+        }
+        extraHeight = (int) (initialAnimationExtraHeight * progress);
+        color = AvatarDrawable.getProfileColorForId(user_id != 0 ? user_id : chat_id);
+        int color2 = AvatarDrawable.getColorForId(user_id != 0 ? user_id : chat_id);
+        if (color != color2) {
+            rD = (int) ((Color.red(color) - Color.red(color2)) * progress);
+            gD = (int) ((Color.green(color) - Color.green(color2)) * progress);
+            bD = (int) ((Color.blue(color) - Color.blue(color2)) * progress);
+            avatarDrawable.setColor(Color.rgb(Color.red(color2) + rD, Color.green(color2) + gD, Color.blue(color2) + bD));
+            avatarImage.invalidate();
+        }
+
+        needLayout();
+    }
+
+    @Override
+    protected AnimatorSetProxy onCustomTransitionAnimation(final boolean isOpen, final Runnable callback) {
+        if (playProfileAnimation) {
+            final AnimatorSetProxy animatorSet = new AnimatorSetProxy();
+            animatorSet.setDuration(150);
+            if (Build.VERSION.SDK_INT > 15) {
+                listView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
+            }
+            ActionBarMenu menu = actionBar.createMenu();
+            if (menu.getItem(10) == null) {
+                if (animatingItem == null) {
+                    animatingItem = menu.addItem(10, R.drawable.ic_ab_other);
+                }
+            }
+            if (isOpen) {
+                FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) onlineTextView[1].getLayoutParams();
+                layoutParams.rightMargin = (int) (-21 * AndroidUtilities.density + AndroidUtilities.dp(8));
+                onlineTextView[1].setLayoutParams(layoutParams);
+
+                int width = (int) Math.ceil(AndroidUtilities.displaySize.x - AndroidUtilities.dp(118 + 8) + 21 * AndroidUtilities.density);
+                float width2 = nameTextView[1].getPaint().measureText(nameTextView[1].getText().toString()) * 1.12f;
+                Drawable[] drawables = nameTextView[1].getCompoundDrawables();
+                for (int b = 0; b < drawables.length; b++) {
+                    if (drawables[b] != null) {
+                        width2 += drawables[b].getIntrinsicWidth() + AndroidUtilities.dp(4);
+                    }
+                }
+
+                layoutParams = (FrameLayout.LayoutParams) nameTextView[1].getLayoutParams();
+                if (width < width2) {
+                    layoutParams.width = (int) Math.ceil(width / 1.12f);
+                } else {
+                    layoutParams.width = LayoutHelper.WRAP_CONTENT;
+                }
+                nameTextView[1].setLayoutParams(layoutParams);
+
+                initialAnimationExtraHeight = AndroidUtilities.dp(88);
+                fragmentView.setBackgroundColor(0);
+                setAnimationProgress(0);
+                ArrayList<Object> animators = new ArrayList<>();
+                animators.add(ObjectAnimatorProxy.ofFloat(this, "animationProgress", 0.0f, 1.0f));
+                if (writeButton != null) {
+                    ViewProxy.setScaleX(writeButton, 0.2f);
+                    ViewProxy.setScaleY(writeButton, 0.2f);
+                    ViewProxy.setAlpha(writeButton, 0.0f);
+                    animators.add(ObjectAnimatorProxy.ofFloat(writeButton, "scaleX", 1.0f));
+                    animators.add(ObjectAnimatorProxy.ofFloat(writeButton, "scaleY", 1.0f));
+                    animators.add(ObjectAnimatorProxy.ofFloat(writeButton, "alpha", 1.0f));
+                }
+                for (int a = 0; a < 2; a++) {
+                    ViewProxy.setAlpha(onlineTextView[a], a == 0 ? 1.0f : 0.0f);
+                    ViewProxy.setAlpha(nameTextView[a], a == 0 ? 1.0f : 0.0f);
+                    animators.add(ObjectAnimatorProxy.ofFloat(onlineTextView[a], "alpha", a == 0 ? 0.0f : 1.0f));
+                    animators.add(ObjectAnimatorProxy.ofFloat(nameTextView[a], "alpha", a == 0 ? 0.0f : 1.0f));
+                }
+                if (animatingItem != null) {
+                    ViewProxy.setAlpha(animatingItem, 1.0f);
+                    animators.add(ObjectAnimatorProxy.ofFloat(animatingItem, "alpha", 0.0f));
+                }
+                animatorSet.playTogether(animators);
+            } else {
+                initialAnimationExtraHeight = extraHeight;
+                ArrayList<Object> animators = new ArrayList<>();
+                animators.add(ObjectAnimatorProxy.ofFloat(this, "animationProgress", 1.0f, 0.0f));
+                if (writeButton != null) {
+                    animators.add(ObjectAnimatorProxy.ofFloat(writeButton, "scaleX", 0.2f));
+                    animators.add(ObjectAnimatorProxy.ofFloat(writeButton, "scaleY", 0.2f));
+                    animators.add(ObjectAnimatorProxy.ofFloat(writeButton, "alpha", 0.0f));
+                }
+                for (int a = 0; a < 2; a++) {
+                    animators.add(ObjectAnimatorProxy.ofFloat(onlineTextView[a], "alpha", a == 0 ? 1.0f : 0.0f));
+                    animators.add(ObjectAnimatorProxy.ofFloat(nameTextView[a], "alpha", a == 0 ? 1.0f : 0.0f));
+                }
+                if (animatingItem != null) {
+                    ViewProxy.setAlpha(animatingItem, 0.0f);
+                    animators.add(ObjectAnimatorProxy.ofFloat(animatingItem, "alpha", 1.0f));
+                }
+                animatorSet.playTogether(animators);
+            }
+            animatorSet.addListener(new AnimatorListenerAdapterProxy() {
+                @Override
+                public void onAnimationEnd(Object animation) {
+                    if (Build.VERSION.SDK_INT > 15) {
+                        listView.setLayerType(View.LAYER_TYPE_NONE, null);
+                    }
+                    if (animatingItem != null) {
+                        ActionBarMenu menu = actionBar.createMenu();
+                        menu.clearItems();
+                        animatingItem = null;
+                    }
+                    callback.run();
+                }
+
+                @Override
+                public void onAnimationCancel(Object animation) {
+                    if (Build.VERSION.SDK_INT > 15) {
+                        listView.setLayerType(View.LAYER_TYPE_NONE, null);
+                    }
+                }
+            });
+            animatorSet.setInterpolator(new DecelerateInterpolator());
+
+            AndroidUtilities.runOnUIThread(new Runnable() {
+                @Override
+                public void run() {
+                    animatorSet.start();
+                }
+            }, 50);
+            return animatorSet;
+        }
+        return null;
+    }
+
     @Override
     public void updatePhotoAtIndex(int index) {
 
@@ -1168,6 +1660,7 @@ public void updatePhotoAtIndex(int index) {
             object.thumb = object.imageReceiver.getBitmap();
             object.size = -1;
             object.radius = avatarImage.getImageReceiver().getRoundRadius();
+            object.scale = ViewProxy.getScaleX(avatarImage);
             return object;
         }
         return null;
@@ -1193,7 +1686,7 @@ public void willHidePhotoViewer() {
     public void setPhotoChecked(int index) { }
 
     @Override
-    public void cancelButtonPressed() { }
+    public boolean cancelButtonPressed() { return true; }
 
     @Override
     public void sendButtonPressed(int index) { }
@@ -1202,14 +1695,14 @@ public void sendButtonPressed(int index) { }
     public int getSelectedCount() { return 0; }
 
     private void updateOnlineCount() {
+        onlineCount = 0;
         if (!(info instanceof TLRPC.TL_chatFull)) {
             return;
         }
-        onlineCount = 0;
         int currentTime = ConnectionsManager.getInstance().getCurrentTime();
         sortedUsers.clear();
         int i = 0;
-        for (TLRPC.TL_chatParticipant participant : info.participants.participants) {
+        for (TLRPC.ChatParticipant participant : info.participants.participants) {
             TLRPC.User user = MessagesController.getInstance().getUser(participant.user_id);
             if (user != null && user.status != null && (user.status.expires > currentTime || user.id == UserConfig.getClientUserId()) && user.status.expires > 10000) {
                 onlineCount++;
@@ -1266,18 +1759,63 @@ public int compare(Integer lhs, Integer rhs) {
             FileLog.e("tmessages", e); //TODO find crash
         }
 
-        if (listView != null) {
-            listView.invalidateViews();
+        if (listAdapter != null) {
+            listAdapter.notifyItemRangeChanged(emptyRowChat2 + 1, sortedUsers.size());
         }
     }
 
-    public void setChatInfo(TLRPC.ChatFull chatParticipants) {
-        info = chatParticipants;
+    public void setChatInfo(TLRPC.ChatFull chatInfo) {
+        info = chatInfo;
+        if (info != null && info.migrated_from_chat_id != 0) {
+            mergeDialogId = -info.migrated_from_chat_id;
+        }
+        fetchUsersFromChannelInfo();
     }
 
-    private void kickUser(TLRPC.TL_chatParticipant user) {
-        if (user != null) {
-            MessagesController.getInstance().deleteUserFromChat(chat_id, MessagesController.getInstance().getUser(user.user_id), info);
+    private void fetchUsersFromChannelInfo() {
+        if (info != null && info instanceof TLRPC.TL_channelFull && info.participants != null && participants != null && participants.isEmpty()) {
+            for (int a = 0; a < info.participants.participants.size(); a++) {
+                TLRPC.ChatParticipant chatParticipant = info.participants.participants.get(a);
+                if (chatParticipant instanceof TLRPC.TL_chatChannelParticipant) {
+                    TLRPC.ChannelParticipant channelParticipant = ((TLRPC.TL_chatChannelParticipant) chatParticipant).channelParticipant;
+                    participants.add(channelParticipant);
+                    participantsMap.put(channelParticipant.user_id, channelParticipant);
+                }
+            }
+        }
+    }
+
+    private void kickUser(int uid) {
+        if (uid != 0) {
+            MessagesController.getInstance().deleteUserFromChat(chat_id, MessagesController.getInstance().getUser(uid), info);
+            if (currentChat.megagroup && participants != null) {
+                boolean changed = false;
+                for (int a = 0; a < participants.size(); a++) {
+                    TLRPC.ChannelParticipant p = participants.get(a);
+                    if (p.user_id == uid) {
+                        if (info != null) {
+                            info.participants_count--;
+                        }
+                        participants.remove(a);
+                        changed = true;
+                        break;
+                    }
+                }
+                if (info != null && info.participants != null) {
+                    for (int a = 0; a < info.participants.participants.size(); a++) {
+                        TLRPC.ChatParticipant p = info.participants.participants.get(a);
+                        if (p.user_id == uid) {
+                            info.participants.participants.remove(a);
+                            changed = true;
+                            break;
+                        }
+                    }
+                }
+                if (changed) {
+                    updateRowsIds();
+                    listAdapter.notifyDataSetChanged();
+                }
+            }
         } else {
             NotificationCenter.getInstance().removeObserver(this, NotificationCenter.closeChats);
             if (AndroidUtilities.isTablet()) {
@@ -1286,6 +1824,7 @@ private void kickUser(TLRPC.TL_chatParticipant user) {
                 NotificationCenter.getInstance().postNotificationName(NotificationCenter.closeChats);
             }
             MessagesController.getInstance().deleteUserFromChat(chat_id, MessagesController.getInstance().getUser(UserConfig.getClientUserId()), info);
+            playProfileAnimation = false;
             finishFragment();
         }
     }
@@ -1298,17 +1837,20 @@ private void updateRowsIds() {
         rowCount = 0;
         overscrollRow = rowCount++;
         if (user_id != 0) {
+            phoneRow = -1;
+            usernameRow = -1;
+            settingsTimerRow = -1;
+            settingsKeyRow = -1;
+            startSecretChatRow = -1;
+            blockedUsersRow = -1;
+
             TLRPC.User user = MessagesController.getInstance().getUser(user_id);
             emptyRow = rowCount++;
-            if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) != 0) {
-                phoneRow = -1;
-            } else {
+            if (user == null || !user.bot) {
                 phoneRow = rowCount++;
             }
             if (user != null && user.username != null && user.username.length() > 0) {
                 usernameRow = rowCount++;
-            } else {
-                usernameRow = -1;
             }
             if (botInfo != null && botInfo.share_text != null && botInfo.share_text.length() > 0) {
                 botSectionRow = rowCount++;
@@ -1320,82 +1862,99 @@ private void updateRowsIds() {
             if (currentEncryptedChat instanceof TLRPC.TL_encryptedChat) {
                 settingsTimerRow = rowCount++;
                 settingsKeyRow = rowCount++;
-            } else {
-                settingsTimerRow = -1;
-                settingsKeyRow = -1;
             }
-            if (user != null && (user.flags & TLRPC.USER_FLAG_BOT) == 0 && currentEncryptedChat == null) {
+            if (user != null && !user.bot && currentEncryptedChat == null) {
                 startSecretChatRow = rowCount++;
-            } else {
-                startSecretChatRow = -1;
             }
         } else if (chat_id != 0) {
+            membersEndRow = -1;
+            membersSectionRow = -1;
+            emptyRowChat2 = -1;
+            addMemberRow = -1;
+            channelInfoRow = -1;
+            channelNameRow = -1;
+            convertRow = -1;
+            convertHelpRow = -1;
+            emptyRowChat = -1;
+            membersSectionRow = -1;
+            membersRow = -1;
+            managementRow = -1;
+            leaveChannelRow = -1;
+            loadMoreMembersRow = -1;
+            blockedUsersRow = -1;
+
             if (chat_id > 0) {
                 emptyRow = rowCount++;
                 if (ChatObject.isChannel(currentChat) && (info != null && info.about != null && info.about.length() > 0 || currentChat.username != null && currentChat.username.length() > 0)) {
                     if (info != null && info.about != null && info.about.length() > 0) {
                         channelInfoRow = rowCount++;
-                    } else {
-                        channelInfoRow = -1;
                     }
                     if (currentChat.username != null && currentChat.username.length() > 0) {
                         channelNameRow = rowCount++;
-                    } else {
-                        channelNameRow = -1;
                     }
                     sectionRow = rowCount++;
-                } else {
-                    channelInfoRow = -1;
-                    channelNameRow = -1;
                 }
                 settingsNotificationsRow = rowCount++;
                 sharedMediaRow = rowCount++;
-                if (!ChatObject.isChannel(currentChat)) {
-                    emptyRowChat = rowCount++;
-                    membersSectionRow = rowCount++;
-                } else {
-                    emptyRowChat = -1;
-                    membersSectionRow = -1;
-                }
                 if (ChatObject.isChannel(currentChat)) {
-                    if (info != null && ((currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0 || (info.flags & 8) != 0)) {
+                    if (!currentChat.megagroup && info != null && (currentChat.creator || info.can_view_participants)) {
                         membersRow = rowCount++;
-                    } else {
-                        membersRow = -1;
                     }
-                    if (!ChatObject.isNotInChat(currentChat) && ((currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0 || (currentChat.flags & TLRPC.CHAT_FLAG_USER_IS_EDITOR) != 0 || (currentChat.flags & TLRPC.CHAT_FLAG_USER_IS_MODERATOR) != 0)) {
+                    if (!ChatObject.isNotInChat(currentChat) && (currentChat.creator || currentChat.editor || currentChat.moderator)) {
                         managementRow = rowCount++;
-                    } else {
-                        managementRow = -1;
                     }
-                    if ((currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) == 0) {
-                        if ((currentChat.flags & TLRPC.CHAT_FLAG_USER_LEFT) == 0 && (currentChat.flags & TLRPC.CHAT_FLAG_USER_KICKED) == 0) {
-                            leaveChannelRow = rowCount++;
-                        } else {
-                            leaveChannelRow = -1;
+                    if (!ChatObject.isNotInChat(currentChat) && currentChat.megagroup && (currentChat.editor || currentChat.creator)) {
+                        blockedUsersRow = rowCount++;
+                    }
+                    if (!currentChat.creator && !currentChat.left && !currentChat.kicked && !currentChat.megagroup) {
+                        leaveChannelRow = rowCount++;
+                    }
+                    if (currentChat.megagroup && (currentChat.editor || currentChat.creator)) {
+                        if (info == null || info.participants_count < MessagesController.getInstance().maxMegagroupCount) {
+                            addMemberRow = rowCount++;
+                        }
+                    }
+                    if (participants != null && !participants.isEmpty()) {
+                        emptyRowChat = rowCount++;
+                        membersSectionRow = rowCount++;
+                        emptyRowChat2 = rowCount++;
+                        rowCount += participants.size();
+                        membersEndRow = rowCount;
+                        if (!usersEndReached) {
+                            loadMoreMembersRow = rowCount++;
                         }
-                        blockedUsersRow = -1;
-                    } else {
-                        leaveChannelRow = -1;
-                        //blockedUsersRow = rowCount++;
                     }
                 } else {
-                    membersRow = -1;
-                    leaveChannelRow = -1;
-                    managementRow = -1;
-                    blockedUsersRow = -1;
+                    if (info != null) {
+                        if (!(info.participants instanceof TLRPC.TL_chatParticipantsForbidden) &&
+                                info.participants.participants.size() < MessagesController.getInstance().maxGroupCount &&
+                                (currentChat.admin || currentChat.creator || !currentChat.admins_enabled)) {
+                            addMemberRow = rowCount++;
+                        }
+
+                        if (currentChat.creator && info.participants.participants.size() >= MessagesController.getInstance().minGroupConvertSize) {
+                            convertRow = rowCount++;
+                        }
+                    }
+                    emptyRowChat = rowCount++;
+                    if (convertRow != -1) {
+                        convertHelpRow = rowCount++;
+                    } else {
+                        membersSectionRow = rowCount++;
+                    }
+                    if (info != null && !(info.participants instanceof TLRPC.TL_chatParticipantsForbidden)) {
+                        emptyRowChat2 = rowCount++;
+                        rowCount += info.participants.participants.size();
+                        membersEndRow = rowCount;
+                    }
                 }
-            }
-            if (!ChatObject.isChannel(currentChat) && info != null && !(info.participants instanceof TLRPC.TL_chatParticipantsForbidden)) {
-                emptyRowChat2 = rowCount++;
-                rowCount += info.participants.participants.size();
-                membersEndRow = rowCount;
-                addMemberRow = rowCount++;
             } else {
-                membersEndRow = -1;
-                membersSectionRow = -1;
-                emptyRowChat2 = -1;
-                addMemberRow = -1;
+                if (!ChatObject.isChannel(currentChat) && info != null && !(info.participants instanceof TLRPC.TL_chatParticipantsForbidden)) {
+                    addMemberRow = rowCount++;
+                    emptyRowChat2 = rowCount++;
+                    rowCount += info.participants.participants.size();
+                    membersEndRow = rowCount;
+                }
             }
         }
     }
@@ -1412,14 +1971,54 @@ private void updateProfileData() {
                 photo = user.photo.photo_small;
                 photoBig = user.photo.photo_big;
             }
-            AvatarDrawable avatarDrawable = new AvatarDrawable(user);
+            avatarDrawable.setInfo(user);
             avatarImage.setImage(photo, "50_50", avatarDrawable);
 
-            nameTextView.setText(UserObject.getUserName(user));
-            if ((user.flags & TLRPC.USER_FLAG_BOT) != 0) {
-                onlineTextView.setText(LocaleController.getString("Bot", R.string.Bot));
+            String newString = UserObject.getUserName(user);
+            String newString2;
+            if (user.id == 333000 || user.id == 777000) {
+                newString2 = LocaleController.getString("ServiceNotifications", R.string.ServiceNotifications);
+            } else if (user.bot) {
+                newString2 = LocaleController.getString("Bot", R.string.Bot);
             } else {
-                onlineTextView.setText(LocaleController.formatUserStatus(user));
+                newString2 = LocaleController.formatUserStatus(user);
+            }
+            for (int a = 0; a < 2; a++) {
+                if (nameTextView[a] == null) {
+                    continue;
+                }
+                if (a == 0) {
+                    if (user.id / 1000 != 777 && user.id / 1000 != 333 && ContactsController.getInstance().contactsDict.get(user.id) == null && (ContactsController.getInstance().contactsDict.size() != 0 || !ContactsController.getInstance().isLoadingContacts())) {
+                        if (user.phone != null && user.phone.length() != 0) {
+                            nameTextView[a].setText(PhoneFormat.getInstance().format("+" + user.phone));
+                        } else {
+                            nameTextView[a].setText(UserObject.getUserName(user));
+                        }
+                    } else {
+                        nameTextView[a].setText(UserObject.getUserName(user));
+                    }
+                } else {
+                    if (!nameTextView[a].getText().equals(newString)) {
+                        nameTextView[a].setText(newString);
+                    }
+                }
+                if (!onlineTextView[a].getText().equals(newString2)) {
+                    onlineTextView[a].setText(newString2);
+                }
+                int leftIcon = currentEncryptedChat != null ? R.drawable.ic_lock_header : 0;
+                if (a != 0) {
+                    if (user.verified) {
+                        if (nameTextView[a].getCompoundDrawables()[2] == null || nameTextView[a].getCompoundDrawables()[0] == null && leftIcon != 0) {
+                            nameTextView[a].setCompoundDrawablesWithIntrinsicBounds(leftIcon, 0, R.drawable.check_profile_fixed, 0);
+                        }
+                    } else {
+                        if (nameTextView[a].getCompoundDrawables()[2] != null || nameTextView[a].getCompoundDrawables()[0] == null && leftIcon != 0) {
+                            nameTextView[a].setCompoundDrawablesWithIntrinsicBounds(leftIcon, 0, 0, 0);
+                        }
+                    }
+                } else {
+                    nameTextView[a].setCompoundDrawablesWithIntrinsicBounds(leftIcon, 0, MessagesController.getInstance().isDialogMuted(dialog_id != 0 ? dialog_id : (long) user_id) ? R.drawable.mute_fixed : 0, 0);
+                }
             }
 
             avatarImage.getImageReceiver().setVisible(!PhotoViewer.getInstance().isShowingImage(photoBig), false);
@@ -1430,20 +2029,19 @@ private void updateProfileData() {
             } else {
                 chat = currentChat;
             }
-            nameTextView.setText(chat.title);
 
+            String newString;
             if (ChatObject.isChannel(chat)) {
-                if (info == null || info.participants_count == 0 || ((currentChat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0 || (info.flags & 8) != 0)) {
+                if (info == null || !currentChat.megagroup && (info.participants_count == 0 || (currentChat.admin || info.can_view_participants))) {
                     if ((chat.flags & TLRPC.CHAT_FLAG_IS_PUBLIC) != 0) {
-                        onlineTextView.setText(LocaleController.getString("ChannelPublic", R.string.ChannelPublic).toLowerCase());
+                        newString = LocaleController.getString("ChannelPublic", R.string.ChannelPublic).toLowerCase();
                     } else {
-                        onlineTextView.setText(LocaleController.getString("ChannelPrivate", R.string.ChannelPrivate).toLowerCase());
+                        newString = LocaleController.getString("ChannelPrivate", R.string.ChannelPrivate).toLowerCase();
                     }
                 } else {
                     int result[] = new int[1];
                     String shortNumber = LocaleController.formatShortNumber(info.participants_count, result);
-                    String text = LocaleController.formatPluralString("Members", result[0]).replace(String.format("%d", result[0]), shortNumber);
-                    onlineTextView.setText(text);
+                    newString = LocaleController.formatPluralString("Members", result[0]).replace(String.format("%d", result[0]), shortNumber);
                 }
             } else {
                 int count = chat.participants_count;
@@ -1451,9 +2049,41 @@ private void updateProfileData() {
                     count = info.participants.participants.size();
                 }
                 if (count != 0 && onlineCount > 1) {
-                    onlineTextView.setText(String.format("%s, %s", LocaleController.formatPluralString("Members", count), LocaleController.formatPluralString("Online", onlineCount)));
+                    newString = String.format("%s, %s", LocaleController.formatPluralString("Members", count), LocaleController.formatPluralString("Online", onlineCount));
+                } else {
+                    newString = LocaleController.formatPluralString("Members", count);
+                }
+            }
+
+            for (int a = 0; a < 2; a++) {
+                if (nameTextView[a] == null) {
+                    continue;
+                }
+                if (chat.title != null && !nameTextView[a].getText().equals(chat.title)) {
+                    nameTextView[a].setText(chat.title);
+                }
+                if (a != 0) {
+                    if (chat.verified) {
+                        if (nameTextView[a].getCompoundDrawables()[2] == null) {
+                            nameTextView[a].setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.check_profile_fixed, 0);
+                        }
+                    } else {
+                        if (nameTextView[a].getCompoundDrawables()[2] != null) {
+                            nameTextView[a].setCompoundDrawablesWithIntrinsicBounds(0, 0, 0, 0);
+                        }
+                    }
+                } else {
+                    nameTextView[a].setCompoundDrawablesWithIntrinsicBounds(0, 0, MessagesController.getInstance().isDialogMuted((long) -chat_id) ? R.drawable.mute_fixed : 0, 0);
+                }
+                if (a == 0 && ChatObject.isChannel(currentChat) && info != null && info.participants_count != 0 && (currentChat.megagroup || currentChat.broadcast)) {
+                    int result[] = new int[1];
+                    String shortNumber = LocaleController.formatShortNumber(info.participants_count, result);
+                    String text = LocaleController.formatPluralString("Members", result[0]).replace(String.format("%d", result[0]), shortNumber);
+                    onlineTextView[a].setText(text);
                 } else {
-                    onlineTextView.setText(LocaleController.formatPluralString("Members", count));
+                    if (!onlineTextView[a].getText().equals(newString)) {
+                        onlineTextView[a].setText(newString);
+                    }
                 }
             }
 
@@ -1463,8 +2093,8 @@ private void updateProfileData() {
                 photo = chat.photo.photo_small;
                 photoBig = chat.photo.photo_big;
             }
-            avatarImage.setImage(photo, "50_50", new AvatarDrawable(chat, true));
-
+            avatarDrawable.setInfo(chat);
+            avatarImage.setImage(photo, "50_50", avatarDrawable);
             avatarImage.getImageReceiver().setVisible(!PhotoViewer.getInstance().isShowingImage(photoBig), false);
         }
     }
@@ -1472,6 +2102,7 @@ private void updateProfileData() {
     private void createActionBarMenu() {
         ActionBarMenu menu = actionBar.createMenu();
         menu.clearItems();
+        animatingItem = null;
 
         if (user_id != 0) {
             if (ContactsController.getInstance().contactsDict.get(user_id) == null) {
@@ -1479,9 +2110,9 @@ private void createActionBarMenu() {
                 if (user == null) {
                     return;
                 }
-                ActionBarMenuItem item = menu.addItem(0, R.drawable.ic_ab_other);
-                if ((user.flags & TLRPC.USER_FLAG_BOT) != 0) {
-                    if ((user.flags & TLRPC.USER_FLAG_BOT_CANT_JOIN_GROUP) == 0) {
+                ActionBarMenuItem item = menu.addItem(10, R.drawable.ic_ab_other);
+                if (user.bot) {
+                    if (!user.bot_nochats) {
                         item.addSubItem(invite_to_group, LocaleController.getString("BotInvite", R.string.BotInvite), 0);
                     }
                     item.addSubItem(share, LocaleController.getString("BotShare", R.string.BotShare), 0);
@@ -1491,14 +2122,14 @@ private void createActionBarMenu() {
                     item.addSubItem(share_contact, LocaleController.getString("ShareContact", R.string.ShareContact), 0);
                     item.addSubItem(block_contact, !userBlocked ? LocaleController.getString("BlockContact", R.string.BlockContact) : LocaleController.getString("Unblock", R.string.Unblock), 0);
                 } else {
-                    if ((user.flags & TLRPC.USER_FLAG_BOT) != 0) {
+                    if (user.bot) {
                         item.addSubItem(block_contact, !userBlocked ? LocaleController.getString("BotStop", R.string.BotStop) : LocaleController.getString("BotRestart", R.string.BotRestart), 0);
                     } else {
                         item.addSubItem(block_contact, !userBlocked ? LocaleController.getString("BlockContact", R.string.BlockContact) : LocaleController.getString("Unblock", R.string.Unblock), 0);
                     }
                 }
             } else {
-                ActionBarMenuItem item = menu.addItem(0, R.drawable.ic_ab_other);
+                ActionBarMenuItem item = menu.addItem(10, R.drawable.ic_ab_other);
                 item.addSubItem(share_contact, LocaleController.getString("ShareContact", R.string.ShareContact), 0);
                 item.addSubItem(block_contact, !userBlocked ? LocaleController.getString("BlockContact", R.string.BlockContact) : LocaleController.getString("Unblock", R.string.Unblock), 0);
                 item.addSubItem(edit_contact, LocaleController.getString("EditContact", R.string.EditContact), 0);
@@ -1507,21 +2138,44 @@ private void createActionBarMenu() {
         } else if (chat_id != 0) {
             if (chat_id > 0) {
                 TLRPC.Chat chat = MessagesController.getInstance().getChat(chat_id);
+                if (writeButton != null) {
+                    boolean isChannel = ChatObject.isChannel(currentChat);
+                    if (isChannel && !currentChat.creator && (!currentChat.megagroup || !currentChat.editor) || !isChannel && !currentChat.admin && !currentChat.creator && currentChat.admins_enabled) {
+                        writeButton.setImageResource(R.drawable.floating_message);
+                        writeButton.setPadding(0, AndroidUtilities.dp(3), 0, 0);
+                    } else {
+                        writeButton.setImageResource(R.drawable.floating_camera);
+                        writeButton.setPadding(0, 0, 0, 0);
+                    }
+                }
                 if (ChatObject.isChannel(chat)) {
-                    if ((chat.flags & TLRPC.CHAT_FLAG_ADMIN) != 0) {
-                        ActionBarMenuItem item = menu.addItem(0, R.drawable.ic_ab_other);
-                        item.addSubItem(edit_name, LocaleController.getString("ChannelEdit", R.string.ChannelEdit), 0);
+                    ActionBarMenuItem item = null;
+                    if (chat.creator) {
+                        item = menu.addItem(10, R.drawable.ic_ab_other);
+                        item.addSubItem(edit_channel, LocaleController.getString("ChannelEdit", R.string.ChannelEdit), 0);
+                    } else if (chat.megagroup && chat.editor) {
+                        item = menu.addItem(10, R.drawable.ic_ab_other);
+                        item.addSubItem(edit_name, LocaleController.getString("EditName", R.string.EditName), 0);
+                    }
+                    if (!chat.creator && !chat.left && !chat.kicked && chat.megagroup) {
+                        if (item == null) {
+                            item = menu.addItem(10, R.drawable.ic_ab_other);
+                        }
+                        item.addSubItem(leave_group, LocaleController.getString("LeaveMegaMenu", R.string.LeaveMegaMenu), 0);
                     }
                 } else {
-                    ActionBarMenuItem item = menu.addItem(0, R.drawable.ic_ab_other);
-                    item.addSubItem(add_member, LocaleController.getString("AddMember", R.string.AddMember), 0);
-                    item.addSubItem(edit_name, LocaleController.getString("EditName", R.string.EditName), 0);
+                    ActionBarMenuItem item = menu.addItem(10, R.drawable.ic_ab_other);
+                    if (chat.creator && chat_id > 0) {
+                        item.addSubItem(set_admins, LocaleController.getString("SetAdmins", R.string.SetAdmins), 0);
+                    }
+                    if (!chat.admins_enabled || chat.creator || chat.admin) {
+                        item.addSubItem(edit_name, LocaleController.getString("EditName", R.string.EditName), 0);
+                    }
                     item.addSubItem(leave_group, LocaleController.getString("DeleteAndExit", R.string.DeleteAndExit), 0);
                 }
             } else {
-                ActionBarMenuItem item = menu.addItem(0, R.drawable.ic_ab_other);
+                ActionBarMenuItem item = menu.addItem(10, R.drawable.ic_ab_other);
                 item.addSubItem(edit_name, LocaleController.getString("EditName", R.string.EditName), 0);
-                item.addSubItem(add_member, LocaleController.getString("AddRecipient", R.string.AddRecipient), 0);
             }
         }
     }
@@ -1557,192 +2211,261 @@ public void didSelectDialog(DialogsActivity messageFragment, long dialog_id, boo
         }
     }
 
-    private class ListAdapter extends BaseFragmentAdapter {
+    private class ListAdapter extends RecyclerListView.Adapter {
         private Context mContext;
 
-        public ListAdapter(Context context) {
-            mContext = context;
-        }
-
-        @Override
-        public boolean areAllItemsEnabled() {
-            return false;
-        }
+        private class Holder extends RecyclerView.ViewHolder {
 
-        @Override
-        public boolean isEnabled(int i) {
-            if (user_id != 0) {
-                return i == phoneRow || i == settingsTimerRow || i == settingsKeyRow || i == settingsNotificationsRow || i == sharedMediaRow || i == startSecretChatRow;
-            } else if (chat_id != 0) {
-                return i == settingsNotificationsRow || i == sharedMediaRow || i > emptyRowChat2 && i < membersEndRow || i == addMemberRow || i == channelNameRow || i == leaveChannelRow || i == membersRow || i == managementRow || i == blockedUsersRow || i == channelInfoRow;
+            public Holder(View itemView) {
+                super(itemView);
             }
-            return false;
         }
 
-        @Override
-        public int getCount() {
-            return rowCount;
-        }
-
-        @Override
-        public Object getItem(int i) {
-            return null;
-        }
-
-        @Override
-        public long getItemId(int i) {
-            return i;
-        }
-
-        @Override
-        public boolean hasStableIds() {
-            return false;
+        public ListAdapter(Context context) {
+            mContext = context;
         }
 
         @Override
-        public View getView(int i, View view, ViewGroup viewGroup) {
-            int type = getItemViewType(i);
-            if (type == 0) {
-                if (view == null) {
+        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+            View view = null;
+            switch (viewType) {
+                case 0:
                     view = new EmptyCell(mContext);
-                }
-                if (i == overscrollRow) {
-                    ((EmptyCell) view).setHeight(AndroidUtilities.dp(88));
-                } else if (i == emptyRowChat || i == emptyRowChat2) {
-                    ((EmptyCell) view).setHeight(AndroidUtilities.dp(8));
-                } else {
-                    ((EmptyCell) view).setHeight(AndroidUtilities.dp(36));
-                }
-            } else if (type == 1) {
-                if (view == null) {
+                    break;
+                case 1:
                     view = new DividerCell(mContext);
                     view.setPadding(AndroidUtilities.dp(72), 0, 0, 0);
-                }
-            } else if (type == 2) {
-                if (view == null) {
-                    view = new TextDetailCell(mContext);
-                }
-                TextDetailCell textDetailCell = (TextDetailCell) view;
+                    break;
+                case 2:
+                    view = new TextDetailCell(mContext) {
+                        @Override
+                        public boolean onTouchEvent(MotionEvent event) {
+                            if (Build.VERSION.SDK_INT >= 21 && getBackground() != null) {
+                                if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {
+                                    getBackground().setHotspot(event.getX(), event.getY());
+                                }
+                            }
+                            return super.onTouchEvent(event);
+                        }
+                    };
+                    break;
+                case 3:
+                    view = new TextCell(mContext) {
+                        @Override
+                        public boolean onTouchEvent(MotionEvent event) {
+                            if (Build.VERSION.SDK_INT >= 21 && getBackground() != null) {
+                                if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {
+                                    getBackground().setHotspot(event.getX(), event.getY());
+                                }
+                            }
+                            return super.onTouchEvent(event);
+                        }
+                    };
+                    break;
+                case 4:
+                    view = new UserCell(mContext, 61, 0) {
+                        @Override
+                        public boolean onTouchEvent(MotionEvent event) {
+                            if (Build.VERSION.SDK_INT >= 21 && getBackground() != null) {
+                                if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {
+                                    getBackground().setHotspot(event.getX(), event.getY());
+                                }
+                            }
+                            return super.onTouchEvent(event);
+                        }
+                    };
+                    break;
+                case 5:
+                    view = new ShadowSectionCell(mContext);
+                    break;
+                case 6:
+                    view = new TextInfoPrivacyCell(mContext);
+                    TextInfoPrivacyCell cell = (TextInfoPrivacyCell) view;
+                    cell.setBackgroundResource(R.drawable.greydivider);
+                    cell.setText(AndroidUtilities.replaceTags(LocaleController.formatString("ConvertGroupInfo", R.string.ConvertGroupInfo, LocaleController.formatPluralString("Members", MessagesController.getInstance().maxMegagroupCount))));
+                    break;
+                case 7:
+                    view = new LoadingCell(mContext);
+                    break;
+                case 8:
+                    view = new AboutLinkCell(mContext);
+                    ((AboutLinkCell) view).setDelegate(new AboutLinkCell.AboutLinkCellDelegate() {
+                        @Override
+                        public void didPressUrl(String url) {
+                            if (url.startsWith("@")) {
+                                MessagesController.openByUserName(url.substring(1), ProfileActivity.this, 0);
+                            } else if (url.startsWith("#")) {
+                                DialogsActivity fragment = new DialogsActivity(null);
+                                fragment.setSearchString(url);
+                                presentFragment(fragment);
+                            } else if (url.startsWith("/")) {
+                                if (parentLayout.fragmentsStack.size() > 1) {
+                                    BaseFragment previousFragment = parentLayout.fragmentsStack.get(parentLayout.fragmentsStack.size() - 2);
+                                    if (previousFragment instanceof ChatActivity) {
+                                        finishFragment();
+                                        ((ChatActivity) previousFragment).chatActivityEnterView.setCommand(null, url, false, false);
+                                    }
+                                }
+                            }
+                        }
+                    });
+                    break;
+            }
+            return new Holder(view);
+        }
 
-                if (i == phoneRow) {
-                    String text;
-                    final TLRPC.User user = MessagesController.getInstance().getUser(user_id);
-                    if (user.phone != null && user.phone.length() != 0) {
-                        text = PhoneFormat.getInstance().format("+" + user.phone);
-                    } else {
-                        text = LocaleController.getString("NumberUnknown", R.string.NumberUnknown);
-                    }
-                    textDetailCell.setTextAndValueAndIcon(text, LocaleController.getString("PhoneMobile", R.string.PhoneMobile), R.drawable.phone_grey);
-                } else if (i == usernameRow) {
-                    String text;
-                    final TLRPC.User user = MessagesController.getInstance().getUser(user_id);
-                    if (user != null && user.username != null && user.username.length() != 0) {
-                        text = "@" + user.username;
+        @Override
+        public void onBindViewHolder(RecyclerView.ViewHolder holder, int i) {
+            boolean checkBackground = true;
+            switch (holder.getItemViewType()) {
+                case 0:
+                    if (i == overscrollRow) {
+                        ((EmptyCell) holder.itemView).setHeight(AndroidUtilities.dp(88));
+                    } else if (i == emptyRowChat || i == emptyRowChat2) {
+                        ((EmptyCell) holder.itemView).setHeight(AndroidUtilities.dp(8));
                     } else {
-                        text = "-";
+                        ((EmptyCell) holder.itemView).setHeight(AndroidUtilities.dp(36));
                     }
-                    textDetailCell.setTextAndValue(text, LocaleController.getString("Username", R.string.Username));
-                } else if (i == channelNameRow) {
-                    String text;
-                    if (currentChat != null && currentChat.username != null && currentChat.username.length() != 0) {
-                        text = "@" + currentChat.username;
-                    } else {
-                        text = "-";
+                    break;
+                case 2:
+                    TextDetailCell textDetailCell = (TextDetailCell) holder.itemView;
+                    if (i == phoneRow) {
+                        String text;
+                        final TLRPC.User user = MessagesController.getInstance().getUser(user_id);
+                        if (user.phone != null && user.phone.length() != 0) {
+                            text = PhoneFormat.getInstance().format("+" + user.phone);
+                        } else {
+                            text = LocaleController.getString("NumberUnknown", R.string.NumberUnknown);
+                        }
+                        textDetailCell.setTextAndValueAndIcon(text, LocaleController.getString("PhoneMobile", R.string.PhoneMobile), R.drawable.phone_grey);
+                    } else if (i == usernameRow) {
+                        String text;
+                        final TLRPC.User user = MessagesController.getInstance().getUser(user_id);
+                        if (user != null && user.username != null && user.username.length() != 0) {
+                            text = "@" + user.username;
+                        } else {
+                            text = "-";
+                        }
+                        textDetailCell.setTextAndValue(text, LocaleController.getString("Username", R.string.Username));
+                    } else if (i == channelNameRow) {
+                        String text;
+                        if (currentChat != null && currentChat.username != null && currentChat.username.length() != 0) {
+                            text = "@" + currentChat.username;
+                        } else {
+                            text = "-";
+                        }
+                        textDetailCell.setTextAndValue(text, "telegram.me/" + currentChat.username);
                     }
-                    textDetailCell.setTextAndValue(text, "telegram.me/" + currentChat.username);
-                }
-            } else if (type == 3) {
-                if (view == null) {
-                    view = new TextCell(mContext);
-                }
-                TextCell textCell = (TextCell) view;
-                textCell.setTextColor(0xff212121);
-
-                if (i == sharedMediaRow) {
-                    String value;
-                    if (totalMediaCount == -1) {
-                        value = LocaleController.getString("Loading", R.string.Loading);
-                    } else {
-                        value = String.format("%d", totalMediaCount);
-                    }
-                    textCell.setMultiline(false);
-                    textCell.setTextAndValue(LocaleController.getString("SharedMedia", R.string.SharedMedia), value);
-                } else if (i == settingsTimerRow) {
-                    TLRPC.EncryptedChat encryptedChat = MessagesController.getInstance().getEncryptedChat((int)(dialog_id >> 32));
-                    String value;
-                    if (encryptedChat.ttl == 0) {
-                        value = LocaleController.getString("ShortMessageLifetimeForever", R.string.ShortMessageLifetimeForever);
-                    } else {
-                        value = AndroidUtilities.formatTTLString(encryptedChat.ttl);
-                    }
-                    textCell.setMultiline(false);
-                    textCell.setTextAndValue(LocaleController.getString("MessageLifetime", R.string.MessageLifetime), value);
-                } else if (i == settingsNotificationsRow) {
-                    textCell.setMultiline(false);
-                    textCell.setTextAndIcon(LocaleController.getString("NotificationsAndSounds", R.string.NotificationsAndSounds), R.drawable.profile_list);
-                } else if (i == startSecretChatRow) {
-                    textCell.setMultiline(false);
-                    textCell.setText(LocaleController.getString("StartEncryptedChat", R.string.StartEncryptedChat));
-                    textCell.setTextColor(0xff37a919);
-                } else if (i == settingsKeyRow) {
-                    IdenticonDrawable identiconDrawable = new IdenticonDrawable();
-                    TLRPC.EncryptedChat encryptedChat = MessagesController.getInstance().getEncryptedChat((int)(dialog_id >> 32));
-                    identiconDrawable.setEncryptedChat(encryptedChat);
-                    textCell.setMultiline(false);
-                    textCell.setTextAndValueDrawable(LocaleController.getString("EncryptionKey", R.string.EncryptionKey), identiconDrawable);
-                } else if (i == botInfoRow) {
-                    textCell.setMultiline(true);
-                    textCell.setTextAndIcon(botInfo.share_text, R.drawable.bot_info);
-                } else if (i == channelInfoRow) {
-                    textCell.setMultiline(true);
-                    textCell.setTextAndIcon(info.about, R.drawable.bot_info);
-                } else if (i == leaveChannelRow) {
-                    textCell.setTextColor(0xffed3d39);
-                    textCell.setMultiline(false);
-                    textCell.setText(LocaleController.getString("LeaveChannel", R.string.LeaveChannel));
-                } else if (i == membersRow) {
-                    textCell.setMultiline(false);
-                    if (info != null) {
-                        textCell.setTextAndValue(LocaleController.getString("ChannelMembers", R.string.ChannelMembers), String.format("%d", info.participants_count));
-                    } else {
-                        textCell.setText(LocaleController.getString("ChannelMembers", R.string.ChannelMembers));
+                    break;
+                case 3:
+                    TextCell textCell = (TextCell) holder.itemView;
+                    textCell.setTextColor(0xff212121);
+
+                    if (i == sharedMediaRow) {
+                        String value;
+                        if (totalMediaCount == -1) {
+                            value = LocaleController.getString("Loading", R.string.Loading);
+                        } else {
+                            value = String.format("%d", totalMediaCount + (totalMediaCountMerge != -1 ? totalMediaCountMerge : 0));
+                        }
+                        textCell.setTextAndValue(LocaleController.getString("SharedMedia", R.string.SharedMedia), value);
+                    } else if (i == settingsTimerRow) {
+                        TLRPC.EncryptedChat encryptedChat = MessagesController.getInstance().getEncryptedChat((int)(dialog_id >> 32));
+                        String value;
+                        if (encryptedChat.ttl == 0) {
+                            value = LocaleController.getString("ShortMessageLifetimeForever", R.string.ShortMessageLifetimeForever);
+                        } else {
+                            value = AndroidUtilities.formatTTLString(encryptedChat.ttl);
+                        }
+                        textCell.setTextAndValue(LocaleController.getString("MessageLifetime", R.string.MessageLifetime), value);
+                    } else if (i == settingsNotificationsRow) {
+                        textCell.setTextAndIcon(LocaleController.getString("NotificationsAndSounds", R.string.NotificationsAndSounds), R.drawable.profile_list);
+                    } else if (i == startSecretChatRow) {
+                        textCell.setText(LocaleController.getString("StartEncryptedChat", R.string.StartEncryptedChat));
+                        textCell.setTextColor(0xff37a919);
+                    } else if (i == settingsKeyRow) {
+                        IdenticonDrawable identiconDrawable = new IdenticonDrawable();
+                        TLRPC.EncryptedChat encryptedChat = MessagesController.getInstance().getEncryptedChat((int)(dialog_id >> 32));
+                        identiconDrawable.setEncryptedChat(encryptedChat);
+                        textCell.setTextAndValueDrawable(LocaleController.getString("EncryptionKey", R.string.EncryptionKey), identiconDrawable);
+                    } else if (i == leaveChannelRow) {
+                        textCell.setTextColor(0xffed3d39);
+                        textCell.setText(LocaleController.getString("LeaveChannel", R.string.LeaveChannel));
+                    } else if (i == convertRow) {
+                        textCell.setText(LocaleController.getString("ConvertGroup", R.string.ConvertGroup));
+                        textCell.setTextColor(0xff37a919);
+                    } else if (i == membersRow) {
+                        if (info != null) {
+                            textCell.setTextAndValue(LocaleController.getString("ChannelMembers", R.string.ChannelMembers), String.format("%d", info.participants_count));
+                        } else {
+                            textCell.setText(LocaleController.getString("ChannelMembers", R.string.ChannelMembers));
+                        }
+                    } else if (i == managementRow) {
+                        if (info != null) {
+                            textCell.setTextAndValue(LocaleController.getString("ChannelAdministrators", R.string.ChannelAdministrators), String.format("%d", info.admins_count));
+                        } else {
+                            textCell.setText(LocaleController.getString("ChannelAdministrators", R.string.ChannelAdministrators));
+                        }
+                    } else if (i == blockedUsersRow) {
+                        if (info != null) {
+                            textCell.setTextAndValue(LocaleController.getString("ChannelBlockedUsers", R.string.ChannelBlockedUsers), String.format("%d", info.kicked_count));
+                        } else {
+                            textCell.setText(LocaleController.getString("ChannelBlockedUsers", R.string.ChannelBlockedUsers));
+                        }
+                    } else if (i == addMemberRow) {
+                        if (chat_id > 0) {
+                            textCell.setText(LocaleController.getString("AddMember", R.string.AddMember));
+                        } else {
+                            textCell.setText(LocaleController.getString("AddRecipient", R.string.AddRecipient));
+                        }
                     }
-                } else if (i == managementRow) {
-                    textCell.setMultiline(false);
-                    if (info != null) {
-                        textCell.setTextAndValue(LocaleController.getString("ChannelAdministrators", R.string.ChannelAdministrators), String.format("%d", info.admins_count));
+                    break;
+                case 4:
+                    if (participants != null) {
+                        TLRPC.ChannelParticipant part = participants.get(i - emptyRowChat2 - 1);
+                        ((UserCell) holder.itemView).setData(MessagesController.getInstance().getUser(part.user_id), null, null, i == emptyRowChat2 + 1 ? R.drawable.menu_newgroup : 0);
                     } else {
-                        textCell.setText(LocaleController.getString("ChannelAdministrators", R.string.ChannelAdministrators));
+                        TLRPC.ChatParticipant part = info.participants.participants.get(sortedUsers.get(i - emptyRowChat2 - 1));
+                        ((UserCell) holder.itemView).setData(MessagesController.getInstance().getUser(part.user_id), null, null, i == emptyRowChat2 + 1 ? R.drawable.menu_newgroup : 0);
                     }
-                } else if (i == blockedUsersRow) {
-                    textCell.setMultiline(false);
-                    if (info != null) {
-                        textCell.setTextAndValue(LocaleController.getString("ChannelBlockedUsers", R.string.ChannelBlockedUsers), String.format("%d", info.kicked_count));
-                    } else {
-                        textCell.setText(LocaleController.getString("ChannelBlockedUsers", R.string.ChannelBlockedUsers));
+                    break;
+                case 8:
+                    AboutLinkCell aboutLinkCell = (AboutLinkCell) holder.itemView;
+                    if (i == botInfoRow) {
+                        aboutLinkCell.setTextAndIcon(botInfo.share_text, R.drawable.bot_info);
+                    } else if (i == channelInfoRow) {
+                        String text = info.about;
+                        while (text.contains("\n\n\n")) {
+                            text = text.replace("\n\n\n", "\n\n");
+                        }
+                        aboutLinkCell.setTextAndIcon(text, R.drawable.bot_info);
                     }
+                    break;
+                default:
+                    checkBackground = false;
+            }
+            if (checkBackground) {
+                boolean enabled = false;
+                if (user_id != 0) {
+                    enabled = i == phoneRow || i == settingsTimerRow || i == settingsKeyRow || i == settingsNotificationsRow || i == sharedMediaRow || i == startSecretChatRow || i == usernameRow;
+                } else if (chat_id != 0) {
+                    enabled = i == convertRow || i == settingsNotificationsRow || i == sharedMediaRow || i > emptyRowChat2 && i < membersEndRow || i == addMemberRow || i == channelNameRow || i == leaveChannelRow || i == membersRow || i == managementRow || i == blockedUsersRow || i == channelInfoRow;
                 }
-            } else if (type == 4) {
-                if (view == null) {
-                    view = new UserCell(mContext, 61);
-                }
-                TLRPC.TL_chatParticipant part = info.participants.participants.get(sortedUsers.get(i - emptyRowChat2 - 1));
-                ((UserCell) view).setData(MessagesController.getInstance().getUser(part.user_id), null, null, i == emptyRowChat2 + 1 ? R.drawable.menu_newgroup : 0);
-            } else if (type == 5) {
-                if (view == null) {
-                    view = new ShadowSectionCell(mContext);
-                }
-            } else if (type == 6) {
-                if (view == null) {
-                    view = new AddMemberCell(mContext);
-                    if (chat_id > 0) {
-                        ((AddMemberCell) view).setText(LocaleController.getString("AddMember", R.string.AddMember));
-                    } else {
-                        ((AddMemberCell) view).setText(LocaleController.getString("AddRecipient", R.string.AddRecipient));
+                if (enabled) {
+                    if (holder.itemView.getBackground() == null) {
+                        holder.itemView.setBackgroundResource(R.drawable.list_selector);
+                    }
+                } else {
+                    if (holder.itemView.getBackground() != null) {
+                        holder.itemView.setBackgroundDrawable(null);
                     }
                 }
             }
-            return view;
+        }
+
+        @Override
+        public int getItemCount() {
+            return rowCount;
         }
 
         @Override
@@ -1753,26 +2476,20 @@ public int getItemViewType(int i) {
                 return 1;
             } else if (i == phoneRow || i == usernameRow || i == channelNameRow) {
                 return 2;
-            } else if (i == leaveChannelRow || i == sharedMediaRow || i == settingsTimerRow || i == settingsNotificationsRow || i == startSecretChatRow || i == settingsKeyRow || i == botInfoRow || i == channelInfoRow || i == membersRow || i == managementRow || i == blockedUsersRow) {
+            } else if (i == leaveChannelRow || i == sharedMediaRow || i == settingsTimerRow || i == settingsNotificationsRow || i == startSecretChatRow || i == settingsKeyRow || i == membersRow || i == managementRow || i == blockedUsersRow || i == convertRow || i == addMemberRow) {
                 return 3;
             } else if (i > emptyRowChat2 && i < membersEndRow) {
                 return 4;
             } else if (i == membersSectionRow) {
                 return 5;
-            } else if (i == addMemberRow) {
+            } else if (i == convertHelpRow) {
                 return 6;
+            } else if (i == loadMoreMembersRow) {
+                return 7;
+            } else if (i == botInfoRow || i == channelInfoRow) {
+                return 8;
             }
             return 0;
         }
-
-        @Override
-        public int getViewTypeCount() {
-            return 7;
-        }
-
-        @Override
-        public boolean isEmpty() {
-            return false;
-        }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/ProfileNotificationsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/ProfileNotificationsActivity.java
index 915bfc16c..62758bc3a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/ProfileNotificationsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/ProfileNotificationsActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.4.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -176,6 +176,9 @@ public void onClick(DialogInterface d, int which) {
                             SharedPreferences preferences = ApplicationLoader.applicationContext.getSharedPreferences("Notifications", Activity.MODE_PRIVATE);
                             SharedPreferences.Editor editor = preferences.edit();
                             editor.putInt("notify2_" + dialog_id, which);
+                            if (which == 2) {
+                                NotificationsController.getInstance().removeNotificationsForDialog(dialog_id);
+                            }
                             MessagesStorage.getInstance().setDialogFlags(dialog_id, which == 2 ? 1 : 0);
                             editor.commit();
                             TLRPC.Dialog dialog = MessagesController.getInstance().dialogs_dict.get(dialog_id);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SecretPhotoViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/SecretPhotoViewer.java
index cf2c24d98..9ca19d128 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/SecretPhotoViewer.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SecretPhotoViewer.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -18,6 +18,7 @@
 import android.graphics.RectF;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
+import android.os.Build;
 import android.text.Layout;
 import android.text.StaticLayout;
 import android.text.TextPaint;
@@ -257,12 +258,20 @@ public void openPhoto(MessageObject messageObject) {
         BitmapDrawable drawable = ImageLoader.getInstance().getImageFromMemory(sizeFull.location, null, null);
         if (drawable == null) {
             File file = FileLoader.getPathToAttach(sizeFull);
-            Bitmap bitmap;
+            Bitmap bitmap = null;
+            BitmapFactory.Options options = null;
+            if (Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT < 21) {
+                options = new BitmapFactory.Options();
+                options.inDither = true;
+                options.inPreferredConfig = Bitmap.Config.ARGB_8888;
+                options.inPurgeable = true;
+                options.inSampleSize = 1;
+                options.inMutable = true;
+            }
             try {
-                bitmap = BitmapFactory.decodeFile(file.getAbsolutePath());
+                bitmap = BitmapFactory.decodeFile(file.getAbsolutePath(), options);
             } catch (Throwable e) {
-                ImageLoader.getInstance().clearMemory();
-                bitmap = BitmapFactory.decodeFile(file.getAbsolutePath());
+                FileLog.e("tmessages", e);
             }
             if (bitmap != null) {
                 drawable = new BitmapDrawable(bitmap);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java
index 09f6ce299..35690078a 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SessionsActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SetAdminsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/SetAdminsActivity.java
new file mode 100644
index 000000000..3e2e1ec3b
--- /dev/null
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SetAdminsActivity.java
@@ -0,0 +1,673 @@
+/*
+ * This is the source code of Telegram for Android v. 3.x.x.
+ * It is licensed under GNU GPL v. 2 or later.
+ * You should have received a copy of the license in this archive (see LICENSE).
+ *
+ * Copyright Nikolai Kudashov, 2013-2015.
+ */
+
+package org.telegram.ui;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.EditText;
+import android.widget.FrameLayout;
+import android.widget.ListView;
+
+import org.telegram.messenger.AndroidUtilities;
+import org.telegram.messenger.ContactsController;
+import org.telegram.messenger.FileLog;
+import org.telegram.messenger.LocaleController;
+import org.telegram.messenger.MessagesController;
+import org.telegram.messenger.NotificationCenter;
+import org.telegram.messenger.R;
+import org.telegram.messenger.UserConfig;
+import org.telegram.messenger.Utilities;
+import org.telegram.tgnet.TLRPC;
+import org.telegram.ui.ActionBar.ActionBar;
+import org.telegram.ui.ActionBar.ActionBarMenu;
+import org.telegram.ui.ActionBar.ActionBarMenuItem;
+import org.telegram.ui.ActionBar.BaseFragment;
+import org.telegram.ui.Adapters.BaseFragmentAdapter;
+import org.telegram.ui.Cells.TextCheckCell;
+import org.telegram.ui.Cells.TextInfoPrivacyCell;
+import org.telegram.ui.Cells.UserCell;
+import org.telegram.ui.Components.EmptyTextProgressView;
+import org.telegram.ui.Components.LayoutHelper;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Timer;
+import java.util.TimerTask;
+
+public class SetAdminsActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
+
+    private ListAdapter listAdapter;
+    private SearchAdapter searchAdapter;
+    private EmptyTextProgressView searchEmptyView;
+    private ListView listView;
+    private TLRPC.ChatFull info;
+    private ArrayList<TLRPC.ChatParticipant> participants = new ArrayList<>();
+    private int chat_id;
+    private TLRPC.Chat chat;
+    private ActionBarMenuItem searchItem;
+    private boolean searching;
+    private boolean searchWas;
+
+    private int allAdminsRow;
+    private int allAdminsInfoRow;
+    private int usersStartRow;
+    private int usersEndRow;
+    private int rowCount;
+
+    public SetAdminsActivity(Bundle args) {
+        super(args);
+        chat_id = args.getInt("chat_id");
+    }
+
+    @Override
+    public boolean onFragmentCreate() {
+        super.onFragmentCreate();
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.chatInfoDidLoaded);
+        NotificationCenter.getInstance().addObserver(this, NotificationCenter.updateInterfaces);
+        return true;
+    }
+
+    @Override
+    public void onFragmentDestroy() {
+        super.onFragmentDestroy();
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.chatInfoDidLoaded);
+        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.updateInterfaces);
+    }
+
+    @Override
+    public View createView(Context context) {
+        searching = false;
+        searchWas = false;
+
+        actionBar.setBackButtonImage(R.drawable.ic_ab_back);
+        actionBar.setAllowOverlayTitle(true);
+        actionBar.setTitle(LocaleController.getString("SetAdminsTitle", R.string.SetAdminsTitle));
+        actionBar.setActionBarMenuOnItemClick(new ActionBar.ActionBarMenuOnItemClick() {
+            @Override
+            public void onItemClick(int id) {
+                if (id == -1) {
+                    finishFragment();
+                }
+            }
+        });
+
+        ActionBarMenu menu = actionBar.createMenu();
+        searchItem = menu.addItem(0, R.drawable.ic_ab_search).setIsSearchField(true).setActionBarMenuItemSearchListener(new ActionBarMenuItem.ActionBarMenuItemSearchListener() {
+            @Override
+            public void onSearchExpand() {
+                searching = true;
+                listView.setEmptyView(searchEmptyView);
+            }
+
+            @Override
+            public void onSearchCollapse() {
+                searching = false;
+                searchWas = false;
+                if (listView != null) {
+                    listView.setEmptyView(null);
+                    searchEmptyView.setVisibility(View.GONE);
+                    if (listView.getAdapter() != listAdapter) {
+                        listView.setAdapter(listAdapter);
+                        fragmentView.setBackgroundColor(0xfff0f0f0);
+                    }
+                }
+                if (searchAdapter != null) {
+                    searchAdapter.search(null);
+                }
+            }
+
+            @Override
+            public void onTextChanged(EditText editText) {
+                String text = editText.getText().toString();
+                if (text.length() != 0) {
+                    searchWas = true;
+                    if (searchAdapter != null && listView.getAdapter() != searchAdapter) {
+                        listView.setAdapter(searchAdapter);
+                        fragmentView.setBackgroundColor(0xffffffff);
+                    }
+                    if (searchEmptyView != null && listView.getEmptyView() != searchEmptyView) {
+                        searchEmptyView.showTextView();
+                        listView.setEmptyView(searchEmptyView);
+                    }
+                }
+                if (searchAdapter != null) {
+                    searchAdapter.search(text);
+                }
+            }
+        });
+        searchItem.getSearchField().setHint(LocaleController.getString("Search", R.string.Search));
+
+        listAdapter = new ListAdapter(context);
+        searchAdapter = new SearchAdapter(context);
+
+        fragmentView = new FrameLayout(context);
+        FrameLayout frameLayout = (FrameLayout) fragmentView;
+        fragmentView.setBackgroundColor(0xfff0f0f0);
+
+        listView = new ListView(context);
+        listView.setDivider(null);
+        listView.setDividerHeight(0);
+        listView.setVerticalScrollBarEnabled(false);
+        listView.setDrawSelectorOnTop(true);
+        frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        listView.setAdapter(listAdapter);
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
+                if (listView.getAdapter() == searchAdapter || i >= usersStartRow && i < usersEndRow) {
+                    UserCell userCell = (UserCell) view;
+                    chat = MessagesController.getInstance().getChat(chat_id);
+                    TLRPC.ChatParticipant participant;
+                    int index = -1;
+                    if (listView.getAdapter() == searchAdapter) {
+                        participant = searchAdapter.getItem(i);
+                        for (int a = 0; a < participants.size(); a++) {
+                            TLRPC.ChatParticipant p = participants.get(a);
+                            if (p.user_id == participant.user_id) {
+                                index = a;
+                                break;
+                            }
+                        }
+                    } else {
+                        participant = participants.get(index = i - usersStartRow);
+                    }
+                    if (index != -1 && !(participant instanceof TLRPC.TL_chatParticipantCreator)) {
+                        TLRPC.ChatParticipant newParticipant;
+                        if (participant instanceof TLRPC.TL_chatParticipant) {
+                            newParticipant = new TLRPC.TL_chatParticipantAdmin();
+                            newParticipant.user_id = participant.user_id;
+                            newParticipant.date = participant.date;
+                            newParticipant.inviter_id = participant.inviter_id;
+                        } else {
+                            newParticipant = new TLRPC.TL_chatParticipant();
+                            newParticipant.user_id = participant.user_id;
+                            newParticipant.date = participant.date;
+                            newParticipant.inviter_id = participant.inviter_id;
+                        }
+                        participants.set(index, newParticipant);
+                        index = info.participants.participants.indexOf(participant);
+                        if (index != -1) {
+                            info.participants.participants.set(index, newParticipant);
+                        }
+                        if (listView.getAdapter() == searchAdapter) {
+                            searchAdapter.searchResult.set(i, newParticipant);
+                        }
+                        participant = newParticipant;
+                        userCell.setChecked(!(participant instanceof TLRPC.TL_chatParticipant) || chat != null && !chat.admins_enabled, true);
+                        if (chat != null && chat.admins_enabled) {
+                            MessagesController.getInstance().toggleUserAdmin(chat_id, participant.user_id, !(participant instanceof TLRPC.TL_chatParticipant));
+                        }
+                    }
+                } else {
+                    if (i == allAdminsRow) {
+                        chat = MessagesController.getInstance().getChat(chat_id);
+                        if (chat != null) {
+                            chat.admins_enabled = !chat.admins_enabled;
+                            ((TextCheckCell) view).setChecked(!chat.admins_enabled);
+                            MessagesController.getInstance().toggleAdminMode(chat_id, chat.admins_enabled);
+                        }
+                    }
+                }
+            }
+        });
+
+        searchEmptyView = new EmptyTextProgressView(context);
+        searchEmptyView.setVisibility(View.GONE);
+        searchEmptyView.setShowAtCenter(true);
+        searchEmptyView.setText(LocaleController.getString("NoResult", R.string.NoResult));
+        frameLayout.addView(searchEmptyView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
+        searchEmptyView.showTextView();
+
+        updateRowsIds();
+
+        return fragmentView;
+    }
+
+    @Override
+    public void didReceivedNotification(int id, Object... args) {
+        if (id == NotificationCenter.chatInfoDidLoaded) {
+            TLRPC.ChatFull chatFull = (TLRPC.ChatFull) args[0];
+            if (chatFull.id == chat_id) {
+                info = chatFull;
+                updateChatParticipants();
+                updateRowsIds();
+            }
+        } if (id == NotificationCenter.updateInterfaces) {
+            int mask = (Integer) args[0];
+            if ((mask & MessagesController.UPDATE_MASK_AVATAR) != 0 || (mask & MessagesController.UPDATE_MASK_NAME) != 0 || (mask & MessagesController.UPDATE_MASK_STATUS) != 0) {
+                if (listView != null) {
+                    int count = listView.getChildCount();
+                    for (int a = 0; a < count; a++) {
+                        View child = listView.getChildAt(a);
+                        if (child instanceof UserCell) {
+                            ((UserCell) child).update(mask);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+    }
+
+    public void setChatInfo(TLRPC.ChatFull chatParticipants) {
+        info = chatParticipants;
+        updateChatParticipants();
+    }
+
+    private int getChatAdminParticipantType(TLRPC.ChatParticipant participant) {
+        if (participant instanceof TLRPC.TL_chatParticipantCreator) {
+            return 0;
+        } else if (participant instanceof TLRPC.TL_chatParticipantAdmin) {
+            return 1;
+        }  else {
+            return 2;
+        }
+    }
+
+    private void updateChatParticipants() {
+        if (info == null) {
+            return;
+        }
+        if (participants.size() != info.participants.participants.size()) {
+            participants.clear();
+            participants.addAll(info.participants.participants);
+            try {
+                Collections.sort(participants, new Comparator<TLRPC.ChatParticipant>() {
+                    @Override
+                    public int compare(TLRPC.ChatParticipant lhs, TLRPC.ChatParticipant rhs) {
+                        int type1 = getChatAdminParticipantType(lhs);
+                        int type2 = getChatAdminParticipantType(rhs);
+                        if (type1 > type2) {
+                            return 1;
+                        } else if (type1 < type2) {
+                            return -1;
+                        } else if (type1 == type2) {
+                            TLRPC.User user1 = MessagesController.getInstance().getUser(rhs.user_id);
+                            TLRPC.User user2 = MessagesController.getInstance().getUser(lhs.user_id);
+                            int status1 = 0;
+                            int status2 = 0;
+                            if (user1 != null && user1.status != null) {
+                                status1 = user1.status.expires;
+                            }
+                            if (user2 != null && user2.status != null) {
+                                status2 = user2.status.expires;
+                            }
+                            if (status1 > 0 && status2 > 0) {
+                                if (status1 > status2) {
+                                    return 1;
+                                } else if (status1 < status2) {
+                                    return -1;
+                                }
+                                return 0;
+                            } else if (status1 < 0 && status2 < 0) {
+                                if (status1 > status2) {
+                                    return 1;
+                                } else if (status1 < status2) {
+                                    return -1;
+                                }
+                                return 0;
+                            } else if (status1 < 0 && status2 > 0 || status1 == 0 && status2 != 0) {
+                                return -1;
+                            } else if (status2 < 0 && status1 > 0 || status2 == 0 && status1 != 0) {
+                                return 1;
+                            }
+                        }
+                        return 0;
+                    }
+                });
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+        }
+    }
+
+    private void updateRowsIds() {
+        rowCount = 0;
+        allAdminsRow = rowCount++;
+        allAdminsInfoRow = rowCount++;
+        if (info != null) {
+            usersStartRow = rowCount;
+            rowCount += participants.size();
+            usersEndRow = rowCount++;
+            if (searchItem != null && !searchWas) {
+                searchItem.setVisibility(View.VISIBLE);
+            }
+        } else {
+            usersStartRow = -1;
+            usersEndRow = -1;
+            if (searchItem != null) {
+                searchItem.setVisibility(View.GONE);
+            }
+        }
+        if (listAdapter != null) {
+            listAdapter.notifyDataSetChanged();
+        }
+    }
+
+    private class ListAdapter extends BaseFragmentAdapter {
+        private Context mContext;
+
+        public ListAdapter(Context context) {
+            mContext = context;
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            if (i == allAdminsRow) {
+                return true;
+            } else if (i >= usersStartRow && i < usersEndRow) {
+                TLRPC.ChatParticipant participant = participants.get(i - usersStartRow);
+                TLRPC.User user = MessagesController.getInstance().getUser(participant.user_id);
+                if (user != null && user.bot) {
+                    return false;
+                }
+                if (!(participant instanceof TLRPC.TL_chatParticipantCreator)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        @Override
+        public int getCount() {
+            return rowCount;
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return null;
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return false;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            int type = getItemViewType(i);
+            if (type == 0) {
+                if (view == null) {
+                    view = new TextCheckCell(mContext);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                TextCheckCell checkCell = (TextCheckCell) view;
+                chat = MessagesController.getInstance().getChat(chat_id);
+                checkCell.setTextAndCheck(LocaleController.getString("SetAdminsAll", R.string.SetAdminsAll), chat != null && !chat.admins_enabled, false);
+            } else if (type == 1) {
+                if (view == null) {
+                    view = new TextInfoPrivacyCell(mContext);
+                }
+                if (i == allAdminsInfoRow) {
+                    if (chat.admins_enabled) {
+                        ((TextInfoPrivacyCell) view).setText(LocaleController.getString("SetAdminsNotAllInfo", R.string.SetAdminsNotAllInfo));
+                    } else {
+                        ((TextInfoPrivacyCell) view).setText(LocaleController.getString("SetAdminsAllInfo", R.string.SetAdminsAllInfo));
+                    }
+                    if (usersStartRow != -1) {
+                        view.setBackgroundResource(R.drawable.greydivider);
+                    } else {
+                        view.setBackgroundResource(R.drawable.greydivider_bottom);
+                    }
+                } else if (i == usersEndRow) {
+                    ((TextInfoPrivacyCell) view).setText("");
+                    view.setBackgroundResource(R.drawable.greydivider_bottom);
+                }
+            } else if (type == 2) {
+                if (view == null) {
+                    view = new UserCell(mContext, 1, 2);
+                    view.setBackgroundColor(0xffffffff);
+                }
+                UserCell userCell = (UserCell) view;
+                TLRPC.ChatParticipant part = participants.get(i - usersStartRow);
+                TLRPC.User user = MessagesController.getInstance().getUser(part.user_id);
+                userCell.setData(user, null, null, 0);
+                chat = MessagesController.getInstance().getChat(chat_id);
+                userCell.setChecked(!(part instanceof TLRPC.TL_chatParticipant) || chat != null && !chat.admins_enabled, false);
+                userCell.setCheckDisabled(chat == null || !chat.admins_enabled || part.user_id == UserConfig.getClientUserId() || user != null && user.bot);
+            }
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            if (i == allAdminsRow) {
+                return 0;
+            } else if (i == allAdminsInfoRow || i == usersEndRow) {
+                return 1;
+            } else {
+                return 2;
+            }
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 3;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return false;
+        }
+    }
+
+    public class SearchAdapter extends BaseFragmentAdapter {
+
+        private Context mContext;
+        private ArrayList<TLRPC.ChatParticipant> searchResult = new ArrayList<>();
+        private ArrayList<CharSequence> searchResultNames = new ArrayList<>();
+        private Timer searchTimer;
+
+        public SearchAdapter(Context context) {
+            mContext = context;
+        }
+
+        public void search(final String query) {
+            try {
+                if (searchTimer != null) {
+                    searchTimer.cancel();
+                }
+            } catch (Exception e) {
+                FileLog.e("tmessages", e);
+            }
+            if (query == null) {
+                searchResult.clear();
+                searchResultNames.clear();
+                notifyDataSetChanged();
+            } else {
+                searchTimer = new Timer();
+                searchTimer.schedule(new TimerTask() {
+                    @Override
+                    public void run() {
+                        try {
+                            searchTimer.cancel();
+                            searchTimer = null;
+                        } catch (Exception e) {
+                            FileLog.e("tmessages", e);
+                        }
+                        processSearch(query);
+                    }
+                }, 200, 300);
+            }
+        }
+
+        private void processSearch(final String query) {
+            AndroidUtilities.runOnUIThread(new Runnable() {
+                @Override
+                public void run() {
+                    final ArrayList<TLRPC.ChatParticipant> contactsCopy = new ArrayList<>();
+                    contactsCopy.addAll(participants);
+                    Utilities.searchQueue.postRunnable(new Runnable() {
+                        @Override
+                        public void run() {
+                            String search1 = query.trim().toLowerCase();
+                            if (search1.length() == 0) {
+                                updateSearchResults(new ArrayList<TLRPC.ChatParticipant>(), new ArrayList<CharSequence>());
+                                return;
+                            }
+                            String search2 = LocaleController.getInstance().getTranslitString(search1);
+                            if (search1.equals(search2) || search2.length() == 0) {
+                                search2 = null;
+                            }
+                            String search[] = new String[1 + (search2 != null ? 1 : 0)];
+                            search[0] = search1;
+                            if (search2 != null) {
+                                search[1] = search2;
+                            }
+
+                            ArrayList<TLRPC.ChatParticipant> resultArray = new ArrayList<>();
+                            ArrayList<CharSequence> resultArrayNames = new ArrayList<>();
+
+                            for (int a = 0; a < contactsCopy.size(); a++) {
+                                TLRPC.ChatParticipant participant = contactsCopy.get(a);
+                                TLRPC.User user = MessagesController.getInstance().getUser(participant.user_id);
+                                if (user.id == UserConfig.getClientUserId() || user.bot) {
+                                    continue;
+                                }
+
+                                String name = ContactsController.formatName(user.first_name, user.last_name).toLowerCase();
+                                String tName = LocaleController.getInstance().getTranslitString(name);
+                                if (name.equals(tName)) {
+                                    tName = null;
+                                }
+
+                                int found = 0;
+                                for (String q : search) {
+                                    if (name.startsWith(q) || name.contains(" " + q) || tName != null && (tName.startsWith(q) || tName.contains(" " + q))) {
+                                        found = 1;
+                                    } else if (user.username != null && user.username.startsWith(q)) {
+                                        found = 2;
+                                    }
+
+                                    if (found != 0) {
+                                        if (found == 1) {
+                                            resultArrayNames.add(AndroidUtilities.generateSearchName(user.first_name, user.last_name, q));
+                                        } else {
+                                            resultArrayNames.add(AndroidUtilities.generateSearchName("@" + user.username, null, "@" + q));
+                                        }
+                                        resultArray.add(participant);
+                                        break;
+                                    }
+                                }
+                            }
+
+                            updateSearchResults(resultArray, resultArrayNames);
+                        }
+                    });
+                }
+            });
+        }
+
+        private void updateSearchResults(final ArrayList<TLRPC.ChatParticipant> users, final ArrayList<CharSequence> names) {
+            AndroidUtilities.runOnUIThread(new Runnable() {
+                @Override
+                public void run() {
+                    searchResult = users;
+                    searchResultNames = names;
+                    notifyDataSetChanged();
+                }
+            });
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return true;
+        }
+
+        @Override
+        public boolean isEnabled(int i) {
+            return true;
+        }
+
+        @Override
+        public int getCount() {
+            return searchResult.size();
+        }
+
+        @Override
+        public TLRPC.ChatParticipant getItem(int i) {
+            return searchResult.get(i);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return i;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return true;
+        }
+
+        @Override
+        public View getView(int i, View view, ViewGroup viewGroup) {
+            if (view == null) {
+                view = new UserCell(mContext, 1, 2);
+            }
+
+            TLRPC.ChatParticipant participant = getItem(i);
+            TLRPC.User user = MessagesController.getInstance().getUser(participant.user_id);
+            String un = user.username;
+
+            CharSequence username = null;
+            CharSequence name = null;
+            if (i < searchResult.size()) {
+                name = searchResultNames.get(i);
+                if (name != null && un != null && un.length() > 0) {
+                    if (name.toString().startsWith("@" + un)) {
+                        username = name;
+                        name = null;
+                    }
+                }
+            }
+            UserCell userCell = (UserCell) view;
+            userCell.setData(user, name, username, 0);
+            chat = MessagesController.getInstance().getChat(chat_id);
+            userCell.setChecked(!(participant instanceof TLRPC.TL_chatParticipant) || chat != null && !chat.admins_enabled, false);
+            userCell.setCheckDisabled(chat == null || !chat.admins_enabled || participant.user_id == UserConfig.getClientUserId() || user != null && user.bot);
+            return view;
+        }
+
+        @Override
+        public int getItemViewType(int i) {
+            return 0;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return 1;
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return searchResult.isEmpty();
+        }
+    }
+}
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
index 8c1170404..a341fe7c2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/SettingsActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -105,6 +105,10 @@
     private ImageView writeButton;
     private AnimatorSetProxy writeButtonAnimation;
     private AvatarUpdater avatarUpdater = new AvatarUpdater();
+    private View extraHeightView;
+    private View shadowView;
+
+    private int extraHeight;
 
     private int overscrollRow;
     private int emptyRow;
@@ -128,6 +132,7 @@
     private int messagesSectionRow2;
     private int textSizeRow;
     private int stickersRow;
+    private int cacheRow;
     private int sendByEnterRow;
     private int supportSectionRow;
     private int supportSectionRow2;
@@ -239,6 +244,7 @@ public void run() {
         messagesSectionRow2 = rowCount++;
         textSizeRow = rowCount++;
         stickersRow = rowCount++;
+        cacheRow = rowCount++;
         sendByEnterRow = rowCount++;
         supportSectionRow = rowCount++;
         supportSectionRow2 = rowCount++;
@@ -270,17 +276,13 @@ public void onFragmentDestroy() {
         avatarUpdater.clear();
     }
 
-    @Override
-    public boolean needAddActionBar() {
-        return false;
-    }
-
     @Override
     public View createView(Context context) {
         actionBar.setBackgroundColor(AvatarDrawable.getProfileBackColorForId(5));
         actionBar.setItemsBackground(AvatarDrawable.getButtonColorForId(5));
         actionBar.setBackButtonImage(R.drawable.ic_ab_back);
-        actionBar.setExtraHeight(AndroidUtilities.dp(88), false);
+        actionBar.setAddToContainer(false);
+        extraHeight = 88;
         if (AndroidUtilities.isTablet()) {
             actionBar.setOccupyStatusBar(false);
         }
@@ -346,41 +348,6 @@ protected boolean drawChild(@NonNull Canvas canvas, @NonNull View child, long dr
         };
         FrameLayout frameLayout = (FrameLayout) fragmentView;
 
-        avatarImage = new BackupImageView(context);
-        avatarImage.setRoundRadius(AndroidUtilities.dp(30));
-        actionBar.addView(avatarImage, LayoutHelper.createFrame(60, 60, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM, LocaleController.isRTL ? 0 : 17, 0, LocaleController.isRTL ? 17 : 0, 22));
-        avatarImage.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                TLRPC.User user = MessagesController.getInstance().getUser(UserConfig.getClientUserId());
-                if (user.photo != null && user.photo.photo_big != null) {
-                    PhotoViewer.getInstance().setParentActivity(getParentActivity());
-                    PhotoViewer.getInstance().openPhoto(user.photo.photo_big, SettingsActivity.this);
-                }
-            }
-        });
-
-        nameTextView = new TextView(context);
-        nameTextView.setTextColor(0xffffffff);
-        nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20);
-        nameTextView.setLines(1);
-        nameTextView.setMaxLines(1);
-        nameTextView.setSingleLine(true);
-        nameTextView.setEllipsize(TextUtils.TruncateAt.END);
-        nameTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
-        nameTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
-        actionBar.addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM, LocaleController.isRTL ? 16 : 97, 0, LocaleController.isRTL ? 97 : 16, 51));
-
-        onlineTextView = new TextView(context);
-        onlineTextView.setTextColor(AvatarDrawable.getProfileTextColorForId(5));
-        onlineTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
-        onlineTextView.setLines(1);
-        onlineTextView.setMaxLines(1);
-        onlineTextView.setSingleLine(true);
-        onlineTextView.setEllipsize(TextUtils.TruncateAt.END);
-        onlineTextView.setGravity((LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT));
-        actionBar.addView(onlineTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.RIGHT : Gravity.LEFT) | Gravity.BOTTOM, LocaleController.isRTL ? 16 : 97, 0, LocaleController.isRTL ? 97 : 16, 30));
-
         listView = new ListView(context);
         listView.setDivider(null);
         listView.setDividerHeight(0);
@@ -594,12 +561,62 @@ public void onClick(DialogInterface dialog, int which, boolean isChecked) {
                     presentFragment(new ChangePhoneHelpActivity());
                 } else if (i == stickersRow) {
                     presentFragment(new StickersActivity());
+                } else if (i == cacheRow) {
+                    presentFragment(new CacheControlActivity());
                 }
             }
         });
 
         frameLayout.addView(actionBar);
 
+        extraHeightView = new View(context);
+        ViewProxy.setPivotY(extraHeightView, 0);
+        extraHeightView.setBackgroundColor(AvatarDrawable.getProfileBackColorForId(5));
+        frameLayout.addView(extraHeightView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 88));
+
+        shadowView = new View(context);
+        shadowView.setBackgroundResource(R.drawable.header_shadow);
+        frameLayout.addView(shadowView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, 3));
+
+        avatarImage = new BackupImageView(context);
+        avatarImage.setRoundRadius(AndroidUtilities.dp(21));
+        ViewProxy.setPivotX(avatarImage, 0);
+        ViewProxy.setPivotY(avatarImage, 0);
+        frameLayout.addView(avatarImage, LayoutHelper.createFrame(42, 42, Gravity.TOP | Gravity.LEFT, 64, 0, 0, 0));
+        avatarImage.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                TLRPC.User user = MessagesController.getInstance().getUser(UserConfig.getClientUserId());
+                if (user.photo != null && user.photo.photo_big != null) {
+                    PhotoViewer.getInstance().setParentActivity(getParentActivity());
+                    PhotoViewer.getInstance().openPhoto(user.photo.photo_big, SettingsActivity.this);
+                }
+            }
+        });
+
+        nameTextView = new TextView(context);
+        nameTextView.setTextColor(0xffffffff);
+        nameTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18);
+        nameTextView.setLines(1);
+        nameTextView.setMaxLines(1);
+        nameTextView.setSingleLine(true);
+        nameTextView.setEllipsize(TextUtils.TruncateAt.END);
+        nameTextView.setGravity(Gravity.LEFT);
+        nameTextView.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"));
+        ViewProxy.setPivotX(nameTextView, 0);
+        ViewProxy.setPivotY(nameTextView, 0);
+        frameLayout.addView(nameTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP, 118, 0, 48, 0));
+
+        onlineTextView = new TextView(context);
+        onlineTextView.setTextColor(AvatarDrawable.getProfileTextColorForId(5));
+        onlineTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14);
+        onlineTextView.setLines(1);
+        onlineTextView.setMaxLines(1);
+        onlineTextView.setSingleLine(true);
+        onlineTextView.setEllipsize(TextUtils.TruncateAt.END);
+        onlineTextView.setGravity(Gravity.LEFT);
+        frameLayout.addView(onlineTextView, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.LEFT | Gravity.TOP, 118, 0, 48, 0));
+
         writeButton = new ImageView(context);
         writeButton.setBackgroundResource(R.drawable.floating_user_states);
         writeButton.setImageResource(R.drawable.floating_camera);
@@ -617,7 +634,7 @@ public void getOutline(View view, Outline outline) {
                 }
             });
         }
-        frameLayout.addView(writeButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, (LocaleController.isRTL ? Gravity.LEFT : Gravity.RIGHT) | Gravity.TOP, LocaleController.isRTL ? 16 : 0, 0, LocaleController.isRTL ? 0 : 16, 0));
+        frameLayout.addView(writeButton, LayoutHelper.createFrame(LayoutHelper.WRAP_CONTENT, LayoutHelper.WRAP_CONTENT, Gravity.RIGHT | Gravity.TOP, 0, 0, 16, 0));
         writeButton.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
@@ -660,6 +677,8 @@ public void onClick(DialogInterface dialogInterface, int i) {
             }
         });
 
+        needLayout();
+
         listView.setOnScrollListener(new AbsListView.OnScrollListener() {
             @Override
             public void onScrollStateChanged(AbsListView view, int scrollState) {
@@ -677,8 +696,8 @@ public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCoun
                     if (firstVisibleItem == 0) {
                         height = AndroidUtilities.dp(88) + (child.getTop() < 0 ? child.getTop() : 0);
                     }
-                    if (actionBar.getExtraHeight() != height) {
-                        actionBar.setExtraHeight(height, true);
+                    if (extraHeight != height) {
+                        extraHeight = height;
                         needLayout();
                     }
                 }
@@ -718,6 +737,7 @@ public void updatePhotoAtIndex(int index) {
                 object.thumb = object.imageReceiver.getBitmap();
                 object.size = -1;
                 object.radius = avatarImage.getImageReceiver().getRoundRadius();
+                object.scale = ViewProxy.getScaleX(avatarImage);
                 return object;
             }
         }
@@ -748,7 +768,8 @@ public void setPhotoChecked(int index) {
     }
 
     @Override
-    public void cancelButtonPressed() {
+    public boolean cancelButtonPressed() {
+        return true;
     }
 
     @Override
@@ -892,32 +913,29 @@ public void onConfigurationChanged(Configuration newConfig) {
 
     private void needLayout() {
         FrameLayout.LayoutParams layoutParams;
+        int newTop = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight();
         if (listView != null) {
             layoutParams = (FrameLayout.LayoutParams) listView.getLayoutParams();
-            layoutParams.topMargin = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight();
-            listView.setLayoutParams(layoutParams);
+            if (layoutParams.topMargin != newTop) {
+                layoutParams.topMargin = newTop;
+                listView.setLayoutParams(layoutParams);
+                ViewProxy.setTranslationY(extraHeightView, newTop);
+            }
         }
 
         if (avatarImage != null) {
-            float diff = actionBar.getExtraHeight() / (float) AndroidUtilities.dp(88);
-            float diffm = 1.0f - diff;
-
-            int avatarSize = 42 + (int) (18 * diff);
-            int avatarX = 17 + (int) (47 * diffm);
-            int avatarY = AndroidUtilities.dp(22) - (int) ((AndroidUtilities.dp(22) - (ActionBar.getCurrentActionBarHeight() - AndroidUtilities.dp(42)) / 2) * (1.0f - diff));
-            int nameX = 97 + (int) (21 * diffm);
-            int nameEndX = 16 + (int) (32 * diffm);
-            int nameY = avatarY + AndroidUtilities.dp(29 - 13 * diffm);
-            int statusY = avatarY + AndroidUtilities.dp(8 - 7 * diffm);
-            float scale = 1.0f - 0.12f * diffm;
-
-            layoutParams = (FrameLayout.LayoutParams) writeButton.getLayoutParams();
-            layoutParams.topMargin = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight() + actionBar.getExtraHeight() - AndroidUtilities.dp(29.5f);
-            writeButton.setLayoutParams(layoutParams);
-
-            //ViewProxy.setScaleX(writeButton, diff > 0.2f ? 1.0f : diff / 0.2f);
-            //ViewProxy.setScaleY(writeButton, diff > 0.2f ? 1.0f : diff / 0.2f);
-            //ViewProxy.setAlpha(writeButton, diff > 0.2f ? 1.0f : diff / 0.2f);
+            float diff = extraHeight / (float) AndroidUtilities.dp(88);
+            ViewProxy.setScaleY(extraHeightView, diff);
+            ViewProxy.setTranslationY(shadowView, newTop + extraHeight);
+
+            if (Build.VERSION.SDK_INT < 11) {
+                layoutParams = (FrameLayout.LayoutParams) writeButton.getLayoutParams();
+                layoutParams.topMargin = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight() + extraHeight - AndroidUtilities.dp(29.5f);
+                writeButton.setLayoutParams(layoutParams);
+            } else {
+                ViewProxy.setTranslationY(writeButton, (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight() + extraHeight - AndroidUtilities.dp(29.5f));
+            }
+
             final boolean setVisible = diff > 0.2f;
             boolean currentVisible = writeButton.getTag() == null;
             if (setVisible != currentVisible) {
@@ -962,30 +980,17 @@ public void onAnimationEnd(Object animation) {
                 writeButtonAnimation.start();
             }
 
-            avatarImage.setRoundRadius(AndroidUtilities.dp(avatarSize / 2));
-            layoutParams = (FrameLayout.LayoutParams) avatarImage.getLayoutParams();
-            layoutParams.width = AndroidUtilities.dp(avatarSize);
-            layoutParams.height = AndroidUtilities.dp(avatarSize);
-            layoutParams.leftMargin = LocaleController.isRTL ? 0 : AndroidUtilities.dp(avatarX);
-            layoutParams.rightMargin = LocaleController.isRTL ? AndroidUtilities.dp(avatarX) : 0;
-            layoutParams.bottomMargin = avatarY;
-            avatarImage.setLayoutParams(layoutParams);
-
-            ViewProxy.setPivotX(nameTextView, 0);
-            ViewProxy.setPivotY(nameTextView, 0);
-            ViewProxy.setScaleX(nameTextView, scale);
-            ViewProxy.setScaleY(nameTextView, scale);
-            layoutParams = (FrameLayout.LayoutParams) nameTextView.getLayoutParams();
-            layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? nameEndX : nameX);
-            layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? nameX : nameEndX);
-            layoutParams.bottomMargin = nameY;
-            nameTextView.setLayoutParams(layoutParams);
-
-            layoutParams = (FrameLayout.LayoutParams) onlineTextView.getLayoutParams();
-            layoutParams.leftMargin = AndroidUtilities.dp(LocaleController.isRTL ? nameEndX : nameX);
-            layoutParams.rightMargin = AndroidUtilities.dp(LocaleController.isRTL ? nameX : nameEndX);
-            layoutParams.bottomMargin = statusY;
-            onlineTextView.setLayoutParams(layoutParams);
+            ViewProxy.setScaleX(avatarImage, (42 + 18 * diff) / 42.0f);
+            ViewProxy.setScaleY(avatarImage, (42 + 18 * diff) / 42.0f);
+            float avatarY = (actionBar.getOccupyStatusBar() ? AndroidUtilities.statusBarHeight : 0) + ActionBar.getCurrentActionBarHeight() / 2.0f * (1.0f + diff) - 21 * AndroidUtilities.density + 27 * AndroidUtilities.density * diff;
+            ViewProxy.setTranslationX(avatarImage, -AndroidUtilities.dp(47) * diff);
+            ViewProxy.setTranslationY(avatarImage, (float) Math.ceil(avatarY));
+            ViewProxy.setTranslationX(nameTextView, -21 * AndroidUtilities.density * diff);
+            ViewProxy.setTranslationY(nameTextView, (float) Math.floor(avatarY) - (float) Math.ceil(AndroidUtilities.density) + (float) Math.floor(7 * AndroidUtilities.density * diff));
+            ViewProxy.setTranslationX(onlineTextView, -21 * AndroidUtilities.density * diff);
+            ViewProxy.setTranslationY(onlineTextView, (float) Math.floor(avatarY) + AndroidUtilities.dp(22) + (float )Math.floor(11 * AndroidUtilities.density) * diff);
+            ViewProxy.setScaleX(nameTextView, 1.0f + 0.12f * diff);
+            ViewProxy.setScaleY(nameTextView, 1.0f + 0.12f * diff);
         }
     }
 
@@ -1068,7 +1073,7 @@ public boolean isEnabled(int i) {
                     i == askQuestionRow || i == sendLogsRow || i == sendByEnterRow || i == privacyRow || i == wifiDownloadRow ||
                     i == mobileDownloadRow || i == clearLogsRow || i == roamingDownloadRow || i == languageRow || i == usernameRow ||
                     i == switchBackendButtonRow || i == telegramFaqRow || i == contactsSortRow || i == contactsReimportRow || i == saveToGalleryRow ||
-                    i == stickersRow;
+                    i == stickersRow || i == cacheRow;
         }
 
         @Override
@@ -1150,6 +1155,8 @@ public View getView(int i, View view, ViewGroup viewGroup) {
                     textCell.setText(LocaleController.getString("ImportContacts", R.string.ImportContacts), true);
                 } else if (i == stickersRow) {
                     textCell.setText(LocaleController.getString("Stickers", R.string.Stickers), true);
+                } else if (i == cacheRow) {
+                    textCell.setText(LocaleController.getString("CacheSettings", R.string.CacheSettings), true);
                 }
             } else if (type == 3) {
                 if (view == null) {
@@ -1268,7 +1275,7 @@ public int getItemViewType(int i) {
                 return 1;
             } else if (i == enableAnimationsRow || i == sendByEnterRow || i == saveToGalleryRow) {
                 return 3;
-            } else if (i == notificationRow || i == backgroundRow || i == askQuestionRow || i == sendLogsRow || i == privacyRow || i == clearLogsRow || i == switchBackendButtonRow || i == telegramFaqRow || i == contactsReimportRow || i == textSizeRow || i == languageRow || i == contactsSortRow || i == stickersRow) {
+            } else if (i == notificationRow || i == backgroundRow || i == askQuestionRow || i == sendLogsRow || i == privacyRow || i == clearLogsRow || i == switchBackendButtonRow || i == telegramFaqRow || i == contactsReimportRow || i == textSizeRow || i == languageRow || i == contactsSortRow || i == stickersRow || i == cacheRow) {
                 return 2;
             } else if (i == versionRow) {
                 return 5;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/StickerPreviewViewer.java b/TMessagesProj/src/main/java/org/telegram/ui/StickerPreviewViewer.java
index 758368610..01e654707 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/StickerPreviewViewer.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/StickerPreviewViewer.java
@@ -107,7 +107,6 @@ public boolean onTouch(View v, MotionEvent event) {
         } else {
             windowLayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
         }
-
         centerImage.setAspectFit(true);
         centerImage.setInvalidateAll(true);
         centerImage.setParentView(containerView);
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/StickersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/StickersActivity.java
index abc2c89ec..5c2b3b7e2 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/StickersActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/StickersActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 2.x.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -12,15 +12,14 @@
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
+import android.graphics.Canvas;
 import android.os.Build;
 import android.os.Message;
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AdapterView;
 import android.widget.FrameLayout;
-import android.widget.ListView;
 import android.widget.Toast;
 
 import org.telegram.messenger.LocaleController;
@@ -30,13 +29,19 @@
 import org.telegram.messenger.ApplicationLoader;
 import org.telegram.messenger.FileLog;
 import org.telegram.messenger.R;
+import org.telegram.messenger.support.widget.LinearLayoutManager;
+import org.telegram.messenger.support.widget.RecyclerView;
+import org.telegram.messenger.support.widget.helper.ItemTouchHelper;
+import org.telegram.tgnet.ConnectionsManager;
+import org.telegram.tgnet.RequestDelegate;
+import org.telegram.tgnet.TLObject;
 import org.telegram.tgnet.TLRPC;
 import org.telegram.ui.ActionBar.ActionBar;
 import org.telegram.ui.ActionBar.BaseFragment;
-import org.telegram.ui.Adapters.BaseFragmentAdapter;
 import org.telegram.ui.Cells.StickerSetCell;
 import org.telegram.ui.Cells.TextInfoPrivacyCell;
 import org.telegram.ui.Components.LayoutHelper;
+import org.telegram.ui.Components.RecyclerListView;
 import org.telegram.ui.Components.StickersAlert;
 import org.telegram.ui.Components.URLSpanNoUnderline;
 
@@ -45,13 +50,68 @@
 
 public class StickersActivity extends BaseFragment implements NotificationCenter.NotificationCenterDelegate {
 
+    private RecyclerListView listView;
     private ListAdapter listAdapter;
 
+    private boolean needReorder;
+
     private int stickersStartRow;
     private int stickersEndRow;
     private int stickersInfoRow;
     private int rowCount;
 
+    public class TouchHelperCallback extends ItemTouchHelper.Callback {
+
+        public static final float ALPHA_FULL = 1.0f;
+
+        @Override
+        public boolean isLongPressDragEnabled() {
+            return true;
+        }
+
+        @Override
+        public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
+            if (viewHolder.getItemViewType() != 0) {
+                return makeMovementFlags(0, 0);
+            }
+            return makeMovementFlags(ItemTouchHelper.UP | ItemTouchHelper.DOWN, 0);
+        }
+
+        @Override
+        public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder source, RecyclerView.ViewHolder target) {
+            if (source.getItemViewType() != target.getItemViewType()) {
+                return false;
+            }
+            listAdapter.swapElements(source.getAdapterPosition(), target.getAdapterPosition());
+            return true;
+        }
+
+        @Override
+        public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) {
+            super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);
+        }
+
+        @Override
+        public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) {
+            if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) {
+                listView.cancelClickRunnables(false);
+                viewHolder.itemView.setPressed(true);
+            }
+            super.onSelectedChanged(viewHolder, actionState);
+        }
+
+        @Override
+        public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {
+
+        }
+
+        @Override
+        public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
+            super.clearView(recyclerView, viewHolder);
+            viewHolder.itemView.setPressed(false);
+        }
+    }
+
     @Override
     public boolean onFragmentCreate() {
         super.onFragmentCreate();
@@ -64,7 +124,7 @@ public boolean onFragmentCreate() {
     @Override
     public void onFragmentDestroy() {
         super.onFragmentDestroy();
-        NotificationCenter.getInstance().removeObserver(this, NotificationCenter.stickersDidLoaded);
+        sendReorder();
     }
 
     @Override
@@ -87,25 +147,28 @@ public void onItemClick(int id) {
         FrameLayout frameLayout = (FrameLayout) fragmentView;
         frameLayout.setBackgroundColor(0xfff0f0f0);
 
-        ListView listView = new ListView(context);
-        listView.setDivider(null);
-        listView.setDividerHeight(0);
-        listView.setVerticalScrollBarEnabled(false);
-        listView.setDrawSelectorOnTop(true);
+        listView = new RecyclerListView(context);
+        LinearLayoutManager layoutManager = new LinearLayoutManager(context);
+        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);
+        listView.setLayoutManager(layoutManager);
+        ItemTouchHelper itemTouchHelper = new ItemTouchHelper(new TouchHelperCallback());
+        itemTouchHelper.attachToRecyclerView(listView);
+
         frameLayout.addView(listView, LayoutHelper.createFrame(LayoutHelper.MATCH_PARENT, LayoutHelper.MATCH_PARENT));
         listView.setAdapter(listAdapter);
-        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+        listView.setOnItemClickListener(new RecyclerListView.OnItemClickListener() {
             @Override
-            public void onItemClick(AdapterView<?> adapterView, View view, final int i, long l) {
-                if (i >= stickersStartRow && i < stickersEndRow && getParentActivity() != null) {
-                    final TLRPC.TL_messages_stickerSet stickerSet = StickersQuery.getStickerSets().get(i);
+            public void onItemClick(View view, int position) {
+                if (position >= stickersStartRow && position < stickersEndRow && getParentActivity() != null) {
+                    sendReorder();
+                    final TLRPC.TL_messages_stickerSet stickerSet = StickersQuery.getStickerSets().get(position);
                     ArrayList<TLRPC.Document> stickers = stickerSet.documents;
                     if (stickers == null || stickers.isEmpty()) {
                         return;
                     }
                     StickersAlert alert = new StickersAlert(getParentActivity(), stickerSet);
                     alert.setButton(AlertDialog.BUTTON_NEGATIVE, LocaleController.getString("Close", R.string.Close), (Message) null);
-                    if ((stickerSet.set.flags & 4) == 0) {
+                    if (!stickerSet.set.official) {
                         alert.setButton(AlertDialog.BUTTON_NEUTRAL, LocaleController.getString("StickersRemove", R.string.StickersRemove), new DialogInterface.OnClickListener() {
                             @Override
                             public void onClick(DialogInterface dialog, int which) {
@@ -129,6 +192,26 @@ public void didReceivedNotification(int id, Object... args) {
         }
     }
 
+    private void sendReorder() {
+        if (!needReorder) {
+            return;
+        }
+        StickersQuery.calcNewHash();
+        needReorder = false;
+        TLRPC.TL_messages_reorderStickerSets req = new TLRPC.TL_messages_reorderStickerSets();
+        ArrayList<TLRPC.TL_messages_stickerSet> arrayList = StickersQuery.getStickerSets();
+        for (int a = 0; a < arrayList.size(); a++) {
+            req.order.add(arrayList.get(a).set.id);
+        }
+        ConnectionsManager.getInstance().sendRequest(req, new RequestDelegate() {
+            @Override
+            public void run(TLObject response, TLRPC.TL_error error) {
+
+            }
+        });
+        NotificationCenter.getInstance().postNotificationName(NotificationCenter.stickersDidLoaded);
+    }
+
     private void updateRows() {
         rowCount = 0;
         ArrayList<TLRPC.TL_messages_stickerSet> stickerSets = StickersQuery.getStickerSets();
@@ -154,46 +237,39 @@ public void onResume() {
         }
     }
 
-    private class ListAdapter extends BaseFragmentAdapter {
+    private class ListAdapter extends RecyclerListView.Adapter {
         private Context mContext;
 
-        public ListAdapter(Context context) {
-            mContext = context;
-        }
+        private class Holder extends RecyclerView.ViewHolder {
 
-        @Override
-        public boolean areAllItemsEnabled() {
-            return false;
+            public Holder(View itemView) {
+                super(itemView);
+            }
         }
 
-        @Override
-        public boolean isEnabled(int i) {
-            return i >= stickersStartRow && i < stickersEndRow;
+        public ListAdapter(Context context) {
+            mContext = context;
         }
 
         @Override
-        public int getCount() {
+        public int getItemCount() {
             return rowCount;
         }
 
-        @Override
-        public Object getItem(int i) {
-            return null;
-        }
-
         @Override
         public long getItemId(int i) {
+            if (i >= stickersStartRow && i < stickersEndRow) {
+                ArrayList<TLRPC.TL_messages_stickerSet> arrayList = StickersQuery.getStickerSets();
+                return arrayList.get(i).set.id;
+            } else if (i == stickersInfoRow) {
+                return Integer.MIN_VALUE;
+            }
             return i;
         }
 
-        @Override
-        public boolean hasStableIds() {
-            return false;
-        }
-
         private void processSelectionOption(int which, TLRPC.TL_messages_stickerSet stickerSet) {
             if (which == 0) {
-                StickersQuery.removeStickersSet(getParentActivity(), stickerSet.set, (stickerSet.set.flags & 2) == 0 ? 1 : 2);
+                StickersQuery.removeStickersSet(getParentActivity(), stickerSet.set, !stickerSet.set.disabled ? 1 : 2);
             } else if (which == 1) {
                 StickersQuery.removeStickersSet(getParentActivity(), stickerSet.set, 0);
             } else if (which == 2) {
@@ -223,32 +299,40 @@ private void processSelectionOption(int which, TLRPC.TL_messages_stickerSet stic
         }
 
         @Override
-        public View getView(int i, View view, ViewGroup viewGroup) {
-            int type = getItemViewType(i);
-            if (type == 0) {
-                if (view == null) {
+        public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
+            if (holder.getItemViewType() == 0) {
+                ArrayList<TLRPC.TL_messages_stickerSet> arrayList = StickersQuery.getStickerSets();
+                ((StickerSetCell) holder.itemView).setStickersSet(arrayList.get(position), position != arrayList.size() - 1);
+            }
+        }
+
+        @Override
+        public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+            View view = null;
+            switch (viewType) {
+                case 0:
                     view = new StickerSetCell(mContext);
                     view.setBackgroundColor(0xffffffff);
+                    view.setBackgroundResource(R.drawable.list_selector_white);
                     ((StickerSetCell) view).setOnOptionsClick(new View.OnClickListener() {
                         @Override
                         public void onClick(View v) {
+                            sendReorder();
                             StickerSetCell cell = (StickerSetCell) v.getParent();
                             final TLRPC.TL_messages_stickerSet stickerSet = cell.getStickersSet();
                             AlertDialog.Builder builder = new AlertDialog.Builder(getParentActivity());
                             builder.setTitle(stickerSet.set.title);
                             CharSequence[] items;
                             final int[] options;
-                            if ((stickerSet.set.flags & 4) != 0) {
-                                options = new int[]{0, 2, 3};
+                            if (stickerSet.set.official) {
+                                options = new int[]{0};
                                 items = new CharSequence[]{
-                                        (stickerSet.set.flags & 2) == 0 ? LocaleController.getString("StickersHide", R.string.StickersHide) : LocaleController.getString("StickersShow", R.string.StickersShow),
-                                        LocaleController.getString("StickersShare", R.string.StickersShare),
-                                        LocaleController.getString("StickersCopy", R.string.StickersCopy),
+                                        !stickerSet.set.disabled ? LocaleController.getString("StickersHide", R.string.StickersHide) : LocaleController.getString("StickersShow", R.string.StickersShow)
                                 };
                             } else {
                                 options = new int[]{0, 1, 2, 3};
                                 items = new CharSequence[]{
-                                        (stickerSet.set.flags & 2) == 0 ? LocaleController.getString("StickersHide", R.string.StickersHide) : LocaleController.getString("StickersShow", R.string.StickersShow),
+                                        !stickerSet.set.disabled ? LocaleController.getString("StickersHide", R.string.StickersHide) : LocaleController.getString("StickersShow", R.string.StickersShow),
                                         LocaleController.getString("StickersRemove", R.string.StickersRemove),
                                         LocaleController.getString("StickersShare", R.string.StickersShare),
                                         LocaleController.getString("StickersCopy", R.string.StickersCopy),
@@ -263,11 +347,8 @@ public void onClick(DialogInterface dialog, int which) {
                             showDialog(builder.create());
                         }
                     });
-                }
-                ArrayList<TLRPC.TL_messages_stickerSet> arrayList = StickersQuery.getStickerSets();
-                ((StickerSetCell) view).setStickersSet(arrayList.get(i), i != arrayList.size() - 1);
-            } else if (type == 1) {
-                if (view == null) {
+                    break;
+                case 1:
                     view = new TextInfoPrivacyCell(mContext);
                     String text = LocaleController.getString("StickersInfo", R.string.StickersInfo);
                     String botName = "@stickers";
@@ -291,9 +372,9 @@ public void onClick(View widget) {
                         ((TextInfoPrivacyCell) view).setText(text);
                     }
                     view.setBackgroundResource(R.drawable.greydivider_bottom);
-                }
+                    break;
             }
-            return view;
+            return new Holder(view);
         }
 
         @Override
@@ -306,14 +387,15 @@ public int getItemViewType(int i) {
             return 0;
         }
 
-        @Override
-        public int getViewTypeCount() {
-            return 2;
-        }
-
-        @Override
-        public boolean isEmpty() {
-            return false;
+        public void swapElements(int fromIndex, int toIndex) {
+            if (fromIndex != toIndex) {
+                needReorder = true;
+            }
+            ArrayList<TLRPC.TL_messages_stickerSet> arrayList = StickersQuery.getStickerSets();
+            TLRPC.TL_messages_stickerSet from = arrayList.get(fromIndex);
+            arrayList.set(fromIndex, arrayList.get(toIndex));
+            arrayList.set(toIndex, from);
+            notifyItemMoved(fromIndex, toIndex);
         }
     }
 }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java
index 32f2b54ab..ed96a2c20 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/TwoStepVerificationActivity.java
@@ -1,5 +1,5 @@
 /*
- * This is the source code of Telegram for Android v. 2.x
+ * This is the source code of Telegram for Android v. 3.x.x
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
@@ -27,7 +27,6 @@
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
-import android.view.WindowManager;
 import android.view.inputmethod.EditorInfo;
 import android.widget.AdapterView;
 import android.widget.EditText;
@@ -465,9 +464,8 @@ public void run() {
     }
 
     @Override
-    public void onOpenAnimationEnd() {
-        super.onOpenAnimationEnd();
-        if (type == 1) {
+    public void onTransitionAnimationEnd(boolean isOpen, boolean backward) {
+        if (isOpen && type == 1) {
             AndroidUtilities.showKeyboard(passwordEditText);
         }
     }
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/VideoEditorActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/VideoEditorActivity.java
index 789b939da..e0c2095d4 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/VideoEditorActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/VideoEditorActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.7.x.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013-2014.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
diff --git a/TMessagesProj/src/main/java/org/telegram/ui/WallpapersActivity.java b/TMessagesProj/src/main/java/org/telegram/ui/WallpapersActivity.java
index 73e57387c..10a497155 100644
--- a/TMessagesProj/src/main/java/org/telegram/ui/WallpapersActivity.java
+++ b/TMessagesProj/src/main/java/org/telegram/ui/WallpapersActivity.java
@@ -1,9 +1,9 @@
 /*
- * This is the source code of Telegram for Android v. 1.3.2.
+ * This is the source code of Telegram for Android v. 3.x.x.
  * It is licensed under GNU GPL v. 2 or later.
  * You should have received a copy of the license in this archive (see LICENSE).
  *
- * Copyright Nikolai Kudashov, 2013.
+ * Copyright Nikolai Kudashov, 2013-2015.
  */
 
 package org.telegram.ui;
@@ -16,6 +16,7 @@
 import android.content.SharedPreferences;
 import android.graphics.Bitmap;
 import android.graphics.Point;
+import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
@@ -86,7 +87,7 @@ public boolean onFragmentCreate() {
         selectedBackground = preferences.getInt("selectedBackground", 1000001);
         selectedColor = preferences.getInt("selectedColor", 0);
         MessagesStorage.getInstance().getWallpapers();
-        File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper-temp.jpg");
+        File toFile = new File(ApplicationLoader.getFilesDirFixed(), "wallpaper-temp.jpg");
         toFile.delete();
         return true;
     }
@@ -124,7 +125,7 @@ public void onItemClick(int id) {
                         TLRPC.PhotoSize size = FileLoader.getClosestPhotoSizeWithSize(wallPaper.sizes, Math.min(width, height));
                         String fileName = size.location.volume_id + "_" + size.location.local_id + ".jpg";
                         File f = new File(FileLoader.getInstance().getDirectory(FileLoader.MEDIA_DIR_CACHE), fileName);
-                        File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper.jpg");
+                        File toFile = new File(ApplicationLoader.getFilesDirFixed(), "wallpaper.jpg");
                         try {
                             done = AndroidUtilities.copyFile(f, toFile);
                         } catch (Exception e) {
@@ -133,8 +134,8 @@ public void onItemClick(int id) {
                         }
                     } else {
                         if (selectedBackground == -1) {
-                            File fromFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper-temp.jpg");
-                            File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper.jpg");
+                            File fromFile = new File(ApplicationLoader.getFilesDirFixed(), "wallpaper-temp.jpg");
+                            File toFile = new File(ApplicationLoader.getFilesDirFixed(), "wallpaper.jpg");
                             done = fromFile.renameTo(toFile);
                         } else {
                             done = true;
@@ -247,11 +248,12 @@ public void onActivityResultFragment(int requestCode, int resultCode, Intent dat
                 try {
                     Point screenSize = AndroidUtilities.getRealScreenSize();
                     Bitmap bitmap = ImageLoader.loadBitmap(currentPicturePath, null, screenSize.x, screenSize.y, true);
-                    File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper-temp.jpg");
+                    File toFile = new File(ApplicationLoader.getFilesDirFixed(), "wallpaper-temp.jpg");
                     stream = new FileOutputStream(toFile);
                     bitmap.compress(Bitmap.CompressFormat.JPEG, 87, stream);
                     selectedBackground = -1;
                     selectedColor = 0;
+                    Drawable drawable = backgroundImage.getDrawable();
                     backgroundImage.setImageBitmap(bitmap);
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -272,11 +274,12 @@ public void onActivityResultFragment(int requestCode, int resultCode, Intent dat
                 try {
                     Point screenSize = AndroidUtilities.getRealScreenSize();
                     Bitmap bitmap = ImageLoader.loadBitmap(null, data.getData(), screenSize.x, screenSize.y, true);
-                    File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper-temp.jpg");
+                    File toFile = new File(ApplicationLoader.getFilesDirFixed(), "wallpaper-temp.jpg");
                     FileOutputStream stream = new FileOutputStream(toFile);
                     bitmap.compress(Bitmap.CompressFormat.JPEG, 87, stream);
                     selectedBackground = -1;
                     selectedColor = 0;
+                    Drawable drawable = backgroundImage.getDrawable();
                     backgroundImage.setImageBitmap(bitmap);
                 } catch (Exception e) {
                     FileLog.e("tmessages", e);
@@ -346,9 +349,9 @@ private void processSelectedBackground() {
                 backgroundImage.setBackgroundColor(0);
                 selectedColor = 0;
             } else if (selectedBackground == -1) {
-                File toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper-temp.jpg");
+                File toFile = new File(ApplicationLoader.getFilesDirFixed(), "wallpaper-temp.jpg");
                 if (!toFile.exists()) {
-                    toFile = new File(ApplicationLoader.applicationContext.getFilesDir(), "wallpaper.jpg");
+                    toFile = new File(ApplicationLoader.getFilesDirFixed(), "wallpaper.jpg");
                 }
                 if (toFile.exists()) {
                     backgroundImage.setImageURI(Uri.fromFile(toFile));
@@ -361,6 +364,7 @@ private void processSelectedBackground() {
                     return;
                 }
                 if (wallPaper instanceof TLRPC.TL_wallPaperSolid) {
+                    Drawable drawable = backgroundImage.getDrawable();
                     backgroundImage.setImageBitmap(null);
                     selectedColor = 0xff000000 | wallPaper.bg_color;
                     backgroundImage.setBackgroundColor(selectedColor);
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/bot_list.png b/TMessagesProj/src/main/res/drawable-hdpi/bot_list.png
new file mode 100755
index 000000000..d87b1878f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/bot_list.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/check_list.png b/TMessagesProj/src/main/res/drawable-hdpi/check_list.png
new file mode 100644
index 000000000..e739bea2f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/check_list.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/check_profile.png b/TMessagesProj/src/main/res/drawable-hdpi/check_profile.png
new file mode 100644
index 000000000..380a8ebff
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/check_profile.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/dialogs_badge2.9.png b/TMessagesProj/src/main/res/drawable-hdpi/dialogs_badge2.9.png
new file mode 100755
index 000000000..76ff17ccc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/dialogs_badge2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/editheader.9.png b/TMessagesProj/src/main/res/drawable-hdpi/editheader.9.png
deleted file mode 100644
index 00240da64..000000000
Binary files a/TMessagesProj/src/main/res/drawable-hdpi/editheader.9.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_fp_40px.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_fp_40px.png
new file mode 100644
index 000000000..48ebd8ad7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_fp_40px.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/ic_settings.png b/TMessagesProj/src/main/res/drawable-hdpi/ic_settings.png
new file mode 100644
index 000000000..e999e3293
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/ic_settings.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/list_circle.png b/TMessagesProj/src/main/res/drawable-hdpi/list_circle.png
new file mode 100755
index 000000000..e6c27d1d8
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/list_circle.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/logo_avatar.png b/TMessagesProj/src/main/res/drawable-hdpi/logo_avatar.png
new file mode 100644
index 000000000..8892c08dc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/logo_avatar.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_pause.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_pause.png
deleted file mode 100644
index 9643e6522..000000000
Binary files a/TMessagesProj/src/main/res/drawable-hdpi/menu_pause.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/menu_play.png b/TMessagesProj/src/main/res/drawable-hdpi/menu_play.png
deleted file mode 100644
index 8b4bb5712..000000000
Binary files a/TMessagesProj/src/main/res/drawable-hdpi/menu_play.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/mic_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/mic_pressed.png
old mode 100755
new mode 100644
index 3cf43e04b..ae9ea3bf4
Binary files a/TMessagesProj/src/main/res/drawable-hdpi/mic_pressed.png and b/TMessagesProj/src/main/res/drawable-hdpi/mic_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_close.png b/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_close.png
new file mode 100755
index 000000000..ee4972c7a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_close.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_pause.png b/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_pause.png
new file mode 100755
index 000000000..390a69c76
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_pause.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_play.png b/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_play.png
new file mode 100755
index 000000000..7e3d35f71
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/miniplayer_play.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/search_share.png b/TMessagesProj/src/main/res/drawable-hdpi/search_share.png
new file mode 100755
index 000000000..e5bf1d95c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/search_share.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/shareblack.png b/TMessagesProj/src/main/res/drawable-hdpi/shareblack.png
new file mode 100644
index 000000000..9a9fd6f15
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/shareblack.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/shareblack_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/shareblack_pressed.png
new file mode 100644
index 000000000..be1b13bf8
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/shareblack_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/shareblue.png b/TMessagesProj/src/main/res/drawable-hdpi/shareblue.png
new file mode 100644
index 000000000..0171ea6f1
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/shareblue.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/shareblue_pressed.png b/TMessagesProj/src/main/res/drawable-hdpi/shareblue_pressed.png
new file mode 100644
index 000000000..02e40e50f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/shareblue_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-hdpi/tip4.png b/TMessagesProj/src/main/res/drawable-hdpi/tip4.png
new file mode 100644
index 000000000..cdc21ca78
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-hdpi/tip4.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/bot_list.png b/TMessagesProj/src/main/res/drawable-mdpi/bot_list.png
new file mode 100755
index 000000000..0c79af3e2
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/bot_list.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/check_list.png b/TMessagesProj/src/main/res/drawable-mdpi/check_list.png
new file mode 100644
index 000000000..4061ffae9
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/check_list.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/check_profile.png b/TMessagesProj/src/main/res/drawable-mdpi/check_profile.png
new file mode 100644
index 000000000..ada9e496d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/check_profile.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/dialogs_badge2.9.png b/TMessagesProj/src/main/res/drawable-mdpi/dialogs_badge2.9.png
new file mode 100755
index 000000000..45eaa60e0
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/dialogs_badge2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/editheader.9.png b/TMessagesProj/src/main/res/drawable-mdpi/editheader.9.png
deleted file mode 100644
index e7f67fe07..000000000
Binary files a/TMessagesProj/src/main/res/drawable-mdpi/editheader.9.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_fp_40px.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_fp_40px.png
new file mode 100644
index 000000000..122f44257
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_fp_40px.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/ic_settings.png b/TMessagesProj/src/main/res/drawable-mdpi/ic_settings.png
new file mode 100644
index 000000000..1d60c823c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/ic_settings.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/list_circle.png b/TMessagesProj/src/main/res/drawable-mdpi/list_circle.png
new file mode 100755
index 000000000..b35bee65f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/list_circle.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/logo_avatar.png b/TMessagesProj/src/main/res/drawable-mdpi/logo_avatar.png
new file mode 100644
index 000000000..c2de7747c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/logo_avatar.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_pause.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_pause.png
deleted file mode 100644
index befe821c8..000000000
Binary files a/TMessagesProj/src/main/res/drawable-mdpi/menu_pause.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/menu_play.png b/TMessagesProj/src/main/res/drawable-mdpi/menu_play.png
deleted file mode 100644
index 6d2ad6b3f..000000000
Binary files a/TMessagesProj/src/main/res/drawable-mdpi/menu_play.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed.png
old mode 100755
new mode 100644
index e1b29c5bc..ed471652e
Binary files a/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed.png and b/TMessagesProj/src/main/res/drawable-mdpi/mic_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_close.png b/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_close.png
new file mode 100755
index 000000000..1f5816b6f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_close.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_pause.png b/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_pause.png
new file mode 100755
index 000000000..9f4edcc7d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_pause.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_play.png b/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_play.png
new file mode 100755
index 000000000..088f15e25
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/miniplayer_play.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/search_share.png b/TMessagesProj/src/main/res/drawable-mdpi/search_share.png
new file mode 100755
index 000000000..9e0e2da33
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/search_share.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/shareblack.png b/TMessagesProj/src/main/res/drawable-mdpi/shareblack.png
new file mode 100644
index 000000000..815e157dc
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/shareblack.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/shareblack_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/shareblack_pressed.png
new file mode 100644
index 000000000..4bb5e13ed
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/shareblack_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/shareblue.png b/TMessagesProj/src/main/res/drawable-mdpi/shareblue.png
new file mode 100644
index 000000000..12a1c6ca5
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/shareblue.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/shareblue_pressed.png b/TMessagesProj/src/main/res/drawable-mdpi/shareblue_pressed.png
new file mode 100644
index 000000000..12a52ff43
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/shareblue_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-mdpi/tip4.png b/TMessagesProj/src/main/res/drawable-mdpi/tip4.png
new file mode 100644
index 000000000..a73985ca7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-mdpi/tip4.png differ
diff --git a/TMessagesProj/src/main/res/drawable-v21/list_selector_white.xml b/TMessagesProj/src/main/res/drawable-v21/list_selector_white.xml
new file mode 100644
index 000000000..5dbf2961f
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable-v21/list_selector_white.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ This is the source code of Telegram for Android v. 3.x.x.
+  ~ It is licensed under GNU GPL v. 2 or later.
+  ~ You should have received a copy of the license in this archive (see LICENSE).
+  ~
+  ~ Copyright Nikolai Kudashov, 2013-2015.
+  -->
+
+<ripple xmlns:android="http://schemas.android.com/apk/res/android"
+    android:color="#2f000000">
+    <item android:id="@android:id/mask" android:drawable="@android:color/white"/>
+    <item android:id="@android:id/background" android:drawable="@android:color/white"/>
+</ripple>
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/bot_list.png b/TMessagesProj/src/main/res/drawable-xhdpi/bot_list.png
new file mode 100755
index 000000000..286e9644b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/bot_list.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/check_list.png b/TMessagesProj/src/main/res/drawable-xhdpi/check_list.png
new file mode 100644
index 000000000..7bc4bc303
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/check_list.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/check_profile.png b/TMessagesProj/src/main/res/drawable-xhdpi/check_profile.png
new file mode 100644
index 000000000..36efe5482
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/check_profile.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_badge2.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_badge2.9.png
new file mode 100755
index 000000000..ad1d30b65
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/dialogs_badge2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/editheader.9.png b/TMessagesProj/src/main/res/drawable-xhdpi/editheader.9.png
deleted file mode 100644
index 50261891c..000000000
Binary files a/TMessagesProj/src/main/res/drawable-xhdpi/editheader.9.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_fp_40px.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_fp_40px.png
new file mode 100644
index 000000000..e1c9590bb
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_fp_40px.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/ic_settings.png b/TMessagesProj/src/main/res/drawable-xhdpi/ic_settings.png
new file mode 100644
index 000000000..c2d1c30b0
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/ic_settings.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/list_circle.png b/TMessagesProj/src/main/res/drawable-xhdpi/list_circle.png
new file mode 100755
index 000000000..73433f905
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/list_circle.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/logo_avatar.png b/TMessagesProj/src/main/res/drawable-xhdpi/logo_avatar.png
new file mode 100644
index 000000000..10c2dc9af
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/logo_avatar.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_pause.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_pause.png
deleted file mode 100644
index 54f0f7bcd..000000000
Binary files a/TMessagesProj/src/main/res/drawable-xhdpi/menu_pause.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/menu_play.png b/TMessagesProj/src/main/res/drawable-xhdpi/menu_play.png
deleted file mode 100644
index 718da7c4e..000000000
Binary files a/TMessagesProj/src/main/res/drawable-xhdpi/menu_play.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/mic_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/mic_pressed.png
old mode 100755
new mode 100644
index 62e655bea..bebe93611
Binary files a/TMessagesProj/src/main/res/drawable-xhdpi/mic_pressed.png and b/TMessagesProj/src/main/res/drawable-xhdpi/mic_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_close.png b/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_close.png
new file mode 100755
index 000000000..07d83314b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_close.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_pause.png b/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_pause.png
new file mode 100755
index 000000000..38746874f
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_pause.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_play.png b/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_play.png
new file mode 100755
index 000000000..e4e14c38a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/miniplayer_play.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/search_share.png b/TMessagesProj/src/main/res/drawable-xhdpi/search_share.png
new file mode 100755
index 000000000..c8c15c21b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/search_share.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/shareblack.png b/TMessagesProj/src/main/res/drawable-xhdpi/shareblack.png
new file mode 100644
index 000000000..6f7d9fffb
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/shareblack.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/shareblack_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/shareblack_pressed.png
new file mode 100644
index 000000000..2d555afca
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/shareblack_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/shareblue.png b/TMessagesProj/src/main/res/drawable-xhdpi/shareblue.png
new file mode 100644
index 000000000..5d249505c
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/shareblue.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/shareblue_pressed.png b/TMessagesProj/src/main/res/drawable-xhdpi/shareblue_pressed.png
new file mode 100644
index 000000000..acdc51fbb
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/shareblue_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xhdpi/tip4.png b/TMessagesProj/src/main/res/drawable-xhdpi/tip4.png
new file mode 100644
index 000000000..e27f791d8
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xhdpi/tip4.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/bot_list.png b/TMessagesProj/src/main/res/drawable-xxhdpi/bot_list.png
new file mode 100755
index 000000000..a42a691ba
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/bot_list.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/check_list.png b/TMessagesProj/src/main/res/drawable-xxhdpi/check_list.png
new file mode 100644
index 000000000..fd5a56b44
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/check_list.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/check_profile.png b/TMessagesProj/src/main/res/drawable-xxhdpi/check_profile.png
new file mode 100644
index 000000000..30bfdb482
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/check_profile.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_badge2.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_badge2.9.png
new file mode 100755
index 000000000..05816fe12
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/dialogs_badge2.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/editheader.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/editheader.9.png
deleted file mode 100644
index a58727f98..000000000
Binary files a/TMessagesProj/src/main/res/drawable-xxhdpi/editheader.9.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_fp_40px.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_fp_40px.png
new file mode 100644
index 000000000..f7e87240e
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_fp_40px.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/ic_settings.png b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_settings.png
new file mode 100644
index 000000000..c95355277
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/ic_settings.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/list_circle.png b/TMessagesProj/src/main/res/drawable-xxhdpi/list_circle.png
new file mode 100755
index 000000000..5a16cbaff
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/list_circle.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/logo_avatar.png b/TMessagesProj/src/main/res/drawable-xxhdpi/logo_avatar.png
new file mode 100644
index 000000000..df02f04f7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/logo_avatar.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_pause.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_pause.png
deleted file mode 100644
index 7bb5c4539..000000000
Binary files a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_pause.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_play.png b/TMessagesProj/src/main/res/drawable-xxhdpi/menu_play.png
deleted file mode 100644
index 3279b876b..000000000
Binary files a/TMessagesProj/src/main/res/drawable-xxhdpi/menu_play.png and /dev/null differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/mic_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/mic_pressed.png
old mode 100755
new mode 100644
index c972af2bd..e7ca00427
Binary files a/TMessagesProj/src/main/res/drawable-xxhdpi/mic_pressed.png and b/TMessagesProj/src/main/res/drawable-xxhdpi/mic_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_close.png b/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_close.png
new file mode 100755
index 000000000..909458acf
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_close.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_pause.png b/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_pause.png
new file mode 100755
index 000000000..1fb43f08b
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_pause.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_play.png b/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_play.png
new file mode 100755
index 000000000..ee163892d
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/miniplayer_play.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/search_share.png b/TMessagesProj/src/main/res/drawable-xxhdpi/search_share.png
new file mode 100755
index 000000000..60007340a
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/search_share.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/shareblack.png b/TMessagesProj/src/main/res/drawable-xxhdpi/shareblack.png
new file mode 100644
index 000000000..2331b1ff1
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/shareblack.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/shareblack_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/shareblack_pressed.png
new file mode 100644
index 000000000..960261dd7
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/shareblack_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/shareblue.png b/TMessagesProj/src/main/res/drawable-xxhdpi/shareblue.png
new file mode 100644
index 000000000..217a889ec
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/shareblue.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/shareblue_pressed.png b/TMessagesProj/src/main/res/drawable-xxhdpi/shareblue_pressed.png
new file mode 100644
index 000000000..8bba0c980
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/shareblue_pressed.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/sheet_shadow.9.png b/TMessagesProj/src/main/res/drawable-xxhdpi/sheet_shadow.9.png
index 13c556455..1e8e69099 100644
Binary files a/TMessagesProj/src/main/res/drawable-xxhdpi/sheet_shadow.9.png and b/TMessagesProj/src/main/res/drawable-xxhdpi/sheet_shadow.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxhdpi/tip4.png b/TMessagesProj/src/main/res/drawable-xxhdpi/tip4.png
new file mode 100644
index 000000000..b78bf58de
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxhdpi/tip4.png differ
diff --git a/TMessagesProj/src/main/res/drawable-xxxhdpi/sheet_shadow.9.png b/TMessagesProj/src/main/res/drawable-xxxhdpi/sheet_shadow.9.png
new file mode 100644
index 000000000..1520a1fc0
Binary files /dev/null and b/TMessagesProj/src/main/res/drawable-xxxhdpi/sheet_shadow.9.png differ
diff --git a/TMessagesProj/src/main/res/drawable/bar_selector_lock.xml b/TMessagesProj/src/main/res/drawable/bar_selector_lock.xml
index ad45bba68..ea81ccde7 100644
--- a/TMessagesProj/src/main/res/drawable/bar_selector_lock.xml
+++ b/TMessagesProj/src/main/res/drawable/bar_selector_lock.xml
@@ -1,5 +1,5 @@
 <!--
-  ~ This is the source code of Telegram for Android v. 2.x
+  ~ This is the source code of Telegram for Android v. 3.x.x
   ~ It is licensed under GNU GPL v. 2 or later.
   ~ You should have received a copy of the license in this archive (see LICENSE).
   ~
diff --git a/TMessagesProj/src/main/res/drawable/bar_selector_picker.xml b/TMessagesProj/src/main/res/drawable/bar_selector_picker.xml
index 3a705f195..ed653c21c 100644
--- a/TMessagesProj/src/main/res/drawable/bar_selector_picker.xml
+++ b/TMessagesProj/src/main/res/drawable/bar_selector_picker.xml
@@ -1,9 +1,9 @@
 <!--
-  ~ This is the source code of Telegram for Android v. 1.4.x.
+  ~ This is the source code of Telegram for Android v. 3.x.x.
   ~ It is licensed under GNU GPL v. 2 or later.
   ~ You should have received a copy of the license in this archive (see LICENSE).
   ~
-  ~ Copyright Nikolai Kudashov, 2013-2014.
+  ~ Copyright Nikolai Kudashov, 2013-2015.
   -->
 
 <selector
diff --git a/TMessagesProj/src/main/res/drawable/bar_selector_white.xml b/TMessagesProj/src/main/res/drawable/bar_selector_white.xml
index 313bf1833..6bd910aa9 100644
--- a/TMessagesProj/src/main/res/drawable/bar_selector_white.xml
+++ b/TMessagesProj/src/main/res/drawable/bar_selector_white.xml
@@ -1,9 +1,9 @@
 <!--
-  ~ This is the source code of Telegram for Android v. 1.4.x.
+  ~ This is the source code of Telegram for Android v. 3.x.x.
   ~ It is licensed under GNU GPL v. 2 or later.
   ~ You should have received a copy of the license in this archive (see LICENSE).
   ~
-  ~ Copyright Nikolai Kudashov, 2013-2014.
+  ~ Copyright Nikolai Kudashov, 2013-2015.
   -->
 
 <selector
diff --git a/TMessagesProj/src/main/res/drawable/bot_keyboard_states.xml b/TMessagesProj/src/main/res/drawable/bot_keyboard_states.xml
index 15083a9e1..c156f3bd4 100644
--- a/TMessagesProj/src/main/res/drawable/bot_keyboard_states.xml
+++ b/TMessagesProj/src/main/res/drawable/bot_keyboard_states.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
 <!--
-  ~ This is the source code of Telegram for Android v. 2.x.x.
+  ~ This is the source code of Telegram for Android v. 3.x.x.
   ~ It is licensed under GNU GPL v. 2 or later.
   ~ You should have received a copy of the license in this archive (see LICENSE).
   ~
diff --git a/TMessagesProj/src/main/res/drawable/check_profile_fixed.xml b/TMessagesProj/src/main/res/drawable/check_profile_fixed.xml
new file mode 100644
index 000000000..591ea9d5d
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/check_profile_fixed.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<layer-list
+    xmlns:android="http://schemas.android.com/apk/res/android" >
+    <item
+        android:drawable="@drawable/check_profile"
+        android:top="3dp" />
+</layer-list>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/drawable/floating_user_states.xml b/TMessagesProj/src/main/res/drawable/floating_user_states.xml
index ee18cbee6..5b66dd520 100644
--- a/TMessagesProj/src/main/res/drawable/floating_user_states.xml
+++ b/TMessagesProj/src/main/res/drawable/floating_user_states.xml
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
 <!--
-  ~ This is the source code of Telegram for Android v. 1.7.x.
+  ~ This is the source code of Telegram for Android v. 3.x.x.
   ~ It is licensed under GNU GPL v. 2 or later.
   ~ You should have received a copy of the license in this archive (see LICENSE).
   ~
-  ~ Copyright Nikolai Kudashov, 2013-2014.
+  ~ Copyright Nikolai Kudashov, 2013-2015.
   -->
 
 <selector xmlns:android="http://schemas.android.com/apk/res/android">
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_backspace.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_backspace.xml
index 41ea5b772..51a217e25 100644
--- a/TMessagesProj/src/main/res/drawable/ic_emoji_backspace.xml
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_backspace.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <selector xmlns:android="http://schemas.android.com/apk/res/android"
-	android:enterFadeDuration="200"
-	android:exitFadeDuration="300">
+	android:enterFadeDuration="1"
+	android:exitFadeDuration="200">
 	<item android:state_pressed="true">
 		<shape android:shape="rectangle">
 			<solid android:color="#ffd1d6d9" />
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_bell.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_bell.xml
index 17b59fd60..224474574 100644
--- a/TMessagesProj/src/main/res/drawable/ic_emoji_bell.xml
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_bell.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <selector
 	xmlns:android="http://schemas.android.com/apk/res/android"
-	android:enterFadeDuration="200"
-	android:exitFadeDuration="300">
+	android:enterFadeDuration="1"
+	android:exitFadeDuration="200">
 	<item
 		android:state_selected="true"
 		android:drawable="@drawable/ic_smiles_bell_active">
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_car.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_car.xml
index 30c4baa25..464dc4346 100644
--- a/TMessagesProj/src/main/res/drawable/ic_emoji_car.xml
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_car.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <selector
 	xmlns:android="http://schemas.android.com/apk/res/android"
-	android:enterFadeDuration="200"
-	android:exitFadeDuration="300"
+	android:enterFadeDuration="1"
+	android:exitFadeDuration="200"
 	>
 	<item
 		android:state_selected="true"
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_flower.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_flower.xml
index 86e934246..7222c9ee6 100644
--- a/TMessagesProj/src/main/res/drawable/ic_emoji_flower.xml
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_flower.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <selector
 	xmlns:android="http://schemas.android.com/apk/res/android"
-	android:enterFadeDuration="200"
-	android:exitFadeDuration="300"
+	android:enterFadeDuration="1"
+	android:exitFadeDuration="200"
 	>
 	<item
 		android:state_selected="true"
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_recent.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_recent.xml
index aa39b4f50..f0a123612 100644
--- a/TMessagesProj/src/main/res/drawable/ic_emoji_recent.xml
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_recent.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <selector
 	xmlns:android="http://schemas.android.com/apk/res/android"
-	android:enterFadeDuration="200"
-	android:exitFadeDuration="300"
+	android:enterFadeDuration="1"
+	android:exitFadeDuration="200"
 	>
 	<item
 		android:state_selected="true"
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_smile.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_smile.xml
index 97d0c7a55..13478f37c 100644
--- a/TMessagesProj/src/main/res/drawable/ic_emoji_smile.xml
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_smile.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <selector
 	xmlns:android="http://schemas.android.com/apk/res/android"
-	android:enterFadeDuration="200"
-	android:exitFadeDuration="300"
+	android:enterFadeDuration="1"
+	android:exitFadeDuration="200"
 	>
 	<item
 		android:state_selected="true"
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_sticker.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_sticker.xml
index 2cb1ecbef..2145747a1 100644
--- a/TMessagesProj/src/main/res/drawable/ic_emoji_sticker.xml
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_sticker.xml
@@ -2,8 +2,8 @@
 
 <selector
 	xmlns:android="http://schemas.android.com/apk/res/android"
-	android:enterFadeDuration="200"
-	android:exitFadeDuration="300">
+	android:enterFadeDuration="1"
+	android:exitFadeDuration="200">
 	<item android:state_selected="true" android:drawable="@drawable/ic_smiles_sticker_active"/>
 	<item android:drawable="@drawable/ic_smiles_sticker"/>
 </selector>
diff --git a/TMessagesProj/src/main/res/drawable/ic_emoji_symbol.xml b/TMessagesProj/src/main/res/drawable/ic_emoji_symbol.xml
index 63a97e2f1..e3b405a7b 100644
--- a/TMessagesProj/src/main/res/drawable/ic_emoji_symbol.xml
+++ b/TMessagesProj/src/main/res/drawable/ic_emoji_symbol.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <selector
 	xmlns:android="http://schemas.android.com/apk/res/android"
-	android:enterFadeDuration="200"
-	android:exitFadeDuration="300">
+	android:enterFadeDuration="1"
+	android:exitFadeDuration="200">
 	<item android:state_selected="true" android:drawable="@drawable/ic_smiles_grid_active"/>
 	<item android:drawable="@drawable/ic_smiles_grid"/>
 </selector>
diff --git a/TMessagesProj/src/main/res/drawable/ic_fingerprint_error.xml b/TMessagesProj/src/main/res/drawable/ic_fingerprint_error.xml
new file mode 100644
index 000000000..be46116da
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/ic_fingerprint_error.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2015 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:width="40.0dp"
+        android:height="40.0dp"
+        android:viewportWidth="40.0"
+        android:viewportHeight="40.0">
+    <path
+        android:pathData="M20.0,0.0C8.96,0.0 0.0,8.95 0.0,20.0s8.96,20.0 20.0,20.0c11.04,0.0 20.0,-8.95 20.0,-20.0S31.04,0.0 20.0,0.0z"
+        android:fillColor="#F4511E"/>
+    <path
+        android:pathData="M21.33,29.33l-2.67,0.0l0.0,-2.67l2.67,0.0L21.33,29.33zM21.33,22.67l-2.67,0.0l0.0,-12.0l2.67,0.0L21.33,22.67z"
+        android:fillColor="#FFFFFF"/>
+</vector>
diff --git a/TMessagesProj/src/main/res/drawable/list_selector_white.xml b/TMessagesProj/src/main/res/drawable/list_selector_white.xml
new file mode 100644
index 000000000..160ae131a
--- /dev/null
+++ b/TMessagesProj/src/main/res/drawable/list_selector_white.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true">
+        <shape android:shape="rectangle">
+            <solid android:color="#fff0f0f0" />
+        </shape>
+    </item>
+    <item android:state_focused="true">
+        <shape android:shape="rectangle">
+            <solid android:color="#fff0f0f0" />
+        </shape>
+    </item>
+    <item android:state_selected="true">
+        <shape android:shape="rectangle">
+            <solid android:color="#fff0f0f0" />
+        </shape>
+    </item>
+    <item android:drawable="@android:color/white" />
+</selector>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/drawable/mic_button_states.xml b/TMessagesProj/src/main/res/drawable/mic_button_states.xml
deleted file mode 100644
index 791017eda..000000000
--- a/TMessagesProj/src/main/res/drawable/mic_button_states.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<selector xmlns:android="http://schemas.android.com/apk/res/android">
-    <item android:drawable="@drawable/mic_pressed" android:state_pressed="true" />
-    <item android:drawable="@drawable/mic" />
-</selector>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-ar/strings.xml b/TMessagesProj/src/main/res/values-ar/strings.xml
index 0bff16ff1..a6d96cc94 100644
--- a/TMessagesProj/src/main/res/values-ar/strings.xml
+++ b/TMessagesProj/src/main/res/values-ar/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">تيليجرام</string>
+    <string name="AppNameBeta">نسخة تيليجرام التجريبية</string>
     <string name="LanguageName">العربية</string>
     <string name="LanguageNameInEnglish">Arabic</string>
     <string name="LanguageCode">ar</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s قام بالدخول للمحادثة السرية.</string>
     <string name="EncryptedChatStartedIncoming">لقد قمت بالدخول للمحادثة السرية.</string>
     <string name="ClearHistory">مسح سجل المحادثات</string>
+    <string name="ClearHistoryCache">حذف من الذاكرة المخبئية</string>
     <string name="DeleteChat">حذف وخروج</string>
     <string name="DeleteChatUser">حذف المحادثة</string>
     <string name="HiddenName">حساب محذوف</string>
@@ -60,7 +62,28 @@
     <string name="MuteDisable">تعطيل</string>
     <string name="Hashtags">الأوسمة</string>
     <string name="Recent">حديث</string>
+    <string name="LinkPreview">معاينة الرابط</string>
     <!--channels-->
+    <string name="SetAsAdmin">ترقية ليكون مشرف</string>
+    <string name="DescriptionInfoMega">يمكنك كتابة وصف اختياري لمجموعتك.</string>
+    <string name="LeaveMega">مغادرة المجموعة</string>
+    <string name="DeleteMega">حذف المجموعة</string>
+    <string name="LeaveMegaMenu">مغادرة المجموعة</string>
+    <string name="DeleteMegaMenu">حذف المجموعة</string>
+    <string name="MegaDeleteInfo">ستخسر كافة الرسائل في هذه المجموعة.</string>
+    <string name="MegaAdminsInfo">يمكنك إضافة إداريّين لمساعدتك في إدارة المجموعة. اضغط باستمرار لحذف الإداريين.</string>
+    <string name="MegaDeleteAlert">لحظة! حذف هذه المجموعة سيزيل كافة الأعضاء والرسائل سيتم حذفها. هل أنت متأكد من رغبتك في حذف المجموعة؟</string>
+    <string name="ActionCreateMega">تم إنشاء مجموعة</string>
+    <string name="MegaAddedBy">un1 قام بإضافتك لهذه المجموعة</string>
+    <string name="MegaLeaveAlert">هل أنت متأكد من أنك تريد الخروج من المجموعة؟</string>
+    <string name="GroupUserCantAdd">المعذرة، لا يمكنك إضافة هذا المستخدم للمجموعات.</string>
+    <string name="GroupUserAddLimit">المعذرة، المجموعة ممتلئة.</string>
+    <string name="GroupUserLeftError">المعذرة, هذا المستخدم قرر مغادرة المجموعة, لا يمكنك دعوته مرة أخرى للمجموعة.</string>
+    <string name="GroupUserCantAdmin">المعذرة، يوجد الكثير من المشرفين في هذه المجموعة.</string>
+    <string name="GroupUserCantBot">المعذرة، يوجد الكثير من حسابات البوت في هذه المجموعة.</string>
+    <string name="ActionMigrateFromGroup">تم ترقية هذه المجموعة لتصبح مجموعة خارقة</string>
+    <string name="ActionMigrateFromGroupNotify">تم ترقية المجموعة %1$s لتصبح مجموعة خارقة</string>
+    <string name="NoBlockedGroup">أعضاء القائمة السوداء هم أعضاء تم حذفهم من المجموعة ولا يمكنهم العودة لها إلى بدعوة من المشرف. روابط الدعوة لن تمكنهم من العودة للمجموعة.</string>
     <string name="NewChannel">قناة جديدة</string>
     <string name="EnterChannelName">اسم القناة</string>
     <string name="Comments">التعليقات</string>
@@ -81,7 +104,7 @@
     <string name="LeaveChannel">غادر القناة</string>
     <string name="LeaveChannelMenu">غادر القناة</string>
     <string name="ChannelSettings">الإعدادات</string>
-    <string name="ChannelJoin">دخول</string>
+    <string name="ChannelJoin">اشترك</string>
     <string name="OpenChannelProfile">معلومات القناة</string>
     <string name="ChannelBroadcast">رسالة جماعية</string>
     <string name="ChannelComment">تعليق</string>
@@ -111,7 +134,6 @@
     <string name="ActionChannelChangedPhoto">تم تغيير صورة القناة</string>
     <string name="ActionChannelRemovedPhoto">تم حذف صورة القناة</string>
     <string name="ActionChannelChangedTitle">تم تغيير اسم القناة إلى un2</string>
-    <string name="ActionChannelInvite">un1 قام بإضافتك لقناة un2</string>
     <string name="ChannelPublicLimitReached">المعذرة، قمت بإنشاء قنوات عامة كثيرة. يمكنك إنشاء قناة خاصة أو حذف أحد القنوات العامة أولًا.</string>
     <string name="ChannelModerator">المراقب</string>
     <string name="ChannelCreator">المنشئ</string>
@@ -127,11 +149,12 @@
     <string name="ChannelLinkInfo">أي شخص يمتلك تيليجرام على جهازه سيمكنه الدخول لقناتك باستخدام هذا الرابط.</string>
     <string name="ChannelAdminsInfo">يمكنك إضافة إداريّون لمساعدتك في إدارة القناة. اضغط باستمرار لحذف الإداريين.</string>
     <string name="ChannelJoinTo">هل ترغب في الدخول لقناة \'%1$s\'؟</string>
-    <string name="ChannelCantOpenPrivate">المعذرة، هذه القناة لم تعد متاحة.</string>
-    <string name="ChannelAddToTitle">هل ترغب بإضافة %1$s لقناة %2$s؟</string>
+    <string name="ChannelCantOpenPrivate">المعذرة، هذه المحادثة لم تعد متاحة.</string>
     <string name="ChannelAddTo">هل ترغب بإضافة %1$s للقناة؟</string>
-    <string name="ChannelUserLeftError">المعذرة, هذا المستخدم قرر مغادرة المجموعة, لا يمكنك دعوته مرة أخرى للمجموعة.</string>
+    <string name="ChannelUserLeftError">المعذرة، هذا المستخدم قرر مغادرة القناة, لا يمكنك دعوته مرة أخرى للقناة.</string>
     <string name="ChannelUserCantAdd">المعذرة، لا يمكنك إضافة هذا المستخدم للقنوات.</string>
+    <string name="ChannelUserCantAdmin">المعذرة، يوجد الكثير من الإداريين في هذه القناة.</string>
+    <string name="ChannelUserCantBot">المعذرة، يوجد الكثير من حسابات البوت في هذه القناة.</string>
     <string name="ChannelUserAddLimit">المعذرة، يمكنك إضافة أول ٢٠٠ عضو للقناة فقط. يمكن لعدد غير محدود من الأعضاء الدخول للقناة عن طريق رابط القناة.</string>
     <string name="ChannelAddedBy">un1 قام بإضافتك لهذه القناة</string>
     <string name="ChannelJoined">لقد قمت بالدخول للقناة.</string>
@@ -147,14 +170,14 @@
     <string name="ChannelMessageGroupDocument">%1$s  قام بإرسال ملف للقناة %2$s</string>
     <string name="ChannelMessageGroupAudio">%1$s  قام بإرسال مقطع صوتي للقناة %2$s</string>
     <string name="ChannelMessageGroupSticker">%1$s  قام بإرسال ملصق للقناة %2$s</string>
-    <string name="ChannelMessageNoText">رسالة جديدة في القناة %1$s</string>
-    <string name="ChannelMessagePhoto">صورة جديدة في القناة %1$s</string>
-    <string name="ChannelMessageVideo">مقطع مرئي جديد في القناة %1$s</string>
-    <string name="ChannelMessageContact">تم مشاركة جهة اتصال في القناة %1$s</string>
-    <string name="ChannelMessageMap">تم مشاركة مكان في القناة %1$s</string>
-    <string name="ChannelMessageDocument">ملف جديد في القناة %1$s</string>
-    <string name="ChannelMessageAudio">ملاحظة صوتية جديدة في القناة %1$s</string>
-    <string name="ChannelMessageSticker">ملصق جديد في القناة %1$s</string>
+    <string name="ChannelMessageNoText">%1$s أرسل رسالة</string>
+    <string name="ChannelMessagePhoto">%1$s أرسل صورة</string>
+    <string name="ChannelMessageVideo">%1$s أرسل مقطع مرئي</string>
+    <string name="ChannelMessageContact">%1$s أرسل جهة اتصال</string>
+    <string name="ChannelMessageMap">%1$s قام بإرسال موقع</string>
+    <string name="ChannelMessageDocument">%1$s أرسل ملف</string>
+    <string name="ChannelMessageAudio">%1$s أرسل رسالة صوتية</string>
+    <string name="ChannelMessageSticker">%1$s أرسل ملصق</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">رسالة جماعية جديدة</string>
     <string name="EnterListName">أدخل اسم القائمة</string>
@@ -239,7 +262,9 @@
     <string name="ReportSpamAlertGroup">هل أنت متأكد من رغبتك في الإبلاغ عن هذه المجموعة كغير مرغوب بها؟</string>
     <string name="NobodyLikesSpam1">المعذرة، يمكنك فقط إرسال رسائل لمن يمتلك رقمك وتمتلك رقمه في الوقت الحالي.</string>
     <string name="NobodyLikesSpam2">المعذرة، يمكنك فقط إضافة من يمتلك رقمك وتمتلك رقمه للمجموعة في الوقت الحالي.</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq/can-39t-send-messages-to-non-contacts</string>
     <string name="MoreInfo">ملعومات إضافية</string>
+    <string name="ShareSendTo">أرسل إلى...</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s قام بتعيين عداد التدمير الذاتي إلى to %2$s</string>
     <string name="MessageLifetimeChangedOutgoing">لقد قمت بتعيين التدمير الذاتي إلى %1$s</string>
@@ -289,6 +314,7 @@
     <string name="Online">متصل</string>
     <string name="LastSeen">آخر ظهور</string>
     <string name="LastSeenDate">آخر ظهور</string>
+    <string name="LastSeenNow">آخر ظهور قبل قليل</string>
     <string name="InviteFriends">قم بدعوة صديق</string>
     <string name="GlobalSearch">بحث شامل</string>
     <string name="Lately">آخر ظهور كان قريب</string>
@@ -314,13 +340,22 @@
     <string name="CopyLink">نسخ الرابط</string>
     <string name="ShareLink">شارك الرابط</string>
     <string name="LinkInfo">أي شخص يمتلك تيليجرام على جهازه سيسطيع الدخول لمجموعتك باستخدام الرابط التالي.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">مشرفو المحادثة</string>
+    <string name="SetAdminsAll">جميع الأعضاء مشرفين</string>
+    <string name="SetAdminsAllInfo">جميع أعضاء القناة يستطيعون إضافة وحذف الأعضاء، والتعديل على اسم وصورة المجموعة.</string>
+    <string name="SetAdminsNotAllInfo">فقط مشرفو القناة يستطيعون حذف الأعضاء، والتعديل على اسم وصورة المجموعة.</string>
     <!--group info view-->
     <string name="SharedMedia">عدد الوسائط المشتركة</string>
     <string name="SETTINGS">الإعدادات</string>
     <string name="AddMember">إضافة مشارك</string>
+    <string name="SetAdmins">تعيين كمشرف</string>
     <string name="DeleteAndExit">مغادرة المجموعة وحذفها</string>
     <string name="Notifications">الإشعارات</string>
     <string name="KickFromGroup">إخراج من المجموعة</string>
+    <string name="ConvertGroup">قم بالتحديث لمجموعة خارقة</string>
+    <string name="ConvertGroupAlert">فضلًا تذكر أن أعضاء هذه المجموعة يلزمهم تحديث تطبيقات تيليجرام لأحدث النسخ ليتمكنوا من الإستفادة من المجموعات الخارقة. هل أنت متأكد من رغبتك في ترقية المجموعة؟</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>تم الوصول للحد الأعلى للأعضاء<![CDATA[</b>]]>\n\nيمكنك ترقية مجموعتك لتصبح مجموعة خارقة لتتمكن من إضافة أعضاء أكثر من الحد الأعلى وخصائص مثل:\n\n• الحد الأعلى للأعضاء يصبح %1$s عضو\n• الأعضاء الجدد يرون تاريخ محادثات المجموعة بشكل كامل\n• المشرفون يمكنهم حذف رسائل كافة الأعضاء\n• الإشعارات على وضع الصامت بشكل تلقائي</string>
     <!--contact info view-->
     <string name="ShareContact">مشاركة</string>
     <string name="AddContact">إضافة</string>
@@ -403,7 +438,6 @@
     <string name="TerminateAllSessions">سجل الخروج من كافة الأجهزة الأخرى</string>
     <string name="Events">الأحداث</string>
     <string name="ContactJoined">اشترك صديق في تيليجرام</string>
-    <string name="Pebble">PEBBLE</string>
     <string name="Language">اللغة</string>
     <string name="AskAQuestionInfo">نرجو الأخذ بالعلم أن الدعم الفني في تيليجرام يقوم به مجموعة من المتطوعين. نحن نحاول الرد بسرعة قدر المستطاع، لكن ربما نستغرق القليل من الوقت.<![CDATA[<br><br>]]> <![CDATA[<a href=\"https://telegram.org/faq/ar\">صفحة الأسئلة الأكثر شيوعًا</a>]]>: يوجد بها حلول للمشاكل وإجابات لمعظم الأسئلة.</string>
     <string name="AskButton">اسأل أحد المتطوعين</string>
@@ -465,6 +499,24 @@
     <string name="SmartNotificationsTimes">الأوقات</string>
     <string name="SmartNotificationsWithin">خلال</string>
     <string name="SmartNotificationsMinutes">دقائق</string>
+    <!--cache view-->
+    <string name="CacheSettings">إعدادات الذاكرة المخبئية</string>
+    <string name="LocalDatabase">قاعدة البيانات على الجهاز</string>
+    <string name="LocalDatabaseClear">هل ترغب في مسح الرسائل المحفوظة في الذاكرة المخبئية؟</string>
+    <string name="LocalDatabaseInfo">مسح قاعدة البيانات على الجهاز سيحذف الرسائل التي تم تنزيلها على جهازك ويقوم بضغط قاعدة البيانات لتوفير مساحة على جهازك. تيليجرام يحتاج لبعض البيانات ليعمل، لذلك حجم قاعدة البيانات لن يصل إلى صفر.\n\nهذه العملية ربما تأخذ عدة دقائق لتتم.</string>
+    <string name="ClearMediaCache">مسح الذاكرة المخبئية</string>
+    <string name="CacheClear">مسح</string>
+    <string name="CalculatingSize">جاري الحساب...</string>
+    <string name="LocalDocumentCache">المستندات</string>
+    <string name="LocalPhotoCache">الصور</string>
+    <string name="LocalAudioCache">الرسائل الصوتية</string>
+    <string name="LocalVideoCache">المقاطع المرئية</string>
+    <string name="LocalMusicCache">الموسيقى</string>
+    <string name="LocalCache">الملفات الأخرى</string>
+    <string name="CacheEmpty">إفراغ</string>
+    <string name="KeepMedia">الإحتفاظ بالوسائط</string>
+    <string name="KeepMediaInfo">الصور، المقاطع المرئية، وجميع الملفات المحفوظة في خوادمنا التي لم <![CDATA[<b> تستخدمها </b>]]> خلال هذه المدة سيتم حذفها لتوفير المساحة. ملفات الوسائط ستبقى في خوادم تيليجرام ويمكنك إعادة تنزيلها متى ما احتجتها مرة أخرى.</string>
+    <string name="KeepMediaForever">إلى الأبد</string>
     <!--sessions view-->
     <string name="SessionsTitle">الأجهزة المسجّل دخول منها</string>
     <string name="CurrentSession">الجهاز الحالي</string>
@@ -493,11 +545,17 @@
     <string name="AutoLockInfo">اطلب رمز المرور إذا غبت فترة محددة من الزمن.</string>
     <string name="AutoLockInTime">خلال %1$s</string>
     <string name="AutoLockDisabled">معطّل</string>
+    <string name="UnlockFingerprint">قم بالفتح بالبصمة</string>
+    <string name="FingerprintInfo">قم بتأكيد البصمة للإستمرار</string>
+    <string name="FingerprintHelp">حساس اللمس</string>
+    <string name="FingerprintNotRecognized">لم يتم التعرف على البصمة. حاول مرة أخرى</string>
     <!--media view-->
     <string name="NoMedia">شارك المقاطع المرئية والصور في هذه المحادثة لتستطيع الوصول إليها من أية جهاز من أجهزتك</string>
     <string name="DocumentsTitle">الملفات المشاركة</string>
     <string name="SharedMediaTitle">الوسائط المشتركة</string>
     <string name="LinksTitle">الروابط المشاركة</string>
+    <string name="AudioTitle">الموسيقى المشتركة</string>
+    <string name="NoSharedAudio">قم بإرسال مقاطع موسيقية لهذه المحادثة ليمكنك الوصول إليها من أجهزتك الأخرى.</string>
     <string name="NoSharedFiles">شارك الملفات والمستندات في هذه المحادثة لتستطيع الوصول إليها من أية جهاز من أجهزتك</string>
     <string name="NoSharedLinks">شارك الروابط في هذه المحادثة لتستطيع الوصول إليها من أية جهاز من أجهزتك</string>
     <!--map view-->
@@ -668,6 +726,7 @@
     <string name="Call">اتصال</string>
     <string name="Copy">نسخ</string>
     <string name="Delete">حذف</string>
+    <string name="DeleteAndStop">حذف وإيقاف</string>
     <string name="Forward">إعادة توجيه</string>
     <string name="Retry">إعادة المحاولة</string>
     <string name="FromCamera">من الكاميرا</string>
@@ -722,12 +781,13 @@
     <string name="NoHandleAppInstalled">لا يوجد لديك تطبيق يمكنه فتح \'%1$s\'، يرجى تنزيل تطبيق مناسب للإستمرار</string>
     <string name="InviteUser">هذا المستخدم ليس لديه تيليجرام بعد ، هل ترغب في دعوته الآن؟</string>
     <string name="AreYouSure">هل أنت متأكد؟</string>
-    <string name="AddToTheGroupTitle">هل ترغب في إضافة %1$s للمجموعة %2$s؟</string>
+    <string name="AddToTheGroupTitle">هل ترغب بإضافة %1$s للمحادثة %2$s؟</string>
     <string name="AddToTheGroupForwardCount">عدد الرسائل الحديثة المراد إعادة تحويلها:</string>
     <string name="AddToTheGroup">إضافة %1$s للمجموعة؟</string>
     <string name="UserAlreadyInGroup">هذا المستخدم عضو مسبق في هذه المجموعة</string>
     <string name="ForwardMessagesTo">؟%1$s هل تريد إعادة توجيه الرسائل إلى</string>
     <string name="SendMessagesTo">هل ترغب في إرسال رسالة إلى %1$s؟</string>
+    <string name="SendContactTo">أرسل جهة الاتصال إلى %1$s؟</string>
     <string name="AreYouSureLogout">نرجو الأخذ بالعلم أنه يمكنك استخدام تيليجرام على أجهزتك المتعددة بسهولة تامة وفي وقت واحد.\n\nوتذكر، تسجيل الخروج يحذف كافة محادثاتك السرية.</string>
     <string name="AreYouSureSessions">هل أنت متأكد من تسجيل الخروج من جميع الأجهزة الأخرى باستثناء هذا الجهاز؟</string>
     <string name="AreYouSureDeleteAndExit">هل أنت متأكد من أنك تريد حذف المجموعة والخروج منها؟</string>
@@ -739,12 +799,21 @@
     <string name="AreYouSureSecretChat">هل أنت متأكد من أنك تريد بدء محادثة سرية؟</string>
     <string name="AreYouSureRegistration">هل أنت متأكد من رغبتك في إلغاء التسجيل؟</string>
     <string name="AreYouSureClearHistory">هل أنت متأكد من رغبتك في حذف سجل المحادثات؟</string>
+    <string name="AreYouSureClearHistoryChannel">حذف كافة المحادثات والوسائط المتعلقة بهذه القناة من الذاكرة المخبئية؟</string>
+    <string name="AreYouSureClearHistorySuper">حذف كافة المحادثات والوسائط المتعلقة بهذه المجموعة الخارقة من الذاكرة المخبئية؟</string>
     <string name="AreYouSureDeleteMessages">هل أنت متأكد من رغبتك في حذف %1$s؟</string>
     <string name="SendMessagesToGroup">هل ترغب في إرسال رسالة إلى %1$s؟</string>
+    <string name="SendContactToGroup">أرسل جهة الاتصال إلى %1$s؟</string>
     <string name="ForwardMessagesToGroup">؟%1$s هل تريد إعادة توجيه الرسائل إلى</string>
     <string name="FeatureUnavailable">.Sorry, this feature is currently not available in your country</string>
     <string name="NoUsernameFound">لا يوجد حساب تيليجرام بهذا الاسم.</string>
     <string name="BotCantJoinGroups">هذا البوت لا يستطيع الدخول للمجموعات.</string>
+    <!--permissions-->
+    <string name="PermissionContacts">تيليجرام يحتاج للسماح له بالوصول لجهات الاتصال الخاصة بك لتتمكن من محادثة أصدقائك من كافة أجهزتك.</string>
+    <string name="PermissionStorage">تيليجرام يحتاج للسماح له بالوصول للذاكرة الخاصة بك لتتمكن من إرسال وحفظ الصور، المقاطع المرئية، الموسيقى وغيرها من الوسائط.</string>
+    <string name="PermissionNoAudio">تيليجرام يحتاج للسماح له بالوصول للمايكروفون الخاص بك لتتمكن من إرسال رسائل صوتية.</string>
+    <string name="PermissionNoLocation">تيليجرام يحتاج للسماح له بالوصول لمكانك لتتمكن من مشاركته مع أصدقائك من خلاله.</string>
+    <string name="PermissionOpenSettings">الإعدادات</string>
     <!--Intro view-->
     <string name="Page1Title">تيليجرام</string>
     <string name="Page2Title">سريع</string>
@@ -882,6 +951,18 @@
     <string name="Photos_few">%1$d صور</string>
     <string name="Photos_many">%1$d صور</string>
     <string name="Photos_other">%1$d صور</string>
+    <string name="LastSeenMinutes_zero">آخر ظهور قبل %1$d دقيقة</string>
+    <string name="LastSeenMinutes_one">آخر ظهور قبل %1$d دقيقة</string>
+    <string name="LastSeenMinutes_two">آخر ظهور قبل %1$d دقيقة</string>
+    <string name="LastSeenMinutes_few">آخر ظهور قبل %1$d دقيقة</string>
+    <string name="LastSeenMinutes_many">آخر ظهور قبل %1$d دقيقة</string>
+    <string name="LastSeenMinutes_other">آخر ظهور قبل %1$d دقيقة</string>
+    <string name="LastSeenHours_zero">آخر ظهور قبل %1$d ساعة</string>
+    <string name="LastSeenHours_one">آخر ظهور قبل %1$d ساعة</string>
+    <string name="LastSeenHours_two">آخر ظهور قبل %1$d ساعة</string>
+    <string name="LastSeenHours_few">آخر ظهور قبل %1$d ساعة</string>
+    <string name="LastSeenHours_many">آخر ظهور قبل %1$d ساعة</string>
+    <string name="LastSeenHours_other">آخر ظهور قبل %1$d ساعة</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d رسالة معاد توجيهها</string>
     <string name="ForwardedMessage_one">الرسالة المعاد توجيهها</string>
@@ -949,6 +1030,7 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s الساعة %2$s</string>
     <!--update text-->
-    <string name="updateText">تم تحديث تيليجرام نسخة الآندرويد. الجديد في نسخة 3.2.0:\n\n- إضافة خدمة القنوات - وسيلة جديدة رائعة لإرسال الرسائل الجماعية لعدد لا محدود من الجماهير (تستبدل الرسائل الجماعية القديمة). \n\n- اللاستزادة، اقرأ هنا: https://telegram.org/blog/channels</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">تيليجرام نسخة الأندرويد تم تحديثه. الجديد في نسخة ٣.٢.٢:\n\n- إدارة للذاكرة المخبئية: إمكانية التحكم بالذاكرة المخبئية، حذف محتوى لمحادثة معينة.\n- حذف الذاكرة المخبئية من المجموعات الخارقة والقنوات: الضغط والتعليق عليها ثم تحذفها من الذاكرة.n\- إدارة الملصقات: إعادة ترتيب ملصقاتك بشكل يدوي. ويتزامن الترتيب مع باقي أجهزتك.n\n\للإستزادة عن هذا التحديث من هنا:n\
+        https://telegram.org/blog/cache-and-stickers</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-de/strings.xml b/TMessagesProj/src/main/res/values-de/strings.xml
index ba2f265df..26814bcfe 100644
--- a/TMessagesProj/src/main/res/values-de/strings.xml
+++ b/TMessagesProj/src/main/res/values-de/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">Telegram</string>
+    <string name="AppNameBeta">Telegram Beta</string>
     <string name="LanguageName">Deutsch</string>
     <string name="LanguageNameInEnglish">German</string>
     <string name="LanguageCode">de</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s ist deinem geheimen Chat beigetreten.</string>
     <string name="EncryptedChatStartedIncoming">Du bist dem geheimen Chat beigetreten.</string>
     <string name="ClearHistory">Verlauf löschen</string>
+    <string name="ClearHistoryCache">Cache leeren</string>
     <string name="DeleteChat">Löschen und beenden</string>
     <string name="DeleteChatUser">Chat löschen</string>
     <string name="HiddenName">Gelöschtes Konto</string>
@@ -60,7 +62,28 @@
     <string name="MuteDisable">Dauerhaft Stumm</string>
     <string name="Hashtags">HASHTAGS</string>
     <string name="Recent">LETZTE</string>
+    <string name="LinkPreview">Linkvorschau</string>
     <!--channels-->
+    <string name="SetAsAdmin">Zum Admin machen</string>
+    <string name="DescriptionInfoMega">Beschreibe deine Gruppe (optional).</string>
+    <string name="LeaveMega">Gruppe verlassen</string>
+    <string name="DeleteMega">Gruppe Löschen</string>
+    <string name="LeaveMegaMenu">Gruppe verlassen</string>
+    <string name="DeleteMegaMenu">Gruppe löschen</string>
+    <string name="MegaDeleteInfo">Du verlierst alle Nachrichten der Gruppe.</string>
+    <string name="MegaAdminsInfo">Administratoren helfen dir, deinen Kanal zu verwalten. Tippen und halten um sie zu löschen.</string>
+    <string name="MegaDeleteAlert">Wenn du diese Gruppe löschst, werden alle Mitglieder und alle Nachrichten entfernt. Wirklich löschen?</string>
+    <string name="ActionCreateMega">Gruppe erstellt</string>
+    <string name="MegaAddedBy">un1 hat dich hinzugefügt</string>
+    <string name="MegaLeaveAlert">Möchtest du wirklich diese Gruppe verlassen?</string>
+    <string name="GroupUserCantAdd">Du kannst diesen Nutzer nicht hinzufügen.</string>
+    <string name="GroupUserAddLimit">Leider ist diese Gruppe schon voll.</string>
+    <string name="GroupUserLeftError">Dieser Nutzer hat die Gruppe zu verlassen, deshalb kannst du ihn nicht wieder einladen.</string>
+    <string name="GroupUserCantAdmin">Es gibt bereits zu viele Administratoren.</string>
+    <string name="GroupUserCantBot">Es gibt bereits zu viele Bots.</string>
+    <string name="ActionMigrateFromGroup">Gruppe wurde in eine Supergruppe geändert</string>
+    <string name="ActionMigrateFromGroupNotify">%1$s wurde in eine Supergruppe geändert</string>
+    <string name="NoBlockedGroup">Blockierte Nutzer können nur durch Admins erneut hinzugefügt werden. Einladungslinks funktionieren nicht.</string>
     <string name="NewChannel">Neuer Kanal</string>
     <string name="EnterChannelName">Kanalname</string>
     <string name="Comments">Kommentare</string>
@@ -111,7 +134,6 @@
     <string name="ActionChannelChangedPhoto">Bild geändert</string>
     <string name="ActionChannelRemovedPhoto">Bild gelöscht</string>
     <string name="ActionChannelChangedTitle">Kanalname zu un2 geändert</string>
-    <string name="ActionChannelInvite">un1 hat dich zu Kanal un2 hinzugefügt</string>
     <string name="ChannelPublicLimitReached">Du hast zu viele öffentliche Kanäle erstellt. Du kannst entweder einen privaten Kanal erstellen oder einen bestehenden Kanal löschen.</string>
     <string name="ChannelModerator">Moderator</string>
     <string name="ChannelCreator">Gründer</string>
@@ -127,11 +149,12 @@
     <string name="ChannelLinkInfo">Jeder, der Telegram installiert hat, kann anhand dieses Links in deinen Kanal.</string>
     <string name="ChannelAdminsInfo">Administratoren helfen dir, deinen Kanal zu verwalten. Tippen und halten um sie zu löschen.</string>
     <string name="ChannelJoinTo">Möchtest du dem Kanal \'%1$s\' beitreten?</string>
-    <string name="ChannelCantOpenPrivate">Dieser Kanal ist nicht mehr zugänglich.</string>
-    <string name="ChannelAddToTitle">%1$s zum Kanal %2$s hinzufügen?</string>
+    <string name="ChannelCantOpenPrivate">Dieser Chat ist nicht mehr zugänglich.</string>
     <string name="ChannelAddTo">%1$s zum Kanal hinzufügen?</string>
-    <string name="ChannelUserLeftError">Dieser Nutzer hat sich entschieden die Gruppe zu verlassen, deshalb kannst du ihn nicht wieder einladen.</string>
+    <string name="ChannelUserLeftError">Dieser Nutzer hat die Gruppe zu verlassen, deshalb kannst du ihn nicht wieder einladen.</string>
     <string name="ChannelUserCantAdd">Du kannst diesen Nutzer nicht einladen.</string>
+    <string name="ChannelUserCantAdmin">Es gibt bereits zu viele Administratoren in diesem Kanal.</string>
+    <string name="ChannelUserCantBot">Es gibt bereits zu viele Bots.</string>
     <string name="ChannelUserAddLimit">Du kannst nur die ersten 200 Leute einladen, aber unbegrenzt viele können dem Kanal über den Einladungslink beitreten. </string>
     <string name="ChannelAddedBy">un1 hat dich hinzugefügt</string>
     <string name="ChannelJoined">Du bist dem Kanal beigetreten</string>
@@ -147,14 +170,14 @@
     <string name="ChannelMessageGroupDocument">%1$s hat eine Datei an den Kanal %2$s gesendet</string>
     <string name="ChannelMessageGroupAudio">%1$s hat eine Sprachnachricht an den Kanal %2$s gesendet</string>
     <string name="ChannelMessageGroupSticker">%1$s hat einen Sticker an den Kanal %2$s gesendet</string>
-    <string name="ChannelMessageNoText">Neue Nachricht im Kanal %1$s</string>
-    <string name="ChannelMessagePhoto">Neues Bild im Kanal %1$s</string>
-    <string name="ChannelMessageVideo">Neues Video im Kanal %1$s</string>
-    <string name="ChannelMessageContact">Kontakt im Kanal %1$s geteilt</string>
-    <string name="ChannelMessageMap">Neuer Standort im Kanal %1$s</string>
-    <string name="ChannelMessageDocument">Neue Datei im Kanal %1$s</string>
-    <string name="ChannelMessageAudio">Neue Sprachnachricht im Kanal %1$s</string>
-    <string name="ChannelMessageSticker">Neuer Sticker im Kanal %1$s</string>
+    <string name="ChannelMessageNoText">%1$s hat eine Nachricht gesendet</string>
+    <string name="ChannelMessagePhoto">%1$s hat ein Bild gesendet</string>
+    <string name="ChannelMessageVideo">%1$s hat ein Video gesendet</string>
+    <string name="ChannelMessageContact">%1$s hat einen Kontakt gesendet</string>
+    <string name="ChannelMessageMap">%1$s hat einen Standort gesendet</string>
+    <string name="ChannelMessageDocument">%1$s hat eine Datei gesendet</string>
+    <string name="ChannelMessageAudio">%1$s hat eine Sprachnachricht gesendet</string>
+    <string name="ChannelMessageSticker">%1$s hat einen Sticker gesendet</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">Neue Broadcast Liste</string>
     <string name="EnterListName">Listenname</string>
@@ -239,7 +262,9 @@
     <string name="ReportSpamAlertGroup">Sicher, dass du Spam von dieser Gruppe melden willst?</string>
     <string name="NobodyLikesSpam1">Derzeit kannst du nur Kontakten schreiben, die auch deine Nummer haben.</string>
     <string name="NobodyLikesSpam2">Derzeit kannst du nur Kontakte hinzufügen, die auch deine Nummer haben.</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq/de#kann-keine-nachrichten-an-nicht-kontakte-senden</string>
     <string name="MoreInfo">Mehr Infos</string>
+    <string name="ShareSendTo">Sende an...</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s hat den Selbstzerstörungs-Timer auf %2$s gesetzt</string>
     <string name="MessageLifetimeChangedOutgoing">Du hast den Selbstzerstörungs-Timer auf %1$s gesetzt</string>
@@ -289,6 +314,7 @@
     <string name="Online">online</string>
     <string name="LastSeen">zul. online</string>
     <string name="LastSeenDate">zul. online</string>
+    <string name="LastSeenNow">zul. online gerade eben</string>
     <string name="InviteFriends">Freunde einladen</string>
     <string name="GlobalSearch">GLOBALE SUCHE</string>
     <string name="Lately">zuletzt kürzlich gesehen</string>
@@ -314,13 +340,22 @@
     <string name="CopyLink">Link kopieren</string>
     <string name="ShareLink">Link teilen</string>
     <string name="LinkInfo">Jeder, der Telegram installiert hat, kann anhand dieses Links in deine Gruppe.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">Administratoren</string>
+    <string name="SetAdminsAll">Alle Mitglieder sind Admins</string>
+    <string name="SetAdminsAllInfo">Gruppenmitglieder können neue Leute hinzufügen sowie den Gruppennamen und das Bild ändern.</string>
+    <string name="SetAdminsNotAllInfo">Nur Admins können neue Leute hinzufügen und entfernen, den Gruppennamen und das Bild ändern.</string>
     <!--group info view-->
     <string name="SharedMedia">Geteilte Medien</string>
     <string name="SETTINGS">Einstellungen</string>
     <string name="AddMember">Mitglied hinzufügen</string>
+    <string name="SetAdmins">Administratoren</string>
     <string name="DeleteAndExit">Löschen und Gruppe verlassen</string>
     <string name="Notifications">Mitteilungen</string>
     <string name="KickFromGroup">Aus der Gruppe entfernen</string>
+    <string name="ConvertGroup">In Supergruppe ändern</string>
+    <string name="ConvertGroupAlert">Gruppenmitglieder müssen ihre Telegram-App aktualisieren um diese Supergruppe benutzen zu können. Wirklich diese Gruppe in eine Supergruppe ändern?</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>Gruppenlimit erreicht.<![CDATA[</b>]]>\n\nFür weitere Funktionen und um das Limit aufzuheben in Supergruppe ändern:\n\n• Bis zu %1$s sind nun möglich\n• Neue Mitglieder sehen gesamten Verlauf\n• Mitteilungen sind standardmäßig stumm\n• Admins können alle Nachrichten löschen</string>
     <!--contact info view-->
     <string name="ShareContact">Teilen</string>
     <string name="AddContact">Hinzufügen</string>
@@ -403,7 +438,6 @@
     <string name="TerminateAllSessions">Alle anderen Geräte abmelden</string>
     <string name="Events">Ereignisse</string>
     <string name="ContactJoined">Kontakt ist Telegram beigetreten</string>
-    <string name="Pebble">PEBBLE</string>
     <string name="Language">Sprache</string>
     <string name="AskAQuestionInfo">Bedenke bitte, dass der Telegram Support von ehrenamtlichen Helfern betreut wird. Wir versuchen so schnell wie möglich zu antworten, dies kann jedoch manchmal ein bisschen dauern.<![CDATA[<br><br>]]>Bitte schau auch in den <![CDATA[<a href=\"https://telegram.org/faq/de\">Fragen und Antworten </a>]]> nach. Dort findest du Antworten auf die meisten Fragen und wichtige Tipps zur <![CDATA[<a href=\"https://telegram.org/faq/de#problembehandlung\">Problembehandlung</a>]]>.</string>
     <string name="AskButton">Eine Frage stellen</string>
@@ -465,6 +499,24 @@
     <string name="SmartNotificationsTimes">Mal</string>
     <string name="SmartNotificationsWithin">innerhalb von</string>
     <string name="SmartNotificationsMinutes">Minuten</string>
+    <!--cache view-->
+    <string name="CacheSettings">Cache-Einstellungen</string>
+    <string name="LocalDatabase">Lokale Datenbank</string>
+    <string name="LocalDatabaseClear">Textnachrichten-Cache leeren?</string>
+    <string name="LocalDatabaseInfo">Zwischengespeicherte Textnachrichten werden entfernt und die Datenbank optimiert um Speicherplatz zurückzuerhalten. Auf Null lässt sich die Größe jedoch nicht reduzieren, da die App einige Daten für den laufenden Betrieb benötigt.\n\nHinweis: Der Vorgang kann mehrere Minuten dauern.</string>
+    <string name="ClearMediaCache">Cache Leeren</string>
+    <string name="CacheClear">Leeren</string>
+    <string name="CalculatingSize">Berechne...</string>
+    <string name="LocalDocumentCache">Dateien</string>
+    <string name="LocalPhotoCache">Bilder</string>
+    <string name="LocalAudioCache">Sprachnachrichten</string>
+    <string name="LocalVideoCache">Videos</string>
+    <string name="LocalMusicCache">Musik</string>
+    <string name="LocalCache">Sonstige Dateien</string>
+    <string name="CacheEmpty">Leer</string>
+    <string name="KeepMedia">Medien behalten</string>
+    <string name="KeepMediaInfo">Bilder, Videos und andere Dateien, auf die du während dieser Zeit <![CDATA[<b>nicht zugegriffen</b>]]> hast, werden von diesem Gerät gelöscht, um Speicherplatz zu sparen.\n\nAlle Medien bleiben in der Telegram Cloud gespeichert und können jederzeit wieder heruntergeladen werden.</string>
+    <string name="KeepMediaForever">Dauerhaft</string>
     <!--sessions view-->
     <string name="SessionsTitle">Sitzungen</string>
     <string name="CurrentSession">Aktuelles Gerät</string>
@@ -493,11 +545,17 @@
     <string name="AutoLockInfo">Sperrt App bei Inaktivität automatisch.</string>
     <string name="AutoLockInTime">in %1$s</string>
     <string name="AutoLockDisabled">Deaktiviert</string>
+    <string name="UnlockFingerprint">Per Fingerabdruck entsperren</string>
+    <string name="FingerprintInfo">Fingerabdruck bestätigen </string>
+    <string name="FingerprintHelp">Berührungssensor</string>
+    <string name="FingerprintNotRecognized">Abdruck nicht erkannt; erneut versuchen </string>
     <!--media view-->
     <string name="NoMedia">Die hier geteilten Bilder und Videos kannst du von jedem deiner Geräte aufrufen.</string>
     <string name="DocumentsTitle">Geteilte Dateien</string>
     <string name="SharedMediaTitle">Geteilte Medien</string>
     <string name="LinksTitle">Geteilte Links</string>
+    <string name="AudioTitle">Geteilte Musik</string>
+    <string name="NoSharedAudio">Die hier geteilten Lieder kannst du von jedem deiner Geräte aufrufen.</string>
     <string name="NoSharedFiles">Die hier geteilten Dateien kannst du von jedem deiner Geräte aufrufen.</string>
     <string name="NoSharedLinks">Die hier geteilten Links kannst du von jedem deiner Geräte aufrufen.</string>
     <!--map view-->
@@ -668,6 +726,7 @@
     <string name="Call">Anrufen</string>
     <string name="Copy">Kopieren</string>
     <string name="Delete">Löschen</string>
+    <string name="DeleteAndStop">Löschen und Anhalten</string>
     <string name="Forward">Weiterleiten</string>
     <string name="Retry">Erneut versuchen</string>
     <string name="FromCamera">Von der Kamera</string>
@@ -722,15 +781,16 @@
     <string name="NoHandleAppInstalled">Du hast keine Applikationen, die den Dateityp \'%1$s\' öffnen könnten. Bitte installiere eine entsprechende Anwendung um fortzufahren.</string>
     <string name="InviteUser">Dieser Benutzer hat noch kein Telegram. Möchtest du ihn einladen?</string>
     <string name="AreYouSure">Bist du sicher?</string>
-    <string name="AddToTheGroupTitle">%1$s zur Gruppe %2$s hinzufügen?</string>
+    <string name="AddToTheGroupTitle">%1$s dem Chat %2$s hinzufügen?</string>
     <string name="AddToTheGroupForwardCount">Wieviele der letzten Nachrichten willst du weiterleiten?</string>
     <string name="AddToTheGroup">%1$s zur Gruppe hinzufügen?</string>
     <string name="UserAlreadyInGroup">Nutzer befindet sich schon in der Gruppe</string>
     <string name="ForwardMessagesTo">Nachrichten an %1$s weiterleiten?</string>
     <string name="SendMessagesTo">Nachricht an %1$s senden?</string>
+    <string name="SendContactTo">Kontakt senden an %1$s?</string>
     <string name="AreYouSureLogout">Wirklich abmelden?\n\nDu kannst Telegram von all deinen Geräten gleichzeitig nutzen.\n\nWichtig: Abmelden löscht deine Geheimen Chats.</string>
     <string name="AreYouSureSessions">Sicher, dass du alle anderen Geräte abmelden möchtest?</string>
-    <string name="AreYouSureDeleteAndExit">Diese Gruppe wirklich löschen und verlassen?</string>
+    <string name="AreYouSureDeleteAndExit">Gruppe löschen und verlassen?</string>
     <string name="AreYouSureDeleteThisChat">Möchtest du wirklich diesen Chat löschen?</string>
     <string name="AreYouSureShareMyContactInfo">Wirklich die eigenen Kontaktinformationen teilen?</string>
     <string name="AreYouSureBlockContact">Diesen Kontakt wirklich blockieren?</string>
@@ -739,12 +799,21 @@
     <string name="AreYouSureSecretChat">Geheimen Chat starten?</string>
     <string name="AreYouSureRegistration">Bist du dir sicher, dass du die Registrierung abbrechen willst?</string>
     <string name="AreYouSureClearHistory">Möchtest du wirklich den Verlauf löschen?</string>
+    <string name="AreYouSureClearHistoryChannel">Cache des Kanals wirklich löschen?</string>
+    <string name="AreYouSureClearHistorySuper">Cache der Supergruppe wirklich löschen?</string>
     <string name="AreYouSureDeleteMessages">Sicher, dass du %1$s löschen willst?</string>
     <string name="SendMessagesToGroup">Nachricht an %1$s senden?</string>
+    <string name="SendContactToGroup">Kontakt senden an %1$s?</string>
     <string name="ForwardMessagesToGroup">Weiterleiten an %1$s?</string>
     <string name="FeatureUnavailable">Verzeihung, diese Funktion ist derzeit in deinem Land nicht verfügbar.</string>
     <string name="NoUsernameFound">Kein Konto mit diesem Benutzernamen</string>
     <string name="BotCantJoinGroups">Keine Gruppen mit diesem Bot möglich</string>
+    <!--permissions-->
+    <string name="PermissionContacts">Telegram benötigt Zugriff auf deine Kontakte um dich auf all denen Geräten mit deinen Freunden zu verbinden. </string>
+    <string name="PermissionStorage">Telegram benötigt Zugriff auf deinen Speicher, damit du Bilder, Videos und Musik senden und speichern kannst.</string>
+    <string name="PermissionNoAudio">Telegram benötigt Zugriff auf dein Mikrofon, damit du Sprachnachrichten senden kannst. </string>
+    <string name="PermissionNoLocation">Telegram benötigt Zugriff auf deinen Standort, damit du ihn mit Freunden teilen kannst. </string>
+    <string name="PermissionOpenSettings">EINSTELLUNGEN</string>
     <!--Intro view-->
     <string name="Page1Title">Telegram</string>
     <string name="Page2Title">Schnell</string>
@@ -882,6 +951,18 @@
     <string name="Photos_few">%1$d Bilder</string>
     <string name="Photos_many">%1$d Bilder</string>
     <string name="Photos_other">%1$d Bilder</string>
+    <string name="LastSeenMinutes_zero">zul. online vor %1$d Minuten</string>
+    <string name="LastSeenMinutes_one">zul. online vor %1$d Minute</string>
+    <string name="LastSeenMinutes_two">zul. online vor %1$d Minuten</string>
+    <string name="LastSeenMinutes_few">zul. online vor %1$d Minuten</string>
+    <string name="LastSeenMinutes_many">zul. online vor %1$d Minuten</string>
+    <string name="LastSeenMinutes_other">zul. online vor %1$d Minuten</string>
+    <string name="LastSeenHours_zero">zul. online vor %1$d Stunden</string>
+    <string name="LastSeenHours_one">zul. online vor %1$d Stunde</string>
+    <string name="LastSeenHours_two">zul. online vor %1$d Stunden</string>
+    <string name="LastSeenHours_few">zul. online vor %1$d Stunden</string>
+    <string name="LastSeenHours_many">zul. online vor %1$d Stunden</string>
+    <string name="LastSeenHours_other">zul. online vor %1$d Stunden</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d angehängten Nachrichten</string>
     <string name="ForwardedMessage_one">Angehängte Nachricht</string>
@@ -949,6 +1030,6 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s um %2$s</string>
     <!--update text-->
-    <string name="updateText">Telegram für Android wurde aktualisiert. Neu in Version 3.2.0:\n\n- Kanäle: Du kannst nun Nachrichten an eine unbegrenzte Anzahl von Leuten schicken (ersetzen die Verteilerlisten).\n\n Mehr Infos über dieses Update: https://telegram.org/blog/channels</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">Telegram für Android wurde aktualisiert. Neu in Version 3.3.2:\n\n- Cache-Verwaltung: Prüfe wieviel Speicherplatz Telegram auf deinem Gerät benutzt und lösche den gesamten Cache oder nur bestimmte Teile.\n- Lösche den Cache von Supergruppen und Kanälen (in der Chatliste Supergruppe oder Kanal gedrückt halten und "Cache löschen").\n- Sticker-Verwaltung: Ändere die Sortierung deiner Sticker-Pakete. Die Sortierung wird auf all deinen Geräten synchronisiert.\n\nAusführliche Informationen zur neuen Version findest du hier:\nhttps://telegram.org/blog/cache-and-stickers</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-es/strings.xml b/TMessagesProj/src/main/res/values-es/strings.xml
index 39936a5f5..0d3e7e834 100644
--- a/TMessagesProj/src/main/res/values-es/strings.xml
+++ b/TMessagesProj/src/main/res/values-es/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">Telegram</string>
+    <string name="AppNameBeta">Telegram Beta</string>
     <string name="LanguageName">Español</string>
     <string name="LanguageNameInEnglish">Spanish</string>
     <string name="LanguageCode">es</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s se unió a tu chat secreto.</string>
     <string name="EncryptedChatStartedIncoming">Te uniste al chat secreto.</string>
     <string name="ClearHistory">Borrar historial</string>
+    <string name="ClearHistoryCache">Eliminar de la caché</string>
     <string name="DeleteChat">Eliminar y salir</string>
     <string name="DeleteChatUser">Eliminar chat</string>
     <string name="HiddenName">Cuenta eliminada</string>
@@ -60,7 +62,28 @@
     <string name="MuteDisable">Desactivar</string>
     <string name="Hashtags">HASHTAGS</string>
     <string name="Recent">RECIENTES</string>
+    <string name="LinkPreview">Vista previa del enlace</string>
     <!--channels-->
+    <string name="SetAsAdmin">Nombrar como administrador</string>
+    <string name="DescriptionInfoMega">Puedes poner una descripción para tu grupo.</string>
+    <string name="LeaveMega">Dejar el grupo</string>
+    <string name="DeleteMega">Eliminar grupo</string>
+    <string name="LeaveMegaMenu">Dejar el grupo</string>
+    <string name="DeleteMegaMenu">Eliminar grupo</string>
+    <string name="MegaDeleteInfo">Perderás todos los mensajes en este grupo.</string>
+    <string name="MegaAdminsInfo">Puedes añadir administradores para que te ayuden a dirigir el canal. Mantén pulsado para eliminarlos.</string>
+    <string name="MegaDeleteAlert">¡Espera! Al eliminar este grupo, todos los miembros y los mensajes se perderán. ¿Quieres eliminarlo?</string>
+    <string name="ActionCreateMega">Grupo creado</string>
+    <string name="MegaAddedBy">un1 te añadió a este grupo</string>
+    <string name="MegaLeaveAlert">¿Quieres dejar el grupo?</string>
+    <string name="GroupUserCantAdd">Lo sentimos, no puedes añadir este usuario a grupos.</string>
+    <string name="GroupUserAddLimit">Lo sentimos, el grupo está lleno.</string>
+    <string name="GroupUserLeftError">Lo sentimos, este usuario decidió dejar el grupo, así que no puedes invitarlo otra vez.</string>
+    <string name="GroupUserCantAdmin">Lo sentimos, hay demasiados administradores en el grupo.</string>
+    <string name="GroupUserCantBot">Lo sentimos, hay demasiados bots en el grupo.</string>
+    <string name="ActionMigrateFromGroup">Este grupo fue convertido en un supergrupo</string>
+    <string name="ActionMigrateFromGroupNotify">%1$s fue convertido en un supergrupo</string>
+    <string name="NoBlockedGroup">Los usuarios bloqueados son eliminados del grupo y sólo pueden volver si son invitados por un administrador. Los enlaces de invitación no funcionan para ellos.</string>
     <string name="NewChannel">Nuevo canal</string>
     <string name="EnterChannelName">Nombre del canal</string>
     <string name="Comments">Comentarios</string>
@@ -97,11 +120,11 @@
     <string name="LinkChecking">Verificando nombre...</string>
     <string name="LinkAvailable">%1$s está disponible.</string>
     <string name="ChannelMembers">Miembros</string>
-    <string name="ChannelBlockedUsers">Usuarios bloqueados</string>
+    <string name="ChannelBlockedUsers">Bloqueados</string>
     <string name="ChannelAdministrators">Administradores</string>
     <string name="ChannelDelete">Eliminar canal</string>
     <string name="ChannelDeleteMenu">Eliminar canal</string>
-    <string name="ChannelDeleteAlert">¡Espera! Al eliminar este canal se quitarán todos los miembros y los mensajes se perderán. ¿Quieres eliminarlo?</string>
+    <string name="ChannelDeleteAlert">¡Espera! Al eliminar este canal, todos los miembros y los mensajes se perderán. ¿Quieres eliminarlo?</string>
     <string name="ChannelLeaveAlert">¿Quieres dejar este canal?</string>
     <string name="ChannelDeleteInfo">Perderás todos los mensajes en este canal.</string>
     <string name="ChannelEdit">Editar</string>
@@ -111,7 +134,6 @@
     <string name="ActionChannelChangedPhoto">Foto del canal cambiada</string>
     <string name="ActionChannelRemovedPhoto">Foto del canal eliminada</string>
     <string name="ActionChannelChangedTitle">Nombre del canal cambiado a un2</string>
-    <string name="ActionChannelInvite">un1 te añadió al canal un2</string>
     <string name="ChannelPublicLimitReached">Lo sentimos, has creado demasiados canales públicos. Puedes crear un canal privado o eliminar uno de tus canales existentes primero.</string>
     <string name="ChannelModerator">Moderador</string>
     <string name="ChannelCreator">Creador</string>
@@ -128,10 +150,11 @@
     <string name="ChannelAdminsInfo">Puedes añadir administradores para que te ayuden en el canal. Mantén pulsado para eliminar un administrador.</string>
     <string name="ChannelJoinTo">¿Quieres unirte al canal \'%1$s\'?</string>
     <string name="ChannelCantOpenPrivate">Lo sentimos, este canal ya no es accesible.</string>
-    <string name="ChannelAddToTitle">¿Añadir a %1$s al canal %2$s?</string>
     <string name="ChannelAddTo">¿Añadir a %1$s al canal?</string>
-    <string name="ChannelUserLeftError">Lo sentimos, este usuario decidió dejar el grupo, así que no puedes invitarlo otra vez.</string>
+    <string name="ChannelUserLeftError">Lo sentimos, este usuario decidió dejar el canal, así que no puedes invitarlo otra vez.</string>
     <string name="ChannelUserCantAdd">Lo sentimos, no puedes añadir a este usuario a canales.</string>
+    <string name="ChannelUserCantAdmin">Lo sentimos, hay demasiados administradores en el canal.</string>
+    <string name="ChannelUserCantBot">Lo sentimos, hay demasiados bots en el canal.</string>
     <string name="ChannelUserAddLimit">Lo sentimos, sólo puedes añadir a los primeros 200 miembros a un canal. Sin embargo, una cantidad ilimitada de personas pueden unirse por el enlace del canal.</string>
     <string name="ChannelAddedBy">un1 te añadió a este canal</string>
     <string name="ChannelJoined">Te uniste al canal</string>
@@ -147,20 +170,20 @@
     <string name="ChannelMessageGroupDocument">%1$s envió un archivo al canal %2$s</string>
     <string name="ChannelMessageGroupAudio">%1$s envió un audio al canal %2$s</string>
     <string name="ChannelMessageGroupSticker">%1$s envió un sticker al canal %2$s</string>
-    <string name="ChannelMessageNoText">Nuevo mensaje en el canal %1$s</string>
-    <string name="ChannelMessagePhoto">Nueva foto en el canal %1$s</string>
-    <string name="ChannelMessageVideo">Nuevo vídeo en el canal %1$s</string>
-    <string name="ChannelMessageContact">Contacto compartido en el canal %1$s</string>
-    <string name="ChannelMessageMap">Nueva ubicación compartida en el canal %1$s</string>
-    <string name="ChannelMessageDocument">Nuevo archivo compartido en el canal %1$s</string>
-    <string name="ChannelMessageAudio">Nueva nota de voz compartida en el canal %1$s</string>
-    <string name="ChannelMessageSticker">Nuevo sticker compartido en el canal %1$s</string>
+    <string name="ChannelMessageNoText">%1$s publicó un mensaje</string>
+    <string name="ChannelMessagePhoto">%1$s publicó una foto</string>
+    <string name="ChannelMessageVideo">%1$s publicó un vídeo</string>
+    <string name="ChannelMessageContact">%1$s publicó un contacto</string>
+    <string name="ChannelMessageMap">%1$s publicó una ubicación</string>
+    <string name="ChannelMessageDocument">%1$s publicó un archivo</string>
+    <string name="ChannelMessageAudio">%1$s publicó un mensaje de voz</string>
+    <string name="ChannelMessageSticker">%1$s publicó un sticker</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">Nueva difusión</string>
     <string name="EnterListName">Nombre de la lista</string>
     <string name="YouCreatedBroadcastList">Creaste una lista de difusión</string>
     <string name="AddRecipient">Añadir destinatario</string>
-    <string name="KickFromBroadcast">Quitar de la lista de difusión</string>
+    <string name="KickFromBroadcast">Eliminar de la lista de difusión</string>
     <!--audio view-->
     <string name="NoAudio">Por favor, añade archivos a la carpeta de música en tu dispositivo para verlos aquí.</string>
     <string name="AttachMusic">Música</string>
@@ -216,7 +239,7 @@
     <string name="EncryptedDescription2">No dejan rastro en el servidor</string>
     <string name="EncryptedDescription3">Tienen autodestrucción de mensajes</string>
     <string name="EncryptedDescription4">Impiden reenviar mensajes</string>
-    <string name="YouWereKicked">Te expulsaron de este grupo</string>
+    <string name="YouWereKicked">Te eliminaron de este grupo</string>
     <string name="YouLeft">Dejaste este grupo</string>
     <string name="DeleteThisGroup">Eliminar este grupo</string>
     <string name="DeleteThisChat">Eliminar este chat</string>
@@ -238,8 +261,10 @@
     <string name="ReportSpamAlert">¿Quieres reportar a este usuario como spam?</string>
     <string name="ReportSpamAlertGroup">¿Quieres reportar a este grupo como spam?</string>
     <string name="NobodyLikesSpam1">Lo sentimos, por ahora puedes enviar mensajes sólo a contactos mutuos.</string>
-    <string name="NobodyLikesSpam2">Lo sentimos, por ahora sólo puedes añadir a contactos mutuos a un grupo.</string>
+    <string name="NobodyLikesSpam2">Lo sentimos, por ahora sólo puedes añadir contactos mutuos a un grupo.</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq/es#no-puedo-enviar-mensajes-a-quienes-no-son-mis-contactos</string>
     <string name="MoreInfo">Más información</string>
+    <string name="ShareSendTo">Enviar a...</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s activó la autodestrucción en %2$s</string>
     <string name="MessageLifetimeChangedOutgoing">Activaste la autodestrucción en %1$s</string>
@@ -269,8 +294,8 @@
     <string name="NotificationEditedGroupPhoto">%1$s cambió la foto del grupo %2$s</string>
     <string name="NotificationGroupAddMember">%1$s invitó a %3$s al grupo %2$s</string>
     <string name="NotificationGroupAddSelf">%1$s volvió al grupo %2$s</string>
-    <string name="NotificationGroupKickMember">%1$s expulsó a %3$s del grupo %2$s</string>
-    <string name="NotificationGroupKickYou">%1$s te expulsó del grupo %2$s</string>
+    <string name="NotificationGroupKickMember">%1$s eliminó a %3$s del grupo %2$s</string>
+    <string name="NotificationGroupKickYou">%1$s te eliminó del grupo %2$s</string>
     <string name="NotificationGroupLeftMember">%1$s dejó el grupo %2$s</string>
     <string name="NotificationContactJoined">¡%1$s se unió a Telegram!</string>
     <string name="NotificationUnrecognizedDevice">%1$s,\nDetectamos un inicio de sesión en tu cuenta desde un nuevo dispositivo, el %2$s\n\nDispositivo: %3$s\nUbicación: %4$s\n\nSi no eras tú, puedes ir a Ajustes - Privacidad y seguridad - Sesiones activas y cerrar esa sesión.\n\nSi crees que alguien ha iniciado la sesión sin tu consentimiento, puedes activar la verificación en dos pasos, en los ajustes de privacidad y seguridad.\n\nAtentamente,\nEl equipo de Telegram</string>
@@ -289,6 +314,7 @@
     <string name="Online">en línea</string>
     <string name="LastSeen">últ. vez</string>
     <string name="LastSeenDate">últ. vez el</string>
+    <string name="LastSeenNow">últ. vez hace un momento</string>
     <string name="InviteFriends">Invitar a amigos</string>
     <string name="GlobalSearch">BÚSQUEDA GLOBAL</string>
     <string name="Lately">últ. vez recientemente</string>
@@ -297,7 +323,7 @@
     <string name="ALongTimeAgo">últ. vez hace mucho tiempo</string>
     <string name="NewMessageTitle">Nuevo mensaje</string>
     <!--group create view-->
-    <string name="SendMessageTo">Enviar mensaje a...</string>
+    <string name="SendMessageTo">Invitar a...</string>
     <string name="EnterGroupNamePlaceholder">Nombre del grupo</string>
     <string name="GroupName">Nombre del grupo</string>
     <string name="MembersCount">%1$d/%2$d miembros</string>
@@ -314,13 +340,22 @@
     <string name="CopyLink">Copiar enlace</string>
     <string name="ShareLink">Compartir enlace</string>
     <string name="LinkInfo">Cualquiera que tenga Telegram instalada podrá unirse a tu grupo siguiendo este enlace.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">Administradores</string>
+    <string name="SetAdminsAll">Todos son administradores</string>
+    <string name="SetAdminsAllInfo">Todos pueden añadir nuevos miembros, editar el nombre y la foto del grupo.</string>
+    <string name="SetAdminsNotAllInfo">Sólo los administradores pueden añadir y eliminar miembros, editar el nombre y la foto del grupo.</string>
     <!--group info view-->
-    <string name="SharedMedia">Todos los archivos</string>
+    <string name="SharedMedia">Multimedia</string>
     <string name="SETTINGS">Ajustes</string>
     <string name="AddMember">Añadir miembro</string>
+    <string name="SetAdmins">Nombrar administradores</string>
     <string name="DeleteAndExit">Eliminar y dejar el grupo</string>
     <string name="Notifications">Notificaciones</string>
-    <string name="KickFromGroup">Expulsar del grupo</string>
+    <string name="KickFromGroup">Eliminar del grupo</string>
+    <string name="ConvertGroup">Convertir en supergrupo</string>
+    <string name="ConvertGroupAlert">Por favor, ten en cuenta que los miembros del grupo tendrán que actualizar Telegram a la última versión para ver tu supergrupo. ¿Quieres convertir el grupo?</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>Límite de miembros alcanzado.<![CDATA[</b>]]>\n\nPara superar el límite y tener características adicionales, conviértelo en un supergrupo:\n\n• Permiten hasta %1$s\n• Nuevos miembros ven todo el historial\n• Un admin. borra mensajes para todos\n• Notificaciones silenciadas por defecto</string>
     <!--contact info view-->
     <string name="ShareContact">Compartir</string>
     <string name="AddContact">Añadir</string>
@@ -367,7 +402,7 @@
     <string name="StickersShow">Mostrar</string>
     <string name="StickersShare">Compartir</string>
     <string name="StickersCopy">Copiar enlace</string>
-    <string name="StickersRemove">Quitar</string>
+    <string name="StickersRemove">Eliminar</string>
     <string name="NoStickers">Sin stickers aún</string>
     <!--settings view-->
     <string name="ResetNotificationsText">Restablecer las notificaciones</string>
@@ -403,7 +438,6 @@
     <string name="TerminateAllSessions">Cerrar todas las otras sesiones</string>
     <string name="Events">Eventos</string>
     <string name="ContactJoined">Un contacto se unió a Telegram</string>
-    <string name="Pebble">PEBBLE</string>
     <string name="Language">Idioma</string>
     <string name="AskAQuestionInfo">Por favor, considera que el soporte de Telegram está hecho por voluntarios. Respondemos lo antes posible, pero puede tomar tiempo.<![CDATA[<br><br>]]>Por favor, mira las <![CDATA[<a href=\"https://telegram.org/faq/es\">preguntas frecuentes de Telegram</a>]]>: tienen respuestas para la mayoría de las preguntas y <![CDATA[<a href=\"https://telegram.org/faq/es#solucin-de-problemas\">soluciones a problemas</a>]]>.</string>
     <string name="AskButton">Preguntar</string>
@@ -465,6 +499,24 @@
     <string name="SmartNotificationsTimes">veces</string>
     <string name="SmartNotificationsWithin">en</string>
     <string name="SmartNotificationsMinutes">minutos</string>
+    <!--cache view-->
+    <string name="CacheSettings">Ajustes de caché</string>
+    <string name="LocalDatabase">Base de datos local</string>
+    <string name="LocalDatabaseClear">¿Borrar los mensajes en la caché?</string>
+    <string name="LocalDatabaseInfo">Al borrar la base de datos se eliminarán los mensajes en la caché y se comprimirá la base de datos para liberar espacio de almacenamiento. Telegram requiere algunos datos para funcionar, así que la base de datos nunca podrá llegar a cero.\n\nEsto puede tardar algunos minutos.</string>
+    <string name="ClearMediaCache">Borrar caché</string>
+    <string name="CacheClear">Borrar</string>
+    <string name="CalculatingSize">Calculando...</string>
+    <string name="LocalDocumentCache">Archivos</string>
+    <string name="LocalPhotoCache">Fotos</string>
+    <string name="LocalAudioCache">Mensajes de voz</string>
+    <string name="LocalVideoCache">Vídeos</string>
+    <string name="LocalMusicCache">Música</string>
+    <string name="LocalCache">Otros archivos</string>
+    <string name="CacheEmpty">Vacío</string>
+    <string name="KeepMedia">Conservar multimedia</string>
+    <string name="KeepMediaInfo">Las fotos, los vídeos y los archivos de los chats en la nube a los que <![CDATA[<b>no accedas</b>]]> durante ese periodo de tiempo se eliminarán del dispositivo para liberar espacio.\n\nToda la multimedia permanecerá en la nube de Telegram y podrás volver a descargarla si la necesitas.</string>
+    <string name="KeepMediaForever">Siempre</string>
     <!--sessions view-->
     <string name="SessionsTitle">Sesiones activas</string>
     <string name="CurrentSession">Sesión actual</string>
@@ -493,11 +545,17 @@
     <string name="AutoLockInfo">El bloqueo se activará transcurrido este tiempo.</string>
     <string name="AutoLockInTime">en %1$s</string>
     <string name="AutoLockDisabled">Desactivado</string>
+    <string name="UnlockFingerprint">Desbloquear con la huella digital</string>
+    <string name="FingerprintInfo">Confirma la huella digital para continuar</string>
+    <string name="FingerprintHelp">Sensor táctil</string>
+    <string name="FingerprintNotRecognized">Huella digital no reconocida. Reinténtalo</string>
     <!--media view-->
     <string name="NoMedia">Comparte fotos y vídeos en este chat y accede a ellos desde cualquier dispositivo.</string>
     <string name="DocumentsTitle">Archivos</string>
     <string name="SharedMediaTitle">Multimedia</string>
     <string name="LinksTitle">Enlaces</string>
+    <string name="AudioTitle">Música</string>
+    <string name="NoSharedAudio">Comparte música en este chat y accede a ella desde cualquier dispositivo.</string>
     <string name="NoSharedFiles">Comparte archivos en este chat y accede a ellos desde cualquier dispositivo.</string>
     <string name="NoSharedLinks">Comparte enlaces en este chat y accede a ellos desde cualquiera de tus dispositivos.</string>
     <!--map view-->
@@ -668,6 +726,7 @@
     <string name="Call">Llamar</string>
     <string name="Copy">Copiar</string>
     <string name="Delete">Eliminar</string>
+    <string name="DeleteAndStop">Eliminar y detener</string>
     <string name="Forward">Reenviar</string>
     <string name="Retry">Reintentar</string>
     <string name="FromCamera">Desde la cámara</string>
@@ -679,21 +738,21 @@
     <!--messages-->
     <string name="ActionInviteYou">Te uniste al grupo con un enlace de invitación</string>
     <string name="ActionInviteUser">un1 se unió al grupo con un enlace de invitación</string>
-    <string name="ActionKickUser">un1 expulsó a un2</string>
+    <string name="ActionKickUser">un1 eliminó a un2</string>
     <string name="ActionLeftUser">un1 dejó el grupo</string>
     <string name="ActionAddUser">un1 añadió a un2</string>
     <string name="ActionRemovedPhoto">un1 eliminó la foto del grupo</string>
     <string name="ActionChangedPhoto">un1 cambió la foto del grupo</string>
     <string name="ActionChangedTitle">un1 cambió el nombre del grupo a un2</string>
     <string name="ActionCreateGroup">un1 creó el grupo</string>
-    <string name="ActionYouKickUser">Expulsaste a un2</string>
+    <string name="ActionYouKickUser">Eliminaste a un2</string>
     <string name="ActionYouLeftUser">Dejaste el grupo</string>
     <string name="ActionYouAddUser">Añadiste a un2</string>
-    <string name="ActionYouRemovedPhoto">Quitaste la foto del grupo</string>
+    <string name="ActionYouRemovedPhoto">Eliminaste la foto del grupo</string>
     <string name="ActionYouChangedPhoto">Cambiaste la foto del grupo</string>
     <string name="ActionYouChangedTitle">Cambiaste el nombre del grupo a un2</string>
     <string name="ActionYouCreateGroup">Creaste el grupo</string>
-    <string name="ActionKickUserYou">un1 te expulsó</string>
+    <string name="ActionKickUserYou">un1 te eliminó</string>
     <string name="ActionAddUserYou">un1 te añadió</string>
     <string name="ActionAddUserSelf">un1 volvió al grupo</string>
     <string name="ActionAddUserSelfYou">Volviste al grupo</string>
@@ -722,12 +781,13 @@
     <string name="NoHandleAppInstalled">No tienes aplicaciones que puedan manejar el tipo de archivo \'%1$s\'. Por favor, instala una para continuar.</string>
     <string name="InviteUser">Este usuario aún no tiene Telegram. ¿Enviarle una invitación?</string>
     <string name="AreYouSure">¿Quieres hacerlo?</string>
-    <string name="AddToTheGroupTitle">¿Añadir a %1$s al grupo %2$s?</string>
+    <string name="AddToTheGroupTitle">¿Añadir a %1$s al chat %2$s?</string>
     <string name="AddToTheGroupForwardCount">Cantidad de últimos mensajes para reenviar:</string>
     <string name="AddToTheGroup">¿Añadir a %1$s al grupo?</string>
     <string name="UserAlreadyInGroup">Este usuario ya está en el grupo</string>
     <string name="ForwardMessagesTo">¿Reenviar mensajes a %1$s?</string>
     <string name="SendMessagesTo">¿Enviar mensajes a %1$s?</string>
+    <string name="SendContactTo">¿Enviar contacto a %1$s?</string>
     <string name="AreYouSureLogout">¿Quieres cerrar sesión?\n\nConsidera que puedes usar Telegram en todos tus dispositivos a la vez.\n\nRecuerda que, al cerrar sesión, eliminas todos tus chats secretos.</string>
     <string name="AreYouSureSessions">¿Quieres terminar todas las otras sesiones?</string>
     <string name="AreYouSureDeleteAndExit">¿Quieres eliminar y dejar el grupo?</string>
@@ -739,12 +799,21 @@
     <string name="AreYouSureSecretChat">¿Quieres iniciar un chat secreto?</string>
     <string name="AreYouSureRegistration">¿Quieres cancelar el registro?</string>
     <string name="AreYouSureClearHistory">¿Quieres eliminar el historial?</string>
+    <string name="AreYouSureClearHistoryChannel">¿Eliminar de la caché los mensajes y multimedia de este canal?</string>
+    <string name="AreYouSureClearHistorySuper">¿Eliminar de la caché los mensajes y multimedia de este supergrupo?</string>
     <string name="AreYouSureDeleteMessages">¿Quieres eliminar %1$s?</string>
     <string name="SendMessagesToGroup">¿Enviar mensajes a %1$s?</string>
+    <string name="SendContactToGroup">¿Enviar contacto a %1$s?</string>
     <string name="ForwardMessagesToGroup">¿Reenviar mensajes a %1$s?</string>
     <string name="FeatureUnavailable">Lo sentimos, esta característica no está disponible en tu país actualmente.</string>
     <string name="NoUsernameFound">No hay ninguna cuenta de Telegram con este alias.</string>
     <string name="BotCantJoinGroups">Este bot no puede unirse a grupos.</string>
+    <!--permissions-->
+    <string name="PermissionContacts">Telegram necesita el acceso a tus contactos, para que puedas comunicarte con ellos en todos tus dispositivos.</string>
+    <string name="PermissionStorage">Telegram necesita acceso a tu almacenamiento, para que puedas enviar y guardar fotos, vídeos, música y otros archivos.</string>
+    <string name="PermissionNoAudio">Telegram necesita acceso a tu micrófono, para que puedas enviar mensajes de voz.</string>
+    <string name="PermissionNoLocation">Telegram necesita acceso a tu ubicación, para que puedas compartirla con tus amigos.</string>
+    <string name="PermissionOpenSettings">AJUSTES</string>
     <!--Intro view-->
     <string name="Page1Title">Telegram</string>
     <string name="Page2Title">Rápida</string>
@@ -882,6 +951,18 @@
     <string name="Photos_few">%1$d fotos</string>
     <string name="Photos_many">%1$d fotos</string>
     <string name="Photos_other">%1$d fotos</string>
+    <string name="LastSeenMinutes_zero">últ. vez hace %1$d minutos</string>
+    <string name="LastSeenMinutes_one">últ. vez hace %1$d minuto</string>
+    <string name="LastSeenMinutes_two">últ. vez hace %1$d minutos</string>
+    <string name="LastSeenMinutes_few">últ. vez hace %1$d minutos</string>
+    <string name="LastSeenMinutes_many">últ. vez hace %1$d minutos</string>
+    <string name="LastSeenMinutes_other">últ. vez hace %1$d minutos</string>
+    <string name="LastSeenHours_zero">últ. vez hace %1$d horas</string>
+    <string name="LastSeenHours_one">últ. vez hace %1$d hora</string>
+    <string name="LastSeenHours_two">últ. vez hace %1$d horas</string>
+    <string name="LastSeenHours_few">últ. vez hace %1$d horas</string>
+    <string name="LastSeenHours_many">últ. vez hace %1$d horas</string>
+    <string name="LastSeenHours_other">últ. vez hace %1$d horas</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d mensajes adjuntos</string>
     <string name="ForwardedMessage_one">Mensaje adjunto</string>
@@ -949,6 +1030,6 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s a las %2$s</string>
     <!--update text-->
-    <string name="updateText">Telegram para Android ha sido actualizada. Novedades en la versión 3.2.0\n\n- Presentamos los Canales - una nueva gran forma de difundir tus mensajes a audiencias ilimitadas (reemplaza a las antiguas difusiones).\n\n Conoce más: https://telegram.org/blog/channels</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">Telegram para Android ha sido actualizada. Novedades en la versión 3.3.2:\n\n- Gestión de caché: controla cuánto espacio usa Telegram en tu dispositivo y borra la caché para tipos específicos de contenido.\n- Elimina la caché de supergrupos y canales: mantén pulsado sobre ellos, en la lista de chats, y elige ‘Eliminar de la caché’.\n- Gestión de stickers: ordena manualmente tus packs de stickers. El orden de los packs ahora está sincronizado en todos tus dispositivos.\n\nMás sobre esta actualización aquí:\nhttps://telegram.org/blog/cache-and-stickers</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-it/strings.xml b/TMessagesProj/src/main/res/values-it/strings.xml
index 73586f5b2..efb234fc7 100644
--- a/TMessagesProj/src/main/res/values-it/strings.xml
+++ b/TMessagesProj/src/main/res/values-it/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">Telegram</string>
+    <string name="AppNameBeta">Telegram Beta</string>
     <string name="LanguageName">Italiano</string>
     <string name="LanguageNameInEnglish">Italian</string>
     <string name="LanguageCode">it</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s si è unito alla tua chat segreta.</string>
     <string name="EncryptedChatStartedIncoming">Sei entrato nella chat segreta.</string>
     <string name="ClearHistory">Cancella cronologia</string>
+    <string name="ClearHistoryCache">Elimina dalla cache</string>
     <string name="DeleteChat">Elimina ed esci</string>
     <string name="DeleteChatUser">Elimina chat</string>
     <string name="HiddenName">Account eliminato</string>
@@ -60,7 +62,28 @@
     <string name="MuteDisable">Disabilita</string>
     <string name="Hashtags">HASHTAG</string>
     <string name="Recent">RECENTI</string>
+    <string name="LinkPreview">Anteprima link</string>
     <!--channels-->
+    <string name="SetAsAdmin">Rendi amministratore</string>
+    <string name="DescriptionInfoMega">Puoi inserire una descrizione opzionale per il tuo gruppo.</string>
+    <string name="LeaveMega">Lascia il gruppo</string>
+    <string name="DeleteMega">Elimina gruppo</string>
+    <string name="LeaveMegaMenu">Lascia il gruppo</string>
+    <string name="DeleteMegaMenu">Elimina gruppo</string>
+    <string name="MegaDeleteInfo">Perderai tutti i messaggi in questo gruppo.</string>
+    <string name="MegaAdminsInfo">Puoi aggiungere amministratori per farti aiutare a gestire il tuo gruppo. Tieni premuto per rimuoverli.</string>
+    <string name="MegaDeleteAlert">Aspetta! Eliminando il gruppo rimuoverai tutti i membri e tutti i messaggi saranno persi. Vuoi comunque eliminare il gruppo?</string>
+    <string name="ActionCreateMega">Gruppo creato</string>
+    <string name="MegaAddedBy">un1 ti ha aggiunto a questo gruppo</string>
+    <string name="MegaLeaveAlert">Sei sicuro di voler lasciare il gruppo?</string>
+    <string name="GroupUserCantAdd">Spiacenti, non puoi aggiungere questo utente ai gruppi.</string>
+    <string name="GroupUserAddLimit">Spiacenti, questo gruppo è pieno.</string>
+    <string name="GroupUserLeftError">Spiacenti, questo utente ha deciso di lasciare il gruppo, quindi non puoi reinvitarlo.</string>
+    <string name="GroupUserCantAdmin">Spiacenti, troppi amministratori in questo gruppo.</string>
+    <string name="GroupUserCantBot">Spiacenti, troppi bot in questo gruppo.</string>
+    <string name="ActionMigrateFromGroup">Questo gruppo è stato aggiornato a supergruppo</string>
+    <string name="ActionMigrateFromGroupNotify">%1$s è stato aggiornato a supergruppo.</string>
+    <string name="NoBlockedGroup">Gli utenti in lista nera sono rimossi dal gruppo e possono tornare solo se invitati da un amministratore. I link di invito non funzionano per loro.</string>
     <string name="NewChannel">Nuovo canale</string>
     <string name="EnterChannelName">Nome canale</string>
     <string name="Comments">Commenti</string>
@@ -111,8 +134,7 @@
     <string name="ActionChannelChangedPhoto">Foto del canale cambiata</string>
     <string name="ActionChannelRemovedPhoto">Foto del canale rimossa</string>
     <string name="ActionChannelChangedTitle">Nome del canale cambiato in un2</string>
-    <string name="ActionChannelInvite">un1 ti ha aggiunto al canale un2</string>
-    <string name="ChannelPublicLimitReached">Spiacenti, hai creato troppi canali pubblici. Puoi o creare un canale privato o eliminare uno dei tuoi precedenti canali per poi crearne un altro.</string>
+    <string name="ChannelPublicLimitReached">Spiacenti, hai creato troppi canali pubblici. Puoi creare un canale privato o eliminare un tuo canale pubblico.</string>
     <string name="ChannelModerator">Moderatore</string>
     <string name="ChannelCreator">Creatore</string>
     <string name="ChannelEditor">Amministratore</string>
@@ -127,11 +149,12 @@
     <string name="ChannelLinkInfo">Chiunque abbia Telegram installato sarà in grado di aggiungersi al tuo canale seguendo questo link.</string>
     <string name="ChannelAdminsInfo">Puoi aggiungere amministratori per farti aiutare a gestire il tuo canale. Tieni premuto per rimuovere gli amministratori.</string>
     <string name="ChannelJoinTo">Vuoi unirti al canale \'%1$s\'?</string>
-    <string name="ChannelCantOpenPrivate">Spiacenti, questo canale non è più accessibile.</string>
-    <string name="ChannelAddToTitle">Aggiungere %1$s al canale %2$s?</string>
+    <string name="ChannelCantOpenPrivate">Spiacenti, questa chat non è più accessibile.</string>
     <string name="ChannelAddTo">Aggiungere %1$s al canale?</string>
-    <string name="ChannelUserLeftError">Spiacenti, questo utente ha deciso di lasciare il gruppo, quindi non puoi reinvitarlo.</string>
+    <string name="ChannelUserLeftError">Spiacenti, questo utente ha deciso di lasciare il canale, quindi non puoi reinvitarlo.</string>
     <string name="ChannelUserCantAdd">Spiacenti, non puoi aggiungere questo utente ai canali.</string>
+    <string name="ChannelUserCantAdmin">Spiacenti, troppi amministratori in questo canale.</string>
+    <string name="ChannelUserCantBot">Spiacenti, troppi bot in questo canale.</string>
     <string name="ChannelUserAddLimit">Spiacenti, puoi aggiungere solo i primi 200 membri a un canale. Ricorda che un numero illimitato di persone potrebbe unirsi tramite il link del canale.</string>
     <string name="ChannelAddedBy">un1 ti ha aggiunto a questo canale</string>
     <string name="ChannelJoined">Ti sei unito al canale</string>
@@ -147,14 +170,14 @@
     <string name="ChannelMessageGroupDocument">%1$s ha inviato un file al canale %2$s</string>
     <string name="ChannelMessageGroupAudio">%1$s ha inviato un audio al canale %2$s</string>
     <string name="ChannelMessageGroupSticker">%1$s ha inviato uno sticker al canale %2$s</string>
-    <string name="ChannelMessageNoText">Nuovo messaggio nel canale %1$s</string>
-    <string name="ChannelMessagePhoto">Nuova foto nel canale %1$s</string>
-    <string name="ChannelMessageVideo">Nuovo video nel canale %1$s</string>
-    <string name="ChannelMessageContact">Contatto condiviso nel canale %1$s</string>
-    <string name="ChannelMessageMap">Nuova posizione condivisa nel canale %1$s</string>
-    <string name="ChannelMessageDocument">Nuovo file condiviso nel canale %1$s</string>
-    <string name="ChannelMessageAudio">Nuova nota vocale condivisa nel canale %1$s</string>
-    <string name="ChannelMessageSticker">Nuovo sticker condiviso nel canale %1$s</string>
+    <string name="ChannelMessageNoText">%1$s ha pubblicato un messaggio</string>
+    <string name="ChannelMessagePhoto">%1$s ha pubblicato una foto</string>
+    <string name="ChannelMessageVideo">%1$s ha pubblicato un video</string>
+    <string name="ChannelMessageContact">%1$s ha pubblicato un contatto</string>
+    <string name="ChannelMessageMap">%1$s ha pubblicato una posizione</string>
+    <string name="ChannelMessageDocument">%1$s ha pubblicato un file</string>
+    <string name="ChannelMessageAudio">%1$s ha pubblicato un messaggio vocale</string>
+    <string name="ChannelMessageSticker">%1$s ha pubblicato uno sticker</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">Nuova lista broadcast</string>
     <string name="EnterListName">Inserisci il nome della lista</string>
@@ -209,7 +232,7 @@
     <string name="TypeMessage">Messaggi</string>
     <string name="ShareMyContactInfo">Condividi il mio contatto</string>
     <string name="AddToContacts">Aggiungi ai contatti</string>
-    <string name="EncryptedPlaceholderTitleIncoming">%s ti ha mandato un invito a una chat segreta.</string>
+    <string name="EncryptedPlaceholderTitleIncoming">%s ti ha invitato ad entrare in una chat segreta.</string>
     <string name="EncryptedPlaceholderTitleOutgoing">Hai invitato %s a entrare in una chat segreta.</string>
     <string name="EncryptedDescriptionTitle">Chat segrete:</string>
     <string name="EncryptedDescription1">Utilizzano la crittografia end-to-end</string>
@@ -237,9 +260,11 @@
     <string name="AddContactChat">AGGIUNGI CONTATTO</string>
     <string name="ReportSpamAlert">Sei sicuro di voler segnalare questo utente come spam?</string>
     <string name="ReportSpamAlertGroup">Sei sicuro di voler segnalare dello spam in questo gruppo?</string>
-    <string name="NobodyLikesSpam1">Spiacenti, ma al momento puoi scrivere solo a contatti in comune.</string>
-    <string name="NobodyLikesSpam2">Spiacenti, ma al momento puoi aggiungere ai gruppi solo a contatti in comune.</string>
+    <string name="NobodyLikesSpam1">Spiacenti, ma al momento puoi scrivere solo contatti in comune.</string>
+    <string name="NobodyLikesSpam2">Spiacenti, ma al momento puoi aggiungere ai gruppi solo contatti in comune.</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq/it#non-posso-inviare-messaggi-a-chi-non-far-parte-dei-miei-contatti</string>
     <string name="MoreInfo">Più info</string>
+    <string name="ShareSendTo">Invia a...</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s ha impostato il timer di autodistruzione a %2$s</string>
     <string name="MessageLifetimeChangedOutgoing">Hai impostato il timer di autodistruzione a %1$s</string>
@@ -289,6 +314,7 @@
     <string name="Online">in linea</string>
     <string name="LastSeen">ultimo accesso</string>
     <string name="LastSeenDate">ultimo accesso</string>
+    <string name="LastSeenNow">ultimo accesso adesso</string>
     <string name="InviteFriends">Invita amici</string>
     <string name="GlobalSearch">RICERCA GLOBALE</string>
     <string name="Lately">ultimo accesso di recente</string>
@@ -314,13 +340,22 @@
     <string name="CopyLink">Copia link</string>
     <string name="ShareLink">Condividi link</string>
     <string name="LinkInfo">Chiunque abbia Telegram installato, sarà in grado di aggiungersi al tuo gruppo aprendo il link.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">Amministratori</string>
+    <string name="SetAdminsAll">Tutti sono amministratori</string>
+    <string name="SetAdminsAllInfo">Tutti i membri possono aggiungere nuovi membri, modificare nome e foto del gruppo.</string>
+    <string name="SetAdminsNotAllInfo">Solo gli amministratori possono aggiungere e rimuovere membri e modificare nome e foto del gruppo.</string>
     <!--group info view-->
     <string name="SharedMedia">Media condivisi</string>
     <string name="SETTINGS">Impostazioni</string>
     <string name="AddMember">Aggiungi membro</string>
+    <string name="SetAdmins">Imposta amministratori</string>
     <string name="DeleteAndExit">Elimina e lascia il gruppo</string>
     <string name="Notifications">Notifiche</string>
     <string name="KickFromGroup">Rimuovi dal gruppo</string>
+    <string name="ConvertGroup">Aggiorna a supergruppo</string>
+    <string name="ConvertGroupAlert">Per favore ricorda che i membri del gruppo dovranno aggiornare Telegram all\'ultima versione per vedere il tuo supergruppo. Sei sicuro di voler aggiornare questo gruppo?</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>Limite di membri raggiunto.<![CDATA[</b>]]>\n\nPer superare il limite ed avere ulteriori funzioni, aggiorna a un supergruppo:\n\n• I supergruppi hanno massimo %1$s\n• I nuovi membri vedono tutta la cronologia\n• Gli amministratori eliminano i messaggi per tutti\n• Le notifiche saranno silenziate di default.</string>
     <!--contact info view-->
     <string name="ShareContact">Condividi</string>
     <string name="AddContact">Aggiungi</string>
@@ -350,7 +385,7 @@
     <string name="UsernameInvalidShort">Un username deve avere almeno 5 caratteri.</string>
     <string name="UsernameInvalidLong">Il massimo per un username è 32 caratteri.</string>
     <string name="UsernameInvalidStartNumber">Spiacenti, un username non può iniziare con un numero.</string>
-    <string name="UsernameHelp">Puoi scegliere un username su <![CDATA[<b>]]>Telegram<![CDATA[</b>]]>. Se lo fai, le altre persone potranno trovarti tramite questo nome utente e contattarti senza conoscere il tuo numero di telefono.<![CDATA[<br><br>]]>Puoi usare <![CDATA[<b>]]>a–z<![CDATA[</b>]]>, <![CDATA[<b>]]>0–9<![CDATA[</b>]]> e underscore. La lunghezza minima è di <![CDATA[<b>]]>5<![CDATA[</b>]]>  caratteri.</string>
+    <string name="UsernameHelp">Puoi scegliere un username su <![CDATA[<b>]]>Telegram<![CDATA[</b>]]>. Se lo fai, le altre persone potranno trovarti tramite questo username e contattarti senza conoscere il tuo numero di telefono.<![CDATA[<br><br>]]>Puoi usare <![CDATA[<b>]]>a–z<![CDATA[</b>]]>, <![CDATA[<b>]]>0–9<![CDATA[</b>]]> e underscore. La lunghezza minima è di <![CDATA[<b>]]>5<![CDATA[</b>]]>  caratteri.</string>
     <string name="UsernameChecking">Controllo l\'username...</string>
     <string name="UsernameAvailable">%1$s è disponibile.</string>
     <string name="UsernameEmpty">Nessuno</string>
@@ -403,7 +438,6 @@
     <string name="TerminateAllSessions">Termina le altre sessioni</string>
     <string name="Events">Eventi</string>
     <string name="ContactJoined">Un contatto si è unito a Telegram</string>
-    <string name="Pebble">PEBBLE</string>
     <string name="Language">Lingua</string>
     <string name="AskAQuestionInfo">Nota che il supporto di Telegram è fornito da volontari. Proviamo a rispondere non appena possibile, ma potrebbe volerci un pò.<![CDATA[<br><br>]]>Dai un\'occhiata alle <![CDATA[<a href=\"https://telegram.org/faq/it#domande-generali\">FAQ di Telegram</a>]]>: troverai risposte alla maggior parte delle domande e suggerimenti importanti per <![CDATA[<a href=\"https://telegram.org/faq/it#risoluzione-dei-problemi\">l\'individuazione del problema</a>]]></string>
     <string name="AskButton">Chiedi a un volontario</string>
@@ -465,6 +499,24 @@
     <string name="SmartNotificationsTimes">volte</string>
     <string name="SmartNotificationsWithin">in</string>
     <string name="SmartNotificationsMinutes">minuti</string>
+    <!--cache view-->
+    <string name="CacheSettings">Impostazioni cache</string>
+    <string name="LocalDatabase">Database locale</string>
+    <string name="LocalDatabaseClear">Eliminare i messaggi salvati nella cache?</string>
+    <string name="LocalDatabaseInfo">Cancellando il database locale verrà eliminato il testo dei messaggi salvati nella cache, e verrà compressa la dimensione del database per risparmiare spazio in memoria. Telegram necessita di alcuni dati per funzionare, quindi il database non raggiungerà mai uno spazio occupato pari a zero.\n\nQuesta operazione può richiedere alcuni minuti.</string>
+    <string name="ClearMediaCache">Pulisci cache</string>
+    <string name="CacheClear">Pulisci</string>
+    <string name="CalculatingSize">Calcolando...</string>
+    <string name="LocalDocumentCache">Documenti</string>
+    <string name="LocalPhotoCache">Foto</string>
+    <string name="LocalAudioCache">Note vocali</string>
+    <string name="LocalVideoCache">Video</string>
+    <string name="LocalMusicCache">Musica</string>
+    <string name="LocalCache">Altri file</string>
+    <string name="CacheEmpty">Vuota</string>
+    <string name="KeepMedia">Mantieni media</string>
+    <string name="KeepMediaInfo">Foto, video e altri file dalle chat nel cloud che non hai <![CDATA[<b>aperto</b>]]>  in questo periodo verranno eliminati dal dispositivo per preservare la spazio sul disco.\n\nTutti i media rimarranno nel cloud di Telegram e potranno essere riscaricati ogni volta che ne avrai bisogno.</string>
+    <string name="KeepMediaForever">Per sempre</string>
     <!--sessions view-->
     <string name="SessionsTitle">Sessioni attive</string>
     <string name="CurrentSession">Sessione corrente</string>
@@ -493,11 +545,17 @@
     <string name="AutoLockInfo">Richiede il codice se lontano per del tempo.</string>
     <string name="AutoLockInTime">tra %1$s</string>
     <string name="AutoLockDisabled">Disabilitato</string>
+    <string name="UnlockFingerprint">Sblocca con impronta digitale</string>
+    <string name="FingerprintInfo">Conferma impronta digitale per continuare</string>
+    <string name="FingerprintHelp">Sensore touch</string>
+    <string name="FingerprintNotRecognized">Impronta digitale non riconosciuta. Riprova</string>
     <!--media view-->
     <string name="NoMedia">Condividi foto e video in questa chat e accedi ad essi da ogni tuo dispositivo.</string>
     <string name="DocumentsTitle">File condivisi</string>
     <string name="SharedMediaTitle">Media condivisi</string>
     <string name="LinksTitle">Link condivisi</string>
+    <string name="AudioTitle">Musica condivisa</string>
+    <string name="NoSharedAudio">Condividi musica in questa chat e accedi ad essa da ogni tuo dispositivo.</string>
     <string name="NoSharedFiles">Condividi file e documenti in questa chat e accedi ad essi da ogni tuo dispositivo.</string>
     <string name="NoSharedLinks">Condividi link in questa chat ed accedi ad essi da ogni tuo dispositivo.</string>
     <!--map view-->
@@ -594,7 +652,7 @@
     <string name="ResetMyAccount">RIPRISTINA IL MIO ACCOUNT</string>
     <string name="ResetMyAccountText">Perderai tutte le chat e i messaggi, insieme ai media e ai file condivisi, se procederai a ripristinare il tuo account.</string>
     <string name="ResetMyAccountWarning">Attenzione</string>
-    <string name="ResetMyAccountWarningText">Questa azione non può essere annullata.\n\n Se ripristini il tuo account, tutti i tuoi messaggi e chat saranno eliminati.</string>
+    <string name="ResetMyAccountWarningText">Questa azione non può essere annullata.\n\nSe ripristini il tuo account, tutti i tuoi messaggi e chat saranno eliminati.</string>
     <string name="ResetMyAccountWarningReset">Ripristina</string>
     <string name="LoginPassword">Password</string>
     <string name="LoginPasswordText">Hai attivato la verifica in due passaggi, così il tuo account è protetto con una password aggiuntiva.</string>
@@ -668,6 +726,7 @@
     <string name="Call">Chiama</string>
     <string name="Copy">Copia</string>
     <string name="Delete">Elimina</string>
+    <string name="DeleteAndStop">Elimina e arresta</string>
     <string name="Forward">Inoltra</string>
     <string name="Retry">Riprova</string>
     <string name="FromCamera">Dalla fotocamera</string>
@@ -722,12 +781,13 @@
     <string name="NoHandleAppInstalled">Non hai applicazioni che possono gestire il tipo di file \'%1$s\': installane una per proseguire</string>
     <string name="InviteUser">Questo utente non ha ancora Telegram, vuoi invitarlo?</string>
     <string name="AreYouSure">Sei sicuro?</string>
-    <string name="AddToTheGroupTitle">Aggiungere %1$s al gruppo %2$s?</string>
+    <string name="AddToTheGroupTitle">Aggiungere %1$s alla chat %2$s?</string>
     <string name="AddToTheGroupForwardCount">Numero di ultimi messaggi da inoltrare:</string>
     <string name="AddToTheGroup">Aggiungere %1$s al gruppo?</string>
     <string name="UserAlreadyInGroup">Questo utente è già membro del gruppo</string>
     <string name="ForwardMessagesTo">Vuoi inoltrare i messaggi a %1$s?</string>
     <string name="SendMessagesTo">Inviare i messaggi a %1$s?</string>
+    <string name="SendContactTo">Inviare contatto a %1$s?</string>
     <string name="AreYouSureLogout">Sei sicuro di volerti disconnettere?\n\nRicorda che puoi usare Telegram su tutti i tuoi dispositivi contemporaneamente.\n\nRicorda, quando ti disconnetti, elimini tutte le Chat Segrete.</string>
     <string name="AreYouSureSessions">Terminare tutte le altre sessioni?</string>
     <string name="AreYouSureDeleteAndExit">Sei sicuro di voler uscire ed eliminare il gruppo?</string>
@@ -739,12 +799,21 @@
     <string name="AreYouSureSecretChat">Iniziare una chat segreta?</string>
     <string name="AreYouSureRegistration">Sei sicuro di volere eliminare questa registrazione?</string>
     <string name="AreYouSureClearHistory">Sei sicuro di volere eliminare la cronologia?</string>
+    <string name="AreYouSureClearHistoryChannel">Eliminare tutti i messaggi e i media salvati nella cache per questo canale?</string>
+    <string name="AreYouSureClearHistorySuper">Eliminare tutti i messaggi e i media salvati nella cache per questo supergruppo?</string>
     <string name="AreYouSureDeleteMessages">Sei sicuro di voler eliminare %1$s?</string>
     <string name="SendMessagesToGroup">Inviare messaggi a %1$s?</string>
+    <string name="SendContactToGroup">Inviare contatto a %1$s?</string>
     <string name="ForwardMessagesToGroup">Inoltra messaggi a %1$s?</string>
     <string name="FeatureUnavailable">Spiacenti, questa funzione non è disponibile nel tuo paese.</string>
     <string name="NoUsernameFound">Non esiste alcun account Telegram con questo username.</string>
     <string name="BotCantJoinGroups">Questo bot non può unirsi ai gruppi.</string>
+    <!--permissions-->
+    <string name="PermissionContacts">Telegram deve accedere ai tuoi contatti per poterti connettere con i tuoi amici su tutti i tuoi dispositivi.</string>
+    <string name="PermissionStorage">Telegram deve accedere alla tua memoria per poter inviare e salvare foto,video, musica e altri media.</string>
+    <string name="PermissionNoAudio">Telegram deve accedere al microfono per poter inviare messaggi vocali.</string>
+    <string name="PermissionNoLocation">Telegram deve accedere alla tua posizione per poterla condividere con i tuoi amici.</string>
+    <string name="PermissionOpenSettings">IMPOSTAZIONI</string>
     <!--Intro view-->
     <string name="Page1Title">Telegram</string>
     <string name="Page2Title">Veloce</string>
@@ -882,6 +951,18 @@
     <string name="Photos_few">%1$d foto</string>
     <string name="Photos_many">%1$d foto</string>
     <string name="Photos_other">%1$d foto</string>
+    <string name="LastSeenMinutes_zero">ultimo accesso %1$d minuti fa</string>
+    <string name="LastSeenMinutes_one">ultimo accesso %1$d minuto fa</string>
+    <string name="LastSeenMinutes_two">ultimo accesso %1$d minuti fa</string>
+    <string name="LastSeenMinutes_few">ultimo accesso %1$d minuti fa</string>
+    <string name="LastSeenMinutes_many">ultimo accesso %1$d minuti fa</string>
+    <string name="LastSeenMinutes_other">ultimo accesso %1$d minuti fa</string>
+    <string name="LastSeenHours_zero">ultimo accesso %1$d ore fa</string>
+    <string name="LastSeenHours_one">ultimo accesso %1$d ora fa</string>
+    <string name="LastSeenHours_two">ultimo accesso %1$d ore fa</string>
+    <string name="LastSeenHours_few">ultimo accesso %1$d ore fa</string>
+    <string name="LastSeenHours_many">ultimo accesso %1$d ore fa</string>
+    <string name="LastSeenHours_other">ultimo accesso %1$d ore fa</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d messaggi inoltrati</string>
     <string name="ForwardedMessage_one">Messaggio inoltrato</string>
@@ -949,6 +1030,6 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s alle %2$s</string>
     <!--update text-->
-    <string name="updateText">Telegram per Android si è aggiornato. Nuovo nella versione 3.2.0:\n\n- Nuovi Canali - una nuova modalità per diffondere i tuoi messaggi ad un pubblico infinito (rimpiazzano le vecchie liste broadcast).\n\nPiù info: https://telegram.org/blog/channels</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">Telegram per Android si è aggiornato. Nuovo nella versione 3.3.2:\n\n- Gestione della cache: Controlla quanto spazio Telegram usa sul tuo dispositivo, elimina la cache per contenuti speicifici.\n- Elimina la cache per i supergruppi e i canali: Tieni premuto su di essi nella lista delle cache e premi \'Elimina dalla cache\'.\n- Gestione degli sticker: Riordina manualmente i tuoi pacchetti di sticker. L\'ordine dei pacchetti è ora sincronizzato tra tutti i dispositivi.\n\nPiù info su questo update:\nhttps://telegram.org/blog/cache-and-stickers</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-ko/strings.xml b/TMessagesProj/src/main/res/values-ko/strings.xml
index 7434f8a4e..7a3559531 100644
--- a/TMessagesProj/src/main/res/values-ko/strings.xml
+++ b/TMessagesProj/src/main/res/values-ko/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">텔레그램</string>
+    <string name="AppNameBeta">텔레그램 베타</string>
     <string name="LanguageName">한국어</string>
     <string name="LanguageNameInEnglish">Korean</string>
     <string name="LanguageCode">ko</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s님이 비밀대화에 참여했습니다.</string>
     <string name="EncryptedChatStartedIncoming">비밀대화에 참여했습니다.</string>
     <string name="ClearHistory">대화내용 지우기</string>
+    <string name="ClearHistoryCache">캐시에서 삭제</string>
     <string name="DeleteChat">채팅방 나가기</string>
     <string name="DeleteChatUser">이 대화 삭제</string>
     <string name="HiddenName">탈퇴한 계정</string>
@@ -60,7 +62,29 @@
     <string name="MuteDisable">비활성화</string>
     <string name="Hashtags">해시태그</string>
     <string name="Recent">최신</string>
+    <string name="LinkPreview">링크 미리복</string>
     <!--channels-->
+    <string name="SetAsAdmin">관리자로 지명</string>
+    <string name="DescriptionInfoMega">그룹에 추가 설명을 제공 할 수 있습니다.</string>
+    <string name="LeaveMega">그룹 나가기</string>
+    <string name="DeleteMega">그룹 삭제</string>
+    <string name="LeaveMegaMenu">그룹 나각</string>
+    <string name="DeleteMegaMenu">그룹 삭제</string>
+    <string name="MegaDeleteInfo">그룹에 있는 모든 메시지가 삭제됩니다.</string>
+    <string name="MegaAdminsInfo">그룹방 관리를 도울 수 있는 관리자를 추가 할 수 있습니다. 길게 탭을하면 관리자 삭제가 가능합니다.</string>
+    <string name="MegaDeleteAlert">이 그룹방을 삭제하실 경우 모든 구성원과 메시지를 삭제를 하게되며 복구가 안됩니다. 그래도 그룹방을 삭제하시겠습니까?</string>
+    <string name="ActionCreateMega">그룹 생성됨</string>
+    <string name="MegaAddedBy">이 그룹방에 un1님이 초대하였습니다.</string>
+    <string name="MegaLeaveAlert">정말 그룹방에서 나가겠습니까?</string>
+    <string name="GroupUserCantAdd">죄송합니다, 이 유저를 그룹에 초대할 수 없습니다.</string>
+    <string name="GroupUserAddLimit">죄송합니다, 그룹방의 인원이 최대치입니다.</string>
+    <string name="GroupUserLeftError">해당 유저가 스스로 그룹방에서 퇴장을 하여 다시 초대할 수 없습니다.</string>
+    <string name="GroupUserCantAdmin">죄송합니다, 그룹방에 너무 많은 관리자가 있습니다.</string>
+    <string name="GroupUserCantBot">죄송합니다, 그룹방에 너무 많은 봇이 있습니다.</string>
+    <string name="ActionMigrateFromGroup">이 그룹방은 슈퍼그룹방으로 업그레이드 되었습니다.</string>
+    <string name="ActionMigrateFromGroupNotify">%1$s 그룹방은 슈퍼그룹방으로 업그레이드 되었습니다.</string>
+  <string name="NoBlockedGroup">그룹방에서 차단되어 퇴장당한 사용자는 관리자가 초대해야지만 그룹방에 입장이 가능합니다.
+초대링크로는 초대가 되지 않습니다.</string>
     <string name="NewChannel">새 채널</string>
     <string name="EnterChannelName">채널명</string>
     <string name="Comments">코멘트들</string>
@@ -105,13 +129,14 @@
     <string name="ChannelLeaveAlert">채널에서 나가시겠습니까?</string>
     <string name="ChannelDeleteInfo">채널에 있는 모든 메시지가 삭제됩니다.</string>
     <string name="ChannelEdit">편집</string>
-    <string name="ChannelWasPrivateAlert">채널에 대한 공개링크를 선택하신 경우, 누구나 검색을 통하여 입장 가능합니다.\n\n비공개 채널로 유지를 하시고 싶으실 경우 링크 생성을 하지 말아주세요</string>
-    <string name="ChannelPublicEmptyUsername">유저들이 공개 채널에 대하여 검색 및 공유가 가능하도록 링크를 선택하여 주세요.\n\n채널을 공개하시지 싫으실 경우, 비공개 채널을 추천드립니다.</string>
+  <string name="ChannelWasPrivateAlert">채널에 대한 공개링크를 선택하신 경우, 누구나 검색을 통하여 입장 가능합니다.\n\n
+비공개 채널로 유지를 하시고 싶으실 경우 링크 생성을 하지 말아주세요</string>
+  <string name="ChannelPublicEmptyUsername">유저들이 공개 채널에 대하여 검색 및 공유가 가능하도록 링크를 선택하여 주세요.\n\n
+채널을 공개하시지 싫으실 경우, 비공개 채널을 추천드립니다.</string>
     <string name="ActionCreateChannel">채널 생성됨</string>
     <string name="ActionChannelChangedPhoto">채널 사진 업데이트됨</string>
     <string name="ActionChannelRemovedPhoto">채널 사진 삭제됨</string>
     <string name="ActionChannelChangedTitle">채널명이 un2로 변경됨</string>
-    <string name="ActionChannelInvite">un2채널에 un1님이 초대하였습니다.</string>
     <string name="ChannelPublicLimitReached">죄송하지만, 너무 많은 공개 채널을 생성하였습니다. 기존 공개 채널을 삭제하시거나 비공개 채널을 생성할 수 있습니다.</string>
     <string name="ChannelModerator">관리자</string>
     <string name="ChannelCreator">생성자</string>
@@ -127,11 +152,12 @@
     <string name="ChannelLinkInfo">텔레그램이 설치된 분들은 링크를 타고 채널에 참여가 가능합니다.</string>
     <string name="ChannelAdminsInfo">채널 관리를 도울 수 있는 관리자를 추가 할 수 있습니다. 길게 탭을하면 관리자 삭제가 가능합니다.</string>
     <string name="ChannelJoinTo">\'%1$s\'채널에 참여하시겠습니까?</string>
-    <string name="ChannelCantOpenPrivate">죄송합니다, 이 채널은 더 이상 접근이 불가능 합니다.</string>
-    <string name="ChannelAddToTitle">%2$s 채널에 %1$s님을 추가할까요?</string>
+    <string name="ChannelCantOpenPrivate">죄송합니다, 이 채팅방에 더 이상 접근이 불가능 합니다.</string>
     <string name="ChannelAddTo">%1$s 님을 이 채널에 추가할까요</string>
-    <string name="ChannelUserLeftError">해당 유저가 스스로 채널에서 퇴장을 하여 다시 초대할 수 없습니다.</string>
+    <string name="ChannelUserLeftError">해당 사용자가 스스로 채널에서 퇴장을 하여 다시 초대할 수 없습니다.</string>
     <string name="ChannelUserCantAdd">죄송합니다, 이 유저를 채널에 추가 할 수 없습니다.</string>
+    <string name="ChannelUserCantAdmin">죄송합니다, 채널에 너무 많은 관리자가 있습니다.</string>
+    <string name="ChannelUserCantBot">죄송합니다, 채널에 너무 많은 봇이 있습니다.</string>
     <string name="ChannelUserAddLimit">죄송합니다, 채널에는 첫 200명까지만 초대가 가능합니다. 채널 링크를 통하여 무제한 입장이 가능합니다.</string>
     <string name="ChannelAddedBy">이 채널에 un1님이 초대하였습니다.</string>
     <string name="ChannelJoined">채널에 참여하였습니다.</string>
@@ -147,14 +173,14 @@
     <string name="ChannelMessageGroupDocument">%1$s님이 %2$s 채널에 파일을 보냈습니다</string>
     <string name="ChannelMessageGroupAudio">%1$s님이 %2$s 채널에 오디오를 보냈습니다</string>
     <string name="ChannelMessageGroupSticker">%1$s님이 %2$s 채널에 스티커를 보냈습니다</string>
-    <string name="ChannelMessageNoText">%1$s채널에 새 메시지가 있습니다.</string>
-    <string name="ChannelMessagePhoto">%1$s채널에 새 사진이 있습니다.</string>
-    <string name="ChannelMessageVideo">%1$s채널에 새 비디오가 있습니다.</string>
-    <string name="ChannelMessageContact">%1$s채널에 새 연락처가 있습니다.</string>
-    <string name="ChannelMessageMap">%1$s채널에 새 위치가 있습니다.</string>
-    <string name="ChannelMessageDocument">%1$s채널에 새 파일이 있습니다.</string>
-    <string name="ChannelMessageAudio">%1$s채널에 새 음성 메시지가 있습니다.</string>
-    <string name="ChannelMessageSticker">%1$s채널에 새 스티커가 있습니다.</string>
+    <string name="ChannelMessageNoText">%1$s 님이 메시지를 보냈습니다</string>
+    <string name="ChannelMessagePhoto">%1$s 님이 사진을 보냈습니다</string>
+    <string name="ChannelMessageVideo">%1$s 님이 동영상을 보냈습니다</string>
+    <string name="ChannelMessageContact">%1$s님이 연락처를 공유했습니다</string>
+    <string name="ChannelMessageMap">%1$s님이 위치를 보냈습니다</string>
+    <string name="ChannelMessageDocument">%1$s 님이 파일을 보냈습니다</string>
+    <string name="ChannelMessageAudio">%1$s님이 음성메시지를 보냈습니다</string>
+    <string name="ChannelMessageSticker">%1$s님이 스티커를 보냈습니다</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">새 단체 메시지 리스트</string>
     <string name="EnterListName">리스트 이름을 입력하세요</string>
@@ -216,7 +242,7 @@
     <string name="EncryptedDescription2">서버에 어떤 흔적도 남기지 않습니다</string>
     <string name="EncryptedDescription3">일정 시간 후에 자동삭제가 가능합니다</string>
     <string name="EncryptedDescription4">전달 기능이 허용되지 않습니다</string>
-    <string name="YouWereKicked">그룹에서 추방되었습니다</string>
+    <string name="YouWereKicked">그룹에서 퇴장당했습니다.</string>
     <string name="YouLeft">그룹을 떠났습니다</string>
     <string name="DeleteThisGroup">이 그룹 삭제</string>
     <string name="DeleteThisChat">이 채팅방 삭제</string>
@@ -239,7 +265,9 @@
     <string name="ReportSpamAlertGroup">이 그룹 메시지를 스팸신고 하시겠습니까?</string>
     <string name="NobodyLikesSpam1">죄송합니다, 서로 연락처가 추가된 경우에만 메시지 전송이 가능합니다.</string>
     <string name="NobodyLikesSpam2">죄송합니다, 서로 연락처가 추가된 경우에만 그룹에 구성원을 추가 할 수 있습니다.</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq#can-39t-send-messages-to-non-contacts</string>
     <string name="MoreInfo">더 보기</string>
+    <string name="ShareSendTo">다음에게 보내기..</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s님이 자동삭제를 %2$s 후로 설정했습니다</string>
     <string name="MessageLifetimeChangedOutgoing">자동삭제를 %1$s 후로 설정했습니다</string>
@@ -269,8 +297,8 @@
     <string name="NotificationEditedGroupPhoto">%1$s님이 %2$s 그룹 사진을 변경했습니다</string>
     <string name="NotificationGroupAddMember">%1$s님이 %3$s님을 %2$s 그룹에 초대했습니다</string>
     <string name="NotificationGroupAddSelf">%1$s 님이 %2$s 그룹으로 되돌아왔습니다</string>
-    <string name="NotificationGroupKickMember">%1$s님이 %3$s님을 %2$s 그룹에서 추방했습니다</string>
-    <string name="NotificationGroupKickYou">%1$s님이 %2$s 그룹에서 추방했습니다</string>
+    <string name="NotificationGroupKickMember">%1$s님이 %3$s님을 %2$s 그룹에서 퇴장당했습니다.</string>
+    <string name="NotificationGroupKickYou">%1$s님이 %2$s 그룹에서 퇴장당했습니다.</string>
     <string name="NotificationGroupLeftMember">%1$s님이 %2$s 그룹을 떠났습니다</string>
     <string name="NotificationContactJoined">%1$s님이 텔레그램에 가입했습니다!</string>
     <string name="NotificationUnrecognizedDevice">%1$s님,\n%2$s에 새 기기에서 회원님의 계정 로그인이 감지되었습니다. \n\n기기: %3$s\n위치: %4$s\n\n본인의 접속이 아니라면  \'설정\' 창에서 \'모든 세션 종료\' 기능을 실행하세요.\n\n만약 강제접속 의심이 되신다면 2단계 인증을 설정 - 개인정보 및 보안에서 설정할 수 있습니다.\n\n감사합니다.\n텔레그램 팀</string>
@@ -289,6 +317,7 @@
     <string name="Online">온라인</string>
     <string name="LastSeen">마지막 접속: </string>
     <string name="LastSeenDate">마지막 접속: </string>
+    <string name="LastSeenNow">방금 전에 확인</string>
     <string name="InviteFriends">친구 초대</string>
     <string name="GlobalSearch">전체 검색</string>
     <string name="Lately">최근에 접속</string>
@@ -314,13 +343,22 @@
     <string name="CopyLink">링크 복사</string>
     <string name="ShareLink">링크 공유</string>
     <string name="LinkInfo">텔레그램이 설치된 분들은 링크를 타고 그룹방에 참여가 가능합니다.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">관리자 대화</string>
+    <string name="SetAdminsAll">모든 구성원이 관리자입니다.</string>
+    <string name="SetAdminsAllInfo">그룹에 있는 모든 구성원은 상대 초대, 이름 및 사진을 수정할 수 있습니다.</string>
+    <string name="SetAdminsNotAllInfo">그룹방에 있는 관리자만 구성원을 초대, 퇴장, 이름 편집 및 사진 수정할 수 있습니다.</string>
     <!--group info view-->
     <string name="SharedMedia">공유한 미디어</string>
     <string name="SETTINGS">설정</string>
     <string name="AddMember">대화상대 추가</string>
+    <string name="SetAdmins">관리자 설정</string>
     <string name="DeleteAndExit">그룹에서 나가기</string>
     <string name="Notifications">알림</string>
     <string name="KickFromGroup">그룹에서 내보내기</string>
+    <string name="ConvertGroup">슈퍼그룹방으로 업그레이드하기</string>
+    <string name="ConvertGroupAlert">슈퍼그룹방을 보려면 구성원들이 최신 텔레그램 버전으로 업데이트 해야합니다. 저암ㄹ로 그룹방을 업그레이드 하시겠습니까?</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>구성원이 최대치입니다.<![CDATA[</b>]]>\n\n추가 기능 및 더 많은 구성원을 추가하려면 슈퍼그룹방으로 업그레이드하세요:\n\n• 슈퍼그룹방은 %1$s명까지 초대가능합니다.\n• 새로운 구성원은 모든 대화내역을 볼 수 있습니다.\n• 관리자는 모두에게 메시지 삭제를 할 수 있습니다.\n• 기본값으로 알림이 음소거 됩니다.</string>
     <!--contact info view-->
     <string name="ShareContact">공유</string>
     <string name="AddContact">추가</string>
@@ -403,7 +441,6 @@
     <string name="TerminateAllSessions">다른 모든 세션 종료</string>
     <string name="Events">이벤트</string>
     <string name="ContactJoined">친구의 텔레그램 가입 알림</string>
-    <string name="Pebble">PEBBLE 스마트워치 지원</string>
     <string name="Language">언어</string>
     <string name="AskAQuestionInfo">텔레그램에 관한 질문은 자원봉사자들이 답변해 드립니다. 신속한 답변을 위해 노력하지만 답변이 다소 늦을 수 있습니다.<![CDATA[<br><br>]]>일반적인 문제와 <![CDATA[<a href=\"https://telegram.org/faq/ko#g\">해결방법</a>]]>에 대해서는 \'<![CDATA[<a href=\"https://telegram.org/faq/ko#a\">자주 묻는 질문</a>]]>\'을 확인해 보세요.</string>
     <string name="AskButton">질문하기</string>
@@ -465,6 +502,24 @@
     <string name="SmartNotificationsTimes">번</string>
     <string name="SmartNotificationsWithin">이내</string>
     <string name="SmartNotificationsMinutes">분</string>
+    <!--cache view-->
+    <string name="CacheSettings">캐시 설정</string>
+    <string name="LocalDatabase">로컬 데이터베이스</string>
+    <string name="LocalDatabaseClear">캐시된 텍스트 메시지를 삭제하시겠습니까?</string>
+    <string name="LocalDatabaseInfo">압축된 데이터베이스 및 캐시에 저장된 메시지를 로컬 데이터베이스에서 삭제하면 내부 저장공간이 증가합니다. 데이터베이스는 Telegram이 작동하는데 어느정도 필요함으로 완전히 삭제가 되지는 않습니다.\n\n이 작업은 완료되기까지 몇분정도 소요가 될 수 있습니다.</string>
+    <string name="ClearMediaCache">캐시 삭제</string>
+    <string name="CacheClear">삭제</string>
+    <string name="CalculatingSize">계산중...</string>
+    <string name="LocalDocumentCache">문서</string>
+    <string name="LocalPhotoCache">사진</string>
+    <string name="LocalAudioCache">음성 메시지</string>
+    <string name="LocalVideoCache">동영상</string>
+    <string name="LocalMusicCache">음악</string>
+    <string name="LocalCache">다른 파일</string>
+    <string name="CacheEmpty">없음</string>
+    <string name="KeepMedia">미디어 저장</string>
+    <string name="KeepMediaInfo">이 기간 동안 클라우드 채팅방에서  <![CDATA[<b>접근하지 않은</b>]]> 사진이나 동영상, 기타 파일 등은 공간 절약을 위해 이 기기에서 삭제됩니다.\n\n모든 파일은 Telegram 클라우드에 여전히 남으며 필요하시면 언제든 다시 다운로드하실 수 있습니다.</string>
+    <string name="KeepMediaForever">영원히</string>
     <!--sessions view-->
     <string name="SessionsTitle">활성화된 세션</string>
     <string name="CurrentSession">현재 세션</string>
@@ -493,11 +548,17 @@
     <string name="AutoLockInfo">일정 시간 후에 잠금코드 활성화</string>
     <string name="AutoLockInTime">%1$s 후에</string>
     <string name="AutoLockDisabled">비활성화됨</string>
+    <string name="UnlockFingerprint">지문으로 언락하기</string>
+    <string name="FingerprintInfo">지문인식 후 진행해주세요</string>
+    <string name="FingerprintHelp">터치 센서</string>
+    <string name="FingerprintNotRecognized">지문인식이 실패하였습니다. 다시 시도해주세요.</string>
     <!--media view-->
     <string name="NoMedia">이 채팅방에서 사진이나 동영상을 공유하면 다른 기기에서도 보실 수 있습니다.</string>
     <string name="DocumentsTitle">공유한 파일</string>
     <string name="SharedMediaTitle">공유된 미디어</string>
     <string name="LinksTitle">공유한 링크</string>
+    <string name="AudioTitle">공유된 음악</string>
+    <string name="NoSharedAudio">이 채팅방에서 음악을 공유하면 다른 기기에서도 보실 수 있습니다.</string>
     <string name="NoSharedFiles">이 채팅방에서 파일이나 문서를 공유하면 다른 기기에서도 보실 수 있습니다.</string>
     <string name="NoSharedLinks">이 채팅방에서 파일이나 문서를 공유하면 다른 기기에서도 보실 수 있습니다.</string>
     <!--map view-->
@@ -668,6 +729,7 @@
     <string name="Call">전화 걸기</string>
     <string name="Copy">복사</string>
     <string name="Delete">삭제</string>
+    <string name="DeleteAndStop">삭제 및 정지</string>
     <string name="Forward">전달</string>
     <string name="Retry">재전송</string>
     <string name="FromCamera">사진 촬영</string>
@@ -679,21 +741,21 @@
     <!--messages-->
     <string name="ActionInviteYou">초대링크를 타고 그룹에 참여하였습니다.</string>
     <string name="ActionInviteUser">초대링크를 타고 그룹에 un1님이 참여하였습니다.</string>
-    <string name="ActionKickUser">un1님이 un2님을 추방했습니다</string>
+    <string name="ActionKickUser">un1님이 un2님을 퇴장시켰습니다.</string>
     <string name="ActionLeftUser">un1님이 퇴장했습니다</string>
     <string name="ActionAddUser">un1님이 un2님을 초대했습니다</string>
     <string name="ActionRemovedPhoto">un1님이 그룹 사진을 삭제했습니다</string>
     <string name="ActionChangedPhoto">un1님이 그룹 사진을 변경했습니다</string>
     <string name="ActionChangedTitle">un1님이 그룹 이름을 un2 그룹으로 변경했습니다</string>
     <string name="ActionCreateGroup">un1님이 그룹을 만들었습니다</string>
-    <string name="ActionYouKickUser">un2님을 추방했습니다</string>
+    <string name="ActionYouKickUser">un2님을 퇴장시켰습니다.</string>
     <string name="ActionYouLeftUser">그룹을 떠났습니다</string>
     <string name="ActionYouAddUser">un2님을 초대했습니다</string>
     <string name="ActionYouRemovedPhoto">그룹 사진을 삭제했습니다</string>
     <string name="ActionYouChangedPhoto">그룹 사진을 변경했습니다</string>
     <string name="ActionYouChangedTitle">그룹 이름을 un2 그룹으로 변경했습니다</string>
     <string name="ActionYouCreateGroup">그룹을 만들었습니다</string>
-    <string name="ActionKickUserYou">un1님이 추방했습니다</string>
+    <string name="ActionKickUserYou">un1님이 퇴장당했습니다.</string>
     <string name="ActionAddUserYou">un1님이 그룹에 초대했습니다</string>
     <string name="ActionAddUserSelf">un1 님께서 그룹에 돌아오셨습니다</string>
     <string name="ActionAddUserSelfYou">그룹에 돌아오셨습니다.</string>
@@ -722,12 +784,13 @@
     <string name="NoHandleAppInstalled">\'%1$s\' 파일 형식을 처리할 앱이 없습니다. 계속하려면 앱을 설치해 주세요.</string>
     <string name="InviteUser">친구가 아직 텔레그램을 사용하지 않네요. 초대해 보세요!</string>
     <string name="AreYouSure">확실합니까?</string>
-    <string name="AddToTheGroupTitle">%2$s 그룹에 %1$s님을 추가할까요?</string>
+    <string name="AddToTheGroupTitle">%2$s 채팅방에 %1$s님을 추가할까요?</string>
     <string name="AddToTheGroupForwardCount">전달할 마지막 대화내용 개수:</string>
     <string name="AddToTheGroup">%1$s 님을 그룹에 추가할까요?</string>
     <string name="UserAlreadyInGroup">이 사용자는 이미 그룹에 추가되었습니다.</string>
     <string name="ForwardMessagesTo">%1$s님에게 메시지를 전달할까요?</string>
     <string name="SendMessagesTo">%1$s님에게 메시지를 보낼까요?</string>
+    <string name="SendContactTo">%1$s에게 연락처를 보내시겠습니까?</string>
     <string name="AreYouSureLogout">정말로 로그아웃하시겠습니까?\n\n텔레그램은 여러 기기에서 동시에 사용이 가능합니다.\n\n로그아웃하시면 비밀대화가 삭제되는 점 유의해주세요.</string>
     <string name="AreYouSureSessions">현재 기기를 제외하고 다른 기기에 로그인된 세션을 모두 종료시킬까요?</string>
     <string name="AreYouSureDeleteAndExit">그룹에서 나갈까요?</string>
@@ -739,12 +802,21 @@
     <string name="AreYouSureSecretChat">비밀대화를 시작할까요?</string>
     <string name="AreYouSureRegistration">정말로 가입을 취소하시겠습니까?</string>
     <string name="AreYouSureClearHistory">정말로 대화내용을 지우시겠습니까?</string>
+    <string name="AreYouSureClearHistoryChannel">채널에서 캐시된 모든 텍스트 및 미디어를 삭제하시겠습니까?</string>
+    <string name="AreYouSureClearHistorySuper">슈커그룹에서 캐시된 모든 텍스트 및 미디어를 삭제하시겠습니까?</string>
     <string name="AreYouSureDeleteMessages">%1$s: 정말로 삭제하시겠습니까?</string>
     <string name="SendMessagesToGroup">%1$s 그룹에 메시지를 보낼까요?</string>
+    <string name="SendContactToGroup">%1$s에게 연락처를 보내시겠습니까?</string>
     <string name="ForwardMessagesToGroup">%1$s 그룹에 메시지를 전달할까요?</string>
     <string name="FeatureUnavailable">이 기능은 회원님의 국가에서는 사용할 수 없습니다.</string>
     <string name="NoUsernameFound">입력된 아이디와 일치하는 텔레그램 계정이 없습니다.</string>
     <string name="BotCantJoinGroups">이 봇은 그룹에 참여 할 수 없습니다.</string>
+    <!--permissions-->
+    <string name="PermissionContacts">Telegram은 여러 기기에서 친구와 메시지를 주고받을 수 있도록 회원님의 연락처 접근이 필요합니다.</string>
+    <string name="PermissionStorage">Telegram은 사진, 비디오, 음악 및 다양한 미디어를 공유 및 저장하기 위하여 스토리지 접근이 필요합니다.</string>
+    <string name="PermissionNoAudio">Telegram이 음성 메시지를 보내기 위하여 마이크에 대한 접근이 필요합니다.</string>
+    <string name="PermissionNoLocation">Telegram이 위치를 친구분들과 공유하기 위해 위치에 대한 접근 권한을 필요로 합니다.</string>
+    <string name="PermissionOpenSettings">설정</string>
     <!--Intro view-->
     <string name="Page1Title">텔레그램</string>
     <string name="Page2Title">눈부신 속도</string>
@@ -882,6 +954,18 @@
     <string name="Photos_few">%1$d 개의 사진</string>
     <string name="Photos_many">%1$d 개의 사진</string>
     <string name="Photos_other">%1$d 개의 사진</string>
+    <string name="LastSeenMinutes_zero">%1$d 분 전에 확인</string>
+    <string name="LastSeenMinutes_one">%1$d 분 전에 확인</string>
+    <string name="LastSeenMinutes_two">%1$d 분 전에 확인</string>
+    <string name="LastSeenMinutes_few">%1$d 분 전에 확인</string>
+    <string name="LastSeenMinutes_many">%1$d 분 전에 확인</string>
+    <string name="LastSeenMinutes_other">%1$d 분 전에 확인</string>
+    <string name="LastSeenHours_zero">%1$d 시간 전에 확인</string>
+    <string name="LastSeenHours_one">%1$d 시간 전에 확인</string>
+    <string name="LastSeenHours_two">%1$d 시간 전에 확인</string>
+    <string name="LastSeenHours_few">%1$d 시간 전에 확인</string>
+    <string name="LastSeenHours_many">%1$d 시간 전에 확인</string>
+    <string name="LastSeenHours_other">%1$d 시간 전에 확인</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d 개의 전달된 메시지</string>
     <string name="ForwardedMessage_one">전달된 메시지</string>
@@ -949,6 +1033,6 @@
     <string name="formatterDay12H">a h:mm</string>
     <string name="formatDateAtTime">%1$s %2$s</string>
     <!--update text-->
-    <string name="updateText">텔레그램 안드로이드 버전이 업데이트 되었습니다. 새로운 버전은 3.2.0 입니다:\n\n-- 채널을 소개합니다. - 인원제한 없이 단체 메시지를 보낼 수 있는 새롭고 멋진 기능입니다. (기존 단체 메시지 대체)\n\nhttps://telegram.org/blog/channels에서 자세한 사항을 알아보세요.</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">텔레그램 안드로이드 버전이 업데이트 되었습니다. 새로운 버전은 3.3.2 입니다:\n\n- 캐시 관리: 저장소에서 텔레그램이 어느정도 사용하는지 관리가능, 각 기기에서 특정 컨텐츠 삭제 가능.\n- 슈퍼그룹 및 채널 캐시 삭제: 채팅목록에서 꾹 누르고 있으면 \'캐시에서 삭제\' 메뉴 선택 가능.\n- 스티커 관리: 수동으로 스티커팩 수정가능. 팩 순서는 모든 기기와 동기화 됩니다.\n\n자세한 업데이트는 https://telegram.org/blog/cache-and-stickers에서 확인하세요.</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-nl/strings.xml b/TMessagesProj/src/main/res/values-nl/strings.xml
index 214c19890..e79b0053b 100644
--- a/TMessagesProj/src/main/res/values-nl/strings.xml
+++ b/TMessagesProj/src/main/res/values-nl/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">Telegram</string>
+    <string name="AppNameBeta">Telegram-bèta</string>
     <string name="LanguageName">Nederlands</string>
     <string name="LanguageNameInEnglish">Dutch</string>
     <string name="LanguageCode">nl</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s neemt deel aan je geheime chat.</string>
     <string name="EncryptedChatStartedIncoming">Toegevoegd aan de geheime chat.</string>
     <string name="ClearHistory">Geschiedenis wissen</string>
+    <string name="ClearHistoryCache">Cache opschonen</string>
     <string name="DeleteChat">Verwijder en verlaat</string>
     <string name="DeleteChatUser">Chat verwijderen</string>
     <string name="HiddenName">Verwijderd account</string>
@@ -60,7 +62,28 @@
     <string name="MuteDisable">Uitschakelen</string>
     <string name="Hashtags">HASHTAGS</string>
     <string name="Recent">RECENT</string>
+    <string name="LinkPreview">Link-voorvertoning</string>
     <!--channels-->
+    <string name="SetAsAdmin">Promoveren tot beheerder</string>
+    <string name="DescriptionInfoMega">Optioneel kun je een groepsbeschrijving geven.</string>
+    <string name="LeaveMega">Groep verlaten</string>
+    <string name="DeleteMega">Groep verwijderen</string>
+    <string name="LeaveMegaMenu">Groep verlaten</string>
+    <string name="DeleteMegaMenu">Groep verwijderen</string>
+    <string name="MegaDeleteInfo">Je raakt alle berichten in deze groep kwijt.</string>
+    <string name="MegaAdminsInfo">Je kunt beheerders toevoegen om je te helpen je groep te beheren. Druk en houd ingedrukt om beheerders te verwijderen.</string>
+    <string name="MegaDeleteAlert">Groep echt verwijderen? Berichten worden gewist en alle deelnemers verwijderd.</string>
+    <string name="ActionCreateMega">Groep gemaakt</string>
+    <string name="MegaAddedBy">un1 heeft je toegevoegd aan deze groep</string>
+    <string name="MegaLeaveAlert">Groep echt verlaten?</string>
+    <string name="GroupUserCantAdd">Je kunt deze gebruiker niet toevoegen aan groepen.</string>
+    <string name="GroupUserAddLimit">Sorry, deze groep is vol.</string>
+    <string name="GroupUserLeftError">Deze gebruiker heeft de groep verlaten. Je kunt hem/haar niet meer uitnodigen.</string>
+    <string name="GroupUserCantAdmin">Maximaal aantal beheerders bereikt.</string>
+    <string name="GroupUserCantBot">Maximaal aantal bots bereikt.</string>
+    <string name="ActionMigrateFromGroup">De groep is opgewaardeerd naar een supergroep</string>
+    <string name="ActionMigrateFromGroupNotify">%1$s is opgewaardeerd naar een supergroep</string>
+    <string name="NoBlockedGroup">Geblokkeerde gebruikers kunnen alleen worden uitgenodigd door beheerders, uitnodigingslinks werken niet voor hen.</string>
     <string name="NewChannel">Nieuw kanaal</string>
     <string name="EnterChannelName">Kanaalnaam</string>
     <string name="Comments">Reacties</string>
@@ -101,9 +124,9 @@
     <string name="ChannelAdministrators">Beheerders</string>
     <string name="ChannelDelete">Kanaal verwijderen</string>
     <string name="ChannelDeleteMenu">Kanaal verwijderen</string>
-    <string name="ChannelDeleteAlert">Kanaal echt verwijderen? Berichten worden gewist en alle deelnemers worden verwijderd.</string>
+    <string name="ChannelDeleteAlert">Kanaal echt verwijderen? Berichten worden gewist en alle deelnemers verwijderd.</string>
     <string name="ChannelLeaveAlert">Kanaal echt verlaten?</string>
-    <string name="ChannelDeleteInfo">Je raakt alle berichten in de kanaal kwijt.</string>
+    <string name="ChannelDeleteInfo">Je raakt alle berichten in dit kanaal kwijt.</string>
     <string name="ChannelEdit">Wijzig</string>
     <string name="ChannelWasPrivateAlert">Als je een publieke link voor je kanaal instelt kan iedereen deze vinden en deelnemen via de zoekfunctie.\n\nStel geen link in als je je kanaal privé wilt houden.</string>
     <string name="ChannelPublicEmptyUsername">Stel een link in voor je publieke kanaal, om deze vindbaar te maken via de zoekfunctie en te delen met anderen.\n\nWil je dit niet dan kun je een privé-kanaal aanmaken.</string>
@@ -111,7 +134,6 @@
     <string name="ActionChannelChangedPhoto">Kanaalfoto bijgewerkt</string>
     <string name="ActionChannelRemovedPhoto">Kanaalfoto verwijderd</string>
     <string name="ActionChannelChangedTitle">Kanaalnaam gewijzigd naar un2</string>
-    <string name="ActionChannelInvite">un1 heeft je toegevoegd aan kanaal un2</string>
     <string name="ChannelPublicLimitReached">Het maximale aantal publieke kanalen is bereikt. Je kunt een privé-kanaal maken of een kanaal verwijderen om een nieuwe te maken.</string>
     <string name="ChannelModerator">Moderator</string>
     <string name="ChannelCreator">Maker</string>
@@ -127,17 +149,18 @@
     <string name="ChannelLinkInfo">Andere Telegram-gebruikers kunnen aan je groep deelnemen door deze link te openen.</string>
     <string name="ChannelAdminsInfo">Je kunt beheerders toevoegen om je te helpen je kanaal te beheren. Druk en houd ingedrukt om beheerders te verwijderen.</string>
     <string name="ChannelJoinTo">Deelnemen aan kanaal \'%1$s\'?</string>
-    <string name="ChannelCantOpenPrivate">Sorry, dit kanaal is niet beschikbaar.</string>
-    <string name="ChannelAddToTitle">%1$s toevoegen aan het kanaal %2$s?</string>
+    <string name="ChannelCantOpenPrivate">Sorry, deze chat is niet beschikbaar.</string>
     <string name="ChannelAddTo">%1$s toevoegen aan het kanaal?</string>
-    <string name="ChannelUserLeftError">Deze gebruiker heeft de groep verlaten. Je kunt hem/haar niet meer uitnodigen.</string>
+    <string name="ChannelUserLeftError">Deze gebruiker heeft het kanaal verlaten. Je kunt hem/haar niet meer uitnodigen.</string>
     <string name="ChannelUserCantAdd">Je kunt deze gebruiker niet toevoegen aan kanalen.</string>
+    <string name="ChannelUserCantAdmin">Maximaal aantal beheerders bereikt.</string>
+    <string name="ChannelUserCantBot">Maximaal aantal bots bereikt.</string>
     <string name="ChannelUserAddLimit">Je kunt  200 deelnemers handmatig toevoegen aan een kanaal. Een ongelimiteerd aantal mensen kan deelnemen via de link van het kanaal.</string>
     <string name="ChannelAddedBy">un1 heeft je toegevoegd aan dit kanaal</string>
     <string name="ChannelJoined">Je neemt deel aan het kanaal</string>
     <string name="ChannelRemoveUser">Verwijderen uit kanaal</string>
     <string name="ChannelCantSendMessage">Je hebt alleen leesrechten in dit kanaal.</string>
-    <string name="ChannelAddedByNotification">%1$s heeft je toegevoegd aan kanaal %2$s</string>
+    <string name="ChannelAddedByNotification">%1$s heeft je toegevoegd aan het kanaal %2$s</string>
     <string name="ChannelPhotoEditNotification">Kanaalfoto van %1$s bijgewerkt</string>
     <string name="ChannelMessageGroupNoText">%1$s heeft een bericht gestuurd naar het kanaal %2$s</string>
     <string name="ChannelMessageGroupPhoto">%1$s heeft een foto gestuurd naar het kanaal %2$s</string>
@@ -147,14 +170,14 @@
     <string name="ChannelMessageGroupDocument">%1$s heeft een bestand gestuurd naar het kanaal %2$s</string>
     <string name="ChannelMessageGroupAudio">%1$s heeft een geluidsbestand gestuurd naar het kanaal %2$s</string>
     <string name="ChannelMessageGroupSticker">%1$s heeft een sticker gestuurd naar het kanaal %2$s</string>
-    <string name="ChannelMessageNoText">Nieuw bericht in het kanaal %1$s</string>
-    <string name="ChannelMessagePhoto">Nieuwe foto in het kanaal %1$s</string>
-    <string name="ChannelMessageVideo">Nieuwe video in het kanaal %1$s</string>
-    <string name="ChannelMessageContact">Contact gedeeld in het kanaal %1$s</string>
-    <string name="ChannelMessageMap">Nieuwe locatie gedeeld in het kanaal %1$s</string>
-    <string name="ChannelMessageDocument">Nieuw bestand gedeeld in het kanaal %1$s</string>
-    <string name="ChannelMessageAudio">Nieuw geluidsbestand gedeeld in het kanaal %1$s</string>
-    <string name="ChannelMessageSticker">Nieuwe sticker gedeeld in het kanaal %1$s</string>
+    <string name="ChannelMessageNoText">%1$s plaatste een bericht</string>
+    <string name="ChannelMessagePhoto">%1$s plaatste een foto</string>
+    <string name="ChannelMessageVideo">%1$s plaatste een video</string>
+    <string name="ChannelMessageContact">%1$s plaatste een contact</string>
+    <string name="ChannelMessageMap">%1$s plaatste een locatie</string>
+    <string name="ChannelMessageDocument">%1$s plaatste een bestand</string>
+    <string name="ChannelMessageAudio">%1$s plaatste een spraakbericht</string>
+    <string name="ChannelMessageSticker">%1$s plaatste een sticker</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">Nieuwe verzendlijst</string>
     <string name="EnterListName">Naam van lijst</string>
@@ -239,7 +262,9 @@
     <string name="ReportSpamAlertGroup">Spam van deze groep echt melden? </string>
     <string name="NobodyLikesSpam1">Je kunt momenteel alleen berichten sturen aan onderlingen contacten.</string>
     <string name="NobodyLikesSpam2">Je kunt momenteel alleen onderlinge contacten aan groepen toevoegen</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq#can-39t-send-messages-to-non-contacts</string>
     <string name="MoreInfo">Meer informatie</string>
+    <string name="ShareSendTo">Versturen naar...</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s heeft de zelfvernietigingstimer ingesteld op %2$s</string>
     <string name="MessageLifetimeChangedOutgoing">Je hebt de zelfvernietigingstimer ingesteld op %1$s</string>
@@ -289,6 +314,7 @@
     <string name="Online">online</string>
     <string name="LastSeen">gezien</string>
     <string name="LastSeenDate">gezien</string>
+    <string name="LastSeenNow">laatst gezien zojuist</string>
     <string name="InviteFriends">Vrienden uitnodigen</string>
     <string name="GlobalSearch">WERELDWIJD ZOEKEN</string>
     <string name="Lately">recent gezien</string>
@@ -314,13 +340,22 @@
     <string name="CopyLink">Link kopiëren</string>
     <string name="ShareLink">Link delen</string>
     <string name="LinkInfo">Andere Telegram-gebruikers kunnen aan je groep deelnemen door deze link te openen.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">Beheerders</string>
+    <string name="SetAdminsAll">Iedereen is beheerder</string>
+    <string name="SetAdminsAllInfo">Iedereen mag deelnemers toevoegen en de groepsfoto of naam wijzigen.</string>
+    <string name="SetAdminsNotAllInfo">Beheerders mogen deelnemers beheren en de groepsfoto of naam wijzigen.</string>
     <!--group info view-->
     <string name="SharedMedia">Gedeelde media</string>
     <string name="SETTINGS">Instellingen</string>
     <string name="AddMember">Deelnemer toevoegen</string>
+    <string name="SetAdmins">Beheerders instellen</string>
     <string name="DeleteAndExit">Groep verwijderen en verlaten</string>
     <string name="Notifications">Meldingen</string>
     <string name="KickFromGroup">Verwijderen uit groep</string>
+    <string name="ConvertGroup">Opwaarderen naar supergroep</string>
+    <string name="ConvertGroupAlert">Groepsdeelnemers moeten updaten naar de meest recente Telegram om je supergroep te kunnen zien. Groep echt opwaarderen?</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>Deelnemerslimiet bereikt.<![CDATA[</b>]]>\n\nWil je extra functies en een hogere limiet? Waardeer op naar een supergroep:\n\n• Supergroepen hebben tot %1$s\n• Nieuwe leden zien de hele geschiedenis\n• Beheerder wist berichten voor iedereen\n• Meldingen staan standaard uit</string>
     <!--contact info view-->
     <string name="ShareContact">Delen</string>
     <string name="AddContact">Toevoegen</string>
@@ -403,9 +438,8 @@
     <string name="TerminateAllSessions">Beëindig alle andere sessies</string>
     <string name="Events">Gebeurtenissen</string>
     <string name="ContactJoined">Contact lid van Telegram</string>
-    <string name="Pebble">PEBBLE</string>
     <string name="Language">Taal</string>
-    <string name="AskAQuestionInfo">De ondersteuning van Telegram wordt gedaan door vrijwilligers. We doen ons best om zo snel mogelijk te antwoorden.<![CDATA[<br><br>]]>Bekijk ook de <![CDATA[<a href=\"https://telegram.org/faq#general\">veelgestelde vragen</a>]]>: Hierhier staan de antwoorden op de meeste vragen en belangrijke tips voor <![CDATA[<a href=\"https://telegram.org/faq#troubleshooting\">het oplossen van problemen</a>]]>.</string>
+    <string name="AskAQuestionInfo">De ondersteuning van Telegram wordt gedaan door vrijwilligers. We doen ons best om zo snel mogelijk te antwoorden.<![CDATA[<br><br>]]>Bekijk ook de <![CDATA[<a href=\"https://telegram.org/faq#general\">veelgestelde vragen</a>]]>: Hier staan de antwoorden op de meeste vragen en belangrijke tips voor <![CDATA[<a href=\"https://telegram.org/faq#troubleshooting\">het oplossen van problemen</a>]]>.</string>
     <string name="AskButton">Vraag een vrijwilliger</string>
     <string name="TelegramFaq">Veelgestelde vragen</string>
     <string name="TelegramFaqUrl">https://telegram.org/faq</string>
@@ -428,7 +462,7 @@
     <string name="BadgeNumber">Badgenummer</string>
     <string name="Short">Kort</string>
     <string name="Long">Lang</string>
-    <string name="SystemDefault">Standaardinstelling</string>
+    <string name="SystemDefault">Systeeminstelling</string>
     <string name="SettingsDefault">Standaardinstelling</string>
     <string name="AutomaticMediaDownload">Automatisch media downloaden</string>
     <string name="WhenUsingMobileData">Bij mobiele verbinding</string>
@@ -465,6 +499,24 @@
     <string name="SmartNotificationsTimes">keer</string>
     <string name="SmartNotificationsWithin">binnen</string>
     <string name="SmartNotificationsMinutes">minuten</string>
+    <!--cache view-->
+    <string name="CacheSettings">Cache-instellingen</string>
+    <string name="LocalDatabase">Lokale database</string>
+    <string name="LocalDatabaseClear">Gecachet tekstberichten wissen?</string>
+    <string name="LocalDatabaseInfo">Het opschonen van de lokale database zal de tekst van gecachet berichten verwijderen en de database comprimeren om ruimte te besparen. Telegram heeft wat ruimte nodig om te kunnen functioneren, dus de databasegrootte zal nooit nul worden.\n\nDit kan enkele minuten duren.</string>
+    <string name="ClearMediaCache">Cache opschonen</string>
+    <string name="CacheClear">Opschonen</string>
+    <string name="CalculatingSize">Berekenen...</string>
+    <string name="LocalDocumentCache">Bestanden</string>
+    <string name="LocalPhotoCache">Foto\'s</string>
+    <string name="LocalAudioCache">Spraakberichten</string>
+    <string name="LocalVideoCache">Video\'s</string>
+    <string name="LocalMusicCache">Muziek</string>
+    <string name="LocalCache">Overige bestanden</string>
+    <string name="CacheEmpty">Leeg</string>
+    <string name="KeepMedia">Media bewaren</string>
+    <string name="KeepMediaInfo">Foto\'s, video\'s en andere bestanden uit cloudchats die je gedurende deze periode niet hebt  <![CDATA[<b>geopend</b>]]> zullen worden verwijderd van dit apparaat om ruimte te besparen.\n\nAlle media zal in de Telegram-cloud bewaard blijven en kan opnieuw worden gedownload als je het weer nodig hebt.</string>
+    <string name="KeepMediaForever">Voor altijd</string>
     <!--sessions view-->
     <string name="SessionsTitle">Actieve sessies</string>
     <string name="CurrentSession">Huidige sessie</string>
@@ -493,11 +545,17 @@
     <string name="AutoLockInfo">Vraag om toegangscode indien afwezig</string>
     <string name="AutoLockInTime">over %1$s</string>
     <string name="AutoLockDisabled">Uitgeschakeld</string>
+    <string name="UnlockFingerprint">Ontgrendel met vingerafdruk</string>
+    <string name="FingerprintInfo">Vingerafdruk bevestigen</string>
+    <string name="FingerprintHelp">Vingerafdruksensor</string>
+    <string name="FingerprintNotRecognized">Vingerafdruk niet herkend,  probeer opnieuw</string>
     <!--media view-->
     <string name="NoMedia">Deel foto\'s en video\'s in deze chat om ze op al je apparaten te kunnen benaderen.</string>
     <string name="DocumentsTitle">Gedeelde bestanden</string>
     <string name="SharedMediaTitle">Gedeelde media</string>
     <string name="LinksTitle">Gedeelde links</string>
+    <string name="AudioTitle">Gedeelde muziek</string>
+    <string name="NoSharedAudio">Deel muziek in deze chat om ze op al je apparaten te kunnen benaderen.</string>
     <string name="NoSharedFiles">Deel bestanden en documenten in deze chat om ze op al je apparaten te kunnen benaderen.</string>
     <string name="NoSharedLinks">Deel links in deze chat om ze op al je apparaten te kunnen benaderen.</string>
     <!--map view-->
@@ -668,6 +726,7 @@
     <string name="Call">Bellen</string>
     <string name="Copy">Kopieer</string>
     <string name="Delete">Verwijder</string>
+    <string name="DeleteAndStop">Verwijderen en stoppen</string>
     <string name="Forward">Doorsturen</string>
     <string name="Retry">Opnieuw proberen</string>
     <string name="FromCamera">Van camera</string>
@@ -728,6 +787,7 @@
     <string name="UserAlreadyInGroup">Gebruiker neemt al deel aan de groep</string>
     <string name="ForwardMessagesTo">Berichten doorsturen naar %1$s?</string>
     <string name="SendMessagesTo">Berichten naar %1$s versturen?</string>
+    <string name="SendContactTo">Contact delen met %1$s?</string>
     <string name="AreYouSureLogout">Weet je zeker dat je wilt uitloggen?\n\nTelegram kun je naadloos op al je apparaten tegelijkertijd gebruiken.\n\nLet op! Als je uitlogt worden al je geheime chats verwijderd.</string>
     <string name="AreYouSureSessions">Alle apparaten behalve het huidige apparaat uitloggen?</string>
     <string name="AreYouSureDeleteAndExit">Verwijderen en de groep verlaten?</string>
@@ -739,12 +799,21 @@
     <string name="AreYouSureSecretChat">Weet je zeker dat je een geheime chat wilt starten?</string>
     <string name="AreYouSureRegistration">Weet je zeker dat je de registratie wilt annuleren?</string>
     <string name="AreYouSureClearHistory">Geschiedenis echt wissen? </string>
+    <string name="AreYouSureClearHistoryChannel">Kanaalcache opschonen?</string>
+    <string name="AreYouSureClearHistorySuper">Supergroepcache echt opschonen?</string>
     <string name="AreYouSureDeleteMessages">%1$s echt verwijderen?</string>
     <string name="SendMessagesToGroup">Berichten naar %1$s versturen?</string>
+    <string name="SendContactToGroup">Contact delen met %1$s?</string>
     <string name="ForwardMessagesToGroup">Berichten doorsturen naar %1$s?</string>
     <string name="FeatureUnavailable">Sorry, deze functie is momenteel niet beschikbaar in jouw land.</string>
     <string name="NoUsernameFound">Er is geen Telegram-account met deze gebruikersnaam.</string>
     <string name="BotCantJoinGroups">Deze bot kan geen groepslid worden.</string>
+    <!--permissions-->
+    <string name="PermissionContacts">Telegram heeft toegang tot je contacten nodig zodat je kan chatten met je vrienden vanaf al je apparaten.</string>
+    <string name="PermissionStorage">Telegram heeft toegang tot je opslaggeheugen nodig zodat je foto\'s, video\'s, muziek en andere media kunt opslaan en versturen.</string>
+    <string name="PermissionNoAudio">Telegram heeft toegang tot je microfoon nodig om spraakberichten te kunnen verzenden.</string>
+    <string name="PermissionNoLocation">Telegram heeft toegang tot je locatie nodig om deze te kunnen delen met je vrienden.</string>
+    <string name="PermissionOpenSettings">INSTELLINGEN</string>
     <!--Intro view-->
     <string name="Page1Title">Telegram</string>
     <string name="Page2Title">Snel</string>
@@ -775,7 +844,7 @@
     <string name="Members_many">%1$d deelnemers</string>
     <string name="Members_other">%1$d deelnemers</string>
     <string name="AndMoreTyping_zero">en nog %1$d personen zijn aan het typen</string>
-    <string name="AndMoreTyping_one">en nog %1$d personen zijn aan het typen</string>
+    <string name="AndMoreTyping_one">en nog %1$d persoon is aan het typen</string>
     <string name="AndMoreTyping_two">en nog %1$d personen zijn aan het typen</string>
     <string name="AndMoreTyping_few">en nog %1$d personen zijn aan het typen</string>
     <string name="AndMoreTyping_many">en nog %1$d personen zijn aan het typen</string>
@@ -793,7 +862,7 @@
     <string name="messages_many">%1$d berichten</string>
     <string name="messages_other">%1$d berichten</string>
     <string name="comments_zero">%1$d reacties</string>
-    <string name="comments_one">%1$d reacties</string>
+    <string name="comments_one">%1$d reactie</string>
     <string name="comments_two">%1$d reacties</string>
     <string name="comments_few">%1$d reacties</string>
     <string name="comments_many">%1$d reacties</string>
@@ -882,6 +951,18 @@
     <string name="Photos_few">%1$d foto\'s</string>
     <string name="Photos_many">%1$d foto\'s</string>
     <string name="Photos_other">%1$d foto\'s</string>
+    <string name="LastSeenMinutes_zero">laatst gezien %1$d min geleden</string>
+    <string name="LastSeenMinutes_one">laatst gezien %1$d minuut geleden</string>
+    <string name="LastSeenMinutes_two">laatst gezien %1$d min geleden</string>
+    <string name="LastSeenMinutes_few">laatst gezien %1$d min geleden</string>
+    <string name="LastSeenMinutes_many">laatst gezien %1$d min geleden</string>
+    <string name="LastSeenMinutes_other">laatst gezien %1$d min geleden</string>
+    <string name="LastSeenHours_zero">laatst gezien %1$d uur geleden</string>
+    <string name="LastSeenHours_one">laatst gezien %1$d uur geleden</string>
+    <string name="LastSeenHours_two">laatst gezien %1$d uur geleden</string>
+    <string name="LastSeenHours_few">laatst gezien %1$d uur geleden</string>
+    <string name="LastSeenHours_many">laatst gezien %1$d uur geleden</string>
+    <string name="LastSeenHours_other">laatst gezien %1$d uur geleden</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">Bijlage: %1$d berichten</string>
     <string name="ForwardedMessage_one">Bijlage: 1 bericht</string>
@@ -901,7 +982,7 @@
     <string name="ForwardedPhoto_few">Bijlage: %1$d foto\'s</string>
     <string name="ForwardedPhoto_many">Bijlage: %1$d foto\'s</string>
     <string name="ForwardedPhoto_other">Bijlage: %1$d foto\'s</string>
-    <string name="ForwardedVideo_zero">Bijlage: %1$d foto\'s</string>
+    <string name="ForwardedVideo_zero">Bijlage: %1$d video\'s</string>
     <string name="ForwardedVideo_one">Bijlage: 1 video</string>
     <string name="ForwardedVideo_two">Bijlage: %1$d video\'s</string>
     <string name="ForwardedVideo_few">Bijlage: %1$d video\'s</string>
@@ -949,6 +1030,6 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s om %2$s</string>
     <!--update text-->
-    <string name="updateText">Telegram voor Android is bijgewerkt. Nieuw in versie 3.2.0:\n\n- Nieuw, kanalen - een perfecte manier om berichten naar een ongelimiteerd publiek te versturen (vervangt de oude verzendlijsten).\n\nMeer over deze update: https://telegram.org/blog/channels</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">Telegram voor Android is bijgewerkt. Nieuw in versie 3.3.2:\n\n- Cache-beheer: Meer controle over het ruimtegebruik van Telegram op je apparaat, je kunt de cache nu ook per soort content opschonen.\n- Cache verwijderen van supergroepen en kanalen? Tik ze aan en hou ze vast in het chats-overzicht, daarna: \'Cache opschonen\'.\n- Stickerbeheer: je kunt nu handmatig je stickerbundels sorteren, de volgorde synchroniseren we voor je, over al je apparaten.\n\nMeer weten? Kijk op:\nhttps://telegram.org/blog/cache-and-stickers</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-pt-rBR/strings.xml b/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
index 594158f59..ebe8ddb55 100644
--- a/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
+++ b/TMessagesProj/src/main/res/values-pt-rBR/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">Telegram</string>
+    <string name="AppNameBeta">Telegram Beta</string>
     <string name="LanguageName">Português (Brasil)</string>
     <string name="LanguageNameInEnglish">Português (Brasil)</string>
     <string name="LanguageCode">pt_BR</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s entrou no chat secreto</string>
     <string name="EncryptedChatStartedIncoming">Você entrou no chat secreto</string>
     <string name="ClearHistory">Limpar histórico</string>
+    <string name="ClearHistoryCache">Apagar do cache</string>
     <string name="DeleteChat">Apagar e sair</string>
     <string name="DeleteChatUser">Apagar conversa</string>
     <string name="HiddenName">Conta Excluída</string>
@@ -60,12 +62,33 @@
     <string name="MuteDisable">Desativar</string>
     <string name="Hashtags">HASHTAGS</string>
     <string name="Recent">RECENTE</string>
+    <string name="LinkPreview">Prévia do link</string>
     <!--channels-->
+    <string name="SetAsAdmin">Promover a administrador</string>
+    <string name="DescriptionInfoMega">Você pode fornecer uma descrição opcional para seu grupo.</string>
+    <string name="LeaveMega">Sair do Grupo</string>
+    <string name="DeleteMega">Apagar Grupo</string>
+    <string name="LeaveMegaMenu">Sair do Grupo</string>
+    <string name="DeleteMegaMenu">Apagar Grupo</string>
+    <string name="MegaDeleteInfo">Você perderá todas as mensagens neste grupo.</string>
+    <string name="MegaAdminsInfo">Você pode adicionar administradores para ajudar você a gerenciar seu grupo. Toque e segure para removê-los.</string>
+    <string name="MegaDeleteAlert">Espere! Apagar este grupo removerá todos os membros e todas as mensagens serão perdidas. Apagar o grupo mesmo assim?</string>
+    <string name="ActionCreateMega">Grupo criado</string>
+    <string name="MegaAddedBy">un1 adicionou você ao grupo</string>
+    <string name="MegaLeaveAlert">Você tem certeza que deseja sair do grupo?</string>
+    <string name="GroupUserCantAdd">Desculpe, você não pode adicionar este usuário a grupos.</string>
+    <string name="GroupUserAddLimit">Desculpe, este grupo está cheio.</string>
+    <string name="GroupUserLeftError">Desculpe, este usuário decidiu sair deste grupo, de maneira que você não pode convidá-lo de volta.</string>
+    <string name="GroupUserCantAdmin">Desculpe, há administradores demais neste grupo.</string>
+    <string name="GroupUserCantBot">Desculpe, há bots demais neste grupo.</string>
+    <string name="ActionMigrateFromGroup">Este grupo foi atualizado para um supergrupo</string>
+    <string name="ActionMigrateFromGroupNotify">%1$s foi atualizado para um supergrupo</string>
+    <string name="NoBlockedGroup">Usuários bloqueados são removidos do grupo e só podem voltar se convidados por um administrador. Convites por link não funcionam para eles.</string>
     <string name="NewChannel">Novo Canal</string>
     <string name="EnterChannelName">Nome do canal</string>
     <string name="Comments">Comentários</string>
     <string name="CommentsInfo">Se você habilitar comentários, pessoas poderão discutir seu post no canal.</string>
-    <string name="AddMutual">Adicionar contatos para o seu canal</string>
+    <string name="AddMutual">Adicionar contatos no canal</string>
     <string name="ChannelUsernameHelp">Pessoas podem compartilhar esse link com outros e encontrar seu canal usando a busca do Telegram.</string>
     <string name="ChannelUsernamePlaceholder">link</string>
     <string name="ChannelPrivateLinkHelp">Pessoas podem entrar em seu canal com este link. Você pode desativar o link quando quiser.</string>
@@ -83,7 +106,7 @@
     <string name="ChannelSettings">Configurações</string>
     <string name="ChannelJoin">ENTRAR</string>
     <string name="OpenChannelProfile">Info do Canal</string>
-    <string name="ChannelBroadcast">Tramissão</string>
+    <string name="ChannelBroadcast">Transmissão</string>
     <string name="ChannelComment">Comentário</string>
     <string name="ShowDiscussion">mostrar comentários</string>
     <string name="ChannelAlertTitle">O que é um Canal?</string>
@@ -97,7 +120,7 @@
     <string name="LinkChecking">Verificando nome...</string>
     <string name="LinkAvailable">%1$s está disponível.</string>
     <string name="ChannelMembers">Membros</string>
-    <string name="ChannelBlockedUsers">Usuários Bloqueados</string>
+    <string name="ChannelBlockedUsers">Usuários bloqueados</string>
     <string name="ChannelAdministrators">Administradores</string>
     <string name="ChannelDelete">Apagar Canal</string>
     <string name="ChannelDeleteMenu">Apagar Canal</string>
@@ -111,7 +134,6 @@
     <string name="ActionChannelChangedPhoto">Foto do canal alterada</string>
     <string name="ActionChannelRemovedPhoto">Foto do canal removida</string>
     <string name="ActionChannelChangedTitle">Nome do canal alterado para un2</string>
-    <string name="ActionChannelInvite">un1 adicionado ao canal un2</string>
     <string name="ChannelPublicLimitReached">Desculpe, você criou muitos canais públicos. Você pode criar um canal privado ou apagar um de seus canais existentes primeiro.</string>
     <string name="ChannelModerator">Moderador</string>
     <string name="ChannelCreator">Criador</string>
@@ -127,11 +149,12 @@
     <string name="ChannelLinkInfo">Qualquer um com Telegram instalado poderá entrar no seu canal abrindo este link.</string>
     <string name="ChannelAdminsInfo">Você pode adicionar administradores para ajudar você a gerenciar seu canal. Aperte e segure para removê-los.</string>
     <string name="ChannelJoinTo">Você deseja entrar no canal \'%1$s\'?</string>
-    <string name="ChannelCantOpenPrivate">Desculpe, esse canal não é acessível.</string>
-    <string name="ChannelAddToTitle">Adicionar %1$s ao grupo %2$s?</string>
+    <string name="ChannelCantOpenPrivate">Desculpe, esta conversa não pode mais ser acessada.</string>
     <string name="ChannelAddTo">Adicionar %1$s ao canal?</string>
-    <string name="ChannelUserLeftError">Desculpe, esse usuário decidiu sair do grupo, você não pode adicioná-lo novamente.</string>
+    <string name="ChannelUserLeftError">Desculpe, este usuário decidiu sair deste canal, então você não pode convidá-lo de volta.</string>
     <string name="ChannelUserCantAdd">Desculpe, você não pode adicionar esse usuário em canais.</string>
+    <string name="ChannelUserCantAdmin">Desculpe, muitos administradores nesse canal.</string>
+    <string name="ChannelUserCantBot">Desculpe, há bots demais neste canal.</string>
     <string name="ChannelUserAddLimit">Desculpe, você só pode adicionar os primeiros 200 membros ao canal. Note que um número ilimitado de pessoas podem entrar via link do canal.</string>
     <string name="ChannelAddedBy">un1 adicionou você ao canal</string>
     <string name="ChannelJoined">Você entrou no canal</string>
@@ -147,14 +170,14 @@
     <string name="ChannelMessageGroupDocument">%1$s enviou um arquivo ao canal %2$s</string>
     <string name="ChannelMessageGroupAudio">%1$s enviou um áudio ao canal %2$s</string>
     <string name="ChannelMessageGroupSticker">%1$s enviou um sticker ao canal %2$s</string>
-    <string name="ChannelMessageNoText">Nova mensagem no canal %1$s</string>
-    <string name="ChannelMessagePhoto">Nova foto no canal %1$s</string>
-    <string name="ChannelMessageVideo">Novo vídeo no canal %1$s</string>
-    <string name="ChannelMessageContact">Contato compartilhado no canal %1$s</string>
-    <string name="ChannelMessageMap">Nova localização compartilhada no canal %1$s</string>
-    <string name="ChannelMessageDocument">Novo arquivo compartilhado no canal %1$s</string>
-    <string name="ChannelMessageAudio">Nova mensagem de voz compartilhada no canal %1$s</string>
-    <string name="ChannelMessageSticker">Novo sticker compartilhado no canal %1$s</string>
+    <string name="ChannelMessageNoText">%1$s postou uma mensagem</string>
+    <string name="ChannelMessagePhoto">%1$s postou uma foto</string>
+    <string name="ChannelMessageVideo">%1$s postou um vídeo</string>
+    <string name="ChannelMessageContact">%1$s postou um contato</string>
+    <string name="ChannelMessageMap">%1$s postou uma foto</string>
+    <string name="ChannelMessageDocument">%1$s postou um arquivo</string>
+    <string name="ChannelMessageAudio">%1$s postou uma mensagem de voz</string>
+    <string name="ChannelMessageSticker">%1$s postou um sticker</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">Nova Lista de Transmissão</string>
     <string name="EnterListName">Digite o nome da lista</string>
@@ -239,7 +262,9 @@
     <string name="ReportSpamAlertGroup">Você tem certeza que deseja reportar esse grupo por spam?</string>
     <string name="NobodyLikesSpam1">Desculpe, você pode enviar mensagens somente para contatos mútuos no momento.</string>
     <string name="NobodyLikesSpam2">Desculpe, você só pode adicionar contatos mútuos à grupos no momento.</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq/br#no-consigo-enviar-mensagens-para-no-contatos</string>
     <string name="MoreInfo">Mais informações</string>
+    <string name="ShareSendTo">Enviar para...</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s estabeleceu o tempo de autodestruição para %2$s </string>
     <string name="MessageLifetimeChangedOutgoing">Você estabeleceu o tempo de autodestruição para %1$s</string>
@@ -273,7 +298,7 @@
     <string name="NotificationGroupKickYou">%1$s removeu você do grupo %2$s</string>
     <string name="NotificationGroupLeftMember">%1$s saiu do grupo %2$s</string>
     <string name="NotificationContactJoined">%1$s entrou para o Telegram!</string>
-    <string name="NotificationUnrecognizedDevice">%1$s,\nNós detectamos que alguém acessou a sua conta a partir de um novo aparelho em %2$s\n\nAparelho: %3$s\nLocalização: %4$s\n\nSe não foi você, você pode ir em Configurações - Provacidade e Segurança - Sessões, e terminar aquela sessão.\n\nSe você acha que alguém acessou a sua conta contra a sua vontade, você pode habilitar a verificação em duas etapas nas configurações de Privacidade e Segurança.\n\nAtenciosamente,\nEquipe Telegram</string>
+    <string name="NotificationUnrecognizedDevice">%1$s,\nNós detectamos que alguém acessou a sua conta a partir de um novo aparelho em %2$s\n\nAparelho: %3$s\nLocalização: %4$s\n\nSe não foi você, você pode ir em Configurações - Privacidade e Segurança - Sessões, e terminar aquela sessão.\n\nSe você acha que alguém acessou a sua conta contra a sua vontade, você pode habilitar a verificação em duas etapas nas configurações de Privacidade e Segurança.\n\nAtenciosamente,\nEquipe Telegram</string>
     <string name="NotificationContactNewPhoto">%1$s atualizou a foto do perfil</string>
     <string name="NotificationInvitedToGroupByLink">%1$s entrou para o grupo %2$s via link de convite</string>
     <string name="Reply">Responder</string>
@@ -289,6 +314,7 @@
     <string name="Online">online</string>
     <string name="LastSeen">visto</string>
     <string name="LastSeenDate">visto</string>
+    <string name="LastSeenNow">visto agora mesmo</string>
     <string name="InviteFriends">Convidar Amigos</string>
     <string name="GlobalSearch">BUSCA GLOBAL</string>
     <string name="Lately">visto recentemente</string>
@@ -301,7 +327,7 @@
     <string name="EnterGroupNamePlaceholder">Digite o nome do grupo</string>
     <string name="GroupName">Nome do grupo</string>
     <string name="MembersCount">%1$d/%2$d membros</string>
-    <string name="JoinToGroup">Você deseja entrar no chat \'%1$s1?</string>
+    <string name="JoinToGroup">Você deseja entrar no chat \'%1$s\'?</string>
     <string name="JoinToGroupErrorFull">Desculpe, este grupo já está lotado.</string>
     <string name="JoinToGroupErrorNotExist">Desculpe, esse chat não existe.</string>
     <string name="LinkCopied">Link copiado para área de transferência</string>
@@ -314,13 +340,22 @@
     <string name="CopyLink">Copiar Link</string>
     <string name="ShareLink">Compartilhar Link</string>
     <string name="LinkInfo">Qualquer um com Telegram instalado poderá entrar no seu grupo abrindo este link.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">Administradores de Conversas</string>
+    <string name="SetAdminsAll">Todos os membros são Administradores</string>
+    <string name="SetAdminsAllInfo">Todos os membros podem adicionar novos membros, editar o nome e a foto do grupo.</string>
+    <string name="SetAdminsNotAllInfo">Somente administradores podem adicionar e remover membros, editar nome foto do grupo.</string>
     <!--group info view-->
     <string name="SharedMedia">Mídia Compartilhada</string>
     <string name="SETTINGS">Configurações</string>
     <string name="AddMember">Adicionar membro</string>
+    <string name="SetAdmins">Definir administradores</string>
     <string name="DeleteAndExit">Apagar e sair do grupo</string>
     <string name="Notifications">Notificações</string>
     <string name="KickFromGroup">Remover do grupo</string>
+    <string name="ConvertGroup">Atualizar para Supergrupo</string>
+    <string name="ConvertGroupAlert">Por favor note que os membros do grupo precisarão atualizar o aplicativo do Telegram até a última versão para verem seu supergrupo. Você tem certeza que deseja atualizar este grupo?</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>Limite de membros atingido.<![CDATA[</b>]]>\n\nPara ir além do limite e ter funções adcionais, atualize para um supergrupo:\n\n• Supergrupos podem ter até %1$s\n• Novos membros veêm todo o histórico de conversas\n• Administradores deletam mensagens para todos\n• Notificações são silenciadas por padrão</string>
     <!--contact info view-->
     <string name="ShareContact">Compartilhar</string>
     <string name="AddContact">Adicionar</string>
@@ -403,7 +438,6 @@
     <string name="TerminateAllSessions">Terminar todas as outras sessões</string>
     <string name="Events">Eventos</string>
     <string name="ContactJoined">Contato entrou para o Telegram</string>
-    <string name="Pebble">PEBBLE</string>
     <string name="Language">Idioma</string>
     <string name="AskAQuestionInfo">Por favor entenda que o suporte do Telegram é feito por voluntários. Tentaremos responder o mais rápido possível, mas poderemos demorar um pouco.<![CDATA[<br><br>]]>Por favor verifique a <![CDATA[<a href=\"https://telegram.org/faq#general\">página de perguntas frequentes do Telegram</a>]]>: há dicas e respostas para a maioria dos <![CDATA[<a href=\"https://telegram.org/faq#troubleshooting\">problemas</a>]]>.</string>
     <string name="AskButton">Pergunte a um voluntário</string>
@@ -465,6 +499,24 @@
     <string name="SmartNotificationsTimes">vezes</string>
     <string name="SmartNotificationsWithin">a cada</string>
     <string name="SmartNotificationsMinutes">minutos</string>
+    <!--cache view-->
+    <string name="CacheSettings">Configurações de Cache</string>
+    <string name="LocalDatabase">Banco de Dados Local</string>
+    <string name="LocalDatabaseClear">Limpar todos os textos em cache?</string>
+    <string name="LocalDatabaseInfo">Limpar o banco de dados local apagará todos os textos das mensagens em cache e compactará o banco de dados para economizar espaço. O Telegram precisa de alguns dados para trabalhar, então o tamanho do banco não vai chegar a zero.\n\nEssa operação pode demorar alguns minutos para ser concluída.</string>
+    <string name="ClearMediaCache">Limpar Cache</string>
+    <string name="CacheClear">Limpar</string>
+    <string name="CalculatingSize">Calculando...</string>
+    <string name="LocalDocumentCache">Documentos</string>
+    <string name="LocalPhotoCache">Fotos</string>
+    <string name="LocalAudioCache">Mensagens de voz</string>
+    <string name="LocalVideoCache">Vídeos</string>
+    <string name="LocalMusicCache">Música</string>
+    <string name="LocalCache">Outros arquivos</string>
+    <string name="CacheEmpty">Vazio</string>
+    <string name="KeepMedia">Manter Mídias</string>
+    <string name="KeepMediaInfo">Fotos, vídeos e outros arquivos da nuvem que você <![CDATA[<b>não acessou</b>]]> durante esse período serão removidos deste dispositivo para economizar espaço em disco.\n\nTodas as mídias permanecerão na nuvem do Telegram e poderão ser baixadas novamente conforme necessário.</string>
+    <string name="KeepMediaForever">Permanentemente</string>
     <!--sessions view-->
     <string name="SessionsTitle">Sessões Ativas</string>
     <string name="CurrentSession">Sessão atual</string>
@@ -493,11 +545,17 @@
     <string name="AutoLockInfo">Requisitar senha se estiver ausente por muito tempo.</string>
     <string name="AutoLockInTime">em %1$s</string>
     <string name="AutoLockDisabled">Desativado</string>
+    <string name="UnlockFingerprint">Desbloquear com Impressão Digital</string>
+    <string name="FingerprintInfo">Confirme a impressão digital para continuar</string>
+    <string name="FingerprintHelp">Toque o sensor</string>
+    <string name="FingerprintNotRecognized">Impressão digital não reconhecida.</string>
     <!--media view-->
     <string name="NoMedia">Compartilhar fotos e vídeos no chat e acessá-los em qualquer um de seus dispositivos.</string>
     <string name="DocumentsTitle">Arquivos Compartilhados</string>
     <string name="SharedMediaTitle">Mídia Compartilhada</string>
     <string name="LinksTitle">Links Compartilhados</string>
+    <string name="AudioTitle">Música Compartilhada</string>
+    <string name="NoSharedAudio">Compartilhe músicas nesse chat e os acesse de qualquer um de seus dispositivos.</string>
     <string name="NoSharedFiles">Compartilhar arquivos e documentos no chat e acessá-los de qualquer um de seus dispositivos.</string>
     <string name="NoSharedLinks">Compartilhe links nesse chat e os acesse de qualquer um de seus dispositivos</string>
     <!--map view-->
@@ -648,8 +706,8 @@
     <string name="BotInvite">Adicionar Ao Grupo</string>
     <string name="BotSettings">Configurações</string>
     <string name="BotHelp">Ajuda</string>
-    <string name="BotStatusRead">tem acesso as mensagens</string>
-    <string name="BotStatusCantRead">não tem acesso as mensagens</string>
+    <string name="BotStatusRead">tem acesso às mensagens</string>
+    <string name="BotStatusCantRead">não tem acesso às mensagens</string>
     <string name="BotInfoTitle">O que esse bot pode fazer?</string>
     <string name="BotStart">COMEÇAR</string>
     <string name="BotUnblock">REINICIAR</string>
@@ -668,6 +726,7 @@
     <string name="Call">Ligar</string>
     <string name="Copy">Copiar</string>
     <string name="Delete">Apagar</string>
+    <string name="DeleteAndStop">Apagar e parar</string>
     <string name="Forward">Encaminhar</string>
     <string name="Retry">Tentar novamente</string>
     <string name="FromCamera">Câmera</string>
@@ -722,12 +781,13 @@
     <string name="NoHandleAppInstalled">Você não possui um aplicativo que suporte o tipo de arquivo \'%1$s\', por favor instale um para continuar</string>
     <string name="InviteUser">Este usuário ainda não possui Telegram, deseja enviar um convite?</string>
     <string name="AreYouSure">Você tem certeza?</string>
-    <string name="AddToTheGroupTitle">Adicionar %1$s ao grupo %2$s?</string>
+    <string name="AddToTheGroupTitle">Adcione %1$s ao chat %2$s?</string>
     <string name="AddToTheGroupForwardCount">Número de mensagens antigas para encaminhar:</string>
     <string name="AddToTheGroup">Adicionar %1$s no grupo?</string>
     <string name="UserAlreadyInGroup">Este usuário já está neste grupo</string>
     <string name="ForwardMessagesTo">Encaminhar mensagem para %1$s?</string>
     <string name="SendMessagesTo">Enviar mensagens para %1$s?</string>
+    <string name="SendContactTo">Enviar contato para %1$s?</string>
     <string name="AreYouSureLogout">Você tem certeza que desejar sair?\n\nSaiba que você pode usar o Telegram em vários dispositivos de uma vez.\n\nLembre-se, sair apaga todos os seus Chats Secretos.</string>
     <string name="AreYouSureSessions">Você tem certeza que deseja terminar todas as outras sessões?</string>
     <string name="AreYouSureDeleteAndExit">Você tem certeza que apagar e sair do grupo?</string>
@@ -739,12 +799,21 @@
     <string name="AreYouSureSecretChat">Você tem certeza que deseja começar um chat secreto?</string>
     <string name="AreYouSureRegistration">Você tem certeza que deseja cancelar o registro?</string>
     <string name="AreYouSureClearHistory">Você tem certeza que deseja limpar o histórico?</string>
+    <string name="AreYouSureClearHistoryChannel">Apagar todos os textos e mídias em cache desse canal?</string>
+    <string name="AreYouSureClearHistorySuper">Apagar todos os textos e mídias em cache desse supergrupo?</string>
     <string name="AreYouSureDeleteMessages">Você tem certeza que deseja apagar %1$s?</string>
     <string name="SendMessagesToGroup">Enviar mensagens para %1$s?</string>
+    <string name="SendContactToGroup">Enviar contato para %1$s?</string>
     <string name="ForwardMessagesToGroup">Encaminhar mensagem para %1$s?</string>
     <string name="FeatureUnavailable">Desculpe, esta funcionalidade não está disponível para seu país.</string>
     <string name="NoUsernameFound">Não há conta do Telegram com esse nome de usuário</string>
     <string name="BotCantJoinGroups">Esse bot não pode entrar em grupos.</string>
+    <!--permissions-->
+    <string name="PermissionContacts">Telegram precisa acessar seus contatos para que você possa se conectar aos seus amigos em todos os seus dispositivos.</string>
+    <string name="PermissionStorage">Telegram precisa acessar seu armazenamento para que você possa enviar e salvar fotos, vídeos, músicas e outras mídias.</string>
+    <string name="PermissionNoAudio">Telegram precisa acessar seu microfone para que você possa enviar mensagens de voz.</string>
+    <string name="PermissionNoLocation">Telegram precisa acessar sua localização para que você possa compartilhar com seus amigos.</string>
+    <string name="PermissionOpenSettings">CONFIGURAÇÕES</string>
     <!--Intro view-->
     <string name="Page1Title">Telegram</string>
     <string name="Page2Title">Rápido</string>
@@ -882,6 +951,18 @@
     <string name="Photos_few">%1$d fotos</string>
     <string name="Photos_many">%1$d fotos</string>
     <string name="Photos_other">%1$d fotos</string>
+    <string name="LastSeenMinutes_zero">visto há %1$d minutos</string>
+    <string name="LastSeenMinutes_one">visto há %1$d minuto</string>
+    <string name="LastSeenMinutes_two">visto há %1$d minutos</string>
+    <string name="LastSeenMinutes_few">visto há %1$d minutos</string>
+    <string name="LastSeenMinutes_many">visto há %1$d minutos</string>
+    <string name="LastSeenMinutes_other">visto há %1$d minutos</string>
+    <string name="LastSeenHours_zero">visto há %1$d horas</string>
+    <string name="LastSeenHours_one">visto há %1$d hora</string>
+    <string name="LastSeenHours_two">visto há %1$d horas</string>
+    <string name="LastSeenHours_few">visto há %1$d horas</string>
+    <string name="LastSeenHours_many">visto há %1$d horas</string>
+    <string name="LastSeenHours_other">visto há %1$d horas</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d mensagens encaminhadas</string>
     <string name="ForwardedMessage_one">Mensagem encaminhada</string>
@@ -949,6 +1030,6 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s às %2$s</string>
     <!--update text-->
-    <string name="updateText">Telegram para Android foi atualizado. Novidade na versão 3.2.0:\n\n- Introduzindo Canais – Uma grande nova maneira de transmitir suas mensagens, com audiência ilimitada (substitui as antigas Transmissões).\n\nMais sobre a atualização: https://telegram.org/blog/channels</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">O Telegram para Android foi atualizado. Novidades da versão 3.3.2:\n\n- Gerenciamento de cache: controle quanto espaço em disco o Telegram ocupa em teu aparelho, apague o cache para tipos específicos de conteúdo.\n- Apague o cache de supergrupos e canais: toque em um deles na lista de contas e escolha "apagar do cache".\n- Gerenciamento de stickers: reordene manualmente teus pacotes de stickers. Agora essa ordem será sincronizada em todos os teus aparelhos.\nMais sobre essa atualização: https://telegram.org/blog/cache-and-stickers</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-pt-rPT/strings.xml b/TMessagesProj/src/main/res/values-pt-rPT/strings.xml
index 899fcefd2..1f0394737 100644
--- a/TMessagesProj/src/main/res/values-pt-rPT/strings.xml
+++ b/TMessagesProj/src/main/res/values-pt-rPT/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">Telegram</string>
+    <string name="AppNameBeta">Telegram Beta</string>
     <string name="LanguageName">Português (Brasil)</string>
     <string name="LanguageNameInEnglish">Português (Brasil)</string>
     <string name="LanguageCode">pt_BR</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s entrou no chat secreto</string>
     <string name="EncryptedChatStartedIncoming">Você entrou no chat secreto</string>
     <string name="ClearHistory">Limpar histórico</string>
+    <string name="ClearHistoryCache">Apagar do cache</string>
     <string name="DeleteChat">Apagar e sair</string>
     <string name="DeleteChatUser">Apagar conversa</string>
     <string name="HiddenName">Conta Excluída</string>
@@ -60,12 +62,33 @@
     <string name="MuteDisable">Desativar</string>
     <string name="Hashtags">HASHTAGS</string>
     <string name="Recent">RECENTE</string>
+    <string name="LinkPreview">Prévia do link</string>
     <!--channels-->
+    <string name="SetAsAdmin">Promover a administrador</string>
+    <string name="DescriptionInfoMega">Você pode fornecer uma descrição opcional para seu grupo.</string>
+    <string name="LeaveMega">Sair do Grupo</string>
+    <string name="DeleteMega">Apagar Grupo</string>
+    <string name="LeaveMegaMenu">Sair do Grupo</string>
+    <string name="DeleteMegaMenu">Apagar Grupo</string>
+    <string name="MegaDeleteInfo">Você perderá todas as mensagens neste grupo.</string>
+    <string name="MegaAdminsInfo">Você pode adicionar administradores para ajudar você a gerenciar seu grupo. Toque e segure para removê-los.</string>
+    <string name="MegaDeleteAlert">Espere! Apagar este grupo removerá todos os membros e todas as mensagens serão perdidas. Apagar o grupo mesmo assim?</string>
+    <string name="ActionCreateMega">Grupo criado</string>
+    <string name="MegaAddedBy">un1 adicionou você ao grupo</string>
+    <string name="MegaLeaveAlert">Você tem certeza que deseja sair do grupo?</string>
+    <string name="GroupUserCantAdd">Desculpe, você não pode adicionar este usuário a grupos.</string>
+    <string name="GroupUserAddLimit">Desculpe, este grupo está cheio.</string>
+    <string name="GroupUserLeftError">Desculpe, este usuário decidiu sair deste grupo, de maneira que você não pode convidá-lo de volta.</string>
+    <string name="GroupUserCantAdmin">Desculpe, há administradores demais neste grupo.</string>
+    <string name="GroupUserCantBot">Desculpe, há bots demais neste grupo.</string>
+    <string name="ActionMigrateFromGroup">Este grupo foi atualizado para um supergrupo</string>
+    <string name="ActionMigrateFromGroupNotify">%1$s foi atualizado para um supergrupo</string>
+    <string name="NoBlockedGroup">Usuários bloqueados são removidos do grupo e só podem voltar se convidados por um administrador. Convites por link não funcionam para eles.</string>
     <string name="NewChannel">Novo Canal</string>
     <string name="EnterChannelName">Nome do canal</string>
     <string name="Comments">Comentários</string>
     <string name="CommentsInfo">Se você habilitar comentários, pessoas poderão discutir seu post no canal.</string>
-    <string name="AddMutual">Adicionar contatos para o seu canal</string>
+    <string name="AddMutual">Adicionar contatos no canal</string>
     <string name="ChannelUsernameHelp">Pessoas podem compartilhar esse link com outros e encontrar seu canal usando a busca do Telegram.</string>
     <string name="ChannelUsernamePlaceholder">link</string>
     <string name="ChannelPrivateLinkHelp">Pessoas podem entrar em seu canal com este link. Você pode desativar o link quando quiser.</string>
@@ -83,7 +106,7 @@
     <string name="ChannelSettings">Configurações</string>
     <string name="ChannelJoin">ENTRAR</string>
     <string name="OpenChannelProfile">Info do Canal</string>
-    <string name="ChannelBroadcast">Tramissão</string>
+    <string name="ChannelBroadcast">Transmissão</string>
     <string name="ChannelComment">Comentário</string>
     <string name="ShowDiscussion">mostrar comentários</string>
     <string name="ChannelAlertTitle">O que é um Canal?</string>
@@ -97,7 +120,7 @@
     <string name="LinkChecking">Verificando nome...</string>
     <string name="LinkAvailable">%1$s está disponível.</string>
     <string name="ChannelMembers">Membros</string>
-    <string name="ChannelBlockedUsers">Usuários Bloqueados</string>
+    <string name="ChannelBlockedUsers">Usuários bloqueados</string>
     <string name="ChannelAdministrators">Administradores</string>
     <string name="ChannelDelete">Apagar Canal</string>
     <string name="ChannelDeleteMenu">Apagar Canal</string>
@@ -111,7 +134,6 @@
     <string name="ActionChannelChangedPhoto">Foto do canal alterada</string>
     <string name="ActionChannelRemovedPhoto">Foto do canal removida</string>
     <string name="ActionChannelChangedTitle">Nome do canal alterado para un2</string>
-    <string name="ActionChannelInvite">un1 adicionado ao canal un2</string>
     <string name="ChannelPublicLimitReached">Desculpe, você criou muitos canais públicos. Você pode criar um canal privado ou apagar um de seus canais existentes primeiro.</string>
     <string name="ChannelModerator">Moderador</string>
     <string name="ChannelCreator">Criador</string>
@@ -127,11 +149,12 @@
     <string name="ChannelLinkInfo">Qualquer um com Telegram instalado poderá entrar no seu canal abrindo este link.</string>
     <string name="ChannelAdminsInfo">Você pode adicionar administradores para ajudar você a gerenciar seu canal. Aperte e segure para removê-los.</string>
     <string name="ChannelJoinTo">Você deseja entrar no canal \'%1$s\'?</string>
-    <string name="ChannelCantOpenPrivate">Desculpe, esse canal não é acessível.</string>
-    <string name="ChannelAddToTitle">Adicionar %1$s ao grupo %2$s?</string>
+    <string name="ChannelCantOpenPrivate">Desculpe, esta conversa não pode mais ser acessada.</string>
     <string name="ChannelAddTo">Adicionar %1$s ao canal?</string>
-    <string name="ChannelUserLeftError">Desculpe, esse usuário decidiu sair do grupo, você não pode adicioná-lo novamente.</string>
+    <string name="ChannelUserLeftError">Desculpe, este usuário decidiu sair deste canal, então você não pode convidá-lo de volta.</string>
     <string name="ChannelUserCantAdd">Desculpe, você não pode adicionar esse usuário em canais.</string>
+    <string name="ChannelUserCantAdmin">Desculpe, muitos administradores nesse canal.</string>
+    <string name="ChannelUserCantBot">Desculpe, há bots demais neste canal.</string>
     <string name="ChannelUserAddLimit">Desculpe, você só pode adicionar os primeiros 200 membros ao canal. Note que um número ilimitado de pessoas podem entrar via link do canal.</string>
     <string name="ChannelAddedBy">un1 adicionou você ao canal</string>
     <string name="ChannelJoined">Você entrou no canal</string>
@@ -147,14 +170,14 @@
     <string name="ChannelMessageGroupDocument">%1$s enviou um arquivo ao canal %2$s</string>
     <string name="ChannelMessageGroupAudio">%1$s enviou um áudio ao canal %2$s</string>
     <string name="ChannelMessageGroupSticker">%1$s enviou um sticker ao canal %2$s</string>
-    <string name="ChannelMessageNoText">Nova mensagem no canal %1$s</string>
-    <string name="ChannelMessagePhoto">Nova foto no canal %1$s</string>
-    <string name="ChannelMessageVideo">Novo vídeo no canal %1$s</string>
-    <string name="ChannelMessageContact">Contato compartilhado no canal %1$s</string>
-    <string name="ChannelMessageMap">Nova localização compartilhada no canal %1$s</string>
-    <string name="ChannelMessageDocument">Novo arquivo compartilhado no canal %1$s</string>
-    <string name="ChannelMessageAudio">Nova mensagem de voz compartilhada no canal %1$s</string>
-    <string name="ChannelMessageSticker">Novo sticker compartilhado no canal %1$s</string>
+    <string name="ChannelMessageNoText">%1$s postou uma mensagem</string>
+    <string name="ChannelMessagePhoto">%1$s postou uma foto</string>
+    <string name="ChannelMessageVideo">%1$s postou um vídeo</string>
+    <string name="ChannelMessageContact">%1$s postou um contato</string>
+    <string name="ChannelMessageMap">%1$s postou uma foto</string>
+    <string name="ChannelMessageDocument">%1$s postou um arquivo</string>
+    <string name="ChannelMessageAudio">%1$s postou uma mensagem de voz</string>
+    <string name="ChannelMessageSticker">%1$s postou um sticker</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">Nova Lista de Transmissão</string>
     <string name="EnterListName">Digite o nome da lista</string>
@@ -239,7 +262,9 @@
     <string name="ReportSpamAlertGroup">Você tem certeza que deseja reportar esse grupo por spam?</string>
     <string name="NobodyLikesSpam1">Desculpe, você pode enviar mensagens somente para contatos mútuos no momento.</string>
     <string name="NobodyLikesSpam2">Desculpe, você só pode adicionar contatos mútuos à grupos no momento.</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq/br#no-consigo-enviar-mensagens-para-no-contatos</string>
     <string name="MoreInfo">Mais informações</string>
+    <string name="ShareSendTo">Enviar para...</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s estabeleceu o tempo de autodestruição para %2$s </string>
     <string name="MessageLifetimeChangedOutgoing">Você estabeleceu o tempo de autodestruição para %1$s</string>
@@ -273,7 +298,7 @@
     <string name="NotificationGroupKickYou">%1$s removeu você do grupo %2$s</string>
     <string name="NotificationGroupLeftMember">%1$s saiu do grupo %2$s</string>
     <string name="NotificationContactJoined">%1$s entrou para o Telegram!</string>
-    <string name="NotificationUnrecognizedDevice">%1$s,\nNós detectamos que alguém acessou a sua conta a partir de um novo aparelho em %2$s\n\nAparelho: %3$s\nLocalização: %4$s\n\nSe não foi você, você pode ir em Configurações - Provacidade e Segurança - Sessões, e terminar aquela sessão.\n\nSe você acha que alguém acessou a sua conta contra a sua vontade, você pode habilitar a verificação em duas etapas nas configurações de Privacidade e Segurança.\n\nAtenciosamente,\nEquipe Telegram</string>
+    <string name="NotificationUnrecognizedDevice">%1$s,\nNós detectamos que alguém acessou a sua conta a partir de um novo aparelho em %2$s\n\nAparelho: %3$s\nLocalização: %4$s\n\nSe não foi você, você pode ir em Configurações - Privacidade e Segurança - Sessões, e terminar aquela sessão.\n\nSe você acha que alguém acessou a sua conta contra a sua vontade, você pode habilitar a verificação em duas etapas nas configurações de Privacidade e Segurança.\n\nAtenciosamente,\nEquipe Telegram</string>
     <string name="NotificationContactNewPhoto">%1$s atualizou a foto do perfil</string>
     <string name="NotificationInvitedToGroupByLink">%1$s entrou para o grupo %2$s via link de convite</string>
     <string name="Reply">Responder</string>
@@ -289,6 +314,7 @@
     <string name="Online">online</string>
     <string name="LastSeen">visto</string>
     <string name="LastSeenDate">visto</string>
+    <string name="LastSeenNow">visto agora mesmo</string>
     <string name="InviteFriends">Convidar Amigos</string>
     <string name="GlobalSearch">BUSCA GLOBAL</string>
     <string name="Lately">visto recentemente</string>
@@ -301,7 +327,7 @@
     <string name="EnterGroupNamePlaceholder">Digite o nome do grupo</string>
     <string name="GroupName">Nome do grupo</string>
     <string name="MembersCount">%1$d/%2$d membros</string>
-    <string name="JoinToGroup">Você deseja entrar no chat \'%1$s1?</string>
+    <string name="JoinToGroup">Você deseja entrar no chat \'%1$s\'?</string>
     <string name="JoinToGroupErrorFull">Desculpe, este grupo já está lotado.</string>
     <string name="JoinToGroupErrorNotExist">Desculpe, esse chat não existe.</string>
     <string name="LinkCopied">Link copiado para área de transferência</string>
@@ -314,13 +340,22 @@
     <string name="CopyLink">Copiar Link</string>
     <string name="ShareLink">Compartilhar Link</string>
     <string name="LinkInfo">Qualquer um com Telegram instalado poderá entrar no seu grupo abrindo este link.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">Administradores de Conversas</string>
+    <string name="SetAdminsAll">Todos os membros são Administradores</string>
+    <string name="SetAdminsAllInfo">Todos os membros podem adicionar novos membros, editar o nome e a foto do grupo.</string>
+    <string name="SetAdminsNotAllInfo">Somente administradores podem adicionar e remover membros, editar nome foto do grupo.</string>
     <!--group info view-->
     <string name="SharedMedia">Mídia Compartilhada</string>
     <string name="SETTINGS">Configurações</string>
     <string name="AddMember">Adicionar membro</string>
+    <string name="SetAdmins">Definir administradores</string>
     <string name="DeleteAndExit">Apagar e sair do grupo</string>
     <string name="Notifications">Notificações</string>
     <string name="KickFromGroup">Remover do grupo</string>
+    <string name="ConvertGroup">Atualizar para Supergrupo</string>
+    <string name="ConvertGroupAlert">Por favor note que os membros do grupo precisarão atualizar o aplicativo do Telegram até a última versão para verem seu supergrupo. Você tem certeza que deseja atualizar este grupo?</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>Limite de membros atingido.<![CDATA[</b>]]>\n\nPara ir além do limite e ter funções adcionais, atualize para um supergrupo:\n\n• Supergrupos podem ter até %1$s\n• Novos membros veêm todo o histórico de conversas\n• Administradores deletam mensagens para todos\n• Notificações são silenciadas por padrão</string>
     <!--contact info view-->
     <string name="ShareContact">Compartilhar</string>
     <string name="AddContact">Adicionar</string>
@@ -403,7 +438,6 @@
     <string name="TerminateAllSessions">Terminar todas as outras sessões</string>
     <string name="Events">Eventos</string>
     <string name="ContactJoined">Contato entrou para o Telegram</string>
-    <string name="Pebble">PEBBLE</string>
     <string name="Language">Idioma</string>
     <string name="AskAQuestionInfo">Por favor entenda que o suporte do Telegram é feito por voluntários. Tentaremos responder o mais rápido possível, mas poderemos demorar um pouco.<![CDATA[<br><br>]]>Por favor verifique a <![CDATA[<a href=\"https://telegram.org/faq#general\">página de perguntas frequentes do Telegram</a>]]>: há dicas e respostas para a maioria dos <![CDATA[<a href=\"https://telegram.org/faq#troubleshooting\">problemas</a>]]>.</string>
     <string name="AskButton">Pergunte a um voluntário</string>
@@ -465,6 +499,24 @@
     <string name="SmartNotificationsTimes">vezes</string>
     <string name="SmartNotificationsWithin">a cada</string>
     <string name="SmartNotificationsMinutes">minutos</string>
+    <!--cache view-->
+    <string name="CacheSettings">Configurações de Cache</string>
+    <string name="LocalDatabase">Banco de Dados Local</string>
+    <string name="LocalDatabaseClear">Limpar todos os textos em cache?</string>
+    <string name="LocalDatabaseInfo">Limpar o banco de dados local apagará todos os textos das mensagens em cache e compactará o banco de dados para economizar espaço. O Telegram precisa de alguns dados para trabalhar, então o tamanho do banco não vai chegar a zero.\n\nEssa operação pode demorar alguns minutos para ser concluída.</string>
+    <string name="ClearMediaCache">Limpar Cache</string>
+    <string name="CacheClear">Limpar</string>
+    <string name="CalculatingSize">Calculando...</string>
+    <string name="LocalDocumentCache">Documentos</string>
+    <string name="LocalPhotoCache">Fotos</string>
+    <string name="LocalAudioCache">Mensagens de voz</string>
+    <string name="LocalVideoCache">Vídeos</string>
+    <string name="LocalMusicCache">Música</string>
+    <string name="LocalCache">Outros arquivos</string>
+    <string name="CacheEmpty">Vazio</string>
+    <string name="KeepMedia">Manter Mídias</string>
+    <string name="KeepMediaInfo">Fotos, vídeos e outros arquivos da nuvem que você <![CDATA[<b>não acessou</b>]]> durante esse período serão removidos deste dispositivo para economizar espaço em disco.\n\nTodas as mídias permanecerão na nuvem do Telegram e poderão ser baixadas novamente conforme necessário.</string>
+    <string name="KeepMediaForever">Permanentemente</string>
     <!--sessions view-->
     <string name="SessionsTitle">Sessões Ativas</string>
     <string name="CurrentSession">Sessão atual</string>
@@ -493,11 +545,17 @@
     <string name="AutoLockInfo">Requisitar senha se estiver ausente por muito tempo.</string>
     <string name="AutoLockInTime">em %1$s</string>
     <string name="AutoLockDisabled">Desativado</string>
+    <string name="UnlockFingerprint">Desbloquear com Impressão Digital</string>
+    <string name="FingerprintInfo">Confirme a impressão digital para continuar</string>
+    <string name="FingerprintHelp">Toque o sensor</string>
+    <string name="FingerprintNotRecognized">Impressão digital não reconhecida.</string>
     <!--media view-->
     <string name="NoMedia">Compartilhar fotos e vídeos no chat e acessá-los em qualquer um de seus dispositivos.</string>
     <string name="DocumentsTitle">Arquivos Compartilhados</string>
     <string name="SharedMediaTitle">Mídia Compartilhada</string>
     <string name="LinksTitle">Links Compartilhados</string>
+    <string name="AudioTitle">Música Compartilhada</string>
+    <string name="NoSharedAudio">Compartilhe músicas nesse chat e os acesse de qualquer um de seus dispositivos.</string>
     <string name="NoSharedFiles">Compartilhar arquivos e documentos no chat e acessá-los de qualquer um de seus dispositivos.</string>
     <string name="NoSharedLinks">Compartilhe links nesse chat e os acesse de qualquer um de seus dispositivos</string>
     <!--map view-->
@@ -648,8 +706,8 @@
     <string name="BotInvite">Adicionar Ao Grupo</string>
     <string name="BotSettings">Configurações</string>
     <string name="BotHelp">Ajuda</string>
-    <string name="BotStatusRead">tem acesso as mensagens</string>
-    <string name="BotStatusCantRead">não tem acesso as mensagens</string>
+    <string name="BotStatusRead">tem acesso às mensagens</string>
+    <string name="BotStatusCantRead">não tem acesso às mensagens</string>
     <string name="BotInfoTitle">O que esse bot pode fazer?</string>
     <string name="BotStart">COMEÇAR</string>
     <string name="BotUnblock">REINICIAR</string>
@@ -668,6 +726,7 @@
     <string name="Call">Ligar</string>
     <string name="Copy">Copiar</string>
     <string name="Delete">Apagar</string>
+    <string name="DeleteAndStop">Apagar e parar</string>
     <string name="Forward">Encaminhar</string>
     <string name="Retry">Tentar novamente</string>
     <string name="FromCamera">Câmera</string>
@@ -722,12 +781,13 @@
     <string name="NoHandleAppInstalled">Você não possui um aplicativo que suporte o tipo de arquivo \'%1$s\', por favor instale um para continuar</string>
     <string name="InviteUser">Este usuário ainda não possui Telegram, deseja enviar um convite?</string>
     <string name="AreYouSure">Você tem certeza?</string>
-    <string name="AddToTheGroupTitle">Adicionar %1$s ao grupo %2$s?</string>
+    <string name="AddToTheGroupTitle">Adcione %1$s ao chat %2$s?</string>
     <string name="AddToTheGroupForwardCount">Número de mensagens antigas para encaminhar:</string>
     <string name="AddToTheGroup">Adicionar %1$s no grupo?</string>
     <string name="UserAlreadyInGroup">Este usuário já está neste grupo</string>
     <string name="ForwardMessagesTo">Encaminhar mensagem para %1$s?</string>
     <string name="SendMessagesTo">Enviar mensagens para %1$s?</string>
+    <string name="SendContactTo">Enviar contato para %1$s?</string>
     <string name="AreYouSureLogout">Você tem certeza que desejar sair?\n\nSaiba que você pode usar o Telegram em vários dispositivos de uma vez.\n\nLembre-se, sair apaga todos os seus Chats Secretos.</string>
     <string name="AreYouSureSessions">Você tem certeza que deseja terminar todas as outras sessões?</string>
     <string name="AreYouSureDeleteAndExit">Você tem certeza que apagar e sair do grupo?</string>
@@ -739,12 +799,21 @@
     <string name="AreYouSureSecretChat">Você tem certeza que deseja começar um chat secreto?</string>
     <string name="AreYouSureRegistration">Você tem certeza que deseja cancelar o registro?</string>
     <string name="AreYouSureClearHistory">Você tem certeza que deseja limpar o histórico?</string>
+    <string name="AreYouSureClearHistoryChannel">Apagar todos os textos e mídias em cache desse canal?</string>
+    <string name="AreYouSureClearHistorySuper">Apagar todos os textos e mídias em cache desse supergrupo?</string>
     <string name="AreYouSureDeleteMessages">Você tem certeza que deseja apagar %1$s?</string>
     <string name="SendMessagesToGroup">Enviar mensagens para %1$s?</string>
+    <string name="SendContactToGroup">Enviar contato para %1$s?</string>
     <string name="ForwardMessagesToGroup">Encaminhar mensagem para %1$s?</string>
     <string name="FeatureUnavailable">Desculpe, esta funcionalidade não está disponível para seu país.</string>
     <string name="NoUsernameFound">Não há conta do Telegram com esse nome de usuário</string>
     <string name="BotCantJoinGroups">Esse bot não pode entrar em grupos.</string>
+    <!--permissions-->
+    <string name="PermissionContacts">Telegram precisa acessar seus contatos para que você possa se conectar aos seus amigos em todos os seus dispositivos.</string>
+    <string name="PermissionStorage">Telegram precisa acessar seu armazenamento para que você possa enviar e salvar fotos, vídeos, músicas e outras mídias.</string>
+    <string name="PermissionNoAudio">Telegram precisa acessar seu microfone para que você possa enviar mensagens de voz.</string>
+    <string name="PermissionNoLocation">Telegram precisa acessar sua localização para que você possa compartilhar com seus amigos.</string>
+    <string name="PermissionOpenSettings">CONFIGURAÇÕES</string>
     <!--Intro view-->
     <string name="Page1Title">Telegram</string>
     <string name="Page2Title">Rápido</string>
@@ -882,6 +951,18 @@
     <string name="Photos_few">%1$d fotos</string>
     <string name="Photos_many">%1$d fotos</string>
     <string name="Photos_other">%1$d fotos</string>
+    <string name="LastSeenMinutes_zero">visto há %1$d minutos</string>
+    <string name="LastSeenMinutes_one">visto há %1$d minuto</string>
+    <string name="LastSeenMinutes_two">visto há %1$d minutos</string>
+    <string name="LastSeenMinutes_few">visto há %1$d minutos</string>
+    <string name="LastSeenMinutes_many">visto há %1$d minutos</string>
+    <string name="LastSeenMinutes_other">visto há %1$d minutos</string>
+    <string name="LastSeenHours_zero">visto há %1$d horas</string>
+    <string name="LastSeenHours_one">visto há %1$d hora</string>
+    <string name="LastSeenHours_two">visto há %1$d horas</string>
+    <string name="LastSeenHours_few">visto há %1$d horas</string>
+    <string name="LastSeenHours_many">visto há %1$d horas</string>
+    <string name="LastSeenHours_other">visto há %1$d horas</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d mensagens encaminhadas</string>
     <string name="ForwardedMessage_one">Mensagem encaminhada</string>
@@ -949,6 +1030,6 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s às %2$s</string>
     <!--update text-->
-    <string name="updateText">Telegram para Android foi atualizado. Novidade na versão 3.2.0:\n\n- Introduzindo Canais – Uma grande nova maneira de transmitir suas mensagens, com audiência ilimitada (substitui as antigas Transmissões).\n\nMais sobre a atualização: https://telegram.org/blog/channels</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">O Telegram para Android foi atualizado. Novidades da versão 3.3.2:\n\n- Gerenciamento de cache: controle quanto espaço em disco o Telegram ocupa em teu aparelho, apague o cache para tipos específicos de conteúdo.\n- Apague o cache de supergrupos e canais: toque em um deles na lista de contas e escolha "apagar do cache".\n- Gerenciamento de stickers: reordene manualmente teus pacotes de stickers. Agora essa ordem será sincronizada em todos os teus aparelhos.\nMais sobre essa atualização: https://telegram.org/blog/cache-and-stickers</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
diff --git a/TMessagesProj/src/main/res/values-v21/styles.xml b/TMessagesProj/src/main/res/values-v21/styles.xml
index 5f8d4a200..61779ddf7 100644
--- a/TMessagesProj/src/main/res/values-v21/styles.xml
+++ b/TMessagesProj/src/main/res/values-v21/styles.xml
@@ -1,9 +1,9 @@
 <!--
-  ~ This is the source code of Telegram for Android v. 1.7.x.
+  ~ This is the source code of Telegram for Android v. 3.x.x.
   ~ It is licensed under GNU GPL v. 2 or later.
   ~ You should have received a copy of the license in this archive (see LICENSE).
   ~
-  ~ Copyright Nikolai Kudashov, 2013-2014.
+  ~ Copyright Nikolai Kudashov, 2013-2015.
   -->
 
 <resources
diff --git a/TMessagesProj/src/main/res/values/strings.xml b/TMessagesProj/src/main/res/values/strings.xml
index 0b29a9eb5..6e90320d1 100644
--- a/TMessagesProj/src/main/res/values/strings.xml
+++ b/TMessagesProj/src/main/res/values/strings.xml
@@ -4,6 +4,7 @@
 
 <resources>
     <string name="AppName">Telegram</string>
+    <string name="AppNameBeta">Telegram Beta</string>
     <string name="LanguageName">English</string>
     <string name="LanguageNameInEnglish">English</string>
     <string name="LanguageCode">en</string>
@@ -45,6 +46,7 @@
     <string name="EncryptedChatStartedOutgoing">%s joined your secret chat.</string>
     <string name="EncryptedChatStartedIncoming">You joined the secret chat.</string>
     <string name="ClearHistory">Clear history</string>
+    <string name="ClearHistoryCache">Delete from cache</string>
     <string name="DeleteChat">Delete and exit</string>
     <string name="DeleteChatUser">Delete chat</string>
     <string name="HiddenName">Deleted Account</string>
@@ -60,7 +62,28 @@
     <string name="MuteDisable">Disable</string>
     <string name="Hashtags">HASHTAGS</string>
     <string name="Recent">RECENT</string>
+    <string name="LinkPreview">Link preview</string>
     <!--channels-->
+    <string name="SetAsAdmin">Promote to admin</string>
+    <string name="DescriptionInfoMega">You can provide an optional description for your group.</string>
+    <string name="LeaveMega">Leave Group</string>
+    <string name="DeleteMega">Delete Group</string>
+    <string name="LeaveMegaMenu">Leave group</string>
+    <string name="DeleteMegaMenu">Delete group</string>
+    <string name="MegaDeleteInfo">You will lose all messages in this group.</string>
+    <string name="MegaAdminsInfo">You can add administrators to help you manage your group. Tap and hold to remove them.</string>
+    <string name="MegaDeleteAlert">Wait! Deleting this group will remove all members and all messages will be lost. Delete the group anyway?</string>
+    <string name="ActionCreateMega">Group created</string>
+    <string name="MegaAddedBy">un1 added you to this group</string>
+    <string name="MegaLeaveAlert">Are you sure you want to leave the group?</string>
+    <string name="GroupUserCantAdd">Sorry, you can\'t add this user to groups.</string>
+    <string name="GroupUserAddLimit">Sorry, this group is full.</string>
+    <string name="GroupUserLeftError">Sorry, this user decided to leave this group, so you cannot invite them back here.</string>
+    <string name="GroupUserCantAdmin">Sorry, too many adminstrators in this group.</string>
+    <string name="GroupUserCantBot">Sorry, too many bots in this group.</string>
+    <string name="ActionMigrateFromGroup">This group was upgraded to a supergroup</string>
+    <string name="ActionMigrateFromGroupNotify">%1$s was upgraded to a supergroup</string>
+    <string name="NoBlockedGroup">Blocked users are removed from the group and can only come back if invited by an admin. Invite links don\'t work for them.</string>
     <string name="NewChannel">New Channel</string>
     <string name="EnterChannelName">Channel name</string>
     <string name="Comments">Comments</string>
@@ -97,7 +120,7 @@
     <string name="LinkChecking">Checking name…</string>
     <string name="LinkAvailable">%1$s is available.</string>
     <string name="ChannelMembers">Members</string>
-    <string name="ChannelBlockedUsers">Blocked Users</string>
+    <string name="ChannelBlockedUsers">Blocked users</string>
     <string name="ChannelAdministrators">Administrators</string>
     <string name="ChannelDelete">Delete Channel</string>
     <string name="ChannelDeleteMenu">Delete channel</string>
@@ -111,7 +134,6 @@
     <string name="ActionChannelChangedPhoto">Channel photo changed</string>
     <string name="ActionChannelRemovedPhoto">Channel photo removed</string>
     <string name="ActionChannelChangedTitle">Channel name changed to un2</string>
-    <string name="ActionChannelInvite">un1 added you to the channel un2</string>
     <string name="ChannelPublicLimitReached">Sorry, you have created too many public channels. You can either create a private channel or delete one of your existing channels first.</string>
     <string name="ChannelModerator">Moderator</string>
     <string name="ChannelCreator">Creator</string>
@@ -127,11 +149,12 @@
     <string name="ChannelLinkInfo">Anyone who has Telegram installed will be able to join your channel by following this link.</string>
     <string name="ChannelAdminsInfo">You can add administrators to help you manage your channel. Tap and hold to remove admins.</string>
     <string name="ChannelJoinTo">Do you want to join the channel \'%1$s\'?</string>
-    <string name="ChannelCantOpenPrivate">Sorry, this channel is no longer accessible.</string>
-    <string name="ChannelAddToTitle">Add %1$s to the channel %2$s?</string>
+    <string name="ChannelCantOpenPrivate">Sorry, this chat is no longer accessible.</string>
     <string name="ChannelAddTo">Add %1$s to the channel?</string>
-    <string name="ChannelUserLeftError">Sorry, this user decided to leave this group, so you cannot invite them back here.</string>
+    <string name="ChannelUserLeftError">Sorry, this user decided to leave this channel, so you cannot invite them back here.</string>
     <string name="ChannelUserCantAdd">Sorry, you can\'t add this user to channels.</string>
+    <string name="ChannelUserCantAdmin">Sorry, too many admins in this channel.</string>
+    <string name="ChannelUserCantBot">Sorry, too many bots in this channel.</string>
     <string name="ChannelUserAddLimit">Sorry, you can only add the first 200 members to a channel. Note that an unlimited number of people may join via the channel\'s link.</string>
     <string name="ChannelAddedBy">un1 added you to this channel</string>
     <string name="ChannelJoined">You joined the channel</string>
@@ -147,14 +170,14 @@
     <string name="ChannelMessageGroupDocument">%1$s sent a file to the channel %2$s</string>
     <string name="ChannelMessageGroupAudio">%1$s sent an audio to the channel %2$s</string>
     <string name="ChannelMessageGroupSticker">%1$s sent a sticker to the channel %2$s</string>
-    <string name="ChannelMessageNoText">New message in the channel %1$s</string>
-    <string name="ChannelMessagePhoto">New photo in the channel %1$s</string>
-    <string name="ChannelMessageVideo">New video in the channel %1$s</string>
-    <string name="ChannelMessageContact">Contact shared in the channel %1$s</string>
-    <string name="ChannelMessageMap">New location shared in the channel %1$s</string>
-    <string name="ChannelMessageDocument">New file shared in the channel %1$s</string>
-    <string name="ChannelMessageAudio">New voice note shared in the channel %1$s</string>
-    <string name="ChannelMessageSticker">New sticker shared in the channel %1$s</string>
+    <string name="ChannelMessageNoText">%1$s posted a message</string>
+    <string name="ChannelMessagePhoto">%1$s posted a photo</string>
+    <string name="ChannelMessageVideo">%1$s posted a video</string>
+    <string name="ChannelMessageContact">%1$s posted a contact</string>
+    <string name="ChannelMessageMap">%1$s posted a location</string>
+    <string name="ChannelMessageDocument">%1$s posted a file</string>
+    <string name="ChannelMessageAudio">%1$s posted a voice message</string>
+    <string name="ChannelMessageSticker">%1$s posted a sticker</string>
     <!--broadcasts-->
     <string name="NewBroadcastList">New Broadcast List</string>
     <string name="EnterListName">Enter list name</string>
@@ -239,7 +262,9 @@
     <string name="ReportSpamAlertGroup">Are you sure you want to report spam from this group?</string>
     <string name="NobodyLikesSpam1">Sorry, you can only send messages to mutual contacts at the moment.</string>
     <string name="NobodyLikesSpam2">Sorry, you can only add mutual contacts to groups at the moment.</string>
+    <string name="NobodyLikesSpamUrl">https://telegram.org/faq#can-39t-send-messages-to-non-contacts</string>
     <string name="MoreInfo">More info</string>
+    <string name="ShareSendTo">Send to...</string>
     <!--notification-->
     <string name="MessageLifetimeChanged">%1$s set the self-destruct timer to %2$s</string>
     <string name="MessageLifetimeChangedOutgoing">You set the self-destruct timer to %1$s</string>
@@ -289,6 +314,7 @@
     <string name="Online">online</string>
     <string name="LastSeen">last seen</string>
     <string name="LastSeenDate">last seen</string>
+    <string name="LastSeenNow">last seen just now</string>
     <string name="InviteFriends">Invite Friends</string>
     <string name="GlobalSearch">GLOBAL SEARCH</string>
     <string name="Lately">last seen recently</string>
@@ -314,13 +340,22 @@
     <string name="CopyLink">Copy Link</string>
     <string name="ShareLink">Share Link</string>
     <string name="LinkInfo">Anyone who has Telegram installed will be able to join your group by following this link.</string>
+    <!--set admins view-->
+    <string name="SetAdminsTitle">Chat Admins</string>
+    <string name="SetAdminsAll">All Members are Admins</string>
+    <string name="SetAdminsAllInfo">All members can add new members, edit name and photo of the group.</string>
+    <string name="SetAdminsNotAllInfo">Only admins can add and remove members, edit name and photo of the group.</string>
     <!--group info view-->
     <string name="SharedMedia">Shared Media</string>
     <string name="SETTINGS">Settings</string>
     <string name="AddMember">Add member</string>
+    <string name="SetAdmins">Set admins</string>
     <string name="DeleteAndExit">Delete and leave group</string>
     <string name="Notifications">Notifications</string>
     <string name="KickFromGroup">Remove from group</string>
+    <string name="ConvertGroup">Upgrade to Supergroup</string>
+    <string name="ConvertGroupAlert">Please note that group members will need to update their Telegram apps to the latest version to see your supergroup. Are you sure you want to upgrade this group?</string>
+    <string name="ConvertGroupInfo"><![CDATA[<b>]]>Members limit reached.<![CDATA[</b>]]>\n\nTo go over the limit and get additional features, upgrade to a supergroup:\n\n• Supergroups can get up to %1$s\n• New members see the entire chat history\n• Admins delete messages for everyone\n• Notifications are muted by default</string>
     <!--contact info view-->
     <string name="ShareContact">Share</string>
     <string name="AddContact">Add</string>
@@ -403,7 +438,6 @@
     <string name="TerminateAllSessions">Terminate All Other Sessions</string>
     <string name="Events">Events</string>
     <string name="ContactJoined">Contact joined Telegram</string>
-    <string name="Pebble">PEBBLE</string>
     <string name="Language">Language</string>
     <string name="AskAQuestionInfo">Please note that Telegram Support is done by volunteers. We try to respond as quickly as possible, but it may take a while.<![CDATA[<br><br>]]>Please take a look at the <![CDATA[<a href=\"https://telegram.org/faq#general\">Telegram FAQ</a>]]>: it has answers to most questions and important tips for <![CDATA[<a href=\"https://telegram.org/faq#troubleshooting\">troubleshooting</a>]]>.</string>
     <string name="AskButton">Ask a volunteer</string>
@@ -465,6 +499,24 @@
     <string name="SmartNotificationsTimes">times</string>
     <string name="SmartNotificationsWithin">within</string>
     <string name="SmartNotificationsMinutes">minutes</string>
+    <!--cache view-->
+    <string name="CacheSettings">Cache Settings</string>
+    <string name="LocalDatabase">Local Database</string>
+    <string name="LocalDatabaseClear">Clear cached text messages?</string>
+    <string name="LocalDatabaseInfo">Clearing the local database will delete the texts of cached messages and compress the database to save internal disk space. Telegram needs some data to work, so database size will not reach zero.\n\nThis operation can take a few minutes to complete.</string>
+    <string name="ClearMediaCache">Clear Cache</string>
+    <string name="CacheClear">Clear</string>
+    <string name="CalculatingSize">Calculating...</string>
+    <string name="LocalDocumentCache">Documents</string>
+    <string name="LocalPhotoCache">Photos</string>
+    <string name="LocalAudioCache">Voice messages</string>
+    <string name="LocalVideoCache">Videos</string>
+    <string name="LocalMusicCache">Music</string>
+    <string name="LocalCache">Other files</string>
+    <string name="CacheEmpty">Empty</string>
+    <string name="KeepMedia">Keep Media</string>
+    <string name="KeepMediaInfo">Photos, videos and other files from cloud chats that you have <![CDATA[<b>not accessed</b>]]> during this period will be removed from this device to save disk space.\n\nAll media will stay in the Telegram cloud and can be re-downloaded if you need it again.</string>
+    <string name="KeepMediaForever">Forever</string>
     <!--sessions view-->
     <string name="SessionsTitle">Active Sessions</string>
     <string name="CurrentSession">Current session</string>
@@ -493,11 +545,17 @@
     <string name="AutoLockInfo">Require passcode if away for a time.</string>
     <string name="AutoLockInTime">in %1$s</string>
     <string name="AutoLockDisabled">Disabled</string>
+    <string name="UnlockFingerprint">Unlock with Fingerprint</string>
+    <string name="FingerprintInfo">Confirm fingerprint to continue</string>
+    <string name="FingerprintHelp">Touch sensor</string>
+    <string name="FingerprintNotRecognized">Fingerprint not recognized. Try again</string>
     <!--media view-->
     <string name="NoMedia">Share photos and videos in this chat and access them on any of your devices.</string>
     <string name="DocumentsTitle">Shared Files</string>
     <string name="SharedMediaTitle">Shared Media</string>
     <string name="LinksTitle">Shared Links</string>
+    <string name="AudioTitle">Shared Music</string>
+    <string name="NoSharedAudio">Share music in this chat and access them on any of your devices.</string>
     <string name="NoSharedFiles">Share files and documents in this chat and access them on any of your devices.</string>
     <string name="NoSharedLinks">Share links in this chat and access them on any of your devices.</string>
     <!--map view-->
@@ -668,6 +726,7 @@
     <string name="Call">Call</string>
     <string name="Copy">Copy</string>
     <string name="Delete">Delete</string>
+    <string name="DeleteAndStop">Delete and stop</string>
     <string name="Forward">Forward</string>
     <string name="Retry">Retry</string>
     <string name="FromCamera">From camera</string>
@@ -722,12 +781,13 @@
     <string name="NoHandleAppInstalled">You don\'t have applications that can handle the file type \'%1$s\', please install one to continue</string>
     <string name="InviteUser">This user does not have Telegram yet, send an invitation?</string>
     <string name="AreYouSure">Are you sure?</string>
-    <string name="AddToTheGroupTitle">Add %1$s to the group %2$s?</string>
+    <string name="AddToTheGroupTitle">Add %1$s to the chat %2$s?</string>
     <string name="AddToTheGroupForwardCount">Number of last messages to forward:</string>
     <string name="AddToTheGroup">Add %1$s to the group?</string>
     <string name="UserAlreadyInGroup">This user is already in this group</string>
     <string name="ForwardMessagesTo">Forward messages to %1$s?</string>
     <string name="SendMessagesTo">Send messages to %1$s?</string>
+    <string name="SendContactTo">Send contact to %1$s?</string>
     <string name="AreYouSureLogout">Are you sure you want to log out?\n\nNote that you can seamlessly use Telegram on all your devices at once.\n\nRemember, logging out kills all your Secret Chats.</string>
     <string name="AreYouSureSessions">Are you sure you want to terminate all other sessions?</string>
     <string name="AreYouSureDeleteAndExit">Are you sure you want to delete and leave the group?</string>
@@ -739,12 +799,21 @@
     <string name="AreYouSureSecretChat">Are you sure you want to start a secret chat?</string>
     <string name="AreYouSureRegistration">Are you sure you want to cancel registration?</string>
     <string name="AreYouSureClearHistory">Are you sure you want to clear history?</string>
+    <string name="AreYouSureClearHistoryChannel">Delete all cached text and media from this channel?</string>
+    <string name="AreYouSureClearHistorySuper">Delete all cached text and media from this supergroup?</string>
     <string name="AreYouSureDeleteMessages">Are you sure you want to delete %1$s?</string>
     <string name="SendMessagesToGroup">Send messages to %1$s?</string>
+    <string name="SendContactToGroup">Send contact to %1$s?</string>
     <string name="ForwardMessagesToGroup">Forward messages to %1$s?</string>
     <string name="FeatureUnavailable">Sorry, this feature is currently not available in your country.</string>
     <string name="NoUsernameFound">There is no Telegram account with this username.</string>
     <string name="BotCantJoinGroups">This bot can\'t join groups.</string>
+    <!--permissions-->
+    <string name="PermissionContacts">Telegram needs access to your contacts so that you can connect with your friends across all your devices.</string>
+    <string name="PermissionStorage">Telegram needs access to your storage so that you can send and save photos, videos, music and other media.</string>
+    <string name="PermissionNoAudio">Telegram needs access to your microphone so that you can send voice messages.</string>
+    <string name="PermissionNoLocation">Telegram needs access to your location so that you can share it with your friends.</string>
+    <string name="PermissionOpenSettings">SETTINGS</string>
     <!--Intro view-->
     <string name="Page1Title">Telegram</string>
     <string name="Page2Title">Fast</string>
@@ -882,6 +951,18 @@
     <string name="Photos_few">%1$d photos</string>
     <string name="Photos_many">%1$d photos</string>
     <string name="Photos_other">%1$d photos</string>
+    <string name="LastSeenMinutes_zero">last seen %1$d minutes ago</string>
+    <string name="LastSeenMinutes_one">last seen %1$d minute ago</string>
+    <string name="LastSeenMinutes_two">last seen %1$d minutes ago</string>
+    <string name="LastSeenMinutes_few">last seen %1$d minutes ago</string>
+    <string name="LastSeenMinutes_many">last seen %1$d minutes ago</string>
+    <string name="LastSeenMinutes_other">last seen %1$d minutes ago</string>
+    <string name="LastSeenHours_zero">last seen %1$d hours ago</string>
+    <string name="LastSeenHours_one">last seen %1$d hour ago</string>
+    <string name="LastSeenHours_two">last seen %1$d hours ago</string>
+    <string name="LastSeenHours_few">last seen %1$d hours ago</string>
+    <string name="LastSeenHours_many">last seen %1$d hours ago</string>
+    <string name="LastSeenHours_other">last seen %1$d hours ago</string>
     <!--forwarded messages-->
     <string name="ForwardedMessage_zero">%1$d forwarded messages</string>
     <string name="ForwardedMessage_one">Forwarded message</string>
@@ -949,6 +1030,6 @@
     <string name="formatterDay12H">h:mm a</string>
     <string name="formatDateAtTime">%1$s at %2$s</string>
     <!--update text-->
-    <string name="updateText">Telegram for Android has been updated. New in version 3.2.0:\n\n- Introducing Channels – a great new way to broadcast your messages to unlimited audiences (replaces old Broadcasts).\n\nRead more: https://telegram.org/blog/channels</string>
-    <string name="updateBuild">614</string>
+    <string name="updateText">Telegram for Android has been updated. New in version 3.3.2:\n\n- Cache management: Control how much disk space Telegram uses on your device, delete cache for specific types of content.\n- Delete cache from supergroups and channels: Tap and hold on them in the chats list and \'Delete from Cache\'.\n- Sticker management: Manually rearrange your sticker packs. Pack order is now synced across all your devices.\n\nMore about this update:\nhttps://telegram.org/blog/cache-and-stickers</string>
+    <string name="updateBuild">693</string>
 </resources>
\ No newline at end of file
