diff --git a/TMessagesProj/build.gradle b/TMessagesProj/build.gradle
index 1fd6ee725..46631a0e1 100644
--- a/TMessagesProj/build.gradle
+++ b/TMessagesProj/build.gradle
@@ -10,12 +10,19 @@ dependencies {
     compile 'net.hockeyapp.android:HockeySDK:3.5.+'
     compile 'com.googlecode.mp4parser:isoparser:1.0.+'
     compile 'org.apache.httpcomponents:httpmime:4.2.1'
+    testCompile 'junit:junit:4.12'
+    testCompile 'org.mockito:mockito-core:1.10.19'
+
 }
 
 android {
     compileSdkVersion 22
     buildToolsVersion '23.0.1'
 
+    testOptions {
+        unitTests.returnDefaultValues = true
+    }
+
     packagingOptions {
         exclude 'META-INF/NOTICE.txt'
         exclude 'META-INF/LICENSE.txt'
diff --git a/TMessagesProj/src/test/java/org/pollgram/decision/service/MessagesManagerTest.java b/TMessagesProj/src/test/java/org/pollgram/decision/service/MessagesManagerTest.java
index 661437531..c49825248 100644
--- a/TMessagesProj/src/test/java/org/pollgram/decision/service/MessagesManagerTest.java
+++ b/TMessagesProj/src/test/java/org/pollgram/decision/service/MessagesManagerTest.java
@@ -38,26 +38,30 @@
     private Map<Long, String> receivedId2LastMessages = new HashMap<>();
     private TLRPC.Chat chat;
     private TLRPC.User user;
+    private Decision decision;
 
     @Before
-    public void setUp(){
+    public void setUp() {
         ApplicationLoader.applicationContext = mMockContext;
 
         chat = new TLRPC.Chat();
-        chat.id =39379118;
+        chat.id = 39379118;
 
         user = new TLRPC.User();
-        user.id = 22;
+        user.id = 93880097;
 
-        this.dao = new PollgramDAOTestImpl(chat.id);
+        this.dao = new PollgramDAOTestImpl(chat.id, user.id);
         messageManager = new PollgramMessagesManagerImpl(dao);
-        this.service = new PollgramServiceImpl(dao,messageManager);
+        this.service = new PollgramServiceImpl(dao, messageManager);
+
+        decision = dao.getDecisions(chat.id, null).get(0);
+
     }
 
     @Test
-    public void testMessageTypeDifferentEmoji(){
-        for (PollgramMessagesManager.MessageType mt1 : PollgramMessagesManager.MessageType.values()){
-            for (PollgramMessagesManager.MessageType mt2 : PollgramMessagesManager.MessageType.values()){
+    public void testMessageTypeDifferentEmoji() {
+        for (PollgramMessagesManager.MessageType mt1 : PollgramMessagesManager.MessageType.values()) {
+            for (PollgramMessagesManager.MessageType mt2 : PollgramMessagesManager.MessageType.values()) {
                 if (mt1.equals(mt2))
                     Assert.assertTrue(mt1.getEmoji().equals(mt2.getEmoji()));
                 else
@@ -67,42 +71,82 @@ public void testMessageTypeDifferentEmoji(){
     }
 
     @Test
-    public void testMessageTypeGetEmoji(){
-        for (PollgramMessagesManager.MessageType mt1 : PollgramMessagesManager.MessageType.values()){
+    public void testMessageTypeGetEmoji() {
+        for (PollgramMessagesManager.MessageType mt1 : PollgramMessagesManager.MessageType.values()) {
             Assert.assertEquals(mt1, PollgramMessagesManager.MessageType.byEmoji(mt1.getEmoji()));
         }
     }
 
     @Test
     public void testSendVotes() throws ParseException {
-        Decision decision = dao.getDecisions(null).get(0);
         List<Option> options = dao.getOptions(decision);
         Collection<Vote> votes = new ArrayList<>();
         Date voteDate = new Date();
-        for (int i=0; i< options.size() ; i++ ){
-            Vote v = new Vote( i % 2 == 0, voteDate, user.id, options.get(i).getId());
+        for (int i = 0; i < options.size(); i++) {
+            Vote v = new Vote(i % 2 == 0, voteDate, user.id, options.get(i).getId());
             votes.add(v);
         }
         String message = messageManager.buildNotifyVoteMessage(decision, votes);
         PollgramMessagesManager.MessageType type = messageManager.getMessageType(message);
         Assert.assertEquals(type, PollgramMessagesManager.MessageType.VOTE);
 
-        Collection<Vote> parsedVotes = messageManager.getVotes(message, chat, voteDate, user.id);
-        Assert.assertEquals(parsedVotes,votes);
+        assertVotes(votes, voteDate, message);
+        assertVotes(votes, voteDate, messageManager.reformatMessage(message));
+    }
 
-        message = messageManager.reformatMessage(message);
-        parsedVotes = messageManager.getVotes(message, chat, voteDate, user.id);
-        Assert.assertEquals(parsedVotes,votes);
+    private void assertVotes(Collection<Vote> votes, Date voteDate, String message) {
+        Collection<Vote> parsedVotes = messageManager.getVotes(message, chat, voteDate, user.id);
+        Assert.assertEquals(parsedVotes, votes);
     }
 
     @Test
     public void testSendRemind() throws ParseException {
-        Decision decision = dao.getDecisions(null).get(0);
-
         String message = messageManager.buildRemindMessage("UserName String", decision);
         PollgramMessagesManager.MessageType type = messageManager.getMessageType(message);
         Assert.assertEquals(type, PollgramMessagesManager.MessageType.REMIND_TO_VOTE);
     }
 
+    @Test
+    public void testNewDecision() throws ParseException {
+        List<Option> options = dao.getOptions(decision);
+        String message = messageManager.buildNotifyNewDecision(decision, options);
+
+        PollgramMessagesManager.MessageType type = messageManager.getMessageType(message);
+        Assert.assertEquals(type, PollgramMessagesManager.MessageType.NEW_DECISION);
+
+        assertNewDecision(decision, options, message);
+        assertNewDecision(decision, options, messageManager.reformatMessage(message));
+
+    }
+
+    private void assertNewDecision(Decision decision, List<Option> options, String message) {
+        PollgramMessagesManager.NewDecisionData result = messageManager.getNewDecision(message, chat, user.id);
+        Assert.assertEquals(decision, result.decision);
+        Assert.assertEquals(options, result.optionList);
+    }
+
+    @Test
+    public void testCloseDecision() {
+        Option winningOption = dao.getOptions(decision).get(0);
+        int voteCount = 5;
+        String message = messageManager.buildCloseDecision(decision, winningOption, voteCount);
+        Assert.assertEquals(messageManager.getMessageType(message), PollgramMessagesManager.MessageType.CLOSE_DECISION);
+
+        assertCloseDecision(decision, winningOption, message);
+        assertCloseDecision(decision, winningOption, messageManager.reformatMessage(message));
+    }
+
+    private void assertCloseDecision(Decision decision, Option winningOption, String message) {
+        PollgramMessagesManager.ClosedDecisionDate result = messageManager.getCloseDecision(message, chat);
+        Assert.assertEquals(decision, result.decision);
+        Assert.assertEquals(winningOption, result.winningOption);
+    }
+
+    @Test
+    public void testReopenDecision() {
+        String message = messageManager.buildReopenDecision(decision);
+
+
+    }
 
 }
\ No newline at end of file
diff --git a/TMessagesProj/src/test/java/org/pollgram/decision/service/PollgramDAOTestImpl.java b/TMessagesProj/src/test/java/org/pollgram/decision/service/PollgramDAOTestImpl.java
index 046708626..1900580b7 100644
--- a/TMessagesProj/src/test/java/org/pollgram/decision/service/PollgramDAOTestImpl.java
+++ b/TMessagesProj/src/test/java/org/pollgram/decision/service/PollgramDAOTestImpl.java
@@ -1,7 +1,204 @@
 package org.pollgram.decision.service;
 
+import android.support.annotation.Nullable;
+
+import org.pollgram.decision.data.DBBean;
+import org.pollgram.decision.data.Decision;
+import org.pollgram.decision.data.Option;
+import org.pollgram.decision.data.TextOption;
+import org.pollgram.decision.data.Vote;
+import org.telegram.messenger.MessagesController;
+import org.telegram.tgnet.TLRPC;
+
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
 /**
  * Created by davide on 21/11/15.
  */
-public class PollgramDAOTestImpl {
+public class PollgramDAOTestImpl implements PollgramDAO {
+
+    private static final String LOG_TAG = "DecisionDAOImpl";
+
+    // TODO remove stub field
+    private final List<Decision> decisions = new ArrayList<>();
+    private final List<Option> textOptions = new ArrayList<>();
+    private final List<Vote> votes = new ArrayList<>();
+
+    PollgramDAOTestImpl(int chatId, long creatorId){
+        long id = 1;
+        /// just for test
+
+        decisions.add(new Decision(id++,chatId, creatorId,"what present do we buy ?", id+"huge bla bla bla" ,true));
+        decisions.add(new Decision(id++, chatId, creatorId, "Where do we go ?", id + "huge bla bla bla", true));
+        decisions.add(new Decision(id++, chatId, creatorId, "When will the party be ?", id + "huge bla bla bla", true));
+        decisions.add(new Decision(id++, chatId, creatorId, "Do we add Slomp to the group ?", id + "huge bla bla bla", false));
+
+        textOptions.add(new TextOption(id++, "Ski", "They cost 385EUR i saw them at the corner shop", decisions.get(0).getId()));
+        textOptions.add(new TextOption(id++, "Phone", "The new StonexOne is AWESOME !!!", decisions.get(0).getId()));
+        textOptions.add(new TextOption(id++, "Trip", "Yeah a trip trought Europe can be a nice idea", decisions.get(0).getId()));
+        textOptions.add(new TextOption(id++, "A stupid idea", "it is late and i have no more ideas ;-/", decisions.get(0).getId()));
+
+    }
+
+    @Override
+    public Decision save(Decision d) {
+        Decision foundDecision = getDecision(d.getTitle(),d.getChatId());
+        return save(d, foundDecision, decisions);
+    }
+
+    private<T extends DBBean> T save(T d, T found, List<T> list) {
+        if (found == null)
+            list.add(d);
+        else {
+            d.setId(found.getId());
+            list.set(list.indexOf(found), d);
+        }
+        return d;
+    }
+
+
+    @Override
+    public Decision getDecision(long decisionId) {
+        for (Decision d : decisions){
+            if (d.getId() == decisionId)
+                return d;
+        }
+        return null;
+    }
+
+    @Override
+    public List<Decision> getDecisions(int chatId, @Nullable Boolean open) {
+        List<Decision> outList = new ArrayList<>();
+        for(Decision d : decisions)
+            if (open == null || d.isOpen() == open.booleanValue())
+                outList.add(d);
+        return outList;
+    }
+
+    @Override
+    public Option getOption(long optionId) {
+        for (Option o : textOptions)
+            if (o.getId() == optionId)
+                return o;
+        return null;
+    }
+
+    @Override
+    public List<Option> getOptions(Decision decision) {
+        return  getOptions(decision.getId());
+
+    }
+
+    @Override
+    public List<Option> getOptions(long decisionId) {
+        if (decisionId == decisions.get(0).getId())
+            return textOptions;
+        else
+            return new ArrayList<>();
+    }
+
+    private Vote getVote(int userId, Option option) {
+        // TODO so stub
+        long stubId = option.getId()*17;
+        Boolean voteValue = option.getId()%2 ==0 ? true : (option.getId()%3 ==0 ? null : false);
+        return new Vote(stubId, voteValue, new Date(), userId, option.getId());
+    }
+
+
+    public List<TLRPC.User> getUsers(int[] usersIds) {
+        List<TLRPC.User> users = new ArrayList<>();
+        for (int i = 0 ; i< usersIds.length ; i++){
+            users.add(MessagesController.getInstance().getUser(usersIds[i]));
+        }
+        return users;
+    }
+
+    @Override
+    public List<Vote> getUserVoteForDecision(long decisionId, int userId) {
+        List<Vote> votes = new ArrayList<>();
+        for (Option c : getOptions(decisionId)) {
+            votes.add(getVote(userId,c));
+        }
+        return votes;
+    }
+
+    @Override
+    public List<Vote> getVotes(long decisionId, @Nullable Integer userId) {
+        return null;
+    }
+
+    @Override
+    public Option save(Option o) {
+        Option found = getOption(o.getTitle(), getDecision(o.getDecisionId()));
+        return save(o, found, textOptions);
+    }
+
+    @Override
+    public Vote save(Vote vote) {
+        {
+            Vote newVote = getVote(vote.getOptionId(), vote.getUserId());
+            if (newVote == null) {
+                votes.add(vote);
+                vote.setId(votes.size());
+                return vote;
+            }
+        }
+        for (int i = 0; i < votes.size(); i++) {
+            if (vote.getOptionId() == votes.get(i).getOptionId() &&
+                    vote.getUserId() == votes.get(i).getUserId()) ;
+            votes.get(i).setVoteTime(vote.getVoteTime());
+            votes.get(i).setVote(vote.isVote());
+            return votes.get(i);
+        }
+        return vote;
+    }
+
+    @Override
+    public Decision getDecision(String decisionTitle, int chatId) {
+        for (Decision d : decisions){
+            if (d.getTitle().equals(decisionTitle) && d.getChatId() == chatId)
+                return d;
+        }
+        return null;
+    }
+
+    @Override
+    public Option getOption(String optionTitle, Decision decision) {
+        for (Option o : textOptions){
+            if (o.getTitle().equals(optionTitle) &&  o.getDecisionId() == decision.getId())
+                return  o;
+        }
+        return null;
+    }
+
+    @Override
+    public Vote getVote(long optionId, int userId) {
+        for (Vote v : votes){
+            if (v.getOptionId() == optionId && v.getUserId() == userId)
+                return  v;
+        }
+        return null;
+    }
+
+    @Override
+    public void purgeData() {
+
+    }
+
+    @Override
+    public void putStubData(int chatId, int creatorId) {
+
+    }
+
+    @Override
+    public int getUserVoteCount(Decision decision) {
+        return 0;
+    }
+
+    @Override
+    public WinningOption getWinningOption(Decision decision) {
+        return null;
+    }
 }
